[
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "translateTemplate(template, keystrokesByCommand)",
        "start_line": "227",
        "end_line": "253",
        "file_path": "src/main-process/application-menu.js",
        "docstring": "The function translates a menu template by iterating through each item, initializing metadata if missing, and processing commands.\\nFor each command, it retrieves associated keystrokes and assigns the first keystroke to the item's label if it includes a space, or to its accelerator otherwise.\\nA click event is set to send the command via the global atomApplication, and the item is marked as window-specific if the command does not start with \"application:\".\\nIf the item has a submenu, the function recursively processes it.\\nFinally, the modified template is returned.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a6e254b7b855",
        "ground_truth": "translateTemplate(template, keystrokesByCommand) {\n  template.forEach(item => {\n    if (item.metadata == null) item.metadata = {};\n    if (item.command) {\n      const keystrokes = keystrokesByCommand[item.command];\n      if (keystrokes && keystrokes.length > 0) {\n        const keystroke = keystrokes[0];\n        // Electron does not support multi-keystroke accelerators. Therefore,\n        // when the command maps to a multi-stroke key binding, show the\n        // keystrokes next to the item's label.\n        if (keystroke.includes(' ')) {\n          item.label += ` [${_.humanizeKeystroke(keystroke)}]`;\n        } else {\n          item.accelerator = MenuHelpers.acceleratorForKeystroke(keystroke);\n        }\n      }\n      item.click = () =>\n        global.atomApplication.sendCommand(item.command, item.commandDetail);\n      if (!/^application:/.test(item.command)) {\n        item.metadata.windowSpecific = true;\n      }\n    }\n    if (item.submenu)\n      this.translateTemplate(item.submenu, keystrokesByCommand);\n  });\n  return template;\n}",
        "import_statements": [],
        "reference_api": [
            "global.atomApplication.sendCommand"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "global.atomApplication.sendCommand"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "flattenMenuItems(menu)",
        "start_line": "69",
        "end_line": "79",
        "file_path": "src/main-process/application-menu.js",
        "docstring": "The function flattenMenuItems(menu) takes a menu object and recursively flattens its items into a single array.\\nIt initializes an empty array to store the items and iterates over the menu's items, adding each item to the array.\\nIf an item has a submenu, the function calls itself recursively to flatten the submenu items and concatenate them to the main array.\\nFinally, the function returns the flattened array of menu items.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c4ff073b485f",
        "ground_truth": "flattenMenuItems(menu) {\n  const object = menu.items || {};\n  let items = [];\n  for (let index in object) {\n    const item = object[index];\n    items.push(item);\n    if (item.submenu)\n      items = items.concat(this.flattenMenuItems(item.submenu));\n  }\n  return items;\n}",
        "import_statements": [],
        "reference_api": [
            "items.concat",
            "items.push",
            "flattenMenuItems",
            "this.flattenMenuItems"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "flattenMenuItems",
                "code": "flattenMenuItems(menu) {\n    const object = menu.items || {};\n    let items = [];\n    for (let index in object) {\n      const item = object[index];\n      items.push(item);\n      if (item.submenu)\n        items = items.concat(this.flattenMenuItems(item.submenu));\n    }\n    return items;\n  }"
            },
            {
                "name": "this.flattenMenuItems",
                "code": "flattenMenuItems(menu) {\n    const object = menu.items || {};\n    let items = [];\n    for (let index in object) {\n      const item = object[index];\n      items.push(item);\n      if (item.submenu)\n        items = items.concat(this.flattenMenuItems(item.submenu));\n    }\n    return items;\n  }"
            }
        ],
        "third_party": [
            "items.concat",
            "items.push"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "const encryptOptions = (options, secret) =>",
        "start_line": "103",
        "end_line": "118",
        "file_path": "src/main-process/atom-application.js",
        "docstring": "The function encryptOptions(options, secret) converts the options object to a JSON string and creates a 16-byte initialization vector.\\nIt then creates an AES-256-GCM cipher using the provided secret and the initialization vector.\\nThe function encrypts the JSON string, concatenates the encrypted content, and retrieves the authentication tag.\\nFinally, it returns a JSON string containing the authentication tag, encrypted content, and the initialization vector in hexadecimal format.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dba487230999",
        "ground_truth": "const encryptOptions = (options, secret) => {\n  const message = JSON.stringify(options);\n  const initVector = crypto.randomBytes(16); // AES uses 16 bytes for iV\n  const cipher = crypto.createCipheriv('aes-256-gcm', secret, initVector);\n   let content = cipher.update(message, 'utf8', 'hex');\n  content += cipher.final('hex');\n   const authTag = cipher.getAuthTag().toString('hex');\n   return JSON.stringify({\n    authTag,\n    content,\n    initVector: initVector.toString('hex')\n  });\n};",
        "import_statements": [],
        "reference_api": [
            "initVector.toString",
            "JSON.stringify",
            "cipher.update",
            "cipher.final",
            "crypto.createCipheriv",
            "cipher.getAuthTag().toString",
            "cipher.getAuthTag",
            "crypto.randomBytes"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "initVector.toString",
            "cipher.update",
            "cipher.final",
            "crypto.createCipheriv",
            "cipher.getAuthTag().toString",
            "cipher.getAuthTag",
            "crypto.randomBytes"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "createClickHandlers(template)",
        "start_line": "14",
        "end_line": "30",
        "file_path": "src/main-process/context-menu.js",
        "docstring": "The function createClickHandlers(template) processes a menu template by iterating through each item.\\nFor items with a command, it ensures the commandDetail property exists and sets a contextCommand flag to true.\\nIt assigns a click event handler that sends the command to a specific window using global atomApplication.\\nIf an item has a submenu instead of a command, the function recursively processes the submenu items.\\n",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7efe3d7cee0f",
        "ground_truth": "createClickHandlers(template) {\n  template.forEach(item => {\n    if (item.command) {\n      if (!item.commandDetail) item.commandDetail = {};\n      item.commandDetail.contextCommand = true;\n      item.click = () => {\n        global.atomApplication.sendCommandToWindow(\n          item.command,\n          this.atomWindow,\n          item.commandDetail\n        );\n      };\n    } else if (item.submenu) {\n      this.createClickHandlers(item.submenu);\n    }\n  });\n}",
        "import_statements": [],
        "reference_api": [
            "global.atomApplication.sendCommandToWindow"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "global.atomApplication.sendCommandToWindow"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "async didSavePath(window, path)",
        "start_line": "50",
        "end_line": "66",
        "file_path": "src/main-process/file-recovery-service.js",
        "docstring": "The async function didSavePath(window, path) manages the release of a recovery file associated with a given path.\\nIt retrieves the recovery file from a map and attempts to release it.\\nIf the release is successful or if an error occurs during the release, it logs the error details.\\nIf the file is released, it removes the file from several maps that track recovery files by file path, window, and recovery file.\\nThis function ensures proper cleanup of recovery files after a file is saved.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "851df56cc3b9",
        "ground_truth": "async didSavePath(window, path) {\n  const recoveryFile = this.recoveryFilesByFilePath.get(path);\n  if (recoveryFile != null) {\n    try {\n      await recoveryFile.release();\n    } catch (err) {\n      console.log(\n        `Couldn't release ${recoveryFile.recoveryPath}. Code: ${\n          err.code\n        }. Message: ${err.message}`\n      );\n    }\n    if (recoveryFile.isReleased()) this.recoveryFilesByFilePath.delete(path);\n    this.recoveryFilesByWindow.get(window).delete(recoveryFile);\n    this.windowsByRecoveryFile.get(recoveryFile).delete(window);\n  }\n}",
        "import_statements": [],
        "reference_api": [
            "console.log",
            "this.windowsByRecoveryFile.get(recoveryFile).delete",
            "this.recoveryFilesByFilePath.get",
            "this.recoveryFilesByWindow.get",
            "recoveryFile.isReleased",
            "this.recoveryFilesByFilePath.delete",
            "this.windowsByRecoveryFile.get",
            "this.recoveryFilesByWindow.get(window).delete",
            "async",
            "recoveryFile.release"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "recoveryFile.isReleased",
                "code": "isReleased() {\n    return this.refCount === 0;\n  }"
            },
            {
                "name": "recoveryFile.release",
                "code": "async release() {\n    this.refCount--;\n    if (this.isReleased()) await this.remove();\n  }"
            }
        ],
        "third_party": [
            "this.windowsByRecoveryFile.get(recoveryFile).delete",
            "this.recoveryFilesByFilePath.get",
            "this.recoveryFilesByWindow.get",
            "this.recoveryFilesByFilePath.delete",
            "this.windowsByRecoveryFile.get",
            "this.recoveryFilesByWindow.get(window).delete",
            "async"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "async didCrashWindow(window)",
        "start_line": "68",
        "end_line": "104",
        "file_path": "src/main-process/file-recovery-service.js",
        "docstring": "The async function didCrashWindow(window) handles the recovery process when a window crashes.\\nIf there are recovery files associated with the window, it iterates over them and attempts to recover each file.\\nIf a recovery attempt fails, it logs an error message and shows a dialog with details about the corrupted file and the location of the recovery file.\\nAfter attempting recovery, it cleans up by removing the recovery file from various tracking maps and deletes its references.\\nThe function ensures that all recovery attempts are awaited and handled appropriately.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "37d777933a87",
        "ground_truth": "async didCrashWindow(window) {\n  if (!this.recoveryFilesByWindow.has(window)) return;\n  const promises = [];\n  for (const recoveryFile of this.recoveryFilesByWindow.get(window)) {\n    promises.push(\n      recoveryFile\n        .recover()\n        .catch(error => {\n          const message = 'A file that Atom was saving could be corrupted';\n          const detail =\n            `Error ${error.code}. There was a crash while saving \"${\n              recoveryFile.originalPath\n            }\", so this file might be blank or corrupted.\\n` +\n            `Atom couldn't recover it automatically, but a recovery file has been saved at: \"${\n              recoveryFile.recoveryPath\n            }\".`;\n          console.log(detail);\n          dialog.showMessageBox(window, {\n            type: 'info',\n            buttons: ['OK'],\n            message,\n            detail\n          });\n        })\n        .then(() => {\n          for (let window of this.windowsByRecoveryFile.get(recoveryFile)) {\n            this.recoveryFilesByWindow.get(window).delete(recoveryFile);\n          }\n          this.windowsByRecoveryFile.delete(recoveryFile);\n          this.recoveryFilesByFilePath.delete(recoveryFile.originalPath);\n        })\n    );\n  }\n  await Promise.all(promises);\n}",
        "import_statements": [],
        "reference_api": [
            "console.log",
            "this.windowsByRecoveryFile.delete",
            "this.recoveryFilesByWindow.get",
            "recoveryFile\n          .recover",
            "promises.push",
            "recoveryFile\n          .recover()\n          .catch",
            "this.windowsByRecoveryFile.get",
            "this.recoveryFilesByWindow.get(window).delete",
            "this.recoveryFilesByFilePath.delete",
            "this.recoveryFilesByWindow.has",
            "async",
            "Promise.all",
            "dialog.showMessageBox",
            "recoveryFile\n          .recover()\n          .catch(error => {\n            const message = 'A file that Atom was saving could be corrupted';\n            const detail =\n              `Error ${error.code}. There was a crash while saving \"${\n                recoveryFile.originalPath\n              }\", so this file might be blank or corrupted.\\n` +\n              `Atom couldn't recover it automatically, but a recovery file has been saved at: \"${\n                recoveryFile.recoveryPath\n              }\".`;\n            console.log(detail);\n            dialog.showMessageBox(window, {\n              type: 'info',\n              buttons: ['OK'],\n              message,\n              detail\n            });\n          })\n          .then"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "recoveryFile\n          .recover",
                "code": "async recover() {\n    await copyFile(this.recoveryPath, this.originalPath, this.fileMode);\n    await this.remove();\n  }"
            }
        ],
        "third_party": [
            "this.windowsByRecoveryFile.delete",
            "this.recoveryFilesByWindow.get",
            "promises.push",
            "recoveryFile\n          .recover()\n          .catch",
            "this.windowsByRecoveryFile.get",
            "this.recoveryFilesByWindow.get(window).delete",
            "this.recoveryFilesByFilePath.delete",
            "this.recoveryFilesByWindow.has",
            "async",
            "dialog.showMessageBox",
            "recoveryFile\n          .recover()\n          .catch(error => {\n            const message = 'A file that Atom was saving could be corrupted';\n            const detail =\n              `Error ${error.code}. There was a crash while saving \"${\n                recoveryFile.originalPath\n              }\", so this file might be blank or corrupted.\\n` +\n              `Atom couldn't recover it automatically, but a recovery file has been saved at: \"${\n                recoveryFile.recoveryPath\n              }\".`;\n            console.log(detail);\n            dialog.showMessageBox(window, {\n              type: 'info',\n              buttons: ['OK'],\n              message,\n              detail\n            });\n          })\n          .then"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "async function copyFile(source, destination, mode)",
        "start_line": "169",
        "end_line": "183",
        "file_path": "src/main-process/file-recovery-service.js",
        "docstring": "The async function copyFile(source, destination, mode) copies a file from the source path to the destination path with the specified mode.\\nIt returns a Promise that creates the destination directory if it doesn't exist, then sets up a read stream from the source file and a write stream to the destination file.\\nIf any errors occur during these operations, the Promise is rejected.\\nThe read stream is piped to the write stream, and once the writing is complete, the Promise is resolved.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "935916bc7ea0",
        "ground_truth": "async function copyFile(source, destination, mode) {\n  return new Promise((resolve, reject) => {\n    mkdirp(Path.dirname(destination), error => {\n      if (error) return reject(error);\n      const readStream = fs.createReadStream(source);\n      readStream.on('error', reject).once('open', () => {\n        const writeStream = fs.createWriteStream(destination, { mode });\n        writeStream\n          .on('error', reject)\n          .on('open', () => readStream.pipe(writeStream))\n          .once('close', () => resolve());\n      });\n    });\n  });\n}",
        "import_statements": [],
        "reference_api": [
            "readStream.on('error', reject).once",
            "writeStream\n          .on('error', reject)\n          .on",
            "mkdirp",
            "writeStream\n          .on('error', reject)\n          .on('open', () => readStream.pipe(writeStream))\n          .once",
            "readStream.on",
            "resolve",
            "fs.createWriteStream",
            "reject",
            "writeStream\n          .on",
            "fs.createReadStream",
            "Path.dirname",
            "readStream.pipe"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "readStream.on('error', reject).once",
            "writeStream\n          .on('error', reject)\n          .on",
            "mkdirp",
            "writeStream\n          .on('error', reject)\n          .on('open', () => readStream.pipe(writeStream))\n          .once",
            "readStream.on",
            "resolve",
            "fs.createWriteStream",
            "reject",
            "writeStream\n          .on",
            "fs.createReadStream",
            "Path.dirname",
            "readStream.pipe"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "function handleStartupEventWithSquirrel()",
        "start_line": "134",
        "end_line": "142",
        "file_path": "src/main-process/start.js",
        "docstring": "The function handleStartupEventWithSquirrel() handles startup events for Squirrel on Windows.\\nIt first checks if the platform is Windows, returning false if it is not.\\nIf it is Windows, it requires the SquirrelUpdate module and retrieves the Squirrel command from the process arguments.\\nIt then passes this command to the handleStartupEvent method of SquirrelUpdate and returns its result.\\nThis function ensures that Squirrel startup events are only processed on Windows platforms.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5410353afedd",
        "ground_truth": "function handleStartupEventWithSquirrel() {\n  if (process.platform !== 'win32') {\n    return false;\n  }\n   const SquirrelUpdate = require('./squirrel-update');\n  const squirrelCommand = process.argv[1];\n  return SquirrelUpdate.handleStartupEvent(squirrelCommand);\n}",
        "import_statements": [],
        "reference_api": [
            "require",
            "SquirrelUpdate.handleStartupEvent"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "require",
            "SquirrelUpdate.handleStartupEvent"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "function normalizeDriveLetterName(filePath)",
        "start_line": "162",
        "end_line": "171",
        "file_path": "src/main-process/start.js",
        "docstring": "The function normalizeDriveLetterName(filePath) normalizes the drive letter of a file path to uppercase on Windows platforms.\\nIf the platform is Windows and the filePath is defined, it replaces the lowercase drive letter at the beginning of the path with its uppercase counterpart.\\nIf the platform is not Windows, it returns the filePath unchanged.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5fb2d4f077cb",
        "ground_truth": "function normalizeDriveLetterName(filePath) {\n  if (process.platform === 'win32' && filePath) {\n    return filePath.replace(\n      /^([a-z]):/,\n      ([driveLetter]) => driveLetter.toUpperCase() + ':'\n    );\n  } else {\n    return filePath;\n  }\n}",
        "import_statements": [],
        "reference_api": [
            "driveLetter.toUpperCase",
            "filePath.replace"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "driveLetter.toUpperCase",
            "filePath.replace"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "register(callback)",
        "start_line": "35",
        "end_line": "48",
        "file_path": "src/main-process/win-shell.js",
        "docstring": "The register(callback) function initializes a registry for each part in the parts array.\\nIt sets a registry key in the HKCU hive, combining a base key with a part-specific key if available.\\nThe function creates the registry key and sets its value.\\nAfter all parts are processed, the provided callback function is called.\\nThe callback is triggered once all registry entries have been successfully set.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e61a087ae10f",
        "ground_truth": "register(callback) {\n  let doneCount = this.parts.length;\n  this.parts.forEach(part => {\n    let reg = new Registry({\n      hive: 'HKCU',\n      key: part.key != null ? `${this.key}\\\\${part.key}` : this.key\n    });\n    return reg.create(() =>\n      reg.set(part.name, Registry.REG_SZ, part.value, () => {\n        if (--doneCount === 0) return callback();\n      })\n    );\n  });\n}",
        "import_statements": [],
        "reference_api": [
            "reg.create",
            "reg.set",
            "callback",
            "this.parts.forEach",
            "register"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "register",
                "code": "register(callback) {\n    let doneCount = this.parts.length;\n    this.parts.forEach(part => {\n      let reg = new Registry({\n        hive: 'HKCU',\n        key: part.key != null ? `${this.key}\\\\${part.key}` : this.key\n      });\n      return reg.create(() =>\n        reg.set(part.name, Registry.REG_SZ, part.value, () => {\n          if (--doneCount === 0) return callback();\n        })\n      );\n    });\n  }"
            }
        ],
        "third_party": [
            "reg.create",
            "reg.set",
            "callback",
            "this.parts.forEach"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "showSaveDialog(options, callback)",
        "start_line": "271",
        "end_line": "282",
        "file_path": "src/application-delegate.js",
        "docstring": "The function showSaveDialog(options, callback) handles displaying a save dialog in both asynchronous and synchronous manners.\\nIf a callback function is provided, it calls showSaveDialog on the current window asynchronously with the given options and callback.\\nIf no callback is provided, it checks if the options parameter is a string and converts it to an object with defaultPath.\\nIt then calls showSaveDialog on the current window synchronously with the options and returns the result.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "35b1a1ac391a",
        "ground_truth": "showSaveDialog(options, callback) {\n  if (typeof callback === 'function') {\n    // Async\n    this.getCurrentWindow().showSaveDialog(options, callback);\n  } else {\n    // Sync\n    if (typeof options === 'string') {\n      options = { defaultPath: options };\n    }\n    return this.getCurrentWindow().showSaveDialog(options);\n  }\n}",
        "import_statements": [],
        "reference_api": [
            "showSaveDialog",
            "this.getCurrentWindow().showSaveDialog",
            "this.getCurrentWindow"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "showSaveDialog",
                "code": "showSaveDialog(options, callback) {\n    if (typeof callback === 'function') {\n      // Async\n      this.getCurrentWindow().showSaveDialog(options, callback);\n    } else {\n      // Sync\n      if (typeof options === 'string') {\n        options = { defaultPath: options };\n      }\n      return this.getCurrentWindow().showSaveDialog(options);\n    }\n  }"
            },
            {
                "name": "this.getCurrentWindow().showSaveDialog",
                "code": "showSaveDialog(options, callback) {\n    if (typeof callback === 'function') {\n      // Async\n      this.getCurrentWindow().showSaveDialog(options, callback);\n    } else {\n      // Sync\n      if (typeof options === 'string') {\n        options = { defaultPath: options };\n      }\n      return this.getCurrentWindow().showSaveDialog(options);\n    }\n  }"
            },
            {
                "name": "this.getCurrentWindow",
                "code": "getCurrentWindow() {\n    return remote.getCurrentWindow();\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "async restoreWindowDimensions()",
        "start_line": "843",
        "end_line": "852",
        "file_path": "src/atom-environment.js",
        "docstring": "The async function restoreWindowDimensions() ensures that window dimensions are valid.\\nIt checks if the current window dimensions are set and valid.\\nIf not, it assigns default window dimensions.\\nIt then sets the window dimensions and returns the dimensions.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a7e394aca19e",
        "ground_truth": "async restoreWindowDimensions() {\n  if (\n    !this.windowDimensions ||\n    !this.isValidDimensions(this.windowDimensions)\n  ) {\n    this.windowDimensions = this.getDefaultWindowDimensions();\n  }\n  await this.setWindowDimensions(this.windowDimensions);\n  return this.windowDimensions;\n}",
        "import_statements": [],
        "reference_api": [
            "this.isValidDimensions",
            "this.getDefaultWindowDimensions",
            "this.setWindowDimensions"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.isValidDimensions",
                "code": "isValidDimensions({ x, y, width, height } = {}) {\n    return width > 0 && height > 0 && x + width > 0 && y + height > 0;\n  }"
            },
            {
                "name": "this.getDefaultWindowDimensions",
                "code": "getDefaultWindowDimensions() {\n    const { windowDimensions } = this.getLoadSettings();\n    if (windowDimensions) return windowDimensions;\n\n    let dimensions;\n    try {\n      dimensions = JSON.parse(localStorage.getItem('defaultWindowDimensions'));\n    } catch (error) {\n      console.warn('Error parsing default window dimensions', error);\n      localStorage.removeItem('defaultWindowDimensions');\n    }\n\n    if (dimensions && this.isValidDimensions(dimensions)) {\n      return dimensions;\n    } else {\n      const {\n        width,\n        height\n      } = this.applicationDelegate.getPrimaryDisplayWorkAreaSize();\n      return { x: 0, y: 0, width: Math.min(1024, width), height };\n    }\n  }"
            },
            {
                "name": "this.setWindowDimensions",
                "code": "setWindowDimensions({ x, y, width, height }) {\n    const steps = [];\n    if (width != null && height != null) {\n      steps.push(this.setSize(width, height));\n    }\n    if (x != null && y != null) {\n      steps.push(this.setPosition(x, y));\n    } else {\n      steps.push(this.center());\n    }\n    return Promise.all(steps);\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "installShellCommandsInteractively()",
        "start_line": "21",
        "end_line": "45",
        "file_path": "src/command-installer.js",
        "docstring": "The function installShellCommandsInteractively() installs shell commands for the application.\\nIt defines a helper function to display an error dialog if installation fails.\\nFirst, it attempts to install the Atom command interactively.\\nIf successful, it then attempts to install the APM command.\\nIf both commands are installed successfully, it shows a confirmation dialog indicating the commands were installed.\\nIf any installation fails, it shows an error dialog with the failure details.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c39fbfaa6502",
        "ground_truth": "installShellCommandsInteractively() {\n  const showErrorDialog = error => {\n    this.applicationDelegate.confirm(\n      {\n        message: 'Failed to install shell commands',\n        detail: error.message\n      },\n      () => {}\n    );\n  };\n  this.installAtomCommand(true, (error, atomCommandName) => {\n    if (error) return showErrorDialog(error);\n    this.installApmCommand(true, (error, apmCommandName) => {\n      if (error) return showErrorDialog(error);\n      this.applicationDelegate.confirm(\n        {\n          message: 'Commands installed.',\n          detail: `The shell commands \\`${atomCommandName}\\` and \\`${apmCommandName}\\` are installed.`\n        },\n        () => {}\n      );\n    });\n  });\n}",
        "import_statements": [],
        "reference_api": [
            "this.applicationDelegate.confirm"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.applicationDelegate.confirm"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "installCommand(commandPath, commandName, askForPrivilege, callback)",
        "start_line": "86",
        "end_line": "105",
        "file_path": "src/command-installer.js",
        "docstring": "The function installCommand(commandPath, commandName, askForPrivilege, callback) installs a command on macOS by creating a symlink at the destination path.\\nIt first checks if the platform is macOS and proceeds only if true.\\nIt constructs the destination path and attempts to read the symlink at that location.\\nIf the symlink points to the correct path or doesn't exist, it creates a new symlink.\\nIf permission is denied and privilege escalation is allowed, it uses elevated privileges to create the symlink.\\nFinally, it calls the callback function with the appropriate error or success status.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "09d527496128",
        "ground_truth": "installCommand(commandPath, commandName, askForPrivilege, callback) {\n  if (process.platform !== 'darwin') return callback();\n  const destinationPath = path.join(this.getInstallDirectory(), commandName);\n  fs.readlink(destinationPath, (error, realpath) => {\n    if (error && error.code !== 'ENOENT') return callback(error);\n    if (realpath === commandPath) return callback(null, commandName);\n    this.createSymlink(fs, commandPath, destinationPath, error => {\n      if (error && error.code === 'EACCES' && askForPrivilege) {\n        const fsAdmin = require('fs-admin');\n        this.createSymlink(fsAdmin, commandPath, destinationPath, error => {\n          callback(error, commandName);\n        });\n      } else {\n        callback(error);\n      }\n    });\n  });\n}",
        "import_statements": [],
        "reference_api": [
            "this.getInstallDirectory",
            "this.createSymlink",
            "fs.readlink",
            "installCommand",
            "require",
            "callback",
            "path.join"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.getInstallDirectory",
                "code": "getInstallDirectory() {\n    return '/usr/local/bin';\n  }"
            },
            {
                "name": "this.createSymlink",
                "code": "createSymlink(fs, sourcePath, destinationPath, callback) {\n    fs.unlink(destinationPath, error => {\n      if (error && error.code !== 'ENOENT') return callback(error);\n      fs.makeTree(path.dirname(destinationPath), error => {\n        if (error) return callback(error);\n        fs.symlink(sourcePath, destinationPath, callback);\n      });\n    });\n  }"
            },
            {
                "name": "installCommand",
                "code": "installCommand(commandPath, commandName, askForPrivilege, callback) {\n    if (process.platform !== 'darwin') return callback();\n\n    const destinationPath = path.join(this.getInstallDirectory(), commandName);\n\n    fs.readlink(destinationPath, (error, realpath) => {\n      if (error && error.code !== 'ENOENT') return callback(error);\n      if (realpath === commandPath) return callback(null, commandName);\n      this.createSymlink(fs, commandPath, destinationPath, error => {\n        if (error && error.code === 'EACCES' && askForPrivilege) {\n          const fsAdmin = require('fs-admin');\n          this.createSymlink(fsAdmin, commandPath, destinationPath, error => {\n            callback(error, commandName);\n          });\n        } else {\n          callback(error);\n        }\n      });\n    });\n  }"
            }
        ],
        "third_party": [
            "fs.readlink",
            "require",
            "callback",
            "path.join"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "moveUp(rowCount = 1, { moveToEndOfSelection } = {})",
        "start_line": "253",
        "end_line": "268",
        "file_path": "src/cursor.js",
        "docstring": "The function moveUp(rowCount = 1, { moveToEndOfSelection } = {}) moves the cursor up by a specified number of rows.\\nIt determines the new cursor position based on whether the moveToEndOfSelection option is set and the selection range.\\nIf the goalColumn is defined, it uses that column for the new position.\\nThe function then sets the new screen position, adjusting the row by subtracting the rowCount and optionally skips soft wrap indentation.\\nFinally, it updates the goalColumn to the current column.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4807d5d43396",
        "ground_truth": "moveUp(rowCount = 1, { moveToEndOfSelection } = {}) {\n  let row, column;\n  const range = this.marker.getScreenRange();\n  if (moveToEndOfSelection && !range.isEmpty()) {\n    ({ row, column } = range.start);\n  } else {\n    ({ row, column } = this.getScreenPosition());\n  }\n  if (this.goalColumn != null) column = this.goalColumn;\n  this.setScreenPosition(\n    { row: row - rowCount, column },\n    { skipSoftWrapIndentation: true }\n  );\n  this.goalColumn = column;\n}",
        "import_statements": [],
        "reference_api": [
            "moveUp",
            "range.isEmpty",
            "this.getScreenPosition",
            "this.setScreenPosition",
            "this.marker.getScreenRange"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "moveUp",
                "code": "moveUp(rowCount = 1, { moveToEndOfSelection } = {}) {\n    let row, column;\n    const range = this.marker.getScreenRange();\n    if (moveToEndOfSelection && !range.isEmpty()) {\n      ({ row, column } = range.start);\n    } else {\n      ({ row, column } = this.getScreenPosition());\n    }\n\n    if (this.goalColumn != null) column = this.goalColumn;\n    this.setScreenPosition(\n      { row: row - rowCount, column },\n      { skipSoftWrapIndentation: true }\n    );\n    this.goalColumn = column;\n  }"
            },
            {
                "name": "this.getScreenPosition",
                "code": "getScreenPosition() {\n    return this.marker.getHeadScreenPosition();\n  }"
            },
            {
                "name": "this.setScreenPosition",
                "code": "setScreenPosition(screenPosition, options = {}) {\n    this.changePosition(options, () => {\n      this.marker.setHeadScreenPosition(screenPosition, options);\n    });\n  }"
            },
            {
                "name": "this.marker.getScreenRange",
                "code": "getScreenRange() {\n    const { row, column } = this.getScreenPosition();\n    return new Range(new Point(row, column), new Point(row, column + 1));\n  }"
            }
        ],
        "third_party": [
            "range.isEmpty"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "decorationsForScreenRowRange(startScreenRow, endScreenRow)",
        "start_line": "144",
        "end_line": "157",
        "file_path": "src/decoration-manager.js",
        "docstring": "The function decorationsForScreenRowRange(startScreenRow, endScreenRow) collects decorations for markers within a specified screen row range.\\nIt initializes an empty object to store decorations by marker ID.\\nIt iterates over decoration layers and finds markers that intersect the given screen row range.\\nFor each marker, it retrieves the associated decorations and stores them in the object using the marker's ID as the key.\\nFinally, it returns the object containing decorations mapped by marker ID.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a18da78a3351",
        "ground_truth": "decorationsForScreenRowRange(startScreenRow, endScreenRow) {\n  const decorationsByMarkerId = {};\n  for (const layer of this.decorationCountsByLayer.keys()) {\n    for (const marker of layer.findMarkers({\n      intersectsScreenRowRange: [startScreenRow, endScreenRow]\n    })) {\n      const decorations = this.decorationsByMarker.get(marker);\n      if (decorations) {\n        decorationsByMarkerId[marker.id] = Array.from(decorations);\n      }\n    }\n  }\n  return decorationsByMarkerId;\n}",
        "import_statements": [],
        "reference_api": [
            "Array.from",
            "this.decorationsByMarker.get",
            "this.decorationCountsByLayer.keys",
            "layer.findMarkers",
            "decorationsForScreenRowRange"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "decorationsForScreenRowRange",
                "code": "decorationsForScreenRowRange(startScreenRow, endScreenRow) {\n    const decorationsByMarkerId = {};\n    for (const layer of this.decorationCountsByLayer.keys()) {\n      for (const marker of layer.findMarkers({\n        intersectsScreenRowRange: [startScreenRow, endScreenRow]\n      })) {\n        const decorations = this.decorationsByMarker.get(marker);\n        if (decorations) {\n          decorationsByMarkerId[marker.id] = Array.from(decorations);\n        }\n      }\n    }\n    return decorationsByMarkerId;\n  }"
            }
        ],
        "third_party": [
            "this.decorationsByMarker.get",
            "this.decorationCountsByLayer.keys",
            "layer.findMarkers"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "decorateMarkerLayer(markerLayer, decorationParams)",
        "start_line": "240",
        "end_line": "255",
        "file_path": "src/decoration-manager.js",
        "docstring": "The function decorateMarkerLayer(markerLayer, decorationParams) decorates a marker layer with given parameters.\\nIt checks if the marker layer is destroyed and throws an error if so.\\nIt retrieves the marker layer from the display layer and creates a new LayerDecoration object.\\nIt then manages a set of decorations for the marker layer, adding the new decoration.\\nThe function observes the decorated layer, triggers an update event for decorations, and returns the created decoration.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "950f6b74f379",
        "ground_truth": "decorateMarkerLayer(markerLayer, decorationParams) {\n  if (markerLayer.isDestroyed()) {\n    throw new Error('Cannot decorate a destroyed marker layer');\n  }\n  markerLayer = this.displayLayer.getMarkerLayer(markerLayer.id);\n  const decoration = new LayerDecoration(markerLayer, this, decorationParams);\n  let layerDecorations = this.layerDecorationsByMarkerLayer.get(markerLayer);\n  if (layerDecorations == null) {\n    layerDecorations = new Set();\n    this.layerDecorationsByMarkerLayer.set(markerLayer, layerDecorations);\n  }\n  layerDecorations.add(decoration);\n  this.observeDecoratedLayer(markerLayer, false);\n  this.emitDidUpdateDecorations();\n  return decoration;\n}",
        "import_statements": [],
        "reference_api": [
            "layerDecorations.add",
            "this.emitDidUpdateDecorations",
            "this.layerDecorationsByMarkerLayer.set",
            "decorateMarkerLayer",
            "markerLayer.isDestroyed",
            "this.displayLayer.getMarkerLayer",
            "this.layerDecorationsByMarkerLayer.get",
            "this.observeDecoratedLayer"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.emitDidUpdateDecorations",
                "code": "emitDidUpdateDecorations() {\n    this.editor.scheduleComponentUpdate();\n    this.emitter.emit('did-update-decorations');\n  }"
            },
            {
                "name": "decorateMarkerLayer",
                "code": "decorateMarkerLayer(markerLayer, decorationParams) {\n    if (markerLayer.isDestroyed()) {\n      throw new Error('Cannot decorate a destroyed marker layer');\n    }\n    markerLayer = this.displayLayer.getMarkerLayer(markerLayer.id);\n    const decoration = new LayerDecoration(markerLayer, this, decorationParams);\n    let layerDecorations = this.layerDecorationsByMarkerLayer.get(markerLayer);\n    if (layerDecorations == null) {\n      layerDecorations = new Set();\n      this.layerDecorationsByMarkerLayer.set(markerLayer, layerDecorations);\n    }\n    layerDecorations.add(decoration);\n    this.observeDecoratedLayer(markerLayer, false);\n    this.emitDidUpdateDecorations();\n    return decoration;\n  }"
            },
            {
                "name": "this.observeDecoratedLayer",
                "code": "observeDecoratedLayer(layer, isMarkerDecoration) {\n    const newCount = (this.decorationCountsByLayer.get(layer) || 0) + 1;\n    this.decorationCountsByLayer.set(layer, newCount);\n    if (newCount === 1) {\n      this.layerUpdateDisposablesByLayer.set(\n        layer,\n        layer.onDidUpdate(this.emitDidUpdateDecorations.bind(this))\n      );\n    }\n    if (isMarkerDecoration) {\n      this.markerDecorationCountsByLayer.set(\n        layer,\n        (this.markerDecorationCountsByLayer.get(layer) || 0) + 1\n      );\n    }\n  }"
            }
        ],
        "third_party": [
            "layerDecorations.add",
            "this.layerDecorationsByMarkerLayer.set",
            "markerLayer.isDestroyed",
            "this.displayLayer.getMarkerLayer",
            "this.layerDecorationsByMarkerLayer.get"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "observeDecoratedLayer(layer, isMarkerDecoration)",
        "start_line": "297",
        "end_line": "312",
        "file_path": "src/decoration-manager.js",
        "docstring": "The function observeDecoratedLayer(layer, isMarkerDecoration) tracks the decoration counts for a given layer.\\nIt increments the count of decorations for the layer and stores it in a map.\\nIf this is the first decoration for the layer, it sets up an event listener for updates to the layer and stores the disposable in another map.\\nIf the decoration is a marker decoration, it also increments and stores the count of marker decorations for the layer in a separate map.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ab015a5cc75d",
        "ground_truth": "observeDecoratedLayer(layer, isMarkerDecoration) {\n  const newCount = (this.decorationCountsByLayer.get(layer) || 0) + 1;\n  this.decorationCountsByLayer.set(layer, newCount);\n  if (newCount === 1) {\n    this.layerUpdateDisposablesByLayer.set(\n      layer,\n      layer.onDidUpdate(this.emitDidUpdateDecorations.bind(this))\n    );\n  }\n  if (isMarkerDecoration) {\n    this.markerDecorationCountsByLayer.set(\n      layer,\n      (this.markerDecorationCountsByLayer.get(layer) || 0) + 1\n    );\n  }\n}",
        "import_statements": [],
        "reference_api": [
            "this.markerDecorationCountsByLayer.set",
            "this.decorationCountsByLayer.get",
            "this.decorationCountsByLayer.set",
            "this.markerDecorationCountsByLayer.get",
            "this.emitDidUpdateDecorations.bind",
            "this.layerUpdateDisposablesByLayer.set",
            "layer.onDidUpdate",
            "observeDecoratedLayer"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.emitDidUpdateDecorations.bind",
                "code": "emitDidUpdateDecorations() {\n    this.editor.scheduleComponentUpdate();\n    this.emitter.emit('did-update-decorations');\n  }"
            },
            {
                "name": "observeDecoratedLayer",
                "code": "observeDecoratedLayer(layer, isMarkerDecoration) {\n    const newCount = (this.decorationCountsByLayer.get(layer) || 0) + 1;\n    this.decorationCountsByLayer.set(layer, newCount);\n    if (newCount === 1) {\n      this.layerUpdateDisposablesByLayer.set(\n        layer,\n        layer.onDidUpdate(this.emitDidUpdateDecorations.bind(this))\n      );\n    }\n    if (isMarkerDecoration) {\n      this.markerDecorationCountsByLayer.set(\n        layer,\n        (this.markerDecorationCountsByLayer.get(layer) || 0) + 1\n      );\n    }\n  }"
            }
        ],
        "third_party": [
            "this.markerDecorationCountsByLayer.set",
            "this.decorationCountsByLayer.get",
            "this.decorationCountsByLayer.set",
            "this.markerDecorationCountsByLayer.get",
            "this.layerUpdateDisposablesByLayer.set",
            "layer.onDidUpdate"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "finishLoading()",
        "start_line": "114",
        "end_line": "124",
        "file_path": "src/package.js",
        "docstring": "The function finishLoading() measures the load time of several operations.\\nIt updates the path by joining it with the package manager's resource path and adds it to the ModuleCache with its metadata.\\nIt then loads the required stylesheets and retrieves the main module path.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9d7f091a1b67",
        "ground_truth": "finishLoading() {\n  this.measure('loadTime', () => {\n    this.path = path.join(this.packageManager.resourcePath, this.path);\n    ModuleCache.add(this.path, this.metadata);\n    this.loadStylesheets();\n    // Unfortunately some packages are accessing `@mainModulePath`, so we need\n    // to compute that variable eagerly also for preloaded packages.\n    this.getMainModulePath();\n  });\n}",
        "import_statements": [],
        "reference_api": [
            "this.getMainModulePath",
            "ModuleCache.add",
            "this.loadStylesheets",
            "finishLoading",
            "this.measure",
            "path.join"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.getMainModulePath",
                "code": "getMainModulePath() {\n    if (this.resolvedMainModulePath) return this.mainModulePath;\n    this.resolvedMainModulePath = true;\n\n    if (this.bundledPackage && this.packageManager.packagesCache[this.name]) {\n      if (this.packageManager.packagesCache[this.name].main) {\n        this.mainModulePath = path.resolve(\n          this.packageManager.resourcePath,\n          'static',\n          this.packageManager.packagesCache[this.name].main\n        );\n      } else {\n        this.mainModulePath = null;\n      }\n    } else {\n      const mainModulePath = this.metadata.main\n        ? path.join(this.path, this.metadata.main)\n        : path.join(this.path, 'index');\n      this.mainModulePath = fs.resolveExtension(mainModulePath, [\n        '',\n        ...CompileCache.supportedExtensions\n      ]);\n    }\n    return this.mainModulePath;\n  }"
            },
            {
                "name": "this.loadStylesheets",
                "code": "loadStylesheets() {\n    this.stylesheets = this.getStylesheetPaths().map(stylesheetPath => [\n      stylesheetPath,\n      this.themeManager.loadStylesheet(stylesheetPath, true)\n    ]);\n  }"
            },
            {
                "name": "finishLoading",
                "code": "finishLoading() {\n    this.measure('loadTime', () => {\n      this.path = path.join(this.packageManager.resourcePath, this.path);\n      ModuleCache.add(this.path, this.metadata);\n\n      this.loadStylesheets();\n      // Unfortunately some packages are accessing `@mainModulePath`, so we need\n      // to compute that variable eagerly also for preloaded packages.\n      this.getMainModulePath();\n    });\n  }"
            },
            {
                "name": "this.measure",
                "code": "measure(key, fn) {\n    const startTime = window.performance.now();\n    const value = fn();\n    this[key] = Math.round(window.performance.now() - startTime);\n    return value;\n  }"
            }
        ],
        "third_party": [
            "ModuleCache.add",
            "path.join"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "atom/atom",
        "function_declaration": "dblclickHandler()",
        "start_line": "23",
        "end_line": "42",
        "file_path": "src/title-bar.js",
        "docstring": "The function dblclickHandler() manages the action taken when the title bar is double-clicked based on user preferences.\\nIt retrieves the user preference for the double-click action using applicationDelegate.getUserDefault().\\nIf the preference is \"Minimize\", it minimizes the window.\\nIf the preference is \"Maximize\", it toggles between maximizing and unmaximizing the window depending on its current state.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a06630788868",
        "ground_truth": "dblclickHandler() {\n  // User preference deciding which action to take on a title bar double-click\n  switch (\n    this.applicationDelegate.getUserDefault(\n      'AppleActionOnDoubleClick',\n      'string'\n    )\n  ) {\n    case 'Minimize':\n      this.applicationDelegate.minimizeWindow();\n      break;\n    case 'Maximize':\n      if (this.applicationDelegate.isWindowMaximized()) {\n        this.applicationDelegate.unmaximizeWindow();\n      } else {\n        this.applicationDelegate.maximizeWindow();\n      }\n      break;\n  }\n}",
        "import_statements": [],
        "reference_api": [
            "this.applicationDelegate.unmaximizeWindow",
            "this.applicationDelegate.minimizeWindow",
            "this.applicationDelegate.isWindowMaximized",
            "this.applicationDelegate.getUserDefault",
            "dblclickHandler",
            "this.applicationDelegate.maximizeWindow"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "dblclickHandler",
                "code": "dblclickHandler() {\n    // User preference deciding which action to take on a title bar double-click\n    switch (\n      this.applicationDelegate.getUserDefault(\n        'AppleActionOnDoubleClick',\n        'string'\n      )\n    ) {\n      case 'Minimize':\n        this.applicationDelegate.minimizeWindow();\n        break;\n      case 'Maximize':\n        if (this.applicationDelegate.isWindowMaximized()) {\n          this.applicationDelegate.unmaximizeWindow();\n        } else {\n          this.applicationDelegate.maximizeWindow();\n        }\n        break;\n    }\n  }"
            }
        ],
        "third_party": [
            "this.applicationDelegate.unmaximizeWindow",
            "this.applicationDelegate.minimizeWindow",
            "this.applicationDelegate.isWindowMaximized",
            "this.applicationDelegate.getUserDefault",
            "this.applicationDelegate.maximizeWindow"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "marktext/marktext",
        "function_declaration": "_openSettingsWindow (category)",
        "start_line": "408",
        "end_line": "422",
        "file_path": "src/main/app/index.js",
        "docstring": "The function _openSettingsWindow(category) manages the opening of a settings window.\\nIt first checks if there are any existing settings windows.\\nIf a settings window exists, it sends a message to change the tab to the specified category and either focuses or moves the window to the top, depending on the operating system.\\nIf no settings window exists, it creates a new one with the specified category.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fd29bc5fd921",
        "ground_truth": "_openSettingsWindow (category) {\n  const settingWins = this._windowManager.getWindowsByType(WindowType.SETTINGS)\n  if (settingWins.length >= 1) {\n    // A setting window is already created\n    const browserSettingWindow = settingWins[0].win.browserWindow\n    browserSettingWindow.webContents.send('settings::change-tab', category)\n    if (isLinux) {\n      browserSettingWindow.focus()\n    } else {\n      browserSettingWindow.moveTop()\n    }\n    return\n  }\n  this._createSettingWindow(category)\n}",
        "import_statements": [
            "path",
            "fs/promises",
            "child_process",
            "dayjs",
            "electron-log",
            "electron",
            "common/filesystem/paths",
            "../config",
            "../cli/parser",
            "../filesystem",
            "../filesystem/markdown",
            "../keyboard",
            "../menu/actions/theme",
            "../menu/templates",
            "../spellchecker",
            "../utils/imagePathAutoComplement",
            "../windows/base",
            "../windows/editor",
            "../windows/setting"
        ],
        "reference_api": [
            "_openSettingsWindow",
            "browserSettingWindow.moveTop",
            "this._windowManager.getWindowsByType",
            "browserSettingWindow.webContents.send",
            "this._createSettingWindow",
            "browserSettingWindow.focus"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_openSettingsWindow",
                "code": "_openSettingsWindow (category) {\n    const settingWins = this._windowManager.getWindowsByType(WindowType.SETTINGS)\n    if (settingWins.length >= 1) {\n      // A setting window is already created\n      const browserSettingWindow = settingWins[0].win.browserWindow\n      browserSettingWindow.webContents.send('settings::change-tab', category)\n      if (isLinux) {\n        browserSettingWindow.focus()\n      } else {\n        browserSettingWindow.moveTop()\n      }\n      return\n    }\n    this._createSettingWindow(category)\n  }"
            },
            {
                "name": "this._createSettingWindow",
                "code": "_createSettingWindow (category) {\n    const setting = new SettingWindow(this._accessor)\n    setting.createWindow(category)\n    this._windowManager.add(setting)\n    if (this._windowManager.windowCount === 1) {\n      this._accessor.menu.setActiveWindow(setting.id)\n    }\n  }"
            }
        ],
        "third_party": [
            "browserSettingWindow.moveTop",
            "this._windowManager.getWindowsByType",
            "browserSettingWindow.webContents.send",
            "browserSettingWindow.focus"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "marktext/marktext",
        "function_declaration": "findBestWindowToOpenIn (fileList)",
        "start_line": "228",
        "end_line": "277",
        "file_path": "src/main/app/windowManager.js",
        "docstring": "The function findBestWindowToOpenIn(fileList) determines the best editor window to open a list of files.\\nIt returns an empty array if the file list is invalid.\\nIt retrieves the last active editor ID and checks the number of open windows.\\nIf there is one or fewer windows, it returns the last active editor ID with the file list.\\nIt then calculates scores for each file across all editor windows, selecting the best window for each file based on these scores.\\nFiles already opened are skipped, and files with no best window are assigned to the last active editor.\\nThe function returns an array of objects, each containing a window ID and the associated file list.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b9c797e2b719",
        "ground_truth": "findBestWindowToOpenIn (fileList) {\n  if (!fileList || !Array.isArray(fileList) || !fileList.length) return []\n  const { windows } = this\n  const lastActiveEditorId = this.getActiveEditorId() // editor id or null\n  if (this.windowCount <= 1) {\n    return [{ windowId: lastActiveEditorId, fileList }]\n  }\n  // Array of scores, same order like fileList.\n  let filePathScores = null\n  for (const window of windows.values()) {\n    if (window.type === WindowType.EDITOR) {\n      const scores = window.getCandidateScores(fileList)\n      if (!filePathScores) {\n        filePathScores = scores\n      } else {\n        const len = filePathScores.length\n        for (let i = 0; i < len; ++i) {\n          // Update score only if the file is not already opened.\n          if (filePathScores[i].score !== -1 && filePathScores[i].score < scores[i].score) {\n            filePathScores[i] = scores[i]\n          }\n        }\n      }\n    }\n  }\n  const buf = []\n  const len = filePathScores.length\n  for (let i = 0; i < len; ++i) {\n    let { id: windowId, score } = filePathScores[i]\n    if (score === -1) {\n      // Skip files that already opened.\n      continue\n    } else if (score === 0) {\n      // There is no best window to open the file(s) in.\n      windowId = lastActiveEditorId\n    }\n    let item = buf.find(w => w.windowId === windowId)\n    if (!item) {\n      item = { windowId, fileList: [] }\n      buf.push(item)\n    }\n    item.fileList.push(fileList[i])\n  }\n  return buf\n}",
        "import_statements": [
            "electron",
            "events",
            "electron-log",
            "../filesystem/watcher",
            "../windows/base"
        ],
        "reference_api": [
            "window.getCandidateScores",
            "buf.push",
            "this.getActiveEditorId",
            "windows.values",
            "buf.find",
            "Array.isArray",
            "item.fileList.push",
            "findBestWindowToOpenIn"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.getActiveEditorId",
                "code": "getActiveEditorId () {\n    const win = this.getActiveEditor()\n    return win ? win.id : null\n  }"
            },
            {
                "name": "windows.values",
                "code": "get windows () {\n    return this._windows\n  }"
            },
            {
                "name": "findBestWindowToOpenIn",
                "code": "findBestWindowToOpenIn (fileList) {\n    if (!fileList || !Array.isArray(fileList) || !fileList.length) return []\n    const { windows } = this\n    const lastActiveEditorId = this.getActiveEditorId() // editor id or null\n\n    if (this.windowCount <= 1) {\n      return [{ windowId: lastActiveEditorId, fileList }]\n    }\n\n    // Array of scores, same order like fileList.\n    let filePathScores = null\n    for (const window of windows.values()) {\n      if (window.type === WindowType.EDITOR) {\n        const scores = window.getCandidateScores(fileList)\n        if (!filePathScores) {\n          filePathScores = scores\n        } else {\n          const len = filePathScores.length\n          for (let i = 0; i < len; ++i) {\n            // Update score only if the file is not already opened.\n            if (filePathScores[i].score !== -1 && filePathScores[i].score < scores[i].score) {\n              filePathScores[i] = scores[i]\n            }\n          }\n        }\n      }\n    }\n\n    const buf = []\n    const len = filePathScores.length\n    for (let i = 0; i < len; ++i) {\n      let { id: windowId, score } = filePathScores[i]\n\n      if (score === -1) {\n        // Skip files that already opened.\n        continue\n      } else if (score === 0) {\n        // There is no best window to open the file(s) in.\n        windowId = lastActiveEditorId\n      }\n\n      let item = buf.find(w => w.windowId === windowId)\n      if (!item) {\n        item = { windowId, fileList: [] }\n        buf.push(item)\n      }\n      item.fileList.push(fileList[i])\n    }\n    return buf\n  }"
            }
        ],
        "third_party": [
            "window.getCandidateScores",
            "buf.push",
            "buf.find",
            "item.fileList.push"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "marktext/marktext",
        "function_declaration": "export const guessEncoding = (buffer, autoGuessEncoding) =>",
        "start_line": "40",
        "end_line": "74",
        "file_path": "src/main/filesystem/encoding.js",
        "docstring": "The function guessEncoding(buffer, autoGuessEncoding) determines the encoding of a given buffer.\\nIt initializes the encoding as 'utf8' and a flag isBom as false.\\nIt first checks for BOM encodings by iterating through predefined BOM encoding sequences.\\nIf a BOM encoding is detected, it returns the encoding and sets isBom to true.\\nIf autoGuessEncoding is enabled, it guesses the encoding using the ced function and adjusts it based on a predefined map or by formatting it to lowercase.\\nFinally, it returns the determined encoding and the isBom flag.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bcd3eb76bbac",
        "ground_truth": "export const guessEncoding = (buffer, autoGuessEncoding) => {\n  let isBom = false\n  let encoding = 'utf8'\n   // Detect UTF8- and UTF16-BOM encodings.\n  for (const [key, value] of Object.entries(BOM_ENCODINGS)) {\n    if (checkSequence(buffer, value)) {\n      return { encoding: key, isBom: true }\n    }\n  }\n   // // Try to detect binary files. Text files should not containt four 0x00 characters.\n  // let zeroSeenCounter = 0\n  // for (let i = 0; i < Math.min(buffer.byteLength, 256); ++i) {\n  //   if (buffer[i] === 0x00) {\n  //     if (zeroSeenCounter >= 3) {\n  //       return { encoding: 'binary', isBom: false }\n  //     }\n  //     zeroSeenCounter++\n  //   } else {\n  //     zeroSeenCounter = 0\n  //   }\n  // }\n   // Auto guess encoding, otherwise use UTF8.\n  if (autoGuessEncoding) {\n    encoding = ced(buffer)\n    if (CED_ICONV_ENCODINGS[encoding]) {\n      encoding = CED_ICONV_ENCODINGS[encoding]\n    } else {\n      encoding = encoding.toLowerCase().replace(/-_/g, '')\n    }\n  }\n  return { encoding, isBom }\n}",
        "import_statements": [
            "ced"
        ],
        "reference_api": [
            "Object.entries",
            "encoding.toLowerCase",
            "encoding.toLowerCase().replace",
            "checkSequence",
            "ced"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "encoding.toLowerCase",
            "encoding.toLowerCase().replace",
            "checkSequence",
            "ced"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "marktext/marktext",
        "function_declaration": "export const writeMarkdownFile = (pathname, content, options) =>",
        "start_line": "55",
        "end_line": "68",
        "file_path": "src/main/filesystem/markdown.js",
        "docstring": "The function writeMarkdownFile(pathname, content, options) writes content to a markdown file with specified options.\\nIt extracts line ending and encoding options, defaulting the file extension to '.md' if not provided.\\nIf line endings need adjustment, it converts them accordingly.\\nThe content is then encoded into a buffer using the specified encoding and BOM setting.\\nFinally, it writes the buffer to the file at the given pathname.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a2525337ad24",
        "ground_truth": "export const writeMarkdownFile = (pathname, content, options) => {\n  const { adjustLineEndingOnSave, lineEnding } = options\n  const { encoding, isBom } = options.encoding\n  const extension = path.extname(pathname) || '.md'\n   if (adjustLineEndingOnSave) {\n    content = convertLineEndings(content, lineEnding)\n  }\n   const buffer = iconv.encode(content, encoding, { addBOM: isBom })\n   // TODO(@fxha): \"safeSaveDocuments\" using temporary file and rename syscall.\n  return writeFile(pathname, buffer, extension, undefined)\n}",
        "import_statements": [
            "fs/promises",
            "path",
            "electron-log",
            "iconv-lite",
            "../config",
            "common/filesystem",
            "common/filesystem/paths",
            "../filesystem",
            "./encoding"
        ],
        "reference_api": [
            "iconv.encode",
            "convertLineEndings",
            "writeFile",
            "path.extname"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "iconv.encode",
            "convertLineEndings",
            "writeFile",
            "path.extname"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "marktext/marktext",
        "function_declaration": "export const registerKeyboardListeners = () =>",
        "start_line": "60",
        "end_line": "76",
        "file_path": "src/main/keyboard/index.js",
        "docstring": "The function registerKeyboardListeners() sets up IPC handlers for keyboard-related events.\\nIt handles requests to retrieve keyboard information and sends this data back to the renderer process.\\nIt also listens for requests to dump keyboard information to a file, writing the information to a temporary JSON file and attempting to open it.\\nErrors during the file write process are logged.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1c01cc82b2d4",
        "ground_truth": "export const registerKeyboardListeners = () => {\n  ipcMain.handle('mt::keybinding-get-keyboard-info', async () => {\n    return getKeyboardInfo()\n  })\n  ipcMain.on('mt::keybinding-debug-dump-keyboard-info', async () => {\n    const dumpPath = path.join(os.tmpdir(), 'marktext_keyboard_info.json')\n    const content = JSON.stringify(getKeyboardInfo(), null, 2)\n    fsPromises.writeFile(dumpPath, content, 'utf8')\n      .then(() => {\n        console.log(`Keyboard information written to \"${dumpPath}\".`)\n        shell.openPath(dumpPath)\n      })\n      .catch(error => {\n        log.error('Error dumping keyboard information:', error)\n      })\n  })\n}",
        "import_statements": [
            "electron",
            "electron-log",
            "events",
            "fs/promises",
            "native-keymap",
            "os",
            "path"
        ],
        "reference_api": [
            "fsPromises.writeFile(dumpPath, content, 'utf8')\n      .then(() => {\n        console.log(`Keyboard information written to \"${dumpPath}\".`)\n        shell.openPath(dumpPath)\n      })\n      .catch",
            "console.log",
            "JSON.stringify",
            "os.tmpdir",
            "shell.openPath",
            "fsPromises.writeFile",
            "ipcMain.handle",
            "getKeyboardInfo",
            "fsPromises.writeFile(dumpPath, content, 'utf8')\n      .then",
            "ipcMain.on",
            "log.error",
            "path.join"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "fsPromises.writeFile(dumpPath, content, 'utf8')\n      .then(() => {\n        console.log(`Keyboard information written to \"${dumpPath}\".`)\n        shell.openPath(dumpPath)\n      })\n      .catch",
            "os.tmpdir",
            "shell.openPath",
            "fsPromises.writeFile",
            "ipcMain.handle",
            "getKeyboardInfo",
            "fsPromises.writeFile(dumpPath, content, 'utf8')\n      .then",
            "ipcMain.on",
            "log.error",
            "path.join"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "marktext/marktext",
        "function_declaration": "_prepareKeyMapper ()",
        "start_line": "118",
        "end_line": "130",
        "file_path": "src/main/keyboard/shortcutHandler.js",
        "docstring": "The function _prepareKeyMapper() updates the key mapper to accommodate non-US keyboards.\\nIt retrieves keyboard information and sets the keyboard layout and keymap using electronLocalshortcut.\\nIt also adds a listener to notify the key mapper when the keyboard layout changes, logging the change in debug mode if enabled, and updates the layout and keymap accordingly.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fa0bb388c99d",
        "ground_truth": "_prepareKeyMapper () {\n  // Update the key mapper to prevent problems on non-US keyboards.\n  const { layout, keymap } = getKeyboardInfo()\n  electronLocalshortcut.setKeyboardLayout(layout, keymap)\n  // Notify key mapper when the keyboard layout was changed.\n  keyboardLayoutMonitor.addListener(({ layout, keymap }) => {\n    if (global.MARKTEXT_DEBUG && process.env.MARKTEXT_DEBUG_KEYBOARD) {\n      console.log('[DEBUG] Keyboard layout changed:\\n', layout)\n    }\n    electronLocalshortcut.setKeyboardLayout(layout, keymap)\n  })\n}",
        "import_statements": [
            "electron",
            "fs",
            "fs/promises",
            "path",
            "electron-log",
            "@hfelix/electron-localshortcut",
            "common/filesystem",
            "common/keybinding",
            "../config",
            "../keyboard",
            "./keybindingsDarwin",
            "./keybindingsLinux",
            "./keybindingsWindows"
        ],
        "reference_api": [
            "console.log",
            "electronLocalshortcut.setKeyboardLayout",
            "keyboardLayoutMonitor.addListener",
            "_prepareKeyMapper",
            "getKeyboardInfo"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_prepareKeyMapper",
                "code": "_prepareKeyMapper () {\n    // Update the key mapper to prevent problems on non-US keyboards.\n    const { layout, keymap } = getKeyboardInfo()\n    electronLocalshortcut.setKeyboardLayout(layout, keymap)\n\n    // Notify key mapper when the keyboard layout was changed.\n    keyboardLayoutMonitor.addListener(({ layout, keymap }) => {\n      if (global.MARKTEXT_DEBUG && process.env.MARKTEXT_DEBUG_KEYBOARD) {\n        console.log('[DEBUG] Keyboard layout changed:\\n', layout)\n      }\n      electronLocalshortcut.setKeyboardLayout(layout, keymap)\n    })\n  }"
            }
        ],
        "third_party": [
            "electronLocalshortcut.setKeyboardLayout",
            "keyboardLayoutMonitor.addListener",
            "getKeyboardInfo"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "agalwood/Motrix",
        "function_declaration": "fixSystemConfig ()",
        "start_line": "146",
        "end_line": "165",
        "file_path": "src/main/core/ConfigManager.js",
        "docstring": "The function fixSystemConfig() performs several tasks to update and correct the system configuration.\\nIt removes any unrecognized options from the aria2c configuration.\\nIt then checks the user proxy configuration and, if enabled and properly set, updates the system configuration with the proxy server and bypass settings.\\nFinally, it addresses the 'spawn ENAMETOOLONG' issue on Windows by reducing the tracker string length and updating the corresponding system configuration.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0438f43329c9",
        "ground_truth": "fixSystemConfig () {\n  // Remove aria2c unrecognized options\n  const { others } = separateConfig(this.systemConfig.store)\n  if (others && Object.keys(others).length > 0) {\n    Object.keys(others).forEach(key => {\n      this.systemConfig.delete(key)\n    })\n  }\n  const proxy = this.getUserConfig('proxy', { enable: false })\n  const { enable, server, bypass, scope = [] } = proxy\n  if (enable && server && scope.includes(PROXY_SCOPES.DOWNLOAD)) {\n    this.setSystemConfig('all-proxy', server)\n    this.setSystemConfig('no-proxy', bypass)\n  }\n  // Fix spawn ENAMETOOLONG on Windows\n  const tracker = reduceTrackerString(this.systemConfig.get('bt-tracker'))\n  this.setSystemConfig('bt-tracker', tracker)\n}",
        "import_statements": [
            "electron",
            "electron-is",
            "electron-store",
            "../utils/index",
            "@shared/constants",
            "@shared/ua",
            "@shared/utils",
            "@shared/utils/tracker"
        ],
        "reference_api": [
            "this.setSystemConfig",
            "this.systemConfig.get",
            "Object.keys(others).forEach",
            "this.systemConfig.delete",
            "scope.includes",
            "this.getUserConfig",
            "separateConfig",
            "reduceTrackerString",
            "Object.keys",
            "fixSystemConfig"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.setSystemConfig",
                "code": "setSystemConfig (...args) {\n    this.systemConfig.set(...args)\n  }"
            },
            {
                "name": "this.getUserConfig",
                "code": "getUserConfig (key, defaultValue) {\n    if (typeof key === 'undefined' &&\n        typeof defaultValue === 'undefined') {\n      return this.userConfig.store\n    }\n\n    return this.userConfig.get(key, defaultValue)\n  }"
            },
            {
                "name": "fixSystemConfig",
                "code": "fixSystemConfig () {\n    // Remove aria2c unrecognized options\n    const { others } = separateConfig(this.systemConfig.store)\n    if (others && Object.keys(others).length > 0) {\n      Object.keys(others).forEach(key => {\n        this.systemConfig.delete(key)\n      })\n    }\n\n    const proxy = this.getUserConfig('proxy', { enable: false })\n    const { enable, server, bypass, scope = [] } = proxy\n    if (enable && server && scope.includes(PROXY_SCOPES.DOWNLOAD)) {\n      this.setSystemConfig('all-proxy', server)\n      this.setSystemConfig('no-proxy', bypass)\n    }\n\n    // Fix spawn ENAMETOOLONG on Windows\n    const tracker = reduceTrackerString(this.systemConfig.get('bt-tracker'))\n    this.setSystemConfig('bt-tracker', tracker)\n  }"
            }
        ],
        "third_party": [
            "this.systemConfig.get",
            "Object.keys(others).forEach",
            "this.systemConfig.delete",
            "scope.includes",
            "separateConfig",
            "reduceTrackerString"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "agalwood/Motrix",
        "function_declaration": "closeClient ()",
        "start_line": "86",
        "end_line": "98",
        "file_path": "src/main/core/UPnPManager.js",
        "docstring": "The function closeClient() checks if a client exists and attempts to close it.\\nIf the client exists, it tries to destroy the client and sets it to null upon successful destruction.\\nIf an error occurs during this process, it logs a warning message indicating the failure to close the UPnP client.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6d6fef58cde3",
        "ground_truth": "closeClient () {\n  if (!client) {\n    return\n  }\n  try {\n    client.destroy(() => {\n      client = null\n    })\n  } catch (err) {\n    logger.warn('[Motrix] close UPnP client fail', err)\n  }\n}",
        "import_statements": [
            "@motrix/nat-api",
            "./Logger"
        ],
        "reference_api": [
            "logger.warn",
            "closeClient",
            "client.destroy"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "closeClient",
                "code": "closeClient () {\n    if (!client) {\n      return\n    }\n\n    try {\n      client.destroy(() => {\n        client = null\n      })\n    } catch (err) {\n      logger.warn('[Motrix] close UPnP client fail', err)\n    }\n  }"
            }
        ],
        "third_party": [
            "logger.warn",
            "client.destroy"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "agalwood/Motrix",
        "function_declaration": "getTouchBarByPage (page)",
        "start_line": "91",
        "end_line": "103",
        "file_path": "src/main/ui/TouchBarManager.js",
        "docstring": "The function getTouchBarByPage(page) retrieves or creates a TouchBar for a given page.\\nIt first checks if the TouchBar for the specified page already exists in the bars collection.\\nIf not, it attempts to build a new TouchBar using a template and assigns it to the page.\\nIf an error occurs during this process, it logs the failure.\\nFinally, it returns the TouchBar for the specified page.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b32ad6f9757b",
        "ground_truth": "getTouchBarByPage (page) {\n  let bar = this.bars[page] || null\n  if (!bar) {\n    try {\n      const items = this.build(this.template)\n      bar = new TouchBar({ items })\n      this.bars[page] = bar\n    } catch (e) {\n      logger.info('getTouchBarByPage fail', e)\n    }\n  }\n  return bar\n}",
        "import_statements": [
            "node:events",
            "node:path",
            "electron",
            "../utils/menu",
            "../core/Logger"
        ],
        "reference_api": [
            "logger.info",
            "this.build",
            "getTouchBarByPage"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.build",
                "code": "build (template) {\n    const result = []\n\n    template.forEach(tpl => {\n      const { id, type, ...rest } = tpl\n      let options = { ...rest }\n      if (type === 'group') {\n        options = { type, items: this.build(options.items) }\n      }\n      const item = this.buildItem(type, options)\n      result.push(item)\n    })\n    return result\n  }"
            },
            {
                "name": "getTouchBarByPage",
                "code": "getTouchBarByPage (page) {\n    let bar = this.bars[page] || null\n    if (!bar) {\n      try {\n        const items = this.build(this.template)\n        bar = new TouchBar({ items })\n        this.bars[page] = bar\n      } catch (e) {\n        logger.info('getTouchBarByPage fail', e)\n      }\n    }\n    return bar\n  }"
            }
        ],
        "third_party": [
            "logger.info"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "agalwood/Motrix",
        "function_declaration": "handleWindowClose (pageOptions, page, window)",
        "start_line": "204",
        "end_line": "221",
        "file_path": "src/main/ui/WindowManager.js",
        "docstring": "The function handleWindowClose(pageOptions, page, window) manages the window close behavior.\\nIt attaches a 'close' event listener to the window.\\nIf the option bindCloseToHide is set and the application is not quitting, it prevents the default close action and hides the window instead.\\nIf the window is in full-screen mode, it exits full-screen before hiding the window.\\nFinally, it emits a 'window-closed' event with the page and window bounds information.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f860bf9bf687",
        "ground_truth": "handleWindowClose (pageOptions, page, window) {\n  window.on('close', (event) => {\n    if (pageOptions.bindCloseToHide && !this.willQuit) {\n      event.preventDefault()\n      // @see https://github.com/electron/electron/issues/20263\n      if (window.isFullScreen()) {\n        window.once('leave-full-screen', () => window.hide())\n        window.setFullScreen(false)\n      } else {\n        window.hide()\n      }\n    }\n    const bounds = window.getBounds()\n    this.emit('window-closed', { page, bounds })\n  })\n}",
        "import_statements": [
            "node:path",
            "node:events",
            "lodash",
            "electron",
            "electron-is",
            "../configs/page",
            "../core/Logger"
        ],
        "reference_api": [
            "this.emit",
            "window.getBounds",
            "window.once",
            "window.setFullScreen",
            "window.hide",
            "event.preventDefault",
            "window.isFullScreen",
            "handleWindowClose",
            "window.on"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "handleWindowClose",
                "code": "handleWindowClose (pageOptions, page, window) {\n    window.on('close', (event) => {\n      if (pageOptions.bindCloseToHide && !this.willQuit) {\n        event.preventDefault()\n\n        // @see https://github.com/electron/electron/issues/20263\n        if (window.isFullScreen()) {\n          window.once('leave-full-screen', () => window.hide())\n\n          window.setFullScreen(false)\n        } else {\n          window.hide()\n        }\n      }\n      const bounds = window.getBounds()\n      this.emit('window-closed', { page, bounds })\n    })\n  }"
            }
        ],
        "third_party": [
            "this.emit",
            "window.getBounds",
            "window.once",
            "window.setFullScreen",
            "window.hide",
            "event.preventDefault",
            "window.isFullScreen",
            "window.on"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "agalwood/Motrix",
        "function_declaration": "export const moveAppToApplicationsFolder = (errorMsg = '') =>",
        "start_line": "106",
        "end_line": "119",
        "file_path": "src/main/utils/index.js",
        "docstring": "The function moveAppToApplicationsFolder(errorMsg = '') attempts to move the application to the Applications folder.\\nIt returns a Promise that resolves if the move is successful and rejects with an error message if the move fails.\\nIf an error occurs during the process, the Promise is rejected with the caught error.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ae062f5e98e3",
        "ground_truth": "export const moveAppToApplicationsFolder = (errorMsg = '') => {\n  return new Promise((resolve, reject) => {\n    try {\n      const result = app.moveToApplicationsFolder()\n      if (result) {\n        resolve(result)\n      } else {\n        reject(new Error(errorMsg))\n      }\n    } catch (err) {\n      reject(err)\n    }\n  })\n}",
        "import_statements": [
            "node:path",
            "node:fs",
            "electron",
            "electron-is",
            "@shared/constants",
            "../configs/engine",
            "../core/Logger"
        ],
        "reference_api": [
            "resolve",
            "reject",
            "app.moveToApplicationsFolder"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "resolve",
            "reject",
            "app.moveToApplicationsFolder"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "nativefier/nativefier",
        "function_declaration": "async function copyIconsIfNecessary(\n  options: AppOptions,\n  appPath: string,\n): Promise<void>",
        "start_line": "33",
        "end_line": "68",
        "file_path": "src/build/buildNativefierApp.ts",
        "docstring": "The async function copyIconsIfNecessary(options, appPath) ensures that application icons are copied if needed.\\nIt first logs the start of the process and checks if an icon is specified in the options.\\nIf no icon is specified, it logs this and exits.\\nIf the platform is 'darwin' or 'mas' and the tray option is not 'false', it copies the tray icon as a .png file to the application path.\\nFor Windows and Linux, it copies the specified icon file to the application path with an appropriate filename extension.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "294de13d4a02",
        "ground_truth": "async function copyIconsIfNecessary(\n  options: AppOptions,\n  appPath: string,\n): Promise<void> {\n  log.debug('Copying icons if necessary');\n  if (!options.packager.icon) {\n    log.debug('No icon specified in options; aborting');\n    return;\n  }\n   if (\n    options.packager.platform === 'darwin' ||\n    options.packager.platform === 'mas'\n  ) {\n    if (options.nativefier.tray !== 'false') {\n      //tray icon needs to be .png\n      log.debug('Copying icon for tray application');\n      const trayIconFileName = `tray-icon.png`;\n      const destIconPath = path.join(appPath, 'icon.png');\n      await fs.copy(\n        `${path.dirname(options.packager.icon)}/${trayIconFileName}`,\n        destIconPath,\n      );\n    } else {\n      log.debug('No copying necessary on macOS; aborting');\n    }\n    return;\n  }\n   // windows & linux: put the icon file into the app\n  const destFileName = `icon${path.extname(options.packager.icon)}`;\n  const destIconPath = path.join(appPath, destFileName);\n   log.debug(`Copying icon ${options.packager.icon} to`, destIconPath);\n  await fs.copy(options.packager.icon, destIconPath);\n}",
        "import_statements": [
            "import * as path from 'path';",
            "* as path",
            "* as path",
            "import * as electronGet from '@electron/get';",
            "* as electronGet",
            "* as electronGet",
            "import electronPackager from 'electron-packager';",
            "electronPackager",
            "import * as fs from 'fs-extra';",
            "* as fs",
            "* as fs",
            "import * as log from 'loglevel';",
            "* as log",
            "* as log",
            "import { convertIconIfNecessary } from './buildIcon';",
            "{ convertIconIfNecessary }",
            "{ convertIconIfNecessary }",
            "convertIconIfNecessary",
            "import {\n  getTempDir,\n  hasWine,\n  isWindows,\n  isWindowsAdmin,\n} from '../helpers/helpers';",
            "{\n  getTempDir,\n  hasWine,\n  isWindows,\n  isWindowsAdmin,\n}",
            "{\n  getTempDir,\n  hasWine,\n  isWindows,\n  isWindowsAdmin,\n}",
            "getTempDir",
            "hasWine",
            "isWindows",
            "isWindowsAdmin",
            "import { useOldAppOptions, findUpgradeApp } from '../helpers/upgrade/upgrade';",
            "{ useOldAppOptions, findUpgradeApp }",
            "{ useOldAppOptions, findUpgradeApp }",
            "useOldAppOptions",
            "findUpgradeApp",
            "import { AppOptions, RawOptions } from '../../shared/src/options/model';",
            "{ AppOptions, RawOptions }",
            "{ AppOptions, RawOptions }",
            "AppOptions",
            "RawOptions",
            "import { getOptions } from '../options/optionsMain';",
            "{ getOptions }",
            "{ getOptions }",
            "getOptions",
            "import { prepareElectronApp } from './prepareElectronApp';",
            "{ prepareElectronApp }",
            "{ prepareElectronApp }",
            "prepareElectronApp"
        ],
        "reference_api": [
            "path.dirname",
            "log.debug",
            "fs.copy",
            "path.extname",
            "path.join"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "path.dirname",
                "code": "["
            },
            {
                "name": "log.debug",
                "code": "["
            },
            {
                "name": "fs.copy",
                "code": "["
            },
            {
                "name": "path.extname",
                "code": "["
            },
            {
                "name": "path.join",
                "code": "["
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "nativefier/nativefier",
        "function_declaration": "export function normalizeAppName(appName: string, url: string): string",
        "start_line": "144",
        "end_line": "153",
        "file_path": "src/build/prepareElectronApp.ts",
        "docstring": "The function normalizeAppName(appName, url) generates a normalized application name.\\nIt creates an MD5 hash from the provided URL and extracts a 6-character substring from the hash.\\nThe function then converts the app name to lowercase, removes certain punctuation marks, and replaces spaces and underscores with hyphens.\\nFinally, it appends \"-nativefier-\" followed by the hash substring to the normalized app name and returns the result.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "af06dceb6a2f",
        "ground_truth": "export function normalizeAppName(appName: string, url: string): string {\n  const hash = crypto.createHash('md5');\n  hash.update(url);\n  const postFixHash = hash.digest('hex').substring(0, 6);\n  const normalized = appName\n    .toLowerCase()\n    .replace(/[,:.]/g, '')\n    .replace(/[\\s_]/g, '-');\n  return `${normalized}-nativefier-${postFixHash}`;\n}",
        "import_statements": [
            "import * as crypto from 'crypto';",
            "* as crypto",
            "* as crypto",
            "import * as fs from 'fs-extra';",
            "* as fs",
            "* as fs",
            "import * as path from 'path';",
            "* as path",
            "* as path",
            "import * as log from 'loglevel';",
            "* as log",
            "* as log",
            "import { generateRandomSuffix } from '../helpers/helpers';",
            "{ generateRandomSuffix }",
            "{ generateRandomSuffix }",
            "generateRandomSuffix",
            "import {\n  AppOptions,\n  OutputOptions,\n  PackageJSON,\n} from '../../shared/src/options/model';",
            "{\n  AppOptions,\n  OutputOptions,\n  PackageJSON,\n}",
            "{\n  AppOptions,\n  OutputOptions,\n  PackageJSON,\n}",
            "AppOptions",
            "OutputOptions",
            "PackageJSON",
            "import { parseJson } from '../utils/parseUtils';",
            "{ parseJson }",
            "{ parseJson }",
            "parseJson",
            "import { DEFAULT_APP_NAME } from '../constants';",
            "{ DEFAULT_APP_NAME }",
            "{ DEFAULT_APP_NAME }",
            "DEFAULT_APP_NAME"
        ],
        "reference_api": [
            "appName\n    .toLowerCase",
            "hash.update",
            "crypto.createHash",
            "appName\n    .toLowerCase()\n    .replace",
            "hash.digest('hex').substring",
            "appName\n    .toLowerCase()\n    .replace(/[,:.]/g, '')\n    .replace",
            "hash.digest"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "appName\n    .toLowerCase",
            "hash.update",
            "crypto.createHash",
            "appName\n    .toLowerCase()\n    .replace",
            "hash.digest('hex').substring",
            "appName\n    .toLowerCase()\n    .replace(/[,:.]/g, '')\n    .replace",
            "hash.digest"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "nativefier/nativefier",
        "function_declaration": "export async function prepareElectronApp(\n  src: string,\n  dest: string,\n  options: AppOptions,\n): Promise<void>",
        "start_line": "180",
        "end_line": "219",
        "file_path": "src/build/prepareElectronApp.ts",
        "docstring": "The async function prepareElectronApp(src, dest, options) prepares an Electron application by copying it from the source to the destination and configuring it.\\nIt logs the copy operation, attempts to copy the app, and handles any errors that occur.\\nThe function writes the app configuration to a JSON file at the destination and copies the bookmarks menu if specified in the options, logging any errors encountered.\\nIt also tries to copy injection scripts and logs errors if they occur.\\nFinally, it changes the app's package JSON name and sets the app bundle ID using the normalized app name.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3728778a6e34",
        "ground_truth": "export async function prepareElectronApp(\n  src: string,\n  dest: string,\n  options: AppOptions,\n): Promise<void> {\n  log.debug(`Copying electron app from ${src} to ${dest}`);\n  try {\n    await fs.copy(src, dest);\n  } catch (err: unknown) {\n    throw `Error copying electron app from ${src} to temp dir ${dest}. Error: ${\n      (err as Error).message\n    }`;\n  }\n   const appJsonPath = path.join(dest, '/nativefier.json');\n  const pickedOptions = pickElectronAppArgs(options);\n  log.debug(`Writing app config to ${appJsonPath}`, pickedOptions);\n  await fs.writeFile(appJsonPath, JSON.stringify(pickedOptions));\n   if (options.nativefier.bookmarksMenu) {\n    const bookmarksJsonPath = path.join(dest, '/bookmarks.json');\n    try {\n      await fs.copy(options.nativefier.bookmarksMenu, bookmarksJsonPath);\n    } catch (err: unknown) {\n      log.error('Error copying bookmarks menu config file.', err);\n    }\n  }\n   try {\n    await maybeCopyScripts(options.nativefier.inject, dest);\n  } catch (err: unknown) {\n    log.error('Error copying injection files.', err);\n  }\n  const normalizedAppName = changeAppPackageJsonName(\n    dest,\n    options.packager.name as string,\n    options.packager.targetUrl,\n  );\n  options.packager.appBundleId = `com.electron.nativefier.${normalizedAppName}`;\n}",
        "import_statements": [
            "import * as crypto from 'crypto';",
            "* as crypto",
            "* as crypto",
            "import * as fs from 'fs-extra';",
            "* as fs",
            "* as fs",
            "import * as path from 'path';",
            "* as path",
            "* as path",
            "import * as log from 'loglevel';",
            "* as log",
            "* as log",
            "import { generateRandomSuffix } from '../helpers/helpers';",
            "{ generateRandomSuffix }",
            "{ generateRandomSuffix }",
            "generateRandomSuffix",
            "import {\n  AppOptions,\n  OutputOptions,\n  PackageJSON,\n} from '../../shared/src/options/model';",
            "{\n  AppOptions,\n  OutputOptions,\n  PackageJSON,\n}",
            "{\n  AppOptions,\n  OutputOptions,\n  PackageJSON,\n}",
            "AppOptions",
            "OutputOptions",
            "PackageJSON",
            "import { parseJson } from '../utils/parseUtils';",
            "{ parseJson }",
            "{ parseJson }",
            "parseJson",
            "import { DEFAULT_APP_NAME } from '../constants';",
            "{ DEFAULT_APP_NAME }",
            "{ DEFAULT_APP_NAME }",
            "DEFAULT_APP_NAME"
        ],
        "reference_api": [
            "JSON.stringify",
            "changeAppPackageJsonName",
            "fs.writeFile",
            "maybeCopyScripts",
            "log.debug",
            "pickElectronAppArgs",
            "fs.copy",
            "log.error",
            "path.join"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "changeAppPackageJsonName",
                "code": "u"
            },
            {
                "name": "maybeCopyScripts",
                "code": "s"
            },
            {
                "name": "pickElectronAppArgs",
                "code": "u"
            }
        ],
        "third_party": [
            "fs.writeFile",
            "log.debug",
            "fs.copy",
            "log.error",
            "path.join"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "nativefier/nativefier",
        "function_declaration": "export function downloadFile(\n  fileUrl: string,\n): Promise<DownloadResult | undefined>",
        "start_line": "71",
        "end_line": "88",
        "file_path": "src/helpers/helpers.ts",
        "docstring": "The function downloadFile(fileUrl: string) downloads a file from the specified URL and returns a promise.\\nIt logs the download attempt and sends a GET request for the file as an array buffer.\\nIf the response contains data, it returns an object with the data and the file extension.\\nIf there is no data, it returns undefined.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "281c20f209ba",
        "ground_truth": "export function downloadFile(\n  fileUrl: string,\n): Promise<DownloadResult | undefined> {\n  log.debug(`Downloading ${fileUrl}`);\n  return axios\n    .get<Buffer>(fileUrl, {\n      responseType: 'arraybuffer',\n    })\n    .then((response) => {\n      if (!response.data) {\n        return undefined;\n      }\n      return {\n        data: response.data,\n        ext: path.extname(fileUrl),\n      };\n    });\n}",
        "import_statements": [
            "import { spawnSync } from 'child_process';",
            "{ spawnSync }",
            "{ spawnSync }",
            "spawnSync",
            "import * as crypto from 'crypto';",
            "* as crypto",
            "* as crypto",
            "import * as os from 'os';",
            "* as os",
            "* as os",
            "import * as path from 'path';",
            "* as path",
            "* as path",
            "import axios from 'axios';",
            "axios",
            "import * as dns from 'dns';",
            "* as dns",
            "* as dns",
            "import * as hasbin from 'hasbin';",
            "* as hasbin",
            "* as hasbin",
            "import * as log from 'loglevel';",
            "* as log",
            "* as log",
            "import * as tmp from 'tmp';",
            "* as tmp",
            "* as tmp",
            "import { parseJson } from '../utils/parseUtils';",
            "{ parseJson }",
            "{ parseJson }",
            "parseJson"
        ],
        "reference_api": [
            "path.extname"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "path.extname",
                "code": "r"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "nativefier/nativefier",
        "function_declaration": "export function camelCased(str: string): string",
        "start_line": "202",
        "end_line": "211",
        "file_path": "src/helpers/helpers.ts",
        "docstring": "The function camelCased(str: string): string converts a hyphen-separated string into camelCase.\\nIt splits the input string by hyphens, filters out any empty strings, and then capitalizes the first letter of each word except the first one.\\nFinally, it joins all words together without spaces to form a camelCase string.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e71c0b9dab4a",
        "ground_truth": "export function camelCased(str: string): string {\n  return str\n    .split('-')\n    .filter((s) => s.length > 0)\n    .map((word, i) => {\n      if (i === 0) return word;\n      return `${word[0].toUpperCase()}${word.substring(1)}`;\n    })\n    .join('');\n}",
        "import_statements": [
            "import { spawnSync } from 'child_process';",
            "{ spawnSync }",
            "{ spawnSync }",
            "spawnSync",
            "import * as crypto from 'crypto';",
            "* as crypto",
            "* as crypto",
            "import * as os from 'os';",
            "* as os",
            "* as os",
            "import * as path from 'path';",
            "* as path",
            "* as path",
            "import axios from 'axios';",
            "axios",
            "import * as dns from 'dns';",
            "* as dns",
            "* as dns",
            "import * as hasbin from 'hasbin';",
            "* as hasbin",
            "* as hasbin",
            "import * as log from 'loglevel';",
            "* as log",
            "* as log",
            "import * as tmp from 'tmp';",
            "* as tmp",
            "* as tmp",
            "import { parseJson } from '../utils/parseUtils';",
            "{ parseJson }",
            "{ parseJson }",
            "parseJson"
        ],
        "reference_api": [
            "word[0].toUpperCase",
            "word.substring"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "word[0].toUpperCase",
                "code": "r"
            },
            {
                "name": "word.substring",
                "code": "r"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "nativefier/nativefier",
        "function_declaration": "export function sanitizeFilename(\n  platform: string | undefined,\n  filenameToSanitize: string,\n): string",
        "start_line": "6",
        "end_line": "25",
        "file_path": "src/utils/sanitizeFilename.ts",
        "docstring": "The function sanitizeFilename(platform, filenameToSanitize) sanitizes a given filename based on the specified platform.\\nIt first sanitizes the filename and then removes spaces and certain Unicode characters if the platform is Linux.\\nIf the resulting filename is empty, it assigns a default application name and logs a warning.\\nThe function logs the sanitized filename and returns it.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c93f0f7bfa03",
        "ground_truth": "export function sanitizeFilename(\n  platform: string | undefined,\n  filenameToSanitize: string,\n): string {\n  let result: string = sanitize(filenameToSanitize);\n   // spaces will cause problems with Ubuntu when pinned to the dock\n  if (platform === 'linux') {\n    result = result.replace(/[\\s\\u200e\\u200f]/g, '');\n  }\n   if (!result || result === '') {\n    result = DEFAULT_APP_NAME;\n    log.warn(\n      'Falling back to default app name as result of filename sanitization. Use flag \"--name\" to set a name',\n    );\n  }\n  log.debug(`Sanitized filename for ${filenameToSanitize} : ${result}`);\n  return result;\n}",
        "import_statements": [
            "import * as log from 'loglevel';",
            "* as log",
            "* as log",
            "import sanitize = require('sanitize-filename');",
            "sanitize = require('sanitize-filename')",
            "import { DEFAULT_APP_NAME } from '../constants';",
            "{ DEFAULT_APP_NAME }",
            "{ DEFAULT_APP_NAME }",
            "DEFAULT_APP_NAME"
        ],
        "reference_api": [
            "log.debug",
            "log.warn",
            "sanitize",
            "result.replace"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "log.debug",
            "log.warn",
            "sanitize",
            "result.replace"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "typeorm/typeorm",
        "function_declaration": "isExpired(savedCache: QueryResultCacheOptions): boolean ",
        "start_line": "194",
        "end_line": "206",
        "file_path": "src/cache/DbQueryResultCache.ts",
        "docstring": "The function isExpired(savedCache: QueryResultCacheOptions): boolean determines if a cached query result has expired.\\nIt calculates the duration by converting it to an integer if it's a string.\\nIt then checks if the sum of the cache time and duration is less than the current time in milliseconds.\\nIf so, it returns true, indicating the cache has expired; otherwise, it returns false.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ac4bf3ef1fa8",
        "ground_truth": "isExpired(savedCache: QueryResultCacheOptions): boolean {\n    const duration =\n        typeof savedCache.duration === \"string\"\n            ? parseInt(savedCache.duration)\n            : savedCache.duration\n    return (\n        (typeof savedCache.time === \"string\"\n            ? parseInt(savedCache.time as any)\n            : savedCache.time)! +\n            duration <\n        new Date().getTime()\n    )\n}",
        "import_statements": [
            "import { ObjectLiteral } from \"../common/ObjectLiteral\"",
            "{ ObjectLiteral }",
            "{ ObjectLiteral }",
            "ObjectLiteral",
            "import { DataSource } from \"../data-source/DataSource\"",
            "{ DataSource }",
            "{ DataSource }",
            "DataSource",
            "import { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\"",
            "{ MssqlParameter }",
            "{ MssqlParameter }",
            "MssqlParameter",
            "import { QueryRunner } from \"../query-runner/QueryRunner\"",
            "{ QueryRunner }",
            "{ QueryRunner }",
            "QueryRunner",
            "import { Table } from \"../schema-builder/table/Table\"",
            "{ Table }",
            "{ Table }",
            "Table",
            "import { QueryResultCache } from \"./QueryResultCache\"",
            "{ QueryResultCache }",
            "{ QueryResultCache }",
            "QueryResultCache",
            "import { QueryResultCacheOptions } from \"./QueryResultCacheOptions\"",
            "{ QueryResultCacheOptions }",
            "{ QueryResultCacheOptions }",
            "QueryResultCacheOptions",
            "import { v4 as uuidv4 } from \"uuid\"",
            "{ v4 as uuidv4 }",
            "{ v4 as uuidv4 }",
            "v4 as uuidv4"
        ],
        "reference_api": [
            "new Date().getTime",
            "parseInt",
            "isExpired"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "new Date().getTime",
                "code": "i"
            },
            {
                "name": "isExpired",
                "code": "i"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "typeorm/typeorm",
        "function_declaration": "static getTimestamp(timestampOptionArgument: any): number",
        "start_line": "107",
        "end_line": "119",
        "file_path": "src/commands/CommandUtils.ts",
        "docstring": "The static function getTimestamp(timestampOptionArgument) validates the provided timestamp argument.\\nIf the argument is not a number or is negative, it throws a TypeORMError with an appropriate message.\\nIf the argument is valid, it converts it to a timestamp and returns it.\\nIf no argument is provided, it returns the current timestamp.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6b8f5c8fc4ec",
        "ground_truth": "static getTimestamp(timestampOptionArgument: any): number {\n    if (\n        timestampOptionArgument &&\n        (isNaN(timestampOptionArgument) || timestampOptionArgument < 0)\n    ) {\n        throw new TypeORMError(\n            `timestamp option should be a non-negative number. received: ${timestampOptionArgument}`,\n        )\n    }\n    return timestampOptionArgument\n        ? new Date(Number(timestampOptionArgument)).getTime()\n        : Date.now()\n}",
        "import_statements": [
            "import * as fs from \"fs\"",
            "* as fs",
            "* as fs",
            "import * as path from \"path\"",
            "* as path",
            "* as path",
            "import mkdirp from \"mkdirp\"",
            "mkdirp",
            "import { TypeORMError } from \"../error\"",
            "{ TypeORMError }",
            "{ TypeORMError }",
            "TypeORMError",
            "import { DataSource } from \"../data-source\"",
            "{ DataSource }",
            "{ DataSource }",
            "DataSource",
            "import { InstanceChecker } from \"../util/InstanceChecker\"",
            "{ InstanceChecker }",
            "{ InstanceChecker }",
            "InstanceChecker",
            "import { importOrRequireFile } from \"../util/ImportUtils\"",
            "{ importOrRequireFile }",
            "{ importOrRequireFile }",
            "importOrRequireFile"
        ],
        "reference_api": [
            "getTimestamp",
            "isNaN",
            "Date.now",
            "Number",
            "new Date(Number(timestampOptionArgument)).getTime"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getTimestamp",
                "code": "o"
            },
            {
                "name": "Number",
                "code": "o"
            },
            {
                "name": "new Date(Number(timestampOptionArgument)).getTime",
                "code": "o"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "typeorm/typeorm",
        "function_declaration": " async dropDatabase(): Promise<void>",
        "start_line": "348",
        "end_line": "382",
        "file_path": "src/data-source/DataSource.ts",
        "docstring": "The async function dropDatabase() attempts to drop the database using a query runner.\\nIt first creates a query runner and then checks the type of database driver.\\nFor certain database types, it collects the unique database names from the entity metadata.\\nIf no specific databases are found, it uses the default driver database.\\nIt clears each database if multiple databases are found; otherwise, it clears the default database.\\nFinally, the function releases the query runner regardless of the outcome.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "747bea9d7ad9",
        "ground_truth": "async dropDatabase(): Promise<void> {\n    const queryRunner = this.createQueryRunner()\n    try {\n        if (\n            this.driver.options.type === \"mssql\" ||\n            DriverUtils.isMySQLFamily(this.driver) ||\n            this.driver.options.type === \"aurora-mysql\" ||\n            DriverUtils.isSQLiteFamily(this.driver)\n        ) {\n            const databases: string[] = []\n            this.entityMetadatas.forEach((metadata) => {\n                if (\n                    metadata.database &&\n                    databases.indexOf(metadata.database) === -1\n                )\n                    databases.push(metadata.database)\n            })\n            if (databases.length === 0 && this.driver.database) {\n                databases.push(this.driver.database)\n            }\n            if (databases.length === 0) {\n                await queryRunner.clearDatabase()\n            } else {\n                for (const database of databases) {\n                    await queryRunner.clearDatabase(database)\n                }\n            }\n        } else {\n            await queryRunner.clearDatabase()\n        }\n    } finally {\n        await queryRunner.release()\n    }\n}",
        "import_statements": [
            "import { Driver } from \"../driver/Driver\"",
            "{ Driver }",
            "{ Driver }",
            "Driver",
            "import { registerQueryBuilders } from \"../query-builder\"",
            "{ registerQueryBuilders }",
            "{ registerQueryBuilders }",
            "registerQueryBuilders",
            "import { Repository } from \"../repository/Repository\"",
            "{ Repository }",
            "{ Repository }",
            "Repository",
            "import { EntitySubscriberInterface } from \"../subscriber/EntitySubscriberInterface\"",
            "{ EntitySubscriberInterface }",
            "{ EntitySubscriberInterface }",
            "EntitySubscriberInterface",
            "import { EntityTarget } from \"../common/EntityTarget\"",
            "{ EntityTarget }",
            "{ EntityTarget }",
            "EntityTarget",
            "import { ObjectType } from \"../common/ObjectType\"",
            "{ ObjectType }",
            "{ ObjectType }",
            "ObjectType",
            "import { EntityManager } from \"../entity-manager/EntityManager\"",
            "{ EntityManager }",
            "{ EntityManager }",
            "EntityManager",
            "import { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\"",
            "{ DefaultNamingStrategy }",
            "{ DefaultNamingStrategy }",
            "DefaultNamingStrategy",
            "import {\n    CannotConnectAlreadyConnectedError,\n    CannotExecuteNotConnectedError,\n    EntityMetadataNotFoundError,\n    QueryRunnerProviderAlreadyReleasedError,\n    TypeORMError,\n} from \"../error\"",
            "{\n    CannotConnectAlreadyConnectedError,\n    CannotExecuteNotConnectedError,\n    EntityMetadataNotFoundError,\n    QueryRunnerProviderAlreadyReleasedError,\n    TypeORMError,\n}",
            "{\n    CannotConnectAlreadyConnectedError,\n    CannotExecuteNotConnectedError,\n    EntityMetadataNotFoundError,\n    QueryRunnerProviderAlreadyReleasedError,\n    TypeORMError,\n}",
            "CannotConnectAlreadyConnectedError",
            "CannotExecuteNotConnectedError",
            "EntityMetadataNotFoundError",
            "QueryRunnerProviderAlreadyReleasedError",
            "TypeORMError",
            "import { TreeRepository } from \"../repository/TreeRepository\"",
            "{ TreeRepository }",
            "{ TreeRepository }",
            "TreeRepository",
            "import { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"",
            "{ NamingStrategyInterface }",
            "{ NamingStrategyInterface }",
            "NamingStrategyInterface",
            "import { EntityMetadata } from \"../metadata/EntityMetadata\"",
            "{ EntityMetadata }",
            "{ EntityMetadata }",
            "EntityMetadata",
            "import { Logger } from \"../logger/Logger\"",
            "{ Logger }",
            "{ Logger }",
            "Logger",
            "import { MigrationInterface } from \"../migration/MigrationInterface\"",
            "{ MigrationInterface }",
            "{ MigrationInterface }",
            "MigrationInterface",
            "import { MigrationExecutor } from \"../migration/MigrationExecutor\"",
            "{ MigrationExecutor }",
            "{ MigrationExecutor }",
            "MigrationExecutor",
            "import { Migration } from \"../migration/Migration\"",
            "{ Migration }",
            "{ Migration }",
            "Migration",
            "import { MongoRepository } from \"../repository/MongoRepository\"",
            "{ MongoRepository }",
            "{ MongoRepository }",
            "MongoRepository",
            "import { MongoEntityManager } from \"../entity-manager/MongoEntityManager\"",
            "{ MongoEntityManager }",
            "{ MongoEntityManager }",
            "MongoEntityManager",
            "import { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\"",
            "{ EntityMetadataValidator }",
            "{ EntityMetadataValidator }",
            "EntityMetadataValidator",
            "import { DataSourceOptions } from \"./DataSourceOptions\"",
            "{ DataSourceOptions }",
            "{ DataSourceOptions }",
            "DataSourceOptions",
            "import { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\"",
            "{ EntityManagerFactory }",
            "{ EntityManagerFactory }",
            "EntityManagerFactory",
            "import { DriverFactory } from \"../driver/DriverFactory\"",
            "{ DriverFactory }",
            "{ DriverFactory }",
            "DriverFactory",
            "import { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\"",
            "{ ConnectionMetadataBuilder }",
            "{ ConnectionMetadataBuilder }",
            "ConnectionMetadataBuilder",
            "import { QueryRunner } from \"../query-runner/QueryRunner\"",
            "{ QueryRunner }",
            "{ QueryRunner }",
            "QueryRunner",
            "import { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"",
            "{ SelectQueryBuilder }",
            "{ SelectQueryBuilder }",
            "SelectQueryBuilder",
            "import { LoggerFactory } from \"../logger/LoggerFactory\"",
            "{ LoggerFactory }",
            "{ LoggerFactory }",
            "LoggerFactory",
            "import { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\"",
            "{ QueryResultCacheFactory }",
            "{ QueryResultCacheFactory }",
            "QueryResultCacheFactory",
            "import { QueryResultCache } from \"../cache/QueryResultCache\"",
            "{ QueryResultCache }",
            "{ QueryResultCache }",
            "QueryResultCache",
            "import { SqljsEntityManager } from \"../entity-manager/SqljsEntityManager\"",
            "{ SqljsEntityManager }",
            "{ SqljsEntityManager }",
            "SqljsEntityManager",
            "import { RelationLoader } from \"../query-builder/RelationLoader\"",
            "{ RelationLoader }",
            "{ RelationLoader }",
            "RelationLoader",
            "import { ObjectUtils } from \"../util/ObjectUtils\"",
            "{ ObjectUtils }",
            "{ ObjectUtils }",
            "ObjectUtils",
            "import { IsolationLevel } from \"../driver/types/IsolationLevel\"",
            "{ IsolationLevel }",
            "{ IsolationLevel }",
            "IsolationLevel",
            "import { ReplicationMode } from \"../driver/types/ReplicationMode\"",
            "{ ReplicationMode }",
            "{ ReplicationMode }",
            "ReplicationMode",
            "import { RelationIdLoader } from \"../query-builder/RelationIdLoader\"",
            "{ RelationIdLoader }",
            "{ RelationIdLoader }",
            "RelationIdLoader",
            "import { DriverUtils } from \"../driver/DriverUtils\"",
            "{ DriverUtils }",
            "{ DriverUtils }",
            "DriverUtils",
            "import { InstanceChecker } from \"../util/InstanceChecker\"",
            "{ InstanceChecker }",
            "{ InstanceChecker }",
            "InstanceChecker",
            "import { ObjectLiteral } from \"../common/ObjectLiteral\"",
            "{ ObjectLiteral }",
            "{ ObjectLiteral }",
            "ObjectLiteral"
        ],
        "reference_api": [
            "databases.indexOf",
            "databases.push"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "databases.indexOf",
                "code": "m"
            },
            {
                "name": "databases.push",
                "code": "m"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "typeorm/typeorm",
        "function_declaration": "createQueryBuilder<Entity extends ObjectLiteral>(\n        entityOrRunner?: EntityTarget<Entity> | QueryRunner,\n        alias?: string,\n        queryRunner?: QueryRunner,\n    ): SelectQueryBuilder<Entity>",
        "start_line": "561",
        "end_line": "583",
        "file_path": "src/data-source/DataSource.ts",
        "docstring": "The function createQueryBuilder<Entity extends ObjectLiteral>(entityOrRunner, alias, queryRunner) creates and returns a SelectQueryBuilder for the specified entity.\\nIt checks if the manager is for MongoDB and throws an error if so, as Query Builder is not supported by MongoDB.\\nIf an alias is provided, it builds the alias, retrieves the metadata for the entity, and initializes the SelectQueryBuilder with the alias and metadata.\\nIf no alias is provided, it initializes the SelectQueryBuilder with the entityOrRunner or queryRunner.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7dce3d050d72",
        "ground_truth": "createQueryBuilder<Entity extends ObjectLiteral>(\n    entityOrRunner?: EntityTarget<Entity> | QueryRunner,\n    alias?: string,\n    queryRunner?: QueryRunner,\n): SelectQueryBuilder<Entity> {\n    if (InstanceChecker.isMongoEntityManager(this.manager))\n        throw new TypeORMError(`Query Builder is not supported by MongoDB.`)\n    if (alias) {\n        alias = DriverUtils.buildAlias(this.driver, undefined, alias)\n        const metadata = this.getMetadata(\n            entityOrRunner as EntityTarget<Entity>,\n        )\n        return new SelectQueryBuilder(this, queryRunner)\n            .select(alias)\n            .from(metadata.target, alias)\n    } else {\n        return new SelectQueryBuilder(\n            this,\n            entityOrRunner as QueryRunner | undefined,\n        )\n    }\n}",
        "import_statements": [
            "import { Driver } from \"../driver/Driver\"",
            "{ Driver }",
            "{ Driver }",
            "Driver",
            "import { registerQueryBuilders } from \"../query-builder\"",
            "{ registerQueryBuilders }",
            "{ registerQueryBuilders }",
            "registerQueryBuilders",
            "import { Repository } from \"../repository/Repository\"",
            "{ Repository }",
            "{ Repository }",
            "Repository",
            "import { EntitySubscriberInterface } from \"../subscriber/EntitySubscriberInterface\"",
            "{ EntitySubscriberInterface }",
            "{ EntitySubscriberInterface }",
            "EntitySubscriberInterface",
            "import { EntityTarget } from \"../common/EntityTarget\"",
            "{ EntityTarget }",
            "{ EntityTarget }",
            "EntityTarget",
            "import { ObjectType } from \"../common/ObjectType\"",
            "{ ObjectType }",
            "{ ObjectType }",
            "ObjectType",
            "import { EntityManager } from \"../entity-manager/EntityManager\"",
            "{ EntityManager }",
            "{ EntityManager }",
            "EntityManager",
            "import { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\"",
            "{ DefaultNamingStrategy }",
            "{ DefaultNamingStrategy }",
            "DefaultNamingStrategy",
            "import {\n    CannotConnectAlreadyConnectedError,\n    CannotExecuteNotConnectedError,\n    EntityMetadataNotFoundError,\n    QueryRunnerProviderAlreadyReleasedError,\n    TypeORMError,\n} from \"../error\"",
            "{\n    CannotConnectAlreadyConnectedError,\n    CannotExecuteNotConnectedError,\n    EntityMetadataNotFoundError,\n    QueryRunnerProviderAlreadyReleasedError,\n    TypeORMError,\n}",
            "{\n    CannotConnectAlreadyConnectedError,\n    CannotExecuteNotConnectedError,\n    EntityMetadataNotFoundError,\n    QueryRunnerProviderAlreadyReleasedError,\n    TypeORMError,\n}",
            "CannotConnectAlreadyConnectedError",
            "CannotExecuteNotConnectedError",
            "EntityMetadataNotFoundError",
            "QueryRunnerProviderAlreadyReleasedError",
            "TypeORMError",
            "import { TreeRepository } from \"../repository/TreeRepository\"",
            "{ TreeRepository }",
            "{ TreeRepository }",
            "TreeRepository",
            "import { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"",
            "{ NamingStrategyInterface }",
            "{ NamingStrategyInterface }",
            "NamingStrategyInterface",
            "import { EntityMetadata } from \"../metadata/EntityMetadata\"",
            "{ EntityMetadata }",
            "{ EntityMetadata }",
            "EntityMetadata",
            "import { Logger } from \"../logger/Logger\"",
            "{ Logger }",
            "{ Logger }",
            "Logger",
            "import { MigrationInterface } from \"../migration/MigrationInterface\"",
            "{ MigrationInterface }",
            "{ MigrationInterface }",
            "MigrationInterface",
            "import { MigrationExecutor } from \"../migration/MigrationExecutor\"",
            "{ MigrationExecutor }",
            "{ MigrationExecutor }",
            "MigrationExecutor",
            "import { Migration } from \"../migration/Migration\"",
            "{ Migration }",
            "{ Migration }",
            "Migration",
            "import { MongoRepository } from \"../repository/MongoRepository\"",
            "{ MongoRepository }",
            "{ MongoRepository }",
            "MongoRepository",
            "import { MongoEntityManager } from \"../entity-manager/MongoEntityManager\"",
            "{ MongoEntityManager }",
            "{ MongoEntityManager }",
            "MongoEntityManager",
            "import { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\"",
            "{ EntityMetadataValidator }",
            "{ EntityMetadataValidator }",
            "EntityMetadataValidator",
            "import { DataSourceOptions } from \"./DataSourceOptions\"",
            "{ DataSourceOptions }",
            "{ DataSourceOptions }",
            "DataSourceOptions",
            "import { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\"",
            "{ EntityManagerFactory }",
            "{ EntityManagerFactory }",
            "EntityManagerFactory",
            "import { DriverFactory } from \"../driver/DriverFactory\"",
            "{ DriverFactory }",
            "{ DriverFactory }",
            "DriverFactory",
            "import { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\"",
            "{ ConnectionMetadataBuilder }",
            "{ ConnectionMetadataBuilder }",
            "ConnectionMetadataBuilder",
            "import { QueryRunner } from \"../query-runner/QueryRunner\"",
            "{ QueryRunner }",
            "{ QueryRunner }",
            "QueryRunner",
            "import { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"",
            "{ SelectQueryBuilder }",
            "{ SelectQueryBuilder }",
            "SelectQueryBuilder",
            "import { LoggerFactory } from \"../logger/LoggerFactory\"",
            "{ LoggerFactory }",
            "{ LoggerFactory }",
            "LoggerFactory",
            "import { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\"",
            "{ QueryResultCacheFactory }",
            "{ QueryResultCacheFactory }",
            "QueryResultCacheFactory",
            "import { QueryResultCache } from \"../cache/QueryResultCache\"",
            "{ QueryResultCache }",
            "{ QueryResultCache }",
            "QueryResultCache",
            "import { SqljsEntityManager } from \"../entity-manager/SqljsEntityManager\"",
            "{ SqljsEntityManager }",
            "{ SqljsEntityManager }",
            "SqljsEntityManager",
            "import { RelationLoader } from \"../query-builder/RelationLoader\"",
            "{ RelationLoader }",
            "{ RelationLoader }",
            "RelationLoader",
            "import { ObjectUtils } from \"../util/ObjectUtils\"",
            "{ ObjectUtils }",
            "{ ObjectUtils }",
            "ObjectUtils",
            "import { IsolationLevel } from \"../driver/types/IsolationLevel\"",
            "{ IsolationLevel }",
            "{ IsolationLevel }",
            "IsolationLevel",
            "import { ReplicationMode } from \"../driver/types/ReplicationMode\"",
            "{ ReplicationMode }",
            "{ ReplicationMode }",
            "ReplicationMode",
            "import { RelationIdLoader } from \"../query-builder/RelationIdLoader\"",
            "{ RelationIdLoader }",
            "{ RelationIdLoader }",
            "RelationIdLoader",
            "import { DriverUtils } from \"../driver/DriverUtils\"",
            "{ DriverUtils }",
            "{ DriverUtils }",
            "DriverUtils",
            "import { InstanceChecker } from \"../util/InstanceChecker\"",
            "{ InstanceChecker }",
            "{ InstanceChecker }",
            "InstanceChecker",
            "import { ObjectLiteral } from \"../common/ObjectLiteral\"",
            "{ ObjectLiteral }",
            "{ ObjectLiteral }",
            "ObjectLiteral"
        ],
        "reference_api": [
            "InstanceChecker.isMongoEntityManager"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "InstanceChecker.isMongoEntityManager",
                "code": "m"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "typeorm/typeorm",
        "function_declaration": "async preload<Entity extends ObjectLiteral>(\n        entityClass: EntityTarget<Entity>,\n        entityLike: DeepPartial<Entity>,\n    ): Promise<Entity | undefined>",
        "start_line": "327",
        "end_line": "347",
        "file_path": "src/entity-manager/EntityManager.ts",
        "docstring": "The async function preload(entityClass, entityLike) preloads an entity by transforming a plain object into a database entity.\\nIt retrieves the metadata for the specified entity class and uses PlainObjectToDatabaseEntityTransformer to transform the provided entity-like object.\\nIf the transformation is successful, it merges the transformed entity with the original entity-like object and returns the result.\\nIf the transformation fails, it returns undefined.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4413268e1791",
        "ground_truth": "async preload<Entity extends ObjectLiteral>(\n    entityClass: EntityTarget<Entity>,\n    entityLike: DeepPartial<Entity>,\n): Promise<Entity | undefined> {\n    const metadata = this.connection.getMetadata(entityClass)\n    const plainObjectToDatabaseEntityTransformer =\n        new PlainObjectToDatabaseEntityTransformer(this.connection.manager)\n    const transformedEntity =\n        await plainObjectToDatabaseEntityTransformer.transform(\n            entityLike,\n            metadata,\n        )\n    if (transformedEntity)\n        return this.merge(\n            entityClass as any,\n            transformedEntity as Entity,\n            entityLike,\n        )\n    return undefined\n}",
        "import_statements": [
            "import { DataSource } from \"../data-source/DataSource\"",
            "{ DataSource }",
            "{ DataSource }",
            "DataSource",
            "import { FindManyOptions } from \"../find-options/FindManyOptions\"",
            "{ FindManyOptions }",
            "{ FindManyOptions }",
            "FindManyOptions",
            "import { EntityTarget } from \"../common/EntityTarget\"",
            "{ EntityTarget }",
            "{ EntityTarget }",
            "EntityTarget",
            "import { ObjectType } from \"../common/ObjectType\"",
            "{ ObjectType }",
            "{ ObjectType }",
            "ObjectType",
            "import { EntityNotFoundError } from \"../error/EntityNotFoundError\"",
            "{ EntityNotFoundError }",
            "{ EntityNotFoundError }",
            "EntityNotFoundError",
            "import { QueryRunnerProviderAlreadyReleasedError } from \"../error/QueryRunnerProviderAlreadyReleasedError\"",
            "{ QueryRunnerProviderAlreadyReleasedError }",
            "{ QueryRunnerProviderAlreadyReleasedError }",
            "QueryRunnerProviderAlreadyReleasedError",
            "import { FindOneOptions } from \"../find-options/FindOneOptions\"",
            "{ FindOneOptions }",
            "{ FindOneOptions }",
            "FindOneOptions",
            "import { DeepPartial } from \"../common/DeepPartial\"",
            "{ DeepPartial }",
            "{ DeepPartial }",
            "DeepPartial",
            "import { RemoveOptions } from \"../repository/RemoveOptions\"",
            "{ RemoveOptions }",
            "{ RemoveOptions }",
            "RemoveOptions",
            "import { SaveOptions } from \"../repository/SaveOptions\"",
            "{ SaveOptions }",
            "{ SaveOptions }",
            "SaveOptions",
            "import { NoNeedToReleaseEntityManagerError } from \"../error/NoNeedToReleaseEntityManagerError\"",
            "{ NoNeedToReleaseEntityManagerError }",
            "{ NoNeedToReleaseEntityManagerError }",
            "NoNeedToReleaseEntityManagerError",
            "import { MongoRepository } from \"../repository/MongoRepository\"",
            "{ MongoRepository }",
            "{ MongoRepository }",
            "MongoRepository",
            "import { TreeRepository } from \"../repository/TreeRepository\"",
            "{ TreeRepository }",
            "{ TreeRepository }",
            "TreeRepository",
            "import { Repository } from \"../repository/Repository\"",
            "{ Repository }",
            "{ Repository }",
            "Repository",
            "import { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"",
            "{ FindOptionsUtils }",
            "{ FindOptionsUtils }",
            "FindOptionsUtils",
            "import { PlainObjectToNewEntityTransformer } from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\"",
            "{ PlainObjectToNewEntityTransformer }",
            "{ PlainObjectToNewEntityTransformer }",
            "PlainObjectToNewEntityTransformer",
            "import { PlainObjectToDatabaseEntityTransformer } from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\"",
            "{ PlainObjectToDatabaseEntityTransformer }",
            "{ PlainObjectToDatabaseEntityTransformer }",
            "PlainObjectToDatabaseEntityTransformer",
            "import {\n    CustomRepositoryCannotInheritRepositoryError,\n    CustomRepositoryNotFoundError,\n    TreeRepositoryNotSupportedError,\n    TypeORMError,\n} from \"../error\"",
            "{\n    CustomRepositoryCannotInheritRepositoryError,\n    CustomRepositoryNotFoundError,\n    TreeRepositoryNotSupportedError,\n    TypeORMError,\n}",
            "{\n    CustomRepositoryCannotInheritRepositoryError,\n    CustomRepositoryNotFoundError,\n    TreeRepositoryNotSupportedError,\n    TypeORMError,\n}",
            "CustomRepositoryCannotInheritRepositoryError",
            "CustomRepositoryNotFoundError",
            "TreeRepositoryNotSupportedError",
            "TypeORMError",
            "import { AbstractRepository } from \"../repository/AbstractRepository\"",
            "{ AbstractRepository }",
            "{ AbstractRepository }",
            "AbstractRepository",
            "import { QueryRunner } from \"../query-runner/QueryRunner\"",
            "{ QueryRunner }",
            "{ QueryRunner }",
            "QueryRunner",
            "import { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"",
            "{ SelectQueryBuilder }",
            "{ SelectQueryBuilder }",
            "SelectQueryBuilder",
            "import { QueryDeepPartialEntity } from \"../query-builder/QueryPartialEntity\"",
            "{ QueryDeepPartialEntity }",
            "{ QueryDeepPartialEntity }",
            "QueryDeepPartialEntity",
            "import { EntityPersistExecutor } from \"../persistence/EntityPersistExecutor\"",
            "{ EntityPersistExecutor }",
            "{ EntityPersistExecutor }",
            "EntityPersistExecutor",
            "import { ObjectId } from \"../driver/mongodb/typings\"",
            "{ ObjectId }",
            "{ ObjectId }",
            "ObjectId",
            "import { InsertResult } from \"../query-builder/result/InsertResult\"",
            "{ InsertResult }",
            "{ InsertResult }",
            "InsertResult",
            "import { UpdateResult } from \"../query-builder/result/UpdateResult\"",
            "{ UpdateResult }",
            "{ UpdateResult }",
            "UpdateResult",
            "import { DeleteResult } from \"../query-builder/result/DeleteResult\"",
            "{ DeleteResult }",
            "{ DeleteResult }",
            "DeleteResult",
            "import { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"",
            "{ FindOptionsWhere }",
            "{ FindOptionsWhere }",
            "FindOptionsWhere",
            "import { IsolationLevel } from \"../driver/types/IsolationLevel\"",
            "{ IsolationLevel }",
            "{ IsolationLevel }",
            "IsolationLevel",
            "import { ObjectUtils } from \"../util/ObjectUtils\"",
            "{ ObjectUtils }",
            "{ ObjectUtils }",
            "ObjectUtils",
            "import { getMetadataArgsStorage } from \"../globals\"",
            "{ getMetadataArgsStorage }",
            "{ getMetadataArgsStorage }",
            "getMetadataArgsStorage",
            "import { UpsertOptions } from \"../repository/UpsertOptions\"",
            "{ UpsertOptions }",
            "{ UpsertOptions }",
            "UpsertOptions",
            "import { InstanceChecker } from \"../util/InstanceChecker\"",
            "{ InstanceChecker }",
            "{ InstanceChecker }",
            "InstanceChecker",
            "import { ObjectLiteral } from \"../common/ObjectLiteral\"",
            "{ ObjectLiteral }",
            "{ ObjectLiteral }",
            "ObjectLiteral",
            "import { PickKeysByType } from \"../common/PickKeysByType\"",
            "{ PickKeysByType }",
            "{ PickKeysByType }",
            "PickKeysByType"
        ],
        "reference_api": [
            "this.connection.getMetadata",
            "plainObjectToDatabaseEntityTransformer.transform",
            "this.merge"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.connection.getMetadata",
                "code": "p"
            },
            {
                "name": "plainObjectToDatabaseEntityTransformer.transform",
                "code": "p"
            },
            {
                "name": "this.merge",
                "code": "p"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "upscayl/upscayl",
        "function_declaration": "export function CompressionInput({\n  compression,\n  handleCompressionChange,\n}: CompressionInputProps)",
        "start_line": "6",
        "end_line": "33",
        "file_path": "renderer/components/settings-tab/CompressionInput.tsx",
        "docstring": "The CompressionInput function is a React component that renders a UI for adjusting image compression settings.\\nIt displays the current compression percentage and provides a range input slider for changing the compression value.\\nIf the compression value is greater than 0, it shows a note about the nature of PNG, JPG, and WebP compression.\\nThe handleCompressionChange function is called when the slider value changes.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c635d2b9bbdf",
        "ground_truth": "export function CompressionInput({\n  compression,\n  handleCompressionChange,\n}: CompressionInputProps) {\n  return (\n    <div className=\"flex flex-col gap-2\">\n      <div className=\"flex gap-1 text-sm font-medium uppercase\">\n        <p className=\"shrink-0\">Image Compression ({compression}%)</p>\n      </div>\n      {compression > 0 && (\n        <p className=\"text-xs text-base-content/80\">\n          PNG compression is lossless, so it might not reduce the file size\n          significantly and higher compression values might affect the\n          performance. JPG and WebP compression is lossy.\n        </p>\n      )}\n      <input\n        type=\"range\"\n        placeholder=\"Type here\"\n        className=\"range range-primary w-full max-w-xs\"\n        min={0}\n        max={100}\n        value={compression}\n        onChange={handleCompressionChange}\n      />\n    </div>\n  );\n}",
        "import_statements": [],
        "reference_api": [
            "Compression"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Compression"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "findAttributesWithPrefix(type, name)",
        "start_line": "53",
        "end_line": "64",
        "file_path": "src/becca/becca.js",
        "docstring": "The function findAttributesWithPrefix(type, name) searches for attributes in the attributeIndex that match a specific prefix.\\nIt constructs a key from the given type and name, then iterates through the attributeIndex.\\nIf an index starts with the key, the corresponding attributes are added to a result array.\\nFinally, the function returns a flattened array of the matched attributes.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "636802ba89ba",
        "ground_truth": "findAttributesWithPrefix(type, name) {\n    const resArr = [];\n    const key = `${type}-${name}`;\n    for (const idx in this.attributeIndex) {\n        if (idx.startsWith(key)) {\n            resArr.push(this.attributeIndex[idx]);\n        }\n    }\n    return resArr.flat();\n}",
        "import_statements": [],
        "reference_api": [
            "idx.startsWith",
            "resArr.push",
            "resArr.flat",
            "findAttributesWithPrefix"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "findAttributesWithPrefix",
                "code": "findAttributesWithPrefix(type, name) {\n        const resArr = [];\n        const key = `${type}-${name}`;\n\n        for (const idx in this.attributeIndex) {\n            if (idx.startsWith(key)) {\n                resArr.push(this.attributeIndex[idx]);\n            }\n        }\n\n        return resArr.flat();\n    }"
            }
        ],
        "third_party": [
            "idx.startsWith",
            "resArr.push",
            "resArr.flat"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "function branchUpdated(branchRow)",
        "start_line": "188",
        "end_line": "205",
        "file_path": "src/becca/becca_loader.js",
        "docstring": "The function branchUpdated(branchRow) updates a note branch in the becca.notes collection.\\nIt first retrieves the child note using the noteId from the branchRow.\\nIf the child note exists, it resets its flatTextCache, sorts its parents, and invalidates its subtree.\\nThen, it retrieves the parent note using the parentNoteId from the branchRow.\\nIf the parent note exists, it sorts its children.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5fafa24f5463",
        "ground_truth": "function branchUpdated(branchRow) {\n    const childNote = becca.notes[branchRow.noteId];\n     if (childNote) {\n        childNote.flatTextCache = null;\n        childNote.sortParents();\n         // notes in the subtree can get new inherited attributes\n        // this is in theory needed upon branch creation, but there's no \"create\" event for sync changes\n        childNote.invalidateSubTree();\n    }\n     const parentNote = becca.notes[branchRow.parentNoteId];\n     if (parentNote) {\n        parentNote.sortChildren();\n    }\n}",
        "import_statements": [],
        "reference_api": [
            "childNote.sortParents",
            "parentNote.sortChildren",
            "childNote.invalidateSubTree"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "childNote.sortParents",
            "parentNote.sortChildren",
            "childNote.invalidateSubTree"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "function trimMime(mime)",
        "start_line": "151",
        "end_line": "174",
        "file_path": "src/becca/similarity.js",
        "docstring": "The function trimMime(mime) processes MIME types to generate a simplified version.\\nIf the MIME type is null or 'text/html', it returns immediately.\\nIf the MIME type is not already cached, it splits the MIME type by '/', ignores common prefixes like 'text/' and 'application/', and removes any leading '-x'.\\nThe result is stored in a cache for future use.\\nThe function then returns the cached simplified MIME type.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "80b2322b7b29",
        "ground_truth": "function trimMime(mime) {\n    if (!mime || mime === 'text/html') {\n        return;\n    }\n     if (!(mime in mimeCache)) {\n        const chunks = mime.split('/');\n         let str = \"\";\n         if (chunks.length >= 2) {\n            // we're not interested in 'text/' or 'application/' prefix\n            str = chunks[1];\n             if (str.startsWith('-x')) {\n                str = str.substr(2);\n            }\n        }\n         mimeCache[mime] = str;\n    }\n     return mimeCache[mime];\n}",
        "import_statements": [],
        "reference_api": [
            "str.substr",
            "mime.split",
            "str.startsWith"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "str.substr",
            "mime.split",
            "str.startsWith"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "function buildDateLimits(baseNote)",
        "start_line": "176",
        "end_line": "185",
        "file_path": "src/becca/similarity.js",
        "docstring": "The function buildDateLimits(baseNote) calculates date limits based on the creation date of a note.\\nIt parses the creation date from the baseNote and converts it to a timestamp.\\nThe function then returns an object with four properties: minDate, minExcludedDate, maxExcludedDate, and maxDate, each representing a specific time range around the creation date.\\nThese date limits are formatted as UTC date-time strings.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5d211ed69fed",
        "ground_truth": "function buildDateLimits(baseNote) {\n    const dateCreatedTs = dateUtils.parseDateTime(baseNote.utcDateCreated).getTime();\n     return {\n        minDate: dateUtils.utcDateTimeStr(new Date(dateCreatedTs - 3600 * 1000)),\n        minExcludedDate: dateUtils.utcDateTimeStr(new Date(dateCreatedTs - 5 * 1000)),\n        maxExcludedDate: dateUtils.utcDateTimeStr(new Date(dateCreatedTs + 5 * 1000)),\n        maxDate: dateUtils.utcDateTimeStr(new Date(dateCreatedTs + 3600 * 1000)),\n    };\n}",
        "import_statements": [],
        "reference_api": [
            "dateUtils.utcDateTimeStr",
            "dateUtils.parseDateTime(baseNote.utcDateCreated).getTime",
            "dateUtils.parseDateTime"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "dateUtils.utcDateTimeStr",
            "dateUtils.parseDateTime(baseNote.utcDateCreated).getTime",
            "dateUtils.parseDateTime"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "_setContent(content, opts = {})",
        "start_line": "128",
        "end_line": "166",
        "file_path": "src/becca/entities/abstract_becca_entity.js",
        "docstring": "The function _setContent(content, opts = {}) sets and potentially saves new content for an entity.\\nIt ensures the content is not null or undefined, converting it to a string or buffer if necessary.\\nIt calculates an unencrypted hash for the content and encrypts it if the entity is protected and a protected session is available.\\nThe function then performs a transactional database operation to save the new blob and updates the entity's blob ID if necessary, deleting the old blob if it is no longer used.\\nOptions forceSave and forceFrontendReload control whether the entity is saved and the frontend reloaded, even if the blob ID hasn't changed.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5ef14ada992c",
        "ground_truth": "_setContent(content, opts = {}) {\n    // client code asks to save entity even if blobId didn't change (something else was changed)\n    opts.forceSave = !!opts.forceSave;\n    opts.forceFrontendReload = !!opts.forceFrontendReload;\n    if (content === null || content === undefined) {\n        throw new Error(`Cannot set null content to ${this.constructor.primaryKeyName} '${this[this.constructor.primaryKeyName]}'`);\n    }\n    if (this.hasStringContent()) {\n        content = content.toString();\n    } else {\n        content = Buffer.isBuffer(content) ? content : Buffer.from(content);\n    }\n    const unencryptedContentForHashCalculation = this.#getUnencryptedContentForHashCalculation(content);\n    if (this.isProtected) {\n        if (protectedSessionService.isProtectedSessionAvailable()) {\n            content = protectedSessionService.encrypt(content);\n        } else {\n            throw new Error(`Cannot update content of blob since protected session is not available.`);\n        }\n    }\n    sql.transactional(() => {\n        const newBlobId = this.#saveBlob(content, unencryptedContentForHashCalculation, opts);\n        const oldBlobId = this.blobId;\n        if (newBlobId !== oldBlobId || opts.forceSave) {\n            this.blobId = newBlobId;\n            this.save();\n            if (newBlobId !== oldBlobId) {\n                this.#deleteBlobIfNotUsed(oldBlobId);\n            }\n        }\n    });\n}",
        "import_statements": [],
        "reference_api": [
            "sql.transactional",
            "this.#saveBlob",
            "this.#getUnencryptedContentForHashCalculation",
            "Buffer.from",
            "content.toString",
            "_setContent",
            "protectedSessionService.isProtectedSessionAvailable",
            "Buffer.isBuffer",
            "protectedSessionService.encrypt",
            "this.save",
            "this.#deleteBlobIfNotUsed",
            "this.hasStringContent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.#saveBlob",
                "code": "#saveBlob(content, unencryptedContentForHashCalculation, opts = {}) {\n        /*\n         * We're using the unencrypted blob for the hash calculation, because otherwise the random IV would\n         * cause every content blob to be unique which would balloon the database size (esp. with revisioning).\n         * This has minor security implications (it's easy to infer that given content is shared between different\n         * notes/attachments), but the trade-off comes out clearly positive.\n         */\n        const newBlobId = utils.hashedBlobId(unencryptedContentForHashCalculation);\n        const blobNeedsInsert = !sql.getValue('SELECT 1 FROM blobs WHERE blobId = ?', [newBlobId]);\n\n        if (!blobNeedsInsert) {\n            return newBlobId;\n        }\n\n        const pojo = {\n            blobId: newBlobId,\n            content: content,\n            dateModified: dateUtils.localNowDateTime(),\n            utcDateModified: dateUtils.utcNowDateTime()\n        };\n\n        sql.upsert(\"blobs\", \"blobId\", pojo);\n\n        // we can't reuse blobId as an entity_changes hash, because this one has to be calculatable without having\n        // access to the decrypted content\n        const hash = blobService.calculateContentHash(pojo);\n\n        entityChangesService.putEntityChange({\n            entityName: 'blobs',\n            entityId: newBlobId,\n            hash: hash,\n            isErased: false,\n            utcDateChanged: pojo.utcDateModified,\n            isSynced: true,\n            // overriding componentId will cause the frontend to think the change is coming from a different component\n            // and thus reload\n            componentId: opts.forceFrontendReload ? utils.randomString(10) : null\n        });\n\n        eventService.emit(eventService.ENTITY_CHANGED, {\n            entityName: 'blobs',\n            entity: this\n        });\n\n        return newBlobId;\n    }"
            },
            {
                "name": "this.#getUnencryptedContentForHashCalculation",
                "code": "#getUnencryptedContentForHashCalculation(unencryptedContent) {\n        if (this.isProtected) {\n            // a \"random\" prefix makes sure that the calculated hash/blobId is different for a decrypted/encrypted content\n            const encryptedPrefixSuffix = \"t$[nvQg7q)&_ENCRYPTED_?M:Bf&j3jr_\";\n            return Buffer.isBuffer(unencryptedContent)\n                ? Buffer.concat([Buffer.from(encryptedPrefixSuffix), unencryptedContent])\n                : `${encryptedPrefixSuffix}${unencryptedContent}`;\n        } else {\n            return unencryptedContent;\n        }\n    }"
            },
            {
                "name": "_setContent",
                "code": "_setContent(content, opts = {}) {\n        // client code asks to save entity even if blobId didn't change (something else was changed)\n        opts.forceSave = !!opts.forceSave;\n        opts.forceFrontendReload = !!opts.forceFrontendReload;\n\n        if (content === null || content === undefined) {\n            throw new Error(`Cannot set null content to ${this.constructor.primaryKeyName} '${this[this.constructor.primaryKeyName]}'`);\n        }\n\n        if (this.hasStringContent()) {\n            content = content.toString();\n        } else {\n            content = Buffer.isBuffer(content) ? content : Buffer.from(content);\n        }\n\n        const unencryptedContentForHashCalculation = this.#getUnencryptedContentForHashCalculation(content);\n\n        if (this.isProtected) {\n            if (protectedSessionService.isProtectedSessionAvailable()) {\n                content = protectedSessionService.encrypt(content);\n            } else {\n                throw new Error(`Cannot update content of blob since protected session is not available.`);\n            }\n        }\n\n        sql.transactional(() => {\n            const newBlobId = this.#saveBlob(content, unencryptedContentForHashCalculation, opts);\n            const oldBlobId = this.blobId;\n\n            if (newBlobId !== oldBlobId || opts.forceSave) {\n                this.blobId = newBlobId;\n                this.save();\n\n                if (newBlobId !== oldBlobId) {\n                    this.#deleteBlobIfNotUsed(oldBlobId);\n                }\n            }\n        });\n    }"
            },
            {
                "name": "this.save",
                "code": "save(opts = {}) {\n        const entityName = this.constructor.entityName;\n        const primaryKeyName = this.constructor.primaryKeyName;\n\n        const isNewEntity = !this[primaryKeyName];\n\n        this.beforeSaving(opts);\n\n        const pojo = this.getPojoToSave();\n\n        sql.transactional(() => {\n            sql.upsert(entityName, primaryKeyName, pojo);\n\n            if (entityName === 'recent_notes') {\n                return;\n            }\n\n            this.putEntityChange(!!this.isDeleted);\n\n            if (!cls.isEntityEventsDisabled()) {\n                const eventPayload = {\n                    entityName,\n                    entity: this\n                };\n\n                if (isNewEntity) {\n                    eventService.emit(eventService.ENTITY_CREATED, eventPayload);\n                }\n\n                eventService.emit(eventService.ENTITY_CHANGED, eventPayload);\n            }\n        });\n\n        return this;\n    }"
            },
            {
                "name": "this.#deleteBlobIfNotUsed",
                "code": "#deleteBlobIfNotUsed(oldBlobId) {\n        if (sql.getValue(\"SELECT 1 FROM notes WHERE blobId = ? LIMIT 1\", [oldBlobId])) {\n            return;\n        }\n\n        if (sql.getValue(\"SELECT 1 FROM attachments WHERE blobId = ? LIMIT 1\", [oldBlobId])) {\n            return;\n        }\n\n        if (sql.getValue(\"SELECT 1 FROM revisions WHERE blobId = ? LIMIT 1\", [oldBlobId])) {\n            return;\n        }\n\n        sql.execute(\"DELETE FROM blobs WHERE blobId = ?\", [oldBlobId]);\n        // blobs are not marked as erased in entity_changes, they are just purged completely\n        // this is because technically every keystroke can create a new blob, and there would be just too many\n        sql.execute(\"DELETE FROM entity_changes WHERE entityName = 'blobs' AND entityId = ?\", [oldBlobId]);\n    }"
            }
        ],
        "third_party": [
            "sql.transactional",
            "Buffer.from",
            "content.toString",
            "protectedSessionService.isProtectedSessionAvailable",
            "Buffer.isBuffer",
            "protectedSessionService.encrypt",
            "this.hasStringContent"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "async createNoteIntoInboxCommand()",
        "start_line": "31",
        "end_line": "45",
        "file_path": "src/public/app/components/entrypoints.js",
        "docstring": "The async function createNoteIntoInboxCommand() creates a new note in the inbox.\\nIt first retrieves the inbox note using dateNoteService.\\nThen, it posts a request to the server to create a child note under the inbox note with specific properties such as content, type, and protection status.\\nAfter ensuring the entity change is known, it opens the new note in a tab with hoisting.\\nFinally, it triggers an event to focus and select the title of the new note.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6f76c3417cdb",
        "ground_truth": "async createNoteIntoInboxCommand() {\n    const inboxNote = await dateNoteService.getInboxNote();\n    const {note} = await server.post(`notes/${inboxNote.noteId}/children?target=into`, {\n        content: '',\n        type: 'text',\n        isProtected: inboxNote.isProtected && protectedSessionHolder.isProtectedSessionAvailable()\n    });\n    await ws.waitForMaxKnownEntityChangeId();\n    await appContext.tabManager.openTabWithNoteWithHoisting(note.noteId, {activate: true});\n    appContext.triggerEvent('focusAndSelectTitle', {isNewNote: true});\n}",
        "import_statements": [
            "../services/utils.js",
            "../services/date_notes.js",
            "../services/protected_session_holder.js",
            "../services/server.js",
            "./app_context.js",
            "./component.js",
            "../services/toast.js",
            "../services/ws.js",
            "../services/bundle.js",
            "../services/froca.js",
            "../services/link.js"
        ],
        "reference_api": [
            "appContext.triggerEvent",
            "appContext.tabManager.openTabWithNoteWithHoisting",
            "dateNoteService.getInboxNote",
            "server.post",
            "protectedSessionHolder.isProtectedSessionAvailable",
            "ws.waitForMaxKnownEntityChangeId"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "appContext.triggerEvent",
            "appContext.tabManager.openTabWithNoteWithHoisting",
            "dateNoteService.getInboxNote",
            "server.post",
            "protectedSessionHolder.isProtectedSessionAvailable",
            "ws.waitForMaxKnownEntityChangeId"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": " async toggleNoteHoistingCommand({noteId = appContext.tabManager.getActiveContextNoteId()})",
        "start_line": "47",
        "end_line": "57",
        "file_path": "src/public/app/components/entrypoints.js",
        "docstring": "The async function toggleNoteHoistingCommand({noteId = appContext.tabManager.getActiveContextNoteId()}) toggles the hoisting state of a note.\\nIt retrieves the note to be hoisted and the active note context.\\nIf the note is already hoisted, it unhoists it.\\nIf the note is not a search type, it sets the note as the hoisted note.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2b91c618a874",
        "ground_truth": "async toggleNoteHoistingCommand({noteId = appContext.tabManager.getActiveContextNoteId()}) {\n    const noteToHoist = await froca.getNote(noteId);\n    const activeNoteContext = appContext.tabManager.getActiveContext();\n    if (noteToHoist.noteId === activeNoteContext.hoistedNoteId) {\n        await activeNoteContext.unhoist();\n    }\n    else if (noteToHoist.type !== 'search') {\n        await activeNoteContext.setHoistedNoteId(noteId);\n    }\n}",
        "import_statements": [
            "../services/utils.js",
            "../services/date_notes.js",
            "../services/protected_session_holder.js",
            "../services/server.js",
            "./app_context.js",
            "./component.js",
            "../services/toast.js",
            "../services/ws.js",
            "../services/bundle.js",
            "../services/froca.js",
            "../services/link.js"
        ],
        "reference_api": [
            "froca.getNote",
            "appContext.tabManager.getActiveContextNoteId",
            "activeNoteContext.setHoistedNoteId",
            "appContext.tabManager.getActiveContext",
            "activeNoteContext.unhoist"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "froca.getNote",
            "appContext.tabManager.getActiveContextNoteId",
            "activeNoteContext.setHoistedNoteId",
            "appContext.tabManager.getActiveContext",
            "activeNoteContext.unhoist"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "async openInWindowCommand({notePath, hoistedNoteId, viewScope})",
        "start_line": "139",
        "end_line": "152",
        "file_path": "src/public/app/components/entrypoints.js",
        "docstring": "The async function openInWindowCommand({notePath, hoistedNoteId, viewScope}) generates a unique hash based on the provided parameters.\\nIf running in an Electron environment, it sends a message via ipcRenderer to create a new window with the generated hash.\\nIf not in an Electron environment, it constructs a URL with the hash and opens a new browser window with specified dimensions.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8df5414bda15",
        "ground_truth": "async openInWindowCommand({notePath, hoistedNoteId, viewScope}) {\n    const extraWindowHash = linkService.calculateHash({notePath, hoistedNoteId, viewScope});\n    if (utils.isElectron()) {\n        const {ipcRenderer} = utils.dynamicRequire('electron');\n        ipcRenderer.send('create-extra-window', { extraWindowHash });\n    }\n    else {\n        const url = `${window.location.protocol}//${window.location.host}${window.location.pathname}?extraWindow=1${extraWindowHash}`;\n        window.open(url, '', 'width=1000,height=800');\n    }\n}",
        "import_statements": [
            "../services/utils.js",
            "../services/date_notes.js",
            "../services/protected_session_holder.js",
            "../services/server.js",
            "./app_context.js",
            "./component.js",
            "../services/toast.js",
            "../services/ws.js",
            "../services/bundle.js",
            "../services/froca.js",
            "../services/link.js"
        ],
        "reference_api": [
            "utils.isElectron",
            "async",
            "utils.dynamicRequire",
            "window.open",
            "linkService.calculateHash",
            "ipcRenderer.send"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "utils.isElectron",
            "async",
            "utils.dynamicRequire",
            "window.open",
            "linkService.calculateHash",
            "ipcRenderer.send"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "async runActiveNoteCommand()",
        "start_line": "158",
        "end_line": "182",
        "file_path": "src/public/app/components/entrypoints.js",
        "docstring": "The async function runActiveNoteCommand() retrieves the active context, including ntxId and note, from the tab manager.\\nIt ensures the command runs only for notes of type 'code'.\\nDepending on the note's MIME type, it executes the note in different environments: frontend, backend, or SQLite schema.\\nFor frontend notes, it fetches and executes a bundle.\\nFor backend notes, it posts a script to the server for execution.\\nFor SQLite schema notes, it executes an SQL query and handles the response, showing an error message if the query fails and triggering an event with the results if successful.\\nFinally, it shows a message indicating the note execution.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bd6dc0a79a5b",
        "ground_truth": "async runActiveNoteCommand() {\n    const {ntxId, note} = appContext.tabManager.getActiveContext();\n    // ctrl+enter is also used elsewhere, so make sure we're running only when appropriate\n    if (!note || note.type !== 'code') {\n        return;\n    }\n    // TODO: use note.executeScript()\n    if (note.mime.endsWith(\"env=frontend\")) {\n        await bundleService.getAndExecuteBundle(note.noteId);\n    } else if (note.mime.endsWith(\"env=backend\")) {\n        await server.post(`script/run/${note.noteId}`);\n    } else if (note.mime === 'text/x-sqlite;schema=trilium') {\n        const resp = await server.post(`sql/execute/${note.noteId}`);\n        if (!resp.success) {\n            toastService.showError(`Error occurred while executing SQL query: ${resp.error}`);\n        }\n        await appContext.triggerEvent('sqlQueryResults', {ntxId: ntxId, results: resp.results});\n    }\n    toastService.showMessage(\"Note executed\");\n}",
        "import_statements": [
            "../services/utils.js",
            "../services/date_notes.js",
            "../services/protected_session_holder.js",
            "../services/server.js",
            "./app_context.js",
            "./component.js",
            "../services/toast.js",
            "../services/ws.js",
            "../services/bundle.js",
            "../services/froca.js",
            "../services/link.js"
        ],
        "reference_api": [
            "appContext.triggerEvent",
            "server.post",
            "note.mime.endsWith",
            "toastService.showError",
            "toastService.showMessage",
            "appContext.tabManager.getActiveContext",
            "bundleService.getAndExecuteBundle"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "appContext.triggerEvent",
            "server.post",
            "note.mime.endsWith",
            "toastService.showError",
            "toastService.showMessage",
            "appContext.tabManager.getActiveContext",
            "bundleService.getAndExecuteBundle"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "async isReadOnly()",
        "start_line": "227",
        "end_line": "253",
        "file_path": "src/public/app/components/note_context.js",
        "docstring": "The async function isReadOnly() determines if a note is read-only.\\nIt first checks if read-only mode is temporarily disabled.\\nThen, it verifies if the note exists and is of type 'text' or 'code'.\\nIt returns true if the note has a 'readOnly' label or if the view mode is 'source'.\\nFor other cases, it retrieves the note's blob and compares its content length against a size limit based on the note type.\\nIf the content length exceeds the limit and the 'autoReadOnlyDisabled' label is not set, it returns true; otherwise, it returns false.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "233cf4163968",
        "ground_truth": "async isReadOnly() {\n    if (this.viewScope.readOnlyTemporarilyDisabled) {\n        return false;\n    }\n    // \"readOnly\" is a state valid only for text/code notes\n    if (!this.note || (this.note.type !== 'text' && this.note.type !== 'code')) {\n        return false;\n    }\n    if (this.note.isLabelTruthy('readOnly')) {\n        return true;\n    }\n    if (this.viewScope.viewMode === 'source') {\n        return true;\n    }\n    const blob = await this.note.getBlob();\n    const sizeLimit = this.note.type === 'text'\n        ? options.getInt('autoReadonlySizeText')\n        : options.getInt('autoReadonlySizeCode');\n    return blob.contentLength > sizeLimit\n        && !this.note.isLabelTruthy('autoReadOnlyDisabled');\n}",
        "import_statements": [
            "../services/protected_session_holder.js",
            "../services/server.js",
            "../services/utils.js",
            "./app_context.js",
            "../services/tree.js",
            "./component.js",
            "../services/froca.js",
            "../services/hoisted_note.js",
            "../services/options.js"
        ],
        "reference_api": [
            "options.getInt",
            "this.note.isLabelTruthy",
            "this.note.getBlob"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.note.isLabelTruthy",
                "code": "get note() {\n        if (!this.noteId || !(this.noteId in froca.notes)) {\n            return null;\n        }\n\n        return froca.notes[this.noteId];\n    }"
            },
            {
                "name": "this.note.getBlob",
                "code": "get note() {\n        if (!this.noteId || !(this.noteId in froca.notes)) {\n            return null;\n        }\n\n        return froca.notes[this.noteId];\n    }"
            }
        ],
        "third_party": [
            "options.getInt"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "async openEmptyTab(ntxId = null, hoistedNoteId = 'root', mainNtxId = null)",
        "start_line": "272",
        "end_line": "296",
        "file_path": "src/public/app/components/tab_manager.js",
        "docstring": "The async function openEmptyTab(ntxId = null, hoistedNoteId = 'root', mainNtxId = null) creates or retrieves a note context.\\nIt initializes a new NoteContext with the provided parameters.\\nIt checks if a similar note context already exists, either by getting the active context on mobile or searching among existing children.\\nIf an existing context is found, it updates the hoistedNoteId and returns the existing context.\\nIf no existing context is found, it adds the new context as a child, triggers a 'newNoteContextCreated' event, and returns the new context.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bca77fc5e32c",
        "ground_truth": "async openEmptyTab(ntxId = null, hoistedNoteId = 'root', mainNtxId = null) {\n    const noteContext = new NoteContext(ntxId, hoistedNoteId, mainNtxId);\n    let existingNoteContext;\n    if (utils.isMobile()) {\n        // kind of hacky way to enforce a single tab on mobile interface - all requests to create a new one\n        // are forced to reuse the existing ab instead\n        existingNoteContext = this.getActiveContext();\n    } else {\n        existingNoteContext = this.children.find(nc => nc.ntxId === noteContext.ntxId);\n    }\n    if (existingNoteContext) {\n        await existingNoteContext.setHoistedNoteId(hoistedNoteId);\n        return existingNoteContext;\n    }\n    this.child(noteContext);\n    await this.triggerEvent('newNoteContextCreated', {noteContext});\n    return noteContext;\n}",
        "import_statements": [
            "./component.js",
            "../services/spaced_update.js",
            "../services/server.js",
            "../services/options.js",
            "../services/froca.js",
            "../services/tree.js",
            "../services/utils.js",
            "./note_context.js",
            "./app_context.js",
            "../utils/mutex.js",
            "../services/link.js"
        ],
        "reference_api": [
            "utils.isMobile",
            "this.getActiveContext",
            "existingNoteContext.setHoistedNoteId",
            "async",
            "this.triggerEvent",
            "this.child",
            "this.children.find"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "this.getActiveContext",
                "code": "getActiveContext() {\n        return this.activeNtxId\n            ? this.getNoteContextById(this.activeNtxId)\n            : null;\n    }"
            }
        ],
        "third_party": [
            "utils.isMobile",
            "existingNoteContext.setHoistedNoteId",
            "async",
            "this.triggerEvent",
            "this.child",
            "this.children.find"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "sortChildren()",
        "start_line": "129",
        "end_line": "137",
        "file_path": "src/public/app/entities/fnote.js",
        "docstring": "The function sortChildren() sorts the children of a parent object based on their positions within branches.\\nIt creates an object to store the positions of each branch by iterating over childToBranch values and retrieving their note positions.\\nIt then sorts the children array in ascending order according to these positions.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fa8b5627c077",
        "ground_truth": "sortChildren() {\n    const branchIdPos = {};\n    for (const branchId of Object.values(this.childToBranch)) {\n        branchIdPos[branchId] = this.froca.getBranch(branchId).notePosition;\n    }\n    this.children.sort((a, b) => branchIdPos[this.childToBranch[a]] - branchIdPos[this.childToBranch[b]]);\n}",
        "import_statements": [
            "../services/server.js",
            "../services/note_attribute_cache.js",
            "../services/ws.js",
            "../services/froca.js",
            "../services/protected_session_holder.js",
            "../services/css_class_manager.js"
        ],
        "reference_api": [
            "this.children.sort",
            "sortChildren",
            "this.froca.getBranch",
            "Object.values"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "sortChildren",
                "code": "sortChildren() {\n        const branchIdPos = {};\n\n        for (const branchId of Object.values(this.childToBranch)) {\n            branchIdPos[branchId] = this.froca.getBranch(branchId).notePosition;\n        }\n\n        this.children.sort((a, b) => branchIdPos[this.childToBranch[a]] - branchIdPos[this.childToBranch[b]]);\n    }"
            }
        ],
        "third_party": [
            "this.children.sort",
            "this.froca.getBranch"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "async function moveToParentNote(branchIdsToMove, newParentBranchId)",
        "start_line": "61",
        "end_line": "86",
        "file_path": "src/public/app/services/branches.js",
        "docstring": "The async function moveToParentNote(branchIdsToMove, newParentBranchId) moves branches to a new parent branch.\\nIt retrieves the new parent branch and checks if it is a valid move destination.\\nIt filters the branch IDs to exclude the root note and iterates through each branch to be moved.\\nFor each branch, it skips moving if the branch is the hoisted note or if its parent note is of type 'search'.\\nIt then attempts to move the branch to the new parent branch via a server request.\\nIf the move fails, it shows an error message and stops the process.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "51a1ff6e218f",
        "ground_truth": "async function moveToParentNote(branchIdsToMove, newParentBranchId) {\n    const newParentBranch = froca.getBranch(newParentBranchId);\n     if (newParentBranch.noteId === '_lbRoot') {\n        toastService.showError('Cannot move notes here.');\n        return;\n    }\n     branchIdsToMove = filterRootNote(branchIdsToMove);\n     for (const branchIdToMove of branchIdsToMove) {\n        const branchToMove = froca.getBranch(branchIdToMove);\n         if (branchToMove.noteId === hoistedNoteService.getHoistedNoteId()\n            || (await branchToMove.getParentNote()).type === 'search') {\n            continue;\n        }\n         const resp = await server.put(`branches/${branchIdToMove}/move-to/${newParentBranchId}`);\n         if (!resp.success) {\n            toastService.showError(resp.message);\n            return;\n        }\n    }\n}",
        "import_statements": [
            "./utils.js",
            "./server.js",
            "./toast.js",
            "./froca.js",
            "./hoisted_note.js",
            "./ws.js",
            "../components/app_context.js"
        ],
        "reference_api": [
            "froca.getBranch",
            "hoistedNoteService.getHoistedNoteId",
            "toastService.showError",
            "server.put",
            "filterRootNote",
            "branchToMove.getParentNote"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "filterRootNote",
                "code": "function filterRootNote(branchIds) {\n    const hoistedNoteId = hoistedNoteService.getHoistedNoteId();\n\n    return branchIds.filter(branchId => {\n        const branch = froca.getBranch(branchId);\n\n        return branch.noteId !== 'root'\n            && branch.noteId !== hoistedNoteId;\n    });\n}"
            }
        ],
        "third_party": [
            "froca.getBranch",
            "hoistedNoteService.getHoistedNoteId",
            "toastService.showError",
            "server.put",
            "branchToMove.getParentNote"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "async function activateParentNotePath()",
        "start_line": "144",
        "end_line": "152",
        "file_path": "src/public/app/services/branches.js",
        "docstring": "The async function activateParentNotePath() changes the active note to its parent note.\\nIt retrieves the active context and extracts the parent note path by removing the last element from the current note path array.\\nIf the parent note path exists, it sets the active note to this parent path.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2ffcc8140af6",
        "ground_truth": "async function activateParentNotePath() {\n    // this is not perfect, maybe we should find the next/previous sibling, but that's more complex\n    const activeContext = appContext.tabManager.getActiveContext();\n    const parentNotePathArr = activeContext.notePathArray.slice(0, -1);\n     if (parentNotePathArr.length > 0) {\n        activeContext.setNote(parentNotePathArr.join(\"/\"));\n    }\n}",
        "import_statements": [
            "./utils.js",
            "./server.js",
            "./toast.js",
            "./froca.js",
            "./hoisted_note.js",
            "./ws.js",
            "../components/app_context.js"
        ],
        "reference_api": [
            "parentNotePathArr.join",
            "activeContext.setNote",
            "activeContext.notePathArray.slice",
            "appContext.tabManager.getActiveContext"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "parentNotePathArr.join",
            "activeContext.setNote",
            "activeContext.notePathArray.slice",
            "appContext.tabManager.getActiveContext"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "zadam/trilium",
        "function_declaration": "async function copy(branchIds)",
        "start_line": "64",
        "end_line": "82",
        "file_path": "src/public/app/services/clipboard.js",
        "docstring": "The async function copy(branchIds) copies branches to the clipboard and sets the clipboard mode to 'copy'.\\nIf running in an Electron environment, it uses the Electron clipboard module.\\nFor each branch to be copied, it creates a reference link and collects the HTML representations of these links.\\nIt then writes the HTML links to the clipboard.\\nFinally, it shows a message indicating the branches have been copied to the clipboard.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "04b13e7ad9f6",
        "ground_truth": "async function copy(branchIds) {\n    clipboardBranchIds = branchIds;\n    clipboardMode = 'copy';\n     if (utils.isElectron()) {\n        // https://github.com/zadam/trilium/issues/2401\n        const {clipboard} = require('electron');\n        const links = [];\n         for (const branch of froca.getBranches(clipboardBranchIds)) {\n            const $link = await linkService.createLink(`${branch.parentNoteId}/${branch.noteId}`, { referenceLink: true });\n            links.push($link[0].outerHTML);\n        }\n         clipboard.writeHTML(links.join(', '));\n    }\n     toastService.showMessage(\"Note(s) have been copied into clipboard.\");\n}",
        "import_statements": [
            "./branches.js",
            "./toast.js",
            "./froca.js",
            "./link.js",
            "./utils.js"
        ],
        "reference_api": [
            "linkService.createLink",
            "links.push",
            "require",
            "clipboard.writeHTML",
            "toastService.showMessage",
            "utils.isElectron",
            "links.join",
            "froca.getBranches"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "linkService.createLink",
            "links.push",
            "require",
            "clipboard.writeHTML",
            "toastService.showMessage",
            "utils.isElectron",
            "links.join",
            "froca.getBranches"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "oldj/SwitchHosts",
        "function_declaration": "export const cleanHostsList = (data: IHostsBasicData): IHostsBasicData => 26",
        "start_line": "26",
        "end_line": "44",
        "file_path": "src/common/hostsFn.ts",
        "docstring": "The function cleanHostsList(data) processes a list of hosts data to ensure proper structure.\\nIt flattens the list and iterates through each item.\\nFor items of type 'folder', it initializes the children property as an empty array if it is not already an array.\\nFor items of type 'group', it initializes the include property as an empty array if it is not already an array.\\nFor items of type 'folder' or 'group', it sets the content property to an empty string.\\nFinally, it returns the modified data.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b3a6cce6e5ce",
        "ground_truth": "export const cleanHostsList = (data: IHostsBasicData): IHostsBasicData => {\n  let list = flatten(data.list)\n   list.map((item) => {\n    if (item.type === 'folder' && !Array.isArray(item.children)) {\n      item.children = [] as IHostsListObject[]\n    }\n     if (item.type === 'group' && !Array.isArray(item.include)) {\n      item.include = [] as string[]\n    }\n     if (item.type === 'folder' || item.type === 'group') {\n      item.content = ''\n    }\n  })\n   return data\n}",
        "import_statements": [
            "import { FolderModeType, IHostsBasicData, IHostsListObject } from '@common/data'",
            "{ FolderModeType, IHostsBasicData, IHostsListObject }",
            "{ FolderModeType, IHostsBasicData, IHostsListObject }",
            "FolderModeType",
            "IHostsBasicData",
            "IHostsListObject",
            "import lodash from 'lodash'",
            "lodash"
        ],
        "reference_api": [
            "Array.isArray"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "oldj/SwitchHosts",
        "function_declaration": "const addHistory = async (content: string) =>",
        "start_line": "45",
        "end_line": "64",
        "file_path": "src/main/actions/hosts/setSystemHosts.ts",
        "docstring": "The async function addHistory(content: string) adds a new entry to the history collection in the database.\\nIt inserts a record with a unique ID, the provided content, and the current timestamp.\\nThe function retrieves the history limit configuration and checks if it is a valid number greater than zero.\\nIf the number of history records exceeds the limit, it deletes the oldest entries until the limit is met.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a494fe11a98c",
        "ground_truth": "const addHistory = async (content: string) => {\n  await swhdb.collection.history.insert({\n    id: uuid4(),\n    content,\n    add_time_ms: new Date().getTime(),\n  })\n   let history_limit = await configGet('history_limit')\n  if (typeof history_limit !== 'number' || history_limit <= 0) return\n   let lists = await swhdb.collection.history.all<IHostsHistoryObject>()\n  if (lists.length <= history_limit) {\n    return\n  }\n   for (let i = 0; i < lists.length - history_limit; i++) {\n    if (!lists[i] || !lists[i].id) break\n    await deleteHistory(lists[i].id)\n  }\n}",
        "import_statements": [
            "import { configGet, deleteHistory, getHistoryList, updateTrayTitle } from '@main/actions'",
            "{ configGet, deleteHistory, getHistoryList, updateTrayTitle }",
            "{ configGet, deleteHistory, getHistoryList, updateTrayTitle }",
            "configGet",
            "deleteHistory",
            "getHistoryList",
            "updateTrayTitle",
            "import tryToRun from '@main/actions/cmd/tryToRun'",
            "tryToRun",
            "import { broadcast } from '@main/core/agent'",
            "{ broadcast }",
            "{ broadcast }",
            "broadcast",
            "import { swhdb } from '@main/data'",
            "{ swhdb }",
            "{ swhdb }",
            "swhdb",
            "import safePSWD from '@main/libs/safePSWD'",
            "safePSWD",
            "import { IHostsWriteOptions } from '@main/types'",
            "{ IHostsWriteOptions }",
            "{ IHostsWriteOptions }",
            "IHostsWriteOptions",
            "import { IHostsHistoryObject } from '@common/data'",
            "{ IHostsHistoryObject }",
            "{ IHostsHistoryObject }",
            "IHostsHistoryObject",
            "import events from '@common/events'",
            "events",
            "import { exec } from 'child_process'",
            "{ exec }",
            "{ exec }",
            "exec",
            "import * as fs from 'fs'",
            "* as fs",
            "* as fs",
            "import md5 from 'md5'",
            "md5",
            "import md5File from 'md5-file'",
            "md5File",
            "import * as os from 'os'",
            "* as os",
            "* as os",
            "import * as path from 'path'",
            "* as path",
            "* as path",
            "import { v4 as uuid4 } from 'uuid'",
            "{ v4 as uuid4 }",
            "{ v4 as uuid4 }",
            "v4 as uuid4",
            "import getPathOfSystemHosts from './getPathOfSystemHostsPath'",
            "getPathOfSystemHosts"
        ],
        "reference_api": [
            "uuid4",
            "deleteHistory",
            "await swhdb.collection.history.all",
            "swhdb.collection.history.insert",
            "configGet",
            "new Date().getTime"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "uuid4",
                "code": "s"
            },
            {
                "name": "deleteHistory",
                "code": "s"
            },
            {
                "name": "await swhdb.collection.history.all",
                "code": "s"
            },
            {
                "name": "swhdb.collection.history.insert",
                "code": "s"
            },
            {
                "name": "configGet",
                "code": "s"
            },
            {
                "name": "new Date().getTime",
                "code": "s"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "oldj/SwitchHosts",
        "function_declaration": "const readOldData = async (): Promise<IHostsBasicData> =>",
        "start_line": "17",
        "end_line": "37",
        "file_path": "src/main/actions/migrate/migrateData.ts",
        "docstring": "The async function readOldData() retrieves and processes old data from a JSON file.\\nIt constructs the file path using the data folder location and a predefined filename.\\nIt defines a default data structure to return if the file does not exist.\\nIf the file exists, it reads the file content and attempts to parse it as JSON.\\nIf parsing is successful, it returns the cleaned data; otherwise, it logs an error and returns the default data structure.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bd1413e33a8a",
        "ground_truth": "const readOldData = async (): Promise<IHostsBasicData> => {\n  const fn = path.join(await getDataFolder(), 'data.json')\n  const default_data: IHostsBasicData = {\n    list: [],\n    trashcan: [],\n    version: version as VersionType,\n  }\n   if (!fs.existsSync(fn)) {\n    return default_data\n  }\n   let content = await fs.promises.readFile(fn, 'utf-8')\n  try {\n    let data = JSON.parse(content) as IHostsBasicData\n    return cleanHostsList(data)\n  } catch (e) {\n    console.error(e)\n    return default_data\n  }\n}",
        "import_statements": [
            "import importV3Data from '@main/actions/migrate/importV3Data'",
            "importV3Data",
            "import getDataFolder from '@main/libs/getDataDir'",
            "getDataFolder",
            "import { IHostsBasicData, VersionType } from '@common/data'",
            "{ IHostsBasicData, VersionType }",
            "{ IHostsBasicData, VersionType }",
            "IHostsBasicData",
            "VersionType",
            "import { cleanHostsList } from '@common/hostsFn'",
            "{ cleanHostsList }",
            "{ cleanHostsList }",
            "cleanHostsList",
            "import version from '@/version.json'",
            "version",
            "import * as fs from 'fs'",
            "* as fs",
            "* as fs",
            "import path from 'path'",
            "path"
        ],
        "reference_api": [
            "fs.promises.readFile",
            "console.error",
            "JSON.parse",
            "getDataFolder",
            "fs.existsSync",
            "cleanHostsList",
            "path.join"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "fs.promises.readFile",
                "code": "s"
            },
            {
                "name": "getDataFolder",
                "code": "s"
            },
            {
                "name": "fs.existsSync",
                "code": "s"
            },
            {
                "name": "cleanHostsList",
                "code": "s"
            },
            {
                "name": "path.join",
                "code": "s"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "oldj/SwitchHosts",
        "function_declaration": "async function getSwhDb(): Promise<PotDb>",
        "start_line": "35",
        "end_line": "45",
        "file_path": "src/main/data/index.ts",
        "docstring": "The async function getSwhDb() initializes and returns the swhdb database instance.\\nIf swhdb is not already initialized, it retrieves the data directory path from local storage and sets the global data_dir.\\nIt then constructs the database directory path and creates a new PotDb instance with this path, logging the directory path.\\nThe global swhdb is set to this new instance.\\nFinally, the function returns the swhdb instance.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1a746af7c945",
        "ground_truth": "async function getSwhDb(): Promise<PotDb> {\n  if (!swhdb) {\n    global.data_dir = await localdb.dict.local.get('data_dir')\n    let db_dir: string = path.join(getDataFolder(), 'data')\n    swhdb = new PotDb(db_dir)\n    console.log(`data db: ${swhdb.dir}`)\n    global.swhdb = swhdb\n  }\n   return swhdb\n}",
        "import_statements": [
            "import * as path from 'path'",
            "* as path",
            "* as path",
            "import PotDb from 'potdb'",
            "PotDb",
            "import { app } from 'electron'",
            "{ app }",
            "{ app }",
            "app",
            "import getDataFolder from '@main/libs/getDataDir'",
            "getDataFolder",
            "import getConfigFolder from '@main/libs/getConfigDir'",
            "getConfigFolder"
        ],
        "reference_api": [
            "console.log",
            "getDataFolder",
            "localdb.dict.local.get",
            "path.join"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getDataFolder",
            "localdb.dict.local.get",
            "path.join"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "oldj/SwitchHosts",
        "function_declaration": "const isNeedRefresh = (hosts: IHostsListObject): boolean => ",
        "start_line": "16",
        "end_line": "31",
        "file_path": "src/main/libs/cron.ts",
        "docstring": "The function isNeedRefresh(hosts: IHostsListObject): boolean determines if a refresh is needed based on certain conditions.\\nIt checks the refresh interval and URL validity, returning false if either is invalid.\\nIf there is no last refresh timestamp, it returns true.\\nIt calculates the time elapsed since the last refresh and returns true if it exceeds the refresh interval.\\nOtherwise, it returns false.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "375d71e6f391",
        "ground_truth": "const isNeedRefresh = (hosts: IHostsListObject): boolean => {\n  let { refresh_interval, last_refresh_ms, url } = hosts\n   if (!refresh_interval || refresh_interval <= 0) return false\n  if (!url || !url.match(/^https?:\\/\\//i)) return false\n   if (!last_refresh_ms) return true\n   let ts = new Date().getTime()\n  if ((ts - last_refresh_ms) / 1000 >= refresh_interval) {\n    return true\n  }\n   // false\n  return false\n}",
        "import_statements": [
            "import { checkUpdate, configGet, getList, refreshHosts } from '@main/actions'",
            "{ checkUpdate, configGet, getList, refreshHosts }",
            "{ checkUpdate, configGet, getList, refreshHosts }",
            "checkUpdate",
            "configGet",
            "getList",
            "refreshHosts",
            "import { broadcast } from '@main/core/agent'",
            "{ broadcast }",
            "{ broadcast }",
            "broadcast",
            "import { IHostsListObject } from '@common/data'",
            "{ IHostsListObject }",
            "{ IHostsListObject }",
            "IHostsListObject",
            "import events from '@common/events'",
            "events",
            "import { flatten } from '@common/hostsFn'",
            "{ flatten }",
            "{ flatten }",
            "flatten"
        ],
        "reference_api": [
            "new Date().getTime",
            "url.match"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "new Date().getTime",
                "code": "h"
            },
            {
                "name": "url.match",
                "code": "h"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "oldj/SwitchHosts",
        "function_declaration": "const callAction = (action: keyof Actions, ...params: any[]) => ",
        "start_line": "24",
        "end_line": "42",
        "file_path": "src/main/preload.ts",
        "docstring": "The function callAction(action: keyof Actions, ...params: any[]) sends an action request via ipcRenderer and returns a promise.\\nIt generates a unique callback identifier and sends a message with the action and parameters.\\nIt listens for a response using the callback identifier and resolves the promise with the response data if successful or rejects it with an error if there is a failure.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e9824782738b",
        "ground_truth": "const callAction = (action: keyof Actions, ...params: any[]) => {\n  const callback = ['_cb', new Date().getTime(), x_get_idx++].join('_')\n   return new Promise((resolve, reject) => {\n    ipcRenderer.send('x_action', {\n      action,\n      data: params,\n      callback,\n    })\n     ipcRenderer.once(callback, (sender, err, d) => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve(d)\n      }\n    })\n  })\n}",
        "import_statements": [
            "import { Actions } from '@common/types'",
            "{ Actions }",
            "{ Actions }",
            "Actions",
            "import { IPopupMenuOption } from '@common/types'",
            "{ IPopupMenuOption }",
            "{ IPopupMenuOption }",
            "IPopupMenuOption",
            "import { contextBridge, ipcRenderer } from 'electron'",
            "{ contextBridge, ipcRenderer }",
            "{ contextBridge, ipcRenderer }",
            "contextBridge",
            "ipcRenderer",
            "import { EventEmitter } from 'events'",
            "{ EventEmitter }",
            "{ EventEmitter }",
            "EventEmitter"
        ],
        "reference_api": [
            "reject",
            "resolve"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "reject",
                "code": "a"
            },
            {
                "name": "resolve",
                "code": "a"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Electron",
        "owner/repo": "oldj/SwitchHosts",
        "function_declaration": "const loadContent = async (is_new = false) =>",
        "start_line": "36",
        "end_line": "50",
        "file_path": "src/renderer/components/Editor/HostsEditor.tsx",
        "docstring": "The async function loadContent(is_new = false) loads and sets content into a CodeMirror editor.\\nIt checks if the editor is available, and if not, retries after a short delay.\\nIt retrieves the content based on the hosts_id, either fetching the system hosts or specific hosts content.\\nThe function sets the retrieved content and updates the editor's value.\\nIf the is_new flag is true, it clears the editor's history.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "027bc2903865",
        "ground_truth": "const loadContent = async (is_new = false) => {\n  let cm_editor = ref_cm.current\n  if (!cm_editor) {\n    setTimeout(loadContent, 100)\n    return\n  }\n  let content =\n    hosts_id === '0' ? await actions.getSystemHosts() : await actions.getHostsContent(hosts_id)\n  setContent(content)\n  cm_editor.setValue(content)\n  if (is_new) {\n    cm_editor.clearHistory()\n  }\n}",
        "import_statements": [
            "@renderer/components/StatusBar",
            "@renderer/core/agent",
            "@renderer/core/useOnBroadcast",
            "@common/data",
            "@common/events",
            "@common/types",
            "@common/utils/wait",
            "ahooks",
            "clsx",
            "codemirror",
            "codemirror/addon/comment/comment",
            "codemirror/addon/selection/mark-selection",
            "react",
            "./cm_hl",
            "./codemirror.module.scss",
            "./HostsEditor.module.scss",
            "@renderer/models/useHostsData"
        ],
        "reference_api": [
            "setTimeout",
            "cm_editor.setValue",
            "cm_editor.clearHistory",
            "setContent",
            "actions.getSystemHosts",
            "actions.getHostsContent"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cm_editor.setValue",
            "cm_editor.clearHistory",
            "setContent",
            "actions.getSystemHosts",
            "actions.getHostsContent"
        ]
    },
    {
        "subclass": "Electron",
        "owner/repo": "oldj/SwitchHosts",
        "function_declaration": "const onGutterClick = (n: number) =>",
        "start_line": "93",
        "end_line": "111",
        "file_path": "src/renderer/components/Editor/HostsEditor.tsx",
        "docstring": "The function onGutterClick(n: number) handles click events on the gutter of a code editor.\\nIt checks if the editor is in read-only mode or if the editor instance is unavailable and returns early if so.\\nIt retrieves information about the clicked line and ignores lines that are empty or whitespace.\\nThe function toggles a comment on the line: if the line starts with a comment character, it removes it; otherwise, it adds a comment character at the beginning.\\nThe modified line replaces the original line in the editor.",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "199f8fb90016",
        "ground_truth": "const onGutterClick = (n: number) => {\n  let cm_editor = ref_cm.current\n  if (is_read_only || !cm_editor) return\n  let info = cm_editor.lineInfo(n)\n  let line = info.text\n  if (/^\\s*$/.test(line)) return\n  let new_line: string\n  if (/^#/.test(line)) {\n    new_line = line.replace(/^#\\s*/, '')\n  } else {\n    new_line = '# ' + line\n  }\n  cm_editor\n    .getDoc()\n    .replaceRange(new_line, { line: info.line, ch: 0 }, { line: info.line, ch: line.length })\n}",
        "import_statements": [
            "import StatusBar from '@renderer/components/StatusBar'",
            "StatusBar",
            "import { actions, agent } from '@renderer/core/agent'",
            "{ actions, agent }",
            "{ actions, agent }",
            "actions",
            "agent",
            "import useOnBroadcast from '@renderer/core/useOnBroadcast'",
            "useOnBroadcast",
            "import { IHostsListObject } from '@common/data'",
            "{ IHostsListObject }",
            "{ IHostsListObject }",
            "IHostsListObject",
            "import events from '@common/events'",
            "events",
            "import { IFindShowSourceParam } from '@common/types'",
            "{ IFindShowSourceParam }",
            "{ IFindShowSourceParam }",
            "IFindShowSourceParam",
            "import wait from '@common/utils/wait'",
            "wait",
            "import { useDebounceFn } from 'ahooks'",
            "{ useDebounceFn }",
            "{ useDebounceFn }",
            "useDebounceFn",
            "import clsx from 'clsx'",
            "clsx",
            "import CodeMirror from 'codemirror'",
            "CodeMirror",
            "import 'codemirror/addon/comment/comment'",
            "import 'codemirror/addon/selection/mark-selection'",
            "import React, { useEffect, useRef, useState } from 'react'",
            "React, { useEffect, useRef, useState }",
            "{ useEffect, useRef, useState }",
            "useEffect",
            "useRef",
            "useState",
            "import modeHosts from './cm_hl'",
            "modeHosts",
            "import './codemirror.module.scss'",
            "import styles from './HostsEditor.module.scss'",
            "styles",
            "import useHostsData from '@renderer/models/useHostsData'",
            "useHostsData"
        ],
        "reference_api": [
            "line.replace",
            "cm_editor.lineInfo",
            "/^\\s*$/.test",
            "cm_editor\n      .getDoc()\n      .replaceRange",
            "cm_editor\n      .getDoc",
            "/^#/.test"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "line.replace",
                "code": "s"
            },
            {
                "name": "cm_editor.lineInfo",
                "code": "s"
            },
            {
                "name": "/^\\s*$/.test",
                "code": "s"
            },
            {
                "name": "cm_editor\n      .getDoc()\n      .replaceRange",
                "code": "s"
            },
            {
                "name": "cm_editor\n      .getDoc",
                "code": "s"
            },
            {
                "name": "/^#/.test",
                "code": "s"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "bool CommandLineParser::parse(const QStringList& args)",
        "start_line": "188",
        "end_line": "226",
        "file_path": "src/cli/commandlineparser.cpp",
        "docstring": "The function parse(const QStringList& args) processes command-line arguments and options.\\nIt begins by clearing previous arguments and options, then initializes variables for parsing.\\nIf a version option is detected, it prints the version and exits if there are no additional arguments, otherwise it returns an error.\\nIt checks for the help option and processes other arguments, distinguishing between options (starting with a dash) and regular arguments.\\nIf any errors occur during processing, it outputs a general error message.\\nFinally, it returns a boolean indicating the success or failure of the parsing process.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "000e8aa4c16c",
        "ground_truth": "bool CommandLineParser::parse(const QStringList& args)\n{\n    m_foundArgs.clear();\n    m_foundOptions.clear();\n    bool ok = true;\n    Node* actualNode = &m_parseTree;\n    auto it = ++args.cbegin();\n    // check  version option\n    QStringList dashedVersion = versionOption.dashedNames();\n    if (m_withVersion && args.length() > 1 &&\n        dashedVersion.contains(args.at(1))) {\n        if (args.length() == 2) {\n            printVersion();\n            m_foundOptions << versionOption;\n        } else {\n            err << \"Invalid arguments after the version option.\";\n            ok = false;\n        }\n        return ok;\n    }\n    // check  help option\n    ok = processIfOptionIsHelp(args, it, actualNode);\n    // process the other args\n    for (; it != args.cend() && ok; ++it) {\n        const QString& val = *it;\n        if (val.startsWith(QLatin1String(\"-\"))) {\n            ok = processOptions(args, it, actualNode);\n         } else {\n            ok = processArgs(args, it, actualNode);\n        }\n    }\n    if (!ok && !m_generalErrorMessage.isEmpty()) {\n        err.enableMessageHeader(false);\n        err << m_generalErrorMessage;\n        err.enableMessageHeader(true);\n    }\n    return ok;\n}",
        "import_statements": [
            "#include \"commandlineparser.h\"\n",
            "#include \"abstractlogger.h\"\n",
            "#include \"src/utils/globalvalues.h\"\n",
            "#include <QApplication>\n",
            "#include <QTextStream>\n"
        ],
        "reference_api": [
            "dashedVersion.contains",
            "processOptions",
            "printVersion",
            "QLatin1String",
            "args.cbegin",
            "args.cend",
            "processArgs",
            "args.length",
            "m_foundOptions.clear",
            "versionOption.dashedNames",
            "err.enableMessageHeader",
            "m_generalErrorMessage.isEmpty",
            "val.startsWith",
            "processIfOptionIsHelp",
            "args.at",
            "m_foundArgs.clear"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "processOptions",
                "code": "bool CommandLineParser::processOptions(const QStringList& args,\n                                       QStringList::const_iterator& actualIt,\n                                       Node* const actualNode)\n{\n    QString arg = *actualIt;\n    bool ok = true;\n    // track values\n    int equalsPos = arg.indexOf(QLatin1String(\"=\"));\n    QString valueStr;\n    if (equalsPos != -1) {\n        valueStr = arg.mid(equalsPos + 1); // right\n        arg = arg.mid(0, equalsPos);       // left\n    }\n    // check format -x --xx...\n    bool isDoubleDashed = arg.startsWith(QLatin1String(\"--\"));\n    ok = isDoubleDashed ? arg.length() > 3 : arg.length() == 2;\n    if (!ok) {\n        err << QStringLiteral(\"the option %1 has a wrong format.\").arg(arg);\n        return ok;\n    }\n    arg = isDoubleDashed ? arg.remove(0, 2) : arg.remove(0, 1);\n    // get option\n    auto endIt = actualNode->options.cend();\n    auto optionIt = endIt;\n    for (auto i = actualNode->options.cbegin(); i != endIt; ++i) {\n        if ((*i).names().contains(arg)) {\n            optionIt = i;\n            break;\n        }\n    }\n    if (optionIt == endIt) {\n        QString argName = actualNode->argument.name();\n        if (argName.isEmpty()) {\n            argName = qApp->applicationName();\n        }\n        err << QStringLiteral(\"the option '%1' is not a valid option \"\n                              \"for the argument '%2'.\")\n                 .arg(arg)\n                 .arg(argName);\n        ok = false;\n        return ok;\n    }\n    // check presence of values\n    CommandOption option = *optionIt;\n    bool requiresValue = !(option.valueName().isEmpty());\n    if (!requiresValue && equalsPos != -1) {\n        err << QStringLiteral(\"the option '%1' contains a '=' and it doesn't \"\n                              \"require a value.\")\n                 .arg(arg);\n        ok = false;\n        return ok;\n    } else if (requiresValue && valueStr.isEmpty()) {\n        // find in the next\n        if (actualIt + 1 != args.cend()) {\n            ++actualIt;\n        } else {\n            err << QStringLiteral(\"Expected value after the option '%1'.\")\n                     .arg(arg);\n            ok = false;\n            return ok;\n        }\n        valueStr = *actualIt;\n    }\n    // check the value correctness\n    if (requiresValue) {\n        ok = option.checkValue(valueStr);\n        if (!ok) {\n            QString msg = option.errorMsg();\n            if (!msg.endsWith(QLatin1String(\".\"))) {\n                msg += QLatin1String(\".\");\n            }\n            err << msg;\n            return ok;\n        }\n        option.setValue(valueStr);\n    }\n    m_foundOptions.append(option);\n    return ok;\n}"
            },
            {
                "name": "printVersion",
                "code": "void CommandLineParser::printVersion()\n{\n    out << GlobalValues::versionInfo();\n}"
            },
            {
                "name": "processArgs",
                "code": "bool CommandLineParser::processArgs(const QStringList& args,\n                                    QStringList::const_iterator& actualIt,\n                                    Node*& actualNode)\n{\n    QString argument = *actualIt;\n    bool ok = true;\n    bool isValidArg = false;\n    for (Node& n : actualNode->subNodes) {\n        if (n.argument.name() == argument) {\n            actualNode = &n;\n            isValidArg = true;\n            break;\n        }\n    }\n    if (isValidArg) {\n        auto nextArg = actualNode->argument;\n        m_foundArgs.append(nextArg);\n        // check next is help\n        ++actualIt;\n        ok = processIfOptionIsHelp(args, actualIt, actualNode);\n        --actualIt;\n    } else {\n        ok = false;\n        err << QStringLiteral(\"'%1' is not a valid argument.\").arg(argument);\n    }\n    return ok;\n}"
            },
            {
                "name": "processIfOptionIsHelp",
                "code": "bool CommandLineParser::processIfOptionIsHelp(\n  const QStringList& args,\n  QStringList::const_iterator& actualIt,\n  Node*& actualNode)\n{\n    bool ok = true;\n    auto dashedHelpNames = helpOption.dashedNames();\n    if (m_withHelp && actualIt != args.cend() &&\n        dashedHelpNames.contains(*actualIt)) {\n        if (actualIt + 1 == args.cend()) {\n            m_foundOptions << helpOption;\n            printHelp(args, actualNode);\n            actualIt++;\n        } else {\n            err << \"Invalid arguments after the help option.\";\n            ok = false;\n        }\n    }\n    return ok;\n}"
            }
        ],
        "third_party": [
            "dashedVersion.contains",
            "QLatin1String",
            "args.cbegin",
            "args.cend",
            "args.length",
            "m_foundOptions.clear",
            "versionOption.dashedNames",
            "err.enableMessageHeader",
            "m_generalErrorMessage.isEmpty",
            "val.startsWith",
            "args.at",
            "m_foundArgs.clear"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "void ButtonListView::updateComponents()",
        "start_line": "86",
        "end_line": "99",
        "file_path": "src/config/buttonlistview.cpp",
        "docstring": "The function ButtonListView::updateComponents() updates the state of list items based on the current configuration.\\nIt retrieves a list of button types from the configuration and an iterable list of button types from CaptureToolButton.\\nFor each item in the list, it checks if the corresponding button type is in the configuration list.\\nIf it is, the item's check state is set to checked; otherwise, it is set to unchecked.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2f02436b366f",
        "ground_truth": "void ButtonListView::updateComponents()\n{\n    m_listButtons = ConfigHandler().buttons();\n    auto listTypes = CaptureToolButton::getIterableButtonTypes();\n    for (int i = 0; i < this->count(); ++i) {\n        QListWidgetItem* item = this->item(i);\n        auto elem = static_cast<CaptureTool::Type>(listTypes.at(i));\n        if (m_listButtons.contains(elem)) {\n            item->setCheckState(Qt::Checked);\n        } else {\n            item->setCheckState(Qt::Unchecked);\n        }\n    }\n}",
        "import_statements": [
            "#include \"buttonlistview.h\"\n",
            "#include \"src/tools/toolfactory.h\"\n",
            "#include \"src/utils/confighandler.h\"\n",
            "#include <QListWidgetItem>\n",
            "#include <algorithm>\n"
        ],
        "reference_api": [
            "CaptureToolButton::getIterableButtonTypes",
            "ConfigHandler",
            "static_cast<CaptureTool::Type>",
            "item->setCheckState",
            "this->count",
            "m_listButtons.contains",
            "this->item",
            "listTypes.at",
            "ConfigHandler().buttons"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ConfigHandler",
                "code": "ConfigHandler::ConfigHandler()\n  : m_settings(QSettings::IniFormat,\n               QSettings::UserScope,\n               qApp->organizationName(),\n               qApp->applicationName())\n{\n    static bool firstInitialization = true;\n    if (firstInitialization) {\n        // check for error every time the file changes\n        m_configWatcher.reset(new QFileSystemWatcher());\n        ensureFileWatched();\n        QObject::connect(m_configWatcher.data(),\n                         &QFileSystemWatcher::fileChanged,\n                         [](const QString& fileName) {\n                             emit getInstance()->fileChanged();\n\n                             if (QFile(fileName).exists()) {\n                                 m_configWatcher->addPath(fileName);\n                             }\n                             if (m_skipNextErrorCheck) {\n                                 m_skipNextErrorCheck = false;\n                                 return;\n                             }\n                             ConfigHandler().checkAndHandleError();\n                             if (!QFile(fileName).exists()) {\n                                 // File watcher stops watching a deleted file.\n                                 // Next time the config is accessed, force it\n                                 // to check for errors (and watch again).\n                                 m_errorCheckPending = true;\n                             }\n                         });\n    }\n    firstInitialization = false;\n}"
            }
        ],
        "third_party": [
            "CaptureToolButton::getIterableButtonTypes",
            "static_cast<CaptureTool::Type>",
            "item->setCheckState",
            "this->count",
            "m_listButtons.contains",
            "this->item",
            "listTypes.at",
            "ConfigHandler().buttons"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "void ColorPickerEditor::addPreset()",
        "start_line": "119",
        "end_line": "138",
        "file_path": "src/config/colorpickereditor.cpp",
        "docstring": "The function addPreset() in ColorPickerEditor adds a new color to the preset list.\\nIt first checks if the color is already in the list and returns if it is.\\nIt then checks if the list has reached the maximum allowed presets (17).\\nIf the limit is reached, it displays an error message and returns.\\nIf the color is not in the list and the limit is not reached, it adds the color to the list and updates the user color configuration.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "578e98634572",
        "ground_truth": "void ColorPickerEditor::addPreset()\n{\n    if (m_colorList.contains(m_color)) {\n        return;\n    }\n     const int maxPresetsAllowed = 17;\n     if (m_colorList.size() >= maxPresetsAllowed) {\n        QMessageBox::critical(\n          this,\n          tr(\"Error\"),\n          tr(\"Unable to add preset. Maximum limit reached.\"));\n        return;\n    }\n     m_colorList << m_color;\n     m_config.setUserColors(m_colorList);\n}",
        "import_statements": [
            "#include \"colorpickereditor.h\"\n",
            "#include \"colorpickereditmode.h\"\n",
            "#include \"src/utils/globalvalues.h\"\n",
            "#include <QApplication>\n",
            "#include <QColor>\n",
            "#include <QGridLayout>\n",
            "#include <QHBoxLayout>\n",
            "#include <QLabel>\n",
            "#include <QLineEdit>\n",
            "#include <QMessageBox>\n",
            "#include <QPushButton>\n",
            "#include <QString>\n",
            "#include <QVector>\n"
        ],
        "reference_api": [
            "m_colorList.contains",
            "m_config.setUserColors",
            "QMessageBox::critical",
            "m_colorList.size",
            "tr"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "m_colorList.contains",
            "m_config.setUserColors",
            "QMessageBox::critical",
            "m_colorList.size",
            "tr"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "UIcolorEditor::UIcolorEditor(QWidget* parent)\n  : QWidget(parent)",
        "start_line": "15",
        "end_line": "34",
        "file_path": "src/config/uicoloreditor.cpp",
        "docstring": "The UIcolorEditor constructor initializes a UI color editor widget.\\nIt sets the size policy to expand, creates horizontal and vertical layouts, and configures spacing using font metrics.\\nThe function aligns the vertical layout to the center, initializes buttons and a color wheel, adds spacing to the vertical layout, integrates it into the horizontal layout, and sets the main layout for the widget.\\nFinally, it updates the components.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3f8c1770cd2e",
        "ground_truth": "UIcolorEditor::UIcolorEditor(QWidget* parent)\n  : QWidget(parent)\n{\n    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n    m_hLayout = new QHBoxLayout;\n    m_vLayout = new QVBoxLayout;\n     const int space = QApplication::fontMetrics().lineSpacing();\n    m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding));\n    m_vLayout->setAlignment(Qt::AlignVCenter);\n     initButtons();\n    initColorWheel();\n     m_vLayout->addSpacing(space);\n    m_hLayout->addLayout(m_vLayout);\n    m_hLayout->addItem(new QSpacerItem(space, space, QSizePolicy::Expanding));\n    setLayout(m_hLayout);\n    updateComponents();\n}",
        "import_statements": [
            "#include \"uicoloreditor.h\"\n",
            "#include \"clickablelabel.h\"\n",
            "#include \"src/utils/confighandler.h\"\n",
            "#include \"src/utils/globalvalues.h\"\n",
            "#include <QApplication>\n",
            "#include <QComboBox>\n",
            "#include <QHBoxLayout>\n",
            "#include <QMap>\n",
            "#include <QSpacerItem>\n",
            "#include <QVBoxLayout>\n"
        ],
        "reference_api": [
            "QApplication::fontMetrics",
            "initButtons",
            "m_vLayout->addSpacing",
            "updateComponents",
            "QApplication::fontMetrics().lineSpacing",
            "setSizePolicy",
            "m_vLayout->setAlignment",
            "setLayout",
            "m_hLayout->addItem",
            "m_hLayout->addLayout",
            "initColorWheel"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "initButtons",
                "code": "void UIcolorEditor::initButtons()\n{\n    const int extraSize = GlobalValues::buttonBaseSize() / 3;\n    int frameSize = GlobalValues::buttonBaseSize() + extraSize;\n\n    m_vLayout->addWidget(new QLabel(tr(\"Select a Button to modify it\"), this));\n\n    auto* frame = new QGroupBox();\n    frame->setFixedSize(frameSize, frameSize);\n\n    m_buttonMainColor = new CaptureToolButton(m_buttonIconType, frame);\n    m_buttonMainColor->move(m_buttonMainColor->x() + extraSize / 2,\n                            m_buttonMainColor->y() + extraSize / 2);\n    auto* h1 = new QHBoxLayout();\n    h1->addWidget(frame);\n    m_labelMain = new ClickableLabel(tr(\"Main Color\"), this);\n    h1->addWidget(m_labelMain);\n    m_vLayout->addLayout(h1);\n\n    m_buttonMainColor->setToolTip(tr(\"Click on this button to set the edition\"\n                                     \" mode of the main color.\"));\n\n    auto* frame2 = new QGroupBox();\n    m_buttonContrast = new CaptureToolButton(m_buttonIconType, frame2);\n    m_buttonContrast->move(m_buttonContrast->x() + extraSize / 2,\n                           m_buttonContrast->y() + extraSize / 2);\n\n    auto* h2 = new QHBoxLayout();\n    h2->addWidget(frame2);\n    frame2->setFixedSize(frameSize, frameSize);\n    m_labelContrast = new ClickableLabel(tr(\"Contrast Color\"), this);\n    m_labelContrast->setStyleSheet(QStringLiteral(\"color : gray\"));\n    h2->addWidget(m_labelContrast);\n    m_vLayout->addLayout(h2);\n\n    m_buttonContrast->setToolTip(tr(\"Click on this button to set the edition\"\n                                    \" mode of the contrast color.\"));\n\n    connect(m_buttonMainColor,\n            &CaptureToolButton::pressedButtonLeftClick,\n            this,\n            &UIcolorEditor::changeLastButton);\n    connect(m_buttonContrast,\n            &CaptureToolButton::pressedButtonLeftClick,\n            this,\n            &UIcolorEditor::changeLastButton);\n    // clicking the labels changes the button too\n    connect(m_labelMain, &ClickableLabel::clicked, this, [this] {\n        changeLastButton(m_buttonMainColor);\n    });\n    connect(m_labelContrast, &ClickableLabel::clicked, this, [this] {\n        changeLastButton(m_buttonContrast);\n    });\n    m_lastButtonPressed = m_buttonMainColor;\n}"
            },
            {
                "name": "updateComponents",
                "code": "void UIcolorEditor::updateComponents()\n{\n    ConfigHandler config;\n    m_uiColor = config.uiColor();\n    m_contrastColor = config.contrastUiColor();\n    m_buttonContrast->setColor(m_contrastColor);\n    m_buttonMainColor->setColor(m_uiColor);\n    if (m_lastButtonPressed == m_buttonMainColor) {\n        m_colorWheel->setColor(m_uiColor);\n    } else {\n        m_colorWheel->setColor(m_contrastColor);\n    }\n}"
            },
            {
                "name": "initColorWheel",
                "code": "void UIcolorEditor::initColorWheel()\n{\n    m_colorWheel = new color_widgets::ColorWheel(this);\n    connect(m_colorWheel,\n            &color_widgets::ColorWheel::colorSelected,\n            this,\n            &UIcolorEditor::updateUIcolor);\n    connect(m_colorWheel,\n            &color_widgets::ColorWheel::colorChanged,\n            this,\n            &UIcolorEditor::updateLocalColor);\n\n    const int size = GlobalValues::buttonBaseSize() * 3;\n    m_colorWheel->setMinimumSize(size, size);\n    m_colorWheel->setMaximumSize(size * 2, size * 2);\n    m_colorWheel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n    m_colorWheel->setToolTip(tr(\"Change the color moving the selectors and see\"\n                                \" the changes in the preview buttons.\"));\n\n    m_hLayout->addWidget(m_colorWheel);\n}"
            }
        ],
        "third_party": [
            "QApplication::fontMetrics",
            "m_vLayout->addSpacing",
            "QApplication::fontMetrics().lineSpacing",
            "setSizePolicy",
            "m_vLayout->setAlignment",
            "setLayout",
            "m_hLayout->addItem",
            "m_hLayout->addLayout"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "void Flameshot::full(const CaptureRequest& req)",
        "start_line": "180",
        "end_line": "198",
        "file_path": "src/core/flameshot.cpp",
        "docstring": "The function Flameshot::full(const CaptureRequest& req) captures a screenshot of the entire desktop.\\nIt first checks for any configuration errors and returns if any are found.\\nIf no errors exist, it grabs the entire desktop as a QPixmap object.\\nIf an initial selection region is specified in the request, it copies that region from the screenshot.\\nIf the screenshot is successful, it exports the capture; otherwise, it emits a captureFailed signal.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ad86ef280917",
        "ground_truth": "void Flameshot::full(const CaptureRequest& req)\n{\n    if (!resolveAnyConfigErrors()) {\n        return;\n    }\n     bool ok = true;\n    QPixmap p(ScreenGrabber().grabEntireDesktop(ok));\n    QRect region = req.initialSelection();\n    if (!region.isNull()) {\n        p = p.copy(region);\n    }\n    if (ok) {\n        QRect selection; // `flameshot full` does not support --selection\n        exportCapture(p, selection, req);\n    } else {\n        emit captureFailed();\n    }\n}",
        "import_statements": [
            "#include \"flameshot.h\"\n",
            "#include \"flameshotdaemon.h\"\n",
            "#include \"abstractlogger.h\"\n",
            "#include \"screenshotsaver.h\"\n",
            "#include \"src/config/configresolver.h\"\n",
            "#include \"src/config/configwindow.h\"\n",
            "#include \"src/core/qguiappcurrentscreen.h\"\n",
            "#include \"src/tools/imgupload/imguploadermanager.h\"\n",
            "#include \"src/tools/imgupload/storages/imguploaderbase.h\"\n",
            "#include \"src/utils/confighandler.h\"\n",
            "#include \"src/utils/screengrabber.h\"\n",
            "#include \"src/widgets/capture/capturewidget.h\"\n",
            "#include \"src/widgets/capturelauncher.h\"\n",
            "#include \"src/widgets/imguploaddialog.h\"\n",
            "#include \"src/widgets/infowindow.h\"\n",
            "#include \"src/widgets/uploadhistory.h\"\n",
            "#include <QApplication>\n",
            "#include <QBuffer>\n",
            "#include <QDebug>\n",
            "#include <QDesktopServices>\n",
            "#include <QDesktopWidget>\n",
            "#include <QFile>\n",
            "#include <QMessageBox>\n",
            "#include <QThread>\n",
            "#include <QTimer>\n",
            "#include <QUrl>\n",
            "#include <QVersionNumber>\n"
        ],
        "reference_api": [
            "exportCapture",
            "ScreenGrabber",
            "req.initialSelection",
            "p.copy",
            "resolveAnyConfigErrors",
            "region.isNull",
            "ScreenGrabber().grabEntireDesktop"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "exportCapture",
                "code": "void Flameshot::exportCapture(const QPixmap& capture,\n                              QRect& selection,\n                              const CaptureRequest& req)\n{\n    using CR = CaptureRequest;\n    int tasks = req.tasks(), mode = req.captureMode();\n    QString path = req.path();\n\n    if (tasks & CR::PRINT_GEOMETRY) {\n        QByteArray byteArray;\n        QBuffer buffer(&byteArray);\n        QTextStream(stdout)\n          << selection.width() << \"x\" << selection.height() << \"+\"\n          << selection.x() << \"+\" << selection.y() << \"\\n\";\n    }\n\n    if (tasks & CR::PRINT_RAW) {\n        QByteArray byteArray;\n        QBuffer buffer(&byteArray);\n        capture.save(&buffer, \"PNG\");\n        QFile file;\n        file.open(stdout, QIODevice::WriteOnly);\n\n        file.write(byteArray);\n        file.close();\n    }\n\n    if (tasks & CR::SAVE) {\n        if (req.path().isEmpty()) {\n            saveToFilesystemGUI(capture);\n        } else {\n            saveToFilesystem(capture, path);\n        }\n    }\n\n    if (tasks & CR::COPY) {\n        FlameshotDaemon::copyToClipboard(capture);\n    }\n\n    if (tasks & CR::PIN) {\n        FlameshotDaemon::createPin(capture, selection);\n        if (mode == CR::SCREEN_MODE || mode == CR::FULLSCREEN_MODE) {\n            AbstractLogger::info()\n              << QObject::tr(\"Full screen screenshot pinned to screen\");\n        }\n    }\n\n    if (tasks & CR::UPLOAD) {\n        if (!ConfigHandler().uploadWithoutConfirmation()) {\n            auto* dialog = new ImgUploadDialog();\n            if (dialog->exec() == QDialog::Rejected) {\n                return;\n            }\n        }\n\n        ImgUploaderBase* widget = ImgUploaderManager().uploader(capture);\n        widget->show();\n        widget->activateWindow();\n        // NOTE: lambda can't capture 'this' because it might be destroyed later\n        CR::ExportTask tasks = tasks;\n        QObject::connect(\n          widget, &ImgUploaderBase::uploadOk, [=](const QUrl& url) {\n              if (ConfigHandler().copyURLAfterUpload()) {\n                  if (!(tasks & CR::COPY)) {\n                      FlameshotDaemon::copyToClipboard(\n                        url.toString(), tr(\"URL copied to clipboard.\"));\n                  }\n                  widget->showPostUploadDialog();\n              }\n          });\n    }\n\n    if (!(tasks & CR::UPLOAD)) {\n        emit captureTaken(capture);\n    }\n}"
            },
            {
                "name": "ScreenGrabber",
                "code": "ScreenGrabber::ScreenGrabber(QObject* parent)\n  : QObject(parent)\n{}"
            },
            {
                "name": "resolveAnyConfigErrors",
                "code": "bool Flameshot::resolveAnyConfigErrors()\n{\n    bool resolved = true;\n    ConfigHandler confighandler;\n    if (!confighandler.checkUnrecognizedSettings() ||\n        !confighandler.checkSemantics()) {\n        auto* resolver = new ConfigResolver();\n        QObject::connect(\n          resolver, &ConfigResolver::rejected, [resolver, &resolved]() {\n              resolved = false;\n              resolver->deleteLater();\n              if (origin() == CLI) {\n                  exit(1);\n              }\n          });\n        QObject::connect(\n          resolver, &ConfigResolver::accepted, [resolver, &resolved]() {\n              resolved = true;\n              resolver->close();\n              resolver->deleteLater();\n              // Ensure that the dialog is closed before starting capture\n              qApp->processEvents();\n          });\n        resolver->exec();\n        qApp->processEvents();\n    }\n    return resolved;\n}"
            }
        ],
        "third_party": [
            "req.initialSelection",
            "p.copy",
            "region.isNull",
            "ScreenGrabber().grabEntireDesktop"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "void FlameshotDaemon::copyToClipboard(const QPixmap& capture)",
        "start_line": "125",
        "end_line": "141",
        "file_path": "src/core/flameshotdaemon.cpp",
        "docstring": "The function copyToClipboard(const QPixmap& capture) copies a QPixmap capture to the clipboard.\\nIf an instance exists, it uses the instance to attach the screenshot to the clipboard.\\nIf no instance exists, it creates a D-Bus message to call the attachScreenshotToClipboard method, serializes the QPixmap data, adds it to the message, and sends the call.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "42abe47d0da0",
        "ground_truth": "void FlameshotDaemon::copyToClipboard(const QPixmap& capture)\n{\n    if (instance()) {\n        instance()->attachScreenshotToClipboard(capture);\n        return;\n    }\n     QDBusMessage m =\n      createMethodCall(QStringLiteral(\"attachScreenshotToClipboard\"));\n     QByteArray data;\n    QDataStream stream(&data, QIODevice::WriteOnly);\n    stream << capture;\n     m << data;\n    call(m);\n}",
        "import_statements": [
            "#include \"flameshotdaemon.h\"\n",
            "#include \"abstractlogger.h\"\n",
            "#include \"confighandler.h\"\n",
            "#include \"flameshot.h\"\n",
            "#include \"pinwidget.h\"\n",
            "#include \"screenshotsaver.h\"\n",
            "#include \"src/utils/globalvalues.h\"\n",
            "#include \"src/widgets/capture/capturewidget.h\"\n",
            "#include \"src/widgets/trayicon.h\"\n",
            "#include <QApplication>\n",
            "#include <QClipboard>\n",
            "#include <QDBusConnection>\n",
            "#include <QDBusMessage>\n",
            "#include <QPixmap>\n",
            "#include <QRect>\n"
        ],
        "reference_api": [
            "call",
            "createMethodCall",
            "instance()->attachScreenshotToClipboard",
            "instance",
            "QStringLiteral"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "call",
                "code": "void FlameshotDaemon::call(const QDBusMessage& m)\n{\n    QDBusConnection sessionBus = QDBusConnection::sessionBus();\n    checkDBusConnection(sessionBus);\n    sessionBus.call(m);\n}"
            },
            {
                "name": "createMethodCall",
                "code": "QDBusMessage FlameshotDaemon::createMethodCall(const QString& method)\n{\n    QDBusMessage m =\n      QDBusMessage::createMethodCall(QStringLiteral(\"org.flameshot.Flameshot\"),\n                                     QStringLiteral(\"/\"),\n                                     QLatin1String(\"\"),\n                                     method);\n    return m;\n}"
            }
        ],
        "third_party": [
            "instance()->attachScreenshotToClipboard",
            "instance",
            "QStringLiteral"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "void FlameshotDaemon::attachTextToClipboard(const QString& text,\n                                            const QString& notification)",
        "start_line": "307",
        "end_line": "324",
        "file_path": "src/core/flameshotdaemon.cpp",
        "docstring": "The function attachTextToClipboard(const QString& text, const QString& notification) attaches text to the clipboard and optionally logs a notification.\\nIf a notification is provided, it logs the notification before modifying the clipboard, especially for Linux systems.\\nIt sets a flag indicating the clipboard is being hosted, retrieves the clipboard instance, blocks its signals, sets the clipboard text, and then unblocks the signals.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4276c0025e1f",
        "ground_truth": "void FlameshotDaemon::attachTextToClipboard(const QString& text,\n                                            const QString& notification)\n{\n    // Must send notification before clipboard modification on linux\n    if (!notification.isEmpty()) {\n        AbstractLogger::info() << notification;\n    }\n     m_hostingClipboard = true;\n    QClipboard* clipboard = QApplication::clipboard();\n     clipboard->blockSignals(true);\n    // This variable is necessary because the signal doesn't get blocked on\n    // windows for some reason\n    m_clipboardSignalBlocked = true;\n    clipboard->setText(text);\n    clipboard->blockSignals(false);\n}",
        "import_statements": [
            "#include \"flameshotdaemon.h\"\n",
            "#include \"abstractlogger.h\"\n",
            "#include \"confighandler.h\"\n",
            "#include \"flameshot.h\"\n",
            "#include \"pinwidget.h\"\n",
            "#include \"screenshotsaver.h\"\n",
            "#include \"src/utils/globalvalues.h\"\n",
            "#include \"src/widgets/capture/capturewidget.h\"\n",
            "#include \"src/widgets/trayicon.h\"\n",
            "#include <QApplication>\n",
            "#include <QClipboard>\n",
            "#include <QDBusConnection>\n",
            "#include <QDBusMessage>\n",
            "#include <QPixmap>\n",
            "#include <QRect>\n"
        ],
        "reference_api": [
            "AbstractLogger::info",
            "QApplication::clipboard",
            "clipboard->blockSignals",
            "notification.isEmpty",
            "clipboard->setText"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "AbstractLogger::info",
            "QApplication::clipboard",
            "clipboard->blockSignals",
            "notification.isEmpty",
            "clipboard->setText"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "void AcceptTool::pressed(CaptureContext& context)",
        "start_line": "49",
        "end_line": "58",
        "file_path": "src/tools/accept/accepttool.cpp",
        "docstring": "The pressed function in AcceptTool handles the press event for the capture tool.\\nIt emits a request to indicate the capture is done.\\nIf the capture request includes a PIN task, it adjusts the selection geometry based on the widget offset and adds the PIN task to the request.\\nFinally, it emits a request to close the GUI.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ef69a941bff6",
        "ground_truth": "void AcceptTool::pressed(CaptureContext& context)\n{\n    emit requestAction(REQ_CAPTURE_DONE_OK);\n    if (context.request.tasks() & CaptureRequest::PIN) {\n        QRect geometry = context.selection;\n        geometry.moveTopLeft(geometry.topLeft() + context.widgetOffset);\n        context.request.addTask(CaptureRequest::PIN);\n    }\n    emit requestAction(REQ_CLOSE_GUI);\n}",
        "import_statements": [
            "#include \"accepttool.h\"\n",
            "#include \"src/utils/screenshotsaver.h\"\n",
            "#include <QApplication>\n",
            "#include <QPainter>\n",
            "#include <QStyle>\n"
        ],
        "reference_api": [
            "context.request.tasks",
            "geometry.topLeft",
            "context.request.addTask",
            "geometry.moveTopLeft"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "context.request.tasks",
            "geometry.topLeft",
            "context.request.addTask",
            "geometry.moveTopLeft"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "int DesktopFileParser::processDirectory(const QDir& dir)",
        "start_line": "106",
        "end_line": "124",
        "file_path": "src/utils/desktopfileparse.cpp",
        "docstring": "The function processDirectory(const QDir& dir) processes a directory to parse and add desktop files to an application list.\\nIt retrieves a list of \"*.desktop\" files in the directory, excluding dot entries.\\nIt tracks the initial length of the application list and iterates through each desktop file, parsing it into a DesktopAppData object.\\nIf parsing is successful, the application data is appended to the list.\\nThe function returns the number of new entries added to the application list.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "954477282486",
        "ground_truth": "int DesktopFileParser::processDirectory(const QDir& dir)\n{\n    // Note that\n    // https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html\n    // says files must end in .desktop or .directory\n    // So filtering by .desktop stops us reading things like editor backups\n    // .kdelnk is long deprecated\n    QStringList entries =\n      dir.entryList({ \"*.desktop\" }, QDir::NoDotAndDotDot | QDir::Files);\n    bool ok;\n    int length = m_appList.length();\n    for (const QString& file : entries) {\n        DesktopAppData app = parseDesktopFile(dir.absoluteFilePath(file), ok);\n        if (ok) {\n            m_appList.append(app);\n        }\n    }\n    return m_appList.length() - length;\n}",
        "import_statements": [
            "#include \"desktopfileparse.h\"\n",
            "#include <QDir>\n",
            "#include <QFile>\n",
            "#include <QLocale>\n",
            "#include <QString>\n",
            "#include <QTextStream>\n"
        ],
        "reference_api": [
            "parseDesktopFile",
            "dir.entryList",
            "m_appList.length",
            "dir.absoluteFilePath",
            "m_appList.append"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "parseDesktopFile",
                "code": "DesktopAppData DesktopFileParser::parseDesktopFile(const QString& fileName,\n                                                   bool& ok) const\n{\n    DesktopAppData res;\n    ok = true;\n    QFile file(fileName);\n    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        ok = false;\n        return res;\n    }\n    bool nameLocaleSet = false;\n    bool descriptionLocaleSet = false;\n    bool isApplication = false;\n    bool isService = false;\n    QTextStream in(&file);\n    // enter the desktop entry definition\n    while (!in.atEnd() && in.readLine() != QLatin1String(\"[Desktop Entry]\")) {\n    }\n    // start parsing\n    while (!in.atEnd()) {\n        QString line = in.readLine();\n        if (line.startsWith(QLatin1String(\"Icon\"))) {\n            res.icon = QIcon::fromTheme(\n              line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(),\n              m_defaultIcon);\n        } else if (!nameLocaleSet && line.startsWith(QLatin1String(\"Name\"))) {\n            if (line.startsWith(m_localeName) ||\n                line.startsWith(m_localeNameShort)) {\n                res.name =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n                nameLocaleSet = true;\n            } else if (line.startsWith(QLatin1String(\"Name=\"))) {\n                res.name =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n            }\n        } else if (!descriptionLocaleSet &&\n                   line.startsWith(QLatin1String(\"Comment\"))) {\n            if (line.startsWith(m_localeDescription) ||\n                line.startsWith(m_localeDescriptionShort)) {\n                res.description =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n                descriptionLocaleSet = true;\n            } else if (line.startsWith(QLatin1String(\"Comment=\"))) {\n                res.description =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n            }\n        } else if (line.startsWith(QLatin1String(\"Exec\"))) {\n            if (line.contains(QLatin1String(\"%\"))) {\n                res.exec =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n            } else {\n                ok = false;\n                break;\n            }\n        } else if (line.startsWith(QLatin1String(\"Type\"))) {\n            if (line.contains(QLatin1String(\"Application\"))) {\n                isApplication = true;\n            }\n            if (line.contains(QLatin1String(\"Service\"))) {\n                isService = true;\n            }\n        } else if (line.startsWith(QLatin1String(\"Categories\"))) {\n            res.categories = line.mid(line.indexOf(QLatin1String(\"=\")) + 1)\n                               .split(QStringLiteral(\";\"));\n        } else if (line == QLatin1String(\"NoDisplay=true\")) {\n            ok = false;\n            break;\n        } else if (line == QLatin1String(\"Terminal=true\")) {\n            res.showInTerminal = true;\n        }\n        // ignore the other entries\n        else if (line.startsWith(QLatin1String(\"[\"))) {\n            break;\n        }\n    }\n    file.close();\n    if (res.exec.isEmpty() || res.name.isEmpty() ||\n        (!isApplication && !isService)) {\n        ok = false;\n    }\n    return res;\n}"
            }
        ],
        "third_party": [
            "dir.entryList",
            "m_appList.length",
            "dir.absoluteFilePath",
            "m_appList.append"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "QMap<QString, QVector<DesktopAppData>> DesktopFileParser::getAppsByCategory(\n  const QStringList& categories)",
        "start_line": "138",
        "end_line": "150",
        "file_path": "src/utils/desktopfileparse.cpp",
        "docstring": "The function getAppsByCategory(categories) groups desktop applications by specified categories.\\nIt initializes a QMap to store the results.\\nFor each application in the internal app list, it checks if the application's categories match any of the provided categories.\\nIf a match is found, the application is added to the corresponding category in the QMap.\\nThe function returns the QMap containing the grouped applications.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e17fc5c9d6d0",
        "ground_truth": "QMap<QString, QVector<DesktopAppData>> DesktopFileParser::getAppsByCategory(\n  const QStringList& categories)\n{\n    QMap<QString, QVector<DesktopAppData>> res;\n    for (const DesktopAppData& app : qAsConst(m_appList)) {\n        for (const QString& category : categories) {\n            if (app.categories.contains(category)) {\n                res[category].append(app);\n            }\n        }\n    }\n    return res;\n}",
        "import_statements": [
            "#include \"desktopfileparse.h\"\n",
            "#include <QDir>\n",
            "#include <QFile>\n",
            "#include <QLocale>\n",
            "#include <QString>\n",
            "#include <QTextStream>\n"
        ],
        "reference_api": [
            "res[category].append",
            "app.categories.contains",
            "qAsConst"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "res[category].append",
            "app.categories.contains",
            "qAsConst"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "flameshot-org/flameshot",
        "function_declaration": "bool saveToFilesystem(const QPixmap& capture,\n                      const QString& path,\n                      const QString& messagePrefix)",
        "start_line": "30",
        "end_line": "69",
        "file_path": "src/utils/screenshotsaver.cpp",
        "docstring": "The function saveToFilesystem(const QPixmap& capture, const QString& path, const QString& messagePrefix) saves a QPixmap capture to the specified file path.\\nIt generates a complete file path using properScreenshotPath and sets the file extension.\\nThe function opens the file for writing and determines the save format based on the file extension, using a specific quality setting for JPEG files.\\nIt constructs a save message, adding the file path and success or error information.\\nIf saving is successful, it logs an info message; otherwise, it logs an error message with details.\\nThe function returns a boolean indicating the success of the save operation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1e9cb2fcafe5",
        "ground_truth": "bool saveToFilesystem(const QPixmap& capture,\n                      const QString& path,\n                      const QString& messagePrefix)\n{\n    QString completePath = FileNameHandler().properScreenshotPath(\n      path, ConfigHandler().saveAsFileExtension());\n    QFile file{ completePath };\n    file.open(QIODevice::WriteOnly);\n     bool okay;\n    QString saveExtension;\n    saveExtension = QFileInfo(completePath).suffix().toLower();\n    if (saveExtension == \"jpg\" || saveExtension == \"jpeg\") {\n        okay = capture.save(&file, nullptr, ConfigHandler().jpegQuality());\n    } else {\n        okay = capture.save(&file);\n    }\n     QString saveMessage = messagePrefix;\n    QString notificationPath = completePath;\n    if (!saveMessage.isEmpty()) {\n        saveMessage += \" \";\n    }\n     if (okay) {\n        saveMessage += QObject::tr(\"Capture saved as \") + completePath;\n        AbstractLogger::info().attachNotificationPath(notificationPath)\n          << saveMessage;\n    } else {\n        saveMessage += QObject::tr(\"Error trying to save as \") + completePath;\n        if (file.error() != QFile::NoError) {\n            saveMessage += \": \" + file.errorString();\n        }\n        notificationPath = \"\";\n        AbstractLogger::error().attachNotificationPath(notificationPath)\n          << saveMessage;\n    }\n     return okay;\n}",
        "import_statements": [
            "#include \"screenshotsaver.h\"\n",
            "#include \"abstractlogger.h\"\n",
            "#include \"src/core/flameshot.h\"\n",
            "#include \"src/core/flameshotdaemon.h\"\n",
            "#include \"src/utils/confighandler.h\"\n",
            "#include \"src/utils/filenamehandler.h\"\n",
            "#include \"src/utils/globalvalues.h\"\n",
            "#include \"utils/desktopinfo.h\"\n",
            "#include <QApplication>\n",
            "#include <QBuffer>\n",
            "#include <QClipboard>\n",
            "#include <QFileDialog>\n",
            "#include <QMessageBox>\n",
            "#include <QMimeData>\n",
            "#include <QStandardPaths>\n",
            "#include <qimagewriter.h>\n",
            "#include <qmimedatabase.h>\n"
        ],
        "reference_api": [
            "AbstractLogger::info",
            "capture.save",
            "ConfigHandler",
            "QObject::tr",
            "QFileInfo(completePath).suffix().toLower",
            "AbstractLogger::info().attachNotificationPath",
            "saveMessage.isEmpty",
            "file.error",
            "QFileInfo",
            "AbstractLogger::error",
            "file.errorString",
            "FileNameHandler().properScreenshotPath",
            "ConfigHandler().jpegQuality",
            "FileNameHandler",
            "AbstractLogger::error().attachNotificationPath",
            "file.open",
            "ConfigHandler().saveAsFileExtension",
            "QFileInfo(completePath).suffix"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ConfigHandler",
                "code": "ConfigHandler::ConfigHandler()\n  : m_settings(QSettings::IniFormat,\n               QSettings::UserScope,\n               qApp->organizationName(),\n               qApp->applicationName())\n{\n    static bool firstInitialization = true;\n    if (firstInitialization) {\n        // check for error every time the file changes\n        m_configWatcher.reset(new QFileSystemWatcher());\n        ensureFileWatched();\n        QObject::connect(m_configWatcher.data(),\n                         &QFileSystemWatcher::fileChanged,\n                         [](const QString& fileName) {\n                             emit getInstance()->fileChanged();\n\n                             if (QFile(fileName).exists()) {\n                                 m_configWatcher->addPath(fileName);\n                             }\n                             if (m_skipNextErrorCheck) {\n                                 m_skipNextErrorCheck = false;\n                                 return;\n                             }\n                             ConfigHandler().checkAndHandleError();\n                             if (!QFile(fileName).exists()) {\n                                 // File watcher stops watching a deleted file.\n                                 // Next time the config is accessed, force it\n                                 // to check for errors (and watch again).\n                                 m_errorCheckPending = true;\n                             }\n                         });\n    }\n    firstInitialization = false;\n}"
            },
            {
                "name": "FileNameHandler",
                "code": "FileNameHandler::FileNameHandler(QObject* parent)\n  : QObject(parent)\n{\n    auto err = AbstractLogger::error(AbstractLogger::Stderr);\n    try {\n        std::locale::global(std::locale());\n    } catch (std::exception& e) {\n        err << \"Locales on your system are not properly configured. Falling \"\n               \"back to defaults\";\n\n        std::locale::global(std::locale(\"en_US.UTF-8\"));\n    }\n}"
            }
        ],
        "third_party": [
            "AbstractLogger::info",
            "capture.save",
            "QObject::tr",
            "QFileInfo(completePath).suffix().toLower",
            "AbstractLogger::info().attachNotificationPath",
            "saveMessage.isEmpty",
            "file.error",
            "QFileInfo",
            "AbstractLogger::error",
            "file.errorString",
            "FileNameHandler().properScreenshotPath",
            "ConfigHandler().jpegQuality",
            "AbstractLogger::error().attachNotificationPath",
            "file.open",
            "ConfigHandler().saveAsFileExtension",
            "QFileInfo(completePath).suffix"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "SFTtech/openage",
        "function_declaration": "void ModManager::activate_modpacks(const std::vector<std::string> &load_order) ",
        "start_line": "22",
        "end_line": "33",
        "file_path": "libopenage/assets/mod_manager.cpp",
        "docstring": "The function activate_modpacks(const std::vector<std::string> &load_order) sets the load order for modpacks.\\nIt clears any currently active modpacks and iterates through the provided load order.\\nFor each modpack ID, it retrieves the corresponding modpack from the available modpacks and activates it by adding it to the active modpacks.\\nA log message is generated for each activated modpack.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ba67f6b4e974",
        "ground_truth": "void ModManager::activate_modpacks(const std::vector<std::string> &load_order) {\n this->set_load_order(load_order);\n  // Clear in case there are already active modpacks\n this->active.clear();\n  for (const auto &modpack_id : load_order) {\n  auto &modpack = this->available.at(modpack_id);\n  this->active.emplace(modpack_id, std::make_shared<Modpack>(modpack));\n  log::log(MSG(info) << \"Activated modpack: \" << modpack_id);\n }\n}",
        "import_statements": [
            "#include \"mod_manager.h\"\n",
            "#include <unordered_set>\n"
        ],
        "reference_api": [
            "this->set_load_order",
            "MSG",
            "this->available.at",
            "this->active.emplace",
            "this->active.clear",
            "std::make_shared<Modpack>",
            "log::log"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->set_load_order",
            "MSG",
            "this->available.at",
            "this->active.emplace",
            "this->active.clear"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "SFTtech/openage",
        "function_declaration": "void ModManager::set_load_order(const std::vector<std::string> &load_order) ",
        "start_line": "35",
        "end_line": "61",
        "file_path": "libopenage/assets/mod_manager.cpp",
        "docstring": "The function set_load_order(const std::vector<std::string> &load_order) sets the load order of modpacks.\\nIt creates a set of requested modpacks from the load_order vector.\\nThe function checks if each modpack in the load order is available and verifies that all dependencies are satisfied and no conflicts exist.\\nIf a requested modpack is unavailable, has unsatisfied dependencies, or conflicts with another modpack, it throws an error.\\nFinally, it updates the load order with the provided list.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "da92dbc3907b",
        "ground_truth": "void ModManager::set_load_order(const std::vector<std::string> &load_order) {\n std::unordered_set<std::string> requested{load_order.begin(), load_order.end()};\n  // sanity check: availability, dependencies, conflicts\n for (const auto &modpack_id : load_order) {\n  if (not this->available.contains(modpack_id)) {\n   throw Error{MSG(err) << \"Requested modpack '\" << modpack_id << \"' not available.\"};\n  }\n   auto &info = this->available.at(modpack_id);\n  for (const auto &dependency : info.dependencies) {\n   if (not requested.contains(dependency)) {\n    throw Error{MSG(err) << \"Dependency '\" << dependency << \"' of modpack '\"\n                         << modpack_id << \"' not satisfied\"};\n   }\n  }\n   for (const auto &conflict : info.conflicts) {\n   if (requested.contains(conflict)) {\n    throw Error{MSG(err) << \"Modpack '\" << modpack_id << \"' conflicts with modpack '\"\n                         << conflict << \"'\"};\n   }\n  }\n }\n  this->load_order = load_order;\n}",
        "import_statements": [
            "#include \"mod_manager.h\"\n",
            "#include <unordered_set>\n"
        ],
        "reference_api": [
            "load_order.end",
            "requested.contains",
            "this->available.at",
            "load_order.begin",
            "MSG",
            "this->available.contains"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "load_order.end",
            "requested.contains",
            "this->available.at",
            "load_order.begin",
            "MSG",
            "this->available.contains"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "SFTtech/openage",
        "function_declaration": "void AudioManager::load_resources(const std::vector<resource_def> &sound_files)",
        "start_line": "87",
        "end_line": "103",
        "file_path": "libopenage/audio/audio_manager.cpp",
        "docstring": "The function load_resources(const std::vector<resource_def> &sound_files) in the AudioManager class loads audio resources.\\nIt first checks if resources are available.\\nIf available, it iterates through the provided sound files and creates a unique key for each file based on its category and ID.\\nIt skips loading if the sound is already loaded.\\nIf not already loaded, it creates the resource and inserts it into the resources map.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "103e298ff430",
        "ground_truth": "void AudioManager::load_resources(const std::vector<resource_def> &sound_files) {\n if (not this->available) {\n  return;\n }\n  for (auto &sound_file : sound_files) {\n  auto key = std::make_tuple(sound_file.category, sound_file.id);\n   if (this->resources.find(key) != std::end(this->resources)) {\n   // sound is already loaded\n   continue;\n  }\n   auto resource = Resource::create_resource(this, sound_file);\n  this->resources.insert({key, resource});\n }\n}",
        "import_statements": [
            "#include \"audio_manager.h\"\n",
            "#include <cstring>\n",
            "#include <sstream>\n",
            "#include <QAudioDevice>\n",
            "#include <QAudioFormat>\n",
            "#include <QAudioSink>\n",
            "#include <QMediaDevices>\n",
            "#include \"../log/log.h\"\n",
            "#include \"../util/misc.h\"\n",
            "#include \"error.h\"\n",
            "#include \"hash_functions.h\"\n",
            "#include \"resource.h\"\n"
        ],
        "reference_api": [
            "this->resources.insert",
            "Resource::create_resource",
            "std::make_tuple",
            "std::end",
            "this->resources.find"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->resources.insert",
            "Resource::create_resource",
            "this->resources.find"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "SFTtech/openage",
        "function_declaration": "Sound AudioManager::get_sound(category_t category, int id)",
        "start_line": "105",
        "end_line": "122",
        "file_path": "libopenage/audio/audio_manager.cpp",
        "docstring": "The function get_sound(category_t category, int id) retrieves a sound resource based on the given category and id.\\nIt first checks if the audio manager is available and throws an error if not.\\nIt searches for the resource in the resources map using the category and id tuple.\\nIf the resource is not found, it throws an error indicating the sound resource does not exist.\\nIf found, it creates a shared pointer to a SoundImpl object using the resource and returns a Sound object containing the audio manager and the sound implementation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "700caeffaaac",
        "ground_truth": "Sound AudioManager::get_sound(category_t category, int id) {\n if (not this->available) {\n  throw error::Error{MSG(err) << \"audio manager not available, \"\n                              << \"but sound was requested!\"};\n }\n  auto resource = resources.find(std::make_tuple(category, id));\n if (resource == std::end(resources)) {\n  throw audio::Error{\n   MSG(err) << \"Sound resource does not exist: \"\n      \"category=\"\n      << category << \", \"\n      << \"id=\" << id};\n }\n  auto sound_impl = std::make_shared<SoundImpl>(resource->second);\n return Sound{this, sound_impl};\n}",
        "import_statements": [
            "#include \"audio_manager.h\"\n",
            "#include <cstring>\n",
            "#include <sstream>\n",
            "#include <QAudioDevice>\n",
            "#include <QAudioFormat>\n",
            "#include <QAudioSink>\n",
            "#include <QMediaDevices>\n",
            "#include \"../log/log.h\"\n",
            "#include \"../util/misc.h\"\n",
            "#include \"error.h\"\n",
            "#include \"hash_functions.h\"\n",
            "#include \"resource.h\"\n"
        ],
        "reference_api": [
            "MSG",
            "std::make_tuple",
            "std::end",
            "resources.find",
            "std::make_shared<SoundImpl>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "MSG",
            "resources.find"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "SFTtech/openage",
        "function_declaration": "void AudioManager::add_sound(const std::shared_ptr<SoundImpl> &sound)",
        "start_line": "157",
        "end_line": "162",
        "file_path": "libopenage/audio/audio_manager.cpp",
        "docstring": "The function add_sound(const std::shared_ptr<SoundImpl> &sound) in AudioManager adds a sound to the playing list.\\nIt retrieves the sound's category and finds the corresponding list of playing sounds.\\nThe function then adds the sound to this list.\\nA TODO comment suggests checking if the sound already exists in the playing list before adding it.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2a0c1f0acd9f",
        "ground_truth": "void AudioManager::add_sound(const std::shared_ptr<SoundImpl> &sound) {\n auto category = sound->get_category();\n auto &playing_list = this->playing_sounds.find(category)->second;\n // TODO probably check if sound already exists in playing list\n playing_list.push_back(sound);\n}",
        "import_statements": [
            "#include \"audio_manager.h\"\n",
            "#include <cstring>\n",
            "#include <sstream>\n",
            "#include <QAudioDevice>\n",
            "#include <QAudioFormat>\n",
            "#include <QAudioSink>\n",
            "#include <QMediaDevices>\n",
            "#include \"../log/log.h\"\n",
            "#include \"../util/misc.h\"\n",
            "#include \"error.h\"\n",
            "#include \"hash_functions.h\"\n",
            "#include \"resource.h\"\n"
        ],
        "reference_api": [
            "sound->get_category",
            "playing_list.push_back",
            "this->playing_sounds.find"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "sound->get_category",
            "playing_list.push_back",
            "this->playing_sounds.find"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "SFTtech/openage",
        "function_declaration": "void Clock::update_time()",
        "start_line": "27",
        "end_line": "51",
        "file_path": "libopenage/time/clock.cpp",
        "docstring": "The function update_time() updates the simulated time of a clock if it is in the RUNNING state.\\nIt acquires a unique lock on a mutex and calculates the elapsed time since the last check.\\nIf no time has passed, it sleeps the thread briefly to prevent stalling.\\nIf the elapsed time exceeds the maximum tick time, it updates the simulated time and real time by the maximum tick time adjusted by the clock's speed.\\nOtherwise, it updates these times by the actual elapsed time.\\nFinally, it updates the last check time to the current time.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2c5f1f9b99b3",
        "ground_truth": "void Clock::update_time() {\n if (this->state == ClockState::RUNNING) {\n  std::unique_lock lock{this->mutex};\n   auto now = simclock_t::now();\n  auto passed = std::chrono::duration_cast<std::chrono::milliseconds>(now - this->last_check);\n  if (passed.count() == 0) {\n   // prevent the clock from stalling the thread forever\n   std::this_thread::sleep_for(std::chrono::milliseconds(1));\n  }\n  else if (passed.count() > this->max_tick_time) {\n   // if too much real time passes between two time updates, we only advance time by a small amount\n   // this prevents the simulation from getting out of control during unplanned stops,\n   // e.g. when debugging or if you close your laptop lid\n   this->sim_time += this->speed * this->max_tick_time;\n   this->sim_real_time += this->max_tick_time;\n  }\n  else {\n   this->sim_time += this->speed * passed.count();\n   this->sim_real_time += passed.count();\n  }\n  this->last_check = now;\n  // TODO: Stop clock if it reaches 0.0s with negative speed?\n }\n}",
        "import_statements": [
            "#include \"clock.h\"\n",
            "#include <thread>\n",
            "#include \"log/log.h\"\n"
        ],
        "reference_api": [
            "passed.count",
            "std::chrono::milliseconds",
            "simclock_t::now",
            "std::chrono::duration_cast<std::chrono::milliseconds>",
            "std::this_thread::sleep_for"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "passed.count",
            "simclock_t::now"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "SFTtech/openage",
        "function_declaration": "void Camera::look_at_scene(Eigen::Vector3f scene_pos)",
        "start_line": "63",
        "end_line": "97",
        "file_path": "libopenage/renderer/camera/camera.cpp",
        "docstring": "The function Camera::look_at_scene(Eigen::Vector3f scene_pos) adjusts the camera's position to look at a specified scene position.\\nIt calculates the vertical distance (y_delta) between the current and target scene positions.\\nUsing this distance, it computes the horizontal distance (xz_distance) based on a trigonometric relationship.\\nThe function then determines the new camera position by adjusting the x and z coordinates while keeping the height unchanged.\\nFinally, it moves the camera to the new position.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c660f2541c89",
        "ground_truth": "void Camera::look_at_scene(Eigen::Vector3f scene_pos) {\n if (scene_pos[1] > this->scene_pos[1]) {\n  // TODO: camera can't look at a position that's\n  //       higher than it's own position\n }\n  // TODO: Although the below method should be faster, calculating and adding the direction\n //       vector from scene_pos to new_pos may be easier to understand\n //       i.e. new_pos = scene_pos + b/sin(30) * direction_vec\n  // due to the fixed angle, the centered scene position\n // and the new camera position form a right triangle.\n //\n //           c - + new camera pos\n //          -    |b\n // center +------+\n //            a\n //\n // we can calculate the new camera position via the offset a\n // using the angle and length of side b.\n auto y_delta = this->scene_pos[1] - scene_pos[1]; // b (vertical distance)\n auto xz_distance = y_delta * std::numbers::sqrt3; // a (horizontal distance); a = b * (cos(30\u00b0) / sin(30\u00b0))\n  // get x and z offsets\n // the camera is pointed diagonally to the negative x and z axis\n // a is the length of the diagonal from camera.xz to scene_pos.xz\n // so the x and z offest are sides of a square with the same diagonal\n auto side_length = xz_distance / std::numbers::sqrt2;\n auto new_pos = Eigen::Vector3f(\n  scene_pos[0] + side_length,\n  this->scene_pos[1], // height unchanged\n  scene_pos[2] + side_length);\n  this->move_to(new_pos);\n}",
        "import_statements": [
            "#include \"camera.h\"\n",
            "#include <array>\n",
            "#include <numbers>\n",
            "#include <string>\n",
            "#include <utility>\n",
            "#include \"coord/pixel.h\"\n",
            "#include \"coord/scene.h\"\n",
            "#include \"renderer/renderer.h\"\n",
            "#include \"renderer/resources/buffer_info.h\"\n"
        ],
        "reference_api": [
            "Eigen::Vector3f",
            "this->move_to"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Eigen::Vector3f",
            "this->move_to"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "ApplicationActionController::DragTarget ApplicationActionController::dragTarget(const QUrl& url) const",
        "start_line": "120",
        "end_line": "133",
        "file_path": "src/appshell/internal/applicationactioncontroller.cpp",
        "docstring": "The function dragTarget(const QUrl& url) const determines the drag target type based on the provided URL.\\nIf the URL is supported by the project files controller, it returns DragTarget::ProjectFile.\\nIf the URL is a local file, it checks the file type.\\nIf the file is a SoundFont, it returns DragTarget::SoundFont.\\nIf the file is supported by the extension installer, it returns DragTarget::Extension.\\nIf none of these conditions are met, it returns DragTarget::Unknown.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3b2d44963495",
        "ground_truth": "ApplicationActionController::DragTarget ApplicationActionController::dragTarget(const QUrl& url) const\n{\n    if (projectFilesController()->isUrlSupported(url)) {\n        return DragTarget::ProjectFile;\n    } else if (url.isLocalFile()) {\n        muse::io::path_t filePath = url.toLocalFile();\n        if (muse::audio::synth::isSoundFont(filePath)) {\n            return DragTarget::SoundFont;\n        } else if (extensionInstaller()->isFileSupported(filePath)) {\n            return DragTarget::Extension;\n        }\n    }\n    return DragTarget::Unknown;\n}",
        "import_statements": [
            "#include \"applicationactioncontroller.h\"\n",
            "#include <QApplication>\n",
            "#include <QCloseEvent>\n",
            "#include <QFileOpenEvent>\n",
            "#include <QWindow>\n",
            "#include <QMimeData>\n",
            "#include \"async/async.h\"\n",
            "#include \"audio/soundfonttypes.h\"\n",
            "#include \"defer.h\"\n",
            "#include \"translation.h\"\n",
            "#include \"log.h\"\n"
        ],
        "reference_api": [
            "url.toLocalFile",
            "url.isLocalFile",
            "extensionInstaller",
            "muse::audio::synth::isSoundFont",
            "projectFilesController()->isUrlSupported",
            "projectFilesController",
            "extensionInstaller()->isFileSupported"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "url.toLocalFile",
            "url.isLocalFile",
            "extensionInstaller",
            "muse::audio::synth::isSoundFont",
            "projectFilesController()->isUrlSupported",
            "projectFilesController",
            "extensionInstaller()->isFileSupported"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "void SessionsManager::removeProjectFromSession(const muse::io::path_t& projectPath)",
        "start_line": "101",
        "end_line": "110",
        "file_path": "src/appshell/internal/sessionsmanager.cpp",
        "docstring": "The function removeProjectFromSession(const muse::io::path_t& projectPath) removes a specified project from the current session.\\nIt retrieves the list of project paths from the session configuration.\\nIf the list is not empty, it removes the specified project path from the list and updates the session configuration with the modified list.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "81a3cd2e265e",
        "ground_truth": "void SessionsManager::removeProjectFromSession(const muse::io::path_t& projectPath)\n{\n    io::paths_t projects = configuration()->sessionProjectsPaths();\n    if (projects.empty()) {\n        return;\n    }\n     projects.erase(std::remove(projects.begin(), projects.end(), projectPath), projects.end());\n    configuration()->setSessionProjectsPaths(projects);\n}",
        "import_statements": [
            "#include \"sessionsmanager.h\"\n"
        ],
        "reference_api": [
            "configuration()->sessionProjectsPaths",
            "configuration()->setSessionProjectsPaths",
            "projects.begin",
            "projects.erase",
            "projects.end",
            "projects.empty",
            "std::remove",
            "configuration"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "configuration()->sessionProjectsPaths",
            "configuration()->setSessionProjectsPaths",
            "projects.begin",
            "projects.erase",
            "projects.end",
            "projects.empty",
            "configuration"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "QVariantList AppearancePreferencesModel::highContrastThemes() const",
        "start_line": "113",
        "end_line": "124",
        "file_path": "src/appshell/view/preferences/appearancepreferencesmodel.cpp",
        "docstring": "The function highContrastThemes() returns a list of high-contrast themes.\\nIt initializes an empty QVariantList and iterates through all available themes.\\nFor each theme, it checks if the theme's code key matches either the high-contrast white or black theme code.\\nIf a match is found, it converts the theme to a map and adds it to the result list.\\nFinally, it returns the list of high-contrast themes.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "98a514c0b62f",
        "ground_truth": "QVariantList AppearancePreferencesModel::highContrastThemes() const\n{\n    QVariantList result;\n     for (const ThemeInfo& theme : allThemes()) {\n        if (theme.codeKey == HIGH_CONTRAST_WHITE_THEME_CODE || theme.codeKey == HIGH_CONTRAST_BLACK_THEME_CODE) {\n            result << ThemeConverter::toMap(theme);\n        }\n    }\n     return result;\n}",
        "import_statements": [
            "#include \"appearancepreferencesmodel.h\"\n",
            "#include \"ui/internal/themeconverter.h\"\n",
            "#include \"log.h\"\n",
            "#include \"translation.h\"\n"
        ],
        "reference_api": [
            "ThemeConverter::toMap",
            "allThemes"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "allThemes",
                "code": "ThemeList AppearancePreferencesModel::allThemes() const\n{\n    return uiConfiguration()->themes();\n}"
            }
        ],
        "third_party": [
            "ThemeConverter::toMap"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "QVariantList PreferencesModel::availablePages() const",
        "start_line": "245",
        "end_line": "268",
        "file_path": "src/appshell/view/preferences/preferencesmodel.cpp",
        "docstring": "The function availablePages() in PreferencesModel returns a list of available preference pages as a QVariantList.\\nIt uses a recursive lambda function, childPages, to traverse through the child items of the root preference page item.\\nFor each child item, it creates a QVariantMap with the child's ID and path, adds it to the result list, and recursively adds any pages of the child's children.\\nFinally, it calls this recursive function on the root item and returns the accumulated list of pages.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ceff09bc116b",
        "ground_truth": "QVariantList PreferencesModel::availablePages() const\n{\n    std::function<QVariantList(const PreferencePageItem*)> childPages;\n    childPages = [&childPages](const PreferencePageItem* item) {\n        QVariantList result;\n         for (int i = 0; i < item->childCount(); ++i) {\n            PreferencePageItem* child = item->childAtRow(i);\n            QVariantMap childObj;\n            childObj[\"id\"] = child->id();\n            childObj[\"path\"] = child->path();\n            result << childObj;\n             QVariantList pages = childPages(child);\n            for (const QVariant& page: pages) {\n                result << page;\n            }\n        }\n         return result;\n    };\n     return childPages(m_rootItem);\n}",
        "import_statements": [
            "#include <QApplication>\n",
            "#include \"preferencesmodel.h\"\n",
            "#include \"log.h\"\n",
            "#include \"translation.h\"\n",
            "#include \"ui/view/iconcodes.h\"\n"
        ],
        "reference_api": [
            "child->id",
            "item->childAtRow",
            "child->path",
            "item->childCount",
            "childPages"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "child->id",
            "item->childAtRow",
            "child->path",
            "item->childCount",
            "childPages"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "MenuItemList AppMenuModel::makeRecentScoresItems()",
        "start_line": "404",
        "end_line": "437",
        "file_path": "src/appshell/view/appmenumodel.cpp",
        "docstring": "The function makeRecentScoresItems() creates a list of menu items for recent files.\\nIt initializes an empty MenuItemList and retrieves the list of recent files.\\nFor each recent file, it creates a new MenuItem and sets its action code to \"file-open\" with the file's display name.\\nIf the file is a cloud project, it sets the icon to a cloud icon.\\nThe function assigns a unique ID to each item, enables it, makes it selectable, and sets its arguments with the file's URL and display name override.\\nFinally, it adds each item to the MenuItemList and returns the list.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "88e5ca72d3e0",
        "ground_truth": "MenuItemList AppMenuModel::makeRecentScoresItems()\n{\n    MenuItemList items;\n    const RecentFilesList& recentFiles = recentFilesController()->recentFilesList();\n     int index = 0;\n    for (const RecentFile& file : recentFiles) {\n        MenuItem* item = new MenuItem(this);\n         UiAction action;\n        action.code = \"file-open\";\n        action.title = TranslatableString::untranslatable(file.displayName(/*includingExtension*/ true));\n        bool isCloud = projectConfiguration()->isCloudProject(file.path);\n         if (isCloud) {\n            action.iconCode = IconCode::Code::CLOUD;\n        }\n         item->setAction(action);\n         item->setId(makeId(item->action().code, index++));\n         UiActionState state;\n        state.enabled = true;\n        item->setState(state);\n         item->setSelectable(true);\n        item->setArgs(ActionData::make_arg2<QUrl, QString>(file.path.toQUrl(), file.displayNameOverride));\n         items << item;\n    }\n     return items;\n}",
        "import_statements": [
            "#include \"appmenumodel.h\"\n",
            "#include \"types/translatablestring.h\"\n",
            "#include \"log.h\"\n"
        ],
        "reference_api": [
            "item->setArgs",
            "item->setId",
            "projectConfiguration",
            "recentFilesController",
            "ActionData::make_arg2<QUrl, QString>",
            "item->setState",
            "file.path.toQUrl",
            "item->setAction",
            "file.displayName",
            "recentFilesController()->recentFilesList",
            "makeId",
            "TranslatableString::untranslatable",
            "item->action",
            "projectConfiguration()->isCloudProject",
            "item->setSelectable"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "makeId",
                "code": "static QString makeId(const ActionCode& actionCode, int itemIndex)\n{\n    return QString::fromStdString(actionCode) + QString::number(itemIndex);\n}"
            }
        ],
        "third_party": [
            "item->setArgs",
            "item->setId",
            "projectConfiguration",
            "recentFilesController",
            "ActionData::make_arg2<QUrl, QString>",
            "item->setState",
            "file.path.toQUrl",
            "item->setAction",
            "file.displayName",
            "recentFilesController()->recentFilesList",
            "TranslatableString::untranslatable",
            "item->action",
            "projectConfiguration()->isCloudProject",
            "item->setSelectable"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "void NavigableAppMenuModel::openMenu(const QString& menuId, bool byHover)",
        "start_line": "87",
        "end_line": "104",
        "file_path": "src/appshell/view/navigableappmenumodel.cpp",
        "docstring": "The function openMenu(const QString& menuId, bool byHover) handles opening a menu based on the provided menu ID and hover status.\\nIt checks if navigation has started and if the menu is already open.\\nIf the menu is not opened by hover and is not already open, it saves or restores the navigation system state based on whether navigation has started or if any menu is currently open.\\nIf navigation has started, it sets the highlighted menu ID.\\nFinally, it emits a signal to request opening the menu with the specified menu ID and hover status.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "855288a783a5",
        "ground_truth": "void NavigableAppMenuModel::openMenu(const QString& menuId, bool byHover)\n{\n    bool navigationStarted = isNavigationStarted();\n    bool menuIsAlreadyOpened = m_openedMenuId == menuId;\n    if (!byHover && !menuIsAlreadyOpened) {\n        if (navigationStarted || !isMenuOpened()) {\n            saveMUNavigationSystemState();\n        } else {\n            restoreMUNavigationSystemState();\n        }\n    }\n     if (navigationStarted) {\n        setHighlightedMenuId(menuId);\n    }\n     emit openMenuRequested(menuId, byHover);\n}",
        "import_statements": [
            "#include \"navigableappmenumodel.h\"\n",
            "#include <QApplication>\n",
            "#include <QWindow>\n",
            "#include <QKeyEvent>\n",
            "#include <private/qkeymapper_p.h>\n",
            "#include \"log.h\"\n"
        ],
        "reference_api": [
            "isNavigationStarted",
            "isMenuOpened",
            "setHighlightedMenuId",
            "saveMUNavigationSystemState",
            "restoreMUNavigationSystemState"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "isNavigationStarted",
                "code": "bool NavigableAppMenuModel::isNavigationStarted() const\n{\n    return !m_highlightedMenuId.isEmpty();\n}"
            },
            {
                "name": "isMenuOpened",
                "code": "bool NavigableAppMenuModel::isMenuOpened() const\n{\n    return !m_openedMenuId.isEmpty();\n}"
            },
            {
                "name": "setHighlightedMenuId",
                "code": "void NavigableAppMenuModel::setHighlightedMenuId(QString highlightedMenuId)\n{\n    if (m_highlightedMenuId == highlightedMenuId) {\n        return;\n    }\n\n    m_highlightedMenuId = highlightedMenuId;\n    emit highlightedMenuIdChanged(m_highlightedMenuId);\n}"
            },
            {
                "name": "saveMUNavigationSystemState",
                "code": "void NavigableAppMenuModel::saveMUNavigationSystemState()\n{\n    bool muNavigationIsHighlight = navigationController()->isHighlight();\n    m_needActivateLastMUNavigationControl = muNavigationIsHighlight;\n\n    INavigationSection* section = navigationController()->activeSection();\n    INavigationPanel* panel = navigationController()->activePanel();\n    INavigationControl* control = navigationController()->activeControl();\n    m_lastActiveMUNavigationState = {\n        section ? section->name().toStdString() : \"\",\n        panel ? panel->name().toStdString() : \"\",\n        control ? control->name().toStdString() : \"\"\n    };\n\n    if (control) {\n        control->setActive(false);\n    }\n}"
            },
            {
                "name": "restoreMUNavigationSystemState",
                "code": "void NavigableAppMenuModel::restoreMUNavigationSystemState()\n{\n    if (m_lastActiveMUNavigationState.has_value()) {\n        MUNavigationSystemState state = m_lastActiveMUNavigationState.value();\n\n        bool ok = navigationController()->requestActivateByName(state.sectionName, state.panelName, state.controlName);\n        if (!ok) {\n            navigationController()->resetNavigation();\n        }\n\n        m_lastActiveMUNavigationState.reset();\n    }\n\n    navigationController()->setIsHighlight(m_needActivateLastMUNavigationControl);\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "QVariant NotationStatusBarModel::currentViewMode()",
        "start_line": "111",
        "end_line": "127",
        "file_path": "src/appshell/view/notationstatusbarmodel.cpp",
        "docstring": "The function currentViewMode() retrieves the current view mode for the notation.\\nIt first determines the view mode, defaulting to PAGE if the notation is not available.\\nIt then iterates through a list of available view modes.\\nIf the current view mode matches an item in the list and is either LINE or SYSTEM, it sets the title to \"Continuous view\" for continuous viewing.\\nFinally, it returns the matched menu item as a QVariant or an empty QVariant if no match is found.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d31bdc9d40b6",
        "ground_truth": "QVariant NotationStatusBarModel::currentViewMode()\n{\n    ViewMode viewMode = notation() ? notation()->viewMode() : ViewMode::PAGE;\n     for (MenuItem* modeItem : makeAvailableViewModeList()) {\n        if (ALL_MODE_MAP.key(modeItem->id().toStdString()) == viewMode) {\n            if (viewMode == ViewMode::LINE || viewMode == ViewMode::SYSTEM) {\n                // In continuous view, we don't want to see \"horizontal\" or \"vertical\" (those should only be visible in the menu)\n                modeItem->setTitle(muse::TranslatableString(\"notation\", \"Continuous view\"));\n            }\n             return QVariant::fromValue(modeItem);\n        }\n    }\n     return QVariant();\n}",
        "import_statements": [
            "#include \"notationstatusbarmodel.h\"\n",
            "#include \"types/translatablestring.h\"\n",
            "#include \"log.h\"\n"
        ],
        "reference_api": [
            "QVariant",
            "modeItem->setTitle",
            "ALL_MODE_MAP.key",
            "makeAvailableViewModeList",
            "QVariant::fromValue",
            "modeItem->id",
            "muse::TranslatableString",
            "notation",
            "notation()->viewMode",
            "modeItem->id().toStdString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "makeAvailableViewModeList",
                "code": "MenuItemList NotationStatusBarModel::makeAvailableViewModeList()\n{\n    if (!notation()) {\n        return {};\n    }\n\n    MenuItemList result;\n\n    ViewMode currentViewMode = notation()->viewMode();\n\n    for (const ViewMode& viewMode: ALL_MODE_MAP.keys()) {\n        ActionCode code = ALL_MODE_MAP[viewMode];\n        if (viewMode == ViewMode::FLOAT && !globalConfiguration()->devModeEnabled()) {\n            continue;\n        }\n        UiAction action = actionsRegister()->action(code);\n\n        MenuItem* viewModeItem = new MenuItem(action, this);\n\n        UiActionState state;\n        state.enabled = true;\n        viewModeItem->setState(state);\n\n        viewModeItem->setId(QString::fromStdString(code));\n        viewModeItem->setSelectable(true);\n        viewModeItem->setSelected(currentViewMode == viewMode);\n\n        result << viewModeItem;\n    }\n\n    return result;\n}"
            },
            {
                "name": "notation",
                "code": "INotationPtr NotationStatusBarModel::notation() const\n{\n    return context()->currentNotation();\n}"
            }
        ],
        "third_party": [
            "QVariant",
            "modeItem->setTitle",
            "ALL_MODE_MAP.key",
            "QVariant::fromValue",
            "modeItem->id",
            "muse::TranslatableString",
            "notation()->viewMode",
            "modeItem->id().toStdString"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "muse::Ret BrailleWriter::write(notation::INotationPtr notation, muse::io::IODevice& destinationDevice, const Options&)",
        "start_line": "44",
        "end_line": "65",
        "file_path": "src/braille/internal/braillewriter.cpp",
        "docstring": "The function BrailleWriter::write(notation::INotationPtr notation, muse::io::IODevice& destinationDevice, const Options&) converts musical notation to Braille and writes it to a specified device.\\nIt checks if the notation and score are valid.\\nIf valid, it writes the Braille representation of the score to a buffer.\\nIf the writing is successful, it converts the buffer data to a ByteArray and writes it to the destination device.\\nThe function returns the result of the Braille writing operation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f161c1b938c8",
        "ground_truth": "muse::Ret BrailleWriter::write(notation::INotationPtr notation, muse::io::IODevice& destinationDevice, const Options&)\n{\n    IF_ASSERT_FAILED(notation) {\n        return make_ret(Ret::Code::UnknownError);\n    }\n     mu::engraving::Score* score = notation->elements()->msScore();\n    IF_ASSERT_FAILED(score) {\n        return make_ret(Ret::Code::UnknownError);\n    }\n     QByteArray qdata;\n    QBuffer buf(&qdata);\n    buf.open(QIODevice::WriteOnly);\n     Ret ret = Braille(score).write(buf);\n    if (ret) {\n        ByteArray data = ByteArray::fromQByteArrayNoCopy(qdata);\n        destinationDevice.write(data);\n    }\n    return ret;\n}",
        "import_statements": [
            "#include \"braillewriter.h\"\n",
            "#include <QBuffer>\n",
            "#include \"braille.h\"\n"
        ],
        "reference_api": [
            "make_ret"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "make_ret"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "musescore/MuseScore",
        "function_declaration": "std::string braille_long_translate(const char* table_name, std::string txt)",
        "start_line": "306",
        "end_line": "321",
        "file_path": "src/braille/internal/louis.cpp",
        "docstring": "The function braille_long_translate(const char* table_name, std::string txt) translates a given text into braille using a specified translation table.\\nIt splits the input text into lines of up to 256 characters.\\nIf no lines are found, it returns an empty string.\\nIt translates the first line and initializes a buffer with the result.\\nFor each subsequent line, it appends the translated text to the buffer, adding a space after each line.\\nFinally, it returns the concatenated braille translation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "192825616947",
        "ground_truth": "std::string braille_long_translate(const char* table_name, std::string txt)\n{\n    std::vector<std::string> lines = split_string(txt, 256);\n     if (lines.size() == 0) {\n        return \"\";\n    }\n     std::string buffer = braille_translate(table_name, lines.front());\n     for (size_t i = 1; i < lines.size(); i++) {\n        std::string text = lines[i] + \" \";\n        buffer.append(braille_translate(table_name, text));\n    }\n    return buffer;\n}",
        "import_statements": [
            "#include <iostream>\n",
            "#include <sstream>\n",
            "#include <stdint.h>\n",
            "#include <stdio.h>\n",
            "#include <stdlib.h>\n",
            "#include <string.h>\n",
            "#include <vector>\n",
            "#include \"braille/thirdparty/liblouis/liblouis/internal.h\"\n",
            "#include \"braille/thirdparty/liblouis/liblouis/liblouis.h\"\n"
        ],
        "reference_api": [
            "lines.front",
            "braille_translate",
            "split_string",
            "buffer.append",
            "lines.size"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "braille_translate",
                "code": "std::string braille_translate(const char* table_name, std::string txt)\n{\n    uint8_t* outputbuf = nullptr;\n    size_t outlen = 0;\n    widechar inbuf[MAXSTRING];\n    widechar transbuf[MAXSTRING];\n    int inlen = 0;\n    int translen = 0;\n\n    inlen = _lou_extParseChars(txt.c_str(), inbuf);\n\n    translen = MAXSTRING;\n    lou_translateString(\n        table_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\n#ifdef WIDECHARS_ARE_UCS4\n    //outputbuf = (uint8_t *) malloc (translen * sizeof(widechar) * sizeof (uint8_t));\n    outputbuf = u32_to_u8(transbuf, translen, NULL, &outlen);\n#else\n    outputbuf = u16_to_u8(transbuf, translen, NULL, &outlen);\n#endif\n\n    if (!outputbuf) {\n        return std::string();\n    }\n\n    std::string ret = std::string(outputbuf, outputbuf + outlen);\n    free(outputbuf);\n\n    return ret;\n}"
            },
            {
                "name": "split_string",
                "code": "std::vector<std::string> split_string(std::string txt, int width)\n{\n    std::vector<std::string> lines;\n\n    QString str = QString::fromStdString(txt);\n\n    int len = str.length();\n\n    if (len <= width) {\n        lines.push_back(txt);\n        return lines;\n    }\n\n    while (len > width) {\n        int idx = width - 1;\n        for (; idx >= 0; idx--) {\n            QString ch = str.left(idx).right(1);\n            if (ch == \"\u2800\") {\n                break;\n            }\n        }\n        if (idx == 0 || idx == -1) {\n            idx = width;\n        }\n\n        QString line = str.left(idx);\n\n        str = str.right(len - idx);\n        len = str.length();\n        lines.push_back(line.toStdString());\n    }\n    if (len > 0) {\n        lines.push_back(str.toStdString());\n    }\n    return lines;\n}\n\n"
            }
        ],
        "third_party": [
            "lines.front",
            "buffer.append",
            "lines.size"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "std::shared_ptr<ProxyEntity> ProfileManager::LoadProxyEntity(const QString &jsonPath)",
        "start_line": "142",
        "end_line": "164",
        "file_path": "db/Database.cpp",
        "docstring": "The function LoadProxyEntity(const QString &jsonPath) in ProfileManager loads a ProxyEntity from a given JSON path.\\nIt first initializes a temporary ProxyEntity to check the validity and type of the JSON.\\nIf the JSON is valid, it creates a new ProxyEntity of the determined type.\\nIt further checks the version of the entity and, if valid, sets the load control flag, assigns the JSON path, and loads the entity.\\nFinally, it returns the loaded ProxyEntity.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9cfd1739fffa",
        "ground_truth": "std::shared_ptr<ProxyEntity> ProfileManager::LoadProxyEntity(const QString &jsonPath) {\n    // Load type\n    ProxyEntity ent0(nullptr, nullptr);\n    ent0.fn = jsonPath;\n    auto validJson = ent0.Load();\n    auto type = ent0.type;\n    // Load content\n    std::shared_ptr<ProxyEntity> ent;\n    bool validType = validJson;\n    if (validType) {\n        ent = NewProxyEntity(type);\n        validType = ent->bean->version != -114514;\n    }\n    if (validType) {\n        ent->load_control_must = true;\n        ent->fn = jsonPath;\n        ent->Load();\n    }\n    return ent;\n}",
        "import_statements": [
            "#include \"Database.hpp\"\n",
            "#include \"fmt/includes.h\"\n",
            "#include <QFile>\n",
            "#include <QDir>\n",
            "#include <QColor>\n"
        ],
        "reference_api": [
            "ent->Load",
            "NewProxyEntity",
            "ent0.Load"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ent->Load",
            "NewProxyEntity",
            "ent0.Load"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "bool NaiveBean::TryParseLink(const QString &link) ",
        "start_line": "238",
        "end_line": "252",
        "file_path": "fmt/Link2Bean.cpp",
        "docstring": "The function NaiveBean::TryParseLink(const QString &link) attempts to parse a given link and extract connection details.\\nIt converts the link to a QUrl object and checks its validity.\\nIt retrieves and processes the protocol, ensuring it is either \"https\" or \"quic\".\\nThe function then extracts the name, server address, port, username, and password from the URL.\\nIt returns true if the username, password, and server address are not empty, indicating a successful parsing.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d2d7a08c10d4",
        "ground_truth": "bool NaiveBean::TryParseLink(const QString &link) {\n    auto url = QUrl(link);\n    if (!url.isValid()) return false;\n    protocol = url.scheme().replace(\"naive+\", \"\");\n    if (protocol != \"https\" && protocol != \"quic\") return false;\n    name = url.fragment(QUrl::FullyDecoded);\n    serverAddress = url.host();\n    serverPort = url.port();\n    username = url.userName();\n    password = url.password();\n    return !(username.isEmpty() || password.isEmpty() || serverAddress.isEmpty());\n}",
        "import_statements": [
            "#include \"db/ProxyEntity.hpp\"\n",
            "#include \"fmt/includes.h\"\n",
            "#include <QUrlQuery>\n"
        ],
        "reference_api": [
            "QUrl",
            "password.isEmpty",
            "serverAddress.isEmpty",
            "url.userName",
            "url.scheme",
            "url.isValid",
            "url.password",
            "username.isEmpty",
            "url.host",
            "url.scheme().replace",
            "url.port",
            "url.fragment"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "QUrl",
            "password.isEmpty",
            "serverAddress.isEmpty",
            "url.userName",
            "url.scheme",
            "url.isValid",
            "url.password",
            "username.isEmpty",
            "url.host",
            "url.scheme().replace",
            "url.port",
            "url.fragment"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "bool JsonStore::Save()",
        "start_line": "184",
        "end_line": "199",
        "file_path": "main/NekoGui.cpp",
        "docstring": "The function Save() in JsonStore saves the current state to a file.\\nIt first calls a pre-save callback if it exists and checks a flag to determine if saving is allowed.\\nThe function converts the current state to JSON bytes and compares it with the last saved content to detect changes.\\nIf changes are detected, it updates the last saved content.\\nThe function opens the file, writes the JSON content, and closes the file.\\nIt returns a boolean indicating whether the content has changed.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2f666eafb5f4",
        "ground_truth": "bool JsonStore::Save() {\n    if (callback_before_save != nullptr) callback_before_save();\n    if (save_control_no_save) return false;\n    auto save_content = ToJsonBytes();\n    auto changed = last_save_content != save_content;\n    last_save_content = save_content;\n    QFile file;\n    file.setFileName(fn);\n    file.open(QIODevice::ReadWrite | QIODevice::Truncate);\n    file.write(save_content);\n    file.close();\n    return changed;\n}",
        "import_statements": [
            "#include \"NekoGui.hpp\"\n",
            "#include \"fmt/Preset.hpp\"\n",
            "#include <QFile>\n",
            "#include <QDir>\n",
            "#include <QApplication>\n",
            "#include <QFileInfo>\n",
            "#include <QJsonObject>\n",
            "#include <QJsonArray>\n",
            "#include <QJsonDocument>\n"
        ],
        "reference_api": [
            "file.close",
            "file.setFileName",
            "callback_before_save",
            "ToJsonBytes",
            "file.write",
            "file.open"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "file.close",
            "file.setFileName",
            "callback_before_save",
            "ToJsonBytes",
            "file.write",
            "file.open"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "void setTimeout(const std::function<void()> &callback, QObject *obj, int timeout)",
        "start_line": "252",
        "end_line": "261",
        "file_path": "main/NekoGui_Utils.cpp",
        "docstring": "The function setTimeout(const std::function<void()> &callback, QObject *obj, int timeout) creates a single-shot QTimer to execute a callback function after a specified timeout.\\nIt connects the QTimer's timeout signal to the callback function and sets the timer to delete itself after executing the callback.\\nThe timer is configured with the given interval and started.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1fb63372333c",
        "ground_truth": "void setTimeout(const std::function<void()> &callback, QObject *obj, int timeout) {\n    auto t = new QTimer;\n    QObject::connect(t, &QTimer::timeout, obj, [=] {\n        callback();\n        t->deleteLater();\n    });\n    t->setSingleShot(true);\n    t->setInterval(timeout);\n    t->start();\n}",
        "import_statements": [
            "#include \"NekoGui_Utils.hpp\"\n",
            "#include \"3rdparty/base64.h\"\n",
            "#include \"3rdparty/QThreadCreateThread.hpp\"\n",
            "#include <random>\n",
            "#include <QApplication>\n",
            "#include <QUrlQuery>\n",
            "#include <QTcpServer>\n",
            "#include <QTimer>\n",
            "#include <QMessageBox>\n",
            "#include <QFile>\n",
            "#include <QJsonObject>\n",
            "#include <QJsonArray>\n",
            "#include <QJsonDocument>\n",
            "#include <QRegularExpression>\n",
            "#include <QDateTime>\n",
            "#include <QLocale>\n"
        ],
        "reference_api": [
            "t->start",
            "callback",
            "t->setInterval",
            "t->setSingleShot",
            "t->deleteLater",
            "QObject::connect"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "t->start",
            "callback",
            "t->setInterval",
            "t->setSingleShot",
            "t->deleteLater",
            "QObject::connect"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "static QByteArray processReply(QNetworkReply *networkReply, QNetworkReply::NetworkError &statusCode) ",
        "start_line": "88",
        "end_line": "107",
        "file_path": "rpc/gRPC.cpp",
        "docstring": "The static function processReply(QNetworkReply *networkReply, QNetworkReply::NetworkError &statusCode) processes a network reply and returns the response data.\\nIt first checks for network errors and updates the status code if an error is found, returning an empty QByteArray.\\nIf no network error is present, it checks for server-side gRPC errors using custom headers.\\nIf a gRPC error is detected, it logs the error message, sets the status code to ProtocolUnknownError, and returns an empty QByteArray.\\nIf no errors are found, it sets the status code to NoError and returns the response data, excluding the gRPC message size header.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "150b7aeeeb35",
        "ground_truth": "static QByteArray processReply(QNetworkReply *networkReply, QNetworkReply::NetworkError &statusCode) {\n    // Check if no network error occured\n    if (networkReply->error() != QNetworkReply::NoError) {\n        statusCode = networkReply->error();\n        return {};\n    }\n    // Check if server answer with error\n    auto errCode = networkReply->rawHeader(GrpcStatusHeader).toInt();\n    if (errCode != 0) {\n        QStringList errstr;\n        errstr << \"grpc-status error code:\" << Int2String(errCode) << \", error msg:\"\n               << QLatin1String(networkReply->rawHeader(GrpcStatusMessage));\n        MW_show_log(errstr.join(\" \"));\n        statusCode = QNetworkReply::NetworkError::ProtocolUnknownError;\n        return {};\n    }\n    statusCode = QNetworkReply::NetworkError::NoError;\n    return networkReply->readAll().mid(GrpcMessageSizeHeaderSize);\n}",
        "import_statements": [
            "#include \"gRPC.h\"\n",
            "#include <utility>\n",
            "#include <QStringList>\n"
        ],
        "reference_api": [
            "networkReply->readAll().mid",
            "QLatin1String",
            "networkReply->readAll",
            "networkReply->rawHeader",
            "MW_show_log",
            "networkReply->rawHeader(GrpcStatusHeader).toInt",
            "Int2String",
            "networkReply->error",
            "errstr.join"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "networkReply->readAll().mid",
            "QLatin1String",
            "networkReply->readAll",
            "networkReply->rawHeader",
            "MW_show_log",
            "networkReply->rawHeader(GrpcStatusHeader).toInt",
            "Int2String",
            "networkReply->error",
            "errstr.join"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "QString Client::Start(bool *rpcOK, const libcore::LoadConfigReq &request)",
        "start_line": "216",
        "end_line": "227",
        "file_path": "rpc/gRPC.cpp",
        "docstring": "The function QString Client::Start(bool *rpcOK, const libcore::LoadConfigReq &request) sends a \"Start\" request with the given configuration to the gRPC channel.\\nIf the request is successful, it sets the rpcOK flag to true and returns the error message from the response.\\nIf the request fails, it sets the rpcOK flag to false and returns an empty string.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ecaaeadcf213",
        "ground_truth": "QString Client::Start(bool *rpcOK, const libcore::LoadConfigReq &request) {\n    libcore::ErrorResp reply;\n    auto status = default_grpc_channel->Call(\"Start\", request, &reply);\n    if (status == QNetworkReply::NoError) {\n        *rpcOK = true;\n        return {reply.error().c_str()};\n    } else {\n        NOT_OK\n        return \"\";\n    }\n}",
        "import_statements": [
            "#include \"gRPC.h\"\n",
            "#include <utility>\n",
            "#include <QStringList>\n"
        ],
        "reference_api": [
            "reply.error().c_str",
            "default_grpc_channel->Call",
            "reply.error"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "reply.error().c_str",
            "default_grpc_channel->Call",
            "reply.error"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "void DialogBasicSettings::refresh_auth()",
        "start_line": "296",
        "end_line": "303",
        "file_path": "ui/dialog_basic_settings.cpp",
        "docstring": "The function refresh_auth() updates the authentication status icon in the UI.\\nIt first clears the text of the inbound_auth UI element.\\nThen, it checks if authentication is needed by querying the inbound_auth data store.\\nIf authentication is needed, it sets the icon to a locked icon.\\nIf not, it sets the icon to an unlocked icon.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7f3365d1207f",
        "ground_truth": "void DialogBasicSettings::refresh_auth() {\n    ui->inbound_auth->setText({});\n    if (NekoGui::dataStore->inbound_auth->NeedAuth()) {\n        ui->inbound_auth->setIcon(Icon::GetMaterialIcon(\"lock-outline\"));\n    } else {\n        ui->inbound_auth->setIcon(Icon::GetMaterialIcon(\"lock-open-outline\"));\n    }\n}",
        "import_statements": [
            "#include \"dialog_basic_settings.h\"\n",
            "#include \"ui_dialog_basic_settings.h\"\n",
            "#include \"3rdparty/qv2ray/v2/ui/widgets/editors/w_JsonEditor.hpp\"\n",
            "#include \"fmt/Preset.hpp\"\n",
            "#include \"ui/ThemeManager.hpp\"\n",
            "#include \"ui/Icon.hpp\"\n",
            "#include \"main/GuiUtils.hpp\"\n",
            "#include \"main/NekoGui.hpp\"\n",
            "#include <QStyleFactory>\n",
            "#include <QFileDialog>\n",
            "#include <QInputDialog>\n",
            "#include <QMessageBox>\n",
            "#include <QTimer>\n"
        ],
        "reference_api": [
            "NekoGui::dataStore->inbound_auth->NeedAuth",
            "ui->inbound_auth->setIcon",
            "Icon::GetMaterialIcon",
            "ui->inbound_auth->setText"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "NekoGui::dataStore->inbound_auth->NeedAuth",
            "ui->inbound_auth->setIcon",
            "Icon::GetMaterialIcon",
            "ui->inbound_auth->setText"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "void DialogManageGroups::on_add_clicked()",
        "start_line": "41",
        "end_line": "52",
        "file_path": "ui/dialog_manage_groups.cpp",
        "docstring": "The function on_add_clicked() handles the addition of a new group.\\nIt creates a new group entity and opens a dialog to edit the group.\\nAfter the dialog execution, it deletes the dialog object.\\nIf the dialog is accepted, it adds the new group to the profile manager, updates the group list, and sends a refresh message to the main window.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "34f643ad7662",
        "ground_truth": "void DialogManageGroups::on_add_clicked() {\n    auto ent = NekoGui::ProfileManager::NewGroup();\n    auto dialog = new DialogEditGroup(ent, this);\n    int ret = dialog->exec();\n    dialog->deleteLater();\n     if (ret == QDialog::Accepted) {\n        NekoGui::profileManager->AddGroup(ent);\n        AddGroupToListIfExist(ent->id);\n        MW_dialog_message(Dialog_DialogManageGroups, \"refresh-1\");\n    }\n}",
        "import_statements": [
            "#include \"dialog_manage_groups.h\"\n",
            "#include \"ui_dialog_manage_groups.h\"\n",
            "#include \"db/Database.hpp\"\n",
            "#include \"sub/GroupUpdater.hpp\"\n",
            "#include \"main/GuiUtils.hpp\"\n",
            "#include \"ui/widget/GroupItem.h\"\n",
            "#include \"ui/edit/dialog_edit_group.h\"\n",
            "#include <QInputDialog>\n",
            "#include <QListWidgetItem>\n",
            "#include <QMessageBox>\n"
        ],
        "reference_api": [
            "NekoGui::ProfileManager::NewGroup",
            "AddGroupToListIfExist",
            "dialog->exec",
            "NekoGui::profileManager->AddGroup",
            "dialog->deleteLater",
            "MW_dialog_message"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "NekoGui::ProfileManager::NewGroup",
            "AddGroupToListIfExist",
            "dialog->exec",
            "NekoGui::profileManager->AddGroup",
            "dialog->deleteLater",
            "MW_dialog_message"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "MatsuriDayo/nekoray",
        "function_declaration": "void DialogManageRoutes::accept()",
        "start_line": "96",
        "end_line": "109",
        "file_path": "ui/dialog_manage_routes.cpp",
        "docstring": "The function accept() in DialogManageRoutes saves the custom route settings and checks if the active routing has changed.\\nIt updates the routing display and assigns the active routing to the data store.\\nThe function sets the routing function name with a prefix and saves the routing configuration.\\nIf any changes are detected, it updates the info message to indicate a route change.\\nFinally, it sends a message to update the data store and closes the dialog with acceptance.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bfac51f6c4a7",
        "ground_truth": "void DialogManageRoutes::accept() {\n    D_C_SAVE_STRING(custom_route_global)\n    bool routeChanged = false;\n    if (NekoGui::dataStore->active_routing != active_routing) routeChanged = true;\n    SaveDisplayRouting(NekoGui::dataStore->routing.get());\n    NekoGui::dataStore->active_routing = active_routing;\n    NekoGui::dataStore->routing->fn = ROUTES_PREFIX + NekoGui::dataStore->active_routing;\n    if (NekoGui::dataStore->routing->Save()) routeChanged = true;\n    //\n    QString info = \"UpdateDataStore\";\n    if (routeChanged) info += \"RouteChanged\";\n    MW_dialog_message(Dialog_DialogManageRoutes, info);\n    QDialog::accept();\n}",
        "import_statements": [
            "#include \"dialog_manage_routes.h\"\n",
            "#include \"ui_dialog_manage_routes.h\"\n",
            "#include \"3rdparty/qv2ray/v2/ui/widgets/editors/w_JsonEditor.hpp\"\n",
            "#include \"3rdparty/qv2ray/v3/components/GeositeReader/GeositeReader.hpp\"\n",
            "#include \"main/GuiUtils.hpp\"\n",
            "#include \"fmt/Preset.hpp\"\n",
            "#include <QFile>\n",
            "#include <QMessageBox>\n",
            "#include <QListWidget>\n",
            "#include <QLineEdit>\n"
        ],
        "reference_api": [
            "D_C_SAVE_STRING",
            "QDialog::accept",
            "NekoGui::dataStore->routing.get",
            "SaveDisplayRouting",
            "NekoGui::dataStore->routing->Save",
            "MW_dialog_message"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SaveDisplayRouting",
                "code": "void DialogManageRoutes::SaveDisplayRouting(NekoGui::Routing *conf) {\n    conf->direct_ip = directIPTxt->toPlainText();\n    conf->direct_domain = directDomainTxt->toPlainText();\n    conf->proxy_ip = proxyIPTxt->toPlainText();\n    conf->proxy_domain = proxyDomainTxt->toPlainText();\n    conf->block_ip = blockIPTxt->toPlainText();\n    conf->block_domain = blockDomainTxt->toPlainText();\n    conf->def_outbound = ui->def_outbound->currentText();\n    conf->custom = CACHE.custom_route;\n    //\n    conf->sniffing_mode = ui->sniffing_mode->currentIndex();\n    conf->domain_strategy = ui->domainStrategyCombo->currentText();\n    conf->outbound_domain_strategy = ui->outbound_domain_strategy->currentText();\n    conf->use_dns_object = ui->use_dns_object->isChecked();\n    conf->dns_object = ui->dns_object->toPlainText();\n    conf->dns_routing = ui->dns_routing->isChecked();\n    conf->remote_dns = ui->remote_dns->currentText();\n    conf->remote_dns_strategy = ui->remote_dns_strategy->currentText();\n    conf->direct_dns = ui->direct_dns->currentText();\n    conf->direct_dns_strategy = ui->direct_dns_strategy->currentText();\n    conf->dns_final_out = ui->dns_final_out->currentText();\n}"
            }
        ],
        "third_party": [
            "D_C_SAVE_STRING",
            "QDialog::accept",
            "NekoGui::dataStore->routing.get",
            "NekoGui::dataStore->routing->Save",
            "MW_dialog_message"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "mapeditor/tiled",
        "function_declaration": "SharedTileset MapReaderPrivate::readTileset(QIODevice *device, const QString &path)",
        "start_line": "173",
        "end_line": "189",
        "file_path": "src/libtiled/mapreader.cpp",
        "docstring": "The function readTileset(QIODevice *device, const QString &path) initializes the process of reading a tileset from a given device and path.\\nIt clears any previous errors and sets the path.\\nThe function sets the device for XML reading and marks the process as reading an external tileset.\\nIf the XML reader identifies the start element as a \"tileset\", it reads the tileset.\\nIf not, it raises an error indicating the file is not a tileset.\\nFinally, it marks the reading process as complete and returns the tileset.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ce56331f659f",
        "ground_truth": "SharedTileset MapReaderPrivate::readTileset(QIODevice *device, const QString &path)\n{\n    mError.clear();\n    mPath.setPath(path);\n    SharedTileset tileset;\n    mReadingExternalTileset = true;\n     xml.setDevice(device);\n     if (xml.readNextStartElement() && xml.name() == QLatin1String(\"tileset\"))\n        tileset = readTileset();\n    else\n        xml.raiseError(tr(\"Not a tileset file.\"));\n     mReadingExternalTileset = false;\n    return tileset;\n}",
        "import_statements": [
            "#include \"mapreader.h\"\n",
            "#include \"compression.h\"\n",
            "#include \"gidmapper.h\"\n",
            "#include \"grouplayer.h\"\n",
            "#include \"imagelayer.h\"\n",
            "#include \"objectgroup.h\"\n",
            "#include \"objecttemplate.h\"\n",
            "#include \"map.h\"\n",
            "#include \"mapobject.h\"\n",
            "#include \"templatemanager.h\"\n",
            "#include \"tile.h\"\n",
            "#include \"tilelayer.h\"\n",
            "#include \"tilesetmanager.h\"\n",
            "#include \"wangset.h\"\n",
            "#include <QCoreApplication>\n",
            "#include <QDebug>\n",
            "#include <QDir>\n",
            "#include <QFileInfo>\n",
            "#include <QVector>\n",
            "#include <QXmlStreamReader>\n",
            "#include <memory>\n"
        ],
        "reference_api": [
            "QLatin1String",
            "mError.clear",
            "xml.setDevice",
            "xml.name",
            "readTileset",
            "xml.readNextStartElement",
            "mPath.setPath",
            "tr",
            "xml.raiseError"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "QLatin1String",
            "mError.clear",
            "xml.setDevice",
            "xml.name",
            "readTileset",
            "xml.readNextStartElement",
            "mPath.setPath",
            "tr",
            "xml.raiseError"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "moonlight-stream/moonlight-qt",
        "function_declaration": "static HMODULE WINAPI LoadLibraryExWHook(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)",
        "start_line": "130",
        "end_line": "138",
        "file_path": "AntiHooking/antihookingprotection.cpp",
        "docstring": "The static function LoadLibraryExWHook(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags) is a hook for loading a library with extended options.\\nIt first checks if the library file name is provided and if it is blacklisted.\\nIf the library is blacklisted, it sets an error indicating access is disabled by policy and returns null.\\nIf the library is not blacklisted, it calls the original LoadLibraryExW function to load the library.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c4502706d0af",
        "ground_truth": "static HMODULE WINAPI LoadLibraryExWHook(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)\n{\n    if (lpLibFileName && isImageBlacklistedW(lpLibFileName)) {\n        SetLastError(ERROR_ACCESS_DISABLED_BY_POLICY);\n        return nullptr;\n    }\n    return s_RealLoadLibraryExW(lpLibFileName, hFile, dwFlags);\n}",
        "import_statements": [
            "#include \"antihookingprotection.h\"\n",
            "#include <Windows.h>\n",
            "#include <detours.h>\n"
        ],
        "reference_api": [
            "s_RealLoadLibraryExW",
            "SetLastError",
            "isImageBlacklistedW"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "s_RealLoadLibraryExW",
            "SetLastError",
            "isImageBlacklistedW"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "moonlight-stream/moonlight-qt",
        "function_declaration": "QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)",
        "start_line": "107",
        "end_line": "129",
        "file_path": "app/backend/boxartmanager.cpp",
        "docstring": "The function loadBoxArtFromNetwork(NvComputer* computer, int appId) retrieves box art for a given application from the network.\\nIt creates an HTTP client for the specified computer and determines the cache path for the box art.\\nIt attempts to download the box art image using the HTTP client.\\nIf the image is successfully downloaded and is not null, it saves the image to the cache path.\\nIf saving is successful, it returns the local file URL of the cached image.\\nIf saving fails, it ensures any zero-byte file is removed.\\nIf the image download fails, it returns an empty URL.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d8b05a05cfe6",
        "ground_truth": "QUrl BoxArtManager::loadBoxArtFromNetwork(NvComputer* computer, int appId)\n{\n    NvHTTP http(computer);\n     QString cachePath = getFilePathForBoxArt(computer, appId);\n    QImage image;\n    try {\n        image = http.getBoxArt(appId);\n    } catch (...) {}\n     // Cache the box art on disk if it loaded\n    if (!image.isNull()) {\n        if (image.save(cachePath)) {\n            return QUrl::fromLocalFile(cachePath);\n        }\n        else {\n            // A failed save() may leave a zero byte file. Make sure that's removed.\n            QFile(cachePath).remove();\n        }\n    }\n     return QUrl();\n}",
        "import_statements": [
            "#include \"boxartmanager.h\"\n",
            "#include \"../path.h\"\n",
            "#include <QImageReader>\n",
            "#include <QImageWriter>\n",
            "#include \"boxartmanager.moc\"\n"
        ],
        "reference_api": [
            "QUrl",
            "image.save",
            "QFile(cachePath).remove",
            "QFile",
            "QUrl::fromLocalFile",
            "image.isNull",
            "getFilePathForBoxArt",
            "http.getBoxArt"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getFilePathForBoxArt",
                "code": "QString\nBoxArtManager::getFilePathForBoxArt(NvComputer* computer, int appId)\n{\n    QDir dir = m_BoxArtDir;\n\n    // Create the cache directory if it did not already exist\n    if (!dir.exists(computer->uuid)) {\n        dir.mkdir(computer->uuid);\n    }\n\n    // Change to this computer's box art cache folder\n    dir.cd(computer->uuid);\n\n    // Try to open the cached file\n    return dir.filePath(QString::number(appId) + \".png\");\n}"
            }
        ],
        "third_party": [
            "QUrl",
            "image.save",
            "QFile(cachePath).remove",
            "QFile",
            "QUrl::fromLocalFile",
            "image.isNull",
            "http.getBoxArt"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "moonlight-stream/moonlight-qt",
        "function_declaration": "void ComputerManager::handleMdnsServiceResolved(MdnsPendingComputer* computer,\n                                                QVector<QHostAddress>& addresses)",
        "start_line": "406",
        "end_line": "442",
        "file_path": "app/backend/computermanager.cpp",
        "docstring": "The function handleMdnsServiceResolved(MdnsPendingComputer* computer, QVector<QHostAddress>& addresses) processes resolved mDNS services for a computer.\\nIt first retrieves the best global IPv6 address.\\nIt attempts to add the host using an IPv4 address by iterating through the addresses and checking their protocol.\\nIf an IPv4 address is found, it adds the new host and sets a flag to true.\\nIf no IPv4 address is found, it falls back to using an IPv6 address.\\nIt checks if the IPv6 address is link-local, site-local, or unique local and adds the host accordingly.\\nFinally, it removes the computer from the pending resolution list and schedules it for deletion.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "40201ad62fc4",
        "ground_truth": "void ComputerManager::handleMdnsServiceResolved(MdnsPendingComputer* computer,\n                                                QVector<QHostAddress>& addresses)\n{\n    QHostAddress v6Global = getBestGlobalAddressV6(addresses);\n    bool added = false;\n     // Add the host using the IPv4 address\n    for (const QHostAddress& address : addresses) {\n        if (address.protocol() == QAbstractSocket::IPv4Protocol) {\n            // NB: We don't just call addNewHost() here with v6Global because the IPv6\n            // address may not be reachable (if the user hasn't installed the IPv6 helper yet\n            // or if this host lacks outbound IPv6 capability). We want to add IPv6 even if\n            // it's not currently reachable.\n            addNewHost(NvAddress(address, computer->port()), true, NvAddress(v6Global, computer->port()));\n            added = true;\n            break;\n        }\n    }\n     if (!added) {\n        // If we get here, there wasn't an IPv4 address so we'll do it v6-only\n        for (const QHostAddress& address : addresses) {\n            if (address.protocol() == QAbstractSocket::IPv6Protocol) {\n                // Use a link-local or site-local address for the \"local address\"\n                if (address.isInSubnet(QHostAddress(\"fe80::\"), 10) ||\n                        address.isInSubnet(QHostAddress(\"fec0::\"), 10) ||\n                        address.isInSubnet(QHostAddress(\"fc00::\"), 7)) {\n                    addNewHost(NvAddress(address, computer->port()), true, NvAddress(v6Global, computer->port()));\n                    break;\n                }\n            }\n        }\n    }\n     m_PendingResolution.removeOne(computer);\n    computer->deleteLater();\n}",
        "import_statements": [
            "#include \"computermanager.h\"\n",
            "#include \"boxartmanager.h\"\n",
            "#include \"nvhttp.h\"\n",
            "#include \"nvpairingmanager.h\"\n",
            "#include <Limelight.h>\n",
            "#include <QtEndian>\n",
            "#include <QThread>\n",
            "#include <QThreadPool>\n",
            "#include <QCoreApplication>\n",
            "#include <random>\n",
            "#include \"computermanager.moc\"\n"
        ],
        "reference_api": [
            "computer->deleteLater",
            "address.isInSubnet",
            "computer->port",
            "addNewHost",
            "m_PendingResolution.removeOne",
            "QHostAddress",
            "address.protocol",
            "NvAddress",
            "getBestGlobalAddressV6"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "addNewHost",
                "code": "void ComputerManager::addNewHost(NvAddress address, bool mdns, NvAddress mdnsIpv6Address)\n{\n    // Punt to a worker thread to avoid stalling the\n    // UI while waiting for serverinfo query to complete\n    PendingAddTask* addTask = new PendingAddTask(this, address, mdnsIpv6Address, mdns);\n    QThreadPool::globalInstance()->start(addTask);\n}"
            },
            {
                "name": "getBestGlobalAddressV6",
                "code": "QHostAddress ComputerManager::getBestGlobalAddressV6(QVector<QHostAddress> &addresses)\n{\n    for (const QHostAddress& address : addresses) {\n        if (address.protocol() == QAbstractSocket::IPv6Protocol) {\n            if (address.isInSubnet(QHostAddress(\"fe80::\"), 10)) {\n                // Link-local\n                continue;\n            }\n\n            if (address.isInSubnet(QHostAddress(\"fec0::\"), 10)) {\n                qInfo() << \"Ignoring site-local address:\" << address;\n                continue;\n            }\n\n            if (address.isInSubnet(QHostAddress(\"fc00::\"), 7)) {\n                qInfo() << \"Ignoring ULA:\" << address;\n                continue;\n            }\n\n            if (address.isInSubnet(QHostAddress(\"2002::\"), 16)) {\n                qInfo() << \"Ignoring 6to4 address:\" << address;\n                continue;\n            }\n\n            if (address.isInSubnet(QHostAddress(\"2001::\"), 32)) {\n                qInfo() << \"Ignoring Teredo address:\" << address;\n                continue;\n            }\n\n            return address;\n        }\n    }\n\n    return QHostAddress();\n}"
            }
        ],
        "third_party": [
            "computer->deleteLater",
            "address.isInSubnet",
            "computer->port",
            "m_PendingResolution.removeOne",
            "QHostAddress",
            "address.protocol",
            "NvAddress"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "moonlight-stream/moonlight-qt",
        "function_declaration": "void ComputerManager::saveHost(NvComputer *computer)",
        "start_line": "444",
        "end_line": "455",
        "file_path": "app/backend/computermanager.cpp",
        "docstring": "The function saveHost(NvComputer *computer) saves the host information if any serializable properties have changed.\\nIt locks the mutex and reads the computer's data.\\nIf the current serialized data differs from the last saved state, it unlocks the mutexes and queues a request to save the hosts to QSettings.\\nThis ensures that only modified host information is saved, optimizing the process.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6a765d35d3a7",
        "ground_truth": "void ComputerManager::saveHost(NvComputer *computer)\n{\n    // If no serializable properties changed, don't bother saving hosts\n    QMutexLocker lock(&m_DelayedFlushMutex);\n    QReadLocker computerLock(&computer->lock);\n    if (!m_LastSerializedHosts.value(computer->uuid).isEqualSerialized(*computer)) {\n        // Queue a request for a delayed flush to QSettings outside of the lock\n        computerLock.unlock();\n        lock.unlock();\n        saveHosts();\n    }\n}",
        "import_statements": [
            "#include \"computermanager.h\"\n",
            "#include \"boxartmanager.h\"\n",
            "#include \"nvhttp.h\"\n",
            "#include \"nvpairingmanager.h\"\n",
            "#include <Limelight.h>\n",
            "#include <QtEndian>\n",
            "#include <QThread>\n",
            "#include <QThreadPool>\n",
            "#include <QCoreApplication>\n",
            "#include <random>\n",
            "#include \"computermanager.moc\"\n"
        ],
        "reference_api": [
            "m_LastSerializedHosts.value(computer->uuid).isEqualSerialized",
            "m_LastSerializedHosts.value",
            "computerLock.unlock",
            "saveHosts",
            "lock.unlock"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "saveHosts",
                "code": "void ComputerManager::saveHosts()\n{\n    Q_ASSERT(m_DelayedFlushThread != nullptr && m_DelayedFlushThread->isRunning());\n\n    // Punt to a worker thread because QSettings on macOS can take ages (> 500 ms)\n    // to persist our host list to disk (especially when a host has a bunch of apps).\n    QMutexLocker locker(&m_DelayedFlushMutex);\n    m_NeedsDelayedFlush = true;\n    m_DelayedFlushCondition.wakeOne();\n}"
            }
        ],
        "third_party": [
            "m_LastSerializedHosts.value(computer->uuid).isEqualSerialized",
            "m_LastSerializedHosts.value",
            "computerLock.unlock",
            "lock.unlock"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "moonlight-stream/moonlight-qt",
        "function_declaration": "bool NvComputer::updateAppList(QVector<NvApp> newAppList)",
        "start_line": "460",
        "end_line": "478",
        "file_path": "app/backend/nvcomputer.cpp",
        "docstring": "The function updateAppList(QVector<NvApp> newAppList) updates the application list if it is different from the current list.\\nIt compares the current app list with the new list and returns false if they are identical.\\nIf the lists differ, it propagates client-side attributes such as hidden and directLaunch from the existing apps to the corresponding new apps based on their IDs.\\nIt then updates the app list with the new list, sorts the app list, and returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "01df52cf216b",
        "ground_truth": "bool NvComputer::updateAppList(QVector<NvApp> newAppList) {\n    if (appList == newAppList) {\n        return false;\n    }\n     // Propagate client-side attributes to the new app list\n    for (const NvApp& existingApp : appList) {\n        for (NvApp& newApp : newAppList) {\n            if (existingApp.id == newApp.id) {\n                newApp.hidden = existingApp.hidden;\n                newApp.directLaunch = existingApp.directLaunch;\n            }\n        }\n    }\n     appList = newAppList;\n    sortAppList();\n    return true;\n}",
        "import_statements": [
            "#include \"nvcomputer.h\"\n",
            "#include \"nvapp.h\"\n",
            "#include \"settings/compatfetcher.h\"\n",
            "#include <QUdpSocket>\n",
            "#include <QHostInfo>\n",
            "#include <QNetworkInterface>\n",
            "#include <QNetworkProxy>\n"
        ],
        "reference_api": [
            "sortAppList"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "sortAppList",
                "code": "void NvComputer::sortAppList()\n{\n    std::stable_sort(appList.begin(), appList.end(), [](const NvApp& app1, const NvApp& app2) {\n       return app1.name.toLower() < app2.name.toLower();\n    });\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Qt",
        "owner/repo": "moonlight-stream/moonlight-qt",
        "function_declaration": "void QuitCommandLineParser::parse(const QStringList &args)",
        "start_line": "217",
        "end_line": "244",
        "file_path": "app/cli/commandlineparser.cpp",
        "docstring": "The function parse(const QStringList &args) in QuitCommandLineParser processes command-line arguments to quit an app on a specified host.\\nIt initializes a CommandLineParser and sets up common options, including a description and positional arguments for \"quit\" and \"host\".\\nIf argument parsing fails, it shows an error message.\\nIt handles unknown, help, and version options.\\nIt verifies that a host argument is provided and sets the m_Host member variable to the provided host value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "527d363b3a18",
        "ground_truth": "void QuitCommandLineParser::parse(const QStringList &args)\n{\n    CommandLineParser parser;\n    parser.setupCommonOptions();\n    parser.setApplicationDescription(\n        \"\\n\"\n        \"Quit the currently running app on the given host.\"\n    );\n    parser.addPositionalArgument(\"quit\", \"quit running app\");\n    parser.addPositionalArgument(\"host\", \"Host computer name, UUID, or IP address\", \"<host>\");\n     if (!parser.parse(args)) {\n        parser.showError(parser.errorText());\n    }\n     parser.handleUnknownOptions();\n     // This method will not return and terminates the process if --version or\n    // --help is specified\n    parser.handleHelpAndVersionOptions();\n     // Verify that host has been provided\n    auto posArgs = parser.positionalArguments();\n    if (posArgs.length() < 2) {\n        parser.showError(\"Host not provided\");\n    }\n    m_Host = parser.positionalArguments().at(1);\n}",
        "import_statements": [
            "#include \"commandlineparser.h\"\n",
            "#include <QCommandLineParser>\n",
            "#include <QRegularExpression>\n"
        ],
        "reference_api": [
            "posArgs.length",
            "parser.showError",
            "parser.handleHelpAndVersionOptions",
            "parser.positionalArguments().at",
            "parser.errorText",
            "parser.parse",
            "parser.handleUnknownOptions",
            "parser.setApplicationDescription",
            "parser.addPositionalArgument",
            "parser.positionalArguments",
            "parser.setupCommonOptions"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "posArgs.length",
            "parser.showError",
            "parser.handleHelpAndVersionOptions",
            "parser.positionalArguments().at",
            "parser.errorText",
            "parser.parse",
            "parser.handleUnknownOptions",
            "parser.setApplicationDescription",
            "parser.addPositionalArgument",
            "parser.positionalArguments",
            "parser.setupCommonOptions"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value QDateWrap::addYears(const Napi::CallbackInfo& info)",
        "start_line": "86",
        "end_line": "93",
        "file_path": "src/cpp/lib/QtCore/QDate/qdate_wrap.cpp",
        "docstring": "The function addYears(const Napi::CallbackInfo& info) in the QDateWrap class adds a specified number of years to the current QDate instance.\\nIt retrieves the number of years to add from the function's arguments and creates a new QDate object with the updated date.\\nThen, it constructs a new QDateWrap instance with the modified date and returns it.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dca3348795d4",
        "ground_truth": "Napi::Value QDateWrap::addYears(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  int nyears = info[0].As<Napi::Number>().Int32Value();\n  QDate date = this->instance->addYears(nyears);\n  auto instance = QDateWrap::constructor.New({Napi::External<QDate>::New(\n      env, new QDate(date.year(), date.month(), date.day()))});\n  return instance;\n}",
        "import_statements": [
            "#include \"QtCore/QDate/qdate_wrap.h\"\n",
            "#include <QDate>\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtCore/QVariant/qvariant_wrap.h\"\n"
        ],
        "reference_api": [
            "QDateWrap::constructor.New",
            "date.month",
            "Napi::External<QDate>::New",
            "date.year",
            "info[0].As<Napi::Number>().Int32Value",
            "info.Env",
            "date.day",
            "this->instance->addYears",
            "info[0].As<Napi::Number>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "QDateWrap::constructor.New",
            "date.month",
            "Napi::External<QDate>::New",
            "date.year",
            "info[0].As<Napi::Number>().Int32Value",
            "info.Env",
            "date.day",
            "this->instance->addYears",
            "info[0].As<Napi::Number>"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value StaticDateWrapMethods::currentDate(const Napi::CallbackInfo& info) ",
        "start_line": "177",
        "end_line": "183",
        "file_path": "src/cpp/lib/QtCore/QDate/qdate_wrap.cpp",
        "docstring": "The function currentDate(const Napi::CallbackInfo& info) retrieves the current date using QDate::currentDate().\\nIt creates a new instance of QDateWrap with the current date's year, month, and day.\\nThis new instance is then returned as a Napi::Value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3f8f791368dc",
        "ground_truth": "Napi::Value StaticDateWrapMethods::currentDate(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  QDate date = QDate::currentDate();\n  auto instance = QDateWrap::constructor.New({Napi::External<QDate>::New(\n      env, new QDate(date.year(), date.month(), date.day()))});\n  return instance;\n}",
        "import_statements": [
            "#include \"QtCore/QDate/qdate_wrap.h\"\n",
            "#include <QDate>\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtCore/QVariant/qvariant_wrap.h\"\n"
        ],
        "reference_api": [
            "QDateWrap::constructor.New",
            "Napi::External<QDate>::New",
            "date.year",
            "info.Env",
            "QDate::currentDate",
            "date.day",
            "date.month"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "QDateWrap::constructor.New",
            "Napi::External<QDate>::New",
            "date.year",
            "info.Env",
            "QDate::currentDate",
            "date.day",
            "date.month"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value StaticDateWrapMethods::isLeapYear(const Napi::CallbackInfo& info)",
        "start_line": "195",
        "end_line": "199",
        "file_path": "src/cpp/lib/QtCore/QDate/qdate_wrap.cpp",
        "docstring": "The function isLeapYear(const Napi::CallbackInfo& info) determines if a given year is a leap year.\\nIt retrieves the year from the function's arguments, converts it to an integer, and checks if the year is a leap year using QDate::isLeapYear.\\nIt returns the result as a Napi::Value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "64d1b8308f8f",
        "ground_truth": "Napi::Value StaticDateWrapMethods::isLeapYear(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  int year = info[0].As<Napi::Number>().Int32Value();\n  return Napi::Value::From(env, QDate::isLeapYear(year));\n}",
        "import_statements": [
            "#include \"QtCore/QDate/qdate_wrap.h\"\n",
            "#include <QDate>\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtCore/QVariant/qvariant_wrap.h\"\n"
        ],
        "reference_api": [
            "QDate::isLeapYear",
            "info[0].As<Napi::Number>().Int32Value",
            "info.Env",
            "Napi::Value::From",
            "info[0].As<Napi::Number>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "QDate::isLeapYear",
            "info[0].As<Napi::Number>().Int32Value",
            "info.Env",
            "Napi::Value::From",
            "info[0].As<Napi::Number>"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value QDateTimeWrap::daysTo(const Napi::CallbackInfo& info)",
        "start_line": "138",
        "end_line": "145",
        "file_path": "src/cpp/lib/QtCore/QDateTime/qdatetime_wrap.cpp",
        "docstring": "The function QDateTimeWrap::daysTo(const Napi::CallbackInfo& info) calculates the number of days between two QDateTimeWrap instances.\\nIt retrieves the environment and the other QDateTimeWrap object from the callback info.\\nIt then unwraps the other QDateTimeWrap instance and calculates the number of days to it from the current instance.\\nFinally, it returns the result as a Napi::Value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "aef23b7ae456",
        "ground_truth": "Napi::Value QDateTimeWrap::daysTo(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  Napi::Object otherObject = info[0].As<Napi::Object>();\n  QDateTimeWrap* otherWrap =\n      Napi::ObjectWrap<QDateTimeWrap>::Unwrap(otherObject);\n  qint64 result = this->instance->daysTo(*otherWrap->getInternalInstance());\n  return Napi::Value::From(env, result);\n}",
        "import_statements": [
            "#include \"QtCore/QDateTime/qdatetime_wrap.h\"\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtCore/QDate/qdate_wrap.h\"\n",
            "#include \"QtCore/QTime/qtime_wrap.h\"\n",
            "#include \"QtCore/QVariant/qvariant_wrap.h\"\n"
        ],
        "reference_api": [
            "Napi::ObjectWrap<QDateTimeWrap>::Unwrap",
            "this->instance->daysTo",
            "info.Env",
            "otherWrap->getInternalInstance",
            "info[0].As<Napi::Object>",
            "Napi::Value::From"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Napi::ObjectWrap<QDateTimeWrap>::Unwrap",
            "this->instance->daysTo",
            "info.Env",
            "otherWrap->getInternalInstance",
            "info[0].As<Napi::Object>",
            "Napi::Value::From"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value QDateTimeWrap::msecsTo(const Napi::CallbackInfo& info)",
        "start_line": "162",
        "end_line": "169",
        "file_path": "src/cpp/lib/QtCore/QDateTime/qdatetime_wrap.cpp",
        "docstring": "The function msecsTo(const Napi::CallbackInfo& info) calculates the milliseconds between the current QDateTimeWrap instance and another QDateTimeWrap instance provided as an argument.\\nIt retrieves the environment and the other QDateTimeWrap object from the function arguments.\\nIt then unwraps the internal QDateTime instance from the other object and calculates the milliseconds difference.\\nFinally, it returns this difference as a Napi::Value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6acfa242f879",
        "ground_truth": "Napi::Value QDateTimeWrap::msecsTo(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  Napi::Object otherObject = info[0].As<Napi::Object>();\n  QDateTimeWrap* otherWrap =\n      Napi::ObjectWrap<QDateTimeWrap>::Unwrap(otherObject);\n  qint64 result = this->instance->msecsTo(*otherWrap->getInternalInstance());\n  return Napi::Value::From(env, result);\n}",
        "import_statements": [
            "#include \"QtCore/QDateTime/qdatetime_wrap.h\"\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtCore/QDate/qdate_wrap.h\"\n",
            "#include \"QtCore/QTime/qtime_wrap.h\"\n",
            "#include \"QtCore/QVariant/qvariant_wrap.h\"\n"
        ],
        "reference_api": [
            "Napi::ObjectWrap<QDateTimeWrap>::Unwrap",
            "info.Env",
            "otherWrap->getInternalInstance",
            "this->instance->msecsTo",
            "info[0].As<Napi::Object>",
            "Napi::Value::From"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Napi::ObjectWrap<QDateTimeWrap>::Unwrap",
            "info.Env",
            "otherWrap->getInternalInstance",
            "this->instance->msecsTo",
            "info[0].As<Napi::Object>",
            "Napi::Value::From"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value QItemSelectionModelWrap::rowIntersectsSelection",
        "start_line": "138",
        "end_line": "147",
        "file_path": "src/cpp/lib/QtCore/QItemSelectionModel/qitemselectionmodel_wrap.cpp",
        "docstring": "The function rowIntersectsSelection(const Napi::CallbackInfo& info) checks if a specified row intersects with the current selection.\\nIt retrieves the environment and the row number from the function arguments.\\nIt also unwraps the parent QModelIndex object from the arguments.\\nIt then calls the rowIntersectsSelection method on the internal instance using the row and parent index.\\nFinally, it returns the result as a Napi::Boolean.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fd6c4b070349",
        "ground_truth": "Napi::Value QItemSelectionModelWrap::rowIntersectsSelection(\n    const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  int row = info[0].As<Napi::Number>().Int32Value();\n  QModelIndexWrap* parentWrap =\n      Napi::ObjectWrap<QModelIndexWrap>::Unwrap(info[1].As<Napi::Object>());\n  QModelIndex* parent = parentWrap->getInternalInstance();\n  bool result = this->instance->rowIntersectsSelection(row, *parent);\n  return Napi::Boolean::New(env, result);\n}",
        "import_statements": [
            "#include \"QtCore/QItemSelectionModel/qitemselectionmodel_wrap.h\"\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtCore/QModelIndex/qmodelindex_wrap.h\"\n"
        ],
        "reference_api": [
            "this->instance->rowIntersectsSelection",
            "info[0].As<Napi::Number>().Int32Value",
            "info.Env",
            "Napi::ObjectWrap<QModelIndexWrap>::Unwrap",
            "Napi::Boolean::New",
            "parentWrap->getInternalInstance",
            "info[1].As<Napi::Object>",
            "info[0].As<Napi::Number>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->instance->rowIntersectsSelection",
            "info[0].As<Napi::Number>().Int32Value",
            "info.Env",
            "Napi::ObjectWrap<QModelIndexWrap>::Unwrap",
            "Napi::Boolean::New",
            "parentWrap->getInternalInstance",
            "info[1].As<Napi::Object>",
            "info[0].As<Napi::Number>"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value QSizeWrap::expandedTo(const Napi::CallbackInfo& info)",
        "start_line": "98",
        "end_line": "107",
        "file_path": "src/cpp/lib/QtCore/QSize/qsize_wrap.cpp",
        "docstring": "The function expandedTo(const Napi::CallbackInfo& info) returns the expanded size of the current QSizeWrap instance compared to another QSizeWrap instance.\\nIt retrieves the environment and the other QSizeWrap object from the function arguments.\\nIt unwraps the internal QSize instance from the other object and calculates the expanded size.\\nIt then creates a new QSizeWrap instance with the result and returns it as a Napi::Value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "05bc5ac254cf",
        "ground_truth": "Napi::Value QSizeWrap::expandedTo(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  QSizeWrap* otherSizeWrap =\n      Napi::ObjectWrap<QSizeWrap>::Unwrap(info[0].As<Napi::Object>());\n  QSize* otherSize = otherSizeWrap->getInternalInstance();\n  QSize result = this->instance->expandedTo(*otherSize);\n  auto resultInstance = QSizeWrap::constructor.New(\n      {Napi::External<QSize>::New(env, new QSize(result))});\n  return resultInstance;\n}",
        "import_statements": [
            "#include \"QtCore/QSize/qsize_wrap.h\"\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtCore/QVariant/qvariant_wrap.h\"\n"
        ],
        "reference_api": [
            "otherSizeWrap->getInternalInstance",
            "info.Env",
            "this->instance->expandedTo",
            "info[0].As<Napi::Object>",
            "QSizeWrap::constructor.New",
            "Napi::ObjectWrap<QSizeWrap>::Unwrap",
            "Napi::External<QSize>::New"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "otherSizeWrap->getInternalInstance",
            "info.Env",
            "this->instance->expandedTo",
            "info[0].As<Napi::Object>",
            "QSizeWrap::constructor.New",
            "Napi::ObjectWrap<QSizeWrap>::Unwrap",
            "Napi::External<QSize>::New"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value StaticQApplicationWrapMethods::desktopFileName",
        "start_line": "244",
        "end_line": "249",
        "file_path": "src/cpp/lib/QtGui/QApplication/qapplication_wrap.cpp",
        "docstring": "The function desktopFileName(const Napi::CallbackInfo& info) retrieves the desktop file name using the QApplication::desktopFileName() method.\\nIt converts the result to a standard string and returns it as a Napi::String in the JavaScript environment.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1efa69400994",
        "ground_truth": "Napi::Value StaticQApplicationWrapMethods::desktopFileName(\n    const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  QString result = QApplication::desktopFileName();\n  return Napi::String::New(env, result.toStdString());\n}",
        "import_statements": [
            "#include \"QtGui/QApplication/qapplication_wrap.h\"\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtGui/QClipboard/qclipboard_wrap.h\"\n",
            "#include \"QtGui/QIcon/qicon_wrap.h\"\n",
            "#include \"QtGui/QPalette/qpalette_wrap.h\"\n",
            "#include \"QtGui/QStyle/qstyle_wrap.h\"\n",
            "#include \"core/Integration/qode-api.h\"\n",
            "#include \"core/WrapperCache/wrappercache.h\"\n"
        ],
        "reference_api": [
            "QApplication::desktopFileName",
            "info.Env",
            "result.toStdString",
            "Napi::String::New"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "QApplication::desktopFileName",
            "info.Env",
            "result.toStdString",
            "Napi::String::New"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value QClipboardWrap::mimeData(const Napi::CallbackInfo& info)",
        "start_line": "140",
        "end_line": "153",
        "file_path": "src/cpp/lib/QtGui/QClipboard/qclipboard_wrap.cpp",
        "docstring": "The function mimeData(const Napi::CallbackInfo& info) retrieves and clones the MIME data from the clipboard.\\nIt gets the environment and mode from the function arguments and retrieves the MIME data from the clipboard based on the specified mode.\\nSince QMimeData lacks a copy constructor, it manually clones the MIME data into a new QMimeData instance.\\nIt then creates a new JavaScript instance of QMimeDataWrap with the cloned data and returns it.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1f5a560eaaa6",
        "ground_truth": "Napi::Value QClipboardWrap::mimeData(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  Napi::Number mode = info[0].As<Napi::Number>();\n  QMimeData* mimeData = const_cast<QMimeData*>(this->instance->mimeData(\n      static_cast<QClipboard::Mode>(mode.Int32Value())));\n   QMimeData* mimeDataClone = new QMimeData();\n  // QMimeData has no copy constructor so I do this\n  QMimeDataWrap::cloneFromMimeDataToData(mimeData, mimeDataClone);\n   auto instance = QMimeDataWrap::constructor.New(\n      {Napi::External<QMimeData>::New(env, mimeDataClone)});\n  return instance;\n}",
        "import_statements": [
            "#include \"QtGui/QClipboard/qclipboard_wrap.h\"\n",
            "#include <QtCore/QMimeData/qmimedata_wrap.h>\n",
            "#include <QtGui/QPixmap/qpixmap_wrap.h>\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"core/WrapperCache/wrappercache.h\"\n"
        ],
        "reference_api": [
            "const_cast<QMimeData*>",
            "info.Env",
            "QMimeDataWrap::cloneFromMimeDataToData",
            "Napi::External<QMimeData>::New",
            "mode.Int32Value",
            "this->instance->mimeData",
            "static_cast<QClipboard::Mode>",
            "info[0].As<Napi::Number>",
            "QMimeDataWrap::constructor.New"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "const_cast<QMimeData*>",
            "info.Env",
            "QMimeDataWrap::cloneFromMimeDataToData",
            "Napi::External<QMimeData>::New",
            "mode.Int32Value",
            "this->instance->mimeData",
            "static_cast<QClipboard::Mode>",
            "info[0].As<Napi::Number>",
            "QMimeDataWrap::constructor.New"
        ]
    },
    {
        "subclass": "Qt",
        "owner/repo": "nodegui/nodegui",
        "function_declaration": "Napi::Value QDragWrap::source(const Napi::CallbackInfo& info)",
        "start_line": "189",
        "end_line": "197",
        "file_path": "src/cpp/lib/QtGui/QDrag/qdrag_wrap.cpp",
        "docstring": "The function source(const Napi::CallbackInfo& info) retrieves the source object of a QDragWrap instance.\\nIt gets the environment from the function arguments and the source QObject from the QDragWrap instance.\\nIt then creates a new QObjectWrap instance using the source object and returns this new instance.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2c6dfc2d7eec",
        "ground_truth": "Napi::Value QDragWrap::source(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  QObject* source = this->instance->source();\n  // We can likely call a wrap directly since QObjectWrap is smart and uses\n  // QPointer?\n  auto instance =\n      QObjectWrap::constructor.New({Napi::External<QObject>::New(env, source)});\n  return instance;\n}",
        "import_statements": [
            "#include \"QtGui/QDrag/qdrag_wrap.h\"\n",
            "#include \"Extras/Utils/nutils.h\"\n",
            "#include \"QtCore/QMimeData/qmimedata_wrap.h\"\n",
            "#include \"QtCore/QObject/qobject_wrap.h\"\n",
            "#include \"QtCore/QPoint/qpoint_wrap.h\"\n",
            "#include \"QtGui/QPixmap/qpixmap_wrap.h\"\n"
        ],
        "reference_api": [
            "QObjectWrap::constructor.New",
            "info.Env",
            "this->instance->source",
            "Napi::External<QObject>::New"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "QObjectWrap::constructor.New",
            "info.Env",
            "this->instance->source",
            "Napi::External<QObject>::New"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected override void OnMouseMove(MouseEventArgs e)",
        "start_line": "337",
        "end_line": "379",
        "file_path": "SunnyUI/Charts/UIBarChart.cs",
        "docstring": "The method OnMouseMove(MouseEventArgs e) handles the mouse move event.\\nIt first calls the base class's OnMouseMove method and then checks if a tooltip should be visible.\\nIf the mouse is within the grid bounds, it calculates the SelectIndex based on the mouse location.\\nIf a valid SelectIndex is found and there are bars available, it updates the tooltip text and size if necessary.\\nIt then calculates the tooltip's position, ensuring it stays within the grid bounds.\\nThe tooltip visibility is updated based on the validity of the tips.\\nExceptions during this process are caught and logged to the console.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "29908bfd3b4b",
        "ground_truth": "protected override void OnMouseMove(MouseEventArgs e)\n{\n    base.OnMouseMove(e);\n    try\n    {\n        if (!Option.ToolTip.Visible) return;\n        if (e.Location.X > Option.Grid.Left && e.Location.X < Width - Option.Grid.Right\n                                               && e.Location.Y > Option.Grid.Top &&\n                                               e.Location.Y < Height - Option.Grid.Bottom)\n        {\n            SelectIndex = (int)((e.Location.X - Option.Grid.Left) / DrawBarWidth);\n        }\n        else\n        {\n            SelectIndex = -1;\n        }\n        if (SelectIndex >= 0 && Bars.Count > 0)\n        {\n            if (tip.Text != Bars[0][selectIndex].Tips)\n            {\n                tip.Text = Bars[0][selectIndex].Tips;\n                tip.Size = new Size(Bars[0][selectIndex].Size.Width + 4, Bars[0][selectIndex].Size.Height + 4);\n            }\n            int x = e.Location.X + 15;\n            int y = e.Location.Y + 20;\n            if (e.Location.X + 15 + tip.Width > Width - Option.Grid.Right)\n                x = e.Location.X - tip.Width - 2;\n            if (e.Location.Y + 20 + tip.Height > Height - Option.Grid.Bottom)\n                y = e.Location.Y - tip.Height - 2;\n            tip.Left = x;\n            tip.Top = y;\n            if (!tip.Visible) tip.Visible = Bars[0][selectIndex].Tips.IsValid();\n        }\n    }\n    catch (Exception exception)\n    {\n        Console.WriteLine(exception);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Concurrent",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Drawing2D",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "Console.WriteLine",
            "Bars[0][selectIndex].Tips.IsValid",
            "base.OnMouseMove"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Bars[0][selectIndex].Tips.IsValid",
            "base.OnMouseMove"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected override void DrawOption(Graphics g)",
        "start_line": "448",
        "end_line": "462",
        "file_path": "SunnyUI/Charts/UIBarChart.cs",
        "docstring": "The protected override function DrawOption(Graphics g) renders various elements of a chart if drawing is needed and an option is set.\\nIt first checks if the Option is null or if drawing is not needed.\\nIf a tooltip with a shadow axis pointer is present, it draws the tooltip.\\nIt then draws the series, axis, title, and if a tooltip with a line axis pointer is present, it draws the tooltip again.\\nFinally, it draws the legend and axis scales.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c04d17af6942",
        "ground_truth": "protected override void DrawOption(Graphics g)\n{\n    if (Option == null) return;\n    if (!NeedDraw) return;\n    if (Option.ToolTip != null && Option.ToolTip.AxisPointer.Type == UIAxisPointerType.Shadow) DrawToolTip(g);\n    DrawSeries(g, Option.Series);\n    DrawAxis(g);\n    DrawTitle(g, Option.Title);\n    if (Option.ToolTip != null && Option.ToolTip.AxisPointer.Type == UIAxisPointerType.Line) DrawToolTip(g);\n    DrawLegend(g, Option.Legend);\n    DrawAxisScales(g);\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Concurrent",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Drawing2D",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "DrawToolTip",
            "DrawAxis",
            "DrawAxisScales",
            "DrawTitle",
            "DrawSeries",
            "DrawLegend"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "DrawToolTip",
                "code": "protected virtual void DrawToolTip(Graphics g)\n        {\n            if (selectIndex < 0) return;\n            if (Option.ToolTip.AxisPointer.Type == UIAxisPointerType.Line)\n            {\n                float x = DrawOrigin.X + SelectIndex * DrawBarWidth + DrawBarWidth / 2.0f;\n                g.DrawLine(ChartStyle.ToolTipShadowColor, x, DrawOrigin.Y, x, Option.Grid.Top);\n            }\n\n            if (Option.ToolTip.AxisPointer.Type == UIAxisPointerType.Shadow)\n            {\n                float x = DrawOrigin.X + SelectIndex * DrawBarWidth;\n                g.FillRectangle(ChartStyle.ToolTipShadowColor, x, Option.Grid.Top, DrawBarWidth, Height - Option.Grid.Top - Option.Grid.Bottom);\n            }\n        }"
            },
            {
                "name": "DrawAxis",
                "code": "protected virtual void DrawAxis(Graphics g)\n        {\n            using var TempFont = Font.DPIScaleFont(UIStyles.DefaultSubFontSize);\n            g.FillRectangle(FillColor, Option.Grid.Left, 1, Width - Option.Grid.Left - Option.Grid.Right, Option.Grid.Top);\n            g.FillRectangle(FillColor, Option.Grid.Left, Height - Option.Grid.Bottom, Width - Option.Grid.Left - Option.Grid.Right, Option.Grid.Bottom - 1);\n\n            if (YAxisStart >= 0) g.DrawLine(ForeColor, DrawOrigin, new Point(DrawOrigin.X + DrawSize.Width, DrawOrigin.Y));\n            if (YAxisEnd <= 0) g.DrawLine(ForeColor, new Point(DrawOrigin.X, Option.Grid.Top), new Point(DrawOrigin.X + DrawSize.Width, Option.Grid.Top));\n\n            g.DrawLine(ForeColor, DrawOrigin, new Point(DrawOrigin.X, DrawOrigin.Y - DrawSize.Height));\n            g.DrawLine(ForeColor, DrawOrigin, new Point(Width - Option.Grid.Right, DrawOrigin.Y));\n\n            if (Option.XAxis.AxisTick.Show)\n            {\n                float start = DrawOrigin.X + DrawBarWidth / 2.0f;\n                for (int i = 0; i < Option.XAxis.Data.Count; i++)\n                {\n                    g.DrawLine(ForeColor, start, DrawOrigin.Y, start, DrawOrigin.Y + Option.XAxis.AxisTick.Length);\n                    start += DrawBarWidth;\n                }\n            }\n\n            if (Option.XAxis.AxisLabel.Show)\n            {\n                float start = DrawOrigin.X;\n                foreach (var data in Option.XAxis.Data)\n                {\n                    int angle = (Option.XAxis.AxisLabel.Angle + 36000) % 360;\n                    if (angle > 0 && angle <= 90)\n                        g.DrawRotateString(data, TempFont, ForeColor, new PointF(start + DrawBarWidth / 2, DrawOrigin.Y + Option.XAxis.AxisTick.Length),\n                            new StringFormat() { Alignment = StringAlignment.Far }, (3600 - Option.XAxis.AxisLabel.Angle) % 360);\n                    else\n                        g.DrawString(data, TempFont, ForeColor, new Rectangle((int)start, DrawOrigin.Y + Option.XAxis.AxisTick.Length, (int)DrawBarWidth, Height), ContentAlignment.TopCenter);\n\n                    start += DrawBarWidth;\n                }\n\n                if (Option.XAxis.Name.IsValid())\n                {\n                    g.DrawString(Option.XAxis.Name, TempFont, ForeColor, new Rectangle(DrawOrigin.X, 0, DrawSize.Width, Height - 16), ContentAlignment.BottomCenter);\n                }\n            }\n\n            if (Option.ShowFullRect)\n            {\n                g.DrawRectangle(ForeColor, Option.Grid.Left, Option.Grid.Top, DrawSize.Width, DrawSize.Height);\n            }\n\n            double[] YLabels = YScale.CalcLabels();\n            float[] labels = YScale.CalcYPixels(YLabels, DrawOrigin.Y, DrawSize.Height);\n            float wmax = 0;\n            for (int i = 0; i < labels.Length; i++)\n            {\n                if (labels[i] > DrawOrigin.Y) continue;\n                if (labels[i] < Option.Grid.Top) continue;\n                if (Option.YAxis.AxisTick.Show)\n                {\n                    g.DrawLine(ForeColor, DrawOrigin.X, labels[i], DrawOrigin.X - Option.YAxis.AxisTick.Length, labels[i]);\n\n                    if (YLabels[i].IsNanOrInfinity()) continue;\n                    if (!Option.YAxis.ShowGridLine) continue;\n                    if (!YLabels[i].EqualsDouble(0))\n                    {\n                        using Pen pn = new Pen(ForeColor);\n                        pn.DashStyle = DashStyle.Dash;\n                        pn.DashPattern = new float[] { 3, 3 };\n                        g.DrawLine(pn, DrawOrigin.X, labels[i], Width - Option.Grid.Right, labels[i]);\n                    }\n                    else\n                    {\n                        g.DrawLine(ForeColor, DrawOrigin.X, labels[i], Width - Option.Grid.Right, labels[i]);\n                    }\n                }\n\n                if (Option.YAxis.AxisLabel.Show)\n                {\n                    string label = YLabels[i].ToString(Option.YAxis.AxisLabel.DecimalPlaces >= 0 ? \"F\" + Option.YAxis.AxisLabel.DecimalPlaces : YScale.Format);\n                    Size sf = TextRenderer.MeasureText(label, TempFont);\n                    wmax = Math.Max(wmax, sf.Width);\n                    g.DrawString(label, TempFont, ForeColor, new Rectangle(DrawOrigin.X - Option.YAxis.AxisTick.Length - Width, (int)labels[i] - Height, Width, Height * 2), ContentAlignment.MiddleRight);\n                }\n            }\n\n            if (Option.YAxis.AxisLabel.Show && Option.YAxis.Name.IsValid())\n            {\n                Size sfName = TextRenderer.MeasureText(Option.YAxis.Name, TempFont);\n                float xx = DrawOrigin.X - Option.YAxis.AxisTick.Length - wmax - sfName.Height / 2.0f;\n                float yy = Option.Grid.Top + DrawSize.Height / 2.0f;\n                g.DrawRotateString(Option.YAxis.Name, TempFont, ForeColor, new PointF(xx, yy), 270);\n            }\n        }"
            },
            {
                "name": "DrawAxisScales",
                "code": "private void DrawAxisScales(Graphics g)\n        {\n            using var TempFont = Font.DPIScaleFont(UIStyles.DefaultSubFontSize);\n            foreach (var line in Option.YAxisScaleLines)\n            {\n                double ymin = YAxisStart * YAxisInterval;\n                double ymax = YAxisEnd * YAxisInterval;\n                float pos = YScale.CalcYPixel(line.Value, DrawOrigin.Y, DrawSize.Height);\n                if (pos <= Option.Grid.Top || pos >= Height - Option.Grid.Bottom) continue;\n                using Pen pn = new Pen(line.Color, line.Size);\n                g.DrawLine(pn, DrawOrigin.X, pos, Width - Option.Grid.Right, pos);\n                g.DrawString(line.Name, TempFont, line.Color, new Rectangle(DrawOrigin.X + 4, (int)pos - 2 - Height, DrawSize.Width - 8, Height), (StringAlignment)((int)line.Left), StringAlignment.Far);\n            }\n        }"
            },
            {
                "name": "DrawSeries",
                "code": "protected virtual void DrawSeries(Graphics g, List<UIBarSeries> series)\n        {\n            if (series == null || series.Count == 0) return;\n            using var TempFont = Font.DPIScaleFont(UIStyles.DefaultSubFontSize);\n            for (int i = 0; i < Bars.Count; i++)\n            {\n                var bars = Bars[i];\n                foreach (var info in bars)\n                {\n                    g.FillRectangle(info.Color, info.Rect);\n\n                    if (Option.ShowValue)\n                    {\n                        string value = info.Value.ToString(\"F\" + info.Series.DecimalPlaces);\n                        if (info.Top)\n                        {\n                            g.DrawString(value, TempFont, info.Color, new Rectangle((int)info.Rect.Center().X - Width, (int)info.Rect.Top - Height, Width * 2, Height), ContentAlignment.BottomCenter);\n                        }\n                        else\n                        {\n                            g.DrawString(value, TempFont, info.Color, new Rectangle((int)info.Rect.Center().X - Width, (int)info.Rect.Bottom, Width * 2, Height), ContentAlignment.TopCenter);\n                        }\n                    }\n                }\n            }\n\n            for (int i = 0; i < Option.XAxis.Data.Count; i++)\n            {\n                Bars[0][i].Size = TextRenderer.MeasureText(Bars[0][i].Tips, TempFont);\n            }\n        }"
            }
        ],
        "third_party": [
            "DrawTitle",
            "DrawLegend"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected virtual void DrawToolTip(Graphics g)",
        "start_line": "468",
        "end_line": "482",
        "file_path": "SunnyUI/Charts/UIBarChart.cs",
        "docstring": "The protected virtual function DrawToolTip(Graphics g) draws a tooltip on a chart based on the selected index and tooltip type.\\nIf no item is selected, it returns immediately.\\nIf the tooltip type is a line, it draws a vertical line at the selected index.\\nIf the tooltip type is a shadow, it fills a rectangle at the selected index.\\nThe positions and dimensions are calculated using the drawing origin, bar width, and grid options.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1f16e1f824d0",
        "ground_truth": "protected virtual void DrawToolTip(Graphics g)\n{\n    if (selectIndex < 0) return;\n    if (Option.ToolTip.AxisPointer.Type == UIAxisPointerType.Line)\n    {\n        float x = DrawOrigin.X + SelectIndex * DrawBarWidth + DrawBarWidth / 2.0f;\n        g.DrawLine(ChartStyle.ToolTipShadowColor, x, DrawOrigin.Y, x, Option.Grid.Top);\n    }\n    if (Option.ToolTip.AxisPointer.Type == UIAxisPointerType.Shadow)\n    {\n        float x = DrawOrigin.X + SelectIndex * DrawBarWidth;\n        g.FillRectangle(ChartStyle.ToolTipShadowColor, x, Option.Grid.Top, DrawBarWidth, Height - Option.Grid.Top - Option.Grid.Bottom);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Concurrent",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Drawing2D",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "g.DrawLine",
            "g.FillRectangle"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "g.DrawLine",
            "g.FillRectangle"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": " protected void DrawTitle(Graphics g, UITitle title)",
        "start_line": "224",
        "end_line": "235",
        "file_path": "SunnyUI/Charts/UIChart.cs",
        "docstring": "The function DrawTitle(Graphics g, UITitle title) renders the title and its subtitle on a graphics context.\\nIt first checks if the title and its text are valid.\\nIf valid, it measures the size of the text and draws it on the graphics context with specified font and color, aligned based on title properties.\\nIf the subtitle text is valid, it creates a temporary scaled font and draws the subtitle below the main title, adjusting its position based on the alignment settings.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "63eac2c0afaa",
        "ground_truth": "protected void DrawTitle(Graphics g, UITitle title)\n{\n    if (title == null) return;\n    if (!title.Text.IsValid()) return;\n    Size sf = TextRenderer.MeasureText(title.Text, Font);\n    g.DrawString(title.Text, Font, ChartStyle.ForeColor, new Rectangle(TextInterval, TextInterval, Width - TextInterval * 2, Height - TextInterval * 2), (StringAlignment)((int)title.Left), (StringAlignment)((int)title.Top));\n    if (!title.SubText.IsValid()) return;\n    using var TempFont = Font.DPIScaleFont(UIStyles.DefaultSubFontSize);\n    g.DrawString(title.SubText, TempFont, ChartStyle.ForeColor, new Rectangle(TextInterval, TextInterval, Width - TextInterval * 2, Height - TextInterval * 2),\n        (StringAlignment)((int)title.Left), (StringAlignment)((int)title.Top), 0, title.Top == UITopAlignment.Bottom ? -sf.Height : sf.Height);\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Drawing2D",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "title.SubText.IsValid",
            "TextRenderer.MeasureText",
            "Font.DPIScaleFont",
            "g.DrawString",
            "title.Text.IsValid"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "title.SubText.IsValid",
            "TextRenderer.MeasureText",
            "Font.DPIScaleFont",
            "g.DrawString",
            "title.Text.IsValid"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected override void CreateEmptyOption()",
        "start_line": "41",
        "end_line": "63",
        "file_path": "SunnyUI/Charts/UIDoughnutChart.cs",
        "docstring": "The function CreateEmptyOption() initializes an empty doughnut chart option if it hasn't been created yet.\\nIt sets the chart title and subtitle, and creates a doughnut series with a specified name, center position, and radius.\\nIt adds five data points to the series and then adds the series to the chart option.\\nFinally, it assigns this option to the emptyOption variable.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fcb55d34cb20",
        "ground_truth": "protected override void CreateEmptyOption()\n{\n    if (emptyOption != null) return;\n    UIDoughnutOption option = new UIDoughnutOption();\n    option.Title = new UITitle();\n    option.Title.Text = \"SunnyUI\";\n    option.Title.SubText = \"DoughnutChart\";\n    var series = new UIDoughnutSeries();\n    series.Name = \"\u997c\u72b6\u56fe\";\n    series.Center = new UICenter(50, 55);\n    series.Radius.Inner = 40;\n    series.Radius.Outer = 70;\n    for (int i = 0; i < 5; i++)\n    {\n        series.AddData(\"Data\" + i, (i + 1) * 20);\n    }\n    option.Series.Add(series);\n    emptyOption = option;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Concurrent",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            ".Series.Add(serie",
            ".AddData(\"Data"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            ".Series.Add(serie",
            ".AddData(\"Data"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "public double[] LabelValues()",
        "start_line": "146",
        "end_line": "165",
        "file_path": "SunnyUI/Charts/UIOption.cs",
        "docstring": "The function LabelValues() generates an array of label values based on the AxisType.\\nIt initializes an array of doubles with a size of Count + 1.\\nFor each index, it calculates the value differently depending on whether the AxisType is DateTime or not.\\nFor DateTime, it creates a DateTimeInt64 object starting from the Start value and adds intervals in milliseconds.\\nFor non-DateTime, it simply adds the interval to the Start value.\\nFinally, it returns the array of calculated values.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7c0a5f0b8f45",
        "ground_truth": "public double[] LabelValues()\n{\n    double[] values = new double[Count + 1];\n    for (int i = 0; i <= Count; i++)\n    {\n        if (AxisType == UIAxisType.DateTime)\n        {\n            DateTimeInt64 dateTime = new DateTimeInt64(Start);\n            dateTime.AddMilliseconds(IntervalMilliseconds * i);\n            values[i] = dateTime.DoubleValue;\n        }\n        else\n        {\n            values[i] = Start + Interval * i;\n        }\n    }\n    return values;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Drawing"
        ],
        "reference_api": [
            "dateTime.AddMilliseconds"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "dateTime.AddMilliseconds"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "public static void ResetBorderColor(Message m, Control control, int width, Color color)",
        "start_line": "250",
        "end_line": "267",
        "file_path": "SunnyUI/Common/UControl.cs",
        "docstring": "The function ResetBorderColor(Message m, Control control, int width, Color color) changes the border color of a specified control.\\nIt creates a Pen object with the specified color and width.\\nIt retrieves the device context for the window handle from the message.\\nIf the device context is valid, it creates a Graphics object, sets its smoothing mode to anti-alias, and draws a rectangle around the control's border.\\nFinally, it releases the device context.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dfdbaee67b59",
        "ground_truth": "public static void ResetBorderColor(Message m, Control control, int width, Color color)\n{\n    //\u6839\u636e\u989c\u8272\u548c\u8fb9\u6846\u50cf\u7d20\u53d6\u5f97\u4e00\u6761\u7ebf\n    using Pen pen = new Pen(color, width);\n    //\u5f97\u5230\u5f53\u524d\u7684\u53e5\u67c4\n    IntPtr hDC = (IntPtr)Win32.User.GetWindowDC(m.HWnd);\n    if (hDC.ToInt32() == 0)\n    {\n        return;\n    }\n    //\u7ed8\u5236\u8fb9\u6846\n    Graphics g = Graphics.FromHdc(hDC);\n    g.SmoothingMode = SmoothingMode.AntiAlias;\n    g.DrawRectangle(pen, 0, 0, control.Width - width, control.Height - width);\n    //\u91ca\u653e\n    Win32.User.ReleaseDC(m.HWnd, hDC);\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Concurrent",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Drawing2D",
            "using System.Drawing.Imaging",
            "using System.Linq",
            "using System.Reflection",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "",
            "  if (hDC.ToInt32() ==",
            "control.Height ",
            " = SmoothingMode",
            "        ret"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "",
            "  if (hDC.ToInt32() ==",
            "control.Height ",
            " = SmoothingMode",
            "        ret"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "public static Bitmap SaveToImage(this Control ctrl)",
        "start_line": "419",
        "end_line": "431",
        "file_path": "SunnyUI/Common/UControl.cs",
        "docstring": "The function SaveToImage(this Control ctrl) captures the image of a given control as a bitmap.\\nIt retrieves the device context (DC) of the control's window and creates a compatible bitmap and DC.\\nIt selects the bitmap into the compatible DC and prints the control's window content into it.\\nA Bitmap object is created from the HBitmap.\\nThe function then deletes the used objects and returns the Bitmap.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "aec16c2608df",
        "ground_truth": "public static Bitmap SaveToImage(this Control ctrl)\n{\n    IntPtr hdc = (IntPtr)Win32.User.GetWindowDC(ctrl.Handle);\n    IntPtr bitmap = (IntPtr)Win32.GDI.CreateCompatibleBitmap(hdc, ctrl.Width, ctrl.Height);\n    IntPtr compatibleDc = (IntPtr)Win32.GDI.CreateCompatibleDC(hdc);\n    Win32.GDI.SelectObject(compatibleDc, bitmap);\n    Win32.GDI.PrintWindow(ctrl.Handle, compatibleDc, 0);\n    Bitmap bmp = Image.FromHbitmap(bitmap);\n    Win32.GDI.DeleteDC(compatibleDc);       //\u5220\u9664\u7528\u8fc7\u7684\u5bf9\u8c61\n    Win32.GDI.DeleteDC(bitmap);       //\u5220\u9664\u7528\u8fc7\u7684\u5bf9\u8c61\n    Win32.GDI.DeleteDC(hdc);       //\u5220\u9664\u7528\u8fc7\u7684\u5bf9\u8c61\n    return bmp;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Concurrent",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Drawing2D",
            "using System.Drawing.Imaging",
            "using System.Linq",
            "using System.Reflection",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "Win32.GDI.DeleteDC",
            "teDC(bitmap);     ",
            "   //\u5220\u9664\u7528\u8fc7\u7684\u5bf9\u8c61\n     ",
            "Win32.GDI.SelectObject",
            "Win32.User.GetWindowDC",
            "Win32.GDI.PrintWindow",
            "Win32.GDI.CreateCompatibleDC",
            "Image.FromHbitmap",
            "Win32.GDI.CreateCompatibleBitmap"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Win32.GDI.DeleteDC",
            "teDC(bitmap);     ",
            "   //\u5220\u9664\u7528\u8fc7\u7684\u5bf9\u8c61\n     ",
            "Win32.GDI.SelectObject",
            "Win32.User.GetWindowDC",
            "Win32.GDI.PrintWindow",
            "Win32.GDI.CreateCompatibleDC",
            "Image.FromHbitmap",
            "Win32.GDI.CreateCompatibleBitmap"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "public static void RemoveClickEvent(this Button button)",
        "start_line": "476",
        "end_line": "491",
        "file_path": "SunnyUI/Common/UControl.cs",
        "docstring": "The function RemoveClickEvent(Button button) removes the click event handler from a Button control.\\nIt retrieves the EventClick field from the Control class using reflection.\\nIf the field is found, it obtains the event handler's key object.\\nIt then gets the Events property of the Button and removes the click event handler from the event handler list if both the property and key object are valid.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8cbc60785194",
        "ground_truth": "public static void RemoveClickEvent(this Button button)\n{\n    FieldInfo f1 = typeof(Control).GetField(\"EventClick\", BindingFlags.Static | BindingFlags.NonPublic);\n    if (f1 == null)\n    {\n        return;\n    }\n    object obj = f1.GetValue(button);\n    PropertyInfo pi = button.GetType().GetProperty(\"Events\", BindingFlags.NonPublic | BindingFlags.Instance);\n    if (pi != null && obj != null)\n    {\n        EventHandlerList list = (EventHandlerList)pi.GetValue(button, null);\n        list?.RemoveHandler(obj, list[obj]);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Concurrent",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Drawing2D",
            "using System.Drawing.Imaging",
            "using System.Linq",
            "using System.Reflection",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "typeof(Control).GetField",
            "pi.GetValue",
            "list?.RemoveHandler",
            "f1.GetValue",
            "button.GetType",
            "button.GetType().GetProperty"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "typeof(Control).GetField",
            "pi.GetValue",
            "list?.RemoveHandler",
            "f1.GetValue",
            "button.GetType",
            "button.GetType().GetProperty"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "public static string CheckVersion()",
        "start_line": "62",
        "end_line": "76",
        "file_path": "SunnyUI/Common/UEnvironment.cs",
        "docstring": "The function CheckVersion() checks the installed version of the .NET Framework on a Windows machine.\\nIt accesses the registry key for the .NET Framework setup.\\nIf the registry key and its \"Release\" value exist, it retrieves the .NET Framework version using the CheckFor45PlusVersion function.\\nIt returns a string indicating the .NET Framework version.\\nIf the key or value is not found, it returns a message stating that .NET Framework 4.5 or later is not detected.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "107200db7c81",
        "ground_truth": "public static string CheckVersion()\n{\n    const string subkey = @\"SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full\\\";\n    using (var ndpKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey(subkey))\n    {\n        if (ndpKey != null && ndpKey.GetValue(\"Release\") != null)\n        {\n            return $\".NET Framework Version: {CheckFor45PlusVersion((int)ndpKey.GetValue(\"Release\"))}\";\n        }\n        else\n        {\n            return \".NET Framework Version 4.5 or later is not detected.\";\n        }\n    }\n}",
        "import_statements": [
            "using Microsoft.Win32"
        ],
        "reference_api": [
            "CheckFor45PlusVersion",
            "RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey",
            "ndpKey.GetValue",
            "RegistryKey.OpenBaseKey"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "CheckFor45PlusVersion",
                "code": "private static string CheckFor45PlusVersion(int releaseKey)\n        {\n            if (releaseKey >= 528040)\n                return \"4.8 or later\";\n            if (releaseKey >= 461808)\n                return \"4.7.2\";\n            if (releaseKey >= 461308)\n                return \"4.7.1\";\n            if (releaseKey >= 460798)\n                return \"4.7\";\n            if (releaseKey >= 394802)\n                return \"4.6.2\";\n            if (releaseKey >= 394254)\n                return \"4.6.1\";\n            if (releaseKey >= 393295)\n                return \"4.6\";\n            if (releaseKey >= 379893)\n                return \"4.5.2\";\n            if (releaseKey >= 378675)\n                return \"4.5.1\";\n            if (releaseKey >= 378389)\n                return \"4.5\";\n            // This code should never execute. A non-null release key should mean\n            // that 4.5 or later is installed.\n            return \"No 4.5 or later version detected\";\n        }"
            }
        ],
        "third_party": [
            "RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey",
            "ndpKey.GetValue",
            "RegistryKey.OpenBaseKey"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "public static bool CopyPixels(Bitmap source, Bitmap target)",
        "start_line": "713",
        "end_line": "730",
        "file_path": "SunnyUI/Common/UFastBitmap.cs",
        "docstring": "The function CopyPixels(Bitmap source, Bitmap target) copies pixel data from a source bitmap to a target bitmap.\\nIt throws an exception if the source and target are the same bitmap.\\nIt checks if the source and target bitmaps have the same dimensions and pixel format; if not, it returns false.\\nIt uses FastLock to lock the bitmaps for fast memory access and then uses memcpy to copy the pixel data from the source to the target.\\nFinally, it returns true to indicate a successful copy.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0078e6ce17ce",
        "ground_truth": "public static bool CopyPixels(Bitmap source, Bitmap target)\n{\n    if (source == target)\n    {\n        throw new ArgumentException(@\"Copying pixels across the same bitmap is not supported\", nameof(source));\n    }\n    if (source.Width != target.Width || source.Height != target.Height || source.PixelFormat != target.PixelFormat)\n        return false;\n    using (FastBitmap fastSource = source.FastLock(),\n        fastTarget = target.FastLock())\n    {\n        memcpy(fastTarget.Scan0, fastSource.Scan0, (ulong)(fastSource.Height * fastSource.Stride * BytesPerPixel));\n    }\n    return true;\n}",
        "import_statements": [
            "using System",
            "using System.Drawing",
            "using System.Drawing.Imaging",
            "using System.Runtime.InteropServices"
        ],
        "reference_api": [
            "source.FastLock",
            "memcpy",
            "nameof",
            "target.FastLock"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "source.FastLock",
            "memcpy",
            "nameof",
            "target.FastLock"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected override void OnMouseMove(MouseEventArgs e)",
        "start_line": "138",
        "end_line": "144",
        "file_path": "SunnyUI/Controls/Color/UIColorBar.cs",
        "docstring": "The function OnMouseMove(MouseEventArgs e) handles the mouse move event for a UI element.\\nIt first calls the base class's OnMouseMove method.\\nIt then creates a PointF object representing the current mouse position.\\nIf the left mouse button is pressed, it calls the SetPercent method with the current mouse position.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b554f6ffc7b1",
        "ground_truth": "protected override void OnMouseMove(MouseEventArgs e)\n{\n    base.OnMouseMove(e);\n    PointF mousepoint = new PointF(e.X, e.Y);\n    if (e.Button == MouseButtons.Left)\n        SetPercent(mousepoint);\n}",
        "import_statements": [
            "using System",
            "using System.Drawing",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "base.OnMouseMove",
            "SetPercent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SetPercent",
                "code": "protected virtual void SetPercent(float percent)\n        {\n            Percent = percent / 100;\n        }"
            }
        ],
        "third_party": [
            "base.OnMouseMove"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected void DrawColorBar(Graphics dc)",
        "start_line": "272",
        "end_line": "280",
        "file_path": "SunnyUI/Controls/Color/UIColorBar.cs",
        "docstring": "The protected function DrawColorBar(Graphics dc) renders a color bar on a graphics context.\\nIt calculates the rectangle area for the bar and checks the number of colors to be used.\\nIf two colors are specified, it draws a two-color bar.\\nIf more colors are specified, it draws a three-color bar.\\nFinally, it draws a selector on the bar based on a percentage value.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "67a92ed0480f",
        "ground_truth": "protected void DrawColorBar(Graphics dc)\n{\n    RectangleF lr = BarRectangle;\n    if (m_numberOfColors == eNumberOfColors.Use2Colors)\n        UIColorUtil.Draw2ColorBar(dc, lr, Orientation, m_color1, m_color2);\n    else\n        UIColorUtil.Draw3ColorBar(dc, lr, Orientation, m_color1, m_color2, m_color3);\n    DrawSelector(dc, lr, Orientation, (float)Percent);\n}",
        "import_statements": [
            "using System",
            "using System.Drawing",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "DrawSelector",
            "UIColorUtil.Draw2ColorBar",
            "UIColorUtil.Draw3ColorBar"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "DrawSelector",
                "code": "protected void DrawSelector(Graphics dc, RectangleF r, Orientation orientation, float percentSet)\n        {\n            using Pen pen = new Pen(Color.CadetBlue);\n            percentSet = Math.Max(0, percentSet);\n            percentSet = Math.Min(1, percentSet);\n            if (orientation == Orientation.Vertical)\n            {\n                float selectorY = (float)Math.Floor(r.Top + (r.Height - (r.Height * percentSet)));\n                if (m_valueOrientation == eValueOrientation.MaxToMin)\n                    selectorY = (float)Math.Floor(r.Top + (r.Height - (r.Height * percentSet)));\n                else\n                    selectorY = (float)Math.Floor(r.Top + (r.Height * percentSet));\n\n                dc.DrawLine(pen, r.X, selectorY, r.Right, selectorY);\n\n                Image image = SelectorImages.Image(SelectorImages.eIndexes.Right);\n                float xpos = r.Right;\n                float ypos = selectorY - image.Height / 2;\n                dc.DrawImageUnscaled(image, (int)xpos, (int)ypos);\n\n                image = SelectorImages.Image(SelectorImages.eIndexes.Left);\n                xpos = r.Left - image.Width;\n                dc.DrawImageUnscaled(image, (int)xpos, (int)ypos);\n            }\n            if (orientation == Orientation.Horizontal)\n            {\n                float selectorX = 0;\n                if (m_valueOrientation == eValueOrientation.MaxToMin)\n                    selectorX = (float)Math.Floor(r.Left + (r.Width - (r.Width * percentSet)));\n                else\n                    selectorX = (float)Math.Floor(r.Left + (r.Width * percentSet));\n\n                dc.DrawLine(pen, selectorX, r.Top, selectorX, r.Bottom);\n\n                Image image = SelectorImages.Image(SelectorImages.eIndexes.Up);\n                float xpos = selectorX - image.Width / 2;\n                float ypos = r.Bottom;\n                dc.DrawImageUnscaled(image, (int)xpos, (int)ypos);\n\n                image = SelectorImages.Image(SelectorImages.eIndexes.Down);\n                ypos = r.Top - image.Height;\n                dc.DrawImageUnscaled(image, (int)xpos, (int)ypos);\n            }\n        }"
            }
        ],
        "third_party": [
            "UIColorUtil.Draw2ColorBar",
            "UIColorUtil.Draw3ColorBar"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "private void ItemForm_VisibleChanged(object sender, EventArgs e)",
        "start_line": "283",
        "end_line": "294",
        "file_path": "SunnyUI/Controls/DropItem/UIDropControl.cs",
        "docstring": "The private function ItemForm_VisibleChanged(object sender, EventArgs e) handles the visibility change event of the form.\\nIt sets the dropSymbol to SymbolNormal by default.\\nIf the form is in a dropped-down state, it changes the dropSymbol to SymbolDropDown.\\nFinally, it triggers a redraw of the form by calling Invalidate().",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "eb7915323235",
        "ground_truth": "private void ItemForm_VisibleChanged(object sender, EventArgs e)\n{\n    dropSymbol = SymbolNormal;\n    if (DroppedDown)\n    {\n        dropSymbol = SymbolDropDown;\n    }\n    Invalidate();\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Design",
            "using System.Drawing.Drawing2D",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "Invalidate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Invalidate"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected override void OnPaintFore(Graphics g, GraphicsPath path)",
        "start_line": "435",
        "end_line": "459",
        "file_path": "SunnyUI/Controls/DropItem/UIDropControl.cs",
        "docstring": "The protected override function OnPaintFore(Graphics g, GraphicsPath path) customizes the foreground painting of a control.\\nIt first adjusts the size using the SizeChange() method.\\nIf the edit component is not visible, it draws either the Text or the Watermark with appropriate styling and alignment.\\nIt then fills a rectangle on the right side of the control with a specific color.\\nDepending on whether the clear button needs to be drawn, it draws either a clear button symbol or a dropdown symbol using font images, applying the specified color and size.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f39e3f212069",
        "ground_truth": "protected override void OnPaintFore(Graphics g, GraphicsPath path)\n{\n    SizeChange();\n    if (!edit.Visible)\n    {\n        if (Text.IsValid())\n            g.DrawString(Text, Font, GetForeColor(), ClientRectangle, TextAlignment);\n        else if (Watermark.IsValid())\n            g.DrawString(Watermark, Font, WatermarkColor, ClientRectangle, TextAlignment, 5);\n    }\n    g.FillRectangle(GetFillColor(), new Rectangle(Width - Padding.Right, 2, Padding.Right - 1, Height - 4));\n    Color color = GetRectColor();\n    int symbol = dropSymbol;\n    if (NeedDrawClearButton)\n    {\n        g.DrawFontImage(261527, SymbolSize, color, new Rectangle(Width - Padding.Right, 0, Padding.Right, Height), -1, 1);\n    }\n    else\n    {\n        g.DrawFontImage(symbol, SymbolSize, color, new Rectangle(Width - Padding.Right, 0, Padding.Right, Height), 1, 0);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Design",
            "using System.Drawing.Drawing2D",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "GetForeColor",
            "Watermark.IsValid",
            "g.FillRectangle",
            "Text.IsValid",
            "g.DrawString",
            "g.DrawFontImage",
            "SizeChange",
            "GetFillColor",
            "GetRectColor"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SizeChange",
                "code": "private void SizeChange()\n        {\n            //if (Height < edit.Height + RectSize * 2 + 2)\n            //{\n            //    NoNeedChange = true;\n            //    Height = edit.Height + RectSize * 2 + 2;\n            //    edit.Top = (Height - edit.Height) / 2;\n            //    NoNeedChange = false;\n            //}\n\n            if (edit.Top != (Height - edit.Height) / 2 + 1)\n            {\n                edit.Top = (Height - edit.Height) / 2 + 1;\n            }\n\n            edit.Left = 4 + Padding.Left;\n            edit.Width = Width - Padding.Left - Padding.Right - 4;\n        }"
            }
        ],
        "third_party": [
            "GetForeColor",
            "Watermark.IsValid",
            "g.FillRectangle",
            "Text.IsValid",
            "g.DrawString",
            "g.DrawFontImage",
            "GetFillColor",
            "GetRectColor"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected override void OnMouseMove(MouseEventArgs e)",
        "start_line": "472",
        "end_line": "489",
        "file_path": "SunnyUI/Controls/DropItem/UIDropControl.cs",
        "docstring": "The protected override function OnMouseMove(MouseEventArgs e) handles mouse movement events.\\nIt first calls the base class's OnMouseMove method.\\nIf the clear button is not shown, it sets NeedDrawClearButton to false and exits.\\nOtherwise, it checks if the mouse pointer is within the control box area on the right side.\\nIf the mouse pointer's position changes the NeedDrawClearButton state and the text is valid, it updates NeedDrawClearButton and triggers a redraw by calling Invalidate().",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c2f43d45d92d",
        "ground_truth": "protected override void OnMouseMove(MouseEventArgs e)\n{\n    base.OnMouseMove(e);\n    if (!showClearButton)\n    {\n        NeedDrawClearButton = false;\n        return;\n    }\n    bool inControlBox = e.Location.X > Width - Padding.Right;\n    if (inControlBox != NeedDrawClearButton && Text.IsValid())\n    {\n        NeedDrawClearButton = inControlBox;\n        Invalidate();\n    }\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Design",
            "using System.Drawing.Drawing2D",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "Invalidate",
            "base.OnMouseMove",
            "Text.IsValid"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Invalidate",
            "base.OnMouseMove",
            "Text.IsValid"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected override void OnLayout(LayoutEventArgs e)",
        "start_line": "277",
        "end_line": "288",
        "file_path": "SunnyUI/Controls/DropItem/UIDropDown.cs",
        "docstring": "The protected override function OnLayout(LayoutEventArgs e) manages the layout of the component.\\nIt calculates the preferred size of the component and adjusts the size if AutoSize is enabled and the suggested size differs from the current size.\\nIt then sets the items to be displayed, triggers the layout completed event, and invalidates the component to refresh its display.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ecd71145bba0",
        "ground_truth": "protected override void OnLayout(LayoutEventArgs e)\n{\n    Size suggestedSize = GetPreferredSize(Size.Empty);\n    if (AutoSize && suggestedSize != Size)\n    {\n        Size = suggestedSize;\n    }\n    SetDisplayedItems();\n    OnLayoutCompleted(EventArgs.Empty);\n    Invalidate();\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "SetDisplayedItems",
            "Invalidate",
            "GetPreferredSize",
            "OnLayoutCompleted"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "SetDisplayedItems",
            "Invalidate",
            "GetPreferredSize",
            "OnLayoutCompleted"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "public override void SetStyleColor(UIBaseStyle uiColor)",
        "start_line": "335",
        "end_line": "346",
        "file_path": "SunnyUI/Controls/DropItem/UINumPadItem.cs",
        "docstring": "The public override function SetStyleColor(UIBaseStyle uiColor) sets the style colors for the UI component.\\nIt calls the base class method to apply the base style.\\nIt sets the fill color to white, the foreground color to the dropdown panel foreground color, and the rectangle color from the provided style.\\nIt then iterates through all UISymbolButton controls within the component and applies the style color to each of them.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "670ec0154771",
        "ground_truth": "public override void SetStyleColor(UIBaseStyle uiColor)\n{\n    base.SetStyleColor(uiColor);\n    fillColor = Color.White;\n    foreColor = uiColor.DropDownPanelForeColor;\n    RectColor = uiColor.RectColor;\n    foreach (var item in this.GetControls<UISymbolButton>(true))\n    {\n        item.SetStyleColor(uiColor);\n    }\n}",
        "import_statements": [
            "using System.ComponentModel",
            "using System.Drawing"
        ],
        "reference_api": [
            "this.GetControls<UISymbolButton>",
            "item.SetStyleColor",
            "base.SetStyleColor"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.GetControls<UISymbolButton>",
            "item.SetStyleColor",
            "base.SetStyleColor"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "public override bool DrawBody(Graphics Gr, RectangleF rc)",
        "start_line": "176",
        "end_line": "198",
        "file_path": "SunnyUI/Controls/UIAnalogMeterRender.cs",
        "docstring": "The public override function DrawBody(Graphics Gr, RectangleF rc) renders the body of an analog meter.\\nIt first checks if the AnalogMeter object is null and returns false if it is.\\nIt retrieves the body color and calculates a darker shade of the color.\\nIt creates and uses a linear gradient brush to fill an ellipse in the provided rectangle area with the body color and its darker shade.\\nIt then adjusts the rectangle dimensions based on the meter's draw ratio and fills another ellipse with a reversed gradient.\\nThe function returns true if the drawing is successful.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "248c24f4cf62",
        "ground_truth": "public override bool DrawBody(Graphics Gr, RectangleF rc)\n{\n    if (this.AnalogMeter == null)\n        return false;\n    Color bodyColor = this.AnalogMeter.BodyColor;\n    Color cDark = LBColorManager.StepColor(bodyColor, 20);\n    using LinearGradientBrush br1 = new LinearGradientBrush(rc, bodyColor, cDark, 45);\n    Gr.FillEllipse(br1, rc);\n    float drawRatio = this.AnalogMeter.GetDrawRatio();\n    RectangleF _rc = rc;\n    _rc.X += 3 * drawRatio;\n    _rc.Y += 3 * drawRatio;\n    _rc.Width -= 6 * drawRatio;\n    _rc.Height -= 6 * drawRatio;\n    using LinearGradientBrush br2 = new LinearGradientBrush(_rc, cDark, bodyColor, 45);\n    Gr.FillEllipse(br2, _rc);\n    return true;\n}",
        "import_statements": [
            "using System",
            "using System.Drawing",
            "using System.Drawing.Drawing2D"
        ],
        "reference_api": [
            "this.AnalogMeter.GetDrawRatio",
            "LBColorManager.StepColor",
            "Gr.FillEllipse"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.AnalogMeter.GetDrawRatio",
            "LBColorManager.StepColor",
            "Gr.FillEllipse"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "yhuse/SunnyUI",
        "function_declaration": "protected override void OnMouseEnter(EventArgs e)",
        "start_line": "723",
        "end_line": "728",
        "file_path": "SunnyUI/Controls/UIButton.cs",
        "docstring": "The public override function DrawBody(Graphics Gr, RectangleF rc) renders the body of an analog meter.\\nIt first checks if the AnalogMeter object is null and returns false if it is.\\nIt retrieves the body color and calculates a darker shade of the color.\\nIt creates and uses a linear gradient brush to fill an ellipse in the provided rectangle area with the body color and its darker shade.\\nIt then adjusts the rectangle dimensions based on the meter's draw ratio and fills another ellipse with a reversed gradient.\\nThe function returns true if the drawing is successful.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "be7c41ba9985",
        "ground_truth": "protected override void OnMouseEnter(EventArgs e)\n{\n    base.OnMouseEnter(e);\n    IsHover = true;\n    Invalidate();\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Drawing",
            "using System.Drawing.Design",
            "using System.Drawing.Drawing2D",
            "using System.Text",
            "using System.Windows.Forms"
        ],
        "reference_api": [
            "Invalidate",
            "base.OnMouseEnter"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Invalidate",
            "base.OnMouseEnter"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "public static void Load()",
        "start_line": "92",
        "end_line": "100",
        "file_path": "Source/GrasscutterTools/Eavesdrop/Internals/INETOptions.cs",
        "docstring": "The public static function Load() initializes the proxy settings by acquiring a lock to ensure thread safety.\\nWithin the lock, it calls methods to load addresses and overrides.\\nIt then checks the registry key value to determine if the proxy is enabled and sets the IsProxyEnabled flag accordingly.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1d476b416b5a",
        "ground_truth": "public static void Load()\n{\n    lock (_stateLock)\n    {\n        LoadAddresses();\n        LoadOverrides();\n        IsProxyEnabled = (_proxyKey.GetValue(\"ProxyEnable\")?.ToString() == \"1\");\n    }\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Collections.Generic",
            "using System.Runtime.InteropServices",
            "using Microsoft.Win32"
        ],
        "reference_api": [
            "LoadAddresses",
            "LoadOverrides",
            "_proxyKey.GetValue(\"ProxyEnable\")?.ToString",
            "_proxyKey.GetValue"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "LoadAddresses",
                "code": "private static void LoadAddresses()\n        {\n            string proxyServer = _proxyKey.GetValue(\"ProxyServer\")?.ToString();\n            if (string.IsNullOrWhiteSpace(proxyServer)) return;\n\n            string[] values = proxyServer.Split(';');\n            foreach (string value in values)\n            {\n                string[] pair = value.Split('=');\n                if (pair.Length != 2)\n                {\n                    HTTPAddress = value;\n                    HTTPSAddress = value;\n                    return;\n                }\n\n                string address = pair[1];\n                string protocol = pair[0];\n                switch (protocol)\n                {\n                    case \"http\": HTTPAddress = address; break;\n                    case \"https\": HTTPSAddress = address; break;\n                }\n            }\n        }"
            },
            {
                "name": "LoadOverrides",
                "code": "private static void LoadOverrides()\n        {\n            string proxyOverride = _proxyKey.GetValue(\"ProxyOverride\")?.ToString();\n            if (string.IsNullOrWhiteSpace(proxyOverride)) return;\n\n            string[] overrides = proxyOverride.Split(';');\n            foreach (string @override in overrides)\n            {\n                if (@override == \"<local>\")\n                {\n                    IsIgnoringLocalTraffic = true;\n                }\n                else if (!Overrides.Contains(@override))\n                {\n                    Overrides.Add(@override);\n                }\n            }\n        }"
            }
        ],
        "third_party": [
            "_proxyKey.GetValue(\"ProxyEnable\")?.ToString",
            "_proxyKey.GetValue"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private static void LoadOverrides()",
        "start_line": "102",
        "end_line": "119",
        "file_path": "Source/GrasscutterTools/Eavesdrop/Internals/INETOptions.cs",
        "docstring": "The private static function LoadOverrides() retrieves and processes proxy override settings.\\nIt gets the \"ProxyOverride\" value from a registry key and checks if it is null or empty.\\nIf not, it splits the override string into an array of individual overrides.\\nIt iterates through each override, setting a flag if local traffic should be ignored and adding unique overrides to the Overrides list.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "298075fa5494",
        "ground_truth": "private static void LoadOverrides()\n{\n    string proxyOverride = _proxyKey.GetValue(\"ProxyOverride\")?.ToString();\n    if (string.IsNullOrWhiteSpace(proxyOverride)) return;\n    string[] overrides = proxyOverride.Split(';');\n    foreach (string @override in overrides)\n    {\n        if (@override == \"<local>\")\n        {\n            IsIgnoringLocalTraffic = true;\n        }\n        else if (!Overrides.Contains(@override))\n        {\n            Overrides.Add(@override);\n        }\n    }\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Collections.Generic",
            "using System.Runtime.InteropServices",
            "using Microsoft.Win32"
        ],
        "reference_api": [
            "Overrides.Add",
            "Overrides.Contains",
            "_proxyKey.GetValue(\"ProxyOverride\")?.ToString",
            "_proxyKey.GetValue",
            "string.IsNullOrWhiteSpace",
            "proxyOverride.Split"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Overrides.Add",
            "Overrides.Contains",
            "_proxyKey.GetValue(\"ProxyOverride\")?.ToString",
            "_proxyKey.GetValue",
            "string.IsNullOrWhiteSpace",
            "proxyOverride.Split"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private async Task<HttpWebRequest> ReadRequestAsync(Uri baseUri)",
        "start_line": "45",
        "end_line": "76",
        "file_path": "Source/GrasscutterTools/Eavesdrop/Network/EavesNode.cs",
        "docstring": "The private async function ReadRequestAsync(Uri baseUri) processes an HTTP request asynchronously.\\nIt initializes the method, headers list, and request URL based on the provided base URI.\\nIt reads the first command line and splits it to extract the HTTP method and request path.\\nWhile the client is connected, it continues to read and collect HTTP headers.\\nIf the method is \"CONNECT\", it updates the base URI, sends an OK response, and attempts to establish a secure tunnel.\\nIf the tunnel is established, it recursively reads the next request.\\nFor other methods, it creates and returns an HttpWebRequest with the specified method, headers, and request URL.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c6c7ed2cfa51",
        "ground_truth": "private async Task<HttpWebRequest> ReadRequestAsync(Uri baseUri)\n{\n    string method = null;\n    var headers = new List<string>();\n    string requestUrl = baseUri?.OriginalString;\n    string command = ReadNonBufferedLine();\n    if (string.IsNullOrWhiteSpace(command)) return null;\n    if (string.IsNullOrWhiteSpace(command)) return null;\n    string[] values = command.Split(' ');\n    method = values[0];\n    requestUrl += values[1];\n    while (_client.Connected)\n    {\n        string header = ReadNonBufferedLine();\n        if (string.IsNullOrWhiteSpace(header)) break;\n        headers.Add(header);\n    }\n    if (method == \"CONNECT\")\n    {\n        baseUri = new Uri(\"https://\" + requestUrl);\n        await SendResponseAsync(HttpStatusCode.OK).ConfigureAwait(false);\n        if (!SecureTunnel(baseUri.Host)) return null;\n        return await ReadRequestAsync(baseUri).ConfigureAwait(false);\n    }\n    else return CreateRequest(method, headers, new Uri(requestUrl));\n}",
        "import_statements": [
            "using System",
            "using System.IO",
            "using System.Net",
            "using System.Text",
            "using System.Net.Http",
            "using System.Net.Sockets",
            "using System.Net.Security",
            "using System.Globalization",
            "using System.IO.Compression",
            "using System.Threading.Tasks",
            "using System.Collections.Generic",
            "using System.Security.Authentication",
            "using System.Text.RegularExpressions",
            "using System.Security.Cryptography.X509Certificates"
        ],
        "reference_api": [
            "ReadNonBufferedLine",
            "SecureTunnel",
            "SendResponseAsync",
            "headers.Add",
            "ReadRequestAsync(baseUri).ConfigureAwait",
            "SendResponseAsync(HttpStatusCode.OK).ConfigureAwait",
            "ReadRequestAsync",
            "CreateRequest",
            "string.IsNullOrWhiteSpace",
            "command.Split"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ReadNonBufferedLine",
                "code": "private string ReadNonBufferedLine()\n        {\n            string line = string.Empty;\n            try\n            {\n                using (var binaryInput = new BinaryReader(GetStream(), Encoding.UTF8, true))\n                {\n                    do { line += binaryInput.ReadChar(); }\n                    while (!line.EndsWith(\"\\r\\n\"));\n                }\n            }\n            catch (EndOfStreamException) { line += \"\\r\\n\"; }\n            return line.Substring(0, line.Length - 2);\n        }"
            },
            {
                "name": "SecureTunnel",
                "code": "private bool SecureTunnel(string host)\n        {\n            try\n            {\n                X509Certificate2 certificate = _certifier.GenerateCertificate(host);\n\n                _secureStream = new SslStream(GetStream());\n                _secureStream.AuthenticateAsServer(certificate, false, SslProtocols.Tls12 | SslProtocols.Tls11 | SslProtocols.Tls, false);\n\n                return true;\n            }\n            catch { return false; }\n        }"
            },
            {
                "name": "SendResponseAsync",
                "code": "public Task SendResponseAsync(WebResponse response, HttpContent content)\n        {\n            string description = \"OK\";\n            var status = HttpStatusCode.OK;\n            if (response is HttpWebResponse httpResponse)\n            {\n                status = httpResponse.StatusCode;\n                description = httpResponse.StatusDescription;\n            }\n            return SendResponseAsync(status, description, response.Headers, content);\n        }"
            },
            {
                "name": "ReadRequestAsync",
                "code": "public Task<HttpWebRequest> ReadRequestAsync()\n        {\n            return ReadRequestAsync(null);\n        }"
            },
            {
                "name": "CreateRequest",
                "code": "private HttpWebRequest CreateRequest(string method, List<string> headers, Uri requestUri)\n        {\n            HttpWebRequest request = WebRequest.CreateHttp(requestUri);\n            request.ProtocolVersion = HttpVersion.Version10;\n            request.CookieContainer = new CookieContainer();\n            request.AllowAutoRedirect = false;\n            request.KeepAlive = false;\n            request.Method = method;\n            request.Proxy = null;\n\n            foreach (string header in headers)\n            {\n                int delimiterIndex = header.IndexOf(':');\n                if (delimiterIndex == -1) continue;\n\n                string name = header.Substring(0, delimiterIndex);\n                string value = header.Substring(delimiterIndex + 2);\n                switch (name.ToLower())\n                {\n                    case \"range\":\n                    case \"expect\":\n                    case \"keep-alive\":\n                    case \"connection\":\n                    case \"proxy-connection\": break;\n\n                    case \"host\": request.Host = value; break;\n                    case \"accept\": request.Accept = value; break;\n                    case \"referer\": request.Referer = value; break;\n                    case \"user-agent\": request.UserAgent = value; break;\n                    case \"content-type\": request.ContentType = value; break;\n\n                    case \"content-length\":\n                    {\n                        request.ContentLength =\n                            long.Parse(value, CultureInfo.InvariantCulture);\n\n                        break;\n                    }\n                    case \"cookie\":\n                    {\n                        foreach (Cookie cookie in GetCookies(value, request.Host))\n                        {\n                            try\n                            {\n                                request.CookieContainer.Add(cookie);\n                            }\n                            catch (CookieException) { }\n                        }\n                        request.Headers[name] = value;\n                        break;\n                    }\n                    case \"if-modified-since\":\n                    {\n                        request.IfModifiedSince = DateTime.Parse(\n                            value.Split(';')[0], CultureInfo.InvariantCulture);\n\n                        break;\n                    }\n\n                    case \"date\":\n                        if (long.TryParse(value, out var timestamp))\n                        {\n                            request.Date = timestamp > 10_000_000_000L\n                                ? DateTimeOffset.FromUnixTimeMilliseconds(timestamp).DateTime\n                                : DateTimeOffset.FromUnixTimeSeconds(timestamp).DateTime;\n                        }\n                        else\n                        {\n                            request.Date = DateTime.Parse(value);\n                        }\n                        break;\n\n                    default:\n                    request.Headers[name] = value; break;\n                }\n            }\n            return request;\n        }"
            }
        ],
        "third_party": [
            "headers.Add",
            "ReadRequestAsync(baseUri).ConfigureAwait",
            "SendResponseAsync(HttpStatusCode.OK).ConfigureAwait",
            "string.IsNullOrWhiteSpace",
            "command.Split"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "public Task SendResponseAsync(WebResponse response, HttpContent content)",
        "start_line": "112",
        "end_line": "122",
        "file_path": "Source/GrasscutterTools/Eavesdrop/Network/EavesNode.cs",
        "docstring": "The public function SendResponseAsync(WebResponse response, HttpContent content) sends an HTTP response asynchronously.\\nIt initializes the status code and description to \"OK\" by default.\\nIf the response is an HttpWebResponse, it updates the status and description based on the response.\\nIt then calls another SendResponseAsync method with the status, description, headers from the response, and the provided content.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6ed63f3b7a68",
        "ground_truth": "public Task SendResponseAsync(WebResponse response, HttpContent content)\n{\n    string description = \"OK\";\n    var status = HttpStatusCode.OK;\n    if (response is HttpWebResponse httpResponse)\n    {\n        status = httpResponse.StatusCode;\n        description = httpResponse.StatusDescription;\n    }\n    return SendResponseAsync(status, description, response.Headers, content);\n}",
        "import_statements": [
            "using System",
            "using System.IO",
            "using System.Net",
            "using System.Text",
            "using System.Net.Http",
            "using System.Net.Sockets",
            "using System.Net.Security",
            "using System.Globalization",
            "using System.IO.Compression",
            "using System.Threading.Tasks",
            "using System.Collections.Generic",
            "using System.Security.Authentication",
            "using System.Text.RegularExpressions",
            "using System.Security.Cryptography.X509Certificates"
        ],
        "reference_api": [
            "SendResponseAsync"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SendResponseAsync",
                "code": "public Task SendResponseAsync(WebResponse response, HttpContent content)\n        {\n            string description = \"OK\";\n            var status = HttpStatusCode.OK;\n            if (response is HttpWebResponse httpResponse)\n            {\n                status = httpResponse.StatusCode;\n                description = httpResponse.StatusDescription;\n            }\n            return SendResponseAsync(status, description, response.Headers, content);\n        }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private bool SecureTunnel(string host)",
        "start_line": "201",
        "end_line": "213",
        "file_path": "Source/GrasscutterTools/Eavesdrop/Network/EavesNode.cs",
        "docstring": "The private function SecureTunnel(string host) establishes a secure tunnel for a given host.\\nIt attempts to generate an SSL certificate for the host and creates an SSL stream.\\nThe stream is authenticated as a server using the generated certificate and supports TLS protocols.\\nIf the process succeeds, the function returns true; otherwise, it returns false if an exception occurs.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "32d978074585",
        "ground_truth": "private bool SecureTunnel(string host)\n{\n    try\n    {\n        X509Certificate2 certificate = _certifier.GenerateCertificate(host);\n        _secureStream = new SslStream(GetStream());\n        _secureStream.AuthenticateAsServer(certificate, false, SslProtocols.Tls12 | SslProtocols.Tls11 | SslProtocols.Tls, false);\n        return true;\n    }\n    catch { return false; }\n}",
        "import_statements": [
            "using System",
            "using System.IO",
            "using System.Net",
            "using System.Text",
            "using System.Net.Http",
            "using System.Net.Sockets",
            "using System.Net.Security",
            "using System.Globalization",
            "using System.IO.Compression",
            "using System.Threading.Tasks",
            "using System.Collections.Generic",
            "using System.Security.Authentication",
            "using System.Text.RegularExpressions",
            "using System.Security.Cryptography.X509Certificates"
        ],
        "reference_api": [
            "GetStream",
            "_certifier.GenerateCertificate",
            "_secureStream.AuthenticateAsServer"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetStream",
                "code": "public Stream GetStream()\n        {\n            return ((Stream)_secureStream ?? _client.GetStream());\n        }"
            }
        ],
        "third_party": [
            "_certifier.GenerateCertificate",
            "_secureStream.AuthenticateAsServer"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "public static StreamContent ReadResponseContent(WebResponse response)",
        "start_line": "319",
        "end_line": "341",
        "file_path": "Source/GrasscutterTools/Eavesdrop/Network/EavesNode.cs",
        "docstring": "The public static function ReadResponseContent(WebResponse response) reads the content from a web response.\\nIf the response has no content, it disposes of the response stream and returns null.\\nIf there is content, it retrieves the response stream and returns a new StreamContent object.\\nThe StreamContent is created with the input stream and a buffer size based on the content length or a default value of 4096 if the content length is not specified.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "67d773149e9b",
        "ground_truth": "public static StreamContent ReadResponseContent(WebResponse response)\n{\n    if (response.ContentLength == 0)\n    {\n        response.GetResponseStream().Dispose();\n        return null;\n    }\n    Stream input = response.GetResponseStream();\n    //if (response is HttpWebResponse httpResponse && !string.IsNullOrWhiteSpace(httpResponse.ContentEncoding))\n    //{\n    //    switch (httpResponse.ContentEncoding)\n    //    {\n    //        //case \"br\": input = new BrotliStream(input, CompressionMode.Decompress); break;\n    //        case \"gzip\": input = new GZipStream(input, CompressionMode.Decompress); break;\n    //        case \"deflate\": input = new DeflateStream(input, CompressionMode.Decompress); break;\n    //    }\n    //    response.Headers.Remove(HttpResponseHeader.ContentLength);\n    //    response.Headers.Remove(HttpResponseHeader.ContentEncoding);\n    //    response.Headers.Add(HttpResponseHeader.TransferEncoding, \"chunked\");\n    //}\n    return new StreamContent(input, response.ContentLength > 0 ? (int)response.ContentLength : 4096);\n}",
        "import_statements": [
            "using System",
            "using System.IO",
            "using System.Net",
            "using System.Text",
            "using System.Net.Http",
            "using System.Net.Sockets",
            "using System.Net.Security",
            "using System.Globalization",
            "using System.IO.Compression",
            "using System.Threading.Tasks",
            "using System.Collections.Generic",
            "using System.Security.Authentication",
            "using System.Text.RegularExpressions",
            "using System.Security.Cryptography.X509Certificates"
        ],
        "reference_api": [
            "response.GetResponseStream().Dispose",
            "response.GetResponseStream"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "response.GetResponseStream().Dispose",
            "response.GetResponseStream"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void BtnLoad_Click(object sender, EventArgs e)",
        "start_line": "88",
        "end_line": "115",
        "file_path": "Source/GrasscutterTools/Forms/FormActivityEditor.cs",
        "docstring": "The private function BtnLoad_Click(object sender, EventArgs e) handles the click event for loading a configuration file.\\nIt retrieves and trims the text from ActivityConfigJsonPath.\\nIf the path is empty, it opens a file dialog to select a JSON file.\\nIf a file is selected, it updates the path.\\nIt then attempts to load the activity configuration from the specified path and shows a success message.\\nIf an exception occurs, it displays an error message with the exception details.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "45d3c11325cf",
        "ground_truth": "private void BtnLoad_Click(object sender, EventArgs e)\n{\n    try\n    {\n        var path = ActivityConfigJsonPath.Text.Trim();\n        if (path == string.Empty)\n        {\n            var dialog = new OpenFileDialog\n            {\n                FileName = \"ActivityConfig.json\",\n                Filter = \"ActivityConfig.Json (*.json)|*.json|All files (*.*)|*.*\",\n            };\n            var result = dialog.ShowDialog();\n            if (result == DialogResult.OK)\n                path = ActivityConfigJsonPath.Text = dialog.FileName;\n            else\n                return;\n        }\n        // \u53cd\u5e8f\u5217\u5316\n        LoadActivityConfig(path);\n        MessageBox.Show(\"OK\", Resources.Tips, MessageBoxButtons.OK);\n    }\n    catch (Exception ex)\n    {\n        MessageBox.Show(ex.ToString(), Resources.Error, MessageBoxButtons.OK, MessageBoxIcon.Error);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Game.Activity",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils",
            "using Newtonsoft.Json"
        ],
        "reference_api": [
            "ActivityConfigJsonPath.Text.Trim",
            "ox.Show(ex.ToSt",
            "ing(), Reso",
            "dialog.ShowDialog",
            "ox.Show(\"OK\", R",
            "vityConfig(path);\n"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ActivityConfigJsonPath.Text.Trim",
            "ox.Show(ex.ToSt",
            "ing(), Reso",
            "dialog.ShowDialog",
            "ox.Show(\"OK\", R",
            "vityConfig(path);\n"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void LoadActivityConfig(string path)",
        "start_line": "121",
        "end_line": "128",
        "file_path": "Source/GrasscutterTools/Forms/FormActivityEditor.cs",
        "docstring": "The private function LoadActivityConfig(string path) loads activity configuration from a specified file path.\\nIt deserializes the JSON content of the file into a list of ActivityConfigItem objects and assigns it to ActivityConfigItems.\\nIt then updates the ListActivityConfigItems control by clearing existing items, adding the newly loaded items, and ending the update to refresh the display.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f97d2ba1a807",
        "ground_truth": "private void LoadActivityConfig(string path)\n{\n    ActivityConfigItems = JsonConvert.DeserializeObject<List<ActivityConfigItem>>(File.ReadAllText(path)) ?? new List<ActivityConfigItem>();\n    ListActivityConfigItems.BeginUpdate();\n    ListActivityConfigItems.Items.Clear();\n    ListActivityConfigItems.Items.AddRange(ActivityConfigItems.Select(Convert).ToArray());\n    ListActivityConfigItems.EndUpdate();\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Game.Activity",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils",
            "using Newtonsoft.Json"
        ],
        "reference_api": [
            "ListActivityConfigItems.Items.Clear",
            "ListActivityConfigItems.Items.AddRange",
            "JsonConvert.DeserializeObject<List<ActivityConfigItem>>",
            "File.ReadAllText",
            "ActivityConfigItems.Select",
            "ListActivityConfigItems.EndUpdate",
            "ActivityConfigItems.Select(Convert).ToArray",
            "ListActivityConfigItems.BeginUpdate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ListActivityConfigItems.Items.Clear",
            "ListActivityConfigItems.Items.AddRange",
            "JsonConvert.DeserializeObject<List<ActivityConfigItem>>",
            "ActivityConfigItems.Select",
            "ListActivityConfigItems.EndUpdate",
            "ActivityConfigItems.Select(Convert).ToArray",
            "ListActivityConfigItems.BeginUpdate"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void BtnSave_Click(object sender, EventArgs e)",
        "start_line": "144",
        "end_line": "171",
        "file_path": "Source/GrasscutterTools/Forms/FormActivityEditor.cs",
        "docstring": "The private function BtnSave_Click(object sender, EventArgs e) handles the click event for saving configuration data.\\nIt retrieves and trims the file path from the ActivityConfigJsonPath text box.\\nIf the path is empty, it opens a SaveFileDialog to allow the user to select a file path.\\nIf the user selects a file, it updates the ActivityConfigJsonPath text box with the chosen path.\\nIf the path is still empty, the function returns without saving.\\nThe function then serializes the ActivityConfigItems to JSON and writes it to the specified file path.\\nIf successful, it displays a confirmation message.\\nIf an exception occurs, it shows an error message with the exception details.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8531cab08f38",
        "ground_truth": "private void BtnSave_Click(object sender, EventArgs e)\n{\n    try\n    {\n        var path = ActivityConfigJsonPath.Text.Trim();\n        if (path == string.Empty)\n        {\n            var dialog = new SaveFileDialog\n            {\n                FileName = \"ActivityConfig.json\",\n                Filter = \"ActivityConfig.json (*.json)|*.json|All files (*.*)|*.*\",\n            };\n            var result = dialog.ShowDialog();\n            if (result == DialogResult.OK)\n                path = ActivityConfigJsonPath.Text = dialog.FileName;\n            else\n                return;\n        }\n        // \u5e8f\u5217\u5316\n        File.WriteAllText(path, JsonConvert.SerializeObject(ActivityConfigItems, Formatting.Indented));\n        MessageBox.Show(\"OK\", Resources.Tips, MessageBoxButtons.OK);\n    }\n    catch (Exception ex)\n    {\n        MessageBox.Show(ex.ToString(), Resources.Error, MessageBoxButtons.OK, MessageBoxIcon.Error);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Game.Activity",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils",
            "using Newtonsoft.Json"
        ],
        "reference_api": [
            "ActivityConfigJsonPath.Text.Trim",
            "dialog.ShowDialog",
            "riteAllText(path,",
            "tring(), Re",
            "eBox.Show(ex.To",
            "nvert.SerializeObject(Activ",
            "eBox.Show(\"OK\","
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ActivityConfigJsonPath.Text.Trim",
            "dialog.ShowDialog",
            "riteAllText(path,",
            "tring(), Re",
            "eBox.Show(ex.To",
            "nvert.SerializeObject(Activ",
            "eBox.Show(\"OK\","
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void LoadAllActivity()",
        "start_line": "180",
        "end_line": "195",
        "file_path": "Source/GrasscutterTools/Forms/FormActivityEditor.cs",
        "docstring": "The private function LoadAllActivity() populates a ListView control with activity data.\\nIt begins by disabling updates to the ListView for efficient bulk processing.\\nIt iterates through each activity group in the GameData.Activity collection.\\nFor each group, it creates a new group control in the ListView and adds items representing the activity IDs and names to this group.\\nAfter all items are added, it re-enables updates to the ListView.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "424111434149",
        "ground_truth": "private void LoadAllActivity()\n{\n    ListAllActivity.BeginUpdate();\n    foreach (var grp in GameData.Activity)\n    {\n        var grpControl = ListAllActivity.Groups.Add(grp.Key, grp.Key);\n        for (var i = 0; i < grp.Value.Count; i++)\n        {\n            ListAllActivity.Items.Add(new ListViewItem(new[]\n            {\n                grp.Value.Ids[i].ToString(), grp.Value.Names[i]\n            }, grpControl));\n        }\n    }\n    ListAllActivity.EndUpdate();\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Game.Activity",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils",
            "using Newtonsoft.Json"
        ],
        "reference_api": [
            "ListAllActivity.EndUpdate",
            "ListAllActivity.Groups.Add",
            "grp.Value.Ids[i].ToString",
            "ListAllActivity.BeginUpdate",
            "ListAllActivity.Items.Add"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ListAllActivity.EndUpdate",
            "ListAllActivity.Groups.Add",
            "grp.Value.Ids[i].ToString",
            "ListAllActivity.BeginUpdate",
            "ListAllActivity.Items.Add"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void ListAllActivity_SelectedIndexChanged(object sender, EventArgs e)",
        "start_line": "200",
        "end_line": "212",
        "file_path": "Source/GrasscutterTools/Forms/FormActivityEditor.cs",
        "docstring": "The private function ListAllActivity_SelectedIndexChanged handles the event when the selected index changes in the ListAllActivity control.\\nIt checks if any items are selected and, if none are selected, it returns.\\nIf an item is selected, it sets the text of NUDActivityId to the text of the selected item.\\nIf an exception occurs, it displays an error message with the exception details in a message box.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "51c5d7f71cb3",
        "ground_truth": "private void ListAllActivity_SelectedIndexChanged(object sender, EventArgs e)\n{\n    try\n    {\n        if (ListAllActivity.SelectedItems.Count == 0)\n            return;\n        NUDActivityId.Text = ListAllActivity.SelectedItems[0].Text;\n    }\n    catch (Exception ex)\n    {\n        MessageBox.Show(ex.ToString(), Resources.Error, MessageBoxButtons.OK, MessageBoxIcon.Error);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Game.Activity",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils",
            "using Newtonsoft.Json"
        ],
        "reference_api": [
            "ex.ToString",
            "MessageBox.Show"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ex.ToString",
            "MessageBox.Show"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void BtnLoad_Click(object sender, EventArgs e)",
        "start_line": "113",
        "end_line": "140",
        "file_path": "Source/GrasscutterTools/Forms/FormDropEditor.cs",
        "docstring": "The private function BtnLoad_Click(object sender, EventArgs e) handles the click event for loading a JSON file.\\nIt retrieves the file path from a text box and checks if it is empty.\\nIf the path is empty, it opens a file dialog to select a JSON file.\\nIf a file is selected, it updates the text box with the selected file path.\\nThe function then attempts to deserialize and load the banners from the specified file path.\\nIf successful, it shows a success message.\\nIf an exception occurs, it displays an error message with the exception details.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8bed5c7884dc",
        "ground_truth": "private void BtnLoad_Click(object sender, EventArgs e)\n{\n    try\n    {\n        var path = TxtDropJsonPath.Text.Trim();\n        if (path == string.Empty)\n        {\n            var dialog = new OpenFileDialog\n            {\n                FileName = \"Drop.json\",\n                Filter = \"Drop.Json (*.json)|*.json|All files (*.*)|*.*\",\n            };\n            var result = dialog.ShowDialog();\n            if (result == DialogResult.OK)\n                path = TxtDropJsonPath.Text = dialog.FileName;\n            else\n                return;\n        }\n        // \u53cd\u5e8f\u5217\u5316\n        LoadBanners(path);\n        MessageBox.Show(\"OK\", Resources.Tips, MessageBoxButtons.OK);\n    }\n    catch (Exception ex)\n    {\n        MessageBox.Show(ex.ToString(), Resources.Error, MessageBoxButtons.OK, MessageBoxIcon.Error);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Game.Drop",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils",
            "using Newtonsoft.Json"
        ],
        "reference_api": [
            "ox.Show(ex.ToSt",
            "ing(), Reso",
            "dialog.ShowDialog",
            "ox.Show(\"OK\", R",
            "ers(path);\n",
            "TxtDropJsonPath.Text.Trim"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ox.Show(ex.ToSt",
            "ing(), Reso",
            "dialog.ShowDialog",
            "ox.Show(\"OK\", R",
            "ers(path);\n",
            "TxtDropJsonPath.Text.Trim"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void ShowDropList(List<DropData> dropList)",
        "start_line": "280",
        "end_line": "291",
        "file_path": "Source/GrasscutterTools/Forms/FormDropEditor.cs",
        "docstring": "The private function ShowDropList(List<DropData> dropList) displays a list of drop data in a UI component.\\nIt begins by updating the list, clears any existing items, and checks if the drop list contains elements.\\nIf there are elements, it adds them to the list, setting the first item as selected.\\nFinally, it ends the update process for the list.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0e39a56d211b",
        "ground_truth": "private void ShowDropList(List<DropData> dropList)\n{\n    // \u663e\u793a\u5230\u5217\u8868\n    ListDropData.BeginUpdate();\n    ListDropData.Items.Clear();\n    if (dropList.Count > 0)\n    {\n        ListDropData.Items.AddRange(dropList.Select(it => it.ToString()).ToArray());\n        ListDropData.SelectedIndex = 0;\n    }\n    ListDropData.EndUpdate();\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Game.Drop",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils",
            "using Newtonsoft.Json"
        ],
        "reference_api": [
            "elect(it => it.",
            "elect(it => it.ToString()).ToArray());\n     ",
            "ta.Items.Clear();\n      ",
            "ta.BeginUpdate();\n      ",
            "ta.EndUpdate();\n      ",
            "g()).ToArra",
            "ta.Items.AddRange(dropList."
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "elect(it => it.",
            "elect(it => it.ToString()).ToArray());\n     ",
            "ta.Items.Clear();\n      ",
            "ta.BeginUpdate();\n      ",
            "ta.EndUpdate();\n      ",
            "g()).ToArra",
            "ta.Items.AddRange(dropList."
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void RemoveDrop(DropData data)",
        "start_line": "462",
        "end_line": "479",
        "file_path": "Source/GrasscutterTools/Forms/FormDropEditor.cs",
        "docstring": "The private function ShowDropList(List<DropData> dropList) updates a list display with provided drop data.\\nIt begins by stopping updates to the list, clears any existing items, and checks if the drop list contains items.\\nIf items are present, it adds them to the list and selects the first item.\\nFinally, it resumes updates to the list.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "60fd5605c44e",
        "ground_truth": "private void RemoveDrop(DropData data)\n{\n    if (ListMonsters.SelectedItems.Count == 0)\n        return;\n    foreach (var monsterId in SelectedMonsterIds())\n    {\n        if (!Banners.TryGetValue(monsterId, out List<DropData> dropList))\n        {\n            dropList = new List<DropData>();\n            Banners[monsterId] = dropList;\n        }\n        dropList.Remove(data);\n    }\n    SelectedDropList.Remove(data);\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Game.Drop",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils",
            "using Newtonsoft.Json"
        ],
        "reference_api": [
            "SelectedMonsterIds",
            "Banners.TryGetValue",
            "SelectedDropList.Remove",
            "dropList.Remove"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SelectedMonsterIds",
                "code": "private IEnumerable<int> SelectedMonsterIds()\n        {\n            foreach (string item in ListMonsters.SelectedItems)\n                yield return ItemMap.ToId(item);\n        }"
            }
        ],
        "third_party": [
            "Banners.TryGetValue",
            "SelectedDropList.Remove",
            "dropList.Remove"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private void FormMain_FormClosed(object sender, FormClosedEventArgs e)",
        "start_line": "161",
        "end_line": "175",
        "file_path": "Source/GrasscutterTools/Forms/FormMain.cs",
        "docstring": "The private function FormMain_FormClosed(object sender, FormClosedEventArgs e) handles the event when the main form is closed.\\nIt logs the entry into the form closed event and iterates through each page, logging the start and completion of their OnClosed method.\\nIt then saves the current settings and logs the completion of the form closed event.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "475581af77bf",
        "ground_truth": "private void FormMain_FormClosed(object sender, FormClosedEventArgs e)\n{\n    Logger.I(TAG, \"FormMain FormClosed enter\");\n    // \u904d\u5386\u6bcf\u4e00\u4e2a\u9875\u9762\uff0c\u901a\u77e5\u5173\u95ed\n    foreach (var page in Pages.Values)\n    {\n        Logger.I(TAG, $\"{page.Name} OnClosed enter\");\n        page.OnClosed();\n        Logger.I(TAG, $\"{page.Name} OnClosed completed\");\n    }\n    // \u4fdd\u5b58\u5f53\u524d\u8bbe\u7f6e\n    SaveSettings();\n    Logger.I(TAG, \"FormMain FormClosed completed\");\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Collections.Specialized",
            "using System.Drawing",
            "using System.Linq",
            "using System.Threading.Tasks",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Pages",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils"
        ],
        "reference_api": [
            "         Logg",
            "me} OnCl",
            "Logger.I",
            "(TAG, \"FormM",
            "ompleted"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "         Logg",
            "me} OnCl",
            "Logger.I",
            "(TAG, \"FormM",
            "ompleted"
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": " private void SaveSettings()",
        "start_line": "180",
        "end_line": "201",
        "file_path": "Source/GrasscutterTools/Forms/FormMain.cs",
        "docstring": "The private function SaveSettings() saves the current application settings.\\nIt records the state of the UI, such as whether AutoCopy is checked, the window's position if it is in normal state, and the size of the main form adjusted for the command log height if applicable.\\nIt also records the splitter distance of the navigation container.\\nThe settings are then saved, and any errors during the process are logged and displayed in an error message to the user.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "afd99ce2de2b",
        "ground_truth": "private void SaveSettings()\n{\n    try\n    {\n        // \u8bb0\u5f55\u754c\u9762\u72b6\u6001\n        Settings.Default.AutoCopy = ChkAutoCopy.Checked;\n        // \u8bb0\u5f55\u7a97\u53e3\u4f4d\u7f6e\n        if (WindowState == FormWindowState.Normal)\n            Settings.Default.MainFormLocation = Location;\n        // \u5982\u679c\u547d\u4ee4\u7a97\u53e3\u5df2\u7ecf\u5f39\u51fa\u4e86\uff0c\u5219\u4e0d\u8981\u4fdd\u5b58\u591a\u4f59\u7684\u9ad8\u5ea6\n        Settings.Default.MainFormSize = TxtCommandRunLog != null ? new Size(Width, Height - TxtCommandRunLogMinHeight) : Size;\n        // \u8bb0\u5f55\u5bfc\u822a\u5bb9\u5668\u5206\u9694\u4f4d\u7f6e\n        Settings.Default.NavContainerSplitterDistance = NavContainer.SplitterDistance;\n        // \u4fdd\u5b58\u8bbe\u7f6e\n        Settings.Default.Save();\n    }\n    catch (Exception ex)\n    {\n        Logger.E(TAG, \"Save settings failed.\", ex);\n        MessageBox.Show(Resources.SettingSaveError + ex.Message, Resources.Error, MessageBoxButtons.OK, MessageBoxIcon.Error);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Collections.Specialized",
            "using System.Drawing",
            "using System.Linq",
            "using System.Threading.Tasks",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Pages",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils"
        ],
        "reference_api": [
            "eError +",
            "MessageBoxIcon.",
            "      Logger.E(TAG, \""
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "eError +",
            "MessageBoxIcon.",
            "      Logger.E(TAG, \""
        ]
    },
    {
        "subclass": "WinForm",
        "owner/repo": "jie65535/GrasscutterCommandGenerator",
        "function_declaration": "private List<Tuple<string, bool>> LoadPageTabOrders()",
        "start_line": "254",
        "end_line": "279",
        "file_path": "Source/GrasscutterTools/Forms/FormMain.cs",
        "docstring": "The private function LoadPageTabOrders() loads the order and visibility status of page tabs.\\nIt first checks if PageTabOrders is already initialized and returns it if so.\\nIf not, it initializes a list of tab orders.\\nIf no page orders are found in the settings, it creates a default list with all pages visible.\\nIf page orders are found, it reads each order from the settings, parsing the page name and visibility status.\\nThe function then returns the list of tab orders.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "597cf3c3cb9f",
        "ground_truth": "private List<Tuple<string, bool>> LoadPageTabOrders()\n{\n    if (PageTabOrders != null) return PageTabOrders;\n    List<Tuple<string, bool>> tabOrders;\n    if (!(Settings.Default.PageOrders?.Count > 0))\n    {\n        tabOrders = new List<Tuple<string, bool>>(Pages.Count);\n        // \u9ed8\u8ba4\u72b6\u6001\n        foreach (var tab in Pages)\n            tabOrders.Add(new Tuple<string, bool>(tab.Key, true));\n    }\n    else\n    {\n        tabOrders = new List<Tuple<string, bool>>(Settings.Default.PageOrders.Count);\n        // \u4ece\u8bbe\u7f6e\u4e2d\u8bfb\u53d6\n        foreach (var item in Settings.Default.PageOrders)\n        {\n            // \u5192\u53f7\u5206\u9694\u7684\u9879   \"PageHome:1\"  0=\u9690\u85cf 1=\u663e\u793a\n            var sp = item.IndexOf(':');\n            if (sp == -1 || !int.TryParse(item.Substring(sp + 1), out var isVisible)) continue;\n            tabOrders.Add(new Tuple<string, bool>(item.Substring(0, sp), isVisible != 0));\n        }\n    }\n    return tabOrders;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Collections.Specialized",
            "using System.Drawing",
            "using System.Linq",
            "using System.Threading.Tasks",
            "using System.Windows.Forms",
            "using GrasscutterTools.Game",
            "using GrasscutterTools.Pages",
            "using GrasscutterTools.Properties",
            "using GrasscutterTools.Utils"
        ],
        "reference_api": [
            "em.Substring(",
            " var isVisib",
            "s.Add(new Tup",
            "f (sp == -1 ",
            "e)) continue;\n",
            "\n             "
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "em.Substring(",
            " var isVisib",
            "s.Add(new Tup",
            "f (sp == -1 ",
            "e)) continue;\n",
            "\n             "
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "public override void Save(FrameInfo info)",
        "start_line": "539",
        "end_line": "549",
        "file_path": "ScreenToGif/Capture/DirectCachedCapture.cs",
        "docstring": "The public override function Save(FrameInfo info) saves frame data to a compressed stream.\\nIt logs the length of the frame data and the current file stream length.\\nIt writes the frame data to the compression stream and flushes the stream.\\nThe frame data is then set to null.\\nFinally, the frame information is added to the project's frames collection.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "952af4cba521",
        "ground_truth": "public override void Save(FrameInfo info)\n{\n    System.Diagnostics.Debug.WriteLine(\"Length:\" + info.Data.Length + \" \" + _fileStream.Length);\n    _compressStream.WriteBytes(info.Data);\n    _compressStream.Flush();\n    info.Data = null;\n    Project.Frames.Add(info);\n}",
        "import_statements": [
            "using System",
            "using System.IO",
            "using System.IO.Compression",
            "using System.Runtime.InteropServices",
            "using System.Threading.Tasks",
            "using System.Windows",
            "using ScreenToGif.Model",
            "using ScreenToGif.Util",
            "using ScreenToGif.Util.Settings",
            "using SharpDX",
            "using SharpDX.Direct3D11",
            "using SharpDX.DXGI",
            "using SharpDX.Mathematics.Interop",
            "using MapFlags = SharpDX.Direct3D11.MapFlags"
        ],
        "reference_api": [
            "Project.Frames.Add",
            "System.Diagnostics.Debug.WriteLine",
            "_compressStream.Flush",
            "_compressStream.WriteBytes"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Project.Frames.Add",
            "System.Diagnostics.Debug.WriteLine",
            "_compressStream.Flush",
            "_compressStream.WriteBytes"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "private void DrawCursorShape(Texture2D texture, OutputDuplicatePointerShapeInformation info, byte[] buffer, int leftCut, int topCut, int cursorWidth, int cursorHeight)",
        "start_line": "872",
        "end_line": "900",
        "file_path": "ScreenToGif/Capture/DirectImageCapture.cs",
        "docstring": "The private function DrawCursorShape(Texture2D texture, OutputDuplicatePointerShapeInformation info, byte[] buffer, int leftCut, int topCut, int cursorWidth, int cursorHeight) renders the cursor shape on a texture.\\nIt uses a surface interface to map the texture for CPU access.\\nThe function handles three cursor types: Monochrome, Color, and Masked Color.\\nFor each type, it calls the appropriate function to draw the cursor based on the provided parameters, including position, dimensions, pitch, and buffer data.\\nAfter drawing, it unmaps the surface to release the CPU access.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f9417f7056c0",
        "ground_truth": "private void DrawCursorShape(Texture2D texture, OutputDuplicatePointerShapeInformation info, byte[] buffer, int leftCut, int topCut, int cursorWidth, int cursorHeight)\n{\n    using (var surface = texture.QueryInterface<Surface>())\n    {\n        //Maps the surface, indicating that the CPU needs access to the data.\n        var rect = surface.Map(SharpDX.DXGI.MapFlags.Write);\n        //Cursors can be divided into 3 types:\n        switch (info.Type)\n        {\n            //Masked monochrome, a cursor which reacts with the background.\n            case (int)OutputDuplicatePointerShapeType.Monochrome:\n                DrawMonochromeCursor(leftCut, topCut, cursorWidth, cursorHeight, rect, info.Pitch, buffer, info.Height);\n                break;\n            //Color, a colored cursor which supports transparency.\n            case (int)OutputDuplicatePointerShapeType.Color:\n                DrawColorCursor(leftCut, topCut, cursorWidth, cursorHeight, rect, info.Pitch, buffer);\n                break;\n            //Masked color, a mix of both previous types.\n            case (int)OutputDuplicatePointerShapeType.MaskedColor:\n                DrawMaskedColorCursor(leftCut, topCut, cursorWidth, cursorHeight, rect, info.Pitch, buffer);\n                break;\n        }\n        surface.Unmap();\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Drawing.Imaging",
            "using System.Linq",
            "using System.Runtime.InteropServices",
            "using System.Threading.Tasks",
            "using System.Windows",
            "using ScreenToGif.Domain.Enums.Native",
            "using ScreenToGif.Domain.Exceptions",
            "using ScreenToGif.Model",
            "using ScreenToGif.Native.External",
            "using ScreenToGif.Native.Structs",
            "using ScreenToGif.Util",
            "using SharpDX",
            "using SharpDX.Direct3D",
            "using SharpDX.Direct3D11",
            "using SharpDX.DXGI",
            "using SharpDX.Mathematics.Interop",
            "using Device = SharpDX.Direct3D11.Device",
            "using MapFlags = SharpDX.Direct3D11.MapFlags"
        ],
        "reference_api": [
            "texture.QueryInterface<Surface>",
            "DrawMaskedColorCursor",
            "DrawColorCursor",
            "surface.Map",
            "DrawMonochromeCursor",
            "surface.Unmap"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "DrawMaskedColorCursor",
                "code": "private void DrawMaskedColorCursor(int offsetX, int offsetY, int width, int height, DataRectangle rect, int pitch, byte[] buffer)\n    {\n        //ImageUtil.ImageMethods.SavePixelArrayToFile(buffer, width, height, 4, System.IO.Path.GetFullPath(\".\\\\MaskedColor.png\"));\n\n        for (var row = offsetY; row < height; row++)\n        {\n            for (var col = offsetX; col < width; col++)\n            {\n                var surfaceIndex = (row - offsetY) * rect.Pitch + (col - offsetX) * 4;\n                var bufferIndex = row * pitch + col * 4;\n                var maskFlag = buffer[bufferIndex + 3];\n\n                //Just copies the pixel color.\n                if (maskFlag == 0)\n                {\n                    Marshal.WriteByte(rect.DataPointer, surfaceIndex, buffer[bufferIndex]);\n                    Marshal.WriteByte(rect.DataPointer, surfaceIndex + 1, buffer[bufferIndex + 1]);\n                    Marshal.WriteByte(rect.DataPointer, surfaceIndex + 2, buffer[bufferIndex + 2]);\n                    return;\n                }\n\n                //Applies the XOR operation with the current color.\n                Marshal.WriteByte(rect.DataPointer, surfaceIndex, (byte)(buffer[bufferIndex] ^ Marshal.ReadByte(rect.DataPointer, surfaceIndex)));\n                Marshal.WriteByte(rect.DataPointer, surfaceIndex + 1, (byte)(buffer[bufferIndex + 1] ^ Marshal.ReadByte(rect.DataPointer, surfaceIndex + 1)));\n                Marshal.WriteByte(rect.DataPointer, surfaceIndex + 2, (byte)(buffer[bufferIndex + 2] ^ Marshal.ReadByte(rect.DataPointer, surfaceIndex + 2)));\n            }\n        }\n    }"
            },
            {
                "name": "DrawColorCursor",
                "code": "private void DrawColorCursor(int offsetX, int offsetY, int width, int height, DataRectangle rect, int pitch, byte[] buffer)\n    {\n        for (var row = offsetY; row < height; row++)\n        {\n            for (var col = offsetX; col < width; col++)\n            {\n                var surfaceIndex = (row - offsetY) * rect.Pitch + (col - offsetX) * 4;\n                var bufferIndex = row * pitch + col * 4;\n                var alpha = buffer[bufferIndex + 3] + 1;\n\n                if (alpha == 1)\n                    continue;\n\n                //Premultiplied alpha values.\n                var invAlpha = 256 - alpha;\n                alpha += 1;\n\n                Marshal.WriteByte(rect.DataPointer, surfaceIndex, (byte)((alpha * buffer[bufferIndex] + invAlpha * Marshal.ReadByte(rect.DataPointer, surfaceIndex)) >> 8));\n                Marshal.WriteByte(rect.DataPointer, surfaceIndex + 1, (byte)((alpha * buffer[bufferIndex + 1] + invAlpha * Marshal.ReadByte(rect.DataPointer, surfaceIndex + 1)) >> 8));\n                Marshal.WriteByte(rect.DataPointer, surfaceIndex + 2, (byte)((alpha * buffer[bufferIndex + 2] + invAlpha * Marshal.ReadByte(rect.DataPointer, surfaceIndex + 2)) >> 8));\n            }\n        }\n    }"
            },
            {
                "name": "DrawMonochromeCursor",
                "code": "private void DrawMonochromeCursor(int offsetX, int offsetY, int width, int height, DataRectangle rect, int pitch, byte[] buffer, int actualHeight)\n    {\n        for (var row = offsetY; row < height; row++)\n        {\n            //128 in binary.\n            byte mask = 0x80;\n\n            //Simulate the offset, adjusting the mask.\n            for (var off = 0; off < offsetX; off++)\n            {\n                if (mask == 0x01)\n                    mask = 0x80;\n                else\n                    mask = (byte)(mask >> 1);\n            }\n\n            for (var col = offsetX; col < width; col++)\n            {\n                var pos = (row - offsetY) * rect.Pitch + (col - offsetX) * 4;\n                var and = (buffer[row * pitch + col / 8] & mask) == mask; //Mask is take from the first half of the cursor image.\n                var xor = (buffer[row * pitch + col / 8 + actualHeight * pitch] & mask) == mask; //Mask is taken from the second half of the cursor image, hence the \"+ height * pitch\".\n\n                //Reads current pixel and applies AND and XOR. (AND/XOR ? White : Black)\n                Marshal.WriteByte(rect.DataPointer, pos, (byte)((Marshal.ReadByte(rect.DataPointer, pos) & (and ? 255 : 0)) ^ (xor ? 255 : 0)));\n                Marshal.WriteByte(rect.DataPointer, pos + 1, (byte)((Marshal.ReadByte(rect.DataPointer, pos + 1) & (and ? 255 : 0)) ^ (xor ? 255 : 0)));\n                Marshal.WriteByte(rect.DataPointer, pos + 2, (byte)((Marshal.ReadByte(rect.DataPointer, pos + 2) & (and ? 255 : 0)) ^ (xor ? 255 : 0)));\n                Marshal.WriteByte(rect.DataPointer, pos + 3, (byte)((Marshal.ReadByte(rect.DataPointer, pos + 3) & 255) ^ 0));\n\n                //Shifts the mask around until it reaches 1, then resets it back to 128.\n                if (mask == 0x01)\n                    mask = 0x80;\n                else\n                    mask = (byte)(mask >> 1);\n            }\n        }\n    }"
            }
        ],
        "third_party": [
            "texture.QueryInterface<Surface>",
            "surface.Map",
            "surface.Unmap"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "public static IUploader CreateCloud(UploadDestinations service)",
        "start_line": "9",
        "end_line": "20",
        "file_path": "ScreenToGif/Cloud/CloudFactory.cs",
        "docstring": "The public static function CreateCloud(UploadDestinations service) creates and returns an uploader instance based on the specified upload destination.\\nIt uses a switch statement to determine the service type.\\nIf the service is Imgur, it returns a new Imgur uploader.\\nIf the service is Yandex, it returns a new YandexDisk uploader.\\nIf the service type is not implemented, it throws a NotImplementedException.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3eb27d345e3c",
        "ground_truth": "public static IUploader CreateCloud(UploadDestinations service)\n{\n    switch (service)\n    {\n        case UploadDestinations.Imgur:\n            return new Imgur();\n        case UploadDestinations.Yandex:\n            return new YandexDisk();\n    }\n    throw new NotImplementedException();\n}",
        "import_statements": [
            "using System",
            "using ScreenToGif.Domain.Enums",
            "using ScreenToGif.Domain.Interfaces"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "public async Task<IHistory> UploadFileAsync(IUploadPreset preset, string path, CancellationToken cancellationToken, IProgress<double> progressCallback = null)\n    {",
        "start_line": "19",
        "end_line": "48",
        "file_path": "ScreenToGif/Cloud/YandexDisk.cs",
        "docstring": "The public async function UploadFileAsync(IUploadPreset preset, string path, CancellationToken cancellationToken, IProgress<double> progressCallback = null) uploads a file to Yandex Disk.\\nIt first checks if the provided file path is valid.\\nIt retrieves an upload link for the file using a preset.\\nIf the link is invalid, it throws an upload exception.\\nIt then opens a file stream and uploads the file to the provided link.\\nAfter uploading, it retrieves a download link for the file.\\nFinally, it creates a history record with upload details and returns it.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8e8c5ad2d18c",
        "ground_truth": "public async Task<IHistory> UploadFileAsync(IUploadPreset preset, string path, CancellationToken cancellationToken, IProgress<double> progressCallback = null)\n{\n    if (string.IsNullOrEmpty(path)) \n        throw new ArgumentException(nameof(path));\n    var fileName = Path.GetFileName(path);\n    var link = await GetAsync<Link>(preset as YandexPreset, \"https://cloud-api.yandex.net/v1/disk/resources/upload?path=app:/\" + fileName + \"&overwrite=true\", cancellationToken);\n             if (string.IsNullOrEmpty(link?.Href)) \n        throw new UploadException(\"Unknown error\");\n    await using (var fileSteram = new FileStream(path, FileMode.Open, FileAccess.Read))\n    {\n        await PutAsync(preset as YandexPreset, link.Href, new StreamContent(fileSteram), cancellationToken);\n    }\n    var downloadLink = await GetAsync<Link>(preset as YandexPreset, \"https://cloud-api.yandex.net/v1/disk/resources/download?path=app:/\" + fileName, cancellationToken);\n    var history = new History\n    {\n        Type = preset.Type,\n        PresetName = preset.Title,\n        DateInUtc = DateTime.UtcNow,\n        Result = 200,\n        Link = downloadLink.Href\n    };\n             return history;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Net",
            "using System.Net.Http",
            "using System.Threading",
            "using System.Threading.Tasks",
            "using ScreenToGif.Domain.Interfaces",
            "using ScreenToGif.Domain.Models.Upload.YandexDisk",
            "using ScreenToGif.Util",
            "using ScreenToGif.Util.Settings",
            "using ScreenToGif.ViewModel.UploadPresets.History",
            "using ScreenToGif.ViewModel.UploadPresets.Yandex"
        ],
        "reference_api": [
            "string.IsNullOrEmpty",
            "nameof",
            "PutAsync",
            "GetAsync<Link>",
            "Path.GetFileName"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "PutAsync",
                "code": "private async Task PutAsync(YandexPreset preset, string url, HttpContent content, CancellationToken cancellationToken)\n    {\n        var handler = new HttpClientHandler\n        {\n            Proxy = WebHelper.GetProxy(),\n            PreAuthenticate = true,\n            UseDefaultCredentials = false,\n        };\n\n        using (var client = new HttpClient(handler))\n        {\n            var request = new HttpRequestMessage(HttpMethod.Put, url)\n            {\n                Headers =\n                {\n                    {HttpRequestHeader.Authorization.ToString(), \"OAuth \" + preset.OAuthToken}\n                },\n                Content = content\n            };\n\n            using (await client.SendAsync(request, cancellationToken))\n            { }\n        }\n    }"
            }
        ],
        "third_party": [
            "string.IsNullOrEmpty",
            "nameof",
            "GetAsync<Link>",
            "Path.GetFileName"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "internal virtual void StartCapture()",
        "start_line": "120",
        "end_line": "135",
        "file_path": "ScreenToGif/Controls/BaseScreenRecorder.cs",
        "docstring": "The internal virtual function StartCapture() initiates the capture process.\\nIt starts the frame rate with either a fixed or variable delay and sets HasImpreciseCapture to false.\\nIf forced garbage collection is enabled in the user settings, it starts the garbage collection timer.\\nIt locks the user settings, creates a cancellation token for the capture process, and runs the capture loop in a new task using the specified capture interval.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0c0b742bf9e6",
        "ground_truth": "internal virtual void StartCapture()\n{\n    FrameRate.Start(HasFixedDelay(), GetFixedDelay());\n    HasImpreciseCapture = false;\n    if (UserSettings.All.ForceGarbageCollection)\n        GarbageTimer.Start();\n    lock (UserSettings.Lock)\n    {\n        //Starts the capture.\n        _captureToken = new CancellationTokenSource();\n        Task.Run(() => PrepareCaptureLoop(GetCaptureInterval()), _captureToken.Token);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Diagnostics",
            "using System.Threading",
            "using System.Threading.Tasks",
            "using ScreenToGif.Capture",
            "using ScreenToGif.Domain.Enums",
            "using ScreenToGif.Domain.Interfaces",
            "using ScreenToGif.Model",
            "using ScreenToGif.Native.Helpers",
            "using ScreenToGif.Util",
            "using ScreenToGif.Util.Settings"
        ],
        "reference_api": [
            "FrameRate.Start",
            "GetCaptureInterval",
            "HasFixedDelay",
            "Task.Run",
            "GetFixedDelay",
            "GarbageTimer.Start",
            "PrepareCaptureLoop"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetCaptureInterval",
                "code": "internal int GetCaptureInterval()\n    {\n        switch (UserSettings.All.CaptureFrequency)\n        {\n            case CaptureFrequencies.PerHour: //15 frames per hour = 240,000 ms (240 sec, 4 min).\n                return (1000 * 60 * 60) / UserSettings.All.LatestFps;\n\n            case CaptureFrequencies.PerMinute: //15 frames per minute = 4,000 ms (4 sec).\n                return (1000 * 60) / UserSettings.All.LatestFps;\n\n            default: //PerSecond. 15 frames per second = 66 ms.\n                return 1000 / UserSettings.All.LatestFps;\n        }\n    }"
            },
            {
                "name": "HasFixedDelay",
                "code": "internal bool HasFixedDelay()\n    {\n        return UserSettings.All.CaptureFrequency != CaptureFrequencies.PerSecond || UserSettings.All.FixedFrameRate;\n    }"
            },
            {
                "name": "GetFixedDelay",
                "code": "internal int GetFixedDelay()\n    {\n        switch (UserSettings.All.CaptureFrequency)\n        {\n            case CaptureFrequencies.Manual:\n                return UserSettings.All.PlaybackDelayManual;\n            case CaptureFrequencies.Interaction:\n                return UserSettings.All.PlaybackDelayInteraction;\n            case CaptureFrequencies.PerMinute:\n                return UserSettings.All.PlaybackDelayMinute;\n            case CaptureFrequencies.PerHour:\n                return UserSettings.All.PlaybackDelayHour;\n            default: //When the capture is 'PerSecond', the fixed delay is set to use the current framerate.\n                return 1000 / UserSettings.All.LatestFps;\n        }\n    }"
            },
            {
                "name": "PrepareCaptureLoop",
                "code": "private void PrepareCaptureLoop(int interval)\n    {\n        using (var resolution = new TimerResolution(1))\n        {\n            if (!resolution.SuccessfullySetTargetResolution)\n            {\n                LogWriter.Log($\"Imprecise timer resolution... Target: {resolution.TargetResolution}, Current: {resolution.CurrentResolution}\");\n                Dispatcher.Invoke(() => HasImpreciseCapture = true);\n            }\n\n            if (UserSettings.All.ShowCursor)\n                CaptureWithCursor(interval);\n            else\n                CaptureWithoutCursor(interval);\n\n            Dispatcher.Invoke(() => HasImpreciseCapture = false);\n        }\n    }"
            }
        ],
        "third_party": [
            "FrameRate.Start",
            "GarbageTimer.Start"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "private void CaptureWithCursor(int interval)",
        "start_line": "185",
        "end_line": "211",
        "file_path": "ScreenToGif/Controls/BaseScreenRecorder.cs",
        "docstring": "The private function CaptureWithCursor(int interval) continuously captures frames with the cursor at a specified interval.\\nIt uses a stopwatch to measure elapsed time and runs in a loop until the capture token is cancelled.\\nWithin the loop, it restarts the stopwatch, creates a new frame with cursor data, clears the key list, captures the frame, and updates the frame count.\\nIf the elapsed time is less than the interval, it waits by sleeping in 1-millisecond increments until the interval is reached.\\nFinally, it stops the stopwatch when the loop exits.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8f8be335465f",
        "ground_truth": "private void CaptureWithCursor(int interval)\n{\n    var sw = new Stopwatch();\n    while (_captureToken != null && !_captureToken.IsCancellationRequested)\n    {\n        sw.Restart();\n        //Capture frame.\n        var frame = new FrameInfo(RecordClicked, KeyList);\n        KeyList.Clear();\n        var frameCount = Capture.CaptureWithCursor(frame);\n        Dispatcher.Invoke(() => FrameCount = frameCount);\n        //If behind wait time, wait before capturing new frame.\n        if (sw.ElapsedMilliseconds >= interval)\n            continue;\n        while (sw.Elapsed.TotalMilliseconds < interval)\n            Thread.Sleep(1);\n        //SpinWait.SpinUntil(() => sw.ElapsedMilliseconds >= interval);\n    }\n    sw.Stop();\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Diagnostics",
            "using System.Threading",
            "using System.Threading.Tasks",
            "using ScreenToGif.Capture",
            "using ScreenToGif.Domain.Enums",
            "using ScreenToGif.Domain.Interfaces",
            "using ScreenToGif.Model",
            "using ScreenToGif.Native.Helpers",
            "using ScreenToGif.Util",
            "using ScreenToGif.Util.Settings"
        ],
        "reference_api": [
            "Thread.Sleep",
            "KeyList.Clear",
            "Dispatcher.Invoke",
            "sw.Restart",
            "sw.Stop",
            "Capture.CaptureWithCursor"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Thread.Sleep",
            "KeyList.Clear",
            "Dispatcher.Invoke",
            "sw.Restart",
            "sw.Stop",
            "Capture.CaptureWithCursor"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "protected override Size ArrangeOverride(Size arrangeSize)",
        "start_line": "198",
        "end_line": "224",
        "file_path": "ScreenToGif/Controls/DataGridHeaderBorder.cs",
        "docstring": "The protected override function ArrangeOverride(Size arrangeSize) arranges the layout of a control.\\nIf UsingBorderImplementation is true, it calls the base class's ArrangeOverride method.\\nIf not, it retrieves the child element and uses the Padding property if set, or a default padding otherwise.\\nIt calculates the child's width and height by subtracting the padding from the arrangeSize dimensions.\\nThe child is then arranged within the available space, considering the padding.\\nFinally, the function returns the arrangeSize.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8ad9c7b2a317",
        "ground_truth": "protected override Size ArrangeOverride(Size arrangeSize)\n{\n    if (UsingBorderImplementation)\n    {\n        // Revert to the Border implementation\n        return base.ArrangeOverride(arrangeSize);\n    }\n    var child = Child;\n    if (child != null)\n    {\n        // Use the public Padding property if it's set\n        var padding = Padding;\n        if (padding.Equals(new Thickness()))\n        {\n            padding = DefaultPadding;\n        }\n        // Reserve space for the chrome\n        var childWidth = Math.Max(0.0, arrangeSize.Width - padding.Left - padding.Right);\n        var childHeight = Math.Max(0.0, arrangeSize.Height - padding.Top - padding.Bottom);\n        child.Arrange(new Rect(padding.Left, padding.Top, childWidth, childHeight));\n    }\n    return arrangeSize;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Diagnostics",
            "using System.Windows",
            "using System.Windows.Controls",
            "using System.Windows.Media"
        ],
        "reference_api": [
            "Math.Max",
            "padding.Equals",
            "base.ArrangeOverride",
            "child.Arrange"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Math.Max",
            "padding.Equals",
            "base.ArrangeOverride",
            "child.Arrange"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "protected override void OnLostFocus(RoutedEventArgs e)",
        "start_line": "294",
        "end_line": "316",
        "file_path": "ScreenToGif/Controls/DecimalBox.cs",
        "docstring": "The protected override function OnLostFocus(RoutedEventArgs e) handles the event when the control loses focus.\\nIt first calls the base class method for losing focus.\\nIf the UpdateOnInput flag is not set, it checks if the text is either empty or not allowed.\\nIf so, it sets the value to a default value and returns.\\nOtherwise, it temporarily ignores changes, converts the text to a decimal value, updates the text format, and stops ignoring changes.\\nIf UpdateOnInput is set, it updates the text format based on the current value.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "719b23bc4229",
        "ground_truth": "protected override void OnLostFocus(RoutedEventArgs e)\n{\n    base.OnLostFocus(e);\n    if (!UpdateOnInput)\n    {\n        if (string.IsNullOrEmpty(Text) || !IsTextAllowed(Text))\n        {\n            Value = DefaultValueIfEmpty;\n            return;\n        }\n        _ignore = true;\n        Value = Convert.ToDecimal(Text, CultureInfo.CurrentCulture);\n        Text = EmptyIfValue == Value ? \"\" : string.Format(CultureInfo.CurrentCulture, _format, Value);\n        _ignore = false;\n        return;\n    }\n    Text = Value == EmptyIfValue ? \"\" : string.Format(CultureInfo.CurrentCulture, _format, Value);\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Globalization",
            "using System.Linq",
            "using System.Text.RegularExpressions",
            "using System.Windows",
            "using System.Windows.Controls",
            "using System.Windows.Input"
        ],
        "reference_api": [
            "Convert.ToDecimal",
            "string.Format",
            "base.OnLostFocus",
            "string.IsNullOrEmpty",
            "IsTextAllowed"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "IsTextAllowed",
                "code": "private bool IsTextAllowed(string text)\n    {\n        return decimal.TryParse(text, out decimal _);\n\n        //var regex = new Regex(@\"^((\\d+)|(\\d{1,3}(\\.\\d{3})+)|(\\d{1,3}(\\.\\d{3})(\\,\\d{3})+))((\\,\\d{4})|(\\,\\d{3})|(\\,\\d{2})|(\\,\\d{1})|(\\,))?$\", RegexOptions.CultureInvariant);\n        //return regex.IsMatch(text);\n    }"
            }
        ],
        "third_party": [
            "Convert.ToDecimal",
            "string.Format",
            "base.OnLostFocus",
            "string.IsNullOrEmpty"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "protected override void OnKeyDown(KeyEventArgs e)",
        "start_line": "318",
        "end_line": "327",
        "file_path": "ScreenToGif/Controls/DecimalBox.cs",
        "docstring": "The protected override function OnKeyDown(KeyEventArgs e) handles key press events.\\nIf the Enter or Return key is pressed, it marks the event as handled and moves the focus to the next focusable element.\\nFinally, it calls the base class's OnKeyDown method to ensure standard key handling behavior.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4bdfdcf8e5ea",
        "ground_truth": "protected override void OnKeyDown(KeyEventArgs e)\n{\n    if (e.Key == Key.Enter || e.Key == Key.Return)\n    {\n        e.Handled = true;\n        MoveFocus(new TraversalRequest(FocusNavigationDirection.Next));\n    }\n    base.OnKeyDown(e);\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Globalization",
            "using System.Linq",
            "using System.Text.RegularExpressions",
            "using System.Windows",
            "using System.Windows.Controls",
            "using System.Windows.Input"
        ],
        "reference_api": [
            "base.OnKeyDown",
            "MoveFocus"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "base.OnKeyDown",
            "MoveFocus"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "protected override void OnMouseMove(MouseEventArgs e)",
        "start_line": "262",
        "end_line": "284",
        "file_path": "ScreenToGif/Controls/DrawingCanvas.cs",
        "docstring": "The protected override function OnMouseMove(MouseEventArgs e) handles mouse movement events during drawing operations.\\nIt checks if the mouse is captured and the left button is pressed.\\nIf in selection mode and no shapes are selected or the Control key is pressed, it updates the selection rectangle based on the mouse coordinates.\\nIf in shape drawing mode, it calculates and updates the render region and shape orientation based on the mouse coordinates, then renders the shape.\\nFinally, it calls the base class's OnMouseMove method.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e9d822d22392",
        "ground_truth": "protected override void OnMouseMove(MouseEventArgs e)\n{\n    if (!IsMouseCaptured || e.LeftButton != MouseButtonState.Pressed)\n        return;\n    if (DrawingMode == DrawingModes.Select && ((_selectedShapes?.Count ?? 0) == 0 || (Keyboard.Modifiers & ModifierKeys.Control) != 0))\n    {\n        var current = GetBoundedCoordinates(e);\n        Selection = new Rect(Math.Min(current.X, _startPoint.X), Math.Min(current.Y, _startPoint.Y), Math.Abs(current.X - _startPoint.X), Math.Abs(current.Y - _startPoint.Y));\n    }\n    else if (DrawingMode == DrawingModes.Shape)\n    {\n        var current = GetBoundedCoordinates(e);\n        RenderRegion = Rect.Inflate(new Rect(Math.Min(current.X, _startPoint.X), Math.Min(current.Y, _startPoint.Y), Math.Abs(current.X - _startPoint.X), Math.Abs(current.Y - _startPoint.Y)), -0.6d, -0.6d);\n        CalculateOrientation(_startPoint, current);\n        RenderShape();\n    }\n    base.OnMouseMove(e);\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.ComponentModel",
            "using System.Linq",
            "using System.Windows",
            "using System.Windows.Controls",
            "using System.Windows.Documents",
            "using System.Windows.Ink",
            "using System.Windows.Input",
            "using System.Windows.Media",
            "using System.Windows.Shapes",
            "using ScreenToGif.Controls.Shapes",
            "using ScreenToGif.Domain.Events"
        ],
        "reference_api": [
            "GetBoundedCoordinates",
            "Math.Abs",
            "base.OnMouseMove",
            "Rect.Inflate",
            "Math.Min",
            "RenderShape",
            "CalculateOrientation"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetBoundedCoordinates",
                "code": "private Point GetBoundedCoordinates(MouseEventArgs e)\n    {\n        var current = e.GetPosition(this);\n\n        if (current.X < -1)\n            current.X = -1;\n\n        if (current.Y < -1)\n            current.Y = -1;\n\n        if (current.X > ActualWidth)\n            current.X = ActualWidth;\n\n        if (current.Y > ActualHeight)\n            current.Y = ActualHeight;\n\n        return current;\n    }"
            },
            {
                "name": "RenderShape",
                "code": "private void RenderShape()\n    {\n        if (RenderRegion.IsEmpty)\n        {\n            if (_currentShape != null)\n                _mainCanvas.Children.Remove(_currentShape);\n\n            return;\n        }\n\n        if (_currentShape != null)\n        {\n            Canvas.SetTop(_currentShape, RenderRegion.Top);\n            Canvas.SetLeft(_currentShape, RenderRegion.Left);\n            _currentShape.Width = RenderRegion.Width;\n            _currentShape.Height = RenderRegion.Height;\n\n            if (_currentShape is Arrow arrow)\n            {\n                arrow.X1 = RenderRegion.Left - _mostDistantPoint.X;\n                arrow.X2 = RenderRegion.Left - Math.Abs(_isRightToLeft ? _mostDistantPoint.X - _currentPoint.X : _currentPoint.X - _mostDistantPoint.X);\n                arrow.Y1 = RenderRegion.Top - _mostDistantPoint.Y;\n                arrow.Y2 = RenderRegion.Top - Math.Abs(_mostDistantPoint.Y - _currentPoint.Y);\n            }\n            return;\n        }\n\n        switch (CurrentShape)\n        {\n            case Shapes.Rectangle:\n                _currentShape = new Rectangle\n                {\n                    Width = RenderRegion.Width,\n                    Height = RenderRegion.Height,\n                    Stroke = Stroke,\n                    StrokeThickness = StrokeThickness,\n                    StrokeDashArray = StrokeDashArray,\n                    Fill = Fill,\n                    RadiusX = Radius,\n                    RadiusY = Radius\n                };\n                break;\n            case Shapes.Ellipse:\n                _currentShape = new Ellipse\n                {\n                    Width = RenderRegion.Width,\n                    Height = RenderRegion.Height,\n                    Stroke = Stroke,\n                    StrokeThickness = StrokeThickness,\n                    StrokeDashArray = StrokeDashArray,\n                    Fill = Fill,\n                };\n                break;\n            case Shapes.Triangle:\n                _currentShape = new Triangle\n                {\n                    Width = RenderRegion.Width,\n                    Height = RenderRegion.Height,\n                    Stroke = Stroke,\n                    StrokeThickness = StrokeThickness,\n                    StrokeDashArray = StrokeDashArray,\n                    Fill = Fill,\n                    //RadiusX = Radius,\n                    //RadiusY = Radius\n                };\n                break;\n            case Shapes.Arrow:\n                _currentShape = new Arrow\n                {\n                    Width = RenderRegion.Width,\n                    Height = RenderRegion.Height,\n                    Stroke = Stroke,\n                    StrokeThickness = StrokeThickness,\n                    StrokeDashArray = StrokeDashArray,\n                    Fill = Fill,\n                    Stretch = Stretch.Fill,\n                    HeadHeight = 10,\n                    HeadWidth = 10,\n                    X1 = RenderRegion.Left - _mostDistantPoint.X,\n                    X2 = RenderRegion.Left - Math.Abs(_isRightToLeft ? _mostDistantPoint.X - _currentPoint.X : _currentPoint.X - _mostDistantPoint.X),\n                    Y1 = RenderRegion.Top - _mostDistantPoint.Y,\n                    Y2 = RenderRegion.Top - Math.Abs(_mostDistantPoint.Y - _currentPoint.Y)\n                };\n                break;\n        }\n\n        if (_currentShape == null)\n            return;\n\n        _mainCanvas.Children.Add(_currentShape);\n\n        Canvas.SetLeft(_currentShape, RenderRegion.Left);\n        Canvas.SetTop(_currentShape, RenderRegion.Top);\n        Panel.SetZIndex(_currentShape, _mainCanvas.Children.OfType<Shape>().Where(w => w.Tag == null).Max(Panel.GetZIndex) + 1);\n    }"
            },
            {
                "name": "CalculateOrientation",
                "code": "private void CalculateOrientation(Point start, Point current)\n    {\n        _isBottomToTop = start.Y < current.Y;\n        _isRightToLeft = start.X < current.X;\n        _mostDistantPoint = start;\n        _currentPoint = current;\n    }"
            }
        ],
        "third_party": [
            "base.OnMouseMove",
            "Rect.Inflate",
            "Math.Min"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "NickeManarin/ScreenToGif",
        "function_declaration": "private void HandleBottomRight(object sender, DragDeltaEventArgs e)",
        "start_line": "557",
        "end_line": "581",
        "file_path": "ScreenToGif/Controls/ElementAdorner.cs",
        "docstring": "The private function HandleBottomRight(object sender, DragDeltaEventArgs e) handles resizing an adorned element when the bottom-right thumb is dragged.\\nIt first checks if the sender is a Thumb and sets the event as handled.\\nIt calculates the new width and height based on the drag amount, ensuring minimum dimensions of 10 units.\\nIt adjusts the width and height to not exceed the parent's dimensions.\\nIt raises a manipulation event with the change in dimensions.\\nFinally, it updates the adorned element's size and calls AfterManipulation() to finalize the resize.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b853f670928a",
        "ground_truth": "private void HandleBottomRight(object sender, DragDeltaEventArgs e)\n{\n    if (!(sender is Thumb)) return;\n    e.Handled = true;\n    //Change the size by the amount the user drags the cursor.\n    var width = Math.Max(_adornedElement.DesiredSize.Width + e.HorizontalChange, 10);\n    var height = Math.Max(_adornedElement.DesiredSize.Height + e.VerticalChange, 10);\n    var top = Canvas.GetTop(_adornedElement);\n    var left = Canvas.GetLeft(_adornedElement);\n    if (left + width > _parent.ActualWidth)\n        width = _parent.ActualWidth - left;\n    if (top + height > _parent.ActualHeight)\n        height = _parent.ActualHeight - top;\n    RaiseManipulatedEvent(width - _adornedElement.Width, height - _adornedElement.Height);\n    _adornedElement.Height = height;\n    _adornedElement.Width = width;\n    AfterManipulation();\n}",
        "import_statements": [
            "using System",
            "using System.Windows",
            "using System.Windows.Controls",
            "using System.Windows.Controls.Primitives",
            "using System.Windows.Documents",
            "using System.Windows.Input",
            "using System.Windows.Media",
            "using System.Windows.Shapes",
            "using ScreenToGif.Domain.Events"
        ],
        "reference_api": [
            "RaiseManipulatedEvent",
            "AfterManipulation",
            "Math.Max",
            "Canvas.GetLeft",
            "Canvas.GetTop"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RaiseManipulatedEvent",
                "code": "void RaiseManipulatedEvent(double angleDiff)\n    {\n        if (ManipulatedEvent == null)\n            return;\n\n        RaiseEvent(new ManipulatedEventArgs(ManipulatedEvent, angleDiff, 0, 0, 0, 0));\n    }"
            },
            {
                "name": "AfterManipulation",
                "code": "private void AfterManipulation()\n    {\n        InvalidateVisual();\n        UpdateLayout();\n    }"
            }
        ],
        "third_party": [
            "Math.Max",
            "Canvas.GetLeft",
            "Canvas.GetTop"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "MaterialDesignInXAML/MaterialDesignInXamlToolkit",
        "function_declaration": "public ComboBoxesViewModel()",
        "start_line": "12",
        "end_line": "31",
        "file_path": "src/MainDemo.Wpf/Domain/ComboBoxesViewModel.cs",
        "docstring": "The public constructor ComboBoxesViewModel() initializes the view model for combo boxes.\\nIt creates a list of integers ranging from 0 to 999 and a short list of string items.\\nIt sets the selected value from the integer list and initializes the selected text to null.\\nIt also creates a long list of random string values by generating random file names in a loop running 1000 times.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4f79040b5f53",
        "ground_truth": "public ComboBoxesViewModel()\n{\n    LongIntegerList = new List<int>(Enumerable.Range(0, 1000));\n    ShortStringList = new[]\n    {\n        \"Item 1\",\n        \"Item 2\",\n        \"Item 3\"\n    };\n    SelectedValueOne = LongIntegerList.Skip(2).First();\n    SelectedTextTwo = null;\n    LongStringList = new List<string>();\n    for (int i = 0; i < 1000; i++)\n    {\n        LongStringList.Add(Path.GetRandomFileName());\n    }\n}",
        "import_statements": [
            "using  MaterialDesignDemo.Shared.Domain"
        ],
        "reference_api": [
            "LongStringList.Add",
            "LongIntegerList.Skip",
            "Enumerable.Range",
            "LongIntegerList.Skip(2).First",
            "Path.GetRandomFileName"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "LongStringList.Add",
            "LongIntegerList.Skip",
            "Enumerable.Range",
            "LongIntegerList.Skip(2).First",
            "Path.GetRandomFileName"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "MaterialDesignInXAML/MaterialDesignInXamlToolkit",
        "function_declaration": "private async Task RunDialog() ",
        "start_line": "13",
        "end_line": "26",
        "file_path": "src/MainDemo.Wpf/Domain/DialogsViewModel.cs",
        "docstring": "The private async function RunDialog() sets up and runs a dialog using the MVVM pattern.\\nIt creates a SampleDialog view and assigns it a SampleDialogViewModel as its data context.\\nIt then shows the dialog using DialogHost.Show, specifying \"RootDialog\" as the host identifier and attaching event handlers for closing and closed events.\\nAfter the dialog is closed, it logs the result, displaying the CommandParameter used to close the dialog.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ca40ae89e1a2",
        "ground_truth": "private async Task RunDialog() \n{\n    //let's set up a little MVVM, cos that's what the cool kids are doing:\n    object? view = new SampleDialog\n    {\n        DataContext = new SampleDialogViewModel()\n    };\n    //show the dialog\n    object? result = await DialogHost.Show(view, \"RootDialog\", null, ClosingEventHandler, ClosedEventHandler);\n    //check the result...\n    Debug.WriteLine(\"Dialog was closed, the CommandParameter used to close it was: \" + (result ?? \"NULL\"));\n}",
        "import_statements": [
            "using System.Diagnostics",
            "using CommunityToolkit.Mvvm.ComponentModel",
            "using CommunityToolkit.Mvvm.Input",
            "using MaterialDesignThemes.Wpf"
        ],
        "reference_api": [
            "Debug.WriteLine",
            "DialogHost.Show"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Debug.WriteLine",
            "DialogHost.Show"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "MaterialDesignInXAML/MaterialDesignInXamlToolkit",
        "function_declaration": "private static void ModifyTheme(Action<Theme> modificationAction)",
        "start_line": "31",
        "end_line": "39",
        "file_path": "src/MainDemo.Wpf/Domain/PaletteSelectorViewModel.cs",
        "docstring": "The private static function ModifyTheme(Action<Theme> modificationAction) modifies the current theme using a provided action.\\nIt creates a PaletteHelper instance to access the current theme.\\nIt then invokes the modification action on the theme if it is not null.\\nFinally, it sets the modified theme back using the PaletteHelper.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d82f32ed6e43",
        "ground_truth": "private static void ModifyTheme(Action<Theme> modificationAction)\n{\n    var paletteHelper = new PaletteHelper();\n    Theme theme = paletteHelper.GetTheme();\n    modificationAction?.Invoke(theme);\n    paletteHelper.SetTheme(theme);\n}",
        "import_statements": [
            "using MaterialDesignColors",
            "using MaterialDesignDemo.Shared.Domain",
            "using MaterialDesignThemes.Wpf"
        ],
        "reference_api": [
            "paletteHelper.GetTheme",
            "paletteHelper.SetTheme",
            "modificationAction?.Invoke"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "paletteHelper.GetTheme",
            "paletteHelper.SetTheme",
            "modificationAction?.Invoke"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "MaterialDesignInXAML/MaterialDesignInXamlToolkit",
        "function_declaration": "private object? CreateContent()",
        "start_line": "64",
        "end_line": "73",
        "file_path": "src/MaterialDesign3.Demo.Wpf/Domain/DemoItem.cs",
        "docstring": "The private function CreateContent() creates an instance of a specified content type using Activator.CreateInstance.\\nIf a data context is provided and the created content is a FrameworkElement, it sets the element's DataContext to the provided data context.\\nThe function then returns the created content.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8cf8182d763e",
        "ground_truth": "private object? CreateContent()\n{\n    var content = Activator.CreateInstance(_contentType);\n    if (_dataContext != null && content is FrameworkElement element)\n    {\n        element.DataContext = _dataContext;\n    }\n    return content;\n}",
        "import_statements": [
            "using MaterialDesignThemes.Wpf"
        ],
        "reference_api": [
            "Activator.CreateInstance"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Activator.CreateInstance"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "MaterialDesignInXAML/MaterialDesignInXamlToolkit",
        "function_declaration": "private void AcceptSample4Dialog(object? _)",
        "start_line": "108",
        "end_line": "115",
        "file_path": "src/MaterialDesign3.Demo.Wpf/Domain/DialogsViewModel.cs",
        "docstring": "The private function AcceptSample4Dialog(object? _) simulates a sample dialog process.\\nIt initializes the Sample4Content with a new SampleProgressDialog.\\nIt then waits for 3 seconds before setting IsSample4DialogOpen to false, using the current synchronization context to ensure it runs on the UI thread.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "96cb26c3eacc",
        "ground_truth": "private void AcceptSample4Dialog(object? _)\n{\n    //pretend to do something for 3 seconds, then close\n    Sample4Content = new SampleProgressDialog();\n    Task.Delay(TimeSpan.FromSeconds(3))\n        .ContinueWith((t, _) => IsSample4DialogOpen = false, null,\n            TaskScheduler.FromCurrentSynchronizationContext());\n}",
        "import_statements": [
            "using System.Diagnostics",
            "using MaterialDesignThemes.Wpf"
        ],
        "reference_api": [
            "Task.Delay",
            "TimeSpan.FromSeconds",
            "Task.Delay(TimeSpan.FromSeconds(3))\n            .ContinueWith",
            "TaskScheduler.FromCurrentSynchronizationContext"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Task.Delay",
            "TimeSpan.FromSeconds",
            "Task.Delay(TimeSpan.FromSeconds(3))\n            .ContinueWith",
            "TaskScheduler.FromCurrentSynchronizationContext"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "File-New-Project/EarTrumpet",
        "function_declaration": "private void OnDeviceAddOrRemove(IAudioDevice device, AudioDeviceEventKind option)",
        "start_line": "93",
        "end_line": "106",
        "file_path": "EarTrumpet/Addons/EarTrumpet.Actions/DataModel/Processing/AudioTriggerManager.cs",
        "docstring": "The private function OnDeviceAddOrRemove(IAudioDevice device, AudioDeviceEventKind option) handles audio device events.\\nIt iterates through the _deviceTriggers collection and checks if the trigger option matches the given event option.\\nIf a trigger's device ID matches the given device ID, it invokes the Triggered event for that trigger.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7afa49e4a449",
        "ground_truth": "private void OnDeviceAddOrRemove(IAudioDevice device, AudioDeviceEventKind option)\n{\n    foreach (var trigger in _deviceTriggers)\n    {\n        if (trigger.Option == option)\n        {\n            // Default device: not supported\n            if (trigger.Device.Id == device.Id)\n            {\n                Triggered?.Invoke(trigger);\n            }\n        }\n    }\n}",
        "import_statements": [
            "using EarTrumpet.Actions.DataModel.Enum",
            "using EarTrumpet.Actions.DataModel.Serialization",
            "using System",
            "using System.Collections.Generic",
            "using EarTrumpet.DataModel.Audio",
            "using EarTrumpet.DataModel.WindowsAudio",
            "using EarTrumpet.Extensibility.Shared"
        ],
        "reference_api": [
            "Triggered?.Invoke"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Triggered?.Invoke"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "File-New-Project/EarTrumpet",
        "function_declaration": "private void LoadAndRegister()",
        "start_line": "91",
        "end_line": "96",
        "file_path": "EarTrumpet/Addons/EarTrumpet.Actions/EarTrumpetActionsAddon.cs",
        "docstring": "The private function LoadAndRegister() loads actions from settings and registers their triggers.\\nIt first clears the trigger manager.\\nThen, it retrieves the actions from settings using a specified key.\\nFinally, it registers each trigger from the loaded actions with the trigger manager.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "50c38fc69dac",
        "ground_truth": "private void LoadAndRegister()\n{\n    _triggerManager.Clear();\n    _actions = Settings.Get(c_actionsSettingKey, new EarTrumpetAction[] { });\n    _actions.SelectMany(a => a.Triggers).ToList().ForEach(t => _triggerManager.Register(t));\n}",
        "import_statements": [
            "using EarTrumpet.Actions.DataModel",
            "using EarTrumpet.Actions.DataModel.Processing",
            "using EarTrumpet.Actions.DataModel.Serialization",
            "using EarTrumpet.Actions.ViewModel",
            "using EarTrumpet.DataModel.Storage",
            "using EarTrumpet.Extensibility",
            "using EarTrumpet.UI.Helpers",
            "using EarTrumpet.UI.ViewModels",
            "using System",
            "using System.Collections.Generic",
            "using System.ComponentModel.Composition",
            "using System.IO",
            "using System.Linq"
        ],
        "reference_api": [
            "_triggerManager.Register",
            "_actions.SelectMany",
            "_triggerManager.Clear",
            "_actions.SelectMany(a => a.Triggers).ToList().ForEach",
            "Settings.Get",
            "_actions.SelectMany(a => a.Triggers).ToList"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_triggerManager.Register",
            "_actions.SelectMany",
            "_triggerManager.Clear",
            "_actions.SelectMany(a => a.Triggers).ToList().ForEach",
            "Settings.Get",
            "_actions.SelectMany(a => a.Triggers).ToList"
        ]
    },
    {
        "subclass": "WPF",
        "owner/repo": "File-New-Project/EarTrumpet",
        "function_declaration": "private void OnTriggered(BaseTrigger trigger)",
        "start_line": "114",
        "end_line": "121",
        "file_path": "EarTrumpet/Addons/EarTrumpet.Actions/EarTrumpetActionsAddon.cs",
        "docstring": "The private function OnTriggered(BaseTrigger trigger) handles the activation of a trigger.\\nIt searches for an action whose triggers include the given trigger.\\nIf an action is found and all its conditions are met, it executes the action by calling TriggerAction.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ab8051e72909",
        "ground_truth": "private void OnTriggered(BaseTrigger trigger)\n{\n    var action = Actions.FirstOrDefault(a => a.Triggers.Contains(trigger));\n    if (action != null && action.Conditions.All(c => ConditionProcessor.IsMet(c)))\n    {\n        TriggerAction(action);\n    }\n}",
        "import_statements": [
            "using EarTrumpet.Actions.DataModel",
            "using EarTrumpet.Actions.DataModel.Processing",
            "using EarTrumpet.Actions.DataModel.Serialization",
            "using EarTrumpet.Actions.ViewModel",
            "using EarTrumpet.DataModel.Storage",
            "using EarTrumpet.Extensibility",
            "using EarTrumpet.UI.Helpers",
            "using EarTrumpet.UI.ViewModels",
            "using System",
            "using System.Collections.Generic",
            "using System.ComponentModel.Composition",
            "using System.IO",
            "using System.Linq"
        ],
        "reference_api": [
            "a.Triggers.Contains",
            "TriggerAction",
            "action.Conditions.All",
            "ConditionProcessor.IsMet",
            "Actions.FirstOrDefault"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "TriggerAction",
                "code": "public void TriggerAction(EarTrumpetAction action)\r\n        {\r\n            action.Actions.ToList().ForEach(a => ActionProcessor.Invoke(a));\r\n        }"
            }
        ],
        "third_party": [
            "a.Triggers.Contains",
            "action.Conditions.All",
            "ConditionProcessor.IsMet",
            "Actions.FirstOrDefault"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "fn apply_run_while_expressions_mentioning(&mut self, name: &VarName)",
        "start_line": "317",
        "end_line": "337",
        "file_path": "crates/eww/src/app.rs",
        "docstring": "The function apply_run_while_expressions_mentioning(&mut self, name: &VarName) processes run-while expressions related to a given variable name.\\nIt retrieves variables mentioning the specified name and filters them to obtain script variables.\\nFor each script variable that is a poll variable, it evaluates its run-while expression in the scope graph.\\nIf the expression evaluates to true, it adds the variable to the script handler.\\nIf false, it stops the variable.\\nAny errors encountered during evaluation are printed using the error handling context.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2f85d28001cf",
        "ground_truth": "fn apply_run_while_expressions_mentioning(&mut self, name: &VarName) {\n    let mentioning_vars = match self.eww_config.get_run_while_mentions_of(name) {\n        Some(x) => x,\n        None => return,\n    };\n    let mentioning_vars = mentioning_vars.iter().filter_map(|name| self.eww_config.get_script_var(name).ok());\n    for var in mentioning_vars {\n        if let ScriptVarDefinition::Poll(poll_var) = var {\n            let scope_graph = self.scope_graph.borrow();\n            let run_while_result = scope_graph\n                .evaluate_simplexpr_in_scope(scope_graph.root_index, &poll_var.run_while_expr)\n                .map(|v| v.as_bool());\n            match run_while_result {\n                Ok(Ok(true)) => self.script_var_handler.add(var.clone()),\n                Ok(Ok(false)) => self.script_var_handler.stop_for_variable(poll_var.name.clone()),\n                Ok(Err(err)) => error_handling_ctx::print_error(anyhow!(err)),\n                Err(err) => error_handling_ctx::print_error(anyhow!(err)),\n            };\n        }\n    }\n}",
        "import_statements": [
            "use crate::{\n    config,\n    daemon_response::DaemonResponseSender,\n    display_backend::DisplayBackend,\n    error_handling_ctx,\n    gtk::prelude::{ContainerExt, CssProviderExt, GtkWindowExt, MonitorExt, StyleContextExt, WidgetExt},\n    paths::EwwPaths,\n    script_var_handler::ScriptVarHandlerHandle,\n    state::scope_graph::{ScopeGraph, ScopeIndex},\n    widgets::window::Window,\n    window_arguments::WindowArguments,\n    window_initiator::WindowInitiator,\n    *,\n};",
            "*",
            "*",
            "*",
            "*",
            "use anyhow::anyhow;",
            "use codespan_reporting::files::Files;",
            "use eww_shared_util::{Span, VarName};",
            "use gdk::Monitor;",
            "use glib::ObjectExt;",
            "use itertools::Itertools;",
            "use once_cell::sync::Lazy;",
            "use simplexpr::{dynval::DynVal, SimplExpr};",
            "use std::{\n    cell::RefCell,\n    collections::{HashMap, HashSet},\n    rc::Rc,\n};",
            "use tokio::sync::mpsc::UnboundedSender;",
            "use yuck::{\n    config::{\n        monitor::MonitorIdentifier,\n        script_var_definition::ScriptVarDefinition,\n        window_geometry::{AnchorPoint, WindowGeometry},\n    },\n    error::DiagError,\n    gen_diagnostic,\n    value::Coords,\n};"
        ],
        "reference_api": [
            "self.script_var_handler.stop_for_variable",
            "var.clone",
            "poll_var.name.clone",
            "self.eww_config.get_run_while_mentions_of",
            "mentioning_vars.iter().filter_map",
            "scope_graph\n                    .evaluate_simplexpr_in_scope",
            "scope_graph\n                    .evaluate_simplexpr_in_scope(scope_graph.root_index, &poll_var.run_while_expr)\n                    .map",
            "self.script_var_handler.add",
            "self.scope_graph.borrow",
            "self.eww_config.get_script_var",
            "mentioning_vars.iter",
            "v.as_bool",
            "error_handling_ctx::print_error",
            "self.eww_config.get_script_var(name).ok"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.script_var_handler.stop_for_variable",
            "var.clone",
            "poll_var.name.clone",
            "self.eww_config.get_run_while_mentions_of",
            "mentioning_vars.iter().filter_map",
            "scope_graph\n                    .evaluate_simplexpr_in_scope",
            "scope_graph\n                    .evaluate_simplexpr_in_scope(scope_graph.root_index, &poll_var.run_while_expr)\n                    .map",
            "self.script_var_handler.add",
            "self.scope_graph.borrow",
            "self.eww_config.get_script_var",
            "mentioning_vars.iter",
            "v.as_bool",
            "error_handling_ctx::print_error",
            "self.eww_config.get_script_var(name).ok"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "fn close_window(&mut self, instance_id: &str) -> Result<()> ",
        "start_line": "340",
        "end_line": "363",
        "file_path": "crates/eww/src/app.rs",
        "docstring": "The function close_window(&mut self, instance_id: &str) -> Result<()> closes a window identified by the given instance ID.\\nIt removes and aborts any existing close timer for the window.\\nIt retrieves and closes the window, then removes its associated scope from the scope graph.\\nThe function identifies and stops any unused global variables.\\nFinally, it removes the instance ID from the arguments map and returns a successful result.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "56f67ae91214",
        "ground_truth": "fn close_window(&mut self, instance_id: &str) -> Result<()> {\n    if let Some(old_abort_send) = self.window_close_timer_abort_senders.remove(instance_id) {\n        _ = old_abort_send.send(());\n    }\n    let eww_window = self\n        .open_windows\n        .remove(instance_id)\n        .with_context(|| format!(\"Tried to close window with id '{instance_id}', but no such window was open\"))?;\n    let scope_index = eww_window.scope_index;\n    eww_window.close();\n    self.scope_graph.borrow_mut().remove_scope(scope_index);\n    let unused_variables = self.scope_graph.borrow().currently_unused_globals();\n    for unused_var in unused_variables {\n        log::debug!(\"stopping script-var {}\", &unused_var);\n        self.script_var_handler.stop_for_variable(unused_var.clone());\n    }\n    self.instance_id_to_args.remove(instance_id);\n    Ok(())\n}",
        "import_statements": [
            "use crate::{\n    config,\n    daemon_response::DaemonResponseSender,\n    display_backend::DisplayBackend,\n    error_handling_ctx,\n    gtk::prelude::{ContainerExt, CssProviderExt, GtkWindowExt, MonitorExt, StyleContextExt, WidgetExt},\n    paths::EwwPaths,\n    script_var_handler::ScriptVarHandlerHandle,\n    state::scope_graph::{ScopeGraph, ScopeIndex},\n    widgets::window::Window,\n    window_arguments::WindowArguments,\n    window_initiator::WindowInitiator,\n    *,\n};",
            "*",
            "*",
            "*",
            "*",
            "use anyhow::anyhow;",
            "use codespan_reporting::files::Files;",
            "use eww_shared_util::{Span, VarName};",
            "use gdk::Monitor;",
            "use glib::ObjectExt;",
            "use itertools::Itertools;",
            "use once_cell::sync::Lazy;",
            "use simplexpr::{dynval::DynVal, SimplExpr};",
            "use std::{\n    cell::RefCell,\n    collections::{HashMap, HashSet},\n    rc::Rc,\n};",
            "use tokio::sync::mpsc::UnboundedSender;",
            "use yuck::{\n    config::{\n        monitor::MonitorIdentifier,\n        script_var_definition::ScriptVarDefinition,\n        window_geometry::{AnchorPoint, WindowGeometry},\n    },\n    error::DiagError,\n    gen_diagnostic,\n    value::Coords,\n};"
        ],
        "reference_api": [
            "self.script_var_handler.stop_for_variable",
            "self.scope_graph.borrow().currently_unused_globals",
            "Ok",
            "self\n            .open_windows\n            .remove(instance_id)\n            .with_context",
            "self\n            .open_windows\n            .remove",
            "eww_window.close",
            "self.scope_graph.borrow_mut().remove_scope",
            "self.scope_graph.borrow",
            "self.scope_graph.borrow_mut",
            "self.instance_id_to_args.remove",
            "self.window_close_timer_abort_senders.remove",
            "unused_var.clone",
            "old_abort_send.send"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.script_var_handler.stop_for_variable",
            "self.scope_graph.borrow().currently_unused_globals",
            "self\n            .open_windows\n            .remove(instance_id)\n            .with_context",
            "self\n            .open_windows\n            .remove",
            "eww_window.close",
            "self.scope_graph.borrow_mut().remove_scope",
            "self.scope_graph.borrow",
            "self.scope_graph.borrow_mut",
            "self.instance_id_to_args.remove",
            "self.window_close_timer_abort_senders.remove",
            "unused_var.clone",
            "old_abort_send.send"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "pub fn load_config(&mut self, config: config::EwwConfig) -> Result<()>",
        "start_line": "475",
        "end_line": "496",
        "file_path": "crates/eww/src/app.rs",
        "docstring": "The function load_config(&mut self, config: config::EwwConfig) -> Result<()> reloads the application's configuration.\\nIt starts by logging the reload process and stopping all script variable handlers.\\nIt replaces the old script variable handler with a new one and waits for the old handler to terminate.\\nThe function logs the new configuration, updates the eww_config, and clears the scope graph with the initial state from the new configuration.\\nIt gathers all open and failed window IDs, retrieves their initial arguments, and reopens each window with these arguments.\\nFinally, it returns a Result indicating success or failure.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a496c83ce944",
        "ground_truth": "pub fn load_config(&mut self, config: config::EwwConfig) -> Result<()> {\n    log::info!(\"Reloading windows\");\n    self.script_var_handler.stop_all();\n    let old_handler = std::mem::replace(&mut self.script_var_handler, script_var_handler::init(self.app_evt_send.clone()));\n    old_handler.join_thread();\n    log::trace!(\"loading config: {:#?}\", config);\n    self.eww_config = config;\n    self.scope_graph.borrow_mut().clear(self.eww_config.generate_initial_state()?);\n    let open_window_ids: Vec<String> =\n        self.open_windows.keys().cloned().chain(self.failed_windows.iter().cloned()).dedup().collect();\n    for instance_id in &open_window_ids {\n        let window_arguments = self.instance_id_to_args.get(instance_id).with_context(|| {\n            format!(\"Cannot reopen window, initial parameters were not saved correctly for {instance_id}\")\n        })?;\n        self.open_window(&window_arguments.clone())?;\n    }\n    Ok(())\n}",
        "import_statements": [
            "use crate::{\n    config,\n    daemon_response::DaemonResponseSender,\n    display_backend::DisplayBackend,\n    error_handling_ctx,\n    gtk::prelude::{ContainerExt, CssProviderExt, GtkWindowExt, MonitorExt, StyleContextExt, WidgetExt},\n    paths::EwwPaths,\n    script_var_handler::ScriptVarHandlerHandle,\n    state::scope_graph::{ScopeGraph, ScopeIndex},\n    widgets::window::Window,\n    window_arguments::WindowArguments,\n    window_initiator::WindowInitiator,\n    *,\n};",
            "*",
            "*",
            "*",
            "*",
            "use anyhow::anyhow;",
            "use codespan_reporting::files::Files;",
            "use eww_shared_util::{Span, VarName};",
            "use gdk::Monitor;",
            "use glib::ObjectExt;",
            "use itertools::Itertools;",
            "use once_cell::sync::Lazy;",
            "use simplexpr::{dynval::DynVal, SimplExpr};",
            "use std::{\n    cell::RefCell,\n    collections::{HashMap, HashSet},\n    rc::Rc,\n};",
            "use tokio::sync::mpsc::UnboundedSender;",
            "use yuck::{\n    config::{\n        monitor::MonitorIdentifier,\n        script_var_definition::ScriptVarDefinition,\n        window_geometry::{AnchorPoint, WindowGeometry},\n    },\n    error::DiagError,\n    gen_diagnostic,\n    value::Coords,\n};"
        ],
        "reference_api": [
            "self.open_windows.keys",
            "script_var_handler::init",
            "self.instance_id_to_args.get",
            "self.eww_config.generate_initial_state",
            "self.scope_graph.borrow_mut",
            "self.failed_windows.iter",
            "self.open_windows.keys().cloned",
            "self.open_windows.keys().cloned().chain",
            "self.script_var_handler.stop_all",
            "window_arguments.clone",
            "self.instance_id_to_args.get(instance_id).with_context",
            "self.open_windows.keys().cloned().chain(self.failed_windows.iter().cloned()).dedup().collect",
            "self.app_evt_send.clone",
            "Ok",
            "self.open_window",
            "self.scope_graph.borrow_mut().clear",
            "self.open_windows.keys().cloned().chain(self.failed_windows.iter().cloned()).dedup",
            "old_handler.join_thread",
            "self.failed_windows.iter().cloned",
            "std::mem::replace"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.open_windows.keys",
            "script_var_handler::init",
            "self.instance_id_to_args.get",
            "self.eww_config.generate_initial_state",
            "self.scope_graph.borrow_mut",
            "self.failed_windows.iter",
            "self.open_windows.keys().cloned",
            "self.open_windows.keys().cloned().chain",
            "self.script_var_handler.stop_all",
            "window_arguments.clone",
            "self.instance_id_to_args.get(instance_id).with_context",
            "self.open_windows.keys().cloned().chain(self.failed_windows.iter().cloned()).dedup().collect",
            "self.app_evt_send.clone",
            "self.open_window",
            "self.scope_graph.borrow_mut().clear",
            "self.open_windows.keys().cloned().chain(self.failed_windows.iter().cloned()).dedup",
            "old_handler.join_thread",
            "self.failed_windows.iter().cloned",
            "std::mem::replace"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "pub fn load_css(&mut self, file_id: usize, css: &str) -> Result<()>",
        "start_line": "499",
        "end_line": "518",
        "file_path": "crates/eww/src/app.rs",
        "docstring": "The function load_css(&mut self, file_id: usize, css: &str) -> Result<()> attempts to load CSS data.\\nIf loading fails, it processes the error message using a regex pattern to extract line and message details.\\nIt then tries to retrieve a file range from a database to create a diagnostic error with a specific span.\\nIf successful, it returns a detailed error; otherwise, it returns a generic CSS error message.\\nIf loading succeeds, it returns Ok.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "939eb758c6a2",
        "ground_truth": "pub fn load_css(&mut self, file_id: usize, css: &str) -> Result<()> {\n    if let Err(err) = self.css_provider.load_from_data(css.as_bytes()) {\n        static PATTERN: Lazy<regex::Regex> = Lazy::new(|| regex::Regex::new(r\"[^:]*:(\\d+):(\\d+)(.*)$\").unwrap());\n        let nice_error_option: Option<_> = (|| {\n            let captures = PATTERN.captures(err.message())?;\n            let line = captures.get(1).unwrap().as_str().parse::<usize>().ok()?;\n            let msg = captures.get(3).unwrap().as_str();\n            let db = error_handling_ctx::FILE_DATABASE.read().ok()?;\n            let line_range = db.line_range(file_id, line - 1).ok()?;\n            let span = Span(line_range.start, line_range.end - 1, file_id);\n            Some(DiagError(gen_diagnostic!(msg, span)))\n        })();\n        match nice_error_option {\n            Some(error) => Err(anyhow!(error)),\n            None => Err(anyhow!(\"CSS error: {}\", err.message())),\n        }\n    } else {\n        Ok(())\n    }\n}",
        "import_statements": [
            "use crate::{\n    config,\n    daemon_response::DaemonResponseSender,\n    display_backend::DisplayBackend,\n    error_handling_ctx,\n    gtk::prelude::{ContainerExt, CssProviderExt, GtkWindowExt, MonitorExt, StyleContextExt, WidgetExt},\n    paths::EwwPaths,\n    script_var_handler::ScriptVarHandlerHandle,\n    state::scope_graph::{ScopeGraph, ScopeIndex},\n    widgets::window::Window,\n    window_arguments::WindowArguments,\n    window_initiator::WindowInitiator,\n    *,\n};",
            "*",
            "*",
            "*",
            "*",
            "use anyhow::anyhow;",
            "use codespan_reporting::files::Files;",
            "use eww_shared_util::{Span, VarName};",
            "use gdk::Monitor;",
            "use glib::ObjectExt;",
            "use itertools::Itertools;",
            "use once_cell::sync::Lazy;",
            "use simplexpr::{dynval::DynVal, SimplExpr};",
            "use std::{\n    cell::RefCell,\n    collections::{HashMap, HashSet},\n    rc::Rc,\n};",
            "use tokio::sync::mpsc::UnboundedSender;",
            "use yuck::{\n    config::{\n        monitor::MonitorIdentifier,\n        script_var_definition::ScriptVarDefinition,\n        window_geometry::{AnchorPoint, WindowGeometry},\n    },\n    error::DiagError,\n    gen_diagnostic,\n    value::Coords,\n};"
        ],
        "reference_api": [
            "Lazy::new",
            "Span",
            "regex::Regex::new(r\"[^:]*:(\\d+):(\\d+)(.*)$\").unwrap",
            "captures.get(1).unwrap().as_str().parse::<usize>().ok",
            "db.line_range",
            "Err",
            "captures.get",
            "(|| {\n                let captures = PATTERN.captures(err.message())?;\n                let line = captures.get(1).unwrap().as_str().parse::<usize>().ok()?;\n                let msg = captures.get(3).unwrap().as_str();\n                let db = error_handling_ctx::FILE_DATABASE.read().ok()?;\n                let line_range = db.line_range(file_id, line - 1).ok()?;\n                let span = Span(line_range.start, line_range.end - 1, file_id);\n                Some(DiagError(gen_diagnostic!(msg, span)))\n            })",
            "self.css_provider.load_from_data",
            "captures.get(3).unwrap().as_str",
            "PATTERN.captures",
            "db.line_range(file_id, line - 1).ok",
            "regex::Regex::new",
            "captures.get(3).unwrap",
            "css.as_bytes",
            "DiagError",
            "Ok",
            "error_handling_ctx::FILE_DATABASE.read",
            "captures.get(1).unwrap().as_str",
            "error_handling_ctx::FILE_DATABASE.read().ok",
            "captures.get(1).unwrap().as_str().parse::<usize>",
            "err.message",
            "captures.get(1).unwrap",
            "Some"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Lazy::new",
            "Span",
            "regex::Regex::new(r\"[^:]*:(\\d+):(\\d+)(.*)$\").unwrap",
            "captures.get(1).unwrap().as_str().parse::<usize>().ok",
            "db.line_range",
            "captures.get",
            "(|| {\n                let captures = PATTERN.captures(err.message())?;\n                let line = captures.get(1).unwrap().as_str().parse::<usize>().ok()?;\n                let msg = captures.get(3).unwrap().as_str();\n                let db = error_handling_ctx::FILE_DATABASE.read().ok()?;\n                let line_range = db.line_range(file_id, line - 1).ok()?;\n                let span = Span(line_range.start, line_range.end - 1, file_id);\n                Some(DiagError(gen_diagnostic!(msg, span)))\n            })",
            "self.css_provider.load_from_data",
            "captures.get(3).unwrap().as_str",
            "PATTERN.captures",
            "db.line_range(file_id, line - 1).ok",
            "regex::Regex::new",
            "captures.get(3).unwrap",
            "css.as_bytes",
            "DiagError",
            "error_handling_ctx::FILE_DATABASE.read",
            "captures.get(1).unwrap().as_str",
            "error_handling_ctx::FILE_DATABASE.read().ok",
            "captures.get(1).unwrap().as_str().parse::<usize>",
            "err.message",
            "captures.get(1).unwrap"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "fn get_gdk_monitor(identifier: Option<MonitorIdentifier>) -> Result<Monitor> ",
        "start_line": "606",
        "end_line": "627",
        "file_path": "crates/eww/src/app.rs",
        "docstring": "The function get_gdk_monitor(identifier: Option<MonitorIdentifier>) -> Result<Monitor> retrieves a monitor based on an optional identifier.\\nIt gets the default display and checks the identifier.\\nIf an identifier is provided, it attempts to find the monitor corresponding to that identifier.\\nIf the monitor cannot be found, it generates an error message listing all available monitors.\\nIf no identifier is provided, it retrieves the primary monitor.\\nThe function returns the found monitor or an error if the process fails.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4a881d16b9af",
        "ground_truth": "fn get_gdk_monitor(identifier: Option<MonitorIdentifier>) -> Result<Monitor> {\n    let display = gdk::Display::default().expect(\"could not get default display\");\n    let monitor = match identifier {\n        Some(ident) => {\n            let mon = get_monitor_from_display(&display, &ident);\n            mon.with_context(|| {\n                let head = format!(\"Failed to get monitor {}\\nThe available monitors are:\", ident);\n                let mut body = String::new();\n                for m in 0..display.n_monitors() {\n                    if let Some(model) = display.monitor(m).and_then(|x| x.model()) {\n                        body.push_str(format!(\"\\n\\t[{}] {}\", m, model).as_str());\n                    }\n                }\n                format!(\"{}{}\", head, body)\n            })?\n        }\n        None => display\n            .primary_monitor()\n            .context(\"Failed to get primary monitor from GTK. Try explicitly specifying the monitor on your window.\")?,\n    };\n    Ok(monitor)\n}",
        "import_statements": [
            "use crate::{\n    config,\n    daemon_response::DaemonResponseSender,\n    display_backend::DisplayBackend,\n    error_handling_ctx,\n    gtk::prelude::{ContainerExt, CssProviderExt, GtkWindowExt, MonitorExt, StyleContextExt, WidgetExt},\n    paths::EwwPaths,\n    script_var_handler::ScriptVarHandlerHandle,\n    state::scope_graph::{ScopeGraph, ScopeIndex},\n    widgets::window::Window,\n    window_arguments::WindowArguments,\n    window_initiator::WindowInitiator,\n    *,\n};",
            "*",
            "*",
            "*",
            "*",
            "use anyhow::anyhow;",
            "use codespan_reporting::files::Files;",
            "use eww_shared_util::{Span, VarName};",
            "use gdk::Monitor;",
            "use glib::ObjectExt;",
            "use itertools::Itertools;",
            "use once_cell::sync::Lazy;",
            "use simplexpr::{dynval::DynVal, SimplExpr};",
            "use std::{\n    cell::RefCell,\n    collections::{HashMap, HashSet},\n    rc::Rc,\n};",
            "use tokio::sync::mpsc::UnboundedSender;",
            "use yuck::{\n    config::{\n        monitor::MonitorIdentifier,\n        script_var_definition::ScriptVarDefinition,\n        window_geometry::{AnchorPoint, WindowGeometry},\n    },\n    error::DiagError,\n    gen_diagnostic,\n    value::Coords,\n};"
        ],
        "reference_api": [
            "String::new",
            "body.push_str",
            "x.model",
            "format!(\"\\n\\t[{}] {}\", m, model).as_str",
            "display\n            .primary_monitor()\n            .context",
            "Ok",
            "get_monitor_from_display",
            "display\n            .primary_monitor",
            "gdk::Display::default",
            "display.monitor",
            "mon.with_context",
            "gdk::Display::default().expect",
            "display.n_monitors",
            "display.monitor(m).and_then"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get_monitor_from_display",
                "code": "pub fn get_monitor_from_display(display: &gdk::Display, identifier: &MonitorIdentifier) -> Option<gdk::Monitor> {\n    match identifier {\n        MonitorIdentifier::List(list) => {\n            for ident in list {\n                if let Some(monitor) = get_monitor_from_display(display, ident) {\n                    return Some(monitor);\n                }\n            }\n            None\n        }\n        MonitorIdentifier::Primary => display.primary_monitor(),\n        MonitorIdentifier::Numeric(num) => display.monitor(*num),\n        MonitorIdentifier::Name(name) => {\n            for m in 0..display.n_monitors() {\n                if let Some(model) = display.monitor(m).and_then(|x| x.model()) {\n                    if model == *name {\n                        return display.monitor(m);\n                    }\n                }\n            }\n            None\n        }\n    }\n}"
            }
        ],
        "third_party": [
            "body.push_str",
            "x.model",
            "format!(\"\\n\\t[{}] {}\", m, model).as_str",
            "display\n            .primary_monitor()\n            .context",
            "display\n            .primary_monitor",
            "gdk::Display::default",
            "display.monitor",
            "mon.with_context",
            "gdk::Display::default().expect",
            "display.n_monitors",
            "display.monitor(m).and_then"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "pub fn get_window_rectangle(geometry: WindowGeometry, screen_rect: gdk::Rectangle) -> gdk::Rectangle",
        "start_line": "656",
        "end_line": "662",
        "file_path": "crates/eww/src/app.rs",
        "docstring": "The function get_window_rectangle(geometry: WindowGeometry, screen_rect: gdk::Rectangle) calculates the window rectangle based on the given geometry and screen dimensions.\\nIt computes the offset and size of the window relative to the screen size.\\nIt calculates the x and y coordinates by adding the screen coordinates, offsets, and anchor point alignments.\\nFinally, it returns a new gdk::Rectangle with the computed x, y, width, and height.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0d4bd8476c3b",
        "ground_truth": "pub fn get_window_rectangle(geometry: WindowGeometry, screen_rect: gdk::Rectangle) -> gdk::Rectangle {\n    let (offset_x, offset_y) = geometry.offset.relative_to(screen_rect.width(), screen_rect.height());\n    let (width, height) = geometry.size.relative_to(screen_rect.width(), screen_rect.height());\n    let x = screen_rect.x() + offset_x + geometry.anchor_point.x.alignment_to_coordinate(width, screen_rect.width());\n    let y = screen_rect.y() + offset_y + geometry.anchor_point.y.alignment_to_coordinate(height, screen_rect.height());\n    gdk::Rectangle::new(x, y, width, height)\n}",
        "import_statements": [
            "use crate::{\n    config,\n    daemon_response::DaemonResponseSender,\n    display_backend::DisplayBackend,\n    error_handling_ctx,\n    gtk::prelude::{ContainerExt, CssProviderExt, GtkWindowExt, MonitorExt, StyleContextExt, WidgetExt},\n    paths::EwwPaths,\n    script_var_handler::ScriptVarHandlerHandle,\n    state::scope_graph::{ScopeGraph, ScopeIndex},\n    widgets::window::Window,\n    window_arguments::WindowArguments,\n    window_initiator::WindowInitiator,\n    *,\n};",
            "*",
            "*",
            "*",
            "*",
            "use anyhow::anyhow;",
            "use codespan_reporting::files::Files;",
            "use eww_shared_util::{Span, VarName};",
            "use gdk::Monitor;",
            "use glib::ObjectExt;",
            "use itertools::Itertools;",
            "use once_cell::sync::Lazy;",
            "use simplexpr::{dynval::DynVal, SimplExpr};",
            "use std::{\n    cell::RefCell,\n    collections::{HashMap, HashSet},\n    rc::Rc,\n};",
            "use tokio::sync::mpsc::UnboundedSender;",
            "use yuck::{\n    config::{\n        monitor::MonitorIdentifier,\n        script_var_definition::ScriptVarDefinition,\n        window_geometry::{AnchorPoint, WindowGeometry},\n    },\n    error::DiagError,\n    gen_diagnostic,\n    value::Coords,\n};"
        ],
        "reference_api": [
            "geometry.anchor_point.x.alignment_to_coordinate",
            "screen_rect.x",
            "gdk::Rectangle::new",
            "screen_rect.width",
            "geometry.size.relative_to",
            "screen_rect.height",
            "screen_rect.y",
            "geometry.anchor_point.y.alignment_to_coordinate",
            "geometry.offset.relative_to"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "geometry.anchor_point.x.alignment_to_coordinate",
            "screen_rect.x",
            "gdk::Rectangle::new",
            "screen_rect.width",
            "geometry.size.relative_to",
            "screen_rect.height",
            "screen_rect.y",
            "geometry.anchor_point.y.alignment_to_coordinate",
            "geometry.offset.relative_to"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "fn initialize_window(window_init: &WindowInitiator, _monitor: gdk::Rectangle, x: i32, y: i32) -> Option<Window>",
        "start_line": "138",
        "end_line": "151",
        "file_path": "crates/eww/src/display_backend.rs",
        "docstring": "The function initialize_window(window_init: &WindowInitiator, _monitor: gdk::Rectangle, x: i32, y: i32) -> Option<Window> initializes a window with specified properties.\\nIt determines the window type based on backend options and creates a new window at the given coordinates.\\nThe function sets the window's resizable property, stacking position (foreground or background), and stickiness based on the initialization parameters.\\nFinally, it returns the configured window wrapped in an Option.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "588081b260d0",
        "ground_truth": "fn initialize_window(window_init: &WindowInitiator, _monitor: gdk::Rectangle, x: i32, y: i32) -> Option<Window> {\n    let window_type =\n        if window_init.backend_options.x11.wm_ignore { gtk::WindowType::Popup } else { gtk::WindowType::Toplevel };\n    let window = Window::new(window_type, x, y);\n    window.set_resizable(window_init.resizable);\n    window.set_keep_above(window_init.stacking == WindowStacking::Foreground);\n    window.set_keep_below(window_init.stacking == WindowStacking::Background);\n    if window_init.backend_options.x11.sticky {\n        window.stick();\n    } else {\n        window.unstick();\n    }\n    Some(window)\n}",
        "import_statements": [
            "use crate::{widgets::window::Window, window_initiator::WindowInitiator};",
            "pub use platform_wayland::WaylandBackend;",
            "pub use platform_x11::{set_xprops, X11Backend};",
            "use crate::{widgets::window::Window, window_initiator::WindowInitiator};",
            "use gtk::prelude::*;",
            "gtk::prelude::*",
            "use yuck::config::{window_definition::WindowStacking, window_geometry::AnchorAlignment};",
            "use super::DisplayBackend;",
            "use crate::{widgets::window::Window, window_initiator::WindowInitiator};",
            "use anyhow::{Context, Result};",
            "use gdk::Monitor;",
            "use gtk::{self, prelude::*};",
            "prelude::*",
            "prelude::*",
            "prelude::*",
            "prelude::*",
            "use x11rb::protocol::xproto::ConnectionExt;",
            "use x11rb::{\n        self,\n        connection::Connection,\n        protocol::xproto::*,\n        rust_connection::{DefaultStream, RustConnection},\n    };",
            "protocol::xproto::*",
            "protocol::xproto::*",
            "protocol::xproto::*",
            "protocol::xproto::*",
            "use yuck::config::{\n        backend_window_options::{Side, X11WindowType},\n        window_definition::WindowStacking,\n    };",
            "use super::DisplayBackend;"
        ],
        "reference_api": [
            "window.set_keep_above",
            "window.unstick",
            "window.stick",
            "window.set_keep_below",
            "Some",
            "window.set_resizable",
            "Window::new"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "window.set_keep_above",
            "window.unstick",
            "window.stick",
            "window.set_keep_below",
            "window.set_resizable",
            "Window::new"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "pub fn print_error(err: anyhow::Error)",
        "start_line": "23",
        "end_line": "31",
        "file_path": "crates/eww/src/error_handling_ctx.rs",
        "docstring": "The function print_error(err: anyhow::Error) handles the printing of errors.\\nIt converts the error to a diagnostic message.\\nIf the conversion is successful, it tries to stringify the diagnostic message.\\nIf stringification is successful, it prints the diagnostic message to the standard error output.\\nIf any step fails, it logs the original error.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bbe996b92d6e",
        "ground_truth": "pub fn print_error(err: anyhow::Error) {\n    match anyhow_err_to_diagnostic(&err) {\n        Some(diag) => match stringify_diagnostic(diag) {\n            Ok(diag) => eprintln!(\"{}\", diag),\n            Err(_) => log::error!(\"{:?}\", err),\n        },\n        None => log::error!(\"{:?}\", err),\n    }\n}",
        "import_statements": [
            "use std::sync::{Arc, RwLock};",
            "use codespan_reporting::{\n    diagnostic::Diagnostic,\n    term::{self, Chars},\n};",
            "use eww_shared_util::Span;",
            "use once_cell::sync::Lazy;",
            "use simplexpr::{dynval::ConversionError, eval::EvalError};",
            "use yuck::{config::validate::ValidationError, error::DiagError, format_diagnostic::ToDiagnostic};",
            "use crate::file_database::FileDatabase;"
        ],
        "reference_api": [
            "stringify_diagnostic",
            "anyhow_err_to_diagnostic"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "stringify_diagnostic",
                "code": "pub fn stringify_diagnostic(mut diagnostic: codespan_reporting::diagnostic::Diagnostic<usize>) -> anyhow::Result<String> {\n    diagnostic.labels.retain(|label| !Span(label.range.start, label.range.end, label.file_id).is_dummy());\n\n    let mut config = term::Config::default();\n    let mut chars = Chars::box_drawing();\n    chars.single_primary_caret = '\u2500';\n    config.chars = chars;\n    config.chars.note_bullet = '\u2192';\n    let mut buf = Vec::new();\n    let mut writer = term::termcolor::Ansi::new(&mut buf);\n    let files = FILE_DATABASE.read().unwrap();\n    term::emit(&mut writer, &config, &*files, &diagnostic)?;\n    Ok(String::from_utf8(buf)?)\n}\n"
            },
            {
                "name": "anyhow_err_to_diagnostic",
                "code": "pub fn anyhow_err_to_diagnostic(err: &anyhow::Error) -> Option<Diagnostic<usize>> {\n    #[allow(clippy::manual_map)]\n    if let Some(err) = err.downcast_ref::<DiagError>() {\n        Some(err.0.clone())\n    } else if let Some(err) = err.downcast_ref::<ConversionError>() {\n        Some(err.to_diagnostic())\n    } else if let Some(err) = err.downcast_ref::<ValidationError>() {\n        Some(err.to_diagnostic())\n    } else if let Some(err) = err.downcast_ref::<EvalError>() {\n        Some(err.to_diagnostic())\n    } else {\n        None\n    }\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "pub async fn run_server<P: AsRef<std::path::Path>>(evt_send: UnboundedSender<app::DaemonCommand>, socket_path: P) -> Result<()>",
        "start_line": "9",
        "end_line": "26",
        "file_path": "crates/eww/src/ipc_server.rs",
        "docstring": "The async function run_server initializes an IPC server using a Unix socket at the specified path.\\nIt binds a listener to the socket path and logs the initialization.\\nIn a loop, it accepts incoming connections.\\nFor each connection, it clones the event sender and spawns a new task to handle the connection asynchronously.\\nIt logs any errors that occur while handling the connection.\\nThe function returns a Result indicating success or failure.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d5e9c17aaa4d",
        "ground_truth": "pub async fn run_server<P: AsRef<std::path::Path>>(evt_send: UnboundedSender<app::DaemonCommand>, socket_path: P) -> Result<()> {\n    let socket_path = socket_path.as_ref();\n    let listener = { tokio::net::UnixListener::bind(socket_path)? };\n    log::info!(\"IPC server initialized\");\n    crate::loop_select_exiting! {\n        connection = listener.accept() => match connection {\n            Ok((stream, _addr)) => {\n                let evt_send = evt_send.clone();\n                tokio::spawn(async move {\n                    let result = handle_connection(stream, evt_send.clone()).await;\n                    crate::print_result_err!(\"while handling IPC connection with client\", result);\n                });\n            },\n            Err(e) => eprintln!(\"Failed to connect to client: {:?}\", e),\n        }\n    }\n    Ok(())\n}",
        "import_statements": [
            "use crate::{app, opts};",
            "use anyhow::{Context, Result};",
            "use std::time::Duration;",
            "use tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    sync::mpsc::*,\n};",
            "sync::mpsc::*",
            "sync::mpsc::*",
            "sync::mpsc::*",
            "sync::mpsc::*"
        ],
        "reference_api": [
            "socket_path.as_ref",
            "Ok",
            "tokio::net::UnixListener::bind"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "socket_path.as_ref",
            "tokio::net::UnixListener::bind"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "async fn handle_connection(mut stream: tokio::net::UnixStream, evt_send: UnboundedSender<app::DaemonCommand>) -> Result<()>",
        "start_line": "29",
        "end_line": "50",
        "file_path": "crates/eww/src/ipc_server.rs",
        "docstring": "The async function handle_connection(mut stream: tokio::net::UnixStream, evt_send: UnboundedSender<app::DaemonCommand>) -> Result<()> manages incoming IPC connections.\\nIt splits the stream into read and write components.\\nIt reads an action from the stream and logs the received command.\\nIt converts the action into a daemon command and sends it through the provided event sender.\\nIf a response is expected, it waits for the response with a timeout of 100 milliseconds.\\nIf a response is received in time, it serializes and writes the response back to the stream.\\nFinally, it shuts down the write stream and returns a result.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4af744d13f02",
        "ground_truth": "async fn handle_connection(mut stream: tokio::net::UnixStream, evt_send: UnboundedSender<app::DaemonCommand>) -> Result<()> {\n    let (mut stream_read, mut stream_write) = stream.split();\n     let action: opts::ActionWithServer = read_action_from_stream(&mut stream_read).await?;\n     log::debug!(\"received command from IPC: {:?}\", &action);\n     let (command, maybe_response_recv) = action.into_daemon_command();\n     evt_send.send(command)?;\n     if let Some(mut response_recv) = maybe_response_recv {\n        log::debug!(\"Waiting for response for IPC client\");\n        if let Ok(Some(response)) = tokio::time::timeout(Duration::from_millis(100), response_recv.recv()).await {\n            let response = bincode::serialize(&response)?;\n            let result = &stream_write.write_all(&response).await;\n            crate::print_result_err!(\"sending text response to ipc client\", &result);\n        }\n    }\n    stream_write.shutdown().await?;\n    Ok(())\n}",
        "import_statements": [
            "use crate::{app, opts};",
            "use anyhow::{Context, Result};",
            "use std::time::Duration;",
            "use tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    sync::mpsc::*,\n};",
            "sync::mpsc::*",
            "sync::mpsc::*",
            "sync::mpsc::*",
            "sync::mpsc::*"
        ],
        "reference_api": [
            "stream_write.write_all",
            "evt_send.send",
            "tokio::time::timeout",
            "Duration::from_millis",
            "Ok",
            "stream.split",
            "action.into_daemon_command",
            "response_recv.recv",
            "read_action_from_stream",
            "bincode::serialize",
            "stream_write.shutdown"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "read_action_from_stream",
                "code": "async fn read_action_from_stream(stream_read: &'_ mut tokio::net::unix::ReadHalf<'_>) -> Result<opts::ActionWithServer> {\n    let mut message_byte_length = [0u8; 4];\n    stream_read.read_exact(&mut message_byte_length).await.context(\"Failed to read message size header in IPC message\")?;\n    let message_byte_length = u32::from_be_bytes(message_byte_length);\n    let mut raw_message = Vec::<u8>::with_capacity(message_byte_length as usize);\n    while raw_message.len() < message_byte_length as usize {\n        stream_read.read_buf(&mut raw_message).await.context(\"Failed to read actual IPC message\")?;\n    }\n\n    bincode::deserialize(&raw_message).context(\"Failed to parse client message\")\n}"
            }
        ],
        "third_party": [
            "stream_write.write_all",
            "evt_send.send",
            "tokio::time::timeout",
            "Duration::from_millis",
            "stream.split",
            "action.into_daemon_command",
            "response_recv.recv",
            "bincode::serialize",
            "stream_write.shutdown"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "async fn read_action_from_stream(stream_read: &'_ mut tokio::net::unix::ReadHalf<'_>) -> Result<opts::ActionWithServer>",
        "start_line": "54",
        "end_line": "64",
        "file_path": "crates/eww/src/ipc_server.rs",
        "docstring": "The async function read_action_from_stream(stream_read: &'_ mut tokio::net::unix::ReadHalf<'_>) -> Result<opts::ActionWithServer> reads an action from a Unix stream.\\nIt first reads the message size header into a 4-byte array and converts it to an unsigned 32-bit integer.\\nIt then allocates a buffer with the specified capacity and reads the message into the buffer in a loop until the full message is received.\\nFinally, it deserializes the raw message using bincode and returns the result, handling any errors that occur during reading or deserialization.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8475be269e09",
        "ground_truth": "async fn read_action_from_stream(stream_read: &'_ mut tokio::net::unix::ReadHalf<'_>) -> Result<opts::ActionWithServer> {\n    let mut message_byte_length = [0u8; 4];\n    stream_read.read_exact(&mut message_byte_length).await.context(\"Failed to read message size header in IPC message\")?;\n    let message_byte_length = u32::from_be_bytes(message_byte_length);\n    let mut raw_message = Vec::<u8>::with_capacity(message_byte_length as usize);\n    while raw_message.len() < message_byte_length as usize {\n        stream_read.read_buf(&mut raw_message).await.context(\"Failed to read actual IPC message\")?;\n    }\n     bincode::deserialize(&raw_message).context(\"Failed to parse client message\")\n}",
        "import_statements": [
            "use crate::{app, opts};",
            "use anyhow::{Context, Result};",
            "use std::time::Duration;",
            "use tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    sync::mpsc::*,\n};",
            "sync::mpsc::*",
            "sync::mpsc::*",
            "sync::mpsc::*",
            "sync::mpsc::*"
        ],
        "reference_api": [
            "stream_read.read_buf",
            "stream_read.read_exact(&mut message_byte_length).await.context",
            "Vec::<u8>::with_capacity",
            "bincode::deserialize",
            "raw_message.len",
            "u32::from_be_bytes",
            "bincode::deserialize(&raw_message).context",
            "stream_read.read_exact",
            "stream_read.read_buf(&mut raw_message).await.context"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "stream_read.read_buf",
            "stream_read.read_exact(&mut message_byte_length).await.context",
            "bincode::deserialize",
            "raw_message.len",
            "u32::from_be_bytes",
            "bincode::deserialize(&raw_message).context",
            "stream_read.read_exact",
            "stream_read.read_buf(&mut raw_message).await.context"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "elkowar/eww",
        "function_declaration": "async fn wait_for_service_exit(con: &zbus::Connection, service: zbus::names::BusName<'_>) -> zbus::fdo::Result<()>",
        "start_line": "282",
        "end_line": "299",
        "file_path": "crates/notifier_host/src/watcher.rs",
        "docstring": "The async function wait_for_service_exit(con: &zbus::Connection, service: zbus::names::BusName<'_>) -> zbus::fdo::Result<()> waits for a D-Bus service to exit.\\nIt creates a D-Bus proxy and listens for changes in the ownership of the specified service name.\\nIf the service does not have an owner initially, it returns immediately.\\nOtherwise, it continues to listen for owner change signals until the service owner disappears.\\nFinally, it returns an Ok result.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5f7bde448666",
        "ground_truth": "async fn wait_for_service_exit(con: &zbus::Connection, service: zbus::names::BusName<'_>) -> zbus::fdo::Result<()> {\n    let dbus = zbus::fdo::DBusProxy::new(con).await?;\n    let mut owner_changes = dbus.receive_name_owner_changed_with_args(&[(0, &service)]).await?;\n     if !dbus.name_has_owner(service.as_ref()).await? {\n        // service has already disappeared\n        return Ok(());\n    }\n     while let Some(sig) = owner_changes.next().await {\n        let args = sig.args()?;\n        if args.new_owner().is_none() {\n            break;\n        }\n    }\n     Ok(())\n}",
        "import_statements": [
            "use crate::names;",
            "use zbus::{dbus_interface, export::ordered_stream::OrderedStreamExt, Interface};"
        ],
        "reference_api": [
            "Ok",
            "owner_changes.next",
            "dbus.name_has_owner",
            "args.new_owner().is_none",
            "args.new_owner",
            "sig.args",
            "dbus.receive_name_owner_changed_with_args",
            "zbus::fdo::DBusProxy::new",
            "service.as_ref"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "owner_changes.next",
            "dbus.name_has_owner",
            "args.new_owner().is_none",
            "args.new_owner",
            "sig.args",
            "dbus.receive_name_owner_changed_with_args",
            "zbus::fdo::DBusProxy::new",
            "service.as_ref"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "flxzt/rnote",
        "function_declaration": "fn doc_export_format_from_ext_str(format: &str) -> anyhow::Result<DocExportFormat> ",
        "start_line": "311",
        "end_line": "320",
        "file_path": "crates/rnote-cli/src/export.rs",
        "docstring": "The function doc_export_format_from_ext_str(format: &str) -> anyhow::Result<DocExportFormat> converts a file extension string to a corresponding DocExportFormat enum.\\nIt matches the input string against supported formats (\"svg\", \"xopp\", \"pdf\") and returns the appropriate enum value.\\nIf the format is not supported, it returns an error with a message indicating the unsupported format.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d5149dd17f39",
        "ground_truth": "fn doc_export_format_from_ext_str(format: &str) -> anyhow::Result<DocExportFormat> {\n    match format {\n        \"svg\" => Ok(DocExportFormat::Svg),\n        \"xopp\" => Ok(DocExportFormat::Xopp),\n        \"pdf\" => Ok(DocExportFormat::Pdf),\n        ext => Err(anyhow::anyhow!(\n            \"Exporting document to format with extension \\\"{ext}\\\" is not supported.\"\n        )),\n    }\n}",
        "import_statements": [
            "use crate::cli::{self, OnConflict};",
            "use crate::validators;",
            "use anyhow::Context;",
            "use p2d::bounding_volume::Aabb;",
            "use rnote_compose::SplitOrder;",
            "use rnote_engine::engine::export::{\n    DocExportFormat, DocExportPrefs, DocPagesExportFormat, DocPagesExportPrefs,\n    SelectionExportFormat, SelectionExportPrefs,\n};",
            "use rnote_engine::engine::EngineSnapshot;",
            "use rnote_engine::{Engine, SelectionCollision};",
            "use std::path::{Path, PathBuf};"
        ],
        "reference_api": [
            "Err",
            "Ok"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "GTK",
        "owner/repo": "flxzt/rnote",
        "function_declaration": "pub(crate) fn file_has_ext(path: &Path, expected_ext: &str) -> anyhow::Result<()>",
        "start_line": "23",
        "end_line": "36",
        "file_path": "crates/rnote-cli/src/validators.rs",
        "docstring": "The function file_has_ext(path: &Path, expected_ext: &str) checks if a given file has the expected extension.\\nIt first ensures the path is a valid file using path_is_file(path).\\nIf the file has the expected extension, it returns Ok(()).\\nIf the file has a different extension or no extension, it returns an error with a descriptive message indicating the expected and found extensions.",
        "language": "Rust",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "47c741fa1cf0",
        "ground_truth": "pub(crate) fn file_has_ext(path: &Path, expected_ext: &str) -> anyhow::Result<()> {\n    path_is_file(path)?;\n    match path.extension() {\n        Some(ext) if ext == expected_ext => Ok(()),\n        Some(ext) => Err(anyhow::anyhow!(\n            \"Expected file with extension \\\"{expected_ext}\\\", found extension \\\"{ext:?}\\\", file \\\"{}\\\".\",\n            path.display()\n        )),\n        None => Err(anyhow::anyhow!(\n            \"Expected file with extension \\\"{expected_ext}\\\", no extension found for file \\\"{}\\\".\",\n            path.display()\n        ))\n    }\n}",
        "import_statements": [
            "use std::path::Path;"
        ],
        "reference_api": [
            "path.extension",
            "Err",
            "path_is_file",
            "Ok"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "path_is_file",
                "code": "pub(crate) fn path_is_file(path: &Path) -> anyhow::Result<()> {\n    if !path.is_file() {\n        return Err(anyhow::anyhow!(\n            \"Expected file, found directory \\\"{}\\\"\",\n            path.display()\n        ));\n    }\n    Ok(())\n}"
            }
        ],
        "third_party": [
            "path.extension"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "waybar::modules::CpuUsage::CpuUsage(const std::string& id, const Json::Value& config)",
        "start_line": "12",
        "end_line": "18",
        "file_path": "src/modules/cpu_usage/common.cpp",
        "docstring": "The constructor CpuUsage(const std::string& id, const Json::Value& config) initializes a CpuUsage object.\\nIt inherits from ALabel, setting up the label with a specified configuration, name, ID, format, and interval.\\nIt defines a thread that emits a data point and then sleeps for the specified interval.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cde4fa8386cb",
        "ground_truth": "waybar::modules::CpuUsage::CpuUsage(const std::string& id, const Json::Value& config)\n    : ALabel(config, \"cpu_usage\", id, \"{usage}%\", 10) {\n  thread_ = [this] {\n    dp.emit();\n    thread_.sleep_for(interval_);\n  };\n}",
        "import_statements": [
            "#include \"modules/cpu_usage.hpp\"\n"
        ],
        "reference_api": [
            "thread_.sleep_for",
            "dp.emit"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "thread_.sleep_for",
            "dp.emit"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "static void handle_global(void *data, struct wl_registry *registry, uint32_t name,\n                          const char *interface, uint32_t version) ",
        "start_line": "71",
        "end_line": "82",
        "file_path": "src/modules/dwl/tags.cpp",
        "docstring": "The static function handle_global(void *data, struct wl_registry *registry, uint32_t name, const char *interface, uint32_t version) binds global interfaces from the Wayland registry.\\nIt checks if the interface matches zdwl_ipc_manager_v2_interface and binds it if true, updating the status_manager_ attribute in the Tags object.\\nIt also checks if the interface matches wl_seat_interface, binds it with the minimum version of 1, and updates the seat_ attribute in the Tags object.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "da58b589c5e8",
        "ground_truth": "static void handle_global(void *data, struct wl_registry *registry, uint32_t name,\n                          const char *interface, uint32_t version) {\n  if (std::strcmp(interface, zdwl_ipc_manager_v2_interface.name) == 0) {\n    static_cast<Tags *>(data)->status_manager_ = static_cast<struct zdwl_ipc_manager_v2 *>(\n        (zdwl_ipc_manager_v2 *)wl_registry_bind(registry, name, &zdwl_ipc_manager_v2_interface, 1));\n  }\n  if (std::strcmp(interface, wl_seat_interface.name) == 0) {\n    version = std::min<uint32_t>(version, 1);\n    static_cast<Tags *>(data)->seat_ = static_cast<struct wl_seat *>(\n        wl_registry_bind(registry, name, &wl_seat_interface, version));\n  }\n}",
        "import_statements": [
            "#include \"modules/dwl/tags.hpp\"\n",
            "#include <gtkmm/button.h>\n",
            "#include <gtkmm/label.h>\n",
            "#include <spdlog/spdlog.h>\n",
            "#include <wayland-client.h>\n",
            "#include <algorithm>\n",
            "#include \"client.hpp\"\n",
            "#include \"dwl-ipc-unstable-v2-client-protocol.h\"\n"
        ],
        "reference_api": [
            "static_cast<Tags *>",
            "std::min<uint32_t>",
            "static_cast<struct zdwl_ipc_manager_v2 *>",
            "std::strcmp",
            "wl_registry_bind",
            "static_cast<struct wl_seat *>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "static_cast<Tags *>",
            "static_cast<struct zdwl_ipc_manager_v2 *>",
            "wl_registry_bind",
            "static_cast<struct wl_seat *>"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "void IPC::parseIPC(const std::string& ev)",
        "start_line": "111",
        "end_line": "120",
        "file_path": "src/modules/hyprland/backend.cpp",
        "docstring": "The function IPC::parseIPC(const std::string& ev) processes an IPC event string.\\nIt extracts the request type from the event string up to the first '>' character.\\nIt acquires a unique lock on the callback mutex to ensure thread safety.\\nThe function iterates through registered callbacks and invokes the handler's onEvent method if the event name matches the extracted request type.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "22230d419d69",
        "ground_truth": "void IPC::parseIPC(const std::string& ev) {\n  std::string request = ev.substr(0, ev.find_first_of('>'));\n  std::unique_lock lock(callbackMutex_);\n   for (auto& [eventname, handler] : callbacks_) {\n    if (eventname == request) {\n      handler->onEvent(ev);\n    }\n  }\n}",
        "import_statements": [
            "#include \"modules/hyprland/backend.hpp\"\n",
            "#include <netdb.h>\n",
            "#include <netinet/in.h>\n",
            "#include <spdlog/spdlog.h>\n",
            "#include <sys/socket.h>\n",
            "#include <sys/stat.h>\n",
            "#include <sys/types.h>\n",
            "#include <sys/un.h>\n",
            "#include <unistd.h>\n",
            "#include <filesystem>\n",
            "#include <string>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "ev.find_first_of",
            "handler->onEvent",
            "ev.substr"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ev.find_first_of",
            "handler->onEvent",
            "ev.substr"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "void IPC::unregisterForIPC(EventHandler* ev_handler)",
        "start_line": "131",
        "end_line": "146",
        "file_path": "src/modules/hyprland/backend.cpp",
        "docstring": "The function IPC::unregisterForIPC(EventHandler* ev_handler) removes a specified event handler from the IPC callbacks.\\nIt first checks if the event handler is not null.\\nIt then acquires a unique lock on the callback mutex.\\nThe function iterates through the callbacks and removes any callback that matches the provided event handler.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5d195fbd6417",
        "ground_truth": "void IPC::unregisterForIPC(EventHandler* ev_handler) {\n  if (ev_handler == nullptr) {\n    return;\n  }\n   std::unique_lock lock(callbackMutex_);\n   for (auto it = callbacks_.begin(); it != callbacks_.end();) {\n    auto& [eventname, handler] = *it;\n    if (handler == ev_handler) {\n      callbacks_.erase(it++);\n    } else {\n      ++it;\n    }\n  }\n}",
        "import_statements": [
            "#include \"modules/hyprland/backend.hpp\"\n",
            "#include <netdb.h>\n",
            "#include <netinet/in.h>\n",
            "#include <spdlog/spdlog.h>\n",
            "#include <sys/socket.h>\n",
            "#include <sys/stat.h>\n",
            "#include <sys/types.h>\n",
            "#include <sys/un.h>\n",
            "#include <unistd.h>\n",
            "#include <filesystem>\n",
            "#include <string>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "callbacks_.begin",
            "callbacks_.erase",
            "callbacks_.end"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "callbacks_.begin",
            "callbacks_.erase",
            "callbacks_.end"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "auto Submap::parseConfig(const Json::Value& config) -> void",
        "start_line": "40",
        "end_line": "50",
        "file_path": "src/modules/hyprland/submap.cpp",
        "docstring": "The function Submap::parseConfig(const Json::Value& config) parses configuration settings from a JSON object.\\nIt checks if the \"always-on\" key is a boolean and sets the always_on_ member accordingly.\\nIt also checks if the \"default-submap\" key is a string and sets the default_submap_ member with its value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2bb5ef8b3cf3",
        "ground_truth": "auto Submap::parseConfig(const Json::Value& config) -> void {\n  auto const& alwaysOn = config[\"always-on\"];\n  if (alwaysOn.isBool()) {\n    always_on_ = alwaysOn.asBool();\n  }\n   auto const& defaultSubmap = config[\"default-submap\"];\n  if (defaultSubmap.isString()) {\n    default_submap_ = defaultSubmap.asString();\n  }\n}",
        "import_statements": [
            "#include \"modules/hyprland/submap.hpp\"\n",
            "#include <spdlog/spdlog.h>\n",
            "#include \"util/sanitize_str.hpp\"\n"
        ],
        "reference_api": [
            "alwaysOn.isBool",
            "alwaysOn.asBool",
            "defaultSubmap.asString",
            "defaultSubmap.isString"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "alwaysOn.isBool",
            "alwaysOn.asBool",
            "defaultSubmap.asString",
            "defaultSubmap.isString"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "std::string WindowCreationPayload::repr(Workspaces &workspace_manager)",
        "start_line": "95",
        "end_line": "106",
        "file_path": "src/modules/hyprland/windowcreationpayload.cpp",
        "docstring": "The function std::string WindowCreationPayload::repr(Workspaces &workspace_manager) generates a string representation of a window.\\nIt checks if the window is of type Repr and returns the stored string if true.\\nIf the window is of type ClassAndTitle, it retrieves the window class and title, and returns a rewritten string using the workspace manager.\\nIf neither condition is met, it logs an error and throws a runtime exception, marking the code path as unreachable.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c60aa24ddc6f",
        "ground_truth": "std::string WindowCreationPayload::repr(Workspaces &workspace_manager) {\n  if (std::holds_alternative<Repr>(m_window)) {\n    return std::get<Repr>(m_window);\n  }\n  if (std::holds_alternative<ClassAndTitle>(m_window)) {\n    auto [window_class, window_title] = std::get<ClassAndTitle>(m_window);\n    return workspace_manager.getRewrite(window_class, window_title);\n  }\n  // Unreachable\n  spdlog::error(\"WorkspaceWindow::repr: Unreachable\");\n  throw std::runtime_error(\"WorkspaceWindow::repr: Unreachable\");\n}",
        "import_statements": [
            "#include \"modules/hyprland/windowcreationpayload.hpp\"\n",
            "#include <json/value.h>\n",
            "#include <spdlog/spdlog.h>\n",
            "#include <string>\n",
            "#include <utility>\n",
            "#include <variant>\n",
            "#include \"modules/hyprland/workspaces.hpp\"\n"
        ],
        "reference_api": [
            "std::get<ClassAndTitle>",
            "spdlog::error",
            "std::runtime_error",
            "std::holds_alternative<Repr>",
            "std::get<Repr>",
            "workspace_manager.getRewrite",
            "std::holds_alternative<ClassAndTitle>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "spdlog::error",
            "workspace_manager.getRewrite"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "void Workspaces::createWorkspacesToCreate()",
        "start_line": "108",
        "end_line": "117",
        "file_path": "src/modules/hyprland/workspaces.cpp",
        "docstring": "The function Workspaces::createWorkspacesToCreate() iterates through a list of workspaces to be created.\\nFor each workspace, it calls createWorkspace with the workspace and client data.\\nIf there are any workspaces created, it updates the window count and sorts",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b9160180960d",
        "ground_truth": "void Workspaces::createWorkspacesToCreate() {\n  for (const auto &[workspaceData, clientsData] : m_workspacesToCreate) {\n    createWorkspace(workspaceData, clientsData);\n  }\n  if (!m_workspacesToCreate.empty()) {\n    updateWindowCount();\n    sortWorkspaces();\n  }\n  m_workspacesToCreate.clear();\n}",
        "import_statements": [
            "#include \"modules/hyprland/workspaces.hpp\"\n",
            "#include <json/value.h>\n",
            "#include <spdlog/spdlog.h>\n",
            "#include <algorithm>\n",
            "#include <memory>\n",
            "#include <string>\n",
            "#include <utility>\n",
            "#include \"util/regex_collection.hpp\"\n"
        ],
        "reference_api": [
            "m_workspacesToCreate.clear",
            "m_workspacesToCreate.empty",
            "createWorkspace",
            "updateWindowCount",
            "sortWorkspaces"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "createWorkspace",
                "code": "void Workspaces::createWorkspace(Json::Value const &workspace_data,\n                                 Json::Value const &clients_data) {\n  auto workspaceName = workspace_data[\"name\"].asString();\n  spdlog::debug(\"Creating workspace {}\", workspaceName);\n\n  // avoid recreating existing workspaces\n  auto workspace = std::find_if(\n      m_workspaces.begin(), m_workspaces.end(),\n      [workspaceName](std::unique_ptr<Workspace> const &w) {\n        return (workspaceName.starts_with(\"special:\") && workspaceName.substr(8) == w->name()) ||\n               workspaceName == w->name();\n      });\n\n  if (workspace != m_workspaces.end()) {\n    // don't recreate workspace, but update persistency if necessary\n    const auto keys = workspace_data.getMemberNames();\n\n    const auto *k = \"persistent-rule\";\n    if (std::find(keys.begin(), keys.end(), k) != keys.end()) {\n      spdlog::debug(\"Set dynamic persistency of workspace {} to: {}\", workspaceName,\n                    workspace_data[k].asBool() ? \"true\" : \"false\");\n      (*workspace)->setPersistentRule(workspace_data[k].asBool());\n    }\n\n    k = \"persistent-config\";\n    if (std::find(keys.begin(), keys.end(), k) != keys.end()) {\n      spdlog::debug(\"Set config persistency of workspace {} to: {}\", workspaceName,\n                    workspace_data[k].asBool() ? \"true\" : \"false\");\n      (*workspace)->setPersistentConfig(workspace_data[k].asBool());\n    }\n\n    return;\n  }\n\n  // create new workspace\n  m_workspaces.emplace_back(std::make_unique<Workspace>(workspace_data, *this, clients_data));\n  Gtk::Button &newWorkspaceButton = m_workspaces.back()->button();\n  m_box.pack_start(newWorkspaceButton, false, false);\n  sortWorkspaces();\n  newWorkspaceButton.show_all();\n}"
            },
            {
                "name": "updateWindowCount",
                "code": "void Workspaces::updateWindowCount() {\n  const Json::Value workspacesJson = gIPC->getSocket1JsonReply(\"workspaces\");\n  for (auto &workspace : m_workspaces) {\n    auto workspaceJson =\n        std::find_if(workspacesJson.begin(), workspacesJson.end(), [&](Json::Value const &x) {\n          return x[\"name\"].asString() == workspace->name() ||\n                 (workspace->isSpecial() && x[\"name\"].asString() == \"special:\" + workspace->name());\n        });\n    uint32_t count = 0;\n    if (workspaceJson != workspacesJson.end()) {\n      try {\n        count = (*workspaceJson)[\"windows\"].asUInt();\n      } catch (const std::exception &e) {\n        spdlog::error(\"Failed to update window count: {}\", e.what());\n      }\n    }\n    workspace->setWindows(count);\n  }\n}"
            },
            {
                "name": "sortWorkspaces",
                "code": "void Workspaces::sortWorkspaces() {\n  std::sort(m_workspaces.begin(), m_workspaces.end(),\n            [&](std::unique_ptr<Workspace> &a, std::unique_ptr<Workspace> &b) {\n              // Helper comparisons\n              auto isIdLess = a->id() < b->id();\n              auto isNameLess = a->name() < b->name();\n\n              switch (m_sortBy) {\n                case SortMethod::ID:\n                  return isIdLess;\n                case SortMethod::NAME:\n                  return isNameLess;\n                case SortMethod::NUMBER:\n                  try {\n                    return std::stoi(a->name()) < std::stoi(b->name());\n                  } catch (const std::invalid_argument &) {\n                    // Handle the exception if necessary.\n                    break;\n                  }\n                case SortMethod::DEFAULT:\n                default:\n                  // Handle the default case here.\n                  // normal -> named persistent -> named -> special -> named special\n\n                  // both normal (includes numbered persistent) => sort by ID\n                  if (a->id() > 0 && b->id() > 0) {\n                    return isIdLess;\n                  }\n\n                  // one normal, one special => normal first\n                  if ((a->isSpecial()) ^ (b->isSpecial())) {\n                    return b->isSpecial();\n                  }\n\n                  // only one normal, one named\n                  if ((a->id() > 0) ^ (b->id() > 0)) {\n                    return a->id() > 0;\n                  }\n\n                  // both special\n                  if (a->isSpecial() && b->isSpecial()) {\n                    // if one is -99 => put it last\n                    if (a->id() == -99 || b->id() == -99) {\n                      return b->id() == -99;\n                    }\n                    // both are 0 (not yet named persistents) / named specials (-98 <= ID <= -1)\n                    return isNameLess;\n                  }\n\n                  // sort non-special named workspaces by name (ID <= -1377)\n                  return isNameLess;\n                  break;\n              }\n\n              // Return a default value if none of the cases match.\n              return isNameLess;  // You can adjust this to your specific needs.\n            });\n\n  for (size_t i = 0; i < m_workspaces.size(); ++i) {\n    m_box.reorder_child(m_workspaces[i]->button(), i);\n  }\n}"
            }
        ],
        "third_party": [
            "m_workspacesToCreate.clear",
            "m_workspacesToCreate.empty"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "auto Mpris::onPlayerNameVanished(PlayerctlPlayerManager* manager, PlayerctlPlayerName* player_name,\n                                 gpointer data) -> void ",
        "start_line": "423",
        "end_line": "435",
        "file_path": "src/modules/mpris/mpris.cpp",
        "docstring": "The function Mpris::onPlayerNameVanished handles the event when a player's name vanishes.\\nIt retrieves the Mpris instance from the provided data and checks its validity.\\nIt logs a debug message with the player's name.\\nIf the vanished player's name matches the current player's name in the Mpris instance, it sets the player to null, hides the event box, and emits an update event.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "07260cd3fead",
        "ground_truth": "auto Mpris::onPlayerNameVanished(PlayerctlPlayerManager* manager, PlayerctlPlayerName* player_name,\n                                 gpointer data) -> void {\n  auto* mpris = static_cast<Mpris*>(data);\n  if (!mpris) return;\n   spdlog::debug(\"mpris: player-vanished callback: {}\", player_name->name);\n   if (std::string(player_name->name) == mpris->player_) {\n    mpris->player = nullptr;\n    mpris->event_box_.set_visible(false);\n    mpris->dp.emit();\n  }\n}",
        "import_statements": [
            "#include \"modules/mpris/mpris.hpp\"\n",
            "#include <fmt/core.h>\n",
            "#include <optional>\n",
            "#include <sstream>\n",
            "#include <string>\n",
            "#include \"util/scope_guard.hpp\"\n",
            "#include <glib.h>\n",
            "#include <spdlog/spdlog.h>\n"
        ],
        "reference_api": [
            "std::string",
            "static_cast<Mpris*>",
            "mpris->dp.emit",
            "mpris->event_box_.set_visible",
            "spdlog::debug"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "static_cast<Mpris*>",
            "mpris->dp.emit",
            "mpris->event_box_.set_visible",
            "spdlog::debug"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "auto Mpris::onPlayerPause(PlayerctlPlayer* player, gpointer data) -> void",
        "start_line": "446",
        "end_line": "453",
        "file_path": "src/modules/mpris/mpris.cpp",
        "docstring": "The function Mpris::onPlayerPause(PlayerctlPlayer* player, gpointer data) handles the player pause event.\\nIt casts the data to an Mpris object and checks if it is valid.\\nIf valid, it logs a debug message indicating the player pause event and updates the widget by emitting a signal through mpris->dp.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "94a47eddc505",
        "ground_truth": "auto Mpris::onPlayerPause(PlayerctlPlayer* player, gpointer data) -> void {\n  auto* mpris = static_cast<Mpris*>(data);\n  if (!mpris) return;\n   spdlog::debug(\"mpris: player-pause callback\");\n  // update widget\n  mpris->dp.emit();\n}",
        "import_statements": [
            "#include \"modules/mpris/mpris.hpp\"\n",
            "#include <fmt/core.h>\n",
            "#include <optional>\n",
            "#include <sstream>\n",
            "#include <string>\n",
            "#include \"util/scope_guard.hpp\"\n",
            "#include <glib.h>\n",
            "#include <spdlog/spdlog.h>\n"
        ],
        "reference_api": [
            "static_cast<Mpris*>",
            "mpris->dp.emit",
            "spdlog::debug"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "static_cast<Mpris*>",
            "mpris->dp.emit",
            "spdlog::debug"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "void BarIpcClient::onInitialConfig(const struct Ipc::ipc_response& res)",
        "start_line": "90",
        "end_line": "98",
        "file_path": "src/modules/sway/bar.cpp",
        "docstring": "The function BarIpcClient::onInitialConfig(const struct Ipc::ipc_response& res) handles the initial configuration response from IPC.\\nIt parses the response payload and checks if the \"success\" field is true.\\nIf not, it retrieves the error message and throws a runtime exception.\\nIf successful, it parses the configuration from the payload and calls onConfigUpdate with the parsed configuration.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "716955fc6ff5",
        "ground_truth": "void BarIpcClient::onInitialConfig(const struct Ipc::ipc_response& res) {\n  auto payload = parser_.parse(res.payload);\n  if (auto success = payload.get(\"success\", true); !success.asBool()) {\n    auto err = payload.get(\"error\", \"Unknown error\");\n    throw std::runtime_error(err.asString());\n  }\n  auto config = parseConfig(payload);\n  onConfigUpdate(config);\n}",
        "import_statements": [
            "#include \"modules/sway/bar.hpp\"\n",
            "#include <spdlog/spdlog.h>\n",
            "#include <sstream>\n",
            "#include <stdexcept>\n",
            "#include \"bar.hpp\"\n",
            "#include \"modules/sway/ipc/ipc.hpp\"\n"
        ],
        "reference_api": [
            "std::runtime_error",
            "parseConfig",
            "onConfigUpdate",
            "parser_.parse",
            "success.asBool",
            "payload.get",
            "err.asString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "parseConfig",
                "code": "struct swaybar_config parseConfig(const Json::Value& payload) {\n  swaybar_config conf;\n  if (auto id = payload[\"id\"]; id.isString()) {\n    conf.id = id.asString();\n  }\n  if (auto mode = payload[\"mode\"]; mode.isString()) {\n    conf.mode = mode.asString();\n  }\n  if (auto hs = payload[\"hidden_state\"]; hs.isString()) {\n    conf.hidden_state = hs.asString();\n  }\n  return conf;\n}"
            },
            {
                "name": "onConfigUpdate",
                "code": "void BarIpcClient::onConfigUpdate(const swaybar_config& config) {\n  spdlog::info(\"config update for {}: id {}, mode {}, hidden_state {}\", bar_.bar_id, config.id,\n               config.mode, config.hidden_state);\n  bar_config_ = config;\n  update();\n}"
            }
        ],
        "third_party": [
            "parser_.parse",
            "success.asBool",
            "payload.get",
            "err.asString"
        ]
    },
    {
        "subclass": "GTK",
        "owner/repo": "Alexays/Waybar",
        "function_declaration": "auto CFFI::doAction(const std::string& name) -> void",
        "start_line": "112",
        "end_line": "117",
        "file_path": "src/modules/cffi.cpp",
        "docstring": "The function CFFI::doAction(const std::string& name) executes a specified action using the CFFI instance.\\nIt asserts that the CFFI instance is not null.\\nIf the provided name is not empty, it calls the doAction method on the hooks_ object, passing the CFFI instance and the action name as a C-string.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e8aa483d1693",
        "ground_truth": "auto CFFI::doAction(const std::string& name) -> void {\n  assert(cffi_instance_ != nullptr);\n  if (!name.empty()) {\n    hooks_.doAction(cffi_instance_, name.c_str());\n  }\n}",
        "import_statements": [
            "#include \"modules/cffi.hpp\"\n",
            "#include <dlfcn.h>\n",
            "#include <json/value.h>\n",
            "#include <algorithm>\n",
            "#include <iostream>\n",
            "#include <type_traits>\n"
        ],
        "reference_api": [
            "assert",
            "name.empty",
            "hooks_.doAction",
            "name.c_str"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "assert",
            "name.empty",
            "hooks_.doAction",
            "name.c_str"
        ]
    }
]