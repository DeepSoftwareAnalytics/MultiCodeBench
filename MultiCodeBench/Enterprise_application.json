[
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def export_zip_documents(self, **args)",
        "start_line": "19",
        "end_line": "28",
        "file_path": "addons/account/controllers/download_docs.py",
        "docstring": "The function export_zip_documents retrieves attachment IDs from HTTP request arguments, verifies read access rights and rules for the attachments, and builds a zip file from the attachments' content. It then prepares HTTP headers for the zip file and returns the zip file as an HTTP response.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "f2eea3b23c41",
        "ground_truth": "def export_zip_documents(self, **args):\n    \"\"\" Download zipped attachments. \"\"\"\n    ids = list(map(int, request.httprequest.args.getlist('ids')))\n    filename = request.httprequest.args.get('filename')\n    attachments = request.env['ir.attachment'].browse(ids)\n    attachments.check_access_rights('read')\n    attachments.check_access_rule('read')\n    content = attachments._build_zip_from_attachments()\n    headers = _get_zip_headers(content, filename)\n    return request.make_response(content, headers)",
        "import_statements": [
            "from odoo import http, _",
            "from odoo.http import request, content_disposition"
        ],
        "reference_api": [
            "attachments._build_zip_from_attachments",
            "list",
            "attachments.check_access_rights",
            "getlist",
            "_get_zip_headers",
            "map",
            "get",
            "attachments.check_access_rule",
            "request.make_response",
            "browse"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get",
                "code": "f get(self, sid):\n        # retro compatibility\n        old_path = super().get_session_filename(sid)\n        session_path = self.get_session_filename(sid)\n        if os.path.isfile(old_path) and not os.path.isfile(session_path):\n            dirname = os.path.dirname(session_path)\n            if not os.path.isdir(dirname):\n                with contextlib.suppress(OSError):\n                    os.mkdir(dirname, 0o0755)\n            with contextlib.suppress(OSError):\n                os.rename(old_path, session_path)\n        return super().get(sid)\n\n"
            },
            {
                "name": "_get_zip_headers",
                "code": "def _get_zip_headers(content, filename):\n    return [\n        ('Content-Type', 'zip'),\n        ('X-Content-Type-Options', 'nosniff'),\n        ('Content-Length', len(content)),\n        ('Content-Disposition', content_disposition(filename)),\n    ]"
            },
            {
                "name": "request.make_response",
                "code": "f make_response(self, data, headers=None, cookies=None, status=200):\n        \"\"\" Helper for non-HTML responses, or HTML responses with custom\n        response headers or cookies.\n\n        While handlers can just return the HTML markup of a page they want to\n        send as a string if non-HTML data is returned they need to create a\n        complete response object, or the returned data will not be correctly\n        interpreted by the clients.\n\n        :param str data: response body\n        :param int status: http status code\n        :param headers: HTTP headers to set on the response\n        :type headers: ``[(name, value)]``\n        :param collections.abc.Mapping cookies: cookies to set on the client\n        :returns: a response object.\n        :rtype: :class:`~odoo.http.Response`\n        \"\"\"\n        response = Response(data, status=status, headers=headers)\n        if cookies:\n            for k, v in cookies.items():\n                response.set_cookie(k, v)\n        return response\n\n"
            }
        ],
        "third_party": [
            "getlist",
            "browse",
            "attachments.check_access_rights",
            "attachments.check_access_rule",
            "attachments._build_zip_from_attachments"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _prepare_home_portal_values(self, counters)",
        "start_line": "16",
        "end_line": "26",
        "file_path": "addons/account/controllers/portal.py",
        "docstring": "The function _prepare_home_portal_values extends the base method to add invoice and bill counts to the values dictionary based on provided counters. It checks read access rights for 'account.move' before counting invoices and bills, and includes these counts in the returned values.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "aad965b1552f",
        "ground_truth": "def _prepare_home_portal_values(self, counters):\n    values = super()._prepare_home_portal_values(counters)\n    if 'invoice_count' in counters:\n        invoice_count = request.env['account.move'].search_count(self._get_invoices_domain('out'), limit=1) \\\n            if request.env['account.move'].check_access_rights('read', raise_exception=False) else 0\n        values['invoice_count'] = invoice_count\n    if 'bill_count' in counters:\n        bill_count = request.env['account.move'].search_count(self._get_invoices_domain('in'), limit=1) \\\n            if request.env['account.move'].check_access_rights('read', raise_exception=False) else 0\n        values['bill_count'] = bill_count\n    return values",
        "import_statements": [
            "from collections import OrderedDict",
            "from odoo import http, _",
            "from odoo.osv import expression",
            "from odoo.addons.portal.controllers.portal import CustomerPortal, pager as portal_pager",
            "from odoo.addons.account.controllers.download_docs import _get_zip_headers",
            "from odoo.exceptions import AccessError, MissingError",
            "from odoo.http import request"
        ],
        "reference_api": [
            "super",
            "search_count",
            "self._get_invoices_domain",
            "check_access_rights",
            "_prepare_home_portal_values"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_prepare_home_portal_values",
                "code": "def _prepare_home_portal_values(self, counters):\n        values = super()._prepare_home_portal_values(counters)\n        if 'invoice_count' in counters:\n            invoice_count = request.env['account.move'].search_count(self._get_invoices_domain('out'), limit=1) \\\n                if request.env['account.move'].check_access_rights('read', raise_exception=False) else 0\n            values['invoice_count'] = invoice_count\n        if 'bill_count' in counters:\n            bill_count = request.env['account.move'].search_count(self._get_invoices_domain('in'), limit=1) \\\n                if request.env['account.move'].check_access_rights('read', raise_exception=False) else 0\n            values['bill_count'] = bill_count\n        return values"
            },
            {
                "name": "self._get_invoices_domain",
                "code": "def _get_invoices_domain(self, m_type=None):\n        if m_type in ['in', 'out']:\n            move_type = [m_type+move for move in ('_invoice', '_refund', '_receipt')]\n        else:\n            move_type = ('out_invoice', 'out_refund', 'in_invoice', 'in_refund', 'out_receipt', 'in_receipt')\n        return [('state', 'not in', ('cancel', 'draft')), ('move_type', 'in', move_type)]"
            },
            {
                "name": "self._get_invoices_domain",
                "code": "def _get_invoices_domain(self, m_type=None):\n        if m_type in ['in', 'out']:\n            move_type = [m_type+move for move in ('_invoice', '_refund', '_receipt')]\n        else:\n            move_type = ('out_invoice', 'out_refund', 'in_invoice', 'in_refund', 'out_receipt', 'in_receipt')\n        return [('state', 'not in', ('cancel', 'draft')), ('move_type', 'in', move_type)]"
            }
        ],
        "third_party": [
            "search_count",
            "check_access_rights",
            "search_count",
            "check_access_rights"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def portal_my_invoices(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, **kw)",
        "start_line": "62",
        "end_line": "76",
        "file_path": "addons/account/controllers/portal.py",
        "docstring": "The function portal_my_invoices prepares the values needed for displaying invoices, including pagination and sorting/filtering options. It retrieves the relevant invoices based on these parameters, updates the session history with the latest invoice IDs, and renders the invoices page with the prepared values.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "40b3f2d3fc91",
        "ground_truth": "def portal_my_invoices(self, page=1, date_begin=None, date_end=None, sortby=None, filterby=None, **kw):\n    values = self._prepare_my_invoices_values(page, date_begin, date_end, sortby, filterby)\n    # pager\n    pager = portal_pager(**values['pager'])\n    # content according to pager and archive selected\n    invoices = values['invoices'](pager['offset'])\n    request.session['my_invoices_history'] = invoices.ids[:100]\n    values.update({\n        'invoices': invoices,\n        'pager': pager,\n    })\n    return request.render(\"account.portal_my_invoices\", values)",
        "import_statements": [
            "from collections import OrderedDict",
            "from odoo import http, _",
            "from odoo.osv import expression",
            "from odoo.addons.portal.controllers.portal import CustomerPortal, pager as portal_pager",
            "from odoo.addons.account.controllers.download_docs import _get_zip_headers",
            "from odoo.exceptions import AccessError, MissingError",
            "from odoo.http import request"
        ],
        "reference_api": [
            "request.render",
            "self._prepare_my_invoices_values",
            "portal_pager",
            "values.update"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self._prepare_my_invoices_values",
                "code": "def _prepare_my_invoices_values(self, page, date_begin, date_end, sortby, filterby, domain=None, url=\"/my/invoices\"):\n        values = self._prepare_portal_layout_values()\n        AccountInvoice = request.env['account.move']\n\n        domain = expression.AND([\n            domain or [],\n            self._get_invoices_domain(),\n        ])\n\n        searchbar_sortings = self._get_account_searchbar_sortings()\n        # default sort by order\n        if not sortby:\n            sortby = 'date'\n        order = searchbar_sortings[sortby]['order']\n\n        searchbar_filters = self._get_account_searchbar_filters()\n        # default filter by value\n        if not filterby:\n            filterby = 'all'\n        domain += searchbar_filters[filterby]['domain']\n\n        if date_begin and date_end:\n            domain += [('create_date', '>', date_begin), ('create_date', '<=', date_end)]\n\n        values.update({\n            'date': date_begin,\n            # content according to pager and archive selected\n            # lambda function to get the invoices recordset when the pager will be defined in the main method of a route\n            'invoices': lambda pager_offset: (\n                AccountInvoice.search(domain, order=order, limit=self._items_per_page, offset=pager_offset)\n                if AccountInvoice.check_access_rights('read', raise_exception=False) else\n                AccountInvoice\n            ),\n            'page_name': 'invoice',\n            'pager': {  # vals to define the pager.\n                \"url\": url,\n                \"url_args\": {'date_begin': date_begin, 'date_end': date_end, 'sortby': sortby},\n                \"total\": AccountInvoice.search_count(domain) if AccountInvoice.check_access_rights('read', raise_exception=False) else 0,\n                \"page\": page,\n                \"step\": self._items_per_page,\n            },\n            'default_url': url,\n            'searchbar_sortings': searchbar_sortings,\n            'sortby': sortby,\n            'searchbar_filters': OrderedDict(sorted(searchbar_filters.items())),\n            'filterby': filterby,\n        })\n        return values"
            },
            {
                "name": "request.render",
                "code": "f render(self):\n        \"\"\" Renders the Response's template, returns the result. \"\"\"\n        self.qcontext['request'] = request\n        return request.env[\"ir.ui.view\"]._render_template(self.template, self.qcontext)\n\n"
            }
        ],
        "third_party": [
            "portal_pager",
            "values.update"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def portal_my_invoice_detail(self, invoice_id, access_token=None, report_type=None, download=False, **kw)",
        "start_line": "128",
        "end_line": "151",
        "file_path": "addons/account/controllers/portal.py",
        "docstring": "The function portal_my_invoice_detail checks access to an invoice and redirects if access is denied. If a PDF download of a posted invoice is requested, it retrieves legal documents, creates a zip file if there are multiple attachments, and returns the file with appropriate headers. For HTML, PDF, or text report types, it prepares and shows the report. Finally, it renders the invoice page view with necessary values.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1c0267d2c408",
        "ground_truth": "def portal_my_invoice_detail(self, invoice_id, access_token=None, report_type=None, download=False, **kw):\n    try:\n        invoice_sudo = self._document_check_access('account.move', invoice_id, access_token)\n    except (AccessError, MissingError):\n        return request.redirect('/my')\n    if report_type == 'pdf' and download and invoice_sudo.state == 'posted':\n        # Download the official attachment(s) or a Pro Forma invoice\n        attachments = invoice_sudo._get_invoice_legal_documents()\n        if len(attachments) > 1:\n            filename = invoice_sudo._get_invoice_report_filename(extension='zip')\n            zip_content = attachments.sudo()._build_zip_from_attachments()\n            headers = _get_zip_headers(zip_content, filename)\n            return request.make_response(zip_content, headers)\n        headers = self._get_http_headers(invoice_sudo, report_type, attachments.raw, download)\n        return request.make_response(attachments.raw, list(headers.items()))\n    elif report_type in ('html', 'pdf', 'text'):\n        has_generated_invoice = bool(invoice_sudo.invoice_pdf_report_id)\n        request.update_context(proforma_invoice=not has_generated_invoice)\n        return self._show_report(model=invoice_sudo, report_type=report_type, report_ref='account.account_invoices', download=download)\n    values = self._invoice_get_page_view_values(invoice_sudo, access_token, **kw)\n    return request.render(\"account.portal_invoice_page\", values)",
        "import_statements": [
            "from collections import OrderedDict",
            "from odoo import http, _",
            "from odoo.osv import expression",
            "from odoo.addons.portal.controllers.portal import CustomerPortal, pager as portal_pager",
            "from odoo.addons.account.controllers.download_docs import _get_zip_headers",
            "from odoo.exceptions import AccessError, MissingError",
            "from odoo.http import request"
        ],
        "reference_api": [
            "request.redirect",
            "_get_zip_headers",
            "list",
            "attachments.sudo",
            "headers.items",
            "bool",
            "len",
            "self._show_report",
            "self._invoice_get_page_view_values",
            "request.render",
            "invoice_sudo._get_invoice_report_filename",
            "_build_zip_from_attachments",
            "self._document_check_access",
            "request.update_context",
            "invoice_sudo._get_invoice_legal_documents",
            "request.make_response",
            "self._get_http_headers"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "request.redirect",
                "code": "f redirect(self, location, code=303, local=True):\n        # compatibility, Werkzeug support URL as location\n        if isinstance(location, URL):\n            location = location.to_url()\n        if local:\n            location = '/' + url_parse(location).replace(scheme='', netloc='').to_url().lstrip('/')\n        if self.db:\n            return self.env['ir.http']._redirect(location, code)\n        return werkzeug.utils.redirect(location, code, Response=Response)\n\n"
            },
            {
                "name": "request.make_response",
                "code": "f make_response(self, data, headers=None, cookies=None, status=200):\n        \"\"\" Helper for non-HTML responses, or HTML responses with custom\n        response headers or cookies.\n\n        While handlers can just return the HTML markup of a page they want to\n        send as a string if non-HTML data is returned they need to create a\n        complete response object, or the returned data will not be correctly\n        interpreted by the clients.\n\n        :param str data: response body\n        :param int status: http status code\n        :param headers: HTTP headers to set on the response\n        :type headers: ``[(name, value)]``\n        :param collections.abc.Mapping cookies: cookies to set on the client\n        :returns: a response object.\n        :rtype: :class:`~odoo.http.Response`\n        \"\"\"\n        response = Response(data, status=status, headers=headers)\n        if cookies:\n            for k, v in cookies.items():\n                response.set_cookie(k, v)\n        return response\n\n"
            },
            {
                "name": "request.make_response",
                "code": "f make_response(self, data, headers=None, cookies=None, status=200):\n        \"\"\" Helper for non-HTML responses, or HTML responses with custom\n        response headers or cookies.\n\n        While handlers can just return the HTML markup of a page they want to\n        send as a string if non-HTML data is returned they need to create a\n        complete response object, or the returned data will not be correctly\n        interpreted by the clients.\n\n        :param str data: response body\n        :param int status: http status code\n        :param headers: HTTP headers to set on the response\n        :type headers: ``[(name, value)]``\n        :param collections.abc.Mapping cookies: cookies to set on the client\n        :returns: a response object.\n        :rtype: :class:`~odoo.http.Response`\n        \"\"\"\n        response = Response(data, status=status, headers=headers)\n        if cookies:\n            for k, v in cookies.items():\n                response.set_cookie(k, v)\n        return response\n\n"
            },
            {
                "name": "request.update_context",
                "code": "f update_context(self, **overrides):\n        \"\"\"\n        Override the environment context of the current request with the\n        values of ``overrides``. To replace the entire context, please\n        use :meth:`~update_env` instead.\n        \"\"\"\n        self.update_env(context=dict(self.env.context, **overrides))\n\n"
            },
            {
                "name": "self._invoice_get_page_view_values",
                "code": "def _invoice_get_page_view_values(self, invoice, access_token, **kwargs):\n        values = {\n            'page_name': 'invoice',\n            'invoice': invoice,\n        }\n        return self._get_page_view_values(invoice, access_token, values, 'my_invoices_history', False, **kwargs)"
            },
            {
                "name": "request.render",
                "code": "f render(self):\n        \"\"\" Renders the Response's template, returns the result. \"\"\"\n        self.qcontext['request'] = request\n        return request.env[\"ir.ui.view\"]._render_template(self.template, self.qcontext)\n\n"
            }
        ],
        "third_party": [
            "self._document_check_access",
            "invoice_sudo._get_invoice_legal_documents",
            "invoice_sudo._get_invoice_report_filename",
            "_build_zip_from_attachments",
            "attachments.sudo",
            "_get_zip_headers",
            "self._get_http_headers",
            "headers.items",
            "self._show_report"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _get_demo_data_products(self, company=False)",
        "start_line": "61",
        "end_line": "70",
        "file_path": "addons/account/demo/account_demo.py",
        "docstring": "The function _get_demo_data_products searches for product templates based on the specified company's domain, updates the sale taxes for these products if the company's account_sale_tax_id is set, and updates the purchase taxes if the company's account_purchase_tax_id is set.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "96b0cb47d711",
        "ground_truth": "def _get_demo_data_products(self, company=False):\n    prod_templates = self.env['product.product'].search(self.env['product.product']._check_company_domain(company))\n    if self.env.company.account_sale_tax_id:\n        prod_templates_sale = prod_templates.filtered(\n            lambda p: not p.taxes_id.filtered_domain(p.taxes_id._check_company_domain(company)))\n        prod_templates_sale.write({'taxes_id': [Command.link(self.env.company.account_sale_tax_id.id)]})\n    if self.env.company.account_purchase_tax_id:\n        prod_templates_purchase = prod_templates.filtered(\n            lambda p: not p.supplier_taxes_id.filtered_domain(p.taxes_id._check_company_domain(company)))\n        prod_templates_purchase.write({'supplier_taxes_id': [Command.link(self.env.company.account_purchase_tax_id.id)]})",
        "import_statements": [
            "import logging",
            "import time",
            "from datetime import timedelta",
            "from dateutil.relativedelta import relativedelta",
            "from odoo import api, fields, models, Command",
            "from odoo.tools.misc import file_open, formatLang",
            "from odoo.exceptions import UserError, ValidationError"
        ],
        "reference_api": [
            "Command.link",
            "filtered_domain",
            "_check_company_domain",
            "prod_templates.filtered",
            "prod_templates_sale.write",
            "search",
            "prod_templates_purchase.write"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "search",
            "_check_company_domain",
            "prod_templates.filtered",
            "filtered_domain",
            "_check_company_domain",
            "prod_templates_sale.write",
            "Command.link",
            "prod_templates.filtered",
            "filtered_domain",
            "_check_company_domain",
            "prod_templates_purchase.write",
            "Command.link"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _get_demo_account(self, xml_id, account_type, company)",
        "start_line": "470",
        "end_line": "491",
        "file_path": "addons/account/demo/account_demo.py",
        "docstring": "The function _get_demo_account searches for a demo account based on the provided xml_id, account_type, and company. It first tries to find the account using the company's ID and the xml_id in the 'ir.model.data' model. If not found, it searches for an account matching the account_type within the company's domain. If still not found, it returns the first account within the company's domain.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "3a9ca1606049",
        "ground_truth": "def _get_demo_account(self, xml_id, account_type, company):\n    \"\"\"Find the most appropriate account possible for demo data creation.\n    :param xml_id (str): the xml_id of the account template in the generic coa\n    :param account_type (str): the full xml_id of the account type wanted\n    :param company (Model<res.company>): the company for which we search the account\n    :return (Model<account.account>): the most appropriate record found\n    \"\"\"\n    return (\n        self.env['account.account'].browse(self.env['ir.model.data'].sudo().search([\n            ('name', '=', '%d_%s' % (company.id, xml_id)),\n            ('model', '=', 'account.account'),\n            ('module', '=like', 'l10n%')\n        ], limit=1).res_id)\n        or self.env['account.account'].search([\n            *self.env['account.account']._check_company_domain(company),\n            ('account_type', '=', account_type),\n        ], limit=1)\n        or self.env['account.account'].search([\n            *self.env['account.account']._check_company_domain(company),\n        ], limit=1)\n    )",
        "import_statements": [
            "import logging",
            "import time",
            "from datetime import timedelta",
            "from dateutil.relativedelta import relativedelta",
            "from odoo import api, fields, models, Command",
            "from odoo.tools.misc import file_open, formatLang",
            "from odoo.exceptions import UserError, ValidationError"
        ],
        "reference_api": [
            "search",
            "_check_company_domain",
            "sudo",
            "browse"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "browse",
            "search",
            "sudo",
            "search",
            "_check_company_domain",
            "search",
            "_check_company_domain"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _check_account_type_unique_current_year_earning(self)",
        "start_line": "33",
        "end_line": "41",
        "file_path": "addons/account/models/account_account.py",
        "docstring": "The function _check_account_type_unique_current_year_earning ensures that there is only one account with the \"Current Year Earnings\" type for each company. It retrieves accounts of this type grouped by company and raises a ValidationError if more than one such account exists for any company.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e9e5339e18c6",
        "ground_truth": "def _check_account_type_unique_current_year_earning(self):\n    result = self._read_group(\n        domain=[('account_type', '=', 'equity_unaffected')],\n        groupby=['company_id'],\n        aggregates=['id:recordset'],\n        having=[('__count', '>', 1)],\n    )\n    for _company, account_unaffected_earnings in result:\n        raise ValidationError(_('You cannot have more than one account with \"Current Year Earnings\" as type. (accounts: %s)', [a.code for a in account_unaffected_earnings]))",
        "import_statements": [
            "from contextlib import nullcontext",
            "from odoo import api, fields, models, _, tools, Command",
            "from odoo.osv import expression",
            "from odoo.exceptions import UserError, ValidationError",
            "from odoo.tools.sql import SQL",
            "from bisect import bisect_left",
            "from collections import defaultdict",
            "import logging",
            "import re"
        ],
        "reference_api": [
            "self._read_group",
            "_",
            "ValidationError"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self._read_group",
            "ValidationError",
            "_"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None)",
        "start_line": "563",
        "end_line": "576",
        "file_path": "addons/account/models/account_account.py",
        "docstring": "The function _name_search searches for records based on a provided name and domain. If no name is given and specific context values are present, it orders accounts by frequency for a partner. Otherwise, it constructs a search domain based on the name and operator, combines it with the given domain, and performs the search with optional limit and order parameters.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "76c5df1e2eb0",
        "ground_truth": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):\n    if not name and self._context.get('partner_id') and self._context.get('move_type'):\n        return self._order_accounts_by_frequency_for_partner(\n                        self.env.company.id, self._context.get('partner_id'), self._context.get('move_type'))\n    domain = domain or []\n    if name:\n        if operator in ('=', '!='):\n            name_domain = ['|', ('code', '=', name.split(' ')[0]), ('name', operator, name)]\n        else:\n            name_domain = ['|', ('code', '=ilike', name.split(' ')[0] + '%'), ('name', operator, name)]\n        if operator in expression.NEGATIVE_TERM_OPERATORS:\n            name_domain = ['&', '!'] + name_domain[1:]\n        domain = expression.AND([name_domain, domain])\n    return self._search(domain, limit=limit, order=order)",
        "import_statements": [
            "from contextlib import nullcontext",
            "from odoo import api, fields, models, _, tools, Command",
            "from odoo.osv import expression",
            "from odoo.exceptions import UserError, ValidationError",
            "from odoo.tools.sql import SQL",
            "from bisect import bisect_left",
            "from collections import defaultdict",
            "import logging",
            "import re"
        ],
        "reference_api": [
            "self._search",
            "name.split",
            "get",
            "expression.AND",
            "self._order_accounts_by_frequency_for_partner"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "get",
            "get",
            "self._order_accounts_by_frequency_for_partner",
            "get",
            "get",
            "name.split",
            "name.split",
            "expression.AND",
            "self._search"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def copy_translations(self, new, excluded=())",
        "start_line": "619",
        "end_line": "626",
        "file_path": "addons/account/models/account_account.py",
        "docstring": "The function copy_translations copies translations from the current record to a new one, excluding specified fields and always excluding the 'name' field. If the new record's name follows a specific pattern, it updates the translations for the name field in the cache to reflect the new name format.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7b50a83ea003",
        "ground_truth": "def copy_translations(self, new, excluded=()):\n    super().copy_translations(new, excluded=tuple(excluded)+('name',))\n    if new.name == _('%s (copy)', self.name):\n        name_field = self._fields['name']\n        self.env.cache.update_raw(new, name_field, [{\n            lang: _('%s (copy)', tr)\n            for lang, tr in name_field._get_stored_translations(self).items()\n        }], dirty=True)",
        "import_statements": [
            "from contextlib import nullcontext",
            "from odoo import api, fields, models, _, tools, Command",
            "from odoo.osv import expression",
            "from odoo.exceptions import UserError, ValidationError",
            "from odoo.tools.sql import SQL",
            "from bisect import bisect_left",
            "from collections import defaultdict",
            "import logging",
            "import re"
        ],
        "reference_api": [
            "super",
            "tuple",
            "copy_translations",
            "_",
            "update_raw",
            "name_field._get_stored_translations",
            "items"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "copy_translations",
                "code": "def copy_translations(self, new, excluded=()):\n        super().copy_translations(new, excluded=tuple(excluded)+('name',))\n        if new.name == _('%s (copy)', self.name):\n            name_field = self._fields['name']\n            self.env.cache.update_raw(new, name_field, [{\n                lang: _('%s (copy)', tr)\n                for lang, tr in name_field._get_stored_translations(self).items()\n            }], dirty=True)"
            }
        ],
        "third_party": [
            "_",
            "update_raw",
            "_",
            "items",
            "name_field._get_stored_translations"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def action_view_invoice(self)",
        "start_line": "82",
        "end_line": "103",
        "file_path": "addons/account/models/account_analytic_account.py",
        "docstring": "The function action_view_invoice ensures a single record context, searches for account move lines related to sale types, adds conditions for the current record's ID and analytic accounts, executes the query to get distinct move IDs, and returns an action dictionary to display customer invoices in tree and form views with specific context and domain settings.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "125114ff7f53",
        "ground_truth": "def action_view_invoice(self):\n    self.ensure_one()\n    query = self.env['account.move.line']._search([('move_id.move_type', 'in', self.env['account.move'].get_sale_types())])\n    query.add_where(\n        SQL(\n            \"%s && %s\",\n            [str(self.id)],\n            self.env['account.move.line']._query_analytic_accounts(),\n        )\n    )\n    query_string, query_param = query.select('DISTINCT account_move_line.move_id')\n    self._cr.execute(query_string, query_param)\n    move_ids = [line.get('move_id') for line in self._cr.dictfetchall()]\n    result = {\n        \"type\": \"ir.actions.act_window\",\n        \"res_model\": \"account.move\",\n        \"domain\": [('id', 'in', move_ids)],\n        \"context\": {\"create\": False, 'default_move_type': 'out_invoice'},\n        \"name\": _(\"Customer Invoices\"),\n        'view_mode': 'tree,form',\n    }\n    return result",
        "import_statements": [
            "from odoo import api, fields, models, _",
            "from odoo.tools import SQL"
        ],
        "reference_api": [
            "self.ensure_one",
            "get_sale_types",
            "query.select",
            "query.add_where",
            "execute",
            "dictfetchall",
            "_",
            "_search",
            "SQL",
            "_query_analytic_accounts",
            "str",
            "line.get"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.ensure_one",
            "_search",
            "get_sale_types",
            "query.add_where",
            "SQL",
            "_query_analytic_accounts",
            "query.select",
            "execute",
            "line.get",
            "dictfetchall",
            "_"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def action_view_vendor_bill(self)",
        "start_line": "105",
        "end_line": "126",
        "file_path": "addons/account/models/account_analytic_account.py",
        "docstring": "The function action_view_vendor_bill ensures a single record context, searches for account move lines related to purchase types and the current record's ID, and retrieves distinct move IDs. It then constructs and returns an action to display vendor bills in a tree and form view, with a specific context to prevent creation and set the default move type to 'in_invoice'.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "b836e6e7ea5d",
        "ground_truth": "def action_view_vendor_bill(self):\n    self.ensure_one()\n    query = self.env['account.move.line']._search([('move_id.move_type', 'in', self.env['account.move'].get_purchase_types())])\n    query.add_where(\n        SQL(\n            \"%s && %s\",\n            [str(self.id)],\n            self.env['account.move.line']._query_analytic_accounts(),\n        )\n    )\n    query_string, query_param = query.select('DISTINCT account_move_line.move_id')\n    self._cr.execute(query_string, query_param)\n    move_ids = [line.get('move_id') for line in self._cr.dictfetchall()]\n    result = {\n        \"type\": \"ir.actions.act_window\",\n        \"res_model\": \"account.move\",\n        \"domain\": [('id', 'in', move_ids)],\n        \"context\": {\"create\": False, 'default_move_type': 'in_invoice'},\n        \"name\": _(\"Vendor Bills\"),\n        'view_mode': 'tree,form',\n    }\n    return result",
        "import_statements": [
            "from odoo import api, fields, models, _",
            "from odoo.tools import SQL"
        ],
        "reference_api": [
            "self.ensure_one",
            "query.select",
            "query.add_where",
            "execute",
            "dictfetchall",
            "_",
            "get_purchase_types",
            "_search",
            "SQL",
            "_query_analytic_accounts",
            "str",
            "line.get"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.ensure_one",
            "_search",
            "get_purchase_types",
            "query.add_where",
            "SQL",
            "_query_analytic_accounts",
            "query.select",
            "execute",
            "line.get",
            "dictfetchall",
            "_"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def write(self, values)",
        "start_line": "347",
        "end_line": "354",
        "file_path": "addons/account/models/account_bank_statement.py",
        "docstring": "The function write modifies records with the provided values. If multiple records are being modified and 'attachment_ids' is among the values, it removes 'attachment_ids' from the values. It then checks attachments within a context manager before calling the parent class's write method and returning the result.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "6b78df61aba1",
        "ground_truth": "def write(self, values):\n    if len(self) != 1 and 'attachment_ids' in values:\n        values.pop('attachment_ids')\n    container = {'records': self}\n    with self._check_attachments(container, [values]):\n        result = super().write(values)\n    return result",
        "import_statements": [
            "from contextlib import contextmanager",
            "from odoo import api, fields, models, _, Command",
            "from odoo.exceptions import UserError",
            "from odoo.tools import create_index",
            "from odoo.tools.misc import formatLang"
        ],
        "reference_api": [
            "super",
            "self._check_attachments",
            "write",
            "len",
            "values.pop"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "values.pop",
                "code": "def pop(self, key, default=None):\n        raise NotImplementedError(\"'pop' not supported on frozendict\")"
            },
            {
                "name": "write",
                "code": "def write(self, values):\n        if len(self) != 1 and 'attachment_ids' in values:\n            values.pop('attachment_ids')\n\n        container = {'records': self}\n        with self._check_attachments(container, [values]):\n            result = super().write(values)\n        return result"
            }
        ],
        "third_party": [
            "self._check_attachments"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _find_or_create_bank_account(self)",
        "start_line": "450",
        "end_line": "470",
        "file_path": "addons/account/models/account_bank_statement_line.py",
        "docstring": "The function _find_or_create_bank_account ensures a single record context, checks a configuration parameter to determine if bank account creation should be skipped, and returns an empty bank account record if true. If not, it searches for an existing bank account with the same account number and partner ID, creating a new one if none is found. The function returns the bank account filtered by the company ID.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8e6b94faa755",
        "ground_truth": "def _find_or_create_bank_account(self):\n    self.ensure_one()\n    if str2bool(self.env['ir.config_parameter'].sudo().get_param(\"account.skip_create_bank_account_on_reconcile\")):\n        return self.env['res.partner.bank']\n    # There is a sql constraint on res.partner.bank ensuring an unique pair <partner, account number>.\n    # Since it's not dependent of the company, we need to search on others company too to avoid the creation\n    # of an extra res.partner.bank raising an error coming from this constraint.\n    # However, at the end, we need to filter out the results to not trigger the check_company when trying to\n    # assign a res.partner.bank owned by another company.\n    bank_account = self.env['res.partner.bank'].sudo().with_context(active_test=False).search([\n        ('acc_number', '=', self.account_number),\n        ('partner_id', '=', self.partner_id.id),\n    ])\n    if not bank_account:\n        bank_account = self.env['res.partner.bank'].create({\n            'acc_number': self.account_number,\n            'partner_id': self.partner_id.id,\n            'journal_id': None,\n        })\n    return bank_account.filtered(lambda x: x.company_id in (False, self.company_id))",
        "import_statements": [
            "from odoo import api, Command, fields, models, _",
            "from odoo.exceptions import UserError, ValidationError",
            "from odoo.osv.expression import get_unaccent_wrapper",
            "from odoo.tools.misc import str2bool",
            "from odoo.addons.base.models.res_bank import sanitize_account_number",
            "from xmlrpc.client import MAXINT",
            "from odoo.tools import create_index"
        ],
        "reference_api": [
            "self.ensure_one",
            "with_context",
            "sudo",
            "create",
            "search",
            "bank_account.filtered",
            "str2bool",
            "get_param"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "str2bool",
                "code": "def str2bool(s, default=None):\n    s = ustr(s).lower()\n    y = 'y yes 1 true t on'.split()\n    n = 'n no 0 false f off'.split()\n    if s not in (y + n):\n        if default is None:\n            raise ValueError('Use 0/1/yes/no/true/false/on/off')\n        return bool(default)\n    return s in y"
            }
        ],
        "third_party": [
            "self.ensure_one",
            "get_param",
            "sudo",
            "search",
            "with_context",
            "sudo",
            "create",
            "bank_account.filtered"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _prepare_counterpart_amounts_using_st_line_rate(self, currency, balance, amount_currency)",
        "start_line": "544",
        "end_line": "590",
        "file_path": "addons/account/models/account_bank_statement_line.py",
        "docstring": "The function _prepare_counterpart_amounts_using_st_line_rate calculates the amounts in different currencies for a given transaction. It ensures a single record context, retrieves relevant accounting amounts and currencies, and computes the transaction amount, journal amount, and company amount using various exchange rates. Depending on the currency type, it adjusts the transaction amount and balance accordingly and returns these values in a dictionary.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1b7a0f87b520",
        "ground_truth": "def _prepare_counterpart_amounts_using_st_line_rate(self, currency, balance, amount_currency):\n    \"\"\" Convert the amounts passed as parameters to the statement line currency using the rates provided by the\n    bank. The computed amounts are the one that could be set on the statement line as a counterpart journal item\n    to fully paid the provided amounts as parameters.\n    :param currency:        The currency in which is expressed 'amount_currency'.\n    :param balance:         The amount expressed in company currency. Only needed when the currency passed as\n                            parameter is neither the statement line's foreign currency, neither the journal's\n                            currency.\n    :param amount_currency: The amount expressed in the 'currency' passed as parameter.\n    :return:                A python dictionary containing:\n        * balance:          The amount to consider expressed in company's currency.\n        * amount_currency:  The amount to consider expressed in statement line's foreign currency.\n    \"\"\"\n    self.ensure_one()\n    transaction_amount, transaction_currency, journal_amount, journal_currency, company_amount, company_currency \\\n        = self._get_accounting_amounts_and_currencies()\n    rate_journal2foreign_curr = journal_amount and abs(transaction_amount) / abs(journal_amount)\n    rate_comp2journal_curr = company_amount and abs(journal_amount) / abs(company_amount)\n    if currency == transaction_currency:\n        trans_amount_currency = amount_currency\n        if rate_journal2foreign_curr:\n            journ_amount_currency = journal_currency.round(trans_amount_currency / rate_journal2foreign_curr)\n        else:\n            journ_amount_currency = 0.0\n        if rate_comp2journal_curr:\n            new_balance = company_currency.round(journ_amount_currency / rate_comp2journal_curr)\n        else:\n            new_balance = 0.0\n    elif currency == journal_currency:\n        trans_amount_currency = transaction_currency.round(amount_currency * rate_journal2foreign_curr)\n        if rate_comp2journal_curr:\n            new_balance = company_currency.round(amount_currency / rate_comp2journal_curr)\n        else:\n            new_balance = 0.0\n    else:\n        journ_amount_currency = journal_currency.round(balance * rate_comp2journal_curr)\n        trans_amount_currency = transaction_currency.round(journ_amount_currency * rate_journal2foreign_curr)\n        new_balance = balance\n    return {\n        'amount_currency': trans_amount_currency,\n        'balance': new_balance,\n    }",
        "import_statements": [
            "from odoo import api, Command, fields, models, _",
            "from odoo.exceptions import UserError, ValidationError",
            "from odoo.osv.expression import get_unaccent_wrapper",
            "from odoo.tools.misc import str2bool",
            "from odoo.addons.base.models.res_bank import sanitize_account_number",
            "from xmlrpc.client import MAXINT",
            "from odoo.tools import create_index"
        ],
        "reference_api": [
            "self.ensure_one",
            "transaction_currency.round",
            "company_currency.round",
            "abs",
            "journal_currency.round",
            "self._get_accounting_amounts_and_currencies"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self._get_accounting_amounts_and_currencies",
                "code": "def _get_accounting_amounts_and_currencies(self):\n        \"\"\" Retrieve the transaction amount, journal amount and the company amount with their corresponding currencies\n        from the journal entry linked to the statement line.\n        All returned amounts will be positive for an inbound transaction, negative for an outbound one.\n\n        :return: (\n            transaction_amount, transaction_currency,\n            journal_amount, journal_currency,\n            company_amount, company_currency,\n        )\n        \"\"\"\n        self.ensure_one()\n        liquidity_line, suspense_line, other_lines = self._seek_for_lines()\n        if suspense_line and not other_lines:\n            transaction_amount = -suspense_line.amount_currency\n            transaction_currency = suspense_line.currency_id\n        else:\n            # In case of to_check or partial reconciliation, we can't trust the suspense line.\n            transaction_amount = self.amount_currency if self.foreign_currency_id else self.amount\n            transaction_currency = self.foreign_currency_id or liquidity_line.currency_id\n        return (\n            transaction_amount,\n            transaction_currency,\n            sum(liquidity_line.mapped('amount_currency')),\n            liquidity_line.currency_id,\n            sum(liquidity_line.mapped('balance')),\n            liquidity_line.company_currency_id,\n        )"
            }
        ],
        "third_party": [
            "self.ensure_one",
            "journal_currency.round",
            "company_currency.round",
            "transaction_currency.round",
            "company_currency.round",
            "journal_currency.round",
            "transaction_currency.round"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _compute_outbound_payment_method_line_ids(self)",
        "start_line": "387",
        "end_line": "396",
        "file_path": "addons/account/models/account_journal.py",
        "docstring": "This function updates the outbound payment methods for journals. For each journal, it first clears existing payment method lines. If the journal type is 'bank' or 'cash', it retrieves the default outbound payment methods and creates new entries for each method. Finally, it assigns the updated list of payment method line commands to the journal.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9535776f8f98",
        "ground_truth": "def _compute_outbound_payment_method_line_ids(self):\n    for journal in self:\n        pay_method_line_ids_commands = [Command.clear()]\n        if journal.type in ('bank', 'cash'):\n            default_methods = journal._default_outbound_payment_methods()\n            pay_method_line_ids_commands += [Command.create({\n                'name': pay_method.name,\n                'payment_method_id': pay_method.id,\n            }) for pay_method in default_methods]\n        journal.outbound_payment_method_line_ids = pay_method_line_ids_commands",
        "import_statements": [
            "from ast import literal_eval",
            "from odoo import api, Command, fields, models, _",
            "from odoo.exceptions import UserError, ValidationError",
            "from odoo.addons.base.models.res_bank import sanitize_account_number",
            "from odoo.tools import remove_accents, groupby",
            "from collections import defaultdict",
            "import logging",
            "import re"
        ],
        "reference_api": [
            "Command.create",
            "journal._default_outbound_payment_methods",
            "Command.clear"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "journal._default_outbound_payment_methods",
                "code": "def _default_outbound_payment_methods(self):\n        return self.env.ref('account.account_payment_method_manual_out')"
            }
        ],
        "third_party": [
            "Command.clear",
            "Command.create"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _compute_date(self)",
        "start_line": "664",
        "end_line": "678",
        "file_path": "addons/account/models/account_move.py",
        "docstring": "This function computes the date for each move. If the move has no invoice date and no existing date, it sets the date to today's date. If an invoice date exists, it checks if the move is not a sale document and calculates the accounting date based on the invoice date and tax report impact. If the calculated accounting date differs from the current date, it updates the move's date and schedules the recalculation of related fields in the environment.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "f5b9d4115264",
        "ground_truth": "def _compute_date(self):\n    for move in self:\n        if not move.invoice_date:\n            if not move.date:\n                move.date = fields.Date.context_today(self)\n            continue\n        accounting_date = move.invoice_date\n        if not move.is_sale_document(include_receipts=True):\n            accounting_date = move._get_accounting_date(move.invoice_date, move._affect_tax_report())\n        if accounting_date and accounting_date != move.date:\n            move.date = accounting_date\n            # _affect_tax_report may trigger premature recompute of line_ids.date\n            self.env.add_to_compute(move.line_ids._fields['date'], move.line_ids)\n            # might be protected because `_get_accounting_date` requires the `name`\n            self.env.add_to_compute(self._fields['name'], move)",
        "import_statements": [
            "from collections import defaultdict",
            "from contextlib import ExitStack, contextmanager",
            "from datetime import date, timedelta",
            "from dateutil.relativedelta import relativedelta",
            "from hashlib import sha256",
            "from json import dumps",
            "import logging",
            "from markupsafe import Markup",
            "import math",
            "import psycopg2",
            "import re",
            "from textwrap import shorten",
            "from odoo import api, fields, models, _, Command",
            "from odoo.addons.account.tools import format_structured_reference_iso",
            "from odoo.exceptions import UserError, ValidationError, AccessError, RedirectWarning",
            "from odoo.tools import (\n    date_utils,\n    email_re,\n    email_split,\n    float_compare,\n    float_is_zero,\n    float_repr,\n    format_amount,\n    format_date,\n    formatLang,\n    frozendict,\n    get_lang,\n    groupby,\n    index_exists,\n    is_html_empty,\n    create_index,\n)"
        ],
        "reference_api": [
            "context_today",
            "move._affect_tax_report",
            "move._get_accounting_date",
            "add_to_compute",
            "move.is_sale_document"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "move.is_sale_document",
                "code": "f is_sale_document(self, include_receipts=False):\n        return self.move_type in self.get_sale_types(include_receipts)\n\n"
            },
            {
                "name": "move._get_accounting_date",
                "code": "f _get_accounting_date(self, invoice_date, has_tax):\n        \"\"\"Get correct accounting date for previous periods, taking tax lock date into account.\n        When registering an invoice in the past, we still want the sequence to be increasing.\n        We then take the last day of the period, depending on the sequence format.\n\n        If there is a tax lock date and there are taxes involved, we register the invoice at the\n        last date of the first open period.\n        :param invoice_date (datetime.date): The invoice date\n        :param has_tax (bool): Iff any taxes are involved in the lines of the invoice\n        :return (datetime.date):\n        \"\"\"\n        lock_dates = self._get_violated_lock_dates(invoice_date, has_tax)\n        today = fields.Date.context_today(self)\n        highest_name = self.highest_name or self._get_last_sequence(relaxed=True)\n        number_reset = self._deduce_sequence_number_reset(highest_name)\n        if lock_dates:\n            invoice_date = lock_dates[-1][0] + timedelta(days=1)\n        if self.is_sale_document(include_receipts=True):\n            if lock_dates:\n                if not highest_name or number_reset == 'month':\n                    return min(today, date_utils.get_month(invoice_date)[1])\n                elif number_reset == 'year':\n                    return min(today, date_utils.end_of(invoice_date, 'year'))\n        else:\n            if not highest_name or number_reset == 'month':\n                if (today.year, today.month) > (invoice_date.year, invoice_date.month):\n                    return date_utils.get_month(invoice_date)[1]\n                else:\n                    return max(invoice_date, today)\n            elif number_reset == 'year':\n                if today.year > invoice_date.year:\n                    return date(invoice_date.year, 12, 31)\n                else:\n                    return max(invoice_date, today)\n        return invoice_date\n\n"
            },
            {
                "name": "move._affect_tax_report",
                "code": "f _affect_tax_report(self):\n        return any(line._affect_tax_report() for line in (self.line_ids | self.invoice_line_ids))\n\n"
            }
        ],
        "third_party": [
            "context_today",
            "add_to_compute",
            "add_to_compute"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def _compute_invoice_payment_term_id(self)",
        "start_line": "872",
        "end_line": "879",
        "file_path": "addons/account/models/account_move.py",
        "docstring": "This function sets the invoice payment term for moves based on their type and the partner's payment terms. For sales documents with a defined customer payment term, it assigns the customer's payment term. For purchase documents with a defined supplier payment term, it assigns the supplier's payment term. If neither condition is met, it sets the invoice payment term to False.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "af48962a564f",
        "ground_truth": "def _compute_invoice_payment_term_id(self):\n    for move in self:\n        if move.is_sale_document(include_receipts=True) and move.partner_id.property_payment_term_id:\n            move.invoice_payment_term_id = move.partner_id.property_payment_term_id\n        elif move.is_purchase_document(include_receipts=True) and move.partner_id.property_supplier_payment_term_id:\n            move.invoice_payment_term_id = move.partner_id.property_supplier_payment_term_id\n        else:\n            move.invoice_payment_term_id = False",
        "import_statements": [
            "from collections import defaultdict",
            "from contextlib import ExitStack, contextmanager",
            "from datetime import date, timedelta",
            "from dateutil.relativedelta import relativedelta",
            "from hashlib import sha256",
            "from json import dumps",
            "import logging",
            "from markupsafe import Markup",
            "import math",
            "import psycopg2",
            "import re",
            "from textwrap import shorten",
            "from odoo import api, fields, models, _, Command",
            "from odoo.addons.account.tools import format_structured_reference_iso",
            "from odoo.exceptions import UserError, ValidationError, AccessError, RedirectWarning",
            "from odoo.tools import (\n    date_utils,\n    email_re,\n    email_split,\n    float_compare,\n    float_is_zero,\n    float_repr,\n    format_amount,\n    format_date,\n    formatLang,\n    frozendict,\n    get_lang,\n    groupby,\n    index_exists,\n    is_html_empty,\n    create_index,\n)"
        ],
        "reference_api": [
            "move.is_purchase_document",
            "move.is_sale_document"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "move.is_sale_document",
                "code": "f is_sale_document(self, include_receipts=False):\n        return self.move_type in self.get_sale_types(include_receipts)\n\n"
            },
            {
                "name": "move.is_purchase_document",
                "code": "f is_purchase_document(self, include_receipts=False):\n        return self.move_type in self.get_purchase_types(include_receipts)\n\n"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": " def _compute_tax_group_id(self)",
        "start_line": "222",
        "end_line": "238",
        "file_path": "addons/account/models/account_tax.py",
        "docstring": "This function assigns the appropriate tax group to each tax based on the tax's country and company. It first categorizes taxes by their country and company. For each group, it searches for a matching tax group with the same country and company. If no exact match is found, it searches for a tax group without a specified country but within the same company.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a071628f8e36",
        "ground_truth": "def _compute_tax_group_id(self):\n    by_country_company = defaultdict(self.browse)\n    for tax in self:\n        if (\n            not tax.tax_group_id\n            or tax.tax_group_id.country_id != tax.country_id\n            or tax.tax_group_id.company_id != tax.company_id\n        ):\n            by_country_company[(tax.country_id, tax.company_id)] += tax\n    for (country, company), taxes in by_country_company.items():\n        taxes.tax_group_id = self.env['account.tax.group'].search([\n            *self.env['account.tax.group']._check_company_domain(company),\n            ('country_id', '=', country.id),\n        ], limit=1) or self.env['account.tax.group'].search([\n            *self.env['account.tax.group']._check_company_domain(company),\n            ('country_id', '=', False),\n        ], limit=1)",
        "import_statements": [
            "from odoo import api, fields, models, _, Command",
            "from odoo.osv import expression",
            "from odoo.tools.float_utils import float_round",
            "from odoo.exceptions import UserError, ValidationError",
            "from odoo.tools.misc import clean_context, formatLang",
            "from odoo.tools import frozendict, groupby, split_every",
            "from collections import defaultdict",
            "from markupsafe import Markup",
            "import ast",
            "import math",
            "import re"
        ],
        "reference_api": [
            "search",
            "defaultdict",
            "_check_company_domain",
            "by_country_company.items"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "defaultdict",
            "by_country_company.items",
            "search",
            "_check_company_domain",
            "search",
            "_check_company_domain"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def login_upload_module(self, module_file, url, login, password, db, force=False)",
        "start_line": "26",
        "end_line": "43",
        "file_path": "odoo/cli/deploy.py",
        "docstring": "This function uploads a module file to a specified server. It first sets the database in the session by accessing the login URL. Then, it prepares the POST request data, including login credentials, database name, and an optional force flag. The module file is read and uploaded to the server's 'base_import_module/login_upload' endpoint. If the server does not have the required module installed or is outdated, it raises an exception. The function returns the server's response text.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5514fee4f39c",
        "ground_truth": "def login_upload_module(self, module_file, url, login, password, db, force=False):\n    print(\"Uploading module file...\")\n    self.session.get(f'{url}/web/login?db={db}', allow_redirects=False)  # this set the db in the session\n    endpoint = url + '/base_import_module/login_upload'\n    post_data = {\n        'login': login,\n        'password': password,\n        'db': db,\n        'force': '1' if force else '',\n    }\n    with open(module_file, 'rb') as f:\n        res = self.session.post(endpoint, files={'mod_file': f}, data=post_data)\n    if res.status_code == 404:\n        raise Exception(\n            \"The server '%s' does not have the 'base_import_module' installed or is not up-to-date.\" % url)\n    res.raise_for_status()\n    return res.text",
        "import_statements": [
            "import argparse",
            "import os",
            "import requests",
            "import sys",
            "import tempfile",
            "import zipfile",
            "from pathlib import Path"
        ],
        "reference_api": [
            "res.raise_for_status",
            "print",
            "get",
            "post",
            "Exception",
            "open"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "get",
            "post",
            "res.raise_for_status"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def import_translation()",
        "start_line": "113",
        "end_line": "122",
        "file_path": "odoo/cli/server.py",
        "docstring": "This function imports translations into the Odoo system. It retrieves configuration settings for the database name and whether to overwrite existing translations. It then creates a new database registry and uses a cursor to initialize a TranslationImporter. The importer loads translation files based on the specified configuration and saves the translations, with the option to overwrite existing ones.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "781e2a94c6d2",
        "ground_truth": "def import_translation():\n    config = odoo.tools.config\n    overwrite = config[\"overwrite_existing_translations\"]\n    dbname = config['db_name']\n     registry = odoo.modules.registry.Registry.new(dbname)\n    with registry.cursor() as cr:\n        translation_importer = odoo.tools.translate.TranslationImporter(cr)\n        translation_importer.load_file(config[\"translate_in\"], config[\"language\"])\n        translation_importer.save(overwrite=overwrite)",
        "import_statements": [
            "import atexit",
            "import csv",
            "import logging",
            "import os",
            "import re",
            "import sys",
            "from pathlib import Path",
            "from psycopg2 import ProgrammingError, errorcodes",
            "import odoo"
        ],
        "reference_api": [
            "registry.cursor",
            "new",
            "TranslationImporter",
            "translation_importer.save",
            "translation_importer.load_file"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "new",
            "registry.cursor",
            "TranslationImporter",
            "translation_importer.load_file",
            "translation_importer.save"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "odoo/odoo",
        "function_declaration": "def add_child(self, name, info)",
        "start_line": "151",
        "end_line": "160",
        "file_path": "odoo/modules/graph.py",
        "docstring": "This function adds a child node to the current node. It creates a new node with the given name and info, sets its depth, and appends it to the children list if it's not already present. It also inherits certain attributes from the parent if they exist. Finally, it sorts the children by name and returns the new node.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "6ac19b8ee563",
        "ground_truth": "def add_child(self, name, info):\n    node = Node(name, self.graph, info)\n    node.depth = self.depth + 1\n    if node not in self.children:\n        self.children.append(node)\n    for attr in ('init', 'update', 'demo'):\n        if hasattr(self, attr):\n            setattr(node, attr, True)\n    self.children.sort(key=lambda x: x.name)\n    return node",
        "import_statements": [
            "import functools",
            "import itertools",
            "import logging",
            "import odoo"
        ],
        "reference_api": [
            "hasattr",
            "Node",
            "append",
            "setattr",
            "sort"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Node",
            "append",
            "sort"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def build_result(account, dates, gl_entries)",
        "start_line": "77",
        "end_line": "103",
        "file_path": "erpnext/accounts/dashboard_chart_source/account_balance_timeline/account_balance_timeline.py",
        "docstring": "This function generates a financial report for a given account over specified dates using general ledger entries. It initializes the result with the dates and zeros for balances, determines the account's root type, and iterates through the entries, updating the balance for each date. If the root type is not \"Asset\" or \"Expense,\" it negates the balances. For \"Asset,\" \"Liability,\" and \"Equity\" accounts, it accumulates the balance over time. Finally, it returns the computed results.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ecff92e6f255",
        "ground_truth": "def build_result(account, dates, gl_entries):\n result = [[getdate(date), 0.0] for date in dates]\n root_type = frappe.get_cached_value(\"Account\", account, \"root_type\")\n  # start with the first date\n date_index = 0\n  # get balances in debit\n for entry in gl_entries:\n  # entry date is after the current pointer, so move the pointer forward\n  while getdate(entry.posting_date) > result[date_index][0]:\n   date_index += 1\n   result[date_index][1] += entry.debit - entry.credit\n  # if account type is credit, switch balances\n if root_type not in (\"Asset\", \"Expense\"):\n  for r in result:\n   r[1] = -1 * r[1]\n  # for balance sheet accounts, the totals are cumulative\n if root_type in (\"Asset\", \"Liability\", \"Equity\"):\n  for i, r in enumerate(result):\n   if i > 0:\n    r[1] = r[1] + result[i - 1][1]\n  return result",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.utils import add_to_date, formatdate, get_link_to_form, getdate, nowdate",
            "from frappe.utils.dashboard import cache_source",
            "from frappe.utils.dateutils import get_from_date_from_timespan, get_period_ending",
            "from frappe.utils.nestedset import get_descendants_of"
        ],
        "reference_api": [
            "enumerate",
            "getdate",
            "frappe.get_cached_value"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getdate",
            "frappe.get_cached_value",
            "getdate"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def validate_receivable_payable_account_type(self)",
        "start_line": "190",
        "end_line": "206",
        "file_path": "erpnext/accounts/doctype/account/account.py",
        "docstring": "This function validates the account type change for receivable and payable accounts. It compares the account type before and after the save operation. If the account type changes from \"Receivable\" or \"Payable\" to a non-receivable/payable type and there are existing general ledger entries for the account, it generates a warning message indicating potential issues in the \"Accounts\" report and adds a comment to the account record.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "0b19cef827c1",
        "ground_truth": "def validate_receivable_payable_account_type(self):\n doc_before_save = self.get_doc_before_save()\n receivable_payable_types = [\"Receivable\", \"Payable\"]\n if (\n  doc_before_save\n  and doc_before_save.account_type in receivable_payable_types\n  and doc_before_save.account_type != self.account_type\n ):\n  # check for ledger entries\n  if frappe.db.get_all(\"GL Entry\", filters={\"account\": self.name, \"is_cancelled\": 0}, limit=1):\n   msg = _(\n    \"There are ledger entries against this account. Changing {0} to non-{1} in live system will cause incorrect output in 'Accounts {2}' report\"\n   ).format(\n    frappe.bold(\"Account Type\"), doc_before_save.account_type, doc_before_save.account_type\n   )\n   frappe.msgprint(msg)\n   self.add_comment(\"Comment\", msg)",
        "import_statements": [
            "import frappe",
            "from frappe import _, throw",
            "from frappe.utils import cint, cstr",
            "from frappe.utils.nestedset import NestedSet, get_ancestors_of, get_descendants_of",
            "import erpnext"
        ],
        "reference_api": [
            "frappe.bold",
            "_",
            "self.get_doc_before_save",
            "self.add_comment",
            "get_all",
            "frappe.msgprint",
            "format"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.get_doc_before_save",
            "get_all",
            "_",
            "frappe.bold",
            "frappe.msgprint",
            "self.add_comment"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def validate_account_currency(self)",
        "start_line": "299",
        "end_line": "310",
        "file_path": "erpnext/accounts/doctype/account/account.py",
        "docstring": "This function validates and sets the currency for an account. It marks the currency as explicitly specified and assigns the company's default currency if none is provided. It checks for existing general ledger entries with a different currency and raises an error if the account currency differs from the ledger entries' currency, preventing changes after entries have been made with another currency.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "bd138a3f3ccd",
        "ground_truth": "def validate_account_currency(self):\n self.currency_explicitly_specified = True\n if not self.account_currency:\n  self.account_currency = frappe.get_cached_value(\"Company\", self.company, \"default_currency\")\n  self.currency_explicitly_specified = False\n gl_currency = frappe.db.get_value(\"GL Entry\", {\"account\": self.name}, \"account_currency\")\n if gl_currency and self.account_currency != gl_currency:\n  if frappe.db.get_value(\"GL Entry\", {\"account\": self.name}):\n   frappe.throw(_(\"Currency can not be changed after making entries using some other currency\"))",
        "import_statements": [
            "import frappe",
            "from frappe import _, throw",
            "from frappe.utils import cint, cstr",
            "from frappe.utils.nestedset import NestedSet, get_ancestors_of, get_descendants_of",
            "import erpnext"
        ],
        "reference_api": [
            "_",
            "frappe.throw",
            "frappe.get_cached_value",
            "get_value"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "frappe.get_cached_value",
            "get_value",
            "get_value",
            "frappe.throw",
            "_"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def aggregate_with_last_account_closing_balance(entries, accounting_dimensions)",
        "start_line": "63",
        "end_line": "83",
        "file_path": "erpnext/accounts/doctype/account_closing_balance/account_closing_balance.py",
        "docstring": "This function aggregates general ledger entries based on specified accounting dimensions. It initializes a dictionary to merge entries, iterating through each entry to generate a unique key and corresponding values. For each key, it updates the debit, credit, and their respective amounts in account currency. The function returns the dictionary containing the aggregated entries.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a8bea28f2b89",
        "ground_truth": "def aggregate_with_last_account_closing_balance(entries, accounting_dimensions):\n merged_entries = {}\n for entry in entries:\n  key, key_values = generate_key(entry, accounting_dimensions)\n  merged_entries.setdefault(\n   key,\n   {\n    \"debit\": 0,\n    \"credit\": 0,\n    \"debit_in_account_currency\": 0,\n    \"credit_in_account_currency\": 0,\n   },\n  )\n   merged_entries[key][\"dimensions\"] = key_values\n  merged_entries[key][\"debit\"] += entry.get(\"debit\")\n  merged_entries[key][\"credit\"] += entry.get(\"credit\")\n  merged_entries[key][\"debit_in_account_currency\"] += entry.get(\"debit_in_account_currency\")\n  merged_entries[key][\"credit_in_account_currency\"] += entry.get(\"credit_in_account_currency\")\n  return merged_entries",
        "import_statements": [
            "import frappe",
            "from frappe.model.document import Document",
            "from frappe.utils import cint, cstr",
            "from erpnext.accounts.doctype.accounting_dimension.accounting_dimension import (\n\tget_accounting_dimensions,\n)"
        ],
        "reference_api": [
            "generate_key",
            "entry.get",
            "merged_entries.setdefault"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "generate_key",
                "code": "def generate_key(entry, accounting_dimensions):\n\tkey = [\n\t\tcstr(entry.get(\"account\")),\n\t\tcstr(entry.get(\"account_currency\")),\n\t\tcstr(entry.get(\"cost_center\")),\n\t\tcstr(entry.get(\"project\")),\n\t\tcstr(entry.get(\"finance_book\")),\n\t\tcint(entry.get(\"is_period_closing_voucher_entry\")),\n\t]\n\n\tkey_values = {\n\t\t\"company\": cstr(entry.get(\"company\")),\n\t\t\"account\": cstr(entry.get(\"account\")),\n\t\t\"account_currency\": cstr(entry.get(\"account_currency\")),\n\t\t\"cost_center\": cstr(entry.get(\"cost_center\")),\n\t\t\"project\": cstr(entry.get(\"project\")),\n\t\t\"finance_book\": cstr(entry.get(\"finance_book\")),\n\t\t\"is_period_closing_voucher_entry\": cint(entry.get(\"is_period_closing_voucher_entry\")),\n\t}\n\tfor dimension in accounting_dimensions:\n\t\tkey.append(cstr(entry.get(dimension)))\n\t\tkey_values[dimension] = cstr(entry.get(dimension))\n\n\treturn tuple(key), key_values"
            }
        ],
        "third_party": [
            "merged_entries.setdefault",
            "entry.get",
            "entry.get",
            "entry.get",
            "entry.get"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def ensure_supplier_is_not_blocked(self)",
        "start_line": "149",
        "end_line": "167",
        "file_path": "erpnext/controllers/accounts_controller.py",
        "docstring": "This function checks if a supplier is blocked before proceeding with a transaction. It identifies whether the transaction is a supplier payment or a buying invoice and retrieves the supplier's information. If the supplier is on hold and the hold type matches the transaction type, it verifies the release date. If the supplier is still blocked, it raises an exception and displays a message indicating that the transaction cannot proceed.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "13c346120514",
        "ground_truth": "def ensure_supplier_is_not_blocked(self):\n is_supplier_payment = self.doctype == \"Payment Entry\" and self.party_type == \"Supplier\"\n is_buying_invoice = self.doctype in [\"Purchase Invoice\", \"Purchase Order\"]\n supplier = None\n supplier_name = None\n if is_buying_invoice or is_supplier_payment:\n  supplier_name = self.supplier if is_buying_invoice else self.party\n  supplier = frappe.get_doc(\"Supplier\", supplier_name)\n if supplier and supplier_name and supplier.on_hold:\n  if (is_buying_invoice and supplier.hold_type in [\"All\", \"Invoices\"]) or (\n   is_supplier_payment and supplier.hold_type in [\"All\", \"Payments\"]\n  ):\n   if not supplier.release_date or getdate(nowdate()) <= supplier.release_date:\n    frappe.msgprint(\n     _(\"{0} is blocked so this transaction cannot proceed\").format(supplier_name),\n     raise_exception=1,\n    )",
        "import_statements": [
            "import json",
            "from collections import defaultdict",
            "import frappe",
            "from frappe import _, bold, qb, throw",
            "from frappe.model.workflow import get_workflow_name, is_transition_condition_satisfied",
            "from frappe.query_builder import Criterion",
            "from frappe.query_builder.custom import ConstantColumn",
            "from frappe.query_builder.functions import Abs, Sum",
            "from frappe.utils import (\n\tadd_days,\n\tadd_months,\n\tcint,\n\tcomma_and,\n\tflt,\n\tfmt_money,\n\tformatdate,\n\tget_last_day,\n\tget_link_to_form,\n\tgetdate,\n\tnowdate,\n\tparse_json,\n\ttoday,\n)",
            "import erpnext",
            "from erpnext.accounts.doctype.accounting_dimension.accounting_dimension import (\n\tget_accounting_dimensions,\n\tget_dimensions,\n)",
            "from erpnext.accounts.doctype.pricing_rule.utils import (\n\tapply_pricing_rule_for_free_items,\n\tapply_pricing_rule_on_transaction,\n\tget_applied_pricing_rules,\n)",
            "from erpnext.accounts.general_ledger import get_round_off_account_and_cost_center",
            "from erpnext.accounts.party import (\n\tget_party_account,\n\tget_party_account_currency,\n\tget_party_gle_currency,\n\tvalidate_party_frozen_disabled,\n)",
            "from erpnext.accounts.utils import (\n\tcreate_gain_loss_journal,\n\tget_account_currency,\n\tget_currency_precision,\n\tget_fiscal_years,\n\tvalidate_fiscal_year,\n)",
            "from erpnext.buying.utils import update_last_purchase_rate",
            "from erpnext.controllers.print_settings import (\n\tset_print_templates_for_item_table,\n\tset_print_templates_for_taxes,\n)",
            "from erpnext.controllers.sales_and_purchase_return import validate_return",
            "from erpnext.exceptions import InvalidCurrency",
            "from erpnext.setup.utils import get_exchange_rate",
            "from erpnext.stock.doctype.item.item import get_uom_conv_factor",
            "from erpnext.stock.doctype.packed_item.packed_item import make_packing_list",
            "from erpnext.stock.get_item_details import (\n\t_get_item_tax_template,\n\tget_conversion_factor,\n\tget_item_details,\n\tget_item_tax_map,\n\tget_item_warehouse,\n)",
            "from erpnext.utilities.regional import temporary_flag",
            "from erpnext.utilities.transaction_base import TransactionBase"
        ],
        "reference_api": [
            "format",
            "getdate",
            "_",
            "frappe.get_doc",
            "frappe.msgprint",
            "nowdate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "frappe.get_doc",
            "getdate",
            "nowdate",
            "frappe.msgprint",
            "_"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def _remove_references_in_repost_doctypes(self)",
        "start_line": "319",
        "end_line": "347",
        "file_path": "erpnext/controllers/accounts_controller.py",
        "docstring": "This function removes references to a document from specified repost doctypes. It first identifies the relevant repost doctypes, then queries for rows where the voucher type and number match the current document. If such rows are found, it organizes them into a map by parent document type and parent. It retrieves each parent document, removes the relevant rows from either \"repost_vouchers\" or \"vouchers\" fields depending on the doctype, sets flags to ignore validation and links, and saves the changes.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a8f202cf49dc",
        "ground_truth": "def _remove_references_in_repost_doctypes(self):\n repost_doctypes = [\"Repost Payment Ledger Items\", \"Repost Accounting Ledger Items\"]\n for _doctype in repost_doctypes:\n  dt = frappe.qb.DocType(_doctype)\n  rows = (\n   frappe.qb.from_(dt)\n   .select(dt.name, dt.parent, dt.parenttype)\n   .where((dt.voucher_type == self.doctype) & (dt.voucher_no == self.name))\n   .run(as_dict=True)\n  )\n  if rows:\n   references_map = frappe._dict()\n   for x in rows:\n    references_map.setdefault((x.parenttype, x.parent), []).append(x.name)\n   for doc, rows in references_map.items():\n    repost_doc = frappe.get_doc(doc[0], doc[1])\n    for row in rows:\n     if _doctype == \"Repost Payment Ledger Items\":\n      repost_doc.remove(repost_doc.get(\"repost_vouchers\", {\"name\": row})[0])\n     else:\n      repost_doc.remove(repost_doc.get(\"vouchers\", {\"name\": row})[0])\n    repost_doc.flags.ignore_validate_update_after_submit = True\n    repost_doc.flags.ignore_links = True\n    repost_doc.save(ignore_permissions=True)",
        "import_statements": [
            "import json",
            "from collections import defaultdict",
            "import frappe",
            "from frappe import _, bold, qb, throw",
            "from frappe.model.workflow import get_workflow_name, is_transition_condition_satisfied",
            "from frappe.query_builder import Criterion",
            "from frappe.query_builder.custom import ConstantColumn",
            "from frappe.query_builder.functions import Abs, Sum",
            "from frappe.utils import (\n\tadd_days,\n\tadd_months,\n\tcint,\n\tcomma_and,\n\tflt,\n\tfmt_money,\n\tformatdate,\n\tget_last_day,\n\tget_link_to_form,\n\tgetdate,\n\tnowdate,\n\tparse_json,\n\ttoday,\n)",
            "import erpnext",
            "from erpnext.accounts.doctype.accounting_dimension.accounting_dimension import (\n\tget_accounting_dimensions,\n\tget_dimensions,\n)",
            "from erpnext.accounts.doctype.pricing_rule.utils import (\n\tapply_pricing_rule_for_free_items,\n\tapply_pricing_rule_on_transaction,\n\tget_applied_pricing_rules,\n)",
            "from erpnext.accounts.general_ledger import get_round_off_account_and_cost_center",
            "from erpnext.accounts.party import (\n\tget_party_account,\n\tget_party_account_currency,\n\tget_party_gle_currency,\n\tvalidate_party_frozen_disabled,\n)",
            "from erpnext.accounts.utils import (\n\tcreate_gain_loss_journal,\n\tget_account_currency,\n\tget_currency_precision,\n\tget_fiscal_years,\n\tvalidate_fiscal_year,\n)",
            "from erpnext.buying.utils import update_last_purchase_rate",
            "from erpnext.controllers.print_settings import (\n\tset_print_templates_for_item_table,\n\tset_print_templates_for_taxes,\n)",
            "from erpnext.controllers.sales_and_purchase_return import validate_return",
            "from erpnext.exceptions import InvalidCurrency",
            "from erpnext.setup.utils import get_exchange_rate",
            "from erpnext.stock.doctype.item.item import get_uom_conv_factor",
            "from erpnext.stock.doctype.packed_item.packed_item import make_packing_list",
            "from erpnext.stock.get_item_details import (\n\t_get_item_tax_template,\n\tget_conversion_factor,\n\tget_item_details,\n\tget_item_tax_map,\n\tget_item_warehouse,\n)",
            "from erpnext.utilities.regional import temporary_flag",
            "from erpnext.utilities.transaction_base import TransactionBase"
        ],
        "reference_api": [
            "select",
            "references_map.setdefault",
            "frappe._dict",
            "run",
            "where",
            "repost_doc.save",
            "append",
            "repost_doc.remove",
            "from_",
            "references_map.items",
            "frappe.get_doc",
            "DocType",
            "repost_doc.get"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "DocType",
            "run",
            "where",
            "from_",
            "frappe._dict",
            "append",
            "references_map.setdefault",
            "references_map.items",
            "frappe.get_doc",
            "repost_doc.remove",
            "repost_doc.get",
            "repost_doc.remove",
            "repost_doc.get",
            "repost_doc.save"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def get_transactions(self, start_date, end_date, account_id=None)",
        "start_line": "87",
        "end_line": "105",
        "file_path": "erpnext/erpnext_integrations/doctype/plaid_settings/plaid_connector.py",
        "docstring": "This function retrieves transactions for a specified date range and optional account ID. It authenticates the client, constructs the query parameters, and fetches the transactions from the client. If the number of retrieved transactions is less than the total, it continues fetching until all transactions are retrieved. It handles specific errors by raising them and logs any other exceptions.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "30148daa7dda",
        "ground_truth": "def get_transactions(self, start_date, end_date, account_id=None):\n self.auth()\n kwargs = dict(access_token=self.access_token, start_date=start_date, end_date=end_date)\n if account_id:\n  kwargs.update(dict(account_ids=[account_id]))\n try:\n  response = self.client.Transactions.get(**kwargs)\n  transactions = response[\"transactions\"]\n  while len(transactions) < response[\"total_transactions\"]:\n   response = self.client.Transactions.get(\n    self.access_token, start_date=start_date, end_date=end_date, offset=len(transactions)\n   )\n   transactions.extend(response[\"transactions\"])\n  return transactions\n except ItemError as e:\n  raise e\n except Exception:\n  frappe.log_error(\"Plaid: Transactions sync error\")",
        "import_statements": [
            "import frappe",
            "import plaid",
            "import requests",
            "from frappe import _",
            "from plaid.errors import APIError, InvalidRequestError, ItemError"
        ],
        "reference_api": [
            "len",
            "dict",
            "self.auth",
            "kwargs.update",
            "get",
            "frappe.log_error",
            "transactions.extend"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.auth",
                "code": "def auth(self):\n\t\ttry:\n\t\t\tself.client.Auth.get(self.access_token)\n\t\texcept ItemError as e:\n\t\t\tif e.code == \"ITEM_LOGIN_REQUIRED\":\n\t\t\t\tpass\n\t\texcept APIError as e:\n\t\t\tif e.code == \"PLANNED_MAINTENANCE\":\n\t\t\t\tpass\n\t\texcept requests.Timeout:\n\t\t\tpass\n\t\texcept Exception as e:\n\t\t\tfrappe.log_error(\"Plaid: Authentication error\")\n\t\t\tfrappe.throw(_(str(e)), title=_(\"Authentication Failed\"))"
            }
        ],
        "third_party": [
            "kwargs.update",
            "get",
            "get",
            "transactions.extend",
            "frappe.log_error"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def add_institution(token, response)",
        "start_line": "54",
        "end_line": "78",
        "file_path": "erpnext/erpnext_integrations/doctype/plaid_settings/plaid_settings.py",
        "docstring": "This function adds a bank institution using a provided token and response. It parses the response, retrieves an access token using the PlaidConnector, and checks if the bank already exists in the database. If the bank does not exist, it creates and inserts a new bank record. If the bank exists, it updates the access token for the existing bank record and saves it. It logs any errors that occur during the process.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "18dc618f26f7",
        "ground_truth": "def add_institution(token, response):\n response = json.loads(response)\n  plaid = PlaidConnector()\n access_token = plaid.get_access_token(token)\n bank = None\n  if not frappe.db.exists(\"Bank\", response[\"institution\"][\"name\"]):\n  try:\n   bank = frappe.get_doc(\n    {\n     \"doctype\": \"Bank\",\n     \"bank_name\": response[\"institution\"][\"name\"],\n     \"plaid_access_token\": access_token,\n    }\n   )\n   bank.insert()\n  except Exception:\n   frappe.log_error(\"Plaid Link Error\")\n else:\n  bank = frappe.get_doc(\"Bank\", response[\"institution\"][\"name\"])\n  bank.plaid_access_token = access_token\n  bank.save()\n  return bank",
        "import_statements": [
            "import json",
            "import frappe",
            "from frappe import _",
            "from frappe.desk.doctype.tag.tag import add_tag",
            "from frappe.model.document import Document",
            "from frappe.utils import add_months, formatdate, getdate, sbool, today",
            "from plaid.errors import ItemError",
            "from erpnext.erpnext_integrations.doctype.plaid_settings.plaid_connector import PlaidConnector"
        ],
        "reference_api": [
            "exists",
            "bank.insert",
            "plaid.get_access_token",
            "json.loads",
            "bank.save",
            "frappe.get_doc",
            "frappe.log_error",
            "PlaidConnector"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "plaid.get_access_token",
                "code": "def get_access_token(self, public_token):\n\t\tif public_token is None:\n\t\t\tfrappe.log_error(\"Plaid: Public token is missing\")\n\t\tresponse = self.client.Item.public_token.exchange(public_token)\n\t\taccess_token = response[\"access_token\"]\n\t\treturn access_token"
            }
        ],
        "third_party": [
            "PlaidConnector",
            "exists",
            "frappe.get_doc",
            "bank.insert",
            "frappe.log_error",
            "frappe.get_doc",
            "bank.save"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def sync_transactions(bank, bank_account)",
        "start_line": "198",
        "end_line": "227",
        "file_path": "erpnext/erpnext_integrations/doctype/plaid_settings/plaid_settings.py",
        "docstring": "This function syncs bank transactions for a specified bank and bank account based on the last integration date. It determines the start and end dates for the transaction retrieval, attempts to fetch the transactions, and processes them into new bank transactions. After syncing, it updates the last integration date to the date of the oldest transaction. It logs the number of new transactions added and handles any exceptions by logging an error message.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "452010cfcec2",
        "ground_truth": "def sync_transactions(bank, bank_account):\n \"\"\"Sync transactions based on the last integration date as the start date, after sync is completed\n add the transaction date of the oldest transaction as the last integration date.\"\"\"\n last_transaction_date = frappe.db.get_value(\"Bank Account\", bank_account, \"last_integration_date\")\n if last_transaction_date:\n  start_date = formatdate(last_transaction_date, \"YYYY-MM-dd\")\n else:\n  start_date = formatdate(add_months(today(), -12), \"YYYY-MM-dd\")\n end_date = formatdate(today(), \"YYYY-MM-dd\")\n  try:\n  transactions = get_transactions(\n   bank=bank, bank_account=bank_account, start_date=start_date, end_date=end_date\n  )\n   result = []\n  if transactions:\n   for transaction in reversed(transactions):\n    result += new_bank_transaction(transaction)\n   if result:\n   last_transaction_date = frappe.db.get_value(\"Bank Transaction\", result.pop(), \"date\")\n    frappe.logger().info(\n    f\"Plaid added {len(result)} new Bank Transactions from '{bank_account}' between {start_date} and {end_date}\"\n   )\n    frappe.db.set_value(\"Bank Account\", bank_account, \"last_integration_date\", last_transaction_date)\n except Exception:\n  frappe.log_error(frappe.get_traceback(), _(\"Plaid transactions sync error\"))",
        "import_statements": [
            "import json",
            "import frappe",
            "from frappe import _",
            "from frappe.desk.doctype.tag.tag import add_tag",
            "from frappe.model.document import Document",
            "from frappe.utils import add_months, formatdate, getdate, sbool, today",
            "from plaid.errors import ItemError",
            "from erpnext.erpnext_integrations.doctype.plaid_settings.plaid_connector import PlaidConnector"
        ],
        "reference_api": [
            "frappe.get_traceback",
            "new_bank_transaction",
            "result.pop",
            "get_value",
            "len",
            "get_transactions",
            "formatdate",
            "frappe.log_error",
            "_",
            "reversed",
            "info",
            "today",
            "add_months",
            "set_value",
            "frappe.logger"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get_transactions",
                "code": "def get_transactions(bank, bank_account=None, start_date=None, end_date=None):\n\taccess_token = None\n\n\tif bank_account:\n\t\trelated_bank = frappe.db.get_values(\n\t\t\t\"Bank Account\", bank_account, [\"bank\", \"integration_id\"], as_dict=True\n\t\t)\n\t\taccess_token = frappe.db.get_value(\"Bank\", related_bank[0].bank, \"plaid_access_token\")\n\t\taccount_id = related_bank[0].integration_id\n\telse:\n\t\taccess_token = frappe.db.get_value(\"Bank\", bank, \"plaid_access_token\")\n\t\taccount_id = None\n\n\tplaid = PlaidConnector(access_token)\n\n\ttransactions = []\n\ttry:\n\t\ttransactions = plaid.get_transactions(start_date=start_date, end_date=end_date, account_id=account_id)\n\texcept ItemError as e:\n\t\tif e.code == \"ITEM_LOGIN_REQUIRED\":\n\t\t\tmsg = _(\"There was an error syncing transactions.\") + \" \"\n\t\t\tmsg += _(\"Please refresh or reset the Plaid linking of the Bank {}.\").format(bank) + \" \"\n\t\t\tfrappe.log_error(message=msg, title=_(\"Plaid Link Refresh Required\"))\n\n\treturn transactions"
            },
            {
                "name": "new_bank_transaction",
                "code": "def new_bank_transaction(transaction):\n\tresult = []\n\n\tbank_account = frappe.db.get_value(\"Bank Account\", dict(integration_id=transaction[\"account_id\"]))\n\n\tamount = float(transaction[\"amount\"])\n\tif amount >= 0.0:\n\t\tdeposit = 0.0\n\t\twithdrawal = amount\n\telse:\n\t\tdeposit = abs(amount)\n\t\twithdrawal = 0.0\n\n\ttags = []\n\tif transaction[\"category\"]:\n\t\ttry:\n\t\t\ttags += transaction[\"category\"]\n\t\t\ttags += [f'Plaid Cat. {transaction[\"category_id\"]}']\n\t\texcept KeyError:\n\t\t\tpass\n\n\tif not frappe.db.exists(\n\t\t\"Bank Transaction\", dict(transaction_id=transaction[\"transaction_id\"])\n\t) and not sbool(transaction[\"pending\"]):\n\t\ttry:\n\t\t\tnew_transaction = frappe.get_doc(\n\t\t\t\t{\n\t\t\t\t\t\"doctype\": \"Bank Transaction\",\n\t\t\t\t\t\"date\": getdate(transaction[\"date\"]),\n\t\t\t\t\t\"bank_account\": bank_account,\n\t\t\t\t\t\"deposit\": deposit,\n\t\t\t\t\t\"withdrawal\": withdrawal,\n\t\t\t\t\t\"currency\": transaction[\"iso_currency_code\"],\n\t\t\t\t\t\"transaction_id\": transaction[\"transaction_id\"],\n\t\t\t\t\t\"transaction_type\": (\n\t\t\t\t\t\ttransaction[\"transaction_code\"] or transaction[\"payment_meta\"][\"payment_method\"]\n\t\t\t\t\t),\n\t\t\t\t\t\"reference_number\": (\n\t\t\t\t\t\ttransaction[\"check_number\"]\n\t\t\t\t\t\tor transaction[\"payment_meta\"][\"reference_number\"]\n\t\t\t\t\t\tor transaction[\"name\"]\n\t\t\t\t\t),\n\t\t\t\t\t\"description\": transaction[\"name\"],\n\t\t\t\t}\n\t\t\t)\n\t\t\tnew_transaction.insert()\n\t\t\tnew_transaction.submit()\n\n\t\t\tfor tag in tags:\n\t\t\t\tadd_tag(tag, \"Bank Transaction\", new_transaction.name)\n\n\t\t\tresult.append(new_transaction.name)\n\n\t\texcept Exception:\n\t\t\tfrappe.throw(_(\"Bank transaction creation error\"))\n\n\treturn result"
            }
        ],
        "third_party": [
            "get_value",
            "formatdate",
            "formatdate",
            "add_months",
            "today",
            "formatdate",
            "today",
            "get_value",
            "result.pop",
            "info",
            "frappe.logger",
            "set_value",
            "frappe.log_error",
            "frappe.get_traceback",
            "_"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def _migrate_entries(self, entity)",
        "start_line": "242",
        "end_line": "265",
        "file_path": "erpnext/erpnext_integrations/doctype/quickbooks_migrator/quickbooks_migrator.py",
        "docstring": "This function migrates entries for a specified entity from a QuickBooks company. It constructs a query URI, determines the total number of entries, and retrieves them in batches of 1000. It preprocesses and saves the entries after fetching. Any exceptions encountered during the process are logged along with the response text.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9c19a41cf3df",
        "ground_truth": "def _migrate_entries(self, entity):\n try:\n  query_uri = f\"{self.api_endpoint}/company/{self.quickbooks_company_id}/query\"\n  max_result_count = 1000\n  # Count number of entries\n  response = self._get(query_uri, params={\"query\": f\"\"\"SELECT COUNT(*) FROM {entity}\"\"\"})\n  entry_count = response.json()[\"QueryResponse\"][\"totalCount\"]\n  # fetch pages and accumulate\n  entries = []\n  for start_position in range(1, entry_count + 1, max_result_count):\n   response = self._get(\n    query_uri,\n    params={\n     \"query\": \"\"\"SELECT * FROM {} STARTPOSITION {} MAXRESULTS {}\"\"\".format(\n      entity, start_position, max_result_count\n     )\n    },\n   )\n   entries.extend(response.json()[\"QueryResponse\"][entity])\n  entries = self._preprocess_entries(entity, entries)\n  self._save_entries(entity, entries)\n except Exception as e:\n  self._log_error(e, response.text)",
        "import_statements": [
            "import json",
            "import traceback",
            "import frappe",
            "import requests",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from requests_oauthlib import OAuth2Session",
            "from erpnext import encode_company_abbr"
        ],
        "reference_api": [
            "response.json",
            "self._get",
            "entries.extend",
            "self._save_entries",
            "self._log_error",
            "self._preprocess_entries",
            "format",
            "range"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self._get",
                "code": "def _get(self, *args, **kwargs):\n\t\tkwargs[\"headers\"] = {\n\t\t\t\"Accept\": \"application/json\",\n\t\t\t\"Authorization\": f\"Bearer {self.access_token}\",\n\t\t}\n\t\tresponse = requests.get(*args, **kwargs)\n\t\t# HTTP Status code 401 here means that the access_token is expired\n\t\t# We can refresh tokens and retry\n\t\t# However limitless recursion does look dangerous\n\t\tif response.status_code == 401:\n\t\t\tself._refresh_tokens()\n\t\t\tresponse = self._get(*args, **kwargs)\n\t\treturn response"
            },
            {
                "name": "self._get",
                "code": "def _get(self, *args, **kwargs):\n\t\tkwargs[\"headers\"] = {\n\t\t\t\"Accept\": \"application/json\",\n\t\t\t\"Authorization\": f\"Bearer {self.access_token}\",\n\t\t}\n\t\tresponse = requests.get(*args, **kwargs)\n\t\t# HTTP Status code 401 here means that the access_token is expired\n\t\t# We can refresh tokens and retry\n\t\t# However limitless recursion does look dangerous\n\t\tif response.status_code == 401:\n\t\t\tself._refresh_tokens()\n\t\t\tresponse = self._get(*args, **kwargs)\n\t\treturn response"
            },
            {
                "name": "self._preprocess_entries",
                "code": "def _preprocess_entries(self, entity, entries):\n\t\tentity_method_map = {\n\t\t\t\"Account\": self._preprocess_accounts,\n\t\t\t\"TaxRate\": self._preprocess_tax_rates,\n\t\t\t\"TaxCode\": self._preprocess_tax_codes,\n\t\t}\n\t\tpreprocessor = entity_method_map.get(entity)\n\t\tif preprocessor:\n\t\t\tentries = preprocessor(entries)\n\t\treturn entries"
            },
            {
                "name": "self._save_entries",
                "code": "def _save_entries(self, entity, entries):\n\t\tentity_method_map = {\n\t\t\t\"Account\": self._save_account,\n\t\t\t\"TaxRate\": self._save_tax_rate,\n\t\t\t\"TaxCode\": self._save_tax_code,\n\t\t\t\"Preferences\": self._save_preference,\n\t\t\t\"Customer\": self._save_customer,\n\t\t\t\"Item\": self._save_item,\n\t\t\t\"Vendor\": self._save_vendor,\n\t\t\t\"Invoice\": self._save_invoice,\n\t\t\t\"CreditMemo\": self._save_credit_memo,\n\t\t\t\"SalesReceipt\": self._save_sales_receipt,\n\t\t\t\"RefundReceipt\": self._save_refund_receipt,\n\t\t\t\"JournalEntry\": self._save_journal_entry,\n\t\t\t\"Bill\": self._save_bill,\n\t\t\t\"VendorCredit\": self._save_vendor_credit,\n\t\t\t\"Payment\": self._save_payment,\n\t\t\t\"BillPayment\": self._save_bill_payment,\n\t\t\t\"Purchase\": self._save_purchase,\n\t\t\t\"Deposit\": self._save_deposit,\n\t\t\t\"Advance Payment\": self._save_advance_payment,\n\t\t\t\"Tax Payment\": self._save_tax_payment,\n\t\t\t\"Sales Tax Payment\": self._save_tax_payment,\n\t\t\t\"Purchase Tax Payment\": self._save_tax_payment,\n\t\t\t\"Inventory Qty Adjust\": self._save_inventory_qty_adjust,\n\t\t}\n\t\ttotal = len(entries)\n\t\tfor index, entry in enumerate(entries, start=1):\n\t\t\tself._publish(\n\t\t\t\t{\n\t\t\t\t\t\"event\": \"progress\",\n\t\t\t\t\t\"message\": _(\"Saving {0}\").format(entity),\n\t\t\t\t\t\"count\": index,\n\t\t\t\t\t\"total\": total,\n\t\t\t\t}\n\t\t\t)\n\t\t\tentity_method_map[entity](entry)\n\t\tfrappe.db.commit()"
            },
            {
                "name": "self._log_error",
                "code": "def _log_error(self, execption, data=\"\"):\n\t\tfrappe.log_error(\n\t\t\ttitle=\"QuickBooks Migration Error\",\n\t\t\tmessage=\"\\n\".join(\n\t\t\t\t[\n\t\t\t\t\t\"Data\",\n\t\t\t\t\tjson.dumps(data, sort_keys=True, indent=4, separators=(\",\", \": \")),\n\t\t\t\t\t\"Exception\",\n\t\t\t\t\ttraceback.format_exc(),\n\t\t\t\t]\n\t\t\t),\n\t\t)"
            }
        ],
        "third_party": [
            "response.json",
            "entries.extend",
            "response.json"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def _save_invoice(self, invoice)",
        "start_line": "647",
        "end_line": "659",
        "file_path": "erpnext/erpnext_integrations/doctype/quickbooks_migrator/quickbooks_migrator.py",
        "docstring": "This function saves an invoice based on its type. It generates a QuickBooks ID for the invoice and checks if any linked transactions are of type \"StatementCharge\" or \"ReimburseCharge.\" If such linked transactions exist, it saves the invoice as a journal entry; otherwise, it saves it as a sales invoice.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5c14043585a6",
        "ground_truth": "def _save_invoice(self, invoice):\n # Invoice can be Linked with Another Transactions\n # If any of these transactions is a \"StatementCharge\" or \"ReimburseCharge\" then in the UI\n # item list is populated from the corresponding transaction, these items are not shown in api response\n # Also as of now there is no way of fetching the corresponding transaction from api\n # We in order to correctly reflect account balance make an equivalent Journal Entry\n quickbooks_id = \"Invoice - {}\".format(invoice[\"Id\"])\n if any(\n  linked[\"TxnType\"] in (\"StatementCharge\", \"ReimburseCharge\") for linked in invoice[\"LinkedTxn\"]\n ):\n  self._save_invoice_as_journal_entry(invoice, quickbooks_id)\n else:\n  self._save_sales_invoice(invoice, quickbooks_id)",
        "import_statements": [
            "import json",
            "import traceback",
            "import frappe",
            "import requests",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from requests_oauthlib import OAuth2Session",
            "from erpnext import encode_company_abbr"
        ],
        "reference_api": [
            "any",
            "self._save_sales_invoice",
            "self._save_invoice_as_journal_entry",
            "format"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self._save_invoice_as_journal_entry",
                "code": "def _save_invoice_as_journal_entry(self, invoice, quickbooks_id):\n\t\ttry:\n\t\t\taccounts = []\n\t\t\tfor line in self.general_ledger[\"Invoice\"][invoice[\"Id\"]][\"lines\"]:\n\t\t\t\taccount_line = {\"account\": line[\"account\"], \"cost_center\": self.default_cost_center}\n\t\t\t\tif line[\"debit\"]:\n\t\t\t\t\taccount_line[\"debit_in_account_currency\"] = line[\"debit\"]\n\t\t\t\telif line[\"credit\"]:\n\t\t\t\t\taccount_line[\"credit_in_account_currency\"] = line[\"credit\"]\n\t\t\t\tif frappe.db.get_value(\"Account\", line[\"account\"], \"account_type\") == \"Receivable\":\n\t\t\t\t\taccount_line[\"party_type\"] = \"Customer\"\n\t\t\t\t\taccount_line[\"party\"] = frappe.get_all(\n\t\t\t\t\t\t\"Customer\",\n\t\t\t\t\t\tfilters={\"quickbooks_id\": invoice[\"CustomerRef\"][\"value\"], \"company\": self.company},\n\t\t\t\t\t)[0][\"name\"]\n\n\t\t\t\taccounts.append(account_line)\n\n\t\t\tposting_date = invoice[\"TxnDate\"]\n\t\t\tself.__save_journal_entry(quickbooks_id, accounts, posting_date)\n\t\texcept Exception as e:\n\t\t\tself._log_error(e, [invoice, accounts])"
            },
            {
                "name": "self._save_sales_invoice",
                "code": "def _save_sales_invoice(self, invoice, quickbooks_id, is_return=False, is_pos=False):\n\t\ttry:\n\t\t\tif not frappe.db.exists(\n\t\t\t\t{\"doctype\": \"Sales Invoice\", \"quickbooks_id\": quickbooks_id, \"company\": self.company}\n\t\t\t):\n\t\t\t\tinvoice_dict = {\n\t\t\t\t\t\"doctype\": \"Sales Invoice\",\n\t\t\t\t\t\"quickbooks_id\": quickbooks_id,\n\t\t\t\t\t# Quickbooks uses ISO 4217 Code\n\t\t\t\t\t# of course this gonna come back to bite me\n\t\t\t\t\t\"currency\": invoice[\"CurrencyRef\"][\"value\"],\n\t\t\t\t\t# Exchange Rate is provided if multicurrency is enabled\n\t\t\t\t\t# It is not provided if multicurrency is not enabled\n\t\t\t\t\t\"conversion_rate\": invoice.get(\"ExchangeRate\", 1),\n\t\t\t\t\t\"posting_date\": invoice[\"TxnDate\"],\n\t\t\t\t\t# QuickBooks doesn't make Due Date a mandatory field this is a hack\n\t\t\t\t\t\"due_date\": invoice.get(\"DueDate\", invoice[\"TxnDate\"]),\n\t\t\t\t\t\"customer\": frappe.get_all(\n\t\t\t\t\t\t\"Customer\",\n\t\t\t\t\t\tfilters={\n\t\t\t\t\t\t\t\"quickbooks_id\": invoice[\"CustomerRef\"][\"value\"],\n\t\t\t\t\t\t\t\"company\": self.company,\n\t\t\t\t\t\t},\n\t\t\t\t\t)[0][\"name\"],\n\t\t\t\t\t\"items\": self._get_si_items(invoice, is_return=is_return),\n\t\t\t\t\t\"taxes\": self._get_taxes(invoice),\n\t\t\t\t\t# Do not change posting_date upon submission\n\t\t\t\t\t\"set_posting_time\": 1,\n\t\t\t\t\t# QuickBooks doesn't round total\n\t\t\t\t\t\"disable_rounded_total\": 1,\n\t\t\t\t\t\"is_return\": is_return,\n\t\t\t\t\t\"is_pos\": is_pos,\n\t\t\t\t\t\"payments\": self._get_invoice_payments(invoice, is_return=is_return, is_pos=is_pos),\n\t\t\t\t\t\"company\": self.company,\n\t\t\t\t}\n\t\t\t\tdiscount = self._get_discount(invoice[\"Line\"])\n\t\t\t\tif discount:\n\t\t\t\t\tif invoice[\"ApplyTaxAfterDiscount\"]:\n\t\t\t\t\t\tinvoice_dict[\"apply_discount_on\"] = \"Net Total\"\n\t\t\t\t\telse:\n\t\t\t\t\t\tinvoice_dict[\"apply_discount_on\"] = \"Grand Total\"\n\t\t\t\t\tinvoice_dict[\"discount_amount\"] = discount[\"Amount\"]\n\n\t\t\t\tinvoice_doc = frappe.get_doc(invoice_dict)\n\t\t\t\tinvoice_doc.insert()\n\t\t\t\tinvoice_doc.submit()\n\t\texcept Exception as e:\n\t\t\tself._log_error(e, [invoice, invoice_dict, json.loads(invoice_doc.as_json())])"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "ERP",
        "owner/repo": "frappe/erpnext",
        "function_declaration": "def create_schedule_list(self, start_date, end_date, no_of_visit, sales_person)",
        "start_line": "160",
        "end_line": "177",
        "file_path": "erpnext/maintenance/doctype/maintenance_schedule/maintenance_schedule.py",
        "docstring": "This function generates a list of scheduled visit dates between a start and end date, given the number of visits and a salesperson. It calculates the interval between visits, iterates to create the schedule, and adjusts dates to avoid holidays. The final list of schedule dates is returned.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8351ba65b354",
        "ground_truth": "def create_schedule_list(self, start_date, end_date, no_of_visit, sales_person):\n schedule_list = []\n start_date_copy = start_date\n date_diff = (getdate(end_date) - getdate(start_date)).days\n add_by = date_diff / no_of_visit\n for _visit in range(cint(no_of_visit)):\n  if getdate(start_date_copy) < getdate(end_date):\n   start_date_copy = add_days(start_date_copy, add_by)\n   if len(schedule_list) < no_of_visit:\n    schedule_date = self.validate_schedule_date_for_holiday_list(\n     getdate(start_date_copy), sales_person\n    )\n    if schedule_date > getdate(end_date):\n     schedule_date = getdate(end_date)\n    schedule_list.append(schedule_date)\n return schedule_list",
        "import_statements": [
            "import frappe",
            "from frappe import _, throw",
            "from frappe.utils import add_days, cint, cstr, date_diff, formatdate, getdate",
            "from erpnext.setup.doctype.employee.employee import get_holiday_list_for_employee",
            "from erpnext.stock.doctype.serial_no.serial_no import get_serial_nos",
            "from erpnext.utilities.transaction_base import TransactionBase, delete_events"
        ],
        "reference_api": [
            "cint",
            "len",
            "schedule_list.append",
            "self.validate_schedule_date_for_holiday_list",
            "add_days",
            "getdate",
            "range"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.validate_schedule_date_for_holiday_list",
                "code": "def validate_schedule_date_for_holiday_list(self, schedule_date, sales_person):\n\t\tvalidated = False\n\n\t\temployee = frappe.db.get_value(\"Sales Person\", sales_person, \"employee\")\n\t\tif employee:\n\t\t\tholiday_list = get_holiday_list_for_employee(employee)\n\t\telse:\n\t\t\tholiday_list = frappe.get_cached_value(\"Company\", self.company, \"default_holiday_list\")\n\n\t\tholidays = frappe.db.sql_list(\n\t\t\t\"\"\"select holiday_date from `tabHoliday` where parent=%s\"\"\", holiday_list\n\t\t)\n\n\t\tif not validated and holidays:\n\t\t\t# max iterations = len(holidays)\n\t\t\tfor _i in range(len(holidays)):\n\t\t\t\tif schedule_date in holidays:\n\t\t\t\t\tschedule_date = add_days(schedule_date, -1)\n\t\t\t\telse:\n\t\t\t\t\tvalidated = True\n\t\t\t\t\tbreak\n\n\t\treturn schedule_date"
            }
        ],
        "third_party": [
            "getdate",
            "getdate",
            "cint",
            "getdate",
            "getdate",
            "add_days",
            "getdate",
            "getdate",
            "getdate",
            "schedule_list.append"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "   public function response($view, $data = [])",
        "start_line": "118",
        "end_line": "143",
        "file_path": "app/Abstracts/BulkAction.php",
        "docstring": "This function generates a JSON response for a given view and data. It determines the method to handle the request, constructs a URL for bulk actions, and renders HTML content for a modal using the specified view and data. The response includes success status, message, data with title, path, handle, and the rendered HTML.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "f9ca0924d1cd",
        "ground_truth": "public function response($view, $data = [])\n{\n    $method = request()->get('handle', 'edit');\n    $handle = $this->actions[$method]['handle'] ?? 'update';\n    $url = route('bulk-actions.action', $this->path);\n    $html = view('components.index.bulkaction.modal', [\n        'url' => $url,\n        'handle' => $handle,\n        'selected' => $data['selected'] ?? $this->getSelectedInput(request()),\n        'html' => view($view, $data)->render(),\n    ])->render();\n    return response()->json([\n        'success' => true,\n        'error' => false,\n        'message' => '',\n        'data' => [\n            'title' => $this->findTranslation($this->text),\n            'path' => $url,\n            'handle' => $handle,\n        ],\n        'html' => $html,\n    ]);\n}",
        "import_statements": [
            "use App\\Jobs\\Common\\CreateMediableForDownload;",
            "use App\\Jobs\\Common\\CreateZipForDownload;",
            "use App\\Jobs\\Common\\DeleteContact;",
            "use App\\Jobs\\Common\\UpdateContact;",
            "use App\\Jobs\\Banking\\DeleteTransaction;",
            "use App\\Traits\\Jobs;",
            "use App\\Traits\\Relationships;",
            "use App\\Traits\\Translations;",
            "use App\\Utilities\\Export;",
            "use App\\Utilities\\Import;",
            "use Illuminate\\Support\\Arr;",
            "use Illuminate\\Support\\Facades\\Bus;",
            "use Throwable;",
            "use Jobs, Relationships, Translations;"
        ],
        "reference_api": [
            "view($view, $data)->render",
            "request",
            "$this->getSelectedInput",
            "$this->findTranslation",
            "route",
            "request()->get",
            "response()->json",
            "view",
            "response",
            "view('components.index.bulkaction.modal', [\n            'url' => $url,\n            'handle' => $handle,\n            'selected' => $data['selected'] ?? $this->getSelectedInput(request()),\n            'html' => view($view, $data)->render(),\n        ])->render"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->getSelectedInput",
                "code": "public function getSelectedInput($request)\n    {\n        return $request->get('selected', []);\n    }"
            },
            {
                "name": "response",
                "code": "public function response($view, $data = [])\n    {\n        $method = request()->get('handle', 'edit');\n\n        $handle = $this->actions[$method]['handle'] ?? 'update';\n        $url = route('bulk-actions.action', $this->path);\n\n        $html = view('components.index.bulkaction.modal', [\n            'url' => $url,\n            'handle' => $handle,\n            'selected' => $data['selected'] ?? $this->getSelectedInput(request()),\n            'html' => view($view, $data)->render(),\n        ])->render();\n\n        return response()->json([\n            'success' => true,\n            'error' => false,\n            'message' => '',\n            'data' => [\n                'title' => $this->findTranslation($this->text),\n                'path' => $url,\n                'handle' => $handle,\n            ],\n            'html' => $html,\n        ]);\n    }"
            }
        ],
        "third_party": [
            "view($view, $data)->render",
            "request",
            "$this->findTranslation",
            "route",
            "request()->get",
            "response()->json",
            "view",
            "view('components.index.bulkaction.modal', [\n            'url' => $url,\n            'handle' => $handle,\n            'selected' => $data['selected'] ?? $this->getSelectedInput(request()),\n            'html' => view($view, $data)->render(),\n        ])->render"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function deleteContacts($request)",
        "start_line": "236",
        "end_line": "247",
        "file_path": "app/Abstracts/BulkAction.php",
        "docstring": "This function deletes selected user contacts from a request. It retrieves the selected contacts, attempts to dispatch a delete operation for each contact, and catches any exceptions that occur, displaying an error message if necessary.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "87b81658f331",
        "ground_truth": "public function deleteContacts($request)\n{\n    $contacts = $this->getSelectedRecords($request, 'user');\n    foreach ($contacts as $contact) {\n        try {\n            $this->dispatch(new DeleteContact($contact));\n        } catch (\\Exception $e) {\n            flash($e->getMessage())->error()->important();\n        }\n    }\n}",
        "import_statements": [
            "use App\\Jobs\\Common\\CreateMediableForDownload;",
            "use App\\Jobs\\Common\\CreateZipForDownload;",
            "use App\\Jobs\\Common\\DeleteContact;",
            "use App\\Jobs\\Common\\UpdateContact;",
            "use App\\Jobs\\Banking\\DeleteTransaction;",
            "use App\\Traits\\Jobs;",
            "use App\\Traits\\Relationships;",
            "use App\\Traits\\Translations;",
            "use App\\Utilities\\Export;",
            "use App\\Utilities\\Import;",
            "use Illuminate\\Support\\Arr;",
            "use Illuminate\\Support\\Facades\\Bus;",
            "use Throwable;",
            "use Jobs, Relationships, Translations;"
        ],
        "reference_api": [
            "$this->getSelectedRecords",
            "$e->getMessage",
            "flash($e->getMessage())->error",
            "$this->dispatch",
            "flash($e->getMessage())->error()->important",
            "flash"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->getSelectedRecords",
                "code": "public function getSelectedRecords($request, $relationships = null)\n    {\n        if (empty($relationships)) {\n            $model = $this->model::query();\n        } else {\n            $relationships = Arr::wrap($relationships);\n\n            $model = $this->model::with($relationships);\n        }\n\n        return $model->find($this->getSelectedInput($request));\n    }"
            }
        ],
        "third_party": [
            "$e->getMessage",
            "flash($e->getMessage())->error",
            "$this->dispatch",
            "flash($e->getMessage())->error()->important",
            "flash"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function deleteTransactions($request)",
        "start_line": "249",
        "end_line": "270",
        "file_path": "app/Abstracts/BulkAction.php",
        "docstring": "This function deletes selected transactions based on the provided request. It retrieves the transactions and attempts to dispatch a job to delete each transaction. If an exception occurs during the deletion, it flashes an error message.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "fb5a63d9d81a",
        "ground_truth": "public function deleteTransactions($request)\n{\n    $transactions = $this->getSelectedRecords($request, 'category');\n    foreach ($transactions as $transaction) {\n        try {\n            $this->dispatch(new DeleteTransaction($transaction));\n        } catch (\\Exception $e) {\n            flash($e->getMessage())->error()->important();\n        }\n    }\n}\n/**\n * Import the excel file or catch errors\n *\n * @param $class\n * @param $request\n * @param $translation\n *\n * @return array\n */",
        "import_statements": [
            "use App\\Jobs\\Common\\CreateMediableForDownload;",
            "use App\\Jobs\\Common\\CreateZipForDownload;",
            "use App\\Jobs\\Common\\DeleteContact;",
            "use App\\Jobs\\Common\\UpdateContact;",
            "use App\\Jobs\\Banking\\DeleteTransaction;",
            "use App\\Traits\\Jobs;",
            "use App\\Traits\\Relationships;",
            "use App\\Traits\\Translations;",
            "use App\\Utilities\\Export;",
            "use App\\Utilities\\Import;",
            "use Illuminate\\Support\\Arr;",
            "use Illuminate\\Support\\Facades\\Bus;",
            "use Throwable;",
            "use Jobs, Relationships, Translations;"
        ],
        "reference_api": [
            "$this->getSelectedRecords",
            "$e->getMessage",
            "flash($e->getMessage())->error",
            "$this->dispatch",
            "flash($e->getMessage())->error()->important",
            "flash"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->getSelectedRecords",
                "code": "public function getSelectedRecords($request, $relationships = null)\n    {\n        if (empty($relationships)) {\n            $model = $this->model::query();\n        } else {\n            $relationships = Arr::wrap($relationships);\n\n            $model = $this->model::with($relationships);\n        }\n\n        return $model->find($this->getSelectedInput($request));\n    }"
            }
        ],
        "third_party": [
            "$e->getMessage",
            "flash($e->getMessage())->error",
            "$this->dispatch",
            "flash($e->getMessage())->error()->important",
            "flash"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function withValidator($validator)",
        "start_line": "102",
        "end_line": "129",
        "file_path": "app/Abstracts/Import.php",
        "docstring": "This function customizes the validation logic for the current request. It first checks if a specific request class exists and if it is an instance of FormRequest. If not, the function exits. For each data row, it initializes the request, prepares the validation rules, and attempts to validate the data. If a validation exception occurs, it adds the validation failures to the validator and rethrows the exception.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "513c2f307c5a",
        "ground_truth": "public function withValidator($validator)\n{\n    $condition = class_exists($this->request_class)\n                ? ! ($request = new $this->request_class) instanceof FormRequest\n                : true;\n    if ($condition) {\n        return;\n    }\n    foreach ($validator->getData() as $row => $data) {\n        $request->initialize(request: $data);\n        $rules = $this->prepareRules($request->rules());\n        try {\n            Validator::make($data, $rules)->validate();\n        } catch (ValidationException $e) {\n            foreach ($e->validator->failed() as $attribute => $value) {\n                foreach ($value as $rule => $params) {\n                    $validator->addFailure($row . '.' . $attribute, $rule, $params);\n                }\n            }\n            throw new ValidationException($validator);\n        }\n    }\n}",
        "import_statements": [
            "use App\\Abstracts\\Http\\FormRequest;",
            "use App\\Traits\\Import as ImportHelper;",
            "use App\\Traits\\Sources;",
            "use App\\Utilities\\Date;",
            "use Carbon\\Exceptions\\InvalidFormatException;",
            "use Illuminate\\Contracts\\Queue\\ShouldQueue;",
            "use Illuminate\\Contracts\\Translation\\HasLocalePreference;",
            "use Illuminate\\Support\\Arr;",
            "use Illuminate\\Support\\Facades\\Log;",
            "use Illuminate\\Support\\Facades\\Validator;",
            "use Illuminate\\Validation\\ValidationException;",
            "use Maatwebsite\\Excel\\Concerns\\Importable;",
            "use Maatwebsite\\Excel\\Concerns\\SkipsEmptyRows;",
            "use Maatwebsite\\Excel\\Concerns\\ToModel;",
            "use Maatwebsite\\Excel\\Concerns\\WithChunkReading;",
            "use Maatwebsite\\Excel\\Concerns\\WithHeadingRow;",
            "use Maatwebsite\\Excel\\Concerns\\WithLimit;",
            "use Maatwebsite\\Excel\\Concerns\\WithMapping;",
            "use Maatwebsite\\Excel\\Concerns\\WithValidation;",
            "use PhpOffice\\PhpSpreadsheet\\Shared\\Date as ExcelDate;",
            "use Importable, ImportHelper, Sources;"
        ],
        "reference_api": [
            "$request->initialize",
            "$validator->getData",
            "$validator->addFailure",
            "$request->rules",
            "class_exists",
            "$e->validator->failed",
            "Validator::make($data, $rules)->validate",
            "Validator::make",
            "$this->prepareRules"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->prepareRules",
                "code": "public function prepareRules(array $rules): array\n    {\n        return $rules;\n    }"
            }
        ],
        "third_party": [
            "$request->initialize",
            "$validator->getData",
            "$validator->addFailure",
            "$request->rules",
            "$e->validator->failed",
            "Validator::make($data, $rules)->validate",
            "Validator::make"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function bootUpdate(...$arguments): void",
        "start_line": "60",
        "end_line": "74",
        "file_path": "app/Abstracts/Job.php",
        "docstring": "This function initializes the update process if the instance implements the ShouldUpdate interface. It sets the model if the first argument is a Model instance and sets the request if the second argument is a Request instance.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "337cc7786d21",
        "ground_truth": "public function bootUpdate(...$arguments): void\n{\n    if (! $this instanceof ShouldUpdate) {\n        return;\n    }\n    if ($arguments[0] instanceof Model) {\n        $this->model = $arguments[0];\n    }\n    $request = $this->getRequestInstance($arguments[1]);\n    if ($request instanceof Request) {\n        $this->request = $request;\n    }\n}",
        "import_statements": [
            "use App\\Abstracts\\Http\\FormRequest;",
            "use App\\Interfaces\\Job\\HasOwner;",
            "use App\\Interfaces\\Job\\HasSource;",
            "use App\\Interfaces\\Job\\ShouldCreate;",
            "use App\\Interfaces\\Job\\ShouldDelete;",
            "use App\\Interfaces\\Job\\ShouldUpdate;",
            "use App\\Traits\\Jobs;",
            "use App\\Traits\\Relationships;",
            "use App\\Traits\\Sources;",
            "use App\\Traits\\Uploads;",
            "use Illuminate\\Database\\Eloquent\\Model;",
            "use Illuminate\\Http\\Request;",
            "use Jobs, Relationships, Sources, Uploads;"
        ],
        "reference_api": [
            "$this->getRequestInstance"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->getRequestInstance",
                "code": "public function getRequestInstance($request)\n    {\n        if (!is_array($request)) {\n            return $request;\n        }\n\n        $class = new class() extends FormRequest {};\n\n        return $class->merge($request);\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": " public function scopeCollect($query, $sort = 'name')",
        "start_line": "102",
        "end_line": "126",
        "file_path": "app/Abstracts/Model.php",
        "docstring": "This function scopes a query to collect records with optional sorting. It retrieves the sorting parameter from the request, applies search and sorting to the query, and checks if the request expects a JSON response and is not an API request. If true, it returns all records; otherwise, it paginates the results based on a limit from the request or a default setting.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "84212032fcca",
        "ground_truth": "public function scopeCollect($query, $sort = 'name')\n{\n    $request = request();\n    /**\n     * Modules that use the sort parameter in CRUD operations cause an error,\n     * so this sort parameter set back to old value after the query is executed.\n     *\n     * for Custom Fields module\n     */\n    $request_sort = $request->get('sort');\n    $query->usingSearchString()->sortable($sort);\n    if ($request->expectsJson() && $request->isNotApi()) {\n        return $query->get();\n    }\n    $request->merge(['sort' => $request_sort]);\n    // This line disabled because broken sortable issue.\n    //$request->offsetUnset('direction');\n    $limit = (int) $request->get('limit', setting('default.list_limit', '25'));\n    return $query->paginate($limit);\n}",
        "import_statements": [
            "use Akaunting\\Sortable\\Traits\\Sortable;",
            "use App\\Events\\Common\\SearchStringApplied;",
            "use App\\Events\\Common\\SearchStringApplying;",
            "use App\\Interfaces\\Export\\WithParentSheet;",
            "use App\\Traits\\DateTime;",
            "use App\\Traits\\Owners;",
            "use App\\Traits\\Sources;",
            "use App\\Traits\\Tenants;",
            "use GeneaLabs\\LaravelModelCaching\\Traits\\Cachable;",
            "use Illuminate\\Database\\Eloquent\\Builder;",
            "use Illuminate\\Database\\Eloquent\\Model as Eloquent;",
            "use Illuminate\\Database\\Eloquent\\SoftDeletes;",
            "use Laratrust\\Contracts\\Ownable;",
            "use Lorisleiva\\LaravelSearchString\\Concerns\\SearchString;",
            "use Cachable, DateTime, Owners, SearchString, SoftDeletes, Sortable, Sources, Tenants;"
        ],
        "reference_api": [
            "$request->expectsJson",
            "setting",
            "request",
            "$query->usingSearchString",
            "$query->get",
            "$request->merge",
            "$request->isNotApi",
            "$request->get",
            "$query->usingSearchString()->sortable",
            "$query->paginate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "$request->expectsJson",
            "setting",
            "request",
            "$query->usingSearchString",
            "$query->get",
            "$request->merge",
            "$request->isNotApi",
            "$request->get",
            "$query->usingSearchString()->sortable",
            "$query->paginate"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function calculateDocumentTotals($model)",
        "start_line": "106",
        "end_line": "132",
        "file_path": "app/Abstracts/Widget.php",
        "docstring": "This function calculates the open and overdue amounts for a given document model. It initializes the amounts and checks if the document status is 'paid', returning zeroes if true. For 'partial' status, it sums the payments from transactions. It then determines if the document is open or overdue based on the due date and adjusts the amounts accordingly. Finally, it returns the calculated open and overdue amounts.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1c1e693dfa46",
        "ground_truth": "public function calculateDocumentTotals($model)\n{\n    $open = $overdue = 0;\n    $today = Date::today()->toDateString();\n    if ($model->status == 'paid') {\n        return [$open, $overdue];\n    }\n    $payments = 0;\n    if ($model->status == 'partial') {\n        foreach ($model->transactions as $transaction) {\n            $payments += $transaction->getAmountConvertedToDefault();\n        }\n    }\n    // Check if the invoice/bill is open or overdue\n    if ($model->due_at > $today) {\n        $open += $model->getAmountConvertedToDefault() - $payments;\n    } else {\n        $overdue += $model->getAmountConvertedToDefault() - $payments;\n    }\n    return [$open, $overdue];\n}",
        "import_statements": [
            "use App\\Models\\Common\\Report;",
            "use App\\Traits\\Charts;",
            "use App\\Traits\\DateTime;",
            "use App\\Utilities\\Date;",
            "use App\\Utilities\\Reports;",
            "use Charts, DateTime;"
        ],
        "reference_api": [
            "Date::today",
            "$model->getAmountConvertedToDefault",
            "$transaction->getAmountConvertedToDefault",
            "Date::today()->toDateString"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Date::today",
            "$model->getAmountConvertedToDefault",
            "$transaction->getAmountConvertedToDefault",
            "Date::today()->toDateString"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function paginate($perPage = null, $columns = ['*'], $pageName = 'page', $page = null)",
        "start_line": "58",
        "end_line": "72",
        "file_path": "app/Builders/Category.php",
        "docstring": "This function paginates query results. It determines the current page and items per page, retrieves the total count of records, and fetches the appropriate subset of results for the current page. It returns a paginator instance with the results, total count, per-page limit, and current page, including the path and page name.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "30215756634a",
        "ground_truth": "public function paginate($perPage = null, $columns = ['*'], $pageName = 'page', $page = null)\n{\n    $page = $page ?: Paginator::resolveCurrentPage($pageName);\n    $perPage = $perPage ?: $this->model->getPerPage();\n    $results = ($total = $this->toBase()->getCountForPagination())\n    ? $this->forPage($page, $perPage)->getWithoutChildren($columns)\n    : $this->model->newCollection();\n    return $this->paginator($results, $total, $perPage, $page, [\n        'path' => Paginator::resolveCurrentPath(),\n        'pageName' => $pageName,\n    ]);\n}",
        "import_statements": [
            "use Illuminate\\Database\\Eloquent\\Builder;",
            "use Illuminate\\Pagination\\Paginator;"
        ],
        "reference_api": [
            "$this->forPage($page, $perPage)->getWithoutChildren",
            "Paginator::resolveCurrentPage",
            "Paginator::resolveCurrentPath",
            "$this->toBase",
            "$this->forPage",
            "$this->paginator",
            "$this->toBase()->getCountForPagination",
            "$this->model->getPerPage",
            "$this->model->newCollection"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "$this->forPage($page, $perPage)->getWithoutChildren",
            "Paginator::resolveCurrentPage",
            "Paginator::resolveCurrentPath",
            "$this->toBase",
            "$this->forPage",
            "$this->paginator",
            "$this->toBase()->getCountForPagination",
            "$this->model->getPerPage",
            "$this->model->newCollection"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function reconcile($request)",
        "start_line": "41",
        "end_line": "58",
        "file_path": "app/BulkActions/Banking/Reconciliations.php",
        "docstring": "This function reconciles selected records based on the provided request. It retrieves the reconciliations and processes each one within a database transaction, setting its status to reconciled and saving it. Additionally, it marks all related transactions within the reconciliation's date range and account ID as reconciled and saves them.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "4b0913f1528d",
        "ground_truth": "public function reconcile($request)\n{\n    $reconciliations = $this->getSelectedRecords($request);\n    foreach ($reconciliations as $reconciliation) {\n        \\DB::transaction(function () use ($reconciliation) {\n            $reconciliation->reconciled = 1;\n            $reconciliation->save();\n            Transaction::where('account_id', $reconciliation->account_id)\n                ->isNotReconciled()\n                ->whereBetween('paid_at', [$reconciliation->started_at, $reconciliation->ended_at])->each(function ($item) {\n                    $item->reconciled = 1;\n                    $item->save();\n                });\n        });\n    }\n}",
        "import_statements": [
            "use App\\Abstracts\\BulkAction;",
            "use App\\Models\\Banking\\Reconciliation;",
            "use App\\Models\\Banking\\Transaction;"
        ],
        "reference_api": [
            "Transaction::where('account_id', $reconciliation->account_id)\n                    ->isNotReconciled()\n                    ->whereBetween('paid_at', [$reconciliation->started_at, $reconciliation->ended_at])->each",
            "$this->getSelectedRecords",
            "Transaction::where('account_id', $reconciliation->account_id)->isNotReconciled",
            "$reconciliation->save",
            "Transaction::where",
            "Transaction::where('account_id', $reconciliation->account_id)\n                    ->isNotReconciled()->whereBetween",
            "\\DB::transaction",
            "$item->save"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Transaction::where('account_id', $reconciliation->account_id)\n                    ->isNotReconciled()\n                    ->whereBetween('paid_at', [$reconciliation->started_at, $reconciliation->ended_at])->each",
            "$this->getSelectedRecords",
            "Transaction::where('account_id', $reconciliation->account_id)->isNotReconciled",
            "$reconciliation->save",
            "Transaction::where",
            "Transaction::where('account_id', $reconciliation->account_id)\n                    ->isNotReconciled()->whereBetween",
            "\\DB::transaction",
            "$item->save"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function handle(): UserInvitation",
        "start_line": "26",
        "end_line": "54",
        "file_path": "app/Jobs/Auth/CreateInvitation.php",
        "docstring": "This function handles user invitations by performing a database transaction. It retrieves and deletes existing invitations for the user, creates a new invitation with a unique token, and attempts to dispatch a notification job to notify the user. If the notification fails, it throws an exception with an error message. Finally, it returns the newly created invitation.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ca77f30647a3",
        "ground_truth": "public function handle(): UserInvitation\n{\n    \\DB::transaction(function () {\n        $invitations = UserInvitation::where('user_id', $this->user->id)->get();\n        foreach ($invitations as $invitation) {\n            $invitation->delete();\n        }\n        $this->invitation = UserInvitation::create([\n            'user_id' => $this->user->id,\n            'token' => (string) Str::uuid(),\n            'created_by' => user_id(),\n            'created_from' => $this->getSourceName(request()),\n        ]);\n        $notification = new Notification($this->invitation);\n        try {\n            $this->dispatch(new NotifyUser($this->user, $notification));\n        } catch (TransportException $e) {\n            $message = trans('errors.title.500');\n            throw new Exception($message);\n        }\n    });\n    return $this->invitation;\n}",
        "import_statements": [
            "use App\\Abstracts\\Job;",
            "use App\\Models\\Auth\\UserInvitation;",
            "use App\\Notifications\\Auth\\Invitation as Notification;",
            "use App\\Traits\\Sources;",
            "use Exception;",
            "use Illuminate\\Support\\Str;",
            "use Symfony\\Component\\Mailer\\Exception\\TransportException;",
            "use Sources;"
        ],
        "reference_api": [
            "UserInvitation::create",
            "$this->getSourceName",
            "request",
            "$invitation->delete",
            "UserInvitation::where('user_id', $this->user->id)->get",
            "user_id",
            "Str::uuid",
            "$this->dispatch",
            "\\DB::transaction",
            "trans",
            "UserInvitation::where"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "UserInvitation::create",
            "$this->getSourceName",
            "request",
            "$invitation->delete",
            "UserInvitation::where('user_id', $this->user->id)->get",
            "user_id",
            "Str::uuid",
            "$this->dispatch",
            "\\DB::transaction",
            "trans",
            "UserInvitation::where"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "akaunting/akaunting",
        "function_declaration": "public function authorize(): void",
        "start_line": "58",
        "end_line": "69",
        "file_path": "app/Jobs/Banking/UpdateTransaction.php",
        "docstring": "This function authorizes a transaction by checking if it has been reconciled or if it is a transfer transaction. If the transaction is reconciled, it throws an exception with a warning message. If it is a transfer transaction, it throws an \"Unauthorized\" exception.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "f19cd66bc149",
        "ground_truth": "public function authorize(): void\n{\n    if ($this->model->reconciled) {\n        $message = trans('messages.warning.reconciled_tran');\n        throw new \\Exception($message);\n    }\n    if ($this->model->isTransferTransaction()) {\n        throw new \\Exception('Unauthorized');\n    }\n}",
        "import_statements": [
            "use App\\Abstracts\\Job;",
            "use App\\Events\\Banking\\TransactionUpdated;",
            "use App\\Events\\Banking\\TransactionUpdating;",
            "use App\\Interfaces\\Job\\ShouldUpdate;",
            "use App\\Jobs\\Banking\\CreateTransactionTaxes;",
            "use App\\Models\\Banking\\Transaction;"
        ],
        "reference_api": [
            "$this->model->isTransferTransaction",
            "trans"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "$this->model->isTransferTransaction",
            "trans"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public boolean doTableFilter(String tableName)",
        "start_line": "50",
        "end_line": "66",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/config/TenantConfig.java",
        "docstring": "This function filters access to specific tables based on the tenant ID extracted from the request's access token. If the tenant ID is not zero, it allows access to certain predefined tables, otherwise, it denies access. It returns a boolean indicating whether access is permitted.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5d31e8e07329",
        "ground_truth": "public boolean doTableFilter(String tableName) {\n    //\u83b7\u53d6\u5f00\u542f\u72b6\u6001\n    Boolean res = true;\n    String token = request.getHeader(\"X-Access-Token\");\n    Long tenantId = Tools.getTenantIdByToken(token);\n    if (tenantId!=0L) {\n        // \u8fd9\u91cc\u53ef\u4ee5\u5224\u65ad\u662f\u5426\u8fc7\u6ee4\u8868\n        if (\"jsh_material_property\".equals(tableName) || \"jsh_sequence\".equals(tableName)\n                || \"jsh_function\".equals(tableName) || \"jsh_platform_config\".equals(tableName)\n                || \"jsh_tenant\".equals(tableName)) {\n            res = true;\n        } else {\n            res = false;\n        }\n    }\n    return res;\n}",
        "import_statements": [
            "import com.baomidou.mybatisplus.core.parser.ISqlParser;",
            "import com.baomidou.mybatisplus.core.parser.ISqlParserFilter;",
            "import com.baomidou.mybatisplus.core.parser.SqlParserHelper;",
            "import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;",
            "import com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor;",
            "import com.baomidou.mybatisplus.extension.plugins.tenant.TenantHandler;",
            "import com.baomidou.mybatisplus.extension.plugins.tenant.TenantSqlParser;",
            "import com.jsh.erp.utils.Tools;",
            "import net.sf.jsqlparser.expression.Expression;",
            "import net.sf.jsqlparser.expression.LongValue;",
            "import org.apache.ibatis.mapping.MappedStatement;",
            "import org.apache.ibatis.reflection.MetaObject;",
            "import org.mybatis.spring.mapper.MapperScannerConfigurer;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.stereotype.Service;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.util.ArrayList;",
            "import java.util.List;"
        ],
        "reference_api": [
            "equals",
            "getHeader",
            "getTenantIdByToken"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getHeader",
            "getTenantIdByToken"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public MapperScannerConfigurer mapperScannerConfigurer()",
        "start_line": "103",
        "end_line": "107",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/config/TenantConfig.java",
        "docstring": "This function configures a MapperScannerConfigurer bean, setting its base package to \u201ccom.jsh.erp.datasource.mappers*\" to scan for mapper interfaces. It returns the configured MapperScannerConfigurer instance.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1c543171d426",
        "ground_truth": "public MapperScannerConfigurer mapperScannerConfigurer() {\n    MapperScannerConfigurer scannerConfigurer = new MapperScannerConfigurer();\n    scannerConfigurer.setBasePackage(\"com.jsh.erp.datasource.mappers*\");\n    return scannerConfigurer;\n}",
        "import_statements": [
            "import com.baomidou.mybatisplus.core.parser.ISqlParser;",
            "import com.baomidou.mybatisplus.core.parser.ISqlParserFilter;",
            "import com.baomidou.mybatisplus.core.parser.SqlParserHelper;",
            "import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;",
            "import com.baomidou.mybatisplus.extension.plugins.PerformanceInterceptor;",
            "import com.baomidou.mybatisplus.extension.plugins.tenant.TenantHandler;",
            "import com.baomidou.mybatisplus.extension.plugins.tenant.TenantSqlParser;",
            "import com.jsh.erp.utils.Tools;",
            "import net.sf.jsqlparser.expression.Expression;",
            "import net.sf.jsqlparser.expression.LongValue;",
            "import org.apache.ibatis.mapping.MappedStatement;",
            "import org.apache.ibatis.reflection.MetaObject;",
            "import org.mybatis.spring.mapper.MapperScannerConfigurer;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.stereotype.Service;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.util.ArrayList;",
            "import java.util.List;"
        ],
        "reference_api": [
            "setBasePackage"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setBasePackage"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public String findBySelect(HttpServletRequest request) throws Exception",
        "start_line": "50",
        "end_line": "71",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/AccountController.java",
        "docstring": "This function retrieves a list of accounts and returns it as a JSON string. It fetches the account data using accountService, converts it to JSON format with account IDs and names, and handles any exceptions by logging an error message and returning a failure message.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "6c4f4f373ece",
        "ground_truth": "public String findBySelect(HttpServletRequest request) throws Exception {\n    String res = null;\n    try {\n        List<Account> dataList = accountService.findBySelect();\n        //\u5b58\u653e\u6570\u636ejson\u6570\u7ec4\n        JSONArray dataArray = new JSONArray();\n        if (null != dataList) {\n            for (Account account : dataList) {\n                JSONObject item = new JSONObject();\n                item.put(\"Id\", account.getId());\n                //\u7ed3\u7b97\u8d26\u6237\u540d\u79f0\n                item.put(\"AccountName\", account.getName());\n                dataArray.add(item);\n            }\n        }\n        res = dataArray.toJSONString();\n    } catch(Exception e){\n        logger.error(e.getMessage(), e);\n        res = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n    }\n    return res;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.datasource.entities.Account;",
            "import com.jsh.erp.datasource.vo.AccountVo4InOutList;",
            "import com.jsh.erp.datasource.vo.AccountVo4List;",
            "import com.jsh.erp.service.account.AccountService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.ErpInfo;",
            "import com.jsh.erp.utils.StringUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.math.BigDecimal;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import static com.jsh.erp.utils.ResponseJsonUtil.returnJson;"
        ],
        "reference_api": [
            "getName",
            "error",
            "getMessage",
            "findBySelect",
            "getId",
            "add",
            "put",
            "toJSONString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "findBySelect",
                "code": "@GetMapping(value = \"/findBySelect\")\n    @ApiOperation(value = \"\u67e5\u627e\u7ed3\u7b97\u8d26\u6237\u4fe1\u606f-\u4e0b\u62c9\u6846\")\n    public String findBySelect(HttpServletRequest request) throws Exception {\n        String res = null;\n        try {\n            List<Account> dataList = accountService.findBySelect();\n            //\u5b58\u653e\u6570\u636ejson\u6570\u7ec4\n            JSONArray dataArray = new JSONArray();\n            if (null != dataList) {\n                for (Account account : dataList) {\n                    JSONObject item = new JSONObject();\n                    item.put(\"Id\", account.getId());\n                    //\u7ed3\u7b97\u8d26\u6237\u540d\u79f0\n                    item.put(\"AccountName\", account.getName());\n                    dataArray.add(item);\n                }\n            }\n            res = dataArray.toJSONString();\n        } catch(Exception e){\n            logger.error(e.getMessage(), e);\n            res = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n        }\n        return res;\n    }"
            }
        ],
        "third_party": [
            "getName",
            "error",
            "getMessage",
            "getId",
            "add",
            "put",
            "toJSONString"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": " public BaseResponseInfo listWithBalance(@RequestParam(\"name\") String name,\n                                            @RequestParam(\"serialNo\") String serialNo,\n                                            @RequestParam(\"currentPage\") Integer currentPage,\n                                            @RequestParam(\"pageSize\") Integer pageSize,\n                                            HttpServletRequest request) throws Exception",
        "start_line": "179",
        "end_line": "199",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/AccountController.java",
        "docstring": "This function returns a paginated list of accounts with their balances based on the provided name and serial number parameters. It constructs a response object, queries the account service for the list of accounts and their count, and populates the response with the result. If an exception occurs, it logs the error and sets the response code and message accordingly.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "6f5d14a69cc9",
        "ground_truth": "public BaseResponseInfo listWithBalance(@RequestParam(\"name\") String name,\n                                        @RequestParam(\"serialNo\") String serialNo,\n                                        @RequestParam(\"currentPage\") Integer currentPage,\n                                        @RequestParam(\"pageSize\") Integer pageSize,\n                                        HttpServletRequest request) throws Exception {\n    BaseResponseInfo res = new BaseResponseInfo();\n    try {\n        Map<String, Object> map = new HashMap<>();\n        List<AccountVo4List> list = accountService.listWithBalance(StringUtil.toNull(name), StringUtil.toNull(serialNo), (currentPage-1)*pageSize, pageSize);\n        Long count = accountService.listWithBalanceCount(StringUtil.toNull(name), StringUtil.toNull(serialNo));\n        map.put(\"rows\", list);\n        map.put(\"total\", count);\n        res.code = 200;\n        res.data = map;\n    } catch(Exception e){\n        logger.error(e.getMessage(), e);\n        res.code = 500;\n        res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n    }\n    return res;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.datasource.entities.Account;",
            "import com.jsh.erp.datasource.vo.AccountVo4InOutList;",
            "import com.jsh.erp.datasource.vo.AccountVo4List;",
            "import com.jsh.erp.service.account.AccountService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.ErpInfo;",
            "import com.jsh.erp.utils.StringUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.math.BigDecimal;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import static com.jsh.erp.utils.ResponseJsonUtil.returnJson;"
        ],
        "reference_api": [
            "error",
            "toNull",
            "getMessage",
            "listWithBalance",
            "put",
            "listWithBalanceCount"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "listWithBalance",
                "code": "@GetMapping(value = \"/listWithBalance\")\n    @ApiOperation(value = \"\u83b7\u53d6\u5e26\u4f59\u989d\u7684\u62a5\u8868\")\n    public BaseResponseInfo listWithBalance(@RequestParam(\"name\") String name,\n                                            @RequestParam(\"serialNo\") String serialNo,\n                                            @RequestParam(\"currentPage\") Integer currentPage,\n                                            @RequestParam(\"pageSize\") Integer pageSize,\n                                            HttpServletRequest request) throws Exception {\n        BaseResponseInfo res = new BaseResponseInfo();\n        try {\n            Map<String, Object> map = new HashMap<>();\n            List<AccountVo4List> list = accountService.listWithBalance(StringUtil.toNull(name), StringUtil.toNull(serialNo), (currentPage-1)*pageSize, pageSize);\n            Long count = accountService.listWithBalanceCount(StringUtil.toNull(name), StringUtil.toNull(serialNo));\n            map.put(\"rows\", list);\n            map.put(\"total\", count);\n            res.code = 200;\n            res.data = map;\n        } catch(Exception e){\n            logger.error(e.getMessage(), e);\n            res.code = 500;\n            res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n        }\n        return res;\n    }"
            }
        ],
        "third_party": [
            "error",
            "toNull",
            "getMessage",
            "put",
            "listWithBalanceCount"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public BaseResponseInfo getStatistics(@RequestParam(\"name\") String name,\n                                          @RequestParam(\"serialNo\") String serialNo,\n                                          HttpServletRequest request) throws Exception",
        "start_line": "208",
        "end_line": "222",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/AccountController.java",
        "docstring": "This function retrieves statistics based on provided name and serial number parameters. It initializes a response object and calls the account service to fetch statistics, handling potential exceptions. If successful, it sets the response code to 200 and includes the data; if an error occurs, it logs the error and sets the response code to 500 with an error message.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "270b0f9fde62",
        "ground_truth": "public BaseResponseInfo getStatistics(@RequestParam(\"name\") String name,\n                                      @RequestParam(\"serialNo\") String serialNo,\n                                      HttpServletRequest request) throws Exception {\n    BaseResponseInfo res = new BaseResponseInfo();\n    try {\n        Map<String, Object> map = accountService.getStatistics(StringUtil.toNull(name), StringUtil.toNull(serialNo));\n        res.code = 200;\n        res.data = map;\n    } catch(Exception e){\n        logger.error(e.getMessage(), e);\n        res.code = 500;\n        res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n    }\n    return res;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.datasource.entities.Account;",
            "import com.jsh.erp.datasource.vo.AccountVo4InOutList;",
            "import com.jsh.erp.datasource.vo.AccountVo4List;",
            "import com.jsh.erp.service.account.AccountService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.ErpInfo;",
            "import com.jsh.erp.utils.StringUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.math.BigDecimal;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import static com.jsh.erp.utils.ResponseJsonUtil.returnJson;"
        ],
        "reference_api": [
            "getMessage",
            "error",
            "getStatistics",
            "toNull"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getStatistics",
                "code": "@GetMapping(value = \"/getStatistics\")\n    @ApiOperation(value = \"\u7ed3\u7b97\u8d26\u6237\u7684\u7edf\u8ba1\")\n    public BaseResponseInfo getStatistics(@RequestParam(\"name\") String name,\n                                          @RequestParam(\"serialNo\") String serialNo,\n                                          HttpServletRequest request) throws Exception {\n        BaseResponseInfo res = new BaseResponseInfo();\n        try {\n            Map<String, Object> map = accountService.getStatistics(StringUtil.toNull(name), StringUtil.toNull(serialNo));\n            res.code = 200;\n            res.data = map;\n        } catch(Exception e){\n            logger.error(e.getMessage(), e);\n            res.code = 500;\n            res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n        }\n        return res;\n    }"
            }
        ],
        "third_party": [
            "getMessage",
            "error",
            "toNull"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": " public BaseResponseInfo getDetailByNumber(@RequestParam(\"billNo\") String billNo,\n                                              HttpServletRequest request)throws Exception",
        "start_line": "101",
        "end_line": "118",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/AccountHeadController.java",
        "docstring": "This function retrieves detailed information for a specific bill number. It initializes a response object and attempts to fetch the details using the account head service. If details are found, the first item is included in the response with a status code of 200. In case of an exception, it logs the error and sets the response code to 500 with an error message.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "4b523b1c91d7",
        "ground_truth": "public BaseResponseInfo getDetailByNumber(@RequestParam(\"billNo\") String billNo,\n                                          HttpServletRequest request)throws Exception {\n    BaseResponseInfo res = new BaseResponseInfo();\n    AccountHeadVo4ListEx ahl = new AccountHeadVo4ListEx();\n    try {\n        List<AccountHeadVo4ListEx> list = accountHeadService.getDetailByNumber(billNo);\n        if(list.size()>0) {\n            ahl = list.get(0);\n        }\n        res.code = 200;\n        res.data = ahl;\n    } catch(Exception e){\n        logger.error(e.getMessage(), e);\n        res.code = 500;\n        res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n    }\n    return res;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.constants.BusinessConstants;",
            "import com.jsh.erp.constants.ExceptionConstants;",
            "import com.jsh.erp.datasource.entities.AccountHead;",
            "import com.jsh.erp.datasource.entities.AccountHeadVo4Body;",
            "import com.jsh.erp.datasource.entities.AccountHeadVo4ListEx;",
            "import com.jsh.erp.service.accountHead.AccountHeadService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.ErpInfo;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.math.BigDecimal;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import static com.jsh.erp.utils.ResponseJsonUtil.returnJson;"
        ],
        "reference_api": [
            "error",
            "getMessage",
            "size",
            "get",
            "getDetailByNumber"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getDetailByNumber",
                "code": "@GetMapping(value = \"/getDetailByNumber\")\n    @ApiOperation(value = \"\u6839\u636e\u7f16\u53f7\u67e5\u8be2\u5355\u636e\u4fe1\u606f\")\n    public BaseResponseInfo getDetailByNumber(@RequestParam(\"billNo\") String billNo,\n                                              HttpServletRequest request)throws Exception {\n        BaseResponseInfo res = new BaseResponseInfo();\n        AccountHeadVo4ListEx ahl = new AccountHeadVo4ListEx();\n        try {\n            List<AccountHeadVo4ListEx> list = accountHeadService.getDetailByNumber(billNo);\n            if(list.size()>0) {\n                ahl = list.get(0);\n            }\n            res.code = 200;\n            res.data = ahl;\n        } catch(Exception e){\n            logger.error(e.getMessage(), e);\n            res.code = 500;\n            res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n        }\n        return res;\n    }"
            }
        ],
        "third_party": [
            "error",
            "getMessage",
            "size",
            "get"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public BaseResponseInfo findDepotByCurrentUser(HttpServletRequest request) throws Exception",
        "start_line": "129",
        "end_line": "141",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/DepotController.java",
        "docstring": "This function retrieves depot information for the current user. It initializes a response object and calls the depot service to fetch the data, handling potential exceptions. If successful, it sets the response code to 200 and includes the data; if an error occurs, it logs the error and sets the response code to 500 with an error message.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "6cc16456f636",
        "ground_truth": "public BaseResponseInfo findDepotByCurrentUser(HttpServletRequest request) throws Exception{\n    BaseResponseInfo res = new BaseResponseInfo();\n    try {\n        JSONArray arr = depotService.findDepotByCurrentUser();\n        res.code = 200;\n        res.data = arr;\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n        res.code = 500;\n        res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n    }\n    return res;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.constants.BusinessConstants;",
            "import com.jsh.erp.constants.ExceptionConstants;",
            "import com.jsh.erp.datasource.entities.Depot;",
            "import com.jsh.erp.datasource.entities.DepotEx;",
            "import com.jsh.erp.datasource.entities.MaterialCurrentStock;",
            "import com.jsh.erp.datasource.entities.MaterialInitialStock;",
            "import com.jsh.erp.exception.BusinessRunTimeException;",
            "import com.jsh.erp.service.depot.DepotService;",
            "import com.jsh.erp.service.material.MaterialService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.service.user.UserService;",
            "import com.jsh.erp.service.userBusiness.UserBusinessService;",
            "import com.jsh.erp.utils.*;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.dao.DataAccessException;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.io.IOException;",
            "import java.math.BigDecimal;",
            "import java.util.*;",
            "import static com.jsh.erp.utils.ResponseJsonUtil.returnJson;"
        ],
        "reference_api": [
            "getMessage",
            "findDepotByCurrentUser",
            "error"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "findDepotByCurrentUser",
                "code": "@GetMapping(value = \"/findDepotByCurrentUser\")\n    @ApiOperation(value = \"\u83b7\u53d6\u5f53\u524d\u7528\u6237\u62e5\u6709\u6743\u9650\u7684\u4ed3\u5e93\u5217\u8868\")\n    public BaseResponseInfo findDepotByCurrentUser(HttpServletRequest request) throws Exception{\n        BaseResponseInfo res = new BaseResponseInfo();\n        try {\n            JSONArray arr = depotService.findDepotByCurrentUser();\n            res.code = 200;\n            res.data = arr;\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            res.code = 500;\n            res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n        }\n        return res;\n    }"
            }
        ],
        "third_party": [
            "getMessage",
            "error"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public JSONArray findRoleFunction(@RequestParam(\"UBType\") String type, @RequestParam(\"UBKeyId\") String keyId,\n                                 HttpServletRequest request)throws Exception",
        "start_line": "158",
        "end_line": "195",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/FunctionController.java",
        "docstring": "This function retrieves role functions based on provided type and keyId parameters. It initializes a JSON array and fetches a list of functions. It creates a JSON object to represent the function list and filters out \"\u7cfb\u7edf\u7ba1\u7406\" for non-admin users based on the tenant ID from the request token. It adds the filtered functions to the JSON array and nests this array within the main JSON object. Finally, it adds the main JSON object to the JSON array and returns it, logging any exceptions that occur.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5ba6a616b49b",
        "ground_truth": "public JSONArray findRoleFunction(@RequestParam(\"UBType\") String type, @RequestParam(\"UBKeyId\") String keyId,\n                             HttpServletRequest request)throws Exception {\n    JSONArray arr = new JSONArray();\n    try {\n        List<Function> dataListFun = functionService.findRoleFunction(\"0\");\n        //\u5f00\u59cb\u62fc\u63a5json\u6570\u636e\n        JSONObject outer = new JSONObject();\n        outer.put(\"id\", 0);\n        outer.put(\"key\", 0);\n        outer.put(\"value\", 0);\n        outer.put(\"title\", \"\u529f\u80fd\u5217\u8868\");\n        outer.put(\"attributes\", \"\u529f\u80fd\u5217\u8868\");\n        //\u5b58\u653e\u6570\u636ejson\u6570\u7ec4\n        JSONArray dataArray = new JSONArray();\n        if (null != dataListFun) {\n            //\u6839\u636e\u6761\u4ef6\u4ece\u5217\u8868\u91cc\u9762\u79fb\u9664\"\u7cfb\u7edf\u7ba1\u7406\"\n            List<Function> dataList = new ArrayList<>();\n            for (Function fun : dataListFun) {\n                String token = request.getHeader(\"X-Access-Token\");\n                Long tenantId = Tools.getTenantIdByToken(token);\n                if (tenantId!=0L) {\n                    if(!(\"\u7cfb\u7edf\u7ba1\u7406\").equals(fun.getName())) {\n                        dataList.add(fun);\n                    }\n                } else {\n                    //\u8d85\u7ba1\n                    dataList.add(fun);\n                }\n            }\n            dataArray = getFunctionList(dataList, type, keyId);\n            outer.put(\"children\", dataArray);\n        }\n        arr.add(outer);\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    }\n    return arr;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.constants.ExceptionConstants;",
            "import com.jsh.erp.datasource.entities.Function;",
            "import com.jsh.erp.datasource.entities.SystemConfig;",
            "import com.jsh.erp.datasource.entities.User;",
            "import com.jsh.erp.datasource.entities.UserBusiness;",
            "import com.jsh.erp.exception.BusinessRunTimeException;",
            "import com.jsh.erp.service.functions.FunctionService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.service.userBusiness.UserBusinessService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.ErpInfo;",
            "import com.jsh.erp.utils.StringUtil;",
            "import com.jsh.erp.utils.Tools;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.dao.DataAccessException;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.util.ArrayList;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import static com.jsh.erp.utils.ResponseJsonUtil.returnJson;"
        ],
        "reference_api": [
            "getName",
            "equals",
            "error",
            "findRoleFunction",
            "getTenantIdByToken",
            "getMessage",
            "getFunctionList",
            "add",
            "put",
            "getHeader"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "findRoleFunction",
                "code": "@GetMapping(value = \"/findRoleFunction\")\n    @ApiOperation(value = \"\u89d2\u8272\u5bf9\u5e94\u529f\u80fd\u663e\u793a\")\n    public JSONArray findRoleFunction(@RequestParam(\"UBType\") String type, @RequestParam(\"UBKeyId\") String keyId,\n                                 HttpServletRequest request)throws Exception {\n        JSONArray arr = new JSONArray();\n        try {\n            List<Function> dataListFun = functionService.findRoleFunction(\"0\");\n            //\u5f00\u59cb\u62fc\u63a5json\u6570\u636e\n            JSONObject outer = new JSONObject();\n            outer.put(\"id\", 0);\n            outer.put(\"key\", 0);\n            outer.put(\"value\", 0);\n            outer.put(\"title\", \"\u529f\u80fd\u5217\u8868\");\n            outer.put(\"attributes\", \"\u529f\u80fd\u5217\u8868\");\n            //\u5b58\u653e\u6570\u636ejson\u6570\u7ec4\n            JSONArray dataArray = new JSONArray();\n            if (null != dataListFun) {\n                //\u6839\u636e\u6761\u4ef6\u4ece\u5217\u8868\u91cc\u9762\u79fb\u9664\"\u7cfb\u7edf\u7ba1\u7406\"\n                List<Function> dataList = new ArrayList<>();\n                for (Function fun : dataListFun) {\n                    String token = request.getHeader(\"X-Access-Token\");\n                    Long tenantId = Tools.getTenantIdByToken(token);\n                    if (tenantId!=0L) {\n                        if(!(\"\u7cfb\u7edf\u7ba1\u7406\").equals(fun.getName())) {\n                            dataList.add(fun);\n                        }\n                    } else {\n                        //\u8d85\u7ba1\n                        dataList.add(fun);\n                    }\n                }\n                dataArray = getFunctionList(dataList, type, keyId);\n                outer.put(\"children\", dataArray);\n            }\n            arr.add(outer);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        }\n        return arr;\n    }"
            },
            {
                "name": "getFunctionList",
                "code": "public JSONArray getFunctionList(List<Function> dataList, String type, String keyId) throws Exception {\n        JSONArray dataArray = new JSONArray();\n        //\u83b7\u53d6\u6743\u9650\u4fe1\u606f\n        String ubValue = userBusinessService.getUBValueByTypeAndKeyId(type, keyId);\n        if (null != dataList) {\n            for (Function function : dataList) {\n                JSONObject item = new JSONObject();\n                item.put(\"id\", function.getId());\n                item.put(\"key\", function.getId());\n                item.put(\"value\", function.getId());\n                item.put(\"title\", function.getName());\n                item.put(\"attributes\", function.getName());\n                List<Function> funList = functionService.findRoleFunction(function.getNumber());\n                if(funList.size()>0) {\n                    JSONArray funArr = getFunctionList(funList, type, keyId);\n                    item.put(\"children\", funArr);\n                    dataArray.add(item);\n                } else {\n                    Boolean flag = ubValue.contains(\"[\" + function.getId().toString() + \"]\");\n                    item.put(\"checked\", flag);\n                    dataArray.add(item);\n                }\n            }\n        }\n        return dataArray;\n    }"
            }
        ],
        "third_party": [
            "getName",
            "error",
            "getTenantIdByToken",
            "getMessage",
            "add",
            "put",
            "getHeader"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public BaseResponseInfo getInfoByKey(@RequestParam(\"platformKey\") String platformKey,\n                                            HttpServletRequest request)throws Exception ",
        "start_line": "125",
        "end_line": "138",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/PlatformConfigController.java",
        "docstring": "This function retrieves platform configuration information based on a provided platform key. It initializes a response object, attempts to fetch the configuration using the platformConfigService, and sets the response code to 200 with the retrieved data if successful. If an exception occurs, it logs the error, sets the response code to 500, and includes an error message.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "d28a903c50e1",
        "ground_truth": "public BaseResponseInfo getInfoByKey(@RequestParam(\"platformKey\") String platformKey,\n                                        HttpServletRequest request)throws Exception {\n    BaseResponseInfo res = new BaseResponseInfo();\n    try {\n        PlatformConfig platformConfig = platformConfigService.getInfoByKey(platformKey);\n        res.code = 200;\n        res.data = platformConfig;\n    } catch(Exception e){\n        logger.error(e.getMessage(), e);\n        res.code = 500;\n        res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n    }\n    return res;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.datasource.entities.PlatformConfig;",
            "import com.jsh.erp.datasource.entities.User;",
            "import com.jsh.erp.service.platformConfig.PlatformConfigService;",
            "import com.jsh.erp.service.user.UserService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.ErpInfo;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.beans.factory.annotation.Value;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.util.HashMap;",
            "import java.util.Map;",
            "import static com.jsh.erp.utils.ResponseJsonUtil.returnJson;"
        ],
        "reference_api": [
            "getMessage",
            "getInfoByKey",
            "error"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getInfoByKey",
                "code": "@GetMapping(value = \"/getInfoByKey\")\n    @ApiOperation(value = \"\u6839\u636eplatformKey\u67e5\u8be2\u4fe1\u606f\")\n    public BaseResponseInfo getInfoByKey(@RequestParam(\"platformKey\") String platformKey,\n                                            HttpServletRequest request)throws Exception {\n        BaseResponseInfo res = new BaseResponseInfo();\n        try {\n            PlatformConfig platformConfig = platformConfigService.getInfoByKey(platformKey);\n            res.code = 200;\n            res.data = platformConfig;\n        } catch(Exception e){\n            logger.error(e.getMessage(), e);\n            res.code = 500;\n            res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n        }\n        return res;\n    }"
            }
        ],
        "third_party": [
            "getMessage",
            "error"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public BaseResponseInfo getCurrentInfo(HttpServletRequest request) throws Exception",
        "start_line": "76",
        "end_line": "90",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/SystemConfigController.java",
        "docstring": "This function retrieves the current system configuration information. It initializes a response object and attempts to fetch the system configuration list from the service. If successful, it sets the response code to 200 and includes the first item from the list in the response data. If an exception occurs, it logs the error, sets the response code to 500, and includes an error message in the response data.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a1dd3b347c6c",
        "ground_truth": "public BaseResponseInfo getCurrentInfo(HttpServletRequest request) throws Exception {\n    BaseResponseInfo res = new BaseResponseInfo();\n    try{\n        List<SystemConfig> list = systemConfigService.getSystemConfig();\n        res.code = 200;\n        if(list.size()>0) {\n            res.data = list.get(0);\n        }\n    } catch(Exception e){\n        logger.error(e.getMessage(), e);\n        res.code = 500;\n        res.data = \"\u83b7\u53d6\u6570\u636e\u5931\u8d25\";\n    }\n    return res;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.datasource.entities.SystemConfig;",
            "import com.jsh.erp.service.depot.DepotService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.service.user.UserService;",
            "import com.jsh.erp.service.userBusiness.UserBusinessService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.FileUtils;",
            "import com.jsh.erp.utils.StringUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.beans.factory.annotation.Value;",
            "import org.springframework.util.AntPathMatcher;",
            "import org.springframework.web.bind.annotation.*;",
            "import org.springframework.web.multipart.MultipartFile;",
            "import org.springframework.web.multipart.MultipartHttpServletRequest;",
            "import org.springframework.web.servlet.HandlerMapping;",
            "import javax.annotation.Resource;",
            "import javax.imageio.ImageIO;",
            "import javax.servlet.http.HttpServletRequest;",
            "import javax.servlet.http.HttpServletResponse;",
            "import java.awt.image.BufferedImage;",
            "import java.io.*;",
            "import java.net.HttpURLConnection;",
            "import java.net.URL;",
            "import java.util.List;"
        ],
        "reference_api": [
            "error",
            "getMessage",
            "size",
            "get",
            "getSystemConfig"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "error",
            "getMessage",
            "size",
            "get",
            "getSystemConfig"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public BaseResponseInfo upload(HttpServletRequest request, HttpServletResponse response)",
        "start_line": "127",
        "end_line": "152",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/SystemConfigController.java",
        "docstring": "This function handles file upload requests. It retrieves the business path and the uploaded file from the request. Depending on the file upload type, it saves the file either locally or to AliOss. It then sets the response code and data based on the success or failure of the upload, logging any exceptions and returning the response.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "89d56baea0fa",
        "ground_truth": "public BaseResponseInfo upload(HttpServletRequest request, HttpServletResponse response) {\n    BaseResponseInfo res = new BaseResponseInfo();\n    try {\n        String savePath = \"\";\n        String bizPath = request.getParameter(\"biz\");\n        MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n        MultipartFile file = multipartRequest.getFile(\"file\");// \u83b7\u53d6\u4e0a\u4f20\u6587\u4ef6\u5bf9\u8c61\n        if(fileUploadType == 1) {\n            savePath = systemConfigService.uploadLocal(file, bizPath, request);\n        } else if(fileUploadType == 2) {\n            savePath = systemConfigService.uploadAliOss(file, bizPath, request);\n        }\n        if(StringUtil.isNotEmpty(savePath)){\n            res.code = 200;\n            res.data = savePath;\n        }else {\n            res.code = 500;\n            res.data = \"\u4e0a\u4f20\u5931\u8d25\uff01\";\n        }\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n        res.code = 500;\n        res.data = \"\u4e0a\u4f20\u5931\u8d25\uff01\";\n    }\n    return res;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.datasource.entities.SystemConfig;",
            "import com.jsh.erp.service.depot.DepotService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.service.user.UserService;",
            "import com.jsh.erp.service.userBusiness.UserBusinessService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.FileUtils;",
            "import com.jsh.erp.utils.StringUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.beans.factory.annotation.Value;",
            "import org.springframework.util.AntPathMatcher;",
            "import org.springframework.web.bind.annotation.*;",
            "import org.springframework.web.multipart.MultipartFile;",
            "import org.springframework.web.multipart.MultipartHttpServletRequest;",
            "import org.springframework.web.servlet.HandlerMapping;",
            "import javax.annotation.Resource;",
            "import javax.imageio.ImageIO;",
            "import javax.servlet.http.HttpServletRequest;",
            "import javax.servlet.http.HttpServletResponse;",
            "import java.awt.image.BufferedImage;",
            "import java.io.*;",
            "import java.net.HttpURLConnection;",
            "import java.net.URL;",
            "import java.util.List;"
        ],
        "reference_api": [
            "error",
            "getFile",
            "uploadLocal",
            "getMessage",
            "isNotEmpty",
            "uploadAliOss",
            "getParameter"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "error",
            "getFile",
            "uploadLocal",
            "getMessage",
            "isNotEmpty",
            "uploadAliOss",
            "getParameter"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": " public void exportExcelByParam(@RequestBody JSONObject jsonObject,\n                                   HttpServletResponse response)",
        "start_line": "279",
        "end_line": "290",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/controller/SystemConfigController.java",
        "docstring": "This function exports data to an Excel file based on parameters provided in a JSON object. It extracts the title, head, tip, and data list from the JSON object and calls a service to perform the export, writing the output to the HTTP response. It handles and logs any exceptions that occur during the process.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9a2a7af4614e",
        "ground_truth": "public void exportExcelByParam(@RequestBody JSONObject jsonObject,\n                               HttpServletResponse response) {\n    try {\n        String title = jsonObject.getString(\"title\");\n        String head = jsonObject.getString(\"head\");\n        String tip = jsonObject.getString(\"tip\");\n        JSONArray arr = jsonObject.getJSONArray(\"list\");\n        systemConfigService.exportExcelByParam(title, head, tip, arr, response);\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    }\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.datasource.entities.SystemConfig;",
            "import com.jsh.erp.service.depot.DepotService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.service.user.UserService;",
            "import com.jsh.erp.service.userBusiness.UserBusinessService;",
            "import com.jsh.erp.utils.BaseResponseInfo;",
            "import com.jsh.erp.utils.FileUtils;",
            "import com.jsh.erp.utils.StringUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.beans.factory.annotation.Value;",
            "import org.springframework.util.AntPathMatcher;",
            "import org.springframework.web.bind.annotation.*;",
            "import org.springframework.web.multipart.MultipartFile;",
            "import org.springframework.web.multipart.MultipartHttpServletRequest;",
            "import org.springframework.web.servlet.HandlerMapping;",
            "import javax.annotation.Resource;",
            "import javax.imageio.ImageIO;",
            "import javax.servlet.http.HttpServletRequest;",
            "import javax.servlet.http.HttpServletResponse;",
            "import java.awt.image.BufferedImage;",
            "import java.io.*;",
            "import java.net.HttpURLConnection;",
            "import java.net.URL;",
            "import java.util.List;"
        ],
        "reference_api": [
            "getString",
            "error",
            "getJSONArray",
            "getMessage",
            "exportExcelByParam"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "exportExcelByParam",
                "code": "@PostMapping(value = \"/exportExcelByParam\")\n    @ApiOperation(value = \"\u751f\u6210excel\u8868\u683c\")\n    public void exportExcelByParam(@RequestBody JSONObject jsonObject,\n                                   HttpServletResponse response) {\n        try {\n            String title = jsonObject.getString(\"title\");\n            String head = jsonObject.getString(\"head\");\n            String tip = jsonObject.getString(\"tip\");\n            JSONArray arr = jsonObject.getJSONArray(\"list\");\n            systemConfigService.exportExcelByParam(title, head, tip, arr, response);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        }\n    }"
            }
        ],
        "third_party": [
            "getString",
            "error",
            "getJSONArray",
            "getMessage"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public int insertAccount(JSONObject obj, HttpServletRequest request)throws Exception ",
        "start_line": "167",
        "end_line": "188",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/service/account/AccountService.java",
        "docstring": "This function inserts a new account based on the provided JSON object. It initializes the account, sets the initial amount to zero if not specified, and determines if the account should be set as the default based on existing accounts. The account is then enabled and inserted into the database. The operation is logged, and any exceptions are caught and logged as failures. The function returns the result of the insert operation.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "aa230640b07b",
        "ground_truth": "public int insertAccount(JSONObject obj, HttpServletRequest request)throws Exception {\n    Account account = JSONObject.parseObject(obj.toJSONString(), Account.class);\n    if(account.getInitialAmount() == null) {\n        account.setInitialAmount(BigDecimal.ZERO);\n    }\n    List<Account> accountList = getAccountByParam(null, null);\n    if(accountList.size() == 0) {\n        account.setIsDefault(true);\n    } else {\n        account.setIsDefault(false);\n    }\n    account.setEnabled(true);\n    int result=0;\n    try{\n        result = accountMapper.insertSelective(account);\n        logService.insertLog(\"\u8d26\u6237\",\n                new StringBuffer(BusinessConstants.LOG_OPERATION_TYPE_ADD).append(account.getName()).toString(), request);\n    }catch(Exception e){\n        JshException.writeFail(logger, e);\n    }\n    return result;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.constants.BusinessConstants;",
            "import com.jsh.erp.constants.ExceptionConstants;",
            "import com.jsh.erp.datasource.entities.*;",
            "import com.jsh.erp.datasource.mappers.*;",
            "import com.jsh.erp.datasource.vo.AccountVo4InOutList;",
            "import com.jsh.erp.datasource.vo.AccountVo4List;",
            "import com.jsh.erp.exception.BusinessRunTimeException;",
            "import com.jsh.erp.exception.JshException;",
            "import com.jsh.erp.service.log.LogService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.service.user.UserService;",
            "import com.jsh.erp.utils.StringUtil;",
            "import com.jsh.erp.utils.Tools;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.transaction.annotation.Transactional;",
            "import org.springframework.web.context.request.RequestContextHolder;",
            "import org.springframework.web.context.request.ServletRequestAttributes;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.math.BigDecimal;",
            "import java.text.DecimalFormat;",
            "import java.util.*;"
        ],
        "reference_api": [
            "getAccountByParam",
            "getInitialAmount",
            "getName",
            "writeFail",
            "setInitialAmount",
            "toString",
            "size",
            "append",
            "insertSelective",
            "parseObject",
            "setEnabled",
            "setIsDefault",
            "insertLog",
            "toJSONString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getAccountByParam",
                "code": "public List<Account> getAccountByParam(String name, String serialNo) throws Exception{\n        List<Account> list=null;\n        try{\n            list=accountMapperEx.getAccountByParam(name, serialNo);\n        }catch(Exception e){\n            JshException.readFail(logger, e);\n        }\n        return list;\n    }"
            }
        ],
        "third_party": [
            "getInitialAmount",
            "getName",
            "writeFail",
            "setInitialAmount",
            "size",
            "append",
            "insertSelective",
            "parseObject",
            "setEnabled",
            "setIsDefault",
            "insertLog",
            "toJSONString"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public Long listWithBalanceCount(String name, String serialNo)",
        "start_line": "502",
        "end_line": "510",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/service/account/AccountService.java",
        "docstring": "This function returns the count of accounts with the specified name and serial number. It calls a mapper method to get the count and handles any exceptions by logging an error. If an exception occurs, it logs the error and returns null.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "d7496f2c2a76",
        "ground_truth": "public Long listWithBalanceCount(String name, String serialNo) {\n    Long result = null;\n    try{\n        result = accountMapperEx.countsByAccount(name, serialNo, null);\n    } catch(Exception e){\n        JshException.readFail(logger, e);\n    }\n    return result;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.constants.BusinessConstants;",
            "import com.jsh.erp.constants.ExceptionConstants;",
            "import com.jsh.erp.datasource.entities.*;",
            "import com.jsh.erp.datasource.mappers.*;",
            "import com.jsh.erp.datasource.vo.AccountVo4InOutList;",
            "import com.jsh.erp.datasource.vo.AccountVo4List;",
            "import com.jsh.erp.exception.BusinessRunTimeException;",
            "import com.jsh.erp.exception.JshException;",
            "import com.jsh.erp.service.log.LogService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.service.user.UserService;",
            "import com.jsh.erp.utils.StringUtil;",
            "import com.jsh.erp.utils.Tools;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.transaction.annotation.Transactional;",
            "import org.springframework.web.context.request.RequestContextHolder;",
            "import org.springframework.web.context.request.ServletRequestAttributes;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.math.BigDecimal;",
            "import java.text.DecimalFormat;",
            "import java.util.*;"
        ],
        "reference_api": [
            "countsByAccount",
            "readFail"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "countsByAccount",
            "readFail"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "jishenghua/jshERP",
        "function_declaration": "public int deleteDepotItem(Long id, HttpServletRequest request)throws Exception",
        "start_line": "143",
        "end_line": "151",
        "file_path": "jshERP-boot/src/main/java/com/jsh/erp/service/depotItem/DepotItemService.java",
        "docstring": "This function deletes a depot item by its ID and returns the result. It attempts to delete the item using the depot item mapper and handles any exceptions by logging the error. The result of the deletion operation is returned.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "c61f011e0619",
        "ground_truth": "public int deleteDepotItem(Long id, HttpServletRequest request)throws Exception {\n    int result =0;\n    try{\n        result=depotItemMapper.deleteByPrimaryKey(id);\n    }catch(Exception e){\n        JshException.writeFail(logger, e);\n    }\n    return result;\n}",
        "import_statements": [
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.jsh.erp.constants.BusinessConstants;",
            "import com.jsh.erp.constants.ExceptionConstants;",
            "import com.jsh.erp.datasource.entities.*;",
            "import com.jsh.erp.datasource.mappers.*;",
            "import com.jsh.erp.datasource.vo.DepotItemStockWarningCount;",
            "import com.jsh.erp.datasource.vo.DepotItemVo4Stock;",
            "import com.jsh.erp.datasource.vo.DepotItemVoBatchNumberList;",
            "import com.jsh.erp.datasource.vo.InOutPriceVo;",
            "import com.jsh.erp.exception.BusinessRunTimeException;",
            "import com.jsh.erp.exception.JshException;",
            "import com.jsh.erp.service.depot.DepotService;",
            "import com.jsh.erp.service.depotHead.DepotHeadService;",
            "import com.jsh.erp.service.log.LogService;",
            "import com.jsh.erp.service.material.MaterialService;",
            "import com.jsh.erp.service.materialExtend.MaterialExtendService;",
            "import com.jsh.erp.service.serialNumber.SerialNumberService;",
            "import com.jsh.erp.service.systemConfig.SystemConfigService;",
            "import com.jsh.erp.service.unit.UnitService;",
            "import com.jsh.erp.service.user.UserService;",
            "import com.jsh.erp.utils.StringUtil;",
            "import com.jsh.erp.utils.Tools;",
            "import org.slf4j.Logger;",
            "import org.slf4j.LoggerFactory;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.transaction.annotation.Transactional;",
            "import javax.annotation.Resource;",
            "import javax.servlet.http.HttpServletRequest;",
            "import java.math.BigDecimal;",
            "import java.util.*;"
        ],
        "reference_api": [
            "deleteByPrimaryKey",
            "writeFail"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "deleteByPrimaryKey",
            "writeFail"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "public  boolean addNode(String projectName, String nodeType, String nodeKey)",
        "start_line": "60",
        "end_line": "84",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/graphservice/GraphServiceImpl.java",
        "docstring": "This function adds a node to a specified project by sending an HTTP GET request to a given endpoint. It creates an HTTP client and constructs the request URL using the project name, node type, and node key. It executes the request, processes the response, and returns true if the response contains a key; otherwise, it returns false. Any exceptions are caught and printed, and resources are closed in the finally block.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "fdf7bfcf1922",
        "ground_truth": "public  boolean addNode(String projectName, String nodeType, String nodeKey) {\n CloseableHttpClient httpClient = HttpClients.createDefault();\n CloseableHttpResponse httpResponse = null;\n try {\n  HttpHost host = new HttpHost(getHost(), getPort(), getProtocol());\n  HttpGet getRequest = new HttpGet(\n    \"/addNode/\" +withProjectName(projectName) + nodeType + \"/\" + nodeKey);\n  httpResponse = httpClient.execute(host, getRequest);\n  HttpEntity entity = httpResponse.getEntity();\n  if (entity != null) {\n   ObjectMapper om = new ObjectMapper();\n   String result = EntityUtils.toString(entity);\n   Map map = om.readValue(result, Map.class);\n   if (map.get(\"key\") != null) {\n    return true;\n   }\n  }\n  return false;\n } catch (Exception e) {\n  e.printStackTrace();\n  return false;\n } finally {\n  close(httpClient, httpResponse);\n }\n}",
        "import_statements": [
            "import com.fasterxml.jackson.databind.ObjectMapper;",
            "import com.skynet.infrastructure.ConversionService;",
            "import com.skynet.infrastructure.GraphService;",
            "import com.terapico.utils.DateTimeUtil;",
            "import org.apache.http.HttpEntity;",
            "import org.apache.http.HttpHost;",
            "import org.apache.http.client.methods.CloseableHttpResponse;",
            "import org.apache.http.client.methods.HttpGet;",
            "import org.apache.http.client.methods.HttpPost;",
            "import org.apache.http.entity.StringEntity;",
            "import org.apache.http.impl.client.CloseableHttpClient;",
            "import org.apache.http.impl.client.HttpClients;",
            "import org.apache.http.util.EntityUtils;",
            "import org.springframework.beans.BeanWrapper;",
            "import org.springframework.beans.BeanWrapperImpl;",
            "import org.springframework.core.convert.support.DefaultConversionService;",
            "import org.springframework.util.StringUtils;",
            "import org.springframework.web.client.RestTemplate;",
            "import java.io.IOException;",
            "import java.lang.reflect.Method;",
            "import java.nio.charset.Charset;",
            "import java.util.*;"
        ],
        "reference_api": [
            "printStackTrace",
            "getHost",
            "getPort",
            "withProjectName",
            "execute",
            "toString",
            "readValue",
            "createDefault",
            "get",
            "getProtocol",
            "close",
            "getEntity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getHost",
                "code": "public String getHost() {\n\t\treturn host;\n\t}"
            },
            {
                "name": "getPort",
                "code": "public int getPort() {\n\t\treturn port;\n\t}"
            },
            {
                "name": "withProjectName",
                "code": "protected String withProjectName(String projectName ) {\n\t\treturn projectName +        \"/\";\n\t}"
            },
            {
                "name": "getProtocol",
                "code": "public String getProtocol() {\n\t\treturn protocol;\n\t}"
            },
            {
                "name": "close",
                "code": "private  void close(CloseableHttpClient httpClient,\n\t\t\tCloseableHttpResponse httpResponse) {\n\t\tif (httpResponse != null) {\n\t\t\ttry {\n\t\t\t\thttpResponse.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tif (httpClient != null) {\n\t\t\ttry {\n\t\t\t\thttpClient.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}"
            }
        ],
        "third_party": [
            "printStackTrace",
            "execute",
            "readValue",
            "createDefault",
            "get",
            "getEntity"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "public  boolean addEdge0(String projectName, String edgeType, String fromType, String toType, String from, String to)",
        "start_line": "118",
        "end_line": "142",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/graphservice/GraphServiceImpl.java",
        "docstring": "This function adds an edge to a project by making an HTTP GET request to a specified endpoint with parameters including project name, edge type, node types, and node identifiers. It uses a CloseableHttpClient to execute the request and processes the response to determine success based on the presence of a \"key\" in the returned JSON. It handles exceptions and ensures resources are closed after execution.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9b69c75f021e",
        "ground_truth": "public  boolean addEdge0(String projectName, String edgeType, String fromType, String toType, String from, String to) {\n CloseableHttpClient httpClient = HttpClients.createDefault();\n CloseableHttpResponse httpResponse = null;\n try {\n  HttpHost host = new HttpHost(getHost(), getPort(), getProtocol());\n  HttpGet getRequest = new HttpGet(\n    \"/addEdge/\" +withProjectName(projectName) + edgeType + \"/\" + fromType + \"/\" + toType + \"/\" + from + \"/\" + to);\n  httpResponse = httpClient.execute(host, getRequest);\n  HttpEntity entity = httpResponse.getEntity();\n  if (entity != null) {\n   ObjectMapper om = new ObjectMapper();\n   String result = EntityUtils.toString(entity);\n   Map map = om.readValue(result, Map.class);\n   if (map.get(\"key\") != null) {\n    return true;\n   }\n  }\n  return false;\n } catch (Exception e) {\n  e.printStackTrace();\n  return false;\n } finally {\n  close(httpClient, httpResponse);\n }\n}",
        "import_statements": [
            "import com.fasterxml.jackson.databind.ObjectMapper;",
            "import com.skynet.infrastructure.ConversionService;",
            "import com.skynet.infrastructure.GraphService;",
            "import com.terapico.utils.DateTimeUtil;",
            "import org.apache.http.HttpEntity;",
            "import org.apache.http.HttpHost;",
            "import org.apache.http.client.methods.CloseableHttpResponse;",
            "import org.apache.http.client.methods.HttpGet;",
            "import org.apache.http.client.methods.HttpPost;",
            "import org.apache.http.entity.StringEntity;",
            "import org.apache.http.impl.client.CloseableHttpClient;",
            "import org.apache.http.impl.client.HttpClients;",
            "import org.apache.http.util.EntityUtils;",
            "import org.springframework.beans.BeanWrapper;",
            "import org.springframework.beans.BeanWrapperImpl;",
            "import org.springframework.core.convert.support.DefaultConversionService;",
            "import org.springframework.util.StringUtils;",
            "import org.springframework.web.client.RestTemplate;",
            "import java.io.IOException;",
            "import java.lang.reflect.Method;",
            "import java.nio.charset.Charset;",
            "import java.util.*;"
        ],
        "reference_api": [
            "printStackTrace",
            "getHost",
            "getPort",
            "withProjectName",
            "execute",
            "toString",
            "readValue",
            "createDefault",
            "get",
            "getProtocol",
            "close",
            "getEntity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getHost",
                "code": "public String getHost() {\n\t\treturn host;\n\t}"
            },
            {
                "name": "getPort",
                "code": "public int getPort() {\n\t\treturn port;\n\t}"
            },
            {
                "name": "withProjectName",
                "code": "protected String withProjectName(String projectName ) {\n\t\treturn projectName +        \"/\";\n\t}"
            },
            {
                "name": "getProtocol",
                "code": "public String getProtocol() {\n\t\treturn protocol;\n\t}"
            },
            {
                "name": "close",
                "code": "private  void close(CloseableHttpClient httpClient,\n\t\t\tCloseableHttpResponse httpResponse) {\n\t\tif (httpResponse != null) {\n\t\t\ttry {\n\t\t\t\thttpResponse.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tif (httpClient != null) {\n\t\t\ttry {\n\t\t\t\thttpClient.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}"
            }
        ],
        "third_party": [
            "printStackTrace",
            "execute",
            "readValue",
            "createDefault",
            "get",
            "getEntity"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "public void sendEvent(Event event)",
        "start_line": "35",
        "end_line": "62",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/kafkaservice/KafkaMessageEventService.java",
        "docstring": "This function sends an event. It first checks if the event and its message are not null. If the event's location is null, it assigns a testing location. It sets the event time and converts the event to a JSON string. If a target is specified, it uses it as the topic; otherwise, it defaults to \"test\". Finally, it creates a producer record with the topic and JSON string, sends it using the producer, and flushes the producer.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ff5587f502f5",
        "ground_truth": "public void sendEvent(Event event) {\n    if (event == null) {\n        return;\n    }\n    if (event.getMessage() == null) {\n        return;\n    }\n    if (event.getLocation() == null) {\n     Location location = acquireTestingLocation();\n     event.setLocation(location);\n    }\n    String jsonResult;\n    try {\n        event.setTime(new Date());\n        jsonResult = objectMapper.copy().writeValueAsString(event);\n    } catch (JsonProcessingException e) {\n        e.printStackTrace();\n        return;\n    }\n    String target = event.getTarget();\n    String topic = \"test\";\n    if (target != null && !target.isEmpty()) {\n        topic = target;\n    }\n    ProducerRecord<String, String> msg = new ProducerRecord<String, String>(topic, jsonResult);\n    producer.send(msg);\n    producer.flush();\n}",
        "import_statements": [
            "import com.fasterxml.jackson.core.JsonProcessingException;",
            "import com.fasterxml.jackson.databind.ObjectMapper;",
            "import com.skynet.infrastructure.EventService;",
            "import com.terapico.caf.baseelement.Event;",
            "import com.terapico.caf.baseelement.Location;",
            "import org.apache.kafka.clients.producer.KafkaProducer;",
            "import org.apache.kafka.clients.producer.Producer;",
            "import org.apache.kafka.clients.producer.ProducerRecord;",
            "import org.springframework.beans.factory.InitializingBean;",
            "import java.util.ArrayList;",
            "import java.util.Date;",
            "import java.util.List;",
            "import java.util.Properties;",
            "import java.util.Random;"
        ],
        "reference_api": [
            "getLocation",
            "printStackTrace",
            "isEmpty",
            "getMessage",
            "send",
            "getTarget",
            "flush",
            "acquireTestingLocation",
            "writeValueAsString",
            "setLocation",
            "setTime",
            "copy"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "acquireTestingLocation",
                "code": "private Location acquireTestingLocation() {\n    \tRandom rand =new Random();\n    \tint index = rand.nextInt(testLocations.size());\n    \treturn testLocations.get(index);\n\t}"
            }
        ],
        "third_party": [
            "getLocation",
            "printStackTrace",
            "isEmpty",
            "getMessage",
            "send",
            "getTarget",
            "flush",
            "writeValueAsString",
            "setLocation",
            "setTime",
            "copy"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "public String upload(String objName, byte[] content)",
        "start_line": "148",
        "end_line": "163",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/AliyunOSSService.java",
        "docstring": "This function uploads a file to an OSS (Object Storage Service) bucket. It initializes the OSS client with access credentials, uploads the file content as an object with the specified name, shuts down the OSS client, and returns the URL of the uploaded object.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ac42de6f7165",
        "ground_truth": "public String upload(String objName, byte[] content) {\n    // \u963f\u91cc\u4e91\u4e3b\u8d26\u53f7AccessKey\u62e5\u6709\u6240\u6709API\u7684\u8bbf\u95ee\u6743\u9650\uff0c\u98ce\u9669\u5f88\u9ad8\u3002\u5f3a\u70c8\u5efa\u8bae\u60a8\u521b\u5efa\u5e76\u4f7f\u7528RAM\u8d26\u53f7\u8fdb\u884cAPI\u8bbf\u95ee\u6216\u65e5\u5e38\u8fd0\u7ef4\uff0c\u8bf7\u767b\u5f55 https://ram.console.aliyun.com \u521b\u5efaRAM\u8d26\u53f7\u3002\n    String accessKeyId = getConfig().getAccessKeyId();\n    String accessKeySecret = getConfig().getAccessKeySecret();\n    // \u521b\u5efaOSSClient\u5b9e\u4f8b\u3002\n    OSSClient ossClient = new OSSClient(\"https://\" + getConfig().getEndpoint(), accessKeyId, accessKeySecret);\n    // \u4e0a\u4f20Byte\u6570\u7ec4\u3002\n    ossClient.putObject(getConfig().getOssBucket(), objName, new ByteArrayInputStream(content));\n    // \u5173\u95edOSSClient\u3002\n    ossClient.shutdown();\n    return \"https://\" + getConfig().getOssBucket() + \".\" + getConfig().getEndpoint() + \"/\" + objName;\n}",
        "import_statements": [
            "import com.aliyun.oss.OSSClient;",
            "import com.aliyuncs.DefaultAcsClient;",
            "import com.aliyuncs.exceptions.ClientException;",
            "import com.aliyuncs.http.MethodType;",
            "import com.aliyuncs.http.ProtocolType;",
            "import com.aliyuncs.profile.DefaultProfile;",
            "import com.aliyuncs.profile.IClientProfile;",
            "import com.aliyuncs.sts.model.v20150401.AssumeRoleRequest;",
            "import com.aliyuncs.sts.model.v20150401.AssumeRoleResponse;",
            "import com.fasterxml.jackson.core.JsonProcessingException;",
            "import com.fasterxml.jackson.databind.ObjectMapper;",
            "import java.io.ByteArrayInputStream;",
            "import java.util.LinkedHashMap;",
            "import java.util.Map;"
        ],
        "reference_api": [
            "getConfig",
            "getAccessKeyId",
            "putObject",
            "getAccessKeySecret",
            "getEndpoint",
            "shutdown",
            "getOssBucket"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getConfig",
                "code": "public AliyunServiceConfiguration getConfig() {\n        return config;\n    }"
            }
        ],
        "third_party": [
            "getAccessKeyId",
            "putObject",
            "getAccessKeySecret",
            "getEndpoint",
            "shutdown",
            "getOssBucket"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "public LocationInfo ipToLocation(String ipAddress) throws Exception",
        "start_line": "53",
        "end_line": "70",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/BasicLocationService.java",
        "docstring": "This function converts an IP address to a location. It retrieves an IpToLocationWorker instance, ensuring it is initialized if necessary. If the worker is unavailable, it returns a LocationInfo object with \"unknown\" values. Otherwise, it uses the worker to get location information based on the IP address and returns the result.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "33db7ae34b8f",
        "ground_truth": "public LocationInfo ipToLocation(String ipAddress) throws Exception {\n    IpToLocationWorker worker = getIpToLocationWorker();\n    if (worker == null) {\n        ensureIpToLocationWorker();\n    }\n    worker = getIpToLocationWorker();\n    if (worker == null) {\n        LocationInfo result = new LocationInfo();\n        result.setSubInfo(\"\u672a\u77e5\");\n        result.setMainInfo(\"\u672a\u77e5\");\n        result.setIpAddress(ipAddress);\n        return result;\n    }\n    LocationInfo result = worker.getLocationInfoByIP(ipAddress);\n    System.out.println(result);\n    return result;\n}",
        "import_statements": [
            "import java.io.File;",
            "import java.util.Date;",
            "import com.github.jarod.qqwry.IPZone;",
            "import com.github.jarod.qqwry.QQWry;",
            "import com.terapico.utils.*;"
        ],
        "reference_api": [
            "getLocationInfoByIP",
            "getIpToLocationWorker",
            "setIpAddress",
            "setMainInfo",
            "println",
            "ensureIpToLocationWorker",
            "setSubInfo"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getLocationInfoByIP",
                "code": "public LocationInfo getLocationInfoByIP(String ipAddress) {\n            IPZone ipZone = qqwry.findIP(ipAddress);\n            LocationInfo  result = new LocationInfo();\n            result.setIpAddress(ipAddress);\n            result.setMainInfo(ipZone.getMainInfo());\n            result.setSubInfo(ipZone.getSubInfo());\n            return result;\n        }"
            },
            {
                "name": "getIpToLocationWorker",
                "code": "protected synchronized IpToLocationWorker getIpToLocationWorker() {\n        if (worker1 != null  && worker1.state == STATE_MASTER) {\n            return worker1;\n        }\n        if (worker2 != null  && worker2.state == STATE_MASTER) {\n            return worker2;\n        }\n        return null;\n    }"
            },
            {
                "name": "ensureIpToLocationWorker",
                "code": "protected synchronized void ensureIpToLocationWorker() throws Exception {\n        if (worker1 != null) {\n            return;\n        }\n        worker1 = initIpToLocationWorker();\n        ensureIpToLocationWorkerHotSwapTask();\n    }"
            }
        ],
        "third_party": [
            "setIpAddress",
            "setMainInfo",
            "println",
            "setSubInfo"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "protected void ensureESClientInitialized() throws Exception",
        "start_line": "57",
        "end_line": "69",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/ElasticsearchClient5_6_3.java",
        "docstring": "This function ensures the Elasticsearch client is initialized. It checks if both low-level and high-level REST clients are already set. If not, it synchronizes the initialization process, parses the cluster hosts and ports, and builds the low-level and high-level REST clients.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "232d7dc62a35",
        "ground_truth": "protected void ensureESClientInitialized() throws Exception {\n if (lowLevelRestClient != null && highLevelRestClient != null) {\n  return;\n }\n synchronized (this) {\n  if (lowLevelRestClient != null && highLevelRestClient != null) {\n   return;\n  }\n  List<HttpHost> hosts = parseHosts(getClusterHostList(), getClusterHostPort());\n  lowLevelRestClient = RestClient.builder(hosts.toArray(new HttpHost[0])).build();\n  highLevelRestClient = new RestHighLevelClient(lowLevelRestClient);\n }\n}",
        "import_statements": [
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import org.apache.http.HttpHost;",
            "import org.elasticsearch.client.RestClient;",
            "import org.elasticsearch.client.RestHighLevelClient;"
        ],
        "reference_api": [
            "getClusterHostList",
            "getClusterHostPort",
            "builder",
            "toArray",
            "build",
            "parseHosts"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getClusterHostList",
                "code": "public String getClusterHostList() {\n\t\treturn clusterHostList;\n\t}"
            },
            {
                "name": "getClusterHostPort",
                "code": "public int getClusterHostPort() {\n\t\treturn clusterHostPort;\n\t}"
            },
            {
                "name": "parseHosts",
                "code": "public static List<HttpHost> parseHosts(String clusterHostList, int clusterPort) {\n\t\tString[] hosts = clusterHostList.trim().split(\"\\\\s*,\\\\s*\");\n\t\tList<HttpHost> result = new ArrayList<HttpHost>();\n\t\tfor (String host : hosts) {\n\t\t\tif (host.indexOf(':') < 0) {\n\t\t\t\tresult.add(new HttpHost(host, clusterPort));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString[] hostInfo = host.split(\":\");\n\t\t\tresult.add(new HttpHost(hostInfo[0], Integer.parseInt(hostInfo[1])));\n\t\t}\n\t\treturn result;\n\t}"
            }
        ],
        "third_party": [
            "builder",
            "toArray",
            "build"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "public static List<HttpHost> parseHosts(String clusterHostList, int clusterPort)",
        "start_line": "89",
        "end_line": "101",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/ElasticsearchClient5_6_3.java",
        "docstring": "This function parses a comma-separated list of cluster hosts and returns a list of HttpHost objects. It splits the input string by commas, iterates through the hosts, and creates HttpHost instances with the specified cluster port or the port provided in the host string. The resulting list of HttpHost objects is returned.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8c01a776e2e7",
        "ground_truth": "public static List<HttpHost> parseHosts(String clusterHostList, int clusterPort) {\n String[] hosts = clusterHostList.trim().split(\"\\\\s*,\\\\s*\");\n List<HttpHost> result = new ArrayList<HttpHost>();\n for (String host : hosts) {\n  if (host.indexOf(':') < 0) {\n   result.add(new HttpHost(host, clusterPort));\n   continue;\n  }\n  String[] hostInfo = host.split(\":\");\n  result.add(new HttpHost(hostInfo[0], Integer.parseInt(hostInfo[1])));\n }\n return result;\n}",
        "import_statements": [
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import org.apache.http.HttpHost;",
            "import org.elasticsearch.client.RestClient;",
            "import org.elasticsearch.client.RestHighLevelClient;"
        ],
        "reference_api": [
            "trim",
            "split",
            "indexOf",
            "parseInt",
            "add"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "parseInt",
            "add"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "protected void pollingWork() throws InterruptedException",
        "start_line": "107",
        "end_line": "129",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/SczhtMessageService.java",
        "docstring": "This function processes tasks from a queue by polling for tasks with a 30-second timeout. If a task is retrieved, it checks the task type. For plain text message tasks, it extracts the recipient number and message data, validates the data, and sends the message. If the message data is invalid or an exception occurs, it logs an error message.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "06d77462474a",
        "ground_truth": "protected void pollingWork() throws InterruptedException{\n Map<String, Object> task = taskQueue.poll(30, TimeUnit.SECONDS);\n if (task == null){\n  return;\n }\n String taskType = (String) task.get(PARAM_TASK_TYPE);\n if (taskType.equals(TASK_PLAIN_TEXT_MESSAGE)){\n  try {\n   String toNumber = (String) task.get(PARAM_RECIEVER_NUMBER);\n   Object param = task.get(PARAM_MESSAGE_DATA);\n   if (!(param instanceof Map)){\n    System.out.println(\"Send message to \" + toNumber + \" failed. Input data is \" + param);\n    return;\n   }\n   String message = (String) ((Map<String, Object>) param).get(\"message\");\n   System.out.println(\"Send message to \" + toNumber+\": \" + message);\n   sendPlainTextMessage(toNumber,message);\n  } catch (Exception e) {\n   e.printStackTrace();\n  }\n  return;\n }\n}",
        "import_statements": [
            "import java.net.URI;",
            "import java.nio.charset.StandardCharsets;",
            "import java.text.SimpleDateFormat;",
            "import java.util.Date;",
            "import java.util.HashMap;",
            "import java.util.Map;",
            "import java.util.concurrent.LinkedBlockingQueue;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.concurrent.atomic.AtomicBoolean;",
            "import java.util.regex.Matcher;",
            "import java.util.regex.Pattern;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.apache.http.HttpEntity;",
            "import org.apache.http.client.methods.CloseableHttpResponse;",
            "import org.apache.http.client.methods.HttpGet;",
            "import org.apache.http.client.utils.URIBuilder;",
            "import org.apache.http.impl.client.CloseableHttpClient;",
            "import org.apache.http.impl.client.HttpClients;",
            "import org.apache.http.util.EntityUtils;"
        ],
        "reference_api": [
            "equals",
            "poll",
            "println",
            "sendPlainTextMessage",
            "get",
            "printStackTrace"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "sendPlainTextMessage",
                "code": "private void sendPlainTextMessage(String toNumber, String message) throws Exception {\n\t\t// http://api.sczht.cc:8888/sms.aspx\n\t\tString sentMsg = \"\u3010\"+getSmsSignName()+\"\u3011 \"+message+getTimeStamp();\n\t\tURI uri = new URIBuilder().setScheme(\"http\").setHost(\"api.sczht.cc\").setPort(8888)\n\t\t\t\t.setPath(\"sms.aspx\").addParameter(\"action\", \"send\")\n\t\t\t\t.addParameter(\"userid\", getUserId())\n\t\t\t\t.addParameter(\"account\", getAccount())\n\t\t\t\t.addParameter(\"password\", getPasswork())\n\t\t\t\t.addParameter(\"mobile\", toNumber)\n\t\t\t\t.addParameter(\"content\",sentMsg )\n\t\t\t\t.build();\n\t\tString content = httpGetRequestXml(uri);\n\t\t//Map<String, Object> responseObj = XMLDecodeUtils.decodeXmlString(content);\n\t\tif (content!=null && isSuccessResponse(content)){\n\t\t\tSystem.out.println(\"SMS to \" + toNumber+\" success:\" + sentMsg);\n\t\t}else{\n\t\t\tSystem.out.println(\"SMS to \" + toNumber+\" failed.\\t response is \" + content);\n\t\t\tif (this.getSmtpService() != null) {\n\t\t\t\tString messageContent = String.format(\"\u5411%s\u53d1\u9001\u6d88\u606f%s\u5931\u8d25.\\r\\n%s\", toNumber, sentMsg, content);\n\t\t\t\tthis.getSmtpService().send(\"archerliyaqing@163.com\", \"\u77ed\u4fe1\u670d\u52a1\u5931\u8d25\", messageContent);\n\t\t\t\tthis.getSmtpService().send(\"philip_chang@163.com\", \"\u77ed\u4fe1\u670d\u52a1\u5931\u8d25\", messageContent);\n\t\t\t\tthis.getSmtpService().send(\"clariones@163.com\", \"\u77ed\u4fe1\u670d\u52a1\u5931\u8d25\", messageContent);\n\t\t\t}\n\t\t}\n\t}"
            }
        ],
        "third_party": [
            "poll",
            "println",
            "get",
            "printStackTrace"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "private static String httpGetRequestXml(URI uri) throws Exception",
        "start_line": "180",
        "end_line": "190",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/SczhtMessageService.java",
        "docstring": "This function performs an HTTP GET request to a specified URI and returns the response content as a string. It uses a CloseableHttpClient to execute the request, retrieves the response entity, converts it to a UTF-8 encoded string, logs the content, and returns it.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "02aa7ef4815e",
        "ground_truth": "private static String httpGetRequestXml(URI uri) throws Exception {\n CloseableHttpClient client = getHttpClient();\n HttpGet httpget = new HttpGet(uri);\n CloseableHttpResponse response = client.execute(httpget);\n HttpEntity entity = response.getEntity();\n String content = EntityUtils.toString(entity, StandardCharsets.UTF_8);\n System.out.println(new Date() + \"message: http-get got: \" + content);\n return content;\n  }",
        "import_statements": [
            "import java.net.URI;",
            "import java.nio.charset.StandardCharsets;",
            "import java.text.SimpleDateFormat;",
            "import java.util.Date;",
            "import java.util.HashMap;",
            "import java.util.Map;",
            "import java.util.concurrent.LinkedBlockingQueue;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.concurrent.atomic.AtomicBoolean;",
            "import java.util.regex.Matcher;",
            "import java.util.regex.Pattern;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.apache.http.HttpEntity;",
            "import org.apache.http.client.methods.CloseableHttpResponse;",
            "import org.apache.http.client.methods.HttpGet;",
            "import org.apache.http.client.utils.URIBuilder;",
            "import org.apache.http.impl.client.CloseableHttpClient;",
            "import org.apache.http.impl.client.HttpClients;",
            "import org.apache.http.util.EntityUtils;"
        ],
        "reference_api": [
            "getHttpClient",
            "execute",
            "toString",
            "println",
            "getEntity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getHttpClient",
                "code": "protected static CloseableHttpClient getHttpClient() {\n\t\tif (httpclient != null) {\n\t\t\treturn httpclient;\n\t\t}\n\t\thttpclient = HttpClients.createDefault();\n\t\treturn httpclient;\n\t}"
            }
        ],
        "third_party": [
            "execute",
            "println",
            "getEntity"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "doublechaintech/scm-biz-suite",
        "function_declaration": "private static Map<String, Object> decodeToMap(String messageXmlStr, boolean doTrim) throws Exception",
        "start_line": "31",
        "end_line": "43",
        "file_path": "bizcore/WEB-INF/caf_core_src/com/skynet/infrastructure/XMLDecodeUtils.java",
        "docstring": "This function decodes an XML string into a Map. It creates a DocumentBuilder to parse the XML string into a Document object, then processes the document's child nodes to extract key-value pairs. It calls a helper method to decode the root element into an array and constructs a Map with the results, returning the Map if decoding is successful, otherwise returning null.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9c353199ab91",
        "ground_truth": "private static Map<String, Object> decodeToMap(String messageXmlStr, boolean doTrim) throws Exception{\n DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n DocumentBuilder builder = factory.newDocumentBuilder();\n Document doc = builder.parse(new ByteArrayInputStream(messageXmlStr.getBytes(StandardCharsets.UTF_8)));\n NodeList msgParamNodes = doc.getDocumentElement().getChildNodes();\n Object[] results = decodeNodeToMap(doc.getDocumentElement(), doTrim);\n if (results == null || results.length < 2){\n  return null;\n }\n Map<String, Object> result = new HashMap<String, Object>();\n result.put((String) results[0], results[1]);\n return result;\n}",
        "import_statements": [
            "import java.io.ByteArrayInputStream;",
            "import java.nio.charset.StandardCharsets;",
            "import java.util.HashMap;",
            "import java.util.LinkedList;",
            "import java.util.List;",
            "import java.util.Map;",
            "import javax.xml.parsers.DocumentBuilder;",
            "import javax.xml.parsers.DocumentBuilderFactory;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.w3c.dom.Document;",
            "import org.w3c.dom.NamedNodeMap;",
            "import org.w3c.dom.Node;",
            "import org.w3c.dom.NodeList;"
        ],
        "reference_api": [
            "newInstance",
            "getBytes",
            "getChildNodes",
            "decodeNodeToMap",
            "getDocumentElement",
            "newDocumentBuilder",
            "put",
            "parse"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "decodeNodeToMap",
                "code": "private static Object[] decodeNodeToMap(Node node, boolean doTrim) throws Exception{\n//\t\tSystem.out.println(\"Now read node \" + node.getNodeName()+\"(\"+node.getNodeType()+\"), value=\"+node.getNodeValue());\n\t\tshort nodeType = node.getNodeType();\n\t\tswitch (nodeType){\n\t\tcase Node.ENTITY_REFERENCE_NODE:\n\t\tcase Node.DOCUMENT_FRAGMENT_NODE:\n\t\tcase Node.DOCUMENT_TYPE_NODE:\n\t\tcase Node.NOTATION_NODE:\n\t\tcase Node.PROCESSING_INSTRUCTION_NODE:\n\t\t\treturn null;\n\t\t\t// \u5ffd\u7565\u4ee5\u4e0a\u7c7b\u578b\u7684\uff4e\uff4f\uff44\uff45\n\t\tcase Node.ATTRIBUTE_NODE:\n\t\t\treturn new Object[]{node.getNodeName(), node.getNodeValue()};\n\t\tcase Node.TEXT_NODE:\n\t\tcase Node.CDATA_SECTION_NODE:\n\t\t\tString nodeValue = node.getNodeValue();\n\t\t\tif (StringUtils.isBlank(nodeValue)){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn new Object[]{TEXT, nodeValue};\n\t\tcase Node.ENTITY_NODE:\n\t\tcase Node.DOCUMENT_NODE:\n\t\tcase Node.ELEMENT_NODE:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tNodeList children = node.getChildNodes();\n\t\tif (children == null){\n\t\t\treturn new Object[]{node.getNodeName(), null};\n\t\t}\n\t\t\n\t\tMap<String, Object> result = new HashMap<String, Object>();\n\t\tNamedNodeMap attrs = node.getAttributes();\n\t\tif (attrs != null){\n\t\t\tfor (int i = 0; i < attrs.getLength(); i++) {\n\t\t\t\tNode attrNode = attrs.item(i);\n\t\t\t\tresult.put(attrNode.getNodeName(), doTrim?attrNode.getNodeValue().trim():attrNode.getNodeValue());\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n//\t\t\tSystem.out.println(result);\n\t\t\tNode childNode = children.item(i);\n\t\t\tObject[] childValue = decodeNodeToMap(childNode, doTrim);\n\t\t\tif (childValue == null || childValue.length < 2){\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tSystem.out.println(\"Now read node \" + childValue[0]+\", value=\"+childValue[1]);\n\t\t\tString key = (String) childValue[0];\n\t\t\tif (TEXT.equals(key)){\n\t\t\t\tString oldValue = (String) result.get(key);\n\t\t\t\tif (StringUtils.isBlank(oldValue)){\n\t\t\t\t\tresult.put(key, childValue[1]);\n\t\t\t\t}else{\n\t\t\t\t\tresult.put(key, oldValue+\"\\r\\n\"+childValue[1]);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tObject existedValue = result.get(key);\n\t\t\tObject newValue = childValue[1];\n\t\t\tif (doTrim && newValue instanceof String){\n\t\t\t\tnewValue = newValue.toString().trim();\n\t\t\t}\n\t\t\tif (existedValue == null){\n\t\t\t\tresult.put(key, newValue);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (existedValue instanceof List){\n\t\t\t\t((List) existedValue).add(newValue);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList<Object> listValue = new LinkedList<Object>();\n\t\t\tlistValue.add(existedValue);\n\t\t\tlistValue.add(newValue);\n\t\t\tresult.put(key, listValue);\n\t\t}\n\t\tif (result.size() == 1 && result.containsKey(TEXT)){\n\t\t\treturn new Object[]{node.getNodeName(), result.get(TEXT)};\n\t\t}\n\t\treturn new Object[]{node.getNodeName(), result};\n\t}"
            }
        ],
        "third_party": [
            "newInstance",
            "getBytes",
            "getChildNodes",
            "getDocumentElement",
            "newDocumentBuilder",
            "put",
            "parse"
        ]
    },
    {
        "subclass": "ERP",
        "owner/repo": "metasfresh/metasfresh",
        "function_declaration": "private void enqueueGenerateSchedulesAfterCommit(@NonNull final I_C_Order orderRecord)",
        "start_line": "79",
        "end_line": "94",
        "file_path": "backend/de-metas-salesorder/src/main/java/de/metas/salesorder/interceptor/C_Order_AutoProcess_Async.java",
        "docstring": "This function enqueues tasks to generate schedules after a commit for a given order. It determines the order's eligibility for auto-processing. If eligible, it logs the action and enqueues the order for automatic shipping and invoicing using the transaction name. If not eligible, it logs the action and schedules the creation of missing shipment schedules if they are not postponed.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "01b280614047",
        "ground_truth": "private void enqueueGenerateSchedulesAfterCommit(@NonNull final I_C_Order orderRecord)\n{\n final OrderId orderId = OrderId.ofRepoId(orderRecord.getC_Order_ID());\n if (isEligibleForAutoProcessing(orderRecord))\n {\n  Loggables.withLogger(logger, Level.INFO).addLog(\"OrderId: {} qualified for auto ship and invoice! Enqueueing order.\", orderId);\n  final String trxName = InterfaceWrapperHelper.getTrxName(orderRecord);\n  completeShipAndInvoiceEnqueuer.enqueue(orderId, trxName);\n }\n else\n {\n  Loggables.withLogger(logger, Level.INFO).addLog(\"Schedule generating missing shipments for orderId: {}\", orderId);\n  CreateMissingShipmentSchedulesWorkpackageProcessor.scheduleIfNotPostponed(orderRecord);\n }\n}",
        "import_statements": [
            "import ch.qos.logback.classic.Level;",
            "import de.metas.async.AsyncBatchId;",
            "import de.metas.async.service.AsyncBatchObserver;",
            "import de.metas.inoutcandidate.async.CreateMissingShipmentSchedulesWorkpackageProcessor;",
            "import de.metas.logging.LogManager;",
            "import de.metas.order.DeliveryRule;",
            "import de.metas.order.OrderId;",
            "import de.metas.salesorder.async.CompleteShipAndInvoiceEnqueuer;",
            "import de.metas.util.Loggables;",
            "import de.metas.util.Services;",
            "import lombok.NonNull;",
            "import org.adempiere.ad.modelvalidator.annotations.DocValidate;",
            "import org.adempiere.ad.modelvalidator.annotations.Interceptor;",
            "import org.adempiere.ad.trx.api.ITrxManager;",
            "import org.adempiere.model.InterfaceWrapperHelper;",
            "import org.adempiere.service.ISysConfigBL;",
            "import org.compiere.model.I_C_Order;",
            "import org.compiere.model.ModelValidator;",
            "import org.slf4j.Logger;",
            "import org.springframework.stereotype.Component;"
        ],
        "reference_api": [
            "enqueue",
            "isEligibleForAutoProcessing",
            "getC_Order_ID",
            "getTrxName",
            "scheduleIfNotPostponed",
            "addLog",
            "withLogger",
            "ofRepoId"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "isEligibleForAutoProcessing",
                "code": "private boolean isEligibleForAutoProcessing(@NonNull final I_C_Order orderRecord)\n\t{\n\t\tfinal boolean featureEnabled = sysConfigBL.getBooleanValue(SYS_Config_AUTO_SHIP_AND_INVOICE, false, orderRecord.getAD_Client_ID(), orderRecord.getAD_Org_ID());\n\n\t\tfinal DeliveryRule deliveryRule = DeliveryRule.ofCode(orderRecord.getDeliveryRule());\n\n\t\tfinal boolean canDoAutoShipAndInvoice = featureEnabled && deliveryRule.isBasedOnDelivery();\n\t\tif (!canDoAutoShipAndInvoice)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t//dev-note: check to see if the order is not already involved in another async job\n\t\tfinal AsyncBatchId asyncBatchId = AsyncBatchId.ofRepoIdOrNull(orderRecord.getC_Async_Batch_ID());\n\n\t\tif (asyncBatchId == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !asyncBatchObserver.isAsyncBatchObserved(asyncBatchId);\n\t}"
            }
        ],
        "third_party": [
            "enqueue",
            "getC_Order_ID",
            "getTrxName",
            "scheduleIfNotPostponed",
            "addLog",
            "withLogger",
            "ofRepoId"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "protected function validateCredentials(Request $request): ?User",
        "start_line": "44",
        "end_line": "53",
        "file_path": "app/Actions/Fortify/RedirectIfTwoFactorAuthenticatable.php",
        "docstring": "This function validates user credentials from a request. It retrieves the user by email and checks the provided password. If the user does not exist or the credentials are invalid, it triggers a failed authentication event and throws an authentication exception.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "08fdb69981b1",
        "ground_truth": "protected function validateCredentials(Request $request): ?User\n{\n    return tap(User::where('email', $request->email)->first(), function ($user) use ($request) {\n        if (! $user || ! $this->guard->getProvider()->validateCredentials($user, ['password' => $request->password])) {\n            $this->fireFailedEvent($request, $user);\n            $this->throwFailedAuthenticationException($request);\n        }\n    });\n}",
        "import_statements": [
            "use App\\Models\\User;",
            "use Closure;",
            "use Illuminate\\Auth\\Events\\Failed;",
            "use Illuminate\\Contracts\\Auth\\StatefulGuard;",
            "use Illuminate\\Http\\Request;",
            "use Illuminate\\Validation\\ValidationException;",
            "use Laravel\\Fortify\\Events\\TwoFactorAuthenticationChallenged;",
            "use Laravel\\Fortify\\LoginRateLimiter;",
            "use LaravelWebauthn\\Facades\\Webauthn;"
        ],
        "reference_api": [
            "User::where('email', $request->email)->first",
            "User::where",
            "tap",
            "$this->fireFailedEvent",
            "$this->guard->getProvider",
            "$this->guard->getProvider()->validateCredentials",
            "$this->throwFailedAuthenticationException"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->fireFailedEvent",
                "code": "protected function fireFailedEvent(Request $request, ?User $user = null): void\n    {\n        event(new Failed(config('fortify.guard'), $user, [\n            'email' => $request->email,\n            'password' => $request->password,\n        ]));\n    }"
            },
            {
                "name": "$this->throwFailedAuthenticationException",
                "code": "protected function throwFailedAuthenticationException(Request $request): void\n    {\n        $this->limiter->increment($request);\n\n        throw ValidationException::withMessages([\n            'email' => [trans('auth.failed')],\n        ]);\n    }"
            }
        ],
        "third_party": [
            "User::where('email', $request->email)->first",
            "User::where",
            "tap",
            "$this->guard->getProvider",
            "$this->guard->getProvider()->validateCredentials"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "protected function throwFailedAuthenticationException(Request $request): void",
        "start_line": "60",
        "end_line": "67",
        "file_path": "app/Actions/Fortify/RedirectIfTwoFactorAuthenticatable.php",
        "docstring": "This function handles failed authentication attempts. It increments the request limit for rate limiting and throws a ValidationException with an error message indicating the authentication failure.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "64d195066208",
        "ground_truth": "protected function throwFailedAuthenticationException(Request $request): void\n{\n    $this->limiter->increment($request);\n    throw ValidationException::withMessages([\n        'email' => [trans('auth.failed')],\n    ]);\n}",
        "import_statements": [
            "use App\\Models\\User;",
            "use Closure;",
            "use Illuminate\\Auth\\Events\\Failed;",
            "use Illuminate\\Contracts\\Auth\\StatefulGuard;",
            "use Illuminate\\Http\\Request;",
            "use Illuminate\\Validation\\ValidationException;",
            "use Laravel\\Fortify\\Events\\TwoFactorAuthenticationChallenged;",
            "use Laravel\\Fortify\\LoginRateLimiter;",
            "use LaravelWebauthn\\Facades\\Webauthn;"
        ],
        "reference_api": [
            "ValidationException::withMessages",
            "trans",
            "$this->limiter->increment"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ValidationException::withMessages",
            "trans",
            "$this->limiter->increment"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "public function toResponse($request)",
        "start_line": "18",
        "end_line": "32",
        "file_path": "app/Actions/Fortify/TwoFactorChallengeView.php",
        "docstring": "This function generates a response for a two-factor authentication challenge. It retrieves the user ID from the session and fetches the user. If the user exists, it prepares a WebAuthn assertion and includes the public key in the response data. It then renders the 'TwoFactorChallenge' view with data indicating whether two-factor authentication is enabled and if the \"remember me\" option is set, and returns the response.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5df2ecd6e675",
        "ground_truth": "public function toResponse($request)\n{\n    $userId = $request->session()->get('login.id');\n    $user = User::find($userId);\n    $data = [];\n    if ($user !== null) {\n        $data['publicKey'] = Webauthn::prepareAssertion($user);\n    }\n    return Inertia::render('Auth/TwoFactorChallenge', $data + [\n        'twoFactor' => optional($user)->two_factor_secret && ! is_null(optional($user)->two_factor_confirmed_at),\n        'remember' => $request->session()->get('login.remember'),\n    ])->toResponse($request);\n}",
        "import_statements": [
            "use App\\Models\\User;",
            "use Inertia\\Inertia;",
            "use Laravel\\Fortify\\Contracts\\TwoFactorChallengeViewResponse as TwoFactorChallengeViewContract;",
            "use LaravelWebauthn\\Facades\\Webauthn;"
        ],
        "reference_api": [
            "$request->session",
            "Webauthn::prepareAssertion",
            "$request->session()->get",
            "User::find",
            "Inertia::render('Auth/TwoFactorChallenge', $data + [\n            'twoFactor' => optional($user)->two_factor_secret && ! is_null(optional($user)->two_factor_confirmed_at),\n            'remember' => $request->session()->get('login.remember'),\n        ])->toResponse",
            "optional",
            "Inertia::render",
            "is_null"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "$request->session",
            "Webauthn::prepareAssertion",
            "$request->session()->get",
            "User::find",
            "Inertia::render('Auth/TwoFactorChallenge', $data + [\n            'twoFactor' => optional($user)->two_factor_secret && ! is_null(optional($user)->two_factor_confirmed_at),\n            'remember' => $request->session()->get('login.remember'),\n        ])->toResponse",
            "optional",
            "Inertia::render"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "private function authenticateUser(Request $request, string $driver, SocialiteUser $socialite): User",
        "start_line": "79",
        "end_line": "98",
        "file_path": "app/Actions/AttemptToAuthenticateSocialite.php",
        "docstring": "This function authenticates a user based on a social media login. It checks if there is an existing user token for the given driver and socialite user ID. If found, it retrieves the associated user and verifies the user association. If not, it creates a new user or associates the socialite token with an existing user. The function returns the authenticated user.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e7f632ade812",
        "ground_truth": "private function authenticateUser(Request $request, string $driver, SocialiteUser $socialite): User\n{\n    if ($userToken = UserToken::firstWhere([\n        'driver_id' => $socialite->getId(),\n        'driver' => $driver,\n    ])) {\n        // Association already exist\n        $user = $userToken->user;\n        $this->checkUserAssociation($request, $user, $driver);\n    } else {\n        // New association: create user or add token to existing user\n        $user = tap($this->getUserOrCreate($socialite), function ($user) use ($driver, $socialite) {\n            $this->createUserToken($user, $driver, $socialite);\n        });\n    }\n    return $user;\n}",
        "import_statements": [
            "use App\\Actions\\Fortify\\CreateNewUser;",
            "use App\\Models\\User;",
            "use App\\Models\\UserToken;",
            "use Illuminate\\Auth\\Events\\Failed;",
            "use Illuminate\\Auth\\Events\\Registered;",
            "use Illuminate\\Contracts\\Auth\\StatefulGuard;",
            "use Illuminate\\Http\\Request;",
            "use Illuminate\\Support\\Facades\\App;",
            "use Illuminate\\Support\\Facades\\Auth;",
            "use Illuminate\\Support\\Str;",
            "use Illuminate\\Validation\\ValidationException;",
            "use Laravel\\Fortify\\Events\\TwoFactorAuthenticationChallenged;",
            "use Laravel\\Fortify\\LoginRateLimiter;",
            "use Laravel\\Socialite\\Contracts\\Provider;",
            "use Laravel\\Socialite\\Contracts\\User as SocialiteUser;",
            "use Laravel\\Socialite\\Facades\\Socialite;",
            "use Laravel\\Socialite\\One\\User as OAuth1User;",
            "use Laravel\\Socialite\\Two\\AbstractProvider;",
            "use Laravel\\Socialite\\Two\\User as OAuth2User;",
            "use LaravelWebauthn\\Facades\\Webauthn;",
            "use Symfony\\Component\\HttpFoundation\\Response;"
        ],
        "reference_api": [
            "tap",
            "$socialite->getId",
            "UserToken::firstWhere",
            "$this->getUserOrCreate",
            "$this->checkUserAssociation",
            "$this->createUserToken"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->getUserOrCreate",
                "code": "private function getUserOrCreate(SocialiteUser $socialite): User\n    {\n        if ($user = Auth::user()) {\n            return $user;\n        }\n\n        return $this->createUser($socialite);\n    }"
            },
            {
                "name": "$this->checkUserAssociation",
                "code": "private function checkUserAssociation(Request $request, User $user, string $driver): void\n    {\n        if (($userId = Auth::id()) && $userId !== $user->id) {\n            $this->throwFailedAuthenticationException($request, $driver, trans('This provider is already associated with another account'));\n        }\n    }"
            },
            {
                "name": "$this->createUserToken",
                "code": "private function createUserToken(User $user, string $driver, SocialiteUser $socialite): UserToken\n    {\n        $token = [\n            'driver' => $driver,\n            'driver_id' => $socialite->getId(),\n            'user_id' => $user->id,\n            'email' => $socialite->getEmail(),\n        ];\n\n        if ($socialite instanceof OAuth1User) {\n            $token['token'] = $socialite->token;\n            $token['token_secret'] = $socialite->tokenSecret;\n            $token['format'] = 'oauth1';\n        } elseif ($socialite instanceof OAuth2User) {\n            $token['token'] = $socialite->token;\n            $token['refresh_token'] = $socialite->refreshToken;\n            $token['expires_in'] = $socialite->expiresIn;\n            $token['format'] = 'oauth2';\n        } else {\n            throw new \\UnexpectedValueException('authentication format not supported');\n        }\n\n        return UserToken::create($token);\n    }"
            }
        ],
        "third_party": [
            "tap",
            "$socialite->getId",
            "UserToken::firstWhere"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "protected function attemptValidateAssertion(Request $request): bool",
        "start_line": "56",
        "end_line": "75",
        "file_path": "app/Actions/AttemptToAuthenticateWebauthn.php",
        "docstring": "This function attempts to validate a WebAuthn assertion for a user. It retrieves the user from the request and returns false if no user is found. It validates the assertion using the filtered credentials from the request. If validation fails, it triggers a failed authentication event, throws an authentication exception, and returns false. If successful, it returns true.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ddce87aea5b1",
        "ground_truth": "protected function attemptValidateAssertion(Request $request): bool\n{\n    $user = $request->user();\n    if ($user === null) {\n        return false;\n    }\n    $result = WebauthnFacade::validateAssertion($user, $this->filterCredentials($request));\n    if (! $result) {\n        $this->fireFailedEvent($request, $user);\n        $this->throwFailedAuthenticationException($request);\n        return false; // @codeCoverageIgnore\n    }\n    return true;\n}",
        "import_statements": [
            "use Illuminate\\Auth\\Events\\Failed;",
            "use Illuminate\\Contracts\\Auth\\Authenticatable;",
            "use Illuminate\\Contracts\\Auth\\StatefulGuard;",
            "use Illuminate\\Http\\Request;",
            "use Illuminate\\Validation\\ValidationException;",
            "use LaravelWebauthn\\Facades\\Webauthn as WebauthnFacade;",
            "use LaravelWebauthn\\Services\\LoginRateLimiter;",
            "use LaravelWebauthn\\Services\\Webauthn;"
        ],
        "reference_api": [
            "$this->filterCredentials",
            "$this->fireFailedEvent",
            "WebauthnFacade::validateAssertion",
            "$request->user",
            "$this->throwFailedAuthenticationException"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->filterCredentials",
                "code": "protected function filterCredentials(Request $request): array\n    {\n        return $request->only(['id', 'rawId', 'response', 'type']);\n    }"
            },
            {
                "name": "$this->fireFailedEvent",
                "code": "protected function fireFailedEvent(Request $request, ?Authenticatable $user = null)\n    {\n        event(new Failed(config('webauthn.guard'), $user, [\n            Webauthn::username() => $user !== null\n                ? $user->{Webauthn::username()}\n                : $request->{Webauthn::username()},\n        ]));\n    }"
            },
            {
                "name": "$this->throwFailedAuthenticationException",
                "code": "protected function throwFailedAuthenticationException(Request $request)\n    {\n        $this->limiter->increment($request);\n\n        throw ValidationException::withMessages([\n            Webauthn::username() => [trans_ignore('webauthn::errors.login_failed')],\n        ]);\n    }"
            }
        ],
        "third_party": [
            "WebauthnFacade::validateAssertion",
            "$request->user"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "private function user(): ?User",
        "start_line": "97",
        "end_line": "112",
        "file_path": "app/Console/Commands/NewAddressBookSubscription.php",
        "docstring": "This function retrieves a user based on the provided email address. If no email is provided, it logs an error and returns null. It attempts to find the user by email and returns the user if found. If the user is not found, it catches the exception, logs an error, and returns null.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "22cef9627da1",
        "ground_truth": "private function user(): ?User\n{\n    if (($email = $this->option('email')) === null) {\n        $this->error('Please provide an email address');\n        return null;\n    }\n    try {\n        return User::where('email', $email)->firstOrFail();\n    } catch (ModelNotFoundException) {\n        $this->error('Could not find user');\n        return null;\n    }\n}",
        "import_statements": [
            "use App\\Domains\\Contact\\DavClient\\Jobs\\SynchronizeAddressBooks;",
            "use App\\Domains\\Contact\\DavClient\\Services\\CreateAddressBookSubscription;",
            "use App\\Models\\AddressBookSubscription;",
            "use App\\Models\\User;",
            "use App\\Models\\Vault;",
            "use Illuminate\\Console\\Command;",
            "use Illuminate\\Database\\Eloquent\\ModelNotFoundException;",
            "use Symfony\\Component\\Console\\Attribute\\AsCommand;"
        ],
        "reference_api": [
            "$this->option",
            "User::where('email', $email)->firstOrFail",
            "$this->error",
            "User::where"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "$this->option",
            "User::where('email', $email)->firstOrFail",
            "$this->error",
            "User::where"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "protected function scoutFlush(): void",
        "start_line": "60",
        "end_line": "70",
        "file_path": "app/Console/Commands/SetupScout.php",
        "docstring": "This function flushes Scout indexes if the Scout driver is configured and the flush option is set. It iterates through the Meilisearch index settings, determines the table name for each index, and runs the Artisan command to flush the index. Finally, it logs a message indicating that the indexes have been flushed.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "be798cf5bfac",
        "ground_truth": "protected function scoutFlush(): void\n{\n    if (config('scout.driver') !== null && $this->option('flush')) {\n        foreach (config('scout.meilisearch.index-settings') as $index => $settings) {\n            $name = (new $index)->getTable();\n            $this->artisan(\"\u2610 Flush {$name} index\", 'scout:flush', ['model' => $index, '--verbose' => true]);\n        }\n        $this->info('\u2713 Indexes flushed');\n    }\n}",
        "import_statements": [
            "use Illuminate\\Console\\Command;",
            "use Illuminate\\Console\\ConfirmableTrait;",
            "use Symfony\\Component\\Console\\Attribute\\AsCommand;",
            "use Symfony\\Component\\Console\\Output\\OutputInterface;",
            "use ConfirmableTrait;"
        ],
        "reference_api": [
            "$this->artisan",
            "$this->option",
            "his->->fo('",
            "config",
            "(new $index)->getTable"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->artisan",
                "code": "nction artisan(string $message, string $command, array $options = [])\n    {\n        $this->info($message);\n        $this->getOutput()->getOutput()->getVerbosity() >= OutputInterface::VERBOSITY_VERBOSE\n            ? $this->call($command, $options)\n            : $this->callSilent($command, $options);\n    }\n}\n"
            }
        ],
        "third_party": [
            "$this->option",
            "his->->fo('",
            "config",
            "(new $index)->getTable"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "private function export(VCardResource $resource): VCard",
        "start_line": "80",
        "end_line": "111",
        "file_path": "app/Domains/Contact/Dav/Services/ExportVCard.php",
        "docstring": "This function exports a VCard from a given VCardResource. It first attempts to read an existing VCard from the resource, setting a UID if it is missing. If reading fails or the VCard doesn't exist, it creates a new VCard with basic information. Then, it applies a series of exporters to add more details to the VCard from the resource. Finally, it returns the populated VCard.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "23739c76cbbb",
        "ground_truth": "private function export(VCardResource $resource): VCard\n{\n    // The standard for most of these fields can be found on https://datatracker.ietf.org/doc/html/rfc6350\n    if ($resource->vcard) {\n        try {\n            /** @var VCard */\n            $vcard = Reader::read($resource->vcard, Reader::OPTION_FORGIVING + Reader::OPTION_IGNORE_INVALID_LINES);\n            if (! $vcard->UID) {\n                $vcard->UID = $resource->distant_uuid ?? $resource->uuid ?? $resource->id;\n            }\n        } catch (ParseException $e) {\n            // Ignore error\n        }\n    }\n    if (! isset($vcard)) {\n        // Basic information\n        $vcard = new VCard([\n            'UID' => $resource->uuid ?? $resource->id,\n            'SOURCE' => $this->getSource($resource),\n            'VERSION' => '4.0',\n        ]);\n    }\n    $exporters = $this->exporters($resource::class);\n    foreach ($exporters as $exporter) {\n        $exporter->export($resource, $vcard);\n    }\n    return $vcard;\n}",
        "import_statements": [
            "use App\\Domains\\Contact\\Dav\\ExportVCardResource;",
            "use App\\Domains\\Contact\\Dav\\Order;",
            "use App\\Domains\\Contact\\Dav\\VCardResource;",
            "use App\\Interfaces\\ServiceInterface;",
            "use App\\Models\\Contact;",
            "use App\\Models\\Group;",
            "use App\\Services\\BaseService;",
            "use Illuminate\\Database\\Eloquent\\ModelNotFoundException;",
            "use Illuminate\\Support\\Collection;",
            "use ReflectionClass;",
            "use Sabre\\VObject\\Component\\VCard;",
            "use Sabre\\VObject\\ParseException;",
            "use Sabre\\VObject\\Reader;"
        ],
        "reference_api": [
            "$exporter->export",
            "isset",
            "$this->getSource",
            "Reader::read",
            "$this->exporters"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->getSource",
                "code": "private function getSource(VCardResource $vcard): string\n    {\n        if ($vcard instanceof Contact) {\n            return route('contact.show', [\n                'vault' => $vcard->vault,\n                'contact' => $vcard,\n            ]);\n        } elseif ($vcard instanceof Group) {\n            return route('group.show', [\n                'vault' => $vcard->vault,\n                'group' => $vcard,\n            ]);\n        } else {\n            throw new ModelNotFoundException();\n        }\n    }"
            },
            {
                "name": "$this->exporters",
                "code": "private function exporters(string $resourceClass): Collection\n    {\n        if (self::$exporters === null) {\n            self::$exporters = collect(subClasses(ExportVCardResource::class))\n                ->sortBy(fn (ReflectionClass $exporter) => Order::get($exporter))\n                ->map(fn (ReflectionClass $exporter): ExportVCardResource => $exporter->newInstance());\n        }\n\n        return self::$exporters\n            ->filter(fn (ExportVCardResource $exporter): bool => $exporter->getType() === $resourceClass);\n    }"
            }
        ],
        "third_party": [
            "$exporter->export",
            "Reader::read"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "monicahq/monica",
        "function_declaration": "public function deleteCard($addressBookId, $cardUri): bool",
        "start_line": "474",
        "end_line": "499",
        "file_path": "app/Domains/Contact/Dav/Web/Backend/CardDAV/CardDAVBackend.php",
        "docstring": "This function deletes a card from an address book based on the given address book ID and card URI. It retrieves the corresponding object, and if it is a contact, it dispatches a job to destroy the contact. If the object is a group, it dispatches a job to destroy the group. Both jobs are placed on the high-priority queue. If the object is neither a contact nor a group, the function returns false.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "0dec6c937508",
        "ground_truth": "public function deleteCard($addressBookId, $cardUri): bool\n{\n    $obj = $this->getObject($addressBookId, $cardUri);\n    if ($obj !== null && $obj instanceof Contact) {\n        DestroyContact::dispatch([\n            'account_id' => $this->user->account_id,\n            'author_id' => $this->user->id,\n            'vault_id' => $obj->vault_id,\n            'contact_id' => $obj->id,\n        ])->onQueue('high');\n        return true;\n    } elseif ($obj !== null && $obj instanceof Group) {\n        DestroyGroup::dispatch([\n            'account_id' => $this->user->account_id,\n            'author_id' => $this->user->id,\n            'vault_id' => $obj->vault_id,\n            'group_id' => $obj->id,\n        ])->onQueue('high');\n        return true;\n    }\n    return false;\n}",
        "import_statements": [
            "use App\\Domains\\Contact\\Dav\\Jobs\\UpdateVCard;",
            "use App\\Domains\\Contact\\Dav\\Services\\ExportVCard;",
            "use App\\Domains\\Contact\\Dav\\Services\\GetEtag;",
            "use App\\Domains\\Contact\\Dav\\VCardResource;",
            "use App\\Domains\\Contact\\Dav\\Web\\Backend\\IDAVBackend;",
            "use App\\Domains\\Contact\\Dav\\Web\\Backend\\SyncDAVBackend;",
            "use App\\Domains\\Contact\\Dav\\Web\\DAVACL\\PrincipalBackend;",
            "use App\\Domains\\Contact\\ManageContact\\Services\\DestroyContact;",
            "use App\\Domains\\Contact\\ManageGroups\\Services\\DestroyGroup;",
            "use App\\Exceptions\\NotEnoughPermissionException;",
            "use App\\Models\\Contact;",
            "use App\\Models\\Group;",
            "use App\\Models\\User;",
            "use App\\Models\\Vault;",
            "use Carbon\\Carbon;",
            "use Illuminate\\Support\\Collection;",
            "use Illuminate\\Support\\Facades\\Bus;",
            "use Illuminate\\Support\\Facades\\Log;",
            "use ReturnTypeWillChange;",
            "use Sabre\\CalDAV\\Plugin as CalDAVPlugin;",
            "use Sabre\\CardDAV\\Backend\\AbstractBackend;",
            "use Sabre\\CardDAV\\Backend\\SyncSupport;",
            "use Sabre\\CardDAV\\Plugin as CardDav;",
            "use Sabre\\DAV;",
            "use Sabre\\DAV\\Server as SabreServer;",
            "use Sabre\\DAV\\Sync\\Plugin as DAVSyncPlugin;",
            "use Sabre\\VObject\\Component\\VCard;",
            "use Sabre\\VObject\\ParseException;",
            "use Sabre\\VObject\\Reader;",
            "use SyncDAVBackend;"
        ],
        "reference_api": [
            "DestroyContact::dispatch([\n                'account_id' => $this->user->account_id,\n                'author_id' => $this->user->id,\n                'vault_id' => $obj->vault_id,\n                'contact_id' => $obj->id,\n            ])->onQueue",
            "$this->getObject",
            "DestroyContact::dispatch",
            "DestroyGroup::dispatch",
            "DestroyGroup::dispatch([\n                'account_id' => $this->user->account_id,\n                'author_id' => $this->user->id,\n                'vault_id' => $obj->vault_id,\n                'group_id' => $obj->id,\n            ])->onQueue"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "DestroyContact::dispatch([\n                'account_id' => $this->user->account_id,\n                'author_id' => $this->user->id,\n                'vault_id' => $obj->vault_id,\n                'contact_id' => $obj->id,\n            ])->onQueue",
            "$this->getObject",
            "DestroyContact::dispatch",
            "DestroyGroup::dispatch",
            "DestroyGroup::dispatch([\n                'account_id' => $this->user->account_id,\n                'author_id' => $this->user->id,\n                'vault_id' => $obj->vault_id,\n                'group_id' => $obj->id,\n            ])->onQueue"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "krayin/laravel-crm",
        "function_declaration": "public function upload(array $data)",
        "start_line": "38",
        "end_line": "56",
        "file_path": "packages/Webkul/Activity/src/Repositories/FileRepository.php",
        "docstring": "This function uploads a file and creates a related lead activity. It first checks if a file is included in the request. If not, it returns immediately. If a file is present, it creates a lead activity record with details from the provided data and the authenticated user. Finally, it creates and returns a new record with the file's name and storage path, associating it with the created lead activity.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "c3389c1494d9",
        "ground_truth": "public function upload(array $data)\n{\n    if (! request()->hasFile('file')) {\n        return;\n    }\n    $leadActivity = $this->activityRepository->create([\n        'is_done' => 1,\n        'type'    => 'file',\n        'comment' => $data['comment'],\n        'user_id' => auth()->guard()->user()->id,\n    ]);\n    return parent::create([\n        'name'        => $data['name'] ?? request()->file('file')->getClientOriginalName(),\n        'path'        => request()->file('file')->store('activities/' . $leadActivity->id),\n        'activity_id' => $leadActivity->id,\n    ]);\n}",
        "import_statements": [
            "use Illuminate\\Container\\Container;",
            "use Webkul\\Core\\Eloquent\\Repository;"
        ],
        "reference_api": [
            "request()->file('file')->getClientOriginalName",
            "request",
            "parent::create",
            "request()->file('file')->store",
            "auth",
            "$this->activityRepository->create",
            "request()->hasFile",
            "auth()->guard()->user",
            "request()->file",
            "auth()->guard"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "request()->file('file')->getClientOriginalName",
            "request",
            "parent::create",
            "request()->file('file')->store",
            "auth",
            "$this->activityRepository->create",
            "request()->hasFile",
            "auth()->guard()->user",
            "request()->file",
            "auth()->guard"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "krayin/laravel-crm",
        "function_declaration": "private function renderCustomResponse(Throwable $exception)",
        "start_line": "88",
        "end_line": "109",
        "file_path": "packages/Webkul/Admin/src/Exceptions/Handler.php",
        "docstring": "This function handles custom error responses based on the exception type and request route. It checks if the route is for admin or front and redirects front routes to the admin session creation. For HTTP exceptions, it sets the status code to a specified value or 500. It returns appropriate responses for ModelNotFoundException, PDOException, and ParseError with status codes 404 or 500.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "093cfe71d543",
        "ground_truth": "private function renderCustomResponse(Throwable $exception)\n{\n    $path = request()->routeIs('admin.*') ? 'admin' : 'front';\n    if ($path == 'front') {\n        return redirect()->route('admin.session.create');\n    }\n    if ($exception instanceof HttpException) {\n        $statusCode = in_array($exception->getStatusCode(), [401, 403, 404, 503])\n            ? $exception->getStatusCode()\n            : 500;\n        return $this->response($path, $statusCode);\n    }\n    if ($exception instanceof ModelNotFoundException) {\n        return $this->response($path, 404);\n    } elseif ($exception instanceof PDOException || $exception instanceof \\ParseError) {\n        return $this->response($path, 500);\n    }\n}",
        "import_statements": [
            "use App\\Exceptions\\Handler as AppExceptionHandler;",
            "use Illuminate\\Auth\\AuthenticationException;",
            "use PDOException;",
            "use Illuminate\\Container\\Container;",
            "use Illuminate\\Database\\Eloquent\\ModelNotFoundException;",
            "use Symfony\\Component\\HttpKernel\\Exception\\HttpException;",
            "use Throwable;"
        ],
        "reference_api": [
            "redirect",
            "request",
            "redirect()->route",
            "request()->routeIs",
            "$exception->getStatusCode",
            "$this->response",
            "in_array"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->response",
                "code": "private function response($path, $statusCode)\n    {\n        if (request()->expectsJson()) {\n            return response()->json([\n                'message' => isset($this->jsonErrorMessages[$statusCode])\n                    ? $this->jsonErrorMessages[$statusCode]\n                    : trans('admin::app.common.something-went-wrong')\n            ], $statusCode);\n        }\n\n        return response()->view(\"{$path}::errors.{$statusCode}\", [], $statusCode);\n    }"
            }
        ],
        "third_party": [
            "redirect",
            "request",
            "redirect()->route",
            "request()->routeIs",
            "$exception->getStatusCode"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "krayin/laravel-crm",
        "function_declaration": "private function response($path, $statusCode)",
        "start_line": "118",
        "end_line": "129",
        "file_path": "packages/Webkul/Admin/src/Exceptions/Handler.php",
        "docstring": "This function generates a response based on the request type and status code. If the request expects a JSON response, it returns a JSON object with an error message. Otherwise, it returns an error view corresponding to the provided status code and path.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "aea38c568068",
        "ground_truth": "private function response($path, $statusCode)\n{\n    if (request()->expectsJson()) {\n        return response()->json([\n            'message' => isset($this->jsonErrorMessages[$statusCode])\n                ? $this->jsonErrorMessages[$statusCode]\n                : trans('admin::app.common.something-went-wrong')\n        ], $statusCode);\n    }\n    return response()->view(\"{$path}::errors.{$statusCode}\", [], $statusCode);\n}",
        "import_statements": [
            "use App\\Exceptions\\Handler as AppExceptionHandler;",
            "use Illuminate\\Auth\\AuthenticationException;",
            "use PDOException;",
            "use Illuminate\\Container\\Container;",
            "use Illuminate\\Database\\Eloquent\\ModelNotFoundException;",
            "use Symfony\\Component\\HttpKernel\\Exception\\HttpException;",
            "use Throwable;"
        ],
        "reference_api": [
            "request",
            "isset",
            "trans",
            "response()->view",
            "response()->json",
            "response",
            "request()->expectsJson"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "response",
                "code": "private function response($path, $statusCode)\n    {\n        if (request()->expectsJson()) {\n            return response()->json([\n                'message' => isset($this->jsonErrorMessages[$statusCode])\n                    ? $this->jsonErrorMessages[$statusCode]\n                    : trans('admin::app.common.something-went-wrong')\n            ], $statusCode);\n        }\n\n        return response()->view(\"{$path}::errors.{$statusCode}\", [], $statusCode);\n    }"
            }
        ],
        "third_party": [
            "request",
            "trans",
            "response()->view",
            "response()->json",
            "request()->expectsJson"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "krayin/laravel-crm",
        "function_declaration": "public function massUpdate()",
        "start_line": "210",
        "end_line": "237",
        "file_path": "packages/Webkul/Admin/src/Http/Controllers/Activity/ActivityController.php",
        "docstring": "This function performs a mass update on activities based on request data. It iterates over the specified activity IDs, dispatching events before and after updating each activity's 'is_done' status. It counts the number of updates and returns a JSON response indicating success or failure based on whether any updates were made.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "87b4461b73e5",
        "ground_truth": "public function massUpdate()\n{\n    $count = 0;\n    $data = request()->all();\n    foreach (request('rows') as $activityId) {\n        Event::dispatch('activity.update.before', $activityId);\n        $activity = $this->activityRepository->update([\n            'is_done' => request('value'),\n        ], $activityId);\n        Event::dispatch('activity.update.after', $activity);\n        $count++;\n    }\n    if (! $count) {\n        return response()->json([\n            'message' => trans('admin::app.activities.mass-update-failed'),\n        ], 400);\n    }\n    return response()->json([\n        'message' => trans('admin::app.activities.mass-update-success'),\n    ]);\n}",
        "import_statements": [
            "use Illuminate\\Support\\Facades\\Event;",
            "use Illuminate\\Support\\Facades\\Storage;",
            "use Carbon\\Carbon;",
            "use Webkul\\Activity\\Repositories\\ActivityRepository;",
            "use Webkul\\Activity\\Repositories\\FileRepository;",
            "use Webkul\\Admin\\Http\\Controllers\\Controller;",
            "use Webkul\\Contact\\Repositories\\PersonRepository;",
            "use Webkul\\Lead\\Repositories\\LeadRepository;",
            "use Webkul\\User\\Repositories\\UserRepository;"
        ],
        "reference_api": [
            "Event::dispatch",
            "request",
            "trans",
            "response()->json",
            "$this->activityRepository->update",
            "response",
            "request()->all"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Event::dispatch",
            "request",
            "trans",
            "response()->json",
            "$this->activityRepository->update",
            "response",
            "request()->all"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "krayin/laravel-crm",
        "function_declaration": " public function massDestroy()",
        "start_line": "337",
        "end_line": "350",
        "file_path": "packages/Webkul/Admin/src/Http/Controllers/Activity/ActivityController.php",
        "docstring": "This function performs a mass deletion of activities based on request data. It iterates over the specified activity IDs, dispatching events before and after deleting each activity. After all deletions, it returns a JSON response indicating a successful destruction.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "b0c21bc826a6",
        "ground_truth": "public function massDestroy()\n{\n    foreach (request('rows') as $activityId) {\n        Event::dispatch('activity.delete.before', $activityId);\n        $this->activityRepository->delete($activityId);\n        Event::dispatch('activity.delete.after', $activityId);\n    }\n    return response()->json([\n        'message' => trans('admin::app.response.destroy-success', ['name' => trans('admin::app.activities.title')])\n    ]);\n}",
        "import_statements": [
            "use Illuminate\\Support\\Facades\\Event;",
            "use Illuminate\\Support\\Facades\\Storage;",
            "use Carbon\\Carbon;",
            "use Webkul\\Activity\\Repositories\\ActivityRepository;",
            "use Webkul\\Activity\\Repositories\\FileRepository;",
            "use Webkul\\Admin\\Http\\Controllers\\Controller;",
            "use Webkul\\Contact\\Repositories\\PersonRepository;",
            "use Webkul\\Lead\\Repositories\\LeadRepository;",
            "use Webkul\\User\\Repositories\\UserRepository;"
        ],
        "reference_api": [
            "Event::dispatch",
            "$this->activityRepository->delete",
            "request",
            "trans",
            "response()->json",
            "response"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Event::dispatch",
            "$this->activityRepository->delete",
            "request",
            "trans",
            "response()->json",
            "response"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "krayin/laravel-crm",
        "function_declaration": " public function updateCards()",
        "start_line": "88",
        "end_line": "106",
        "file_path": "packages/Webkul/Admin/src/Http/Controllers/Admin/DashboardController.php",
        "docstring": "This function updates the selection status of dashboard cards based on request data. It retrieves the current cards and iterates through the request data to match and update the 'selected' status of each card. Finally, it returns the updated cards as a JSON response.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "d3e901b3af67",
        "ground_truth": "public function updateCards()\n{\n    $requestData = request()->all();\n    $cards = $this->dashboardHelper->getCards();\n    foreach ($requestData['cards'] as $requestedCardData) {\n        foreach ($cards as $cardIndex => $card) {\n            if (isset($card['card_id'])\n                && isset($requestedCardData['card_id'])\n                && $card['card_id'] == $requestedCardData['card_id']\n            ) {\n                $cards[$cardIndex]['selected'] = $requestedCardData['selected'];\n            }\n        }\n    }\n    return response()->json($cards);\n}",
        "import_statements": [
            "use Carbon\\Carbon;",
            "use Webkul\\Admin\\Http\\Controllers\\Controller;",
            "use Webkul\\Admin\\Helpers\\Dashboard as DashboardHelper;"
        ],
        "reference_api": [
            "request",
            "isset",
            "response()->json",
            "$this->dashboardHelper->getCards",
            "response",
            "request()->all"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "request",
            "response()->json",
            "$this->dashboardHelper->getCards",
            "response",
            "request()->all"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "krayin/laravel-crm",
        "function_declaration": "public function store()",
        "start_line": "61",
        "end_line": "72",
        "file_path": "packages/Webkul/Admin/src/Http/Controllers/Configuration/ConfigurationController.php",
        "docstring": "This function stores a new configuration. It dispatches an event before saving, creates the configuration with the provided request data, and then dispatches an event after saving. It flashes a success message to the session and redirects back to the previous page.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "f63e0f8906b4",
        "ground_truth": "public function store()\n{\n    Event::dispatch('core.configuration.save.before');\n    $this->configurationRepository->create(request()->all());\n    Event::dispatch('core.configuration.save.after');\n    session()->flash('success', trans('admin::app.configuration.save-message'));\n    return redirect()->back();\n}",
        "import_statements": [
            "use Illuminate\\Support\\Facades\\Event;",
            "use Illuminate\\Support\\Facades\\Storage;",
            "use Webkul\\Core\\Contracts\\Validations\\Code;",
            "use Webkul\\Admin\\Http\\Controllers\\Controller;",
            "use Webkul\\Core\\Repositories\\CoreConfigRepository as ConfigurationRepository;"
        ],
        "reference_api": [
            "redirect",
            "Event::dispatch",
            "request",
            "session()->flash",
            "redirect()->back",
            "$this->configurationRepository->create",
            "session",
            "trans",
            "request()->all"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "redirect",
            "Event::dispatch",
            "request",
            "session()->flash",
            "redirect()->back",
            "$this->configurationRepository->create",
            "session",
            "trans",
            "request()->all"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "krayin/laravel-crm",
        "function_declaration": "public function download()",
        "start_line": "79",
        "end_line": "88",
        "file_path": "packages/Webkul/Admin/src/Http/Controllers/Configuration/ConfigurationController.php",
        "docstring": "This function handles file download requests. It retrieves the file path from the request parameters, constructs the full file name, and fetches the corresponding configuration from the repository. Finally, it returns the file for download using the stored value.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "bcf54c41a921",
        "ground_truth": "public function download()\n{\n    $path = request()->route()->parameters()['path'];\n    $fileName = 'configuration/'. $path;\n    $config = $this->configurationRepository->findOneByField('value', $fileName);\n    return Storage::download($config['value']);\n}",
        "import_statements": [
            "use Illuminate\\Support\\Facades\\Event;",
            "use Illuminate\\Support\\Facades\\Storage;",
            "use Webkul\\Core\\Contracts\\Validations\\Code;",
            "use Webkul\\Admin\\Http\\Controllers\\Controller;",
            "use Webkul\\Core\\Repositories\\CoreConfigRepository as ConfigurationRepository;"
        ],
        "reference_api": [
            "request()->route",
            "request",
            "Storage::download",
            "request()->route()->parameters",
            "$this->configurationRepository->findOneByField"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Storage::download",
                "code": "public function download()\n    {\n        $path = request()->route()->parameters()['path'];\n\n        $fileName = 'configuration/'. $path;\n\n        $config = $this->configurationRepository->findOneByField('value', $fileName);\n\n        return Storage::download($config['value']);\n    }"
            }
        ],
        "third_party": [
            "request()->route",
            "request",
            "request()->route()->parameters",
            "$this->configurationRepository->findOneByField"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public Result setHeaderModelSort(@RequestBody List<String> list) ",
        "start_line": "102",
        "end_line": "114",
        "file_path": "admin/src/main/java/com/kakarote/admin/controller/AdminConfigController.java",
        "docstring": "This function sets the header model sort order based on a list of models. It creates a list of AdminModelSort objects, each with specified attributes, and adds them to a list. It then removes existing sort settings for the user and saves the new sort settings in batch. Finally, it returns a success result.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1fbf002ce3db",
        "ground_truth": "public Result setHeaderModelSort(@RequestBody List<String> list) {\n    List<AdminModelSort> modelSortList = new ArrayList<>();\n    for (int i = 0; i < list.size(); i++) {\n        AdminModelSort adminModelSort = new AdminModelSort();\n        adminModelSort.setType(1).setModel(list.get(i)).setSort(i).setIsHidden(0).setUserId(UserUtil.getUserId());\n        modelSortList.add(adminModelSort);\n    }\n    LambdaQueryWrapper<AdminModelSort> wrapper = new LambdaQueryWrapper<>();\n    wrapper.eq(AdminModelSort::getType, 1).eq(AdminModelSort::getUserId, UserUtil.getUserId());\n    adminModelSortService.remove(wrapper);\n    adminModelSortService.saveBatch(modelSortList, Const.BATCH_SAVE_SIZE);\n    return R.ok();\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.AdminConst;",
            "import com.kakarote.admin.common.AdminModuleEnum;",
            "import com.kakarote.admin.common.log.AdminConfigLog;",
            "import com.kakarote.admin.entity.BO.AdminCompanyBO;",
            "import com.kakarote.admin.entity.BO.AdminInitDataBO;",
            "import com.kakarote.admin.entity.BO.LogWelcomeSpeechBO;",
            "import com.kakarote.admin.entity.BO.ModuleSettingBO;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminModelSort;",
            "import com.kakarote.admin.entity.PO.AdminUserConfig;",
            "import com.kakarote.admin.entity.VO.ModuleSettingVO;",
            "import com.kakarote.admin.service.IAdminConfigService;",
            "import com.kakarote.admin.service.IAdminModelSortService;",
            "import com.kakarote.admin.service.IAdminUserConfigService;",
            "import com.kakarote.core.common.*;",
            "import com.kakarote.core.common.log.BehaviorEnum;",
            "import com.kakarote.core.common.log.SysLog;",
            "import com.kakarote.core.common.log.SysLogHandler;",
            "import com.kakarote.core.utils.UserUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import io.swagger.annotations.ApiParam;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.servlet.http.HttpServletRequest;",
            "import javax.validation.Valid;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "setSort",
            "setType",
            "ok",
            "saveBatch",
            "size",
            "getUserId",
            "setUserId",
            "setIsHidden",
            "get",
            "eq",
            "add",
            "setModel",
            "remove"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setSort",
            "setType",
            "ok",
            "saveBatch",
            "size",
            "getUserId",
            "setUserId",
            "setIsHidden",
            "get",
            "eq",
            "add",
            "setModel",
            "remove"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public Result setModuleSetting(@Valid @RequestBody ModuleSettingBO moduleSetting)",
        "start_line": "150",
        "end_line": "158",
        "file_path": "admin/src/main/java/com/kakarote/admin/controller/AdminConfigController.java",
        "docstring": "This function updates the status of a module setting. It retrieves the current admin configuration by the setting ID and checks if the module is CRM. If it is CRM, it returns an error. Otherwise, it updates the status of the admin configuration and saves the updated setting, returning a success result.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "d51385d0c4fb",
        "ground_truth": "public Result setModuleSetting(@Valid @RequestBody ModuleSettingBO moduleSetting) {\n    AdminConfig adminConfig = adminConfigService.getById(moduleSetting.getSettingId());\n    if (AdminModuleEnum.CRM.getValue().equals(adminConfig.getName())) {\n        return R.error(AdminCodeEnum.ADMIN_MODULE_CLOSE_ERROR);\n    }\n    adminConfig.setStatus(moduleSetting.getStatus());\n    adminConfigService.setModuleSetting(adminConfig);\n    return Result.ok();\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.AdminConst;",
            "import com.kakarote.admin.common.AdminModuleEnum;",
            "import com.kakarote.admin.common.log.AdminConfigLog;",
            "import com.kakarote.admin.entity.BO.AdminCompanyBO;",
            "import com.kakarote.admin.entity.BO.AdminInitDataBO;",
            "import com.kakarote.admin.entity.BO.LogWelcomeSpeechBO;",
            "import com.kakarote.admin.entity.BO.ModuleSettingBO;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminModelSort;",
            "import com.kakarote.admin.entity.PO.AdminUserConfig;",
            "import com.kakarote.admin.entity.VO.ModuleSettingVO;",
            "import com.kakarote.admin.service.IAdminConfigService;",
            "import com.kakarote.admin.service.IAdminModelSortService;",
            "import com.kakarote.admin.service.IAdminUserConfigService;",
            "import com.kakarote.core.common.*;",
            "import com.kakarote.core.common.log.BehaviorEnum;",
            "import com.kakarote.core.common.log.SysLog;",
            "import com.kakarote.core.common.log.SysLogHandler;",
            "import com.kakarote.core.utils.UserUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import io.swagger.annotations.ApiParam;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.servlet.http.HttpServletRequest;",
            "import javax.validation.Valid;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "getName",
            "getById",
            "equals",
            "ok",
            "error",
            "getValue",
            "getStatus",
            "getSettingId",
            "setModuleSetting",
            "setStatus"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "setModuleSetting",
                "code": "@ApiOperation(value = \"\u8bbe\u7f6e\u4f01\u4e1a\u6a21\u5757\")\n    @PostMapping(\"/setModuleSetting\")\n    @SysLogHandler(subModel = SubModelType.ADMIN_OTHER_SETTINGS,behavior = BehaviorEnum.UPDATE)\n    public Result setModuleSetting(@Valid @RequestBody ModuleSettingBO moduleSetting) {\n        AdminConfig adminConfig = adminConfigService.getById(moduleSetting.getSettingId());\n        if (AdminModuleEnum.CRM.getValue().equals(adminConfig.getName())) {\n            return R.error(AdminCodeEnum.ADMIN_MODULE_CLOSE_ERROR);\n        }\n        adminConfig.setStatus(moduleSetting.getStatus());\n        adminConfigService.setModuleSetting(adminConfig);\n        return Result.ok();\n    }"
            }
        ],
        "third_party": [
            "getName",
            "getById",
            "ok",
            "error",
            "getValue",
            "getStatus",
            "getSettingId",
            "setStatus"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": " public Result queryCustomSetting(@RequestBody JSONArray json,@PathVariable(\"customKey\") String customKey) ",
        "start_line": "217",
        "end_line": "232",
        "file_path": "admin/src/main/java/com/kakarote/admin/controller/AdminConfigController.java",
        "docstring": "This function handles custom setting queries based on a provided key and JSON array. It retrieves the user configuration by the custom key. If the configuration exists, it updates its value with the provided JSON. If not, it creates a new user configuration with the provided JSON and saves it. Finally, it returns a successful result.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "38d2abda3119",
        "ground_truth": "public Result queryCustomSetting(@RequestBody JSONArray json,@PathVariable(\"customKey\") String customKey) {\n    AdminUserConfig userConfig = adminUserConfigService.queryUserConfigByName(customKey);\n    if (userConfig != null) {\n        userConfig.setValue(json.toJSONString());\n        adminUserConfigService.updateById(userConfig);\n    } else {\n        userConfig = new AdminUserConfig();\n        userConfig.setStatus(1);\n        userConfig.setName(customKey);\n        userConfig.setValue(json.toJSONString());\n        userConfig.setUserId(UserUtil.getUserId());\n        userConfig.setDescription(\"\u7528\u6237\u81ea\u5b9a\u4e49\u53c2\u6570\u8bbe\u7f6e\");\n        adminUserConfigService.save(userConfig);\n    }\n    return R.ok();\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.alibaba.fastjson.JSONArray;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.AdminConst;",
            "import com.kakarote.admin.common.AdminModuleEnum;",
            "import com.kakarote.admin.common.log.AdminConfigLog;",
            "import com.kakarote.admin.entity.BO.AdminCompanyBO;",
            "import com.kakarote.admin.entity.BO.AdminInitDataBO;",
            "import com.kakarote.admin.entity.BO.LogWelcomeSpeechBO;",
            "import com.kakarote.admin.entity.BO.ModuleSettingBO;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminModelSort;",
            "import com.kakarote.admin.entity.PO.AdminUserConfig;",
            "import com.kakarote.admin.entity.VO.ModuleSettingVO;",
            "import com.kakarote.admin.service.IAdminConfigService;",
            "import com.kakarote.admin.service.IAdminModelSortService;",
            "import com.kakarote.admin.service.IAdminUserConfigService;",
            "import com.kakarote.core.common.*;",
            "import com.kakarote.core.common.log.BehaviorEnum;",
            "import com.kakarote.core.common.log.SysLog;",
            "import com.kakarote.core.common.log.SysLogHandler;",
            "import com.kakarote.core.utils.UserUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import io.swagger.annotations.ApiParam;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.web.bind.annotation.*;",
            "import javax.servlet.http.HttpServletRequest;",
            "import javax.validation.Valid;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "save",
            "setDescription",
            "ok",
            "setName",
            "getUserId",
            "queryUserConfigByName",
            "setUserId",
            "setStatus",
            "updateById",
            "setValue",
            "toJSONString"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "save",
            "setDescription",
            "ok",
            "setName",
            "getUserId",
            "queryUserConfigByName",
            "setUserId",
            "setStatus",
            "updateById",
            "setValue",
            "toJSONString"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public Result<AdminUser> queryUserInfo(@RequestParam(\"userId\") Long userId) ",
        "start_line": "298",
        "end_line": "305",
        "file_path": "admin/src/main/java/com/kakarote/admin/controller/AdminUserController.java",
        "docstring": "This function retrieves user information for a given user ID. It fetches the user details, retrieves the department name based on the user's department ID, sets the department name in the user object, and nullifies the salt and password fields. It then returns the user information wrapped in a result object.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "d3605bc2f5f9",
        "ground_truth": "public Result<AdminUser> queryUserInfo(@RequestParam(\"userId\") Long userId) {\n    AdminUser byId = adminUserService.getById(userId);\n    String nameByDeptId = ApplicationContextHolder.getBean(IAdminDeptService.class).getNameByDeptId(byId.getDeptId());\n    byId.setDeptName(nameByDeptId);\n    byId.setSalt(null);\n    byId.setPassword(null);\n    return R.ok(byId);\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.io.FileUtil;",
            "import cn.hutool.core.io.IoUtil;",
            "import cn.hutool.core.util.ObjectUtil;",
            "import cn.hutool.extra.servlet.ServletUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.alibaba.fastjson.util.TypeUtils;",
            "import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.log.AdminUserLog;",
            "import com.kakarote.admin.entity.BO.*;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.AdminUserConfig;",
            "import com.kakarote.admin.entity.VO.AdminSuperUserVo;",
            "import com.kakarote.admin.entity.VO.AdminUserVO;",
            "import com.kakarote.admin.entity.VO.HrmSimpleUserVO;",
            "import com.kakarote.admin.service.*;",
            "import com.kakarote.core.common.*;",
            "import com.kakarote.core.common.log.BehaviorEnum;",
            "import com.kakarote.core.common.log.SysLog;",
            "import com.kakarote.core.common.log.SysLogHandler;",
            "import com.kakarote.core.entity.BasePage;",
            "import com.kakarote.core.entity.UserInfo;",
            "import com.kakarote.core.exception.NoLoginException;",
            "import com.kakarote.core.feign.admin.entity.SimpleUser;",
            "import com.kakarote.core.feign.email.EmailService;",
            "import com.kakarote.core.servlet.ApplicationContextHolder;",
            "import com.kakarote.core.servlet.upload.UploadEntity;",
            "import com.kakarote.core.utils.UserCacheUtil;",
            "import com.kakarote.core.utils.UserUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.validation.annotation.Validated;",
            "import org.springframework.web.bind.annotation.*;",
            "import org.springframework.web.multipart.MultipartFile;",
            "import javax.servlet.http.HttpServletRequest;",
            "import javax.servlet.http.HttpServletResponse;",
            "import javax.validation.constraints.NotNull;",
            "import java.io.BufferedInputStream;",
            "import java.io.File;",
            "import java.io.IOException;",
            "import java.util.*;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "getById",
            "ok",
            "getBean",
            "setDeptName",
            "setSalt",
            "getNameByDeptId",
            "getDeptId",
            "setPassword"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getById",
            "ok",
            "getBean",
            "setDeptName",
            "setSalt",
            "getNameByDeptId",
            "getDeptId",
            "setPassword"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": " public Result readNotice() ",
        "start_line": "349",
        "end_line": "365",
        "file_path": "admin/src/main/java/com/kakarote/admin/controller/AdminUserController.java",
        "docstring": "This function updates the \"readNotice\" status for the current user. It retrieves the user ID and checks if there are multiple \"readNotice\" entries for the user. If more than one entry exists, it updates the status to 1 for all matching entries. If not, it creates a new \"readNotice\" entry with status 1 and saves it. The function returns a success result.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "eec7f492f5f4",
        "ground_truth": "public Result readNotice() {\n    Long userId = UserUtil.getUserId();\n    String name = \"readNotice\";\n    Integer count = adminUserConfigService.lambdaQuery().eq(AdminUserConfig::getUserId, userId).eq(AdminUserConfig::getName, name).count();\n    if (count > 1) {\n        adminUserConfigService.lambdaUpdate().set(AdminUserConfig::getStatus, 1).eq(AdminUserConfig::getUserId, userId).eq(AdminUserConfig::getName, name).update();\n    } else {\n        AdminUserConfig adminUserConfig = new AdminUserConfig();\n        adminUserConfig.setValue(\"\");\n        adminUserConfig.setName(name);\n        adminUserConfig.setUserId(userId);\n        adminUserConfig.setStatus(1);\n        adminUserConfig.setDescription(\"\u5347\u7ea7\u65e5\u5fd7\u9605\u8bfb\u72b6\u6001\");\n        adminUserConfigService.save(adminUserConfig);\n    }\n    return R.ok();\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.io.FileUtil;",
            "import cn.hutool.core.io.IoUtil;",
            "import cn.hutool.core.util.ObjectUtil;",
            "import cn.hutool.extra.servlet.ServletUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.alibaba.fastjson.JSONObject;",
            "import com.alibaba.fastjson.util.TypeUtils;",
            "import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.log.AdminUserLog;",
            "import com.kakarote.admin.entity.BO.*;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.AdminUserConfig;",
            "import com.kakarote.admin.entity.VO.AdminSuperUserVo;",
            "import com.kakarote.admin.entity.VO.AdminUserVO;",
            "import com.kakarote.admin.entity.VO.HrmSimpleUserVO;",
            "import com.kakarote.admin.service.*;",
            "import com.kakarote.core.common.*;",
            "import com.kakarote.core.common.log.BehaviorEnum;",
            "import com.kakarote.core.common.log.SysLog;",
            "import com.kakarote.core.common.log.SysLogHandler;",
            "import com.kakarote.core.entity.BasePage;",
            "import com.kakarote.core.entity.UserInfo;",
            "import com.kakarote.core.exception.NoLoginException;",
            "import com.kakarote.core.feign.admin.entity.SimpleUser;",
            "import com.kakarote.core.feign.email.EmailService;",
            "import com.kakarote.core.servlet.ApplicationContextHolder;",
            "import com.kakarote.core.servlet.upload.UploadEntity;",
            "import com.kakarote.core.utils.UserCacheUtil;",
            "import com.kakarote.core.utils.UserUtil;",
            "import io.swagger.annotations.Api;",
            "import io.swagger.annotations.ApiOperation;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.validation.annotation.Validated;",
            "import org.springframework.web.bind.annotation.*;",
            "import org.springframework.web.multipart.MultipartFile;",
            "import javax.servlet.http.HttpServletRequest;",
            "import javax.servlet.http.HttpServletResponse;",
            "import javax.validation.constraints.NotNull;",
            "import java.io.BufferedInputStream;",
            "import java.io.File;",
            "import java.io.IOException;",
            "import java.util.*;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "save",
            "count",
            "setDescription",
            "ok",
            "lambdaUpdate",
            "setName",
            "set",
            "getUserId",
            "setUserId",
            "lambdaQuery",
            "eq",
            "setStatus",
            "update",
            "setValue"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "save",
            "count",
            "setDescription",
            "ok",
            "lambdaUpdate",
            "setName",
            "set",
            "getUserId",
            "setUserId",
            "lambdaQuery",
            "eq",
            "setStatus",
            "update",
            "setValue"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public void setAdminConfig(AdminCompanyBO adminCompanyBO)",
        "start_line": "95",
        "end_line": "106",
        "file_path": "admin/src/main/java/com/kakarote/admin/service/impl/AdminConfigServiceImpl.java",
        "docstring": "This function sets the administrative configuration for company information. It searches for an existing configuration with the name \"companyInfo.\" If not found, it creates a new configuration with default values. It then updates the configuration's value with the provided company information in JSON format and saves or updates the configuration.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "bb4f6d7099ab",
        "ground_truth": "public void setAdminConfig(AdminCompanyBO adminCompanyBO) {\n    String companyKey = \"companyInfo\";\n    AdminConfig adminConfig = lambdaQuery().eq(AdminConfig::getName, companyKey).last(\" limit 1\").one();\n    if (adminConfig == null) {\n        adminConfig = new AdminConfig();\n        adminConfig.setName(companyKey);\n        adminConfig.setStatus(1);\n        adminConfig.setDescription(\"\u4f01\u4e1aLOGO\u914d\u7f6e\");\n    }\n    adminConfig.setValue(JSON.toJSONString(adminCompanyBO));\n    saveOrUpdate(adminConfig);\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.collection.CollUtil;",
            "import cn.hutool.core.util.RandomUtil;",
            "import cn.hutool.core.util.StrUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.AdminConst;",
            "import com.kakarote.admin.common.AdminModuleEnum;",
            "import com.kakarote.admin.common.AuthPasswordUtil;",
            "import com.kakarote.admin.entity.BO.AdminCompanyBO;",
            "import com.kakarote.admin.entity.BO.AdminInitDataBO;",
            "import com.kakarote.admin.entity.BO.LogWelcomeSpeechBO;",
            "import com.kakarote.admin.entity.PO.AdminAttention;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.AdminUserRole;",
            "import com.kakarote.admin.entity.VO.AdminUserVO;",
            "import com.kakarote.admin.entity.VO.ModuleSettingVO;",
            "import com.kakarote.admin.mapper.AdminConfigMapper;",
            "import com.kakarote.admin.service.*;",
            "import com.kakarote.core.common.SystemCodeEnum;",
            "import com.kakarote.core.common.cache.AdminCacheKey;",
            "import com.kakarote.core.exception.CrmException;",
            "import com.kakarote.core.feign.crm.service.CrmAnalysisService;",
            "import com.kakarote.core.feign.jxc.service.JxcExamineService;",
            "import com.kakarote.core.feign.km.KmService;",
            "import com.kakarote.core.feign.oa.OaService;",
            "import com.kakarote.core.feign.work.WorkService;",
            "import com.kakarote.core.servlet.BaseServiceImpl;",
            "import com.kakarote.core.utils.BaseUtil;",
            "import com.kakarote.core.utils.UserUtil;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.Objects;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "one",
            "last",
            "setDescription",
            "setName",
            "lambdaQuery",
            "eq",
            "setStatus",
            "setValue",
            "saveOrUpdate",
            "toJSONString"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "one",
            "last",
            "setDescription",
            "setName",
            "lambdaQuery",
            "eq",
            "setStatus",
            "setValue",
            "saveOrUpdate",
            "toJSONString"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public AdminCompanyBO queryAdminConfig()",
        "start_line": "114",
        "end_line": "122",
        "file_path": "admin/src/main/java/com/kakarote/admin/service/impl/AdminConfigServiceImpl.java",
        "docstring": "This function retrieves the admin configuration for a company. It queries the admin configuration using a specific key and, if found, parses the configuration value into an AdminCompanyBO object. It returns this object, either populated with the parsed data or as a new instance if no configuration is found.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7a8c61774b82",
        "ground_truth": "public AdminCompanyBO queryAdminConfig() {\n    String companyKey = \"companyInfo\";\n    AdminConfig adminConfig = lambdaQuery().eq(AdminConfig::getName, companyKey).last(\" limit 1\").one();\n    AdminCompanyBO adminCompanyBO = new AdminCompanyBO();\n    if (adminConfig != null) {\n        adminCompanyBO = JSON.parseObject(adminConfig.getValue(), AdminCompanyBO.class);\n    }\n    return adminCompanyBO;\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.collection.CollUtil;",
            "import cn.hutool.core.util.RandomUtil;",
            "import cn.hutool.core.util.StrUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.AdminConst;",
            "import com.kakarote.admin.common.AdminModuleEnum;",
            "import com.kakarote.admin.common.AuthPasswordUtil;",
            "import com.kakarote.admin.entity.BO.AdminCompanyBO;",
            "import com.kakarote.admin.entity.BO.AdminInitDataBO;",
            "import com.kakarote.admin.entity.BO.LogWelcomeSpeechBO;",
            "import com.kakarote.admin.entity.PO.AdminAttention;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.AdminUserRole;",
            "import com.kakarote.admin.entity.VO.AdminUserVO;",
            "import com.kakarote.admin.entity.VO.ModuleSettingVO;",
            "import com.kakarote.admin.mapper.AdminConfigMapper;",
            "import com.kakarote.admin.service.*;",
            "import com.kakarote.core.common.SystemCodeEnum;",
            "import com.kakarote.core.common.cache.AdminCacheKey;",
            "import com.kakarote.core.exception.CrmException;",
            "import com.kakarote.core.feign.crm.service.CrmAnalysisService;",
            "import com.kakarote.core.feign.jxc.service.JxcExamineService;",
            "import com.kakarote.core.feign.km.KmService;",
            "import com.kakarote.core.feign.oa.OaService;",
            "import com.kakarote.core.feign.work.WorkService;",
            "import com.kakarote.core.servlet.BaseServiceImpl;",
            "import com.kakarote.core.utils.BaseUtil;",
            "import com.kakarote.core.utils.UserUtil;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.Objects;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "one",
            "last",
            "getValue",
            "parseObject",
            "lambdaQuery",
            "eq"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "one",
            "last",
            "getValue",
            "parseObject",
            "lambdaQuery",
            "eq"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": " public void setLogWelcomeSpeech(List<String> stringList)",
        "start_line": "165",
        "end_line": "178",
        "file_path": "admin/src/main/java/com/kakarote/admin/service/impl/AdminConfigServiceImpl.java",
        "docstring": "This function sets the log welcome speech by taking a list of strings, creating AdminConfig objects for each string, and setting their properties. It then removes existing configurations with the specified log configuration name and saves the new list of configurations in batch.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "61e79dab4156",
        "ground_truth": "public void setLogWelcomeSpeech(List<String> stringList) {\n    List<AdminConfig> configList = new ArrayList<>();\n    stringList.forEach(str -> {\n        AdminConfig config = new AdminConfig();\n        config.setName(logConfigName);\n        config.setValue(str);\n        config.setStatus(1);\n        configList.add(config);\n    });\n    QueryWrapper<AdminConfig> queryWrapper = new QueryWrapper<>();\n    queryWrapper.eq(\"name\", logConfigName);\n    remove(queryWrapper);\n    saveBatch(configList, AdminConst.BATCH_SAVE_SIZE);\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.collection.CollUtil;",
            "import cn.hutool.core.util.RandomUtil;",
            "import cn.hutool.core.util.StrUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.AdminConst;",
            "import com.kakarote.admin.common.AdminModuleEnum;",
            "import com.kakarote.admin.common.AuthPasswordUtil;",
            "import com.kakarote.admin.entity.BO.AdminCompanyBO;",
            "import com.kakarote.admin.entity.BO.AdminInitDataBO;",
            "import com.kakarote.admin.entity.BO.LogWelcomeSpeechBO;",
            "import com.kakarote.admin.entity.PO.AdminAttention;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.AdminUserRole;",
            "import com.kakarote.admin.entity.VO.AdminUserVO;",
            "import com.kakarote.admin.entity.VO.ModuleSettingVO;",
            "import com.kakarote.admin.mapper.AdminConfigMapper;",
            "import com.kakarote.admin.service.*;",
            "import com.kakarote.core.common.SystemCodeEnum;",
            "import com.kakarote.core.common.cache.AdminCacheKey;",
            "import com.kakarote.core.exception.CrmException;",
            "import com.kakarote.core.feign.crm.service.CrmAnalysisService;",
            "import com.kakarote.core.feign.jxc.service.JxcExamineService;",
            "import com.kakarote.core.feign.km.KmService;",
            "import com.kakarote.core.feign.oa.OaService;",
            "import com.kakarote.core.feign.work.WorkService;",
            "import com.kakarote.core.servlet.BaseServiceImpl;",
            "import com.kakarote.core.utils.BaseUtil;",
            "import com.kakarote.core.utils.UserUtil;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.Objects;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "saveBatch",
            "setName",
            "forEach",
            "eq",
            "setStatus",
            "add",
            "setValue",
            "remove"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "saveBatch",
            "setName",
            "forEach",
            "eq",
            "setStatus",
            "add",
            "setValue",
            "remove"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public String verifyPassword(AdminInitDataBO adminInitDataBO)",
        "start_line": "261",
        "end_line": "273",
        "file_path": "admin/src/main/java/com/kakarote/admin/service/impl/AdminConfigServiceImpl.java",
        "docstring": "This function verifies the user's password. It retrieves the current user ID and user details, including the username. It checks the provided password against the stored password using the username and salt. If the password is correct, it generates a temporary access code, stores it in Redis with a 10-minute expiration, and returns the code. If the password is incorrect, it throws an exception indicating an invalid password.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "08475b0afb35",
        "ground_truth": "public String verifyPassword(AdminInitDataBO adminInitDataBO) {\n    Long userId = UserUtil.getUserId();\n    AdminUser user = adminUserService.getById(userId);\n     String userName = user.getUsername();\n     boolean isPass = AuthPasswordUtil.verify(userName + adminInitDataBO.getPassword(), user.getSalt(), user.getPassword());\n    if (isPass) {\n        String cacheName = AdminCacheKey.TEMPORARY_ACCESS_CODE_CACHE_KEY + userId;\n        String value = String.valueOf(RandomUtil.randomInt(100000, 999999));\n        BaseUtil.getRedis().setex(cacheName, 600, value);\n        return value;\n    }\n    throw new CrmException(AdminCodeEnum.ADMIN_PASSWORD_INVALID_ERROR);\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.collection.CollUtil;",
            "import cn.hutool.core.util.RandomUtil;",
            "import cn.hutool.core.util.StrUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.AdminConst;",
            "import com.kakarote.admin.common.AdminModuleEnum;",
            "import com.kakarote.admin.common.AuthPasswordUtil;",
            "import com.kakarote.admin.entity.BO.AdminCompanyBO;",
            "import com.kakarote.admin.entity.BO.AdminInitDataBO;",
            "import com.kakarote.admin.entity.BO.LogWelcomeSpeechBO;",
            "import com.kakarote.admin.entity.PO.AdminAttention;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.AdminUserRole;",
            "import com.kakarote.admin.entity.VO.AdminUserVO;",
            "import com.kakarote.admin.entity.VO.ModuleSettingVO;",
            "import com.kakarote.admin.mapper.AdminConfigMapper;",
            "import com.kakarote.admin.service.*;",
            "import com.kakarote.core.common.SystemCodeEnum;",
            "import com.kakarote.core.common.cache.AdminCacheKey;",
            "import com.kakarote.core.exception.CrmException;",
            "import com.kakarote.core.feign.crm.service.CrmAnalysisService;",
            "import com.kakarote.core.feign.jxc.service.JxcExamineService;",
            "import com.kakarote.core.feign.km.KmService;",
            "import com.kakarote.core.feign.oa.OaService;",
            "import com.kakarote.core.feign.work.WorkService;",
            "import com.kakarote.core.servlet.BaseServiceImpl;",
            "import com.kakarote.core.utils.BaseUtil;",
            "import com.kakarote.core.utils.UserUtil;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.Objects;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "randomInt",
            "getById",
            "getUsername",
            "getRedis",
            "setex",
            "valueOf",
            "getUserId",
            "verify",
            "getPassword",
            "getSalt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "randomInt",
            "getById",
            "getUsername",
            "getRedis",
            "setex",
            "getUserId",
            "verify",
            "getPassword",
            "getSalt"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "private boolean verifyInitAuth()",
        "start_line": "362",
        "end_line": "371",
        "file_path": "admin/src/main/java/com/kakarote/admin/service/impl/AdminConfigServiceImpl.java",
        "docstring": "This function checks if the current user lacks authorization for the initial authentication URL. It retrieves the user ID, constructs a key, and fetches the list of unauthorized menu URLs from Redis. If the initial authentication URL is in this list, it returns true, indicating no authorization; otherwise, it returns false.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9ec6e4941174",
        "ground_truth": "private boolean verifyInitAuth() {\n    boolean isNoAuth = false;\n    Long userId = UserUtil.getUserId();\n    String key = userId.toString();\n    List<String> noAuthMenuUrls = BaseUtil.getRedis().get(key);\n    if (noAuthMenuUrls != null && noAuthMenuUrls.contains(INIT_AUTH_URL)) {\n        isNoAuth = true;\n    }\n    return isNoAuth;\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.collection.CollUtil;",
            "import cn.hutool.core.util.RandomUtil;",
            "import cn.hutool.core.util.StrUtil;",
            "import com.alibaba.fastjson.JSON;",
            "import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;",
            "import com.kakarote.admin.common.AdminCodeEnum;",
            "import com.kakarote.admin.common.AdminConst;",
            "import com.kakarote.admin.common.AdminModuleEnum;",
            "import com.kakarote.admin.common.AuthPasswordUtil;",
            "import com.kakarote.admin.entity.BO.AdminCompanyBO;",
            "import com.kakarote.admin.entity.BO.AdminInitDataBO;",
            "import com.kakarote.admin.entity.BO.LogWelcomeSpeechBO;",
            "import com.kakarote.admin.entity.PO.AdminAttention;",
            "import com.kakarote.admin.entity.PO.AdminConfig;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.AdminUserRole;",
            "import com.kakarote.admin.entity.VO.AdminUserVO;",
            "import com.kakarote.admin.entity.VO.ModuleSettingVO;",
            "import com.kakarote.admin.mapper.AdminConfigMapper;",
            "import com.kakarote.admin.service.*;",
            "import com.kakarote.core.common.SystemCodeEnum;",
            "import com.kakarote.core.common.cache.AdminCacheKey;",
            "import com.kakarote.core.exception.CrmException;",
            "import com.kakarote.core.feign.crm.service.CrmAnalysisService;",
            "import com.kakarote.core.feign.jxc.service.JxcExamineService;",
            "import com.kakarote.core.feign.km.KmService;",
            "import com.kakarote.core.feign.oa.OaService;",
            "import com.kakarote.core.feign.work.WorkService;",
            "import com.kakarote.core.servlet.BaseServiceImpl;",
            "import com.kakarote.core.utils.BaseUtil;",
            "import com.kakarote.core.utils.UserUtil;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.Objects;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "getRedis",
            "toString",
            "getUserId",
            "get",
            "contains"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getRedis",
            "getUserId",
            "get"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public void saveRoleMenu(Integer roleId, List<Integer> menuIdList)",
        "start_line": "25",
        "end_line": "34",
        "file_path": "admin/src/main/java/com/kakarote/admin/service/impl/AdminRoleMenuServiceImpl.java",
        "docstring": "This function assigns a list of menu IDs to a specified role by creating a list of AdminRoleMenu objects, each containing a role ID and a menu ID. It then saves the list of role-menu associations in batches.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5a248de33a20",
        "ground_truth": "public void saveRoleMenu(Integer roleId, List<Integer> menuIdList) {\n    List<AdminRoleMenu> adminRoleMenuList = new ArrayList<>();\n    menuIdList.forEach(menuId -> {\n        AdminRoleMenu adminRoleMenu = new AdminRoleMenu();\n        adminRoleMenu.setMenuId(menuId);\n        adminRoleMenu.setRoleId(roleId);\n        adminRoleMenuList.add(adminRoleMenu);\n    });\n    saveBatch(adminRoleMenuList, Const.BATCH_SAVE_SIZE);\n}",
        "import_statements": [
            "import com.kakarote.admin.entity.PO.AdminRoleMenu;",
            "import com.kakarote.admin.mapper.AdminRoleMenuMapper;",
            "import com.kakarote.admin.service.IAdminRoleMenuService;",
            "import com.kakarote.core.common.Const;",
            "import com.kakarote.core.servlet.BaseServiceImpl;",
            "import org.springframework.stereotype.Service;",
            "import java.util.ArrayList;",
            "import java.util.List;"
        ],
        "reference_api": [
            "saveBatch",
            "forEach",
            "add",
            "setRoleId",
            "setMenuId"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "saveBatch",
            "forEach",
            "add",
            "setRoleId",
            "setMenuId"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public void saveSysLog(SysLog sysLog) ",
        "start_line": "169",
        "end_line": "184",
        "file_path": "admin/src/main/java/com/kakarote/admin/service/impl/EsSysLogServiceImpl.java",
        "docstring": "This function saves a system log asynchronously. It retrieves the log index, converts the log object to a map, formats the creation time, and removes the ID. It then creates an index request and submits it to the Elasticsearch client. If an error occurs, it logs the error message.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a550a6fea46c",
        "ground_truth": "public void saveSysLog(SysLog sysLog) {\n    String index = getSysLogIndex();\n    adminThreadPoolExecutor.execute(() -> {\n        IndexRequest indexRequest = new IndexRequest(index, \"_doc\");\n        Map<String, Object> source = BeanUtil.beanToMap(sysLog);\n        source.put(\"createTime\", DateUtil.formatDateTime(sysLog.getCreateTime()));\n        source.remove(\"id\");\n        indexRequest.source(source);\n        try {\n            IndexResponse index1 = restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);\n            System.out.println(index1.status());\n        } catch (IOException e) {\n            log.error(\"\u4fdd\u5b58\u7cfb\u7edf\u65e5\u5fd7\u5f02\u5e38,msg:{}\", e.getMessage());\n        }\n    });\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.collection.CollUtil;",
            "import cn.hutool.core.date.DateUtil;",
            "import cn.hutool.core.util.StrUtil;",
            "import com.kakarote.admin.entity.BO.QuerySysLogBO;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.LoginLog;",
            "import com.kakarote.admin.entity.PO.SysLog;",
            "import com.kakarote.admin.service.IAdminUserService;",
            "import com.kakarote.admin.service.ISysLogService;",
            "import com.kakarote.core.entity.BasePage;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.elasticsearch.action.index.IndexRequest;",
            "import org.elasticsearch.action.index.IndexResponse;",
            "import org.elasticsearch.action.search.SearchRequest;",
            "import org.elasticsearch.action.search.SearchResponse;",
            "import org.elasticsearch.client.RequestOptions;",
            "import org.elasticsearch.client.RestHighLevelClient;",
            "import org.elasticsearch.client.indices.CreateIndexRequest;",
            "import org.elasticsearch.client.indices.GetIndexRequest;",
            "import org.elasticsearch.common.xcontent.XContentType;",
            "import org.elasticsearch.index.query.*;",
            "import org.elasticsearch.search.SearchHit;",
            "import org.elasticsearch.search.SearchHits;",
            "import org.elasticsearch.search.builder.SearchSourceBuilder;",
            "import org.elasticsearch.search.sort.SortOrder;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;",
            "import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;",
            "import org.springframework.stereotype.Service;",
            "import javax.annotation.Resource;",
            "import java.io.IOException;",
            "import java.time.LocalDate;",
            "import java.time.format.DateTimeFormatter;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.Map;"
        ],
        "reference_api": [
            "getSysLogIndex",
            "index",
            "error",
            "source",
            "execute",
            "beanToMap",
            "getMessage",
            "remove",
            "println",
            "formatDateTime",
            "status",
            "put",
            "getCreateTime"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getSysLogIndex",
                "code": "private String getSysLogIndex() {\n        String month = LocalDate.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM\"));\n        String index = getIndexAliases(SYS_LOG_TYPE) + \"-\" + month;\n        GetIndexRequest getIndexRequest = new GetIndexRequest(index);\n        try {\n            boolean exists = restHighLevelClient.indices().exists(getIndexRequest, RequestOptions.DEFAULT);\n            if (!exists) {\n                CreateIndexRequest createIndexRequest = new CreateIndexRequest(index);\n                createIndexRequest.source(SYS_LOG_INDEX_SOURCE, XContentType.JSON);\n                restHighLevelClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);\n            }\n        } catch (IOException e) {\n            log.error(\"\u521b\u5efa\u7cfb\u7edf\u65e5\u5fd7\u7d22\u5f15\u5f02\u5e38,msg:{}\", e.getMessage());\n        }\n        return index;\n    }"
            }
        ],
        "third_party": [
            "index",
            "error",
            "source",
            "execute",
            "beanToMap",
            "getMessage",
            "remove",
            "println",
            "formatDateTime",
            "status",
            "put",
            "getCreateTime"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "WuKongOpenSource/WukongCRM-11.0-JAVA",
        "function_declaration": "public BasePage<SysLog> querySysLogPageList(QuerySysLogBO querySysLogBO)",
        "start_line": "246",
        "end_line": "269",
        "file_path": "admin/src/main/java/com/kakarote/admin/service/impl/EsSysLogServiceImpl.java",
        "docstring": "This function queries a paginated list of system logs based on the given query parameters. It initializes the search criteria, sorts the results by creation time in descending order, and excludes specific fields from the response. It executes the search request using a REST client, maps the search results to SysLog objects, and populates a BasePage object with the results, including total hits and current page. It handles IO exceptions by logging an error message.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8ba01d193706",
        "ground_truth": "public BasePage<SysLog> querySysLogPageList(QuerySysLogBO querySysLogBO) {\n    getSysLogIndex();\n    BasePage<SysLog> page = new BasePage<>();\n    List<SysLog> logList = new ArrayList<>();\n    SearchSourceBuilder searchSourceBuilder = createSearchSourceBuilder(querySysLogBO);\n    searchSourceBuilder.sort(\"createTime\", SortOrder.DESC);\n    searchSourceBuilder.fetchSource(null, new String[]{\"args\",\"className\",\"methodName\"});\n    try {\n        SearchRequest searchRequest = new SearchRequest(getIndexAliases(SYS_LOG_TYPE));\n        searchRequest.source(searchSourceBuilder);\n        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);\n        SearchHits hits = searchResponse.getHits();\n        for (SearchHit hit : hits.getHits()) {\n            Map<String, Object> sourceAsMap = hit.getSourceAsMap();\n            logList.add(BeanUtil.mapToBean(sourceAsMap, SysLog.class, true));\n        }\n        page.setTotal(hits.getTotalHits());\n        page.setCurrent(querySysLogBO.getPage());\n        page.setList(logList);\n    } catch (IOException e) {\n        log.error(\"\u67e5\u8be2\u7cfb\u7edf\u65e5\u5fd7\u5f02\u5e38,msg:{}\", e.getMessage());\n    }\n    return page;\n}",
        "import_statements": [
            "import cn.hutool.core.bean.BeanUtil;",
            "import cn.hutool.core.collection.CollUtil;",
            "import cn.hutool.core.date.DateUtil;",
            "import cn.hutool.core.util.StrUtil;",
            "import com.kakarote.admin.entity.BO.QuerySysLogBO;",
            "import com.kakarote.admin.entity.PO.AdminUser;",
            "import com.kakarote.admin.entity.PO.LoginLog;",
            "import com.kakarote.admin.entity.PO.SysLog;",
            "import com.kakarote.admin.service.IAdminUserService;",
            "import com.kakarote.admin.service.ISysLogService;",
            "import com.kakarote.core.entity.BasePage;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.elasticsearch.action.index.IndexRequest;",
            "import org.elasticsearch.action.index.IndexResponse;",
            "import org.elasticsearch.action.search.SearchRequest;",
            "import org.elasticsearch.action.search.SearchResponse;",
            "import org.elasticsearch.client.RequestOptions;",
            "import org.elasticsearch.client.RestHighLevelClient;",
            "import org.elasticsearch.client.indices.CreateIndexRequest;",
            "import org.elasticsearch.client.indices.GetIndexRequest;",
            "import org.elasticsearch.common.xcontent.XContentType;",
            "import org.elasticsearch.index.query.*;",
            "import org.elasticsearch.search.SearchHit;",
            "import org.elasticsearch.search.SearchHits;",
            "import org.elasticsearch.search.builder.SearchSourceBuilder;",
            "import org.elasticsearch.search.sort.SortOrder;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;",
            "import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;",
            "import org.springframework.stereotype.Service;",
            "import javax.annotation.Resource;",
            "import java.io.IOException;",
            "import java.time.LocalDate;",
            "import java.time.format.DateTimeFormatter;",
            "import java.util.ArrayList;",
            "import java.util.List;",
            "import java.util.Map;"
        ],
        "reference_api": [
            "getHits",
            "setList",
            "getSysLogIndex",
            "getTotalHits",
            "error",
            "source",
            "getIndexAliases",
            "getMessage",
            "fetchSource",
            "createSearchSourceBuilder",
            "setTotal",
            "mapToBean",
            "getSourceAsMap",
            "search",
            "getPage",
            "add",
            "setCurrent",
            "sort"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getSysLogIndex",
                "code": "private String getSysLogIndex() {\n        String month = LocalDate.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM\"));\n        String index = getIndexAliases(SYS_LOG_TYPE) + \"-\" + month;\n        GetIndexRequest getIndexRequest = new GetIndexRequest(index);\n        try {\n            boolean exists = restHighLevelClient.indices().exists(getIndexRequest, RequestOptions.DEFAULT);\n            if (!exists) {\n                CreateIndexRequest createIndexRequest = new CreateIndexRequest(index);\n                createIndexRequest.source(SYS_LOG_INDEX_SOURCE, XContentType.JSON);\n                restHighLevelClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);\n            }\n        } catch (IOException e) {\n            log.error(\"\u521b\u5efa\u7cfb\u7edf\u65e5\u5fd7\u7d22\u5f15\u5f02\u5e38,msg:{}\", e.getMessage());\n        }\n        return index;\n    }"
            },
            {
                "name": "getIndexAliases",
                "code": "private static String getIndexAliases(Integer logType){\n        String indexAliases;\n        if (logType.equals(SYS_LOG_TYPE)){\n            indexAliases = \"wk-sys-log\";\n        }else {\n            indexAliases = \"wk-login-log\";\n        }\n        return indexAliases;\n    }"
            },
            {
                "name": "createSearchSourceBuilder",
                "code": "private SearchSourceBuilder createSearchSourceBuilder(QuerySysLogBO querySysLogBO) {\n        SearchSourceBuilder searchSourceBuilder = SearchSourceBuilder.searchSource();\n        //query\n        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();\n        if (querySysLogBO.getType() != null){\n            if (querySysLogBO.getType() == 1){\n                boolQueryBuilder.mustNot(QueryBuilders.termQuery(\"model\",\"admin\"));\n            }else if (querySysLogBO.getType() == 2){\n                boolQueryBuilder.must(QueryBuilders.termQuery(\"model\",\"admin\"));\n            }\n        }\n        if (querySysLogBO.getStartTime() != null && querySysLogBO.getEndTime() != null) {\n            RangeQueryBuilder createTimeQuery = QueryBuilders.rangeQuery(querySysLogBO.getType() == null ? \"loginTime\" : \"createTime\")\n                    .gte(querySysLogBO.getStartTime())\n                    .lte(querySysLogBO.getEndTime());\n            boolQueryBuilder.filter(createTimeQuery);\n        }\n        if (CollUtil.isNotEmpty(querySysLogBO.getUserIds())) {\n            TermsQueryBuilder userIdQuery = QueryBuilders.termsQuery(\"userId\", querySysLogBO.getUserIds());\n            boolQueryBuilder.filter(userIdQuery);\n        }\n        if (StrUtil.isNotEmpty(querySysLogBO.getModel())) {\n            TermQueryBuilder modelQuery = QueryBuilders.termQuery(\"model\", querySysLogBO.getModel());\n            boolQueryBuilder.filter(modelQuery);\n        }\n        if (CollUtil.isNotEmpty(querySysLogBO.getSubModelLabels())) {\n            TermsQueryBuilder modelQuery = QueryBuilders.termsQuery(\"subModelLabel\", querySysLogBO.getSubModelLabels());\n            boolQueryBuilder.filter(modelQuery);\n        }\n        //\u5206\u9875\n        if (querySysLogBO.getPage() <= 100) {\n            if (querySysLogBO.getPageType().equals(1)) {\n                // \u8bbe\u7f6e\u8d77\u6b62\u548c\u7ed3\u675f\n                searchSourceBuilder.from((querySysLogBO.getPage() - 1) * querySysLogBO.getLimit());\n            }\n        }\n        //\u8bbe\u7f6e\u67e5\u8be2\u6761\u6570\n        searchSourceBuilder.size(querySysLogBO.getLimit());\n        searchSourceBuilder.query(boolQueryBuilder);\n        return searchSourceBuilder;\n    }"
            }
        ],
        "third_party": [
            "getHits",
            "setList",
            "getTotalHits",
            "error",
            "source",
            "getMessage",
            "fetchSource",
            "setTotal",
            "mapToBean",
            "getSourceAsMap",
            "search",
            "getPage",
            "add",
            "setCurrent",
            "sort"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "async function downloadFile(url, dest)",
        "start_line": "13",
        "end_line": "30",
        "file_path": "client/scripts/build.js",
        "docstring": "This asynchronous function downloads a file from a given URL and saves it to a specified destination. It creates a writable stream for the destination file, makes an HTTPS GET request to the URL, and pipes the response to the file. Once the download is complete, it closes the file and resolves the promise. If an error occurs, it deletes the file and rejects the promise with the error.",
        "language": "JavaScript",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8a5f123ce19a",
        "ground_truth": "async function downloadFile(url, dest) {\n  const file = fs.createWriteStream(dest);\n  return new Promise((resolve, reject) => {\n    https\n      .get(url, function (response) {\n        response.pipe(file);\n        file.on(\"finish\", function () {\n          file.close(() => {\n            resolve();\n          });\n        });\n      })\n      .on(\"error\", function (err) {\n        fs.unlink(dest);\n        reject(err);\n      });\n  });\n}",
        "import_statements": [
            "node:fs",
            "node:path",
            "node:https",
            "shelljs",
            "chalk",
            "axios",
            "openblocks-dev-utils/buildVars.js",
            "openblocks-dev-utils/util.js"
        ],
        "reference_api": [
            "file.close",
            "fs.unlink",
            "response.pipe",
            "resolve",
            "file.on",
            "fs.createWriteStream",
            "https\n      .get",
            "reject",
            "https\n      .get(url, function (response) {\n        response.pipe(file);\n        file.on(\"finish\", function () {\n          file.close(() => {\n            resolve();\n          });\n        });\n      })\n      .on"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "file.close",
            "fs.unlink",
            "response.pipe",
            "resolve",
            "file.on",
            "fs.createWriteStream",
            "https\n      .get",
            "reject",
            "https\n      .get(url, function (response) {\n        response.pipe(file);\n        file.on(\"finish\", function () {\n          file.close(() => {\n            resolve();\n          });\n        });\n      })\n      .on"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": " private Flux<Application> getDependentModules(Application module, Set<String> circularDependencyCheckSet)",
        "start_line": "134",
        "end_line": "141",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/application/service/ApplicationService.java",
        "docstring": "This function retrieves dependent modules for a given application module while avoiding circular dependencies. It filters out already processed module IDs, adds new module IDs to the circular dependency check set, and retrieves the corresponding modules. It handles errors by logging a warning and continues processing.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "0eb664e65a38",
        "ground_truth": "private Flux<Application> getDependentModules(Application module, Set<String> circularDependencyCheckSet) {\n    return Flux.fromIterable(module.getLiveModules())\n            .filter(moduleId -> !circularDependencyCheckSet.contains(moduleId))\n            .doOnNext(circularDependencyCheckSet::add)\n            .collectList()\n            .flatMapMany(this::findByIdIn)\n            .onErrorContinue((e, i) -> log.warn(\"get dependent modules on error continue , {}\", e.getMessage()));\n}",
        "import_statements": [
            "import static com.openblocks.domain.application.ApplicationUtil.getDependentModulesFromDsl;",
            "import java.util.Collection;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Set;",
            "import java.util.stream.Collectors;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.context.annotation.Lazy;",
            "import org.springframework.stereotype.Service;",
            "import com.google.common.collect.Lists;",
            "import com.google.common.collect.Sets;",
            "import com.openblocks.domain.application.model.Application;",
            "import com.openblocks.domain.application.model.ApplicationStatus;",
            "import com.openblocks.domain.application.repository.ApplicationRepository;",
            "import com.openblocks.domain.permission.model.ResourceRole;",
            "import com.openblocks.domain.permission.service.ResourcePermissionService;",
            "import com.openblocks.infra.annotation.NonEmptyMono;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper;",
            "import com.openblocks.sdk.constants.FieldName;",
            "import com.openblocks.sdk.exception.BizError;",
            "import com.openblocks.sdk.exception.BizException;",
            "import com.openblocks.sdk.models.HasIdAndAuditing;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "filter",
            "flatMapMany",
            "getLiveModules",
            "doOnNext",
            "getMessage",
            "onErrorContinue",
            "warn",
            "contains",
            "collectList",
            "fromIterable"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "filter",
            "flatMapMany",
            "getLiveModules",
            "doOnNext",
            "getMessage",
            "onErrorContinue",
            "warn",
            "collectList",
            "fromIterable"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public static void doGetDependentModules(Map<?, ?> map, Set<String> dependentModuleIds)",
        "start_line": "35",
        "end_line": "59",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/application/ApplicationUtil.java",
        "docstring": "This function recursively retrieves dependent module IDs from a nested map structure. It checks if the component type is \"module\" and adds the corresponding app ID to the set of dependent module IDs if it is not blank. It iterates through the map's entries and processes any nested maps or lists, invoking itself recursively to find and collect all dependent module IDs.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e208820f2c7a",
        "ground_truth": "public static void doGetDependentModules(Map<?, ?> map, Set<String> dependentModuleIds) {\n    Object compType = map.get(\"compType\");\n    if (compType instanceof String compTypeStr && compTypeStr.equals(\"module\")) {\n        Object comp = map.get(\"comp\");\n        if (comp instanceof Map<?, ?> compMap) {\n            String appId = (String) compMap.get(\"appId\");\n            if (StringUtils.isNotBlank(appId)) {\n                dependentModuleIds.add(appId);\n            }\n        }\n    }\n    map.forEach((key, value) -> {\n        if (value instanceof Map<?, ?> valueMap) {\n            doGetDependentModules(valueMap, dependentModuleIds);\n        }\n        if (value instanceof List<?> valueList) {\n            valueList.forEach(i -> {\n                if (i instanceof Map<?, ?> iMap) {\n                    doGetDependentModules(iMap, dependentModuleIds);\n                }\n            });\n        }\n    });\n}",
        "import_statements": [
            "import java.util.Collections;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Set;",
            "import javax.validation.constraints.NotNull;",
            "import org.apache.commons.lang3.StringUtils;",
            "import com.google.common.collect.Sets;"
        ],
        "reference_api": [
            "equals",
            "forEach",
            "get",
            "doGetDependentModules",
            "add",
            "isNotBlank"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "doGetDependentModules",
                "code": "public static void doGetDependentModules(Map<?, ?> map, Set<String> dependentModuleIds) {\n        Object compType = map.get(\"compType\");\n        if (compType instanceof String compTypeStr && compTypeStr.equals(\"module\")) {\n            Object comp = map.get(\"comp\");\n            if (comp instanceof Map<?, ?> compMap) {\n                String appId = (String) compMap.get(\"appId\");\n                if (StringUtils.isNotBlank(appId)) {\n                    dependentModuleIds.add(appId);\n                }\n            }\n        }\n\n        map.forEach((key, value) -> {\n            if (value instanceof Map<?, ?> valueMap) {\n                doGetDependentModules(valueMap, dependentModuleIds);\n            }\n            if (value instanceof List<?> valueList) {\n                valueList.forEach(i -> {\n                    if (i instanceof Map<?, ?> iMap) {\n                        doGetDependentModules(iMap, dependentModuleIds);\n                    }\n                });\n            }\n        });\n    }"
            }
        ],
        "third_party": [
            "forEach",
            "get",
            "add",
            "isNotBlank"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": " private Asset createAsset(DataBuffer dataBuffer, MediaType srcContentType, boolean createThumbnail) throws IOException ",
        "start_line": "96",
        "end_line": "110",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/asset/service/AssetServiceImpl.java",
        "docstring": "This function creates an Asset object by processing the given DataBuffer. It reads the image data, resizes it if the createThumbnail flag is true, and sets the content type to JPEG. If not creating a thumbnail, it retains the original content type. The function releases the DataBuffer after processing and returns a new Asset with the processed image data and content type.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "4e7e7106fd70",
        "ground_truth": "private Asset createAsset(DataBuffer dataBuffer, MediaType srcContentType, boolean createThumbnail) throws IOException {\n    byte[] imageData;\n    MediaType contentType;\n    if (createThumbnail) {\n        imageData = resizeImage(dataBuffer);\n        contentType = MediaType.IMAGE_JPEG;\n    } else {\n        imageData = new byte[dataBuffer.readableByteCount()];\n        dataBuffer.read(imageData);\n        contentType = srcContentType;\n    }\n    DataBufferUtils.release(dataBuffer);\n    return Asset.from(contentType, imageData);\n}",
        "import_statements": [
            "import java.awt.Color;",
            "import java.awt.Image;",
            "import java.awt.image.BufferedImage;",
            "import java.io.ByteArrayOutputStream;",
            "import java.io.IOException;",
            "import java.util.Set;",
            "import javax.imageio.ImageIO;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.core.io.buffer.DataBuffer;",
            "import org.springframework.core.io.buffer.DataBufferUtils;",
            "import org.springframework.core.io.buffer.DefaultDataBufferFactory;",
            "import org.springframework.http.HttpHeaders;",
            "import org.springframework.http.HttpStatus;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.codec.multipart.Part;",
            "import org.springframework.http.server.reactive.ServerHttpResponse;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.web.server.ServerWebExchange;",
            "import com.openblocks.domain.asset.model.Asset;",
            "import com.openblocks.sdk.config.dynamic.Conf;",
            "import com.openblocks.sdk.config.dynamic.ConfigCenter;",
            "import com.openblocks.sdk.exception.BizError;",
            "import com.openblocks.sdk.exception.BizException;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "from",
            "readableByteCount",
            "read",
            "resizeImage",
            "release"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "resizeImage",
                "code": "private byte[] resizeImage(DataBuffer dataBuffer) throws IOException {\n        int dimension = thumbNailPhotoDimension.get();\n        BufferedImage bufferedImage = ImageIO.read(dataBuffer.asInputStream());\n        Image scaledImage = bufferedImage.getScaledInstance(dimension, dimension, Image.SCALE_SMOOTH);\n        BufferedImage imageBuff = new BufferedImage(dimension, dimension, BufferedImage.TYPE_INT_RGB);\n        imageBuff.getGraphics().drawImage(scaledImage, 0, 0, new Color(0, 0, 0), null);\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        ImageIO.write(imageBuff, \"jpg\", buffer);\n        byte[] data = buffer.toByteArray();\n        buffer.close();\n        DataBufferUtils.release(dataBuffer);\n        return data;\n    }"
            }
        ],
        "third_party": [
            "from",
            "readableByteCount",
            "read",
            "release"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public Mono<Void> makeImageResponse(ServerWebExchange exchange, String assetId)",
        "start_line": "127",
        "end_line": "141",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/asset/service/AssetServiceImpl.java",
        "docstring": "This function creates an image response for a given asset ID in a reactive web exchange. It retrieves the asset by its ID, sets the response status to OK, and sets the content type header if available. Finally, it writes the asset data to the response using a data buffer.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e010df09a01e",
        "ground_truth": "public Mono<Void> makeImageResponse(ServerWebExchange exchange, String assetId) {\n    return getById(assetId)\n            .flatMap(asset -> {\n                final String contentType = asset.getContentType();\n                final ServerHttpResponse response = exchange.getResponse();\n                response.setStatusCode(HttpStatus.OK);\n                if (contentType != null) {\n                    response.getHeaders().set(HttpHeaders.CONTENT_TYPE, contentType);\n                }\n                return response.writeWith(Mono.just(new DefaultDataBufferFactory().wrap(asset.getData())));\n            });\n}",
        "import_statements": [
            "import java.awt.Color;",
            "import java.awt.Image;",
            "import java.awt.image.BufferedImage;",
            "import java.io.ByteArrayOutputStream;",
            "import java.io.IOException;",
            "import java.util.Set;",
            "import javax.imageio.ImageIO;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.core.io.buffer.DataBuffer;",
            "import org.springframework.core.io.buffer.DataBufferUtils;",
            "import org.springframework.core.io.buffer.DefaultDataBufferFactory;",
            "import org.springframework.http.HttpHeaders;",
            "import org.springframework.http.HttpStatus;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.codec.multipart.Part;",
            "import org.springframework.http.server.reactive.ServerHttpResponse;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.web.server.ServerWebExchange;",
            "import com.openblocks.domain.asset.model.Asset;",
            "import com.openblocks.sdk.config.dynamic.Conf;",
            "import com.openblocks.sdk.config.dynamic.ConfigCenter;",
            "import com.openblocks.sdk.exception.BizError;",
            "import com.openblocks.sdk.exception.BizException;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "getById",
            "getData",
            "getContentType",
            "getHeaders",
            "setStatusCode",
            "just",
            "getResponse",
            "set",
            "wrap",
            "writeWith",
            "flatMap"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getById",
                "code": "@Override\n    public Mono<Asset> getById(String id) {\n        return repository.findById(id);\n    }"
            }
        ],
        "third_party": [
            "getData",
            "getContentType",
            "getHeaders",
            "setStatusCode",
            "just",
            "getResponse",
            "set",
            "wrap",
            "writeWith",
            "flatMap"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "protected Flux<FindAuthConfig> findAllAuthConfigsForEnterpriseMode() ",
        "start_line": "76",
        "end_line": "87",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/authentication/AuthenticationServiceImpl.java",
        "docstring": "This function retrieves all authentication configurations for enterprise mode. If the workspace mode is SAAS, it returns an empty Flux. Otherwise, it fetches organizations in enterprise mode, maps their authentication configurations to FindAuthConfig objects, and returns them as a Flux.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "3840d74a3995",
        "ground_truth": "protected Flux<FindAuthConfig> findAllAuthConfigsForEnterpriseMode() {\n    if (commonConfig.getWorkspace().getMode() == WorkspaceMode.SAAS) {\n        return Flux.empty();\n    }\n    return organizationService.getOrganizationInEnterpriseMode()\n            .flatMapIterable(organization ->\n                    organization.getAuthConfigs()\n                            .stream()\n                            .map(abstractAuthConfig -> new FindAuthConfig(abstractAuthConfig, organization))\n                            .collect(Collectors.toList())\n            );\n}",
        "import_statements": [
            "import static com.openblocks.sdk.exception.BizError.LOG_IN_SOURCE_NOT_SUPPORTED;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofError;",
            "import java.util.Objects;",
            "import java.util.function.Function;",
            "import java.util.stream.Collectors;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import com.openblocks.domain.organization.service.OrganizationService;",
            "import com.openblocks.sdk.auth.AbstractAuthConfig;",
            "import com.openblocks.sdk.config.AuthProperties;",
            "import com.openblocks.sdk.config.CommonConfig;",
            "import com.openblocks.sdk.constants.WorkspaceMode;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "getMode",
            "toList",
            "flatMapIterable",
            "map",
            "getOrganizationInEnterpriseMode",
            "getWorkspace",
            "collect",
            "getAuthConfigs",
            "empty",
            "stream"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getMode",
            "toList",
            "flatMapIterable",
            "map",
            "getOrganizationInEnterpriseMode",
            "getWorkspace",
            "collect",
            "getAuthConfigs",
            "empty",
            "stream"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public MongockSpring5.MongockApplicationRunner mongockApplicationRunner(ApplicationContext springContext, MongoTemplate mongoTemplate)",
        "start_line": "52",
        "end_line": "62",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/configurations/MongoConfig.java",
        "docstring": "This function configures and returns a MongockApplicationRunner for database migrations. It sets up a MongoDB driver with specific write and read concerns, specifies the package to scan for change logs, and integrates the Spring application context. It then builds and returns the MongockApplicationRunner instance.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "504ee7326825",
        "ground_truth": "public MongockSpring5.MongockApplicationRunner mongockApplicationRunner(ApplicationContext springContext, MongoTemplate mongoTemplate) {\n    SpringDataMongoV3Driver springDataMongoV3Driver = SpringDataMongoV3Driver.withDefaultLock(mongoTemplate);\n    springDataMongoV3Driver.setWriteConcern(WriteConcern.JOURNALED.withJournal(false));\n    springDataMongoV3Driver.setReadConcern(ReadConcern.LOCAL);\n    return MongockSpring5.builder()\n            .setDriver(springDataMongoV3Driver)\n            .addChangeLogsScanPackages(List.of(\"com.openblocks.runner.migrations\"))\n            .setSpringContext(springContext)\n            .buildApplicationRunner();\n}",
        "import_statements": [
            "import java.util.List;",
            "import javax.annotation.PostConstruct;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.context.ApplicationContext;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.context.annotation.Configuration;",
            "import org.springframework.context.annotation.Primary;",
            "import org.springframework.data.domain.ReactiveAuditorAware;",
            "import org.springframework.data.mongodb.MongoDatabaseFactory;",
            "import org.springframework.data.mongodb.ReactiveMongoDatabaseFactory;",
            "import org.springframework.data.mongodb.config.EnableReactiveMongoAuditing;",
            "import org.springframework.data.mongodb.core.MongoTemplate;",
            "import org.springframework.data.mongodb.core.ReactiveMongoTemplate;",
            "import org.springframework.data.mongodb.core.convert.MappingMongoConverter;",
            "import org.springframework.data.mongodb.gridfs.ReactiveGridFsTemplate;",
            "import org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;",
            "import org.springframework.security.core.context.ReactiveSecurityContextHolder;",
            "import com.github.cloudyrock.mongock.driver.mongodb.springdata.v3.SpringDataMongoV3Driver;",
            "import com.github.cloudyrock.spring.v5.MongockSpring5;",
            "import com.mongodb.ReadConcern;",
            "import com.mongodb.ReadPreference;",
            "import com.mongodb.WriteConcern;",
            "import com.openblocks.domain.user.model.User;",
            "import com.openblocks.sdk.config.MaterialProperties;",
            "import com.openblocks.sdk.models.HasIdAndAuditing;",
            "import lombok.extern.slf4j.Slf4j;"
        ],
        "reference_api": [
            "setWriteConcern",
            "withDefaultLock",
            "of",
            "setReadConcern",
            "addChangeLogsScanPackages",
            "withJournal",
            "builder",
            "buildApplicationRunner",
            "setSpringContext",
            "setDriver"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setWriteConcern",
            "withDefaultLock",
            "of",
            "setReadConcern",
            "addChangeLogsScanPackages",
            "withJournal",
            "builder",
            "buildApplicationRunner",
            "setSpringContext",
            "setDriver"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public ReactiveMongoTemplate reactiveMongoSlaveTemplate(ReactiveMongoDatabaseFactory mongoDbFactory,\n            MappingMongoConverter mappingMongoConverter)",
        "start_line": "86",
        "end_line": "91",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/configurations/MongoConfig.java",
        "docstring": "This function creates and configures a ReactiveMongoTemplate instance using the provided MongoDB factory and mapping converter. It sets the read preference to \"secondaryPreferred\" and returns the configured ReactiveMongoTemplate.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "2c8015b63ee8",
        "ground_truth": "public ReactiveMongoTemplate reactiveMongoSlaveTemplate(ReactiveMongoDatabaseFactory mongoDbFactory,\n        MappingMongoConverter mappingMongoConverter) {\n    ReactiveMongoTemplate mongoTemplate = new ReactiveMongoTemplate(mongoDbFactory, mappingMongoConverter);\n    mongoTemplate.setReadPreference(ReadPreference.secondaryPreferred());\n    return mongoTemplate;\n}",
        "import_statements": [
            "import java.util.List;",
            "import javax.annotation.PostConstruct;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.context.ApplicationContext;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.context.annotation.Configuration;",
            "import org.springframework.context.annotation.Primary;",
            "import org.springframework.data.domain.ReactiveAuditorAware;",
            "import org.springframework.data.mongodb.MongoDatabaseFactory;",
            "import org.springframework.data.mongodb.ReactiveMongoDatabaseFactory;",
            "import org.springframework.data.mongodb.config.EnableReactiveMongoAuditing;",
            "import org.springframework.data.mongodb.core.MongoTemplate;",
            "import org.springframework.data.mongodb.core.ReactiveMongoTemplate;",
            "import org.springframework.data.mongodb.core.convert.MappingMongoConverter;",
            "import org.springframework.data.mongodb.gridfs.ReactiveGridFsTemplate;",
            "import org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;",
            "import org.springframework.security.core.context.ReactiveSecurityContextHolder;",
            "import com.github.cloudyrock.mongock.driver.mongodb.springdata.v3.SpringDataMongoV3Driver;",
            "import com.github.cloudyrock.spring.v5.MongockSpring5;",
            "import com.mongodb.ReadConcern;",
            "import com.mongodb.ReadPreference;",
            "import com.mongodb.WriteConcern;",
            "import com.openblocks.domain.user.model.User;",
            "import com.openblocks.sdk.config.MaterialProperties;",
            "import com.openblocks.sdk.models.HasIdAndAuditing;",
            "import lombok.extern.slf4j.Slf4j;"
        ],
        "reference_api": [
            "secondaryPreferred",
            "setReadPreference"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "secondaryPreferred",
            "setReadPreference"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public Mono<Map<String, Object>> getLiveDSLByLibraryQueryId(String libraryQueryId)",
        "start_line": "69",
        "end_line": "74",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/query/service/LibraryQueryService.java",
        "docstring": "This function retrieves the live DSL for a given library query ID. It first attempts to get the latest library query record's DSL. If no record is found, it fetches the DSL directly from the library query by its ID.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7314447a4b23",
        "ground_truth": "public Mono<Map<String, Object>> getLiveDSLByLibraryQueryId(String libraryQueryId) {\n    return libraryQueryRecordService.getLatestRecordByLibraryQueryId(libraryQueryId)\n            .map(LibraryQueryRecord::getLibraryQueryDSL)\n            .switchIfEmpty(getById(libraryQueryId)\n                    .map(LibraryQuery::getLibraryQueryDSL));\n}",
        "import_statements": [
            "import static com.openblocks.sdk.exception.BizError.LIBRARY_QUERY_NOT_FOUND;",
            "import static com.openblocks.sdk.util.ExceptionUtils.deferredError;",
            "import java.util.Map;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import com.openblocks.domain.query.model.BaseQuery;",
            "import com.openblocks.domain.query.model.LibraryQuery;",
            "import com.openblocks.domain.query.model.LibraryQueryRecord;",
            "import com.openblocks.domain.query.repository.LibraryQueryRepository;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "switchIfEmpty",
            "getLatestRecordByLibraryQueryId",
            "map",
            "getById"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getById",
                "code": "public Mono<LibraryQuery> getById(String libraryQueryId) {\n        return libraryQueryRepository.findById(libraryQueryId)\n                .switchIfEmpty(deferredError(LIBRARY_QUERY_NOT_FOUND, \"LIBRARY_QUERY_NOT_FOUND\"));\n    }"
            }
        ],
        "third_party": [
            "switchIfEmpty",
            "getLatestRecordByLibraryQueryId",
            "map"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": " public Mono<QueryExecutionResult> executeQuery(Datasource datasource, Map<String, Object> queryConfig, Map<String, Object> requestParams,\n            String timeoutStr, QueryVisitorContext queryVisitorContext)",
        "start_line": "44",
        "end_line": "65",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/query/service/QueryExecutionService.java",
        "docstring": "This function executes a query on a given datasource with specified configurations and parameters. It determines the timeout duration and defers the query execution based on the datasource type, either using Node.js or executing locally. It handles timeout exceptions by mapping them to a plugin exception and resumes with an error result for other plugin exceptions. For other exceptions, it logs the error and maps it to a generic query execution error.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "101689d9f27a",
        "ground_truth": "public Mono<QueryExecutionResult> executeQuery(Datasource datasource, Map<String, Object> queryConfig, Map<String, Object> requestParams,\n        String timeoutStr, QueryVisitorContext queryVisitorContext) {\n    int timeoutMs = QueryTimeoutUtils.parseQueryTimeoutMs(timeoutStr, requestParams);\n    return Mono.defer(() -> {\n                if (datasourceMetaInfoService.isJsDatasourcePlugin(datasource.getType())) {\n                    return executeByNodeJs(datasource, queryConfig, requestParams);\n                }\n                return executeLocally(datasource, queryConfig, requestParams, queryVisitorContext);\n            })\n            .timeout(Duration.ofMillis(timeoutMs))\n            .onErrorMap(TimeoutException.class, e -> new PluginException(QUERY_EXECUTION_TIMEOUT, \"PLUGIN_EXECUTION_TIMEOUT\", timeoutMs))\n            .onErrorResume(PluginException.class, pluginException -> Mono.just(QueryExecutionResult.error(pluginException)))\n            .onErrorMap(exception -> {\n                if (exception instanceof BizException) {\n                    return exception;\n                }\n                log.error(\"query exception\", exception);\n                return ofException(QUERY_EXECUTION_ERROR, \"QUERY_EXECUTION_ERROR\", exception.getMessage());\n            });\n}",
        "import_statements": [
            "import static com.openblocks.sdk.exception.BizError.QUERY_EXECUTION_ERROR;",
            "import static com.openblocks.sdk.exception.PluginCommonError.QUERY_EXECUTION_TIMEOUT;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofException;",
            "import java.time.Duration;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.concurrent.TimeoutException;",
            "import java.util.stream.Collectors;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import com.openblocks.domain.datasource.model.Datasource;",
            "import com.openblocks.domain.datasource.model.DatasourceConnectionHolder;",
            "import com.openblocks.domain.datasource.service.DatasourceConnectionPool;",
            "import com.openblocks.domain.plugin.client.DatasourcePluginClient;",
            "import com.openblocks.domain.plugin.service.DatasourceMetaInfoService;",
            "import com.openblocks.domain.query.util.QueryTimeoutUtils;",
            "import com.openblocks.sdk.exception.BizException;",
            "import com.openblocks.sdk.exception.PluginException;",
            "import com.openblocks.sdk.models.QueryExecutionResult;",
            "import com.openblocks.sdk.query.QueryExecutionContext;",
            "import com.openblocks.sdk.query.QueryVisitorContext;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "parseQueryTimeoutMs",
            "ofException",
            "executeLocally",
            "just",
            "error",
            "timeout",
            "isJsDatasourcePlugin",
            "getMessage",
            "executeByNodeJs",
            "defer",
            "onErrorMap",
            "ofMillis",
            "onErrorResume",
            "getType"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "executeLocally",
                "code": "private Mono<QueryExecutionResult> executeLocally(Datasource datasource, Map<String, Object> queryConfig, Map<String, Object> requestParams,\n            QueryVisitorContext queryVisitorContext) {\n        var queryExecutor = datasourceMetaInfoService.getQueryExecutor(datasource.getType());\n\n        return queryExecutor.buildQueryExecutionContextMono(datasource.getDetailConfig(), queryConfig, requestParams, queryVisitorContext)\n                .zipWhen(context -> datasourceConnectionPool.getOrCreateConnection(datasource))\n                .flatMap(tuple -> {\n                    QueryExecutionContext queryExecutionRequest = tuple.getT1();\n                    DatasourceConnectionHolder connectionHolder = tuple.getT2();\n                    return queryExecutor.doExecuteQuery(connectionHolder.connection(), queryExecutionRequest)\n                            .doOnError(connectionHolder::onQueryError);\n                });\n    }"
            },
            {
                "name": "executeByNodeJs",
                "code": "private Mono<QueryExecutionResult> executeByNodeJs(Datasource datasource, Map<String, Object> queryConfig, Map<String, Object> requestParams) {\n        List<Map<String, Object>> context = requestParams.entrySet()\n                .stream()\n                .map(entry -> Map.of(\"key\", entry.getKey(), \"value\", entry.getValue()))\n                .collect(Collectors.toList());\n        return datasourcePluginClient.executeQuery(datasource.getType(), queryConfig, context, datasource.getDetailConfig());\n    }"
            }
        ],
        "third_party": [
            "parseQueryTimeoutMs",
            "ofException",
            "just",
            "error",
            "timeout",
            "isJsDatasourcePlugin",
            "getMessage",
            "defer",
            "onErrorMap",
            "ofMillis",
            "onErrorResume",
            "getType"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "private Mono<QueryExecutionResult> executeLocally(Datasource datasource, Map<String, Object> queryConfig, Map<String, Object> requestParams,\n            QueryVisitorContext queryVisitorContext)",
        "start_line": "67",
        "end_line": "79",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/query/service/QueryExecutionService.java",
        "docstring": "This function executes a query locally for a given datasource. It retrieves the appropriate query executor based on the datasource type, builds the query execution context, and acquires a connection from the datasource connection pool. It then executes the query using the connection and handles any errors that occur during execution.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "35960c4bc4c6",
        "ground_truth": "private Mono<QueryExecutionResult> executeLocally(Datasource datasource, Map<String, Object> queryConfig, Map<String, Object> requestParams,\n        QueryVisitorContext queryVisitorContext) {\n    var queryExecutor = datasourceMetaInfoService.getQueryExecutor(datasource.getType());\n    return queryExecutor.buildQueryExecutionContextMono(datasource.getDetailConfig(), queryConfig, requestParams, queryVisitorContext)\n            .zipWhen(context -> datasourceConnectionPool.getOrCreateConnection(datasource))\n            .flatMap(tuple -> {\n                QueryExecutionContext queryExecutionRequest = tuple.getT1();\n                DatasourceConnectionHolder connectionHolder = tuple.getT2();\n                return queryExecutor.doExecuteQuery(connectionHolder.connection(), queryExecutionRequest)\n                        .doOnError(connectionHolder::onQueryError);\n            });\n}",
        "import_statements": [
            "import static com.openblocks.sdk.exception.BizError.QUERY_EXECUTION_ERROR;",
            "import static com.openblocks.sdk.exception.PluginCommonError.QUERY_EXECUTION_TIMEOUT;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofException;",
            "import java.time.Duration;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.concurrent.TimeoutException;",
            "import java.util.stream.Collectors;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import com.openblocks.domain.datasource.model.Datasource;",
            "import com.openblocks.domain.datasource.model.DatasourceConnectionHolder;",
            "import com.openblocks.domain.datasource.service.DatasourceConnectionPool;",
            "import com.openblocks.domain.plugin.client.DatasourcePluginClient;",
            "import com.openblocks.domain.plugin.service.DatasourceMetaInfoService;",
            "import com.openblocks.domain.query.util.QueryTimeoutUtils;",
            "import com.openblocks.sdk.exception.BizException;",
            "import com.openblocks.sdk.exception.PluginException;",
            "import com.openblocks.sdk.models.QueryExecutionResult;",
            "import com.openblocks.sdk.query.QueryExecutionContext;",
            "import com.openblocks.sdk.query.QueryVisitorContext;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "getT2",
            "doOnError",
            "getQueryExecutor",
            "zipWhen",
            "buildQueryExecutionContextMono",
            "getDetailConfig",
            "doExecuteQuery",
            "getOrCreateConnection",
            "getT1",
            "connection",
            "getType",
            "flatMap"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getT2",
            "doOnError",
            "getQueryExecutor",
            "zipWhen",
            "buildQueryExecutionContextMono",
            "getDetailConfig",
            "doExecuteQuery",
            "getOrCreateConnection",
            "getT1",
            "connection",
            "getType",
            "flatMap"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public static int parseQueryTimeoutMs(String timeoutStr)",
        "start_line": "27",
        "end_line": "54",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/query/util/QueryTimeoutUtils.java",
        "docstring": "This function parses a query timeout string and converts it to milliseconds. It checks if the input string is blank and uses a default timeout if necessary. It extracts the numeric value and unit from the string, converts the value to milliseconds, and ensures it does not exceed the maximum allowed timeout. If the value is invalid or exceeds the limit, it throws an exception.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5a915af1d200",
        "ground_truth": "public static int parseQueryTimeoutMs(String timeoutStr) {\n    if (StringUtils.isBlank(timeoutStr)) {\n        return DEFAULT_QUERY_TIMEOUT_MILLIS;\n    }\n    Pair<String, Integer> unitInfo = getUnitInfo(timeoutStr);\n    String unit = unitInfo.getLeft();\n    int unitIndex = unitInfo.getRight();\n    String valueStr;\n    if (unitIndex == -1) {\n        valueStr = timeoutStr;\n    } else {\n        valueStr = timeoutStr.substring(0, unitIndex);\n    }\n    double value = NumberUtils.toDouble(valueStr, -1);\n    if (value < 0) {\n        throw new PluginException(QUERY_ARGUMENT_ERROR, \"INVALID_TIMEOUT_SETTING\", timeoutStr);\n    }\n    int millis = convertToMs(value, unit);\n    if (millis > Duration.ofSeconds(MAX_QUERY_TIMEOUT_SECONDS).toMillis()) {\n        throw new PluginException(EXCEED_MAX_QUERY_TIMEOUT, \"EXCEED_MAX_QUERY_TIMEOUT\", MAX_QUERY_TIMEOUT_SECONDS);\n    }\n    return millis;\n}",
        "import_statements": [
            "import static com.openblocks.sdk.exception.PluginCommonError.EXCEED_MAX_QUERY_TIMEOUT;",
            "import static com.openblocks.sdk.exception.PluginCommonError.QUERY_ARGUMENT_ERROR;",
            "import static com.openblocks.sdk.util.MustacheHelper.renderMustacheString;",
            "import java.time.Duration;",
            "import java.util.Map;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.apache.commons.lang3.math.NumberUtils;",
            "import org.apache.commons.lang3.tuple.Pair;",
            "import com.google.common.annotations.VisibleForTesting;",
            "import com.openblocks.sdk.exception.PluginException;"
        ],
        "reference_api": [
            "getLeft",
            "isBlank",
            "convertToMs",
            "getUnitInfo",
            "substring",
            "ofSeconds",
            "toMillis",
            "getRight",
            "toDouble"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "convertToMs",
                "code": "private static int convertToMs(double value, String unit) {\n        if (unit.equals(\"s\")) {\n            return (int) (value * 1000);\n        } else {\n            return (int) value;\n        }\n    }"
            },
            {
                "name": "getUnitInfo",
                "code": "private static Pair<String, Integer> getUnitInfo(String str) {\n        int unitIndex = StringUtils.indexOfAny(str, 'M', 'm');\n        if (unitIndex == -1) {\n            unitIndex = StringUtils.indexOfAny(str, 'S', 's');\n        }\n        if (unitIndex == -1) {\n            return Pair.of(\"ms\", -1);\n        }\n        return Pair.of(str.substring(unitIndex).toLowerCase(), unitIndex);\n\n    }"
            }
        ],
        "third_party": [
            "getLeft",
            "isBlank",
            "ofSeconds",
            "toMillis",
            "getRight",
            "toDouble"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "private Mono<List<Pair<String, String>>> copyDatasourceFromTemplateToCurrentOrganization(String currentOrganizationId, Application application,\n            String visitorId)",
        "start_line": "95",
        "end_line": "108",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/solutions/TemplateSolution.java",
        "docstring": "This function copies datasources from a template to the current organization. It retrieves the live queries from the given application and extracts the datasource IDs. If no queries are found, it returns an error. It then iterates over the datasource IDs, copies each datasource to the current organization, and returns a list of original and copied datasource ID pairs.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e16ee17a7cb2",
        "ground_truth": "private Mono<List<Pair<String, String>>> copyDatasourceFromTemplateToCurrentOrganization(String currentOrganizationId, Application application,\n        String visitorId) {\n    Set<ApplicationQuery> queries = application.getLiveQueries();\n    if (isNull(queries)) {\n        return ofError(TEMPLATE_NOT_CORRECT, \"TEMPLATE_NOT_CORRECT\");\n    }\n    Set<String> datasourceIds = queries.stream()\n            .map(query -> query.getBaseQuery().getDatasourceId())\n            .collect(Collectors.toSet());\n    return Flux.fromIterable(datasourceIds)\n            .flatMap(datasourceId -> doCopyDatasource(currentOrganizationId, datasourceId, visitorId)\n                    .map(copiedDatasourceId -> Pair.of(datasourceId, copiedDatasourceId)))\n            .collectList();\n}",
        "import_statements": [
            "import static com.openblocks.sdk.exception.BizError.TEMPLATE_NOT_CORRECT;",
            "import static com.openblocks.sdk.exception.BizError.TEMPLATE_NOT_EXIST;",
            "import static com.openblocks.sdk.util.ExceptionUtils.deferredError;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofError;",
            "import static java.util.Objects.isNull;",
            "import java.util.Collection;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Set;",
            "import java.util.stream.Collectors;",
            "import javax.annotation.Nonnull;",
            "import org.apache.commons.lang3.RandomStringUtils;",
            "import org.apache.commons.lang3.tuple.Pair;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.context.annotation.Lazy;",
            "import org.springframework.stereotype.Service;",
            "import com.openblocks.domain.application.model.Application;",
            "import com.openblocks.domain.application.model.ApplicationStatus;",
            "import com.openblocks.domain.application.service.ApplicationService;",
            "import com.openblocks.domain.datasource.model.Datasource;",
            "import com.openblocks.domain.datasource.model.DatasourceCreationSource;",
            "import com.openblocks.domain.datasource.service.DatasourceService;",
            "import com.openblocks.domain.query.model.ApplicationQuery;",
            "import com.openblocks.domain.template.model.Template;",
            "import com.openblocks.domain.template.service.TemplateService;",
            "import com.openblocks.infra.annotation.NonEmptyMono;",
            "import com.openblocks.infra.util.TupleUtils;",
            "import com.openblocks.sdk.util.JsonUtils;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "ofError",
            "of",
            "getBaseQuery",
            "map",
            "toSet",
            "isNull",
            "doCopyDatasource",
            "collect",
            "getDatasourceId",
            "getLiveQueries",
            "collectList",
            "fromIterable",
            "stream",
            "flatMap"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "doCopyDatasource",
                "code": "@SuppressWarnings({\"ConstantConditions\"})\n    private Mono<String> doCopyDatasource(String organizationId, String datasourceId, String visitorId) {\n        return datasourceService.getById(datasourceId)\n                .flatMap(datasource -> {\n                    if (datasource.isSystemStatic()) {\n                        return Mono.just(datasource.getId());\n                    }\n\n                    // return new QUICK_REST_API id for legacy quick rest api\n                    if (datasource.isLegacyQuickRestApi()) {\n                        return Mono.just(Datasource.QUICK_REST_API.getId());\n                    }\n\n                    if (datasource.isLegacyOpenblocksApi()) {\n                        return Mono.just(Datasource.OPENBLOCKS_API.getId());\n                    }\n                    return createNewDatasourceFrom(organizationId, visitorId, datasource);\n                });\n\n    }"
            }
        ],
        "third_party": [
            "ofError",
            "of",
            "getBaseQuery",
            "map",
            "toSet",
            "isNull",
            "collect",
            "getDatasourceId",
            "getLiveQueries",
            "collectList",
            "fromIterable",
            "stream",
            "flatMap"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "private Mono<String> doCopyDatasource(String organizationId, String datasourceId, String visitorId)",
        "start_line": "115",
        "end_line": "133",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/solutions/TemplateSolution.java",
        "docstring": "This function copies a datasource by first retrieving it based on its ID. If the datasource is system static, it returns its ID. For legacy quick REST API or legacy Openblocks API datasources, it returns their respective new IDs. Otherwise, it creates a new datasource based on the given organization ID and visitor ID.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "d04a5a2cee44",
        "ground_truth": "private Mono<String> doCopyDatasource(String organizationId, String datasourceId, String visitorId) {\n    return datasourceService.getById(datasourceId)\n            .flatMap(datasource -> {\n                if (datasource.isSystemStatic()) {\n                    return Mono.just(datasource.getId());\n                }\n                // return new QUICK_REST_API id for legacy quick rest api\n                if (datasource.isLegacyQuickRestApi()) {\n                    return Mono.just(Datasource.QUICK_REST_API.getId());\n                }\n                if (datasource.isLegacyOpenblocksApi()) {\n                    return Mono.just(Datasource.OPENBLOCKS_API.getId());\n                }\n                return createNewDatasourceFrom(organizationId, visitorId, datasource);\n            });\n}",
        "import_statements": [
            "import static com.openblocks.sdk.exception.BizError.TEMPLATE_NOT_CORRECT;",
            "import static com.openblocks.sdk.exception.BizError.TEMPLATE_NOT_EXIST;",
            "import static com.openblocks.sdk.util.ExceptionUtils.deferredError;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofError;",
            "import static java.util.Objects.isNull;",
            "import java.util.Collection;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Set;",
            "import java.util.stream.Collectors;",
            "import javax.annotation.Nonnull;",
            "import org.apache.commons.lang3.RandomStringUtils;",
            "import org.apache.commons.lang3.tuple.Pair;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.context.annotation.Lazy;",
            "import org.springframework.stereotype.Service;",
            "import com.openblocks.domain.application.model.Application;",
            "import com.openblocks.domain.application.model.ApplicationStatus;",
            "import com.openblocks.domain.application.service.ApplicationService;",
            "import com.openblocks.domain.datasource.model.Datasource;",
            "import com.openblocks.domain.datasource.model.DatasourceCreationSource;",
            "import com.openblocks.domain.datasource.service.DatasourceService;",
            "import com.openblocks.domain.query.model.ApplicationQuery;",
            "import com.openblocks.domain.template.model.Template;",
            "import com.openblocks.domain.template.service.TemplateService;",
            "import com.openblocks.infra.annotation.NonEmptyMono;",
            "import com.openblocks.infra.util.TupleUtils;",
            "import com.openblocks.sdk.util.JsonUtils;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "isSystemStatic",
            "getById",
            "just",
            "createNewDatasourceFrom",
            "isLegacyQuickRestApi",
            "getId",
            "isLegacyOpenblocksApi",
            "flatMap"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "createNewDatasourceFrom",
                "code": "@SuppressWarnings(\"ReactiveStreamsNullableInLambdaInTransform\")\n    @Nonnull\n    private Mono<String> createNewDatasourceFrom(String organizationId, String visitorId, Datasource datasource) {\n        Datasource copyDatasource = new Datasource();\n        copyDatasource.setName(generateCopyDatasourceName(datasource.getName()));\n        copyDatasource.setType(datasource.getType());\n        copyDatasource.setDetailConfig(datasource.getDetailConfig());\n        copyDatasource.setCreationSource(DatasourceCreationSource.CLONE_FROM_TEMPLATE.getValue());\n        copyDatasource.setOrganizationId(organizationId);\n        return datasourceService.create(copyDatasource, visitorId)\n\n                .map(Datasource::getId);\n    }"
            }
        ],
        "third_party": [
            "isSystemStatic",
            "getById",
            "just",
            "isLegacyQuickRestApi",
            "getId",
            "isLegacyOpenblocksApi",
            "flatMap"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": " public Mono<Boolean> saveProfilePhoto(Part filePart, User user)",
        "start_line": "128",
        "end_line": "140",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/user/service/UserServiceImpl.java",
        "docstring": "This function saves a user's profile photo. It uploads the new photo, and if the user has a previous avatar, it removes the old one. It then updates the user's profile with the new avatar. The function returns a Mono<Boolean> indicating the success of the operation.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "725030ef43ac",
        "ground_truth": "public Mono<Boolean> saveProfilePhoto(Part filePart, User user) {\n    String prevAvatar = ObjectUtils.defaultIfNull(user.getAvatar(), \"\");\n    Mono<Asset> newAvatarMono = assetService.upload(filePart, avatarMaxSizeInKb.get(), true);\n    return newAvatarMono\n            .flatMap(newAvatar -> {\n                Mono<Boolean> updateUserAvatarMono = updateUserAvatar(newAvatar, user.getId());\n                if (StringUtils.isEmpty(prevAvatar)) {\n                    return updateUserAvatarMono;\n                }\n                return assetService.remove(prevAvatar).then(updateUserAvatarMono);\n            });\n}",
        "import_statements": [
            "import static com.google.common.collect.Sets.newHashSet;",
            "import static com.openblocks.domain.user.model.UserDetail.ANONYMOUS_CURRENT_USER;",
            "import static com.openblocks.sdk.constants.GlobalContext.CLIENT_IP;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofError;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofException;",
            "import java.security.SecureRandom;",
            "import java.util.Collection;",
            "import java.util.List;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.Objects;",
            "import java.util.Optional;",
            "import java.util.Set;",
            "import java.util.function.Function;",
            "import java.util.stream.Collectors;",
            "import javax.annotation.Nonnull;",
            "import javax.annotation.PostConstruct;",
            "import org.apache.commons.lang3.ObjectUtils;",
            "import org.apache.commons.lang3.RandomStringUtils;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.dao.DuplicateKeyException;",
            "import org.springframework.http.codec.multipart.Part;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.web.server.ServerWebExchange;",
            "import com.openblocks.domain.asset.model.Asset;",
            "import com.openblocks.domain.asset.service.AssetService;",
            "import com.openblocks.domain.authentication.AuthenticationService;",
            "import com.openblocks.domain.authentication.context.FormAuthRequestContext;",
            "import com.openblocks.domain.encryption.EncryptionService;",
            "import com.openblocks.domain.group.model.Group;",
            "import com.openblocks.domain.group.service.GroupMemberService;",
            "import com.openblocks.domain.group.service.GroupService;",
            "import com.openblocks.domain.organization.model.OrgMember;",
            "import com.openblocks.domain.organization.service.OrgMemberService;",
            "import com.openblocks.domain.user.model.AuthUser;",
            "import com.openblocks.domain.user.model.Connection;",
            "import com.openblocks.domain.user.model.User;",
            "import com.openblocks.domain.user.model.User.TransformedUserInfo;",
            "import com.openblocks.domain.user.model.UserDetail;",
            "import com.openblocks.domain.user.model.UserState;",
            "import com.openblocks.domain.user.repository.UserRepository;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper.PartialResourceWithId;",
            "import com.openblocks.sdk.config.CommonConfig;",
            "import com.openblocks.sdk.config.dynamic.Conf;",
            "import com.openblocks.sdk.config.dynamic.ConfigCenter;",
            "import com.openblocks.sdk.constants.AuthSourceConstants;",
            "import com.openblocks.sdk.constants.FieldName;",
            "import com.openblocks.sdk.constants.WorkspaceMode;",
            "import com.openblocks.sdk.exception.BizError;",
            "import com.openblocks.sdk.exception.BizException;",
            "import com.openblocks.sdk.util.LocaleUtils;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "upload",
            "defaultIfNull",
            "getAvatar",
            "remove",
            "get",
            "then",
            "getId",
            "updateUserAvatar",
            "isEmpty",
            "flatMap"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "updateUserAvatar",
                "code": "private Mono<Boolean> updateUserAvatar(Asset newAvatar, String userId) {\n        User user = new User();\n        user.setAvatar(newAvatar.getId());\n        return mongoUpsertHelper.updateById(user, userId);\n    }"
            }
        ],
        "third_party": [
            "upload",
            "defaultIfNull",
            "getAvatar",
            "remove",
            "get",
            "then",
            "getId",
            "isEmpty",
            "flatMap"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public Mono<User> createNewUserByAuthUser(AuthUser authUser)",
        "start_line": "164",
        "end_line": "180",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/user/service/UserServiceImpl.java",
        "docstring": "This function creates a new user from an AuthUser object. It sets the user's name, state, enabled status, and avatar link based on the AuthUser. If the auth source is email and the auth context contains a password, it encrypts the password and sets it for the user. It also establishes user connections from the AuthUser and marks the user as new. Finally, it creates and returns the new user.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ba18ff764ca0",
        "ground_truth": "public Mono<User> createNewUserByAuthUser(AuthUser authUser) {\n    User newUser = new User();\n    newUser.setName(authUser.getUsername());\n    newUser.setState(UserState.ACTIVATED);\n    newUser.setIsEnabled(true);\n    newUser.setTpAvatarLink(authUser.getAvatar());\n    if (AuthSourceConstants.EMAIL.equals(authUser.getSource())\n            && authUser.getAuthContext() instanceof FormAuthRequestContext formAuthRequestContext) {\n        newUser.setPassword(encryptionService.encryptPassword(formAuthRequestContext.getPassword()));\n    }\n    Set<Connection> connections = newHashSet();\n    Connection connection = authUser.toAuthConnection();\n    connections.add(connection);\n    newUser.setConnections(connections);\n    newUser.setIsNewUser(true);\n    return create(newUser);\n}",
        "import_statements": [
            "import static com.google.common.collect.Sets.newHashSet;",
            "import static com.openblocks.domain.user.model.UserDetail.ANONYMOUS_CURRENT_USER;",
            "import static com.openblocks.sdk.constants.GlobalContext.CLIENT_IP;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofError;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofException;",
            "import java.security.SecureRandom;",
            "import java.util.Collection;",
            "import java.util.List;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.Objects;",
            "import java.util.Optional;",
            "import java.util.Set;",
            "import java.util.function.Function;",
            "import java.util.stream.Collectors;",
            "import javax.annotation.Nonnull;",
            "import javax.annotation.PostConstruct;",
            "import org.apache.commons.lang3.ObjectUtils;",
            "import org.apache.commons.lang3.RandomStringUtils;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.dao.DuplicateKeyException;",
            "import org.springframework.http.codec.multipart.Part;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.web.server.ServerWebExchange;",
            "import com.openblocks.domain.asset.model.Asset;",
            "import com.openblocks.domain.asset.service.AssetService;",
            "import com.openblocks.domain.authentication.AuthenticationService;",
            "import com.openblocks.domain.authentication.context.FormAuthRequestContext;",
            "import com.openblocks.domain.encryption.EncryptionService;",
            "import com.openblocks.domain.group.model.Group;",
            "import com.openblocks.domain.group.service.GroupMemberService;",
            "import com.openblocks.domain.group.service.GroupService;",
            "import com.openblocks.domain.organization.model.OrgMember;",
            "import com.openblocks.domain.organization.service.OrgMemberService;",
            "import com.openblocks.domain.user.model.AuthUser;",
            "import com.openblocks.domain.user.model.Connection;",
            "import com.openblocks.domain.user.model.User;",
            "import com.openblocks.domain.user.model.User.TransformedUserInfo;",
            "import com.openblocks.domain.user.model.UserDetail;",
            "import com.openblocks.domain.user.model.UserState;",
            "import com.openblocks.domain.user.repository.UserRepository;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper.PartialResourceWithId;",
            "import com.openblocks.sdk.config.CommonConfig;",
            "import com.openblocks.sdk.config.dynamic.Conf;",
            "import com.openblocks.sdk.config.dynamic.ConfigCenter;",
            "import com.openblocks.sdk.constants.AuthSourceConstants;",
            "import com.openblocks.sdk.constants.FieldName;",
            "import com.openblocks.sdk.constants.WorkspaceMode;",
            "import com.openblocks.sdk.exception.BizError;",
            "import com.openblocks.sdk.exception.BizException;",
            "import com.openblocks.sdk.util.LocaleUtils;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "equals",
            "getUsername",
            "setName",
            "encryptPassword",
            "getAuthContext",
            "setConnections",
            "setIsNewUser",
            "getAvatar",
            "toAuthConnection",
            "setIsEnabled",
            "create",
            "setTpAvatarLink",
            "setState",
            "add",
            "getPassword",
            "getSource",
            "setPassword",
            "newHashSet"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "create",
                "code": "@Override\n    public Mono<User> create(User user) {\n        return repository.save(user);\n    }"
            },
            {
                "name": "setPassword",
                "code": "@Override\n    public Mono<Boolean> setPassword(String userId, String password) {\n        return findById(userId)\n                .map(user -> {\n                    user.setPassword(encryptionService.encryptPassword(password));\n                    return user;\n                })\n                .flatMap(repository::save)\n                .thenReturn(true);\n    }"
            }
        ],
        "third_party": [
            "getUsername",
            "setName",
            "encryptPassword",
            "getAuthContext",
            "setConnections",
            "setIsNewUser",
            "getAvatar",
            "toAuthConnection",
            "setIsEnabled",
            "setTpAvatarLink",
            "setState",
            "add",
            "getPassword",
            "getSource",
            "newHashSet"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public Mono<Boolean> bindEmail(User user, String email)",
        "start_line": "189",
        "end_line": "204",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/user/service/UserServiceImpl.java",
        "docstring": "This function binds an email to a user by creating a new connection with the email source and adding it to the user's connections. It then saves the user and returns true if successful. If a DuplicateKeyException occurs, it returns a specific error; otherwise, it propagates the error.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "cf0845c883a7",
        "ground_truth": "public Mono<Boolean> bindEmail(User user, String email) {\n    Connection connection = Connection.builder()\n            .source(AuthSourceConstants.EMAIL)\n            .name(email)\n            .rawId(email)\n            .build();\n    user.getConnections().add(connection);\n    return repository.save(user)\n            .then(Mono.just(true))\n            .onErrorResume(throwable -> {\n                if (throwable instanceof DuplicateKeyException) {\n                    return Mono.error(new BizException(BizError.ALREADY_BIND, \"ALREADY_BIND\", email, \"\"));\n                }\n                return Mono.error(throwable);\n            });\n}",
        "import_statements": [
            "import static com.google.common.collect.Sets.newHashSet;",
            "import static com.openblocks.domain.user.model.UserDetail.ANONYMOUS_CURRENT_USER;",
            "import static com.openblocks.sdk.constants.GlobalContext.CLIENT_IP;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofError;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofException;",
            "import java.security.SecureRandom;",
            "import java.util.Collection;",
            "import java.util.List;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.Objects;",
            "import java.util.Optional;",
            "import java.util.Set;",
            "import java.util.function.Function;",
            "import java.util.stream.Collectors;",
            "import javax.annotation.Nonnull;",
            "import javax.annotation.PostConstruct;",
            "import org.apache.commons.lang3.ObjectUtils;",
            "import org.apache.commons.lang3.RandomStringUtils;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.dao.DuplicateKeyException;",
            "import org.springframework.http.codec.multipart.Part;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.web.server.ServerWebExchange;",
            "import com.openblocks.domain.asset.model.Asset;",
            "import com.openblocks.domain.asset.service.AssetService;",
            "import com.openblocks.domain.authentication.AuthenticationService;",
            "import com.openblocks.domain.authentication.context.FormAuthRequestContext;",
            "import com.openblocks.domain.encryption.EncryptionService;",
            "import com.openblocks.domain.group.model.Group;",
            "import com.openblocks.domain.group.service.GroupMemberService;",
            "import com.openblocks.domain.group.service.GroupService;",
            "import com.openblocks.domain.organization.model.OrgMember;",
            "import com.openblocks.domain.organization.service.OrgMemberService;",
            "import com.openblocks.domain.user.model.AuthUser;",
            "import com.openblocks.domain.user.model.Connection;",
            "import com.openblocks.domain.user.model.User;",
            "import com.openblocks.domain.user.model.User.TransformedUserInfo;",
            "import com.openblocks.domain.user.model.UserDetail;",
            "import com.openblocks.domain.user.model.UserState;",
            "import com.openblocks.domain.user.repository.UserRepository;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper.PartialResourceWithId;",
            "import com.openblocks.sdk.config.CommonConfig;",
            "import com.openblocks.sdk.config.dynamic.Conf;",
            "import com.openblocks.sdk.config.dynamic.ConfigCenter;",
            "import com.openblocks.sdk.constants.AuthSourceConstants;",
            "import com.openblocks.sdk.constants.FieldName;",
            "import com.openblocks.sdk.constants.WorkspaceMode;",
            "import com.openblocks.sdk.exception.BizError;",
            "import com.openblocks.sdk.exception.BizException;",
            "import com.openblocks.sdk.util.LocaleUtils;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "getConnections",
            "save",
            "name",
            "just",
            "source",
            "error",
            "then",
            "onErrorResume",
            "add",
            "rawId",
            "build",
            "builder"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getConnections",
            "save",
            "name",
            "just",
            "source",
            "error",
            "then",
            "onErrorResume",
            "add",
            "rawId",
            "build",
            "builder"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public Mono<Boolean> updatePassword(String userId, String oldPassword, String newPassword)",
        "start_line": "223",
        "end_line": "241",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/user/service/UserServiceImpl.java",
        "docstring": "This function updates a user's password by first finding the user by their ID. It checks if the current password is valid and matches the provided old password. If the validation passes, it encrypts the new password and updates the user record. It returns true if the operation is successful, otherwise, it returns an error for invalid password.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "6371b85223d3",
        "ground_truth": "public Mono<Boolean> updatePassword(String userId, String oldPassword, String newPassword) {\n    return findById(userId)\n            .<User> handle((user, sink) -> {\n                String password = user.getPassword();\n                if (StringUtils.isBlank(password)) {\n                    sink.error(ofException(BizError.INVALID_PASSWORD, \"INVALID_PASSWORD\"));\n                    return;\n                }\n                String originalEncryptPassword = user.getPassword();\n                if (!encryptionService.matchPassword(oldPassword, originalEncryptPassword)) {\n                    sink.error(ofException(BizError.INVALID_PASSWORD, \"INVALID_PASSWORD\"));\n                    return;\n                }\n                user.setPassword(encryptionService.encryptPassword(newPassword));\n                sink.next(user);\n            })\n            .flatMap(repository::save)\n            .thenReturn(true);\n}",
        "import_statements": [
            "import static com.google.common.collect.Sets.newHashSet;",
            "import static com.openblocks.domain.user.model.UserDetail.ANONYMOUS_CURRENT_USER;",
            "import static com.openblocks.sdk.constants.GlobalContext.CLIENT_IP;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofError;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofException;",
            "import java.security.SecureRandom;",
            "import java.util.Collection;",
            "import java.util.List;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.Objects;",
            "import java.util.Optional;",
            "import java.util.Set;",
            "import java.util.function.Function;",
            "import java.util.stream.Collectors;",
            "import javax.annotation.Nonnull;",
            "import javax.annotation.PostConstruct;",
            "import org.apache.commons.lang3.ObjectUtils;",
            "import org.apache.commons.lang3.RandomStringUtils;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.dao.DuplicateKeyException;",
            "import org.springframework.http.codec.multipart.Part;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.web.server.ServerWebExchange;",
            "import com.openblocks.domain.asset.model.Asset;",
            "import com.openblocks.domain.asset.service.AssetService;",
            "import com.openblocks.domain.authentication.AuthenticationService;",
            "import com.openblocks.domain.authentication.context.FormAuthRequestContext;",
            "import com.openblocks.domain.encryption.EncryptionService;",
            "import com.openblocks.domain.group.model.Group;",
            "import com.openblocks.domain.group.service.GroupMemberService;",
            "import com.openblocks.domain.group.service.GroupService;",
            "import com.openblocks.domain.organization.model.OrgMember;",
            "import com.openblocks.domain.organization.service.OrgMemberService;",
            "import com.openblocks.domain.user.model.AuthUser;",
            "import com.openblocks.domain.user.model.Connection;",
            "import com.openblocks.domain.user.model.User;",
            "import com.openblocks.domain.user.model.User.TransformedUserInfo;",
            "import com.openblocks.domain.user.model.UserDetail;",
            "import com.openblocks.domain.user.model.UserState;",
            "import com.openblocks.domain.user.repository.UserRepository;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper.PartialResourceWithId;",
            "import com.openblocks.sdk.config.CommonConfig;",
            "import com.openblocks.sdk.config.dynamic.Conf;",
            "import com.openblocks.sdk.config.dynamic.ConfigCenter;",
            "import com.openblocks.sdk.constants.AuthSourceConstants;",
            "import com.openblocks.sdk.constants.FieldName;",
            "import com.openblocks.sdk.constants.WorkspaceMode;",
            "import com.openblocks.sdk.exception.BizError;",
            "import com.openblocks.sdk.exception.BizException;",
            "import com.openblocks.sdk.util.LocaleUtils;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "ofException",
            "error",
            "next",
            "encryptPassword",
            "isBlank",
            "thenReturn",
            "matchPassword",
            "findById",
            "getPassword",
            "setPassword",
            "handle",
            "flatMap"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "findById",
                "code": "@Override\n    public Mono<User> findById(String id) {\n        if (id == null) {\n            return Mono.error(new BizException(BizError.INVALID_PARAMETER, \"INVALID_PARAMETER\", FieldName.ID));\n        }\n\n        return repository.findById(id);\n    }"
            },
            {
                "name": "setPassword",
                "code": "@Override\n    public Mono<Boolean> setPassword(String userId, String password) {\n        return findById(userId)\n                .map(user -> {\n                    user.setPassword(encryptionService.encryptPassword(password));\n                    return user;\n                })\n                .flatMap(repository::save)\n                .thenReturn(true);\n    }"
            }
        ],
        "third_party": [
            "ofException",
            "error",
            "next",
            "encryptPassword",
            "isBlank",
            "thenReturn",
            "matchPassword",
            "getPassword",
            "handle",
            "flatMap"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "protected Mono<List<Map<String, String>>> buildUserDetailGroups(String userId, OrgMember orgMember, boolean withoutDynamicGroups,\n            Locale locale)",
        "start_line": "328",
        "end_line": "344",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/user/service/UserServiceImpl.java",
        "docstring": "This function builds a list of user detail groups for a given user and organization member. Depending on whether the member is an admin or if dynamic groups should be excluded, it retrieves the appropriate groups. It filters out the \"all users\" group and maps the remaining groups to a list of maps containing group IDs and localized group names.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e343ae527afa",
        "ground_truth": "protected Mono<List<Map<String, String>>> buildUserDetailGroups(String userId, OrgMember orgMember, boolean withoutDynamicGroups,\n        Locale locale) {\n    String orgId = orgMember.getOrgId();\n    Flux<Group> groups;\n    if (orgMember.isAdmin()) {\n        groups = groupService.getByOrgId(orgId).sort();\n    } else {\n        if (withoutDynamicGroups) {\n            groups = groupMemberService.getNonDynamicUserGroupIdsInOrg(orgId, userId).flatMapMany(l -> groupService.getByIds(l));\n        } else {\n            groups = groupMemberService.getUserGroupIdsInOrg(orgId, userId).flatMapMany(l -> groupService.getByIds(l));\n        }\n    }\n    return groups.filter(group -> !group.isAllUsersGroup())\n            .map(group -> Map.of(\"groupId\", Objects.toString(group.getId(), \"\"), \"groupName\", group.getName(locale)))\n            .collectList();\n}",
        "import_statements": [
            "import static com.google.common.collect.Sets.newHashSet;",
            "import static com.openblocks.domain.user.model.UserDetail.ANONYMOUS_CURRENT_USER;",
            "import static com.openblocks.sdk.constants.GlobalContext.CLIENT_IP;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofError;",
            "import static com.openblocks.sdk.util.ExceptionUtils.ofException;",
            "import java.security.SecureRandom;",
            "import java.util.Collection;",
            "import java.util.List;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.Objects;",
            "import java.util.Optional;",
            "import java.util.Set;",
            "import java.util.function.Function;",
            "import java.util.stream.Collectors;",
            "import javax.annotation.Nonnull;",
            "import javax.annotation.PostConstruct;",
            "import org.apache.commons.lang3.ObjectUtils;",
            "import org.apache.commons.lang3.RandomStringUtils;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.dao.DuplicateKeyException;",
            "import org.springframework.http.codec.multipart.Part;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.web.server.ServerWebExchange;",
            "import com.openblocks.domain.asset.model.Asset;",
            "import com.openblocks.domain.asset.service.AssetService;",
            "import com.openblocks.domain.authentication.AuthenticationService;",
            "import com.openblocks.domain.authentication.context.FormAuthRequestContext;",
            "import com.openblocks.domain.encryption.EncryptionService;",
            "import com.openblocks.domain.group.model.Group;",
            "import com.openblocks.domain.group.service.GroupMemberService;",
            "import com.openblocks.domain.group.service.GroupService;",
            "import com.openblocks.domain.organization.model.OrgMember;",
            "import com.openblocks.domain.organization.service.OrgMemberService;",
            "import com.openblocks.domain.user.model.AuthUser;",
            "import com.openblocks.domain.user.model.Connection;",
            "import com.openblocks.domain.user.model.User;",
            "import com.openblocks.domain.user.model.User.TransformedUserInfo;",
            "import com.openblocks.domain.user.model.UserDetail;",
            "import com.openblocks.domain.user.model.UserState;",
            "import com.openblocks.domain.user.repository.UserRepository;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper.PartialResourceWithId;",
            "import com.openblocks.sdk.config.CommonConfig;",
            "import com.openblocks.sdk.config.dynamic.Conf;",
            "import com.openblocks.sdk.config.dynamic.ConfigCenter;",
            "import com.openblocks.sdk.constants.AuthSourceConstants;",
            "import com.openblocks.sdk.constants.FieldName;",
            "import com.openblocks.sdk.constants.WorkspaceMode;",
            "import com.openblocks.sdk.exception.BizError;",
            "import com.openblocks.sdk.exception.BizException;",
            "import com.openblocks.sdk.util.LocaleUtils;",
            "import lombok.extern.slf4j.Slf4j;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "filter",
            "flatMapMany",
            "getOrgId",
            "getName",
            "getNonDynamicUserGroupIdsInOrg",
            "getUserGroupIdsInOrg",
            "of",
            "getByIds",
            "isAllUsersGroup",
            "map",
            "getByOrgId",
            "toString",
            "getId",
            "collectList",
            "isAdmin",
            "sort"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getByIds",
                "code": "@Override\n    public Mono<Map<String, User>> getByIds(Collection<String> ids) {\n        Set<String> idSet = newHashSet(ids);\n        return repository.findByIdIn(idSet)\n                .collectList()\n                .map(it -> it.stream()\n                        .collect(Collectors.toMap(User::getId, Function.identity()))\n                );\n    }"
            }
        ],
        "third_party": [
            "filter",
            "flatMapMany",
            "getOrgId",
            "getName",
            "getNonDynamicUserGroupIdsInOrg",
            "getUserGroupIdsInOrg",
            "of",
            "isAllUsersGroup",
            "map",
            "getByOrgId",
            "getId",
            "collectList",
            "isAdmin",
            "sort"
        ]
    },
    {
        "subclass": "CRM",
        "owner/repo": "openblocks-dev/openblocks",
        "function_declaration": "public Mono<Boolean> markNewUserGuidanceShown(String userId)",
        "start_line": "33",
        "end_line": "39",
        "file_path": "server/api-service/openblocks-domain/src/main/java/com/openblocks/domain/user/service/UserStatusService.java",
        "docstring": "This function marks the new user guidance as shown for a given user ID. It creates a UserStatus object with the user ID and sets the `hasShowNewUserGuidance` field to true. Then, it performs an upsert operation using `mongoUpsertHelper` to update or insert the user status in the database.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "81d5de06ce76",
        "ground_truth": "public Mono<Boolean> markNewUserGuidanceShown(String userId) {\n    UserStatus userStatus = UserStatus.builder()\n            .id(userId)\n            .hasShowNewUserGuidance(true)\n            .build();\n    return mongoUpsertHelper.upsert(userStatus, \"id\", userId);\n}",
        "import_statements": [
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.context.annotation.Lazy;",
            "import org.springframework.data.mongodb.core.query.Update;",
            "import org.springframework.stereotype.Service;",
            "import com.openblocks.domain.user.constant.UserStatusType;",
            "import com.openblocks.domain.user.model.UserStatus;",
            "import com.openblocks.domain.user.repository.UserStatusRepository;",
            "import com.openblocks.infra.mongo.MongoUpsertHelper;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "hasShowNewUserGuidance",
            "id",
            "build",
            "builder",
            "upsert"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "hasShowNewUserGuidance",
            "id",
            "build",
            "builder",
            "upsert"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "gohugoio/hugo",
        "function_declaration": "func (c *Cache) ClearMatching(predicatePartition func(k string, p PartitionManager) bool, predicateValue func(k, v any) bool) ",
        "start_line": "153",
        "end_line": "176",
        "file_path": "cache/dynacache/dynacache.go",
        "docstring": "This function clears cache entries that match given predicates. It first ensures the partition predicate is not nil and panics if the value predicate is nil. It then creates a run group to handle clearing matching entries across multiple partitions concurrently. Each partition that satisfies the partition predicate is enqueued for processing, where entries are cleared based on the value predicate. The function waits for all tasks to complete before returning.",
        "language": "Go",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "6a960c887da0",
        "ground_truth": "func (c *Cache) ClearMatching(predicatePartition func(k string, p PartitionManager) bool, predicateValue func(k, v any) bool) {\n if predicatePartition == nil {\n  predicatePartition = func(k string, p PartitionManager) bool { return true }\n }\n if predicateValue == nil {\n  panic(\"nil predicateValue\")\n }\n g := rungroup.Run[PartitionManager](context.Background(), rungroup.Config[PartitionManager]{\n  NumWorkers: len(c.partitions),\n  Handle: func(ctx context.Context, partition PartitionManager) error {\n   partition.clearMatching(predicateValue)\n   return nil\n  },\n })\n  for k, p := range c.partitions {\n  if !predicatePartition(k, p) {\n   continue\n  }\n  g.Enqueue(p)\n }\n  g.Wait()\n}",
        "import_statements": [
            "import (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\t\"path\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/bep/lazycache\"\n\t\"github.com/bep/logg\"\n\t\"github.com/gohugoio/hugo/common/collections\"\n\t\"github.com/gohugoio/hugo/common/herrors\"\n\t\"github.com/gohugoio/hugo/common/loggers\"\n\t\"github.com/gohugoio/hugo/common/paths\"\n\t\"github.com/gohugoio/hugo/common/rungroup\"\n\t\"github.com/gohugoio/hugo/config\"\n\t\"github.com/gohugoio/hugo/helpers\"\n\t\"github.com/gohugoio/hugo/identity\"\n\t\"github.com/gohugoio/hugo/resources/resource\"\n)"
        ],
        "reference_api": [
            "g.Enqueue",
            "predicatePartition",
            "len",
            "rungroup.Run",
            "context.Background",
            "partition.clearMatching",
            "g.Wait",
            "panic"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "g.Enqueue",
            "predicatePartition",
            "len",
            "rungroup.Run",
            "context.Background",
            "partition.clearMatching",
            "g.Wait",
            "panic"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "gohugoio/hugo",
        "function_declaration": "func calculateMaxSizePerPartition(maxItemsTotal, totalWeightQuantity, numPartitions int) int",
        "start_line": "233",
        "end_line": "243",
        "file_path": "cache/dynacache/dynacache.go",
        "docstring": "This function calculates the maximum size per partition given the total number of items, total weight quantity, and number of partitions. It first checks that the number of partitions and total weight quantity are greater than zero. Then, it calculates the average weight per partition and returns the maximum size per partition based on the provided formula.",
        "language": "Go",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "3043f15d1c38",
        "ground_truth": "func calculateMaxSizePerPartition(maxItemsTotal, totalWeightQuantity, numPartitions int) int {\n if numPartitions == 0 {\n  panic(\"numPartitions must be > 0\")\n }\n if totalWeightQuantity == 0 {\n  panic(\"totalWeightQuantity must be > 0\")\n }\n  avgWeight := float64(totalWeightQuantity) / float64(numPartitions)\n return int(math.Floor(float64(maxItemsTotal) / float64(numPartitions) * (100.0 / avgWeight)))\n}",
        "import_statements": [
            "import (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\t\"path\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/bep/lazycache\"\n\t\"github.com/bep/logg\"\n\t\"github.com/gohugoio/hugo/common/collections\"\n\t\"github.com/gohugoio/hugo/common/herrors\"\n\t\"github.com/gohugoio/hugo/common/loggers\"\n\t\"github.com/gohugoio/hugo/common/paths\"\n\t\"github.com/gohugoio/hugo/common/rungroup\"\n\t\"github.com/gohugoio/hugo/config\"\n\t\"github.com/gohugoio/hugo/helpers\"\n\t\"github.com/gohugoio/hugo/identity\"\n\t\"github.com/gohugoio/hugo/resources/resource\"\n)"
        ],
        "reference_api": [
            "float64",
            "math.Floor",
            "int",
            "panic"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "float64",
            "int",
            "panic"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "public Map<String, Object> contributorMap()",
        "start_line": "29",
        "end_line": "38",
        "file_path": "application/src/main/java/run/halo/app/actuator/DatabaseInfoContributor.java",
        "docstring": "This function creates and returns a map with database connection metadata. It retrieves connection metadata, and if it is not null, it adds the database product name and version to the map. If the metadata is null, it returns an empty map.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "564698899cd7",
        "ground_truth": "public Map<String, Object> contributorMap() {\n    var map = new HashMap<String, Object>();\n    var connectionMetadata = getConnectionMetadata().block();\n    if (Objects.isNull(connectionMetadata)) {\n        return map;\n    }\n    map.put(\"name\", connectionMetadata.getDatabaseProductName());\n    map.put(\"version\", connectionMetadata.getDatabaseVersion());\n    return map;\n}",
        "import_statements": [
            "import io.r2dbc.spi.Connection;",
            "import io.r2dbc.spi.ConnectionFactory;",
            "import io.r2dbc.spi.ConnectionMetadata;",
            "import java.util.HashMap;",
            "import java.util.Map;",
            "import java.util.Objects;",
            "import org.springframework.boot.actuate.info.Info;",
            "import org.springframework.boot.actuate.info.InfoContributor;",
            "import org.springframework.stereotype.Component;",
            "import reactor.core.publisher.Mono;"
        ],
        "reference_api": [
            "getConnectionMetadata",
            "getDatabaseVersion",
            "isNull",
            "put",
            "block",
            "getDatabaseProductName"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getConnectionMetadata",
                "code": "private Mono<ConnectionMetadata> getConnectionMetadata() {\n        return Mono.usingWhen(this.connectionFactory.create(),\n            conn -> Mono.just(conn.getMetadata()),\n            Connection::close,\n            (conn, t) -> conn.close(),\n            Connection::close\n        );\n    }"
            }
        ],
        "third_party": [
            "getDatabaseVersion",
            "isNull",
            "put",
            "block",
            "getDatabaseProductName"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "private void handleUserSetting(GlobalInfo info, ConfigMap configMap)",
        "start_line": "121",
        "end_line": "131",
        "file_path": "application/src/main/java/run/halo/app/actuator/GlobalInfoEndpoint.java",
        "docstring": "This function handles user settings based on the provided configuration map. It retrieves the user settings from the configuration map. If the user settings are null, it disables registration and email verification on registration in the GlobalInfo object. Otherwise, it updates the GlobalInfo object with the retrieved settings for registration and email verification.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "38d2e041f2fb",
        "ground_truth": "private void handleUserSetting(GlobalInfo info, ConfigMap configMap) {\n    var userSetting = SystemSetting.get(configMap, User.GROUP, User.class);\n    if (userSetting == null) {\n        info.setAllowRegistration(false);\n        info.setMustVerifyEmailOnRegistration(false);\n    } else {\n        info.setAllowRegistration(\n            userSetting.getAllowRegistration() != null && userSetting.getAllowRegistration());\n        info.setMustVerifyEmailOnRegistration(userSetting.getMustVerifyEmailOnRegistration());\n    }\n}",
        "import_statements": [
            "import static org.apache.commons.lang3.BooleanUtils.isTrue;",
            "import java.net.URL;",
            "import java.util.List;",
            "import java.util.Locale;",
            "import java.util.TimeZone;",
            "import lombok.Data;",
            "import lombok.RequiredArgsConstructor;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springframework.beans.factory.ObjectProvider;",
            "import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;",
            "import org.springframework.boot.actuate.endpoint.web.annotation.WebEndpoint;",
            "import org.springframework.stereotype.Component;",
            "import run.halo.app.extension.ConfigMap;",
            "import run.halo.app.infra.InitializationStateGetter;",
            "import run.halo.app.infra.SystemConfigurableEnvironmentFetcher;",
            "import run.halo.app.infra.SystemSetting;",
            "import run.halo.app.infra.SystemSetting.Basic;",
            "import run.halo.app.infra.SystemSetting.Comment;",
            "import run.halo.app.infra.SystemSetting.User;",
            "import run.halo.app.infra.properties.HaloProperties;",
            "import run.halo.app.security.AuthProviderService;"
        ],
        "reference_api": [
            "getMustVerifyEmailOnRegistration",
            "get",
            "getAllowRegistration",
            "setMustVerifyEmailOnRegistration",
            "setAllowRegistration"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getMustVerifyEmailOnRegistration",
            "get",
            "getAllowRegistration",
            "setMustVerifyEmailOnRegistration",
            "setAllowRegistration"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "public Object restart()",
        "start_line": "29",
        "end_line": "36",
        "file_path": "application/src/main/java/run/halo/app/actuator/RestartEndpoint.java",
        "docstring": "This function initiates an application restart by creating a new thread group and thread to execute the restart process. It sets the thread as non-daemon and assigns the application class loader as its context class loader. The thread is then started, and the function returns a message indicating the restart has begun.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "935261f7f70d",
        "ground_truth": "public Object restart() {\n    var threadGroup = new ThreadGroup(\"RestartGroup\");\n    var thread = new Thread(threadGroup, this::doRestart, \"restartMain\");\n    thread.setDaemon(false);\n    thread.setContextClassLoader(Application.class.getClassLoader());\n    thread.start();\n    return Collections.singletonMap(\"message\", \"Restarting\");\n}",
        "import_statements": [
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.util.Collections;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.boot.SpringApplication;",
            "import org.springframework.boot.actuate.endpoint.annotation.WriteOperation;",
            "import org.springframework.boot.actuate.endpoint.web.annotation.WebEndpoint;",
            "import org.springframework.boot.context.event.ApplicationStartedEvent;",
            "import org.springframework.context.ApplicationContext;",
            "import org.springframework.context.ApplicationListener;",
            "import org.springframework.context.ConfigurableApplicationContext;",
            "import org.springframework.stereotype.Component;",
            "import run.halo.app.Application;"
        ],
        "reference_api": [
            "singletonMap",
            "getClassLoader",
            "setContextClassLoader",
            "setDaemon",
            "start"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "singletonMap",
            "getClassLoader",
            "setContextClassLoader",
            "setDaemon",
            "start"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": " public void configureHttpMessageCodecs(ServerCodecConfigurer configurer)",
        "start_line": "89",
        "end_line": "95",
        "file_path": "application/src/main/java/run/halo/app/config/WebFluxConfig.java",
        "docstring": "This function configures HTTP message codecs for a server. It sets up a Jackson JSON decoder and encoder using a provided ObjectMapper for handling JSON serialization and deserialization.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9875227cac26",
        "ground_truth": "public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n    // we need to customize the Jackson2Json[Decoder][Encoder] here to serialize and\n    // deserialize special types, e.g.: Instant, LocalDateTime. So we use ObjectMapper\n    // created by outside.\n    configurer.defaultCodecs().jackson2JsonDecoder(new Jackson2JsonDecoder(objectMapper));\n    configurer.defaultCodecs().jackson2JsonEncoder(new Jackson2JsonEncoder(objectMapper));\n}",
        "import_statements": [
            "import static org.springframework.util.ResourceUtils.FILE_URL_PREFIX;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.accept;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.method;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.path;",
            "import static org.springframework.web.reactive.function.server.RouterFunctions.route;",
            "import static run.halo.app.infra.utils.FileUtils.checkDirectoryTraversal;",
            "import com.fasterxml.jackson.databind.ObjectMapper;",
            "import java.util.List;",
            "import java.util.Objects;",
            "import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;",
            "import org.springframework.boot.autoconfigure.web.WebProperties;",
            "import org.springframework.context.ApplicationContext;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.context.annotation.Configuration;",
            "import org.springframework.core.annotation.Order;",
            "import org.springframework.http.CacheControl;",
            "import org.springframework.http.HttpMethod;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.codec.CodecConfigurer;",
            "import org.springframework.http.codec.HttpMessageWriter;",
            "import org.springframework.http.codec.ServerCodecConfigurer;",
            "import org.springframework.http.codec.json.Jackson2JsonDecoder;",
            "import org.springframework.http.codec.json.Jackson2JsonEncoder;",
            "import org.springframework.lang.NonNull;",
            "import org.springframework.web.reactive.config.ResourceHandlerRegistration;",
            "import org.springframework.web.reactive.config.ResourceHandlerRegistry;",
            "import org.springframework.web.reactive.config.WebFluxConfigurer;",
            "import org.springframework.web.reactive.function.BodyInserters;",
            "import org.springframework.web.reactive.function.server.RouterFunction;",
            "import org.springframework.web.reactive.function.server.ServerResponse;",
            "import org.springframework.web.reactive.resource.EncodedResourceResolver;",
            "import org.springframework.web.reactive.resource.PathResourceResolver;",
            "import org.springframework.web.reactive.result.view.ViewResolutionResultHandler;",
            "import org.springframework.web.reactive.result.view.ViewResolver;",
            "import reactor.core.publisher.Mono;",
            "import run.halo.app.console.ProxyFilter;",
            "import run.halo.app.console.WebSocketRequestPredicate;",
            "import run.halo.app.core.endpoint.WebSocketHandlerMapping;",
            "import run.halo.app.core.extension.endpoint.CustomEndpoint;",
            "import run.halo.app.core.extension.endpoint.CustomEndpointsBuilder;",
            "import run.halo.app.infra.properties.AttachmentProperties;",
            "import run.halo.app.infra.properties.HaloProperties;",
            "import run.halo.app.plugin.extensionpoint.ExtensionGetter;",
            "import run.halo.app.webfilter.AdditionalWebFilterChainProxy;"
        ],
        "reference_api": [
            "jackson2JsonDecoder",
            "jackson2JsonEncoder",
            "defaultCodecs"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "jackson2JsonDecoder",
            "jackson2JsonEncoder",
            "defaultCodecs"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "RouterFunction<ServerResponse> consoleIndexRedirection()",
        "start_line": "112",
        "end_line": "119",
        "file_path": "application/src/main/java/run/halo/app/config/WebFluxConfig.java",
        "docstring": "This function defines a router for redirecting requests to the console index page. It sets up a predicate to match GET requests to \"/console/**\" excluding \"/console/assets/**\", accepting HTML, and not being a WebSocket request. When matched, it serves the console index.html file from the specified location.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1691061bb071",
        "ground_truth": "RouterFunction<ServerResponse> consoleIndexRedirection() {\n    var consolePredicate = method(HttpMethod.GET)\n        .and(path(\"/console/**\").and(path(\"/console/assets/**\").negate()))\n        .and(accept(MediaType.TEXT_HTML))\n        .and(new WebSocketRequestPredicate().negate());\n    return route(consolePredicate,\n        request -> this.serveIndex(haloProp.getConsole().getLocation() + \"index.html\"));\n}",
        "import_statements": [
            "import static org.springframework.util.ResourceUtils.FILE_URL_PREFIX;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.accept;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.method;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.path;",
            "import static org.springframework.web.reactive.function.server.RouterFunctions.route;",
            "import static run.halo.app.infra.utils.FileUtils.checkDirectoryTraversal;",
            "import com.fasterxml.jackson.databind.ObjectMapper;",
            "import java.util.List;",
            "import java.util.Objects;",
            "import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;",
            "import org.springframework.boot.autoconfigure.web.WebProperties;",
            "import org.springframework.context.ApplicationContext;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.context.annotation.Configuration;",
            "import org.springframework.core.annotation.Order;",
            "import org.springframework.http.CacheControl;",
            "import org.springframework.http.HttpMethod;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.codec.CodecConfigurer;",
            "import org.springframework.http.codec.HttpMessageWriter;",
            "import org.springframework.http.codec.ServerCodecConfigurer;",
            "import org.springframework.http.codec.json.Jackson2JsonDecoder;",
            "import org.springframework.http.codec.json.Jackson2JsonEncoder;",
            "import org.springframework.lang.NonNull;",
            "import org.springframework.web.reactive.config.ResourceHandlerRegistration;",
            "import org.springframework.web.reactive.config.ResourceHandlerRegistry;",
            "import org.springframework.web.reactive.config.WebFluxConfigurer;",
            "import org.springframework.web.reactive.function.BodyInserters;",
            "import org.springframework.web.reactive.function.server.RouterFunction;",
            "import org.springframework.web.reactive.function.server.ServerResponse;",
            "import org.springframework.web.reactive.resource.EncodedResourceResolver;",
            "import org.springframework.web.reactive.resource.PathResourceResolver;",
            "import org.springframework.web.reactive.result.view.ViewResolutionResultHandler;",
            "import org.springframework.web.reactive.result.view.ViewResolver;",
            "import reactor.core.publisher.Mono;",
            "import run.halo.app.console.ProxyFilter;",
            "import run.halo.app.console.WebSocketRequestPredicate;",
            "import run.halo.app.core.endpoint.WebSocketHandlerMapping;",
            "import run.halo.app.core.extension.endpoint.CustomEndpoint;",
            "import run.halo.app.core.extension.endpoint.CustomEndpointsBuilder;",
            "import run.halo.app.infra.properties.AttachmentProperties;",
            "import run.halo.app.infra.properties.HaloProperties;",
            "import run.halo.app.plugin.extensionpoint.ExtensionGetter;",
            "import run.halo.app.webfilter.AdditionalWebFilterChainProxy;"
        ],
        "reference_api": [
            "path",
            "accept",
            "getLocation",
            "route",
            "serveIndex",
            "and",
            "negate",
            "method",
            "getConsole"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "serveIndex",
                "code": "private Mono<ServerResponse> serveIndex(String indexLocation) {\n        var indexResource = applicationContext.getResource(indexLocation);\n        try {\n            return ServerResponse.ok()\n                .cacheControl(CacheControl.noStore())\n                .body(BodyInserters.fromResource(indexResource));\n        } catch (Throwable e) {\n            return Mono.error(e);\n        }\n    }"
            }
        ],
        "third_party": [
            "path",
            "accept",
            "getLocation",
            "route",
            "and",
            "negate",
            "method",
            "getConsole"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "RouterFunction<ServerResponse> ucIndexRedirect()",
        "start_line": "122",
        "end_line": "129",
        "file_path": "application/src/main/java/run/halo/app/config/WebFluxConfig.java",
        "docstring": "This function defines a router for redirecting UC (User Console) index requests. It creates a predicate to match GET requests to \"/uc/**\" excluding \"/uc/assets/**\", accepting \"text/html\" and not being WebSocket requests. If the predicate is met, it serves the \"index.html\" file from the specified UC location.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1935c34ee581",
        "ground_truth": "RouterFunction<ServerResponse> ucIndexRedirect() {\n    var consolePredicate = method(HttpMethod.GET)\n        .and(path(\"/uc/**\").and(path(\"/uc/assets/**\").negate()))\n        .and(accept(MediaType.TEXT_HTML))\n        .and(new WebSocketRequestPredicate().negate());\n    return route(consolePredicate,\n        request -> this.serveIndex(haloProp.getUc().getLocation() + \"index.html\"));\n}",
        "import_statements": [
            "import static org.springframework.util.ResourceUtils.FILE_URL_PREFIX;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.accept;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.method;",
            "import static org.springframework.web.reactive.function.server.RequestPredicates.path;",
            "import static org.springframework.web.reactive.function.server.RouterFunctions.route;",
            "import static run.halo.app.infra.utils.FileUtils.checkDirectoryTraversal;",
            "import com.fasterxml.jackson.databind.ObjectMapper;",
            "import java.util.List;",
            "import java.util.Objects;",
            "import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;",
            "import org.springframework.boot.autoconfigure.web.WebProperties;",
            "import org.springframework.context.ApplicationContext;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.context.annotation.Configuration;",
            "import org.springframework.core.annotation.Order;",
            "import org.springframework.http.CacheControl;",
            "import org.springframework.http.HttpMethod;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.codec.CodecConfigurer;",
            "import org.springframework.http.codec.HttpMessageWriter;",
            "import org.springframework.http.codec.ServerCodecConfigurer;",
            "import org.springframework.http.codec.json.Jackson2JsonDecoder;",
            "import org.springframework.http.codec.json.Jackson2JsonEncoder;",
            "import org.springframework.lang.NonNull;",
            "import org.springframework.web.reactive.config.ResourceHandlerRegistration;",
            "import org.springframework.web.reactive.config.ResourceHandlerRegistry;",
            "import org.springframework.web.reactive.config.WebFluxConfigurer;",
            "import org.springframework.web.reactive.function.BodyInserters;",
            "import org.springframework.web.reactive.function.server.RouterFunction;",
            "import org.springframework.web.reactive.function.server.ServerResponse;",
            "import org.springframework.web.reactive.resource.EncodedResourceResolver;",
            "import org.springframework.web.reactive.resource.PathResourceResolver;",
            "import org.springframework.web.reactive.result.view.ViewResolutionResultHandler;",
            "import org.springframework.web.reactive.result.view.ViewResolver;",
            "import reactor.core.publisher.Mono;",
            "import run.halo.app.console.ProxyFilter;",
            "import run.halo.app.console.WebSocketRequestPredicate;",
            "import run.halo.app.core.endpoint.WebSocketHandlerMapping;",
            "import run.halo.app.core.extension.endpoint.CustomEndpoint;",
            "import run.halo.app.core.extension.endpoint.CustomEndpointsBuilder;",
            "import run.halo.app.infra.properties.AttachmentProperties;",
            "import run.halo.app.infra.properties.HaloProperties;",
            "import run.halo.app.plugin.extensionpoint.ExtensionGetter;",
            "import run.halo.app.webfilter.AdditionalWebFilterChainProxy;"
        ],
        "reference_api": [
            "path",
            "accept",
            "getLocation",
            "route",
            "serveIndex",
            "getUc",
            "and",
            "negate",
            "method"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "serveIndex",
                "code": "private Mono<ServerResponse> serveIndex(String indexLocation) {\n        var indexResource = applicationContext.getResource(indexLocation);\n        try {\n            return ServerResponse.ok()\n                .cacheControl(CacheControl.noStore())\n                .body(BodyInserters.fromResource(indexResource));\n        } catch (Throwable e) {\n            return Mono.error(e);\n        }\n    }"
            }
        ],
        "third_party": [
            "path",
            "accept",
            "getLocation",
            "route",
            "getUc",
            "and",
            "negate",
            "method"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "public ReactiveIndexedSessionRepository<MapSession> reactiveSessionRepository",
        "start_line": "118",
        "end_line": "126",
        "file_path": "application/src/main/java/run/halo/app/config/WebServerSecurityConfig.java",
        "docstring": "This function creates and configures an in-memory reactive session repository. It initializes the repository with a concurrent hash map and sets the default session timeout based on properties from the session and server configurations. The configured repository is then returned.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "75ce083288cd",
        "ground_truth": "public ReactiveIndexedSessionRepository<MapSession> reactiveSessionRepository(\n    SessionProperties sessionProperties,\n    ServerProperties serverProperties) {\n    var repository = new InMemoryReactiveIndexedSessionRepository(new ConcurrentHashMap<>());\n    var timeout = sessionProperties.determineTimeout(\n        () -> serverProperties.getReactive().getSession().getTimeout());\n    repository.setDefaultMaxInactiveInterval(timeout);\n    return repository;\n}",
        "import_statements": [
            "import static org.springframework.security.config.Customizer.withDefaults;",
            "import static org.springframework.security.web.server.authentication.ServerWebExchangeDelegatingReactiveAuthenticationManagerResolver.builder;",
            "import static org.springframework.security.web.server.util.matcher.ServerWebExchangeMatchers.pathMatchers;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import lombok.RequiredArgsConstructor;",
            "import org.springframework.beans.factory.ObjectProvider;",
            "import org.springframework.boot.autoconfigure.session.SessionProperties;",
            "import org.springframework.boot.autoconfigure.web.ServerProperties;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.context.annotation.Configuration;",
            "import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;",
            "import org.springframework.security.config.web.server.ServerHttpSecurity;",
            "import org.springframework.security.crypto.factory.PasswordEncoderFactories;",
            "import org.springframework.security.crypto.password.PasswordEncoder;",
            "import org.springframework.security.web.server.SecurityWebFilterChain;",
            "import org.springframework.security.web.server.context.ServerSecurityContextRepository;",
            "import org.springframework.security.web.server.context.WebSessionServerSecurityContextRepository;",
            "import org.springframework.session.MapSession;",
            "import org.springframework.session.config.annotation.web.server.EnableSpringWebSession;",
            "import org.springframework.web.reactive.function.server.RouterFunction;",
            "import org.springframework.web.reactive.function.server.ServerResponse;",
            "import run.halo.app.core.extension.service.RoleService;",
            "import run.halo.app.core.extension.service.UserService;",
            "import run.halo.app.extension.ReactiveExtensionClient;",
            "import run.halo.app.infra.AnonymousUserConst;",
            "import run.halo.app.infra.properties.HaloProperties;",
            "import run.halo.app.security.DefaultUserDetailService;",
            "import run.halo.app.security.authentication.CryptoService;",
            "import run.halo.app.security.authentication.SecurityConfigurer;",
            "import run.halo.app.security.authentication.impl.RsaKeyService;",
            "import run.halo.app.security.authentication.login.PublicKeyRouteBuilder;",
            "import run.halo.app.security.authentication.pat.PatAuthenticationManager;",
            "import run.halo.app.security.authentication.pat.PatServerWebExchangeMatcher;",
            "import run.halo.app.security.authentication.twofactor.TwoFactorAuthorizationManager;",
            "import run.halo.app.security.authorization.RequestInfoAuthorizationManager;",
            "import run.halo.app.security.session.InMemoryReactiveIndexedSessionRepository;",
            "import run.halo.app.security.session.ReactiveIndexedSessionRepository;"
        ],
        "reference_api": [
            "setDefaultMaxInactiveInterval",
            "getReactive",
            "getSession",
            "determineTimeout",
            "getTimeout"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setDefaultMaxInactiveInterval",
            "getReactive",
            "getSession",
            "determineTimeout",
            "getTimeout"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "DefaultUserDetailService userDetailsService(UserService userService,\n        RoleService roleService,\n        HaloProperties haloProperties)",
        "start_line": "129",
        "end_line": "136",
        "file_path": "application/src/main/java/run/halo/app/config/WebServerSecurityConfig.java",
        "docstring": "This function creates and configures a DefaultUserDetailService instance using UserService, RoleService, and HaloProperties. It initializes the service with the provided user and role services, and configures it to enable or disable two-factor authentication based on the security settings in HaloProperties. Finally, it returns the configured DefaultUserDetailService instance.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8b04e4000b63",
        "ground_truth": "DefaultUserDetailService userDetailsService(UserService userService,\n    RoleService roleService,\n    HaloProperties haloProperties) {\n    var userDetailService = new DefaultUserDetailService(userService, roleService);\n    var twoFactorAuthDisabled = haloProperties.getSecurity().getTwoFactorAuth().isDisabled();\n    userDetailService.setTwoFactorAuthDisabled(twoFactorAuthDisabled);\n    return userDetailService;\n}",
        "import_statements": [
            "import static org.springframework.security.config.Customizer.withDefaults;",
            "import static org.springframework.security.web.server.authentication.ServerWebExchangeDelegatingReactiveAuthenticationManagerResolver.builder;",
            "import static org.springframework.security.web.server.util.matcher.ServerWebExchangeMatchers.pathMatchers;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import lombok.RequiredArgsConstructor;",
            "import org.springframework.beans.factory.ObjectProvider;",
            "import org.springframework.boot.autoconfigure.session.SessionProperties;",
            "import org.springframework.boot.autoconfigure.web.ServerProperties;",
            "import org.springframework.context.annotation.Bean;",
            "import org.springframework.context.annotation.Configuration;",
            "import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;",
            "import org.springframework.security.config.web.server.ServerHttpSecurity;",
            "import org.springframework.security.crypto.factory.PasswordEncoderFactories;",
            "import org.springframework.security.crypto.password.PasswordEncoder;",
            "import org.springframework.security.web.server.SecurityWebFilterChain;",
            "import org.springframework.security.web.server.context.ServerSecurityContextRepository;",
            "import org.springframework.security.web.server.context.WebSessionServerSecurityContextRepository;",
            "import org.springframework.session.MapSession;",
            "import org.springframework.session.config.annotation.web.server.EnableSpringWebSession;",
            "import org.springframework.web.reactive.function.server.RouterFunction;",
            "import org.springframework.web.reactive.function.server.ServerResponse;",
            "import run.halo.app.core.extension.service.RoleService;",
            "import run.halo.app.core.extension.service.UserService;",
            "import run.halo.app.extension.ReactiveExtensionClient;",
            "import run.halo.app.infra.AnonymousUserConst;",
            "import run.halo.app.infra.properties.HaloProperties;",
            "import run.halo.app.security.DefaultUserDetailService;",
            "import run.halo.app.security.authentication.CryptoService;",
            "import run.halo.app.security.authentication.SecurityConfigurer;",
            "import run.halo.app.security.authentication.impl.RsaKeyService;",
            "import run.halo.app.security.authentication.login.PublicKeyRouteBuilder;",
            "import run.halo.app.security.authentication.pat.PatAuthenticationManager;",
            "import run.halo.app.security.authentication.pat.PatServerWebExchangeMatcher;",
            "import run.halo.app.security.authentication.twofactor.TwoFactorAuthorizationManager;",
            "import run.halo.app.security.authorization.RequestInfoAuthorizationManager;",
            "import run.halo.app.security.session.InMemoryReactiveIndexedSessionRepository;",
            "import run.halo.app.security.session.ReactiveIndexedSessionRepository;"
        ],
        "reference_api": [
            "getSecurity",
            "isDisabled",
            "getTwoFactorAuth",
            "setTwoFactorAuthDisabled"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getSecurity",
            "isDisabled",
            "getTwoFactorAuth",
            "setTwoFactorAuthDisabled"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "public Comment.CommentOwner toCommentOwner()",
        "start_line": "30",
        "end_line": "42",
        "file_path": "application/src/main/java/run/halo/app/content/comment/CommentEmailOwner.java",
        "docstring": "This function converts an object to a CommentOwner instance. It sets the kind to \"email\", assigns the email or an empty string if null, and sets the display name. It also initializes annotations for the avatar and website, then returns the configured CommentOwner.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "d643a44eebb6",
        "ground_truth": "public Comment.CommentOwner toCommentOwner() {\n    Comment.CommentOwner commentOwner = new Comment.CommentOwner();\n    commentOwner.setKind(Comment.CommentOwner.KIND_EMAIL);\n    // email nullable\n    commentOwner.setName(StringUtils.defaultString(email, StringUtils.EMPTY));\n    commentOwner.setDisplayName(displayName);\n    Map<String, String> annotations = new LinkedHashMap<>();\n    commentOwner.setAnnotations(annotations);\n    annotations.put(Comment.CommentOwner.AVATAR_ANNO, avatar);\n    annotations.put(Comment.CommentOwner.WEBSITE_ANNO, website);\n    return commentOwner;\n}",
        "import_statements": [
            "import java.util.LinkedHashMap;",
            "import java.util.Map;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springframework.util.Assert;",
            "import run.halo.app.core.extension.content.Comment;"
        ],
        "reference_api": [
            "setName",
            "setDisplayName",
            "defaultString",
            "setAnnotations",
            "put",
            "setKind"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setName",
            "setDisplayName",
            "defaultString",
            "setAnnotations",
            "put",
            "setKind"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "boolean isPostOwner(Post post, Comment.CommentOwner commentOwner)",
        "start_line": "134",
        "end_line": "144",
        "file_path": "application/src/main/java/run/halo/app/content/comment/CommentNotificationReasonPublisher.java",
        "docstring": "This function checks if a given comment owner is the owner of a specified post. It compares the comment owner's kind and name with the post owner's information. If the kind is email, it fetches the user by the post owner and checks the email. Otherwise, it directly compares the comment owner's name with the post owner.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "af31a33287ec",
        "ground_truth": "boolean isPostOwner(Post post, Comment.CommentOwner commentOwner) {\n    String kind = commentOwner.getKind();\n    String name = commentOwner.getName();\n    var postOwner = post.getSpec().getOwner();\n    if (Comment.CommentOwner.KIND_EMAIL.equals(kind)) {\n        return client.fetch(User.class, postOwner)\n            .filter(user -> name.equals(user.getSpec().getEmail()))\n            .isPresent();\n    }\n    return name.equals(postOwner);\n}",
        "import_statements": [
            "import static org.apache.commons.lang3.StringUtils.defaultIfBlank;",
            "import static run.halo.app.content.comment.ReplyNotificationSubscriptionHelper.identityFrom;",
            "import com.fasterxml.jackson.core.type.TypeReference;",
            "import java.util.Map;",
            "import java.util.Optional;",
            "import lombok.Builder;",
            "import lombok.RequiredArgsConstructor;",
            "import lombok.experimental.UtilityClass;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springframework.context.event.EventListener;",
            "import org.springframework.scheduling.annotation.Async;",
            "import org.springframework.stereotype.Component;",
            "import org.springframework.util.Assert;",
            "import run.halo.app.content.NotificationReasonConst;",
            "import run.halo.app.core.extension.User;",
            "import run.halo.app.core.extension.content.Comment;",
            "import run.halo.app.core.extension.content.Post;",
            "import run.halo.app.core.extension.content.Reply;",
            "import run.halo.app.core.extension.content.SinglePage;",
            "import run.halo.app.core.extension.notification.Reason;",
            "import run.halo.app.core.extension.notification.Subscription;",
            "import run.halo.app.event.post.CommentCreatedEvent;",
            "import run.halo.app.event.post.ReplyCreatedEvent;",
            "import run.halo.app.extension.ExtensionClient;",
            "import run.halo.app.extension.GroupVersionKind;",
            "import run.halo.app.extension.Ref;",
            "import run.halo.app.infra.ExternalLinkProcessor;",
            "import run.halo.app.infra.utils.JsonUtils;",
            "import run.halo.app.notification.NotificationReasonEmitter;",
            "import run.halo.app.plugin.extensionpoint.ExtensionGetter;"
        ],
        "reference_api": [
            "getName",
            "filter",
            "equals",
            "getOwner",
            "getSpec",
            "isPresent",
            "fetch",
            "getKind",
            "getEmail"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getName",
            "filter",
            "getOwner",
            "getSpec",
            "isPresent",
            "fetch",
            "getKind",
            "getEmail"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "public ListOptions toListOptions()",
        "start_line": "70",
        "end_line": "89",
        "file_path": "application/src/main/java/run/halo/app/content/comment/CommentQuery.java",
        "docstring": "This function converts label and field selectors into a ListOptions object. It builds a field query from the selectors and adds conditions based on keyword and owner name, if provided. Finally, it sets the constructed field selector in the ListOptions object and returns it.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "80647f393c4c",
        "ground_truth": "public ListOptions toListOptions() {\n    var listOptions =\n        labelAndFieldSelectorToListOptions(getLabelSelector(), getFieldSelector());\n    var fieldQuery = listOptions.getFieldSelector().query();\n    String keyword = getKeyword();\n    if (StringUtils.isNotBlank(keyword)) {\n        fieldQuery = and(fieldQuery, contains(\"spec.raw\", keyword));\n    }\n    String ownerName = getOwnerName();\n    if (StringUtils.isNotBlank(ownerName)) {\n        String ownerKind = StringUtils.defaultIfBlank(getOwnerKind(), User.KIND);\n        fieldQuery = and(fieldQuery,\n            equal(\"spec.owner\", Comment.CommentOwner.ownerIdentity(ownerKind, ownerName)));\n    }\n    listOptions.setFieldSelector(FieldSelector.of(fieldQuery));\n    return listOptions;\n}",
        "import_statements": [
            "import static org.springdoc.core.fn.builders.parameter.Builder.parameterBuilder;",
            "import static run.halo.app.extension.index.query.QueryFactory.and;",
            "import static run.halo.app.extension.index.query.QueryFactory.contains;",
            "import static run.halo.app.extension.index.query.QueryFactory.equal;",
            "import static run.halo.app.extension.router.selector.SelectorUtil.labelAndFieldSelectorToListOptions;",
            "import io.swagger.v3.oas.annotations.enums.ParameterIn;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.springdoc.core.fn.builders.operation.Builder;",
            "import org.springframework.data.domain.Sort;",
            "import org.springframework.web.reactive.function.server.ServerRequest;",
            "import org.springframework.web.server.ServerWebExchange;",
            "import run.halo.app.core.extension.User;",
            "import run.halo.app.core.extension.content.Comment;",
            "import run.halo.app.core.extension.endpoint.SortResolver;",
            "import run.halo.app.extension.ListOptions;",
            "import run.halo.app.extension.PageRequest;",
            "import run.halo.app.extension.PageRequestImpl;",
            "import run.halo.app.extension.router.IListRequest;",
            "import run.halo.app.extension.router.QueryParamBuildUtil;",
            "import run.halo.app.extension.router.selector.FieldSelector;"
        ],
        "reference_api": [
            "getOwnerName",
            "setFieldSelector",
            "ownerIdentity",
            "getLabelSelector",
            "getKeyword",
            "labelAndFieldSelectorToListOptions",
            "defaultIfBlank",
            "query",
            "of",
            "getFieldSelector",
            "and",
            "contains",
            "equal",
            "getOwnerKind",
            "isNotBlank"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getOwnerName",
                "code": "public String getOwnerName() {\n        String ownerName = queryParams.getFirst(\"ownerName\");\n        return StringUtils.isBlank(ownerName) ? null : ownerName;\n    }"
            },
            {
                "name": "getKeyword",
                "code": "public String getKeyword() {\n        String keyword = queryParams.getFirst(\"keyword\");\n        return StringUtils.isBlank(keyword) ? null : keyword;\n    }"
            },
            {
                "name": "getOwnerKind",
                "code": "public String getOwnerKind() {\n        String ownerKind = queryParams.getFirst(\"ownerKind\");\n        return StringUtils.isBlank(ownerKind) ? null : ownerKind;\n    }"
            }
        ],
        "third_party": [
            "setFieldSelector",
            "ownerIdentity",
            "getLabelSelector",
            "labelAndFieldSelectorToListOptions",
            "defaultIfBlank",
            "query",
            "of",
            "getFieldSelector",
            "and",
            "equal",
            "isNotBlank"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "Mono<CommentStats> fetchStats(String commentName)",
        "start_line": "227",
        "end_line": "235",
        "file_path": "application/src/main/java/run/halo/app/content/comment/CommentServiceImpl.java",
        "docstring": "This function fetches statistics for a given comment name. It ensures the comment name is not null, retrieves the counter associated with the comment, and maps the upvote count to a CommentStats object. If no counter is found, it returns an empty CommentStats object.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "95c1ce631715",
        "ground_truth": "Mono<CommentStats> fetchStats(String commentName) {\n    Assert.notNull(commentName, \"The commentName must not be null.\");\n    return counterService.getByName(MeterUtils.nameOf(Comment.class, commentName))\n        .map(counter -> CommentStats.builder()\n            .upvote(counter.getUpvote())\n            .build()\n        )\n        .defaultIfEmpty(CommentStats.empty());\n}",
        "import_statements": [
            "import static run.halo.app.extension.index.query.QueryFactory.and;",
            "import static run.halo.app.extension.index.query.QueryFactory.equal;",
            "import static run.halo.app.extension.index.query.QueryFactory.isNull;",
            "import java.time.Duration;",
            "import java.time.Instant;",
            "import java.util.Set;",
            "import java.util.function.Function;",
            "import org.apache.commons.lang3.BooleanUtils;",
            "import org.springframework.dao.OptimisticLockingFailureException;",
            "import org.springframework.data.domain.Sort;",
            "import org.springframework.lang.NonNull;",
            "import org.springframework.security.core.context.ReactiveSecurityContextHolder;",
            "import org.springframework.stereotype.Component;",
            "import org.springframework.util.Assert;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;",
            "import reactor.util.retry.Retry;",
            "import run.halo.app.core.extension.User;",
            "import run.halo.app.core.extension.content.Comment;",
            "import run.halo.app.core.extension.service.RoleService;",
            "import run.halo.app.core.extension.service.UserService;",
            "import run.halo.app.extension.Extension;",
            "import run.halo.app.extension.ListOptions;",
            "import run.halo.app.extension.ListResult;",
            "import run.halo.app.extension.PageRequest;",
            "import run.halo.app.extension.PageRequestImpl;",
            "import run.halo.app.extension.ReactiveExtensionClient;",
            "import run.halo.app.extension.Ref;",
            "import run.halo.app.extension.router.selector.FieldSelector;",
            "import run.halo.app.infra.SystemConfigurableEnvironmentFetcher;",
            "import run.halo.app.infra.exception.AccessDeniedException;",
            "import run.halo.app.metrics.CounterService;",
            "import run.halo.app.metrics.MeterUtils;",
            "import run.halo.app.plugin.extensionpoint.ExtensionGetter;",
            "import run.halo.app.security.authorization.AuthorityUtils;"
        ],
        "reference_api": [
            "getByName",
            "nameOf",
            "upvote",
            "getUpvote",
            "map",
            "notNull",
            "empty",
            "defaultIfEmpty",
            "build",
            "builder"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getByName",
            "nameOf",
            "upvote",
            "getUpvote",
            "map",
            "notNull",
            "empty",
            "defaultIfEmpty",
            "build",
            "builder"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "void subscribeReply(UserIdentity identity)",
        "start_line": "45",
        "end_line": "54",
        "file_path": "application/src/main/java/run/halo/app/content/comment/ReplyNotificationSubscriptionHelper.java",
        "docstring": "This function subscribes a user to reply notifications. It creates a subscriber from the given user identity and, if successful, sets up an interest reason for the subscription, specifying that the reason type is \"someone replied to you\" and the condition is that the replied owner matches the user's name. Finally, it subscribes the user to the notification center and blocks until the subscription is completed.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "c273b7a1f123",
        "ground_truth": "void subscribeReply(UserIdentity identity) {\n    var subscriber = createSubscriber(identity);\n    if (subscriber == null) {\n        return;\n    }\n    var interestReason = new Subscription.InterestReason();\n    interestReason.setReasonType(NotificationReasonConst.SOMEONE_REPLIED_TO_YOU);\n    interestReason.setExpression(\"props.repliedOwner == '%s'\".formatted(identity.name()));\n    notificationCenter.subscribe(subscriber, interestReason).block();\n}",
        "import_statements": [
            "import io.micrometer.common.util.StringUtils;",
            "import lombok.RequiredArgsConstructor;",
            "import org.springframework.lang.Nullable;",
            "import org.springframework.stereotype.Component;",
            "import run.halo.app.content.NotificationReasonConst;",
            "import run.halo.app.core.extension.content.Comment;",
            "import run.halo.app.core.extension.content.Reply;",
            "import run.halo.app.core.extension.notification.Subscription;",
            "import run.halo.app.notification.NotificationCenter;",
            "import run.halo.app.notification.UserIdentity;"
        ],
        "reference_api": [
            "name",
            "formatted",
            "setReasonType",
            "createSubscriber",
            "block",
            "setExpression",
            "subscribe"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "createSubscriber",
                "code": "@Nullable\n    private Subscription.Subscriber createSubscriber(UserIdentity author) {\n        if (StringUtils.isBlank(author.name())) {\n            return null;\n        }\n\n        Subscription.Subscriber subscriber = new Subscription.Subscriber();\n        subscriber.setName(author.name());\n        return subscriber;\n    }"
            }
        ],
        "third_party": [
            "name",
            "formatted",
            "setReasonType",
            "block",
            "setExpression",
            "subscribe"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "halo-dev/halo",
        "function_declaration": "private Mono<Comment> approveComment(Comment comment)",
        "start_line": "76",
        "end_line": "85",
        "file_path": "application/src/main/java/run/halo/app/content/comment/ReplyServiceImpl.java",
        "docstring": "This function approves a comment by setting its approved status to true and recording the current time. It updates the comment using a client and handles optimistic locking failures by retrying the update operation with the specified update function.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e2b873268244",
        "ground_truth": "private Mono<Comment> approveComment(Comment comment) {\n    UnaryOperator<Comment> updateFunc = commentToUpdate -> {\n        commentToUpdate.getSpec().setApproved(true);\n        commentToUpdate.getSpec().setApprovedTime(Instant.now());\n        return commentToUpdate;\n    };\n    return client.update(updateFunc.apply(comment))\n        .onErrorResume(OptimisticLockingFailureException.class,\n            e -> updateCommentWithRetry(comment.getMetadata().getName(), updateFunc));\n}",
        "import_statements": [
            "import static run.halo.app.extension.index.query.QueryFactory.and;",
            "import static run.halo.app.extension.index.query.QueryFactory.equal;",
            "import static run.halo.app.extension.index.query.QueryFactory.isNull;",
            "import static run.halo.app.security.authorization.AuthorityUtils.COMMENT_MANAGEMENT_ROLE_NAME;",
            "import static run.halo.app.security.authorization.AuthorityUtils.authoritiesToRoles;",
            "import java.time.Duration;",
            "import java.time.Instant;",
            "import java.util.ArrayList;",
            "import java.util.Set;",
            "import java.util.function.Function;",
            "import java.util.function.UnaryOperator;",
            "import lombok.RequiredArgsConstructor;",
            "import org.apache.commons.lang3.BooleanUtils;",
            "import org.apache.commons.lang3.StringUtils;",
            "import org.reactivestreams.Publisher;",
            "import org.springframework.dao.OptimisticLockingFailureException;",
            "import org.springframework.data.domain.Sort;",
            "import org.springframework.security.core.context.ReactiveSecurityContextHolder;",
            "import org.springframework.security.core.context.SecurityContext;",
            "import org.springframework.stereotype.Service;",
            "import org.springframework.util.Assert;",
            "import reactor.core.publisher.Flux;",
            "import reactor.core.publisher.Mono;",
            "import reactor.util.retry.Retry;",
            "import run.halo.app.core.extension.User;",
            "import run.halo.app.core.extension.content.Comment;",
            "import run.halo.app.core.extension.content.Reply;",
            "import run.halo.app.core.extension.service.RoleService;",
            "import run.halo.app.core.extension.service.UserService;",
            "import run.halo.app.extension.ListOptions;",
            "import run.halo.app.extension.ListResult;",
            "import run.halo.app.extension.PageRequest;",
            "import run.halo.app.extension.PageRequestImpl;",
            "import run.halo.app.extension.ReactiveExtensionClient;",
            "import run.halo.app.extension.router.selector.FieldSelector;",
            "import run.halo.app.metrics.CounterService;",
            "import run.halo.app.metrics.MeterUtils;"
        ],
        "reference_api": [
            "getName",
            "getSpec",
            "update",
            "apply",
            "updateCommentWithRetry",
            "setApproved",
            "getMetadata",
            "onErrorResume",
            "now",
            "setApprovedTime"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "updateCommentWithRetry",
                "code": "private Mono<Comment> updateCommentWithRetry(String name, UnaryOperator<Comment> updateFunc) {\n        return Mono.defer(() -> client.get(Comment.class, name)\n                .map(updateFunc)\n                .flatMap(client::update)\n            )\n            .retryWhen(Retry.backoff(8, Duration.ofMillis(100))\n                .filter(OptimisticLockingFailureException.class::isInstance));\n    }"
            }
        ],
        "third_party": [
            "getName",
            "getSpec",
            "update",
            "apply",
            "setApproved",
            "getMetadata",
            "onErrorResume",
            "now",
            "setApprovedTime"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "filamentphp/filament",
        "function_declaration": "public function prepareModalAction(StaticAction $action): StaticAction",
        "start_line": "427",
        "end_line": "443",
        "file_path": "packages/actions/src/Concerns/CanOpenModal.php",
        "docstring": "This function prepares a modal action by checking if the action is an instance of MountableAction. If so, it associates the action with the current Livewire component. If both the current instance and action implement HasRecord, it sets the record on the action. Finally, it returns the action.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "87b91730ba0c",
        "ground_truth": "public function prepareModalAction(StaticAction $action): StaticAction\n{\n    if (! $action instanceof MountableAction) {\n        return $action;\n    }\n    $action->livewire($this->getLivewire());\n    if (\n        ($this instanceof HasRecord) &&\n        ($action instanceof HasRecord)\n    ) {\n        $action->record($this->getRecord());\n    }\n    return $action;\n}",
        "import_statements": [
            "use Closure;",
            "use Filament\\Actions\\Contracts\\HasRecord;",
            "use Filament\\Actions\\MountableAction;",
            "use Filament\\Actions\\StaticAction;",
            "use Filament\\Support\\Enums\\Alignment;",
            "use Filament\\Support\\Enums\\MaxWidth;",
            "use Filament\\Support\\View\\Components\\Modal;",
            "use Illuminate\\Contracts\\Support\\Htmlable;",
            "use Illuminate\\Contracts\\View\\View;"
        ],
        "reference_api": [
            "$this->getRecord",
            "$action->record",
            "$this->getLivewire",
            "$action->livewire"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "$this->getRecord",
            "$action->record",
            "$this->getLivewire",
            "$action->livewire"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "filamentphp/filament",
        "function_declaration": "public function dispatchSuccessRedirect(): static",
        "start_line": "27",
        "end_line": "36",
        "file_path": "packages/actions/src/Concerns/CanRedirect.php",
        "docstring": "This function handles a successful redirect. It evaluates the success redirect URL and, if the URL is not empty, performs a redirect to that URL. It returns the current instance of the object.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e79f440b334f",
        "ground_truth": "public function dispatchSuccessRedirect(): static\n{\n    $url = $this->evaluate($this->successRedirectUrl);\n    if (filled($url)) {\n        $this->redirect($url);\n    }\n    return $this;\n}",
        "import_statements": [
            "use Closure;",
            "use Filament\\Support\\Facades\\FilamentView;",
            "use function Filament\\Support\\is_app_url;"
        ],
        "reference_api": [
            "filled",
            "$this->evaluate",
            "$this->redirect"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "$this->redirect",
                "code": "public function redirect(string | Closure $url): void\n    {\n        $url = $this->evaluate($url);\n\n        $this->getLivewire()->redirect($url, navigate: FilamentView::hasSpaMode() && is_app_url($url));\n    }"
            }
        ],
        "third_party": [
            "filled",
            "$this->evaluate"
        ]
    },
    {
        "subclass": "CMS",
        "owner/repo": "filamentphp/filament",
        "function_declaration": "protected function syncTagsWithAnyType(?Model $record, array $state): void",
        "start_line": "64",
        "end_line": "87",
        "file_path": "packages/spatie-laravel-tags-plugin/src/Forms/Components/SpatieTagsInput.php",
        "docstring": "This function syncs tags with a given record. It checks if the record exists and has a tags method. It retrieves the tag model class and processes the provided tag names to find or create tags. Finally, it synchronizes the tags with the record by syncing their IDs.",
        "language": "PHP",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8fdc11cc8b44",
        "ground_truth": "protected function syncTagsWithAnyType(?Model $record, array $state): void\n{\n    if (! ($record && method_exists($record, 'tags'))) {\n        return;\n    }\n    $tagClassName = config('tags.tag_model', Tag::class);\n    $tags = collect($state)->map(function ($tagName) use ($tagClassName) {\n        $locale = $tagClassName::getLocale();\n        $tag = $tagClassName::findFromStringOfAnyType($tagName, $locale);\n        if ($tag?->isEmpty() ?? true) {\n            $tag = $tagClassName::create([\n                'name' => [$locale => $tagName],\n            ]);\n        }\n        return $tag;\n    })->flatten();\n    $record->tags()->sync($tags->pluck('id'));\n}",
        "import_statements": [
            "use Closure;",
            "use Filament\\SpatieLaravelTagsPlugin\\Types\\AllTagTypes;",
            "use Illuminate\\Database\\Eloquent\\Builder;",
            "use Illuminate\\Database\\Eloquent\\Model;",
            "use Spatie\\Tags\\Tag;"
        ],
        "reference_api": [
            "$record->tags",
            "$tagClassName::create",
            "$record->tags()->sync",
            "$tags->pluck",
            "config",
            "$tagClassName::getLocale",
            "collect($state)->map",
            "collect",
            "$tagClassName::findFromStringOfAnyType",
            "collect($state)->map(function ($tagName) use ($tagClassName) {\n            $locale = $tagClassName::getLocale();\n\n            $tag = $tagClassName::findFromStringOfAnyType($tagName, $locale);\n\n            if ($tag?->isEmpty() ?? true) {\n                $tag = $tagClassName::create([\n                    'name' => [$locale => $tagName],\n                ]);\n            }\n\n            return $tag;\n        })->flatten",
            "method_exists"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "$record->tags",
            "$tagClassName::create",
            "$record->tags()->sync",
            "$tags->pluck",
            "config",
            "$tagClassName::getLocale",
            "collect($state)->map",
            "collect",
            "$tagClassName::findFromStringOfAnyType",
            "collect($state)->map(function ($tagName) use ($tagClassName) {\n            $locale = $tagClassName::getLocale();\n\n            $tag = $tagClassName::findFromStringOfAnyType($tagName, $locale);\n\n            if ($tag?->isEmpty() ?? true) {\n                $tag = $tagClassName::create([\n                    'name' => [$locale => $tagName],\n                ]);\n            }\n\n            return $tag;\n        })->flatten"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "harness/gitness",
        "function_declaration": "func CheckPipeline(ctx context.Context, authorizer authz.Authorizer, session *auth.Session,\n\trepoPath string, pipelineIdentifier string, permission enum.Permission) error ",
        "start_line": "32",
        "end_line": "44",
        "file_path": "app/api/auth/pipeline.go",
        "docstring": "This function checks if a user has the required permission for a pipeline. It dissects the repository path to obtain the space path and repository name, creates a scope and resource for the pipeline, and calls the Check function with the context, authorizer, session, scope, resource, and permission to perform the authorization check. It returns an error if the path dissection fails or if the permission check is not successful.",
        "language": "Go",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7688efe952c7",
        "ground_truth": "func CheckPipeline(ctx context.Context, authorizer authz.Authorizer, session *auth.Session,\n repoPath string, pipelineIdentifier string, permission enum.Permission) error {\n spacePath, repoName, err := paths.DisectLeaf(repoPath)\n if err != nil {\n  return fmt.Errorf(\"failed to disect path '%s': %w\", repoPath, err)\n }\n scope := &types.Scope{SpacePath: spacePath, Repo: repoName}\n resource := &types.Resource{\n  Type:       enum.ResourceTypePipeline,\n  Identifier: pipelineIdentifier,\n }\n return Check(ctx, authorizer, session, scope, resource, permission)\n}",
        "import_statements": [
            "import (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/harness/gitness/app/auth\"\n\t\"github.com/harness/gitness/app/auth/authz\"\n\t\"github.com/harness/gitness/app/paths\"\n\t\"github.com/harness/gitness/types\"\n\t\"github.com/harness/gitness/types/enum\"\n)"
        ],
        "reference_api": [
            "Check",
            "fmt.Errorf",
            "paths.DisectLeaf"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Check",
            "paths.DisectLeaf"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "harness/gitness",
        "function_declaration": "func CheckSpace(\n\tctx context.Context,\n\tauthorizer authz.Authorizer,\n\tsession *auth.Session,\n\tspace *types.Space,\n\tpermission enum.Permission,\n) error",
        "start_line": "31",
        "end_line": "50",
        "file_path": "app/api/auth/space.go",
        "docstring": "This function checks if a session has a specified permission for a space. It dissects the space path to get the parent space and name, creates a scope and resource based on the parent space and name, and then calls the Check function with the context, authorizer, session, scope, resource, and permission.",
        "language": "Go",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ff2995d8eeeb",
        "ground_truth": "func CheckSpace(\n ctx context.Context,\n authorizer authz.Authorizer,\n session *auth.Session,\n space *types.Space,\n permission enum.Permission,\n) error {\n parentSpace, name, err := paths.DisectLeaf(space.Path)\n if err != nil {\n  return fmt.Errorf(\"failed to disect path '%s': %w\", space.Path, err)\n }\n  scope := &types.Scope{SpacePath: parentSpace}\n resource := &types.Resource{\n  Type:       enum.ResourceTypeSpace,\n  Identifier: name,\n }\n  return Check(ctx, authorizer, session, scope, resource, permission)\n}",
        "import_statements": [
            "import (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/harness/gitness/app/auth\"\n\t\"github.com/harness/gitness/app/auth/authz\"\n\t\"github.com/harness/gitness/app/paths\"\n\t\"github.com/harness/gitness/types\"\n\t\"github.com/harness/gitness/types/enum\"\n)"
        ],
        "reference_api": [
            "Check",
            "fmt.Errorf",
            "paths.DisectLeaf"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Check",
            "paths.DisectLeaf"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "harness/gitness",
        "function_declaration": "func SanitizeJSONPayload(source json.RawMessage, data any) (json.RawMessage, error)",
        "start_line": "90",
        "end_line": "118",
        "file_path": "app/api/controller/check/check_report.go",
        "docstring": "This function sanitizes a JSON payload. It first checks if the source is empty and marshals the provided data if so. It then decodes the source JSON, disallowing unknown fields, and encodes the data to ensure it conforms to the required format. It removes any trailing newline from the result before returning the sanitized JSON or an error if the process fails.",
        "language": "Go",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1603e7a38dc8",
        "ground_truth": "func SanitizeJSONPayload(source json.RawMessage, data any) (json.RawMessage, error) {\n if len(source) == 0 {\n  return json.Marshal(data) // marshal the empty object\n }\n  decoder := json.NewDecoder(bytes.NewReader(source))\n decoder.DisallowUnknownFields()\n  if err := decoder.Decode(&data); err != nil {\n  return nil, usererror.BadRequestf(\"Payload data doesn't match the required format: %s\", err.Error())\n }\n  buffer := bytes.NewBuffer(nil)\n buffer.Grow(512)\n  encoder := json.NewEncoder(buffer)\n encoder.SetEscapeHTML(false)\n if err := encoder.Encode(data); err != nil {\n  return nil, fmt.Errorf(\"failed to sanitize json payload: %w\", err)\n }\n  result := buffer.Bytes()\n  if result[len(result)-1] == '\\n' {\n  result = result[:len(result)-1]\n }\n  return result, nil\n}",
        "import_statements": [
            "import (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"time\"\n\n\t\"github.com/harness/gitness/app/api/usererror\"\n\t\"github.com/harness/gitness/app/auth\"\n\t\"github.com/harness/gitness/git\"\n\t\"github.com/harness/gitness/store\"\n\t\"github.com/harness/gitness/types\"\n\t\"github.com/harness/gitness/types/enum\"\n)"
        ],
        "reference_api": [
            "bytes.NewBuffer",
            "buffer.Bytes",
            "fmt.Errorf",
            "usererror.BadRequestf",
            "buffer.Grow",
            "json.Marshal",
            "decoder.Decode",
            "json.NewDecoder",
            "encoder.Encode",
            "len",
            "bytes.NewReader",
            "json.NewEncoder",
            "decoder.DisallowUnknownFields",
            "err.Error",
            "encoder.SetEscapeHTML"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "bytes.NewBuffer",
            "buffer.Bytes",
            "usererror.BadRequestf",
            "buffer.Grow",
            "decoder.Decode",
            "encoder.Encode",
            "len",
            "bytes.NewReader",
            "decoder.DisallowUnknownFields",
            "err.Error",
            "encoder.SetEscapeHTML"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "harness/gitness",
        "function_declaration": "func (c *Controller) getRepoCheckAccess(ctx context.Context,\n\tsession *auth.Session, repoRef string, reqPermission enum.Permission,\n) (*types.Repository, error)",
        "start_line": "59",
        "end_line": "76",
        "file_path": "app/api/controller/check/controller.go",
        "docstring": "This function retrieves a repository and checks access permissions for a given session. It first validates the repository reference. If valid, it fetches the repository using the reference. It then checks the required permissions for the session on the repository. If any step fails, it returns an error; otherwise, it returns the repository.",
        "language": "Go",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "39430d5f99b6",
        "ground_truth": "func (c *Controller) getRepoCheckAccess(ctx context.Context,\n session *auth.Session, repoRef string, reqPermission enum.Permission,\n) (*types.Repository, error) {\n if repoRef == \"\" {\n  return nil, usererror.BadRequest(\"A valid repository reference must be provided.\")\n }\n  repo, err := c.repoStore.FindByRef(ctx, repoRef)\n if err != nil {\n  return nil, fmt.Errorf(\"failed to find repository: %w\", err)\n }\n  if err = apiauth.CheckRepo(ctx, c.authorizer, session, repo, reqPermission); err != nil {\n  return nil, fmt.Errorf(\"access check failed: %w\", err)\n }\n  return repo, nil\n}",
        "import_statements": [
            "import (\n\t\"context\"\n\t\"fmt\"\n\n\tapiauth \"github.com/harness/gitness/app/api/auth\"\n\t\"github.com/harness/gitness/app/api/usererror\"\n\t\"github.com/harness/gitness/app/auth\"\n\t\"github.com/harness/gitness/app/auth/authz\"\n\t\"github.com/harness/gitness/app/store\"\n\t\"github.com/harness/gitness/git\"\n\t\"github.com/harness/gitness/store/database/dbtx\"\n\t\"github.com/harness/gitness/types\"\n\t\"github.com/harness/gitness/types/enum\"\n)"
        ],
        "reference_api": [
            "apiauth.CheckRepo",
            "usererror.BadRequest",
            "c.repoStore.FindByRef",
            "fmt.Errorf"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "apiauth.CheckRepo",
            "usererror.BadRequest",
            "c.repoStore.FindByRef"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "harness/gitness",
        "function_declaration": "func ProvideCheckSanitizers() map[enum.CheckPayloadKind]func(in *ReportInput, s *auth.Session) error",
        "start_line": "24",
        "end_line": "36",
        "file_path": "app/api/controller/check/sanitizers.go",
        "docstring": "This function provides a map of check sanitizers for different payload kinds. It initializes the map, assigns specific sanitizers for empty, raw, markdown, and pipeline payload kinds, and returns the map. Markdown and raw payloads use the same sanitizer.",
        "language": "Go",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "064193efe809",
        "ground_truth": "func ProvideCheckSanitizers() map[enum.CheckPayloadKind]func(in *ReportInput, s *auth.Session) error {\n registeredCheckSanitizers := make(map[enum.CheckPayloadKind]func(in *ReportInput, s *auth.Session) error)\n  registeredCheckSanitizers[enum.CheckPayloadKindEmpty] = createEmptyPayloadSanitizer()\n  registeredCheckSanitizers[enum.CheckPayloadKindRaw] = createRawPayloadSanitizer()\n  // Markdown and Raw are the same.\n registeredCheckSanitizers[enum.CheckPayloadKindMarkdown] = registeredCheckSanitizers[enum.CheckPayloadKindRaw]\n  registeredCheckSanitizers[enum.CheckPayloadKindPipeline] = createPipelinePayloadSanitizer()\n return registeredCheckSanitizers\n}",
        "import_statements": [
            "import (\n\t\"github.com/harness/gitness/app/api/usererror\"\n\t\"github.com/harness/gitness/app/auth\"\n\t\"github.com/harness/gitness/types\"\n\t\"github.com/harness/gitness/types/enum\"\n)"
        ],
        "reference_api": [
            "createEmptyPayloadSanitizer",
            "createPipelinePayloadSanitizer",
            "make",
            "createRawPayloadSanitizer"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "createEmptyPayloadSanitizer",
                "code": "func createEmptyPayloadSanitizer() func(in *ReportInput, _ *auth.Session) error {\n\treturn func(in *ReportInput, _ *auth.Session) error {\n\t\t// the default payload kind (empty) does not support the payload data: clear it here\n\t\tin.Payload.Version = \"\"\n\t\tin.Payload.Data = []byte(\"{}\")\n\n\t\tif in.Link == \"\" { // the link is mandatory as there is nothing in the payload\n\t\t\treturn usererror.BadRequest(\"Link is missing\")\n\t\t}\n\n\t\treturn nil\n\t}\n}"
            },
            {
                "name": "createPipelinePayloadSanitizer",
                "code": "func createPipelinePayloadSanitizer() func(in *ReportInput, _ *auth.Session) error {\n\treturn func(_ *ReportInput, _ *auth.Session) error {\n\t\treturn usererror.BadRequest(\"Kind cannot be pipeline for external checks\")\n\t}\n}"
            },
            {
                "name": "createRawPayloadSanitizer",
                "code": "func createRawPayloadSanitizer() func(in *ReportInput, _ *auth.Session) error {\n\treturn func(in *ReportInput, _ *auth.Session) error {\n\t\t// the text payload kinds (raw and markdown) do not support the version\n\t\tif in.Payload.Version != \"\" {\n\t\t\treturn usererror.BadRequestf(\"Payload version must be empty for the payload kind '%s'\",\n\t\t\t\tin.Payload.Kind)\n\t\t}\n\n\t\tpayloadDataJSON, err := SanitizeJSONPayload(in.Payload.Data, &types.CheckPayloadText{})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tin.Payload.Data = payloadDataJSON\n\n\t\treturn nil\n\t}\n}"
            }
        ],
        "third_party": [
            "make"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function Buffer:attach_to_renderer(on_render)",
        "start_line": "49",
        "end_line": "61",
        "file_path": "lua/vgit/core/Buffer.lua",
        "docstring": "This function attaches a buffer to a renderer, allowing the rendering logic to be injected and changed at runtime. It sets the on_render logic in the buffer's state. If the buffer is not already attached to the screen, it attaches the buffer to the renderer and updates the state to reflect this. The function returns the buffer instance.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ea30e48c1ed0",
        "ground_truth": "function Buffer:attach_to_renderer(on_render)\n  -- Method to inject on_render logic and only state it.\n  -- This allows us to change rendering logic during run time.\n  local state = self.state\n  state.on_render = on_render\n   if not state.is_attached_to_screen then\n    renderer.attach(self)\n    state.is_attached_to_screen = true\n  end\n   return self\nend",
        "import_statements": [
            "require('vgit.core.fs')",
            "require('vgit.core.loop')",
            "require('vgit.core.event')",
            "require('vgit.core.Object')",
            "require('vgit.core.keymap')",
            "require('vgit.core.Watcher')",
            "require('vgit.core.console')",
            "require('vgit.core.renderer')",
            "require('vgit.core.Namespace')"
        ],
        "reference_api": [
            "renderer.attach"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "renderer.attach"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function Buffer:watch(callback)",
        "start_line": "97",
        "end_line": "114",
        "file_path": "lua/vgit/core/Buffer.lua",
        "docstring": "This function sets up a file watcher for a buffer. It watches the buffer's filename and runs a callback function when changes are detected. If an error occurs during watching, it logs an error message. If the buffer is valid and a callback is provided, it executes the callback function.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "6c7e189a8448",
        "ground_truth": "function Buffer:watch(callback)\n  self.watcher:watch_file(\n    self.filename,\n    loop.coroutine(function(err)\n      if err then\n        console.debug.error(string.format('Error encountered while watching %s', self.filename))\n        return\n      end\n       loop.free_textlock()\n      if self and self:is_valid() and callback then\n        callback()\n      end\n    end)\n  )\n   return self\nend",
        "import_statements": [
            "require('vgit.core.fs')",
            "require('vgit.core.loop')",
            "require('vgit.core.event')",
            "require('vgit.core.Object')",
            "require('vgit.core.keymap')",
            "require('vgit.core.Watcher')",
            "require('vgit.core.console')",
            "require('vgit.core.renderer')",
            "require('vgit.core.Namespace')"
        ],
        "reference_api": [
            "loop.free_textlock",
            "self:is_valid",
            "loop.coroutine",
            "console.debug.error",
            "callback",
            "string.format",
            "self.watcher:watch_file"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "callback",
                "code": "callback"
            }
        ],
        "third_party": [
            "loop.free_textlock",
            "self:is_valid",
            "loop.coroutine",
            "console.debug.error",
            "self.watcher:watch_file"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function Color:to_hex()",
        "start_line": "15",
        "end_line": "29",
        "file_path": "lua/vgit/core/Color.lua",
        "docstring": "This function converts a color object to its hexadecimal representation. If the hex value is already cached, it returns it. Otherwise, it retrieves the color's specification, determines the relevant attribute (foreground or background), and attempts to get the highlight color using Neovim's API. If successful, it converts the color to a hex string and caches it. Finally, it returns the hex value.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "f997559f2b0b",
        "ground_truth": "function Color:to_hex()\n  if self.hex then\n    return self.hex\n  end\n   local spec = self.spec\n  local attribute = spec.attribute == 'fg' and 'foreground' or 'background'\n  local success, hl = pcall(vim.api.nvim_get_hl_by_name, spec.name, true)\n   if success and hl and hl[attribute] then\n    self.hex = '#' .. bit.tohex(hl[attribute], 6)\n  end\n   return self.hex\nend",
        "import_statements": [
            "require('vgit.core.Rgb')",
            "require('vgit.vendor.bit')",
            "require('vgit.core.Object')"
        ],
        "reference_api": [
            "pcall",
            "bit.tohex"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "bit.tohex"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function Namespace:add_pattern_highlight(buffer, pattern, hl)",
        "start_line": "23",
        "end_line": "45",
        "file_path": "lua/vgit/core/Namespace.lua",
        "docstring": "This function adds pattern-based highlights to a buffer. It retrieves the buffer's lines and iterates through each line, searching for occurrences of the specified pattern. For each match found, it applies the specified highlight to the buffer. The function returns the namespace object.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "cea42cbdd427",
        "ground_truth": "function Namespace:add_pattern_highlight(buffer, pattern, hl)\n  local lines = buffer:get_lines()\n   for i = 1, #lines do\n    local line = lines[i]\n     local j = 0\n     while true do\n      local from, to = line:find(pattern, j + 1)\n       j = from\n       if from == nil then\n        break\n      end\n       self:add_highlight(buffer, hl, i - 1, from - 1, to)\n    end\n  end\n   return self\nend",
        "import_statements": [
            "require('vgit.core.utils')",
            "require('vgit.core.Object')",
            "require('vgit.settings.signs')"
        ],
        "reference_api": [
            "line:find",
            "buffer:get_lines",
            "self:add_highlight"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"buffer:get_lines",
                "code":"function Buffer:get_lines(top, bot)\n  top = top or 0\n  bot = bot or -1\n\n  return vim.api.nvim_buf_get_lines(self.bufnr, top, bot, false)\nend"
            },
            {
                "name":"self:add_highlight",
                "code":"function Buffer:add_highlight(hl, row, col_top, col_end)\n  self.namespace:add_highlight(self, hl, row, col_top, col_end)\n\n  return self\nend"
            }
        ],
        "third_party": [
            "line:find",
            "buffer:get_lines",
            "self:add_highlight"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function Namespace:transpose_virtual_text(buffer, text, hl, row, col, pos, priority)",
        "start_line": "47",
        "end_line": "59",
        "file_path": "lua/vgit/core/Namespace.lua",
        "docstring": "This function adds virtual text to a specific position in a buffer. It calculates a unique ID based on the row and column, then sets an extmark with the given text, highlight, position, and priority using Neovim's API. The function returns the generated ID.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "3dbe4c91dce7",
        "ground_truth": "function Namespace:transpose_virtual_text(buffer, text, hl, row, col, pos, priority)\n  local id = row + 1 + col\n   pcall(vim.api.nvim_buf_set_extmark, buffer.bufnr, self.ns_id, row, col, {\n    id = id,\n    virt_text = { { text, hl } },\n    virt_text_pos = pos or 'overlay',\n    hl_mode = 'combine',\n    priority = priority,\n  })\n   return id\nend",
        "import_statements": [
            "require('vgit.core.utils')",
            "require('vgit.core.Object')",
            "require('vgit.settings.signs')"
        ],
        "reference_api": [
            "pcall"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function Spawn:parse_result(output, callback)",
        "start_line": "8",
        "end_line": "30",
        "file_path": "lua/vgit/core/Spawn.lua",
        "docstring": "This function processes an output string, invoking a callback function for each line. It concatenates the output into a single string, iterates through each character, and collects characters into lines. When a newline character is encountered, it triggers the callback with the current line and resets the line. After processing, it calls the callback with any remaining line.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "30527915f47f",
        "ground_truth": "function Spawn:parse_result(output, callback)\n  if not callback then\n    return\n  end\n   local line = {}\n  output = table.concat(output)\n   for i = 1, #output do\n    local char = output:sub(i, i)\n     if char == '\\n' then\n      callback(table.concat(line))\n      line = {}\n    else\n      line[#line + 1] = char\n    end\n  end\n   if #line > 0 then\n    callback(table.concat(line))\n  end\nend",
        "import_statements": [
            "require('vgit.core.loop')",
            "require('vgit.core.Object')"
        ],
        "reference_api": [
            "callback",
            "output:sub",
            "table.concat"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "callback",
                "code": "callback"
            }
        ],
        "third_party": [
            "output:sub"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function Watcher:watch_file(path, handler)",
        "start_line": "15",
        "end_line": "29",
        "file_path": "lua/vgit/core/Watcher.lua",
        "docstring": "This function sets up a file watcher for a specified path. If a watcher already exists, it returns the existing watcher. Otherwise, it creates a new file system event watcher using Neovim's loop, starts watching the specified path with the given handler, and returns the watcher instance.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "e93b09a412bc",
        "ground_truth": "function Watcher:watch_file(path, handler)\n  if self.watcher then\n    return self.watcher\n  end\n   self.watcher = vim.loop.new_fs_event()\n   vim.loop.fs_event_start(self.watcher, path, {\n    watch_entry = false,\n    stat = false,\n    recursive = false,\n  }, handler)\n   return self\nend",
        "import_statements": [
            "require('vgit.core.loop')",
            "require('vgit.core.Object')"
        ],
        "reference_api": [
            "vim.loop.new_fs_event",
            "vim.loop.fs_event_start"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "vim.loop.new_fs_event",
            "vim.loop.fs_event_start"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function GitBuffer:live_hunks()",
        "start_line": "34",
        "end_line": "61",
        "file_path": "lua/vgit/git/GitBuffer.lua",
        "docstring": "This function processes live hunks for a Git buffer. It retrieves the buffer lines and calculates the hunks using the git object. If there's an error, it returns the error. Otherwise, it sets up signs for each line in the hunks, categorizing them by type and assigning priorities. It updates the buffer's signs and returns the hunks.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1bd57114d46c",
        "ground_truth": "function GitBuffer:live_hunks()\n  local lines = self:get_lines()\n  local err, hunks = self.git_object:live_hunks(lines)\n   if err then return err end\n   local sign_types = signs_setting:get('usage').main\n  local sign_priority = signs_setting:get('priority')\n  local sign_group = self.namespace:get_sign_ns_id(self)\n   self.signs = {}\n  for i = 1, #hunks do\n    local hunk = hunks[i]\n    for j = hunk.top, hunk.bot do\n      local lnum = (hunk.type == 'remove' and j == 0) and 1 or j\n      self.signs[lnum] = {\n        id = lnum,\n        lnum = lnum,\n        buffer = self.bufnr,\n        group = sign_group,\n        name = sign_types[hunk.type],\n        priority = sign_priority,\n      }\n    end\n  end\n   return nil, hunks\nend",
        "import_statements": [
            "require('vgit.core.Buffer')",
            "require('vgit.git.GitObject')",
            "require('vgit.settings.signs')"
        ],
        "reference_api": [
            "self.git_object:live_hunks",
            "signs_setting:get",
            "self:get_lines",
            "self.namespace:get_sign_ns_id"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.git_object:live_hunks",
            "signs_setting:get",
            "self:get_lines",
            "self.namespace:get_sign_ns_id"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "tanvirtin/vgit.nvim",
        "function_declaration": "function GitObject:stage_hunk_from_patch(patch)",
        "start_line": "71",
        "end_line": "83",
        "file_path": "lua/vgit/git/GitObject.lua",
        "docstring": "This function stages a hunk from a patch for a Git object. It creates a temporary file, writes the patch content to it, and calls the Git command to stage the hunk using the temporary file. After staging, it removes the temporary file and returns any error that occurred during the process.",
        "language": "Lua",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "48ec5c554dbd",
        "ground_truth": "function GitObject:stage_hunk_from_patch(patch)\n  local patch_filename = fs.tmpname()\n  loop.free_textlock()\n  fs.write_file(patch_filename, patch)\n   loop.free_textlock()\n  local err = self.git:stage_hunk_from_patch(patch_filename)\n   loop.free_textlock()\n  fs.remove_file(patch_filename)\n   return err\nend",
        "import_statements": [
            "require('vgit.core.fs')",
            "require('vgit.core.loop')",
            "require('vgit.git.cli.Git')",
            "require('vgit.core.utils')",
            "require('vgit.core.Object')",
            "require('vgit.git.cli.models.Hunk')",
            "require('vgit.git.cli.models.Patch')"
        ],
        "reference_api": [
            "loop.free_textlock",
            "self.git:stage_hunk_from_patch",
            "fs.remove_file",
            "fs.write_file",
            "fs.tmpname"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"loop.free_textlock",
                "code":"function loop.free_textlock(times)\n  for _ = 1, times or 1 do\n    loop.suspend_textlock()\n  end\n\n  return loop\nend"
            },
            {
                "name": "fs.remove_file",
                "code":"function fs.remove_file(filepath) return os.remove(filepath) end"
            },
            {
                "name":"fs.write_file",
                "code":"function fs.write_file(filepath, lines)\n  local f = io.open(filepath, 'wb')\n\n  for i = 1, #lines do\n    f:write(lines[i])\n    f:write('\\n')\n  end\n\n  f:close()\n\n  return fs\nend"
            }

        ],
        "third_party": [
            "fs.remove_file",
            "fs.write_file",
            "fs.tmpname"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "public Token getAccessToken(Token requestToken, Verifier verifier)",
        "start_line": "29",
        "end_line": "36",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/api/credentials/BitbucketOAuthService.java",
        "docstring": "This function retrieves an access token using a request token and verifier. It creates an OAuth request to the access token endpoint, adds the necessary authentication header and body parameters, sends the request, and extracts the access token from the response body using the API's access token extractor.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "695fd7138742",
        "ground_truth": "public Token getAccessToken(Token requestToken, Verifier verifier) {\n    OAuthRequest request = new OAuthRequest(api.getAccessTokenVerb(), api.getAccessTokenEndpoint());\n    request.addHeader(OAuthConstants.HEADER, this.getHttpBasicAuthHeaderValue());\n    request.addBodyParameter(GRANT_TYPE_KEY, GRANT_TYPE_CLIENT_CREDENTIALS);\n    Response response = request.send();\n    return api.getAccessTokenExtractor().extract(response.getBody());\n}",
        "import_statements": [
            "import java.nio.charset.StandardCharsets;",
            "import org.eclipse.jgit.util.Base64;",
            "import org.scribe.builder.api.DefaultApi20;",
            "import org.scribe.model.OAuthConfig;",
            "import org.scribe.model.OAuthConstants;",
            "import org.scribe.model.OAuthRequest;",
            "import org.scribe.model.Response;",
            "import org.scribe.model.Token;",
            "import org.scribe.model.Verifier;",
            "import org.scribe.oauth.OAuth20ServiceImpl;"
        ],
        "reference_api": [
            "addHeader",
            "getAccessTokenEndpoint",
            "getHttpBasicAuthHeaderValue",
            "getAccessTokenVerb",
            "getBody",
            "send",
            "extract",
            "addBodyParameter",
            "getAccessTokenExtractor"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getHttpBasicAuthHeaderValue",
                "code": "private String getHttpBasicAuthHeaderValue() {\n        String authStr = config.getApiKey() + \":\" + config.getApiSecret();\n\n        return \"Basic \" + Base64.encodeBytes(authStr.getBytes(StandardCharsets.UTF_8));\n    }"
            }
        ],
        "third_party": [
            "addHeader",
            "getAccessTokenEndpoint",
            "getAccessTokenVerb",
            "getBody",
            "send",
            "extract",
            "addBodyParameter",
            "getAccessTokenExtractor"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "public void configureContext(HttpClientContext context, HttpHost host)",
        "start_line": "71",
        "end_line": "79",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/api/credentials/BitbucketUsernamePasswordAuthenticator.java",
        "docstring": "This function configures the HTTP client context with authentication details for a given host. It sets up a credentials provider with the specified credentials, adds the host to an authentication cache using the Basic authentication scheme, and assigns these to the context. Additionally, it logs the action of adding the host to the auth cache.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "69b663fe4629",
        "ground_truth": "public void configureContext(HttpClientContext context, HttpHost host) {\n    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n    credentialsProvider.setCredentials(new AuthScope(host), httpCredentials);\n    AuthCache authCache = new BasicAuthCache();\n    LOGGER.log(Level.FINE,\"Add host={0} to authCache.\", host);\n    authCache.put(host, new BasicScheme());\n    context.setCredentialsProvider(credentialsProvider);\n    context.setAuthCache(authCache);\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketAuthenticator;",
            "import com.cloudbees.plugins.credentials.CredentialsScope;",
            "import com.cloudbees.plugins.credentials.common.StandardUsernameCredentials;",
            "import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials;",
            "import com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl;",
            "import java.util.logging.Level;",
            "import java.util.logging.Logger;",
            "import org.apache.http.HttpHost;",
            "import org.apache.http.auth.AuthScope;",
            "import org.apache.http.auth.UsernamePasswordCredentials;",
            "import org.apache.http.client.AuthCache;",
            "import org.apache.http.client.CredentialsProvider;",
            "import org.apache.http.client.protocol.HttpClientContext;",
            "import org.apache.http.impl.auth.BasicScheme;",
            "import org.apache.http.impl.client.BasicAuthCache;",
            "import org.apache.http.impl.client.BasicCredentialsProvider;"
        ],
        "reference_api": [
            "log",
            "setCredentials",
            "setAuthCache",
            "setCredentialsProvider",
            "put"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "log",
            "setCredentials",
            "setAuthCache",
            "setCredentialsProvider",
            "put"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "public static String buildUrl(@NonNull AvatarCacheSource source, @NonNull String size)",
        "start_line": "151",
        "end_line": "166",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/avatars/AvatarCache.java",
        "docstring": "This function builds a URL for an avatar image based on the provided source and size. It retrieves the Jenkins instance and the AvatarCache extension. If the cache instance is null, it throws an error. It generates a cache key, seeds the cache, and constructs the URL using the Jenkins root URL and the encoded key with the specified size. If UTF-8 encoding is unsupported, it throws an error.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7e19e17aca40",
        "ground_truth": "public static String buildUrl(@NonNull AvatarCacheSource source, @NonNull String size) {\n    Jenkins j = Jenkins.get();\n    AvatarCache instance = ExtensionList.lookup(RootAction.class).get(AvatarCache.class);\n    if (instance == null) {\n        throw new AssertionError();\n    }\n    String key = Util.getDigestOf(AvatarCache.class.getName() + source.hashKey());\n    // seed the cache\n    instance.getCacheEntry(key, source);\n    try {\n        return j.getRootUrlFromRequest() + instance.getUrlName() + \"/\" + Util.rawEncode(key) + \".png?size=\"\n                + URLEncoder.encode(size, StandardCharsets.UTF_8.name());\n    } catch (UnsupportedEncodingException e) {\n        throw new AssertionError(\"JLS specification mandates support for UTF-8 encoding\", e);\n    }\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.avatars.AvatarCacheSource.AvatarImage;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import edu.umd.cs.findbugs.annotations.Nullable;",
            "import hudson.Extension;",
            "import hudson.ExtensionList;",
            "import hudson.Util;",
            "import hudson.model.RootAction;",
            "import hudson.model.UnprotectedRootAction;",
            "import hudson.util.DaemonThreadFactory;",
            "import hudson.util.HttpResponses;",
            "import hudson.util.NamingThreadFactory;",
            "import java.awt.Color;",
            "import java.awt.Graphics2D;",
            "import java.awt.image.BufferedImage;",
            "import java.io.ByteArrayOutputStream;",
            "import java.io.IOException;",
            "import java.io.UnsupportedEncodingException;",
            "import java.net.URLEncoder;",
            "import java.nio.charset.StandardCharsets;",
            "import java.security.MessageDigest;",
            "import java.security.NoSuchAlgorithmException;",
            "import java.util.Iterator;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.concurrent.Callable;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import java.util.concurrent.ConcurrentMap;",
            "import java.util.concurrent.ExecutionException;",
            "import java.util.concurrent.Future;",
            "import java.util.concurrent.LinkedBlockingQueue;",
            "import java.util.concurrent.ThreadPoolExecutor;",
            "import java.util.concurrent.TimeUnit;",
            "import javax.imageio.ImageIO;",
            "import javax.servlet.ServletException;",
            "import javax.servlet.http.HttpServletResponse;",
            "import jenkins.model.Jenkins;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.kohsuke.stapler.HttpResponse;",
            "import org.kohsuke.stapler.QueryParameter;",
            "import org.kohsuke.stapler.StaplerRequest;",
            "import org.kohsuke.stapler.StaplerResponse;",
            "import static java.awt.RenderingHints.KEY_ALPHA_INTERPOLATION;",
            "import static java.awt.RenderingHints.KEY_INTERPOLATION;",
            "import static java.awt.RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY;",
            "import static java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC;"
        ],
        "reference_api": [
            "getName",
            "encode",
            "name",
            "getRootUrlFromRequest",
            "rawEncode",
            "getDigestOf",
            "lookup",
            "get",
            "hashKey",
            "getUrlName",
            "getCacheEntry"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getUrlName",
                "code": "@Override\n    public String getUrlName() {\n        return ActionURI;\n    }"
            },
            {
                "name": "getCacheEntry",
                "code": "@Nullable\n    private CacheEntry getCacheEntry(@NonNull final String key, @Nullable final AvatarCacheSource source) {\n        CacheEntry entry = cache.get(key);\n        if (entry == null) {\n            synchronized (serviceLock) {\n                entry = cache.get(key);\n                if (entry == null) {\n                    if (source == null) {\n                        return null;\n                    }\n                    entry = new CacheEntry(source, service.submit(new FetchImage(source)));\n                    cache.put(key, entry);\n                }\n            }\n        } else {\n            if (entry.isStale()) {\n                synchronized (serviceLock) {\n                    if (!entry.pending()) {\n                        entry.setFuture(service.submit(new FetchImage(entry.source)));\n                    }\n                }\n            }\n        }\n        entry.touch();\n        if (iterator == null || !iterator.hasNext()) {\n            synchronized (serviceLock) {\n                if (iterator == null || !iterator.hasNext()) {\n                    iterator = cache.entrySet().iterator();\n                }\n            }\n        } else {\n            synchronized (iterator) {\n                // process one entry in the cache each access\n                if (iterator.hasNext()) {\n                    Map.Entry<String, CacheEntry> next = iterator.next();\n                    if (next.getValue().isUnused()) {\n                        iterator.remove();\n                    }\n                } else {\n                    iterator = null;\n                }\n            }\n        }\n        return entry;\n    }"
            }
        ],
        "third_party": [
            "getName",
            "encode",
            "name",
            "getRootUrlFromRequest",
            "rawEncode",
            "getDigestOf",
            "lookup",
            "get",
            "hashKey"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "private CacheEntry(AvatarCacheSource source, BufferedImage image, long lastModified)",
        "start_line": "493",
        "end_line": "503",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/avatars/AvatarCache.java",
        "docstring": "This constructor initializes a CacheEntry object with a source, image, and last modified timestamp. If the image exceeds 128x128 pixels, it scales the image down to 128x128 to limit storage size. It sets the last modified timestamp to the current time if the provided value is negative.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "eb919c836652",
        "ground_truth": "private CacheEntry(AvatarCacheSource source, BufferedImage image, long lastModified) {\n    this.source = source;\n    if (image.getHeight() > 128 || image.getWidth() > 128) {\n        // limit the amount of storage\n        this.image = scaleImage(image, 128);\n        image.flush();\n    } else {\n        this.image = image;\n    }\n    this.lastModified = lastModified < 0 ? System.currentTimeMillis() : lastModified;\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.avatars.AvatarCacheSource.AvatarImage;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import edu.umd.cs.findbugs.annotations.Nullable;",
            "import hudson.Extension;",
            "import hudson.ExtensionList;",
            "import hudson.Util;",
            "import hudson.model.RootAction;",
            "import hudson.model.UnprotectedRootAction;",
            "import hudson.util.DaemonThreadFactory;",
            "import hudson.util.HttpResponses;",
            "import hudson.util.NamingThreadFactory;",
            "import java.awt.Color;",
            "import java.awt.Graphics2D;",
            "import java.awt.image.BufferedImage;",
            "import java.io.ByteArrayOutputStream;",
            "import java.io.IOException;",
            "import java.io.UnsupportedEncodingException;",
            "import java.net.URLEncoder;",
            "import java.nio.charset.StandardCharsets;",
            "import java.security.MessageDigest;",
            "import java.security.NoSuchAlgorithmException;",
            "import java.util.Iterator;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.concurrent.Callable;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import java.util.concurrent.ConcurrentMap;",
            "import java.util.concurrent.ExecutionException;",
            "import java.util.concurrent.Future;",
            "import java.util.concurrent.LinkedBlockingQueue;",
            "import java.util.concurrent.ThreadPoolExecutor;",
            "import java.util.concurrent.TimeUnit;",
            "import javax.imageio.ImageIO;",
            "import javax.servlet.ServletException;",
            "import javax.servlet.http.HttpServletResponse;",
            "import jenkins.model.Jenkins;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.kohsuke.stapler.HttpResponse;",
            "import org.kohsuke.stapler.QueryParameter;",
            "import org.kohsuke.stapler.StaplerRequest;",
            "import org.kohsuke.stapler.StaplerResponse;",
            "import static java.awt.RenderingHints.KEY_ALPHA_INTERPOLATION;",
            "import static java.awt.RenderingHints.KEY_INTERPOLATION;",
            "import static java.awt.RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY;",
            "import static java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC;"
        ],
        "reference_api": [
            "getWidth",
            "currentTimeMillis",
            "flush",
            "getHeight",
            "scaleImage"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "scaleImage",
                "code": "@NonNull\n    private static BufferedImage scaleImage(@NonNull BufferedImage src, int size) {\n        BufferedImage imageSrc = src;\n        int newWidth;\n        int newHeight;\n        if (src.getWidth() > src.getHeight()) {\n            newWidth = size;\n            newHeight = size * src.getHeight() / src.getWidth();\n        } else if (src.getHeight() > src.getWidth()) {\n            newWidth = size * src.getWidth() / src.getHeight();\n            newHeight = size;\n        } else {\n            newWidth = newHeight = size;\n        }\n        boolean flushSrc = false;\n        if (newWidth <= src.getWidth() * 6 / 7 && newHeight <= src.getWidth() * 6 / 7) {\n            // when scaling down, you get better image quality if you scale down in multiple\n            // rounds\n            // see https://community.oracle.com/docs/DOC-983611\n            // we scale each round by 6/7 = ~85% as this gives nicer looking images\n            int curWidth = src.getWidth();\n            int curHeight = src.getHeight();\n            // we want to break the rounds and do the final round and centre when the src\n            // image is this size\n            final int penultimateSize = size * 7 / 6;\n            while (true) {\n                curWidth = curWidth - curWidth / 7;\n                curHeight = curHeight - curHeight / 7;\n                if (curWidth <= penultimateSize && curHeight <= penultimateSize) {\n                    // we are within one round of target size let's go\n                    break;\n                }\n                BufferedImage tmp = new BufferedImage(curWidth, curHeight, BufferedImage.TYPE_INT_ARGB);\n                Graphics2D g = tmp.createGraphics();\n                try {\n                    // important, if we don't set these two hints then scaling will not work\n                    // headless\n                    g.setRenderingHint(KEY_INTERPOLATION, VALUE_INTERPOLATION_BICUBIC);\n                    g.setRenderingHint(KEY_ALPHA_INTERPOLATION, VALUE_ALPHA_INTERPOLATION_QUALITY);\n                    g.scale(((double) curWidth) / src.getWidth(), ((double) curHeight) / src.getHeight());\n                    g.drawImage(src, 0, 0, null);\n                } finally {\n                    g.dispose();\n                }\n                if (flushSrc) {\n                    imageSrc.flush();\n                }\n                imageSrc = tmp;\n                flushSrc = true;\n            }\n        }\n        BufferedImage tmp = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g = tmp.createGraphics();\n        try {\n            // important, if we don't set these two hints then scaling will not work\n            // headless\n            g.setRenderingHint(KEY_INTERPOLATION, VALUE_INTERPOLATION_BICUBIC);\n            g.setRenderingHint(KEY_ALPHA_INTERPOLATION, VALUE_ALPHA_INTERPOLATION_QUALITY);\n            g.scale(((double) newWidth) / imageSrc.getWidth(), ((double) newHeight) / imageSrc.getHeight());\n            g.drawImage(imageSrc, (size - newWidth) / 2, (size - newHeight) / 2, null);\n        } finally {\n            g.dispose();\n        }\n        if (flushSrc) {\n            imageSrc.flush();\n        }\n        imageSrc = tmp;\n        return imageSrc;\n    }"
            }
        ],
        "third_party": [
            "getWidth",
            "currentTimeMillis",
            "flush",
            "getHeight"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "private synchronized boolean pending()",
        "start_line": "526",
        "end_line": "548",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/avatars/AvatarCache.java",
        "docstring": "This synchronized function checks the status of a future cache entry. If the future is null, it returns false. If the future is done, it retrieves the cache entry, updates the image and last modified time, and sets the future to null. If the future is not done or an exception occurs, it returns true.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ba8fe511b4aa",
        "ground_truth": "private synchronized boolean pending() {\n    if (future == null) {\n        return false;\n    }\n    if (future.isDone()) {\n        try {\n            CacheEntry pending = future.get();\n            if (pending.image != null && image != null) {\n                image.flush();\n            }\n            if (pending.image != null) {\n                image = pending.image;\n            }\n            lastModified = pending.lastModified;\n            future = null;\n            return false;\n        } catch (InterruptedException | ExecutionException e) {\n            // ignore\n        }\n    }\n    return true;\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.avatars.AvatarCacheSource.AvatarImage;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import edu.umd.cs.findbugs.annotations.Nullable;",
            "import hudson.Extension;",
            "import hudson.ExtensionList;",
            "import hudson.Util;",
            "import hudson.model.RootAction;",
            "import hudson.model.UnprotectedRootAction;",
            "import hudson.util.DaemonThreadFactory;",
            "import hudson.util.HttpResponses;",
            "import hudson.util.NamingThreadFactory;",
            "import java.awt.Color;",
            "import java.awt.Graphics2D;",
            "import java.awt.image.BufferedImage;",
            "import java.io.ByteArrayOutputStream;",
            "import java.io.IOException;",
            "import java.io.UnsupportedEncodingException;",
            "import java.net.URLEncoder;",
            "import java.nio.charset.StandardCharsets;",
            "import java.security.MessageDigest;",
            "import java.security.NoSuchAlgorithmException;",
            "import java.util.Iterator;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.concurrent.Callable;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import java.util.concurrent.ConcurrentMap;",
            "import java.util.concurrent.ExecutionException;",
            "import java.util.concurrent.Future;",
            "import java.util.concurrent.LinkedBlockingQueue;",
            "import java.util.concurrent.ThreadPoolExecutor;",
            "import java.util.concurrent.TimeUnit;",
            "import javax.imageio.ImageIO;",
            "import javax.servlet.ServletException;",
            "import javax.servlet.http.HttpServletResponse;",
            "import jenkins.model.Jenkins;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.kohsuke.stapler.HttpResponse;",
            "import org.kohsuke.stapler.QueryParameter;",
            "import org.kohsuke.stapler.StaplerRequest;",
            "import org.kohsuke.stapler.StaplerResponse;",
            "import static java.awt.RenderingHints.KEY_ALPHA_INTERPOLATION;",
            "import static java.awt.RenderingHints.KEY_INTERPOLATION;",
            "import static java.awt.RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY;",
            "import static java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC;"
        ],
        "reference_api": [
            "isDone",
            "get",
            "flush"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "isDone",
            "get",
            "flush"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node)\n                throws IOException, ServletException",
        "start_line": "588",
        "end_line": "606",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/avatars/AvatarCache.java",
        "docstring": "This function generates an HTTP response with a PNG image. It writes the image to a byte array output stream and flushes the image if required. It sets appropriate headers for caching and content type, then writes the byte array to the response output stream.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "2b13277fdd7f",
        "ground_truth": "public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node)\n        throws IOException, ServletException {\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    try {\n        ImageIO.write(image, \"png\", bos);\n    } finally {\n        if (flushImage) {\n            image.flush();\n        }\n    }\n    final byte[] bytes = bos.toByteArray();\n    if (lastModified > 0) {\n        rsp.addDateHeader(\"Last-Modified\", lastModified);\n    }\n    rsp.addHeader(\"Cache-control\", cacheControl);\n    rsp.setContentType(\"image/png\");\n    rsp.setContentLength(bytes.length);\n    rsp.getOutputStream().write(bytes);\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.avatars.AvatarCacheSource.AvatarImage;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import edu.umd.cs.findbugs.annotations.Nullable;",
            "import hudson.Extension;",
            "import hudson.ExtensionList;",
            "import hudson.Util;",
            "import hudson.model.RootAction;",
            "import hudson.model.UnprotectedRootAction;",
            "import hudson.util.DaemonThreadFactory;",
            "import hudson.util.HttpResponses;",
            "import hudson.util.NamingThreadFactory;",
            "import java.awt.Color;",
            "import java.awt.Graphics2D;",
            "import java.awt.image.BufferedImage;",
            "import java.io.ByteArrayOutputStream;",
            "import java.io.IOException;",
            "import java.io.UnsupportedEncodingException;",
            "import java.net.URLEncoder;",
            "import java.nio.charset.StandardCharsets;",
            "import java.security.MessageDigest;",
            "import java.security.NoSuchAlgorithmException;",
            "import java.util.Iterator;",
            "import java.util.Locale;",
            "import java.util.Map;",
            "import java.util.concurrent.Callable;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import java.util.concurrent.ConcurrentMap;",
            "import java.util.concurrent.ExecutionException;",
            "import java.util.concurrent.Future;",
            "import java.util.concurrent.LinkedBlockingQueue;",
            "import java.util.concurrent.ThreadPoolExecutor;",
            "import java.util.concurrent.TimeUnit;",
            "import javax.imageio.ImageIO;",
            "import javax.servlet.ServletException;",
            "import javax.servlet.http.HttpServletResponse;",
            "import jenkins.model.Jenkins;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.kohsuke.stapler.HttpResponse;",
            "import org.kohsuke.stapler.QueryParameter;",
            "import org.kohsuke.stapler.StaplerRequest;",
            "import org.kohsuke.stapler.StaplerResponse;",
            "import static java.awt.RenderingHints.KEY_ALPHA_INTERPOLATION;",
            "import static java.awt.RenderingHints.KEY_INTERPOLATION;",
            "import static java.awt.RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY;",
            "import static java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC;"
        ],
        "reference_api": [
            "setContentLength",
            "addHeader",
            "toByteArray",
            "write",
            "addDateHeader",
            "getOutputStream",
            "flush",
            "setContentType"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setContentLength",
            "addHeader",
            "toByteArray",
            "write",
            "addDateHeader",
            "getOutputStream",
            "flush",
            "setContentType"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "public BitbucketCloudApiClient(boolean enableCache, int teamCacheDuration, int repositoriesCacheDuration,\n            String owner, String projectKey, String repositoryName, BitbucketAuthenticator authenticator)",
        "start_line": "177",
        "end_line": "207",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/client/BitbucketCloudApiClient.java",
        "docstring": "This constructor initializes a BitbucketCloudApiClient with optional caching and authentication. It sets up cache expiration for team and repositories if caching is enabled. It configures an HTTP client with a keep-alive strategy, connection manager, and retry handler. If an authenticator is provided, it configures the HTTP client and context for authentication. It also sets client proxy parameters before building the HTTP client.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "0bcade75816f",
        "ground_truth": "public BitbucketCloudApiClient(boolean enableCache, int teamCacheDuration, int repositoriesCacheDuration,\n        String owner, String projectKey, String repositoryName, BitbucketAuthenticator authenticator) {\n    this.authenticator = authenticator;\n    this.owner = owner;\n    this.projectKey = projectKey;\n    this.repositoryName = repositoryName;\n    this.enableCache = enableCache;\n    if (enableCache) {\n        cachedTeam.setExpireDuration(teamCacheDuration, MINUTES);\n        cachedRepositories.setExpireDuration(repositoriesCacheDuration, MINUTES);\n    }\n    // Create Http client\n    HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n    httpClientBuilder.setKeepAliveStrategy((__, ___) -> MILLISECONDS.convert(5, SECONDS));\n    httpClientBuilder.setConnectionManager(connectionManager);\n    httpClientBuilder.setConnectionManagerShared(true);\n    httpClientBuilder.setRetryHandler(new StandardHttpRequestRetryHandler());\n    if (authenticator != null) {\n        authenticator.configureBuilder(httpClientBuilder);\n        context = HttpClientContext.create();\n        authenticator.configureContext(context, API_HOST);\n    }\n    setClientProxyParams(\"bitbucket.org\", httpClientBuilder);\n    this.client = httpClientBuilder.build();\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.JsonParser;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApi;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketAuthenticator;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketBuildStatus;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketCloudWorkspace;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketCommit;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketException;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketPullRequest;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketRequestException;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketTeam;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketWebHook;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.credentials.BitbucketUsernamePasswordAuthenticator;",
            "import com.cloudbees.jenkins.plugins.bitbucket.avatars.AvatarCacheSource.AvatarImage;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.branch.BitbucketCloudBranch;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.branch.BitbucketCloudCommit;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.pullrequest.BitbucketPullRequestCommit;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.pullrequest.BitbucketPullRequestCommits;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.pullrequest.BitbucketPullRequestValue;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.pullrequest.BitbucketPullRequests;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.BitbucketCloudRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.BitbucketRepositoryHook;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.BitbucketRepositoryHooks;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.BitbucketRepositorySource;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.PaginatedBitbucketRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.UserRoleInRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.filesystem.BitbucketSCMFile;",
            "import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials;",
            "import com.damnhandy.uri.template.UriTemplate;",
            "import com.damnhandy.uri.template.impl.Operator;",
            "import com.fasterxml.jackson.core.type.TypeReference;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.ProxyConfiguration;",
            "import hudson.Util;",
            "import java.awt.image.BufferedImage;",
            "import java.io.BufferedInputStream;",
            "import java.io.ByteArrayOutputStream;",
            "import java.io.FileNotFoundException;",
            "import java.io.IOException;",
            "import java.io.InputStream;",
            "import java.io.UnsupportedEncodingException;",
            "import java.net.InetSocketAddress;",
            "import java.net.Proxy;",
            "import java.net.URI;",
            "import java.net.URISyntaxException;",
            "import java.nio.charset.StandardCharsets;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.Comparator;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.concurrent.Callable;",
            "import java.util.logging.Level;",
            "import java.util.logging.Logger;",
            "import javax.imageio.ImageIO;",
            "import jenkins.model.Jenkins;",
            "import jenkins.scm.api.SCMFile;",
            "import org.apache.commons.io.IOUtils;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.apache.http.HttpHost;",
            "import org.apache.http.HttpStatus;",
            "import org.apache.http.NameValuePair;",
            "import org.apache.http.auth.AuthScope;",
            "import org.apache.http.auth.UsernamePasswordCredentials;",
            "import org.apache.http.client.AuthCache;",
            "import org.apache.http.client.CredentialsProvider;",
            "import org.apache.http.client.config.RequestConfig;",
            "import org.apache.http.client.entity.UrlEncodedFormEntity;",
            "import org.apache.http.client.methods.CloseableHttpResponse;",
            "import org.apache.http.client.methods.HttpDelete;",
            "import org.apache.http.client.methods.HttpGet;",
            "import org.apache.http.client.methods.HttpHead;",
            "import org.apache.http.client.methods.HttpPost;",
            "import org.apache.http.client.methods.HttpPut;",
            "import org.apache.http.client.methods.HttpRequestBase;",
            "import org.apache.http.client.protocol.HttpClientContext;",
            "import org.apache.http.config.SocketConfig;",
            "import org.apache.http.entity.ContentType;",
            "import org.apache.http.entity.StringEntity;",
            "import org.apache.http.impl.auth.BasicScheme;",
            "import org.apache.http.impl.client.BasicAuthCache;",
            "import org.apache.http.impl.client.BasicCredentialsProvider;",
            "import org.apache.http.impl.client.CloseableHttpClient;",
            "import org.apache.http.impl.client.HttpClientBuilder;",
            "import org.apache.http.impl.client.StandardHttpRequestRetryHandler;",
            "import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;",
            "import org.apache.http.message.BasicNameValuePair;",
            "import org.apache.http.util.EntityUtils;",
            "import org.kohsuke.accmod.Restricted;",
            "import org.kohsuke.accmod.restrictions.ProtectedExternally;",
            "import static java.util.concurrent.TimeUnit.HOURS;",
            "import static java.util.concurrent.TimeUnit.MILLISECONDS;",
            "import static java.util.concurrent.TimeUnit.MINUTES;",
            "import static java.util.concurrent.TimeUnit.SECONDS;"
        ],
        "reference_api": [
            "configureContext",
            "setConnectionManager",
            "setClientProxyParams",
            "build",
            "convert",
            "setExpireDuration",
            "setConnectionManagerShared",
            "setRetryHandler",
            "setKeepAliveStrategy",
            "create",
            "configureBuilder"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "setClientProxyParams",
                "code": "private void setClientProxyParams(String host, HttpClientBuilder builder) {\n        Jenkins jenkins = Jenkins.getInstanceOrNull();\n        ProxyConfiguration proxyConfig = null;\n        if (jenkins != null) {\n            proxyConfig = jenkins.proxy;\n        }\n\n        Proxy proxy = Proxy.NO_PROXY;\n        if (proxyConfig != null) {\n            proxy = proxyConfig.createProxy(host);\n        }\n\n        if (proxy.type() != Proxy.Type.DIRECT) {\n            final InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();\n            LOGGER.fine(\"Jenkins proxy: \" + proxy.address());\n            HttpHost proxyHttpHost = new HttpHost(proxyAddress.getHostName(), proxyAddress.getPort());\n            builder.setProxy(proxyHttpHost);\n            String username = proxyConfig.getUserName();\n            String password = proxyConfig.getPassword();\n            if (username != null && !\"\".equals(username.trim())) {\n                LOGGER.fine(\"Using proxy authentication (user=\" + username + \")\");\n                if (context == null) {\n                    // may have been already set in com.cloudbees.jenkins.plugins.bitbucket.api.credentials.BitbucketUsernamePasswordAuthenticator.configureContext(HttpClientContext, HttpHost)\n                    context = HttpClientContext.create();\n                }\n                CredentialsProvider credentialsProvider = context.getCredentialsProvider();\n                if (credentialsProvider == null) {\n                    credentialsProvider = new BasicCredentialsProvider();\n                    // may have been already set in com.cloudbees.jenkins.plugins.bitbucket.api.credentials.BitbucketUsernamePasswordAuthenticator.configureContext(HttpClientContext, HttpHost)\n                    context.setCredentialsProvider(credentialsProvider);\n                }\n                credentialsProvider.setCredentials(new AuthScope(proxyHttpHost), new UsernamePasswordCredentials(username, password));\n                AuthCache authCache = context.getAuthCache();\n                if (authCache == null) {\n                    authCache = new BasicAuthCache();\n                    context.setAuthCache(authCache);\n                }\n                authCache.put(proxyHttpHost, new BasicScheme());\n            }\n        }\n    }"
            }
        ],
        "third_party": [
            "configureContext",
            "setConnectionManager",
            "build",
            "convert",
            "setExpireDuration",
            "setConnectionManagerShared",
            "setRetryHandler",
            "setKeepAliveStrategy",
            "create",
            "configureBuilder"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "private void setupClosureForPRBranch(BitbucketPullRequestValue pullRequest)",
        "start_line": "312",
        "end_line": "321",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/client/BitbucketCloudApiClient.java",
        "docstring": "This function sets up commit closures for the source and destination branches of a Bitbucket pull request. It retrieves the source branch and, if it exists, assigns a new CommitClosure based on the branch's raw node. It then does the same for the destination branch.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "3a55763e86c1",
        "ground_truth": "private void setupClosureForPRBranch(BitbucketPullRequestValue pullRequest) {\n    BitbucketCloudBranch branch = pullRequest.getSource().getBranch();\n    if (branch != null) {\n        branch.setCommitClosure(new CommitClosure(branch.getRawNode()));\n    }\n    branch = pullRequest.getDestination().getBranch();\n    if (branch != null) {\n        branch.setCommitClosure(new CommitClosure(branch.getRawNode()));\n    }\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.JsonParser;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApi;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketAuthenticator;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketBuildStatus;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketCloudWorkspace;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketCommit;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketException;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketPullRequest;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketRequestException;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketTeam;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketWebHook;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.credentials.BitbucketUsernamePasswordAuthenticator;",
            "import com.cloudbees.jenkins.plugins.bitbucket.avatars.AvatarCacheSource.AvatarImage;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.branch.BitbucketCloudBranch;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.branch.BitbucketCloudCommit;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.pullrequest.BitbucketPullRequestCommit;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.pullrequest.BitbucketPullRequestCommits;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.pullrequest.BitbucketPullRequestValue;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.pullrequest.BitbucketPullRequests;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.BitbucketCloudRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.BitbucketRepositoryHook;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.BitbucketRepositoryHooks;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.BitbucketRepositorySource;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.PaginatedBitbucketRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.UserRoleInRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.filesystem.BitbucketSCMFile;",
            "import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials;",
            "import com.damnhandy.uri.template.UriTemplate;",
            "import com.damnhandy.uri.template.impl.Operator;",
            "import com.fasterxml.jackson.core.type.TypeReference;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.ProxyConfiguration;",
            "import hudson.Util;",
            "import java.awt.image.BufferedImage;",
            "import java.io.BufferedInputStream;",
            "import java.io.ByteArrayOutputStream;",
            "import java.io.FileNotFoundException;",
            "import java.io.IOException;",
            "import java.io.InputStream;",
            "import java.io.UnsupportedEncodingException;",
            "import java.net.InetSocketAddress;",
            "import java.net.Proxy;",
            "import java.net.URI;",
            "import java.net.URISyntaxException;",
            "import java.nio.charset.StandardCharsets;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.Comparator;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.concurrent.Callable;",
            "import java.util.logging.Level;",
            "import java.util.logging.Logger;",
            "import javax.imageio.ImageIO;",
            "import jenkins.model.Jenkins;",
            "import jenkins.scm.api.SCMFile;",
            "import org.apache.commons.io.IOUtils;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.apache.http.HttpHost;",
            "import org.apache.http.HttpStatus;",
            "import org.apache.http.NameValuePair;",
            "import org.apache.http.auth.AuthScope;",
            "import org.apache.http.auth.UsernamePasswordCredentials;",
            "import org.apache.http.client.AuthCache;",
            "import org.apache.http.client.CredentialsProvider;",
            "import org.apache.http.client.config.RequestConfig;",
            "import org.apache.http.client.entity.UrlEncodedFormEntity;",
            "import org.apache.http.client.methods.CloseableHttpResponse;",
            "import org.apache.http.client.methods.HttpDelete;",
            "import org.apache.http.client.methods.HttpGet;",
            "import org.apache.http.client.methods.HttpHead;",
            "import org.apache.http.client.methods.HttpPost;",
            "import org.apache.http.client.methods.HttpPut;",
            "import org.apache.http.client.methods.HttpRequestBase;",
            "import org.apache.http.client.protocol.HttpClientContext;",
            "import org.apache.http.config.SocketConfig;",
            "import org.apache.http.entity.ContentType;",
            "import org.apache.http.entity.StringEntity;",
            "import org.apache.http.impl.auth.BasicScheme;",
            "import org.apache.http.impl.client.BasicAuthCache;",
            "import org.apache.http.impl.client.BasicCredentialsProvider;",
            "import org.apache.http.impl.client.CloseableHttpClient;",
            "import org.apache.http.impl.client.HttpClientBuilder;",
            "import org.apache.http.impl.client.StandardHttpRequestRetryHandler;",
            "import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;",
            "import org.apache.http.message.BasicNameValuePair;",
            "import org.apache.http.util.EntityUtils;",
            "import org.kohsuke.accmod.Restricted;",
            "import org.kohsuke.accmod.restrictions.ProtectedExternally;",
            "import static java.util.concurrent.TimeUnit.HOURS;",
            "import static java.util.concurrent.TimeUnit.MILLISECONDS;",
            "import static java.util.concurrent.TimeUnit.MINUTES;",
            "import static java.util.concurrent.TimeUnit.SECONDS;"
        ],
        "reference_api": [
            "getDestination",
            "getBranch",
            "getRawNode",
            "setCommitClosure",
            "getSource"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getBranch",
                "code": "@Override\n    public BitbucketCloudBranch getBranch(@NonNull String branchName) throws IOException, InterruptedException {\n        String url = UriTemplate.fromTemplate(REPO_URL_TEMPLATE + \"/refs/branches/{name}\")\n            .set(\"owner\", owner)\n            .set(\"repo\", repositoryName)\n            .set(\"name\", branchName)\n            .expand();\n        String response = getRequest(url);\n        try {\n            return getSingleBranch(response);\n        } catch (IOException e) {\n            throw new IOException(\"I/O error when parsing response from URL: \" + url, e);\n        }\n    }"
            }
        ],
        "third_party": [
            "getDestination",
            "getRawNode",
            "setCommitClosure",
            "getSource"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "private static String getRootURL(@NonNull Run<?, ?> build)",
        "start_line": "61",
        "end_line": "69",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/BitbucketBuildStatusNotifications.java",
        "docstring": "This function retrieves the root URL for a given Jenkins build. It first gets the Jenkins location configuration. If the configuration or URL is null, it throws an IllegalStateException. Otherwise, it returns the display URL for the build using the DisplayURLProvider.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "f8fdc6ac34d2",
        "ground_truth": "private static String getRootURL(@NonNull Run<?, ?> build) {\n    JenkinsLocationConfiguration cfg = JenkinsLocationConfiguration.get();\n    if (cfg == null || cfg.getUrl() == null) {\n        throw new IllegalStateException(\"Could not determine Jenkins URL.\");\n    }\n    return DisplayURLProvider.get().getRunURL(build);\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.BranchDiscoveryTrait.ExcludeOriginPRBranchesSCMHeadFilter;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApi;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketBuildStatus;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.BitbucketCloudApiClient;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.FilePath;",
            "import hudson.model.Result;",
            "import hudson.model.Run;",
            "import hudson.model.TaskListener;",
            "import hudson.model.listeners.RunListener;",
            "import hudson.model.listeners.SCMListener;",
            "import hudson.scm.SCM;",
            "import hudson.scm.SCMRevisionState;",
            "import java.io.File;",
            "import java.io.IOException;",
            "import java.net.MalformedURLException;",
            "import java.net.URL;",
            "import jenkins.model.JenkinsLocationConfiguration;",
            "import jenkins.plugins.git.AbstractGitSCMSource;",
            "import jenkins.scm.api.SCMHeadObserver;",
            "import jenkins.scm.api.SCMRevision;",
            "import jenkins.scm.api.SCMRevisionAction;",
            "import jenkins.scm.api.SCMSource;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.jenkinsci.plugins.displayurlapi.DisplayURLProvider;"
        ],
        "reference_api": [
            "getRunURL",
            "get",
            "getUrl"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getRunURL",
            "get",
            "getUrl"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "static String checkURL(@NonNull String url, BitbucketApi bitbucket) ",
        "start_line": "80",
        "end_line": "97",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/BitbucketBuildStatusNotifications.java",
        "docstring": "This function validates a given Jenkins URL. It checks if the URL is well-formed and ensures it does not use \"localhost\" or \"unconfigured-jenkins-location\" as the host. For Bitbucket Cloud API clients, it also verifies that the host is fully qualified. If any of these conditions are not met or the URL is malformed, it throws an IllegalStateException.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "80415d8563e2",
        "ground_truth": "static String checkURL(@NonNull String url, BitbucketApi bitbucket) {\n    try {\n        URL anURL = new URL(url);\n        if (\"localhost\".equals(anURL.getHost())) {\n            throw new IllegalStateException(\"Jenkins URL cannot start with http://localhost\");\n        }\n        if (\"unconfigured-jenkins-location\".equals(anURL.getHost())) {\n            throw new IllegalStateException(\"Could not determine Jenkins URL.\");\n        }\n        if (bitbucket instanceof BitbucketCloudApiClient && !anURL.getHost().contains(\".\")) {\n            throw new IllegalStateException(\n                \"Please use a fully qualified name or an IP address for Jenkins URL, this is required by Bitbucket cloud\");\n        }\n        return url;\n    } catch (MalformedURLException e) {\n        throw new IllegalStateException(\"Bad Jenkins URL\");\n    }\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.BranchDiscoveryTrait.ExcludeOriginPRBranchesSCMHeadFilter;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApi;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketBuildStatus;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.BitbucketCloudApiClient;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.FilePath;",
            "import hudson.model.Result;",
            "import hudson.model.Run;",
            "import hudson.model.TaskListener;",
            "import hudson.model.listeners.RunListener;",
            "import hudson.model.listeners.SCMListener;",
            "import hudson.scm.SCM;",
            "import hudson.scm.SCMRevisionState;",
            "import java.io.File;",
            "import java.io.IOException;",
            "import java.net.MalformedURLException;",
            "import java.net.URL;",
            "import jenkins.model.JenkinsLocationConfiguration;",
            "import jenkins.plugins.git.AbstractGitSCMSource;",
            "import jenkins.scm.api.SCMHeadObserver;",
            "import jenkins.scm.api.SCMRevision;",
            "import jenkins.scm.api.SCMRevisionAction;",
            "import jenkins.scm.api.SCMSource;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.jenkinsci.plugins.displayurlapi.DisplayURLProvider;"
        ],
        "reference_api": [
            "getHost",
            "equals",
            "contains"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getHost"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "private static void sendNotifications(BitbucketSCMSource source, Run<?, ?> build, TaskListener listener)\n            throws IOException, InterruptedException",
        "start_line": "173",
        "end_line": "205",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/BitbucketBuildStatusNotifications.java",
        "docstring": "This function sends build notifications to Bitbucket for a given source and build. It initializes the Bitbucket context and checks if notifications are disabled. If not, it retrieves the SCM revision and its hash. It determines whether to share the build key between branch and PR. Based on the revision type, it logs the notification type, constructs the build key, and initializes the Bitbucket client. Finally, it creates and sends the build status notification.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a00613493272",
        "ground_truth": "private static void sendNotifications(BitbucketSCMSource source, Run<?, ?> build, TaskListener listener)\n        throws IOException, InterruptedException {\n    BitbucketSCMSourceContext sourceContext = new BitbucketSCMSourceContext(null,\n        SCMHeadObserver.none()).withTraits(source.getTraits());\n    if (sourceContext.notificationsDisabled()) {\n        return;\n    }\n    SCMRevision r = SCMRevisionAction.getRevision(source, build);\n    if (r == null) {\n        return;\n    }\n    String hash = getHash(r);\n    if (hash == null) {\n        return;\n    }\n    boolean shareBuildKeyBetweenBranchAndPR = sourceContext\n        .filters().stream()\n        .anyMatch(filter -> filter instanceof ExcludeOriginPRBranchesSCMHeadFilter);\n    String key;\n    BitbucketApi bitbucket;\n    if (r instanceof PullRequestSCMRevision) {\n        listener.getLogger().println(\"[Bitbucket] Notifying pull request build result\");\n        PullRequestSCMHead head = (PullRequestSCMHead) r.getHead();\n        key = getBuildKey(build, head.getOriginName(), shareBuildKeyBetweenBranchAndPR);\n        bitbucket = source.buildBitbucketClient(head);\n    } else {\n        listener.getLogger().println(\"[Bitbucket] Notifying commit build result\");\n        key = getBuildKey(build, r.getHead().getName(), shareBuildKeyBetweenBranchAndPR);\n        bitbucket = source.buildBitbucketClient();\n    }\n    createStatus(build, listener, bitbucket, key, hash);\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.BranchDiscoveryTrait.ExcludeOriginPRBranchesSCMHeadFilter;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApi;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketBuildStatus;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.BitbucketCloudApiClient;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.FilePath;",
            "import hudson.model.Result;",
            "import hudson.model.Run;",
            "import hudson.model.TaskListener;",
            "import hudson.model.listeners.RunListener;",
            "import hudson.model.listeners.SCMListener;",
            "import hudson.scm.SCM;",
            "import hudson.scm.SCMRevisionState;",
            "import java.io.File;",
            "import java.io.IOException;",
            "import java.net.MalformedURLException;",
            "import java.net.URL;",
            "import jenkins.model.JenkinsLocationConfiguration;",
            "import jenkins.plugins.git.AbstractGitSCMSource;",
            "import jenkins.scm.api.SCMHeadObserver;",
            "import jenkins.scm.api.SCMRevision;",
            "import jenkins.scm.api.SCMRevisionAction;",
            "import jenkins.scm.api.SCMSource;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.jenkinsci.plugins.displayurlapi.DisplayURLProvider;"
        ],
        "reference_api": [
            "getName",
            "getLogger",
            "getRevision",
            "buildBitbucketClient",
            "createStatus",
            "filters",
            "getTraits",
            "withTraits",
            "getHead",
            "anyMatch",
            "println",
            "getOriginName",
            "getHash",
            "getBuildKey",
            "notificationsDisabled",
            "stream",
            "none"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "createStatus",
                "code": "private static void createStatus(@NonNull Run<?, ?> build, @NonNull TaskListener listener,\n        @NonNull BitbucketApi bitbucket, @NonNull String key, @NonNull String hash)\n            throws IOException, InterruptedException {\n\n        final SCMSource source = SCMSource.SourceByItem.findSource(build.getParent());\n        if (!(source instanceof BitbucketSCMSource)) {\n            return;\n        }\n\n        String url;\n        try {\n            url = getRootURL(build);\n            checkURL(url, bitbucket);\n        } catch (IllegalStateException e) {\n            listener.getLogger().println(\"Can not determine Jenkins root URL \" +\n                    \"or Jenkins URL is not a valid URL regarding Bitbucket API. \" +\n                    \"Commit status notifications are disabled until a root URL is \" +\n                    \"configured in Jenkins global configuration. \\n\" +\n                    \"IllegalStateException: \" + e.getMessage());\n            return;\n        }\n\n        final Result result = build.getResult();\n        final String name = build.getFullDisplayName(); // use the build number as the display name of the status\n        String buildDescription = build.getDescription();\n        String statusDescription;\n        BitbucketBuildStatus.Status state;\n        if (Result.SUCCESS.equals(result)) {\n            statusDescription = StringUtils.defaultIfBlank(buildDescription, \"This commit looks good.\");\n            state = BitbucketBuildStatus.Status.SUCCESSFUL;\n        } else if (Result.UNSTABLE.equals(result)) {\n            statusDescription = StringUtils.defaultIfBlank(buildDescription, \"This commit has test failures.\");\n            BitbucketSCMSourceContext context = new BitbucketSCMSourceContext(null, SCMHeadObserver.none()).withTraits(source.getTraits());\n            if (context.sendSuccessNotificationForUnstableBuild()) {\n                state = BitbucketBuildStatus.Status.SUCCESSFUL;\n            } else {\n                state = BitbucketBuildStatus.Status.FAILED;\n            }\n        } else if (Result.FAILURE.equals(result)) {\n            statusDescription = StringUtils.defaultIfBlank(buildDescription, \"There was a failure building this commit.\");\n            state = BitbucketBuildStatus.Status.FAILED;\n        } else if (Result.NOT_BUILT.equals(result)) {\n            // Bitbucket Cloud and Server support different build states.\n            statusDescription = StringUtils.defaultIfBlank(buildDescription, \"This commit was not built (probably the build was skipped)\");\n            BitbucketSCMSourceContext context = new BitbucketSCMSourceContext(null, SCMHeadObserver.none()).withTraits(source.getTraits());\n            if (context.disableNotificationForNotBuildJobs()) {\n                state = (bitbucket instanceof BitbucketCloudApiClient) ? BitbucketBuildStatus.Status.STOPPED : null;\n            } else {\n                state = BitbucketBuildStatus.Status.SUCCESSFUL;\n            }\n        } else if (result != null) { // ABORTED etc.\n            statusDescription = StringUtils.defaultIfBlank(buildDescription, \"Something is wrong with the build of this commit.\");\n            state = BitbucketBuildStatus.Status.FAILED;\n        } else {\n            statusDescription = StringUtils.defaultIfBlank(buildDescription, \"The build is in progress...\");\n            state = BitbucketBuildStatus.Status.INPROGRESS;\n        }\n\n        if (state != null) {\n            BitbucketChangesetCommentNotifier notifier = new BitbucketChangesetCommentNotifier(bitbucket);\n            notifier.buildStatus(new BitbucketBuildStatus(hash, statusDescription, state, url, key, name));\n            if (result != null) {\n                listener.getLogger().println(\"[Bitbucket] Build result notified\");\n            }\n        } else {\n            listener.getLogger().println(\"[Bitbucket] Skip result notification\");\n        }\n    }"
            },
            {
                "name": "getHash",
                "code": "@CheckForNull\n    private static String getHash(@CheckForNull SCMRevision revision) {\n        if (revision instanceof PullRequestSCMRevision) {\n            // unwrap\n            revision = ((PullRequestSCMRevision) revision).getPull();\n        }\n        if (revision instanceof AbstractGitSCMSource.SCMRevisionImpl) {\n            return ((AbstractGitSCMSource.SCMRevisionImpl) revision).getHash();\n        }\n        return null;\n    }"
            },
            {
                "name": "getBuildKey",
                "code": "private static String getBuildKey(@NonNull Run<?, ?> build, String branch,\n        boolean shareBuildKeyBetweenBranchAndPR) {\n\n        // When the ExcludeOriginPRBranchesSCMHeadFilter filter is active, we want the\n        // build status key to be the same between the branch project and the PR project.\n        // This is to avoid having two build statuses when a branch goes into PR and\n        // it was already built at least once as a branch.\n        // So the key we use is the branch name.\n        String key;\n        if (shareBuildKeyBetweenBranchAndPR) {\n            String folderName = build.getParent().getParent().getFullName();\n            key = String.format(\"%s/%s\", folderName, branch);\n        } else {\n            key = build.getParent().getFullName(); // use the job full name as the key for the status\n        }\n\n        return key;\n    }"
            }
        ],
        "third_party": [
            "getName",
            "getLogger",
            "getRevision",
            "buildBitbucketClient",
            "filters",
            "getTraits",
            "withTraits",
            "getHead",
            "anyMatch",
            "println",
            "getOriginName",
            "notificationsDisabled",
            "stream",
            "none"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": " private static String getBuildKey(@NonNull Run<?, ?> build, String branch,\n        boolean shareBuildKeyBetweenBranchAndPR)",
        "start_line": "219",
        "end_line": "236",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/BitbucketBuildStatusNotifications.java",
        "docstring": "This function generates a build key for a given Jenkins build and branch. If the `shareBuildKeyBetweenBranchAndPR` flag is true, it combines the folder name and branch to create the key. Otherwise, it uses the job's full name as the key. The function returns the generated key.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "c19361ed6737",
        "ground_truth": "private static String getBuildKey(@NonNull Run<?, ?> build, String branch,\n    boolean shareBuildKeyBetweenBranchAndPR) {\n    // When the ExcludeOriginPRBranchesSCMHeadFilter filter is active, we want the\n    // build status key to be the same between the branch project and the PR project.\n    // This is to avoid having two build statuses when a branch goes into PR and\n    // it was already built at least once as a branch.\n    // So the key we use is the branch name.\n    String key;\n    if (shareBuildKeyBetweenBranchAndPR) {\n        String folderName = build.getParent().getParent().getFullName();\n        key = String.format(\"%s/%s\", folderName, branch);\n    } else {\n        key = build.getParent().getFullName(); // use the job full name as the key for the status\n    }\n    return key;\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.BranchDiscoveryTrait.ExcludeOriginPRBranchesSCMHeadFilter;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApi;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketBuildStatus;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.BitbucketCloudApiClient;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.FilePath;",
            "import hudson.model.Result;",
            "import hudson.model.Run;",
            "import hudson.model.TaskListener;",
            "import hudson.model.listeners.RunListener;",
            "import hudson.model.listeners.SCMListener;",
            "import hudson.scm.SCM;",
            "import hudson.scm.SCMRevisionState;",
            "import java.io.File;",
            "import java.io.IOException;",
            "import java.net.MalformedURLException;",
            "import java.net.URL;",
            "import jenkins.model.JenkinsLocationConfiguration;",
            "import jenkins.plugins.git.AbstractGitSCMSource;",
            "import jenkins.scm.api.SCMHeadObserver;",
            "import jenkins.scm.api.SCMRevision;",
            "import jenkins.scm.api.SCMRevisionAction;",
            "import jenkins.scm.api.SCMSource;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.jenkinsci.plugins.displayurlapi.DisplayURLProvider;"
        ],
        "reference_api": [
            "getParent",
            "format",
            "getFullName"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getParent",
            "getFullName"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "private Object readResolve() throws ObjectStreamException",
        "start_line": "177",
        "end_line": "212",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/BitbucketSCMNavigator.java",
        "docstring": "This function resolves the server URL and traits for a BitbucketSCMNavigator object during deserialization. It sets the server URL if it's null, logs a warning if it remains null, and reconstructs legacy traits to reflect legacy behavior if traits are null. The function returns the updated object.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5f659b29a99e",
        "ground_truth": "private Object readResolve() throws ObjectStreamException {\n    if (serverUrl == null) {\n        serverUrl = BitbucketEndpointConfiguration.get().readResolveServerUrl(bitbucketServerUrl);\n    }\n    if (serverUrl == null) {\n        LOGGER.log(Level.WARNING, \"BitbucketSCMNavigator::readResolve : serverUrl is still empty\");\n    }\n    if (traits == null) {\n        // legacy instance, reconstruct traits to reflect legacy behaviour\n        traits = new ArrayList<>();\n        this.traits.add(new BranchDiscoveryTrait(true, true));\n        this.traits.add(new OriginPullRequestDiscoveryTrait(EnumSet.of(ChangeRequestCheckoutStrategy.HEAD)));\n        this.traits.add(new ForkPullRequestDiscoveryTrait(\n                EnumSet.of(ChangeRequestCheckoutStrategy.HEAD),\n                new ForkPullRequestDiscoveryTrait.TrustEveryone())\n        );\n        this.traits.add(new PublicRepoPullRequestFilterTrait());\n        if ((includes != null && !\"*\".equals(includes)) || (excludes != null && !\"\".equals(excludes))) {\n            traits.add(new WildcardSCMHeadFilterTrait(\n                    StringUtils.defaultIfBlank(includes, \"*\"),\n                    StringUtils.defaultIfBlank(excludes, \"\")));\n        }\n        if (checkoutCredentialsId != null\n                && !BitbucketSCMSource.DescriptorImpl.SAME.equals(checkoutCredentialsId)\n                && !checkoutCredentialsId.equals(credentialsId)) {\n            traits.add(new SSHCheckoutTrait(checkoutCredentialsId));\n        }\n        traits.add(new WebhookRegistrationTrait(\n                autoRegisterHooks ? WebhookRegistration.ITEM : WebhookRegistration.DISABLE)\n        );\n        if (pattern != null && !\".*\".equals(pattern)) {\n            traits.add(new RegexSCMSourceFilterTrait(pattern));\n        }\n    }\n    return this;\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApi;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApiFactory;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketAuthenticator;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketTeam;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.UserRoleInRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.endpoints.AbstractBitbucketEndpoint;",
            "import com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketCloudEndpoint;",
            "import com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketEndpointConfiguration;",
            "import com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketServerEndpoint;",
            "import com.cloudbees.jenkins.plugins.bitbucket.server.BitbucketServerWebhookImplementation;",
            "import com.cloudbees.jenkins.plugins.bitbucket.server.client.repository.BitbucketServerProject;",
            "import com.cloudbees.plugins.credentials.CredentialsNameProvider;",
            "import com.cloudbees.plugins.credentials.common.StandardCredentials;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;",
            "import hudson.Extension;",
            "import hudson.RestrictedSince;",
            "import hudson.Util;",
            "import hudson.console.HyperlinkNote;",
            "import hudson.model.Action;",
            "import hudson.model.Item;",
            "import hudson.model.TaskListener;",
            "import hudson.plugins.git.GitSCM;",
            "import hudson.security.AccessControlled;",
            "import hudson.util.FormFillFailure;",
            "import hudson.util.FormValidation;",
            "import hudson.util.ListBoxModel;",
            "import java.io.IOException;",
            "import java.io.ObjectStreamException;",
            "import java.util.ArrayList;",
            "import java.util.Arrays;",
            "import java.util.Collections;",
            "import java.util.EnumSet;",
            "import java.util.HashSet;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.Set;",
            "import java.util.logging.Level;",
            "import java.util.logging.Logger;",
            "import jenkins.authentication.tokens.api.AuthenticationTokens;",
            "import jenkins.model.Jenkins;",
            "import jenkins.plugins.git.traits.GitBrowserSCMSourceTrait;",
            "import jenkins.scm.api.SCMNavigator;",
            "import jenkins.scm.api.SCMNavigatorDescriptor;",
            "import jenkins.scm.api.SCMNavigatorEvent;",
            "import jenkins.scm.api.SCMNavigatorOwner;",
            "import jenkins.scm.api.SCMSource;",
            "import jenkins.scm.api.SCMSourceCategory;",
            "import jenkins.scm.api.SCMSourceObserver;",
            "import jenkins.scm.api.SCMSourceOwner;",
            "import jenkins.scm.api.metadata.ObjectMetadataAction;",
            "import jenkins.scm.api.mixin.ChangeRequestCheckoutStrategy;",
            "import jenkins.scm.api.trait.SCMNavigatorRequest;",
            "import jenkins.scm.api.trait.SCMNavigatorTrait;",
            "import jenkins.scm.api.trait.SCMNavigatorTraitDescriptor;",
            "import jenkins.scm.api.trait.SCMSourceTrait;",
            "import jenkins.scm.api.trait.SCMTrait;",
            "import jenkins.scm.api.trait.SCMTraitDescriptor;",
            "import jenkins.scm.impl.UncategorizedSCMSourceCategory;",
            "import jenkins.scm.impl.form.NamedArrayList;",
            "import jenkins.scm.impl.trait.Discovery;",
            "import jenkins.scm.impl.trait.RegexSCMSourceFilterTrait;",
            "import jenkins.scm.impl.trait.Selection;",
            "import jenkins.scm.impl.trait.WildcardSCMHeadFilterTrait;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.jenkins.ui.icon.Icon;",
            "import org.jenkins.ui.icon.IconSet;",
            "import org.jenkinsci.Symbol;",
            "import org.kohsuke.accmod.Restricted;",
            "import org.kohsuke.accmod.restrictions.DoNotUse;",
            "import org.kohsuke.accmod.restrictions.NoExternalUse;",
            "import org.kohsuke.stapler.AncestorInPath;",
            "import org.kohsuke.stapler.DataBoundConstructor;",
            "import org.kohsuke.stapler.DataBoundSetter;",
            "import org.kohsuke.stapler.QueryParameter;",
            "import static com.cloudbees.jenkins.plugins.bitbucket.BitbucketApiUtils.getFromBitbucket;"
        ],
        "reference_api": [
            "equals",
            "readResolveServerUrl",
            "of",
            "log",
            "defaultIfBlank",
            "get",
            "add"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "readResolveServerUrl",
            "of",
            "log",
            "defaultIfBlank",
            "get",
            "add"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "public void record(@NonNull String name, boolean isMatch)",
        "start_line": "831",
        "end_line": "840",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/BitbucketSCMNavigator.java",
        "docstring": "This function records the result of a repository match check. It retrieves the Bitbucket repository by name and logs a message indicating whether the repository is proposed or ignored based on the isMatch flag. If the repository is proposed, it increments the count.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8be16b5a10cb",
        "ground_truth": "public void record(@NonNull String name, boolean isMatch) {\n    BitbucketRepository repository = this.request.getBitbucketRepository(name);\n    if (isMatch) {\n        listener.getLogger().format(\"Proposing %s%n\", repository.getFullName());\n        count++;\n    } else {\n        listener.getLogger().format(\"Ignoring %s%n\", repository.getFullName());\n    }\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApi;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketApiFactory;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketAuthenticator;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketTeam;",
            "import com.cloudbees.jenkins.plugins.bitbucket.client.repository.UserRoleInRepository;",
            "import com.cloudbees.jenkins.plugins.bitbucket.endpoints.AbstractBitbucketEndpoint;",
            "import com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketCloudEndpoint;",
            "import com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketEndpointConfiguration;",
            "import com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketServerEndpoint;",
            "import com.cloudbees.jenkins.plugins.bitbucket.server.BitbucketServerWebhookImplementation;",
            "import com.cloudbees.jenkins.plugins.bitbucket.server.client.repository.BitbucketServerProject;",
            "import com.cloudbees.plugins.credentials.CredentialsNameProvider;",
            "import com.cloudbees.plugins.credentials.common.StandardCredentials;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;",
            "import hudson.Extension;",
            "import hudson.RestrictedSince;",
            "import hudson.Util;",
            "import hudson.console.HyperlinkNote;",
            "import hudson.model.Action;",
            "import hudson.model.Item;",
            "import hudson.model.TaskListener;",
            "import hudson.plugins.git.GitSCM;",
            "import hudson.security.AccessControlled;",
            "import hudson.util.FormFillFailure;",
            "import hudson.util.FormValidation;",
            "import hudson.util.ListBoxModel;",
            "import java.io.IOException;",
            "import java.io.ObjectStreamException;",
            "import java.util.ArrayList;",
            "import java.util.Arrays;",
            "import java.util.Collections;",
            "import java.util.EnumSet;",
            "import java.util.HashSet;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.Set;",
            "import java.util.logging.Level;",
            "import java.util.logging.Logger;",
            "import jenkins.authentication.tokens.api.AuthenticationTokens;",
            "import jenkins.model.Jenkins;",
            "import jenkins.plugins.git.traits.GitBrowserSCMSourceTrait;",
            "import jenkins.scm.api.SCMNavigator;",
            "import jenkins.scm.api.SCMNavigatorDescriptor;",
            "import jenkins.scm.api.SCMNavigatorEvent;",
            "import jenkins.scm.api.SCMNavigatorOwner;",
            "import jenkins.scm.api.SCMSource;",
            "import jenkins.scm.api.SCMSourceCategory;",
            "import jenkins.scm.api.SCMSourceObserver;",
            "import jenkins.scm.api.SCMSourceOwner;",
            "import jenkins.scm.api.metadata.ObjectMetadataAction;",
            "import jenkins.scm.api.mixin.ChangeRequestCheckoutStrategy;",
            "import jenkins.scm.api.trait.SCMNavigatorRequest;",
            "import jenkins.scm.api.trait.SCMNavigatorTrait;",
            "import jenkins.scm.api.trait.SCMNavigatorTraitDescriptor;",
            "import jenkins.scm.api.trait.SCMSourceTrait;",
            "import jenkins.scm.api.trait.SCMTrait;",
            "import jenkins.scm.api.trait.SCMTraitDescriptor;",
            "import jenkins.scm.impl.UncategorizedSCMSourceCategory;",
            "import jenkins.scm.impl.form.NamedArrayList;",
            "import jenkins.scm.impl.trait.Discovery;",
            "import jenkins.scm.impl.trait.RegexSCMSourceFilterTrait;",
            "import jenkins.scm.impl.trait.Selection;",
            "import jenkins.scm.impl.trait.WildcardSCMHeadFilterTrait;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.jenkins.ui.icon.Icon;",
            "import org.jenkins.ui.icon.IconSet;",
            "import org.jenkinsci.Symbol;",
            "import org.kohsuke.accmod.Restricted;",
            "import org.kohsuke.accmod.restrictions.DoNotUse;",
            "import org.kohsuke.accmod.restrictions.NoExternalUse;",
            "import org.kohsuke.stapler.AncestorInPath;",
            "import org.kohsuke.stapler.DataBoundConstructor;",
            "import org.kohsuke.stapler.DataBoundSetter;",
            "import org.kohsuke.stapler.QueryParameter;",
            "import static com.cloudbees.jenkins.plugins.bitbucket.BitbucketApiUtils.getFromBitbucket;"
        ],
        "reference_api": [
            "getBitbucketRepository",
            "getLogger",
            "format",
            "getFullName"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getBitbucketRepository",
            "getLogger",
            "getFullName"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "public Revision decorateRevisionToBuild(\n        GitSCM scm,\n        Run<?, ?> build,\n        GitClient git,\n        TaskListener listener,\n        Revision marked,\n        Revision rev\n    ) throws InterruptedException",
        "start_line": "38",
        "end_line": "65",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/FallbackToOtherRepositoryGitSCMExtension.java",
        "docstring": "This function decorates a Git revision for a Jenkins build. It filters branches with hashes to find those whose commits don't exist locally and creates RefSpecs for them. If there are RefSpecs, it fetches the missing commits from the remote repository using the provided clone link. Finally, it returns the given revision.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a6b5821e3001",
        "ground_truth": "public Revision decorateRevisionToBuild(\n    GitSCM scm,\n    Run<?, ?> build,\n    GitClient git,\n    TaskListener listener,\n    Revision marked,\n    Revision rev\n) throws InterruptedException {\n    List<RefSpec> refSpecs = branchWithHashes.stream()\n        .filter(branchWithHash -> !commitExists(git, branchWithHash.getHash()))\n        .map(branchWithHash -> {\n            String branch = branchWithHash.getBranch();\n            return new RefSpec(\"+refs/heads/\" + branch + \":refs/remotes/\" + remoteName + \"/\" + branch);\n        })\n        .collect(Collectors.toList());\n    if (!refSpecs.isEmpty()) {\n        FetchCommand fetchCommand = git.fetch_();\n        URIish remote;\n        try {\n            remote = new URIish(cloneLink);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n        fetchCommand.from(remote, refSpecs).execute();\n    }\n    return rev;\n}",
        "import_statements": [
            "import hudson.model.Run;",
            "import hudson.model.TaskListener;",
            "import hudson.plugins.git.GitException;",
            "import hudson.plugins.git.GitSCM;",
            "import hudson.plugins.git.Revision;",
            "import hudson.plugins.git.extensions.GitSCMExtension;",
            "import java.net.URISyntaxException;",
            "import java.util.List;",
            "import java.util.stream.Collectors;",
            "import org.eclipse.jgit.transport.RefSpec;",
            "import org.eclipse.jgit.transport.URIish;",
            "import org.jenkinsci.plugins.gitclient.FetchCommand;",
            "import org.jenkinsci.plugins.gitclient.GitClient;"
        ],
        "reference_api": [
            "filter",
            "commitExists",
            "from",
            "toList",
            "execute",
            "map",
            "getBranch",
            "collect",
            "fetch_",
            "getHash",
            "stream",
            "isEmpty"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "commitExists",
                "code": "private static boolean commitExists(GitClient git, String sha1) {\n        try {\n            git.revParse(sha1);\n            return true;\n        } catch (GitException ignored) {\n            return false;\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }"
            }
        ],
        "third_party": [
            "filter",
            "from",
            "toList",
            "execute",
            "map",
            "getBranch",
            "collect",
            "fetch_",
            "getHash",
            "stream",
            "isEmpty"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/bitbucket-branch-source-plugin",
        "function_declaration": "public Map<String, BitbucketHref> getLinks()",
        "start_line": "160",
        "end_line": "171",
        "file_path": "src/main/java/com/cloudbees/jenkins/plugins/bitbucket/server/client/pullrequest/BitbucketServerPullRequest.java",
        "docstring": "This function retrieves a map of Bitbucket links. If the links are null, it returns null. Otherwise, it creates a new map and populates it with the first BitbucketHref from each entry in the original links map, returning the result.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "58004de8c64f",
        "ground_truth": "public Map<String, BitbucketHref> getLinks() {\n    if (links == null) {\n        return null;\n    }\n    Map<String, BitbucketHref> result = new HashMap<>();\n    for (Map.Entry<String, List<BitbucketHref>> entry : this.links.entrySet()) {\n        if (!entry.getValue().isEmpty()) {\n            result.put(entry.getKey(), entry.getValue().get(0));\n        }\n    }\n    return result;\n}",
        "import_statements": [
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketHref;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketPullRequest;",
            "import com.cloudbees.jenkins.plugins.bitbucket.api.BitbucketReviewer;",
            "import com.fasterxml.jackson.annotation.JsonIgnore;",
            "import com.fasterxml.jackson.annotation.JsonInclude;",
            "import com.fasterxml.jackson.annotation.JsonProperty;",
            "import com.fasterxml.jackson.databind.annotation.JsonDeserialize;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import java.util.Collections;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;"
        ],
        "reference_api": [
            "getValue",
            "entrySet",
            "getKey",
            "get",
            "put",
            "isEmpty"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getValue",
            "entrySet",
            "getKey",
            "get",
            "put",
            "isEmpty"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "JohnstonCode/svn-scm",
        "function_declaration": "public async execute(...resourceStates: SourceControlResourceState[])",
        "start_line": "9",
        "end_line": "32",
        "file_path": "src/commands/add.ts",
        "docstring": "This asynchronous function executes a series of operations on given resource states in a source control system. It first retrieves the selected resource states, returning if none are selected. It maps the selected resources to their URIs and processes them by repository. For each repository, it converts the resources to file paths and attempts to add these files to the repository, handling any errors by logging them and showing an error message.",
        "language": "TypeScript",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "bf7825346651",
        "ground_truth": "public async execute(...resourceStates: SourceControlResourceState[]) {\n  const selection = await this.getResourceStates(resourceStates);\n  if (selection.length === 0) {\n    return;\n  }\n  const uris = selection.map(resource => resource.resourceUri);\n  await this.runByRepository(uris, async (repository, resources) => {\n    if (!repository) {\n      return;\n    }\n    const paths = resources.map(resource => resource.fsPath);\n    try {\n      await repository.addFiles(paths);\n    } catch (error) {\n      console.log(error);\n      window.showErrorMessage(\"Unable to add file\");\n    }\n  });\n}",
        "import_statements": [
            "import { SourceControlResourceState, window } from \"vscode\";",
            "{ SourceControlResourceState, window }",
            "{ SourceControlResourceState, window }",
            "SourceControlResourceState",
            "window",
            "import { Command } from \"./command\";",
            "{ Command }",
            "{ Command }",
            "Command"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "SCM",
        "owner/repo": "JohnstonCode/svn-scm",
        "function_declaration": "protected async getResourceStates",
        "start_line": "97",
        "end_line": "114",
        "file_path": "src/commands/command.ts",
        "docstring": "This async function retrieves resource states for source control. It first checks if the provided resource states are empty or if the first resource URI is not an instance of Uri. If so, it attempts to get a single SCM resource and updates the resource states. Finally, it filters and returns the resource states that are instances of Resource.",
        "language": "TypeScript",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "21845a480c9e",
        "ground_truth": "protected async getResourceStates(\n  resourceStates: SourceControlResourceState[]\n): Promise<Resource[]> {\n  if (\n    resourceStates.length === 0 ||\n    !(resourceStates[0].resourceUri instanceof Uri)\n  ) {\n    const resource = await this.getSCMResource();\n    if (!resource) {\n      return [];\n    }\n    resourceStates = [resource];\n  }\n  return resourceStates.filter(s => s instanceof Resource) as Resource[];\n}",
        "import_statements": [
            "import * as path from \"path\";",
            "* as path",
            "* as path",
            "import {\n  commands,\n  Disposable,\n  Position,\n  Range,\n  SourceControlResourceState,\n  TextDocumentShowOptions,\n  TextEditor,\n  Uri,\n  ViewColumn,\n  window,\n  workspace,\n  WorkspaceEdit\n} from \"vscode\";",
            "{\n  commands,\n  Disposable,\n  Position,\n  Range,\n  SourceControlResourceState,\n  TextDocumentShowOptions,\n  TextEditor,\n  Uri,\n  ViewColumn,\n  window,\n  workspace,\n  WorkspaceEdit\n}",
            "{\n  commands,\n  Disposable,\n  Position,\n  Range,\n  SourceControlResourceState,\n  TextDocumentShowOptions,\n  TextEditor,\n  Uri,\n  ViewColumn,\n  window,\n  workspace,\n  WorkspaceEdit\n}",
            "commands",
            "Disposable",
            "Position",
            "Range",
            "SourceControlResourceState",
            "TextDocumentShowOptions",
            "TextEditor",
            "Uri",
            "ViewColumn",
            "window",
            "workspace",
            "WorkspaceEdit",
            "import {\n  ICommandOptions,\n  Status,\n  SvnUriAction,\n  LineChange\n} from \"../common/types\";",
            "{\n  ICommandOptions,\n  Status,\n  SvnUriAction,\n  LineChange\n}",
            "{\n  ICommandOptions,\n  Status,\n  SvnUriAction,\n  LineChange\n}",
            "ICommandOptions",
            "Status",
            "SvnUriAction",
            "LineChange",
            "import { exists, readFile, stat, unlink } from \"../fs\";",
            "{ exists, readFile, stat, unlink }",
            "{ exists, readFile, stat, unlink }",
            "exists",
            "readFile",
            "stat",
            "unlink",
            "import { inputIgnoreList } from \"../ignoreitems\";",
            "{ inputIgnoreList }",
            "{ inputIgnoreList }",
            "inputIgnoreList",
            "import { applyLineChanges } from \"../lineChanges\";",
            "{ applyLineChanges }",
            "{ applyLineChanges }",
            "applyLineChanges",
            "import { SourceControlManager } from \"../source_control_manager\";",
            "{ SourceControlManager }",
            "{ SourceControlManager }",
            "SourceControlManager",
            "import { Repository } from \"../repository\";",
            "{ Repository }",
            "{ Repository }",
            "Repository",
            "import { Resource } from \"../resource\";",
            "{ Resource }",
            "{ Resource }",
            "Resource",
            "import IncomingChangeNode from \"../treeView/nodes/incomingChangeNode\";",
            "IncomingChangeNode",
            "import { fromSvnUri, toSvnUri } from \"../uri\";",
            "{ fromSvnUri, toSvnUri }",
            "{ fromSvnUri, toSvnUri }",
            "fromSvnUri",
            "toSvnUri",
            "import { getSvnDir } from \"../util\";",
            "{ getSvnDir }",
            "{ getSvnDir }",
            "getSvnDir"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "SCM",
        "owner/repo": "JohnstonCode/svn-scm",
        "function_declaration": "  protected async getSCMResource(uri?: Uri): Promise<Resource | undefined>",
        "start_line": "162",
        "end_line": "191",
        "file_path": "src/commands/command.ts",
        "docstring": "This async function retrieves a source control management (SCM) resource for a given URI. If no URI is provided, it uses the URI of the active text editor. If the URI is in the \"svn\" scheme, it converts it to a file URI. For file URIs, it gets the source control manager and retrieves the repository for the URI, returning the corresponding resource. If no valid URI or repository is found, it returns undefined.",
        "language": "TypeScript",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9cdf8c671ccf",
        "ground_truth": "protected async getSCMResource(uri?: Uri): Promise<Resource | undefined> {\n  uri = uri\n    ? uri\n    : window.activeTextEditor && window.activeTextEditor.document.uri;\n  if (!uri) {\n    return undefined;\n  }\n  if (uri.scheme === \"svn\") {\n    const { fsPath } = fromSvnUri(uri);\n    uri = Uri.file(fsPath);\n  }\n  if (uri.scheme === \"file\") {\n    const sourceControlManager = (await commands.executeCommand(\n      \"svn.getSourceControlManager\",\n      \"\"\n    )) as SourceControlManager;\n    const repository = sourceControlManager.getRepository(uri);\n    if (!repository) {\n      return undefined;\n    }\n    return repository.getResourceFromFile(uri);\n  }\n  return;\n}",
        "import_statements": [
            "import * as path from \"path\";",
            "* as path",
            "* as path",
            "import {\n  commands,\n  Disposable,\n  Position,\n  Range,\n  SourceControlResourceState,\n  TextDocumentShowOptions,\n  TextEditor,\n  Uri,\n  ViewColumn,\n  window,\n  workspace,\n  WorkspaceEdit\n} from \"vscode\";",
            "{\n  commands,\n  Disposable,\n  Position,\n  Range,\n  SourceControlResourceState,\n  TextDocumentShowOptions,\n  TextEditor,\n  Uri,\n  ViewColumn,\n  window,\n  workspace,\n  WorkspaceEdit\n}",
            "{\n  commands,\n  Disposable,\n  Position,\n  Range,\n  SourceControlResourceState,\n  TextDocumentShowOptions,\n  TextEditor,\n  Uri,\n  ViewColumn,\n  window,\n  workspace,\n  WorkspaceEdit\n}",
            "commands",
            "Disposable",
            "Position",
            "Range",
            "SourceControlResourceState",
            "TextDocumentShowOptions",
            "TextEditor",
            "Uri",
            "ViewColumn",
            "window",
            "workspace",
            "WorkspaceEdit",
            "import {\n  ICommandOptions,\n  Status,\n  SvnUriAction,\n  LineChange\n} from \"../common/types\";",
            "{\n  ICommandOptions,\n  Status,\n  SvnUriAction,\n  LineChange\n}",
            "{\n  ICommandOptions,\n  Status,\n  SvnUriAction,\n  LineChange\n}",
            "ICommandOptions",
            "Status",
            "SvnUriAction",
            "LineChange",
            "import { exists, readFile, stat, unlink } from \"../fs\";",
            "{ exists, readFile, stat, unlink }",
            "{ exists, readFile, stat, unlink }",
            "exists",
            "readFile",
            "stat",
            "unlink",
            "import { inputIgnoreList } from \"../ignoreitems\";",
            "{ inputIgnoreList }",
            "{ inputIgnoreList }",
            "inputIgnoreList",
            "import { applyLineChanges } from \"../lineChanges\";",
            "{ applyLineChanges }",
            "{ applyLineChanges }",
            "applyLineChanges",
            "import { SourceControlManager } from \"../source_control_manager\";",
            "{ SourceControlManager }",
            "{ SourceControlManager }",
            "SourceControlManager",
            "import { Repository } from \"../repository\";",
            "{ Repository }",
            "{ Repository }",
            "Repository",
            "import { Resource } from \"../resource\";",
            "{ Resource }",
            "{ Resource }",
            "Resource",
            "import IncomingChangeNode from \"../treeView/nodes/incomingChangeNode\";",
            "IncomingChangeNode",
            "import { fromSvnUri, toSvnUri } from \"../uri\";",
            "{ fromSvnUri, toSvnUri }",
            "{ fromSvnUri, toSvnUri }",
            "fromSvnUri",
            "toSvnUri",
            "import { getSvnDir } from \"../util\";",
            "{ getSvnDir }",
            "{ getSvnDir }",
            "getSvnDir"
        ],
        "reference_api": [
            "Uri.file",
            "fromSvnUri",
            "commands.executeCommand",
            "getSCMResource",
            "repository.getResourceFromFile",
            "sourceControlManager.getRepository"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Uri.file",
                "code": "."
            },
            {
                "name": "fromSvnUri",
                "code": "."
            },
            {
                "name": "commands.executeCommand",
                "code": "."
            },
            {
                "name": "getSCMResource",
                "code": "."
            },
            {
                "name": "repository.getResourceFromFile",
                "code": "."
            },
            {
                "name": "sourceControlManager.getRepository",
                "code": "."
            }
        ],
        "third_party": []
    },
    {
        "subclass": "SCM",
        "owner/repo": "JohnstonCode/svn-scm",
        "function_declaration": " public async openDiffCmd(element: ISvnPathChange)",
        "start_line": "87",
        "end_line": "102",
        "file_path": "src/historyView/branchChangesProvider.ts",
        "docstring": "This async function handles opening a diff command for a given SVN path change element. It retrieves the remote repository for the element. If the element is modified, it opens a diff between the old and new revisions. If the element is added, it opens the remote file at the new path and revision.",
        "language": "TypeScript",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "5149f80daf8e",
        "ground_truth": "public async openDiffCmd(element: ISvnPathChange) {\n  const repo = await this.model.getRemoteRepository(element.repo);\n  if (element.item === Status.MODIFIED) {\n    return openDiff(\n      repo,\n      element.oldPath,\n      element.oldRevision,\n      element.newRevision,\n      element.newPath\n    );\n  }\n  if (element.item === Status.ADDED) {\n    return openFileRemote(repo, element.newPath, element.newRevision);\n  }\n}",
        "import_statements": [
            "import {\n  TreeDataProvider,\n  Disposable,\n  TreeItem,\n  commands,\n  EventEmitter,\n  window\n} from \"vscode\";",
            "{\n  TreeDataProvider,\n  Disposable,\n  TreeItem,\n  commands,\n  EventEmitter,\n  window\n}",
            "{\n  TreeDataProvider,\n  Disposable,\n  TreeItem,\n  commands,\n  EventEmitter,\n  window\n}",
            "TreeDataProvider",
            "Disposable",
            "TreeItem",
            "commands",
            "EventEmitter",
            "window",
            "import { SourceControlManager } from \"../source_control_manager\";",
            "{ SourceControlManager }",
            "{ SourceControlManager }",
            "SourceControlManager",
            "import { ISvnPathChange, Status } from \"../common/types\";",
            "{ ISvnPathChange, Status }",
            "{ ISvnPathChange, Status }",
            "ISvnPathChange",
            "Status",
            "import { openDiff, getIconObject, openFileRemote } from \"./common\";",
            "{ openDiff, getIconObject, openFileRemote }",
            "{ openDiff, getIconObject, openFileRemote }",
            "openDiff",
            "getIconObject",
            "openFileRemote",
            "import { dispose } from \"../util\";",
            "{ dispose }",
            "{ dispose }",
            "dispose"
        ],
        "reference_api": [
            "openFileRemote",
            "openDiff",
            "openDiffCmd",
            "this.model.getRemoteRepository"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "openFileRemote",
                "code": ")"
            },
            {
                "name": "openDiff",
                "code": ")"
            },
            {
                "name": "openDiffCmd",
                "code": ")"
            },
            {
                "name": "this.model.getRemoteRepository",
                "code": ")"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "SCM",
        "owner/repo": "JohnstonCode/svn-scm",
        "function_declaration": "export async function copyCommitToClipboard(what: string, item: ILogTreeItem)",
        "start_line": "82",
        "end_line": "96",
        "file_path": "src/historyView/common.ts",
        "docstring": "This async function copies commit information to the clipboard in a VS Code extension. It first checks if the clipboard is supported. If not, it shows an error message. If the item is a commit, it copies the specified commit message or revision to the clipboard.",
        "language": "TypeScript",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a08f0266eabb",
        "ground_truth": "export async function copyCommitToClipboard(what: string, item: ILogTreeItem) {\n  const clipboard = (env as any).clipboard;\n  if (clipboard === undefined) {\n    window.showErrorMessage(\"Clipboard is supported in VS Code 1.30 and newer\");\n    return;\n  }\n  if (item.kind === LogTreeItemKind.Commit) {\n    const commit = item.data as ISvnLogEntry;\n    switch (what) {\n      case \"msg\":\n      case \"revision\":\n        await clipboard.writeText(commit[what]);\n    }\n  }\n}",
        "import_statements": [
            "import { createHash } from \"crypto\";",
            "{ createHash }",
            "{ createHash }",
            "createHash",
            "import * as path from \"path\";",
            "* as path",
            "* as path",
            "import * as dayjs from \"dayjs\";",
            "* as dayjs",
            "* as dayjs",
            "import * as relativeTime from \"dayjs/plugin/relativeTime\";",
            "* as relativeTime",
            "* as relativeTime",
            "import {\n  commands,\n  env,\n  TextDocumentShowOptions,\n  ThemeIcon,\n  TreeItem,\n  Uri,\n  window\n} from \"vscode\";",
            "{\n  commands,\n  env,\n  TextDocumentShowOptions,\n  ThemeIcon,\n  TreeItem,\n  Uri,\n  window\n}",
            "{\n  commands,\n  env,\n  TextDocumentShowOptions,\n  ThemeIcon,\n  TreeItem,\n  Uri,\n  window\n}",
            "commands",
            "env",
            "TextDocumentShowOptions",
            "ThemeIcon",
            "TreeItem",
            "Uri",
            "window",
            "import { ISvnLogEntry, ISvnLogEntryPath } from \"../common/types\";",
            "{ ISvnLogEntry, ISvnLogEntryPath }",
            "{ ISvnLogEntry, ISvnLogEntryPath }",
            "ISvnLogEntry",
            "ISvnLogEntryPath",
            "import { exists, lstat } from \"../fs\";",
            "{ exists, lstat }",
            "{ exists, lstat }",
            "exists",
            "lstat",
            "import { configuration } from \"../helpers/configuration\";",
            "{ configuration }",
            "{ configuration }",
            "configuration",
            "import { IRemoteRepository } from \"../remoteRepository\";",
            "{ IRemoteRepository }",
            "{ IRemoteRepository }",
            "IRemoteRepository",
            "import { SvnRI } from \"../svnRI\";",
            "{ SvnRI }",
            "{ SvnRI }",
            "SvnRI",
            "import { tempSvnFs } from \"../temp_svn_fs\";",
            "{ tempSvnFs }",
            "{ tempSvnFs }",
            "tempSvnFs"
        ],
        "reference_api": [
            "clipboard.writeText",
            "window.showErrorMessage"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "clipboard.writeText",
                "code": "a"
            },
            {
                "name": "window.showErrorMessage",
                "code": "a"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/gitea-plugin",
        "function_declaration": "public GiteaConnection open() throws IOException, InterruptedException",
        "start_line": "128",
        "end_line": "145",
        "file_path": "src/main/java/org/jenkinsci/plugin/gitea/client/api/Gitea.java",
        "docstring": "This function attempts to open a Gitea connection by loading available GiteaConnectionFactory implementations. It iterates through the factories to find the most suitable one based on their ability to open the connection and their priority. If a suitable factory is found, it opens the connection. If no suitable factory is found, it throws an IOException.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "65ea1cc73c3d",
        "ground_truth": "public GiteaConnection open() throws IOException, InterruptedException {\n    ServiceLoader<GiteaConnectionFactory> loader = ServiceLoader.load(GiteaConnectionFactory.class, classLoader);\n    long priority = 0L;\n    GiteaConnectionFactory best = null;\n    for (GiteaConnectionFactory factory : loader) {\n        if (factory.canOpen(this)) {\n            long p = factory.priority(this);\n            if (best == null || p > priority) {\n                best = factory;\n                priority = p;\n            }\n        }\n    }\n    if (best != null) {\n        return best.open(this);\n    }\n    throw new IOException(\"No implementation for connecting to \" + serverUrl);\n}",
        "import_statements": [
            "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import java.io.IOException;",
            "import java.util.ServiceLoader;",
            "import jenkins.model.Jenkins;",
            "import org.jenkinsci.plugin.gitea.client.spi.GiteaConnectionFactory;"
        ],
        "reference_api": [
            "load",
            "canOpen",
            "open",
            "priority"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "open",
                "code": "@NonNull\n    public GiteaConnection open() throws IOException, InterruptedException {\n        ServiceLoader<GiteaConnectionFactory> loader = ServiceLoader.load(GiteaConnectionFactory.class, classLoader);\n        long priority = 0L;\n        GiteaConnectionFactory best = null;\n        for (GiteaConnectionFactory factory : loader) {\n            if (factory.canOpen(this)) {\n                long p = factory.priority(this);\n                if (best == null || p > priority) {\n                    best = factory;\n                    priority = p;\n                }\n            }\n        }\n        if (best != null) {\n            return best.open(this);\n        }\n        throw new IOException(\"No implementation for connecting to \" + serverUrl);\n    }"
            }
        ],
        "third_party": [
            "load",
            "canOpen",
            "priority"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/gitea-plugin",
        "function_declaration": "public Gitea jenkinsPluginClassLoader()",
        "start_line": "147",
        "end_line": "155",
        "file_path": "src/main/java/org/jenkinsci/plugin/gitea/client/api/Gitea.java",
        "docstring": "This function sets the class loader for a Gitea instance. It retrieves the Jenkins instance, and if it is not null, it uses the Jenkins plugin manager's class loader; otherwise, it uses the current class's class loader. It returns the Gitea instance.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "aaf07318bc5b",
        "ground_truth": "public Gitea jenkinsPluginClassLoader() {\n    // HACK for Jenkins\n    // by rights this should be the context classloader, but Jenkins does not expose plugins on that\n    // so we need instead to use the uberClassLoader as that will have the implementations\n    Jenkins instance = Jenkins.getInstanceOrNull();\n    classLoader = instance == null ? getClass().getClassLoader() : instance.getPluginManager().uberClassLoader;\n    // END HACK\n    return this;\n}",
        "import_statements": [
            "import com.fasterxml.jackson.annotation.JsonIgnoreProperties;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import java.io.IOException;",
            "import java.util.ServiceLoader;",
            "import jenkins.model.Jenkins;",
            "import org.jenkinsci.plugin.gitea.client.spi.GiteaConnectionFactory;"
        ],
        "reference_api": [
            "getInstanceOrNull",
            "getClassLoader",
            "getClass",
            "getPluginManager"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getInstanceOrNull",
            "getClassLoader",
            "getClass",
            "getPluginManager"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/gitea-plugin",
        "function_declaration": "public GiteaServer(@CheckForNull String displayName, @NonNull String serverUrl, boolean manageHooks,\n                       @CheckForNull String credentialsId, @CheckForNull String aliasUrl) ",
        "start_line": "136",
        "end_line": "145",
        "file_path": "src/main/java/org/jenkinsci/plugin/gitea/servers/GiteaServer.java",
        "docstring": "This constructor initializes a GiteaServer object. It sets the `manageHooks` flag based on the presence of `credentialsId`, assigns `credentialsId` if hooks are managed, and normalizes the `serverUrl`. The `displayName` is set based on the provided value or derived from the server URL. It also normalizes and trims the `aliasUrl`.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "db7157e73a2b",
        "ground_truth": "public GiteaServer(@CheckForNull String displayName, @NonNull String serverUrl, boolean manageHooks,\n                   @CheckForNull String credentialsId, @CheckForNull String aliasUrl) {\n    this.manageHooks = manageHooks && StringUtils.isNotBlank(credentialsId);\n    this.credentialsId = manageHooks ? credentialsId : null;\n    this.serverUrl = GiteaServers.normalizeServerUrl(serverUrl);\n    this.displayName = StringUtils.isBlank(displayName)\n            ? SCMName.fromUrl(this.serverUrl, COMMON_PREFIX_HOSTNAMES)\n            : displayName;\n    this.aliasUrl = StringUtils.trimToNull(GiteaServers.normalizeServerUrl(aliasUrl));\n}",
        "import_statements": [
            "import com.cloudbees.plugins.credentials.CredentialsMatchers;",
            "import com.cloudbees.plugins.credentials.CredentialsProvider;",
            "import com.cloudbees.plugins.credentials.common.StandardCredentials;",
            "import com.cloudbees.plugins.credentials.common.StandardListBoxModel;",
            "import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials;",
            "import com.cloudbees.plugins.credentials.domains.URIRequirementBuilder;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.Util;",
            "import hudson.model.AbstractDescribableImpl;",
            "import hudson.model.Descriptor;",
            "import hudson.security.ACL;",
            "import hudson.util.FormValidation;",
            "import hudson.util.ListBoxModel;",
            "import java.io.IOException;",
            "import java.net.MalformedURLException;",
            "import java.net.URI;",
            "import java.net.URISyntaxException;",
            "import javax.annotation.Nonnull;",
            "import jenkins.authentication.tokens.api.AuthenticationTokens;",
            "import jenkins.model.Jenkins;",
            "import jenkins.scm.api.SCMName;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.jenkinsci.plugin.gitea.client.api.Gitea;",
            "import org.jenkinsci.plugin.gitea.client.api.GiteaAuth;",
            "import org.jenkinsci.plugin.gitea.client.api.GiteaConnection;",
            "import org.jenkinsci.plugin.gitea.client.api.GiteaUser;",
            "import org.kohsuke.accmod.Restricted;",
            "import org.kohsuke.accmod.restrictions.DoNotUse;",
            "import org.kohsuke.accmod.restrictions.NoExternalUse;",
            "import org.kohsuke.stapler.DataBoundConstructor;",
            "import org.kohsuke.stapler.QueryParameter;"
        ],
        "reference_api": [
            "trimToNull",
            "isBlank",
            "normalizeServerUrl",
            "fromUrl",
            "isNotBlank"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "trimToNull",
            "isBlank",
            "normalizeServerUrl",
            "fromUrl",
            "isNotBlank"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/gitea-plugin",
        "function_declaration": "public ListBoxModel doFillCredentialsIdItems(@QueryParameter String serverUrl)",
        "start_line": "287",
        "end_line": "299",
        "file_path": "src/main/java/org/jenkinsci/plugin/gitea/servers/GiteaServer.java",
        "docstring": "This function populates the credentials dropdown list for a given server URL. It first checks if the user has administrative permissions, normalizes the server URL, and then includes matching credentials based on the server URL requirements and authentication tokens for GiteaAuth. The resulting list of credentials is returned.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "1e52cb0f058b",
        "ground_truth": "public ListBoxModel doFillCredentialsIdItems(@QueryParameter String serverUrl) {\n    Jenkins.get().checkPermission(Jenkins.ADMINISTER);\n    StandardListBoxModel result = new StandardListBoxModel();\n    serverUrl = GiteaServers.normalizeServerUrl(serverUrl);\n    result.includeMatchingAs(\n            ACL.SYSTEM,\n            Jenkins.get(),\n            StandardCredentials.class,\n            URIRequirementBuilder.fromUri(serverUrl).build(),\n            AuthenticationTokens.matcher(GiteaAuth.class)\n    );\n    return result;\n}",
        "import_statements": [
            "import com.cloudbees.plugins.credentials.CredentialsMatchers;",
            "import com.cloudbees.plugins.credentials.CredentialsProvider;",
            "import com.cloudbees.plugins.credentials.common.StandardCredentials;",
            "import com.cloudbees.plugins.credentials.common.StandardListBoxModel;",
            "import com.cloudbees.plugins.credentials.common.StandardUsernamePasswordCredentials;",
            "import com.cloudbees.plugins.credentials.domains.URIRequirementBuilder;",
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.Util;",
            "import hudson.model.AbstractDescribableImpl;",
            "import hudson.model.Descriptor;",
            "import hudson.security.ACL;",
            "import hudson.util.FormValidation;",
            "import hudson.util.ListBoxModel;",
            "import java.io.IOException;",
            "import java.net.MalformedURLException;",
            "import java.net.URI;",
            "import java.net.URISyntaxException;",
            "import javax.annotation.Nonnull;",
            "import jenkins.authentication.tokens.api.AuthenticationTokens;",
            "import jenkins.model.Jenkins;",
            "import jenkins.scm.api.SCMName;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.jenkinsci.plugin.gitea.client.api.Gitea;",
            "import org.jenkinsci.plugin.gitea.client.api.GiteaAuth;",
            "import org.jenkinsci.plugin.gitea.client.api.GiteaConnection;",
            "import org.jenkinsci.plugin.gitea.client.api.GiteaUser;",
            "import org.kohsuke.accmod.Restricted;",
            "import org.kohsuke.accmod.restrictions.DoNotUse;",
            "import org.kohsuke.accmod.restrictions.NoExternalUse;",
            "import org.kohsuke.stapler.DataBoundConstructor;",
            "import org.kohsuke.stapler.QueryParameter;"
        ],
        "reference_api": [
            "fromUri",
            "checkPermission",
            "includeMatchingAs",
            "normalizeServerUrl",
            "get",
            "matcher",
            "build"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "fromUri",
            "checkPermission",
            "includeMatchingAs",
            "normalizeServerUrl",
            "get",
            "matcher",
            "build"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/gitea-plugin",
        "function_declaration": "public static String normalizeServerUrl(@CheckForNull String serverUrl)",
        "start_line": "83",
        "end_line": "114",
        "file_path": "src/main/java/org/jenkinsci/plugin/gitea/servers/GiteaServers.java",
        "docstring": "This function normalizes a server URL. It converts the URL to lowercase, removes default ports (80 for HTTP and 443 for HTTPS), and ensures the URL is properly formatted. If an exception occurs during URI parsing, it is ignored. The function also removes any trailing slash from the URL before returning it.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7efa03739d4c",
        "ground_truth": "public static String normalizeServerUrl(@CheckForNull String serverUrl) {\n    serverUrl = StringUtils.defaultString(serverUrl);\n    try {\n        URI uri = new URI(serverUrl).normalize();\n        String scheme = uri.getScheme();\n        if (\"http\".equals(scheme) || \"https\".equals(scheme)) {\n            // we only expect http / https, but also these are the only ones where we know the authority\n            // is server based, i.e. [userinfo@]server[:port]\n            // DNS names must be US-ASCII and are case insensitive, so we force all to lowercase\n            String host = uri.getHost() == null ? null : uri.getHost().toLowerCase(Locale.ENGLISH);\n            int port = uri.getPort();\n            if (\"http\".equals(scheme) && port == 80) {\n                port = -1;\n            } else if (\"https\".equals(scheme) && port == 443) {\n                port = -1;\n            }\n            serverUrl = new URI(\n                    scheme,\n                    uri.getUserInfo(),\n                    host,\n                    port,\n                    uri.getPath(),\n                    uri.getQuery(),\n                    uri.getFragment()\n            ).toASCIIString();\n        }\n    } catch (URISyntaxException e) {\n        // ignore, this was a best effort tidy-up\n    }\n    return serverUrl.replaceAll(\"/$\", \"\");\n}",
        "import_statements": [
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.ExtensionList;",
            "import hudson.Util;",
            "import hudson.util.ListBoxModel;",
            "import java.net.URI;",
            "import java.net.URISyntaxException;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.HashSet;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.ListIterator;",
            "import java.util.Locale;",
            "import java.util.Set;",
            "import jenkins.model.GlobalConfiguration;",
            "import jenkins.model.Jenkins;",
            "import net.sf.json.JSONObject;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.kohsuke.stapler.StaplerRequest;"
        ],
        "reference_api": [
            "getPath",
            "toLowerCase",
            "equals",
            "getHost",
            "getPort",
            "replaceAll",
            "getFragment",
            "getUserInfo",
            "defaultString",
            "toASCIIString",
            "getQuery",
            "getScheme",
            "normalize"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getPath",
            "toLowerCase",
            "getHost",
            "getPort",
            "replaceAll",
            "getFragment",
            "getUserInfo",
            "defaultString",
            "toASCIIString",
            "getQuery",
            "getScheme",
            "normalize"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/gitea-plugin",
        "function_declaration": "public ListBoxModel getServerItems()",
        "start_line": "203",
        "end_line": "211",
        "file_path": "src/main/java/org/jenkinsci/plugin/gitea/servers/GiteaServers.java",
        "docstring": "This function retrieves a list of Gitea server items for display. It creates a ListBoxModel and iterates through the available Gitea servers, adding each server's URL and display name to the model. If the display name is blank, only the server URL is added. The function returns the populated ListBoxModel.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7c39a93a98ef",
        "ground_truth": "public ListBoxModel getServerItems() {\n    ListBoxModel result = new ListBoxModel();\n    for (GiteaServer endpoint : getServers()) {\n        String serverUrl = endpoint.getServerUrl();\n        String displayName = endpoint.getDisplayName();\n        result.add(StringUtils.isBlank(displayName) ? serverUrl : displayName + \" (\" + serverUrl + \")\", serverUrl);\n    }\n    return result;\n}",
        "import_statements": [
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.ExtensionList;",
            "import hudson.Util;",
            "import hudson.util.ListBoxModel;",
            "import java.net.URI;",
            "import java.net.URISyntaxException;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.HashSet;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.ListIterator;",
            "import java.util.Locale;",
            "import java.util.Set;",
            "import jenkins.model.GlobalConfiguration;",
            "import jenkins.model.Jenkins;",
            "import net.sf.json.JSONObject;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.kohsuke.stapler.StaplerRequest;"
        ],
        "reference_api": [
            "getServerUrl",
            "isBlank",
            "getServers",
            "add",
            "getDisplayName"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getServers",
                "code": "@NonNull\n    public synchronized List<GiteaServer> getServers() {\n        return servers == null || servers.isEmpty()\n                ? Collections.<GiteaServer>emptyList()\n                : Collections.unmodifiableList(servers);\n    }"
            }
        ],
        "third_party": [
            "getServerUrl",
            "isBlank",
            "add",
            "getDisplayName"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/gitea-plugin",
        "function_declaration": "public synchronized void setServers(@CheckForNull List<? extends GiteaServer> servers)",
        "start_line": "239",
        "end_line": "255",
        "file_path": "src/main/java/org/jenkinsci/plugin/gitea/servers/GiteaServers.java",
        "docstring": "This synchronized method sets the list of Gitea servers. It checks for the necessary admin permissions, removes duplicates and empty URLs from the provided server list, and updates the servers. Finally, it saves the configuration.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "b28d7a8aea26",
        "ground_truth": "public synchronized void setServers(@CheckForNull List<? extends GiteaServer> servers) {\n    Jenkins.get().checkPermission(Jenkins.ADMINISTER);\n    List<GiteaServer> eps = new ArrayList<>(Util.fixNull(servers));\n    // remove duplicates and empty urls\n    Set<String> serverUrls = new HashSet<>();\n    for (ListIterator<GiteaServer> iterator = eps.listIterator(); iterator.hasNext(); ) {\n        GiteaServer endpoint = iterator.next();\n        String serverUrl = endpoint.getServerUrl();\n        if (StringUtils.isBlank(serverUrl) || serverUrls.contains(serverUrl)) {\n            iterator.remove();\n            continue;\n        }\n        serverUrls.add(serverUrl);\n    }\n    this.servers = eps;\n    save();\n}",
        "import_statements": [
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.ExtensionList;",
            "import hudson.Util;",
            "import hudson.util.ListBoxModel;",
            "import java.net.URI;",
            "import java.net.URISyntaxException;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.HashSet;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.ListIterator;",
            "import java.util.Locale;",
            "import java.util.Set;",
            "import jenkins.model.GlobalConfiguration;",
            "import jenkins.model.Jenkins;",
            "import net.sf.json.JSONObject;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.kohsuke.stapler.StaplerRequest;"
        ],
        "reference_api": [
            "save",
            "checkPermission",
            "getServerUrl",
            "fixNull",
            "listIterator",
            "next",
            "isBlank",
            "get",
            "hasNext",
            "contains",
            "add",
            "remove"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get",
                "code": "public static GiteaServers get() {\n        return ExtensionList.lookup(GlobalConfiguration.class).get(GiteaServers.class);\n    }"
            }
        ],
        "third_party": [
            "save",
            "checkPermission",
            "getServerUrl",
            "fixNull",
            "listIterator",
            "next",
            "isBlank",
            "hasNext",
            "add",
            "remove"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "jenkinsci/gitea-plugin",
        "function_declaration": "public synchronized boolean removeServer(@CheckForNull String serverUrl)",
        "start_line": "313",
        "end_line": "325",
        "file_path": "src/main/java/org/jenkinsci/plugin/gitea/servers/GiteaServers.java",
        "docstring": "This synchronized method removes a Gitea server with the specified URL. It normalizes the server URL, checks for and removes the matching server from the current list of servers, updates the server list, and returns a boolean indicating whether any server was removed.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "8a339d5a79ed",
        "ground_truth": "public synchronized boolean removeServer(@CheckForNull String serverUrl) {\n    serverUrl = normalizeServerUrl(serverUrl);\n    boolean modified = false;\n    List<GiteaServer> endpoints = new ArrayList<>(getServers());\n    for (Iterator<GiteaServer> iterator = endpoints.iterator(); iterator.hasNext(); ) {\n        if (serverUrl.equals(iterator.next().getServerUrl())) {\n            iterator.remove();\n            modified = true;\n        }\n    }\n    setServers(endpoints);\n    return modified;\n}",
        "import_statements": [
            "import edu.umd.cs.findbugs.annotations.CheckForNull;",
            "import edu.umd.cs.findbugs.annotations.NonNull;",
            "import hudson.Extension;",
            "import hudson.ExtensionList;",
            "import hudson.Util;",
            "import hudson.util.ListBoxModel;",
            "import java.net.URI;",
            "import java.net.URISyntaxException;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.HashSet;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.ListIterator;",
            "import java.util.Locale;",
            "import java.util.Set;",
            "import jenkins.model.GlobalConfiguration;",
            "import jenkins.model.Jenkins;",
            "import net.sf.json.JSONObject;",
            "import org.apache.commons.lang.StringUtils;",
            "import org.kohsuke.stapler.StaplerRequest;"
        ],
        "reference_api": [
            "setServers",
            "equals",
            "getServerUrl",
            "next",
            "iterator",
            "normalizeServerUrl",
            "hasNext",
            "getServers",
            "remove"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "setServers",
                "code": "public synchronized void setServers(@CheckForNull List<? extends GiteaServer> servers) {\n        Jenkins.get().checkPermission(Jenkins.ADMINISTER);\n        List<GiteaServer> eps = new ArrayList<>(Util.fixNull(servers));\n        // remove duplicates and empty urls\n        Set<String> serverUrls = new HashSet<>();\n        for (ListIterator<GiteaServer> iterator = eps.listIterator(); iterator.hasNext(); ) {\n            GiteaServer endpoint = iterator.next();\n            String serverUrl = endpoint.getServerUrl();\n            if (StringUtils.isBlank(serverUrl) || serverUrls.contains(serverUrl)) {\n                iterator.remove();\n                continue;\n            }\n            serverUrls.add(serverUrl);\n        }\n        this.servers = eps;\n        save();\n    }"
            },
            {
                "name": "normalizeServerUrl",
                "code": "@NonNull\n    public static String normalizeServerUrl(@CheckForNull String serverUrl) {\n        serverUrl = StringUtils.defaultString(serverUrl);\n        try {\n            URI uri = new URI(serverUrl).normalize();\n            String scheme = uri.getScheme();\n            if (\"http\".equals(scheme) || \"https\".equals(scheme)) {\n                // we only expect http / https, but also these are the only ones where we know the authority\n                // is server based, i.e. [userinfo@]server[:port]\n                // DNS names must be US-ASCII and are case insensitive, so we force all to lowercase\n\n                String host = uri.getHost() == null ? null : uri.getHost().toLowerCase(Locale.ENGLISH);\n                int port = uri.getPort();\n                if (\"http\".equals(scheme) && port == 80) {\n                    port = -1;\n                } else if (\"https\".equals(scheme) && port == 443) {\n                    port = -1;\n                }\n                serverUrl = new URI(\n                        scheme,\n                        uri.getUserInfo(),\n                        host,\n                        port,\n                        uri.getPath(),\n                        uri.getQuery(),\n                        uri.getFragment()\n                ).toASCIIString();\n            }\n        } catch (URISyntaxException e) {\n            // ignore, this was a best effort tidy-up\n        }\n        return serverUrl.replaceAll(\"/$\", \"\");\n    }"
            },
            {
                "name": "getServers",
                "code": "@NonNull\n    public synchronized List<GiteaServer> getServers() {\n        return servers == null || servers.isEmpty()\n                ? Collections.<GiteaServer>emptyList()\n                : Collections.unmodifiableList(servers);\n    }"
            }
        ],
        "third_party": [
            "getServerUrl",
            "next",
            "iterator",
            "hasNext",
            "remove"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "scm-manager/scm-manager",
        "function_declaration": "private void scanForConfigAnnotations(Set<DescriptorElement> descriptorElements, RoundEnvironment roundEnv, TypeElement annotation)",
        "start_line": "153",
        "end_line": "164",
        "file_path": "scm-annotation-processor/src/main/java/sonia/scm/annotation/ScmAnnotationProcessor.java",
        "docstring": "This method scans for elements annotated with a specific annotation within the provided round environment. For each annotated element, it retrieves attributes from the annotation, converts the element's type to a string, and adds a new ConfigElement with these attributes and type to the set of descriptor elements.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "ac059ccf2e98",
        "ground_truth": "private void scanForConfigAnnotations(Set<DescriptorElement> descriptorElements, RoundEnvironment roundEnv, TypeElement annotation) {\n  Set<? extends Element> elementsAnnotatedWith = roundEnv.getElementsAnnotatedWith(annotation);\n  for (Element element : elementsAnnotatedWith) {\n    Map<String, String> attributesFromAnnotation = getAttributesFromAnnotation(element, annotation);\n    String type = element.asType().toString();\n    descriptorElements.add(new ConfigElement(attributesFromAnnotation, type));\n  }\n}",
        "import_statements": [
            "import com.github.legman.Subscribe;",
            "import com.google.common.base.Throwables;",
            "import com.google.common.collect.ImmutableSet;",
            "import com.google.common.collect.Maps;",
            "import com.google.common.collect.Sets;",
            "import jakarta.ws.rs.Path;",
            "import jakarta.ws.rs.ext.Provider;",
            "import org.kohsuke.MetaInfServices;",
            "import org.mapstruct.Mapper;",
            "import org.w3c.dom.DOMException;",
            "import org.w3c.dom.Document;",
            "import org.xml.sax.SAXException;",
            "import picocli.CommandLine;",
            "import sonia.scm.annotation.ClassSetElement.ClassWithAttributes;",
            "import sonia.scm.config.ConfigValue;",
            "import sonia.scm.plugin.PluginAnnotation;",
            "import sonia.scm.plugin.Requires;",
            "import javax.annotation.processing.AbstractProcessor;",
            "import javax.annotation.processing.Filer;",
            "import javax.annotation.processing.Processor;",
            "import javax.annotation.processing.RoundEnvironment;",
            "import javax.annotation.processing.SupportedAnnotationTypes;",
            "import javax.annotation.processing.SupportedSourceVersion;",
            "import javax.lang.model.SourceVersion;",
            "import javax.lang.model.element.AnnotationMirror;",
            "import javax.lang.model.element.AnnotationValue;",
            "import javax.lang.model.element.Element;",
            "import javax.lang.model.element.ElementKind;",
            "import javax.lang.model.element.ExecutableElement;",
            "import javax.lang.model.element.TypeElement;",
            "import javax.lang.model.element.VariableElement;",
            "import javax.tools.Diagnostic.Kind;",
            "import javax.tools.FileObject;",
            "import javax.tools.StandardLocation;",
            "import javax.xml.XMLConstants;",
            "import javax.xml.parsers.DocumentBuilder;",
            "import javax.xml.parsers.DocumentBuilderFactory;",
            "import javax.xml.parsers.ParserConfigurationException;",
            "import javax.xml.transform.OutputKeys;",
            "import javax.xml.transform.Transformer;",
            "import javax.xml.transform.TransformerConfigurationException;",
            "import javax.xml.transform.TransformerException;",
            "import javax.xml.transform.TransformerFactory;",
            "import javax.xml.transform.dom.DOMSource;",
            "import javax.xml.transform.stream.StreamResult;",
            "import java.io.File;",
            "import java.io.IOException;",
            "import java.lang.annotation.Annotation;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Set;",
            "import static javax.lang.model.util.ElementFilter.methodsIn;"
        ],
        "reference_api": [
            "getAttributesFromAnnotation",
            "asType",
            "toString",
            "add",
            "getElementsAnnotatedWith"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getAttributesFromAnnotation",
                "code": "private Map<String, String> getAttributesFromAnnotation(Element el,\n                                                          TypeElement annotation) {\n    Map<String, String> attributes = Maps.newHashMap();\n\n    for (AnnotationMirror annotationMirror : el.getAnnotationMirrors()) {\n      String qn = annotationMirror.getAnnotationType().asElement().toString();\n\n      if (qn.equals(annotation.toString())) {\n        for (Map.Entry<? extends ExecutableElement,\n                  ? extends AnnotationValue> entry : annotationMirror.getElementValues().entrySet()) {\n          attributes.put(entry.getKey().getSimpleName().toString(),\n            getValue(entry.getValue()));\n        }\n\n        // add default values\n        for (ExecutableElement meth : methodsIn(annotationMirror.getAnnotationType().asElement().getEnclosedElements())) {\n          String attribute = meth.getSimpleName().toString();\n          AnnotationValue defaultValue = meth.getDefaultValue();\n          if (defaultValue != null && !attributes.containsKey(attribute)) {\n            String value = getValue(defaultValue);\n            if (value != null && !value.isEmpty()) {\n              attributes.put(attribute, value);\n            }\n          }\n        }\n      }\n    }\n\n    return attributes;\n  }"
            }
        ],
        "third_party": [
            "asType",
            "add",
            "getElementsAnnotatedWith"
        ]
    },
    {
        "subclass": "SCM",
        "owner/repo": "scm-manager/scm-manager",
        "function_declaration": "private TypeElement findAnnotation(Set<? extends TypeElement> annotations,\n                                     Class<? extends Annotation> annotationClass) ",
        "start_line": "166",
        "end_line": "180",
        "file_path": "scm-annotation-processor/src/main/java/sonia/scm/annotation/ScmAnnotationProcessor.java",
        "docstring": "This method searches for a specific annotation within a set of type elements. It iterates through the provided annotations and compares their qualified names to the target annotation class name, replacing `$` with `.` for matching subclasses. It returns the matched annotation type element or null if not found.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a3425fa3ea35",
        "ground_truth": "private TypeElement findAnnotation(Set<? extends TypeElement> annotations,\n                                   Class<? extends Annotation> annotationClass) {\n  TypeElement annotation = null;\n  for (TypeElement typeElement : annotations) {\n    // Replace $ with . to match subclasses\n    if (typeElement.getQualifiedName().toString().equals(annotationClass.getName().replace(\"$\", \".\"))) {\n      annotation = typeElement;\n      break;\n    }\n  }\n  return annotation;\n}",
        "import_statements": [
            "import com.github.legman.Subscribe;",
            "import com.google.common.base.Throwables;",
            "import com.google.common.collect.ImmutableSet;",
            "import com.google.common.collect.Maps;",
            "import com.google.common.collect.Sets;",
            "import jakarta.ws.rs.Path;",
            "import jakarta.ws.rs.ext.Provider;",
            "import org.kohsuke.MetaInfServices;",
            "import org.mapstruct.Mapper;",
            "import org.w3c.dom.DOMException;",
            "import org.w3c.dom.Document;",
            "import org.xml.sax.SAXException;",
            "import picocli.CommandLine;",
            "import sonia.scm.annotation.ClassSetElement.ClassWithAttributes;",
            "import sonia.scm.config.ConfigValue;",
            "import sonia.scm.plugin.PluginAnnotation;",
            "import sonia.scm.plugin.Requires;",
            "import javax.annotation.processing.AbstractProcessor;",
            "import javax.annotation.processing.Filer;",
            "import javax.annotation.processing.Processor;",
            "import javax.annotation.processing.RoundEnvironment;",
            "import javax.annotation.processing.SupportedAnnotationTypes;",
            "import javax.annotation.processing.SupportedSourceVersion;",
            "import javax.lang.model.SourceVersion;",
            "import javax.lang.model.element.AnnotationMirror;",
            "import javax.lang.model.element.AnnotationValue;",
            "import javax.lang.model.element.Element;",
            "import javax.lang.model.element.ElementKind;",
            "import javax.lang.model.element.ExecutableElement;",
            "import javax.lang.model.element.TypeElement;",
            "import javax.lang.model.element.VariableElement;",
            "import javax.tools.Diagnostic.Kind;",
            "import javax.tools.FileObject;",
            "import javax.tools.StandardLocation;",
            "import javax.xml.XMLConstants;",
            "import javax.xml.parsers.DocumentBuilder;",
            "import javax.xml.parsers.DocumentBuilderFactory;",
            "import javax.xml.parsers.ParserConfigurationException;",
            "import javax.xml.transform.OutputKeys;",
            "import javax.xml.transform.Transformer;",
            "import javax.xml.transform.TransformerConfigurationException;",
            "import javax.xml.transform.TransformerException;",
            "import javax.xml.transform.TransformerFactory;",
            "import javax.xml.transform.dom.DOMSource;",
            "import javax.xml.transform.stream.StreamResult;",
            "import java.io.File;",
            "import java.io.IOException;",
            "import java.lang.annotation.Annotation;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Set;",
            "import static javax.lang.model.util.ElementFilter.methodsIn;"
        ],
        "reference_api": [
            "getName",
            "equals",
            "replace",
            "toString",
            "getQualifiedName"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getName",
            "getQualifiedName"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def get_leave_application_filters(\n\temployee: str,\n\tapprover_id: str | None = None,\n\tfor_approval: bool = False,\n) -> dict",
        "start_line": "163",
        "end_line": "183",
        "file_path": "hrms/api/__init__.py",
        "docstring": "This function generates filters for retrieving leave applications based on the employee and optional approver ID. If `for_approval` is true, it sets filters to retrieve pending approval applications excluding the employee's own applications. It also applies workflow-based state filters or defaults to \"Open\" status. If `for_approval` is false, it filters applications based on the employee and excludes canceled applications.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "4002e89493bc",
        "ground_truth": "def get_leave_application_filters(\n employee: str,\n approver_id: str | None = None,\n for_approval: bool = False,\n) -> dict:\n filters = frappe._dict()\n if for_approval:\n  filters.docstatus = 0\n  filters.employee = (\"!=\", employee)\n   if workflow := get_workflow(\"Leave Application\"):\n   allowed_states = get_allowed_states_for_workflow(workflow, approver_id)\n   filters[workflow.workflow_state_field] = (\"in\", allowed_states)\n  else:\n   filters.status = \"Open\"\n   filters.leave_approver = approver_id\n else:\n  filters.docstatus = (\"!=\", 2)\n  filters.employee = employee\n  return filters",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model import get_permitted_fields",
            "from frappe.model.workflow import get_workflow_name",
            "from frappe.query_builder import Order",
            "from frappe.utils import getdate, strip_html"
        ],
        "reference_api": [
            "get_allowed_states_for_workflow",
            "get_workflow",
            "frappe._dict"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get_allowed_states_for_workflow",
                "code": "def get_allowed_states_for_workflow(workflow: dict, user_id: str) -> list[str]:\n\tuser_roles = frappe.get_roles(user_id)\n\treturn [transition.state for transition in workflow.transitions if transition.allowed in user_roles]"
            }
        ],
        "third_party": [
            "frappe._dict",
            "get_workflow"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def get_leave_balance_map(employee: str) -> dict[str, dict[str, float]]:",
        "start_line": "187",
        "end_line": "209",
        "file_path": "hrms/api/__init__.py",
        "docstring": "This function retrieves the leave balance map for a specified employee. It gets the current date and fetches leave details using the `get_leave_details` function. It then constructs a dictionary that maps each leave type to its allocated and balance leave details and returns this dictionary.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7bbb937df591",
        "ground_truth": "def get_leave_balance_map(employee: str) -> dict[str, dict[str, float]]:\n \"\"\"\n Returns a map of leave type and balance details like:\n {\n         'Casual Leave': {'allocated_leaves': 10.0, 'balance_leaves': 5.0},\n         'Earned Leave': {'allocated_leaves': 3.0, 'balance_leaves': 3.0},\n }\n \"\"\"\n from hrms.hr.doctype.leave_application.leave_application import get_leave_details\n  date = getdate()\n leave_map = {}\n  leave_details = get_leave_details(employee, date)\n allocation = leave_details[\"leave_allocation\"]\n  for leave_type, details in allocation.items():\n  leave_map[leave_type] = {\n   \"allocated_leaves\": details.get(\"total_leaves\"),\n   \"balance_leaves\": details.get(\"remaining_leaves\"),\n  }\n  return leave_map",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model import get_permitted_fields",
            "from frappe.model.workflow import get_workflow_name",
            "from frappe.query_builder import Order",
            "from frappe.utils import getdate, strip_html"
        ],
        "reference_api": [
            "details.get",
            "getdate",
            "allocation.items",
            "get_leave_details"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getdate",
            "get_leave_details",
            "allocation.items",
            "details.get",
            "details.get"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def get_holidays_for_employee(employee: str) -> list[dict]:",
        "start_line": "213",
        "end_line": "231",
        "file_path": "hrms/api/__init__.py",
        "docstring": "This function retrieves a list of holidays for a specified employee. It first obtains the holiday list for the employee. If no holiday list is found, it returns an empty list. Otherwise, it queries the holidays from the database, excluding weekly offs, and orders them by date. It then strips HTML from the holiday descriptions and returns the list of holidays.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "9d90f8f0917e",
        "ground_truth": "def get_holidays_for_employee(employee: str) -> list[dict]:\n from erpnext.setup.doctype.employee.employee import get_holiday_list_for_employee\n  holiday_list = get_holiday_list_for_employee(employee, raise_exception=False)\n if not holiday_list:\n  return []\n  Holiday = frappe.qb.DocType(\"Holiday\")\n holidays = (\n  frappe.qb.from_(Holiday)\n  .select(Holiday.name, Holiday.holiday_date, Holiday.description)\n  .where((Holiday.parent == holiday_list) & (Holiday.weekly_off == 0))\n  .orderby(Holiday.holiday_date, order=Order.asc)\n ).run(as_dict=True)\n  for holiday in holidays:\n  holiday[\"description\"] = strip_html(holiday[\"description\"] or \"\").strip()\n  return holidays",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model import get_permitted_fields",
            "from frappe.model.workflow import get_workflow_name",
            "from frappe.query_builder import Order",
            "from frappe.utils import getdate, strip_html"
        ],
        "reference_api": [
            "select",
            "run",
            "where",
            "strip_html",
            "from_",
            "DocType",
            "get_holiday_list_for_employee",
            "strip",
            "orderby"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "get_holiday_list_for_employee",
            "DocType",
            "run",
            "orderby",
            "where",
            "from_",
            "strip",
            "strip_html"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def send_reminders_in_advance_weekly()",
        "start_line": "16",
        "end_line": "22",
        "file_path": "hrms/controllers/employee_reminders.py",
        "docstring": "This function sends weekly holiday reminders in advance if the HR settings specify to send reminders and the frequency is set to \"Weekly.\" It retrieves the relevant settings and, if conditions are met, calls a function to send the reminders.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "a90ba556e53e",
        "ground_truth": "def send_reminders_in_advance_weekly():\n to_send_in_advance = int(frappe.db.get_single_value(\"HR Settings\", \"send_holiday_reminders\"))\n frequency = frappe.db.get_single_value(\"HR Settings\", \"frequency\")\n if not (to_send_in_advance and frequency == \"Weekly\"):\n  return\n  send_advance_holiday_reminders(\"Weekly\")",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.utils import add_days, add_months, comma_sep, getdate, today",
            "from erpnext.setup.doctype.employee.employee import get_all_employee_emails, get_employee_email",
            "from hrms.hr.utils import get_holidays_for_employee"
        ],
        "reference_api": [
            "get_single_value",
            "int",
            "send_advance_holiday_reminders"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "send_advance_holiday_reminders",
                "code": "def send_advance_holiday_reminders(frequency):\n\t\"\"\"Send Holiday Reminders in Advance to Employees\n\t`frequency` (str): 'Weekly' or 'Monthly'\n\t\"\"\"\n\tif frequency == \"Weekly\":\n\t\tstart_date = getdate()\n\t\tend_date = add_days(getdate(), 7)\n\telif frequency == \"Monthly\":\n\t\t# Sent on 1st of every month\n\t\tstart_date = getdate()\n\t\tend_date = add_months(getdate(), 1)\n\telse:\n\t\treturn\n\n\temployees = frappe.db.get_all(\"Employee\", filters={\"status\": \"Active\"}, pluck=\"name\")\n\tfor employee in employees:\n\t\tholidays = get_holidays_for_employee(\n\t\t\temployee, start_date, end_date, only_non_weekly=True, raise_exception=False\n\t\t)\n\n\t\tsend_holidays_reminder_in_advance(employee, holidays)"
            }
        ],
        "third_party": [
            "get_single_value",
            "get_single_value"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def calculate_self_appraisal_score(self)",
        "start_line": "164",
        "end_line": "170",
        "file_path": "hrms/hr/doctype/appraisal/appraisal.py",
        "docstring": "This function calculates the self-appraisal score for an employee. It iterates through self-ratings, computes the score for each entry by multiplying the rating by 5 and the percentage weightage, and accumulates the total score. The final self-appraisal score is set with appropriate precision.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "37594f7876f9",
        "ground_truth": "def calculate_self_appraisal_score(self):\n total = 0\n for entry in self.self_ratings:\n  score = flt(entry.rating) * 5 * flt(entry.per_weightage / 100)\n  total += flt(score)\n self.self_score = flt(total, self.precision(\"self_score\"))",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.query_builder.functions import Avg",
            "from frappe.utils import flt, get_link_to_form, now",
            "from hrms.hr.doctype.appraisal_cycle.appraisal_cycle import validate_active_appraisal_cycle",
            "from hrms.hr.utils import validate_active_employee",
            "from hrms.mixins.appraisal import AppraisalMixin",
            "from hrms.payroll.utils import sanitize_expression"
        ],
        "reference_api": [
            "self.precision",
            "flt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "flt",
            "flt",
            "flt",
            "flt",
            "self.precision"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def calculate_final_score(self)",
        "start_line": "185",
        "end_line": "208",
        "file_path": "hrms/hr/doctype/appraisal/appraisal.py",
        "docstring": "This function calculates the final score for an appraisal. It retrieves the appraisal cycle document and checks if the final score should be calculated based on a formula. If so, it gathers necessary data, sanitizes the formula, and evaluates it. Otherwise, it calculates the final score as the average of the total score, average feedback score, and self-appraisal score. The final score is then set with the appropriate precision.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "42120d2aae56",
        "ground_truth": "def calculate_final_score(self):\n final_score = 0\n appraisal_cycle_doc = frappe.get_cached_doc(\"Appraisal Cycle\", self.appraisal_cycle)\n formula = appraisal_cycle_doc.final_score_formula\n based_on_formula = appraisal_cycle_doc.calculate_final_score_based_on_formula\n if based_on_formula:\n  employee_doc = frappe.get_cached_doc(\"Employee\", self.employee)\n  data = {\n   \"goal_score\": flt(self.total_score),\n   \"average_feedback_score\": flt(self.avg_feedback_score),\n   \"self_appraisal_score\": flt(self.self_score),\n  }\n  data.update(appraisal_cycle_doc.as_dict())\n  data.update(employee_doc.as_dict())\n  data.update(self.as_dict())\n  sanitized_formula = sanitize_expression(formula)\n  final_score = frappe.safe_eval(sanitized_formula, data)\n else:\n  final_score = (flt(self.total_score) + flt(self.avg_feedback_score) + flt(self.self_score)) / 3\n self.final_score = flt(final_score, self.precision(\"final_score\"))",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.query_builder.functions import Avg",
            "from frappe.utils import flt, get_link_to_form, now",
            "from hrms.hr.doctype.appraisal_cycle.appraisal_cycle import validate_active_appraisal_cycle",
            "from hrms.hr.utils import validate_active_employee",
            "from hrms.mixins.appraisal import AppraisalMixin",
            "from hrms.payroll.utils import sanitize_expression"
        ],
        "reference_api": [
            "self.as_dict",
            "frappe.get_cached_doc",
            "self.precision",
            "flt",
            "sanitize_expression",
            "data.update",
            "employee_doc.as_dict",
            "frappe.safe_eval",
            "appraisal_cycle_doc.as_dict"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "sanitize_expression",
                "code": "def sanitize_expression(string: str | None = None) -> str | None:\n\t\"\"\"\n\tRemoves leading and trailing whitespace and merges multiline strings into a single line.\n\n\tArgs:\n\t    string (str, None): The string expression to be sanitized. Defaults to None.\n\n\tReturns:\n\t    str or None: The sanitized string expression or None if the input string is None.\n\n\tExample:\n\t    expression = \"\\r\\n    gross_pay > 10000\\n    \"\n\t    sanitized_expr = sanitize_expression(expression)\n\n\t\"\"\"\n\n\tif not string:\n\t\treturn None\n\n\tparts = string.strip().splitlines()\n\tstring = \" \".join(parts)\n\n\treturn string"
            }
        ],
        "third_party": [
            "frappe.get_cached_doc",
            "frappe.get_cached_doc",
            "flt",
            "flt",
            "flt",
            "data.update",
            "appraisal_cycle_doc.as_dict",
            "data.update",
            "employee_doc.as_dict",
            "data.update",
            "self.as_dict",
            "frappe.safe_eval",
            "flt",
            "flt",
            "flt",
            "flt",
            "self.precision"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def validate_attendance_date(self)",
        "start_line": "50",
        "end_line": "71",
        "file_path": "hrms/hr/doctype/attendance/attendance.py",
        "docstring": "This function validates the attendance date for an employee. It ensures that attendance is not marked for future dates unless the status is \"On Leave\" and there is no leave application. It also checks that the attendance date is not earlier than the employee's date of joining. If either condition is violated, it throws an error with an appropriate message.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "3ef1807aa706",
        "ground_truth": "def validate_attendance_date(self):\n date_of_joining = frappe.db.get_value(\"Employee\", self.employee, \"date_of_joining\")\n # leaves can be marked for future dates\n if (\n  self.status != \"On Leave\"\n  and not self.leave_application\n  and getdate(self.attendance_date) > getdate(nowdate())\n ):\n  frappe.throw(\n   _(\"Attendance can not be marked for future dates: {0}\").format(\n    frappe.bold(format_date(self.attendance_date)),\n   )\n  )\n elif date_of_joining and getdate(self.attendance_date) < getdate(date_of_joining):\n  frappe.throw(\n   _(\"Attendance date {0} can not be less than employee {1}'s joining date: {2}\").format(\n    frappe.bold(format_date(self.attendance_date)),\n    frappe.bold(self.employee),\n    frappe.bold(format_date(date_of_joining)),\n   )\n  )",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.utils import (\n\tadd_days,\n\tcint,\n\tcstr,\n\tformat_date,\n\tget_datetime,\n\tget_link_to_form,\n\tgetdate,\n\tnowdate,\n)",
            "from hrms.hr.doctype.shift_assignment.shift_assignment import has_overlapping_timings",
            "from hrms.hr.utils import (\n\tget_holiday_dates_for_employee,\n\tget_holidays_for_employee,\n\tvalidate_active_employee,\n)"
        ],
        "reference_api": [
            "frappe.bold",
            "format_date",
            "frappe.throw",
            "_",
            "get_value",
            "nowdate",
            "getdate",
            "format"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "get_value",
            "getdate",
            "getdate",
            "nowdate",
            "frappe.throw",
            "_",
            "frappe.bold",
            "format_date",
            "getdate",
            "getdate",
            "frappe.throw",
            "_",
            "frappe.bold",
            "format_date",
            "frappe.bold",
            "frappe.bold",
            "format_date"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def validate_duplicate_record(self)",
        "start_line": "73",
        "end_line": "85",
        "file_path": "hrms/hr/doctype/attendance/attendance.py",
        "docstring": "This function checks for duplicate attendance records for an employee on a given date. If a duplicate is found, it raises an exception with a message indicating the employee, the date, and a link to the existing attendance record.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "538dc53d23a6",
        "ground_truth": "def validate_duplicate_record(self):\n duplicate = self.get_duplicate_attendance_record()\n if duplicate:\n  frappe.throw(\n   _(\"Attendance for employee {0} is already marked for the date {1}: {2}\").format(\n    frappe.bold(self.employee),\n    frappe.bold(format_date(self.attendance_date)),\n    get_link_to_form(\"Attendance\", duplicate),\n   ),\n   title=_(\"Duplicate Attendance\"),\n   exc=DuplicateAttendanceError,\n  )",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.utils import (\n\tadd_days,\n\tcint,\n\tcstr,\n\tformat_date,\n\tget_datetime,\n\tget_link_to_form,\n\tgetdate,\n\tnowdate,\n)",
            "from hrms.hr.doctype.shift_assignment.shift_assignment import has_overlapping_timings",
            "from hrms.hr.utils import (\n\tget_holiday_dates_for_employee,\n\tget_holidays_for_employee,\n\tvalidate_active_employee,\n)"
        ],
        "reference_api": [
            "self.get_duplicate_attendance_record",
            "frappe.bold",
            "format_date",
            "frappe.throw",
            "_",
            "get_link_to_form",
            "format"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.get_duplicate_attendance_record",
                "code": "def get_duplicate_attendance_record(self) -> str | None:\n\t\tAttendance = frappe.qb.DocType(\"Attendance\")\n\t\tquery = (\n\t\t\tfrappe.qb.from_(Attendance)\n\t\t\t.select(Attendance.name)\n\t\t\t.where(\n\t\t\t\t(Attendance.employee == self.employee)\n\t\t\t\t& (Attendance.docstatus < 2)\n\t\t\t\t& (Attendance.attendance_date == self.attendance_date)\n\t\t\t\t& (Attendance.name != self.name)\n\t\t\t)\n\t\t)\n\n\t\tif self.shift:\n\t\t\tquery = query.where(\n\t\t\t\t((Attendance.shift.isnull()) | (Attendance.shift == \"\"))\n\t\t\t\t| (\n\t\t\t\t\t((Attendance.shift.isnotnull()) | (Attendance.shift != \"\"))\n\t\t\t\t\t& (Attendance.shift == self.shift)\n\t\t\t\t)\n\t\t\t)\n\n\t\tduplicate = query.run(pluck=True)\n\n\t\treturn duplicate[0] if duplicate else None"
            }
        ],
        "third_party": [
            "frappe.throw",
            "_",
            "frappe.bold",
            "frappe.bold",
            "format_date",
            "get_link_to_form",
            "_"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def send_summary(self)",
        "start_line": "31",
        "end_line": "44",
        "file_path": "hrms/hr/doctype/daily_work_summary/daily_work_summary.py",
        "docstring": "This function sends a daily summary of all replies to a specified group at midnight. It retrieves message details, gets the email addresses of users in the specified group, and sends an email with the summary using a template. After sending the email, it updates the status to \"Sent.\"",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7c73c326e62f",
        "ground_truth": "def send_summary(self):\n \"\"\"Send summary of all replies. Called at midnight\"\"\"\n args = self.get_message_details()\n emails = get_user_emails_from_group(self.daily_work_summary_group)\n frappe.sendmail(\n  recipients=emails,\n  template=\"daily_work_summary\",\n  args=args,\n  subject=_(self.daily_work_summary_group),\n  reference_doctype=self.doctype,\n  reference_name=self.name,\n )\n self.db_set(\"status\", \"Sent\")",
        "import_statements": [
            "from email_reply_parser import EmailReplyParser",
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.utils import global_date_format"
        ],
        "reference_api": [
            "get_user_emails_from_group",
            "frappe.sendmail",
            "self.get_message_details",
            "_",
            "self.db_set"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.get_message_details",
                "code": "def get_message_details(self):\n\t\t\"\"\"Return args for template\"\"\"\n\t\tdws_group = frappe.get_doc(\"Daily Work Summary Group\", self.daily_work_summary_group)\n\n\t\treplies = frappe.get_all(\n\t\t\t\"Communication\",\n\t\t\tfields=[\"content\", \"text_content\", \"sender\"],\n\t\t\tfilters=dict(\n\t\t\t\treference_doctype=self.doctype,\n\t\t\t\treference_name=self.name,\n\t\t\t\tcommunication_type=\"Communication\",\n\t\t\t\tsent_or_received=\"Received\",\n\t\t\t),\n\t\t\torder_by=\"creation asc\",\n\t\t)\n\n\t\tdid_not_reply = self.email_sent_to.split()\n\n\t\tfor d in replies:\n\t\t\tuser = frappe.db.get_values(\n\t\t\t\t\"User\", {\"email\": d.sender}, [\"full_name\", \"user_image\"], as_dict=True\n\t\t\t)\n\n\t\t\td.sender_name = user[0].full_name if user else d.sender\n\t\t\td.image = user[0].image if user and user[0].image else None\n\n\t\t\toriginal_image = d.image\n\t\t\t# make thumbnail image\n\t\t\ttry:\n\t\t\t\tif original_image:\n\t\t\t\t\tfile_name = frappe.get_list(\"File\", {\"file_url\": original_image})\n\n\t\t\t\t\tif file_name:\n\t\t\t\t\t\tfile_name = file_name[0].name\n\t\t\t\t\t\tfile_doc = frappe.get_doc(\"File\", file_name)\n\t\t\t\t\t\tthumbnail_image = file_doc.make_thumbnail(\n\t\t\t\t\t\t\tset_as_thumbnail=False, width=100, height=100, crop=True\n\t\t\t\t\t\t)\n\t\t\t\t\t\td.image = thumbnail_image\n\t\t\texcept Exception:\n\t\t\t\td.image = original_image\n\n\t\t\tif d.sender in did_not_reply:\n\t\t\t\tdid_not_reply.remove(d.sender)\n\t\t\tif d.text_content:\n\t\t\t\td.content = frappe.utils.md_to_html(EmailReplyParser.parse_reply(d.text_content))\n\n\t\tdid_not_reply = [\n\t\t\t(frappe.db.get_value(\"User\", {\"email\": email}, \"full_name\") or email) for email in did_not_reply\n\t\t]\n\n\t\treturn dict(\n\t\t\treplies=replies,\n\t\t\toriginal_message=dws_group.message,\n\t\t\ttitle=_(\"Work Summary for {0}\").format(global_date_format(self.creation)),\n\t\t\tdid_not_reply=\", \".join(did_not_reply) or \"\",\n\t\t\tdid_not_reply_title=_(\"No replies from\"),\n\t\t)"
            },
            {
                "name": "get_user_emails_from_group",
                "code": "def get_user_emails_from_group(group):\n\t\"\"\"Returns list of email of enabled users from the given group\n\n\t:param group: Daily Work Summary Group `name`\"\"\"\n\tgroup_doc = group\n\tif isinstance(group_doc, str):\n\t\tgroup_doc = frappe.get_doc(\"Daily Work Summary Group\", group)\n\n\temails = get_users_email(group_doc)\n\n\treturn emails"
            }
        ],
        "third_party": [
            "frappe.sendmail",
            "_",
            "self.db_set"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def validate_duplicate_interview(self)",
        "start_line": "31",
        "end_line": "45",
        "file_path": "hrms/hr/doctype/interview/interview.py",
        "docstring": "This function checks for duplicate interview records for a job applicant in the same interview round. If a duplicate is found, it raises an exception with a message indicating that job applicants are not allowed to appear twice for the same interview round, including a link to the existing interview record and the job applicant's information.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "18973acd73bf",
        "ground_truth": "def validate_duplicate_interview(self):\n duplicate_interview = frappe.db.exists(\n  \"Interview\",\n  {\"job_applicant\": self.job_applicant, \"interview_round\": self.interview_round, \"docstatus\": 1},\n )\n if duplicate_interview:\n  frappe.throw(\n   _(\n    \"Job Applicants are not allowed to appear twice for the same Interview round. Interview {0} already scheduled for Job Applicant {1}\"\n   ).format(\n    frappe.bold(get_link_to_form(\"Interview\", duplicate_interview)),\n    frappe.bold(self.job_applicant),\n   )\n  )",
        "import_statements": [
            "import datetime",
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.query_builder.functions import Avg",
            "from frappe.utils import cint, cstr, get_datetime, get_link_to_form, getdate, nowtime"
        ],
        "reference_api": [
            "exists",
            "frappe.bold",
            "frappe.throw",
            "_",
            "get_link_to_form",
            "format"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "exists",
            "frappe.throw",
            "_",
            "frappe.bold",
            "get_link_to_form",
            "frappe.bold"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def calculate_average_rating(self)",
        "start_line": "57",
        "end_line": "65",
        "file_path": "hrms/hr/doctype/interview_feedback/interview_feedback.py",
        "docstring": "This function calculates the average rating from a list of skill assessments. It sums the ratings of all assessments that have a rating and then divides the total by the number of assessments to get the average. The result is stored in the `average_rating` attribute. If there are no assessments, the average rating is set to 0.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "2f305a78ebff",
        "ground_truth": "def calculate_average_rating(self):\n total_rating = 0\n for d in self.skill_assessment:\n  if d.rating:\n   total_rating += flt(d.rating)\n self.average_rating = flt(\n  total_rating / len(self.skill_assessment) if len(self.skill_assessment) else 0\n )",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.query_builder.functions import Avg",
            "from frappe.utils import flt, get_link_to_form, getdate"
        ],
        "reference_api": [
            "len",
            "flt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "flt",
            "flt"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def create_interview(doc):",
        "start_line": "16",
        "end_line": "30",
        "file_path": "hrms/hr/doctype/interview_round/interview_round.py",
        "docstring": "This function creates a new Interview document. It takes a document as input, which can be a string or a dictionary. It initializes the Interview document with the interview round and designation from the input. If interviewers are provided, it adds them to the interview details. The function then returns the created Interview document.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "b4fe0be54386",
        "ground_truth": "def create_interview(doc):\n if isinstance(doc, str):\n  doc = json.loads(doc)\n  doc = frappe.get_doc(doc)\n  interview = frappe.new_doc(\"Interview\")\n interview.interview_round = doc.name\n interview.designation = doc.designation\n  if doc.interviewers:\n  interview.interview_details = []\n  for d in doc.interviewers:\n   interview.append(\"interview_details\", {\"interviewer\": d.user})\n  return interview",
        "import_statements": [
            "import json",
            "import frappe",
            "from frappe.model.document import Document"
        ],
        "reference_api": [
            "json.loads",
            "frappe.new_doc",
            "isinstance",
            "frappe.get_doc",
            "interview.append"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "frappe.get_doc",
            "frappe.new_doc",
            "interview.append"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def get_job_offer(self, from_date, to_date)",
        "start_line": "44",
        "end_line": "55",
        "file_path": "hrms/hr/doctype/job_offer/job_offer.py",
        "docstring": "This function retrieves job offers created within a specified date range for a particular designation and company, where the document status is 1 (submitted). It returns a list of job offer names matching these criteria.",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "685e05773636",
        "ground_truth": "def get_job_offer(self, from_date, to_date):\n \"\"\"Returns job offer created during a time period\"\"\"\n return frappe.get_all(\n  \"Job Offer\",\n  filters={\n   \"offer_date\": [\"between\", (from_date, to_date)],\n   \"designation\": self.designation,\n   \"company\": self.company,\n   \"docstatus\": 1,\n  },\n  fields=[\"name\"],\n )",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.model.mapper import get_mapped_doc",
            "from frappe.utils import cint, flt, get_link_to_form"
        ],
        "reference_api": [
            "frappe.get_all"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "frappe.get_all"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "frappe/hrms",
        "function_declaration": "def get_offer_acceptance_rate(company=None, department=None)",
        "start_line": "110",
        "end_line": "125",
        "file_path": "hrms/hr/doctype/job_offer/job_offer.py",
        "docstring": "This function calculates the offer acceptance rate for job offers, optionally filtered by company or department. It counts the total job offers with a docstatus of 1 and the accepted job offers within those filters. It then returns the acceptance rate as a percentage, along with the field type \"Percent.\"",
        "language": "Python",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "2bdb2c2e712f",
        "ground_truth": "def get_offer_acceptance_rate(company=None, department=None):\n filters = {\"docstatus\": 1}\n if company:\n  filters[\"company\"] = company\n if department:\n  filters[\"department\"] = department\n  total_offers = frappe.db.count(\"Job Offer\", filters=filters)\n  filters[\"status\"] = \"Accepted\"\n total_accepted = frappe.db.count(\"Job Offer\", filters=filters)\n  return {\n  \"value\": flt(total_accepted) / flt(total_offers) * 100 if total_offers else 0,\n  \"fieldtype\": \"Percent\",\n }",
        "import_statements": [
            "import frappe",
            "from frappe import _",
            "from frappe.model.document import Document",
            "from frappe.model.mapper import get_mapped_doc",
            "from frappe.utils import cint, flt, get_link_to_form"
        ],
        "reference_api": [
            "count",
            "flt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "count",
            "count",
            "flt",
            "flt"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "ahmet-cetinkaya/hrms-project-backend",
        "function_declaration": "public ResponseEntity<Result> register(@Valid @RequestBody final EmployerForRegisterDto employerForRegisterDto)",
        "start_line": "51",
        "end_line": "58",
        "file_path": "src/main/java/ahmetcetinkaya/HRMSProjectBackend/api/controllers/EmployersController.java",
        "docstring": "This function handles the registration of an employer. It validates the incoming EmployerForRegisterDto request body and calls the employerService to register the employer. If the registration is unsuccessful, it returns a BAD_REQUEST response with the result. Otherwise, it returns an OK response with the result.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "7d5dc5673c02",
        "ground_truth": "public ResponseEntity<Result> register(@Valid @RequestBody final EmployerForRegisterDto employerForRegisterDto) {\n final Result result = employerService.register(employerForRegisterDto);\n if (!result.isSuccess())\n  return new ResponseEntity<>(result, HttpStatus.BAD_REQUEST);\n return ResponseEntity.ok(result);\n}",
        "import_statements": [
            "import java.util.List;",
            "import javax.validation.Valid;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.http.HttpStatus;",
            "import org.springframework.http.ResponseEntity;",
            "import org.springframework.web.bind.annotation.*;",
            "import org.springframework.web.multipart.MultipartFile;",
            "import ahmetcetinkaya.HRMSProjectBackend.business.abstracts.EmployerService;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.api.abstracts.BaseController;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.utilities.results.DataResult;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.utilities.results.Result;",
            "import ahmetcetinkaya.HRMSProjectBackend.entities.concretes.Employer;",
            "import ahmetcetinkaya.HRMSProjectBackend.entities.concretes.EmployerUpdate;",
            "import ahmetcetinkaya.HRMSProjectBackend.entities.dtos.EmployerForRegisterDto;",
            "import ahmetcetinkaya.HRMSProjectBackend.entities.dtos.EmployerForUpdateDto;"
        ],
        "reference_api": [
            "register",
            "isSuccess",
            "ok"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "register",
                "code": "@PostMapping(\"/register\")\n\tpublic ResponseEntity<Result> register(@Valid @RequestBody final EmployerForRegisterDto employerForRegisterDto) {\n\t\tfinal Result result = employerService.register(employerForRegisterDto);\n\n\t\tif (!result.isSuccess())\n\t\t\treturn new ResponseEntity<>(result, HttpStatus.BAD_REQUEST);\n\n\t\treturn ResponseEntity.ok(result);\n\t}"
            }
        ],
        "third_party": [
            "isSuccess",
            "ok"
        ]
    },
    {
        "subclass": "HRMS",
        "owner/repo": "ahmet-cetinkaya/hrms-project-backend",
        "function_declaration": "public Result updateByUser(final CompanyStaffForUpdateDto companyStaffForUpdateDto) ",
        "start_line": "35",
        "end_line": "50",
        "file_path": "src/main/java/ahmetcetinkaya/HRMSProjectBackend/business/concretes/CompanyStaffManager.java",
        "docstring": "This function updates company staff details based on a provided DTO. It first retrieves the staff record by ID, returning an error result if not found. It then checks business rules, specifically if the provided password matches the existing one. If the rules check fails, it returns the failure result. If successful, it updates the staff's first and last names, saves the changes, and returns a success result indicating the staff was updated.",
        "language": "Java",
        "commit_sha": "",
        "created_time": "",
        "instance_id": "3753dc9d4e57",
        "ground_truth": "public Result updateByUser(final CompanyStaffForUpdateDto companyStaffForUpdateDto) {\n final Optional<CompanyStaff> companyStaff = companyStaffDao.findById(companyStaffForUpdateDto.getId());\n if (companyStaff.isEmpty())\n  return new ErrorResult(Messages.notFound(\"Company staff\"));\n final Result businessRulesResult = BusinessRules\n   .run(arePasswordMatch(companyStaff.get().getPassword(), companyStaffForUpdateDto.getPassword()));\n if (!businessRulesResult.isSuccess())\n  return businessRulesResult;\n companyStaff.get().setFirstName(companyStaffForUpdateDto.getFirstName());\n companyStaff.get().setLastName(companyStaffForUpdateDto.getLastName());\n companyStaffDao.save(companyStaff.get());\n return new SuccessResult(Messages.updated(\"Company Staff\"));\n}",
        "import_statements": [
            "import java.util.Optional;",
            "import org.springframework.beans.factory.annotation.Autowired;",
            "import org.springframework.stereotype.Service;",
            "import ahmetcetinkaya.HRMSProjectBackend.business.abstracts.CompanyStaffService;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.business.abstracts.BaseManager;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.business.constants.Messages;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.utilities.business.BusinessRules;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.utilities.results.ErrorResult;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.utilities.results.Result;",
            "import ahmetcetinkaya.HRMSProjectBackend.core.utilities.results.SuccessResult;",
            "import ahmetcetinkaya.HRMSProjectBackend.dataAccess.abstracts.CompanyStaffDao;",
            "import ahmetcetinkaya.HRMSProjectBackend.entities.concretes.CompanyStaff;",
            "import ahmetcetinkaya.HRMSProjectBackend.entities.dtos.CompanyStaffForUpdateDto;"
        ],
        "reference_api": [
            "arePasswordMatch",
            "save",
            "isSuccess",
            "notFound",
            "run",
            "setLastName",
            "getLastName",
            "updated",
            "getFirstName",
            "get",
            "getId",
            "findById",
            "setFirstName",
            "getPassword",
            "isEmpty"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "arePasswordMatch",
                "code": "private Result arePasswordMatch(final String password, final String confirmPassword) {\n\t\treturn password.equals(confirmPassword) ? new SuccessResult() : new ErrorResult(Messages.passwordsNotMatch);\n\t}"
            }
        ],
        "third_party": [
            "save",
            "isSuccess",
            "notFound",
            "run",
            "setLastName",
            "getLastName",
            "updated",
            "getFirstName",
            "get",
            "getId",
            "findById",
            "setFirstName",
            "getPassword",
            "isEmpty"
        ]
    }
]