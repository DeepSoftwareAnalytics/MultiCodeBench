[
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)",
        "start_line": "194",
        "end_line": "218",
        "file_path": "Marlin/src/HAL/DUE/usb/udc.c",
        "docstring": "The function \"udc_next_desc_in_iface\" searches for the next USB descriptor within a given interface descriptor.\\nIt starts from the provided descriptor, moves to the next descriptor by incrementing the descriptor pointer by the length of the current descriptor, and continues this until it either finds the specified descriptor type or reaches the end of the configuration descriptor.\\nIf it finds the specified descriptor type, it returns a pointer to that descriptor; otherwise, it returns \"NULL\".",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "37c223ece5db",
        "ground_truth": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n  UDC_DESC_STORAGE * desc, uint8_t desc_id)\n{\n usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;\n  ptr_eof_desc = udc_get_eof_conf();\n // Go to next descriptor\n desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +\n   desc->bLength);\n // Check the end of configuration descriptor\n while (ptr_eof_desc > desc) {\n  // If new interface descriptor is found,\n  // then it is the end of the current global interface descriptor\n  if (USB_DT_INTERFACE == desc->bDescriptorType) {\n   break; // End of global interface descriptor\n  }\n  if (desc_id == desc->bDescriptorType) {\n   return desc; // Specific descriptor found\n  }\n  // Go to next descriptor\n  desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +\n    desc->bLength);\n }\n return NULL; // No specific descriptor found\n}",
        "import_statements": [],
        "reference_api": [
            "udc_get_eof_conf"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "udc_get_eof_conf"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)",
        "start_line": "230",
        "end_line": "265",
        "file_path": "Marlin/src/HAL/DUE/usb/udc.c",
        "docstring": "The function \"udc_update_iface_desc\" checks if a specified interface descriptor with a given setting number exists within the current USB configuration.\\nIt first verifies that there is a valid configuration and that the interface number is within bounds.\\nIt then iterates through the descriptors, starting from the beginning of the configuration descriptor, and checks each one to see if it matches the specified interface number and setting number.\\nIf it finds a matching interface descriptor, it returns \"true\"; otherwise, it returns \"false\".",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4feb3728e1a8",
        "ground_truth": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\n{\n usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;\n  if (0 == udc_num_configuration) {\n  return false;\n }\n  if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n  return false;\n }\n  // Start at the beginning of configuration descriptor\n udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)\n   udc_ptr_conf->desc;\n  // Check the end of configuration descriptor\n ptr_end_desc = udc_get_eof_conf();\n while (ptr_end_desc >\n   (UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {\n  if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {\n   // A interface descriptor is found\n   // Check interface and alternate setting number\n   if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&\n     (setting_num ==\n     udc_ptr_iface->bAlternateSetting)) {\n    return true; // Interface found\n   }\n  }\n  // Go to next descriptor\n  udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (\n    (uint8_t *) udc_ptr_iface +\n    udc_ptr_iface->bLength);\n }\n return false; // Interface not found\n}",
        "import_statements": [],
        "reference_api": [
            "udc_get_eof_conf"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "udc_get_eof_conf"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "static bool udc_req_std_ep_get_status(void)",
        "start_line": "443",
        "end_line": "457",
        "file_path": "Marlin/src/HAL/DUE/usb/udc.c",
        "docstring": "The function \"udc_req_std_ep_get_status\" handles a standard request to get the status of a USB endpoint.\\nIt first checks if the request length matches the size of the endpoint status variable.\\nIt then determines the status of the specified endpoint, setting the status to \"halted\" if the endpoint is halted, or \"0\" if it is not.\\nFinally, it sets up the response payload with the endpoint status and returns \"true\".",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4e3b5aff2b43",
        "ground_truth": "static bool udc_req_std_ep_get_status(void)\n{\n static le16_t udc_ep_status;\n  if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {\n  return false;\n }\n  udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.\n   wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;\n  udd_set_setup_payload( (uint8_t *) & udc_ep_status,\n   sizeof(udc_ep_status));\n return true;\n}",
        "import_statements": [],
        "reference_api": [
            "udd_ep_is_halted",
            "CPU_TO_LE16",
            "udd_set_setup_payload"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "udd_ep_is_halted",
            "CPU_TO_LE16",
            "udd_set_setup_payload"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "static bool udc_req_iface(void)",
        "start_line": "1029",
        "end_line": "1057",
        "file_path": "Marlin/src/HAL/DUE/usb/udc.c",
        "docstring": "The function \"udc_req_iface\" processes a USB control request for a specific interface.\\nIt first checks if the device is in a configured state and if the requested interface number is valid.\\nIt updates the interface descriptor to the default setting and then to the current alternate setting.\\nIf both updates are successful, it forwards the SETUP request to the corresponding USB Device Interface (UDI) handler and returns the result of the handler's setup function.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0d705073305d",
        "ground_truth": "static bool udc_req_iface(void)\n{\n uint8_t iface_num;\n udi_api_t UDC_DESC_STORAGE *udi_api;\n  if (0 == udc_num_configuration) {\n  return false; // The device is not is configured state yet\n }\n // Check interface number\n iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;\n if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n  return false;\n }\n  //* To update udc_ptr_iface with the selected interface in request\n // Select first alternate setting of interface to update udc_ptr_iface\n // before calling udi_api->getsetting()\n if (!udc_update_iface_desc(iface_num, 0)) {\n  return false;\n }\n // Select the interface with the current alternate setting\n udi_api = udc_ptr_conf->udi_apis[iface_num];\n if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {\n  return false;\n }\n  // Send the SETUP request to the UDI corresponding to the interface number\n return udi_api->setup();\n}",
        "import_statements": [],
        "reference_api": [
            "udc_update_iface_desc",
            "udi_api->setup",
            "udi_api->getsetting"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "udc_update_iface_desc",
                "code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\n{\n\tusb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;\n\n\tif (0 == udc_num_configuration) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t// Start at the beginning of configuration descriptor\n\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)\n\t\t\tudc_ptr_conf->desc;\n\n\t// Check the end of configuration descriptor\n\tptr_end_desc = udc_get_eof_conf();\n\twhile (ptr_end_desc >\n\t\t\t(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {\n\t\tif (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {\n\t\t\t// A interface descriptor is found\n\t\t\t// Check interface and alternate setting number\n\t\t\tif ((iface_num == udc_ptr_iface->bInterfaceNumber) &&\n\t\t\t\t\t(setting_num ==\n\t\t\t\t\tudc_ptr_iface->bAlternateSetting)) {\n\t\t\t\treturn true; // Interface found\n\t\t\t}\n\t\t}\n\t\t// Go to next descriptor\n\t\tudc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (\n\t\t\t\t(uint8_t *) udc_ptr_iface +\n\t\t\t\tudc_ptr_iface->bLength);\n\t}\n\treturn false; // Interface not found\n}"
            }
        ],
        "third_party": [
            "udi_api->setup",
            "udi_api->getsetting"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "bool udi_msc_enable(void)",
        "start_line": "369",
        "end_line": "390",
        "file_path": "Marlin/src/HAL/DUE/usb/udi_msc.c",
        "docstring": "The function \"udi_msc_enable\" initializes and enables the USB Mass Storage Class (MSC) interface.\\nIt sets initial states for several flags, retrieves the number of Logical Unit Numbers (LUNs), and checks if there are any LUNs available.\\nIf no LUNs are available or if the external enable function fails, it returns \"false\".\\nOtherwise, it unloads the medium on each LUN and starts the MSC process by waiting for a Command Block Wrapper (CBW) reception, finally returning \"true\".",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cfe149164a72",
        "ground_truth": "bool udi_msc_enable(void) {\n  uint8_t lun;\n  udi_msc_b_trans_req = false;\n  udi_msc_b_cbw_invalid = false;\n  udi_msc_b_ack_trans = true;\n  udi_msc_b_reset_trans = true;\n  udi_msc_nb_lun = get_nb_lun();\n  if (0 == udi_msc_nb_lun)\n    return false; // No lun available, then not authorize to enable interface\n  udi_msc_nb_lun--;\n  // Call application callback\n  // to initialize memories or signal that interface is enabled\n  if (!UDI_MSC_ENABLE_EXT())\n    return false;\n  // Load the medium on each LUN\n  for (lun = 0; lun <= udi_msc_nb_lun; lun ++) {\n    mem_unload(lun, false);\n  }\n  // Start MSC process by CBW reception\n  udi_msc_cbw_wait();\n  return true;\n}",
        "import_statements": [],
        "reference_api": [
            "udi_msc_cbw_wait",
            "mem_unload",
            "get_nb_lun",
            "UDI_MSC_ENABLE_EXT"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "udi_msc_cbw_wait",
                "code": "static void udi_msc_cbw_wait(void) {\n  // Register buffer and callback on OUT endpoint\n  if (!udd_ep_run(UDI_MSC_EP_OUT, true,\n          (uint8_t *) & udi_msc_cbw,\n          sizeof(udi_msc_cbw),\n          udi_msc_cbw_received)) {\n    // OUT endpoint not available (halted), then wait a clear of halt.\n    udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_wait);\n  }\n}"
            }
        ],
        "third_party": [
            "mem_unload",
            "get_nb_lun",
            "UDI_MSC_ENABLE_EXT"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)",
        "start_line": "607",
        "end_line": "620",
        "file_path": "Marlin/src/HAL/DUE/usb/udi_msc.c",
        "docstring": "The function \"udi_msc_data_sent\" handles the completion of a data transfer in the USB Mass Storage Class (MSC).\\nIt first checks the status of the transfer, and if it is not successful, it waits for a MSC setup reset to restart CBW reception.\\nIf the transfer is successful, it updates the sense data, decreases the data residue in the Command Status Wrapper (CSW) by the amount of data sent, and processes the updated CSW.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "87967e204674",
        "ground_truth": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep) {\n  UNUSED(ep);\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Error protocol\n    // Now wait MSC setup reset to relaunch CBW reception\n    return;\n  }\n  // Update sense data\n  udi_msc_sense_pass();\n  // Update CSW\n  udi_msc_csw.dCSWDataResidue -= nb_sent;\n  udi_msc_csw_process();\n}",
        "import_statements": [],
        "reference_api": [
            "udi_msc_csw_process",
            "UNUSED",
            "udi_msc_sense_pass"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "udi_msc_csw_process",
                "code": "static void udi_msc_csw_process(void) {\n  if (0 != udi_msc_csw.dCSWDataResidue) {\n    // Residue not NULL\n    // then STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n  }\n  // Prepare and send CSW\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n  udi_msc_csw_send();\n}"
            },
            {
                "name": "udi_msc_sense_pass",
                "code": "static void udi_msc_sense_pass(void) {\n  udi_msc_clear_sense();\n  udi_msc_csw.bCSWStatus = USB_CSW_STATUS_PASS;\n}"
            }
        ],
        "third_party": [
            "UNUSED"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "static void udi_msc_csw_process(void)",
        "start_line": "625",
        "end_line": "638",
        "file_path": "Marlin/src/HAL/DUE/usb/udi_msc.c",
        "docstring": "The function \"udi_msc_csw_process\" handles the processing of the Command Status Wrapper (CSW) in a USB Mass Storage Class device.\\nIf there is a non-zero data residue, it stalls the next request from the USB host on the appropriate endpoint based on the direction of the Command Block Wrapper (CBW).\\nIt then prepares the CSW by setting its tag and converting the data residue to little-endian format before sending the CSW.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "223e49dddfc0",
        "ground_truth": "static void udi_msc_csw_process(void) {\n  if (0 != udi_msc_csw.dCSWDataResidue) {\n    // Residue not NULL\n    // then STALL next request from USB host on corresponding endpoint\n    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)\n      udd_ep_set_halt(UDI_MSC_EP_IN);\n    else\n      udd_ep_set_halt(UDI_MSC_EP_OUT);\n  }\n  // Prepare and send CSW\n  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n  udi_msc_csw_send();\n}",
        "import_statements": [],
        "reference_api": [
            "udd_ep_set_halt",
            "cpu_to_le32",
            "udi_msc_csw_send"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "udi_msc_csw_send",
                "code": "void udi_msc_csw_send(void) {\n  // Sends CSW on IN endpoint\n  if (!udd_ep_run(UDI_MSC_EP_IN, false,\n          (uint8_t *) & udi_msc_csw,\n          sizeof(udi_msc_csw),\n          udi_msc_csw_sent)) {\n    // Endpoint not available\n    // then restart CSW sent when endpoint IN STALL will be cleared\n    udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_send);\n  }\n}"
            }
        ],
        "third_party": [
            "udd_ep_set_halt",
            "cpu_to_le32"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)",
        "start_line": "99",
        "end_line": "123",
        "file_path": "Marlin/src/HAL/DUE/usb/usb_task.c",
        "docstring": "The function \"usb_task_cdc_set_dtr\" manages the Data Terminal Ready (DTR) signal for a specified USB port.\\nIt updates the DTR status and checks if the DTR rate is 1200.\\nIf the rate is 1200 and the DTR signal is disabled, it schedules a delayed system reset by writing to the reset controller and calling \"initiateReset\".\\nIf the DTR signal is enabled, it cancels any scheduled reset by calling \"cancelReset\".",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "839b7d837327",
        "ground_truth": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable) {\n  UNUSED(port);\n  // Keep DTR status\n  main_b_dtr_active = b_enable;\n   //  Implement Arduino-Compatible kludge to enter programming mode from\n  // the native port:\n  //  \"Auto-reset into the bootloader is triggered when the port, already\n  // open at 1200 bps, is closed.\"\n   if (1200 == dwDTERate) {\n    // We check DTR state to determine if host port is open (bit 0 of lineState).\n    if (!b_enable) {\n       // Set RST pin to go low for 65535 clock cycles on reset\n      //  This helps restarting when firmware flash ends\n      RSTC->RSTC_MR = 0xA5000F01;\n       // Schedule delayed reset\n      initiateReset(250);\n    }\n    else\n      cancelReset();\n  }\n}",
        "import_statements": [],
        "reference_api": [
            "cancelReset",
            "UNUSED",
            "initiateReset"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cancelReset",
            "UNUSED",
            "initiateReset"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "bool usb_task_other_requests(void)",
        "start_line": "266",
        "end_line": "299",
        "file_path": "Marlin/src/HAL/DUE/usb/usb_task.c",
        "docstring": "The function \"usb_task_other_requests\" handles USB vendor-specific requests.\\nIt checks the request type and processes specific request indices (0x04 and 0x05) to set up pointers and sizes for Microsoft-compatible ID and extended properties descriptors.\\nIt then updates the control request payload and size accordingly, returning \"true\" if the request is processed, or \"false\" if the request index is not recognized.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1583927e29c8",
        "ground_truth": "bool usb_task_other_requests(void) {\n  uint8_t *ptr = 0;\n  uint16_t size = 0;\n   if (Udd_setup_type() == USB_REQ_TYPE_VENDOR) {\n    //if (udd_g_ctrlreq.req.bRequest == 0x30)\n    if (1) {\n      if (udd_g_ctrlreq.req.wIndex == 0x04) {\n        ptr = (uint8_t*)&microsoft_compatible_id_descriptor;\n        size = (udd_g_ctrlreq.req.wLength);\n        if (size > microsoft_compatible_id_descriptor.dwLength)\n          size = microsoft_compatible_id_descriptor.dwLength;\n      }\n      else if (udd_g_ctrlreq.req.wIndex == 0x05) {\n        ptr = (uint8_t*)&microsoft_extended_properties_descriptor;\n        size = (udd_g_ctrlreq.req.wLength);\n        if (size > microsoft_extended_properties_descriptor.dwLength)\n          size = microsoft_extended_properties_descriptor.dwLength;\n      }\n      else\n        return false;\n    }\n  }\n   udd_g_ctrlreq.payload_size = size;\n  if (size == 0) {\n    udd_g_ctrlreq.callback = 0;\n    udd_g_ctrlreq.over_under_run = 0;\n  }\n  else\n    udd_g_ctrlreq.payload = ptr;\n   return true;\n}",
        "import_statements": [],
        "reference_api": [
            "Udd_setup_type"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Udd_setup_type"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void spiRead(uint8_t *buf, uint16_t nbyte)",
        "start_line": "642",
        "end_line": "653",
        "file_path": "Marlin/src/HAL/DUE/HAL_SPI.cpp",
        "docstring": "The function \"spiRead\" reads a specified number of bytes from an SPI device into a buffer.\\nIt first checks if the number of bytes to read is zero, returning immediately if true.\\nFor each byte to be read, it sends a dummy byte to the SPI transmit data register, waits for a byte to be received, and then stores the received byte into the buffer.\\nFinally, it reads the last byte using the \"spiRec\" function and stores it in the buffer.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6deb4a0512e1",
        "ground_truth": "void spiRead(uint8_t *buf, uint16_t nbyte) {\n  if (!nbyte) return;\n  --nbyte;\n  for (int i = 0; i < nbyte; i++) {\n    //WHILE_TX(0);\n    SPI0->SPI_TDR = 0x000000FF | SPI_PCS(SPI_CHAN);\n    WHILE_RX(0);\n    buf[i] = SPI0->SPI_RDR;\n    //DELAY_US(1U);\n  }\n  buf[nbyte] = spiRec();\n}",
        "import_statements": [],
        "reference_api": [
            "spiRec",
            "SPI_PCS",
            "WHILE_RX"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "spiRec",
            "SPI_PCS",
            "WHILE_RX"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)",
        "start_line": "78",
        "end_line": "96",
        "file_path": "Marlin/src/HAL/DUE/InterruptVectors.cpp",
        "docstring": "The function \"install_isr\" installs a new interrupt service routine (ISR) handler for a specified interrupt request (IRQ) and returns the original handler.\\nIt first retrieves the address of the relocated interrupt vector table, then disables global interrupts to ensure atomic operation.\\nIt retrieves the current handler for the specified IRQ, replaces it with the new handler, and then re-enables global interrupts.\\nFinally, it returns the original ISR handler.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6f07faaace16",
        "ground_truth": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler) {\n  // Get the address of the relocated table\n  pfnISR_Handler *isrtab = get_relocated_table_addr();\n   // Disable global interrupts\n  CRITICAL_SECTION_START();\n   // Get the original handler\n  pfnISR_Handler oldHandler = isrtab[irq + 16];\n   // Install the new one\n  isrtab[irq + 16] = newHandler;\n   // Reenable interrupts\n  CRITICAL_SECTION_END();\n   // Return the original one\n  return oldHandler;\n}",
        "import_statements": [],
        "reference_api": [
            "CRITICAL_SECTION_START",
            "get_relocated_table_addr",
            "CRITICAL_SECTION_END"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "CRITICAL_SECTION_START",
            "get_relocated_table_addr",
            "CRITICAL_SECTION_END"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "int MarlinSerialUSB::peek()",
        "start_line": "54",
        "end_line": "71",
        "file_path": "Marlin/src/HAL/DUE/MarlinSerialUSB.cpp",
        "docstring": "The function \"MarlinSerialUSB::peek\" checks for a pending character in the serial USB buffer and returns it if available.\\nIf a pending character exists, it returns that character.\\nIf the USB CDC is not enabled or configured on the PC side, or if no bytes are sent from the PC, it returns -1.\\nIf bytes are available, it reads the next character, processes it if the emergency parser is enabled, and returns the character.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "34133faca84a",
        "ground_truth": "int MarlinSerialUSB::peek() {\n  if (pending_char >= 0)\n    return pending_char;\n   // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n   // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n   pending_char = udi_cdc_getc();\n   TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)pending_char));\n   return pending_char;\n}",
        "import_statements": [],
        "reference_api": [
            "emergency_parser.update",
            "udi_cdc_getc",
            "static_cast<MSerialT1*>",
            "udi_cdc_is_rx_ready",
            "usb_task_cdc_isenabled",
            "TERN_"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "emergency_parser.update",
            "udi_cdc_getc",
            "static_cast<MSerialT1*>",
            "udi_cdc_is_rx_ready",
            "usb_task_cdc_isenabled",
            "TERN_"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "int MarlinSerialUSB::read()",
        "start_line": "73",
        "end_line": "93",
        "file_path": "Marlin/src/HAL/DUE/MarlinSerialUSB.cpp",
        "docstring": "The function \"MarlinSerialUSB::read\" reads a character from the USB serial interface.\\nIt first checks if there is a pending character and returns it if available.\\nIf not, it checks if the USB CDC is enabled and configured; if not, it returns -1.\\nIt then checks if there are any bytes available to read from the PC; if not, it returns -1.\\nIf a byte is available, it reads the byte, updates the emergency parser if enabled, and returns the read character.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1bfec0523f11",
        "ground_truth": "int MarlinSerialUSB::read() {\n  if (pending_char >= 0) {\n    int ret = pending_char;\n    pending_char = -1;\n    return ret;\n  }\n   // If USB CDC not enumerated or not configured on the PC side\n  if (!usb_task_cdc_isenabled())\n    return -1;\n   // If no bytes sent from the PC\n  if (!udi_cdc_is_rx_ready())\n    return -1;\n   int c = udi_cdc_getc();\n   TERN_(EMERGENCY_PARSER, emergency_parser.update(static_cast<MSerialT1*>(this)->emergency_state, (char)c));\n   return c;\n}",
        "import_statements": [],
        "reference_api": [
            "emergency_parser.update",
            "udi_cdc_getc",
            "static_cast<MSerialT1*>",
            "udi_cdc_is_rx_ready",
            "usb_task_cdc_isenabled",
            "TERN_"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "emergency_parser.update",
            "udi_cdc_getc",
            "static_cast<MSerialT1*>",
            "udi_cdc_is_rx_ready",
            "usb_task_cdc_isenabled",
            "TERN_"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "int MarlinSerialUSB::available()",
        "start_line": "95",
        "end_line": "100",
        "file_path": "Marlin/src/HAL/DUE/MarlinSerialUSB.cpp",
        "docstring": "The function \"MarlinSerialUSB::available\" checks and returns the number of pending characters in the USB serial buffer.\\nIf there are pending characters, it returns the count.\\nIf there are no pending characters, it checks if the USB CDC is enabled and ready to receive data, returning the appropriate status.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "46e286175a69",
        "ground_truth": "int MarlinSerialUSB::available() {\n  if (pending_char > 0) return pending_char;\n  return pending_char == 0 ||\n    // or USB CDC enumerated and configured on the PC side and some bytes where sent to us */\n    (usb_task_cdc_isenabled() && udi_cdc_is_rx_ready());\n}",
        "import_statements": [],
        "reference_api": [
            "udi_cdc_is_rx_ready",
            "usb_task_cdc_isenabled"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "udi_cdc_is_rx_ready",
            "usb_task_cdc_isenabled"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)",
        "start_line": "985",
        "end_line": "994",
        "file_path": "Marlin/src/HAL/DUE/eeprom_flash.cpp",
        "docstring": "The function \"PersistentStore::read_data\" reads data from a persistent storage starting at a given position and updates the CRC value.\\nIt reads each byte from the storage, optionally writes it to the provided value buffer, updates the CRC, and increments the position.\\nThe process continues until the specified size is exhausted.\\nIt returns \"false\" after completing the operation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "684c979e79a3",
        "ground_truth": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/) {\n  do {\n    uint8_t c = ee_Read(uint32_t(REAL_EEPROM_ADDR(pos)));\n    if (writing) *value = c;\n    crc16(crc, &c, 1);\n    pos++;\n    value++;\n  } while (--size);\n  return false;\n}",
        "import_statements": [],
        "reference_api": [
            "uint32_t",
            "crc16",
            "REAL_EEPROM_ADDR",
            "ee_Read"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "crc16",
                "code": "void crc16(uint16_t *crc, const void * const data, uint16_t cnt) {\n  uint8_t *ptr = (uint8_t *)data;\n  while (cnt--) {\n    *crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)*ptr++) << 8));\n    for (uint8_t i = 0; i < 8; i++)\n      *crc = (uint16_t)((*crc & 0x8000) ? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n  }\n}"
            },
            {
                "name": "ee_Read",
                "code": "static uint8_t ee_Read(uint32_t address, bool excludeRAMBuffer=false) {\n\n  uint32_t baddr;\n  uint32_t blen;\n\n  // If we were requested an address outside of the emulated range, fail now\n  if (address >= EEPROMSize)\n    return false;\n\n  // Check that the value is not contained in the RAM buffer\n  if (!excludeRAMBuffer) {\n    uint16_t i = 0;\n    while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */\n\n      // Get the address of the block\n      baddr = buffer[i] | (buffer[i + 1] << 8);\n\n      // Get the length of the block\n      blen = buffer[i + 2];\n\n      // If we reach the end of the list, break loop\n      if (blen == 0xFF)\n        break;\n\n      // Check if data is contained in this block\n      if (address >= baddr &&\n        address < (baddr + blen)) {\n\n        // Yes, it is contained. Return it!\n        return buffer[i + 3 + address - baddr];\n      }\n\n      // As blocks are always sorted, if the starting address of this block is higher\n      // than the address we are looking for, break loop now - We wont find the value\n      // associated to the address\n      if (baddr > address)\n        break;\n\n      // Jump to the next block\n      i += 3 + blen;\n    }\n  }\n\n  // It is NOT on the RAM buffer. It could be stored in FLASH. We are\n  //  ensured on a given FLASH page, address contents are never repeated\n  //  but on different pages, there is no such warranty, so we must go\n  //  backwards from the last written FLASH page to the first one.\n  for (int page = curPage - 1; page >= 0; --page) {\n\n    // Get a pointer to the flash page\n    uint8_t *pflash = (uint8_t*)getFlashStorage(page + curGroup * PagesPerGroup);\n\n    uint16_t i = 0;\n    while (i <= (PageSize - 4)) { /* (PageSize - 4) because otherwise, there is not enough room for data and headers */\n\n      // Get the address of the block\n      baddr = pflash[i] | (pflash[i + 1] << 8);\n\n      // Get the length of the block\n      blen = pflash[i + 2];\n\n      // If we reach the end of the list, break loop\n      if (blen == 0xFF)\n        break;\n\n      // Check if data is contained in this block\n      if (address >= baddr && address < (baddr + blen))\n        return pflash[i + 3 + address - baddr]; // Yes, it is contained. Return it!\n\n      // As blocks are always sorted, if the starting address of this block is higher\n      // than the address we are looking for, break loop now - We wont find the value\n      // associated to the address\n      if (baddr > address) break;\n\n      // Jump to the next block\n      i += 3 + blen;\n    }\n  }\n\n  // If reached here, value is not stored, so return its default value\n  return 0xFF;\n}"
            }
        ],
        "third_party": [
            "uint32_t",
            "REAL_EEPROM_ADDR"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)",
        "start_line": "375",
        "end_line": "406",
        "file_path": "Marlin/src/HAL/ESP32/HAL.cpp",
        "docstring": "The function \"analogWrite\" sets the PWM (Pulse Width Modulation) value for a specified pin.\\nIt first attempts to use hardware PWM channels via the \"ledcWrite\" function.\\nIf the pin does not support hardware PWM or no channels are available, it searches for an existing software PWM state for the pin.\\nIf not found, it allocates a new slot, starts the timer if this is the first PWM pin used, and increments the used PWM count.\\nFinally, it sets the PWM value, converting it to a 7-bit internal representation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b6348e44f615",
        "ground_truth": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/) { // always 8 bit resolution!\n  // Use ledc hardware for internal pins\n  const int8_t cid = get_pwm_channel(pin, freq, res);\n  if (cid >= 0) {\n    ledcWrite(cid, value); // set duty value\n    return;\n  }\n   // not a hardware PWM pin OR no PWM channels available\n  int idx = -1;\n   // Search Pin\n  for (int i = 0; i < numPWMUsed; ++i)\n    if (pwmState[i].pin == pin) { idx = i; break; }\n   // not found ?\n  if (idx < 0) {\n    // No slots remaining\n    if (numPWMUsed >= MAX_PWM_PINS) return;\n     // Take new slot for pin\n    idx = numPWMUsed;\n    pwmState[idx].pin = pin;\n    // Start timer on first use\n    if (idx == 0) HAL_timer_start(MF_TIMER_PWM, PWM_TIMER_FREQUENCY);\n     ++numPWMUsed;\n  }\n   // Use 7bit internal value - add 1 to have 100% high at 255\n  pwmState[idx].value = (value + 1) / 2;\n}",
        "import_statements": [],
        "reference_api": [
            "HAL_timer_start",
            "get_pwm_channel",
            "ledcWrite"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get_pwm_channel",
                "code": "int8_t get_pwm_channel(const pin_t pin, const uint32_t freq, const uint16_t res) {\n  if (!WITHIN(pin, 1, MAX_PWM_IOPIN)) return -1; // Not a hardware PWM pin!\n  int8_t cid = channel_for_pin(pin);\n  if (cid >= 0) return cid;\n\n  // Find an empty adjacent channel (same timer & freq/res)\n  for (int i = 0; i <= CHANNEL_MAX_NUM; i++) {\n    if (chan_pin[i] == 0) {\n      if (chan_pin[i ^ 0x1] != 0) {\n        if (pwmInfo[i / 2].freq == freq && pwmInfo[i / 2].res == res) {\n          chan_pin[i] = pin; // Allocate PWM to this channel\n          ledcAttachPin(pin, i);\n          return i;\n        }\n      }\n      else if (cid == -1)    // Pair of empty channels?\n        cid = i & 0xFE;      // Save lower channel number\n    }\n  }\n  // not attached, is an empty timer slot avail?\n  if (cid >= 0) {\n    chan_pin[cid] = pin;\n    pwmInfo[cid / 2].freq = freq;\n    pwmInfo[cid / 2].res = res;\n    ledcSetup(cid, freq, res);\n    ledcAttachPin(pin, cid);\n  }\n  return cid; // -1 if no channel avail\n}"
            }
        ],
        "third_party": [
            "HAL_timer_start",
            "ledcWrite"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void Servo::move(const int value)",
        "start_line": "56",
        "end_line": "64",
        "file_path": "Marlin/src/HAL/ESP32/Servo.cpp",
        "docstring": "The function \"move\" in the \"Servo\" class moves a servo to a specified position.\\nIt first verifies the servo delay array length using a static assertion.\\nIf the servo attaches successfully, it writes the desired value to move the servo and waits for a predefined delay specific to the servo channel.\\nOptionally, it detaches the servo after the move if the \"DEACTIVATE_SERVOS_AFTER_MOVE\" condition is enabled.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8d30ff0014ff",
        "ground_truth": "void Servo::move(const int value) {\n  constexpr uint16_t servo_delay[] = SERVO_DELAY;\n  static_assert(COUNT(servo_delay) == NUM_SERVOS, \"SERVO_DELAY must be an array NUM_SERVOS long.\");\n  if (attach(0) >= 0) {\n    write(value);\n    safe_delay(servo_delay[channel]);\n    TERN_(DEACTIVATE_SERVOS_AFTER_MOVE, detach());\n  }\n}",
        "import_statements": [],
        "reference_api": [
            "COUNT",
            "write",
            "attach",
            "safe_delay",
            "TERN_",
            "detach"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "write",
                "code": "void Servo::write(int inDegrees) {\n  degrees = constrain(inDegrees, MIN_ANGLE, MAX_ANGLE);\n  int us = map(degrees, MIN_ANGLE, MAX_ANGLE, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);\n  int duty = map(us, 0, TAU_USEC, 0, MAX_COMPARE);\n  if (channel >= 0) ledcWrite(channel, duty); // don't save duty for servos!\n}"
            },
            {
                "name": "attach",
                "code": "int8_t Servo::attach(const int inPin) {\n  if (inPin > 0) pin = inPin;\n  channel = get_pwm_channel(pin, 50u, 16u);\n  return channel; // -1 if no PWM avail.\n}"
            },
            {
                "name": "safe_delay",
                "code": "void safe_delay(millis_t ms) {\n  while (ms > 50) {\n    ms -= 50;\n    delay(50);\n    thermalManager.task();\n  }\n  delay(ms);\n  thermalManager.task(); // This keeps us safe if too many small safe_delay() calls are made\n}"
            },
            {
                "name": "detach",
                "code": "void Servo::detach() {\n  if (channel >= 0) ledcWrite(channel, 0);\n}"
            }
        ],
        "third_party": [
            "COUNT",
            "TERN_"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void i2s_push_sample()",
        "start_line": "373",
        "end_line": "395",
        "file_path": "Marlin/src/HAL/ESP32/i2s.cpp",
        "docstring": "The function \"i2s_push_sample\" updates the PWM states for each pin and writes the resulting data to a DMA buffer.\\nFor each pin, it checks if the pin has active PWM by evaluating its duty cycle.\\nIf the PWM tick count reaches zero, it toggles the pin state between high and low based on its current state and sets the tick count for the next transition.\\nFinally, it stores the updated port data into the current position of the DMA buffer and increments the buffer position.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9397f207ddf5",
        "ground_truth": "void i2s_push_sample() {\n  // Every 4\u00b5s (when space in DMA buffer) toggle each expander PWM output using\n  // the current duty cycle/frequency so they sync with any steps (once\n  // through the DMA/FIFO buffers).  PWM signal inversion handled by other functions\n  for (uint8_t p = 0; p < MAX_EXPANDER_BITS; ++p) {\n    if (hal.pwm_pin_data[p].pwm_duty_ticks > 0) { // pin has active pwm?\n      if (hal.pwm_pin_data[p].pwm_tick_count == 0) {\n        if (TEST32(i2s_port_data, p)) {  // hi->lo\n          CBI32(i2s_port_data, p);\n          hal.pwm_pin_data[p].pwm_tick_count = hal.pwm_pin_data[p].pwm_cycle_ticks - hal.pwm_pin_data[p].pwm_duty_ticks;\n        }\n        else { // lo->hi\n          SBI32(i2s_port_data, p);\n          hal.pwm_pin_data[p].pwm_tick_count = hal.pwm_pin_data[p].pwm_duty_ticks;\n        }\n      }\n      else\n        hal.pwm_pin_data[p].pwm_tick_count--;\n    }\n  }\n   dma.current[dma.rw_pos++] = i2s_port_data;\n}",
        "import_statements": [],
        "reference_api": [
            "TEST32",
            "SBI32",
            "CBI32"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "TEST32",
            "SBI32",
            "CBI32"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)",
        "start_line": "141",
        "end_line": "146",
        "file_path": "Marlin/src/HAL/ESP32/timers.cpp",
        "docstring": "The function \"HAL_timer_get_count\" retrieves the current counter value of a specified hardware timer.\\nIt takes a timer number as input, accesses the corresponding timer configuration, and fetches the current counter value from the timer.\\nThe function then returns this counter value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3c122bba57b7",
        "ground_truth": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num) {\n  const tTimerConfig timer = timer_config[timer_num];\n  uint64_t counter_value;\n  timer_get_counter_value(timer.group, timer.idx, &counter_value);\n  return counter_value;\n}",
        "import_statements": [],
        "reference_api": [
            "timer_get_counter_value"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "timer_get_counter_value"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)",
        "start_line": "84",
        "end_line": "92",
        "file_path": "Marlin/src/HAL/HC32/eeprom_sdcard.cpp",
        "docstring": "The function \"PersistentStore::read_data\" reads data from EEPROM, updates the CRC, and optionally writes the read data into a provided buffer.\\nFor each byte in the specified size, it reads the byte from the EEPROM, updates the CRC, and if the writing flag is true, stores the byte in the provided buffer.\\nAfter processing the specified number of bytes, it updates the position pointer by the size of the data read.\\nIt returns false upon completion.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d20484e3d16c",
        "ground_truth": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/) {\n  for (size_t i = 0; i < size; i++) {\n    const uint8_t c = HAL_eeprom_data[pos + i];\n    if (writing) value[i] = c;\n    crc16(crc, &c, 1);\n  }\n  pos += size;\n  return false;\n}",
        "import_statements": [],
        "reference_api": [
            "crc16"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "crc16",
                "code": "void crc16(uint16_t *crc, const void * const data, uint16_t cnt) {\n  uint8_t *ptr = (uint8_t *)data;\n  while (cnt--) {\n    *crc = (uint16_t)(*crc ^ (uint16_t)(((uint16_t)*ptr++) << 8));\n    for (uint8_t i = 0; i < 8; i++)\n      *crc = (uint16_t)((*crc & 0x8000) ? ((uint16_t)(*crc << 1) ^ 0x1021) : (*crc << 1));\n  }\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)",
        "start_line": "118",
        "end_line": "129",
        "file_path": "Marlin/src/HAL/HC32/sdio.cpp",
        "docstring": "The function \"SDIO_WriteBlock\" attempts to write a block of data to an SD card using the SDIO interface.\\nIt first asserts that the SDIO handle and source pointer are not null.\\nIt then tries to write the block, retrying up to a defined number of times if the write operation fails.\\nIf the write operation succeeds, it returns \"true\".\\nIf all retries fail, it prints an error message and returns \"false\".",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3ca886f0fcd1",
        "ground_truth": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {\n  CORE_ASSERT(handle != nullptr, \"SDIO not initialized\", return false);\n  CORE_ASSERT(src != nullptr, \"SDIO_WriteBlock src is NULL\", return false);\n   WITH_RETRY(SDIO_WRITE_RETRIES, {\n    en_result_t rc = SDCARD_WriteBlocks(handle, block, 1, (uint8_t *)src, SDIO_WRITE_TIMEOUT);\n    if (rc == Ok) return true;\n    printf(\"SDIO_WriteBlock error (rc=%u; ErrorCode=%lu)\\n\", rc, handle->u32ErrorCode);\n  })\n   return false;\n}",
        "import_statements": [],
        "reference_api": [
            "printf",
            "SDCARD_WriteBlocks",
            "CORE_ASSERT",
            "WITH_RETRY"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "SDCARD_WriteBlocks",
            "CORE_ASSERT",
            "WITH_RETRY"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)",
        "start_line": "38",
        "end_line": "52",
        "file_path": "Marlin/src/HAL/HC32/timers.cpp",
        "docstring": "The function \"HAL_timer_start\" initializes a hardware timer with a specified frequency based on the provided timer channel.\\nIf the timer channel corresponds to the temperature timer, it starts the timer with the given frequency and temperature timer prescale, and sets the callback priority for temperature.\\nIf the timer channel corresponds to the step timer, it starts the timer with the given frequency and stepper timer prescale, and sets the callback priority for stepper.\\nIf the timer channel is invalid, it triggers an assertion failure.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6064dcb222f7",
        "ground_truth": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency) {\n  if (timer_num == TEMP_TIMER_NUM) {\n    CORE_DEBUG_PRINTF(\"HAL_timer_start: temp timer, f=%ld\\n\", long(frequency));\n    timer_num->start(frequency, TEMP_TIMER_PRESCALE);\n    timer_num->setCallbackPriority(TEMP_TIMER_PRIORITY);\n  }\n  else if (timer_num == STEP_TIMER_NUM) {\n    CORE_DEBUG_PRINTF(\"HAL_timer_start: step timer, f=%ld\\n\", long(frequency));\n    timer_num->start(frequency, STEPPER_TIMER_PRESCALE);\n    timer_num->setCallbackPriority(STEP_TIMER_PRIORITY);\n  }\n  else {\n    CORE_ASSERT_FAIL(\"HAL_timer_start: invalid timer_num\")\n  }\n}",
        "import_statements": [],
        "reference_api": [
            "timer_num->start",
            "CORE_DEBUG_PRINTF",
            "CORE_ASSERT_FAIL",
            "timer_num->setCallbackPriority",
            "long"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "timer_num->start",
            "CORE_DEBUG_PRINTF",
            "CORE_ASSERT_FAIL",
            "timer_num->setCallbackPriority",
            "long"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "bool PersistentStore::access_start()",
        "start_line": "40",
        "end_line": "58",
        "file_path": "Marlin/src/HAL/LINUX/eeprom.cpp",
        "docstring": "The function \"PersistentStore::access_start\" opens an EEPROM file and initializes a buffer with its contents.\\nIf the file does not exist or cannot be opened, it returns \"false\".\\nIt checks the file size; if the file is smaller than the expected EEPROM size, it fills the remainder of the buffer with a default erase value.\\nIf the file is of sufficient size, it reads the file's contents into the buffer.\\nFinally, it closes the file and returns \"true\".",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6ab8b797a670",
        "ground_truth": "bool PersistentStore::access_start() {\n  const char eeprom_erase_value = 0xFF;\n  FILE * eeprom_file = fopen(filename, \"rb\");\n  if (!eeprom_file) return false;\n   fseek(eeprom_file, 0L, SEEK_END);\n  std::size_t file_size = ftell(eeprom_file);\n   if (file_size < MARLIN_EEPROM_SIZE) {\n    memset(buffer + file_size, eeprom_erase_value, MARLIN_EEPROM_SIZE - file_size);\n  }\n  else {\n    fseek(eeprom_file, 0L, SEEK_SET);\n    fread(buffer, sizeof(uint8_t), sizeof(buffer), eeprom_file);\n  }\n   fclose(eeprom_file);\n  return true;\n}",
        "import_statements": [],
        "reference_api": [
            "fclose",
            "fread",
            "memset",
            "ftell",
            "fopen",
            "fseek"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "fread"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)",
        "start_line": "85",
        "end_line": "99",
        "file_path": "Marlin/src/HAL/STM32/HAL_SPI.cpp",
        "docstring": "The function \"HAL_SPI_STM32_SpiTransfer_Mode_3\" performs an SPI data transfer in Mode 3.\\nIt sends and receives a byte of data by iterating through each bit.\\nFor each bit, it sets the clock pin low, writes the most significant bit of the byte to the MOSI pin, toggles the clock pin high, and reads the bit from the MISO pin.\\nThe function shifts the byte left and incorporates the read bit.\\nAfter completing the transfer, it introduces a small delay before returning the received byte.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c583d63e258f",
        "ground_truth": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b) { // using Mode 3\n  for (uint8_t bits = 8; bits--;) {\n    WRITE(SD_SCK_PIN, LOW);\n    WRITE(SD_MOSI_PIN, b & 0x80);\n    delaySPIFunc();\n    WRITE(SD_SCK_PIN, HIGH);\n    delaySPIFunc();\n    b <<= 1;        // little setup time\n    b |= (READ(SD_MISO_PIN) != 0);\n  }\n  DELAY_NS(125);\n  return b;\n}",
        "import_statements": [
            "#include \"../platforms.h\"\n"
        ],
        "reference_api": [
            "DELAY_NS",
            "WRITE",
            "READ",
            "delaySPIFunc"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "DELAY_NS",
            "WRITE",
            "READ",
            "delaySPIFunc"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)",
        "start_line": "103",
        "end_line": "112",
        "file_path": "Marlin/src/HAL/STM32/HardwareSerial.cpp",
        "docstring": "The function \"RCC_AHBPeriphClockCmd\" enables or disables the AHB peripheral clock based on the specified parameters.\\nIt first validates the parameters to ensure they are correct.\\nIf the \"NewState\" parameter is not \"DISABLE\", it enables the specified AHB peripheral clock by setting the corresponding bit in the \"AHBENR\" register.\\nOtherwise, it disables the clock by clearing the corresponding bit in the \"AHBENR\" register.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c17acede1672",
        "ground_truth": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState) {\n  /* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}",
        "import_statements": [
            "#include \"../platforms.h\"\n"
        ],
        "reference_api": [
            "assert_param",
            "IS_FUNCTIONAL_STATE",
            "IS_RCC_AHB_PERIPH"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "assert_param",
            "IS_FUNCTIONAL_STATE",
            "IS_RCC_AHB_PERIPH"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void MarlinSerial::_rx_complete_irq(serial_t *obj)",
        "start_line": "110",
        "end_line": "128",
        "file_path": "Marlin/src/HAL/STM32/MarlinSerial.cpp",
        "docstring": "The function \"MarlinSerial::_rx_complete_irq\" handles the reception of a byte via a serial interrupt.\\nIf no parity error occurs, it reads the byte and stores it in the receive buffer if there is space available.\\nIt calculates the next buffer index and updates the head pointer.\\nIf enabled, it also updates the emergency parser with the received byte.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "07c84ed22693",
        "ground_truth": "void MarlinSerial::_rx_complete_irq(serial_t *obj) {\n  // No Parity error, read byte and store it in the buffer if there is room\n  unsigned char c;\n  if (uart_getc(obj, &c) == 0) {\n    rx_buffer_index_t i = (unsigned int)(obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n    // If tail overlaps head the buffer is overflowed\n    // so don't write the character or advance the head.\n    if (i != obj->rx_tail) {\n      obj->rx_buff[obj->rx_head] = c;\n      obj->rx_head = i;\n    }\n    #if ENABLED(EMERGENCY_PARSER)\n      emergency_parser.update(static_cast<MSerialT*>(this)->emergency_state, c);\n    #endif\n  }\n}",
        "import_statements": [
            "#include \"../platforms.h\"\n"
        ],
        "reference_api": [
            "static_cast<MSerialT*>",
            "uart_getc",
            "emergency_parser.update",
            "ENABLED"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "static_cast<MSerialT*>",
            "uart_getc",
            "emergency_parser.update",
            "ENABLED"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "MarlinFirmware/Marlin",
        "function_declaration": "void HAL_timer_enable_interrupt(const uint8_t timer_num)",
        "start_line": "176",
        "end_line": "187",
        "file_path": "Marlin/src/HAL/STM32/timers.cpp",
        "docstring": "The function \"HAL_timer_enable_interrupt\" enables interrupts for a specified timer if it is initialized and does not already have an interrupt attached.\\nIt checks if the timer is initialized and lacks an interrupt.\\nDepending on the timer number, it attaches the appropriate interrupt handler: \"Step_Handler\" for \"MF_TIMER_STEP\" or \"Temp_Handler\" for \"MF_TIMER_TEMP\".",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1a4209a2e1f1",
        "ground_truth": "void HAL_timer_enable_interrupt(const uint8_t timer_num) {\n  if (HAL_timer_initialized(timer_num) && !timer_instance[timer_num]->hasInterrupt()) {\n    switch (timer_num) {\n      case MF_TIMER_STEP:\n        timer_instance[timer_num]->attachInterrupt(Step_Handler);\n        break;\n      case MF_TIMER_TEMP:\n        timer_instance[timer_num]->attachInterrupt(Temp_Handler);\n        break;\n    }\n  }\n}",
        "import_statements": [
            "#include \"../platforms.h\"\n"
        ],
        "reference_api": [
            "timer_instance[timer_num]->hasInterrupt",
            "timer_instance[timer_num]->attachInterrupt",
            "HAL_timer_initialized"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "timer_instance[timer_num]->hasInterrupt",
            "timer_instance[timer_num]->attachInterrupt",
            "HAL_timer_initialized"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "tinygo-org/tinygo",
        "function_declaration": "func LastIndexRabinKarp[T string | []byte](s, sep T) int",
        "start_line": "306",
        "end_line": "327",
        "file_path": "src/internal/bytealg/bytealg.go",
        "docstring": "The function \"LastIndexRabinKarp\" performs a reverse Rabin-Karp search to find the last occurrence of a substring within a string or byte slice.\\nIt calculates the hash of the substring and uses it to compare against the hash of substrings in the main string from the end towards the beginning.\\nIf a matching hash is found and the actual substring matches, it returns the starting index of the last occurrence; otherwise, it returns -1.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e7f70295bd11",
        "ground_truth": "func LastIndexRabinKarp[T string | []byte](s, sep T) int {\n // Rabin-Karp search from the end of the string\n hashss, pow := HashStrRev(sep)\n n := len(sep)\n last := len(s) - n\n var h uint32\n for i := len(s) - 1; i >= last; i-- {\n  h = h*PrimeRK + uint32(s[i])\n }\n if h == hashss && string(s[last:]) == string(sep) {\n  return last\n }\n for i := last - 1; i >= 0; i-- {\n  h *= PrimeRK\n  h += uint32(s[i])\n  h -= pow * uint32(s[i+n])\n  if h == hashss && string(s[i:i+n]) == string(sep) {\n   return i\n  }\n }\n return -1\n}",
        "import_statements": [],
        "reference_api": [
            "uint32",
            "len",
            "string",
            "HashStrRev"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "HashStrRev",
                "code": "func HashStrRev[T string | []byte](sep T) (uint32, uint32) {\n\thash := uint32(0)\n\tfor i := len(sep) - 1; i >= 0; i-- {\n\t\thash = hash*PrimeRK + uint32(sep[i])\n\t}\n\tvar pow, sq uint32 = 1, PrimeRK\n\tfor i := len(sep); i > 0; i >>= 1 {\n\t\tif i&1 != 0 {\n\t\t\tpow *= sq\n\t\t}\n\t\tsq *= sq\n\t}\n\treturn hash, pow\n}"
            }
        ],
        "third_party": [
            "uint32",
            "len",
            "string"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "tinygo-org/tinygo",
        "function_declaration": "func (usbcdc *USBCDC) Flush()",
        "start_line": "88",
        "end_line": "96",
        "file_path": "src/machine/usb/cdc/usbcdc.go",
        "docstring": "The function \"Flush\" in the \"USBCDC\" struct sends any available data in the transmit buffer to the USB endpoint.\\nIt disables interrupts, checks if there is data in the transmit buffer, and if so, sends it to the USB endpoint using \"SendUSBInPacket\".\\nIf no data is available, it sets \"waitTxc\" to false.\\nFinally, it restores the interrupt mask.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5090d25de8b9",
        "ground_truth": "func (usbcdc *USBCDC) Flush() {\n mask := interrupt.Disable()\n if b, ok := usbcdc.txBuffer.Get(); ok {\n  machine.SendUSBInPacket(cdcEndpointIn, b)\n } else {\n  usbcdc.waitTxc = false\n }\n interrupt.Restore(mask)\n}",
        "import_statements": [
            "import (\n\t\"errors\"\n\t\"machine\"\n\t\"machine/usb\"\n\t\"runtime/interrupt\"\n)"
        ],
        "reference_api": [
            "machine.SendUSBInPacket",
            "usbcdc.txBuffer.Get",
            "interrupt.Disable",
            "interrupt.Restore"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "machine.SendUSBInPacket",
            "usbcdc.txBuffer.Get",
            "interrupt.Disable",
            "interrupt.Restore"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "tinygo-org/tinygo",
        "function_declaration": "func (i2c *I2C) start(address uint8, write bool)",
        "start_line": "87",
        "end_line": "101",
        "file_path": "src/machine/machine_atmega.go",
        "docstring": "The function \"start\" initializes an I2C communication by sending a start condition and the address of the peripheral.\\nIt first sets the control register to clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module.\\nThen it waits for the start condition to be transmitted by checking the interrupt flag.\\nAfter that, it writes the 7-bit shifted peripheral address to the bus, setting the read flag if needed, and sends it.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "54d6ec2ef3cb",
        "ground_truth": "func (i2c *I2C) start(address uint8, write bool) {\n // Clear TWI interrupt flag, put start condition on SDA, and enable TWI.\n i2c.crReg.Set((i2c.crINT | i2c.crSTA | i2c.crEN))\n  // Wait till start condition is transmitted.\n for !i2c.crReg.HasBits(i2c.crINT) {\n }\n  // Write 7-bit shifted peripheral address.\n address <<= 1\n if !write {\n  address |= 1 // set read flag\n }\n i2c.writeByte(address)\n}",
        "import_statements": [
            "import (\n\t\"device/avr\"\n\t\"runtime/interrupt\"\n\t\"runtime/volatile\"\n\t\"unsafe\"\n)"
        ],
        "reference_api": [
            "i2c.crReg.HasBits",
            "i2c.writeByte",
            "i2c.crReg.Set"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "i2c.crReg.HasBits",
            "i2c.writeByte",
            "i2c.crReg.Set"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "tinygo-org/tinygo",
        "function_declaration": "func (f flashBlockDevice) EraseBlocks(start, len int64) error",
        "start_line": "431",
        "end_line": "445",
        "file_path": "src/machine/machine_nrf.go",
        "docstring": "The function \"EraseBlocks\" in the \"flashBlockDevice\" struct erases a specified number of blocks in flash memory starting from a given block.\\nIt calculates the start address based on the block number and block size, then waits for any ongoing flash operations to complete.\\nThe flash is configured for erasing, and after each block is erased, it waits until the flash is no longer busy.\\nFinally, the flash is set back to read mode and the function returns \"nil\" indicating successful completion.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "57a792477dc8",
        "ground_truth": "func (f flashBlockDevice) EraseBlocks(start, len int64) error {\n address := FlashDataStart() + uintptr(start*f.EraseBlockSize())\n waitWhileFlashBusy()\n  nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Een)\n defer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n  for i := start; i < start+len; i++ {\n  nrf.NVMC.ERASEPAGE.Set(uint32(address))\n  waitWhileFlashBusy()\n  address += uintptr(f.EraseBlockSize())\n }\n  return nil\n}",
        "import_statements": [
            "import (\n\t\"bytes\"\n\t\"device/nrf\"\n\t\"encoding/binary\"\n\t\"runtime/interrupt\"\n\t\"unsafe\"\n)"
        ],
        "reference_api": [
            "f.EraseBlockSize",
            "FlashDataStart",
            "nrf.NVMC.SetCONFIG_WEN",
            "waitWhileFlashBusy",
            "nrf.NVMC.ERASEPAGE.Set",
            "uint32",
            "uintptr"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "f.EraseBlockSize",
            "FlashDataStart",
            "nrf.NVMC.SetCONFIG_WEN",
            "waitWhileFlashBusy",
            "nrf.NVMC.ERASEPAGE.Set",
            "uint32",
            "uintptr"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "tinygo-org/tinygo",
        "function_declaration": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)",
        "start_line": "383",
        "end_line": "404",
        "file_path": "src/machine/machine_nrf.go",
        "docstring": "The function \"WriteAt\" in the \"flashBlockDevice\" struct writes a byte slice to a flash memory at a specified offset.\\nIt first checks if the write operation exceeds the flash memory bounds and returns an error if it does.\\nThe function calculates the start address for writing and pads the byte slice to fit the write block size.\\nIt then enables write mode on the flash memory controller, writes the data in blocks, and waits for the flash memory to be ready after each write operation.\\nFinally, it returns the number of bytes written or an error if the operation fails.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0d13f2ab7097",
        "ground_truth": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error) {\n if FlashDataStart()+uintptr(off)+uintptr(len(p)) > FlashDataEnd() {\n  return 0, errFlashCannotWritePastEOF\n }\n  address := FlashDataStart() + uintptr(off)\n padded := f.pad(p)\n  waitWhileFlashBusy()\n  nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Wen)\n defer nrf.NVMC.SetCONFIG_WEN(nrf.NVMC_CONFIG_WEN_Ren)\n  for j := 0; j < len(padded); j += int(f.WriteBlockSize()) {\n  // write word\n  *(*uint32)(unsafe.Pointer(address)) = binary.LittleEndian.Uint32(padded[j : j+int(f.WriteBlockSize())])\n  address += uintptr(f.WriteBlockSize())\n  waitWhileFlashBusy()\n }\n  return len(padded), nil\n}",
        "import_statements": [
            "import (\n\t\"bytes\"\n\t\"device/nrf\"\n\t\"encoding/binary\"\n\t\"runtime/interrupt\"\n\t\"unsafe\"\n)"
        ],
        "reference_api": [
            "nrf.NVMC.SetCONFIG_WEN",
            "FlashDataStart",
            "waitWhileFlashBusy",
            "int",
            "len",
            "binary.LittleEndian.Uint32",
            "(*uint32)",
            "FlashDataEnd",
            "f.WriteBlockSize",
            "uintptr",
            "unsafe.Pointer",
            "f.pad"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "nrf.NVMC.SetCONFIG_WEN",
            "FlashDataStart",
            "waitWhileFlashBusy",
            "int",
            "len",
            "binary.LittleEndian.Uint32",
            "(*uint32)",
            "FlashDataEnd",
            "f.WriteBlockSize",
            "uintptr",
            "unsafe.Pointer",
            "f.pad"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "tinygo-org/tinygo",
        "function_declaration": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)",
        "start_line": "129",
        "end_line": "148",
        "file_path": "src/os/dir_darwin.go",
        "docstring": "The function \"darwinOpenDir\" attempts to open a directory file descriptor on a Darwin (macOS) system.\\nIt first duplicates the provided file descriptor and checks for errors.\\nIf successful, it then repeatedly attempts to open the directory using \"syscall.Fdopendir\" until it either succeeds or encounters an error other than \"syscall.EINTR\".\\nIf an error occurs, it closes the duplicated file descriptor and returns the error message; otherwise, it returns the directory pointer with no error.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "57d59e8091c3",
        "ground_truth": "func darwinOpenDir(fd syscallFd) (uintptr, string, error) {\n // fdopendir(3) takes control of the file descriptor,\n // so use a dup.\n fd2, err := syscall.Dup(fd)\n if err != nil {\n  return 0, \"dup\", err\n }\n var dir uintptr\n for {\n  dir, err = syscall.Fdopendir(fd2)\n  if err != syscall.EINTR {\n   break\n  }\n }\n if err != nil {\n  syscall.Close(fd2)\n  return 0, \"fdopendir\", err\n }\n return dir, \"\", nil\n}",
        "import_statements": [
            "import (\n\t\"io\"\n\t\"runtime\"\n\t\"syscall\"\n\t\"unsafe\"\n)"
        ],
        "reference_api": [
            "syscall.Fdopendir",
            "syscall.Close",
            "syscall.Dup"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "syscall.Fdopendir",
            "syscall.Close",
            "syscall.Dup"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "static uint32_t sketchSize(sketchSize_t response)",
        "start_line": "177",
        "end_line": "194",
        "file_path": "cores/esp32/Esp.cpp",
        "docstring": "The function \"sketchSize\" determines the size of the current running sketch on an ESP device.\\nIt retrieves the partition information of the currently running application and verifies the image metadata.\\nIf the response parameter is true, it returns the free space available in the partition.\\nIf the response parameter is false, it returns the actual size of the sketch.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c77b4c3328e4",
        "ground_truth": "static uint32_t sketchSize(sketchSize_t response) {\n  esp_image_metadata_t data;\n  const esp_partition_t *running = esp_ota_get_running_partition();\n  if (!running) {\n    return 0;\n  }\n  const esp_partition_pos_t running_pos = {\n    .offset = running->address,\n    .size = running->size,\n  };\n  data.start_addr = running_pos.offset;\n  esp_image_verify(ESP_IMAGE_VERIFY, &running_pos, &data);\n  if (response) {\n    return running_pos.size - data.image_len;\n  } else {\n    return data.image_len;\n  }\n}",
        "import_statements": [
            "#include \"Arduino.h\"\n",
            "#include \"Esp.h\"\n",
            "#include \"esp_sleep.h\"\n",
            "#include \"spi_flash_mmap.h\"\n",
            "#include <memory>\n",
            "#include <soc/soc.h>\n",
            "#include <esp_partition.h>\n",
            "#include <MD5Builder.h>\n",
            "#include \"soc/spi_reg.h\"\n",
            "#include \"esp_system.h\"\n",
            "#include \"esp_chip_info.h\"\n",
            "#include \"esp_mac.h\"\n",
            "#include \"esp_flash.h\"\n"
        ],
        "reference_api": [
            "esp_image_verify",
            "esp_ota_get_running_partition"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "esp_image_verify",
            "esp_ota_get_running_partition"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)",
        "start_line": "126",
        "end_line": "144",
        "file_path": "cores/esp32/FirmwareMSC.cpp",
        "docstring": "The function \"msc_update_setup_disk\" initializes and sets up a RAM disk for an MSC (Mass Storage Class) device with a specified volume label and serial number.\\nIt calculates the required disk sectors, allocates memory for the RAM disk, and logs an error if allocation fails.\\nThe function then sets up the boot sector and file allocation table (FAT), and optionally adds a root directory entry for a firmware file if a partition is running.\\nIt returns \"true\" upon successful setup.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "61ae55ab6772",
        "ground_truth": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number) {\n  msc_total_sectors = msc_update_get_required_disk_sectors();\n  uint8_t ram_sectors = msc_table_sectors + 2;\n  msc_ram_disk = (uint8_t *)calloc(ram_sectors, DISK_SECTOR_SIZE);\n  if (!msc_ram_disk) {\n    log_e(\"Failed to allocate RAM Disk: %u bytes\", ram_sectors * DISK_SECTOR_SIZE);\n    return false;\n  }\n  fw_start_sector = ram_sectors;\n  fw_end_sector = fw_start_sector;\n  msc_boot = fat_add_boot_sector(msc_ram_disk, msc_total_sectors, msc_table_sectors, fat_file_system_type(mcs_is_fat16), volume_label, serial_number);\n  msc_table = fat_add_table(msc_ram_disk, msc_boot, mcs_is_fat16);\n  //fat_dir_entry_t * label = fat_add_label(msc_ram_disk, volume_label);\n  if (msc_run_partition) {\n    fw_entry = fat_add_root_file(msc_ram_disk, 0, \"FIRMWARE\", \"BIN\", fw_size, 2, mcs_is_fat16);\n    fw_end_sector = FAT_SIZE_TO_SECTORS(fw_size) + fw_start_sector;\n  }\n  return true;\n}",
        "import_statements": [
            "#include \"FirmwareMSC.h\"\n"
        ],
        "reference_api": [
            "FAT_SIZE_TO_SECTORS",
            "fat_file_system_type",
            "log_e",
            "fat_add_boot_sector",
            "fat_add_table",
            "calloc",
            "msc_update_get_required_disk_sectors",
            "fat_add_root_file"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "msc_update_get_required_disk_sectors",
                "code": "static size_t msc_update_get_required_disk_sectors() {\n  size_t data_sectors = 16;\n  size_t total_sectors = 0;\n  msc_run_partition = esp_ota_get_running_partition();\n  msc_ota_partition = esp_ota_get_next_update_partition(NULL);\n  if (msc_run_partition) {\n    fw_size = get_firmware_size(msc_run_partition);\n    data_sectors += FAT_SIZE_TO_SECTORS(fw_size);\n    log_d(\"APP size: %u (%u sectors)\", fw_size, FAT_SIZE_TO_SECTORS(fw_size));\n  } else {\n    log_w(\"APP partition not found. Reading disabled\");\n  }\n  if (msc_ota_partition) {\n    data_sectors += FAT_SIZE_TO_SECTORS(msc_ota_partition->size);\n    log_d(\"OTA size: %u (%u sectors)\", msc_ota_partition->size, FAT_SIZE_TO_SECTORS(msc_ota_partition->size));\n  } else {\n    log_w(\"OTA partition not found. Writing disabled\");\n  }\n  msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, false);\n  total_sectors = data_sectors + msc_table_sectors + 2;\n  if (total_sectors > 0xFF4) {\n    log_d(\"USING FAT16\");\n    mcs_is_fat16 = true;\n    total_sectors -= msc_table_sectors;\n    msc_table_sectors = fat_sectors_per_alloc_table(data_sectors, true);\n    total_sectors += msc_table_sectors;\n  } else {\n    log_d(\"USING FAT12\");\n    mcs_is_fat16 = false;\n  }\n  log_d(\"FAT sector size: %u\", DISK_SECTOR_SIZE);\n  log_d(\"FAT data sectors: %u\", data_sectors);\n  log_d(\"FAT table sectors: %u\", msc_table_sectors);\n  log_d(\"FAT total sectors: %u (%uKB)\", total_sectors, (total_sectors * DISK_SECTOR_SIZE) / 1024);\n  return total_sectors;\n}"
            }
        ],
        "third_party": [
            "FAT_SIZE_TO_SECTORS",
            "fat_file_system_type",
            "log_e",
            "fat_add_boot_sector",
            "fat_add_table",
            "fat_add_root_file"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)",
        "start_line": "218",
        "end_line": "228",
        "file_path": "cores/esp32/FirmwareMSC.cpp",
        "docstring": "The function \"msc_update_write\" performs an update write operation on a specified partition in an ESP device.\\nIt checks if the given offset is aligned with the flash sector size and, if so, erases the corresponding sector before writing new data.\\nIf the erase operation fails, it logs an error message and returns the error code.\\nIf the erase is successful or not needed, it writes the data to the specified offset and returns the result of the write operation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ab9a1d1944f3",
        "ground_truth": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size) {\n  esp_err_t err = ESP_OK;\n  if ((offset & (SPI_FLASH_SEC_SIZE - 1)) == 0) {\n    err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n    log_v(\"ERASE[0x%08X]: %s\", offset, (err != ESP_OK) ? \"FAIL\" : \"OK\");\n    if (err != ESP_OK) {\n      return err;\n    }\n  }\n  return esp_partition_write(partition, offset, data, size);\n}",
        "import_statements": [
            "#include \"FirmwareMSC.h\"\n"
        ],
        "reference_api": [
            "esp_partition_write",
            "log_v",
            "esp_partition_erase_range"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "esp_partition_write",
            "log_v",
            "esp_partition_erase_range"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)",
        "start_line": "34",
        "end_line": "55",
        "file_path": "cores/esp32/HEXBuilder.cpp",
        "docstring": "The function \"hex2bytes\" converts a hexadecimal string to a byte array.\\nIt iterates through the input string, converts each valid hexadecimal character to its byte value, and assembles these values into bytes in the output array.\\nThe function skips any non-hexadecimal characters and ensures the output does not exceed the specified maximum length.\\nIt returns the number of bytes produced from the input string.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b1e6dde12189",
        "ground_truth": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in) {\n  size_t len = 0;\n  for (; *in; in++) {\n    uint8_t c = hex_char_to_byte(*in);\n    // Silently skip anything unknown.\n    if (c > 15) {\n      continue;\n    }\n     if (len & 1) {\n      if (len / 2 < maxlen) {\n        out[len / 2] |= c;\n      }\n    } else {\n      if (len / 2 < maxlen) {\n        out[len / 2] = c << 4;\n      }\n    }\n    len++;\n  }\n  return (len + 1) / 2;\n}",
        "import_statements": [
            "#include <Arduino.h>\n",
            "#include <HEXBuilder.h>\n"
        ],
        "reference_api": [
            "hex_char_to_byte"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "hex_char_to_byte",
                "code": "static uint8_t hex_char_to_byte(uint8_t c) {\n  return (c >= 'a' && c <= 'f')   ? (c - ((uint8_t)'a' - 0xa))\n         : (c >= 'A' && c <= 'F') ? (c - ((uint8_t)'A' - 0xA))\n         : (c >= '0' && c <= '9') ? (c - (uint8_t)'0')\n                                  : 0x10;  // unknown char is 16\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "int HWCDC::availableForWrite(void)",
        "start_line": "406",
        "end_line": "416",
        "file_path": "cores/esp32/HWCDC.cpp",
        "docstring": "The function \"availableForWrite\" checks the amount of free space available in the transmit ring buffer for writing data.\\nIt first verifies that the transmit ring buffer and lock are initialized.\\nIt then attempts to take the semaphore lock within a specified timeout period.\\nIf successful, it retrieves the current free size of the ring buffer, releases the lock, and returns the free size.\\nIf the lock cannot be obtained, it returns 0.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "728a0972efb0",
        "ground_truth": "int HWCDC::availableForWrite(void) {\n  if (tx_ring_buf == NULL || tx_lock == NULL) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, tx_timeout_ms / portTICK_PERIOD_MS) != pdPASS) {\n    return 0;\n  }\n  size_t a = xRingbufferGetCurFreeSize(tx_ring_buf);\n  xSemaphoreGive(tx_lock);\n  return a;\n}",
        "import_statements": [
            "#include \"USB.h\"\n"
        ],
        "reference_api": [
            "xSemaphoreTake",
            "xRingbufferGetCurFreeSize",
            "xSemaphoreGive"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "xSemaphoreTake",
            "xRingbufferGetCurFreeSize",
            "xSemaphoreGive"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)",
        "start_line": "157",
        "end_line": "180",
        "file_path": "cores/esp32/HardwareSerial.cpp",
        "docstring": "The function \"HardwareSerial::onReceive\" sets a callback function to be called when data is received on the serial port.\\nIt locks the serial mutex, assigns the provided callback function to \"_onReceiveCB\", and configures the receive timeout behavior based on the \"onlyOnTimeout\" and \"_rxTimeout\" values.\\nIf the callback is not NULL, it sets the FIFO full threshold and creates an event task if it does not already exist.\\nFinally, it unlocks the serial mutex.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "77c2e955d3c0",
        "ground_truth": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout) {\n  HSERIAL_MUTEX_LOCK();\n  // function may be NULL to cancel onReceive() from its respective task\n  _onReceiveCB = function;\n   // setting the callback to NULL will just disable it\n  if (_onReceiveCB != NULL) {\n    // When Rx timeout is Zero (disabled), there is only one possible option that is callback when FIFO reaches 120 bytes\n    _onReceiveTimeout = _rxTimeout > 0 ? onlyOnTimeout : false;\n     // in case that onReceive() shall work only with RX Timeout, FIFO shall be high\n    // this is a work around for an IDF issue with events and low FIFO Full value (< 3)\n    if (_onReceiveTimeout) {\n      uartSetRxFIFOFull(_uart, 120);\n      log_w(\"OnReceive is set to Timeout only, thus FIFO Full is now 120 bytes.\");\n    }\n     // this method can be called after Serial.begin(), therefore it shall create the event task\n    if (_uart != NULL && _eventTask == NULL) {\n      _createEventTask(this);  // Create event task\n    }\n  }\n  HSERIAL_MUTEX_UNLOCK();\n}",
        "import_statements": [
            "#include <stdlib.h>\n",
            "#include <stdio.h>\n",
            "#include <string.h>\n",
            "#include <inttypes.h>\n",
            "#include <ctime>\n",
            "#include \"pins_arduino.h\"\n",
            "#include \"io_pin_remap.h\"\n",
            "#include \"HardwareSerial.h\"\n",
            "#include \"soc/soc_caps.h\"\n",
            "#include \"driver/uart.h\"\n",
            "#include \"freertos/queue.h\"\n"
        ],
        "reference_api": [
            "HSERIAL_MUTEX_LOCK",
            "log_w",
            "uartSetRxFIFOFull",
            "_createEventTask",
            "HSERIAL_MUTEX_UNLOCK"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_createEventTask",
                "code": "void HardwareSerial::_createEventTask(void *args) {\n  // Creating UART event Task\n  xTaskCreateUniversal(\n    _uartEventTask, \"uart_event_task\", ARDUINO_SERIAL_EVENT_TASK_STACK_SIZE, this, ARDUINO_SERIAL_EVENT_TASK_PRIORITY, &_eventTask,\n    ARDUINO_SERIAL_EVENT_TASK_RUNNING_CORE\n  );\n  if (_eventTask == NULL) {\n    log_e(\" -- UART%d Event Task not Created!\", _uart_nr);\n  }\n}"
            }
        ],
        "third_party": [
            "HSERIAL_MUTEX_LOCK",
            "log_w",
            "uartSetRxFIFOFull",
            "HSERIAL_MUTEX_UNLOCK"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)",
        "start_line": "293",
        "end_line": "307",
        "file_path": "cores/esp32/Stream.cpp",
        "docstring": "The function \"readBytesUntil\" reads characters from a stream into a buffer until a specified terminator character is encountered or the specified length is reached.\\nIt returns the number of characters read, excluding the null terminator.\\nIf the length is less than 1, it returns 0.\\nThe function uses \"timedRead\" to get each character and stops reading if the terminator is found or the end of the stream is reached.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e30adf227199",
        "ground_truth": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length) {\n  if (length < 1) {\n    return 0;\n  }\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) {\n      break;\n    }\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index;  // return number of characters, not including null terminator\n}",
        "import_statements": [
            "#include \"Arduino.h\"\n",
            "#include \"Stream.h\"\n",
            "#include \"esp32-hal.h\"\n"
        ],
        "reference_api": [
            "timedRead"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "timedRead",
                "code": "int Stream::timedRead() {\n  int c;\n  _startMillis = millis();\n  do {\n    c = read();\n    if (c >= 0) {\n      return c;\n    }\n  } while (millis() - _startMillis < _timeout);\n  return -1;  // -1 indicates timeout\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)",
        "start_line": "111",
        "end_line": "128",
        "file_path": "cores/esp32/Tone.cpp",
        "docstring": "The function \"tone\" generates a tone on a specified pin with a given frequency and duration.\\nIt logs the pin, frequency, and duration, then checks if the pin is available or already in use.\\nIf the pin is available, it initializes the tone and sends a start command with the pin, frequency, and duration to a queue.\\nIf the pin is in use, it logs an error message instructing to stop the current tone on the pin first.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "986f26ededba",
        "ground_truth": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration) {\n  log_d(\"pin=%d, frequency=%u Hz, duration=%lu ms\", pin, frequency, duration);\n  if (_pin == -1 || _pin == pin) {\n    if (tone_init()) {\n      tone_msg_t tone_msg = {\n        .tone_cmd = TONE_START,\n        .pin = pin,\n        .frequency = frequency,\n        .duration = duration,\n      };\n      xQueueSend(_tone_queue, &tone_msg, portMAX_DELAY);\n      return;\n    }\n  } else {\n    log_e(\"Tone is still running on pin %d, call noTone(%d) first!\", _pin, _pin);\n    return;\n  }\n}",
        "import_statements": [
            "#include <Arduino.h>\n",
            "#include \"esp32-hal-ledc.h\"\n",
            "#include \"freertos/task.h\"\n",
            "#include \"freertos/queue.h\"\n",
            "#include \"freertos/semphr.h\"\n"
        ],
        "reference_api": [
            "xQueueSend",
            "log_e",
            "tone_init",
            "log_d"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "tone_init",
                "code": "static int tone_init() {\n  if (_tone_queue == NULL) {\n    log_v(\"Creating tone queue\");\n    _tone_queue = xQueueCreate(128, sizeof(tone_msg_t));\n    if (_tone_queue == NULL) {\n      log_e(\"Could not create tone queue\");\n      return 0;  // ERR\n    }\n    log_v(\"Tone queue created\");\n  }\n\n  if (_tone_task == NULL) {\n    log_v(\"Creating tone task\");\n    xTaskCreate(\n      tone_task,   // Function to implement the task\n      \"toneTask\",  // Name of the task\n      3500,        // Stack size in words\n      NULL,        // Task input parameter\n      1,           // Priority of the task\n      &_tone_task  // Task handle.\n    );\n    if (_tone_task == NULL) {\n      log_e(\"Could not create tone task\");\n      return 0;  // ERR\n    }\n    log_v(\"Tone task created\");\n  }\n  return 1;  // OK\n}"
            }
        ],
        "third_party": [
            "xQueueSend",
            "log_e",
            "log_d"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "bool ESPUSB::webUSB(bool enabled)",
        "start_line": "299",
        "end_line": "307",
        "file_path": "cores/esp32/USB.cpp",
        "docstring": "The function \"ESPUSB::webUSB\" enables or disables WebUSB functionality based on the provided parameter.\\nIf USB has not started, it updates the WebUSB enabled state and ensures the USB version is at least 0x0210 when enabling WebUSB.\\nThe function returns a boolean indicating whether USB has not started.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "93f686ae4d18",
        "ground_truth": "bool ESPUSB::webUSB(bool enabled) {\n  if (!_started) {\n    webusb_enabled = enabled;\n    if (enabled && usb_version < 0x0210) {\n      usb_version = 0x0210;\n    }\n  }\n  return !_started;\n}",
        "import_statements": [
            "#include \"USB.h\"\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "Arduino",
        "owner/repo": "espressif/arduino-esp32",
        "function_declaration": "void USBCDC::_onRX()",
        "start_line": "269",
        "end_line": "286",
        "file_path": "cores/esp32/USBCDC.cpp",
        "docstring": "The function \"USBCDC::_onRX\" handles incoming USB CDC (Communications Device Class) data.\\nIt reads data into a buffer and attempts to send each byte to a receive queue.\\nIf the queue is full, it posts an overflow event with the number of dropped bytes and logs an error.\\nIf data is successfully read, it posts a receive event with the length of the received data.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bd49c13e135e",
        "ground_truth": "void USBCDC::_onRX() {\n  arduino_usb_cdc_event_data_t p;\n  uint8_t buf[CONFIG_TINYUSB_CDC_RX_BUFSIZE + 1];\n  uint32_t count = tud_cdc_n_read(itf, buf, CONFIG_TINYUSB_CDC_RX_BUFSIZE);\n  for (uint32_t i = 0; i < count; i++) {\n    if (rx_queue == NULL || !xQueueSend(rx_queue, buf + i, 10)) {\n      p.rx_overflow.dropped_bytes = count - i;\n      arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_OVERFLOW_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n      log_e(\"CDC RX Overflow.\");\n      count = i;\n      break;\n    }\n  }\n  if (count) {\n    p.rx.len = count;\n    arduino_usb_event_post(ARDUINO_USB_CDC_EVENTS, ARDUINO_USB_CDC_RX_EVENT, &p, sizeof(arduino_usb_cdc_event_data_t), portMAX_DELAY);\n  }\n}",
        "import_statements": [
            "#include \"USBCDC.h\"\n"
        ],
        "reference_api": [
            "log_e",
            "arduino_usb_event_post",
            "tud_cdc_n_read",
            "xQueueSend"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "log_e",
            "arduino_usb_event_post",
            "tud_cdc_n_read",
            "xQueueSend"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)",
        "start_line": "240",
        "end_line": "250",
        "file_path": "api/api.go",
        "docstring": "The function \"robotDevices\" handles HTTP requests to retrieve devices associated with a specific robot.\\nIt checks if a robot with the given name exists and if so, gathers its devices into a JSON format and writes this JSON response to the HTTP response writer.\\nIf the robot does not exist, it returns a JSON response with an error message indicating that no robot was found with the specified name.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "658ef3c9dd4f",
        "ground_truth": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request) {\n if robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n  jsonDevices := []*gobot.JSONDevice{}\n  robot.Devices().Each(func(d gobot.Device) {\n   jsonDevices = append(jsonDevices, gobot.NewJSONDevice(d))\n  })\n  a.writeJSON(map[string]interface{}{\"devices\": jsonDevices}, res)\n } else {\n  a.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n }\n}",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/bmizerany/pat\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/api/robeaux\"\n)"
        ],
        "reference_api": [
            "req.URL.Query().Get",
            "gobot.NewJSONDevice",
            "a.writeJSON",
            "a.master.Robot",
            "req.URL.Query",
            "append",
            "robot.Devices().Each",
            "robot.Devices"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "req.URL.Query().Get",
            "gobot.NewJSONDevice",
            "a.writeJSON",
            "a.master.Robot",
            "req.URL.Query",
            "append",
            "robot.Devices().Each",
            "robot.Devices"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)",
        "start_line": "315",
        "end_line": "325",
        "file_path": "api/api.go",
        "docstring": "The function \"robotConnections\" handles HTTP requests to retrieve the connections of a specified robot.\\nIt extracts the robot name from the request URL and checks if the robot exists.\\nIf the robot is found, it iterates through its connections, converts them to JSON format, and writes them to the HTTP response.\\nIf the robot is not found, it writes an error message to the HTTP response indicating that no robot with the specified name was found.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bc8258b7482d",
        "ground_truth": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request) {\n jsonConnections := []*gobot.JSONConnection{}\n if robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n  robot.Connections().Each(func(c gobot.Connection) {\n   jsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n  })\n  a.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n } else {\n  a.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n }\n}",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/bmizerany/pat\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/api/robeaux\"\n)"
        ],
        "reference_api": [
            "req.URL.Query().Get",
            "a.writeJSON",
            "a.master.Robot",
            "req.URL.Query",
            "robot.Connections",
            "append",
            "gobot.NewJSONConnection",
            "robot.Connections().Each"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "req.URL.Query().Get",
            "a.writeJSON",
            "a.master.Robot",
            "req.URL.Query",
            "robot.Connections",
            "append",
            "gobot.NewJSONConnection",
            "robot.Connections().Each"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)",
        "start_line": "346",
        "end_line": "360",
        "file_path": "api/api.go",
        "docstring": "The function \"executeRobotDeviceCommand\" handles HTTP requests to execute a command on a robot device.\\nIt retrieves the robot and device names from the URL query parameters and checks if the device exists.\\nIf the device exists, it executes the specified command on the device using the Gobot framework.\\nIf an error occurs while retrieving the device, it writes the error message as a JSON response.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b9456640d4c7",
        "ground_truth": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request) {\n if _, err := a.jsonDeviceFor(req.URL.Query().Get(\":robot\"),\n  req.URL.Query().Get(\":device\")); err != nil {\n  a.writeJSON(map[string]interface{}{\"error\": err.Error()}, res)\n } else {\n  a.executeCommand(\n   //nolint:forcetypeassert // no error return value, so there is no better way\n   a.master.Robot(req.URL.Query().Get(\":robot\")).\n    Device(req.URL.Query().Get(\":device\")).(gobot.Commander).\n    Command(req.URL.Query().Get(\":command\")),\n   res,\n   req,\n  )\n }\n}",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/bmizerany/pat\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/api/robeaux\"\n)"
        ],
        "reference_api": [
            "req.URL.Query().Get",
            "a.writeJSON",
            "a.master.Robot",
            "req.URL.Query",
            "a.master.Robot(req.URL.Query().Get(\":robot\")).\n\t\t\t\tDevice",
            "err.Error",
            "a.master.Robot(req.URL.Query().Get(\":robot\")).\n\t\t\t\tDevice(req.URL.Query().Get(\":device\")).(gobot.Commander).\n\t\t\t\tCommand",
            "a.executeCommand",
            "a.jsonDeviceFor"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "req.URL.Query().Get",
            "a.writeJSON",
            "a.master.Robot",
            "req.URL.Query",
            "a.master.Robot(req.URL.Query().Get(\":robot\")).\n\t\t\t\tDevice",
            "err.Error",
            "a.master.Robot(req.URL.Query().Get(\":robot\")).\n\t\t\t\tDevice(req.URL.Query().Get(\":device\")).(gobot.Commander).\n\t\t\t\tCommand",
            "a.executeCommand",
            "a.jsonDeviceFor"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func BasicAuth(username, password string) http.HandlerFunc",
        "start_line": "10",
        "end_line": "22",
        "file_path": "api/basic_auth.go",
        "docstring": "The function \"BasicAuth\" creates an HTTP handler function that implements basic authentication using a specified username and password.\\nIt compares the \"Authorization\" header from incoming requests with the expected value based on the provided credentials.\\nIf the comparison fails, it sets the \"WWW-Authenticate\" header and responds with a \"401 Unauthorized\" status and an error message.\\nIf the comparison succeeds, the request proceeds to the next handler.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b27af1ddb67b",
        "ground_truth": "func BasicAuth(username, password string) http.HandlerFunc {\n // Inspired by https://github.com/codegangsta/martini-contrib/blob/master/auth/\n return func(res http.ResponseWriter, req *http.Request) {\n  if !secureCompare(req.Header.Get(\"Authorization\"),\n   \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)),\n  ) {\n   res.Header().Set(\"WWW-Authenticate\",\n    \"Basic realm=\\\"Authorization Required\\\"\",\n   )\n   http.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n  }\n }\n}",
        "import_statements": [
            "import (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"net/http\"\n)"
        ],
        "reference_api": [
            "res.Header",
            "req.Header.Get",
            "res.Header().Set",
            "http.Error",
            "secureCompare",
            "base64.StdEncoding.EncodeToString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "secureCompare",
                "code": "func secureCompare(given string, actual string) bool {\n\tif subtle.ConstantTimeEq(int32(len(given)), int32(len(actual))) == 1 {\n\t\treturn subtle.ConstantTimeCompare([]byte(given), []byte(actual)) == 1\n\t}\n\t// Securely compare actual to itself to keep constant time,\n\t// but always return false\n\treturn subtle.ConstantTimeCompare([]byte(actual), []byte(actual)) == 1 && false\n}"
            }
        ],
        "third_party": [
            "res.Header",
            "req.Header.Get",
            "res.Header().Set",
            "http.Error"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)",
        "start_line": "214",
        "end_line": "231",
        "file_path": "drivers/aio/analog_sensor_driver.go",
        "docstring": "The function \"analogSensorRead\" reads the value from an analog sensor and returns the raw and scaled values.\\nIt locks the sensor for reading, checks if the connection supports analog reading, and retrieves the raw sensor value.\\nIt then scales the raw value according to the sensor's configuration, updates the last read values, and returns both the raw and scaled values, or an error if the reading fails.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "44daf24485fb",
        "ground_truth": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error) {\n a.mutex.Lock()\n defer a.mutex.Unlock()\n  reader, ok := a.connection.(AnalogReader)\n if !ok {\n  return 0, 0, fmt.Errorf(\"AnalogRead is not supported by the platform '%s'\", a.Connection().Name())\n }\n  rawValue, err := reader.AnalogRead(a.Pin())\n if err != nil {\n  return 0, 0, err\n }\n  a.lastRawValue = rawValue\n a.lastValue = a.sensorCfg.scale(a.lastRawValue)\n return a.lastRawValue, a.lastValue, nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n)"
        ],
        "reference_api": [
            "fmt.Errorf",
            "a.sensorCfg.scale",
            "a.Connection",
            "a.Connection().Name",
            "a.mutex.Lock",
            "a.Pin",
            "a.mutex.Unlock",
            "reader.AnalogRead"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "a.sensorCfg.scale",
            "a.Connection",
            "a.Connection().Name",
            "a.mutex.Lock",
            "a.Pin",
            "a.mutex.Unlock",
            "reader.AnalogRead"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver",
        "start_line": "84",
        "end_line": "91",
        "file_path": "drivers/aio/grove_drivers.go",
        "docstring": "The function \"NewGroveSoundSensorDriver\" creates and initializes a new Grove Sound Sensor driver.\\nIt takes an AnalogReader, a pin string, and optional parameters as inputs.\\nIt initializes the driver with an AnalogSensorDriver using the provided inputs and assigns a default name to the driver.\\nFinally, it returns a pointer to the newly created GroveSoundSensorDriver.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f0d7bf48c40b",
        "ground_truth": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver {\n d := GroveSoundSensorDriver{\n  AnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n }\n d.driverCfg.name = gobot.DefaultName(\"GroveSoundSensor\")\n  return &d\n}",
        "import_statements": [
            "import \"gobot.io/x/gobot/v2"
        ],
        "reference_api": [
            "gobot.DefaultName",
            "NewAnalogSensorDriver"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "gobot.DefaultName",
            "NewAnalogSensorDriver"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *MFRC522Common) softReset() error",
        "start_line": "135",
        "end_line": "153",
        "file_path": "drivers/common/mfrc522/mfrc522_pcd.go",
        "docstring": "The function \"softReset\" performs a soft reset on an MFRC522 device.\\nIt writes the soft reset command to the command register and then waits for a specified initialization time.\\nAfter the delay, it reads the command register to check the status.\\nIf the power-down bit is still set, it returns an error indicating that the initialization took too long.\\nIf successful, it returns nil.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e9605540ecaf",
        "ground_truth": "func (d *MFRC522Common) softReset() error {\n if err := d.writeByteData(regCommand, commandRegSoftReset); err != nil {\n  return err\n }\n  // The datasheet does not mention how long the SoftReset command takes to complete. According to section 8.8.2 of the\n // datasheet the oscillator start-up time is the start up time of the crystal + 37.74 us.\n // TODO: this can be done better by wait until the power down bit is cleared\n time.Sleep(initTime)\n val, err := d.readByteData(regCommand)\n if err != nil {\n  return err\n }\n  if val&commandRegPowerDownBit > 1 {\n  return fmt.Errorf(\"initialization takes longer than %s\", initTime)\n }\n return nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"time\"\n)"
        ],
        "reference_api": [
            "d.writeByteData",
            "fmt.Errorf",
            "time.Sleep",
            "d.readByteData"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "d.writeByteData",
            "d.readByteData"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)",
        "start_line": "335",
        "end_line": "362",
        "file_path": "drivers/common/mfrc522/mfrc522_pcd.go",
        "docstring": "The function \"readFifo\" reads data from the FIFO buffer of an MFRC522 device into a provided byte slice.\\nIt first checks the number of bytes available in the FIFO and compares it to the expected length of the byte slice.\\nIf the lengths do not match, it returns an error.\\nIf they match, it reads each byte from the FIFO into the byte slice.\\nFinally, it reads the control register to get the last bits received and returns this value along with any errors encountered.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7c10ca38153c",
        "ground_truth": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error) {\n n, err := d.readByteData(regFIFOLevel) // Number of bytes in the FIFO\n if err != nil {\n  return 0, err\n }\n if n > uint8(len(backData)) {\n  return 0, fmt.Errorf(\"more data in FIFO (%d) than expected (%d)\", n, len(backData))\n }\n  if n < uint8(len(backData)) {\n  return 0, fmt.Errorf(\"less data in FIFO (%d) than expected (%d)\", n, len(backData))\n }\n  // the register command is always the same, the pointer in FIFO is incremented automatically after each read\n for i := 0; i < int(n); i++ {\n  byteVal, err := d.readByteData(regFIFOData)\n  if err != nil {\n   return 0, err\n  }\n  backData[i] = byteVal\n }\n  rxLastBits, err := d.readByteData(regControl)\n if err != nil {\n  return 0, err\n }\n return rxLastBits & controlRegRxLastBits, nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"time\"\n)"
        ],
        "reference_api": [
            "fmt.Errorf",
            "int",
            "uint8",
            "len",
            "d.readByteData"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "int",
            "uint8",
            "len",
            "d.readByteData"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *MFRC522Common) piccHalt() error",
        "start_line": "175",
        "end_line": "196",
        "file_path": "drivers/common/mfrc522/mfrc522_picc.go",
        "docstring": "The function \"piccHalt\" halts communication with a PICC (Proximity Integrated Circuit Card).\\nIt first logs a debug message if debugging is enabled.\\nIt then creates a halt command, calculates the CRC for the command, and appends the CRC result to the command.\\nIt sends the halt command to the PICC and expects an error to indicate successful halting.\\nIf the halt is successful, it returns nil; otherwise, it returns an error message.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a2ef62668705",
        "ground_truth": "func (d *MFRC522Common) piccHalt() error {\n if piccDebug {\n  fmt.Println(\"-halt-\")\n }\n haltCommand := []byte{piccCommandHLTA, 0x00}\n crcResult := []byte{0x00, 0x00}\n if err := d.calculateCRC(haltCommand, crcResult); err != nil {\n  return err\n }\n haltCommand = append(haltCommand, crcResult...)\n  txLastBits := uint8(0x00) // we use all 8 bits\n if err := d.communicateWithPICC(commandRegTransceive, haltCommand, []byte{}, txLastBits, false); err != nil {\n  // an error is the sign for successful halt\n  if piccDebug {\n   fmt.Println(\"this is not treated as error:\", err)\n  }\n  return nil\n }\n  return fmt.Errorf(\"something went wrong with halt\")\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n)"
        ],
        "reference_api": [
            "d.communicateWithPICC",
            "fmt.Errorf",
            "uint8",
            "append",
            "fmt.Println",
            "d.calculateCRC"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "d.communicateWithPICC",
            "uint8",
            "append",
            "d.calculateCRC"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)",
        "start_line": "242",
        "end_line": "260",
        "file_path": "drivers/common/mfrc522/mfrc522_picc.go",
        "docstring": "The function \"piccRead\" reads data from a specific block on an MFRC522 RFID card.\\nIt constructs a read command, calculates the CRC for the command, and appends the CRC to the command.\\nIt then communicates with the RFID card using the command and retrieves up to 16 bytes of data from the specified block.\\nIf successful, it returns the data; otherwise, it returns an error.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "04841011faf7",
        "ground_truth": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error) {\n if piccDebug {\n  fmt.Println(\"-read-\")\n }\n readDataCommand := []byte{piccCommandMFRegREAD, block}\n crcResult := []byte{0x00, 0x00}\n if err := d.calculateCRC(readDataCommand, crcResult); err != nil {\n  return nil, err\n }\n readDataCommand = append(readDataCommand, crcResult...)\n  txLastBits := uint8(0x00)    // we use all 8 bits\n backData := make([]byte, 18) // 16 data byte and 2 byte CRC\n if err := d.communicateWithPICC(commandRegTransceive, readDataCommand, backData, txLastBits, true); err != nil {\n  return nil, err\n }\n  return backData[:16], nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n)"
        ],
        "reference_api": [
            "d.communicateWithPICC",
            "uint8",
            "make",
            "append",
            "fmt.Println",
            "d.calculateCRC"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "d.communicateWithPICC",
            "uint8",
            "make",
            "append",
            "d.calculateCRC"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error",
        "start_line": "392",
        "end_line": "408",
        "file_path": "drivers/common/mfrc522/mfrc522_picc.go",
        "docstring": "The function \"piccRequest\" sends a request command to a PICC (Proximity Integrated Circuit Card) and expects a response.\\nIt first checks if the answer buffer has at least 2 bytes of space.\\nThen, it clears specific bits in the collision register.\\nFor certain request modes, it sets the transmission to use only 7 bits of the last byte.\\nFinally, it communicates with the PICC using the transceive command and returns any errors encountered during the process.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "70dc02692db5",
        "ground_truth": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error {\n if len(answer) < 2 {\n  return fmt.Errorf(\"at least 2 bytes room needed for the answer\")\n }\n  if err := d.clearRegisterBitMask(regColl, collRegValuesAfterCollBit); err != nil {\n  return err\n }\n  // for request A and wake up the short frame format is used - transmit only 7 bits of the last (and only) byte.\n txLastBits := uint8(0x07 & bitFramingRegTxLastBits)\n if err := d.communicateWithPICC(commandRegTransceive, []byte{reqMode}, answer, txLastBits, false); err != nil {\n  return err\n }\n  return nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n)"
        ],
        "reference_api": [
            "d.communicateWithPICC",
            "fmt.Errorf",
            "uint8",
            "len",
            "d.clearRegisterBitMask"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "d.communicateWithPICC",
            "uint8",
            "len",
            "d.clearRegisterBitMask"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *EasyDriver) onePinStepping() error",
        "start_line": "207",
        "end_line": "229",
        "file_path": "drivers/gpio/easy_driver.go",
        "docstring": "The function \"onePinStepping\" performs a single step operation for an EasyDriver stepper motor controller.\\nIt locks the valueMutex to ensure thread safety while accessing shared variables.\\nThe function then triggers a valid step by setting the step pin low, waiting for a delay, and setting the step pin high.\\nDepending on the direction, it increments or decrements the step number.\\nThe function returns any error encountered during the digital write operations.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "18bf5f10ea02",
        "ground_truth": "func (d *EasyDriver) onePinStepping() error {\n // ensure that read and write of variables (direction, stepNum) can not interfere\n d.valueMutex.Lock()\n defer d.valueMutex.Unlock()\n  // a valid steps occurs for a low to high transition\n if err := d.digitalWrite(d.stepPin, 0); err != nil {\n  return err\n }\n  time.Sleep(d.getDelayPerStep())\n if err := d.digitalWrite(d.stepPin, 1); err != nil {\n  return err\n }\n  if d.direction == StepperDriverForward {\n  d.stepNum++\n } else {\n  d.stepNum--\n }\n  return nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n)"
        ],
        "reference_api": [
            "d.valueMutex.Lock",
            "time.Sleep",
            "d.valueMutex.Unlock",
            "d.digitalWrite",
            "d.getDelayPerStep"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "d.valueMutex.Lock",
            "d.valueMutex.Unlock",
            "d.digitalWrite",
            "d.getDelayPerStep"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *HCSR04Driver) StartDistanceMonitor() error",
        "start_line": "157",
        "end_line": "187",
        "file_path": "drivers/gpio/hcsr04_driver.go",
        "docstring": "The function \"StartDistanceMonitor\" initiates continuous distance monitoring for an HCSR04 ultrasonic sensor.\\nIt locks the mutex to prevent interference with start and stop operations.\\nIf a distance monitor is already running, it returns an error.\\nOtherwise, it creates a stop channel and a wait group, then starts a goroutine that repeatedly measures distance until the stop channel is signaled.\\nThe distance measurements are performed at regular intervals, and any errors during measurement are logged.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6d68988a836a",
        "ground_truth": "func (d *HCSR04Driver) StartDistanceMonitor() error {\n // ensure that start and stop can not interfere\n d.mutex.Lock()\n defer d.mutex.Unlock()\n  if d.distanceMonitorStopChan != nil {\n  return fmt.Errorf(\"distance monitor already started for '%s'\", d.driverCfg.name)\n }\n  d.distanceMonitorStopChan = make(chan struct{})\n d.distanceMonitorStopWaitGroup = &sync.WaitGroup{}\n d.distanceMonitorStopWaitGroup.Add(1)\n  go func(name string) {\n  defer d.distanceMonitorStopWaitGroup.Done()\n  for {\n   select {\n   case <-d.distanceMonitorStopChan:\n    d.distanceMonitorStopChan = nil\n    return\n   default:\n    if err := d.measureDistance(); err != nil {\n     fmt.Printf(\"continuous measure distance skipped for '%s': %v\\n\", name, err)\n    }\n    time.Sleep(hcsr04MonitorUpdate)\n   }\n  }\n }(d.driverCfg.name)\n  return nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/system\"\n)"
        ],
        "reference_api": [
            "d.mutex.Lock",
            "fmt.Errorf",
            "d.measureDistance",
            "func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}",
            "make",
            "time.Sleep",
            "d.distanceMonitorStopWaitGroup.Add",
            "fmt.Printf",
            "d.mutex.Unlock",
            "d.distanceMonitorStopWaitGroup.Done"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "d.mutex.Lock",
            "d.measureDistance",
            "func(name string) {\n\t\tdefer d.distanceMonitorStopWaitGroup.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.distanceMonitorStopChan:\n\t\t\t\td.distanceMonitorStopChan = nil\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif err := d.measureDistance(); err != nil {\n\t\t\t\t\tfmt.Printf(\"continuous measure distance skipped for '%s': %v\\n\", name, err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(hcsr04MonitorUpdate)\n\t\t\t}\n\t\t}\n\t}",
            "make",
            "d.distanceMonitorStopWaitGroup.Add",
            "d.mutex.Unlock",
            "d.distanceMonitorStopWaitGroup.Done"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)",
        "start_line": "198",
        "end_line": "214",
        "file_path": "drivers/gpio/hcsr04_driver.go",
        "docstring": "The function \"createEventHandler\" for the \"HCSR04Driver\" generates an event handler to measure the duration of an ultrasonic pulse.\\nIt initializes a variable to track the start timestamp of the pulse.\\nWhen a rising edge event is detected, it records the timestamp.\\nWhen a falling edge event is detected, it calculates the duration of the pulse, sends this duration to a channel, and resets the start timestamp.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e081f93e0d95",
        "ground_truth": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32) {\n var startTimestamp time.Duration\n return func(offset int, t time.Duration, et string, sn uint32, lsn uint32) {\n  switch et {\n  case system.DigitalPinEventRisingEdge:\n   startTimestamp = t\n  case system.DigitalPinEventFallingEdge:\n   // unfortunately there is an additional falling edge at each start trigger, so we need to filter this\n   // we use the start duration value for filtering\n   if startTimestamp == 0 {\n    return\n   }\n   d.delayMicroSecChan <- (t - startTimestamp).Microseconds()\n   startTimestamp = 0\n  }\n }\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/system\"\n)"
        ],
        "reference_api": [
            "(t - startTimestamp).Microseconds"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "(t - startTimestamp).Microseconds"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *HCSR04Driver) measureDistance() error",
        "start_line": "227",
        "end_line": "244",
        "file_path": "drivers/gpio/hcsr04_driver.go",
        "docstring": "The function \"measureDistance\" measures the distance using the HCSR04 sensor.\\nIt locks the measurement mutex to ensure exclusive access and unlocks it after the measurement.\\nIt triggers the sensor and waits for the measurement to complete or for a timeout to occur.\\nIf a timeout is reached, it returns an error.\\nIf the measurement is successful, it stores the measured time in microseconds.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3e6e58865196",
        "ground_truth": "func (d *HCSR04Driver) measureDistance() error {\n d.measureMutex.Lock()\n defer d.measureMutex.Unlock()\n  if err := d.emitTrigger(); err != nil {\n  return err\n }\n  // stop the loop if the measure is done or the timeout is elapsed\n timeout := hcsr04StartTransmitTimeout + hcsr04ReceiveTimeout\n select {\n case <-time.After(timeout):\n  return fmt.Errorf(\"timeout %s reached while waiting for value with echo pin %s\", timeout, d.echoPinID)\n case d.lastMeasureMicroSec = <-d.delayMicroSecChan:\n }\n  return nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/system\"\n)"
        ],
        "reference_api": [
            "time.After",
            "fmt.Errorf",
            "d.measureMutex.Lock",
            "d.emitTrigger",
            "d.measureMutex.Unlock"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "d.measureMutex.Lock",
            "d.emitTrigger",
            "d.measureMutex.Unlock"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "platformio/platformio-core",
        "function_declaration": "def fetch_authentication_token(self)",
        "start_line": "66",
        "end_line": "86",
        "file_path": "platformio/account/client.py",
        "docstring": "The function \"fetch_authentication_token\" retrieves the authentication token for the application.\\nIt first checks if the token is available in the environment variables.\\nIf not, it checks the local state for a valid access token and its expiration time.\\nIf the access token is expired but a refresh token is available, it attempts to fetch a new access token using the refresh token.\\nIf successful, it updates the local state with the new authentication data and returns the new access token.\\nIf all methods fail, it raises an \"AccountNotAuthorized\" exception.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2e67109ea5b2",
        "ground_truth": "def fetch_authentication_token(self):\n    if os.environ.get(\"PLATFORMIO_AUTH_TOKEN\"):\n        return os.environ.get(\"PLATFORMIO_AUTH_TOKEN\")\n    auth = app.get_state_item(\"account\", {}).get(\"auth\", {})\n    if auth.get(\"access_token\") and auth.get(\"access_token_expire\"):\n        if auth.get(\"access_token_expire\") > time.time():\n            return auth.get(\"access_token\")\n        if auth.get(\"refresh_token\"):\n            try:\n                data = self.fetch_json_data(\n                    \"post\",\n                    \"/v1/login\",\n                    headers={\n                        \"Authorization\": \"Bearer %s\" % auth.get(\"refresh_token\")\n                    },\n                )\n                app.set_state_item(\"account\", data)\n                return data.get(\"auth\").get(\"access_token\")\n            except AccountError:\n                self.delete_local_session()\n    raise AccountNotAuthorized()",
        "import_statements": [
            "import os",
            "import time",
            "from platformio import __accounts_api__, app",
            "from platformio.exception import PlatformioException, UserSideException",
            "from platformio.http import HTTPClient, HTTPClientError"
        ],
        "reference_api": [
            "self.fetch_json_data",
            "auth.get",
            "app.set_state_item",
            "get",
            "data.get",
            "self.delete_local_session",
            "AccountNotAuthorized",
            "app.get_state_item",
            "time.time"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.fetch_json_data",
                "code": "def fetch_json_data(self, *args, **kwargs):\n        try:\n            return super().fetch_json_data(*args, **kwargs)\n        except HTTPClientError as exc:\n            raise AccountError(exc) from exc"
            }
        ],
        "third_party": [
            "get",
            "get",
            "get",
            "app.get_state_item",
            "auth.get",
            "auth.get",
            "auth.get",
            "auth.get",
            "auth.get",
            "auth.get",
            "app.set_state_item",
            "get",
            "data.get",
            "self.delete_local_session",
            "AccountNotAuthorized"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "platformio/platformio-core",
        "function_declaration": "def logout(self)",
        "start_line": "124",
        "end_line": "135",
        "file_path": "platformio/account/client.py",
        "docstring": "The function \"logout\" logs the user out by performing the following steps:\\nIt retrieves the refresh token, deletes the local session, and then attempts to send a POST request to the \"/v1/logout\" endpoint with the refresh token.\\nIf an AccountError occurs during the request, it is ignored.\\nThe function returns \"True\" after completing these steps.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "791802ce1fb5",
        "ground_truth": "def logout(self):\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.fetch_json_data(\n            \"post\",\n            \"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n        )\n    except AccountError:\n        pass\n    return True",
        "import_statements": [
            "import os",
            "import time",
            "from platformio import __accounts_api__, app",
            "from platformio.exception import PlatformioException, UserSideException",
            "from platformio.http import HTTPClient, HTTPClientError"
        ],
        "reference_api": [
            "self.delete_local_session",
            "self.fetch_json_data",
            "self.get_refresh_token"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.fetch_json_data",
                "code": "def fetch_json_data(self, *args, **kwargs):\n        try:\n            return super().fetch_json_data(*args, **kwargs)\n        except HTTPClientError as exc:\n            raise AccountError(exc) from exc"
            }
        ],
        "third_party": [
            "self.get_refresh_token",
            "self.delete_local_session"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "platformio/platformio-core",
        "function_declaration": "def dump_used_packages(self)",
        "start_line": "55",
        "end_line": "67",
        "file_path": "platformio/platform/_packages.py",
        "docstring": "The function \"dump_used_packages\" returns a list of non-optional packages with their names and versions.\\nIt iterates through the packages, skips optional ones, and collects metadata for the others.\\nIf a package's metadata indicates it is external, it includes the source URL in the result.\\nFinally, it returns the list of packages with their respective information.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6384129c9ae6",
        "ground_truth": "def dump_used_packages(self):\n    result = []\n    for name, options in self.packages.items():\n        if options.get(\"optional\"):\n            continue\n        pkg = self.get_package(name)\n        if not pkg or not pkg.metadata:\n            continue\n        item = {\"name\": pkg.metadata.name, \"version\": str(pkg.metadata.version)}\n        if pkg.metadata.spec.external:\n            item[\"src_url\"] = pkg.metadata.spec.uri\n        result.append(item)\n    return result",
        "import_statements": [
            "from platformio.package.meta import PackageSpec"
        ],
        "reference_api": [
            "options.get",
            "self.get_package",
            "result.append",
            "items",
            "str"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.get_package",
                "code": "def get_package(self, name, spec=None):\n        if not name:\n            return None\n        return self.pm.get_package(spec or self.get_package_spec(name))"
            }
        ],
        "third_party": [
            "items",
            "options.get",
            "result.append"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "platformio/platformio-core",
        "function_declaration": "def from_env(cls, env, targets=None, autoinstall=False)",
        "start_line": "95",
        "end_line": "103",
        "file_path": "platformio/platform/factory.py",
        "docstring": "The function \"from_env\" creates and configures an instance of a project environment based on a specified environment name.\\nIt retrieves the platform specification for the environment from the project configuration.\\nIf the specification is not found, it raises an \"UndefinedEnvPlatformError\".\\nIt then creates a new instance of the class with the platform specification and autoinstall option, sets the project environment, and configures the project packages for the given environment and targets.\\nFinally, it returns the configured instance.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fb6e9b1c15cd",
        "ground_truth": "def from_env(cls, env, targets=None, autoinstall=False):\n    config = ProjectConfig.get_instance()\n    spec = config.get(f\"env:{env}\", \"platform\", None)\n    if not spec:\n        raise UndefinedEnvPlatformError(env)\n    p = cls.new(spec, autoinstall=autoinstall)\n    p.project_env = env\n    p.configure_project_packages(env, targets)\n    return p",
        "import_statements": [
            "import os",
            "import re",
            "import sys",
            "from platformio import fs",
            "from platformio.compat import load_python_module",
            "from platformio.package.meta import PackageItem",
            "from platformio.platform import base",
            "from platformio.platform.exception import UnknownPlatform",
            "from platformio.project.config import ProjectConfig",
            "from platformio.project.exception import UndefinedEnvPlatformError"
        ],
        "reference_api": [
            "cls.new",
            "UndefinedEnvPlatformError",
            "config.get",
            "ProjectConfig.get_instance",
            "p.configure_project_packages"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "config.get",
                "code": "def get(self, section, option, default=MISSING):\n        value = None\n        try:\n            value = self.getraw(section, option, default)\n        except configparser.Error as exc:\n            raise exception.InvalidProjectConfError(self.path, str(exc))\n\n        option_meta = self.find_option_meta(section, option)\n        if not option_meta:\n            return value\n\n        if option_meta.validate:\n            value = option_meta.validate(value)\n        if option_meta.multiple:\n            value = self.parse_multi_values(value or [])\n        try:\n            return self.cast_to(value, option_meta.type)\n        except click.BadParameter as exc:\n            if not self.expand_interpolations:\n                return value\n            raise exception.ProjectOptionValueError(\n                \"%s for `%s` option in the `%s` section (%s)\"\n                % (exc.format_message(), option, section, option_meta.description)\n            )"
            }
        ],
        "third_party": [
            "ProjectConfig.get_instance",
            "UndefinedEnvPlatformError",
            "cls.new",
            "p.configure_project_packages"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)",
        "start_line": "119",
        "end_line": "127",
        "file_path": "esp32_marauder/AXP192.cpp",
        "docstring": "The function \"ReadBuff\" reads a specified number of bytes from a given address of the AXP192 device.\\nIt initiates communication with the device at I2C address 0x34, sends the address to read from, and ends the transmission.\\nIt then requests the specified number of bytes from the device and stores the received data into the provided buffer.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "437d8520b195",
        "ground_truth": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff) {\n    Wire1.beginTransmission(0x34);\n    Wire1.write(Addr);\n    Wire1.endTransmission();\n    Wire1.requestFrom(0x34, (int)Size);\n    for (int i = 0; i < Size; i++) {\n        *(Buff + i) = Wire1.read();\n    }\n}",
        "import_statements": [
            "#include \"AXP192.h\"\n"
        ],
        "reference_api": [
            "Wire1.requestFrom",
            "Wire1.write",
            "Wire1.beginTransmission",
            "Wire1.endTransmission",
            "Wire1.read"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Wire1.requestFrom",
            "Wire1.write",
            "Wire1.beginTransmission",
            "Wire1.endTransmission",
            "Wire1.read"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "void AXP192::DeepSleep(uint64_t time_in_us)",
        "start_line": "303",
        "end_line": "312",
        "file_path": "esp32_marauder/AXP192.cpp",
        "docstring": "The function \"DeepSleep\" puts the AXP192 into deep sleep mode for a specified duration.\\nIt first calls \"SetSleep\" to prepare the device for sleep.\\nIf a non-zero duration is provided, it enables a timer to wake up the device after the specified time in microseconds.\\nIf the duration is zero, it disables the timer wakeup source.\\nFinally, it initiates deep sleep immediately or for the specified duration.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "256a5084bf22",
        "ground_truth": "void AXP192::DeepSleep(uint64_t time_in_us) {\n    SetSleep();\n     if (time_in_us > 0) {\n        esp_sleep_enable_timer_wakeup(time_in_us);\n    } else {\n        esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_TIMER);\n    }\n    (time_in_us == 0) ? esp_deep_sleep_start() : esp_deep_sleep(time_in_us);\n}",
        "import_statements": [
            "#include \"AXP192.h\"\n"
        ],
        "reference_api": [
            "esp_sleep_disable_wakeup_source",
            "SetSleep",
            "esp_sleep_enable_timer_wakeup",
            "esp_deep_sleep",
            "esp_deep_sleep_start"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SetSleep",
                "code": "void AXP192::SetSleep(void) {\n    uint8_t buf = Read8bit(0x31);\n    buf         = (1 << 3) | buf;\n    Write1Byte(0x31, buf);\n    Write1Byte(0x90, 0x00);\n    Write1Byte(0x12, 0x09);\n    // Write1Byte(0x12, 0x00);\n    Write1Byte(0x12, Read8bit(0x12) & 0xA1);  // Disable all outputs but DCDC1\n}"
            }
        ],
        "third_party": [
            "esp_sleep_disable_wakeup_source",
            "esp_sleep_enable_timer_wakeup",
            "esp_deep_sleep",
            "esp_deep_sleep_start"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "int Display::scroll_line(uint32_t color)",
        "start_line": "365",
        "end_line": "392",
        "file_path": "esp32_marauder/Display.cpp",
        "docstring": "The function \"scroll_line\" scrolls the display by one line and fills the new line with a specified color.\\nIt stores the current starting y-coordinate, then fills a rectangle at this coordinate with the specified color.\\nThe y-coordinate is incremented by the height of a text line, wrapping around if it exceeds the display boundaries minus the bottom fixed area.\\nIf a specific condition (tteBar) is met, it uses alternative top fixed area coordinates.\\nFinally, it updates the scroll address and returns the previous y-coordinate.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "00a628ed69af",
        "ground_truth": "int Display::scroll_line(uint32_t color) {\n  //Serial.println(\"scroll_line()\");\n  int yTemp = yStart; // Store the old yStart, this is where we draw the next line\n  // Use the record of line lengths to optimise the rectangle size we need to erase the top line\n   // Check if we have the \"touch to exit bar\"\n  if (!tteBar)\n  {\n    tft.fillRect(0,yStart,blank[(yStart-TOP_FIXED_AREA)/TEXT_HEIGHT],TEXT_HEIGHT, color);\n       // Change the top of the scroll area\n    yStart+=TEXT_HEIGHT;\n    // The value must wrap around as the screen memory is a circular buffer\n    if (yStart >= YMAX - BOT_FIXED_AREA) yStart = TOP_FIXED_AREA + (yStart - YMAX + BOT_FIXED_AREA);\n  }\n  else\n  {\n    tft.fillRect(0,yStart,blank[(yStart-TOP_FIXED_AREA_2)/TEXT_HEIGHT],TEXT_HEIGHT, color);\n       // Change the top of the scroll area\n    yStart+=TEXT_HEIGHT;\n    // The value must wrap around as the screen memory is a circular buffer\n    if (yStart >= YMAX - BOT_FIXED_AREA) yStart = TOP_FIXED_AREA_2 + (yStart - YMAX + BOT_FIXED_AREA);\n  }\n  // Now we can scroll the display\n  scrollAddress(yStart);\n  return  yTemp;\n}",
        "import_statements": [
            "#include \"Display.h\"\n",
            "#include \"lang_var.h\"\n"
        ],
        "reference_api": [
            "scrollAddress",
            "tft.fillRect"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "scrollAddress",
                "code": "void Display::scrollAddress(uint16_t vsp) {\n  #ifdef HAS_ILI9341\n    tft.writecommand(ILI9341_VSCRSADD); // Vertical scrolling pointer\n    tft.writedata(vsp>>8);\n    tft.writedata(vsp);\n  #endif\n}"
            }
        ],
        "third_party": [
            "tft.fillRect"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)",
        "start_line": "28",
        "end_line": "37",
        "file_path": "esp32_marauder/EvilPortal.cpp",
        "docstring": "The function \"begin\" initializes the EvilPortal by setting up access points and HTML content.\\nIt takes lists of SSIDs and Access Points as input.\\nIt returns false if setting the access points or HTML content fails.\\nIf both setups are successful, it starts the portal and returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b2af25a9f3e8",
        "ground_truth": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points) {\n  if (!this->setAP(ssids, access_points))\n    return false;\n  if (!this->setHtml())\n    return false;\n       startPortal();\n   return true;\n}",
        "import_statements": [
            "#include \"EvilPortal.h\"\n"
        ],
        "reference_api": [
            "this->setAP",
            "this->setHtml",
            "startPortal"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "startPortal",
                "code": "void EvilPortal::startPortal() {\n  // wait for flipper input to get config index\n  this->startAP();\n\n  this->runServer = true;\n}"
            }
        ],
        "third_party": [
            "this->setAP",
            "this->setHtml"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "void GpsInterface::enable_queue()",
        "start_line": "243",
        "end_line": "256",
        "file_path": "esp32_marauder/GpsInterface.cpp",
        "docstring": "The function \"enable_queue\" manages the state of the queue for the GPS interface.\\nIf the queue is already enabled, it ensures that the queue, text, and text_in are initialized.\\nIf the queue is not enabled, it flushes the existing queue and sets the queue_enabled_flag to true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9ad8e092bdd8",
        "ground_truth": "void GpsInterface::enable_queue(){\n  if(this->queue_enabled_flag){\n    if(!this->queue)\n      this->new_queue();\n    if(!this->text)\n      this->text=new LinkedList<String>;\n    if(!this->text_in)\n      this->text_in=new LinkedList<String>;\n  }\n  else {\n    this->flush_queue();\n    this->queue_enabled_flag=1;\n  }\n}",
        "import_statements": [
            "#include \"GpsInterface.h\"\n"
        ],
        "reference_api": [
            "this->flush_queue",
            "this->new_queue"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->flush_queue",
            "this->new_queue"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "void GpsInterface::flush_queue_nmea()",
        "start_line": "280",
        "end_line": "290",
        "file_path": "esp32_marauder/GpsInterface.cpp",
        "docstring": "The function \"flush_queue_nmea\" clears the current NMEA sentence queue for the GPS interface.\\nIf the queue exists and contains elements, it creates a new queue and deletes the old one.\\nIf the queue does not exist, it simply creates a new queue.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "607c4ad31e75",
        "ground_truth": "void GpsInterface::flush_queue_nmea(){\n  if(this->queue){\n    if(this->queue->size()){\n      LinkedList<nmea_sentence_t> *delme=this->queue;\n      this->new_queue();\n      delete delme;\n    }\n  }\n  else\n    this->new_queue();\n}",
        "import_statements": [
            "#include \"GpsInterface.h\"\n"
        ],
        "reference_api": [
            "this->queue->size",
            "this->new_queue"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->queue->size",
            "this->new_queue"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)",
        "start_line": "34",
        "end_line": "50",
        "file_path": "esp32_marauder/MenuFunctions.cpp",
        "docstring": "The function \"my_disp_flush\" updates a specified area of the display with new color data.\\nIt starts a write transaction, sets the address window to the specified area, and iterates through each pixel in the area.\\nFor each pixel, it writes the corresponding color from the provided color buffer.\\nAfter updating the area, it ends the write transaction and notifies that the display flush is complete.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8cbba9bbe0f4",
        "ground_truth": "void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)\n{\n  extern Display display_obj;\n  uint16_t c;\n   display_obj.tft.startWrite();\n  display_obj.tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n  for (int y = area->y1; y <= area->y2; y++) {\n    for (int x = area->x1; x <= area->x2; x++) {\n      c = color_p->full;\n      display_obj.tft.writeColor(c, 1);\n      color_p++;\n    }\n  }\n  display_obj.tft.endWrite();\n  lv_disp_flush_ready(disp);\n}",
        "import_statements": [
            "#include \"MenuFunctions.h\"\n",
            "#include \"lang_var.h\"\n"
        ],
        "reference_api": [
            "display_obj.tft.startWrite",
            "lv_disp_flush_ready",
            "display_obj.tft.writeColor",
            "display_obj.tft.endWrite",
            "display_obj.tft.setAddrWindow"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "display_obj.tft.startWrite",
            "lv_disp_flush_ready",
            "display_obj.tft.writeColor",
            "display_obj.tft.endWrite",
            "display_obj.tft.setAddrWindow"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "void MenuFunctions::showMenuList(Menu * menu, int layer)",
        "start_line": "2298",
        "end_line": "2310",
        "file_path": "esp32_marauder/MenuFunctions.cpp",
        "docstring": "The function \"showMenuList\" displays the menu nodes in a given menu with indentation based on the specified layer.\\nIt iterates through all menu nodes and prints each node's name with indentation proportional to the layer level.\\nAfter listing all nodes, it prints an empty line.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "86c372c99d86",
        "ground_truth": "void MenuFunctions::showMenuList(Menu * menu, int layer)\n{\n  // Iterate through all of the menu nodes in the menu\n  for (uint8_t i = 0; i < menu->list->size(); i++)\n  {\n    // Depending on layer, indent\n    for (uint8_t x = 0; x < layer * 4; x++)\n      Serial.print(\" \");\n    Serial.print(\"Node: \");\n    Serial.println(menu->list->get(i).name);\n  }\n  Serial.println();\n}",
        "import_statements": [
            "#include \"MenuFunctions.h\"\n",
            "#include \"lang_var.h\"\n"
        ],
        "reference_api": [
            "Serial.print",
            "menu->list->get",
            "menu->list->size",
            "Serial.println"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Serial.print",
            "menu->list->get",
            "menu->list->size",
            "Serial.println"
        ]
    },
    {
        "subclass": "Arduino",
        "owner/repo": "justcallmekoko/ESP32Marauder",
        "function_declaration": "int WiFiScan::generateSSIDs(int count)",
        "start_line": "410",
        "end_line": "424",
        "file_path": "esp32_marauder/WiFiScan.cpp",
        "docstring": "The function \"generateSSIDs\" generates a specified number of random SSIDs.\\nIt iterates through the given count, creating random SSIDs composed of 6 characters.\\nEach SSID is assigned a random channel and a random MAC address.\\nThe generated SSID is added to a list and printed to the serial output.\\nThe function returns the number of generated SSIDs.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fa401d949f3c",
        "ground_truth": "int WiFiScan::generateSSIDs(int count) {\n  uint8_t num_gen = count;\n  for (uint8_t x = 0; x < num_gen; x++) {\n    String essid = \"\";\n     for (uint8_t i = 0; i < 6; i++)\n      essid.concat(alfa[random(65)]);\n     ssid s = {essid, random(1, 12), {random(256), random(256), random(256), random(256), random(256), random(256)}, false};\n    ssids->add(s);\n    Serial.println(ssids->get(ssids->size() - 1).essid);\n  }\n   return num_gen;\n}",
        "import_statements": [
            "#include \"WiFiScan.h\"\n",
            "#include \"lang_var.h\"\n"
        ],
        "reference_api": [
            "ssids->size",
            "random",
            "essid.concat",
            "Serial.println",
            "ssids->add",
            "ssids->get"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ssids->size",
            "random",
            "essid.concat",
            "Serial.println",
            "ssids->add",
            "ssids->get"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "khadkarajesh/Pi-Image-Capturer",
        "function_declaration": "def create_topic(project_id, topic_name)",
        "start_line": "22",
        "end_line": "26",
        "file_path": "device_1/raspberry_pi_with_camera.py",
        "docstring": "The function \"create_topic\" creates a new topic in Google Cloud Pub/Sub.\\nIt initializes a PublisherClient, constructs the topic path using the provided project ID and topic name, and creates the topic.\\nAfter successfully creating the topic, it prints a confirmation message with the topic details.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4a06857e3120",
        "ground_truth": "def create_topic(project_id, topic_name):\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))",
        "import_statements": [
            "import argparse",
            "import datetime",
            "import os",
            "import time",
            "import socket",
            "import random",
            "from random import randint",
            "import json",
            "import sys",
            "import jwt",
            "from google.cloud import storage",
            "from pprint import pprint"
        ],
        "reference_api": [
            "print",
            "publisher.topic_path",
            "pubsub_v1.PublisherClient",
            "publisher.create_topic",
            "format"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "publisher.create_topic",
                "code": "def create_topic(project_id, topic_name):\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print('Topic created: {}'.format(topic))"
            }
        ],
        "third_party": [
            "pubsub_v1.PublisherClient",
            "publisher.topic_path"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "khadkarajesh/Pi-Image-Capturer",
        "function_declaration": "def create_jwt(project_id, private_key_file, algorithm)",
        "start_line": "40",
        "end_line": "71",
        "file_path": "device_1/raspberry_pi_with_camera.py",
        "docstring": "The function \"create_jwt\" generates a JSON Web Token (JWT) for authentication purposes.\\nIt sets the issued time (iat) to the current UTC time and the expiration time (exp) to one hour later.\\nThe audience (aud) field is set to the provided GCP project ID.\\nThe private key is read from the specified file, and the JWT is created using the specified algorithm.\\nThe function returns the encoded JWT.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0986206a5cb5",
        "ground_truth": "def create_jwt(project_id, private_key_file, algorithm):\n    \"\"\"Creates a JWT (https://jwt.io) to establish an MQTT connection.\n        Args:\n         project_id: The cloud project ID this device belongs to\n         private_key_file: A path to a file containing either an RSA256 or\n                 ES256 private key.\n         algorithm: The encryption algorithm to use. Either 'RS256' or 'ES256'\n        Returns:\n            An MQTT generated from the given project_id and private key, which\n            expires in 20 minutes. After 20 minutes, your client will be\n            disconnected, and a new JWT will have to be generated.\n        Raises:\n            ValueError: If the private_key_file does not contain a known key.\n        \"\"\"\n     token = {\n            # The time that the token was issued at\n            'iat': datetime.datetime.utcnow(),\n            # The time the token expires.\n            'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n            # The audience field should always be set to the GCP project id.\n            'aud': project_id\n    }\n     # Read the private key file.\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n     print('Creating JWT using {} from private key file {}'.format(\n            algorithm, private_key_file))\n     return jwt.encode(token, private_key, algorithm=algorithm)",
        "import_statements": [
            "import argparse",
            "import datetime",
            "import os",
            "import time",
            "import socket",
            "import random",
            "from random import randint",
            "import json",
            "import sys",
            "import jwt",
            "from google.cloud import storage",
            "from pprint import pprint"
        ],
        "reference_api": [
            "jwt.encode",
            "print",
            "f.read",
            "datetime.timedelta",
            "utcnow",
            "open",
            "format"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "utcnow",
            "utcnow",
            "f.read",
            "jwt.encode"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "khadkarajesh/Pi-Image-Capturer",
        "function_declaration": "def on_message(unused_client, unused_userdata, message)",
        "start_line": "96",
        "end_line": "110",
        "file_path": "device_1/raspberry_pi_with_camera.py",
        "docstring": "The function \"on_message\" is a callback that handles incoming messages for a subscribed device.\\nIt prints the received message's payload, topic, and QoS.\\nIf the payload is \"on\", it captures a preview image, uploads the file to a specified bucket, and publishes the file's URL to an MQTT event topic.\\nIf the payload is not \"on\", it simply prints \"off\".",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9ae28498f034",
        "ground_truth": "def on_message(unused_client, unused_userdata, message):\n        \"\"\"Callback when the device receives a message on a subscription.\"\"\"\n        payload = message.payload\n        print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n            payload, message.topic, str(message.qos)))\n        print(payload.decode('utf-8'))\n        if payload.decode('utf-8') == 'on':\n            to_save_image_path = sys.path[0] + '/'    \n            preview_capture(to_save_image_path)\n            args = parse_command_line_args()\n            url = upload_file(to_save_image_path,args.bucket_name)\n            mqtt_event = '/devices/{}/events'.format(args.device_id)\n            unused_client.publish(mqtt_event, url, qos=1)\n        else:\n            print('off')",
        "import_statements": [
            "import argparse",
            "import datetime",
            "import os",
            "import time",
            "import socket",
            "import random",
            "from random import randint",
            "import json",
            "import sys",
            "import jwt",
            "from google.cloud import storage",
            "from pprint import pprint"
        ],
        "reference_api": [
            "print",
            "preview_capture",
            "unused_client.publish",
            "payload.decode",
            "upload_file",
            "parse_command_line_args",
            "str",
            "format"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "preview_capture",
                "code": "def preview_capture(path):\n    camera = get_camera()\n    camera.start_preview()\n    time.sleep(5)\n    camera.capture(path)\n    camera.stop_preview()\n    camera.close_camera()"
            },
            {
                "name": "parse_command_line_args",
                "code": "def parse_command_line_args():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(description=(\n            'Example Google Cloud IoT Core MQTT device connection code.'))\n    parser.add_argument(\n            '--project_id',\n            default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n            help='GCP cloud project name')\n    parser.add_argument(\n            '--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument(\n            '--device_id', required=True, help='Cloud IoT Core device id')\n    parser.add_argument(\n            '--private_key_file',\n            required=True, help='Path to private key file.')\n    parser.add_argument(\n            '--algorithm',\n            choices=('RS256', 'ES256'),\n            default='RS256',\n            help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--bucket_name', required=True, help='Cloud Storage bucket name')\n    parser.add_argument(\n            '--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument(\n            '--ca_certs',\n            default='roots.pem',\n            help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n            '--mqtt_bridge_hostname',\n            default='mqtt.googleapis.com',\n            help='MQTT bridge hostname.')\n    parser.add_argument(\n            '--mqtt_bridge_port',\n            choices=(8883, 443),\n            default=8883,\n            type=int,\n            help='MQTT bridge port.')\n    return parser.parse_args()"
            },
            {
                "name": "upload_file",
                "code": "def upload_file(path, bucket_name):\n    storage_client = storage.Client()\n    pprint(bucket_name)\n    bucket = storage_client.get_bucket(bucket_name)\n    blob = bucket.blob('image/')\n    blob.upload_from_filename(path)\n    return blob.public_url"
            }
        ],
        "third_party": [
            "payload.decode",
            "payload.decode",
            "unused_client.publish"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "khadkarajesh/Pi-Image-Capturer",
        "function_declaration": "def parse_command_line_args()",
        "start_line": "17",
        "end_line": "28",
        "file_path": "device_2/subscriber.py",
        "docstring": "The function \"parse_command_line_args\" parses command line arguments for a Google Cloud IoT MQTT device connection.\\nIt requires the project ID and subscription name, with the project ID defaulting to the value of the \"GOOGLE_CLOUD_PROJECT\" environment variable if not provided.\\nIt returns the parsed arguments.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8a50b742d703",
        "ground_truth": "def parse_command_line_args():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(\n        description='Example Google Cloud IoT MQTT device connection code.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--subscription_name', required=True, help='Cloud IoT Topic name')\n    return parser.parse_args()",
        "import_statements": [
            "import argparse",
            "import time",
            "import json",
            "from google.cloud import pubsub_v1",
            "import os"
        ],
        "reference_api": [
            "get",
            "parser.add_argument",
            "argparse.ArgumentParser",
            "parser.parse_args"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "get"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "khadkarajesh/Pi-Image-Capturer",
        "function_declaration": "def get_client(service_account_json)",
        "start_line": "15",
        "end_line": "34",
        "file_path": "server/server.py",
        "docstring": "The function \"get_client\" creates and returns a client for the Google Cloud IoT Core service.\\nIt takes a path to a service account JSON file as input and defines the necessary API scopes, version, and discovery URL.\\nIt then loads the service account credentials, scopes them appropriately, and uses them to build and return the client for the Cloud IoT Core service using the discovery API URL.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f1fedfdf8267",
        "ground_truth": "def get_client(service_account_json):\n    \"\"\"Returns an authorized API client by discovering the IoT API and creating\n    a service object using the service account credentials JSON.\"\"\"\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_name = 'cloudiotcore'\n     credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n     discovery_url = '{}?version={}'.format(\n        discovery_api, api_version)\n     return discovery.build(\n        service_name,\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials)",
        "import_statements": [
            "import argparse",
            "import base64",
            "import io",
            "import os",
            "import sys",
            "import time",
            "from google.cloud import pubsub",
            "from google.oauth2 import service_account",
            "from googleapiclient import discovery",
            "from googleapiclient.errors import HttpError"
        ],
        "reference_api": [
            "credentials.with_scopes",
            "discovery.build",
            "from_service_account_file",
            "format"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "from_service_account_file",
            "credentials.with_scopes",
            "discovery.build"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "lemariva/uPyIoT",
        "function_declaration": "def sign_hash(hash_value, priv_key, hash_method)",
        "start_line": "250",
        "end_line": "281",
        "file_path": "third_party/rsa/pkcs1.py",
        "docstring": "The function \"sign_hash\" signs a given hash value using a specified private key and hash method.\\nIt first retrieves the ASN1 code for the hash method and raises an error if the hash method is invalid.\\nIt then concatenates the ASN1 code with the hash value, pads the result for signing, and encrypts the padded hash using the private key.\\nThe function returns the encrypted signature as a byte block.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bfd7b4fdff6a",
        "ground_truth": "def sign_hash(hash_value, priv_key, hash_method):\n    \"\"\"Signs a precomputed hash with the private key.\n     Hashes the message, then signs the hash with the given key. This is known\n    as a \"detached signature\", because the message itself isn't altered.\n     :param hash_value: A precomputed hash to sign (ignores message). Should be set to\n        None if needing to hash and sign message.\n    :param priv_key: the :py:class:`rsa.PrivateKey` to sign with\n    :param hash_method: the hash method used on the message. Use 'MD5', 'SHA-1',\n        'SHA-224', SHA-256', 'SHA-384' or 'SHA-512'.\n    :return: a message signature block.\n    :raise OverflowError: if the private key is too small to contain the\n        requested hash.\n     \"\"\"\n     # Get the ASN1 code for this hash method\n    if hash_method not in HASH_ASN1:\n        raise ValueError('Invalid hash method: %s' % hash_method)\n    asn1code = HASH_ASN1[hash_method]\n     # Encrypt the hash with the private key\n    cleartext = asn1code + hash_value\n    keylength = common.byte_size(priv_key.n)\n    padded = _pad_for_signing(cleartext, keylength)\n     payload = transform.bytes2int(padded)\n    encrypted = priv_key.blinded_encrypt(payload)\n    block = transform.int2bytes(encrypted, keylength)\n     return block",
        "import_statements": [
            "import os",
            "from third_party.rsa._compat import range",
            "from third_party.rsa import common, transform, core"
        ],
        "reference_api": [
            "transform.bytes2int",
            "ValueError",
            "_pad_for_signing",
            "common.byte_size",
            "transform.int2bytes",
            "priv_key.blinded_encrypt"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_pad_for_signing",
                "code": "ef _pad_for_signing(message, target_length):\n    r\"\"\"Pads the message for signing, returning the padded message.\n\n    The padding is always a repetition of FF bytes.\n\n    :return: 00 01 PADDING 00 MESSAGE\n\n    >>> block = _pad_for_signing(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x01'\n    >>> block[-6:]\n    b'\\x00hello'\n    >>> block[2:-6]\n    b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\n\n    \"\"\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError('%i bytes needed for message, but there is only'\n                            ' space for %i' % (msglength, max_msglength))\n\n    padding_length = target_length - msglength - 3\n\n    return b''.join([b'\\x00\\x01',\n                     padding_length * b'\\xff',\n                     b'\\x00',\n                     message])\n"
            }
        ],
        "third_party": [
            "common.byte_size",
            "transform.bytes2int",
            "priv_key.blinded_encrypt",
            "transform.int2bytes"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "lemariva/uPyIoT",
        "function_declaration": "def verify(message, signature, pub_key)",
        "start_line": "306",
        "end_line": "338",
        "file_path": "third_party/rsa/pkcs1.py",
        "docstring": "The function \"verify\" checks the validity of a signature for a given message using a public key.\\nIt converts the signature to an integer and decrypts it to obtain the clear signature.\\nThe function then determines the hash method used, computes the hash of the message, and reconstructs the expected padded hash.\\nIf the expected padded hash does not match the clear signature, it raises a verification error.\\nIf the verification is successful, it returns the hash method name.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "70487729fb7a",
        "ground_truth": "def verify(message, signature, pub_key):\n    \"\"\"Verifies that the signature matches the message.\n     The hash method is detected automatically from the signature.\n     :param message: the signed message. Can be an 8-bit string or a file-like\n        object. If ``message`` has a ``read()`` method, it is assumed to be a\n        file-like object.\n    :param signature: the signature block, as created with :py:func:`rsa.sign`.\n    :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message.\n    :raise VerificationError: when the signature doesn't match the message.\n    :returns: the name of the used hash.\n     \"\"\"\n     keylength = common.byte_size(pub_key.n)\n    encrypted = transform.bytes2int(signature)\n    decrypted = core.decrypt_int(encrypted, pub_key.e, pub_key.n)\n    clearsig = transform.int2bytes(decrypted, keylength)\n     # Get the hash method\n    method_name = _find_method_hash(clearsig)\n    message_hash = compute_hash(message, method_name)\n     # Reconstruct the expected padded hash\n    cleartext = HASH_ASN1[method_name] + message_hash\n    expected = _pad_for_signing(cleartext, keylength)\n     # Compare with the signed one\n    if expected != clearsig:\n        raise VerificationError('Verification failed')\n     return method_name",
        "import_statements": [
            "import os",
            "from third_party.rsa._compat import range",
            "from third_party.rsa import common, transform, core"
        ],
        "reference_api": [
            "transform.bytes2int",
            "compute_hash",
            "_find_method_hash",
            "core.decrypt_int",
            "_pad_for_signing",
            "common.byte_size",
            "VerificationError",
            "transform.int2bytes"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_find_method_hash",
                "code": "ef _find_method_hash(clearsig):\n    \"\"\"Finds the hash method.\n\n    :param clearsig: full padded ASN1 and hash.\n    :return: the used hash method.\n    :raise VerificationFailed: when the hash method cannot be found\n    \"\"\"\n\n    for (hashname, asn1code) in HASH_ASN1.items():\n        if asn1code in clearsig:\n            return hashname\n\n    raise VerificationError('Verification failed')\n"
            },
            {
                "name": "compute_hash",
                "code": "ef compute_hash(message, method_name):\n    \"\"\"Returns the message digest.\n\n    :param message: the signed message. Can be an 8-bit string or a file-like\n        object. If ``message`` has a ``read()`` method, it is assumed to be a\n        file-like object.\n    :param method_name: the hash method, must be a key of\n        :py:const:`HASH_METHODS`.\n\n    \"\"\"\n\n    if method_name not in HASH_METHODS:\n        raise ValueError('Invalid hash method: %s' % method_name)\n\n    method = HASH_METHODS[method_name]\n    hasher = method()\n\n    if hasattr(message, 'read') and hasattr(message.read, '__call__'):\n        # read as 1K blocks\n        for block in yield_fixedblocks(message, 1024):\n            hasher.update(block)\n    else:\n        # hash the message object itself.\n        hasher.update(message)\n\n    return hasher.digest()\n"
            },
            {
                "name": "_pad_for_signing",
                "code": "ef _pad_for_signing(message, target_length):\n    r\"\"\"Pads the message for signing, returning the padded message.\n\n    The padding is always a repetition of FF bytes.\n\n    :return: 00 01 PADDING 00 MESSAGE\n\n    >>> block = _pad_for_signing(b'hello', 16)\n    >>> len(block)\n    16\n    >>> block[0:2]\n    b'\\x00\\x01'\n    >>> block[-6:]\n    b'\\x00hello'\n    >>> block[2:-6]\n    b'\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\n\n    \"\"\"\n\n    max_msglength = target_length - 11\n    msglength = len(message)\n\n    if msglength > max_msglength:\n        raise OverflowError('%i bytes needed for message, but there is only'\n                            ' space for %i' % (msglength, max_msglength))\n\n    padding_length = target_length - msglength - 3\n\n    return b''.join([b'\\x00\\x01',\n                     padding_length * b'\\xff',\n                     b'\\x00',\n                     message])\n"
            }
        ],
        "third_party": [
            "common.byte_size",
            "transform.bytes2int",
            "core.decrypt_int",
            "transform.int2bytes",
            "VerificationError"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "static void connectMQTT()",
        "start_line": "135",
        "end_line": "149",
        "file_path": "mcc_generated_files/cloud/cloud_service.c",
        "docstring": "The function \"connectMQTT\" establishes an MQTT connection.\\nIt first retrieves the current time and, if the time is valid, updates the JWT using the current UNIX time format.\\nIt then calls the function to connect to the MQTT client and sets a flag to send an MQTT SUBSCRIBE packet after the connection is established.\\nFinally, it prints a debug message indicating the MQTT connection attempt.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e64d5c267dd4",
        "ground_truth": "static void connectMQTT()\n{\n   uint32_t currentTime = time(NULL);\n       if (currentTime > 0)\n   {\n      // The JWT takes time in UNIX format (seconds since 1970), AVR-LIBC uses seconds from 2000 ...\n      updateJWT(currentTime + UNIX_OFFSET);\t  \n   MQTT_CLIENT_connect();\n   }      \n   debug_print(\"CLOUD: MQTT Connect\");\n       // MQTT SUBSCRIBE packet will be sent after the MQTT connection is established.\n   sendSubscribe = true;\n}",
        "import_statements": [
            "#include <stdlib.h>\n",
            "#include <stdio.h>\n",
            "#include <string.h>\n",
            "#include <time.h>\n",
            "#include \"../clock.h\"\n",
            "#include \"cloud_service.h\"\n",
            "#include \"bsd_adapter/bsdWINC.h\"\n",
            "#include \"../winc/driver/include/m2m_wifi.h\"\n",
            "#include \"../winc/socket/include/socket.h\"\n",
            "#include \"../config/IoT_Sensor_Node_config.h\"\n",
            "#include \"crypto_client/crypto_client.h\"\n",
            "#include \"crypto_client/cryptoauthlib_main.h\"\n",
            "#include \"../debug_print.h\"\n",
            "#include \"../drivers/timeout.h\"\n",
            "#include \"mqtt_packetPopulation/mqtt_packetPopulate.h\"\n",
            "#include \"../mqtt/mqtt_core/mqtt_core.h\"\n",
            "#include \"wifi_service.h",
            "#include \"../application_manager.h\"\n",
            "#include \"../credentials_storage/credentials_storage.h\"\n",
            "#include \"../mqtt/mqtt_packetTransfer_interface.h\"\n"
        ],
        "reference_api": [
            "updateJWT",
            "debug_print",
            "time",
            "MQTT_CLIENT_connect"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "updateJWT",
                "code": "static void updateJWT(uint32_t epoch)\n{\n   char ateccsn[20];\n   CRYPTO_CLIENT_printSerialNumber(ateccsn);\n   sprintf(deviceId, \"d%s\", ateccsn);\n\n   sprintf(cid, \"projects/%s/locations/%s/registries/%s/devices/%s\", projectId, projectRegion, registryId, deviceId);\n   sprintf(mqttTopic, \"/devices/%s/events\", deviceId);\n   \n   debug_printInfo(\"MQTT: cid=%s\", cid);\n   debug_printInfo(\"MQTT: mqttTopic=%s\", mqttTopic);\n   uint8_t res = CRYPTO_CLIENT_createJWT((char*)mqttPassword, PASSWORD_SPACE, epoch, projectId);\n\n   time_t t = epoch - UNIX_OFFSET;\n   debug_printInfo(\"JWT: Result(%d) at %s\", res==0? 1 : -1, ctime(&t));\n}"
            }
        ],
        "third_party": [
            "debug_print",
            "MQTT_CLIENT_connect"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)",
        "start_line": "188",
        "end_line": "229",
        "file_path": "mcc_generated_files/cryptoauthlib/lib/atcacert/atcacert_date.c",
        "docstring": "The function \"str_to_uint\" converts a string of digits into an unsigned integer.\\nIt takes a string pointer, the width of the string, and a pointer to store the resulting number.\\nIt checks each character to ensure it is a digit and calculates the numeric value.\\nIf the string contains non-digit characters or represents a number too large to handle, it returns the original string pointer as an error indicator.\\nIf successful, it returns a pointer to the position just past the processed digits.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "999f49cc1296",
        "ground_truth": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\n{\n    const uint8_t* error_ret = str;\n    const uint8_t* good_ret = str + width;\n    uint32_t prev_num = 0;\n    uint32_t digit_value = 1;\n    int digit;\n     str += width - 1;\n    *num = 0;\n    for (digit = 0; digit < width; digit++)\n    {\n        if (*str < '0' || *str > '9')\n        {\n            return error_ret;  // Character is not a digit\n        }\n        if (digit >= 10)\n        {\n            if (*str != '0')\n            {\n                return error_ret;  // Number is larger than the output can handle\n            }\n            continue;\n        }\n        if (digit == 9 && *str > '4')\n        {\n            return error_ret;  // Number is larger than the output can handle\n         }\n        *num += digit_value * (*str - '0');\n        if (*num < prev_num)\n        {\n            return error_ret;  // Number rolled over, it is larger than the output can handle\n         }\n        digit_value *= 10;\n        prev_num = *num;\n        str--;\n    }\n     return good_ret;\n}",
        "import_statements": [
            "#include <string.h>\n",
            "#include \"atcacert_date.h\"\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)",
        "start_line": "464",
        "end_line": "486",
        "file_path": "mcc_generated_files/cryptoauthlib/lib/atcacert/atcacert_def.c",
        "docstring": "The function \"atcacert_date_dec_rfc5280_utc\" decodes a date in RFC5280 UTC format into a timestamp structure.\\nIt takes a formatted date and a pointer to a timestamp structure as inputs.\\nIf the inputs are invalid, it returns an error code.\\nThe function initializes the timestamp structure, converts the year portion of the formatted date to an integer, and adjusts the year if it is less than 50 by adding 2000.\\nIf there is an error during conversion, it returns a decoding error code.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a50e95e53b3a",
        "ground_truth": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)\n{\n    int ret = 0;\n    const uint8_t* device_sn = NULL;\n     if (build_state == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n     if (build_state->is_device_sn)\n    {\n        device_sn = build_state->device_sn;\n    }\n     ret = atcacert_gen_cert_sn(build_state->cert_def, build_state->cert, *build_state->cert_size, device_sn);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n     return ret;\n}",
        "import_statements": [
            "#include \"atcacert_def.h\"\n",
            "#include \"../crypto/atca_crypto_sw_sha1.h\"\n",
            "#include \"../crypto/atca_crypto_sw_sha2.h\"\n",
            "#include \"atcacert_der.h\"\n",
            "#include \"atcacert_date.h\"\n",
            "#include <string.h>\n"
        ],
        "reference_api": [
            "atcacert_gen_cert_sn"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "atcacert_gen_cert_sn",
                "code": "int atcacert_gen_cert_sn(const atcacert_def_t* cert_def,\n                         uint8_t*              cert,\n                         size_t                cert_size,\n                         const uint8_t         device_sn[9])\n{\n    int ret = 0;\n    size_t sn_size = 0;\n    uint8_t msg[64 + 3];\n    uint8_t sn[32];\n    atcacert_tm_utc_t issue_date;\n\n    if (cert_def == NULL || cert == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (cert_def->sn_source == SNSRC_STORED || cert_def->sn_source == SNSRC_STORED_DYNAMIC || cert_def->std_cert_elements[STDCERT_CERT_SN].count == 0)\n    {\n        return ATCACERT_E_SUCCESS;  // Certificate serial number is not generated or not in the certificate\n\n    }\n    switch (cert_def->sn_source)\n    {\n    case SNSRC_DEVICE_SN:     // Cert serial number is 0x40(MSB) + 9-byte device serial number. Only applies to device certificates.\n        if (device_sn == NULL)\n        {\n            return ATCACERT_E_BAD_PARAMS;\n        }\n        sn_size = 1 + 9;\n        sn[0] = 0x40;\n        memcpy(&sn[1], device_sn, 9);\n        break;\n\n    case SNSRC_SIGNER_ID:     // Cert serial number is 0x40(MSB) + 2-byte signer ID. Only applies to signer certificates.\n        sn_size = 1 + 2;\n        sn[0] = 0x40;\n        ret = atcacert_get_signer_id(cert_def, cert, cert_size, &sn[1]);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        break;\n\n    case SNSRC_PUB_KEY_HASH_RAW:     // Cert serial number is the SHA256(Subject public key + Encoded dates)\n    case SNSRC_PUB_KEY_HASH_POS:\n    case SNSRC_PUB_KEY_HASH:\n        if (cert_def->std_cert_elements[STDCERT_CERT_SN].count > 32)\n        {\n            return ATCACERT_E_UNEXPECTED_ELEM_SIZE;\n        }\n        sn_size = cert_def->std_cert_elements[STDCERT_CERT_SN].count;\n\n        // Add public key to hash input\n        ret = atcacert_get_subj_public_key(cert_def, cert, cert_size, &msg[0]);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n\n        // Add compressed/encoded dates to hash input\n        ret = atcacert_get_issue_date(cert_def, cert, cert_size, &issue_date);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcacert_date_enc_compcert(&issue_date, cert_def->expire_years, &msg[64]);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcac_sw_sha2_256(msg, 64 + 3, sn);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n\n        if (cert_def->sn_source == SNSRC_PUB_KEY_HASH_POS || cert_def->sn_source == SNSRC_PUB_KEY_HASH)\n        {\n            sn[0] &= 0x7F;      // Ensure the SN is positive\n        }\n        if (cert_def->sn_source == SNSRC_PUB_KEY_HASH)\n        {\n            sn[0] |= 0x40;      // Ensure the SN doesn't have any trimmable bytes\n        }\n        break;\n\n    case SNSRC_DEVICE_SN_HASH_RAW:     // Cert serial number is the SHA256(Device SN + Encoded dates). Only applies to device certificates.\n    case SNSRC_DEVICE_SN_HASH_POS:\n    case SNSRC_DEVICE_SN_HASH:\n        if (device_sn == NULL)\n        {\n            return ATCACERT_E_BAD_PARAMS;\n        }\n        if (cert_def->std_cert_elements[STDCERT_CERT_SN].count > 32)\n        {\n            return ATCACERT_E_UNEXPECTED_ELEM_SIZE;\n        }\n        sn_size = cert_def->std_cert_elements[STDCERT_CERT_SN].count;\n\n        // Add device SN to the hash input\n        memcpy(&msg[0], device_sn, 9);\n\n        // Add compressed/encoded dates to hash input\n        ret = atcacert_get_issue_date(cert_def, cert, cert_size, &issue_date);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcacert_date_enc_compcert(&issue_date, cert_def->expire_years, &msg[9]);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n        ret = atcac_sw_sha2_256(msg, 9 + 3, sn);\n        if (ret != ATCACERT_E_SUCCESS)\n        {\n            return ret;\n        }\n\n        if (cert_def->sn_source == SNSRC_DEVICE_SN_HASH_POS || cert_def->sn_source == SNSRC_DEVICE_SN_HASH)\n        {\n            sn[0] &= 0x7F;      // Ensure the SN is positive\n        }\n        if (cert_def->sn_source == SNSRC_DEVICE_SN_HASH)\n        {\n            sn[0] |= 0x40;      // Ensure the SN doesn't have any trimmable bytes\n        }\n        break;\n\n    default:\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    return atcacert_set_cert_element(cert_def, &cert_def->std_cert_elements[STDCERT_CERT_SN], cert, cert_size, sn, sn_size);\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])",
        "start_line": "36",
        "end_line": "70",
        "file_path": "mcc_generated_files/cryptoauthlib/lib/atcacert/atcacert_host_hw.c",
        "docstring": "The function \"atcacert_verify_cert_hw\" verifies a certificate using hardware acceleration.\\nIt takes a certificate definition, the certificate itself, its size, and the CA public key as inputs.\\nIt first checks for null parameters and returns an error if any are found.\\nIt then retrieves the digest of the certificate's to-be-signed (TBS) portion and the certificate's signature.\\nFinally, it verifies the TBS digest against the signature using the CA public key and returns a success or verification failure code based on the result.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b8549b57b762",
        "ground_truth": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])\n{\n    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    bool is_verified = false;\n     if (cert_def == NULL || ca_public_key == NULL || cert == NULL)\n    {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n     ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n     ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS)\n    {\n        return ret;\n    }\n     ret = atcab_verify_extern(tbs_digest, signature, ca_public_key, &is_verified);\n    if (ret != ATCA_SUCCESS)\n    {\n        return ret;\n    }\n     return is_verified ? ATCACERT_E_SUCCESS : ATCACERT_E_VERIFY_FAILED;\n}",
        "import_statements": [
            "#include \"atcacert_host_hw.h\"\n",
            "#include \"../basic/atca_basic.h\"\n",
            "#include \"../crypto/atca_crypto_sw_sha2.h\"\n"
        ],
        "reference_api": [
            "atcacert_get_signature",
            "atcacert_get_tbs_digest",
            "atcab_verify_extern"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "atcacert_get_signature",
            "atcacert_get_tbs_digest",
            "atcab_verify_extern"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{",
        "start_line": "212",
        "end_line": "246",
        "file_path": "mcc_generated_files/drivers/timeout.c",
        "docstring": "The function \"atcacert_verify_cert_hw\" verifies a certificate using hardware acceleration.\\nIt takes a certificate definition, the certificate itself, its size, and the CA public key as inputs.\\nIt first checks for null parameters and returns an error if any are found.\\nIt then retrieves the digest of the certificate's to-be-signed (TBS) portion and the certificate's signature.\\nFinally, it verifies the TBS digest against the signature using the CA public key and returns a success or verification failure code based on the result.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "55aabdebc164",
        "ground_truth": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\n    bool retVal = false; \n    if (*list == NULL)\n        return retVal;\n     // Guard in case we get interrupted, we cannot safely compare/search and get interrupted\n    IEC0bits.T1IE = 0;\n     // Special case, the head is the one we are deleting\n    if (timer == *list)\n    {\n        *list = (*list)->next;       // Delete the head\n        retVal = true;\n        startTimerAtHead();        // Start the new timer at the head\n    } else \n    {   // More than one timer in the list, search the list.  \n        timerStruct_t *findTimer = *list;\n        timerStruct_t *prevTimer = NULL;\n        while(findTimer != NULL)\n        {\n            if(findTimer == timer)\n            {\n                prevTimer->next = findTimer->next;\n                retVal = true;\n                break;\n            }\n            prevTimer = findTimer;\n            findTimer = findTimer->next;\n        } \n        IEC0bits.T1IE = 1;\n    }\n     return retVal;\n}",
        "import_statements": [
            "#include <stdio.h>\n",
            "#include \"timeout.h\"\n",
            "#include \"../tmr1.h\"\n"
        ],
        "reference_api": [
            "startTimerAtHead",
            "optimize"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "startTimerAtHead",
                "code": "void startTimerAtHead(void)\n{\n    // NOTE: listHead must NOT equal NULL at this point.\n\n    IEC0bits.T1IE = 0;\n\n    if(listHead==NULL) // no timeouts left\n    {\n        stopTimeouts();\n        return;\n    }\n\n    uint32_t period = listHead->absoluteTime - absoluteTimeofLastTimeout;\n\n    // Timer is too far, insert dummy and schedule timer after the dummy\n    if (period > TMR1_Period16BitGet())\n    {\n        dummy.absoluteTime = absoluteTimeofLastTimeout + TMR1_Period16BitGet();\n        dummy.next = listHead;\n        listHead = &dummy;\n        period = TMR1_Period16BitGet();\n    }\n\n    setTimerDuration(period);\n\n    IEC0bits.T1IE = 1;\n    isRunning = true;\n}"
            }
        ],
        "third_party": [
            "optimize"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "int BSD_close(int socket)",
        "start_line": "320",
        "end_line": "352",
        "file_path": "mcc_generated_files/cloud/bsd_adapter/bsdWINC.c",
        "docstring": "The function \"BSD_close\" attempts to close a given socket and returns a status code.\\nIt first retrieves the socket information and sets its state to \"NOT_A_SOCKET\" if it exists.\\nThen, it calls the close function and checks the return value for errors.\\nIf an error occurs, it sets the appropriate error number based on the error type and returns \"BSD_ERROR\".\\nIf no error occurs, it returns \"BSD_SUCCESS\".",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4ce116b8459c",
        "ground_truth": "int BSD_close(int socket)\n{\n   wincSocketResponses_t wincCloseReturn;\n       debug_printGOOD(\"BSD: BSD_close (%d) \",socket);\n   packetReceptionHandler_t* sock = getSocketInfo(socket);\n   if (sock != NULL)\n   {\n      sock->socketState = NOT_A_SOCKET;\n   }\n        wincCloseReturn = close((SOCKET)socket);\n  if (wincCloseReturn!= WINC_SOCK_ERR_NO_ERROR)\n {\n  switch(wincCloseReturn)\n  {\n     case WINC_SOCK_ERR_INVALID_ARG:\n         bsd_setErrNo(EBADF);\n     break;\n     case WINC_SOCK_ERR_INVALID:\n         bsd_setErrNo(EIO);\n     break;\n     default:\n     break;\n  }\n  return BSD_ERROR;\n } \n else\n {\n        return BSD_SUCCESS;\n }\n}",
        "import_statements": [
            "#include <stdint.h>\n",
            "#include <stdbool.h>\n",
            "#include <string.h>\n",
            "#include <stdio.h>\n",
            "#include \"../../config/IoT_Sensor_Node_config.h\"\n",
            "#include \"bsdWINC.h\"\n",
            "#include \"../../winc/socket/include/socket.h\"\n",
            "#include \"../../debug_print.h\"\n"
        ],
        "reference_api": [
            "debug_printGOOD",
            "getSocketInfo",
            "close",
            "bsd_setErrNo"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "close",
                "code": "sint8 close(SOCKET sock)\n{\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n    M2M_INFO(\"Sock to delete <%d>\\n\", sock);\n\tif(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))\n\t{\n\t\tuint8\tu8Cmd = SOCKET_CMD_CLOSE;\n\t\ttstrCloseCmd strclose;\n\t\tstrclose.sock = sock; \n\t\tstrclose.u16SessionID\t\t= gastrSockets[sock].u16SessionID;\n\t\t\n\t\tgastrSockets[sock].bIsUsed = 0;\n\t\tgastrSockets[sock].u16SessionID =0;\n\t\t\n\t\tif(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)\n\t\t{\n\t\t\tu8Cmd = SOCKET_CMD_SSL_CLOSE;\n\t\t}\n\t\ts8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t\tm2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));\n\t}\n\treturn s8Ret;\n}"
            },
            {
                "name": "bsd_setErrNo",
                "code": "static void bsd_setErrNo (bsdErrno_t errorNumber)\n{\n\tbsdErrorNumber = errorNumber;\n}"
            }
        ],
        "third_party": [
            "debug_printGOOD",
            "getSocketInfo"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "int BSD_listen(int socket, int backlog)",
        "start_line": "490",
        "end_line": "522",
        "file_path": "mcc_generated_files/cloud/bsd_adapter/bsdWINC.c",
        "docstring": "The function \"BSD_listen\" sets a socket to listen for incoming connections with a specified backlog.\\nIt calls the \"listen\" function and checks the response for errors.\\nIf an error occurs, it sets the appropriate error number based on the response and returns \"BSD_ERROR\".\\nIf no error occurs, it returns \"BSD_SUCCESS\".",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f7f432a3cd7b",
        "ground_truth": "int BSD_listen(int socket, int backlog)\n{\n wincSocketResponses_t wincListenResponse;\n   wincListenResponse = listen ((SOCKET)socket, (uint8_t)backlog);\n   if (wincListenResponse != WINC_SOCK_ERR_NO_ERROR)\n {\n  switch(wincListenResponse)\n  {\n   case SOCK_ERR_INVALID_ARG:\n   if (socket < 0)\n   {\n    bsd_setErrNo(ENOTSOCK);\n   }\n   else\n   {\n    bsd_setErrNo(EINVAL);\n   }\n   break;\n   case SOCK_ERR_INVALID:\n    bsd_setErrNo(EIO);\n   break;\n   default:\n   break;\n  }\n  return BSD_ERROR;\n }\n else\n {\n  return BSD_SUCCESS;\n }\n}",
        "import_statements": [
            "#include <stdint.h>\n",
            "#include <stdbool.h>\n",
            "#include <string.h>\n",
            "#include <stdio.h>\n",
            "#include \"../../config/IoT_Sensor_Node_config.h\"\n",
            "#include \"bsdWINC.h\"\n",
            "#include \"../../winc/socket/include/socket.h\"\n",
            "#include \"../../debug_print.h\"\n"
        ],
        "reference_api": [
            "bsd_setErrNo",
            "listen"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "bsd_setErrNo",
                "code": "static void bsd_setErrNo (bsdErrno_t errorNumber)\n{\n\tbsdErrorNumber = errorNumber;\n}"
            },
            {
                "name": "listen",
                "code": "sint8 listen(SOCKET sock, uint8 backlog)\n{\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))\n\t{\n\t\ttstrListenCmd\t\tstrListen;\n\n\t\tstrListen.sock = sock;\n\t\tstrListen.u8BackLog = backlog;\n\t\tstrListen.u16SessionID\t\t= gastrSockets[sock].u16SessionID;\n\n\t\ts8Ret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);\n\t\tif(s8Ret != SOCK_ERR_NO_ERROR)\n\t\t{\n\t\t\ts8Ret = SOCK_ERR_INVALID;\n\t\t}\n\t}\n\treturn s8Ret;\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)",
        "start_line": "524",
        "end_line": "559",
        "file_path": "mcc_generated_files/cloud/bsd_adapter/bsdWINC.c",
        "docstring": "The function \"BSD_accept\" attempts to accept a connection on a given socket.\\nIt converts the socket address to a supported format and checks the address family.\\nIf the address family is supported, it calls the accept function to accept the connection.\\nIf the address family is not supported, it sets an error and returns an error code.\\nIf the accept function fails, it sets the appropriate error based on the socket value and returns an error code.\\nIf the accept function succeeds, it returns a success code.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e816de0747b8",
        "ground_truth": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\n{\n wincSocketResponses_t wincAcceptReturn;\n wincSupported_sockaddr winc_sockaddr;\n   winc_sockaddr.sa_family = addr->sa_family;\n memcpy((void*)winc_sockaddr.sa_data, (const void *)addr->sa_data, sizeof(winc_sockaddr.sa_data));\n   switch(winc_sockaddr.sa_family)\n {\n  case PF_INET:\n   winc_sockaddr.sa_family = AF_INET;\n   wincAcceptReturn = accept((SOCKET)socket, (struct sockaddr*)&winc_sockaddr, (uint8_t *)addrlen);\n  break;\n  default:\t\t//Address family not supported by WINC\n   bsd_setErrNo(EAFNOSUPPORT);\n   return BSD_ERROR;\t\t\n } \n   if (wincAcceptReturn != WINC_SOCK_ERR_NO_ERROR)\n {\n  if (socket < 0)\n  {\n   bsd_setErrNo(ENOTSOCK);\n  }\n  else\n  {\n   bsd_setErrNo(EINVAL);\n  }\n  return BSD_ERROR;\n }\n else\n {\n  return BSD_SUCCESS;\n    }\n}",
        "import_statements": [
            "#include <stdint.h>\n",
            "#include <stdbool.h>\n",
            "#include <string.h>\n",
            "#include <stdio.h>\n",
            "#include \"../../config/IoT_Sensor_Node_config.h\"\n",
            "#include \"bsdWINC.h\"\n",
            "#include \"../../winc/socket/include/socket.h\"\n",
            "#include \"../../debug_print.h\"\n"
        ],
        "reference_api": [
            "memcpy",
            "bsd_setErrNo",
            "accept"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "bsd_setErrNo",
                "code": "static void bsd_setErrNo (bsdErrno_t errorNumber)\n{\n\tbsdErrorNumber = errorNumber;\n}"
            },
            {
                "name": "accept",
                "code": "sint8 accept(SOCKET sock, struct sockaddr *addr, uint8 *addrlen)\n{\n\tsint8\ts8Ret = SOCK_ERR_INVALID_ARG;\n\t\n\tif(sock >= 0 && (gastrSockets[sock].bIsUsed == 1) )\n\t{\n\t\ts8Ret = SOCK_ERR_NO_ERROR;\n\t}\n\treturn s8Ret;\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "static void connectMQTT()",
        "start_line": "135",
        "end_line": "149",
        "file_path": "mcc_generated_files/cloud/cloud_service.c",
        "docstring": "The function connectMQTT initializes a connection to an MQTT broker. It first retrieves the current time in UNIX format and checks if the time is valid. If valid, it updates the JWT with the current time offset and initiates the MQTT connection. A debug message is printed to indicate the connection attempt. The function sets a flag to send an MQTT SUBSCRIBE packet once the connection is established.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "96143957b80a",
        "ground_truth": "static void connectMQTT()\n{\n   uint32_t currentTime = time(NULL);\n       if (currentTime > 0)\n   {\n      // The JWT takes time in UNIX format (seconds since 1970), AVR-LIBC uses seconds from 2000 ...\n      updateJWT(currentTime + UNIX_OFFSET);\t  \n   MQTT_CLIENT_connect();\n   }      \n   debug_print(\"CLOUD: MQTT Connect\");\n       // MQTT SUBSCRIBE packet will be sent after the MQTT connection is established.\n   sendSubscribe = true;\n}",
        "import_statements": [
            "#include <stdlib.h>\n",
            "#include <stdio.h>\n",
            "#include <string.h>\n",
            "#include <time.h>\n",
            "#include \"../clock.h\"\n",
            "#include \"cloud_service.h\"\n",
            "#include \"bsd_adapter/bsdWINC.h\"\n",
            "#include \"../winc/driver/include/m2m_wifi.h\"\n",
            "#include \"../winc/socket/include/socket.h\"\n",
            "#include \"../config/IoT_Sensor_Node_config.h\"\n",
            "#include \"crypto_client/crypto_client.h\"\n",
            "#include \"crypto_client/cryptoauthlib_main.h\"\n",
            "#include \"../debug_print.h\"\n",
            "#include \"../drivers/timeout.h\"\n",
            "#include \"mqtt_packetPopulation/mqtt_packetPopulate.h\"\n",
            "#include \"../mqtt/mqtt_core/mqtt_core.h\"\n",
            "#include \"wifi_service.h",
            "#include \"../application_manager.h\"\n",
            "#include \"../credentials_storage/credentials_storage.h\"\n",
            "#include \"../mqtt/mqtt_packetTransfer_interface.h\"\n"
        ],
        "reference_api": [
            "updateJWT",
            "debug_print",
            "time",
            "MQTT_CLIENT_connect"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "updateJWT",
                "code": "static void updateJWT(uint32_t epoch)\n{\n   char ateccsn[20];\n   CRYPTO_CLIENT_printSerialNumber(ateccsn);\n   sprintf(deviceId, \"d%s\", ateccsn);\n\n   sprintf(cid, \"projects/%s/locations/%s/registries/%s/devices/%s\", projectId, projectRegion, registryId, deviceId);\n   sprintf(mqttTopic, \"/devices/%s/events\", deviceId);\n   \n   debug_printInfo(\"MQTT: cid=%s\", cid);\n   debug_printInfo(\"MQTT: mqttTopic=%s\", mqttTopic);\n   uint8_t res = CRYPTO_CLIENT_createJWT((char*)mqttPassword, PASSWORD_SPACE, epoch, projectId);\n\n   time_t t = epoch - UNIX_OFFSET;\n   debug_printInfo(\"JWT: Result(%d) at %s\", res==0? 1 : -1, ctime(&t));\n}"
            }
        ],
        "third_party": [
            "debug_print",
            "MQTT_CLIENT_connect"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "void CLOUD_disconnect(void)",
        "start_line": "181",
        "end_line": "187",
        "file_path": "mcc_generated_files/cloud/cloud_service.c",
        "docstring": "The function \"CLOUD_disconnect\" disconnects from the cloud service.\\nIt logs a debug message indicating the disconnection.\\nIf the MQTT connection state is \"CONNECTED\", it retrieves the client connection information and disconnects the MQTT client.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0819d0a91a22",
        "ground_truth": "void CLOUD_disconnect(void){\n    debug_printError(\"CLOUD: Disconnect\");\n    if (MQTT_GetConnectionState() == CONNECTED)\n    {\n        MQTT_Disconnect(MQTT_GetClientConnectionInfo());\n    }\n}",
        "import_statements": [
            "#include <stdlib.h>\n",
            "#include <stdio.h>\n",
            "#include <string.h>\n",
            "#include <time.h>\n",
            "#include \"../clock.h\"\n",
            "#include \"cloud_service.h\"\n",
            "#include \"bsd_adapter/bsdWINC.h\"\n",
            "#include \"../winc/driver/include/m2m_wifi.h\"\n",
            "#include \"../winc/socket/include/socket.h\"\n",
            "#include \"../config/IoT_Sensor_Node_config.h\"\n",
            "#include \"crypto_client/crypto_client.h\"\n",
            "#include \"crypto_client/cryptoauthlib_main.h\"\n",
            "#include \"../debug_print.h\"\n",
            "#include \"../drivers/timeout.h\"\n",
            "#include \"mqtt_packetPopulation/mqtt_packetPopulate.h\"\n",
            "#include \"../mqtt/mqtt_core/mqtt_core.h\"\n",
            "#include \"wifi_service.h",
            "#include \"../application_manager.h\"\n",
            "#include \"../credentials_storage/credentials_storage.h\"\n",
            "#include \"../mqtt/mqtt_packetTransfer_interface.h\"\n"
        ],
        "reference_api": [
            "MQTT_Disconnect",
            "MQTT_GetConnectionState",
            "MQTT_GetClientConnectionInfo",
            "debug_printError"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "MQTT_Disconnect",
                "code": "mqttCurrentState MQTT_Disconnect(mqttContext* connectionInfo) {\n   if ((mqttState == CONNECTED) || (mqttState == WAITFORCONNACK)) {\n      timeout_delete(&pingreqTimer);\n\n      mqttSendDisconnect(connectionInfo);\n      mqttState = DISCONNECTED;\n   }\n\n   return mqttState;\n\n}"
            },
            {
                "name": "MQTT_GetConnectionState",
                "code": "mqttCurrentState MQTT_GetConnectionState(void) {\n   return mqttState;\n}"
            }
        ],
        "third_party": [
            "MQTT_GetClientConnectionInfo",
            "debug_printError"
        ]
    },
    {
        "subclass": "google_iot_core",
        "owner/repo": "luciodj/PIC-IOT_AirQuality.X",
        "function_declaration": "bool wifi_connectToAp(uint8_t passed_wifi_creds)",
        "start_line": "102",
        "end_line": "123",
        "file_path": "mcc_generated_files/cloud/wifi_service.c",
        "docstring": "The function \"wifi_connectToAp\" attempts to connect to a Wi-Fi access point using either new credentials or default credentials.\\nIf new credentials are provided, it connects using the specified SSID, authentication type, and password.\\nIf not, it attempts to connect using the default Wi-Fi settings.\\nIf the connection fails, it logs an error message, updates the networking error status, and returns false.\\nIf the connection succeeds, it returns true.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c4cebfea2663",
        "ground_truth": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\n{\n int8_t e = 0;\n   if(passed_wifi_creds == NEW_CREDENTIALS)\n {\n  e=m2m_wifi_connect((char *)ssid, sizeof(ssid), atoi((char*)authType), (char *)pass, M2M_WIFI_CH_ALL);\n }\n else\n {\n  e=m2m_wifi_default_connect();\n }\n    if(M2M_SUCCESS != e)\n {\n   debug_printError(\"WIFI: wifi error = %d\",e);\n   shared_networking_params.haveERROR = 1;\n   return false;\n }\n   return true;\n}",
        "import_statements": [
            "#include <stdio.h>\n",
            "#include <time.h>\n",
            "#include <string.h>\n",
            "#include <stdlib.h>\n",
            "#include \"../clock.h\"\n",
            "#include <libpic30.h>\n",
            "#include \"wifi_service.h\"\n",
            "#include \"../winc/driver/include/m2m_wifi.h\"\n",
            "#include \"../drivers/timeout.h\"\n",
            "#include \"../application_manager.h\"\n",
            "#include \"../debug_print.h\"\n",
            "#include \"../config/IoT_Sensor_Node_config.h\"\n",
            "#include \"../config/conf_winc.h\"\n",
            "#include \"../config/mqtt_config.h\"\n",
            "#include \"../winc/socket/include/socket.h\"\n",
            "#include \"../credentials_storage/credentials_storage.h\"\n",
            "#include \"../tmr2.h\"\n",
            "#include \"../led.h\"\n"
        ],
        "reference_api": [
            "m2m_wifi_connect",
            "m2m_wifi_default_connect",
            "debug_printError",
            "atoi"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "m2m_wifi_connect",
                "code": "sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)\n{\n\treturn m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);\n}"
            },
            {
                "name": "m2m_wifi_default_connect",
                "code": "sint8 m2m_wifi_default_connect(void)\n{\n\treturn hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DEFAULT_CONNECT, NULL, 0,NULL, 0,0);\n}"
            }
        ],
        "third_party": [
            "debug_printError"
        ]
    },
    {
        "subclass": "aws_iot_core",
        "owner/repo": "aws-samples/aws-appsync-iot-core-realtime-dashboard",
        "function_declaration": "async function DisplaySensors(map)",
        "start_line": "32",
        "end_line": "52",
        "file_path": "web/src/MapPage.jsx",
        "docstring": "The function \"DisplaySensors\" asynchronously retrieves a list of sensors and displays them on a map.\\nIt generates a client, sends a GraphQL query to fetch sensor data, and logs the API response.\\nIf the response contains data, it logs the retrieval of sensors and iterates through each sensor to create a marker.\\nEach marker is then placed on the map at the sensor's geographical coordinates.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d94ebb9143a1",
        "ground_truth": "async function DisplaySensors(map) {\n    const client = generateClient();\n    const response = await client.graphql({ query: listSensors})\n    console.log('API Response:', response)\n    if (response && response.data) {\n        console.log('sensors retrived');\n        response.data.listSensors.forEach((sensor) => {\n            var marker = CreateSensorMarker(sensor)\n            console.log(marker)\n            console.log(sensor)\n            new Marker({element: marker})\n                .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                .addTo(map);\n        })\n    }\n}",
        "import_statements": [
            "react",
            "maplibre-gl-js-amplify",
            "maplibre-gl",
            "aws-amplify/api",
            "./graphql/queries",
            "./graphql/subscriptions",
            "maplibre-gl/dist/maplibre-gl.css",
            "./MapPage.css"
        ],
        "reference_api": [
            "new Marker({element: marker})\n                        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                        .addTo",
            "console.log",
            "generateClient",
            "CreateSensorMarker",
            "client.graphql",
            "new Marker({element: marker})\n                        .setLngLat",
            "response.data.listSensors.forEach"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "new Marker({element: marker})\n                        .setLngLat([sensor.geo.longitude, sensor.geo.latitude])\n                        .addTo",
            "generateClient",
            "CreateSensorMarker",
            "client.graphql",
            "new Marker({element: marker})\n                        .setLngLat",
            "response.data.listSensors.forEach"
        ]
    },
    {
        "subclass": "aws_iot_core",
        "owner/repo": "aws-samples/aws-appsync-iot-core-realtime-dashboard",
        "function_declaration": "const CreateSensorMarker = (sensor) =>",
        "start_line": "18",
        "end_line": "29",
        "file_path": "web/src/MapPage.jsx",
        "docstring": "This function, `CreateSensorMarker`, generates an HTML div element representing a sensor marker.\\nIt sets the marker's id using the sensor's unique ID, assigns it a specific class name,\\nand styles it with a default color and border.\\nThe function returns the created marker element.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c59402c8583d",
        "ground_truth": "const CreateSensorMarker = (sensor) => {\n    var marker = document.createElement('div')\n    marker.id = 'sensor-image-' + sensor.sensorId\n    marker.className = \"sensor\"\n    let sensorColor = 'white'\n    marker.style.backgroundColor = sensorColor\n    marker.style.border = \"border: 0.1em solid \" + sensorColor + \";\"\n    return marker;\n}",
        "import_statements": [
            "react",
            "maplibre-gl-js-amplify",
            "maplibre-gl",
            "aws-amplify/api",
            "./graphql/queries",
            "./graphql/subscriptions",
            "maplibre-gl/dist/maplibre-gl.css",
            "./MapPage.css"
        ],
        "reference_api": [
            "document.createElement"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType",
        "start_line": "148",
        "end_line": "174",
        "file_path": "homeassistant/auth/mfa_modules/__init__.py",
        "docstring": "The function \"_load_mfa_module\" asynchronously loads a multi-factor authentication (MFA) module for Home Assistant.\\nIt constructs the module path and attempts to import the module, logging and raising an error if the import fails.\\nIf the module has requirements and pip installation is not skipped, it processes these requirements.\\nThe function checks if the module's requirements have already been processed to avoid redundant installations.\\nFinally, it returns the loaded module.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b11889b4f484",
        "ground_truth": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType:\n    \"\"\"Load an mfa auth module.\"\"\"\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n     try:\n        module = await async_import_module(hass, module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load mfa module %s: %s\", module_name, err)\n        raise HomeAssistantError(\n            f\"Unable to load mfa module {module_name}: {err}\"\n        ) from err\n     if hass.config.skip_pip or not hasattr(module, \"REQUIREMENTS\"):\n        return module\n     processed = hass.data.get(DATA_REQS)\n    if processed and module_name in processed:\n        return module\n     processed = hass.data[DATA_REQS] = set()\n     await requirements.async_process_requirements(\n        hass, module_path, module.REQUIREMENTS\n    )\n     processed.add(module_name)\n    return module",
        "import_statements": [
            "import logging",
            "import types",
            "from typing import Any",
            "from voluptuous.humanize import humanize_error",
            "from homeassistant import data_entry_flow, requirements",
            "from homeassistant.const import CONF_ID, CONF_NAME, CONF_TYPE",
            "from homeassistant.core import HomeAssistant",
            "from homeassistant.data_entry_flow import FlowResult",
            "from homeassistant.exceptions import HomeAssistantError",
            "from homeassistant.helpers.importlib import async_import_module",
            "from homeassistant.util.decorator import Registry",
            "from homeassistant.util.hass_dict import HassKey"
        ],
        "reference_api": [
            "async_import_module",
            "hasattr",
            "requirements.async_process_requirements",
            "set",
            "_LOGGER.error",
            "HomeAssistantError",
            "get",
            "processed.add"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "async_import_module",
                "code": "async def async_import_module(hass: HomeAssistant, name: str) -> ModuleType:\n    \"\"\"Import a module or return it from the cache.\"\"\"\n    cache = hass.data.setdefault(DATA_IMPORT_CACHE, {})\n    if module := cache.get(name):\n        return module\n\n    failure_cache = hass.data.setdefault(DATA_IMPORT_FAILURES, {})\n    if name in failure_cache:\n        raise ModuleNotFoundError(f\"{name} not found\", name=name)\n\n    import_futures = hass.data.setdefault(DATA_IMPORT_FUTURES, {})\n    if future := import_futures.get(name):\n        return await future\n\n    if name in sys.modules:\n        return _get_module(cache, name)\n\n    import_future = hass.loop.create_future()\n    import_futures[name] = import_future\n    try:\n        module = await hass.async_add_import_executor_job(_get_module, cache, name)\n        import_future.set_result(module)\n    except BaseException as ex:\n        if isinstance(ex, ModuleNotFoundError):\n            failure_cache[name] = True\n        import_future.set_exception(ex)\n        with suppress(BaseException):\n            # Set the exception retrieved flag on the future since\n            # it will never be retrieved unless there\n            # are concurrent calls\n            import_future.result()\n        raise\n    finally:\n        del import_futures[name]\n\n    return module"
            },
            {
                "name": "get",
                "code": "def get(self, entity_id: str) -> State | None:\n        \"\"\"Retrieve state of entity_id or None if not found.\n\n        Async friendly.\n        \"\"\"\n        return self._states_data.get(entity_id) or self._states_data.get(\n            entity_id.lower()\n        )"
            },
            {
                "name": "processed.add",
                "code": "def add(self, component: str) -> None:\n        \"\"\"Add a component to the store.\"\"\"\n        if \".\" not in component:\n            self._top_level_components.add(component)\n            self._all_components.add(component)\n        else:\n            platform, _, domain = component.partition(\".\")\n            if domain in BASE_PLATFORMS:\n                self._all_components.add(platform)\n        return super().add(component)"
            }
        ],
        "third_party": [
            "_LOGGER.error",
            "HomeAssistantError",
            "requirements.async_process_requirements"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any",
        "start_line": "56",
        "end_line": "67",
        "file_path": "homeassistant/auth/mfa_modules/insecure_example.py",
        "docstring": "The function \"async_setup_user\" sets up a user to use an MFA module.\\nIt extracts the PIN from the provided setup data and checks if the user already has an entry in the internal data list.\\nIf an entry exists, it updates the PIN; otherwise, it adds a new entry with the user ID and PIN to the data list.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "06cb8df1ac97",
        "ground_truth": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any:\n    \"\"\"Set up user to use mfa module.\"\"\"\n    # data shall has been validate in caller\n    pin = setup_data[\"pin\"]\n    for data in self._data:\n        if data[\"user_id\"] == user_id:\n            # already setup, override\n            data[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})",
        "import_statements": [
            "from typing import Any",
            "from homeassistant.core import HomeAssistant"
        ],
        "reference_api": [
            "append"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "append"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "async def _async_load(self) -> None",
        "start_line": "117",
        "end_line": "129",
        "file_path": "homeassistant/auth/mfa_modules/notify.py",
        "docstring": "The function \"_async_load\" asynchronously loads stored user data.\\nIt acquires an initialization lock to ensure thread safety and checks if user settings are already loaded.\\nIf not, it attempts to load data from the user store.\\nIf the data is empty, it initializes an empty dictionary for user settings.\\nIt then populates the user settings by creating \"NotifySetting\" objects for each user based on the loaded data.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f1ff44afdbcc",
        "ground_truth": "async def _async_load(self) -> None:\n    \"\"\"Load stored data.\"\"\"\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        if (data := await self._user_store.async_load()) is None:\n            data = cast(dict[str, dict[str, Any]], {STORAGE_USERS: {}})\n        self._user_settings = {\n            user_id: NotifySetting(**setting)\n            for user_id, setting in data.get(STORAGE_USERS, {}).items()\n        }",
        "import_statements": [
            "import asyncio",
            "from collections import OrderedDict",
            "import logging",
            "from typing import Any, cast",
            "import attr",
            "from homeassistant.const import CONF_EXCLUDE, CONF_INCLUDE",
            "from homeassistant.core import HomeAssistant, callback",
            "from homeassistant.data_entry_flow import FlowResult",
            "from homeassistant.exceptions import ServiceNotFound",
            "from homeassistant.helpers import config_validation as cv",
            "from homeassistant.helpers.storage import Store"
        ],
        "reference_api": [
            "NotifySetting",
            "cast",
            "data.get",
            "items",
            "async_load"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "async_load",
                "code": "async def async_load(self) -> None:\n        \"\"\"Load [homeassistant] core config.\"\"\"\n        if not (data := await self._store.async_load()):\n            return\n\n        # In 2021.9 we fixed validation to disallow a path (because that's never\n        # correct) but this data still lives in storage, so we print a warning.\n        if data.get(\"external_url\") and urlparse(data[\"external_url\"]).path not in (\n            \"\",\n            \"/\",\n        ):\n            _LOGGER.warning(\"Invalid external_url set. It's not allowed to have a path\")\n\n        if data.get(\"internal_url\") and urlparse(data[\"internal_url\"]).path not in (\n            \"\",\n            \"/\",\n        ):\n            _LOGGER.warning(\"Invalid internal_url set. It's not allowed to have a path\")\n\n        await self._async_update(\n            source=ConfigSource.STORAGE,\n            latitude=data.get(\"latitude\"),\n            longitude=data.get(\"longitude\"),\n            elevation=data.get(\"elevation\"),\n            unit_system=data.get(\"unit_system_v2\"),\n            location_name=data.get(\"location_name\"),\n            time_zone=data.get(\"time_zone\"),\n            external_url=data.get(\"external_url\", UNDEFINED),\n            internal_url=data.get(\"internal_url\", UNDEFINED),\n            currency=data.get(\"currency\"),\n            country=data.get(\"country\"),\n            language=data.get(\"language\"),\n            radius=data[\"radius\"],\n        )"
            },
            {
                "name": "data.get",
                "code": "def get(self, entity_id: str) -> State | None:\n        \"\"\"Retrieve state of entity_id or None if not found.\n\n        Async friendly.\n        \"\"\"\n        return self._states_data.get(entity_id) or self._states_data.get(\n            entity_id.lower()\n        )"
            }
        ],
        "third_party": [
            "cast",
            "NotifySetting",
            "items"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool",
        "start_line": "204",
        "end_line": "219",
        "file_path": "homeassistant/auth/mfa_modules/notify.py",
        "docstring": "The function \"async_validate\" asynchronously validates user input for a given user ID.\\nIt ensures user settings are loaded, then retrieves the notification settings for the specified user.\\nIf no settings are found for the user, it returns False.\\nOtherwise, it validates the user input by verifying the OTP using an executor job and returns True if the validation passes.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "434ec0293b96",
        "ground_truth": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool:\n    \"\"\"Return True if validation passed.\"\"\"\n    if self._user_settings is None:\n        await self._async_load()\n        assert self._user_settings is not None\n    if (notify_setting := self._user_settings.get(user_id)) is None:\n        return False\n    # user_input has been validate in caller\n    return await self.hass.async_add_executor_job(\n        _verify_otp,\n        notify_setting.secret,\n        user_input.get(INPUT_FIELD_CODE, \"\"),\n        notify_setting.counter,\n    )",
        "import_statements": [
            "import asyncio",
            "from collections import OrderedDict",
            "import logging",
            "from typing import Any, cast",
            "import attr",
            "from homeassistant.const import CONF_EXCLUDE, CONF_INCLUDE",
            "from homeassistant.core import HomeAssistant, callback",
            "from homeassistant.data_entry_flow import FlowResult",
            "from homeassistant.exceptions import ServiceNotFound",
            "from homeassistant.helpers import config_validation as cv",
            "from homeassistant.helpers.storage import Store"
        ],
        "reference_api": [
            "get",
            "async_add_executor_job",
            "user_input.get",
            "self._async_load"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get",
                "code": "def get(self, entity_id: str) -> State | None:\n        \"\"\"Retrieve state of entity_id or None if not found.\n\n        Async friendly.\n        \"\"\"\n        return self._states_data.get(entity_id) or self._states_data.get(\n            entity_id.lower()\n        )"
            },
            {
                "name": "user_input.get",
                "code": "def get(self, entity_id: str) -> State | None:\n        \"\"\"Retrieve state of entity_id or None if not found.\n\n        Async friendly.\n        \"\"\"\n        return self._states_data.get(entity_id) or self._states_data.get(\n            entity_id.lower()\n        )"
            }
        ],
        "third_party": [
            "self._async_load",
            "async_add_executor_job"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None",
        "start_line": "54",
        "end_line": "68",
        "file_path": "homeassistant/auth/permissions/entities.py",
        "docstring": "The function \"_lookup_area\" retrieves entity permissions based on the entity's area.\\nIt first fetches the entity entry using the entity ID.\\nIf the entity or its associated device is not found, it returns None.\\nNext, it retrieves the device entry and checks if it has an associated area.\\nIf the device entry or area ID is missing, it returns None.\\nFinally, it returns the permissions for the area from the provided area dictionary.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "551ba99a6968",
        "ground_truth": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None:\n    \"\"\"Look up entity permissions by area.\"\"\"\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n     if entity_entry is None or entity_entry.device_id is None:\n        return None\n     device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n     if device_entry is None or device_entry.area_id is None:\n        return None\n     return area_dict.get(device_entry.area_id)",
        "import_statements": [
            "from collections import OrderedDict",
            "from collections.abc import Callable"
        ],
        "reference_api": [
            "async_get",
            "area_dict.get"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "async_get",
            "async_get",
            "area_dict.get"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "def merge_policies(policies: list[PolicyType]) -> PolicyType",
        "start_line": "10",
        "end_line": "23",
        "file_path": "homeassistant/auth/permissions/merge.py",
        "docstring": "The function \"merge_policies\" merges multiple policy dictionaries into a single policy.\\nIt initializes a new policy dictionary and a set to track seen categories.\\nFor each policy and each category within it, if the category hasn't been seen, it adds the category to the set and merges the corresponding categories from all policies.\\nThe merged policy dictionary is cast to the appropriate type and returned.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8e394c61e20c",
        "ground_truth": "def merge_policies(policies: list[PolicyType]) -> PolicyType:\n    \"\"\"Merge policies.\"\"\"\n    new_policy: dict[str, CategoryType] = {}\n    seen: set[str] = set()\n    for policy in policies:\n        for category in policy:\n            if category in seen:\n                continue\n            seen.add(category)\n            new_policy[category] = _merge_policies(\n                [policy.get(category) for policy in policies]\n            )\n    cast(PolicyType, new_policy)\n    return new_policy",
        "import_statements": [
            "from typing import cast"
        ],
        "reference_api": [
            "_merge_policies",
            "set",
            "cast",
            "seen.add",
            "policy.get"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_merge_policies",
                "code": "def _merge_policies(sources: list[CategoryType]) -> CategoryType:\n    \"\"\"Merge a policy.\"\"\"\n    # When merging policies, the most permissive wins.\n    # This means we order it like this:\n    # True > Dict > None\n    #\n    # True: allow everything\n    # Dict: specify more granular permissions\n    # None: no opinion\n    #\n    # If there are multiple sources with a dict as policy, we recursively\n    # merge each key in the source.\n\n    policy: CategoryType = None\n    seen: set[str] = set()\n    for source in sources:\n        if source is None:\n            continue\n\n        # A source that's True will always win. Shortcut return.\n        if source is True:\n            return True\n\n        assert isinstance(source, dict)\n\n        if policy is None:\n            policy = cast(CategoryType, {})\n\n        assert isinstance(policy, dict)\n\n        for key in source:\n            if key in seen:\n                continue\n            seen.add(key)\n\n            key_sources = [src.get(key) for src in sources if isinstance(src, dict)]\n\n            policy[key] = _merge_policies(key_sources)\n\n    return policy"
            }
        ],
        "third_party": [
            "seen.add",
            "policy.get",
            "cast"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType",
        "start_line": "156",
        "end_line": "184",
        "file_path": "homeassistant/auth/providers/__init__.py",
        "docstring": "The function \"load_auth_provider_module\" asynchronously loads an authentication provider module for Home Assistant.\\nIt attempts to import the specified provider module and logs an error if the import fails, raising a \"HomeAssistantError\".\\nIf the module has no additional requirements or the requirements should be skipped, it returns the module.\\nOtherwise, it processes the module's requirements and updates the processed requirements set before returning the module.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3d78fbe0bdc3",
        "ground_truth": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType:\n    \"\"\"Load an auth provider.\"\"\"\n    try:\n        module = await async_import_module(\n            hass, f\"homeassistant.auth.providers.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load auth provider %s: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Unable to load auth provider {provider}: {err}\"\n        ) from err\n     if hass.config.skip_pip or not hasattr(module, \"REQUIREMENTS\"):\n        return module\n     if (processed := hass.data.get(DATA_REQS)) is None:\n        processed = hass.data[DATA_REQS] = set()\n    elif provider in processed:\n        return module\n     reqs = module.REQUIREMENTS\n    await requirements.async_process_requirements(\n        hass, f\"auth provider {provider}\", reqs\n    )\n     processed.add(provider)\n    return module",
        "import_statements": [
            "from collections.abc import Mapping",
            "import logging",
            "import types",
            "from typing import Any",
            "from voluptuous.humanize import humanize_error",
            "from homeassistant import data_entry_flow, requirements",
            "from homeassistant.const import CONF_ID, CONF_NAME, CONF_TYPE",
            "from homeassistant.core import HomeAssistant, callback",
            "from homeassistant.exceptions import HomeAssistantError",
            "from homeassistant.helpers.importlib import async_import_module",
            "from homeassistant.util import dt as dt_util",
            "from homeassistant.util.decorator import Registry",
            "from homeassistant.util.hass_dict import HassKey"
        ],
        "reference_api": [
            "async_import_module",
            "hasattr",
            "requirements.async_process_requirements",
            "set",
            "_LOGGER.error",
            "HomeAssistantError",
            "get",
            "processed.add"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "async_import_module",
                "code": "async def async_import_module(hass: HomeAssistant, name: str) -> ModuleType:\n    \"\"\"Import a module or return it from the cache.\"\"\"\n    cache = hass.data.setdefault(DATA_IMPORT_CACHE, {})\n    if module := cache.get(name):\n        return module\n\n    failure_cache = hass.data.setdefault(DATA_IMPORT_FAILURES, {})\n    if name in failure_cache:\n        raise ModuleNotFoundError(f\"{name} not found\", name=name)\n\n    import_futures = hass.data.setdefault(DATA_IMPORT_FUTURES, {})\n    if future := import_futures.get(name):\n        return await future\n\n    if name in sys.modules:\n        return _get_module(cache, name)\n\n    import_future = hass.loop.create_future()\n    import_futures[name] = import_future\n    try:\n        module = await hass.async_add_import_executor_job(_get_module, cache, name)\n        import_future.set_result(module)\n    except BaseException as ex:\n        if isinstance(ex, ModuleNotFoundError):\n            failure_cache[name] = True\n        import_future.set_exception(ex)\n        with suppress(BaseException):\n            # Set the exception retrieved flag on the future since\n            # it will never be retrieved unless there\n            # are concurrent calls\n            import_future.result()\n        raise\n    finally:\n        del import_futures[name]\n\n    return module"
            },
            {
                "name": "get",
                "code": "def get(self, entity_id: str) -> State | None:\n        \"\"\"Retrieve state of entity_id or None if not found.\n\n        Async friendly.\n        \"\"\"\n        return self._states_data.get(entity_id) or self._states_data.get(\n            entity_id.lower()\n        )"
            },
            {
                "name": "processed.add",
                "code": "def add(self, component: str) -> None:\n        \"\"\"Add a component to the store.\"\"\"\n        if \".\" not in component:\n            self._top_level_components.add(component)\n            self._all_components.add(component)\n        else:\n            platform, _, domain = component.partition(\".\")\n            if domain in BASE_PLATFORMS:\n                self._all_components.add(platform)\n        return super().add(component)"
            }
        ],
        "third_party": [
            "_LOGGER.error",
            "HomeAssistantError",
            "requirements.async_process_requirements"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "async def async_load(self) -> None",
        "start_line": "105",
        "end_line": "111",
        "file_path": "homeassistant/auth/providers/homeassistant.py",
        "docstring": "The function \"async_load\" asynchronously loads stored user data.\\nIt attempts to load data from the store and initializes an empty users list if no data is found.\\nIt then checks for non-normalized usernames within the loaded data and assigns the data to an internal variable.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5747687b7c1f",
        "ground_truth": "async def async_load(self) -> None:\n    \"\"\"Load stored data.\"\"\"\n    if (data := await self._store.async_load()) is None:\n        data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n    self._async_check_for_not_normalized_usernames(data)\n    self._data = data",
        "import_statements": [
            "import asyncio",
            "import base64",
            "from collections.abc import Mapping",
            "import logging",
            "from typing import Any, cast",
            "import bcrypt",
            "from homeassistant.const import CONF_ID",
            "from homeassistant.core import HomeAssistant, callback",
            "from homeassistant.exceptions import HomeAssistantError",
            "from homeassistant.helpers import issue_registry as ir",
            "from homeassistant.helpers.storage import Store"
        ],
        "reference_api": [
            "async_load",
            "cast",
            "self._async_check_for_not_normalized_usernames"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "async_load",
                "code": "async def async_load(self) -> None:\n        \"\"\"Load stored data.\"\"\"\n        if (data := await self._store.async_load()) is None:\n            data = cast(dict[str, list[dict[str, str]]], {\"users\": []})\n\n        self._async_check_for_not_normalized_usernames(data)\n        self._data = data"
            }
        ],
        "third_party": [
            "cast",
            "self._async_check_for_not_normalized_usernames"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "def validate_login(self, username: str, password: str) -> None",
        "start_line": "160",
        "end_line": "183",
        "file_path": "homeassistant/auth/providers/homeassistant.py",
        "docstring": "The function \"validate_login\" verifies a user's login credentials.\\nIt normalizes the provided username and initializes a dummy hash to prevent timing attacks.\\nIt iterates through all users to find a matching username.\\nIf no matching user is found, it performs a dummy hash check and raises an \"InvalidAuth\" exception.\\nIf a user is found, it decodes the stored password hash and uses bcrypt's timing-safe check to compare the provided password with the stored hash.\\nIf the passwords do not match, it raises an \"InvalidAuth\" exception.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2b24a182d218",
        "ground_truth": "def validate_login(self, username: str, password: str) -> None:\n    \"\"\"Validate a username and password.\n    Raises InvalidAuth if auth invalid.\n    \"\"\"\n    username = self.normalize_username(username)\n    dummy = b\"$2b$12$CiuFGszHx9eNHxPuQcwBWez4CwDTOcLTX5CbOpV6gef2nYuXkY7BO\"\n    found = None\n    # Compare all users to avoid timing attacks.\n    for user in self.users:\n        if self.normalize_username(user[\"username\"]) == username:\n            found = user\n    if found is None:\n        # check a hash to make timing the same as if user was found\n        bcrypt.checkpw(b\"foo\", dummy)\n        raise InvalidAuth\n    user_hash = base64.b64decode(found[\"password\"])\n    # bcrypt.checkpw is timing-safe\n    if not bcrypt.checkpw(password.encode(), user_hash):\n        raise InvalidAuth",
        "import_statements": [
            "import asyncio",
            "import base64",
            "from collections.abc import Mapping",
            "import logging",
            "from typing import Any, cast",
            "import bcrypt",
            "from homeassistant.const import CONF_ID",
            "from homeassistant.core import HomeAssistant, callback",
            "from homeassistant.exceptions import HomeAssistantError",
            "from homeassistant.helpers import issue_registry as ir",
            "from homeassistant.helpers.storage import Store"
        ],
        "reference_api": [
            "self.normalize_username",
            "base64.b64decode",
            "bcrypt.checkpw",
            "password.encode"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.normalize_username",
            "self.normalize_username",
            "bcrypt.checkpw",
            "bcrypt.checkpw",
            "password.encode"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "def async_remove_auth(self, username: str) -> None",
        "start_line": "208",
        "end_line": "221",
        "file_path": "homeassistant/auth/providers/homeassistant.py",
        "docstring": "The function \"async_remove_auth\" removes a user's authentication.\\nIt normalizes the provided username and searches for the user in the users list.\\nIf the user is found, it removes the user from the list.\\nIf the user is not found, it raises an \"InvalidUser\" exception with the message \"user_not_found\".",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f37f02097efa",
        "ground_truth": "def async_remove_auth(self, username: str) -> None:\n    \"\"\"Remove authentication.\"\"\"\n    username = self.normalize_username(username)\n    index = None\n    for i, user in enumerate(self.users):\n        if self.normalize_username(user[\"username\"]) == username:\n            index = i\n            break\n    if index is None:\n        raise InvalidUser(translation_key=\"user_not_found\")\n    self.users.pop(index)",
        "import_statements": [
            "import asyncio",
            "import base64",
            "from collections.abc import Mapping",
            "import logging",
            "from typing import Any, cast",
            "import bcrypt",
            "from homeassistant.const import CONF_ID",
            "from homeassistant.core import HomeAssistant, callback",
            "from homeassistant.exceptions import HomeAssistantError",
            "from homeassistant.helpers import issue_registry as ir",
            "from homeassistant.helpers.storage import Store"
        ],
        "reference_api": [
            "self.normalize_username",
            "InvalidUser",
            "pop",
            "enumerate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.normalize_username",
            "self.normalize_username",
            "InvalidUser",
            "pop"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "async def async_will_remove_credentials(self, credentials: Credentials) -> None",
        "start_line": "389",
        "end_line": "400",
        "file_path": "homeassistant/auth/providers/homeassistant.py",
        "docstring": "The function \"async_will_remove_credentials\" handles the removal of authentication data when credentials are deleted.\\nIf the data is not initialized, it initializes it first.\\nIt then attempts to remove the authentication associated with the given username and save the changes.\\nIf the user is invalid, it catches and ignores the exception.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5f7a570175ef",
        "ground_truth": "async def async_will_remove_credentials(self, credentials: Credentials) -> None:\n    \"\"\"When credentials get removed, also remove the auth.\"\"\"\n    if self.data is None:\n        await self.async_initialize()\n        assert self.data is not None\n    try:\n        self.data.async_remove_auth(credentials.data[\"username\"])\n        await self.data.async_save()\n    except InvalidUser:\n        # Can happen if somehow we didn't clean up a credential\n        pass",
        "import_statements": [
            "import asyncio",
            "import base64",
            "from collections.abc import Mapping",
            "import logging",
            "from typing import Any, cast",
            "import bcrypt",
            "from homeassistant.const import CONF_ID",
            "from homeassistant.core import HomeAssistant, callback",
            "from homeassistant.exceptions import HomeAssistantError",
            "from homeassistant.helpers import issue_registry as ir",
            "from homeassistant.helpers.storage import Store"
        ],
        "reference_api": [
            "async_remove_auth",
            "self.async_initialize",
            "async_save"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.async_initialize",
                "code": "def async_initialize(self) -> None:\n        \"\"\"Finish initializing a config object.\n\n        This must be called before the config object is used.\n        \"\"\"\n        self._store = self._ConfigStore(self.hass)"
            },
            {
                "name": "async_save",
                "code": "async def async_save(self) -> None:\n        \"\"\"Save data.\"\"\"\n        if self._data is not None:\n            await self._store.async_save(self._data)"
            }
        ],
        "third_party": [
            "async_remove_auth"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]",
        "start_line": "37",
        "end_line": "60",
        "file_path": "homeassistant/util/executor.py",
        "docstring": "The function \"join_or_interrupt_threads\" attempts to join or interrupt a set of threads.\\nIt calculates the timeout for each thread and tries to join them within the specified timeout.\\nIf a thread is no longer alive or has no identifier, it is added to the joined set.\\nIf logging is enabled, it logs threads that are still running.\\nIt then attempts to raise a SystemExit exception in any remaining threads.\\nThe function returns the set of successfully joined threads.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bf55dbe212cb",
        "ground_truth": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]:\n    \"\"\"Attempt to join or interrupt a set of threads.\"\"\"\n    joined = set()\n    timeout_per_thread = timeout / len(threads)\n     for thread in threads:\n        thread.join(timeout=timeout_per_thread)\n         if not thread.is_alive() or thread.ident is None:\n            joined.add(thread)\n            continue\n         if log:\n            _log_thread_running_at_shutdown(thread.name, thread.ident)\n         with contextlib.suppress(SystemError):\n            # SystemError at this stage is usually a race condition\n            # where the thread happens to die right before we force\n            # it to raise the exception\n            async_raise(thread.ident, SystemExit)\n     return joined",
        "import_statements": [
            "from concurrent.futures import ThreadPoolExecutor",
            "import contextlib",
            "import logging",
            "import sys",
            "from threading import Thread",
            "import time",
            "import traceback",
            "from typing import Any"
        ],
        "reference_api": [
            "thread.is_alive",
            "joined.add",
            "contextlib.suppress",
            "len",
            "set",
            "thread.join",
            "_log_thread_running_at_shutdown",
            "async_raise"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_log_thread_running_at_shutdown",
                "code": "def _log_thread_running_at_shutdown(name: str, ident: int) -> None:\n    \"\"\"Log the stack of a thread that was still running at shutdown.\"\"\"\n    frames = sys._current_frames()  # noqa: SLF001\n    stack = frames.get(ident)\n    formatted_stack = traceback.format_stack(stack)\n    _LOGGER.warning(\n        \"Thread[%s] is still running at shutdown: %s\",\n        name,\n        \"\".join(formatted_stack).strip(),\n    )"
            }
        ],
        "third_party": [
            "thread.join",
            "thread.is_alive",
            "joined.add",
            "async_raise"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "def deadlock_safe_shutdown() -> None",
        "start_line": "14",
        "end_line": "35",
        "file_path": "homeassistant/util/thread.py",
        "docstring": "The function \"deadlock_safe_shutdown\" performs a shutdown that avoids deadlocks.\\nIt identifies all non-main, non-daemon, alive threads and calculates a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\\nIt then attempts to join each thread within the calculated timeout and logs a warning if joining a thread fails.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "107e0d377449",
        "ground_truth": "def deadlock_safe_shutdown() -> None:\n    \"\"\"Shutdown that will not deadlock.\"\"\"\n    # threading._shutdown can deadlock forever\n    # see https://github.com/justengel/continuous_threading#shutdown-update\n    # for additional detail\n    remaining_threads = [\n        thread\n        for thread in threading.enumerate()\n        if thread is not threading.main_thread()\n        and not thread.daemon\n        and thread.is_alive()\n    ]\n     if not remaining_threads:\n        return\n     timeout_per_thread = THREADING_SHUTDOWN_TIMEOUT / len(remaining_threads)\n    for thread in remaining_threads:\n        try:\n            thread.join(timeout_per_thread)\n        except Exception as err:  # noqa: BLE001\n            _LOGGER.warning(\"Failed to join thread: %s\", err)",
        "import_statements": [
            "import ctypes",
            "import inspect",
            "import logging",
            "import threading",
            "from typing import Any"
        ],
        "reference_api": [
            "thread.is_alive",
            "len",
            "thread.join",
            "threading.enumerate",
            "threading.main_thread",
            "_LOGGER.warning"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "thread.is_alive",
            "thread.join",
            "_LOGGER.warning"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None",
        "start_line": "744",
        "end_line": "751",
        "file_path": "homeassistant/bootstrap.py",
        "docstring": "The function \"_async_dispatch\" dispatches a signal based on the state of remaining setups.\\nIf there are setups remaining or the previous state was not empty, it sends an internal dispatcher signal with the remaining setups.\\nIt then updates the internal flag to reflect whether there are remaining setups.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ea3b3f2eca2b",
        "ground_truth": "def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None:\n\"\"\"Dispatch the signal.\"\"\"\nif remaining_with_setup_started or not self._previous_was_empty:\n    async_dispatcher_send_internal(\n        self._hass, SIGNAL_BOOTSTRAP_INTEGRATIONS, remaining_with_setup_started",
        "import_statements": [
            "import asyncio",
            "from collections import defaultdict",
            "import contextlib",
            "from functools import partial",
            "from itertools import chain",
            "import logging",
            "from logging.handlers import RotatingFileHandler, TimedRotatingFileHandler",
            "import mimetypes",
            "from operator import contains, itemgetter",
            "import os",
            "import platform",
            "import sys",
            "import threading",
            "from time import monotonic",
            "from typing import TYPE_CHECKING, Any",
            "import cryptography.hazmat.backends.openssl.backend",
            "import yarl"
        ],
        "reference_api": [
            "async_dispatcher_send_internal"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "async_dispatcher_send_internal"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "home-assistant/core",
        "function_declaration": "def validate(integrations: dict[str, Integration], config: Config) -> None:",
        "start_line": "29",
        "end_line": "45",
        "file_path": "script/hassfest/bluetooth.py",
        "docstring": "The function \"validate\" verifies the correctness of the bluetooth.py file for Home Assistant.\\nIt generates and validates the Bluetooth content based on provided integrations and stores it in the configuration cache.\\nIf specific integrations are not being validated, it reads the current content of bluetooth.py and compares it with the generated content.\\nIf the contents differ, it adds an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a77eabd01ec1",
        "ground_truth": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    \"\"\"Validate bluetooth file.\"\"\"\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations)\n     if config.specific_integrations:\n        return\n     with open(str(bluetooth_path)) as fp:\n        current = fp.read()\n        if current != content:\n            config.add_error(\n                \"bluetooth\",\n                \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n                fixable=True,\n            )\n        return",
        "import_statements": [],
        "reference_api": [
            "config.add_error",
            "generate_and_validate",
            "fp.read",
            "str",
            "open"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "generate_and_validate",
                "code": "def generate_and_validate(integrations: dict[str, Integration]) -> str:\n    \"\"\"Validate and generate bluetooth data.\"\"\"\n    match_list = []\n\n    for domain in sorted(integrations):\n        match_types = integrations[domain].manifest.get(\"bluetooth\", [])\n\n        if not match_types:\n            continue\n\n        match_list.extend({\"domain\": domain, **entry} for entry in match_types)\n\n    return format_python_namespace(\n        {\"BLUETOOTH\": match_list},\n        annotations={\n            \"BLUETOOTH\": \"Final[list[dict[str, bool | str | int | list[int]]]]\"\n        },\n    )"
            }
        ],
        "third_party": [
            "fp.read",
            "config.add_error"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func (d *Dropbox) refreshToken() error",
        "start_line": "40",
        "end_line": "60",
        "file_path": "drivers/dropbox/util.go",
        "docstring": "The function \"refreshToken\" refreshes the access token for a Dropbox instance.\\nIt sends a POST request to the Dropbox OAuth2 token endpoint with the refresh token, app key, and app secret.\\nIf the request succeeds, it updates the access token; otherwise, it logs the response and returns an error if any issues occur.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f39bd31b6e07",
        "ground_truth": "func (d *Dropbox) refreshToken() error {\n url := \"https://api.dropbox.com/oauth2/token\"\n var resp base.TokenResp\n var e TokenError\n  res, err := base.RestyClient.R().SetResult(&resp).SetError(&e).\n  SetFormData(map[string]string{\n   \"refresh_token\": d.RefreshToken,\n   \"grant_type\":    \"refresh_token\",\n  }).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post(url)\n if err != nil {\n  return err\n }\n logger.Info(\"get refresh token\", zap.String(\"res\", res.String()))\n if e.Error != \"\" {\n  return fmt.Errorf(e.Error)\n }\n d.AccessToken = resp.AccessToken\n return nil\n }",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS/drivers/base\"\n\t\"github.com/go-resty/resty/v2\"\n\t\"go.uber.org/zap\"\n)"
        ],
        "reference_api": [
            "base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData",
            "fmt.Errorf",
            "res.String",
            "base.RestyClient.R().SetResult",
            "zap.String",
            "base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth",
            "base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader",
            "base.RestyClient.R().SetResult(&resp).SetError",
            "logger.Info",
            "base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post",
            "base.RestyClient.R"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData",
            "res.String",
            "base.RestyClient.R().SetResult",
            "zap.String",
            "base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth",
            "base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader",
            "base.RestyClient.R().SetResult(&resp).SetError",
            "logger.Info",
            "base.RestyClient.R().SetResult(&resp).SetError(&e).\n\t\tSetFormData(map[string]string{\n\t\t\t\"refresh_token\": d.RefreshToken,\n\t\t\t\"grant_type\":    \"refresh_token\",\n\t\t}).SetBasicAuth(d.Addition.AppKey, d.Addition.AppSecret).SetHeader(\"Content-Type\", \"application/x-www-form-urlencoded\").Post",
            "base.RestyClient.R"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)",
        "start_line": "71",
        "end_line": "99",
        "file_path": "drivers/google_drive/util.go",
        "docstring": "The function \"request\" sends an authenticated HTTP request to a specified Google Drive URL using a given method.\\nIt sets the authorization header with the access token and includes parameters for supporting all drives.\\nIf a callback is provided, it customizes the request; if a response structure is provided, it sets the request result.\\nThe function handles errors, including refreshing the token if a 401 error occurs, and retries the request after refreshing the token.\\nIt returns the response body or an error if the request fails.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ab2306bd1c96",
        "ground_truth": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error) {\n req := base.RestyClient.R()\n req.SetHeader(\"Authorization\", \"Bearer \"+d.AccessToken)\n req.SetQueryParam(\"includeItemsFromAllDrives\", \"true\")\n req.SetQueryParam(\"supportsAllDrives\", \"true\")\n if callback != nil {\n  callback(req)\n }\n if resp != nil {\n  req.SetResult(resp)\n }\n var e Error\n req.SetError(&e)\n res, err := req.Execute(method, url)\n if err != nil {\n  return nil, err\n }\n if e.Error.Code != 0 {\n  if e.Error.Code == 401 {\n   err = d.refreshToken()\n   if err != nil {\n    return nil, err\n   }\n   return d.request(url, method, callback, resp)\n  }\n  return nil, fmt.Errorf(\"%s: %v\", e.Error.Message, e.Error.Errors)\n }\n return res.Body(), nil\n}",
        "import_statements": [
            "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS/drivers/base\"\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils\"\n\t\"github.com/go-resty/resty/v2\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"go.uber.org/zap\"\n)"
        ],
        "reference_api": [
            "res.Body",
            "req.SetQueryParam",
            "req.SetHeader",
            "fmt.Errorf",
            "req.Execute",
            "callback",
            "d.refreshToken",
            "d.request",
            "req.SetError",
            "req.SetResult",
            "base.RestyClient.R"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "res.Body",
            "req.SetQueryParam",
            "req.SetHeader",
            "req.Execute",
            "callback",
            "d.refreshToken",
            "d.request",
            "req.SetError",
            "req.SetResult",
            "base.RestyClient.R"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error",
        "start_line": "134",
        "end_line": "157",
        "file_path": "drivers/google_drive/util.go",
        "docstring": "The function \"chunkUpload\" uploads a file to Google Drive in chunks.\\nIt calculates the chunk size and uploads each chunk sequentially until the entire file is uploaded.\\nDuring the process, it checks for context cancellation and handles HTTP requests with appropriate headers for each chunk.\\nIf an error occurs, it returns the error; otherwise, it completes the upload and returns nil.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "394e47fa9726",
        "ground_truth": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error {\n var defaultChunkSize = d.ChunkSize * 1024 * 1024\n var finish int64 = 0\n for finish < stream.GetSize() {\n  if utils.IsCanceled(ctx) {\n   return ctx.Err()\n  }\n  chunkSize := stream.GetSize() - finish\n  if chunkSize > defaultChunkSize {\n   chunkSize = defaultChunkSize\n  }\n  _, err := d.request(url, http.MethodPut, func(req *resty.Request) {\n   req.SetHeaders(map[string]string{\n    \"Content-Length\": strconv.FormatInt(chunkSize, 10),\n    \"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n   }).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext(ctx)\n  }, nil)\n  if err != nil {\n   return err\n  }\n  finish += chunkSize\n }\n return nil\n}",
        "import_statements": [
            "import (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS/drivers/base\"\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils\"\n\t\"github.com/go-resty/resty/v2\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"go.uber.org/zap\"\n)"
        ],
        "reference_api": [
            "io.LimitReader",
            "req.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody",
            "utils.IsCanceled",
            "req.SetHeaders",
            "ctx.Err",
            "req.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext",
            "stream.GetReadCloser",
            "stream.GetSize",
            "d.request",
            "fmt.Sprintf",
            "strconv.FormatInt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "req.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody",
            "utils.IsCanceled",
            "req.SetHeaders",
            "ctx.Err",
            "req.SetHeaders(map[string]string{\n\t\t\t\t\"Content-Length\": strconv.FormatInt(chunkSize, 10),\n\t\t\t\t\"Content-Range\":  fmt.Sprintf(\"bytes %d-%d/%d\", finish, finish+chunkSize-1, stream.GetSize()),\n\t\t\t}).SetBody(io.LimitReader(stream.GetReadCloser(), chunkSize)).SetContext",
            "stream.GetReadCloser",
            "stream.GetSize",
            "d.request",
            "strconv.FormatInt"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func UmountStorage(ctx echo.Context) error",
        "start_line": "72",
        "end_line": "85",
        "file_path": "route/v1/cloud.go",
        "docstring": "The function \"UmountStorage\" handles the unmounting of a storage device.\\nIt binds JSON data from the request context and retrieves the \"mount_point\" value.\\nIf the mount point is empty, it returns a client error response.\\nIt attempts to unmount the storage at the specified mount point and returns a service error response if unmounting fails.\\nIf successful, it deletes the corresponding configuration and returns a success response.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "09f7ab396d35",
        "ground_truth": "func UmountStorage(ctx echo.Context) error {\n json := make(map[string]string)\n ctx.Bind(&json)\n mountPoint := json[\"mount_point\"]\n if mountPoint == \"\" {\n  return ctx.JSON(common_err.CLIENT_ERROR, model.Result{Success: common_err.CLIENT_ERROR, Message: common_err.GetMsg(common_err.CLIENT_ERROR), Data: \"mount_point is empty\"})\n }\n err := service.MyService.Storage().UnmountStorage(mountPoint)\n if err != nil {\n  return ctx.JSON(common_err.SERVICE_ERROR, model.Result{Success: common_err.SERVICE_ERROR, Message: common_err.GetMsg(common_err.SERVICE_ERROR), Data: err.Error()})\n }\n service.MyService.Storage().DeleteConfigByName(strings.ReplaceAll(mountPoint, \"/mnt/\", \"\"))\n return ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS), Data: \"success\"})\n}",
        "import_statements": [
            "import (\n\t\"strings\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS/drivers/dropbox\"\n\t\"github.com/IceWhaleTech/CasaOS/drivers/google_drive\"\n\t\"github.com/IceWhaleTech/CasaOS/drivers/onedrive\"\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\"\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\t\"github.com/labstack/echo/v4\"\n\t\"go.uber.org/zap\"\n)"
        ],
        "reference_api": [
            "ctx.JSON",
            "ctx.Bind",
            "strings.ReplaceAll",
            "make",
            "common_err.GetMsg",
            "service.MyService.Storage().DeleteConfigByName",
            "service.MyService.Storage().UnmountStorage",
            "err.Error",
            "service.MyService.Storage"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ctx.JSON",
            "ctx.Bind",
            "make",
            "common_err.GetMsg",
            "service.MyService.Storage().DeleteConfigByName",
            "service.MyService.Storage().UnmountStorage",
            "err.Error",
            "service.MyService.Storage"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func GetLocalFile(ctx echo.Context) error",
        "start_line": "119",
        "end_line": "134",
        "file_path": "route/v1/file.go",
        "docstring": "The function \"GetLocalFile\" handles HTTP requests to retrieve a local file.\\nIt extracts the file path from the query parameters and checks if the path is provided.\\nIf the path is missing or the file does not exist, it returns a JSON response with an appropriate error message.\\nIf the file exists, it returns the file to the client.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f91b4efa4a7f",
        "ground_truth": "func GetLocalFile(ctx echo.Context) error {\n path := ctx.QueryParam(\"path\")\n if len(path) == 0 {\n  return ctx.JSON(http.StatusOK, model.Result{\n   Success: common_err.INVALID_PARAMS,\n   Message: common_err.GetMsg(common_err.INVALID_PARAMS),\n  })\n }\n if !file.Exists(path) {\n  return ctx.JSON(http.StatusOK, model.Result{\n   Success: common_err.FILE_DOES_NOT_EXIST,\n   Message: common_err.GetMsg(common_err.FILE_DOES_NOT_EXIST),\n  })\n }\n return ctx.File(path)\n}",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\turl2 \"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/robfig/cron/v3\"\n\t\"github.com/tidwall/gjson\"\n\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/file\"\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\tmodel2 \"github.com/IceWhaleTech/CasaOS/service/model\"\n\n\t\"github.com/google/uuid\"\n\t\"go.uber.org/zap\"\n\n\t\"github.com/h2non/filetype\"\n)"
        ],
        "reference_api": [
            "ctx.JSON",
            "len",
            "common_err.GetMsg",
            "ctx.QueryParam",
            "ctx.File",
            "file.Exists"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ctx.JSON",
            "len",
            "common_err.GetMsg",
            "ctx.QueryParam",
            "ctx.File",
            "file.Exists"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func PostNotifyMessage(ctx echo.Context) error",
        "start_line": "12",
        "end_line": "21",
        "file_path": "route/v1/notify.go",
        "docstring": "The function \"PostNotifyMessage\" handles HTTP POST requests to send a notification.\\nIt retrieves the \"name\" parameter from the request context and binds the request body to a message map.\\nIf binding fails, it returns a bad request error with the binding error message.\\nIf successful, it sends the notification using the \"name\" and \"message\", then returns a success response.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "129591f07d9b",
        "ground_truth": "func PostNotifyMessage(ctx echo.Context) error {\n name := ctx.Param(\"name\")\n message := make(map[string]interface{})\n if err := ctx.Bind(&message); err != nil {\n  return ctx.JSON(http.StatusBadRequest, model.Result{Success: common_err.INVALID_PARAMS, Message: err.Error()})\n }\n  service.MyService.Notify().SendNotify(name, message)\n return ctx.JSON(common_err.SUCCESS, model.Result{Success: common_err.SUCCESS, Message: common_err.GetMsg(common_err.SUCCESS)})\n}",
        "import_statements": [
            "import (\n\t\"net/http\"\n\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\"\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\t\"github.com/labstack/echo/v4\"\n)"
        ],
        "reference_api": [
            "ctx.Param",
            "ctx.JSON",
            "ctx.Bind",
            "service.MyService.Notify().SendNotify",
            "make",
            "common_err.GetMsg",
            "err.Error",
            "service.MyService.Notify"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ctx.Param",
            "ctx.JSON",
            "ctx.Bind",
            "service.MyService.Notify().SendNotify",
            "make",
            "common_err.GetMsg",
            "err.Error",
            "service.MyService.Notify"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func NotifyWS(ctx echo.Context) error",
        "start_line": "27",
        "end_line": "44",
        "file_path": "route/v1/notify_old.go",
        "docstring": "The function \"NotifyWS\" upgrades an HTTP GET request to a WebSocket connection.\\nIt adds the new WebSocket connection to a list of connections and ensures that the message sending service is running.\\nThe function then enters a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "587524e838a4",
        "ground_truth": "func NotifyWS(ctx echo.Context) error {\n // \u5347\u7ea7get\u8bf7\u6c42\u4e3awebSocket\u534f\u8bae\n ws, err := upGrader.Upgrade(ctx.Response().Writer, ctx.Request(), nil)\n if err != nil {\n  return nil\n }\n defer ws.Close()\n service.WebSocketConns = append(service.WebSocketConns, ws)\n  if !service.SocketRun {\n  service.SocketRun = true\n  service.SendMeg()\n }\n for {\n  mt, message, err := ws.ReadMessage()\n  fmt.Println(mt, message, err)\n }\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\t\"github.com/IceWhaleTech/CasaOS/types\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/labstack/echo/v4\"\n)"
        ],
        "reference_api": [
            "service.SendMeg",
            "ctx.Request",
            "append",
            "ws.Close",
            "upGrader.Upgrade",
            "ctx.Response",
            "ws.ReadMessage",
            "fmt.Println"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "service.SendMeg",
            "ctx.Request",
            "append",
            "ws.Close",
            "upGrader.Upgrade",
            "ctx.Response",
            "ws.ReadMessage"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func GetSystemHardwareInfo(ctx echo.Context) error",
        "start_line": "179",
        "end_line": "193",
        "file_path": "route/v1/system.go",
        "docstring": "The function \"GetSystemHardwareInfo\" retrieves and returns system hardware information as a JSON response.\\nIt gathers the drive model and architecture, and if CPU information is available, it returns this data with a success message.\\nIf CPU information is not available, it returns \"nil\".",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1397bcfe7eaf",
        "ground_truth": "func GetSystemHardwareInfo(ctx echo.Context) error {\n data := make(map[string]string, 1)\n data[\"drive_model\"] = service.MyService.System().GetDeviceTree()\n data[\"arch\"] = runtime.GOARCH\n  if cpu := service.MyService.System().GetCpuInfo(); len(cpu) > 0 {\n  return ctx.JSON(common_err.SUCCESS,\n   model.Result{\n    Success: common_err.SUCCESS,\n    Message: common_err.GetMsg(common_err.SUCCESS),\n    Data:    data,\n   })\n }\n return nil\n}",
        "import_statements": [
            "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unsafe\"\n\n\thttp2 \"github.com/IceWhaleTech/CasaOS-Common/utils/http\"\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/port\"\n\t\"github.com/IceWhaleTech/CasaOS/common\"\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/config\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/version\"\n\t\"github.com/IceWhaleTech/CasaOS/service\"\n\tmodel2 \"github.com/IceWhaleTech/CasaOS/service/model\"\n\t\"github.com/IceWhaleTech/CasaOS/types\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/tidwall/gjson\"\n)"
        ],
        "reference_api": [
            "service.MyService.System",
            "service.MyService.System().GetCpuInfo",
            "ctx.JSON",
            "len",
            "make",
            "common_err.GetMsg",
            "service.MyService.System().GetDeviceTree"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "service.MyService.System",
            "service.MyService.System().GetCpuInfo",
            "ctx.JSON",
            "len",
            "make",
            "common_err.GetMsg",
            "service.MyService.System().GetDeviceTree"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func (s *service) Services() (map[bool]*[]string, error)",
        "start_line": "15",
        "end_line": "37",
        "file_path": "service/health.go",
        "docstring": "The function \"Services\" retrieves a list of services matching \"casaos*\" and categorizes them based on their running status.\\nIt calls \"systemctl.ListServices\" to get the services and checks for errors.\\nIt then separates the services into running and not running lists based on their status.\\nFinally, it returns a map with boolean keys indicating the running status, each pointing to the corresponding list of service names.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "73bd9f483ea9",
        "ground_truth": "func (s *service) Services() (map[bool]*[]string, error) {\n services, err := systemctl.ListServices(\"casaos*\")\n if err != nil {\n  return nil, err\n }\n  var running, notRunning []string\n  for _, service := range services {\n  if service.Running {\n   running = append(running, service.Name)\n  } else {\n   notRunning = append(notRunning, service.Name)\n  }\n }\n  result := map[bool]*[]string{\n  true:  &running,\n  false: &notRunning,\n }\n  return result, nil\n}",
        "import_statements": [
            "import (\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/port\"\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/systemctl\"\n)"
        ],
        "reference_api": [
            "append",
            "systemctl.ListServices"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "append",
            "systemctl.ListServices"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})",
        "start_line": "55",
        "end_line": "70",
        "file_path": "service/notify.go",
        "docstring": "The function \"SendNotify\" sends a notification with a given name and message map.\\nIt serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\\nIf the response status code is not OK, it logs the failure along with the response details.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ea1dadc1c92f",
        "ground_truth": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}) {\n msg := make(map[string]string)\n for k, v := range message {\n  bt, _ := json.Marshal(v)\n  msg[k] = string(bt)\n }\n response, err := MyService.MessageBus().PublishEventWithResponse(context.Background(), common.SERVICENAME, name, msg)\n if err != nil {\n  logger.Error(\"failed to publish event to message bus\", zap.Error(err), zap.Any(\"event\", msg))\n  return\n }\n if response.StatusCode() != http.StatusOK {\n  logger.Error(\"failed to publish event to message bus\", zap.String(\"status\", response.Status()), zap.Any(\"response\", response))\n }\n // SocketServer.BroadcastToRoom(\"/\", \"public\", path, message)\n}",
        "import_statements": [
            "import (\n\t\"context\"\n\t\"encoding/json\"\n\tjson2 \"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS/common\"\n\tmodel2 \"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/model/notify\"\n\t\"github.com/IceWhaleTech/CasaOS/service/model\"\n\t\"github.com/IceWhaleTech/CasaOS/types\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sync/syncmap\"\n\n\tsocketio \"github.com/googollee/go-socket.io\"\n\t\"github.com/gorilla/websocket\"\n\t\"gorm.io/gorm\"\n)"
        ],
        "reference_api": [
            "string",
            "json.Marshal",
            "response.StatusCode",
            "zap.String",
            "MyService.MessageBus().PublishEventWithResponse",
            "make",
            "logger.Error",
            "context.Background",
            "zap.Any",
            "response.Status",
            "MyService.MessageBus",
            "zap.Error"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "string",
            "response.StatusCode",
            "zap.String",
            "MyService.MessageBus().PublishEventWithResponse",
            "make",
            "logger.Error",
            "context.Background",
            "zap.Any",
            "response.Status",
            "MyService.MessageBus",
            "zap.Error"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func (c *store) MessageBus() *message_bus.ClientWithResponses",
        "start_line": "129",
        "end_line": "147",
        "file_path": "service/service.go",
        "docstring": "The function \"MessageBus\" creates and returns a new message bus client with responses.\\nIt initializes the client and attempts to retrieve the message bus address using a specified runtime path.\\nIf the address is found, it sets the client's server to the retrieved address; otherwise, it sets the server to a default error message.\\nThe function then returns the initialized client.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2e85f66d0860",
        "ground_truth": "func (c *store) MessageBus() *message_bus.ClientWithResponses {\n client, _ := message_bus.NewClientWithResponses(\"\", func(c *message_bus.Client) error {\n  // error will never be returned, as we always want to return a client, even with wrong address,\n  // in order to avoid panic.\n  //\n  // If we don't avoid panic, message bus becomes a hard dependency, which is not what we want.\n   messageBusAddress, err := external.GetMessageBusAddress(config.CommonInfo.RuntimePath)\n  if err != nil {\n   c.Server = \"message bus address not found\"\n   return nil\n  }\n   c.Server = messageBusAddress\n  return nil\n })\n  return client\n}",
        "import_statements": [
            "import (\n\t\"github.com/IceWhaleTech/CasaOS-Common/external\"\n\t\"github.com/IceWhaleTech/CasaOS/codegen/message_bus\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/config\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/patrickmn/go-cache\"\n\t\"gorm.io/gorm\"\n)"
        ],
        "reference_api": [
            "external.GetMessageBusAddress",
            "message_bus.NewClientWithResponses"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "external.GetMessageBusAddress",
            "message_bus.NewClientWithResponses"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func GetIP(request *http.Request) string",
        "start_line": "31",
        "end_line": "43",
        "file_path": "service/socket.go",
        "docstring": "The function \"GetIP\" retrieves the IP address from an HTTP request.\\nIt first checks the \"x-forwarded-for\" header and extracts the first IP if present.\\nIf the header is not available, it uses the request's remote address.\\nIt converts the loopback addresses \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\" before returning the IP address.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b5b9e246990a",
        "ground_truth": "func GetIP(request *http.Request) string {\n ip := \"\"\n if len(request.Header.Get(\"x-forwarded-for\")) > 0 {\n  ip = strings.Split(request.Header.Get(\"x-forwarded-for\"), \",\")[0]\n } else {\n  ip = request.RemoteAddr\n }\n  if ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n  ip = \"127.0.0.1\"\n }\n return ip\n}",
        "import_statements": [
            "import (\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\tmodel2 \"github.com/IceWhaleTech/CasaOS/service/model\"\n\t\"github.com/mileusna/useragent\"\n)"
        ],
        "reference_api": [
            "strings.Split",
            "len",
            "request.Header.Get"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "len",
            "request.Header.Get"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func (c *systemService) GenreateSystemEntry()",
        "start_line": "123",
        "end_line": "150",
        "file_path": "service/system.go",
        "docstring": "The function \"GenreateSystemEntry\" generates a consolidated system entry JSON file.\\nIt defines paths for the modules directory and the entry file, ensuring the entry file exists.\\nIt reads each module directory for entry.json files, concatenates their content into a single JSON array, and writes this array to the entry file path.\\nErrors encountered during directory reading, file reading, or file writing are logged accordingly.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "095b4e6024be",
        "ground_truth": "func (c *systemService) GenreateSystemEntry() {\n modelsPath := \"/var/lib/casaos/www/modules\"\n entryFileName := \"entry.json\"\n entryFilePath := filepath.Join(config.AppInfo.DBPath, \"db\", entryFileName)\n file.IsNotExistCreateFile(entryFilePath)\n  dir, err := os.ReadDir(modelsPath)\n if err != nil {\n  logger.Error(\"read dir error\", zap.Error(err))\n  return\n }\n json := \"[\"\n for _, v := range dir {\n  data, err := os.ReadFile(filepath.Join(modelsPath, v.Name(), entryFileName))\n  if err != nil {\n   logger.Error(\"read entry file error\", zap.Error(err))\n   continue\n  }\n  json += string(data) + \",\"\n }\n json = strings.TrimRight(json, \",\")\n json += \"]\"\n err = os.WriteFile(entryFilePath, []byte(json), 0o666)\n if err != nil {\n  logger.Error(\"write entry file error\", zap.Error(err))\n  return\n }",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\tnet2 \"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/command\"\n\texec2 \"github.com/IceWhaleTech/CasaOS-Common/utils/exec\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/file\"\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS/common\"\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/config\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\"\n\t\"github.com/tidwall/gjson\"\n\t\"go.uber.org/zap\"\n\n\t\"github.com/shirou/gopsutil/v3/cpu\"\n\t\"github.com/shirou/gopsutil/v3/disk\"\n\t\"github.com/shirou/gopsutil/v3/host\"\n\t\"github.com/shirou/gopsutil/v3/mem\"\n\t\"github.com/shirou/gopsutil/v3/net\"\n)"
        ],
        "reference_api": [
            "string",
            "strings.TrimRight",
            "logger.Error",
            "os.ReadFile",
            "file.IsNotExistCreateFile",
            "filepath.Join",
            "v.Name",
            "os.WriteFile",
            "os.ReadDir",
            "zap.Error"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "string",
            "logger.Error",
            "file.IsNotExistCreateFile",
            "v.Name",
            "os.ReadDir",
            "zap.Error"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "IceWhaleTech/CasaOS",
        "function_declaration": "func (c *systemService) GetMacAddress() (string, error) ",
        "start_line": "176",
        "end_line": "191",
        "file_path": "service/system.go",
        "docstring": "The function \"GetMacAddress\" retrieves the MAC address of a network interface.\\nIt first gets a list of network interfaces and checks for errors.\\nThen, it retrieves a list of network names from the system service.\\nIt iterates over the interfaces and network names, returning the MAC address of the first matching interface.\\nIf no matching interface is found, it returns an error.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d2b7079478d1",
        "ground_truth": "func (c *systemService) GetMacAddress() (string, error) {\n interfaces, err := net.Interfaces()\n if err != nil {\n  return \"\", err\n }\n nets := MyService.System().GetNet(true)\n for _, v := range interfaces {\n  for _, n := range nets {\n   if v.Name == n {\n    return v.HardwareAddr, nil\n   }\n  }\n }",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\tnet2 \"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/command\"\n\texec2 \"github.com/IceWhaleTech/CasaOS-Common/utils/exec\"\n\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/file\"\n\t\"github.com/IceWhaleTech/CasaOS-Common/utils/logger\"\n\t\"github.com/IceWhaleTech/CasaOS/common\"\n\t\"github.com/IceWhaleTech/CasaOS/model\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/config\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/common_err\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/httper\"\n\t\"github.com/IceWhaleTech/CasaOS/pkg/utils/ip_helper\"\n\t\"github.com/tidwall/gjson\"\n\t\"go.uber.org/zap\"\n\n\t\"github.com/shirou/gopsutil/v3/cpu\"\n\t\"github.com/shirou/gopsutil/v3/disk\"\n\t\"github.com/shirou/gopsutil/v3/host\"\n\t\"github.com/shirou/gopsutil/v3/mem\"\n\t\"github.com/shirou/gopsutil/v3/net\"\n)"
        ],
        "reference_api": [
            "errors.New",
            "MyService.System().GetNet",
            "net.Interfaces",
            "MyService.System"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "MyService.System().GetNet",
            "net.Interfaces",
            "MyService.System"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "taosdata/TDengine",
        "function_declaration": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)",
        "start_line": "58",
        "end_line": "75",
        "file_path": "source/client/src/clientEnv.c",
        "docstring": "The function \"registerRequest\" registers a new request object.\\nIt first adds a reference to the request object and increments the request count for the associated TSC object.\\nIf the TSC object has application information, it updates the application's request summary, including total and current request counts.\\nIt logs debug information about the new request and returns a success code.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9333855fecb1",
        "ground_truth": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj) {\n  // connection has been released already, abort creating request.\n  pRequest->self = taosAddRef(clientReqRefPool, pRequest);\n   int32_t num = atomic_add_fetch_32(&pTscObj->numOfReqs, 1);\n   if (pTscObj->pAppInfo) {\n    SAppClusterSummary *pSummary = &pTscObj->pAppInfo->summary;\n     int32_t total = atomic_add_fetch_64((int64_t *)&pSummary->totalRequests, 1);\n    int32_t currentInst = atomic_add_fetch_64((int64_t *)&pSummary->currentRequests, 1);\n    tscDebug(\"0x%\" PRIx64 \" new Request from connObj:0x%\" PRIx64\n             \", current:%d, app current:%d, total:%d, reqId:0x%\" PRIx64,\n             pRequest->self, pRequest->pTscObj->id, num, currentInst, total, pRequest->requestId);\n  }\n   return TSDB_CODE_SUCCESS;\n}",
        "import_statements": [
            "#include <ttimer.h>\n",
            "#include \"cJSON.h\"\n",
            "#include \"catalog.h\"\n",
            "#include \"clientInt.h\"\n",
            "#include \"clientLog.h\"\n",
            "#include \"clientMonitor.h\"\n",
            "#include \"functionMgt.h\"\n",
            "#include \"os.h\"\n",
            "#include \"osSleep.h\"\n",
            "#include \"query.h\"\n",
            "#include \"qworker.h\"\n",
            "#include \"scheduler.h\"\n",
            "#include \"tcache.h\"\n",
            "#include \"tglobal.h\"\n",
            "#include \"thttp.h\"\n",
            "#include \"tmsg.h\"\n",
            "#include \"tqueue.h\"\n",
            "#include \"tref.h\"\n",
            "#include \"trpc.h\"\n",
            "#include \"tsched.h\"\n",
            "#include \"ttime.h\"\n",
            "#include \"tversion.h\"\n"
        ],
        "reference_api": [
            "atomic_add_fetch_64",
            "taosAddRef",
            "tscDebug",
            "atomic_add_fetch_32"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "atomic_add_fetch_64",
            "taosAddRef",
            "tscDebug",
            "atomic_add_fetch_32"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "taosdata/TDengine",
        "function_declaration": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)",
        "start_line": "171",
        "end_line": "187",
        "file_path": "source/client/src/clientEnv.c",
        "docstring": "The function \"checkSlowLogExceptDb\" checks if a given request is associated with a database that is not the specified exception database.\\nIt first compares the primary database of the request with the exception database.\\nIf they are not the same, it iterates through a list of databases in the request, ignoring any schema prefixes, and checks each against the exception database.\\nThe function returns true if none of the databases match the exception; otherwise, it returns false.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3120013c53c3",
        "ground_truth": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb) {\n  if (pRequest->pDb != NULL) {\n    return strcmp(pRequest->pDb, exceptDb) != 0;\n  }\n   for (int i = 0; i < taosArrayGetSize(pRequest->dbList); i++) {\n    char *db = taosArrayGet(pRequest->dbList, i);\n    char *dot = strchr(db, '.');\n    if (dot != NULL) {\n      db = dot + 1;\n    }\n    if(strcmp(db, exceptDb) == 0){\n      return false;\n    }\n  }\n  return true;\n}",
        "import_statements": [
            "#include <ttimer.h>\n",
            "#include \"cJSON.h\"\n",
            "#include \"catalog.h\"\n",
            "#include \"clientInt.h\"\n",
            "#include \"clientLog.h\"\n",
            "#include \"clientMonitor.h\"\n",
            "#include \"functionMgt.h\"\n",
            "#include \"os.h\"\n",
            "#include \"osSleep.h\"\n",
            "#include \"query.h\"\n",
            "#include \"qworker.h\"\n",
            "#include \"scheduler.h\"\n",
            "#include \"tcache.h\"\n",
            "#include \"tglobal.h\"\n",
            "#include \"thttp.h\"\n",
            "#include \"tmsg.h\"\n",
            "#include \"tqueue.h\"\n",
            "#include \"tref.h\"\n",
            "#include \"trpc.h\"\n",
            "#include \"tsched.h\"\n",
            "#include \"ttime.h\"\n",
            "#include \"tversion.h\"\n"
        ],
        "reference_api": [
            "strcmp",
            "taosArrayGet",
            "taosArrayGetSize",
            "strchr"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "taosArrayGet",
            "taosArrayGetSize"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "taosdata/TDengine",
        "function_declaration": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)",
        "start_line": "269",
        "end_line": "280",
        "file_path": "source/client/src/clientEnv.c",
        "docstring": "The function \"clientRpcRfp\" determines if a client RPC request needs to be redirected based on an error code and message type.\\nIf the error code indicates a need for redirection and the message type is not one of several specific types, it returns true indicating redirection is needed.\\nOtherwise, it returns false indicating no redirection is required.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7558fd043790",
        "ground_truth": "static bool clientRpcRfp(int32_t code, tmsg_t msgType) {\n  if (NEED_REDIRECT_ERROR(code)) {\n    if (msgType == TDMT_SCH_QUERY || msgType == TDMT_SCH_MERGE_QUERY || msgType == TDMT_SCH_FETCH ||\n        msgType == TDMT_SCH_MERGE_FETCH || msgType == TDMT_SCH_QUERY_HEARTBEAT || msgType == TDMT_SCH_DROP_TASK ||\n        msgType == TDMT_SCH_TASK_NOTIFY) {\n      return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}",
        "import_statements": [
            "#include <ttimer.h>\n",
            "#include \"cJSON.h\"\n",
            "#include \"catalog.h\"\n",
            "#include \"clientInt.h\"\n",
            "#include \"clientLog.h\"\n",
            "#include \"clientMonitor.h\"\n",
            "#include \"functionMgt.h\"\n",
            "#include \"os.h\"\n",
            "#include \"osSleep.h\"\n",
            "#include \"query.h\"\n",
            "#include \"qworker.h\"\n",
            "#include \"scheduler.h\"\n",
            "#include \"tcache.h\"\n",
            "#include \"tglobal.h\"\n",
            "#include \"thttp.h\"\n",
            "#include \"tmsg.h\"\n",
            "#include \"tqueue.h\"\n",
            "#include \"tref.h\"\n",
            "#include \"trpc.h\"\n",
            "#include \"tsched.h\"\n",
            "#include \"ttime.h\"\n",
            "#include \"tversion.h\"\n"
        ],
        "reference_api": [
            "NEED_REDIRECT_ERROR"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "NEED_REDIRECT_ERROR"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "taosdata/TDengine",
        "function_declaration": "void stopAllRequests(SHashObj *pRequests)",
        "start_line": "343",
        "end_line": "356",
        "file_path": "source/client/src/clientEnv.c",
        "docstring": "The function \"stopAllRequests\" stops all ongoing requests in a given hash table of requests.\\nIt iterates through the hash table, acquires each request by its request ID, and stops the query associated with the request if it is valid.\\nAfter stopping the query, it releases the request and continues to the next request in the hash table until all requests are processed.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1ed1f4a17f8c",
        "ground_truth": "void stopAllRequests(SHashObj *pRequests) {\n  void *pIter = taosHashIterate(pRequests, NULL);\n  while (pIter != NULL) {\n    int64_t *rid = pIter;\n     SRequestObj *pRequest = acquireRequest(*rid);\n    if (pRequest) {\n      taos_stop_query(pRequest);\n      releaseRequest(*rid);\n    }\n     pIter = taosHashIterate(pRequests, pIter);\n  }\n}",
        "import_statements": [
            "#include <ttimer.h>\n",
            "#include \"cJSON.h\"\n",
            "#include \"catalog.h\"\n",
            "#include \"clientInt.h\"\n",
            "#include \"clientLog.h\"\n",
            "#include \"clientMonitor.h\"\n",
            "#include \"functionMgt.h\"\n",
            "#include \"os.h\"\n",
            "#include \"osSleep.h\"\n",
            "#include \"query.h\"\n",
            "#include \"qworker.h\"\n",
            "#include \"scheduler.h\"\n",
            "#include \"tcache.h\"\n",
            "#include \"tglobal.h\"\n",
            "#include \"thttp.h\"\n",
            "#include \"tmsg.h\"\n",
            "#include \"tqueue.h\"\n",
            "#include \"tref.h\"\n",
            "#include \"trpc.h\"\n",
            "#include \"tsched.h\"\n",
            "#include \"ttime.h\"\n",
            "#include \"tversion.h\"\n"
        ],
        "reference_api": [
            "taosHashIterate",
            "acquireRequest",
            "releaseRequest",
            "taos_stop_query"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "releaseRequest",
                "code": "int32_t releaseRequest(int64_t rid) { return taosReleaseRef(clientReqRefPool, rid); }"
            }
        ],
        "third_party": [
            "taosHashIterate",
            "acquireRequest",
            "taos_stop_query"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "taosdata/TDengine",
        "function_declaration": "void tscStopCrashReport()",
        "start_line": "788",
        "end_line": "801",
        "file_path": "source/client/src/clientEnv.c",
        "docstring": "The function \"tscStopCrashReport\" stops the crash report thread if crash reporting is enabled.\\nIt first checks if crash reporting is enabled and exits if not.\\nIt then attempts to set the clientStop flag to 1 using an atomic compare-and-exchange operation.\\nIf the operation fails, it logs a message indicating the crash report thread is already stopped and returns.\\nIf the operation succeeds, it waits in a loop until the clientStop flag becomes 0, indicating the thread has stopped.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0dd1380011aa",
        "ground_truth": "void tscStopCrashReport() {\n  if (!tsEnableCrashReport) {\n    return;\n  }\n   if (atomic_val_compare_exchange_32(&clientStop, 0, 1)) {\n    tscDebug(\"crash report thread already stopped\");\n    return;\n  }\n   while (atomic_load_32(&clientStop) > 0) {\n    taosMsleep(100);\n  }\n}",
        "import_statements": [
            "#include <ttimer.h>\n",
            "#include \"cJSON.h\"\n",
            "#include \"catalog.h\"\n",
            "#include \"clientInt.h\"\n",
            "#include \"clientLog.h\"\n",
            "#include \"clientMonitor.h\"\n",
            "#include \"functionMgt.h\"\n",
            "#include \"os.h\"\n",
            "#include \"osSleep.h\"\n",
            "#include \"query.h\"\n",
            "#include \"qworker.h\"\n",
            "#include \"scheduler.h\"\n",
            "#include \"tcache.h\"\n",
            "#include \"tglobal.h\"\n",
            "#include \"thttp.h\"\n",
            "#include \"tmsg.h\"\n",
            "#include \"tqueue.h\"\n",
            "#include \"tref.h\"\n",
            "#include \"trpc.h\"\n",
            "#include \"tsched.h\"\n",
            "#include \"ttime.h\"\n",
            "#include \"tversion.h\"\n"
        ],
        "reference_api": [
            "atomic_load_32",
            "taosMsleep",
            "atomic_val_compare_exchange_32",
            "tscDebug"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "atomic_load_32",
            "taosMsleep",
            "atomic_val_compare_exchange_32",
            "tscDebug"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "taosdata/TDengine",
        "function_declaration": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)",
        "start_line": "322",
        "end_line": "349",
        "file_path": "source/client/src/clientHb.c",
        "docstring": "The function \"hbProcessViewInfoRsp\" processes a heartbeat response containing view information.\\nIt deserializes the response and checks for errors.\\nIf deserialization fails, it cleans up and returns an error code.\\nIt iterates through the deserialized view metadata and either updates or removes view metadata in the catalog based on the number of columns in each view.\\nFinally, it destroys the response array and returns a success code.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ede524f8cfd7",
        "ground_truth": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog) {\n  int32_t code = 0;\n   SViewHbRsp hbRsp = {0};\n  if (tDeserializeSViewHbRsp(value, valueLen, &hbRsp) != 0) {\n    taosArrayDestroyEx(hbRsp.pViewRsp, hbFreeSViewMetaInRsp);\n    terrno = TSDB_CODE_INVALID_MSG;\n    return -1;\n  }\n   int32_t numOfMeta = taosArrayGetSize(hbRsp.pViewRsp);\n  for (int32_t i = 0; i < numOfMeta; ++i) {\n    SViewMetaRsp *rsp = taosArrayGetP(hbRsp.pViewRsp, i);\n     if (rsp->numOfCols < 0) {\n      tscDebug(\"hb to remove view, db:%s, view:%s\", rsp->dbFName, rsp->name);\n      catalogRemoveViewMeta(pCatalog, rsp->dbFName, rsp->dbId, rsp->name, rsp->viewId);\n      tFreeSViewMetaRsp(rsp);\n      taosMemoryFreeClear(rsp);\n    } else {\n      tscDebug(\"hb to update view, db:%s, view:%s\", rsp->dbFName, rsp->name);\n      catalogUpdateViewMeta(pCatalog, rsp);\n    }\n  }\n   taosArrayDestroy(hbRsp.pViewRsp);\n  return TSDB_CODE_SUCCESS;\n}",
        "import_statements": [
            "#include \"catalog.h\"\n",
            "#include \"clientInt.h\"\n",
            "#include \"clientLog.h\"\n",
            "#include \"scheduler.h\"\n",
            "#include \"trpc.h\"\n",
            "#include \"tglobal.h\"\n",
            "#include \"clientMonitor.h\"\n"
        ],
        "reference_api": [
            "tDeserializeSViewHbRsp",
            "taosArrayGetSize",
            "tFreeSViewMetaRsp",
            "taosArrayGetP",
            "taosArrayDestroyEx",
            "catalogRemoveViewMeta",
            "taosMemoryFreeClear",
            "taosArrayDestroy",
            "tscDebug",
            "catalogUpdateViewMeta"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "tDeserializeSViewHbRsp",
            "taosArrayGetSize",
            "tFreeSViewMetaRsp",
            "taosArrayGetP",
            "taosArrayDestroyEx",
            "catalogRemoveViewMeta",
            "taosMemoryFreeClear",
            "taosArrayDestroy",
            "tscDebug",
            "catalogUpdateViewMeta"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "taosdata/TDengine",
        "function_declaration": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)",
        "start_line": "204",
        "end_line": "214",
        "file_path": "source/common/src/cos.c",
        "docstring": "The function \"responsePropertiesCallback\" processes S3 response properties to extract the content length.\\nIt updates the content length in the provided callback data structure if the content length from the response properties is greater than zero; otherwise, it sets the content length to zero.\\nThe function returns \"S3StatusOK\" to indicate successful processing.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f87670226f65",
        "ground_truth": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData) {\n  //(void)callbackData;\n  TS3SizeCBD *cbd = callbackData;\n  if (properties->contentLength > 0) {\n    cbd->content_length = properties->contentLength;\n  } else {\n    cbd->content_length = 0;\n  }\n   return S3StatusOK;\n}",
        "import_statements": [
            "#include \"cos.h\"\n",
            "#include \"cos_cp.h\"\n",
            "#include \"tdef.h\"\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "iot",
        "owner/repo": "taosdata/TDengine",
        "function_declaration": "void startRsync()",
        "start_line": "132",
        "end_line": "159",
        "file_path": "source/common/src/rsync.c",
        "docstring": "The function \"startRsync\" initializes and starts an Rsync server for checkpoint backups.\\nIt first attempts to create the checkpoint backup directory and logs an error if it fails.\\nIt then removes empty directories and generates an Rsync configuration file.\\nIf the configuration file generation is successful, it constructs and executes a command to start the Rsync daemon with the specified port and configuration file.\\nIt logs whether the Rsync server started successfully or if it encountered an error.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "32f7325bef8b",
        "ground_truth": "void startRsync() {\n  if (taosMulMkDir(tsCheckpointBackupDir) != 0) {\n    uError(\"[rsync] build checkpoint backup dir failed, path:%s,\" ERRNO_ERR_FORMAT, tsCheckpointBackupDir,\n           ERRNO_ERR_DATA);\n    return;\n  }\n   removeEmptyDir();\n   char confDir[PATH_MAX] = {0};\n  snprintf(confDir, PATH_MAX, \"%srsync.conf\", tsCheckpointBackupDir);\n   int32_t code = generateConfigFile(confDir);\n  if (code != 0) {\n    return;\n  }\n   char cmd[PATH_MAX] = {0};\n  snprintf(cmd, PATH_MAX, \"rsync --daemon --port=%d --config=%s\", tsRsyncPort, confDir);\n  // start rsync service to backup checkpoint\n  code = system(cmd);\n  if (code != 0) {\n    uError(\"[rsync] start server failed, code:%d,\" ERRNO_ERR_FORMAT, code, ERRNO_ERR_DATA);\n  } else {\n    uDebug(\"[rsync] start server successful\");\n  }\n }",
        "import_statements": [
            "#include \"rsync.h\"\n",
            "#include <stdlib.h>\n",
            "#include \"tglobal.h\"\n"
        ],
        "reference_api": [
            "uDebug",
            "system",
            "removeEmptyDir",
            "uError",
            "taosMulMkDir",
            "generateConfigFile",
            "snprintf"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "removeEmptyDir",
                "code": "static void removeEmptyDir() {\n  TdDirPtr pDir = taosOpenDir(tsCheckpointBackupDir);\n  if (pDir == NULL) return;\n\n  TdDirEntryPtr de = NULL;\n  while ((de = taosReadDir(pDir)) != NULL) {\n    if (!taosDirEntryIsDir(de)) {\n      continue;\n    }\n\n    if (strcmp(taosGetDirEntryName(de), \".\") == 0 || strcmp(taosGetDirEntryName(de), \"..\") == 0) continue;\n\n    char filename[PATH_MAX] = {0};\n    snprintf(filename, sizeof(filename), \"%s%s\", tsCheckpointBackupDir, taosGetDirEntryName(de));\n\n    TdDirPtr      pDirTmp = taosOpenDir(filename);\n    TdDirEntryPtr deTmp = NULL;\n    bool          empty = true;\n    while ((deTmp = taosReadDir(pDirTmp)) != NULL) {\n      if (strcmp(taosGetDirEntryName(deTmp), \".\") == 0 || strcmp(taosGetDirEntryName(deTmp), \"..\") == 0) continue;\n      empty = false;\n    }\n    if (empty) taosRemoveDir(filename);\n    taosCloseDir(&pDirTmp);\n  }\n\n  taosCloseDir(&pDir);\n}"
            },
            {
                "name": "generateConfigFile",
                "code": "static int32_t generateConfigFile(char* confDir) {\n  TdFilePtr pFile = taosOpenFile(confDir, TD_FILE_CREATE | TD_FILE_WRITE | TD_FILE_TRUNC);\n  if (pFile == NULL) {\n    uError(\"[rsync] open conf file error, dir:%s,\" ERRNO_ERR_FORMAT, confDir, ERRNO_ERR_DATA);\n    return -1;\n  }\n\n#ifdef WINDOWS\n  char path[PATH_MAX] = {0};\n  changeDirFromWindowsToLinux(tsCheckpointBackupDir, path);\n#endif\n\n  char confContent[PATH_MAX * 4] = {0};\n  snprintf(confContent, PATH_MAX * 4,\n#ifndef WINDOWS\n           \"uid = root\\n\"\n           \"gid = root\\n\"\n#endif\n           \"use chroot = false\\n\"\n           \"max connections = 200\\n\"\n           \"timeout = 100\\n\"\n           \"lock file = %srsync.lock\\n\"\n           \"log file = %srsync.log\\n\"\n           \"ignore errors = true\\n\"\n           \"read only = false\\n\"\n           \"list = false\\n\"\n           \"[checkpoint]\\n\"\n           \"path = %s\",\n           tsCheckpointBackupDir, tsCheckpointBackupDir,\n#ifdef WINDOWS\n           path\n#else\n           tsCheckpointBackupDir\n#endif\n  );\n  uDebug(\"[rsync] conf:%s\", confContent);\n  if (taosWriteFile(pFile, confContent, strlen(confContent)) <= 0) {\n    uError(\"[rsync] write conf file error,\" ERRNO_ERR_FORMAT, ERRNO_ERR_DATA);\n    taosCloseFile(&pFile);\n    return -1;\n  }\n\n  taosCloseFile(&pFile);\n  return 0;\n}"
            }
        ],
        "third_party": [
            "uDebug",
            "uError",
            "taosMulMkDir"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "public void destroyDispatcher(String dispatcherId)",
        "start_line": "66",
        "end_line": "73",
        "file_path": "common/actor/src/main/java/org/thingsboard/server/actors/DefaultTbActorSystem.java",
        "docstring": "The function \"destroyDispatcher\" removes and shuts down a dispatcher identified by its ID.\\nIt retrieves the dispatcher from the dispatchers collection and, if found, shuts down its executor immediately.\\nIf the dispatcher is not found, it throws a runtime exception indicating that the dispatcher with the specified ID is not registered.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ca24c06528d5",
        "ground_truth": "public void destroyDispatcher(String dispatcherId) {\n    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n    } else {\n        throw new RuntimeException(\"Dispatcher with id [\" + dispatcherId + \"] is not registered!\");\n    }\n}",
        "import_statements": [
            "import lombok.Data;",
            "import lombok.Getter;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.thingsboard.common.util.ThingsBoardThreadFactory;",
            "import org.thingsboard.server.common.msg.TbActorMsg;",
            "import java.util.Collections;",
            "import java.util.List;",
            "import java.util.Set;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import java.util.concurrent.ConcurrentMap;",
            "import java.util.concurrent.ExecutorService;",
            "import java.util.concurrent.Executors;",
            "import java.util.concurrent.ScheduledExecutorService;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.concurrent.locks.Lock;",
            "import java.util.concurrent.locks.ReentrantLock;",
            "import java.util.function.Predicate;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "shutdownNow",
            "remove",
            "getExecutor"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "shutdownNow",
            "remove",
            "getExecutor"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)",
        "start_line": "172",
        "end_line": "183",
        "file_path": "common/actor/src/main/java/org/thingsboard/server/actors/DefaultTbActorSystem.java",
        "docstring": "The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f9259705d3ba",
        "ground_truth": "private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority) {\n    Set<TbActorId> children = parentChildMap.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(id -> {\n            try {\n                tell(id, msg, highPriority);\n            } catch (TbActorNotRegisteredException e) {\n                log.warn(\"Actor is missing for {}\", id);\n            }\n        });\n    }\n}",
        "import_statements": [
            "import lombok.Data;",
            "import lombok.Getter;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.thingsboard.common.util.ThingsBoardThreadFactory;",
            "import org.thingsboard.server.common.msg.TbActorMsg;",
            "import java.util.Collections;",
            "import java.util.List;",
            "import java.util.Set;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import java.util.concurrent.ConcurrentMap;",
            "import java.util.concurrent.ExecutorService;",
            "import java.util.concurrent.Executors;",
            "import java.util.concurrent.ScheduledExecutorService;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.concurrent.locks.Lock;",
            "import java.util.concurrent.locks.ReentrantLock;",
            "import java.util.function.Predicate;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "filter",
            "forEach",
            "get",
            "warn",
            "stream",
            "tell"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "tell",
                "code": "@Override\n    public void tell(TbActorId target, TbActorMsg actorMsg) {\n        tell(target, actorMsg, false);\n    }"
            }
        ],
        "third_party": [
            "filter",
            "forEach",
            "get",
            "warn",
            "stream"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "private void enqueue(TbActorMsg msg, boolean highPriority)",
        "start_line": "106",
        "end_line": "129",
        "file_path": "common/actor/src/main/java/org/thingsboard/server/actors/TbActorMailbox.java",
        "docstring": "The function \"enqueue\" handles the enqueuing of messages based on their priority and the state of the actor.\\nIf destruction is not in progress, it adds high-priority messages to the highPriorityMsgs queue and normal messages to the normalPriorityMsgs queue, then attempts to process the queue.\\nIf destruction is in progress and the message is a high-priority RULE_NODE_UPDATED_MSG, it may reinitialize the actor if it failed during initialization.\\nOtherwise, it notifies the message that the actor has stopped.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3e09fe4efcf0",
        "ground_truth": "private void enqueue(TbActorMsg msg, boolean highPriority) {\n    if (!destroyInProgress.get()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        tryProcessQueue(true);\n    } else {\n        if (highPriority && msg.getMsgType().equals(MsgType.RULE_NODE_UPDATED_MSG)) {\n            synchronized (this) {\n                if (stopReason == TbActorStopReason.INIT_FAILED) {\n                    destroyInProgress.set(false);\n                    stopReason = null;\n                    initActor();\n                } else {\n                    msg.onTbActorStopped(stopReason);\n                }\n            }\n        } else {\n            msg.onTbActorStopped(stopReason);\n        }\n    }\n}",
        "import_statements": [
            "import lombok.Getter;",
            "import lombok.RequiredArgsConstructor;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.thingsboard.server.common.data.EntityType;",
            "import org.thingsboard.server.common.msg.MsgType;",
            "import org.thingsboard.server.common.msg.TbActorError;",
            "import org.thingsboard.server.common.msg.TbActorMsg;",
            "import org.thingsboard.server.common.msg.TbActorStopReason;",
            "import java.util.List;",
            "import java.util.concurrent.ConcurrentLinkedQueue;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.concurrent.atomic.AtomicBoolean;",
            "import java.util.function.Predicate;",
            "import java.util.function.Supplier;"
        ],
        "reference_api": [
            "tryProcessQueue",
            "onTbActorStopped",
            "getMsgType",
            "equals",
            "set",
            "initActor",
            "get",
            "add"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "tryProcessQueue",
                "code": "private void tryProcessQueue(boolean newMsg) {\n        if (ready.get() == READY) {\n            if (newMsg || !highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty()) {\n                if (busy.compareAndSet(FREE, BUSY)) {\n                    dispatcher.getExecutor().execute(this::processMailbox);\n                } else {\n                    log.trace(\"[{}] MessageBox is busy, new msg: {}\", selfId, newMsg);\n                }\n            } else {\n                log.trace(\"[{}] MessageBox is empty, new msg: {}\", selfId, newMsg);\n            }\n        } else {\n            log.trace(\"[{}] MessageBox is not ready, new msg: {}\", selfId, newMsg);\n        }\n    }"
            },
            {
                "name": "initActor",
                "code": "public void initActor() {\n        dispatcher.getExecutor().execute(() -> tryInit(1));\n    }"
            }
        ],
        "third_party": [
            "onTbActorStopped",
            "getMsgType",
            "set",
            "get",
            "add"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "private void processMailbox()",
        "start_line": "147",
        "end_line": "179",
        "file_path": "common/actor/src/main/java/org/thingsboard/server/actors/TbActorMailbox.java",
        "docstring": "The function \"processMailbox\" processes messages from high and normal priority queues up to a specified throughput limit.\\nIt iterates through the queues, attempting to process each message using the actor's process method.\\nIf an initialization failure occurs, it sets a stop reason and destroys the actor.\\nFor other exceptions, it logs the failure and applies the actor's process failure strategy, potentially stopping the actor if required.\\nIf there are no more messages, it sets the actor's status to free and schedules a queue processing attempt; otherwise, it continues processing the mailbox.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c7eeae2fcef2",
        "ground_truth": "private void processMailbox() {\n    boolean noMoreElements = false;\n    for (int i = 0; i < settings.getActorThroughput(); i++) {\n        TbActorMsg msg = highPriorityMsgs.poll();\n        if (msg == null) {\n            msg = normalPriorityMsgs.poll();\n        }\n        if (msg != null) {\n            try {\n                log.debug(\"[{}] Going to process message: {}\", selfId, msg);\n                actor.process(msg);\n            } catch (TbRuleNodeUpdateException updateException) {\n                stopReason = TbActorStopReason.INIT_FAILED;\n                destroy(updateException.getCause());\n            } catch (Throwable t) {\n                log.debug(\"[{}] Failed to process message: {}\", selfId, msg, t);\n                ProcessFailureStrategy strategy = actor.onProcessFailure(msg, t);\n                if (strategy.isStop()) {\n                    system.stop(selfId);\n                }\n            }\n        } else {\n            noMoreElements = true;\n            break;\n        }\n    }\n    if (noMoreElements) {\n        busy.set(FREE);\n        dispatcher.getExecutor().execute(() -> tryProcessQueue(false));\n    } else {\n        dispatcher.getExecutor().execute(this::processMailbox);\n    }\n}",
        "import_statements": [
            "import lombok.Getter;",
            "import lombok.RequiredArgsConstructor;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.thingsboard.server.common.data.EntityType;",
            "import org.thingsboard.server.common.msg.MsgType;",
            "import org.thingsboard.server.common.msg.TbActorError;",
            "import org.thingsboard.server.common.msg.TbActorMsg;",
            "import org.thingsboard.server.common.msg.TbActorStopReason;",
            "import java.util.List;",
            "import java.util.concurrent.ConcurrentLinkedQueue;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.concurrent.atomic.AtomicBoolean;",
            "import java.util.function.Predicate;",
            "import java.util.function.Supplier;"
        ],
        "reference_api": [
            "process",
            "stop",
            "tryProcessQueue",
            "poll",
            "getCause",
            "execute",
            "set",
            "isStop",
            "getActorThroughput",
            "destroy",
            "debug",
            "onProcessFailure",
            "getExecutor"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "stop",
                "code": "@Override\n    public void stop(TbActorId target) {\n        system.stop(target);\n    }"
            },
            {
                "name": "tryProcessQueue",
                "code": "private void tryProcessQueue(boolean newMsg) {\n        if (ready.get() == READY) {\n            if (newMsg || !highPriorityMsgs.isEmpty() || !normalPriorityMsgs.isEmpty()) {\n                if (busy.compareAndSet(FREE, BUSY)) {\n                    dispatcher.getExecutor().execute(this::processMailbox);\n                } else {\n                    log.trace(\"[{}] MessageBox is busy, new msg: {}\", selfId, newMsg);\n                }\n            } else {\n                log.trace(\"[{}] MessageBox is empty, new msg: {}\", selfId, newMsg);\n            }\n        } else {\n            log.trace(\"[{}] MessageBox is not ready, new msg: {}\", selfId, newMsg);\n        }\n    }"
            },
            {
                "name": "destroy",
                "code": "public void destroy(Throwable cause) {\n        if (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }"
            }
        ],
        "third_party": [
            "process",
            "poll",
            "getCause",
            "execute",
            "set",
            "isStop",
            "getActorThroughput",
            "debug",
            "onProcessFailure",
            "getExecutor"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "public void destroy(Throwable cause)",
        "start_line": "231",
        "end_line": "246",
        "file_path": "common/actor/src/main/java/org/thingsboard/server/actors/TbActorMailbox.java",
        "docstring": "The function \"destroy\" initiates the destruction of an actor with a specified cause.\\nIt sets the stop reason if not already set and marks the destruction as in progress.\\nThe function then schedules a task on the dispatcher's executor to set the actor's readiness to \"not ready,\" invoke the actor's destroy method with the stop reason and cause, and notify all queued messages of the actor's stoppage.\\nAny exceptions during this process are logged with a warning.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c77f1760a734",
        "ground_truth": "public void destroy(Throwable cause) {\n    if (stopReason == null) {\n        stopReason = TbActorStopReason.STOPPED;\n    }\n    destroyInProgress.set(true);\n    dispatcher.getExecutor().execute(() -> {\n        try {\n            ready.set(NOT_READY);\n            actor.destroy(stopReason, cause);\n            highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n        } catch (Throwable t) {\n            log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n        }\n    });\n}",
        "import_statements": [
            "import lombok.Getter;",
            "import lombok.RequiredArgsConstructor;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.thingsboard.server.common.data.EntityType;",
            "import org.thingsboard.server.common.msg.MsgType;",
            "import org.thingsboard.server.common.msg.TbActorError;",
            "import org.thingsboard.server.common.msg.TbActorMsg;",
            "import org.thingsboard.server.common.msg.TbActorStopReason;",
            "import java.util.List;",
            "import java.util.concurrent.ConcurrentLinkedQueue;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.concurrent.atomic.AtomicBoolean;",
            "import java.util.function.Predicate;",
            "import java.util.function.Supplier;"
        ],
        "reference_api": [
            "onTbActorStopped",
            "execute",
            "set",
            "forEach",
            "destroy",
            "warn",
            "getExecutor"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "destroy",
                "code": "public void destroy(Throwable cause) {\n        if (stopReason == null) {\n            stopReason = TbActorStopReason.STOPPED;\n        }\n        destroyInProgress.set(true);\n        dispatcher.getExecutor().execute(() -> {\n            try {\n                ready.set(NOT_READY);\n                actor.destroy(stopReason, cause);\n                highPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n                normalPriorityMsgs.forEach(msg -> msg.onTbActorStopped(stopReason));\n            } catch (Throwable t) {\n                log.warn(\"[{}] Failed to destroy actor: {}\", selfId, t);\n            }\n        });\n    }"
            }
        ],
        "third_party": [
            "onTbActorStopped",
            "execute",
            "set",
            "forEach",
            "warn",
            "getExecutor"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)",
        "start_line": "70",
        "end_line": "95",
        "file_path": "common/cache/src/main/java/org/thingsboard/server/cache/limits/DefaultRateLimitService.java",
        "docstring": "The function \"checkRateLimit\" verifies if a specified API call for a tenant exceeds the rate limit.\\nIf the tenant ID corresponds to the system tenant, it always returns true.\\nIt retrieves the tenant's profile; if not found and ignoring missing tenants is allowed, it returns true, otherwise, it throws a TenantProfileNotFoundException.\\nIt fetches the rate limit configuration from the tenant profile and checks the rate limit.\\nIf the rate limit is exceeded, it processes a rate limit notification.\\nFinally, it returns whether the rate limit check was successful.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "faa557453384",
        "ground_truth": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound) {\n    if (tenantId.isSysTenantId()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileProvider.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    String rateLimitConfig = tenantProfile.getProfileConfiguration()\n            .map(api::getLimitConfig).orElse(null);\n    boolean success = checkRateLimit(api, level, rateLimitConfig);\n    if (!success) {\n        notificationRuleProcessor.process(RateLimitsTrigger.builder()\n                .tenantId(tenantId)\n                .api(api)\n                .limitLevel(level instanceof EntityId ? (EntityId) level : tenantId)\n                .limitLevelEntityName(null)\n                .build());\n    }\n    return success;\n}",
        "import_statements": [
            "import com.github.benmanes.caffeine.cache.Cache;",
            "import com.github.benmanes.caffeine.cache.Caffeine;",
            "import lombok.Data;",
            "import lombok.extern.slf4j.Slf4j;",
            "import org.springframework.beans.factory.annotation.Value;",
            "import org.springframework.context.annotation.Lazy;",
            "import org.springframework.stereotype.Service;",
            "import org.thingsboard.server.common.data.StringUtils;",
            "import org.thingsboard.server.common.data.TenantProfile;",
            "import org.thingsboard.server.common.data.exception.TenantProfileNotFoundException;",
            "import org.thingsboard.server.common.data.id.EntityId;",
            "import org.thingsboard.server.common.data.id.TenantId;",
            "import org.thingsboard.server.common.data.limit.LimitedApi;",
            "import org.thingsboard.server.common.data.notification.rule.trigger.RateLimitsTrigger;",
            "import org.thingsboard.server.common.msg.notification.NotificationRuleProcessor;",
            "import org.thingsboard.server.common.msg.tools.TbRateLimits;",
            "import java.util.concurrent.TimeUnit;"
        ],
        "reference_api": [
            "process",
            "orElse",
            "api",
            "limitLevelEntityName",
            "map",
            "tenantId",
            "checkRateLimit",
            "builder",
            "get",
            "getProfileConfiguration",
            "build",
            "limitLevel",
            "isSysTenantId"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "checkRateLimit",
                "code": "@Override\n    public boolean checkRateLimit(LimitedApi api, TenantId tenantId) {\n        return checkRateLimit(api, tenantId, tenantId);\n    }"
            }
        ],
        "third_party": [
            "process",
            "orElse",
            "api",
            "limitLevelEntityName",
            "map",
            "tenantId",
            "builder",
            "get",
            "getProfileConfiguration",
            "build",
            "limitLevel",
            "isSysTenantId"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "public void evictTimeoutSessions()",
        "start_line": "44",
        "end_line": "54",
        "file_path": "common/coap-server/src/main/java/org/thingsboard/server/coapserver/TbCoapDtlsSessionInMemoryStorage.java",
        "docstring": "The function \"evictTimeoutSessions\" removes DTLS sessions that have been inactive for a duration longer than the specified timeout.\\nIt calculates the expiration time based on the current time minus the inactivity timeout.\\nIt then iterates over the entries in the DTLS sessions map and removes those with a last activity time older than the calculated expiration time, logging each removal.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "86dc1ef3798b",
        "ground_truth": "public void evictTimeoutSessions() {\n    long expTime = System.currentTimeMillis() - dtlsSessionInactivityTimeout;\n    dtlsSessionsMap.entrySet().removeIf(entry -> {\n        if (entry.getValue().getLastActivityTime() < expTime) {\n            log.trace(\"DTLS session was removed from in-memory store: [{}]\", entry.getKey());\n            return true;\n        } else {\n            return false;\n        }\n    });\n}",
        "import_statements": [
            "import lombok.Data;",
            "import lombok.extern.slf4j.Slf4j;",
            "import java.net.InetSocketAddress;",
            "import java.util.concurrent.ConcurrentHashMap;",
            "import java.util.concurrent.ConcurrentMap;"
        ],
        "reference_api": [
            "removeIf",
            "getValue",
            "getLastActivityTime",
            "entrySet",
            "currentTimeMillis",
            "getKey",
            "trace"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "removeIf",
            "getValue",
            "getLastActivityTime",
            "entrySet",
            "currentTimeMillis",
            "getKey",
            "trace"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)",
        "start_line": "57",
        "end_line": "71",
        "file_path": "rest-client/src/main/java/org/thingsboard/rest/client/utils/RestJsonConverter.java",
        "docstring": "The function \"toTimeseries\" converts a map of timeseries data into a list of TsKvEntry objects.\\nIt first checks if the input map is not empty.\\nIf not empty, it iterates over the map entries, parses the values, and constructs a list of TsKvEntry objects for each key-value pair in the map.\\nIf the input map is empty, it returns an empty list.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b79b5af90fe1",
        "ground_truth": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries) {\n    if (!CollectionUtils.isEmpty(timeseries)) {\n        List<TsKvEntry> result = new ArrayList<>();\n        timeseries.forEach((key, values) ->\n                result.addAll(values.stream().map(ts -> {\n                            KvEntry entry = parseValue(key, ts.get(VALUE));\n                            return new BasicTsKvEntry(ts.get(TS).asLong(), entry);\n                        }\n                ).toList())\n        );\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}",
        "import_statements": [
            "import com.fasterxml.jackson.databind.JsonNode;",
            "import org.springframework.util.CollectionUtils;",
            "import org.thingsboard.server.common.data.kv.AttributeKvEntry;",
            "import org.thingsboard.server.common.data.kv.BaseAttributeKvEntry;",
            "import org.thingsboard.server.common.data.kv.BasicTsKvEntry;",
            "import org.thingsboard.server.common.data.kv.BooleanDataEntry;",
            "import org.thingsboard.server.common.data.kv.DoubleDataEntry;",
            "import org.thingsboard.server.common.data.kv.JsonDataEntry;",
            "import org.thingsboard.server.common.data.kv.KvEntry;",
            "import org.thingsboard.server.common.data.kv.LongDataEntry;",
            "import org.thingsboard.server.common.data.kv.StringDataEntry;",
            "import org.thingsboard.server.common.data.kv.TsKvEntry;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.stream.Collectors;"
        ],
        "reference_api": [
            "parseValue",
            "toList",
            "map",
            "asLong",
            "forEach",
            "get",
            "addAll",
            "stream",
            "isEmpty",
            "emptyList"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "parseValue",
                "code": "private static KvEntry parseValue(String key, JsonNode value) {\n        if (!value.isContainerNode()) {\n            if (value.isBoolean()) {\n                return new BooleanDataEntry(key, value.asBoolean());\n            } else if (value.isNumber()) {\n                return parseNumericValue(key, value);\n            } else if (value.isTextual()) {\n                return new StringDataEntry(key, value.asText());\n            } else {\n                throw new RuntimeException(CAN_T_PARSE_VALUE + value);\n            }\n        } else {\n            return new JsonDataEntry(key, value.toString());\n        }\n    }"
            }
        ],
        "third_party": [
            "toList",
            "map",
            "asLong",
            "forEach",
            "get",
            "addAll",
            "stream",
            "isEmpty",
            "emptyList"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "public void refreshToken()",
        "start_line": "249",
        "end_line": "255",
        "file_path": "rest-client/src/main/java/org/thingsboard/rest/client/RestClient.java",
        "docstring": "The function \"refreshToken\" sends a request to refresh the authentication token.\\nIt creates a request map containing the current refresh token and sends a POST request to the authentication endpoint.\\nUpon receiving the response, it updates the token information with the current timestamp and the response body.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5515923bb5f5",
        "ground_truth": "public void refreshToken() {\n    Map<String, String> refreshTokenRequest = new HashMap<>();\n    refreshTokenRequest.put(\"refreshToken\", refreshToken);\n    long ts = System.currentTimeMillis();\n    ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/token\", refreshTokenRequest, JsonNode.class);\n    setTokenInfo(ts, tokenInfo.getBody());\n}",
        "import_statements": [
            "import com.auth0.jwt.JWT;",
            "import com.fasterxml.jackson.databind.JsonNode;",
            "import com.fasterxml.jackson.databind.node.ObjectNode;",
            "import com.google.common.base.Strings;",
            "import org.apache.commons.io.IOUtils;",
            "import org.springframework.core.ParameterizedTypeReference;",
            "import org.springframework.core.io.ByteArrayResource;",
            "import org.springframework.core.io.Resource;",
            "import org.springframework.http.HttpEntity;",
            "import org.springframework.http.HttpHeaders;",
            "import org.springframework.http.HttpMethod;",
            "import org.springframework.http.HttpRequest;",
            "import org.springframework.http.HttpStatus;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.ResponseEntity;",
            "import org.springframework.http.client.support.HttpRequestWrapper;",
            "import org.springframework.util.CollectionUtils;",
            "import org.springframework.util.LinkedMultiValueMap;",
            "import org.springframework.util.MultiValueMap;",
            "import org.springframework.web.client.HttpClientErrorException;",
            "import org.springframework.web.client.RestTemplate;",
            "import org.thingsboard.common.util.JacksonUtil;",
            "import org.thingsboard.common.util.ThingsBoardExecutors;",
            "import org.thingsboard.rest.client.utils.RestJsonConverter;",
            "import org.thingsboard.server.common.data.AdminSettings;",
            "import org.thingsboard.server.common.data.ClaimRequest;",
            "import org.thingsboard.server.common.data.Customer;",
            "import org.thingsboard.server.common.data.Dashboard;",
            "import org.thingsboard.server.common.data.DashboardInfo;",
            "import org.thingsboard.server.common.data.Device;",
            "import org.thingsboard.server.common.data.DeviceInfo;",
            "import org.thingsboard.server.common.data.DeviceProfile;",
            "import org.thingsboard.server.common.data.DeviceProfileInfo;",
            "import org.thingsboard.server.common.data.DeviceTransportType;",
            "import org.thingsboard.server.common.data.EntityInfo;",
            "import org.thingsboard.server.common.data.EntitySubtype;",
            "import org.thingsboard.server.common.data.EntityType;",
            "import org.thingsboard.server.common.data.EntityView;",
            "import org.thingsboard.server.common.data.EntityViewInfo;",
            "import org.thingsboard.server.common.data.EventInfo;",
            "import org.thingsboard.server.common.data.ImageExportData;",
            "import org.thingsboard.server.common.data.OtaPackage;",
            "import org.thingsboard.server.common.data.OtaPackageInfo;",
            "import org.thingsboard.server.common.data.SaveDeviceWithCredentialsRequest;",
            "import org.thingsboard.server.common.data.StringUtils;",
            "import org.thingsboard.server.common.data.SystemInfo;",
            "import org.thingsboard.server.common.data.TbImageDeleteResult;",
            "import org.thingsboard.server.common.data.TbResource;",
            "import org.thingsboard.server.common.data.TbResourceInfo;",
            "import org.thingsboard.server.common.data.Tenant;",
            "import org.thingsboard.server.common.data.TenantInfo;",
            "import org.thingsboard.server.common.data.TenantProfile;",
            "import org.thingsboard.server.common.data.UpdateMessage;",
            "import org.thingsboard.server.common.data.UsageInfo;",
            "import org.thingsboard.server.common.data.User;",
            "import org.thingsboard.server.common.data.UserEmailInfo;",
            "import org.thingsboard.server.common.data.alarm.Alarm;",
            "import org.thingsboard.server.common.data.alarm.AlarmComment;",
            "import org.thingsboard.server.common.data.alarm.AlarmCommentInfo;",
            "import org.thingsboard.server.common.data.alarm.AlarmInfo;",
            "import org.thingsboard.server.common.data.alarm.AlarmSearchStatus;",
            "import org.thingsboard.server.common.data.alarm.AlarmSeverity;",
            "import org.thingsboard.server.common.data.alarm.AlarmStatus;",
            "import org.thingsboard.server.common.data.asset.Asset;",
            "import org.thingsboard.server.common.data.asset.AssetInfo;",
            "import org.thingsboard.server.common.data.asset.AssetProfile;",
            "import org.thingsboard.server.common.data.asset.AssetProfileInfo;",
            "import org.thingsboard.server.common.data.asset.AssetSearchQuery;",
            "import org.thingsboard.server.common.data.audit.ActionType;",
            "import org.thingsboard.server.common.data.audit.AuditLog;",
            "import org.thingsboard.server.common.data.device.DeviceSearchQuery;",
            "import org.thingsboard.server.common.data.edge.Edge;",
            "import org.thingsboard.server.common.data.edge.EdgeEvent;",
            "import org.thingsboard.server.common.data.edge.EdgeInfo;",
            "import org.thingsboard.server.common.data.edge.EdgeInstructions;",
            "import org.thingsboard.server.common.data.edge.EdgeSearchQuery;",
            "import org.thingsboard.server.common.data.entityview.EntityViewSearchQuery;",
            "import org.thingsboard.server.common.data.id.AlarmCommentId;",
            "import org.thingsboard.server.common.data.id.AlarmId;",
            "import org.thingsboard.server.common.data.id.AssetId;",
            "import org.thingsboard.server.common.data.id.AssetProfileId;",
            "import org.thingsboard.server.common.data.id.CustomerId;",
            "import org.thingsboard.server.common.data.id.DashboardId;",
            "import org.thingsboard.server.common.data.id.DeviceId;",
            "import org.thingsboard.server.common.data.id.DeviceProfileId;",
            "import org.thingsboard.server.common.data.id.EdgeId;",
            "import org.thingsboard.server.common.data.id.EntityId;",
            "import org.thingsboard.server.common.data.id.EntityViewId;",
            "import org.thingsboard.server.common.data.id.OAuth2ClientRegistrationTemplateId;",
            "import org.thingsboard.server.common.data.id.OtaPackageId;",
            "import org.thingsboard.server.common.data.id.QueueId;",
            "import org.thingsboard.server.common.data.id.RuleChainId;",
            "import org.thingsboard.server.common.data.id.RuleNodeId;",
            "import org.thingsboard.server.common.data.id.TbResourceId;",
            "import org.thingsboard.server.common.data.id.TenantId;",
            "import org.thingsboard.server.common.data.id.TenantProfileId;",
            "import org.thingsboard.server.common.data.id.UserId;",
            "import org.thingsboard.server.common.data.id.WidgetTypeId;",
            "import org.thingsboard.server.common.data.id.WidgetsBundleId;",
            "import org.thingsboard.server.common.data.kv.Aggregation;",
            "import org.thingsboard.server.common.data.kv.AttributeKvEntry;",
            "import org.thingsboard.server.common.data.kv.TsKvEntry;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2ClientInfo;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2ClientRegistrationTemplate;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2Info;",
            "import org.thingsboard.server.common.data.oauth2.PlatformType;",
            "import org.thingsboard.server.common.data.ota.ChecksumAlgorithm;",
            "import org.thingsboard.server.common.data.ota.OtaPackageType;",
            "import org.thingsboard.server.common.data.page.PageData;",
            "import org.thingsboard.server.common.data.page.PageLink;",
            "import org.thingsboard.server.common.data.page.SortOrder;",
            "import org.thingsboard.server.common.data.page.TimePageLink;",
            "import org.thingsboard.server.common.data.plugin.ComponentDescriptor;",
            "import org.thingsboard.server.common.data.plugin.ComponentType;",
            "import org.thingsboard.server.common.data.query.AlarmCountQuery;",
            "import org.thingsboard.server.common.data.query.AlarmData;",
            "import org.thingsboard.server.common.data.query.AlarmDataQuery;",
            "import org.thingsboard.server.common.data.query.EntityCountQuery;",
            "import org.thingsboard.server.common.data.query.EntityData;",
            "import org.thingsboard.server.common.data.query.EntityDataQuery;",
            "import org.thingsboard.server.common.data.queue.Queue;",
            "import org.thingsboard.server.common.data.relation.EntityRelation;",
            "import org.thingsboard.server.common.data.relation.EntityRelationInfo;",
            "import org.thingsboard.server.common.data.relation.EntityRelationsQuery;",
            "import org.thingsboard.server.common.data.relation.RelationTypeGroup;",
            "import org.thingsboard.server.common.data.rule.DefaultRuleChainCreateRequest;",
            "import org.thingsboard.server.common.data.rule.RuleChain;",
            "import org.thingsboard.server.common.data.rule.RuleChainData;",
            "import org.thingsboard.server.common.data.rule.RuleChainMetaData;",
            "import org.thingsboard.server.common.data.rule.RuleChainType;",
            "import org.thingsboard.server.common.data.security.DeviceCredentials;",
            "import org.thingsboard.server.common.data.security.DeviceCredentialsType;",
            "import org.thingsboard.server.common.data.security.model.JwtPair;",
            "import org.thingsboard.server.common.data.security.model.JwtSettings;",
            "import org.thingsboard.server.common.data.security.model.SecuritySettings;",
            "import org.thingsboard.server.common.data.security.model.UserPasswordPolicy;",
            "import org.thingsboard.server.common.data.sms.config.TestSmsRequest;",
            "import org.thingsboard.server.common.data.sync.ie.importing.csv.BulkImportRequest;",
            "import org.thingsboard.server.common.data.sync.ie.importing.csv.BulkImportResult;",
            "import org.thingsboard.server.common.data.sync.vc.AutoCommitSettings;",
            "import org.thingsboard.server.common.data.sync.vc.BranchInfo;",
            "import org.thingsboard.server.common.data.sync.vc.EntityDataDiff;",
            "import org.thingsboard.server.common.data.sync.vc.EntityDataInfo;",
            "import org.thingsboard.server.common.data.sync.vc.EntityVersion;",
            "import org.thingsboard.server.common.data.sync.vc.RepositorySettings;",
            "import org.thingsboard.server.common.data.sync.vc.VersionCreationResult;",
            "import org.thingsboard.server.common.data.sync.vc.VersionLoadResult;",
            "import org.thingsboard.server.common.data.sync.vc.VersionedEntityInfo;",
            "import org.thingsboard.server.common.data.sync.vc.request.create.VersionCreateRequest;",
            "import org.thingsboard.server.common.data.sync.vc.request.load.VersionLoadRequest;",
            "import org.thingsboard.server.common.data.widget.DeprecatedFilter;",
            "import org.thingsboard.server.common.data.widget.WidgetType;",
            "import org.thingsboard.server.common.data.widget.WidgetTypeDetails;",
            "import org.thingsboard.server.common.data.widget.WidgetTypeInfo;",
            "import org.thingsboard.server.common.data.widget.WidgetsBundle;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.net.URI;",
            "import java.util.Collections;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Optional;",
            "import java.util.UUID;",
            "import java.util.concurrent.ExecutorService;",
            "import java.util.concurrent.Future;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.stream.Collectors;",
            "import static org.thingsboard.server.common.data.StringUtils.isEmpty;"
        ],
        "reference_api": [
            "setTokenInfo",
            "getBody",
            "currentTimeMillis",
            "put",
            "postForEntity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "setTokenInfo",
                "code": "private synchronized void setTokenInfo(long ts, JsonNode tokenInfo) {\n        this.mainToken = tokenInfo.get(\"token\").asText();\n        this.refreshToken = tokenInfo.get(\"refreshToken\").asText();\n        this.mainTokenExpTs = JWT.decode(this.mainToken).getExpiresAtAsInstant().toEpochMilli();\n        this.refreshTokenExpTs = JWT.decode(refreshToken).getExpiresAtAsInstant().toEpochMilli();\n        this.clientServerTimeDiff = JWT.decode(this.mainToken).getIssuedAtAsInstant().toEpochMilli() - ts;\n    }"
            }
        ],
        "third_party": [
            "getBody",
            "currentTimeMillis",
            "put",
            "postForEntity"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": " private void doLogin()",
        "start_line": "263",
        "end_line": "270",
        "file_path": "rest-client/src/main/java/org/thingsboard/rest/client/RestClient.java",
        "docstring": "The function \"doLogin\" performs a login operation by sending a POST request with the username and password to the authentication endpoint.\\nIt captures the current timestamp, creates a login request map with the credentials, and sends the request to the \"/api/auth/login\" URL.\\nUpon receiving the response, it updates the token information with the response data and the timestamp.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2e481513bbc1",
        "ground_truth": "private void doLogin() {\n    long ts = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    ResponseEntity<JsonNode> tokenInfo = loginRestTemplate.postForEntity(baseURL + \"/api/auth/login\", loginRequest, JsonNode.class);\n    setTokenInfo(ts, tokenInfo.getBody());\n}",
        "import_statements": [
            "import com.auth0.jwt.JWT;",
            "import com.fasterxml.jackson.databind.JsonNode;",
            "import com.fasterxml.jackson.databind.node.ObjectNode;",
            "import com.google.common.base.Strings;",
            "import org.apache.commons.io.IOUtils;",
            "import org.springframework.core.ParameterizedTypeReference;",
            "import org.springframework.core.io.ByteArrayResource;",
            "import org.springframework.core.io.Resource;",
            "import org.springframework.http.HttpEntity;",
            "import org.springframework.http.HttpHeaders;",
            "import org.springframework.http.HttpMethod;",
            "import org.springframework.http.HttpRequest;",
            "import org.springframework.http.HttpStatus;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.ResponseEntity;",
            "import org.springframework.http.client.support.HttpRequestWrapper;",
            "import org.springframework.util.CollectionUtils;",
            "import org.springframework.util.LinkedMultiValueMap;",
            "import org.springframework.util.MultiValueMap;",
            "import org.springframework.web.client.HttpClientErrorException;",
            "import org.springframework.web.client.RestTemplate;",
            "import org.thingsboard.common.util.JacksonUtil;",
            "import org.thingsboard.common.util.ThingsBoardExecutors;",
            "import org.thingsboard.rest.client.utils.RestJsonConverter;",
            "import org.thingsboard.server.common.data.AdminSettings;",
            "import org.thingsboard.server.common.data.ClaimRequest;",
            "import org.thingsboard.server.common.data.Customer;",
            "import org.thingsboard.server.common.data.Dashboard;",
            "import org.thingsboard.server.common.data.DashboardInfo;",
            "import org.thingsboard.server.common.data.Device;",
            "import org.thingsboard.server.common.data.DeviceInfo;",
            "import org.thingsboard.server.common.data.DeviceProfile;",
            "import org.thingsboard.server.common.data.DeviceProfileInfo;",
            "import org.thingsboard.server.common.data.DeviceTransportType;",
            "import org.thingsboard.server.common.data.EntityInfo;",
            "import org.thingsboard.server.common.data.EntitySubtype;",
            "import org.thingsboard.server.common.data.EntityType;",
            "import org.thingsboard.server.common.data.EntityView;",
            "import org.thingsboard.server.common.data.EntityViewInfo;",
            "import org.thingsboard.server.common.data.EventInfo;",
            "import org.thingsboard.server.common.data.ImageExportData;",
            "import org.thingsboard.server.common.data.OtaPackage;",
            "import org.thingsboard.server.common.data.OtaPackageInfo;",
            "import org.thingsboard.server.common.data.SaveDeviceWithCredentialsRequest;",
            "import org.thingsboard.server.common.data.StringUtils;",
            "import org.thingsboard.server.common.data.SystemInfo;",
            "import org.thingsboard.server.common.data.TbImageDeleteResult;",
            "import org.thingsboard.server.common.data.TbResource;",
            "import org.thingsboard.server.common.data.TbResourceInfo;",
            "import org.thingsboard.server.common.data.Tenant;",
            "import org.thingsboard.server.common.data.TenantInfo;",
            "import org.thingsboard.server.common.data.TenantProfile;",
            "import org.thingsboard.server.common.data.UpdateMessage;",
            "import org.thingsboard.server.common.data.UsageInfo;",
            "import org.thingsboard.server.common.data.User;",
            "import org.thingsboard.server.common.data.UserEmailInfo;",
            "import org.thingsboard.server.common.data.alarm.Alarm;",
            "import org.thingsboard.server.common.data.alarm.AlarmComment;",
            "import org.thingsboard.server.common.data.alarm.AlarmCommentInfo;",
            "import org.thingsboard.server.common.data.alarm.AlarmInfo;",
            "import org.thingsboard.server.common.data.alarm.AlarmSearchStatus;",
            "import org.thingsboard.server.common.data.alarm.AlarmSeverity;",
            "import org.thingsboard.server.common.data.alarm.AlarmStatus;",
            "import org.thingsboard.server.common.data.asset.Asset;",
            "import org.thingsboard.server.common.data.asset.AssetInfo;",
            "import org.thingsboard.server.common.data.asset.AssetProfile;",
            "import org.thingsboard.server.common.data.asset.AssetProfileInfo;",
            "import org.thingsboard.server.common.data.asset.AssetSearchQuery;",
            "import org.thingsboard.server.common.data.audit.ActionType;",
            "import org.thingsboard.server.common.data.audit.AuditLog;",
            "import org.thingsboard.server.common.data.device.DeviceSearchQuery;",
            "import org.thingsboard.server.common.data.edge.Edge;",
            "import org.thingsboard.server.common.data.edge.EdgeEvent;",
            "import org.thingsboard.server.common.data.edge.EdgeInfo;",
            "import org.thingsboard.server.common.data.edge.EdgeInstructions;",
            "import org.thingsboard.server.common.data.edge.EdgeSearchQuery;",
            "import org.thingsboard.server.common.data.entityview.EntityViewSearchQuery;",
            "import org.thingsboard.server.common.data.id.AlarmCommentId;",
            "import org.thingsboard.server.common.data.id.AlarmId;",
            "import org.thingsboard.server.common.data.id.AssetId;",
            "import org.thingsboard.server.common.data.id.AssetProfileId;",
            "import org.thingsboard.server.common.data.id.CustomerId;",
            "import org.thingsboard.server.common.data.id.DashboardId;",
            "import org.thingsboard.server.common.data.id.DeviceId;",
            "import org.thingsboard.server.common.data.id.DeviceProfileId;",
            "import org.thingsboard.server.common.data.id.EdgeId;",
            "import org.thingsboard.server.common.data.id.EntityId;",
            "import org.thingsboard.server.common.data.id.EntityViewId;",
            "import org.thingsboard.server.common.data.id.OAuth2ClientRegistrationTemplateId;",
            "import org.thingsboard.server.common.data.id.OtaPackageId;",
            "import org.thingsboard.server.common.data.id.QueueId;",
            "import org.thingsboard.server.common.data.id.RuleChainId;",
            "import org.thingsboard.server.common.data.id.RuleNodeId;",
            "import org.thingsboard.server.common.data.id.TbResourceId;",
            "import org.thingsboard.server.common.data.id.TenantId;",
            "import org.thingsboard.server.common.data.id.TenantProfileId;",
            "import org.thingsboard.server.common.data.id.UserId;",
            "import org.thingsboard.server.common.data.id.WidgetTypeId;",
            "import org.thingsboard.server.common.data.id.WidgetsBundleId;",
            "import org.thingsboard.server.common.data.kv.Aggregation;",
            "import org.thingsboard.server.common.data.kv.AttributeKvEntry;",
            "import org.thingsboard.server.common.data.kv.TsKvEntry;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2ClientInfo;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2ClientRegistrationTemplate;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2Info;",
            "import org.thingsboard.server.common.data.oauth2.PlatformType;",
            "import org.thingsboard.server.common.data.ota.ChecksumAlgorithm;",
            "import org.thingsboard.server.common.data.ota.OtaPackageType;",
            "import org.thingsboard.server.common.data.page.PageData;",
            "import org.thingsboard.server.common.data.page.PageLink;",
            "import org.thingsboard.server.common.data.page.SortOrder;",
            "import org.thingsboard.server.common.data.page.TimePageLink;",
            "import org.thingsboard.server.common.data.plugin.ComponentDescriptor;",
            "import org.thingsboard.server.common.data.plugin.ComponentType;",
            "import org.thingsboard.server.common.data.query.AlarmCountQuery;",
            "import org.thingsboard.server.common.data.query.AlarmData;",
            "import org.thingsboard.server.common.data.query.AlarmDataQuery;",
            "import org.thingsboard.server.common.data.query.EntityCountQuery;",
            "import org.thingsboard.server.common.data.query.EntityData;",
            "import org.thingsboard.server.common.data.query.EntityDataQuery;",
            "import org.thingsboard.server.common.data.queue.Queue;",
            "import org.thingsboard.server.common.data.relation.EntityRelation;",
            "import org.thingsboard.server.common.data.relation.EntityRelationInfo;",
            "import org.thingsboard.server.common.data.relation.EntityRelationsQuery;",
            "import org.thingsboard.server.common.data.relation.RelationTypeGroup;",
            "import org.thingsboard.server.common.data.rule.DefaultRuleChainCreateRequest;",
            "import org.thingsboard.server.common.data.rule.RuleChain;",
            "import org.thingsboard.server.common.data.rule.RuleChainData;",
            "import org.thingsboard.server.common.data.rule.RuleChainMetaData;",
            "import org.thingsboard.server.common.data.rule.RuleChainType;",
            "import org.thingsboard.server.common.data.security.DeviceCredentials;",
            "import org.thingsboard.server.common.data.security.DeviceCredentialsType;",
            "import org.thingsboard.server.common.data.security.model.JwtPair;",
            "import org.thingsboard.server.common.data.security.model.JwtSettings;",
            "import org.thingsboard.server.common.data.security.model.SecuritySettings;",
            "import org.thingsboard.server.common.data.security.model.UserPasswordPolicy;",
            "import org.thingsboard.server.common.data.sms.config.TestSmsRequest;",
            "import org.thingsboard.server.common.data.sync.ie.importing.csv.BulkImportRequest;",
            "import org.thingsboard.server.common.data.sync.ie.importing.csv.BulkImportResult;",
            "import org.thingsboard.server.common.data.sync.vc.AutoCommitSettings;",
            "import org.thingsboard.server.common.data.sync.vc.BranchInfo;",
            "import org.thingsboard.server.common.data.sync.vc.EntityDataDiff;",
            "import org.thingsboard.server.common.data.sync.vc.EntityDataInfo;",
            "import org.thingsboard.server.common.data.sync.vc.EntityVersion;",
            "import org.thingsboard.server.common.data.sync.vc.RepositorySettings;",
            "import org.thingsboard.server.common.data.sync.vc.VersionCreationResult;",
            "import org.thingsboard.server.common.data.sync.vc.VersionLoadResult;",
            "import org.thingsboard.server.common.data.sync.vc.VersionedEntityInfo;",
            "import org.thingsboard.server.common.data.sync.vc.request.create.VersionCreateRequest;",
            "import org.thingsboard.server.common.data.sync.vc.request.load.VersionLoadRequest;",
            "import org.thingsboard.server.common.data.widget.DeprecatedFilter;",
            "import org.thingsboard.server.common.data.widget.WidgetType;",
            "import org.thingsboard.server.common.data.widget.WidgetTypeDetails;",
            "import org.thingsboard.server.common.data.widget.WidgetTypeInfo;",
            "import org.thingsboard.server.common.data.widget.WidgetsBundle;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.net.URI;",
            "import java.util.Collections;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Optional;",
            "import java.util.UUID;",
            "import java.util.concurrent.ExecutorService;",
            "import java.util.concurrent.Future;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.stream.Collectors;",
            "import static org.thingsboard.server.common.data.StringUtils.isEmpty;"
        ],
        "reference_api": [
            "setTokenInfo",
            "getBody",
            "currentTimeMillis",
            "put",
            "postForEntity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "setTokenInfo",
                "code": "private synchronized void setTokenInfo(long ts, JsonNode tokenInfo) {\n        this.mainToken = tokenInfo.get(\"token\").asText();\n        this.refreshToken = tokenInfo.get(\"refreshToken\").asText();\n        this.mainTokenExpTs = JWT.decode(this.mainToken).getExpiresAtAsInstant().toEpochMilli();\n        this.refreshTokenExpTs = JWT.decode(refreshToken).getExpiresAtAsInstant().toEpochMilli();\n        this.clientServerTimeDiff = JWT.decode(this.mainToken).getIssuedAtAsInstant().toEpochMilli() - ts;\n    }"
            }
        ],
        "third_party": [
            "getBody",
            "currentTimeMillis",
            "put",
            "postForEntity"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "public Optional<Device> getDeviceById(DeviceId deviceId)",
        "start_line": "1228",
        "end_line": "1239",
        "file_path": "rest-client/src/main/java/org/thingsboard/rest/client/RestClient.java",
        "docstring": "The function \"getDeviceById\" retrieves a device by its ID using a REST API call.\\nIt sends a GET request to the \"/api/device/{deviceId}\" endpoint and returns the device wrapped in an Optional if found.\\nIf a 404 (Not Found) error occurs, it returns an empty Optional.\\nFor other HTTP errors, it rethrows the exception.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "47f8466c5067",
        "ground_truth": "public Optional<Device> getDeviceById(DeviceId deviceId) {\n    try {\n        ResponseEntity<Device> device = restTemplate.getForEntity(baseURL + \"/api/device/{deviceId}\", Device.class, deviceId.getId());\n        return Optional.ofNullable(device.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}",
        "import_statements": [
            "import com.auth0.jwt.JWT;",
            "import com.fasterxml.jackson.databind.JsonNode;",
            "import com.fasterxml.jackson.databind.node.ObjectNode;",
            "import com.google.common.base.Strings;",
            "import org.apache.commons.io.IOUtils;",
            "import org.springframework.core.ParameterizedTypeReference;",
            "import org.springframework.core.io.ByteArrayResource;",
            "import org.springframework.core.io.Resource;",
            "import org.springframework.http.HttpEntity;",
            "import org.springframework.http.HttpHeaders;",
            "import org.springframework.http.HttpMethod;",
            "import org.springframework.http.HttpRequest;",
            "import org.springframework.http.HttpStatus;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.ResponseEntity;",
            "import org.springframework.http.client.support.HttpRequestWrapper;",
            "import org.springframework.util.CollectionUtils;",
            "import org.springframework.util.LinkedMultiValueMap;",
            "import org.springframework.util.MultiValueMap;",
            "import org.springframework.web.client.HttpClientErrorException;",
            "import org.springframework.web.client.RestTemplate;",
            "import org.thingsboard.common.util.JacksonUtil;",
            "import org.thingsboard.common.util.ThingsBoardExecutors;",
            "import org.thingsboard.rest.client.utils.RestJsonConverter;",
            "import org.thingsboard.server.common.data.AdminSettings;",
            "import org.thingsboard.server.common.data.ClaimRequest;",
            "import org.thingsboard.server.common.data.Customer;",
            "import org.thingsboard.server.common.data.Dashboard;",
            "import org.thingsboard.server.common.data.DashboardInfo;",
            "import org.thingsboard.server.common.data.Device;",
            "import org.thingsboard.server.common.data.DeviceInfo;",
            "import org.thingsboard.server.common.data.DeviceProfile;",
            "import org.thingsboard.server.common.data.DeviceProfileInfo;",
            "import org.thingsboard.server.common.data.DeviceTransportType;",
            "import org.thingsboard.server.common.data.EntityInfo;",
            "import org.thingsboard.server.common.data.EntitySubtype;",
            "import org.thingsboard.server.common.data.EntityType;",
            "import org.thingsboard.server.common.data.EntityView;",
            "import org.thingsboard.server.common.data.EntityViewInfo;",
            "import org.thingsboard.server.common.data.EventInfo;",
            "import org.thingsboard.server.common.data.ImageExportData;",
            "import org.thingsboard.server.common.data.OtaPackage;",
            "import org.thingsboard.server.common.data.OtaPackageInfo;",
            "import org.thingsboard.server.common.data.SaveDeviceWithCredentialsRequest;",
            "import org.thingsboard.server.common.data.StringUtils;",
            "import org.thingsboard.server.common.data.SystemInfo;",
            "import org.thingsboard.server.common.data.TbImageDeleteResult;",
            "import org.thingsboard.server.common.data.TbResource;",
            "import org.thingsboard.server.common.data.TbResourceInfo;",
            "import org.thingsboard.server.common.data.Tenant;",
            "import org.thingsboard.server.common.data.TenantInfo;",
            "import org.thingsboard.server.common.data.TenantProfile;",
            "import org.thingsboard.server.common.data.UpdateMessage;",
            "import org.thingsboard.server.common.data.UsageInfo;",
            "import org.thingsboard.server.common.data.User;",
            "import org.thingsboard.server.common.data.UserEmailInfo;",
            "import org.thingsboard.server.common.data.alarm.Alarm;",
            "import org.thingsboard.server.common.data.alarm.AlarmComment;",
            "import org.thingsboard.server.common.data.alarm.AlarmCommentInfo;",
            "import org.thingsboard.server.common.data.alarm.AlarmInfo;",
            "import org.thingsboard.server.common.data.alarm.AlarmSearchStatus;",
            "import org.thingsboard.server.common.data.alarm.AlarmSeverity;",
            "import org.thingsboard.server.common.data.alarm.AlarmStatus;",
            "import org.thingsboard.server.common.data.asset.Asset;",
            "import org.thingsboard.server.common.data.asset.AssetInfo;",
            "import org.thingsboard.server.common.data.asset.AssetProfile;",
            "import org.thingsboard.server.common.data.asset.AssetProfileInfo;",
            "import org.thingsboard.server.common.data.asset.AssetSearchQuery;",
            "import org.thingsboard.server.common.data.audit.ActionType;",
            "import org.thingsboard.server.common.data.audit.AuditLog;",
            "import org.thingsboard.server.common.data.device.DeviceSearchQuery;",
            "import org.thingsboard.server.common.data.edge.Edge;",
            "import org.thingsboard.server.common.data.edge.EdgeEvent;",
            "import org.thingsboard.server.common.data.edge.EdgeInfo;",
            "import org.thingsboard.server.common.data.edge.EdgeInstructions;",
            "import org.thingsboard.server.common.data.edge.EdgeSearchQuery;",
            "import org.thingsboard.server.common.data.entityview.EntityViewSearchQuery;",
            "import org.thingsboard.server.common.data.id.AlarmCommentId;",
            "import org.thingsboard.server.common.data.id.AlarmId;",
            "import org.thingsboard.server.common.data.id.AssetId;",
            "import org.thingsboard.server.common.data.id.AssetProfileId;",
            "import org.thingsboard.server.common.data.id.CustomerId;",
            "import org.thingsboard.server.common.data.id.DashboardId;",
            "import org.thingsboard.server.common.data.id.DeviceId;",
            "import org.thingsboard.server.common.data.id.DeviceProfileId;",
            "import org.thingsboard.server.common.data.id.EdgeId;",
            "import org.thingsboard.server.common.data.id.EntityId;",
            "import org.thingsboard.server.common.data.id.EntityViewId;",
            "import org.thingsboard.server.common.data.id.OAuth2ClientRegistrationTemplateId;",
            "import org.thingsboard.server.common.data.id.OtaPackageId;",
            "import org.thingsboard.server.common.data.id.QueueId;",
            "import org.thingsboard.server.common.data.id.RuleChainId;",
            "import org.thingsboard.server.common.data.id.RuleNodeId;",
            "import org.thingsboard.server.common.data.id.TbResourceId;",
            "import org.thingsboard.server.common.data.id.TenantId;",
            "import org.thingsboard.server.common.data.id.TenantProfileId;",
            "import org.thingsboard.server.common.data.id.UserId;",
            "import org.thingsboard.server.common.data.id.WidgetTypeId;",
            "import org.thingsboard.server.common.data.id.WidgetsBundleId;",
            "import org.thingsboard.server.common.data.kv.Aggregation;",
            "import org.thingsboard.server.common.data.kv.AttributeKvEntry;",
            "import org.thingsboard.server.common.data.kv.TsKvEntry;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2ClientInfo;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2ClientRegistrationTemplate;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2Info;",
            "import org.thingsboard.server.common.data.oauth2.PlatformType;",
            "import org.thingsboard.server.common.data.ota.ChecksumAlgorithm;",
            "import org.thingsboard.server.common.data.ota.OtaPackageType;",
            "import org.thingsboard.server.common.data.page.PageData;",
            "import org.thingsboard.server.common.data.page.PageLink;",
            "import org.thingsboard.server.common.data.page.SortOrder;",
            "import org.thingsboard.server.common.data.page.TimePageLink;",
            "import org.thingsboard.server.common.data.plugin.ComponentDescriptor;",
            "import org.thingsboard.server.common.data.plugin.ComponentType;",
            "import org.thingsboard.server.common.data.query.AlarmCountQuery;",
            "import org.thingsboard.server.common.data.query.AlarmData;",
            "import org.thingsboard.server.common.data.query.AlarmDataQuery;",
            "import org.thingsboard.server.common.data.query.EntityCountQuery;",
            "import org.thingsboard.server.common.data.query.EntityData;",
            "import org.thingsboard.server.common.data.query.EntityDataQuery;",
            "import org.thingsboard.server.common.data.queue.Queue;",
            "import org.thingsboard.server.common.data.relation.EntityRelation;",
            "import org.thingsboard.server.common.data.relation.EntityRelationInfo;",
            "import org.thingsboard.server.common.data.relation.EntityRelationsQuery;",
            "import org.thingsboard.server.common.data.relation.RelationTypeGroup;",
            "import org.thingsboard.server.common.data.rule.DefaultRuleChainCreateRequest;",
            "import org.thingsboard.server.common.data.rule.RuleChain;",
            "import org.thingsboard.server.common.data.rule.RuleChainData;",
            "import org.thingsboard.server.common.data.rule.RuleChainMetaData;",
            "import org.thingsboard.server.common.data.rule.RuleChainType;",
            "import org.thingsboard.server.common.data.security.DeviceCredentials;",
            "import org.thingsboard.server.common.data.security.DeviceCredentialsType;",
            "import org.thingsboard.server.common.data.security.model.JwtPair;",
            "import org.thingsboard.server.common.data.security.model.JwtSettings;",
            "import org.thingsboard.server.common.data.security.model.SecuritySettings;",
            "import org.thingsboard.server.common.data.security.model.UserPasswordPolicy;",
            "import org.thingsboard.server.common.data.sms.config.TestSmsRequest;",
            "import org.thingsboard.server.common.data.sync.ie.importing.csv.BulkImportRequest;",
            "import org.thingsboard.server.common.data.sync.ie.importing.csv.BulkImportResult;",
            "import org.thingsboard.server.common.data.sync.vc.AutoCommitSettings;",
            "import org.thingsboard.server.common.data.sync.vc.BranchInfo;",
            "import org.thingsboard.server.common.data.sync.vc.EntityDataDiff;",
            "import org.thingsboard.server.common.data.sync.vc.EntityDataInfo;",
            "import org.thingsboard.server.common.data.sync.vc.EntityVersion;",
            "import org.thingsboard.server.common.data.sync.vc.RepositorySettings;",
            "import org.thingsboard.server.common.data.sync.vc.VersionCreationResult;",
            "import org.thingsboard.server.common.data.sync.vc.VersionLoadResult;",
            "import org.thingsboard.server.common.data.sync.vc.VersionedEntityInfo;",
            "import org.thingsboard.server.common.data.sync.vc.request.create.VersionCreateRequest;",
            "import org.thingsboard.server.common.data.sync.vc.request.load.VersionLoadRequest;",
            "import org.thingsboard.server.common.data.widget.DeprecatedFilter;",
            "import org.thingsboard.server.common.data.widget.WidgetType;",
            "import org.thingsboard.server.common.data.widget.WidgetTypeDetails;",
            "import org.thingsboard.server.common.data.widget.WidgetTypeInfo;",
            "import org.thingsboard.server.common.data.widget.WidgetsBundle;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.net.URI;",
            "import java.util.Collections;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Optional;",
            "import java.util.UUID;",
            "import java.util.concurrent.ExecutorService;",
            "import java.util.concurrent.Future;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.stream.Collectors;",
            "import static org.thingsboard.server.common.data.StringUtils.isEmpty;"
        ],
        "reference_api": [
            "getStatusCode",
            "getForEntity",
            "getBody",
            "ofNullable",
            "getId",
            "empty"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getStatusCode",
            "getForEntity",
            "getBody",
            "ofNullable",
            "getId",
            "empty"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "thingsboard/thingsboard",
        "function_declaration": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)",
        "start_line": "1322",
        "end_line": "1334",
        "file_path": "rest-client/src/main/java/org/thingsboard/rest/client/RestClient.java",
        "docstring": "The function \"saveDeviceWithCredentials\" saves a device along with its credentials by sending a POST request to the \"/api/device-with-credentials\" endpoint.\\nIt creates a request object containing the device and its credentials, and attempts to send this request.\\nIf successful, it returns an Optional containing the saved device.\\nIf a 404 error occurs, it returns an empty Optional; otherwise, it rethrows any other exceptions encountered.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "20f3aaf882c2",
        "ground_truth": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials) {\n    try {\n        SaveDeviceWithCredentialsRequest request = new SaveDeviceWithCredentialsRequest(device, credentials);\n        ResponseEntity<Device> deviceOpt = restTemplate.postForEntity(baseURL + \"/api/device-with-credentials\", request, Device.class);\n        return Optional.ofNullable(deviceOpt.getBody());\n    } catch (HttpClientErrorException exception) {\n        if (exception.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw exception;\n        }\n    }\n}",
        "import_statements": [
            "import com.auth0.jwt.JWT;",
            "import com.fasterxml.jackson.databind.JsonNode;",
            "import com.fasterxml.jackson.databind.node.ObjectNode;",
            "import com.google.common.base.Strings;",
            "import org.apache.commons.io.IOUtils;",
            "import org.springframework.core.ParameterizedTypeReference;",
            "import org.springframework.core.io.ByteArrayResource;",
            "import org.springframework.core.io.Resource;",
            "import org.springframework.http.HttpEntity;",
            "import org.springframework.http.HttpHeaders;",
            "import org.springframework.http.HttpMethod;",
            "import org.springframework.http.HttpRequest;",
            "import org.springframework.http.HttpStatus;",
            "import org.springframework.http.MediaType;",
            "import org.springframework.http.ResponseEntity;",
            "import org.springframework.http.client.support.HttpRequestWrapper;",
            "import org.springframework.util.CollectionUtils;",
            "import org.springframework.util.LinkedMultiValueMap;",
            "import org.springframework.util.MultiValueMap;",
            "import org.springframework.web.client.HttpClientErrorException;",
            "import org.springframework.web.client.RestTemplate;",
            "import org.thingsboard.common.util.JacksonUtil;",
            "import org.thingsboard.common.util.ThingsBoardExecutors;",
            "import org.thingsboard.rest.client.utils.RestJsonConverter;",
            "import org.thingsboard.server.common.data.AdminSettings;",
            "import org.thingsboard.server.common.data.ClaimRequest;",
            "import org.thingsboard.server.common.data.Customer;",
            "import org.thingsboard.server.common.data.Dashboard;",
            "import org.thingsboard.server.common.data.DashboardInfo;",
            "import org.thingsboard.server.common.data.Device;",
            "import org.thingsboard.server.common.data.DeviceInfo;",
            "import org.thingsboard.server.common.data.DeviceProfile;",
            "import org.thingsboard.server.common.data.DeviceProfileInfo;",
            "import org.thingsboard.server.common.data.DeviceTransportType;",
            "import org.thingsboard.server.common.data.EntityInfo;",
            "import org.thingsboard.server.common.data.EntitySubtype;",
            "import org.thingsboard.server.common.data.EntityType;",
            "import org.thingsboard.server.common.data.EntityView;",
            "import org.thingsboard.server.common.data.EntityViewInfo;",
            "import org.thingsboard.server.common.data.EventInfo;",
            "import org.thingsboard.server.common.data.ImageExportData;",
            "import org.thingsboard.server.common.data.OtaPackage;",
            "import org.thingsboard.server.common.data.OtaPackageInfo;",
            "import org.thingsboard.server.common.data.SaveDeviceWithCredentialsRequest;",
            "import org.thingsboard.server.common.data.StringUtils;",
            "import org.thingsboard.server.common.data.SystemInfo;",
            "import org.thingsboard.server.common.data.TbImageDeleteResult;",
            "import org.thingsboard.server.common.data.TbResource;",
            "import org.thingsboard.server.common.data.TbResourceInfo;",
            "import org.thingsboard.server.common.data.Tenant;",
            "import org.thingsboard.server.common.data.TenantInfo;",
            "import org.thingsboard.server.common.data.TenantProfile;",
            "import org.thingsboard.server.common.data.UpdateMessage;",
            "import org.thingsboard.server.common.data.UsageInfo;",
            "import org.thingsboard.server.common.data.User;",
            "import org.thingsboard.server.common.data.UserEmailInfo;",
            "import org.thingsboard.server.common.data.alarm.Alarm;",
            "import org.thingsboard.server.common.data.alarm.AlarmComment;",
            "import org.thingsboard.server.common.data.alarm.AlarmCommentInfo;",
            "import org.thingsboard.server.common.data.alarm.AlarmInfo;",
            "import org.thingsboard.server.common.data.alarm.AlarmSearchStatus;",
            "import org.thingsboard.server.common.data.alarm.AlarmSeverity;",
            "import org.thingsboard.server.common.data.alarm.AlarmStatus;",
            "import org.thingsboard.server.common.data.asset.Asset;",
            "import org.thingsboard.server.common.data.asset.AssetInfo;",
            "import org.thingsboard.server.common.data.asset.AssetProfile;",
            "import org.thingsboard.server.common.data.asset.AssetProfileInfo;",
            "import org.thingsboard.server.common.data.asset.AssetSearchQuery;",
            "import org.thingsboard.server.common.data.audit.ActionType;",
            "import org.thingsboard.server.common.data.audit.AuditLog;",
            "import org.thingsboard.server.common.data.device.DeviceSearchQuery;",
            "import org.thingsboard.server.common.data.edge.Edge;",
            "import org.thingsboard.server.common.data.edge.EdgeEvent;",
            "import org.thingsboard.server.common.data.edge.EdgeInfo;",
            "import org.thingsboard.server.common.data.edge.EdgeInstructions;",
            "import org.thingsboard.server.common.data.edge.EdgeSearchQuery;",
            "import org.thingsboard.server.common.data.entityview.EntityViewSearchQuery;",
            "import org.thingsboard.server.common.data.id.AlarmCommentId;",
            "import org.thingsboard.server.common.data.id.AlarmId;",
            "import org.thingsboard.server.common.data.id.AssetId;",
            "import org.thingsboard.server.common.data.id.AssetProfileId;",
            "import org.thingsboard.server.common.data.id.CustomerId;",
            "import org.thingsboard.server.common.data.id.DashboardId;",
            "import org.thingsboard.server.common.data.id.DeviceId;",
            "import org.thingsboard.server.common.data.id.DeviceProfileId;",
            "import org.thingsboard.server.common.data.id.EdgeId;",
            "import org.thingsboard.server.common.data.id.EntityId;",
            "import org.thingsboard.server.common.data.id.EntityViewId;",
            "import org.thingsboard.server.common.data.id.OAuth2ClientRegistrationTemplateId;",
            "import org.thingsboard.server.common.data.id.OtaPackageId;",
            "import org.thingsboard.server.common.data.id.QueueId;",
            "import org.thingsboard.server.common.data.id.RuleChainId;",
            "import org.thingsboard.server.common.data.id.RuleNodeId;",
            "import org.thingsboard.server.common.data.id.TbResourceId;",
            "import org.thingsboard.server.common.data.id.TenantId;",
            "import org.thingsboard.server.common.data.id.TenantProfileId;",
            "import org.thingsboard.server.common.data.id.UserId;",
            "import org.thingsboard.server.common.data.id.WidgetTypeId;",
            "import org.thingsboard.server.common.data.id.WidgetsBundleId;",
            "import org.thingsboard.server.common.data.kv.Aggregation;",
            "import org.thingsboard.server.common.data.kv.AttributeKvEntry;",
            "import org.thingsboard.server.common.data.kv.TsKvEntry;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2ClientInfo;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2ClientRegistrationTemplate;",
            "import org.thingsboard.server.common.data.oauth2.OAuth2Info;",
            "import org.thingsboard.server.common.data.oauth2.PlatformType;",
            "import org.thingsboard.server.common.data.ota.ChecksumAlgorithm;",
            "import org.thingsboard.server.common.data.ota.OtaPackageType;",
            "import org.thingsboard.server.common.data.page.PageData;",
            "import org.thingsboard.server.common.data.page.PageLink;",
            "import org.thingsboard.server.common.data.page.SortOrder;",
            "import org.thingsboard.server.common.data.page.TimePageLink;",
            "import org.thingsboard.server.common.data.plugin.ComponentDescriptor;",
            "import org.thingsboard.server.common.data.plugin.ComponentType;",
            "import org.thingsboard.server.common.data.query.AlarmCountQuery;",
            "import org.thingsboard.server.common.data.query.AlarmData;",
            "import org.thingsboard.server.common.data.query.AlarmDataQuery;",
            "import org.thingsboard.server.common.data.query.EntityCountQuery;",
            "import org.thingsboard.server.common.data.query.EntityData;",
            "import org.thingsboard.server.common.data.query.EntityDataQuery;",
            "import org.thingsboard.server.common.data.queue.Queue;",
            "import org.thingsboard.server.common.data.relation.EntityRelation;",
            "import org.thingsboard.server.common.data.relation.EntityRelationInfo;",
            "import org.thingsboard.server.common.data.relation.EntityRelationsQuery;",
            "import org.thingsboard.server.common.data.relation.RelationTypeGroup;",
            "import org.thingsboard.server.common.data.rule.DefaultRuleChainCreateRequest;",
            "import org.thingsboard.server.common.data.rule.RuleChain;",
            "import org.thingsboard.server.common.data.rule.RuleChainData;",
            "import org.thingsboard.server.common.data.rule.RuleChainMetaData;",
            "import org.thingsboard.server.common.data.rule.RuleChainType;",
            "import org.thingsboard.server.common.data.security.DeviceCredentials;",
            "import org.thingsboard.server.common.data.security.DeviceCredentialsType;",
            "import org.thingsboard.server.common.data.security.model.JwtPair;",
            "import org.thingsboard.server.common.data.security.model.JwtSettings;",
            "import org.thingsboard.server.common.data.security.model.SecuritySettings;",
            "import org.thingsboard.server.common.data.security.model.UserPasswordPolicy;",
            "import org.thingsboard.server.common.data.sms.config.TestSmsRequest;",
            "import org.thingsboard.server.common.data.sync.ie.importing.csv.BulkImportRequest;",
            "import org.thingsboard.server.common.data.sync.ie.importing.csv.BulkImportResult;",
            "import org.thingsboard.server.common.data.sync.vc.AutoCommitSettings;",
            "import org.thingsboard.server.common.data.sync.vc.BranchInfo;",
            "import org.thingsboard.server.common.data.sync.vc.EntityDataDiff;",
            "import org.thingsboard.server.common.data.sync.vc.EntityDataInfo;",
            "import org.thingsboard.server.common.data.sync.vc.EntityVersion;",
            "import org.thingsboard.server.common.data.sync.vc.RepositorySettings;",
            "import org.thingsboard.server.common.data.sync.vc.VersionCreationResult;",
            "import org.thingsboard.server.common.data.sync.vc.VersionLoadResult;",
            "import org.thingsboard.server.common.data.sync.vc.VersionedEntityInfo;",
            "import org.thingsboard.server.common.data.sync.vc.request.create.VersionCreateRequest;",
            "import org.thingsboard.server.common.data.sync.vc.request.load.VersionLoadRequest;",
            "import org.thingsboard.server.common.data.widget.DeprecatedFilter;",
            "import org.thingsboard.server.common.data.widget.WidgetType;",
            "import org.thingsboard.server.common.data.widget.WidgetTypeDetails;",
            "import org.thingsboard.server.common.data.widget.WidgetTypeInfo;",
            "import org.thingsboard.server.common.data.widget.WidgetsBundle;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.net.URI;",
            "import java.util.Collections;",
            "import java.util.HashMap;",
            "import java.util.List;",
            "import java.util.Map;",
            "import java.util.Optional;",
            "import java.util.UUID;",
            "import java.util.concurrent.ExecutorService;",
            "import java.util.concurrent.Future;",
            "import java.util.concurrent.TimeUnit;",
            "import java.util.stream.Collectors;",
            "import static org.thingsboard.server.common.data.StringUtils.isEmpty;"
        ],
        "reference_api": [
            "getStatusCode",
            "getBody",
            "ofNullable",
            "empty",
            "postForEntity"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getStatusCode",
            "getBody",
            "ofNullable",
            "empty",
            "postForEntity"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "rwaldron/johnny-five",
        "function_declaration": "brightness(addr, val)",
        "start_line": "312",
        "end_line": "322",
        "file_path": "lib/led/ledcontrol.js",
        "docstring": "The function \"brightness\" adjusts the brightness of LED devices.\\nIf only one argument is provided, it sets the brightness for all devices to the given value.\\nIf two arguments are provided, it sets the brightness for the specified device address to the given value, mapped from a percentage (0-100) to a scale used by the LED controller (0-15).\\nThe function returns the context object for method chaining.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f9af0a32ce24",
        "ground_truth": "brightness(addr, val) {\n  if (arguments.length === 1) {\n    val = addr;\n    this.each(function(device) {\n      this.brightness(device, val);\n    });\n  } else {\n    this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n  }\n  return this;\n}",
        "import_statements": [],
        "reference_api": [
            "brightness",
            "this.each",
            "this.send",
            "this.brightness",
            "Board.map"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "brightness",
                "code": "brightness(addr, val) {\n    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }"
            },
            {
                "name": "this.each",
                "code": "each(callbackfn) {\n    for (let i = 0; i < this.devices; i++) {\n      callbackfn.call(this, i);\n    }\n  }"
            },
            {
                "name": "this.brightness",
                "code": "brightness(addr, val) {\n    if (arguments.length === 1) {\n      val = addr;\n      this.each(function(device) {\n        this.brightness(device, val);\n      });\n    } else {\n      this.send(addr, this.OP.BRIGHTNESS || LedControl.OP.BRIGHTNESS, Board.map(val, 0, 100, 0, 15));\n    }\n    return this;\n  }"
            }
        ],
        "third_party": [
            "this.send",
            "Board.map"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "rwaldron/johnny-five",
        "function_declaration": "device(addr)",
        "start_line": "411",
        "end_line": "426",
        "file_path": "lib/led/ledcontrol.js",
        "docstring": "The function \"device\" creates an object with methods bound to a specific address.\\nIt iterates over the keys from the prototype of \"LedControl\" and the own properties of the current object, binding each function to the given address.\\nThe resulting object with bound methods is then returned.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b5d7fcf10695",
        "ground_truth": "device(addr) {\n  const bound = {};\n  /* keys from prototype */\n  Object.keys(LedControl.prototype).forEach(key => {\n    bound[key] = this[key].bind(this, addr);\n  });\n  /* functions from interface */\n  Object.getOwnPropertyNames(this).forEach(key => {\n    if (this[key] && typeof this[key] === \"function\") {\n      bound[key] = this[key].bind(this, addr);\n    }\n  });\n  return bound;\n}",
        "import_statements": [],
        "reference_api": [
            "Object.getOwnPropertyNames(this).forEach",
            "Object.getOwnPropertyNames",
            "this[key].bind",
            "Object.keys(LedControl.prototype).forEach",
            "device",
            "Object.keys"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "device",
                "code": "device(addr) {\n    const bound = {};\n\n    /* keys from prototype */\n    Object.keys(LedControl.prototype).forEach(key => {\n      bound[key] = this[key].bind(this, addr);\n    });\n\n    /* functions from interface */\n    Object.getOwnPropertyNames(this).forEach(key => {\n      if (this[key] && typeof this[key] === \"function\") {\n        bound[key] = this[key].bind(this, addr);\n      }\n    });\n    return bound;\n  }"
            }
        ],
        "third_party": [
            "Object.getOwnPropertyNames(this).forEach",
            "Object.getOwnPropertyNames",
            "this[key].bind",
            "Object.keys(LedControl.prototype).forEach"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "rwaldron/johnny-five",
        "function_declaration": "Collection.installCallbackReconciliation = (target, methods) => ",
        "start_line": "157",
        "end_line": "190",
        "file_path": "lib/mixins/collection.js",
        "docstring": "The function \"installCallbackReconciliation\" adds callback reconciliation methods to a target object for a given list of methods.\\nFor each specified method, it creates a function that schedules the method to be called on each element in the collection, with a specified duration and callback.\\nIf the duration is not provided, it defaults to 1000 milliseconds.\\nIt ensures the callback is a function, collects promises for each method call, and invokes the callback once all promises are resolved.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7eeebfcd0176",
        "ground_truth": "Collection.installCallbackReconciliation = (target, methods) => {\n  // Methods with callbacks need to have the callback called\n  // as a result of all entries reaching completion, not\n  // calling the callback once for each entry completion.\n  // Uses an array to match pattern in Led, and may be more\n  // in future.\n  methods.forEach(method => {\n    target[method] = function(duration, callback) {\n      const length = this.length;\n      const signals = [];\n       if (typeof duration === \"function\") {\n        callback = duration;\n        duration = 1000;\n      }\n       if (typeof callback !== \"function\") {\n        callback = noop;\n      }\n       for (let i = 0; i < length; i++) {\n        signals.push(\n          /* jshint ignore:start */\n          new Promise(resolve => this[i][method](duration, () => resolve()))\n          /* jshint ignore:end */\n        );\n      }\n       Promise.all(signals).then(callback);\n       return this;\n    };\n  });\n};",
        "import_statements": [],
        "reference_api": [
            "this[i][method]",
            "resolve",
            "signals.push",
            "Promise.all",
            "Promise.all(signals).then"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this[i][method]",
            "resolve",
            "signals.push",
            "Promise.all(signals).then"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "rwaldron/johnny-five",
        "function_declaration": "listen()",
        "start_line": "315",
        "end_line": "333",
        "file_path": "lib/gps.js",
        "docstring": "The function \"listen\" reads data from a serial port and processes NMEA sentences.\\nIt initializes an empty input string and starts a read loop on the specified serial port.\\nAs data is received, it appends the data to the input string and splits it into sentences based on the \"\\r\\n\" delimiter.\\nIt processes all complete sentences by calling \"parseNmeaSentence\" for each one and retains any incomplete sentence for the next read.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f290c33a08e9",
        "ground_truth": "listen() {\n  const state = priv.get(this);\n  let input = \"\";\n  // Start the read loop\n  this.io.serialRead(state.portId, data => {\n    input += new Buffer(data).toString(\"ascii\");\n    const sentences = input.split(\"\\r\\n\");\n    if (sentences.length > 1) {\n      for (let i = 0; i < sentences.length - 1; i++) {\n        this.parseNmeaSentence(sentences[i]);\n      }\n      input = sentences[sentences.length - 1];\n    }\n  });\n}",
        "import_statements": [],
        "reference_api": [
            "input.split",
            "priv.get",
            "listen",
            "new Buffer(data).toString",
            "this.parseNmeaSentence",
            "this.io.serialRead"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "priv.get",
                "code": "get() {\n        const state = priv.get(this);\n        return state.frequency;\n      }"
            },
            {
                "name": "listen",
                "code": "listen() {\n\n    const state = priv.get(this);\n    let input = \"\";\n\n    // Start the read loop\n    this.io.serialRead(state.portId, data => {\n\n      input += new Buffer(data).toString(\"ascii\");\n      const sentences = input.split(\"\\r\\n\");\n\n      if (sentences.length > 1) {\n        for (let i = 0; i < sentences.length - 1; i++) {\n          this.parseNmeaSentence(sentences[i]);\n        }\n        input = sentences[sentences.length - 1];\n      }\n    });\n  }"
            },
            {
                "name": "this.parseNmeaSentence",
                "code": "parseNmeaSentence(sentence) {\n\n    const state = priv.get(this);\n    const cksum = sentence.split(\"*\");\n\n    // Check for valid sentence\n    if (cksum[1] !== getNmeaChecksum(cksum[0].substring(1))) {\n      return;\n    }\n\n    this.emit(\"sentence\", sentence);\n\n    const segments = cksum[0].split(\",\");\n    const last = {\n      latitude: state.latitude,\n      longitude: state.longitude,\n      altitude: state.altitude,\n      speed: state.speed,\n      course: state.course\n    };\n\n    switch (segments[0]) {\n      case \"$GPGGA\":\n        // Time, position and fix related data\n        state.time = segments[1];\n        state.latitude = degToDec(segments[2], 2, segments[3], this.fixed);\n        state.longitude = degToDec(segments[4], 3, segments[5], this.fixed);\n        state.altitude = Number(segments[9]);\n        break;\n\n      case \"$GPGSA\":\n        // Operating details\n        state.sat.satellites = segments.slice(3, 15);\n        state.sat.pdop = Number(segments[15]);\n        state.sat.hdop = Number(segments[16]);\n        state.sat.vdop = Number(segments[17]);\n        this.emit(\"operations\", sentence);\n        break;\n\n      case \"$GPRMC\":\n        // GPS & Transit data\n        state.time = segments[1];\n        state.latitude = degToDec(segments[3], 2, segments[4], this.fixed);\n        state.longitude = degToDec(segments[5], 3, segments[6], this.fixed);\n        state.course = Number(segments[8]);\n        state.speed = toFixed(segments[7] * 0.514444, this.fixed);\n        break;\n\n      case \"$GPVTG\":\n        // Track Made Good and Ground Speed\n        state.course = Number(segments[1]);\n        state.speed = toFixed(segments[5] * 0.514444, this.fixed);\n        break;\n\n      case \"$GPGSV\":\n        // Satellites in view\n        break;\n\n      case \"$PGACK\":\n        // Acknowledge command\n        this.emit(\"acknowledge\", sentence);\n        break;\n\n      default:\n        this.emit(\"unknown\", sentence);\n        break;\n    }\n\n    this.emit(\"data\", {\n      latitude: state.latitude,\n      longitude: state.longitude,\n      altitude: state.altitude,\n      speed: state.speed,\n      course: state.course,\n      sat: state.sat,\n      time: state.time\n    });\n\n    if (last.latitude !== state.latitude ||\n      last.longitude !== state.longitude ||\n      last.altitude !== state.altitude) {\n\n      this.emit(\"change\", {\n        latitude: state.latitude,\n        longitude: state.longitude,\n        altitude: state.altitude\n      });\n    }\n\n    if (last.speed !== state.speed ||\n      last.course !== state.course) {\n\n      this.emit(\"navigation\", {\n        speed: state.speed,\n        course: state.course\n      });\n    }\n\n  }"
            }
        ],
        "third_party": [
            "input.split",
            "new Buffer(data).toString",
            "this.io.serialRead"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)",
        "start_line": "63",
        "end_line": "77",
        "file_path": "drivers/adc/adc_ad559x.c",
        "docstring": "The function \"adc_ad559x_validate_buffer_size\" validates the buffer size for an ADC sequence.\\nIt calculates the number of active channels and the needed buffer size based on the number of channels and the size of each data sample.\\nIf the provided buffer size is insufficient, it returns an error code indicating insufficient memory; otherwise, it returns 0 indicating success.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ec7b00323130",
        "ground_truth": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n        const struct adc_sequence *sequence)\n{\n uint8_t channels;\n size_t needed;\n  channels = POPCOUNT(sequence->channels);\n needed = channels * sizeof(uint16_t);\n  if (sequence->buffer_size < needed) {\n  return -ENOMEM;\n }\n  return 0;\n}",
        "import_statements": [
            "#include <zephyr/drivers/adc.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/drivers/mfd/ad559x.h>\n",
            "#include \"adc_context.h\"\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "POPCOUNT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "POPCOUNT"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)",
        "start_line": "79",
        "end_line": "104",
        "file_path": "drivers/adc/adc_ad559x.c",
        "docstring": "The function \"adc_ad559x_start_read\" initiates an ADC read operation for the AD559x device.\\nIt first checks if the resolution of the ADC sequence matches the expected resolution and if the specified channels are valid.\\nIf these checks fail, it logs an error and returns an invalid argument error.\\nIt then validates the buffer size for the ADC read and logs an error if the buffer is insufficient.\\nIf all checks pass, it sets the buffer, starts the ADC read context, and waits for the read operation to complete, returning the result.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ef1d8bcd8c32",
        "ground_truth": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\n{\n struct adc_ad559x_data *data = dev->data;\n int ret;\n  if (sequence->resolution != AD559X_ADC_RESOLUTION) {\n  LOG_ERR(\"invalid resolution %d\", sequence->resolution);\n  return -EINVAL;\n }\n  if (find_msb_set(sequence->channels) > AD559X_PIN_MAX) {\n  LOG_ERR(\"invalid channels in mask: 0x%08x\", sequence->channels);\n  return -EINVAL;\n }\n  ret = adc_ad559x_validate_buffer_size(dev, sequence);\n if (ret < 0) {\n  LOG_ERR(\"insufficient buffer size\");\n  return ret;\n }\n  data->buffer = sequence->buffer;\n adc_context_start_read(&data->ctx, sequence);\n  return adc_context_wait_for_completion(&data->ctx);\n}",
        "import_statements": [
            "#include <zephyr/drivers/adc.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/drivers/mfd/ad559x.h>\n",
            "#include \"adc_context.h\"\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "adc_context_start_read",
            "find_msb_set",
            "adc_context_wait_for_completion",
            "adc_ad559x_validate_buffer_size",
            "LOG_ERR"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "adc_ad559x_validate_buffer_size",
                "code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\n{\n\tuint8_t channels;\n\tsize_t needed;\n\n\tchannels = POPCOUNT(sequence->channels);\n\tneeded = channels * sizeof(uint16_t);\n\n\tif (sequence->buffer_size < needed) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
            }
        ],
        "third_party": [
            "adc_context_start_read",
            "find_msb_set",
            "adc_context_wait_for_completion",
            "LOG_ERR"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static void adc_context_start_sampling(struct adc_context *ctx)",
        "start_line": "173",
        "end_line": "181",
        "file_path": "drivers/adc/adc_ad559x.c",
        "docstring": "The function \"adc_context_start_sampling\" initiates ADC sampling for a given context.\\nIt retrieves the ADC data structure from the context, sets the channels to be sampled, and initializes the repeat buffer with the data buffer.\\nFinally, it releases a semaphore to signal the start of sampling.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "340abb79f057",
        "ground_truth": "static void adc_context_start_sampling(struct adc_context *ctx)\n{\n struct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n  data->channels = ctx->sequence.channels;\n data->repeat_buffer = data->buffer;\n  k_sem_give(&data->sem);\n}",
        "import_statements": [
            "#include <zephyr/drivers/adc.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/drivers/mfd/ad559x.h>\n",
            "#include \"adc_context.h\"\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "CONTAINER_OF",
            "k_sem_give"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "CONTAINER_OF",
            "k_sem_give"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)",
        "start_line": "183",
        "end_line": "190",
        "file_path": "drivers/adc/adc_ad559x.c",
        "docstring": "The function \"adc_context_update_buffer_pointer\" updates the buffer pointer in the ADC context.\\nIt retrieves the ADC data container from the context and, if repeat sampling is enabled, sets the buffer pointer to the repeat buffer.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "448704e208e1",
        "ground_truth": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\n{\n struct adc_ad559x_data *data = CONTAINER_OF(ctx, struct adc_ad559x_data, ctx);\n  if (repeat_sampling) {\n  data->buffer = data->repeat_buffer;\n }\n}",
        "import_statements": [
            "#include <zephyr/drivers/adc.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/drivers/mfd/ad559x.h>\n",
            "#include \"adc_context.h\"\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "CONTAINER_OF"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "CONTAINER_OF"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)",
        "start_line": "192",
        "end_line": "217",
        "file_path": "drivers/adc/adc_ad559x.c",
        "docstring": "The function \"adc_ad559x_acquisition_thread\" continuously acquires data from ADC channels in a loop.\\nIt waits for a semaphore to be released, then iterates through the active channels.\\nFor each channel, it reads the ADC value and stores the result in a buffer.\\nIf reading from a channel fails, it logs an error and marks the ADC context as complete.\\nAfter all channels are read, it signals that the sampling is done.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d2f0366c9355",
        "ground_truth": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\n{\n uint16_t result;\n uint8_t channel;\n int ret;\n  while (true) {\n  k_sem_take(&data->sem, K_FOREVER);\n   while (data->channels != 0) {\n   channel = find_lsb_set(data->channels) - 1;\n    ret = adc_ad559x_read_channel(data->dev, channel, &result);\n   if (ret < 0) {\n    LOG_ERR(\"failed to read channel %d (ret %d)\", channel, ret);\n    adc_context_complete(&data->ctx, ret);\n    break;\n   }\n    *data->buffer++ = result;\n   WRITE_BIT(data->channels, channel, 0);\n  }\n   adc_context_on_sampling_done(&data->ctx, data->dev);\n }\n}",
        "import_statements": [
            "#include <zephyr/drivers/adc.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/drivers/mfd/ad559x.h>\n",
            "#include \"adc_context.h\"\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "find_lsb_set",
            "k_sem_take",
            "adc_ad559x_read_channel",
            "WRITE_BIT",
            "adc_context_on_sampling_done",
            "LOG_ERR",
            "adc_context_complete"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "adc_ad559x_read_channel",
                "code": "static int adc_ad559x_read_channel(const struct device *dev, uint8_t channel, uint16_t *result)\n{\n\tconst struct adc_ad559x_config *config = dev->config;\n\tuint16_t val;\n\tuint8_t conv_channel;\n\tint ret;\n\n\t/* Select channel */\n\tret = mfd_ad559x_write_reg(config->mfd_dev, AD559X_REG_SEQ_ADC, BIT(channel));\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (mfd_ad559x_has_pointer_byte_map(config->mfd_dev)) {\n\t\t/* Start readback */\n\t\tval = AD559X_ADC_RD_POINTER;\n\t\tret = mfd_ad559x_write_raw(config->mfd_dev, (uint8_t *)&val,\n\t\t\t\t\t   AD559X_ADC_RD_POINTER_SIZE);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Read channel */\n\t\tret = mfd_ad559x_read_raw(config->mfd_dev, (uint8_t *)&val, sizeof(val));\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Invalid data:\n\t\t * See Figure 46. Single-Channel ADC Conversion Sequence.\n\t\t * The first conversion result always returns invalid data.\n\t\t */\n\t\t(void)mfd_ad559x_read_raw(config->mfd_dev, (uint8_t *)&val, sizeof(val));\n\n\t\tret = mfd_ad559x_read_raw(config->mfd_dev, (uint8_t *)&val, sizeof(val));\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tval = sys_be16_to_cpu(val);\n\n\t/*\n\t * Invalid data:\n\t * See AD5592 \"ADC section\" in \"Theory of operation\" chapter.\n\t * Valid ADC result has MSB bit set to 0.\n\t */\n\tif ((val & AD559X_ADC_RES_IND_BIT) != 0) {\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Invalid channel converted:\n\t * See AD5592 \"ADC section\" in \"Theory of operation\" chapter.\n\t * Conversion result contains channel number which should match requested channel.\n\t */\n\tconv_channel = FIELD_GET(AD559X_ADC_RES_CHAN_MASK, val);\n\tif (conv_channel != channel) {\n\t\treturn -EIO;\n\t}\n\n\t*result = val & AD559X_ADC_RES_VAL_MASK;\n\n\treturn 0;\n}"
            }
        ],
        "third_party": [
            "find_lsb_set",
            "k_sem_take",
            "WRITE_BIT",
            "adc_context_on_sampling_done",
            "LOG_ERR",
            "adc_context_complete"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int ads1112_wait_data_ready(const struct device *dev)",
        "start_line": "150",
        "end_line": "173",
        "file_path": "drivers/adc/adc_ads1112.c",
        "docstring": "The function \"ads1112_wait_data_ready\" waits for the ADS1112 device to be ready for data reading.\\nIt puts the current thread to sleep for the device's specified ready time, then reads the configuration register to check the status.\\nIf the device is not ready, it repeatedly sleeps for 100 microseconds and checks the status again until the device is ready.\\nIf an error occurs during register reading, it returns the error code; otherwise, it returns 0 when the device is ready.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f1cb41e44045",
        "ground_truth": "static int ads1112_wait_data_ready(const struct device *dev)\n{\n int rc;\n struct ads1112_data *data = dev->data;\n  k_sleep(data->ready_time);\n uint8_t status = 0;\n  rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &status);\n if (rc != 0) {\n  return rc;\n }\n  while ((status & ADS1112_CONFIG_MASK_READY) == 0) {\n   k_sleep(K_USEC(100));\n  rc = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &status);\n  if (rc != 0) {\n   return rc;\n  }\n }\n  return 0;\n}",
        "import_statements": [
            "#include <zephyr/device.h>\n",
            "#include <zephyr/devicetree.h>\n",
            "#include <zephyr/drivers/adc.h>\n",
            "#include <zephyr/drivers/i2c.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/sys/util.h>\n",
            "#include \"adc_context.h\"\n"
        ],
        "reference_api": [
            "K_USEC",
            "ads1112_read_reg",
            "k_sleep"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ads1112_read_reg",
                "code": "static int ads1112_read_reg(const struct device *dev, enum ads1112_reg reg_addr, uint8_t *reg_val)\n{\n\tconst struct ads1112_config *config = dev->config;\n\tuint8_t buf[3] = {0};\n\tint rc = i2c_read_dt(&config->bus, buf, sizeof(buf));\n\n\tif (reg_addr == ADS1112_REG_OUTPUT) {\n\t\treg_val[0] = buf[0];\n\t\treg_val[1] = buf[1];\n\t} else {\n\t\treg_val[0] = buf[2];\n\t}\n\n\treturn rc;\n}"
            }
        ],
        "third_party": [
            "K_USEC",
            "k_sleep"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)",
        "start_line": "248",
        "end_line": "262",
        "file_path": "drivers/adc/adc_ads1112.c",
        "docstring": "The function \"ads1112_validate_buffer_size\" checks if the buffer size in an ADC sequence is sufficient.\\nIt calculates the required buffer size based on the number of samplings, including any extra samplings specified in the sequence options.\\nIf the buffer size is less than the required size, it logs an error message and returns an error code; otherwise, it returns 0 indicating the buffer size is sufficient.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "01f9112959db",
        "ground_truth": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\n{\n size_t needed = sizeof(int16_t);\n  if (sequence->options) {\n  needed *= (1 + sequence->options->extra_samplings);\n }\n  if (sequence->buffer_size < needed) {\n  LOG_ERR(\"Insufficient buffer %i < %i\", sequence->buffer_size, needed);\n  return -ENOMEM;\n }\n  return 0;\n}",
        "import_statements": [
            "#include <zephyr/device.h>\n",
            "#include <zephyr/devicetree.h>\n",
            "#include <zephyr/drivers/adc.h>\n",
            "#include <zephyr/drivers/i2c.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/sys/util.h>\n",
            "#include \"adc_context.h\"\n"
        ],
        "reference_api": [
            "LOG_ERR"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "LOG_ERR"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)",
        "start_line": "298",
        "end_line": "317",
        "file_path": "drivers/adc/adc_ads1112.c",
        "docstring": "The function \"ads1112_adc_start_read\" initiates an ADC read operation for the ADS1112 device.\\nIt validates the ADC sequence and, if valid, assigns the sequence buffer to the device data.\\nIt then starts the ADC read context.\\nIf the wait flag is true, it waits for the read operation to complete before returning the result code.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9cda505dbdf6",
        "ground_truth": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n      bool wait)\n{\n int rc = 0;\n struct ads1112_data *data = dev->data;\n  rc = ads1112_validate_sequence(dev, sequence);\n if (rc != 0) {\n  return rc;\n }\n  data->buffer = sequence->buffer;\n  adc_context_start_read(&data->ctx, sequence);\n  if (wait) {\n  rc = adc_context_wait_for_completion(&data->ctx);\n }\n return rc;\n}",
        "import_statements": [
            "#include <zephyr/device.h>\n",
            "#include <zephyr/devicetree.h>\n",
            "#include <zephyr/drivers/adc.h>\n",
            "#include <zephyr/drivers/i2c.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/sys/util.h>\n",
            "#include \"adc_context.h\"\n"
        ],
        "reference_api": [
            "adc_context_wait_for_completion",
            "ads1112_validate_sequence",
            "adc_context_start_read"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ads1112_validate_sequence",
                "code": "static int ads1112_validate_sequence(const struct device *dev, const struct adc_sequence *sequence)\n{\n\tconst struct ads1112_data *data = dev->data;\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Invalid Channel 0x%x\", sequence->channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ads1112_validate_buffer_size(sequence);\n}"
            }
        ],
        "third_party": [
            "adc_context_wait_for_completion",
            "adc_context_start_read"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])",
        "start_line": "158",
        "end_line": "169",
        "file_path": "drivers/audio/codec_shell.c",
        "docstring": "The function \"cmd_apply_prop\" applies properties to an audio codec device.\\nIt retrieves the device based on an argument and checks if the device binding is successful.\\nIf the device is not found, it logs an error and returns an error code.\\nIf the device is found, it applies the audio codec properties to the device and returns the result of the operation.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3a203b1c5978",
        "ground_truth": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\n{\n const struct device *dev;\n  dev = device_get_binding(argv[args_indx.device]);\n if (!dev) {\n  shell_error(sh, \"Audio Codec device not found\");\n  return -ENODEV;\n }\n  return audio_codec_apply_properties(dev);\n}",
        "import_statements": [
            "#include <stdlib.h>\n",
            "#include <zephyr/shell/shell.h>\n",
            "#include <zephyr/audio/codec.h>\n"
        ],
        "reference_api": [
            "audio_codec_apply_properties",
            "device_get_binding",
            "shell_error"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "audio_codec_apply_properties",
            "device_get_binding",
            "shell_error"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)",
        "start_line": "55",
        "end_line": "92",
        "file_path": "drivers/audio/mpxxdtyy-i2s.c",
        "docstring": "The function \"mpxxdtyy_i2s_trigger\" handles the triggering of I2S commands for a given device based on the specified DMIC trigger command.\\nIt checks the current state of the device and sets the appropriate I2S command and state transition.\\nIt supports start and stop commands, ensuring the device transitions between configured and active states.\\nThe function sends the I2S command and updates the device state if successful; otherwise, it logs an error and returns the error code.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b295ed6b5753",
        "ground_truth": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\n{\n int ret;\n const struct mpxxdtyy_config *config = dev->config;\n struct mpxxdtyy_data *const data = dev->data;\n enum i2s_trigger_cmd i2s_cmd;\n enum dmic_state tmp_state;\n  switch (cmd) {\n case DMIC_TRIGGER_START:\n  if (data->state == DMIC_STATE_CONFIGURED) {\n   tmp_state = DMIC_STATE_ACTIVE;\n   i2s_cmd = I2S_TRIGGER_START;\n  } else {\n   return 0;\n  }\n  break;\n case DMIC_TRIGGER_STOP:\n  if (data->state == DMIC_STATE_ACTIVE) {\n   tmp_state = DMIC_STATE_CONFIGURED;\n   i2s_cmd = I2S_TRIGGER_STOP;\n  } else {\n   return 0;\n  }\n  break;\n default:\n  return -EINVAL;\n }\n  ret = i2s_trigger(config->comm_master, I2S_DIR_RX, i2s_cmd);\n if (ret != 0) {\n  LOG_ERR(\"trigger failed with %d error\", ret);\n  return ret;\n }\n  data->state = tmp_state;\n return 0;\n}",
        "import_statements": [
            "#include \"mpxxdtyy.h\"\n",
            "#include <zephyr/drivers/i2s.h>\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "i2s_trigger",
            "LOG_ERR"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "i2s_trigger",
            "LOG_ERR"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)",
        "start_line": "279",
        "end_line": "298",
        "file_path": "drivers/auxdisplay/auxdisplay_hd44780.c",
        "docstring": "The function \"auxdisplay_hd44780_set_display_mode\" configures the display mode of an HD44780 auxiliary display.\\nIt retrieves the configuration and data from the device and initializes the display mode command.\\nIt modifies the command based on the current cursor and position blink settings.\\nIf the display is enabled, it sets the corresponding flag.\\nFinally, it sends the command to the device to update the display mode.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "eee6d909504a",
        "ground_truth": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\n{\n const struct auxdisplay_hd44780_config *config = dev->config;\n struct auxdisplay_hd44780_data *data = dev->data;\n uint8_t cmd = AUXDISPLAY_HD44780_CMD_DISPLAY_MODE;\n  if (data->cursor_enabled) {\n  cmd |= AUXDISPLAY_HD44780_CURSOR_ENABLED;\n }\n  if (data->position_blink_enabled) {\n  cmd |= AUXDISPLAY_HD44780_POSITION_BLINK_ENABLED;\n }\n  if (enabled) {\n  cmd |= AUXDISPLAY_HD44780_DISPLAY_ENABLED;\n }\n  auxdisplay_hd44780_command(dev, false, cmd, config->capabilities.mode);\n}",
        "import_statements": [
            "#include <string.h>\n",
            "#include <zephyr/device.h>\n",
            "#include <zephyr/devicetree.h>\n",
            "#include <zephyr/drivers/auxdisplay.h>\n",
            "#include <zephyr/drivers/gpio.h>\n",
            "#include <zephyr/pm/device.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "auxdisplay_hd44780_command"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "auxdisplay_hd44780_command",
                "code": "static void auxdisplay_hd44780_command(const struct device *dev, bool rs, uint8_t cmd,\n\t\t\t\t       uint8_t mode)\n{\n\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tint8_t i = 7;\n\n\tif (mode == AUXDISPLAY_HD44780_MODE_8_BIT) {\n\t\twhile (i >= 0) {\n\t\t\tgpio_pin_set_dt(&config->db_gpios[i], ((cmd & BIT(i)) ? 1 : 0));\n\t\t\t--i;\n\t\t}\n\t} else {\n\t\twhile (i >= 4) {\n\t\t\tgpio_pin_set_dt(&config->db_gpios[i], ((cmd & BIT(i)) ? 1 : 0));\n\t\t\t--i;\n\t\t}\n\t}\n\n\tgpio_pin_set_dt(&config->rs_gpio, rs);\n\n\tif (config->rw_gpio.port) {\n\t\tgpio_pin_set_dt(&config->rw_gpio, 0);\n\t}\n\n\tgpio_pin_set_dt(&config->e_gpio, 1);\n\tk_sleep(K_USEC(config->enable_line_rise_delay));\n\tgpio_pin_set_dt(&config->e_gpio, 0);\n\tk_sleep(K_USEC(config->enable_line_fall_delay));\n\n\tif (mode == AUXDISPLAY_HD44780_MODE_4_BIT) {\n\t\twhile (i >= 0) {\n\t\t\tgpio_pin_set_dt(&config->db_gpios[(i + 4)], ((cmd & BIT(i)) ? 1 : 0));\n\t\t\t--i;\n\t\t}\n\n\t\tgpio_pin_set_dt(&config->e_gpio, 1);\n\t\tk_sleep(K_USEC(config->enable_line_rise_delay));\n\t\tgpio_pin_set_dt(&config->e_gpio, 0);\n\t\tk_sleep(K_USEC(config->enable_line_fall_delay));\n\t}\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int auxdisplay_itron_is_busy(const struct device *dev)",
        "start_line": "283",
        "end_line": "295",
        "file_path": "drivers/auxdisplay/auxdisplay_itron.c",
        "docstring": "The function \"auxdisplay_itron_is_busy\" checks if the auxiliary display device is busy.\\nIt retrieves the configuration for the device and checks if the busy GPIO port is defined.\\nIf the port is not defined, it returns an error code (-ENOTSUP).\\nOtherwise, it gets the status of the busy GPIO pin and returns the result.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dd0550888382",
        "ground_truth": "static int auxdisplay_itron_is_busy(const struct device *dev)\n{\n const struct auxdisplay_itron_config *config = dev->config;\n int rc;\n  if (config->busy_gpio.port == NULL) {\n  return -ENOTSUP;\n }\n  rc = gpio_pin_get_dt(&config->busy_gpio);\n  return rc;\n}",
        "import_statements": [
            "#include <string.h>\n",
            "#include <zephyr/device.h>\n",
            "#include <zephyr/devicetree.h>\n",
            "#include <zephyr/drivers/auxdisplay.h>\n",
            "#include <zephyr/drivers/gpio.h>\n",
            "#include <zephyr/drivers/uart.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include \"auxdisplay_itron.h\"\n"
        ],
        "reference_api": [
            "gpio_pin_get_dt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "gpio_pin_get_dt"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)",
        "start_line": "110",
        "end_line": "121",
        "file_path": "drivers/auxdisplay/auxdisplay_serlcd.c",
        "docstring": "The function \"auxdisplay_serlcd_send_special_command\" sends a special command to an LCD device via I2C.\\nIt constructs a buffer containing the special command prefix and the command itself, then writes this buffer to the device using the I2C bus.\\nAfter sending the command, it introduces a delay specified in the device configuration before returning the result of the I2C write operation.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "002c18770a96",
        "ground_truth": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n           const enum auxdisplay_serlcd_special_command command)\n{\n const struct auxdisplay_serlcd_config *config = dev->config;\n const uint8_t buffer[2] = {SERLCD_BEGIN_SPECIAL_COMMAND, command};\n  int rc = i2c_write_dt(&config->bus, buffer, sizeof(buffer));\n  k_sleep(K_MSEC(config->special_command_delay_ms));\n return rc;\n}",
        "import_statements": [
            "#include <stdlib.h>\n",
            "#include <string.h>\n",
            "#include <zephyr/device.h>\n",
            "#include <zephyr/devicetree.h>\n",
            "#include <zephyr/drivers/i2c.h>\n",
            "#include <zephyr/drivers/auxdisplay.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/sys/util.h>\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "i2c_write_dt",
            "K_MSEC",
            "k_sleep"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "i2c_write_dt",
            "K_MSEC",
            "k_sleep"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)",
        "start_line": "94",
        "end_line": "106",
        "file_path": "drivers/bbram/bbram_emul.c",
        "docstring": "The function \"bbram_emul_read\" reads data from a battery-backed RAM (BBRAM) emulator.\\nIt checks if the requested read size is valid and ensures the read operation does not exceed the memory bounds or involve invalid memory.\\nIf the checks pass, it copies the data from the specified offset in the device's memory to the provided buffer.\\nThe function returns 0 on success and an error code if any check fails.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2ca0632c091f",
        "ground_truth": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n      uint8_t *data)\n{\n const struct bbram_emul_config *config = dev->config;\n struct bbram_emul_data *dev_data = dev->data;\n  if (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n  return -EFAULT;\n }\n  memcpy(data, dev_data->data + offset, size);\n return 0;\n}",
        "import_statements": [
            "#include <zephyr/drivers/bbram.h>\n",
            "#include <string.h>\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "bbram_emul_check_invalid",
            "memcpy"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "bbram_emul_check_invalid",
                "code": "static int bbram_emul_check_invalid(const struct device *dev)\n{\n\tstruct bbram_emul_data *data = dev->data;\n\tbool is_invalid = data->status.is_invalid;\n\n\tdata->status.is_invalid = false;\n\treturn is_invalid;\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)",
        "start_line": "108",
        "end_line": "120",
        "file_path": "drivers/bbram/bbram_emul.c",
        "docstring": "The function \"bbram_emul_write\" writes data to a Battery-Backed RAM (BBRAM) emulation device.\\nIt checks if the write size is valid, if the write operation stays within the bounds of the BBRAM, and if the BBRAM is not in an invalid state.\\nIf these checks pass, it copies the data to the specified offset within the device's memory.\\nIf any check fails, it returns an error; otherwise, it returns 0 to indicate success.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3b60b1b563c7",
        "ground_truth": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n       const uint8_t *data)\n{\n const struct bbram_emul_config *config = dev->config;\n struct bbram_emul_data *dev_data = dev->data;\n  if (size < 1 || offset + size > config->size || bbram_emul_check_invalid(dev)) {\n  return -EFAULT;\n }\n  memcpy(dev_data->data + offset, data, size);\n return 0;\n}",
        "import_statements": [
            "#include <zephyr/drivers/bbram.h>\n",
            "#include <string.h>\n",
            "#include <zephyr/logging/log.h>\n"
        ],
        "reference_api": [
            "bbram_emul_check_invalid",
            "memcpy"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "bbram_emul_check_invalid",
                "code": "static int bbram_emul_check_invalid(const struct device *dev)\n{\n\tstruct bbram_emul_data *data = dev->data;\n\tbool is_invalid = data->status.is_invalid;\n\n\tdata->status.is_invalid = false;\n\treturn is_invalid;\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)",
        "start_line": "56",
        "end_line": "71",
        "file_path": "drivers/bbram/bbram_shell.c",
        "docstring": "The function \"parse_device\" checks for and retrieves a BBRAM device based on command-line arguments.\\nIt verifies that the required argument for the device is provided.\\nIf not, it logs an error and returns an invalid argument error code.\\nIt attempts to bind to the specified device and, if unsuccessful, logs an error and returns a device not found error code.\\nIf successful, it returns 0.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "95c2cd7f3153",
        "ground_truth": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n          const struct device **bbram_dev)\n{\n if (argc < 2) {\n  shell_error(sh, \"Missing BBRAM device\");\n  return -EINVAL;\n }\n  *bbram_dev = device_get_binding(argv[1]);\n if (!*bbram_dev) {\n  shell_error(sh, \"Given BBRAM device was not found\");\n  return -ENODEV;\n }\n  return 0;\n}",
        "import_statements": [
            "#include <stdlib.h>\n",
            "#include <string.h>\n",
            "#include <zephyr/devicetree.h>\n",
            "#include <zephyr/drivers/bbram.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/shell/shell.h>\n",
            "#include <zephyr/sys/util.h>\n"
        ],
        "reference_api": [
            "device_get_binding",
            "shell_error"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "device_get_binding",
            "shell_error"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static void h4_read_hdr(const struct device *dev)",
        "start_line": "107",
        "end_line": "120",
        "file_path": "drivers/bluetooth/hci/h4.c",
        "docstring": "The function \"h4_read_hdr\" reads header data from a UART device into a buffer.\\nIt calculates the number of bytes already read, then attempts to read the remaining bytes from the UART FIFO into the header buffer.\\nIf the read operation fails, it logs an error message; otherwise, it updates the remaining byte count based on the number of bytes successfully read.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6cdfd96fdf39",
        "ground_truth": "static void h4_read_hdr(const struct device *dev)\n{\n const struct h4_config *cfg = dev->config;\n struct h4_data *h4 = dev->data;\n int bytes_read = h4->rx.hdr_len - h4->rx.remaining;\n int ret;\n  ret = uart_fifo_read(cfg->uart, h4->rx.hdr + bytes_read, h4->rx.remaining);\n if (unlikely(ret < 0)) {\n  LOG_ERR(\"Unable to read from UART (ret %d)\", ret);\n } else {\n  h4->rx.remaining -= ret;\n }\n}",
        "import_statements": [
            "#include <errno.h>\n",
            "#include <stddef.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/arch/cpu.h>\n",
            "#include <zephyr/init.h>\n",
            "#include <zephyr/drivers/uart.h>\n",
            "#include <zephyr/sys/util.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <string.h>\n",
            "#include <zephyr/bluetooth/bluetooth.h>\n",
            "#include <zephyr/bluetooth/hci.h>\n",
            "#include <zephyr/drivers/bluetooth.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include \"common/bt_str.h\"\n",
            "#include \"../util.h\"\n"
        ],
        "reference_api": [
            "unlikely",
            "LOG_ERR",
            "uart_fifo_read"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "unlikely",
            "LOG_ERR",
            "uart_fifo_read"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static size_t h4_discard(const struct device *uart, size_t len)",
        "start_line": "274",
        "end_line": "286",
        "file_path": "drivers/bluetooth/hci/h4.c",
        "docstring": "The function \"h4_discard\" reads and discards a specified number of bytes from a UART device's FIFO buffer.\\nIt attempts to read up to 33 bytes into a temporary buffer and logs an error if the read operation fails.\\nIt returns the number of bytes successfully read or 0 if an error occurs.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8a01405af8b4",
        "ground_truth": "static size_t h4_discard(const struct device *uart, size_t len)\n{\n uint8_t buf[33];\n int err;\n  err = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n if (unlikely(err < 0)) {\n  LOG_ERR(\"Unable to read from UART (err %d)\", err);\n  return 0;\n }\n  return err;\n}",
        "import_statements": [
            "#include <errno.h>\n",
            "#include <stddef.h>\n",
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/arch/cpu.h>\n",
            "#include <zephyr/init.h>\n",
            "#include <zephyr/drivers/uart.h>\n",
            "#include <zephyr/sys/util.h>\n",
            "#include <zephyr/sys/byteorder.h>\n",
            "#include <string.h>\n",
            "#include <zephyr/bluetooth/bluetooth.h>\n",
            "#include <zephyr/bluetooth/hci.h>\n",
            "#include <zephyr/drivers/bluetooth.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include \"common/bt_str.h\"\n",
            "#include \"../util.h\"\n"
        ],
        "reference_api": [
            "unlikely",
            "MIN",
            "LOG_ERR",
            "uart_fifo_read"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "unlikely",
            "MIN",
            "LOG_ERR",
            "uart_fifo_read"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static inline void chan_update_hop(const struct zbus_channel *chan)",
        "start_line": "201",
        "end_line": "229",
        "file_path": "subsys/zbus/zbus.c",
        "docstring": "The function \"chan_update_hop\" updates the highest observer priority for a given channel.\\nIt locks the channel data and iterates through the observers, checking each observer's priority and whether it is enabled.\\nIf an observer has a higher priority (lower numerical value) than the current highest, it updates the highest observer priority.\\nFinally, it sets the channel's highest observer priority to the determined value.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7b511ed0717b",
        "ground_truth": "static inline void chan_update_hop(const struct zbus_channel *chan)\n{\n struct zbus_channel_observation *observation;\n struct zbus_channel_observation_mask *observation_mask;\n  int chan_highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY;\n  K_SPINLOCK(&_zbus_chan_slock) {\n  const int limit = chan->data->observers_end_idx;\n   for (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n   STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n   STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n    __ASSERT(observation != NULL, \"observation must be not NULL\");\n    const struct zbus_observer *obs = observation->obs;\n    if (!obs->data->enabled || observation_mask->enabled) {\n    continue;\n   }\n    if (chan_highest_observer_priority > obs->data->priority) {\n    chan_highest_observer_priority = obs->data->priority;\n   }\n  }\n  chan->data->highest_observer_priority = chan_highest_observer_priority;\n }\n}",
        "import_statements": [
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/init.h>\n",
            "#include <zephyr/sys/iterable_sections.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include <zephyr/sys/printk.h>\n",
            "#include <zephyr/net/buf.h>\n",
            "#include <zephyr/zbus/zbus.h>\n"
        ],
        "reference_api": [
            "K_SPINLOCK",
            "STRUCT_SECTION_GET",
            "__ASSERT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "K_SPINLOCK",
            "STRUCT_SECTION_GET",
            "__ASSERT"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "static inline void update_all_channels_hop(const struct zbus_observer *obs)",
        "start_line": "231",
        "end_line": "240",
        "file_path": "subsys/zbus/zbus.c",
        "docstring": "The function \"update_all_channels_hop\" updates all channels observed by a given observer.\\nIt iterates through each channel observation and checks if the observer matches the provided observer.\\nIf they match, it calls the function to update the channel.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "30e09ece8d6e",
        "ground_truth": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\n{\n STRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {\n  if (obs != observation->obs) {\n   continue;\n  }\n   chan_update_hop(observation->chan);\n }\n}",
        "import_statements": [
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/init.h>\n",
            "#include <zephyr/sys/iterable_sections.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include <zephyr/sys/printk.h>\n",
            "#include <zephyr/net/buf.h>\n",
            "#include <zephyr/zbus/zbus.h>\n"
        ],
        "reference_api": [
            "STRUCT_SECTION_FOREACH",
            "chan_update_hop"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "chan_update_hop",
                "code": "static inline void chan_update_hop(const struct zbus_channel *chan)\n{\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n\tint chan_highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY;\n\n\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\tconst int limit = chan->data->observers_end_idx;\n\n\t\tfor (int16_t i = chan->data->observers_start_idx; i < limit; ++i) {\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t\t__ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (chan_highest_observer_priority > obs->data->priority) {\n\t\t\t\tchan_highest_observer_priority = obs->data->priority;\n\t\t\t}\n\t\t}\n\t\tchan->data->highest_observer_priority = chan_highest_observer_priority;\n\t}\n}"
            }
        ],
        "third_party": [
            "STRUCT_SECTION_FOREACH"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)",
        "start_line": "260",
        "end_line": "272",
        "file_path": "subsys/zbus/zbus.c",
        "docstring": "The function \"zbus_obs_detach_from_thread\" detaches a zbus observer from a thread.\\nIt first asserts that the operation is not being performed in an ISR and that the observer is not null.\\nIt then locks a spinlock, sets the observer's priority to the minimum thread priority, updates all channels associated with the observer, and returns 0.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5de039f79429",
        "ground_truth": "int zbus_obs_detach_from_thread(const struct zbus_observer *obs)\n{\n _ZBUS_ASSERT(!k_is_in_isr(), \"cannot detach from an ISR\");\n _ZBUS_ASSERT(obs != NULL, \"obs is required\");\n  K_SPINLOCK(&obs_slock) {\n  obs->data->priority = ZBUS_MIN_THREAD_PRIORITY;\n   update_all_channels_hop(obs);\n }\n  return 0;\n}",
        "import_statements": [
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/init.h>\n",
            "#include <zephyr/sys/iterable_sections.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include <zephyr/sys/printk.h>\n",
            "#include <zephyr/net/buf.h>\n",
            "#include <zephyr/zbus/zbus.h>\n"
        ],
        "reference_api": [
            "K_SPINLOCK",
            "k_is_in_isr",
            "_ZBUS_ASSERT",
            "update_all_channels_hop"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "update_all_channels_hop",
                "code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\n{\n\tSTRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {\n\t\tif (obs != observation->obs) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchan_update_hop(observation->chan);\n\t}\n}"
            }
        ],
        "third_party": [
            "K_SPINLOCK",
            "k_is_in_isr",
            "_ZBUS_ASSERT"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "zephyrproject-rtos/zephyr",
        "function_declaration": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)",
        "start_line": "390",
        "end_line": "414",
        "file_path": "subsys/zbus/zbus.c",
        "docstring": "The function \"zbus_chan_notify\" notifies a zbus channel with a specified timeout.\\nIt asserts that the channel is not null and adjusts the timeout if in an ISR.\\nIt calculates the end time based on the timeout and initializes the context priority.\\nIt then locks the channel, executes the notification logic, unlocks the channel, and returns any error encountered during the process.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b8019727be92",
        "ground_truth": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\n{\n int err;\n  _ZBUS_ASSERT(chan != NULL, \"chan is required\");\n  if (k_is_in_isr()) {\n  timeout = K_NO_WAIT;\n }\n  k_timepoint_t end_time = sys_timepoint_calc(timeout);\n  int context_priority = ZBUS_MIN_THREAD_PRIORITY;\n  err = chan_lock(chan, timeout, &context_priority);\n if (err) {\n  return err;\n }\n  err = _zbus_vded_exec(chan, end_time);\n  chan_unlock(chan, context_priority);\n  return err;\n}",
        "import_statements": [
            "#include <zephyr/kernel.h>\n",
            "#include <zephyr/init.h>\n",
            "#include <zephyr/sys/iterable_sections.h>\n",
            "#include <zephyr/logging/log.h>\n",
            "#include <zephyr/sys/printk.h>\n",
            "#include <zephyr/net/buf.h>\n",
            "#include <zephyr/zbus/zbus.h>\n"
        ],
        "reference_api": [
            "k_is_in_isr",
            "_zbus_vded_exec",
            "chan_lock",
            "chan_unlock",
            "_ZBUS_ASSERT",
            "sys_timepoint_calc"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_zbus_vded_exec",
                "code": "static inline int _zbus_vded_exec(const struct zbus_channel *chan, k_timepoint_t end_time)\n{\n\tint err = 0;\n\tint last_error = 0;\n\tstruct net_buf *buf = NULL;\n\n\t/* Static observer event dispatcher logic */\n\tstruct zbus_channel_observation *observation;\n\tstruct zbus_channel_observation_mask *observation_mask;\n\n#if defined(CONFIG_ZBUS_MSG_SUBSCRIBER)\n\tstruct net_buf_pool *pool =\n\t\tCOND_CODE_1(CONFIG_ZBUS_MSG_SUBSCRIBER_NET_BUF_POOL_ISOLATION,\n\t\t\t    (chan->data->msg_subscriber_pool), (&_zbus_msg_subscribers_pool));\n\n\tbuf = _zbus_create_net_buf(pool, zbus_chan_msg_size(chan), sys_timepoint_timeout(end_time));\n\n\t_ZBUS_ASSERT(buf != NULL, \"net_buf zbus_msg_subscribers_pool is \"\n\t\t\t\t  \"unavailable or heap is full\");\n\n\tmemcpy(net_buf_user_data(buf), &chan, sizeof(struct zbus_channel *));\n\n\tnet_buf_add_mem(buf, zbus_chan_msg(chan), zbus_chan_msg_size(chan));\n#endif /* CONFIG_ZBUS_MSG_SUBSCRIBER */\n\n\tLOG_DBG(\"Notifing %s's observers. Starting VDED:\", _ZBUS_CHAN_NAME(chan));\n\n\tint __maybe_unused index = 0;\n\n\tfor (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx;\n\t     i < limit; ++i) {\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation, i, &observation);\n\t\tSTRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);\n\n\t\t_ZBUS_ASSERT(observation != NULL, \"observation must be not NULL\");\n\n\t\tconst struct zbus_observer *obs = observation->obs;\n\n\t\tif (!obs->data->enabled || observation_mask->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = _zbus_notify_observer(chan, obs, end_time, buf);\n\n\t\tif (err) {\n\t\t\tlast_error = err;\n\t\t\tLOG_ERR(\"could not deliver notification to observer %s. Error code %d\",\n\t\t\t\t_ZBUS_OBS_NAME(obs), err);\n\t\t\tif (err == -ENOMEM) {\n\t\t\t\tif (IS_ENABLED(CONFIG_ZBUS_MSG_SUBSCRIBER)) {\n\t\t\t\t\tnet_buf_unref(buf);\n\t\t\t\t}\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tLOG_DBG(\" %d -> %s\", index++, _ZBUS_OBS_NAME(obs));\n\t}\n\n#if defined(CONFIG_ZBUS_RUNTIME_OBSERVERS)\n\t/* Dynamic observer event dispatcher logic */\n\tstruct zbus_observer_node *obs_nd, *tmp;\n\n\tSYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->data->observers, obs_nd, tmp, node) {\n\t\tconst struct zbus_observer *obs = obs_nd->obs;\n\n\t\tif (!obs->data->enabled) {\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = _zbus_notify_observer(chan, obs, end_time, buf);\n\n\t\tif (err) {\n\t\t\tlast_error = err;\n\t\t}\n\t}\n#endif /* CONFIG_ZBUS_RUNTIME_OBSERVERS */\n\n\tIF_ENABLED(CONFIG_ZBUS_MSG_SUBSCRIBER, (net_buf_unref(buf);))\n\n\treturn last_error;\n}"
            },
            {
                "name": "chan_lock",
                "code": "static inline int chan_lock(const struct zbus_channel *chan, k_timeout_t timeout, int *prio)\n{\n\tbool boosting = false;\n\n#if defined(CONFIG_ZBUS_PRIORITY_BOOST)\n\tif (!k_is_in_isr()) {\n\t\t*prio = k_thread_priority_get(k_current_get());\n\n\t\tK_SPINLOCK(&_zbus_chan_slock) {\n\t\t\tif (*prio > chan->data->highest_observer_priority) {\n\t\t\t\tint new_prio = chan->data->highest_observer_priority - 1;\n\n\t\t\t\tnew_prio = MAX(new_prio, 0);\n\n\t\t\t\t/* Elevating priority since the highest_observer_priority is\n\t\t\t\t * greater than the current thread\n\t\t\t\t */\n\t\t\t\tk_thread_priority_set(k_current_get(), new_prio);\n\n\t\t\t\tboosting = true;\n\t\t\t}\n\t\t}\n\t}\n#endif /* CONFIG_ZBUS_PRIORITY_BOOST */\n\n\tint err = k_sem_take(&chan->data->sem, timeout);\n\n\tif (err) {\n\t\t/* When the priority boost is disabled, this IF will be optimized out. */\n\t\tif (boosting) {\n\t\t\t/* Restoring thread priority since the semaphore is not available */\n\t\t\tk_thread_priority_set(k_current_get(), *prio);\n\t\t}\n\n\t\treturn err;\n\t}\n\n\treturn 0;\n}"
            },
            {
                "name": "chan_unlock",
                "code": "static inline void chan_unlock(const struct zbus_channel *chan, int prio)\n{\n\tk_sem_give(&chan->data->sem);\n\n#if defined(CONFIG_ZBUS_PRIORITY_BOOST)\n\t/* During the unlock phase, with the priority boost enabled, the priority must be\n\t * restored to the original value in case it was elevated\n\t */\n\tif (prio < ZBUS_MIN_THREAD_PRIORITY) {\n\t\tk_thread_priority_set(k_current_get(), prio);\n\t}\n#endif /* CONFIG_ZBUS_PRIORITY_BOOST */\n}"
            }
        ],
        "third_party": [
            "k_is_in_isr",
            "_ZBUS_ASSERT",
            "sys_timepoint_calc"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "void ETH_ITConfig(uint32_t Int, BOOL enable)",
        "start_line": "428",
        "end_line": "452",
        "file_path": "bsp/CME_M7/StdPeriph_Driver/src/cmem7_eth.c",
        "docstring": "The function \"ETH_ITConfig\" configures the enabling or disabling of Ethernet interrupts.\\nIt verifies the validity of the interrupt parameter and then either enables or disables the specified interrupt.\\nWhen enabling, it checks if the interrupt is normal or abnormal and sets the corresponding enable bits.\\nWhen disabling, it clears the specified interrupt and updates the normal and abnormal interrupt enable bits based on the remaining enabled interrupts.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e7a90af304f1",
        "ground_truth": "void ETH_ITConfig(uint32_t Int, BOOL enable) {\n    assert_param(IS_ETH_INT(Int));\n     if (enable) {\n        if (IS_ETH_INT_NORMAL(Int)) {\n            ETH->INT_EN_b.NIE = TRUE;\n        }\n         if (IS_ETH_INT_ABNORMAL(Int)) {\n            ETH->INT_EN_b.AIE = TRUE;\n        }\n         ETH->INT_EN |= Int;\n    } else {\n        ETH->INT_EN &= ~Int;\n         if (!IS_ETH_INT_NORMAL(ETH->INT_EN)) {\n            ETH->INT_EN_b.NIE = FALSE;\n        }\n         if (!IS_ETH_INT_ABNORMAL(ETH->INT_EN)) {\n            ETH->INT_EN_b.AIE = FALSE;\n        }\n    }\n}",
        "import_statements": [
            "#include \"cmem7_eth.h\"\n",
            "#include \"cmem7_misc.h\"\n"
        ],
        "reference_api": [
            "IS_ETH_INT_ABNORMAL",
            "IS_ETH_INT_NORMAL",
            "assert_param",
            "IS_ETH_INT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "IS_ETH_INT_ABNORMAL",
            "IS_ETH_INT_NORMAL",
            "assert_param",
            "IS_ETH_INT"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)",
        "start_line": "556",
        "end_line": "568",
        "file_path": "bsp/CME_M7/StdPeriph_Driver/src/cmem7_eth.c",
        "docstring": "The function \"ETH_AcquireFreeTxDesc\" searches for and acquires a free Ethernet transmit descriptor.\\nIt starts by getting the current transmit descriptor address and checks if the descriptor is owned by the device.\\nIf a free descriptor is found, it returns the descriptor; otherwise, it continues to the next descriptor in the list until it loops back to the starting address.\\nIf no free descriptor is found, it returns 0.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "39b1f303c655",
        "ground_truth": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void) {\n    uint32_t cur = ETH->CURTDESAPTR;\n    INNER_ETH_TX_DESC *desc = (INNER_ETH_TX_DESC *)cur;\n     do {\n        if (desc->TX_0.TX0_b.OWN == ETH_DESC_OWN_BY_SELF) {\n            return (ETH_TX_DESC *)desc;\n        }\n        desc = (INNER_ETH_TX_DESC *)desc->nextDescAddr;\n    } while ((uint32_t)desc != cur);\n   return 0;\n}",
        "import_statements": [
            "#include \"cmem7_eth.h\"\n",
            "#include \"cmem7_misc.h\"\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)",
        "start_line": "116",
        "end_line": "134",
        "file_path": "bsp/Infineon/libraries/HAL_Drivers/drv_dac.c",
        "docstring": "The function \"cyp_adc_convert\" initializes and enables a DAC channel for a specified device.\\nIt asserts that the device is not null and retrieves the corresponding DAC channel.\\nIt then attempts to enable the DAC output with the specified value using the Cy_CSDIDAC_OutputEnable function.\\nIf the initialization fails, it logs an error message and returns an error code; otherwise, it returns RT_EOK indicating success.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7367af8d29f1",
        "ground_truth": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)\n{\n    RT_ASSERT(device != RT_NULL);\n     cy_rslt_t result;\n     rt_uint32_t cyp_channel;\n     cyp_channel = cyp_dac_get_channel(channel);\n     result = Cy_CSDIDAC_OutputEnable(cyp_channel, *value, &csdidac_context);\n    if (result != RT_EOK)\n    {\n        LOG_E(\"DAC  channel initialization failed. Error: %d\\n\", result);\n        return -RT_ENOSYS;\n    }\n     return RT_EOK;\n}",
        "import_statements": [
            "#include \"drv_dac.h\"\n",
            "#include \"drv_common.h\"\n",
            "#include <rtthread.h>\n"
        ],
        "reference_api": [
            "cyp_dac_get_channel",
            "RT_ASSERT",
            "Cy_CSDIDAC_OutputEnable",
            "LOG_E"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "cyp_dac_get_channel",
                "code": "static rt_uint32_t cyp_dac_get_channel(rt_uint32_t channel)\n{\n    rt_uint32_t cyp_dac_channel = 0;\n\n    switch (channel)\n    {\n    case 1:\n        cyp_dac_channel = CY_CSDIDAC_A;\n        break;\n    case 2:\n        cyp_dac_channel = CY_CSDIDAC_B;\n        break;\n    default:\n        RT_ASSERT(0);\n        break;\n    }\n\n    return cyp_dac_channel;\n}"
            }
        ],
        "third_party": [
            "RT_ASSERT",
            "Cy_CSDIDAC_OutputEnable",
            "LOG_E"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)",
        "start_line": "71",
        "end_line": "87",
        "file_path": "bsp/Infineon/libraries/HAL_Drivers/drv_flash.c",
        "docstring": "The function \"ifx_flash_read_32k\" reads data from flash memory into a buffer.\\nIt first checks if the read operation would exceed the flash memory's end address and logs an error if it does, returning an invalid argument error code.\\nIf the address is valid, it reads the specified size of data from the flash memory address into the buffer, byte by byte.\\nFinally, it returns the number of bytes read.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3beae49110b9",
        "ground_truth": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\n{\n    rt_uint32_t i;\n     if ((addr + size) > IFX_EFLASH_END_ADDRESS)\n    {\n        LOG_E(\"read outrange flash size! addr is (0x%p)\", (void *)(addr + size));\n        return -RT_EINVAL;\n    }\n     for (i = 0; i < size; i++, buf++, addr++)\n    {\n        *buf = *(rt_uint8_t *) addr;\n    }\n     return size;\n}",
        "import_statements": [
            "#include <rtthread.h>\n",
            "#include \"drv_common.h\"\n"
        ],
        "reference_api": [
            "LOG_E"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "LOG_E"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)",
        "start_line": "163",
        "end_line": "176",
        "file_path": "bsp/Infineon/libraries/HAL_Drivers/drv_hwtimer.c",
        "docstring": "The function \"timer_counter_get\" retrieves the current count value of a hardware timer.\\nIt first asserts that the provided timer is not null.\\nThen, it retrieves the timer object from the timer's user data and reads the current count using the \"cyhal_timer_read\" function.\\nFinally, it returns the count value.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b83f53e604b7",
        "ground_truth": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)\n{\n    cyhal_timer_t *tim = RT_NULL;\n     rt_uint32_t count;\n     RT_ASSERT(timer != RT_NULL);\n     tim = (cyhal_timer_t *)timer->parent.user_data;\n     count = cyhal_timer_read(tim);\n     return count;\n}",
        "import_statements": [
            "#include \"drv_common.h\"\n",
            "#include \"drv_hwtimer.h\"\n",
            "#include <board.h>\n",
            "#include <rtthread.h>\n",
            "#include <rtdevice.h>\n"
        ],
        "reference_api": [
            "RT_ASSERT",
            "cyhal_timer_read"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "RT_ASSERT",
            "cyhal_timer_read"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "void dfs_lock(void)",
        "start_line": "114",
        "end_line": "127",
        "file_path": "components/dfs/dfs_v1/src/dfs.c",
        "docstring": "The function \"dfs_lock\" attempts to acquire a mutex lock for the filesystem.\\nIt repeatedly tries to take the mutex until it is successful, waiting indefinitely each time.\\nIf the mutex acquisition fails for any reason other than being busy, it triggers an assertion failure.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "05824ffa38b7",
        "ground_truth": "void dfs_lock(void)\n{\n    rt_err_t result = -RT_EBUSY;\n     while (result == -RT_EBUSY)\n    {\n        result = rt_mutex_take(&fslock, RT_WAITING_FOREVER);\n    }\n     if (result != RT_EOK)\n    {\n        RT_ASSERT(0);\n    }\n}",
        "import_statements": [
            "#include <dfs.h>\n",
            "#include <dfs_fs.h>\n",
            "#include <dfs_file.h>\n",
            "#include \"dfs_private.h\"\n"
        ],
        "reference_api": [
            "rt_mutex_take",
            "RT_ASSERT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_mutex_take",
            "RT_ASSERT"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)",
        "start_line": "198",
        "end_line": "221",
        "file_path": "components/dfs/dfs_v1/src/dfs.c",
        "docstring": "The function \"fd_slot_alloc\" allocates an empty file descriptor (fd) slot in a file descriptor table.\\nIt searches for an empty slot starting from the specified index.\\nIf no empty slot is found, it attempts to expand the fd table.\\nIt returns the index of the allocated slot, or -1 if expansion fails.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5480b7f59af4",
        "ground_truth": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\n{\n    int idx;\n     /* find an empty fd slot */\n    for (idx = startfd; idx < (int)fdt->maxfd; idx++)\n    {\n        if (fdt->fds[idx] == RT_NULL)\n        {\n            return idx;\n        }\n    }\n     idx = fdt->maxfd;\n    if (idx < startfd)\n    {\n        idx = startfd;\n    }\n    if (fd_slot_expand(fdt, idx) < 0)\n    {\n        return -1;\n    }\n    return idx;\n}",
        "import_statements": [
            "#include <dfs.h>\n",
            "#include <dfs_fs.h>\n",
            "#include <dfs_file.h>\n",
            "#include \"dfs_private.h\"\n"
        ],
        "reference_api": [
            "fd_slot_expand"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "fd_slot_expand",
                "code": "static int fd_slot_expand(struct dfs_fdtable *fdt, int fd)\n{\n    int nr;\n    int index;\n    struct dfs_file **fds = NULL;\n\n    if (fd < fdt->maxfd)\n    {\n        return fd;\n    }\n    if (fd >= DFS_FD_MAX)\n    {\n        return -1;\n    }\n\n    nr = ((fd + 4) & ~3);\n    if (nr > DFS_FD_MAX)\n    {\n        nr = DFS_FD_MAX;\n    }\n    fds = (struct dfs_file **)rt_realloc(fdt->fds, nr * sizeof(struct dfs_file *));\n    if (!fds)\n    {\n        return -1;\n    }\n\n    /* clean the new allocated fds */\n    for (index = fdt->maxfd; index < nr; index++)\n    {\n        fds[index] = NULL;\n    }\n    fdt->fds   = fds;\n    fdt->maxfd = nr;\n\n    return fd;\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "const char *rt_strerror(rt_err_t error)",
        "start_line": "744",
        "end_line": "758",
        "file_path": "src/klibc/kstdio.c",
        "docstring": "The function \"rt_strerror\" returns a string representation of a given error code.\\nIt first converts the error code to a positive value if it is negative.\\nIt then iterates through an array of known error strings to find a match for the error code.\\nIf a match is found, it returns the corresponding error string; otherwise, it returns \"EUNKNOW\".",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "22549fe9d853",
        "ground_truth": "const char *rt_strerror(rt_err_t error)\n{\n    int i = 0;\n     if (error < 0)\n        error = -error;\n     for (i = 0; i < sizeof(rt_errno_strs) / sizeof(rt_errno_strs[0]); i++)\n    {\n        if (rt_errno_strs[i].error == error)\n            return rt_errno_strs[i].str;\n    }\n     return \"EUNKNOW\";\n}",
        "import_statements": [
            "#include <rtdef.h>\n",
            "#include <rtcompiler.h>\n",
            "#include <rtklibc.h>\n",
            "#include <rtm.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))",
        "start_line": "82",
        "end_line": "103",
        "file_path": "src/idle.c",
        "docstring": "The function \"rt_thread_idle_sethook\" registers a hook function to be called during the idle thread execution.\\nIt locks a spinlock to ensure thread safety and iterates through the idle hook list to find an empty slot.\\nIf an empty slot is found, it assigns the hook to that slot and returns a success code (RT_EOK).\\nIf no empty slot is available, it returns an error code (-RT_EFULL).\\nFinally, it releases the spinlock and returns the result.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "21987673f31c",
        "ground_truth": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\n{\n    rt_size_t i;\n    rt_err_t ret = -RT_EFULL;\n    rt_base_t level;\n     level = rt_spin_lock_irqsave(&_hook_spinlock);\n     for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)\n    {\n        if (idle_hook_list[i] == RT_NULL)\n        {\n            idle_hook_list[i] = hook;\n            ret = RT_EOK;\n            break;\n        }\n    }\n     rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n     return ret;\n}",
        "import_statements": [
            "#include <rthw.h>\n",
            "#include <rtthread.h>\n"
        ],
        "reference_api": [
            "rt_spin_lock_irqsave",
            "rt_spin_unlock_irqrestore"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_spin_lock_irqsave",
            "rt_spin_unlock_irqrestore"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))",
        "start_line": "113",
        "end_line": "134",
        "file_path": "src/idle.c",
        "docstring": "The function \"rt_thread_idle_delhook\" removes a specified hook from the idle hook list.\\nIt locks the spinlock to ensure thread safety and iterates through the idle hook list to find the specified hook.\\nIf found, it sets the corresponding entry to null and returns a success code.\\nIf the hook is not found, it returns an error code indicating that the operation is not supported.\\nFinally, it unlocks the spinlock and returns the result.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4cbc6d4f6171",
        "ground_truth": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\n{\n    rt_size_t i;\n    rt_err_t ret = -RT_ENOSYS;\n    rt_base_t level;\n     level = rt_spin_lock_irqsave(&_hook_spinlock);\n     for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)\n    {\n        if (idle_hook_list[i] == hook)\n        {\n            idle_hook_list[i] = RT_NULL;\n            ret = RT_EOK;\n            break;\n        }\n    }\n     rt_spin_unlock_irqrestore(&_hook_spinlock, level);\n     return ret;\n}",
        "import_statements": [
            "#include <rthw.h>\n",
            "#include <rtthread.h>\n"
        ],
        "reference_api": [
            "rt_spin_lock_irqsave",
            "rt_spin_unlock_irqrestore"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_spin_lock_irqsave",
            "rt_spin_unlock_irqrestore"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)",
        "start_line": "165",
        "end_line": "184",
        "file_path": "src/ipc.c",
        "docstring": "The function \"rt_susp_list_resume_all\" resumes all threads in a given suspension list.\\nIt starts by ensuring the scheduler is unlocked and then dequeues and wakes up each suspended thread from the list one by one until the list is empty.\\nIt returns RT_EOK to indicate successful completion.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "19847f2b22b0",
        "ground_truth": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\n{\n    struct rt_thread *thread;\n     RT_SCHED_DEBUG_IS_UNLOCKED;\n     /* wakeup all suspended threads */\n    thread = rt_susp_list_dequeue(susp_list, thread_error);\n    while (thread)\n    {\n        /*\n         * resume NEXT thread\n         * In rt_thread_resume function, it will remove current thread from\n         * suspended list\n         */\n        thread = rt_susp_list_dequeue(susp_list, thread_error);\n    }\n     return RT_EOK;\n}",
        "import_statements": [
            "#include <rtthread.h>\n",
            "#include <rthw.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [
            "rt_susp_list_dequeue"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_susp_list_dequeue"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "rt_device_t rt_console_set_device(const char *name)",
        "start_line": "188",
        "end_line": "215",
        "file_path": "src/kservice.c",
        "docstring": "The function \"rt_console_set_device\" sets a new console device by its name.\\nIt saves the current console device, finds the new device by its name, and checks if it is the same as the current device.\\nIf it is different and valid, it closes the current console device if it exists, opens the new console device with read/write and stream flags, and sets it as the new console device.\\nFinally, it returns the old console device.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "49cd9de412be",
        "ground_truth": "rt_device_t rt_console_set_device(const char *name)\n{\n    rt_device_t new_device, old_device;\n     /* save old device */\n    old_device = _console_device;\n     /* find new console device */\n    new_device = rt_device_find(name);\n     /* check whether it's a same device */\n    if (new_device == old_device) return RT_NULL;\n     if (new_device != RT_NULL)\n    {\n        if (_console_device != RT_NULL)\n        {\n            /* close old console device */\n            rt_device_close(_console_device);\n        }\n         /* set new console device */\n        rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        _console_device = new_device;\n    }\n     return old_device;\n}",
        "import_statements": [
            "#include <rtthread.h>\n",
            "#include <rthw.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [
            "rt_device_open",
            "rt_device_close",
            "rt_device_find"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_device_open",
            "rt_device_close",
            "rt_device_find"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "int rt_object_get_length(enum rt_object_class_type type)",
        "start_line": "269",
        "end_line": "287",
        "file_path": "src/object.c",
        "docstring": "The function \"rt_object_get_length\" returns the count of objects of a specified type.\\nIt retrieves information about the object class type and locks the corresponding spinlock to ensure thread safety.\\nIt iterates through the object list, counting the number of objects.\\nFinally, it releases the spinlock and returns the count.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8530e7eb6cc8",
        "ground_truth": "int rt_object_get_length(enum rt_object_class_type type)\n{\n    int count = 0;\n    rt_base_t level;\n    struct rt_list_node *node = RT_NULL;\n    struct rt_object_information *information = RT_NULL;\n     information = rt_object_get_information((enum rt_object_class_type)type);\n    if (information == RT_NULL) return 0;\n     level = rt_spin_lock_irqsave(&(information->spinlock));\n    rt_list_for_each(node, &(information->object_list))\n    {\n        count ++;\n    }\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n     return count;\n}",
        "import_statements": [
            "#include <rtthread.h>\n",
            "#include <rthw.h>\n"
        ],
        "reference_api": [
            "rt_list_for_each",
            "rt_spin_lock_irqsave",
            "rt_object_get_information",
            "rt_spin_unlock_irqrestore"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_list_for_each",
            "rt_spin_lock_irqsave",
            "rt_object_get_information",
            "rt_spin_unlock_irqrestore"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "void rt_object_detach(rt_object_t object)",
        "start_line": "414",
        "end_line": "433",
        "file_path": "src/object.c",
        "docstring": "The function \"rt_object_detach\" detaches an RT-Thread object from its management system.\\nIt first checks that the object is not null, then calls a hook function for detachment.\\nIt retrieves the object's information structure and locks its spinlock to ensure thread safety.\\nThe function removes the object from its list, unlocks the spinlock, and sets the object's type to zero.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9c88db151352",
        "ground_truth": "void rt_object_detach(rt_object_t object)\n{\n    rt_base_t level;\n    struct rt_object_information *information;\n     /* object check */\n    RT_ASSERT(object != RT_NULL);\n     RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n     information = rt_object_get_information((enum rt_object_class_type)object->type);\n    RT_ASSERT(information != RT_NULL);\n     level = rt_spin_lock_irqsave(&(information->spinlock));\n    /* remove from old list */\n    rt_list_remove(&(object->list));\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n     object->type = 0;\n}",
        "import_statements": [
            "#include <rtthread.h>\n",
            "#include <rthw.h>\n"
        ],
        "reference_api": [
            "rt_object_get_information",
            "RT_ASSERT",
            "rt_spin_unlock_irqrestore",
            "RT_OBJECT_HOOK_CALL",
            "rt_list_remove",
            "rt_spin_lock_irqsave"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_object_get_information",
            "RT_ASSERT",
            "rt_spin_unlock_irqrestore",
            "RT_OBJECT_HOOK_CALL",
            "rt_list_remove",
            "rt_spin_lock_irqsave"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "rt_err_t rt_custom_object_destroy(rt_object_t obj)",
        "start_line": "741",
        "end_line": "756",
        "file_path": "src/object.c",
        "docstring": "The function \"rt_custom_object_destroy\" destroys a custom RT object.\\nIt checks if the object is valid and of the custom object class type.\\nIf the object has a destroy method, it calls this method and stores the return value.\\nFinally, it deletes the object and returns the result of the destroy operation.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7c244d78ebb0",
        "ground_truth": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\n{\n    rt_err_t ret = -1;\n     struct rt_custom_object *cobj = (struct rt_custom_object *)obj;\n     if (obj && obj->type == RT_Object_Class_Custom)\n    {\n        if (cobj->destroy)\n        {\n            ret = cobj->destroy(cobj->data);\n        }\n        rt_object_delete(obj);\n    }\n    return ret;\n}",
        "import_statements": [
            "#include <rtthread.h>\n",
            "#include <rthw.h>\n"
        ],
        "reference_api": [
            "rt_object_delete",
            "cobj->destroy"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "rt_object_delete",
                "code": "void rt_object_delete(rt_object_t object)\n{\n    rt_base_t level;\n    struct rt_object_information *information;\n\n    /* object check */\n    RT_ASSERT(object != RT_NULL);\n    RT_ASSERT(!(object->type & RT_Object_Class_Static));\n\n    RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));\n\n\n    information = rt_object_get_information((enum rt_object_class_type)object->type);\n    RT_ASSERT(information != RT_NULL);\n\n    level = rt_spin_lock_irqsave(&(information->spinlock));\n\n    /* remove from old list */\n    rt_list_remove(&(object->list));\n\n    rt_spin_unlock_irqrestore(&(information->spinlock), level);\n\n    /* reset object type */\n    object->type = RT_Object_Class_Null;\n\n    /* free the memory of object */\n    RT_KERNEL_FREE(object);\n}"
            }
        ],
        "third_party": [
            "cobj->destroy"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "static void _thread_exit(void)",
        "start_line": "79",
        "end_line": "98",
        "file_path": "src/thread.c",
        "docstring": "The function \"_thread_exit\" handles the termination of the current thread.\\nIt retrieves the current thread, enters a critical section, and closes the thread.\\nThe thread is then added to the defunct thread list.\\nAfter exiting the critical section safely, it triggers a context switch to the next task by calling the scheduler.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8502151cda65",
        "ground_truth": "static void _thread_exit(void)\n{\n    struct rt_thread *thread;\n    rt_base_t critical_level;\n     /* get current thread */\n    thread = rt_thread_self();\n     critical_level = rt_enter_critical();\n     rt_thread_close(thread);\n     /* insert to defunct thread list */\n    rt_thread_defunct_enqueue(thread);\n     rt_exit_critical_safe(critical_level);\n     /* switch to next task */\n    rt_schedule();\n}",
        "import_statements": [
            "#include <rthw.h>\n",
            "#include <rtthread.h>\n",
            "#include <stddef.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [
            "rt_thread_defunct_enqueue",
            "rt_exit_critical_safe",
            "rt_thread_close",
            "rt_schedule",
            "rt_enter_critical",
            "rt_thread_self"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "rt_thread_close",
                "code": "rt_err_t rt_thread_close(rt_thread_t thread)\n{\n    rt_sched_lock_level_t slvl;\n    rt_uint8_t thread_status;\n\n    /* forbid scheduling on current core if closing current thread */\n    RT_ASSERT(thread != rt_thread_self() || rt_critical_level());\n\n    /* before checking status of scheduler */\n    rt_sched_lock(&slvl);\n\n    /* check if thread is already closed */\n    thread_status = rt_sched_thread_get_stat(thread);\n    if (thread_status != RT_THREAD_CLOSE)\n    {\n        if (thread_status != RT_THREAD_INIT)\n        {\n            /* remove from schedule */\n            rt_sched_remove_thread(thread);\n        }\n\n        /* release thread timer */\n        rt_timer_detach(&(thread->thread_timer));\n\n        /* change stat */\n        rt_sched_thread_close(thread);\n    }\n\n    /* scheduler works are done */\n    rt_sched_unlock(slvl);\n\n    return RT_EOK;\n}"
            },
            {
                "name": "rt_thread_self",
                "code": "rt_thread_t rt_thread_self(void)\n{\n#ifndef RT_USING_SMP\n    return rt_cpu_self()->current_thread;\n\n#elif defined (ARCH_USING_HW_THREAD_SELF)\n    return rt_hw_thread_self();\n\n#else /* !ARCH_USING_HW_THREAD_SELF */\n    rt_thread_t self;\n    rt_base_t lock;\n\n    lock = rt_hw_local_irq_disable();\n    self = rt_cpu_self()->current_thread;\n    rt_hw_local_irq_enable(lock);\n\n    return self;\n#endif /* ARCH_USING_HW_THREAD_SELF */\n}"
            }
        ],
        "third_party": [
            "rt_thread_defunct_enqueue",
            "rt_exit_critical_safe",
            "rt_schedule",
            "rt_enter_critical"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "static void _thread_timeout(void *parameter)",
        "start_line": "106",
        "end_line": "134",
        "file_path": "src/thread.c",
        "docstring": "The function \"_thread_timeout\" handles thread timeout events.\\nIt takes a thread as a parameter and performs parameter checks to ensure validity.\\nIt locks the scheduler, verifies the thread is suspended, sets the thread's error number to a timeout value, removes the thread from the suspend list, inserts it into the ready list, and then unlocks the scheduler to reschedule.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e0f1dd5a29a1",
        "ground_truth": "static void _thread_timeout(void *parameter)\n{\n    struct rt_thread *thread;\n    rt_sched_lock_level_t slvl;\n     thread = (struct rt_thread *)parameter;\n     /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n     rt_sched_lock(&slvl);\n     /**\n     * resume of the thread and stop of the thread timer should be an atomic\n     * operation. So we don't expected that thread had resumed.\n     */\n    RT_ASSERT(rt_sched_thread_is_suspended(thread));\n     /* set error number */\n    thread->error = -RT_ETIMEOUT;\n     /* remove from suspend list */\n    rt_list_remove(&RT_THREAD_LIST_NODE(thread));\n    /* insert to schedule ready list */\n    rt_sched_insert_thread(thread);\n    /* do schedule and release the scheduler lock */\n    rt_sched_unlock_n_resched(slvl);\n}",
        "import_statements": [
            "#include <rthw.h>\n",
            "#include <rtthread.h>\n",
            "#include <stddef.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [
            "RT_ASSERT",
            "rt_sched_thread_is_suspended",
            "rt_sched_insert_thread",
            "RT_THREAD_LIST_NODE",
            "rt_sched_unlock_n_resched",
            "rt_sched_lock",
            "rt_object_get_type",
            "rt_list_remove"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "RT_ASSERT",
            "rt_sched_thread_is_suspended",
            "rt_sched_insert_thread",
            "RT_THREAD_LIST_NODE",
            "rt_sched_unlock_n_resched",
            "rt_sched_lock",
            "rt_object_get_type",
            "rt_list_remove"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "static void _thread_detach_from_mutex(rt_thread_t thread)",
        "start_line": "137",
        "end_line": "164",
        "file_path": "src/thread.c",
        "docstring": "The function \"_thread_detach_from_mutex\" detaches a thread from any mutex it is waiting on or has taken.\\nIt locks the thread's spinlock, checks if the thread is waiting on a mutex, and if so, removes it from the mutex's waiting list and clears the pending object.\\nIt then releases all mutexes the thread has taken and restores the spinlock state.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2af96ff4a75a",
        "ground_truth": "static void _thread_detach_from_mutex(rt_thread_t thread)\n{\n    rt_list_t *node;\n    rt_list_t *tmp_list;\n    struct rt_mutex *mutex;\n    rt_base_t level;\n     level = rt_spin_lock_irqsave(&thread->spinlock);\n     /* check if thread is waiting on a mutex */\n    if ((thread->pending_object) &&\n        (rt_object_get_type(thread->pending_object) == RT_Object_Class_Mutex))\n    {\n        /* remove it from its waiting list */\n        struct rt_mutex *mutex = (struct rt_mutex*)thread->pending_object;\n        rt_mutex_drop_thread(mutex, thread);\n        thread->pending_object = RT_NULL;\n    }\n     /* free taken mutex after detaching from waiting, so we don't lost mutex just got */\n    rt_list_for_each_safe(node, tmp_list, &(thread->taken_object_list))\n    {\n        mutex = rt_list_entry(node, struct rt_mutex, taken_list);\n        rt_mutex_release(mutex);\n    }\n     rt_spin_unlock_irqrestore(&thread->spinlock, level);\n}",
        "import_statements": [
            "#include <rthw.h>\n",
            "#include <rtthread.h>\n",
            "#include <stddef.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [
            "rt_list_for_each_safe",
            "rt_mutex_release",
            "rt_list_entry",
            "rt_mutex_drop_thread",
            "rt_spin_unlock_irqrestore",
            "rt_object_get_type",
            "rt_spin_lock_irqsave"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_list_for_each_safe",
            "rt_mutex_release",
            "rt_list_entry",
            "rt_mutex_drop_thread",
            "rt_spin_unlock_irqrestore",
            "rt_object_get_type",
            "rt_spin_lock_irqsave"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "rt_err_t rt_thread_startup(rt_thread_t thread)",
        "start_line": "385",
        "end_line": "402",
        "file_path": "src/thread.c",
        "docstring": "The function \"rt_thread_startup\" starts a given thread.\\nIt first checks that the thread is not null, is in the initialization state, and is of the correct type.\\nIt logs the thread's name and priority, calculates its priority attributes, and resets its state to suspended.\\nFinally, it resumes the thread and triggers a scheduler if available, returning RT_EOK upon successful startup.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a54791eb73ca",
        "ground_truth": "rt_err_t rt_thread_startup(rt_thread_t thread)\n{\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT((RT_SCHED_CTX(thread).stat & RT_THREAD_STAT_MASK) == RT_THREAD_INIT);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n     LOG_D(\"startup a thread:%s with priority:%d\",\n          thread->parent.name, thread->current_priority);\n     /* calculate priority attribute and reset thread stat to suspend */\n    rt_sched_thread_startup(thread);\n     /* resume and do a schedule if scheduler is available */\n    rt_thread_resume(thread);\n     return RT_EOK;\n}",
        "import_statements": [
            "#include <rthw.h>\n",
            "#include <rtthread.h>\n",
            "#include <stddef.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [
            "rt_thread_resume",
            "rt_sched_thread_startup",
            "RT_ASSERT",
            "RT_SCHED_CTX",
            "LOG_D",
            "rt_object_get_type"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "rt_thread_resume",
                "code": "rt_err_t rt_thread_resume(rt_thread_t thread)\n{\n    rt_sched_lock_level_t slvl;\n    rt_err_t error;\n\n    /* parameter check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type((rt_object_t)thread) == RT_Object_Class_Thread);\n\n    LOG_D(\"thread resume: %s\", thread->parent.name);\n\n    rt_sched_lock(&slvl);\n\n    error = rt_sched_thread_ready(thread);\n\n    if (!error)\n    {\n        error = rt_sched_unlock_n_resched(slvl);\n\n        /**\n         * RT_ESCHEDLOCKED indicates that the current thread is in a critical section,\n         * rather than 'thread' can't be resumed. Therefore, we can ignore this error.\n         */\n        if (error == -RT_ESCHEDLOCKED)\n        {\n            error = RT_EOK;\n        }\n    }\n    else\n    {\n        rt_sched_unlock(slvl);\n    }\n\n    RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread));\n\n    return error;\n}"
            }
        ],
        "third_party": [
            "rt_sched_thread_startup",
            "RT_ASSERT",
            "RT_SCHED_CTX",
            "LOG_D",
            "rt_object_get_type"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)",
        "start_line": "172",
        "end_line": "184",
        "file_path": "src/timer.c",
        "docstring": "The function \"_timer_list_next_timeout\" retrieves the next timeout tick from a timer list.\\nIt checks if the highest level of the timer skip list is not empty.\\nIf not empty, it gets the first timer entry and sets the provided timeout tick to the timer's timeout value, returning RT_EOK.\\nIf the list is empty, it returns an error code.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bfda287b2d91",
        "ground_truth": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)\n{\n    struct rt_timer *timer;\n     if (!rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))\n    {\n        timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,\n                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n        *timeout_tick = timer->timeout_tick;\n        return RT_EOK;\n    }\n    return -RT_ERROR;\n}",
        "import_statements": [
            "#include <rtthread.h>\n",
            "#include <rthw.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [
            "rt_list_isempty",
            "rt_list_entry"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rt_list_isempty",
            "rt_list_entry"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "RT-Thread/rt-thread",
        "function_declaration": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)",
        "start_line": "345",
        "end_line": "367",
        "file_path": "src/timer.c",
        "docstring": "The function \"rt_timer_create\" creates and initializes a new timer object.\\nIt checks that the timeout function is not null and that the specified time is within a valid range.\\nIt allocates memory for the timer object and, if successful, initializes the timer with the provided timeout function, parameter, time, and flag.\\nThe function returns a pointer to the created timer object or null if the allocation fails.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7cb3a2404f73",
        "ground_truth": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)\n{\n    struct rt_timer *timer;\n     /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n    RT_ASSERT(time < RT_TICK_MAX / 2);\n     /* allocate a object */\n    timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);\n    if (timer == RT_NULL)\n    {\n        return RT_NULL;\n    }\n     _timer_init(timer, timeout, parameter, time, flag);\n     return timer;\n}",
        "import_statements": [
            "#include <rtthread.h>\n",
            "#include <rthw.h>\n",
            "#include <rtdbg.h>\n"
        ],
        "reference_api": [
            "RT_ASSERT",
            "rt_object_allocate",
            "_timer_init"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_timer_init",
                "code": "static void _timer_init(rt_timer_t timer,\n                        void (*timeout)(void *parameter),\n                        void      *parameter,\n                        rt_tick_t  time,\n                        rt_uint8_t flag)\n{\n    int i;\n\n#ifdef RT_USING_TIMER_ALL_SOFT\n    flag               |= RT_TIMER_FLAG_SOFT_TIMER;\n#endif\n\n    /* set flag */\n    timer->parent.flag  = flag;\n\n    /* set deactivated */\n    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;\n\n    timer->timeout_func = timeout;\n    timer->parameter    = parameter;\n\n    timer->timeout_tick = 0;\n    timer->init_tick    = time;\n\n    /* initialize timer list */\n    for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)\n    {\n        rt_list_init(&(timer->row[i]));\n    }\n}"
            }
        ],
        "third_party": [
            "RT_ASSERT",
            "rt_object_allocate"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)",
        "start_line": "62",
        "end_line": "75",
        "file_path": "api/api.go",
        "docstring": "The function \"ServeHTTP\" processes an HTTP request by sequentially passing it through a series of handlers.\\nFor each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\\nIf any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\\nIf all handlers pass without unauthorized status, it forwards the request to the router for further handling.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dede8c248766",
        "ground_truth": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n for _, handler := range a.handlers {\n  rec := httptest.NewRecorder()\n  handler(rec, req)\n  for k, v := range rec.Header() {\n   res.Header()[k] = v\n  }\n  if rec.Code == http.StatusUnauthorized {\n   http.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n   return\n  }\n }\n a.router.ServeHTTP(res, req)\n}",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/bmizerany/pat\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/api/robeaux\"\n)"
        ],
        "reference_api": [
            "a.router.ServeHTTP",
            "res.Header",
            "handler",
            "http.Error",
            "httptest.NewRecorder",
            "rec.Header"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "a.router.ServeHTTP",
            "res.Header",
            "handler",
            "http.Error",
            "httptest.NewRecorder",
            "rec.Header"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) ",
        "start_line": "174",
        "end_line": "194",
        "file_path": "api/api.go",
        "docstring": "The function \"robeaux\" serves static assets in response to HTTP requests.\\nIt retrieves the requested asset based on the URL path and checks for errors.\\nIf the asset is found, it sets the appropriate Content-Type header based on the file extension (js, css, html).\\nIt then writes the asset content to the response.\\nIf an error occurs while retrieving the asset, it returns a 404 error.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "314b5f1c1ddc",
        "ground_truth": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n path := req.URL.Path\n buf, err := robeaux.Asset(path[1:])\n if err != nil {\n  http.Error(res, err.Error(), http.StatusNotFound)\n  return\n }\n split := strings.Split(path, \".\")\n ext := split[len(split)-1]\n switch ext {\n case \"js\":\n  res.Header().Set(\"Content-Type\", \"text/javascript; charset=utf-8\")\n case \"css\":\n  res.Header().Set(\"Content-Type\", \"text/css; charset=utf-8\")\n case \"html\":\n  res.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n }\n if _, err := res.Write(buf); err != nil {\n  panic(err)\n }\n}",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/bmizerany/pat\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/api/robeaux\"\n)"
        ],
        "reference_api": [
            "robeaux.Asset",
            "res.Header",
            "res.Write",
            "len",
            "strings.Split",
            "http.Error",
            "res.Header().Set",
            "err.Error",
            "panic"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "robeaux.Asset",
            "res.Header",
            "res.Write",
            "len",
            "http.Error",
            "res.Header().Set",
            "err.Error",
            "panic"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)",
        "start_line": "315",
        "end_line": "325",
        "file_path": "api/api.go",
        "docstring": "The function \"robotConnections\" handles HTTP requests to retrieve the connections of a specified robot.\\nIt extracts the robot name from the request URL and finds the corresponding robot using the master instance.\\nIf the robot is found, it gathers its connections and converts them to JSON format.\\nThe function then writes the JSON response containing the connections.\\nIf the robot is not found, it writes a JSON error message indicating that no robot was found with the specified name.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8ac41dfcacc9",
        "ground_truth": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request) {\n jsonConnections := []*gobot.JSONConnection{}\n if robot := a.master.Robot(req.URL.Query().Get(\":robot\")); robot != nil {\n  robot.Connections().Each(func(c gobot.Connection) {\n   jsonConnections = append(jsonConnections, gobot.NewJSONConnection(c))\n  })\n  a.writeJSON(map[string]interface{}{\"connections\": jsonConnections}, res)\n } else {\n  a.writeJSON(map[string]interface{}{\"error\": \"No Robot found with the name \" + req.URL.Query().Get(\":robot\")}, res)\n }\n}",
        "import_statements": [
            "import (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/bmizerany/pat\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/api/robeaux\"\n)"
        ],
        "reference_api": [
            "req.URL.Query().Get",
            "a.writeJSON",
            "a.master.Robot",
            "req.URL.Query",
            "robot.Connections",
            "append",
            "gobot.NewJSONConnection",
            "robot.Connections().Each"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "req.URL.Query().Get",
            "a.writeJSON",
            "a.master.Robot",
            "req.URL.Query",
            "robot.Connections",
            "append",
            "gobot.NewJSONConnection",
            "robot.Connections().Each"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func BasicAuth(username, password string) http.HandlerFunc",
        "start_line": "10",
        "end_line": "22",
        "file_path": "api/basic_auth.go",
        "docstring": "The function \"BasicAuth\" creates an HTTP handler that enforces Basic Authentication.\\nIt checks the \"Authorization\" header in the request against a base64-encoded username and password.\\nIf the comparison fails, it sets the \"WWW-Authenticate\" header and returns a \"Not Authorized\" response with a 401 status code.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "16a20222e69b",
        "ground_truth": "func BasicAuth(username, password string) http.HandlerFunc {\n // Inspired by https://github.com/codegangsta/martini-contrib/blob/master/auth/\n return func(res http.ResponseWriter, req *http.Request) {\n  if !secureCompare(req.Header.Get(\"Authorization\"),\n   \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)),\n  ) {\n   res.Header().Set(\"WWW-Authenticate\",\n    \"Basic realm=\\\"Authorization Required\\\"\",\n   )\n   http.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n  }\n }\n}",
        "import_statements": [
            "import (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"net/http\"\n)"
        ],
        "reference_api": [
            "res.Header",
            "req.Header.Get",
            "res.Header().Set",
            "http.Error",
            "secureCompare",
            "base64.StdEncoding.EncodeToString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "secureCompare",
                "code": "func secureCompare(given string, actual string) bool {\n\tif subtle.ConstantTimeEq(int32(len(given)), int32(len(actual))) == 1 {\n\t\treturn subtle.ConstantTimeCompare([]byte(given), []byte(actual)) == 1\n\t}\n\t// Securely compare actual to itself to keep constant time,\n\t// but always return false\n\treturn subtle.ConstantTimeCompare([]byte(actual), []byte(actual)) == 1 && false\n}"
            }
        ],
        "third_party": [
            "res.Header",
            "req.Header.Get",
            "res.Header().Set",
            "http.Error"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) ",
        "start_line": "147",
        "end_line": "159",
        "file_path": "drivers/aio/analog_actuator_driver.go",
        "docstring": "The function \"AnalogActuatorLinearScaler\" creates a linear scaler function to convert an input float value from one range to an integer value in another range.\\nIt calculates the slope and intercept for the scaling transformation and returns a function that performs the scaling.\\nThe returned function ensures the output is clamped within the target range.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c6b3dd5d10f7",
        "ground_truth": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) {\n m := float64(toMax-toMin) / (fromMax - fromMin)\n n := float64(toMin) - m*fromMin\n return func(input float64) int {\n  if input <= fromMin {\n   return toMin\n  }\n  if input >= fromMax {\n   return toMax\n  }\n  return int(input*m + n)\n }\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"strconv\"\n)"
        ],
        "reference_api": [
            "float64",
            "int"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "float64",
            "int"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)",
        "start_line": "214",
        "end_line": "231",
        "file_path": "drivers/aio/analog_sensor_driver.go",
        "docstring": "The function \"analogSensorRead\" reads the value from an analog sensor.\\nIt locks the mutex to ensure thread safety and verifies that the connection supports analog reading.\\nIf the connection is valid, it reads the raw value from the specified pin and updates the last raw and scaled values.\\nIt returns the raw value, the scaled value, and any error encountered during the read operation.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "973e7f360ae8",
        "ground_truth": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error) {\n a.mutex.Lock()\n defer a.mutex.Unlock()\n  reader, ok := a.connection.(AnalogReader)\n if !ok {\n  return 0, 0, fmt.Errorf(\"AnalogRead is not supported by the platform '%s'\", a.Connection().Name())\n }\n  rawValue, err := reader.AnalogRead(a.Pin())\n if err != nil {\n  return 0, 0, err\n }\n  a.lastRawValue = rawValue\n a.lastValue = a.sensorCfg.scale(a.lastRawValue)\n return a.lastRawValue, a.lastValue, nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n)"
        ],
        "reference_api": [
            "fmt.Errorf",
            "a.sensorCfg.scale",
            "a.Connection",
            "a.Connection().Name",
            "a.mutex.Lock",
            "a.Pin",
            "a.mutex.Unlock",
            "reader.AnalogRead"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "a.sensorCfg.scale",
            "a.Connection",
            "a.Connection().Name",
            "a.mutex.Lock",
            "a.Pin",
            "a.mutex.Unlock",
            "reader.AnalogRead"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 ",
        "start_line": "250",
        "end_line": "262",
        "file_path": "drivers/aio/analog_sensor_driver.go",
        "docstring": "The function \"AnalogSensorLinearScaler\" returns a scaling function that linearly maps input values from one range to another.\\nIt calculates the slope (m) and intercept (n) for the linear transformation based on the provided minimum and maximum values of the input and output ranges.\\nThe returned function scales the input value accordingly, ensuring it stays within the specified output range.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6defa4c6d37d",
        "ground_truth": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n m := (toMax - toMin) / float64(fromMax-fromMin)\n n := toMin - m*float64(fromMin)\n return func(input int) float64 {\n  if input <= fromMin {\n   return toMin\n  }\n  if input >= fromMax {\n   return toMax\n  }\n  return float64(input)*m + n\n }\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n)"
        ],
        "reference_api": [
            "float64"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "float64"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver",
        "start_line": "52",
        "end_line": "73",
        "file_path": "drivers/aio/grove_drivers.go",
        "docstring": "The function \"NewGrovePiezoVibrationSensorDriver\" creates and initializes a new Grove Piezo Vibration Sensor driver.\\nIt initializes the driver with an AnalogSensorDriver using the provided analog reader, pin, and optional parameters.\\nIt sets a default name for the driver and adds a vibration event.\\nThe function also sets up an event listener for data events that publishes a vibration event if the data exceeds a threshold value of 1000.\\nIf an error occurs while setting up the event listener, it panics.\\nFinally, it returns the initialized driver.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4c1015cd0618",
        "ground_truth": "func NewGrovePiezoVibrationSensorDriver(\n a AnalogReader,\n pin string,\n opts ...interface{},\n) *GrovePiezoVibrationSensorDriver {\n d := &GrovePiezoVibrationSensorDriver{\n  AnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n }\n d.driverCfg.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n  d.AddEvent(Vibration)\n  if err := d.On(d.Event(Data), func(data interface{}) {\n  if data.(int) > 1000 { //nolint:forcetypeassert // no error return value, so there is no better way\n   d.Publish(d.Event(Vibration), data)\n  }\n }); err != nil {\n  panic(err)\n }\n  return d\n}",
        "import_statements": [
            "import \"gobot.io/x/gobot/v2"
        ],
        "reference_api": [
            "gobot.DefaultName",
            "d.Publish",
            "d.On",
            "d.Event",
            "d.AddEvent",
            "NewAnalogSensorDriver",
            "panic"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "gobot.DefaultName",
            "d.Publish",
            "d.On",
            "d.Event",
            "d.AddEvent",
            "NewAnalogSensorDriver",
            "panic"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *BuzzerDriver) Tone(hz, duration float64) error",
        "start_line": "204",
        "end_line": "223",
        "file_path": "drivers/gpio/buzzer_driver.go",
        "docstring": "The function \"Tone\" generates a tone on a buzzer for a specified frequency (hz) and duration.\\nIt calculates the tone period based on the given frequency and the tempo based on the buzzer's beats per minute (bpm).\\nThe function then toggles the buzzer on and off at intervals determined by the tone period, repeating this process to match the desired tempo.\\nIf any error occurs while turning the buzzer on or off, the function returns the error.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "350571fc3b1f",
        "ground_truth": "func (d *BuzzerDriver) Tone(hz, duration float64) error {\n // calculation based off https://www.arduino.cc/en/Tutorial/Melody\n tone := (1.0 / (2.0 * hz)) * 1000000.0\n  tempo := ((60 / d.bpm) * (duration * 1000))\n  for i := 0.0; i < tempo*1000; i += tone * 2.0 {\n  if err := d.On(); err != nil {\n   return err\n  }\n  time.Sleep(time.Duration(tone) * time.Microsecond)\n   if err := d.Off(); err != nil {\n   return err\n  }\n  time.Sleep(time.Duration(tone) * time.Microsecond)\n }\n  return nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n)"
        ],
        "reference_api": [
            "time.Duration",
            "d.On",
            "time.Sleep",
            "d.Off"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "time.Duration",
            "d.On",
            "d.Off"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (d *EasyDriver) sleepWithSleepPin() error",
        "start_line": "232",
        "end_line": "246",
        "file_path": "drivers/gpio/easy_driver.go",
        "docstring": "The function \"sleepWithSleepPin\" puts the EasyDriver into sleep mode using the configured sleep pin.\\nIt checks if the sleep pin is set, returning an error if it is not.\\nIt stops any ongoing operations and sets the sleep pin to low, which is the active state for sleeping.\\nFinally, it marks the driver as sleeping and returns nil.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1fea4ec469d8",
        "ground_truth": "func (d *EasyDriver) sleepWithSleepPin() error {\n if d.easyCfg.sleepPin == \"\" {\n  return fmt.Errorf(\"sleepPin is not set for '%s'\", d.driverCfg.name)\n }\n  _ = d.stopIfRunning() // drop step errors\n  // sleepPin is active low\n if err := d.digitalWrite(d.easyCfg.sleepPin, 0); err != nil {\n  return err\n }\n d.sleeping = true\n  return nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gobot.io/x/gobot/v2\"\n)"
        ],
        "reference_api": [
            "d.stopIfRunning",
            "fmt.Errorf",
            "d.digitalWrite"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "d.stopIfRunning",
            "d.digitalWrite"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)",
        "start_line": "78",
        "end_line": "95",
        "file_path": "platforms/adaptors/analogpinsadaptor.go",
        "docstring": "The function \"analogPin\" retrieves or initializes an analog pin for a given ID.\\nIt first checks if the pins map is initialized, returning an error if not.\\nIf the pin for the given ID is already present, it returns the pin.\\nIf the pin is not present, it translates the ID to obtain the path and parameters, initializes a new analog pin with these parameters, stores it in the pins map, and then returns the new pin.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "850129d49bbe",
        "ground_truth": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error) {\n if a.pins == nil {\n  return nil, fmt.Errorf(\"not connected for pin %s\", id)\n }\n  pin := a.pins[id]\n  if pin == nil {\n  path, r, w, bufLen, err := a.translate(id)\n  if err != nil {\n   return nil, err\n  }\n  pin = a.sys.NewAnalogPin(path, r, w, bufLen)\n  a.pins[id] = pin\n }\n  return pin, nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"sync\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/system\"\n)"
        ],
        "reference_api": [
            "fmt.Errorf",
            "a.sys.NewAnalogPin",
            "a.translate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "a.sys.NewAnalogPin",
            "a.translate"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error ",
        "start_line": "211",
        "end_line": "220",
        "file_path": "platforms/adaptors/digitalpinsadaptor.go",
        "docstring": "The function \"DigitalWrite\" writes a digital value to a specified pin on a DigitalPinsAdaptor.\\nIt locks the adaptor's mutex to ensure thread safety, retrieves the digital pin with output direction, and writes the specified value to the pin.\\nIf any error occurs during pin retrieval, it returns the error.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "773651aede82",
        "ground_truth": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n a.mutex.Lock()\n defer a.mutex.Unlock()\n  pin, err := a.digitalPin(id, system.WithPinDirectionOutput(int(val)))\n if err != nil {\n  return err\n }\n return pin.Write(int(val))\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-multierror\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/system\"\n)"
        ],
        "reference_api": [
            "a.digitalPin",
            "int",
            "a.mutex.Lock",
            "system.WithPinDirectionOutput",
            "pin.Write",
            "a.mutex.Unlock"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "a.digitalPin",
            "int",
            "a.mutex.Lock",
            "system.WithPinDirectionOutput",
            "pin.Write",
            "a.mutex.Unlock"
        ]
    },
    {
        "subclass": "iot",
        "owner/repo": "hybridgroup/gobot",
        "function_declaration": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)",
        "start_line": "222",
        "end_line": "250",
        "file_path": "platforms/adaptors/digitalpinsadaptor.go",
        "docstring": "The function \"digitalPin\" retrieves or initializes a digital pin for a DigitalPinsAdaptor.\\nIt checks if the adaptor is connected to any pins and returns an error if not.\\nIt appends additional options to the pin's existing options and attempts to retrieve the pin by its ID.\\nIf the pin does not exist, it translates the ID to obtain chip and line information, creates a new digital pin, initializes it, and stores it.\\nIf the pin already exists, it applies the provided options to it.\\nFinally, it returns the configured pin.",
        "language": "Go",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2ab8ed2bd953",
        "ground_truth": "func (a *DigitalPinsAdaptor) digitalPin(\n id string,\n opts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error) {\n if a.pins == nil {\n  return nil, fmt.Errorf(\"not connected for pin %s\", id)\n }\n  o := append(a.pinOptions[id], opts...)\n pin := a.pins[id]\n  if pin == nil {\n  chip, line, err := a.translate(id)\n  if err != nil {\n   return nil, err\n  }\n  pin = a.sys.NewDigitalPin(chip, line, o...)\n  if err = a.initialize(pin); err != nil {\n   return nil, err\n  }\n  a.pins[id] = pin\n } else {\n  if err := pin.ApplyOptions(o...); err != nil {\n   return nil, err\n  }\n }\n  return pin, nil\n}",
        "import_statements": [
            "import (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-multierror\"\n\n\t\"gobot.io/x/gobot/v2\"\n\t\"gobot.io/x/gobot/v2/system\"\n)"
        ],
        "reference_api": [
            "a.sys.NewDigitalPin",
            "fmt.Errorf",
            "a.translate",
            "a.initialize",
            "pin.ApplyOptions",
            "append"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "a.sys.NewDigitalPin",
            "a.translate",
            "a.initialize",
            "pin.ApplyOptions",
            "append"
        ]
    }
]