[
    {
        "subclass": "Unity3D",
        "owner/repo": "Perfare/AssetStudio",
        "function_declaration": "public static void PreloadDll(string dllName)",
        "start_line": "12",
        "end_line": "26",
        "file_path": "AssetStudio.PInvoke/DllLoader.cs",
        "docstring": "The PreloadDll function is designed to preload a DLL by determining the current operating system and loading the DLL from a specified directory.\\nIt retrieves the DLL directory and then checks the OS platform.\\nIf the platform is Windows, it uses the Win32 method to load the DLL; otherwise, it uses the Posix method.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "47ee1dae200b",
        "ground_truth": "public static void PreloadDll(string dllName)\n{\n    var dllDir = GetDirectedDllDirectory();\n    // Not using OperatingSystem.Platform.\n    // See: https://www.mono-project.com/docs/faq/technical/#how-to-detect-the-execution-platform\n    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n    {\n        Win32.LoadDll(dllDir, dllName);\n    }\n    else\n    {\n        Posix.LoadDll(dllDir, dllName);\n    }\n}",
        "import_statements": [
            "using System",
            "using System.ComponentModel",
            "using System.Diagnostics",
            "using System.IO",
            "using System.Runtime.InteropServices"
        ],
        "reference_api": [
            "Win32.LoadDll",
            "Posix.LoadDll",
            "RuntimeInformation.IsOSPlatform",
            "GetDirectedDllDirectory"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetDirectedDllDirectory",
                "code": "private static string GetDirectedDllDirectory()\n        {\n            var localPath = Process.GetCurrentProcess().MainModule.FileName;\n            var localDir = Path.GetDirectoryName(localPath);\n\n            var subDir = Environment.Is64BitProcess ? \"x64\" : \"x86\";\n\n            var directedDllDir = Path.Combine(localDir, subDir);\n\n            return directedDllDir;\n        }"
            }
        ],
        "third_party": [
            "Win32.LoadDll",
            "Posix.LoadDll",
            "RuntimeInformation.IsOSPlatform"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Perfare/AssetStudio",
        "function_declaration": "private void LoadAssetsFromMemory(FileReader reader, string originalPath, string unityVersion = null)",
        "start_line": "151",
        "end_line": "175",
        "file_path": "AssetStudio/AssetsManager.cs",
        "docstring": "This function, LoadAssetsFromMemory, reads and processes asset files from memory using a FileReader object.\\nIt ensures the assets file is not already loaded, creates a SerializedFile instance, sets its version if needed,\\nadds it to the asset file list. Errors during this process are logged, and skipped files are noted.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2073a8291d05",
        "ground_truth": "private void LoadAssetsFromMemory(FileReader reader, string originalPath, string unityVersion = null)\n{\n    if (!assetsFileListHash.Contains(reader.FileName))\n    {\n        try\n        {\n            var assetsFile = new SerializedFile(reader, this);\n            assetsFile.originalPath = originalPath;\n            if (!string.IsNullOrEmpty(unityVersion) && assetsFile.header.m_Version < SerializedFileFormatVersion.Unknown_7)\n            {\n                assetsFile.SetVersion(unityVersion);\n            }\n            CheckStrippedVersion(assetsFile);\n            assetsFileList.Add(assetsFile);\n            assetsFileListHash.Add(assetsFile.fileName);\n        }\n        catch (Exception e)\n        {\n            Logger.Error($\"Error while reading assets file {reader.FullPath} from {Path.GetFileName(originalPath)}\", e);\n            resourceFileReaders.Add(reader.FileName, reader);\n        }\n    }\n    else\n        Logger.Info($\"Skipping {originalPath} ({reader.FileName})\");\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.IO.Compression",
            "using System.Linq",
            "using System.Text",
            "using static AssetStudio.ImportHelper"
        ],
        "reference_api": [
            "assetsFile.SetVersion",
            "assetsFileListHash.Contains",
            "string.IsNullOrEmpty",
            "Logger.Info",
            "assetsFileListHash.Add",
            "CheckStrippedVersion",
            "Logger.Error",
            "resourceFileReaders.Add",
            "Path.GetFileName",
            "assetsFileList.Add"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "CheckStrippedVersion",
                "code": "public void CheckStrippedVersion(SerializedFile assetsFile)\n        {\n            if (assetsFile.IsVersionStripped && string.IsNullOrEmpty(SpecifyUnityVersion))\n            {\n                throw new Exception(\"The Unity version has been stripped, please set the version in the options\");\n            }\n            if (!string.IsNullOrEmpty(SpecifyUnityVersion))\n            {\n                assetsFile.SetVersion(SpecifyUnityVersion);\n            }\n        }"
            }
        ],
        "third_party": [
            "assetsFile.SetVersion",
            "assetsFileListHash.Contains",
            "string.IsNullOrEmpty",
            "Logger.Info",
            "assetsFileListHash.Add",
            "Logger.Error",
            "resourceFileReaders.Add",
            "Path.GetFileName",
            "assetsFileList.Add"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Perfare/AssetStudio",
        "function_declaration": "public ImportedFrame FindFrameByPath(string path)",
        "start_line": "63",
        "end_line": "74",
        "file_path": "AssetStudio/IImported.cs",
        "docstring": "This function, FindFrameByPath, searches for a frame by its path.\\nIt extracts the name from the path, searches through child frames with that name,\\nand returns the frame if its path matches the given path. If no match is found, it returns null.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5dacc6a26301",
        "ground_truth": "public ImportedFrame FindFrameByPath(string path)\n{\n    var name = path.Substring(path.LastIndexOf('/') + 1);\n    foreach (var frame in FindChilds(name))\n    {\n        if (frame.Path.EndsWith(path, StringComparison.Ordinal))\n        {\n            return frame;\n        }\n    }\n    return null;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO"
        ],
        "reference_api": [
            "frame.Path.EndsWith",
            "path.LastIndexOf",
            "FindChilds",
            "path.Substring"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "FindChilds",
                "code": "public IEnumerable<ImportedFrame> FindChilds(string name)\n        {\n            if (Name == name)\n            {\n                yield return this;\n            }\n            foreach (var child in children)\n            {\n                foreach (var item in child.FindChilds(name))\n                {\n                    yield return item;\n                }\n            }\n        }"
            }
        ],
        "third_party": [
            "frame.Path.EndsWith",
            "path.LastIndexOf",
            "path.Substring"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Perfare/AssetStudio",
        "function_declaration": "public static FileReader DecompressGZip(FileReader reader)",
        "start_line": "54",
        "end_line": "66",
        "file_path": "AssetStudio/ImportHelper.cs",
        "docstring": "This function, DecompressGZip, decompresses a GZip-compressed FileReader object.\\nIt reads the compressed data into a MemoryStream, decompresses it using GZipStream,\\nand returns a new FileReader with the decompressed data.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c20b04c4ad37",
        "ground_truth": "public static FileReader DecompressGZip(FileReader reader)\n{\n    using (reader)\n    {\n        var stream = new MemoryStream();\n        using (var gs = new GZipStream(reader.BaseStream, CompressionMode.Decompress))\n        {\n            gs.CopyTo(stream);\n        }\n        stream.Position = 0;\n        return new FileReader(reader.FullPath, stream);\n    }\n}",
        "import_statements": [
            "using Org.Brotli.Dec",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.IO.Compression",
            "using System.Linq"
        ],
        "reference_api": [
            "gs.CopyTo"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "gs.CopyTo"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Perfare/AssetStudio",
        "function_declaration": "public void ParseStrings(SwitchForm[] switchForms, string[] commandStrings)",
        "start_line": "171",
        "end_line": "187",
        "file_path": "AssetStudio/7zip/Common/CommandLineParser.cs",
        "docstring": "This function, ParseStrings, processes an array of command strings using an array of SwitchForm objects.\\nIt iterates through the command strings, stops parsing switches if a specific stop token is found,\\nand adds unparsed or non-switch strings to a collection of non-switch strings.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "11ce5c7b009d",
        "ground_truth": "public void ParseStrings(SwitchForm[] switchForms, string[] commandStrings)\n{\n int numCommandStrings = commandStrings.Length;\n bool stopSwitch = false;\n for (int i = 0; i < numCommandStrings; i++)\n {\n  string s = commandStrings[i];\n  if (stopSwitch)\n   NonSwitchStrings.Add(s);\n  else\n   if (s == kStopSwitchParsing)\n   stopSwitch = true;\n  else\n   if (!ParseString(s, switchForms))\n   NonSwitchStrings.Add(s);\n }\n}",
        "import_statements": [
            "using System",
            "using System.Collections"
        ],
        "reference_api": [
            "NonSwitchStrings.Add",
            "ParseString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ParseString",
                "code": "bool ParseString(string srcString, SwitchForm[] switchForms)\n\t\t{\n\t\t\tint len = srcString.Length;\n\t\t\tif (len == 0)\n\t\t\t\treturn false;\n\t\t\tint pos = 0;\n\t\t\tif (!IsItSwitchChar(srcString[pos]))\n\t\t\t\treturn false;\n\t\t\twhile (pos < len)\n\t\t\t{\n\t\t\t\tif (IsItSwitchChar(srcString[pos]))\n\t\t\t\t\tpos++;\n\t\t\t\tconst int kNoLen = -1;\n\t\t\t\tint matchedSwitchIndex = 0;\n\t\t\t\tint maxLen = kNoLen;\n\t\t\t\tfor (int switchIndex = 0; switchIndex < _switches.Length; switchIndex++)\n\t\t\t\t{\n\t\t\t\t\tint switchLen = switchForms[switchIndex].IDString.Length;\n\t\t\t\t\tif (switchLen <= maxLen || pos + switchLen > len)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (String.Compare(switchForms[switchIndex].IDString, 0,\n\t\t\t\t\t\t\tsrcString, pos, switchLen, true) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmatchedSwitchIndex = switchIndex;\n\t\t\t\t\t\tmaxLen = switchLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (maxLen == kNoLen)\n\t\t\t\t\tthrow new Exception(\"maxLen == kNoLen\");\n\t\t\t\tSwitchResult matchedSwitch = _switches[matchedSwitchIndex];\n\t\t\t\tSwitchForm switchForm = switchForms[matchedSwitchIndex];\n\t\t\t\tif ((!switchForm.Multi) && matchedSwitch.ThereIs)\n\t\t\t\t\tthrow new Exception(\"switch must be single\");\n\t\t\t\tmatchedSwitch.ThereIs = true;\n\t\t\t\tpos += maxLen;\n\t\t\t\tint tailSize = len - pos;\n\t\t\t\tSwitchType type = switchForm.Type;\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase SwitchType.PostMinus:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tailSize == 0)\n\t\t\t\t\t\t\t\tmatchedSwitch.WithMinus = false;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmatchedSwitch.WithMinus = (srcString[pos] == kSwitchMinus);\n\t\t\t\t\t\t\t\tif (matchedSwitch.WithMinus)\n\t\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase SwitchType.PostChar:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tailSize < switchForm.MinLen)\n\t\t\t\t\t\t\t\tthrow new Exception(\"switch is not full\");\n\t\t\t\t\t\t\tstring charSet = switchForm.PostCharSet;\n\t\t\t\t\t\t\tconst int kEmptyCharValue = -1;\n\t\t\t\t\t\t\tif (tailSize == 0)\n\t\t\t\t\t\t\t\tmatchedSwitch.PostCharIndex = kEmptyCharValue;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint index = charSet.IndexOf(srcString[pos]);\n\t\t\t\t\t\t\t\tif (index < 0)\n\t\t\t\t\t\t\t\t\tmatchedSwitch.PostCharIndex = kEmptyCharValue;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmatchedSwitch.PostCharIndex = index;\n\t\t\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase SwitchType.LimitedPostString:\n\t\t\t\t\tcase SwitchType.UnLimitedPostString:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint minLen = switchForm.MinLen;\n\t\t\t\t\t\t\tif (tailSize < minLen)\n\t\t\t\t\t\t\t\tthrow new Exception(\"switch is not full\");\n\t\t\t\t\t\t\tif (type == SwitchType.UnLimitedPostString)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmatchedSwitch.PostStrings.Add(srcString.Substring(pos));\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tString stringSwitch = srcString.Substring(pos, minLen);\n\t\t\t\t\t\t\tpos += minLen;\n\t\t\t\t\t\t\tfor (int i = minLen; i < switchForm.MaxLen && pos < len; i++, pos++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tchar c = srcString[pos];\n\t\t\t\t\t\t\t\tif (IsItSwitchChar(c))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tstringSwitch += c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmatchedSwitch.PostStrings.Add(stringSwitch);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\n\t\t}"
            }
        ],
        "third_party": [
            "NonSwitchStrings.Add"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Perfare/AssetStudio",
        "function_declaration": "public Texture2DConverter(Texture2D m_Texture2D)",
        "start_line": "17",
        "end_line": "26",
        "file_path": "AssetStudioUtility/Texture2DConverter.cs",
        "docstring": "This constructor, Texture2DConverter, initializes a Texture2DConverter object by extracting and setting properties\\nsuch as image data, width, height, texture format, version, platform, and output size from a given Texture2D object.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b8da2d0a3f76",
        "ground_truth": "public Texture2DConverter(Texture2D m_Texture2D)\n{\n    reader = m_Texture2D.image_data;\n    m_Width = m_Texture2D.m_Width;\n    m_Height = m_Texture2D.m_Height;\n    m_TextureFormat = m_Texture2D.m_TextureFormat;\n    version = m_Texture2D.version;\n    platform = m_Texture2D.platform;\n    outPutSize = m_Width * m_Height * 4;\n}",
        "import_statements": [
            "using System",
            "using System.Runtime.CompilerServices",
            "using Texture2DDecoder"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "mob-sakai/ParticleEffectForUGUI",
        "function_declaration": "private static string CollectActiveNames(SerializedProperty sp, List<string> result)",
        "start_line": "16",
        "end_line": "43",
        "file_path": "Editor/AnimatablePropertyEditor.cs",
        "docstring": "This function, CollectActiveNames, gathers the names from a SerializedProperty array into a list.\\nIt clears the result list, iterates through the array, and adds each name to the list.\\nIf no names are found, it returns \"Nothing\".\\nOtherwise, it concatenates the names into a single string, separated by commas, and returns this string.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4d1412b550a3",
        "ground_truth": "private static string CollectActiveNames(SerializedProperty sp, List<string> result)\n{\n    result.Clear();\n    for (var i = 0; i < sp.arraySize; i++)\n    {\n        var spName = sp.GetArrayElementAtIndex(i).FindPropertyRelative(\"m_Name\");\n        if (spName == null) continue;\n        result.Add(spName.stringValue);\n    }\n    s_Sb.Length = 0;\n    if (result.Count == 0)\n    {\n        s_Sb.Append(\"Nothing\");\n    }\n    else\n    {\n        result.Aggregate(s_Sb, (a, b) =>\n        {\n            s_Sb.Append(b);\n            return s_Sb.Append(\", \");\n        });\n        s_Sb.Length -= 2;\n    }\n    return s_Sb.ToString();\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using System.Linq",
            "using System.Text",
            "using UnityEditor",
            "using UnityEngine"
        ],
        "reference_api": [
            "sp.GetArrayElementAtIndex",
            "result.Aggregate",
            "s_Sb.Append",
            "result.Clear",
            "result.Add",
            "s_Sb.ToString",
            "sp.GetArrayElementAtIndex(i).FindPropertyRelative"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "sp.GetArrayElementAtIndex",
            "result.Aggregate",
            "s_Sb.Append",
            "result.Clear",
            "result.Add",
            "s_Sb.ToString",
            "sp.GetArrayElementAtIndex(i).FindPropertyRelative"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "mob-sakai/ParticleEffectForUGUI",
        "function_declaration": "private static void AddMenu(GenericMenu menu, SerializedProperty sp, ShaderProperty prop, bool add)",
        "start_line": "100",
        "end_line": "122",
        "file_path": "Editor/AnimatablePropertyEditor.cs",
        "docstring": "This function, AddMenu, adds a menu item to a GenericMenu based on a ShaderProperty.\\nIf adding is allowed and the property name is not already active, it creates a menu item with the property's name and type.\\nSelecting the item will either remove the property from or add it to a SerializedProperty array,\\nand apply the changes to the serialized object.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5014bde74f8b",
        "ground_truth": "private static void AddMenu(GenericMenu menu, SerializedProperty sp, ShaderProperty prop, bool add)\n{\n    if (add && s_ActiveNames.Contains(prop.name)) return;\n    var label = new GUIContent($\"{prop.name} ({prop.type})\");\n    menu.AddItem(label, s_ActiveNames.Contains(prop.name), () =>\n    {\n        var index = s_ActiveNames.IndexOf(prop.name);\n        if (0 <= index)\n        {\n            sp.DeleteArrayElementAtIndex(index);\n        }\n        else\n        {\n            sp.InsertArrayElementAtIndex(sp.arraySize);\n            var p = sp.GetArrayElementAtIndex(sp.arraySize - 1);\n            p.FindPropertyRelative(\"m_Name\").stringValue = prop.name;\n            p.FindPropertyRelative(\"m_Type\").intValue = (int)prop.type;\n        }\n        sp.serializedObject.ApplyModifiedProperties();\n    });\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using System.Linq",
            "using System.Text",
            "using UnityEditor",
            "using UnityEngine"
        ],
        "reference_api": [
            "s_ActiveNames.Contains",
            "sp.GetArrayElementAtIndex",
            "sp.DeleteArrayElementAtIndex",
            "menu.AddItem",
            "sp.serializedObject.ApplyModifiedProperties",
            "sp.InsertArrayElementAtIndex",
            "p.FindPropertyRelative",
            "s_ActiveNames.IndexOf"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "s_ActiveNames.Contains",
            "sp.GetArrayElementAtIndex",
            "sp.DeleteArrayElementAtIndex",
            "menu.AddItem",
            "sp.serializedObject.ApplyModifiedProperties",
            "sp.InsertArrayElementAtIndex",
            "p.FindPropertyRelative",
            "s_ActiveNames.IndexOf"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "mob-sakai/ParticleEffectForUGUI",
        "function_declaration": "private static bool DrawFloatOrVector3Field(SerializedProperty sp, bool showXyz)",
        "start_line": "470",
        "end_line": "506",
        "file_path": "Editor/UIParticleEditor.cs",
        "docstring": "This function, DrawFloatOrVector3Field, draws a UI field for a SerializedProperty that can represent either a single float or a Vector3.\\nIt checks if the x, y, and z values are approximately equal or have multiple different values to determine the display mode.\\nIf showXyz is true, it displays the property as a Vector3; otherwise, it displays the x value and syncs y and z to x.\\nThe function also includes a toggle button to switch between single float and Vector3 display modes.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "20e390481814",
        "ground_truth": "private static bool DrawFloatOrVector3Field(SerializedProperty sp, bool showXyz)\n{\n    var x = sp.FindPropertyRelative(\"x\");\n    var y = sp.FindPropertyRelative(\"y\");\n    var z = sp.FindPropertyRelative(\"z\");\n    showXyz |= !Mathf.Approximately(x.floatValue, y.floatValue) ||\n               !Mathf.Approximately(y.floatValue, z.floatValue) ||\n               y.hasMultipleDifferentValues ||\n               z.hasMultipleDifferentValues;\n    EditorGUILayout.BeginHorizontal();\n    if (showXyz)\n    {\n        EditorGUILayout.PropertyField(sp);\n    }\n    else\n    {\n        EditorGUI.BeginChangeCheck();\n        EditorGUILayout.PropertyField(x, s_ContentScale);\n        if (EditorGUI.EndChangeCheck())\n        {\n            y.floatValue = z.floatValue = x.floatValue;\n        }\n    }\n    EditorGUI.BeginChangeCheck();\n    showXyz = GUILayout.Toggle(showXyz, s_Content3D, EditorStyles.miniButton, GUILayout.Width(30));\n    if (EditorGUI.EndChangeCheck() && !showXyz)\n    {\n        z.floatValue = y.floatValue = x.floatValue;\n    }\n    EditorGUILayout.EndHorizontal();\n    return showXyz;\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using System.Linq",
            "using System.Text.RegularExpressions",
            "using UnityEditor",
            "using UnityEditor.UI",
            "using UnityEditorInternal",
            "using UnityEngine",
            "using UnityEngine.Profiling",
            "using UnityEngine.UI",
            "using Coffee.UIParticleExtensions"
        ],
        "reference_api": [
            "EditorGUILayout.PropertyField",
            "EditorGUI.BeginChangeCheck",
            "GUILayout.Width",
            "EditorGUILayout.EndHorizontal",
            "Mathf.Approximately",
            "GUILayout.Toggle",
            "EditorGUILayout.BeginHorizontal",
            "EditorGUI.EndChangeCheck",
            "sp.FindPropertyRelative"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "EditorGUILayout.PropertyField",
            "EditorGUI.BeginChangeCheck",
            "GUILayout.Width",
            "EditorGUILayout.EndHorizontal",
            "Mathf.Approximately",
            "GUILayout.Toggle",
            "EditorGUILayout.BeginHorizontal",
            "EditorGUI.EndChangeCheck",
            "sp.FindPropertyRelative"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "mob-sakai/ParticleEffectForUGUI",
        "function_declaration": "public static Material Add(Material baseMat, Texture texture, int id, int props)",
        "start_line": "10",
        "end_line": "38",
        "file_path": "Runtime/ModifiedMaterial.cs",
        "docstring": "This function, Add, creates or retrieves a custom material based on a base material, texture, id, and properties.\\nIt searches for an existing matching entry in a list and increments its count if found, returning the custom material.\\nIf no match is found, it creates a new material entry, sets its properties, adds it to the list, and returns the new custom material.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c3587cbcda7e",
        "ground_truth": "public static Material Add(Material baseMat, Texture texture, int id, int props)\n{\n    MatEntry e;\n    for (var i = 0; i < s_Entries.Count; i++)\n    {\n        e = s_Entries[i];\n        if (e.baseMat != baseMat || e.texture != texture || e.id != id || e.props != props) continue;\n        ++e.count;\n        return e.customMat;\n    }\n    e = new MatEntry\n    {\n        count = 1,\n        baseMat = baseMat,\n        texture = texture,\n        id = id,\n        props = props,\n        customMat = new Material(baseMat)\n        {\n            name = $\"{baseMat.name}_{id}\",\n            hideFlags = HideFlags.DontSave | HideFlags.NotEditable,\n            mainTexture = texture ? texture : baseMat.mainTexture\n        }\n    };\n    s_Entries.Add(e);\n    //Debug.LogFormat(\">>>> ModifiedMaterial.Add -> count = count:{0}, mat:{1}, tex:{2}, id:{3}\", s_Entries.Count, baseMat, texture, id);\n    return e.customMat;\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using UnityEngine"
        ],
        "reference_api": [
            "s_Entries.Add"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "s_Entries.Add"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "mob-sakai/ParticleEffectForUGUI",
        "function_declaration": "public static void Remove(Material customMat)",
        "start_line": "40",
        "end_line": "60",
        "file_path": "Runtime/ModifiedMaterial.cs",
        "docstring": "This function, Remove, handles the removal of a custom material from a list of entries.\\nIt checks if the material is valid, iterates through the list, and decreases the count of the matching entry.\\nIf the count reaches zero, it destroys the material and clears its associated data, then removes the entry from the list.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a35149bc8b8b",
        "ground_truth": "public static void Remove(Material customMat)\n{\n    if (!customMat) return;\n    for (var i = 0; i < s_Entries.Count; ++i)\n    {\n        var e = s_Entries[i];\n        if (e.customMat != customMat) continue;\n        if (--e.count == 0)\n        {\n            //Debug.LogFormat(\">>>> ModifiedMaterial.Remove -> count:{0}, mat:{1}, tex:{2}, id:{3}\", s_Entries.Count - 1, e.customMat, e.texture, e.id);\n            Misc.DestroyImmediate(e.customMat);\n            e.customMat = null;\n            e.baseMat = null;\n            e.texture = null;\n            s_Entries.RemoveAt(i);\n        }\n        break;\n    }\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using UnityEngine"
        ],
        "reference_api": [
            "Misc.DestroyImmediate",
            "s_Entries.RemoveAt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Misc.DestroyImmediate",
            "s_Entries.RemoveAt"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "mob-sakai/ParticleEffectForUGUI",
        "function_declaration": "private void RefreshParticles(GameObject root)",
        "start_line": "530",
        "end_line": "554",
        "file_path": "Runtime/UIParticle.cs",
        "docstring": "This function, RefreshParticles, updates the particle systems in a GameObject's hierarchy.\\nIt collects all child particle systems, removes those not associated with the current UIParticle instance,\\nand adjusts their texture sheet animation settings if necessary.\\nFinally, it calls RefreshParticles on the updated list of particle systems.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "892bbee52ab9",
        "ground_truth": "private void RefreshParticles(GameObject root)\n{\n    if (!root) return;\n    root.GetComponentsInChildren(true, particles);\n    for (var i = particles.Count - 1; 0 <= i; i--)\n    {\n        var ps = particles[i];\n        if (!ps || ps.GetComponentInParent<UIParticle>(true) != this)\n        {\n            particles.RemoveAt(i);\n        }\n    }\n    for (var i = 0; i < particles.Count; i++)\n    {\n        var ps = particles[i];\n        var tsa = ps.textureSheetAnimation;\n        if (tsa.mode == ParticleSystemAnimationMode.Sprites && tsa.uvChannelMask == 0)\n        {\n            tsa.uvChannelMask = UVChannelFlags.UV0;\n        }\n    }\n    RefreshParticles(particles);\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Runtime.CompilerServices",
            "using Coffee.UIParticleExtensions",
            "using UnityEngine",
            "using UnityEngine.Rendering",
            "using UnityEngine.Serialization",
            "using UnityEngine.UI",
            "using Random = UnityEngine.Random"
        ],
        "reference_api": [
            "RefreshParticles",
            "particles.RemoveAt",
            "root.GetComponentsInChildren",
            "ps.GetComponentInParent<UIParticle>"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RefreshParticles",
                "code": "public void RefreshParticles()\n        {\n            RefreshParticles(gameObject);\n        }"
            }
        ],
        "third_party": [
            "particles.RemoveAt",
            "root.GetComponentsInChildren",
            "ps.GetComponentInParent<UIParticle>"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "private void RegisterColorSwapManagers(ContainerBuilder containerBuilder)",
        "start_line": "153",
        "end_line": "160",
        "file_path": "NitroxClient/ClientAutoFacRegistrar.cs",
        "docstring": "This function, RegisterColorSwapManagers, registers all types in the current assembly that implement the IColorSwapManager interface\\nwith a container builder. It configures these types to be treated as single-instance components.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d6b082e37770",
        "ground_truth": "private void RegisterColorSwapManagers(ContainerBuilder containerBuilder)\n{\n    containerBuilder\n        .RegisterAssemblyTypes(currentAssembly)\n        .AssignableTo<IColorSwapManager>()\n        .As<IColorSwapManager>()\n        .SingleInstance();\n}",
        "import_statements": [
            "global using NitroxClient.Helpers",
            "global using NitroxModel.Logger",
            "global using static NitroxModel.Extensions",
            "using System.Reflection",
            "using Autofac",
            "using Autofac.Core",
            "using NitroxClient.Communication",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.Communication.MultiplayerSession",
            "using NitroxClient.Communication.NetworkingLayer.LiteNetLib",
            "using NitroxClient.Communication.Packets.Processors.Abstract",
            "using NitroxClient.Debuggers",
            "using NitroxClient.Debuggers.Drawer",
            "using NitroxClient.GameLogic",
            "using NitroxClient.GameLogic.ChatUI",
            "using NitroxClient.GameLogic.FMOD",
            "using NitroxClient.GameLogic.HUD",
            "using NitroxClient.GameLogic.InitialSync.Abstract",
            "using NitroxClient.GameLogic.PlayerLogic",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerModel",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerModel.Abstract",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerPreferences",
            "using NitroxClient.GameLogic.Settings",
            "using NitroxClient.GameLogic.Spawning.Metadata",
            "using NitroxClient.GameLogic.Spawning.Metadata.Extractor.Abstract",
            "using NitroxClient.GameLogic.Spawning.Metadata.Processor.Abstract",
            "using NitroxClient.Map",
            "using NitroxModel",
            "using NitroxModel.Core",
            "using NitroxModel.GameLogic.FMOD",
            "using NitroxModel.Helper",
            "using NitroxModel_Subnautica.Helper"
        ],
        "reference_api": [
            "containerBuilder\n                .RegisterAssemblyTypes(currentAssembly)\n                .AssignableTo<IColorSwapManager>()\n                .As<IColorSwapManager>()\n                .SingleInstance",
            "containerBuilder\n                .RegisterAssemblyTypes(currentAssembly)\n                .AssignableTo<IColorSwapManager>()\n                .As<IColorSwapManager>",
            "containerBuilder\n                .RegisterAssemblyTypes(currentAssembly)\n                .AssignableTo<IColorSwapManager>",
            "containerBuilder\n                .RegisterAssemblyTypes"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "containerBuilder\n                .RegisterAssemblyTypes(currentAssembly)\n                .AssignableTo<IColorSwapManager>()\n                .As<IColorSwapManager>()\n                .SingleInstance",
            "containerBuilder\n                .RegisterAssemblyTypes(currentAssembly)\n                .AssignableTo<IColorSwapManager>()\n                .As<IColorSwapManager>",
            "containerBuilder\n                .RegisterAssemblyTypes(currentAssembly)\n                .AssignableTo<IColorSwapManager>",
            "containerBuilder\n                .RegisterAssemblyTypes"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": " public async Task ConnectAsync(string ipAddress, int port)",
        "start_line": "48",
        "end_line": "54",
        "file_path": "NitroxClient/Communication/MultiplayerSession/MultiplayerSessionManager.cs",
        "docstring": "This function, ConnectAsync, sets the IP address and port, then waits for a serializer initialization task to complete.\\nAfterward, it initiates a reservation negotiation using the current state.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2359d72977a4",
        "ground_truth": "public async Task ConnectAsync(string ipAddress, int port)\n{\n    IpAddress = ipAddress;\n    ServerPort = port;\n    await initSerializerTask;\n    await CurrentState.NegotiateReservationAsync(this);\n}",
        "import_statements": [
            "using System",
            "using System.Threading.Tasks",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.Communication.MultiplayerSession.ConnectionState",
            "using NitroxClient.GameLogic",
            "using NitroxModel.DataStructures",
            "using NitroxModel.Helper",
            "using NitroxModel.MultiplayerSession",
            "using NitroxModel.Packets",
            "using NitroxModel.Serialization"
        ],
        "reference_api": [
            "CurrentState.NegotiateReservationAsync"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "CurrentState.NegotiateReservationAsync"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public void UpdateConnectionState(IMultiplayerSessionConnectionState sessionConnectionState)",
        "start_line": "134",
        "end_line": "151",
        "file_path": "NitroxClient/Communication/MultiplayerSession/MultiplayerSessionManager.cs",
        "docstring": "This function, UpdateConnectionState, updates the current multiplayer session connection state.\\nIt validates the input, logs the transition from the previous state to the new state,\\nand invokes the ConnectionStateChanged event. If the new state is SESSION_RESERVED,\\nit updates the player name in the log.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "151a27d718b1",
        "ground_truth": "public void UpdateConnectionState(IMultiplayerSessionConnectionState sessionConnectionState)\n{\n    Validate.NotNull(sessionConnectionState);\n    string fromStage = CurrentState == null ? \"null\" : CurrentState.CurrentStage.ToString();\n    string username = AuthenticationContext == null ? \"\" : AuthenticationContext.Username;\n    Log.Debug($\"Updating session stage from '{fromStage}' to '{sessionConnectionState.CurrentStage}' for '{username}'\");\n    CurrentState = sessionConnectionState;\n    // Last connection state changed will not have any handlers\n    ConnectionStateChanged?.Invoke(CurrentState);\n    if (sessionConnectionState.CurrentStage == MultiplayerSessionConnectionStage.SESSION_RESERVED)\n    {\n        Log.PlayerName = username;\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Threading.Tasks",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.Communication.MultiplayerSession.ConnectionState",
            "using NitroxClient.GameLogic",
            "using NitroxModel.DataStructures",
            "using NitroxModel.Helper",
            "using NitroxModel.MultiplayerSession",
            "using NitroxModel.Packets",
            "using NitroxModel.Serialization"
        ],
        "reference_api": [
            "CurrentState.CurrentStage.ToString",
            "Validate.NotNull",
            "Log.Debug",
            "ConnectionStateChanged?.Invoke"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "CurrentState.CurrentStage.ToString",
            "Validate.NotNull",
            "Log.Debug",
            "ConnectionStateChanged?.Invoke"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public async Task StartAsync(string ipAddress, int serverPort)",
        "start_line": "43",
        "end_line": "57",
        "file_path": "NitroxClient/Communication/NetworkingLayer/LiteNetLib/LiteNetLibClient.cs",
        "docstring": "This function, StartAsync, asynchronously initializes and starts a LiteNetLibClient, then attempts to connect it to a server\\nusing a specified IP address and port. It waits for a connection event for up to 2000 milliseconds and then resets the event.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7f7717307d6a",
        "ground_truth": "public async Task StartAsync(string ipAddress, int serverPort)\n{\n    Log.Info(\"Initializing LiteNetLibClient...\");\n    // ConfigureAwait(false) is needed because Unity uses a custom \"UnitySynchronizationContext\". Which makes async/await work like Unity coroutines.\n    // Because this Task.Run is async-over-sync this would otherwise blocks the main thread as it wants to, without ConfigureAwait(false), continue on the same thread (i.e. main thread).\n    await Task.Run(() =>\n    {\n        client.Start();\n        client.Connect(ipAddress, serverPort, \"nitrox\");\n    }).ConfigureAwait(false);\n    connectedEvent.WaitOne(2000);\n    connectedEvent.Reset();\n}",
        "import_statements": [
            "using System.Buffers",
            "using System.Threading",
            "using System.Threading.Tasks",
            "using LiteNetLib",
            "using LiteNetLib.Utils",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.Debuggers",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.MonoBehaviours.Gui.Modals",
            "using NitroxModel.Networking",
            "using NitroxModel.Packets"
        ],
        "reference_api": [
            "connectedEvent.Reset",
            "Log.Info",
            "connectedEvent.WaitOne",
            "Task.Run",
            "Task.Run(() =>\n        {\n            client.Start();\n            client.Connect(ipAddress, serverPort, \"nitrox\");\n        }).ConfigureAwait",
            "client.Connect",
            "client.Start"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "connectedEvent.Reset",
            "Log.Info",
            "connectedEvent.WaitOne",
            "Task.Run(() =>\n        {\n            client.Start();\n            client.Connect(ipAddress, serverPort, \"nitrox\");\n        }).ConfigureAwait",
            "client.Connect",
            "client.Start"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public void StartFireSuppression(NitroxId id)",
        "start_line": "66",
        "end_line": "76",
        "file_path": "NitroxClient/GameLogic/Cyclops.cs",
        "docstring": "This function, StartFireSuppression, initiates the fire suppression system on a Cyclops object identified by a NitroxId.\\nIt retrieves the Cyclops object, finds the fire suppression button component, and starts the fire suppression system coroutine.\\nIt also begins the cooldown period for the button, ensuring the process is handled within a packet suppressor context.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "eeb95434f1eb",
        "ground_truth": "public void StartFireSuppression(NitroxId id)\n{\n    GameObject cyclops = NitroxEntity.RequireObjectFrom(id);\n    CyclopsFireSuppressionSystemButton fireSuppButton = cyclops.RequireComponentInChildren<CyclopsFireSuppressionSystemButton>();\n    using (PacketSuppressor<CyclopsFireSuppression>.Suppress())\n    {\n        // Infos from SubFire.StartSystem\n        fireSuppButton.subFire.StartCoroutine(StartFireSuppressionSystem(fireSuppButton.subFire));\n        fireSuppButton.StartCooldown();\n    }\n}",
        "import_statements": [
            "using System.Collections",
            "using System.Collections.Generic",
            "using System.Linq",
            "using NitroxClient.Communication",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel_Subnautica.DataStructures",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.Packets",
            "using NitroxModel_Subnautica.DataStructures.GameLogic",
            "using NitroxModel_Subnautica.Packets",
            "using UnityEngine",
            "using static NitroxClient.GameLogic.Spawning.Metadata.Extractor.CyclopsMetadataExtractor"
        ],
        "reference_api": [
            "StartFireSuppressionSystem",
            "PacketSuppressor<CyclopsFireSuppression>.Suppress",
            "NitroxEntity.RequireObjectFrom",
            "fireSuppButton.subFire.StartCoroutine",
            "fireSuppButton.StartCooldown",
            "cyclops.RequireComponentInChildren<CyclopsFireSuppressionSystemButton>"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "StartFireSuppressionSystem",
                "code": "private IEnumerator StartFireSuppressionSystem(SubFire fire)\n        {\n            fire.subRoot.voiceNotificationManager.PlayVoiceNotification(fire.subRoot.fireSupressionNotification, false, true);\n            yield return Yielders.WaitFor3Seconds;\n            fire.fireSuppressionActive = true;\n            fire.subRoot.fireSuppressionState = true;\n            fire.subRoot.BroadcastMessage(\"NewAlarmState\", null, SendMessageOptions.DontRequireReceiver);\n            fire.Invoke(nameof(SubFire.CancelFireSuppression), fire.fireSuppressionSystemDuration);\n            float doorCloseDuration = 30f;\n            fire.gameObject.BroadcastMessage(\"TemporaryLock\", doorCloseDuration, SendMessageOptions.DontRequireReceiver);\n        }"
            }
        ],
        "third_party": [
            "PacketSuppressor<CyclopsFireSuppression>.Suppress",
            "NitroxEntity.RequireObjectFrom",
            "fireSuppButton.subFire.StartCoroutine",
            "fireSuppButton.StartCooldown",
            "cyclops.RequireComponentInChildren<CyclopsFireSuppressionSystemButton>"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public void OnDamagePointRepaired(SubRoot subRoot, CyclopsDamagePoint damagePoint, float repairAmount)",
        "start_line": "108",
        "end_line": "125",
        "file_path": "NitroxClient/GameLogic/Cyclops.cs",
        "docstring": "This function, OnDamagePointRepaired, handles the event when a damage point on a SubRoot is repaired.\\nIt verifies the SubRoot ID, identifies the specific damage point, creates a repair packet with the relevant details,\\nand sends this packet using a packet sender.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a23a043559c6",
        "ground_truth": "public void OnDamagePointRepaired(SubRoot subRoot, CyclopsDamagePoint damagePoint, float repairAmount)\n{\n    if (!subRoot.TryGetIdOrWarn(out NitroxId subId))\n    {\n        return;\n    }\n    for (int i = 0; i < subRoot.damageManager.damagePoints.Length; i++)\n    {\n        if (subRoot.damageManager.damagePoints[i] == damagePoint)\n        {\n            CyclopsDamagePointRepaired packet = new(subId, i, repairAmount);\n            packetSender.Send(packet);\n            return;\n        }\n    }\n}",
        "import_statements": [
            "using System.Collections",
            "using System.Collections.Generic",
            "using System.Linq",
            "using NitroxClient.Communication",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel_Subnautica.DataStructures",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.Packets",
            "using NitroxModel_Subnautica.DataStructures.GameLogic",
            "using NitroxModel_Subnautica.Packets",
            "using UnityEngine",
            "using static NitroxClient.GameLogic.Spawning.Metadata.Extractor.CyclopsMetadataExtractor"
        ],
        "reference_api": [
            "subRoot.TryGetIdOrWarn",
            "packetSender.Send"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "subRoot.TryGetIdOrWarn",
            "packetSender.Send"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "private void BroadcastDamageState(SubRoot subRoot, Optional<DamageInfo> info)",
        "start_line": "130",
        "end_line": "157",
        "file_path": "NitroxClient/GameLogic/Cyclops.cs",
        "docstring": "This function, BroadcastDamageState, sends a damage state update for a given SubRoot object.\\nIt checks if the SubRoot has a valid ID and sufficient health. If damage information is provided,\\nit creates a CyclopsDamageInfoData object. It then gathers active damage points and fire data,\\nconstructs a CyclopsDamage packet with the collected information, and sends the packet.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dfb3586de856",
        "ground_truth": "private void BroadcastDamageState(SubRoot subRoot, Optional<DamageInfo> info)\n{\n    if (!subRoot.TryGetIdOrWarn(out NitroxId subId))\n    {\n        return;\n    }\n    LiveMixin subHealth = subRoot.gameObject.RequireComponent<LiveMixin>();\n    if (subHealth.health <= 0)\n    {\n        return;\n    }\n    CyclopsDamageInfoData damageInfo = null;\n    if (info.HasValue)\n    {\n        DamageInfo damage = info.Value;\n        Optional<NitroxId> dealerId = damage.dealer.GetId();\n        // Source of the damage. Used if the damage done to the Cyclops was not calculated on other clients. Currently it's just used to figure out what sounds and\n        // visual effects should be used.\n        damageInfo = new CyclopsDamageInfoData(subId, dealerId, damage.originalDamage, damage.damage, damage.position.ToDto(), damage.type);\n    }\n    int[] damagePointIndexes = GetActiveDamagePoints(subRoot).ToArray();\n    CyclopsFireData[] firePoints = GetActiveRoomFires(subRoot.GetComponent<SubFire>()).ToArray();\n    CyclopsDamage packet = new(subId, subRoot.GetComponent<LiveMixin>().health, subRoot.damageManager.subLiveMixin.health, subRoot.GetComponent<SubFire>().liveMixin.health, damagePointIndexes, firePoints, damageInfo);\n    packetSender.Send(packet);\n}",
        "import_statements": [
            "using System.Collections",
            "using System.Collections.Generic",
            "using System.Linq",
            "using NitroxClient.Communication",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel_Subnautica.DataStructures",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.Packets",
            "using NitroxModel_Subnautica.DataStructures.GameLogic",
            "using NitroxModel_Subnautica.Packets",
            "using UnityEngine",
            "using static NitroxClient.GameLogic.Spawning.Metadata.Extractor.CyclopsMetadataExtractor"
        ],
        "reference_api": [
            "damage.dealer.GetId",
            "GetActiveDamagePoints(subRoot).ToArray",
            "packetSender.Send",
            "subRoot.TryGetIdOrWarn",
            "damage.position.ToDto",
            "subRoot.GetComponent<SubFire>",
            "GetActiveRoomFires(subRoot.GetComponent<SubFire>()).ToArray",
            "subRoot.gameObject.RequireComponent<LiveMixin>",
            "GetActiveRoomFires",
            "subRoot.GetComponent<LiveMixin>",
            "GetActiveDamagePoints"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetActiveRoomFires",
                "code": "private IEnumerable<CyclopsFireData> GetActiveRoomFires(SubFire subFire)\n        {\n            if (!subFire.subRoot.TryGetIdOrWarn(out NitroxId subRootId))\n            {\n                yield break;\n            }\n\n            foreach (KeyValuePair<CyclopsRooms, SubFire.RoomFire> roomFire in subFire.roomFires)\n            {\n                for (int i = 0; i < roomFire.Value.spawnNodes.Length; i++)\n                {\n                    if (roomFire.Value.spawnNodes[i].childCount > 0)\n                    {\n                        if (!roomFire.Value.spawnNodes[i].GetComponentInChildren<Fire>().TryGetIdOrWarn(out NitroxId fireId))\n                        {\n                            yield break;\n                        }\n\n                        yield return new CyclopsFireData(fireId, subRootId, roomFire.Key, i);\n                    }\n                }\n            }\n        }"
            },
            {
                "name": "GetActiveDamagePoints",
                "code": "private IEnumerable<int> GetActiveDamagePoints(SubRoot subRoot)\n        {\n            for (int i = 0; i < subRoot.damageManager.damagePoints.Length; i++)\n            {\n                if (subRoot.damageManager.damagePoints[i].gameObject.activeSelf)\n                {\n                    yield return i;\n                }\n            }\n        }"
            }
        ],
        "third_party": [
            "damage.dealer.GetId",
            "GetActiveDamagePoints(subRoot).ToArray",
            "packetSender.Send",
            "subRoot.TryGetIdOrWarn",
            "damage.position.ToDto",
            "subRoot.GetComponent<SubFire>",
            "GetActiveRoomFires(subRoot.GetComponent<SubFire>()).ToArray",
            "subRoot.gameObject.RequireComponent<LiveMixin>",
            "subRoot.GetComponent<LiveMixin>"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public void CleanupExistingEntities(List<Entity> dirtyEntities)",
        "start_line": "244",
        "end_line": "257",
        "file_path": "NitroxClient/GameLogic/Entities.cs",
        "docstring": "This function, CleanupExistingEntities, processes a list of dirty entities.\\nFor each entity, it removes the entity hierarchy and attempts to get the associated GameObject.\\nIf the GameObject exists, it destroys the GameObject.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "03223c10109f",
        "ground_truth": "public void CleanupExistingEntities(List<Entity> dirtyEntities)\n{\n    foreach (Entity entity in dirtyEntities)\n    {\n        RemoveEntityHierarchy(entity);\n        Optional<GameObject> gameObject = NitroxEntity.GetObjectFrom(entity.Id);\n        if (gameObject.HasValue)\n        {\n            UnityEngine.Object.Destroy(gameObject.Value);\n        }\n    }\n}",
        "import_statements": [
            "using System",
            "using System.Collections",
            "using System.Collections.Generic",
            "using System.Linq",
            "using NitroxClient.Communication",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerModel.Abstract",
            "using NitroxClient.GameLogic.Spawning",
            "using NitroxClient.GameLogic.Spawning.Abstract",
            "using NitroxClient.GameLogic.Spawning.Bases",
            "using NitroxClient.GameLogic.Spawning.Metadata",
            "using NitroxClient.GameLogic.Spawning.WorldEntities",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.GameLogic",
            "using NitroxModel.DataStructures.GameLogic.Entities",
            "using NitroxModel.DataStructures.GameLogic.Entities.Bases",
            "using NitroxModel.DataStructures.GameLogic.Entities.Metadata",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.Packets",
            "using UnityEngine",
            "using UWE"
        ],
        "reference_api": [
            "UnityEngine.Object.Destroy",
            "RemoveEntityHierarchy",
            "NitroxEntity.GetObjectFrom"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RemoveEntityHierarchy",
                "code": "public void RemoveEntityHierarchy(Entity entity)\n        {\n            RemoveEntity(entity.Id);\n\n            foreach (Entity child in entity.ChildEntities)\n            {\n                RemoveEntityHierarchy(child);\n            }\n        }"
            }
        ],
        "third_party": [
            "UnityEngine.Object.Destroy",
            "NitroxEntity.GetObjectFrom"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "private void AddPendingParentEntity(Entity entity)",
        "start_line": "271",
        "end_line": "280",
        "file_path": "NitroxClient/GameLogic/Entities.cs",
        "docstring": "This function, AddPendingParentEntity, adds an entity to a list of pending parent entities.\\nIt checks if the parent ID already has an associated list in the dictionary. If not, it creates one.\\nThen it adds the entity to the appropriate list.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "990abe8e473e",
        "ground_truth": "private void AddPendingParentEntity(Entity entity)\n{\n    if (!pendingParentEntitiesByParentId.TryGetValue(entity.ParentId, out List<Entity> pendingEntities))\n    {\n        pendingEntities = new List<Entity>();\n        pendingParentEntitiesByParentId[entity.ParentId] = pendingEntities;\n    }\n    pendingEntities.Add(entity);\n}",
        "import_statements": [
            "using System",
            "using System.Collections",
            "using System.Collections.Generic",
            "using System.Linq",
            "using NitroxClient.Communication",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerModel.Abstract",
            "using NitroxClient.GameLogic.Spawning",
            "using NitroxClient.GameLogic.Spawning.Abstract",
            "using NitroxClient.GameLogic.Spawning.Bases",
            "using NitroxClient.GameLogic.Spawning.Metadata",
            "using NitroxClient.GameLogic.Spawning.WorldEntities",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.GameLogic",
            "using NitroxModel.DataStructures.GameLogic.Entities",
            "using NitroxModel.DataStructures.GameLogic.Entities.Bases",
            "using NitroxModel.DataStructures.GameLogic.Entities.Metadata",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.Packets",
            "using UnityEngine",
            "using UWE"
        ],
        "reference_api": [
            "pendingParentEntitiesByParentId.TryGetValue",
            "pendingEntities.Add"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "pendingParentEntitiesByParentId.TryGetValue",
            "pendingEntities.Add"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public void BroadcastClawUse(ExosuitClawArm clawArm, float cooldown)",
        "start_line": "21",
        "end_line": "41",
        "file_path": "NitroxClient/GameLogic/ExosuitModuleEvent.cs",
        "docstring": "This function, BroadcastClawUse, broadcasts an action performed by an ExosuitClawArm based on the cooldown time.\\nIt determines the action type by comparing the cooldown with predefined pickup and punch cooldowns.\\nIf the cooldown matches the pickup time, it sets the action to START_USE_TOOL.\\nIf it matches the punch time, it sets the action to ALT_HIT.\\nIf neither, it logs an error. Finally, it broadcasts the action using BroadcastArmAction.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a885fbb1f085",
        "ground_truth": "public void BroadcastClawUse(ExosuitClawArm clawArm, float cooldown)\n{\n    ExosuitArmAction action;\n    // If cooldown of claw arm matches pickup cooldown, the exosuit arm performed a pickup action\n    if (cooldown == clawArm.cooldownPickup)\n    {\n        action = ExosuitArmAction.START_USE_TOOL;\n    } // Else if it matches the punch cooldown, it has punched something (or nothing but water, who knows)\n    else if (cooldown == clawArm.cooldownPunch)\n    {\n        action = ExosuitArmAction.ALT_HIT;\n    }\n    else\n    {\n        Log.Error(\"Cooldown time does not match pickup or punch time\");\n        return;\n    }\n    BroadcastArmAction(TechType.ExosuitClawArmModule, clawArm, action, null, null);\n}",
        "import_statements": [
            "using NitroxClient.Communication.Abstract",
            "using NitroxModel_Subnautica.DataStructures",
            "using NitroxModel.DataStructures",
            "using NitroxModel_Subnautica.Packets",
            "using UnityEngine"
        ],
        "reference_api": [
            "Log.Error",
            "BroadcastArmAction"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "BroadcastArmAction",
                "code": "public void BroadcastArmAction(TechType techType, IExosuitArm exosuitArm, ExosuitArmAction armAction, Vector3? opVector, Quaternion? opRotation)\n    {\n        if (exosuitArm.GetGameObject().TryGetIdOrWarn(out NitroxId id))\n        {\n            ExosuitArmActionPacket packet = new(techType, id, armAction, opVector?.ToDto(), opRotation?.ToDto());\n            packetSender.Send(packet);\n        }\n    }"
            }
        ],
        "third_party": [
            "Log.Error"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public void BroadcastBatteryAdd(GameObject gameObject, GameObject parent, TechType techType)",
        "start_line": "79",
        "end_line": "96",
        "file_path": "NitroxClient/GameLogic/ItemContainers.cs",
        "docstring": "This function, BroadcastBatteryAdd, broadcasts the addition of a battery to a game object.\\nIt retrieves the IDs of the game object and its parent. If successful, it extracts metadata for the entity,\\ncreates an InstalledBatteryEntity with the collected information, and sends an EntitySpawnedByClient packet.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e390441c8dc2",
        "ground_truth": "public void BroadcastBatteryAdd(GameObject gameObject, GameObject parent, TechType techType)\n{\n    if (!gameObject.TryGetIdOrWarn(out NitroxId id))\n    {\n        return;\n    }\n    if (!parent.TryGetIdOrWarn(out NitroxId parentId))\n    {\n        return;\n    }\n    Optional<EntityMetadata> metadata = entityMetadataManager.Extract(gameObject);\n    InstalledBatteryEntity installedBattery = new(id, techType.ToDto(), metadata.OrNull(), parentId, new());\n    EntitySpawnedByClient spawnedPacket = new EntitySpawnedByClient(installedBattery);\n    packetSender.Send(spawnedPacket);\n}",
        "import_statements": [
            "using NitroxClient.Communication",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.GameLogic.Helper",
            "using NitroxClient.GameLogic.PlayerLogic",
            "using NitroxClient.GameLogic.Spawning.Metadata",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.GameLogic.Entities",
            "using NitroxModel.DataStructures.GameLogic.Entities.Metadata",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.Packets",
            "using NitroxModel_Subnautica.DataStructures",
            "using UnityEngine"
        ],
        "reference_api": [
            "entityMetadataManager.Extract",
            "gameObject.TryGetIdOrWarn",
            "metadata.OrNull",
            "packetSender.Send",
            "techType.ToDto",
            "parent.TryGetIdOrWarn"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "entityMetadataManager.Extract",
            "gameObject.TryGetIdOrWarn",
            "metadata.OrNull",
            "packetSender.Send",
            "techType.ToDto",
            "parent.TryGetIdOrWarn"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public void PickedUp(GameObject gameObject, TechType techType)",
        "start_line": "40",
        "end_line": "67",
        "file_path": "NitroxClient/GameLogic/Items.cs",
        "docstring": "This function, PickedUp, handles the event of picking up a game object in the game.\\nIt sets the PickingUpObject to the given game object, removes any remote control, and checks for a NitroxId.\\nIf the object lacks an ID, it generates a new one. It stops entity position broadcasting, converts the object to an inventory item,\\nmarks it as spawned, logs the pickup event, creates a PickupItem packet, and sends it.\\nFinally, it resets PickingUpObject to null.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a87b772a8e5a",
        "ground_truth": "public void PickedUp(GameObject gameObject, TechType techType)\n{\n    PickingUpObject = gameObject;\n    // We want to remove any remote tracking immediately on pickup as it can cause weird behavior like holding a ghost item still in the world.\n    RemoveAnyRemoteControl(gameObject);\n    if (!gameObject.TryGetNitroxId(out NitroxId id))\n    {\n        Log.Debug($\"Found item with ({gameObject.name}) with no id, assigning a new one\");\n        id = NitroxEntity.GenerateNewId(gameObject);\n    }\n    EntityPositionBroadcaster.StopWatchingEntity(id);\n    InventoryItemEntity inventoryItemEntity = ConvertToInventoryItemEntity(gameObject, entityMetadataManager);\n    // Some picked up entities are not known by the server for several reasons.  First it can be picked up via a spawn item command.  Another\n    // example is that some obects are not 'real' objects until they are clicked and end up spawning a prefab.  For example, the fire extinguisher\n    // in the escape pod (mono: IntroFireExtinguisherHandTarget) or Creepvine seeds (mono: PickupPrefab).  When clicked, these spawn new prefabs\n    // directly into the player's inventory.  These will ultimately be registered server side with the above inventoryItemEntity.\n    entities.MarkAsSpawned(inventoryItemEntity);\n    Log.Debug($\"PickedUp {id} {techType}\");\n    PickupItem pickupItem = new(id, inventoryItemEntity);\n    packetSender.Send(pickupItem);\n    PickingUpObject = null;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Linq",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.GameLogic.Helper",
            "using NitroxClient.GameLogic.Spawning.Metadata",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.GameLogic",
            "using NitroxModel.DataStructures.GameLogic.Entities",
            "using NitroxModel.DataStructures.GameLogic.Entities.Metadata",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.Packets",
            "using NitroxModel_Subnautica.DataStructures",
            "using UnityEngine"
        ],
        "reference_api": [
            "EntityPositionBroadcaster.StopWatchingEntity",
            "NitroxEntity.GenerateNewId",
            "gameObject.TryGetNitroxId",
            "RemoveAnyRemoteControl",
            "entities.MarkAsSpawned",
            "ConvertToInventoryItemEntity",
            "packetSender.Send",
            "Log.Debug"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RemoveAnyRemoteControl",
                "code": "private void RemoveAnyRemoteControl(GameObject gameObject)\n    {\n        UnityEngine.Object.Destroy(gameObject.GetComponent<RemotelyControlled>());\n    }"
            },
            {
                "name": "ConvertToInventoryItemEntity",
                "code": "public static InventoryItemEntity ConvertToInventoryItemEntity(GameObject gameObject, EntityMetadataManager entityMetadataManager)\n    {\n        NitroxId itemId = NitroxEntity.GetIdOrGenerateNew(gameObject); // id may not exist, create if missing\n        string classId = gameObject.RequireComponent<PrefabIdentifier>().ClassId;\n        TechType techType = gameObject.RequireComponent<Pickupable>().GetTechType();\n        Optional<EntityMetadata> metadata = entityMetadataManager.Extract(gameObject);\n        List<Entity> children = GetPrefabChildren(gameObject, itemId, entityMetadataManager).ToList();\n\n        // Newly created objects are always placed into the player's inventory.\n        if (!Player.main.TryGetNitroxId(out NitroxId ownerId))\n        {\n            throw new InvalidOperationException(\"[Items] Player has no id! Couldn't parent InventoryItem.\");\n        }\n\n        InventoryItemEntity inventoryItemEntity = new(itemId, classId, techType.ToDto(), metadata.OrNull(), ownerId, children);\n        BatteryChildEntityHelper.TryPopulateInstalledBattery(gameObject, inventoryItemEntity.ChildEntities, itemId);\n\n        return inventoryItemEntity;\n    }"
            }
        ],
        "third_party": [
            "EntityPositionBroadcaster.StopWatchingEntity",
            "NitroxEntity.GenerateNewId",
            "gameObject.TryGetNitroxId",
            "entities.MarkAsSpawned",
            "packetSender.Send",
            "Log.Debug"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public static InventoryItemEntity ConvertToInventoryItemEntity(GameObject gameObject, EntityMetadataManager entityMetadataManager)",
        "start_line": "206",
        "end_line": "224",
        "file_path": "NitroxClient/GameLogic/Items.cs",
        "docstring": "This function, ConvertToInventoryItemEntity, converts a GameObject into an InventoryItemEntity.\\nIt generates or retrieves a NitroxId for the GameObject, extracts its class ID and TechType,\\nand gathers its metadata and child entities. It also retrieves the player's ID and constructs\\nan InventoryItemEntity using this information. If applicable, it populates the entity with battery data.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b6d1e68114e1",
        "ground_truth": "public static InventoryItemEntity ConvertToInventoryItemEntity(GameObject gameObject, EntityMetadataManager entityMetadataManager)\n{\n    NitroxId itemId = NitroxEntity.GetIdOrGenerateNew(gameObject); // id may not exist, create if missing\n    string classId = gameObject.RequireComponent<PrefabIdentifier>().ClassId;\n    TechType techType = gameObject.RequireComponent<Pickupable>().GetTechType();\n    Optional<EntityMetadata> metadata = entityMetadataManager.Extract(gameObject);\n    List<Entity> children = GetPrefabChildren(gameObject, itemId, entityMetadataManager).ToList();\n    // Newly created objects are always placed into the player's inventory.\n    if (!Player.main.TryGetNitroxId(out NitroxId ownerId))\n    {\n        throw new InvalidOperationException(\"[Items] Player has no id! Couldn't parent InventoryItem.\");\n    }\n    InventoryItemEntity inventoryItemEntity = new(itemId, classId, techType.ToDto(), metadata.OrNull(), ownerId, children);\n    BatteryChildEntityHelper.TryPopulateInstalledBattery(gameObject, inventoryItemEntity.ChildEntities, itemId);\n    return inventoryItemEntity;\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.Linq",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.GameLogic.Helper",
            "using NitroxClient.GameLogic.Spawning.Metadata",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.GameLogic",
            "using NitroxModel.DataStructures.GameLogic.Entities",
            "using NitroxModel.DataStructures.GameLogic.Entities.Metadata",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.Packets",
            "using NitroxModel_Subnautica.DataStructures",
            "using UnityEngine"
        ],
        "reference_api": [
            "gameObject.RequireComponent<PrefabIdentifier>",
            "entityMetadataManager.Extract",
            "GetPrefabChildren(gameObject, itemId, entityMetadataManager).ToList",
            "metadata.OrNull",
            "BatteryChildEntityHelper.TryPopulateInstalledBattery",
            "Player.main.TryGetNitroxId",
            "gameObject.RequireComponent<Pickupable>().GetTechType",
            "GetPrefabChildren",
            "techType.ToDto",
            "NitroxEntity.GetIdOrGenerateNew",
            "gameObject.RequireComponent<Pickupable>"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetPrefabChildren",
                "code": "public static IEnumerable<Entity> GetPrefabChildren(GameObject gameObject, NitroxId parentId, EntityMetadataManager entityMetadataManager)\n    {\n        foreach (IGrouping<string, PrefabIdentifier> prefabGroup in gameObject.GetAllComponentsInChildren<PrefabIdentifier>()\n                                                                              .Where(prefab => prefab.gameObject != gameObject)\n                                                                              .GroupBy(prefab => prefab.classId))\n        {\n            int indexInGroup = 0;\n\n            foreach (PrefabIdentifier prefab in prefabGroup)\n            {\n                NitroxId id = NitroxEntity.GetIdOrGenerateNew(prefab.gameObject); // We do this here bc a MetadataExtractor could be requiring the id to increment or so\n                Optional<EntityMetadata> metadata = entityMetadataManager.Extract(prefab.gameObject);\n\n                if (metadata.HasValue)\n                {\n                    TechTag techTag = prefab.gameObject.GetComponent<TechTag>();\n                    TechType techType = (techTag) ? techTag.type : TechType.None;\n\n                    yield return new PrefabChildEntity(id, prefab.classId, techType.ToDto(), indexInGroup, metadata.Value, parentId);\n\n                    indexInGroup++;\n                }\n            }\n        }\n    }"
            }
        ],
        "third_party": [
            "gameObject.RequireComponent<PrefabIdentifier>",
            "entityMetadataManager.Extract",
            "GetPrefabChildren(gameObject, itemId, entityMetadataManager).ToList",
            "metadata.OrNull",
            "BatteryChildEntityHelper.TryPopulateInstalledBattery",
            "Player.main.TryGetNitroxId",
            "gameObject.RequireComponent<Pickupable>().GetTechType",
            "techType.ToDto",
            "NitroxEntity.GetIdOrGenerateNew",
            "gameObject.RequireComponent<Pickupable>"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "public LocalPlayer(IMultiplayerSession multiplayerSession, IPacketSender packetSender, ThrottledPacketSender throttledPacketSender)",
        "start_line": "43",
        "end_line": "52",
        "file_path": "NitroxClient/GameLogic/LocalPlayer.cs",
        "docstring": "This constructor, LocalPlayer, initializes a LocalPlayer instance with provided multiplayer session and packet sender objects.\\nIt sets up lazy-loaded references for the player's body, player model, and body prototype.\\nIt also assigns default player permissions.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e416d51a7af7",
        "ground_truth": "public LocalPlayer(IMultiplayerSession multiplayerSession, IPacketSender packetSender, ThrottledPacketSender throttledPacketSender)\n{\n    this.multiplayerSession = multiplayerSession;\n    this.packetSender = packetSender;\n    this.throttledPacketSender = throttledPacketSender;\n    body = new Lazy<GameObject>(() => Player.main.RequireGameObject(\"body\"));\n    playerModel = new Lazy<GameObject>(() => Body.RequireGameObject(\"player_view\"));\n    bodyPrototype = new Lazy<GameObject>(CreateBodyPrototype);\n    Permissions = Perms.PLAYER;\n}",
        "import_statements": [
            "using System",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerModel",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerModel.Abstract",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.GameLogic",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.MultiplayerSession",
            "using NitroxModel.Packets",
            "using NitroxModel_Subnautica.DataStructures",
            "using UnityEngine",
            "using UnityEngine.Rendering",
            "using Object = UnityEngine.Object"
        ],
        "reference_api": [
            "Body.RequireGameObject",
            "Player.main.RequireGameObject"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Body.RequireGameObject",
            "Player.main.RequireGameObject"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "SubnauticaNitrox/Nitrox",
        "function_declaration": "private GameObject CreateBodyPrototype",
        "start_line": "126",
        "end_line": "148",
        "file_path": "NitroxClient/GameLogic/LocalPlayer.cs",
        "docstring": "This function, CreateBodyPrototype, creates a prototype of a player's body GameObject for multiplayer use.\\nIt first ensures the player's head is visible, then instantiates a clone of the body prototype.\\nThe head's shadow casting mode is reset, and the clone is deactivated and renamed to \"RemotePlayerPrototype\".\\nItems held in hand are removed from the clone before it is returned.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "def56af985df",
        "ground_truth": "private GameObject CreateBodyPrototype()\n{\n    GameObject prototype = Body;\n    // Cheap fix for showing head, much easier since male_geo contains many different heads\n    prototype.GetComponentInParent<Player>().head.shadowCastingMode = ShadowCastingMode.On;\n    GameObject clone = Object.Instantiate(prototype, Multiplayer.Main.transform, false);\n    prototype.GetComponentInParent<Player>().head.shadowCastingMode = ShadowCastingMode.ShadowsOnly;\n    clone.SetActive(false);\n    clone.name = \"RemotePlayerPrototype\";\n    // Removing items that are held in hand\n    foreach (Transform child in clone.transform.Find($\"player_view/{PlayerEquipmentConstants.ITEM_ATTACH_POINT_GAME_OBJECT_NAME}\"))\n    {\n        if (!child.gameObject.name.Contains(\"attach1_\"))\n        {\n            Object.DestroyImmediate(child.gameObject);\n        }\n    }\n    return clone;\n}",
        "import_statements": [
            "using System",
            "using NitroxClient.Communication.Abstract",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerModel",
            "using NitroxClient.GameLogic.PlayerLogic.PlayerModel.Abstract",
            "using NitroxClient.MonoBehaviours",
            "using NitroxClient.Unity.Helper",
            "using NitroxModel.DataStructures",
            "using NitroxModel.DataStructures.GameLogic",
            "using NitroxModel.DataStructures.Util",
            "using NitroxModel.MultiplayerSession",
            "using NitroxModel.Packets",
            "using NitroxModel_Subnautica.DataStructures",
            "using UnityEngine",
            "using UnityEngine.Rendering",
            "using Object = UnityEngine.Object"
        ],
        "reference_api": [
            "clone.transform.Find",
            "prototype.GetComponentInParent<Player>",
            "child.gameObject.name.Contains",
            "Object.DestroyImmediate",
            "clone.SetActive",
            "Object.Instantiate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "clone.transform.Find",
            "prototype.GetComponentInParent<Player>",
            "child.gameObject.name.Contains",
            "Object.DestroyImmediate",
            "clone.SetActive",
            "Object.Instantiate"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "BepInEx/BepInEx",
        "function_declaration": "void ICacheable.Save(BinaryWriter bw)",
        "start_line": "50",
        "end_line": "75",
        "file_path": "BepInEx.Core/Contract/PluginInfo.cs",
        "docstring": "This function, Save, serializes the state of an ICacheable object to a BinaryWriter.\\nIt writes the object's type name, location, metadata, processes, dependencies, incompatibilities,\\nand target version to the binary stream. Dependencies and incompatibilities are recursively saved.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e9bd7f669aed",
        "ground_truth": "void ICacheable.Save(BinaryWriter bw)\n{\n    bw.Write(TypeName);\n    bw.Write(Location);\n    bw.Write(Metadata.GUID);\n    bw.Write(Metadata.Name);\n    bw.Write(Metadata.Version.ToString());\n    var processList = Processes.ToList();\n    bw.Write(processList.Count);\n    foreach (var bepInProcess in processList)\n        bw.Write(bepInProcess.ProcessName);\n    var depList = Dependencies.ToList();\n    bw.Write(depList.Count);\n    foreach (var bepInDependency in depList)\n        ((ICacheable) bepInDependency).Save(bw);\n    var incList = Incompatibilities.ToList();\n    bw.Write(incList.Count);\n    foreach (var bepInIncompatibility in incList)\n        ((ICacheable) bepInIncompatibility).Save(bw);\n    bw.Write(TargettedBepInExVersion.ToString(4));\n}",
        "import_statements": [
            "using System",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Linq",
            "using BepInEx.Bootstrap"
        ],
        "reference_api": [
            "Dependencies.ToList",
            "Metadata.Version.ToString",
            "bw.Write",
            "Processes.ToList",
            "Incompatibilities.ToList",
            "((ICacheable) bepInIncompatibility).Save",
            "TargettedBepInExVersion.ToString",
            "((ICacheable) bepInDependency).Save"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Dependencies.ToList",
            "Metadata.Version.ToString",
            "bw.Write",
            "Processes.ToList",
            "Incompatibilities.ToList",
            "((ICacheable) bepInIncompatibility).Save",
            "TargettedBepInExVersion.ToString",
            "((ICacheable) bepInDependency).Save"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "BepInEx/BepInEx",
        "function_declaration": "public override BasePlugin LoadPlugin(PluginInfo pluginInfo, Assembly pluginAssembly)",
        "start_line": "127",
        "end_line": "137",
        "file_path": "Runtimes/Unity/BepInEx.Unity.IL2CPP/IL2CPPChainloader.cs",
        "docstring": "This function, LoadPlugin, loads a plugin using its information and assembly.\\nIt retrieves the plugin type, creates an instance of it, and invokes the PluginLoad event.\\nIt then calls the Load method on the plugin instance and returns the instance.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a7e51620987d",
        "ground_truth": "public override BasePlugin LoadPlugin(PluginInfo pluginInfo, Assembly pluginAssembly)\n{\n    var type = pluginAssembly.GetType(pluginInfo.TypeName);\n    var pluginInstance = (BasePlugin) Activator.CreateInstance(type);\n    PluginLoad?.Invoke(pluginInfo, pluginAssembly, pluginInstance);\n    pluginInstance.Load();\n    return pluginInstance;\n}",
        "import_statements": [
            "using System",
            "using System.Reflection",
            "using System.Runtime.InteropServices",
            "using BepInEx.Bootstrap",
            "using BepInEx.Configuration",
            "using BepInEx.Logging",
            "using BepInEx.Preloader.Core",
            "using BepInEx.Preloader.Core.Logging",
            "using BepInEx.Unity.IL2CPP.Hook",
            "using BepInEx.Unity.IL2CPP.Logging",
            "using BepInEx.Unity.IL2CPP.Utils",
            "using Il2CppInterop.Runtime.InteropTypes",
            "using UnityEngine",
            "using Logger = BepInEx.Logging.Logger"
        ],
        "reference_api": [
            "pluginInstance.Load",
            "PluginLoad?.Invoke",
            "pluginAssembly.GetType",
            "Activator.CreateInstance"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "pluginInstance.Load",
            "PluginLoad?.Invoke",
            "pluginAssembly.GetType",
            "Activator.CreateInstance"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "BepInEx/BepInEx",
        "function_declaration": "public MethodBase GenerateTrampoline(MethodBase signature = null)",
        "start_line": "61",
        "end_line": "70",
        "file_path": "Runtimes/Unity/BepInEx.Unity.IL2CPP/Hook/BaseNativeDetour.cs",
        "docstring": "This function, GenerateTrampoline, creates and returns a trampoline method.\\nIf the TrampolineMethod is null, it calls Prepare and then generates a native proxy\\nusing the TrampolinePtr and an optional method signature, storing it in TrampolineMethod.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0925dc086c01",
        "ground_truth": "public MethodBase GenerateTrampoline(MethodBase signature = null)\n{\n    if (TrampolineMethod == null)\n    {\n        Prepare();\n        TrampolineMethod = DetourHelper.GenerateNativeProxy(TrampolinePtr, signature);\n    }\n    return TrampolineMethod;\n}",
        "import_statements": [
            "using System",
            "using System.Reflection",
            "using System.Runtime.InteropServices",
            "using BepInEx.Logging",
            "using MonoMod.RuntimeDetour"
        ],
        "reference_api": [
            "DetourHelper.GenerateNativeProxy",
            "Prepare"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Prepare",
                "code": "private void Prepare()\n    {\n        if (IsPrepared) return;\n        Logger.LogDebug($\"Preparing detour from 0x{OriginalMethodPtr:X2} to 0x{DetourMethodPtr:X2}\");\n        PrepareImpl();\n        Logger.LogDebug($\"Prepared detour; Trampoline: 0x{TrampolinePtr:X2}\");\n        IsPrepared = true;\n    }"
            }
        ],
        "third_party": [
            "DetourHelper.GenerateNativeProxy"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "AssetRipper/AssetRipper",
        "function_declaration": "private static Dictionary<string, string> LoadLanguageInternal(string code)",
        "start_line": "14",
        "end_line": "21",
        "file_path": "Source/AssetRipper.GUI.Localizations/LocalizationLoader.cs",
        "docstring": "This function, LoadLanguageInternal, loads a language file in JSON format for a given language code.\\nIt retrieves the language file as a stream from the assembly's resources.\\nIf the file is not found, it throws a NullReferenceException.\\nThe function then deserializes the stream into a dictionary and returns it.\\nIf deserialization fails, it throws a JsonException.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cfab5c23610e",
        "ground_truth": "private static Dictionary<string, string> LoadLanguageInternal(string code)\n{\n using Stream stream = typeof(LocalizationLoader).Assembly.GetManifestResourceStream(LocalizationFilePrefix + code + \".json\")\n  ?? throw new NullReferenceException($\"Could not load language file {code}.json\");\n return JsonSerializer.Deserialize(stream, DictionarySerializerContext.Default.DictionaryStringString)\n  ?? throw new JsonException($\"Could not parse language file {code}.json\");\n}",
        "import_statements": [
            "using System.Text.Json"
        ],
        "reference_api": [
            "typeof(LocalizationLoader).Assembly.GetManifestResourceStream",
            "JsonSerializer.Deserialize"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "typeof(LocalizationLoader).Assembly.GetManifestResourceStream",
            "JsonSerializer.Deserialize"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "YarnSpinnerTool/YarnSpinner",
        "function_declaration": "private int GenerateCodeForExpressionsInFormattedText(IList<IParseTree> nodes)",
        "start_line": "32",
        "end_line": "59",
        "file_path": "YarnSpinner.Compiler/CodeGenerationVisitor.cs",
        "docstring": "This function, GenerateCodeForExpressionsInFormattedText, processes a list of parse tree nodes to count expressions.\\nIt initializes an expression count, iterates through the nodes, and if a node is a ParserRuleContext, it visits the node and increments the count.\\nThe function returns the total number of expressions found.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9978bd31d199",
        "ground_truth": "private int GenerateCodeForExpressionsInFormattedText(IList<IParseTree> nodes)\n{\n    int expressionCount = 0;\n    // First, visit all of the nodes, which are either terminal text\n    // nodes or expressions. if they're expressions, we evaluate them,\n    // and inject a positional reference into the final string.\n    foreach (var child in nodes)\n    {\n        if (child is ITerminalNode)\n        {\n            // nothing to do; string assembly will have been done by the\n            // StringTableGeneratorVisitor\n        }\n        else if (child is ParserRuleContext)\n        {\n            // assume that this is an expression (the parser only\n            // permits them to be expressions, but we can't specify that\n            // here) - visit it, and we will emit code that pushes the\n            // final value of this expression onto the stack. running\n            // the line will pop these expressions off the stack.\n            this.Visit(child);\n            expressionCount += 1;\n        }\n    }\n    return expressionCount;\n}",
        "import_statements": [],
        "reference_api": [
            "this.Visit"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.Visit"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "YarnSpinnerTool/YarnSpinner",
        "function_declaration": "public override int VisitLine_statement(YarnSpinnerParser.Line_statementContext context)",
        "start_line": "62",
        "end_line": "89",
        "file_path": "YarnSpinner.Compiler/CodeGenerationVisitor.cs",
        "docstring": "This function, VisitLine_statement, processes a line statement in a Yarn Spinner script.\\nIt generates code for any expressions in the formatted text, retrieves the line ID tag,\\nand emits a RunLine opcode with the line ID and expression count. If no line ID tag is found,\\nit throws an InvalidOperationException.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8f9bf9ee575a",
        "ground_truth": "public override int VisitLine_statement(YarnSpinnerParser.Line_statementContext context)\n{\n    // TODO: add support for line conditions:\n    //\n    // Mae: here's a line <<if true>>\n    //\n    // is identical to\n    //\n    // <<if true>> Mae: here's a line <<endif>>\n    // Evaluate the inline expressions and push the results onto the\n    // stack.\n    var expressionCount = this.GenerateCodeForExpressionsInFormattedText(context.line_formatted_text().children);\n    // Get the lineID for this string from the hashtags\n    var lineIDTag = Compiler.GetLineIDTag(context.hashtag());\n    if (lineIDTag == null)\n    {\n        throw new InvalidOperationException(\"Internal error: line should have an implicit or explicit line ID tag, but none was found\");\n    }\n    var lineID = lineIDTag.text.Text;\n    this.compiler.Emit(OpCode.RunLine, context.Start, new Operand(lineID), new Operand(expressionCount));\n    return 0;\n}",
        "import_statements": [],
        "reference_api": [
            "this.compiler.Emit",
            "context.line_formatted_text",
            "context.hashtag",
            "this.GenerateCodeForExpressionsInFormattedText",
            "Compiler.GetLineIDTag"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.compiler.Emit",
            "context.line_formatted_text",
            "context.hashtag",
            "this.GenerateCodeForExpressionsInFormattedText",
            "Compiler.GetLineIDTag"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "YarnSpinnerTool/YarnSpinner",
        "function_declaration": "private static IEnumerable<Diagnostic> UnknownCommands(YarnFileData yarnFile)",
        "start_line": "23",
        "end_line": "41",
        "file_path": "YarnSpinner.LanguageServer/src/Server/Diagnostics/Warnings.cs",
        "docstring": "This function, UnknownCommands, identifies command references in a YarnFileData object that do not have corresponding definitions in the project's known commands.\\nFor each unknown command, it generates a Diagnostic object with a warning message, severity level, code, and additional data about the command.\\nThe function returns these diagnostics as an enumerable collection.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b70d033fed9c",
        "ground_truth": "private static IEnumerable<Diagnostic> UnknownCommands(YarnFileData yarnFile)\n{\n    var knownCommands = yarnFile.Project.Commands;\n    foreach (var commandReference in yarnFile.CommandReferences)\n    {\n        if (knownCommands.Any(c => c.YarnName == commandReference.Name) == false)\n        {\n            // We don't know what command this is referring to.\n            yield return new Diagnostic\n            {\n                Message = $\"Could not find {(commandReference.IsCommand ? \"command\" : \"function\")} definition for {commandReference.Name}\",\n                Severity = DiagnosticSeverity.Warning,\n                Range = new Range(commandReference.ExpressionRange.Start, commandReference.ParametersRange.Start.Delta(0, -1)),\n                Code = nameof(YarnDiagnosticCode.YRNMsngCmdDef),\n                Data = JToken.FromObject((commandReference.Name, commandReference.IsCommand)),\n            };\n        }\n    }\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using System.Linq",
            "using MoreLinq",
            "using Newtonsoft.Json.Linq",
            "using OmniSharp.Extensions.LanguageServer.Protocol.Models",
            "using Range = OmniSharp.Extensions.LanguageServer.Protocol.Models.Range"
        ],
        "reference_api": [
            "knownCommands.Any",
            "JToken.FromObject",
            "nameof",
            "commandReference.ParametersRange.Start.Delta"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "knownCommands.Any",
            "JToken.FromObject",
            "nameof",
            "commandReference.ParametersRange.Start.Delta"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "YarnSpinnerTool/YarnSpinner",
        "function_declaration": "public CodeActionRegistrationOptions GetRegistrationOptions(CodeActionCapability capability, ClientCapabilities clientCapabilities)",
        "start_line": "47",
        "end_line": "57",
        "file_path": "YarnSpinner.LanguageServer/src/Server/Handlers/CodeActionHandler.cs",
        "docstring": "This function, GetRegistrationOptions, creates and returns registration options for code actions.\\nIt sets the document selector to a Yarn-specific selector, disables the resolve provider,\\nand specifies that only quick fix code actions are supported.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9a072876f358",
        "ground_truth": "public CodeActionRegistrationOptions GetRegistrationOptions(CodeActionCapability capability, ClientCapabilities clientCapabilities)\n{\n    return new CodeActionRegistrationOptions\n    {\n        DocumentSelector = Utils.YarnDocumentSelector,\n        ResolveProvider = false,\n        CodeActionKinds = new Container<CodeActionKind>(CodeActionKind.QuickFix),\n        // TODO Consider implementing CodeActionKind.SourceFixAll available in proposed lsp 3.17\n    };\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using System.Linq",
            "using System.Threading",
            "using System.Threading.Tasks",
            "using Newtonsoft.Json.Linq",
            "using OmniSharp.Extensions.LanguageServer.Protocol",
            "using OmniSharp.Extensions.LanguageServer.Protocol.Client.Capabilities",
            "using OmniSharp.Extensions.LanguageServer.Protocol.Document",
            "using OmniSharp.Extensions.LanguageServer.Protocol.Models",
            "using YarnLanguageServer.Diagnostics"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "YarnSpinnerTool/YarnSpinner",
        "function_declaration": "public bool TryGetValue<T>(string variableName, out T result)",
        "start_line": "267",
        "end_line": "284",
        "file_path": "YarnSpinner/Dialogue.cs",
        "docstring": "This function, TryGetValue, attempts to retrieve a variable by its name from a collection.\\nIf the variable is found and its type is compatible with the specified type T, it assigns the value to the result and returns true.\\nIf the types are incompatible, it throws an ArgumentException.\\nIf the variable is not found, it sets the result to the default value and returns false.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7b61df32aee3",
        "ground_truth": "public bool TryGetValue<T>(string variableName, out T result)\n{\n    if (this.variables.TryGetValue(variableName, out var foundValue))\n    {\n        if (typeof(T).IsAssignableFrom(foundValue.GetType()))\n        {\n            result = (T)foundValue;\n            return true;\n        }\n        else\n        {\n            throw new ArgumentException($\"Variable {variableName} is present, but is of type {foundValue.GetType()}, not {typeof(T)}\");\n        }\n    }\n    result = default;\n    return false;\n}",
        "import_statements": [],
        "reference_api": [
            "foundValue.GetType",
            "typeof(T).IsAssignableFrom",
            "this.variables.TryGetValue"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "foundValue.GetType",
            "typeof(T).IsAssignableFrom",
            "this.variables.TryGetValue"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "YarnSpinnerTool/YarnSpinner",
        "function_declaration": "public Dialogue(Yarn.IVariableStorage variableStorage)",
        "start_line": "572",
        "end_line": "593",
        "file_path": "YarnSpinner/Dialogue.cs",
        "docstring": "This constructor, Dialogue, initializes a dialogue system with a provided variable storage.\\nIt sets up a Library and VirtualMachine, imports a StandardLibrary, and registers functions for node visit tracking.\\nAdditionally, it creates a LineParser and registers marker processors for select, plural, and ordinal markers.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7201488347ef",
        "ground_truth": "public Dialogue(Yarn.IVariableStorage variableStorage)\n{\n    this.VariableStorage = variableStorage ?? throw new ArgumentNullException(nameof(variableStorage));\n    Library = new Library();\n    this.vm = new VirtualMachine(this);\n    Library.ImportLibrary(new StandardLibrary());\n    Library.RegisterFunction(\"visited\", delegate(string node){\n        return IsNodeVisited(node);\n    });\n    Library.RegisterFunction(\"visited_count\", delegate(string node){\n        return GetNodeVisitCount(node);\n    });\n    lineParser = new LineParser();\n    lineParser.RegisterMarkerProcessor(\"select\", this);\n    lineParser.RegisterMarkerProcessor(\"plural\", this);\n    lineParser.RegisterMarkerProcessor(\"ordinal\", this);\n}",
        "import_statements": [],
        "reference_api": [
            "Library.RegisterFunction",
            "nameof",
            "lineParser.RegisterMarkerProcessor",
            "GetNodeVisitCount",
            "Library.ImportLibrary",
            "IsNodeVisited"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetNodeVisitCount",
                "code": "private float GetNodeVisitCount(string nodeName)\n        {\n            float count = 0;\n            VariableStorage.TryGetValue<float>(Library.GenerateUniqueVisitedVariableForNode(nodeName), out count);\n            return count;\n        }"
            },
            {
                "name": "IsNodeVisited",
                "code": "private bool IsNodeVisited(string nodeName)\n        {\n            float count = 0;\n            if (VariableStorage.TryGetValue<float>(Library.GenerateUniqueVisitedVariableForNode(nodeName), out count))\n            {\n                return count > 0;\n            }\n            return false;\n        }"
            }
        ],
        "third_party": [
            "Library.RegisterFunction",
            "nameof",
            "lineParser.RegisterMarkerProcessor",
            "Library.ImportLibrary"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "qiankanglai/LoopScrollRect",
        "function_declaration": "public int FindUniqueID(string UniqueID)",
        "start_line": "83",
        "end_line": "99",
        "file_path": "Samples~/Demo/Scripts/CustomListBank.cs",
        "docstring": "This function, FindUniqueID, searches for a specified UniqueID within a list of LoopListBankData.\\nIt returns the index of the matching entry if found, or -1 if the UniqueID is null, empty, or not found in the list.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "59b7b5a9c34a",
        "ground_truth": "public int FindUniqueID(string UniqueID)\n{\n    if (string.IsNullOrEmpty(UniqueID))\n    {\n        return -1;\n    }\n    for (int i = 0; i < m_LoopListBankDataList.Count; ++i)\n    {\n        if (m_LoopListBankDataList[i].UniqueID == UniqueID)\n        {\n            return i;\n        }\n    }\n    return -1;\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using UnityEngine"
        ],
        "reference_api": [
            "string.IsNullOrEmpty"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "string.IsNullOrEmpty"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "qiankanglai/LoopScrollRect",
        "function_declaration": "public void AddContent(object newContent)",
        "start_line": "101",
        "end_line": "107",
        "file_path": "Samples~/Demo/Scripts/CustomListBank.cs",
        "docstring": "This function, AddContent, adds new content to a list of LoopListBankData.\\nIt creates a new LoopListBankData object, assigns the provided content to it,\\ngenerates a unique ID for it, and adds it to the m_LoopListBankDataList.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2b85606238aa",
        "ground_truth": "public void AddContent(object newContent)\n{\n    LoopListBankData TempCustomData = new LoopListBankData();\n    TempCustomData.Content = newContent;\n    TempCustomData.UniqueID = System.Guid.NewGuid().ToString();\n    m_LoopListBankDataList.Add(TempCustomData);\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using UnityEngine"
        ],
        "reference_api": [
            "m_LoopListBankDataList.Add",
            "System.Guid.NewGuid",
            "System.Guid.NewGuid().ToString"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "m_LoopListBankDataList.Add",
            "System.Guid.NewGuid",
            "System.Guid.NewGuid().ToString"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "qiankanglai/LoopScrollRect",
        "function_declaration": "public virtual void ScrollCellIndex(int idx, object content, string ClickUniqueID = \"\", object ClickObject = null)",
        "start_line": "109",
        "end_line": "118",
        "file_path": "Samples~/Demo/Scripts/ScrollIndexCallbackBase.cs",
        "docstring": "This function, ScrollCellIndex, updates the index and content of a scroll cell.\\nIt assigns the provided index to m_IndexID and the provided content to m_Content.\\nIf m_IsUpdateGameObjectName is true, it updates the GameObject's name to include the prefab name and index.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "34e593106991",
        "ground_truth": "public virtual void ScrollCellIndex(int idx, object content, string ClickUniqueID = \"\", object ClickObject = null)\n{\n    m_IndexID = idx;\n    m_Content = content;\n    if (m_IsUpdateGameObjectName)\n    {\n        gameObject.name = string.Format(\"{0} Cell {1}\", m_PrefabName, idx.ToString());\n    }\n}",
        "import_statements": [
            "using System",
            "using UnityEngine",
            "using UnityEngine.Events",
            "using UnityEngine.Serialization",
            "using UnityEngine.UI"
        ],
        "reference_api": [
            "string.Format",
            "idx.ToString"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "string.Format",
            "idx.ToString"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "qiankanglai/LoopScrollRect",
        "function_declaration": "private void OnButtonAddDataClickk()",
        "start_line": "56",
        "end_line": "70",
        "file_path": "Samples~/Demo/Scripts/UI_ControlData.cs",
        "docstring": "This function, OnButtonAddDataClick, handles the addition of new data when a button is clicked.\\nIt parses the input field text to determine the number of items to add, ensuring at least one item is added.\\nIt then adds random integers between 0 and 10 to the list bank, updates the total count of the scroll rect, and refreshes the displayed cells.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6b6a6cc329cc",
        "ground_truth": "private void OnButtonAddDataClick()\n{\n    int AddCount = 0;\n    int.TryParse(m_InputFieldSrollToCell_AddCount.text, out AddCount);\n    int TargetCount = Mathf.Max(1, AddCount);\n    for (int i = 0; i < TargetCount; ++i)\n    {\n        int RandomResult = Random.Range(0, 10);\n        m_ListBank.AddContent(RandomResult);\n    }\n    m_InitOnStart.m_LoopScrollRect.totalCount = m_InitOnStart.m_LoopListBank.GetListLength();\n    m_InitOnStart.m_LoopScrollRect.RefreshCells();\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using System.Linq",
            "using UnityEngine",
            "using UnityEngine.UI"
        ],
        "reference_api": [
            "m_ListBank.AddContent",
            "m_InitOnStart.m_LoopScrollRect.RefreshCells",
            "m_InitOnStart.m_LoopListBank.GetListLength",
            "Mathf.Max",
            "Random.Range",
            "int.TryParse"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "m_ListBank.AddContent",
            "m_InitOnStart.m_LoopScrollRect.RefreshCells",
            "m_InitOnStart.m_LoopListBank.GetListLength",
            "Mathf.Max",
            "Random.Range",
            "int.TryParse"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "qiankanglai/LoopScrollRect",
        "function_declaration": "protected override void ClearTempPool()",
        "start_line": "54",
        "end_line": "74",
        "file_path": "Runtime/LoopScrollRect.cs",
        "docstring": "This function, ClearTempPool, clears temporary objects from a content pool.\\nIt verifies that the content has the expected number of child elements.\\nIf there are items marked for deletion at the start, it returns them to the prefab source and resets the start index.\\nSimilarly, if there are items marked for deletion at the end, it returns them to the prefab source and resets the end index.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "209961c9eb8e",
        "ground_truth": "protected override void ClearTempPool()\n{\n    Debug.Assert(m_Content.childCount >= deletedItemTypeStart + deletedItemTypeEnd);\n    if (deletedItemTypeStart > 0)\n    {\n        for (int i = deletedItemTypeStart - 1; i >= 0; i--)\n        {\n            prefabSource.ReturnObject(m_Content.GetChild(i));\n        }\n        deletedItemTypeStart = 0;\n    }\n    if (deletedItemTypeEnd > 0)\n    {\n        int t = m_Content.childCount - deletedItemTypeEnd;\n        for (int i = m_Content.childCount - 1; i >= t; i--)\n        {\n            prefabSource.ReturnObject(m_Content.GetChild(i));\n        }\n        deletedItemTypeEnd = 0;\n    }\n}",
        "import_statements": [
            "using UnityEngine",
            "using UnityEngine.Events",
            "using UnityEngine.EventSystems",
            "using System",
            "using System.Collections",
            "using System.Collections.Generic"
        ],
        "reference_api": [
            "prefabSource.ReturnObject",
            "m_Content.GetChild",
            "Debug.Assert"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "prefabSource.ReturnObject",
            "m_Content.GetChild",
            "Debug.Assert"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Unity-Technologies/com.unity.netcode.gameobjects",
        "function_declaration": "public void AnticipateScale(Vector3 newScale)",
        "start_line": "193",
        "end_line": "213",
        "file_path": "com.unity.netcode.gameobjects/Components/AnticipatedNetworkTransform.cs",
        "docstring": "This function, AnticipateScale, updates the scale of a transform to a new value, accounting for network conditions.\\nIt first checks if the network is active and listening. If so, it sets the local and anticipated scales to the new value.\\nIf allowed, it also updates the authoritative scale. It then records the anticipated transform and updates the anticipation counters and times.\\nFinally, it resets the smooth transition duration and current smooth time.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c6bb290de2b3",
        "ground_truth": "public void AnticipateScale(Vector3 newScale)\n{\n    if (NetworkManager.ShutdownInProgress || !NetworkManager.IsListening)\n    {\n        return;\n    }\n    transform.localScale = newScale;\n    m_AnticipatedTransform.Scale = newScale;\n    if (CanCommitToTransform)\n    {\n        m_AuthoritativeTransform.Scale = newScale;\n    }\n    m_PreviousAnticipatedTransform = m_AnticipatedTransform;\n    m_LastAnticipaionCounter = NetworkManager.AnticipationSystem.AnticipationCounter;\n    m_LastAnticipationTime = NetworkManager.LocalTime.Time;\n    m_SmoothDuration = 0;\n    m_CurrentSmoothTime = 0;\n}",
        "import_statements": [
            "using Unity.Mathematics",
            "using UnityEngine"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Unity-Technologies/com.unity.netcode.gameobjects",
        "function_declaration": "private void FlushMessages()",
        "start_line": "24",
        "end_line": "51",
        "file_path": "com.unity.netcode.gameobjects/Components/NetworkAnimator.cs",
        "docstring": "This function, FlushMessages, sends accumulated animation, parameter, and trigger updates through a network animator.\\nIt iterates over lists of animation updates, parameter updates, and trigger updates, sending each update via the appropriate client or server RPC method.\\nAfter sending, it clears the lists to prepare for the next set of updates.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d67d3c80dd00",
        "ground_truth": "private void FlushMessages()\n{\n    foreach (var animationUpdate in m_SendAnimationUpdates)\n    {\n        m_NetworkAnimator.SendAnimStateClientRpc(animationUpdate.AnimationMessage, animationUpdate.ClientRpcParams);\n    }\n    m_SendAnimationUpdates.Clear();\n    foreach (var sendEntry in m_SendParameterUpdates)\n    {\n        m_NetworkAnimator.SendParametersUpdateClientRpc(sendEntry.ParametersUpdateMessage, sendEntry.ClientRpcParams);\n    }\n    m_SendParameterUpdates.Clear();\n    foreach (var sendEntry in m_SendTriggerUpdates)\n    {\n        if (!sendEntry.SendToServer)\n        {\n            m_NetworkAnimator.SendAnimTriggerClientRpc(sendEntry.AnimationTriggerMessage, sendEntry.ClientRpcParams);\n        }\n        else\n        {\n            m_NetworkAnimator.SendAnimTriggerServerRpc(sendEntry.AnimationTriggerMessage);\n        }\n    }\n    m_SendTriggerUpdates.Clear();\n}",
        "import_statements": [],
        "reference_api": [
            "m_NetworkAnimator.SendAnimTriggerClientRpc",
            "m_SendTriggerUpdates.Clear",
            "m_NetworkAnimator.SendParametersUpdateClientRpc",
            "m_SendParameterUpdates.Clear",
            "m_NetworkAnimator.SendAnimTriggerServerRpc",
            "m_SendAnimationUpdates.Clear",
            "m_NetworkAnimator.SendAnimStateClientRpc"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "m_NetworkAnimator.SendAnimTriggerClientRpc",
            "m_SendTriggerUpdates.Clear",
            "m_NetworkAnimator.SendParametersUpdateClientRpc",
            "m_SendParameterUpdates.Clear",
            "m_NetworkAnimator.SendAnimTriggerServerRpc",
            "m_SendAnimationUpdates.Clear",
            "m_NetworkAnimator.SendAnimStateClientRpc"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Unity-Technologies/com.unity.netcode.gameobjects",
        "function_declaration": "public void NetworkUpdate(NetworkUpdateStage updateStage)",
        "start_line": "54",
        "end_line": "85",
        "file_path": "com.unity.netcode.gameobjects/Components/NetworkAnimator.cs",
        "docstring": "This function, NetworkUpdate, handles network updates for a networked animator based on the update stage.\\nDuring the PreUpdate stage, it flushes pending messages if the animator is the owner or the server.\\nIt then processes parameter updates and checks for animator changes, depending on server authority and ownership.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0632b2f27d22",
        "ground_truth": "public void NetworkUpdate(NetworkUpdateStage updateStage)\n{\n    switch (updateStage)\n    {\n        case NetworkUpdateStage.PreUpdate:\n            {\n                // Only the owner or the server send messages\n                if (m_NetworkAnimator.IsOwner || m_IsServer)\n                {\n                    // Flush any pending messages\n                    FlushMessages();\n                }\n                // Everyone applies any parameters updated\n                for (int i = 0; i < m_ProcessParameterUpdates.Count; i++)\n                {\n                    var parameterUpdate = m_ProcessParameterUpdates[i];\n                    m_NetworkAnimator.UpdateParameters(ref parameterUpdate);\n                }\n                m_ProcessParameterUpdates.Clear();\n                var isServerAuthority = m_NetworkAnimator.IsServerAuthoritative();\n                // owners when owner authoritative or the server when server authoritative are the only instances that\n                // checks for Animator changes\n                if ((!isServerAuthority && m_NetworkAnimator.IsOwner) || (isServerAuthority && m_NetworkAnimator.IsServer))\n                {\n                    m_NetworkAnimator.CheckForAnimatorChanges();\n                }\n                break;\n            }\n    }\n}",
        "import_statements": [],
        "reference_api": [
            "m_NetworkAnimator.IsServerAuthoritative",
            "m_ProcessParameterUpdates.Clear",
            "m_NetworkAnimator.UpdateParameters",
            "FlushMessages",
            "m_NetworkAnimator.CheckForAnimatorChanges"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "FlushMessages",
                "code": "private void FlushMessages()\n        {\n            foreach (var animationUpdate in m_SendAnimationUpdates)\n            {\n                m_NetworkAnimator.SendAnimStateClientRpc(animationUpdate.AnimationMessage, animationUpdate.ClientRpcParams);\n            }\n\n            m_SendAnimationUpdates.Clear();\n\n            foreach (var sendEntry in m_SendParameterUpdates)\n            {\n                m_NetworkAnimator.SendParametersUpdateClientRpc(sendEntry.ParametersUpdateMessage, sendEntry.ClientRpcParams);\n            }\n            m_SendParameterUpdates.Clear();\n\n            foreach (var sendEntry in m_SendTriggerUpdates)\n            {\n                if (!sendEntry.SendToServer)\n                {\n                    m_NetworkAnimator.SendAnimTriggerClientRpc(sendEntry.AnimationTriggerMessage, sendEntry.ClientRpcParams);\n                }\n                else\n                {\n                    m_NetworkAnimator.SendAnimTriggerServerRpc(sendEntry.AnimationTriggerMessage);\n                }\n            }\n            m_SendTriggerUpdates.Clear();\n        }"
            }
        ],
        "third_party": [
            "m_NetworkAnimator.IsServerAuthoritative",
            "m_ProcessParameterUpdates.Clear",
            "m_NetworkAnimator.UpdateParameters",
            "m_NetworkAnimator.CheckForAnimatorChanges"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Unity-Technologies/com.unity.netcode.gameobjects",
        "function_declaration": "private void UpdateOwnershipAuthority()",
        "start_line": "76",
        "end_line": "94",
        "file_path": "com.unity.netcode.gameobjects/Components/NetworkRigidbody.cs",
        "docstring": "This function, UpdateOwnershipAuthority, updates the ownership authority of an object based on server authority and ownership status.\\nIt sets the object's authority state and adjusts the Rigidbody's kinematic and interpolation properties accordingly.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d78874b65b32",
        "ground_truth": "private void UpdateOwnershipAuthority()\n{\n    if (m_IsServerAuthoritative)\n    {\n        m_IsAuthority = NetworkManager.IsServer;\n    }\n    else\n    {\n        m_IsAuthority = IsOwner;\n    }\n    // If you have authority then you are not kinematic\n    m_Rigidbody.isKinematic = !m_IsAuthority;\n    // Set interpolation of the Rigidbody based on authority\n    // With authority: let local transform handle interpolation\n    // Without authority: let the NetworkTransform handle interpolation\n    m_Rigidbody.interpolation = m_IsAuthority ? m_OriginalInterpolation : RigidbodyInterpolation.None;\n}",
        "import_statements": [],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "Unity-Technologies/com.unity.netcode.gameobjects",
        "function_declaration": "public static void DecompressQuaternion(ref Quaternion quaternion, uint compressed)",
        "start_line": "100",
        "end_line": "121",
        "file_path": "com.unity.netcode.gameobjects/Components/QuaternionCompressor.cs",
        "docstring": "This function, DecompressQuaternion, reconstructs a Quaternion from a compressed uint value.\\nIt determines which quaternion component to skip based on the compressed value's highest two bits.\\nIt then decompresses the remaining components, calculates their sum of squared magnitudes,\\nand computes the skipped component to ensure the quaternion's unit length.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "304fe1278db9",
        "ground_truth": "public static void DecompressQuaternion(ref Quaternion quaternion, uint compressed)\n{\n    // Get the last two bits for the index to skip (0-3)\n    var indexToSkip = (int)(compressed >> 30);\n    // Reverse out the values while skipping over the largest value index\n    var sumOfSquaredMagnitudes = 0.0f;\n    for (int i = 3; i >= 0; --i)\n    {\n        if (i == indexToSkip)\n        {\n            continue;\n        }\n        // Check the negative bit and multiply that result with the decompressed and decoded value\n        quaternion[i] = ((compressed & k_NegShortBit) > 0 ? -1.0f : 1.0f) * ((compressed & k_PrecisionMask) * k_DcompressionDecodingMask);\n        sumOfSquaredMagnitudes += quaternion[i] * quaternion[i];\n        compressed = compressed >> 10;\n    }\n    // Since a normalized quaternion's magnitude is 1.0f, we subtract the sum of the squared smallest three from the unit value and take\n    // the square root of the difference to find the final largest value\n    quaternion[indexToSkip] = Mathf.Sqrt(1.0f - sumOfSquaredMagnitudes);\n}",
        "import_statements": [
            "using System.Runtime.CompilerServices",
            "using UnityEngine"
        ],
        "reference_api": [
            "Mathf.Sqrt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Mathf.Sqrt"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "JasonXuDeveloper/JEngine",
        "function_declaration": "static void GenerateCLRBindingByAnalysis()",
        "start_line": "14",
        "end_line": "28",
        "file_path": "UnityProject/Assets/Dependencies/ILRuntime/Editor/ILRuntimeCLRBinding.cs",
        "docstring": "This function, GenerateCLRBindingByAnalysis, generates CLR bindings through analysis.\\nIt creates a new AppDomain, loads an assembly from a specified file, and initializes ILRuntime with the domain.\\nIt then generates binding code and refreshes the AssetDatabase.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "452b860a7dde",
        "ground_truth": "static void GenerateCLRBindingByAnalysis()\n{\n    //\u7528\u65b0\u7684\u5206\u6790\u70ed\u66f4dll\u8c03\u7528\u5f15\u7528\u6765\u751f\u6210\u7ed1\u5b9a\u4ee3\u7801\n    AppDomain domain = new AppDomain();\n    using (FileStream fs = new FileStream($\"{ConstMgr.DLLSourceFolder}{ConstMgr.MainHotDLLName}{ConstMgr.DLLExtension}\", FileMode.Open, FileAccess.Read))\n    {\n        domain.LoadAssembly(fs);\n        //Crossbind Adapter is needed to generate the correct binding code\n        InitILRuntime(domain);\n        BindingCodeGenerator.GenerateBindingCode(domain, \"Assets/Dependencies/ILRuntime/Generated\");\n    }\n    AssetDatabase.Refresh();\n}",
        "import_statements": [],
        "reference_api": [
            "indingCodeGen",
            "",
            "Code(domain, \"Assets/Dependencies/ILRunt",
            "  //Crossbind Adapt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "indingCodeGen",
            "",
            "Code(domain, \"Assets/Dependencies/ILRunt",
            "  //Crossbind Adapt"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public override void OnInspectorGUI()",
        "start_line": "22",
        "end_line": "48",
        "file_path": "Scripts/Editor/Inspector/ConfigComponentInspector.cs",
        "docstring": "This function, OnInspectorGUI, customizes the inspector GUI for a ConfigComponent.\\nIt updates the serialized object, displays various properties, and uses a disabled group to prevent changes during play mode.\\nIf the application is playing and the target is a prefab in the hierarchy, it displays the config count and cached bytes size.\\nFinally, it applies any modified properties and repaints the inspector.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b8990031b636",
        "ground_truth": "public override void OnInspectorGUI()\n{\n    base.OnInspectorGUI();\n    serializedObject.Update();\n    ConfigComponent t = (ConfigComponent)target;\n    EditorGUI.BeginDisabledGroup(EditorApplication.isPlayingOrWillChangePlaymode);\n    {\n        EditorGUILayout.PropertyField(m_EnableLoadConfigUpdateEvent);\n        EditorGUILayout.PropertyField(m_EnableLoadConfigDependencyAssetEvent);\n        m_ConfigHelperInfo.Draw();\n        EditorGUILayout.PropertyField(m_CachedBytesSize);\n    }\n    EditorGUI.EndDisabledGroup();\n    if (EditorApplication.isPlaying && IsPrefabInHierarchy(t.gameObject))\n    {\n        EditorGUILayout.LabelField(\"Config Count\", t.Count.ToString());\n        EditorGUILayout.LabelField(\"Cached Bytes Size\", t.CachedBytesSize.ToString());\n    }\n    serializedObject.ApplyModifiedProperties();\n    Repaint();\n}",
        "import_statements": [
            "using UnityEditor",
            "using UnityGameFramework.Runtime"
        ],
        "reference_api": [
            "EditorGUILayout.LabelField",
            "Repaint",
            "EditorGUILayout.PropertyField",
            "IsPrefabInHierarchy",
            "base.OnInspectorGUI",
            "serializedObject.Update",
            "EditorGUI.BeginDisabledGroup",
            "t.CachedBytesSize.ToString",
            "serializedObject.ApplyModifiedProperties",
            "t.Count.ToString",
            "EditorGUI.EndDisabledGroup",
            "m_ConfigHelperInfo.Draw"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "EditorGUILayout.LabelField",
            "Repaint",
            "EditorGUILayout.PropertyField",
            "IsPrefabInHierarchy",
            "base.OnInspectorGUI",
            "serializedObject.Update",
            "EditorGUI.BeginDisabledGroup",
            "t.CachedBytesSize.ToString",
            "serializedObject.ApplyModifiedProperties",
            "t.Count.ToString",
            "EditorGUI.EndDisabledGroup",
            "m_ConfigHelperInfo.Draw"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public static void DefaultScenes()",
        "start_line": "84",
        "end_line": "101",
        "file_path": "Scripts/Editor/Misc/BuildSettings.cs",
        "docstring": "This function, DefaultScenes, sets the build settings scenes to a default set of scenes.\\nIt creates a HashSet of default scene names, converts them into a list of EditorBuildSettingsScene objects,\\nand updates the EditorBuildSettings with this list.\\nFinally, it logs that the scenes have been set to the default.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6453adc2daa8",
        "ground_truth": "public static void DefaultScenes()\n{\n    HashSet<string> sceneNames = new HashSet<string>();\n    foreach (string sceneName in s_DefaultSceneNames)\n    {\n        sceneNames.Add(sceneName);\n    }\n    List<EditorBuildSettingsScene> scenes = new List<EditorBuildSettingsScene>();\n    foreach (string sceneName in sceneNames)\n    {\n        scenes.Add(new EditorBuildSettingsScene(sceneName, true));\n    }\n    EditorBuildSettings.scenes = scenes.ToArray();\n    Debug.Log(\"Set scenes of build settings to default scenes.\");\n}",
        "import_statements": [
            "using GameFramework",
            "using System.Collections.Generic",
            "using System.IO",
            "using System.Xml",
            "using UnityEditor",
            "using UnityEngine"
        ],
        "reference_api": [
            "scenes.Add",
            "scenes.ToArray",
            "sceneNames.Add",
            "Debug.Log"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "scenes.Add",
            "scenes.ToArray",
            "sceneNames.Add",
            "Debug.Log"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public void Draw()",
        "start_line": "43",
        "end_line": "61",
        "file_path": "Scripts/Editor/Misc/HelperInfo.cs",
        "docstring": "This function, Draw, renders a custom editor UI for selecting and configuring a helper type.\\nIt displays a popup menu for selecting a helper type and updates the selected index accordingly.\\nIf no helper type is selected, it displays a field for a custom helper and shows an error message if the custom helper is not set.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e199f1a42526",
        "ground_truth": "public void Draw()\n{\n    string displayName = FieldNameForDisplay(m_Name);\n    int selectedIndex = EditorGUILayout.Popup(Utility.Text.Format(\"{0} Helper\", displayName), m_HelperTypeNameIndex, m_HelperTypeNames);\n    if (selectedIndex != m_HelperTypeNameIndex)\n    {\n        m_HelperTypeNameIndex = selectedIndex;\n        m_HelperTypeName.stringValue = selectedIndex <= 0 ? null : m_HelperTypeNames[selectedIndex];\n    }\n    if (m_HelperTypeNameIndex <= 0)\n    {\n        EditorGUILayout.PropertyField(m_CustomHelper);\n        if (m_CustomHelper.objectReferenceValue == null)\n        {\n            EditorGUILayout.HelpBox(Utility.Text.Format(\"You must set Custom {0} Helper.\", displayName), MessageType.Error);\n        }\n    }\n}",
        "import_statements": [
            "using GameFramework",
            "using System.Collections.Generic",
            "using System.Text.RegularExpressions",
            "using UnityEditor",
            "using UnityEngine"
        ],
        "reference_api": [
            "EditorGUILayout.HelpBox",
            "EditorGUILayout.PropertyField",
            "EditorGUILayout.Popup",
            "FieldNameForDisplay",
            "Utility.Text.Format"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "FieldNameForDisplay",
                "code": "private string FieldNameForDisplay(string fieldName)\n        {\n            if (string.IsNullOrEmpty(fieldName))\n            {\n                return string.Empty;\n            }\n\n            string str = Regex.Replace(fieldName, @\"^m_\", string.Empty);\n            str = Regex.Replace(str, @\"((?<=[a-z])[A-Z]|[A-Z](?=[a-z]))\", @\" $1\").TrimStart();\n            return str;\n        }"
            }
        ],
        "third_party": [
            "EditorGUILayout.HelpBox",
            "EditorGUILayout.PropertyField",
            "EditorGUILayout.Popup",
            "Utility.Text.Format"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public static void DisableAllLogs()",
        "start_line": "51",
        "end_line": "64",
        "file_path": "Scripts/Editor/Misc/LogScriptingDefineSymbols.cs",
        "docstring": "This function, DisableAllLogs, disables all logging by removing specific scripting define symbols.\\nIt removes a general logging symbol and then iterates through and removes symbols for specific logs and logs above a certain level.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "957e0aaa6f72",
        "ground_truth": "public static void DisableAllLogs()\n{\n    ScriptingDefineSymbols.RemoveScriptingDefineSymbol(EnableLogScriptingDefineSymbol);\n    foreach (string specifyLogScriptingDefineSymbol in SpecifyLogScriptingDefineSymbols)\n    {\n        ScriptingDefineSymbols.RemoveScriptingDefineSymbol(specifyLogScriptingDefineSymbol);\n    }\n    foreach (string aboveLogScriptingDefineSymbol in AboveLogScriptingDefineSymbols)\n    {\n        ScriptingDefineSymbols.RemoveScriptingDefineSymbol(aboveLogScriptingDefineSymbol);\n    }\n}",
        "import_statements": [
            "using UnityEditor"
        ],
        "reference_api": [
            "ScriptingDefineSymbols.RemoveScriptingDefineSymbol"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ScriptingDefineSymbols.RemoveScriptingDefineSymbol"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public static GameFrameworkComponent GetComponent(Type type)",
        "start_line": "43",
        "end_line": "57",
        "file_path": "Scripts/Runtime/Base/GameEntry.cs",
        "docstring": "This function, GetComponent, searches for and returns a GameFrameworkComponent of a specified type.\\nIt iterates through a linked list of components, checking each component's type.\\nIf a matching component is found, it returns it; otherwise, it returns null.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8a544c3d9513",
        "ground_truth": "public static GameFrameworkComponent GetComponent(Type type)\n{\n    LinkedListNode<GameFrameworkComponent> current = s_GameFrameworkComponents.First;\n    while (current != null)\n    {\n        if (current.Value.GetType() == type)\n        {\n            return current.Value;\n        }\n        current = current.Next;\n    }\n    return null;\n}",
        "import_statements": [
            "using GameFramework",
            "using System",
            "using System.Collections.Generic",
            "using UnityEngine",
            "using UnityEngine.SceneManagement"
        ],
        "reference_api": [
            "current.Value.GetType"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "current.Value.GetType"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public static void Shutdown(ShutdownType shutdownType)",
        "start_line": "85",
        "end_line": "116",
        "file_path": "Scripts/Runtime/Base/GameEntry.cs",
        "docstring": "This function, Shutdown, handles the shutdown process of the game framework based on the specified shutdown type.\\nIt logs the shutdown action, shuts down the BaseComponent if it exists, and clears game framework components.\\nDepending on the shutdown type, it either restarts the game scene, quits the application, or does nothing if the type is None.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ec304512c0e4",
        "ground_truth": "public static void Shutdown(ShutdownType shutdownType)\n{\n    Log.Info(\"Shutdown Game Framework ({0})...\", shutdownType);\n    BaseComponent baseComponent = GetComponent<BaseComponent>();\n    if (baseComponent != null)\n    {\n        baseComponent.Shutdown();\n        baseComponent = null;\n    }\n    s_GameFrameworkComponents.Clear();\n    if (shutdownType == ShutdownType.None)\n    {\n        return;\n    }\n    if (shutdownType == ShutdownType.Restart)\n    {\n        SceneManager.LoadScene(GameFrameworkSceneId);\n        return;\n    }\n    if (shutdownType == ShutdownType.Quit)\n    {\n        Application.Quit();\n#if UNITY_EDITOR\n        UnityEditor.EditorApplication.isPlaying = false;\n#endif\n        return;\n    }\n}",
        "import_statements": [
            "using GameFramework",
            "using System",
            "using System.Collections.Generic",
            "using UnityEngine",
            "using UnityEngine.SceneManagement"
        ],
        "reference_api": [
            "baseComponent.Shutdown",
            "Log.Info",
            "GetComponent<BaseComponent>",
            "Application.Quit",
            "SceneManager.LoadScene",
            "s_GameFrameworkComponents.Clear"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "baseComponent.Shutdown",
            "Log.Info",
            "GetComponent<BaseComponent>",
            "Application.Quit",
            "SceneManager.LoadScene",
            "s_GameFrameworkComponents.Clear"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "protected override void Awake()",
        "start_line": "67",
        "end_line": "90",
        "file_path": "Scripts/Runtime/Config/ConfigComponent.cs",
        "docstring": "This function, Awake, initializes the configuration manager by obtaining it from the GameFrameworkEntry module.\\nIt checks if the config manager is valid and logs a fatal error if not.\\nIt subscribes to events for reading data success and failure, and optionally to update and dependency asset events based on specific flags.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5c78a1d4f59d",
        "ground_truth": "protected override void Awake()\n{\n    base.Awake();\n    m_ConfigManager = GameFrameworkEntry.GetModule<IConfigManager>();\n    if (m_ConfigManager == null)\n    {\n        Log.Fatal(\"Config manager is invalid.\");\n        return;\n    }\n    m_ConfigManager.ReadDataSuccess += OnReadDataSuccess;\n    m_ConfigManager.ReadDataFailure += OnReadDataFailure;\n    if (m_EnableLoadConfigUpdateEvent)\n    {\n        m_ConfigManager.ReadDataUpdate += OnReadDataUpdate;\n    }\n    if (m_EnableLoadConfigDependencyAssetEvent)\n    {\n        m_ConfigManager.ReadDataDependencyAsset += OnReadDataDependencyAsset;\n    }\n}",
        "import_statements": [
            "using GameFramework",
            "using GameFramework.Config",
            "using GameFramework.Resource",
            "using UnityEngine"
        ],
        "reference_api": [
            "base.Awake",
            "Log.Fatal",
            "GameFrameworkEntry.GetModule<IConfigManager>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "base.Awake",
            "Log.Fatal",
            "GameFrameworkEntry.GetModule<IConfigManager>"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public override bool ReadData(IConfigManager configManager, string configAssetName, object configAsset, object userData)",
        "start_line": "36",
        "end_line": "53",
        "file_path": "Scripts/Runtime/Config/DefaultConfigHelper.cs",
        "docstring": "This function, ReadData, reads and parses configuration data using a provided config manager.\\nIt checks if the config asset is a TextAsset and determines the parsing method based on the file extension.\\nIf the asset ends with a specific byte extension, it parses the data as bytes; otherwise, it parses as text.\\nIf the asset is invalid, it logs a warning and returns false.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fbb36ff9d552",
        "ground_truth": "public override bool ReadData(IConfigManager configManager, string configAssetName, object configAsset, object userData)\n{\n    TextAsset configTextAsset = configAsset as TextAsset;\n    if (configTextAsset != null)\n    {\n        if (configAssetName.EndsWith(BytesAssetExtension, StringComparison.Ordinal))\n        {\n            return configManager.ParseData(configTextAsset.bytes, userData);\n        }\n        else\n        {\n            return configManager.ParseData(configTextAsset.text, userData);\n        }\n    }\n    Log.Warning(\"Config asset '{0}' is invalid.\", configAssetName);\n    return false;\n}",
        "import_statements": [
            "using GameFramework",
            "using GameFramework.Config",
            "using System",
            "using System.IO",
            "using System.Text",
            "using UnityEngine"
        ],
        "reference_api": [
            "configManager.ParseData",
            "configAssetName.EndsWith",
            "Log.Warning"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "configManager.ParseData",
            "configAssetName.EndsWith",
            "Log.Warning"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public override bool ParseData(IConfigManager configManager, byte[] configBytes, int startIndex, int length, object userData)",
        "start_line": "131",
        "end_line": "159",
        "file_path": "Scripts/Runtime/Config/DefaultConfigHelper.cs",
        "docstring": "This function, ParseData, parses configuration data from a byte array and adds it to a config manager.\\nIt reads the byte array using a MemoryStream and BinaryReader, extracting config names and values.\\nIf a config entry cannot be added due to being invalid or duplicate, it logs a warning and returns false.\\nIf an exception occurs during parsing, it logs the exception and returns false. Otherwise, it returns true.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "84d744c480ca",
        "ground_truth": "public override bool ParseData(IConfigManager configManager, byte[] configBytes, int startIndex, int length, object userData)\n{\n    try\n    {\n        using (MemoryStream memoryStream = new MemoryStream(configBytes, startIndex, length, false))\n        {\n            using (BinaryReader binaryReader = new BinaryReader(memoryStream, Encoding.UTF8))\n            {\n                while (binaryReader.BaseStream.Position < binaryReader.BaseStream.Length)\n                {\n                    string configName = binaryReader.ReadString();\n                    string configValue = binaryReader.ReadString();\n                    if (!configManager.AddConfig(configName, configValue))\n                    {\n                        Log.Warning(\"Can not add config with config name '{0}' which may be invalid or duplicate.\", configName);\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    catch (Exception exception)\n    {\n        Log.Warning(\"Can not parse config bytes with exception '{0}'.\", exception);\n        return false;\n    }\n}",
        "import_statements": [
            "using GameFramework",
            "using GameFramework.Config",
            "using System",
            "using System.IO",
            "using System.Text",
            "using UnityEngine"
        ],
        "reference_api": [
            "binaryReader.ReadString",
            "configManager.AddConfig",
            "Log.Warning"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "binaryReader.ReadString",
            "configManager.AddConfig",
            "Log.Warning"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public override void ReleaseDataAsset(IConfigManager configManager, object configAsset)",
        "start_line": "166",
        "end_line": "169",
        "file_path": "Scripts/Runtime/Config/DefaultConfigHelper.cs",
        "docstring": "This function, ReleaseDataAsset, releases a configuration asset by unloading it using a resource component.\\nIt takes a config manager and the config asset as parameters and calls the UnloadAsset method on the resource component.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "298bb6fa19a4",
        "ground_truth": "public override void ReleaseDataAsset(IConfigManager configManager, object configAsset)\n{\n    m_ResourceComponent.UnloadAsset(configAsset);\n}",
        "import_statements": [
            "using GameFramework",
            "using GameFramework.Config",
            "using System",
            "using System.IO",
            "using System.Text",
            "using UnityEngine"
        ],
        "reference_api": [
            "m_ResourceComponent.UnloadAsset"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "m_ResourceComponent.UnloadAsset"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": " public static ActiveSceneChangedEventArgs Create(Scene lastActiveScene, Scene activeScene)",
        "start_line": "68",
        "end_line": "74",
        "file_path": "Scripts/Runtime/Scene/ActiveSceneChangedEventArgs.cs",
        "docstring": "This function, ReleaseDataAsset, releases a configuration asset by unloading it using a resource component.\\nIt takes a config manager and the config asset as parameters and calls the UnloadAsset method on the resource component.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fa2003d95e36",
        "ground_truth": "public static ActiveSceneChangedEventArgs Create(Scene lastActiveScene, Scene activeScene)\n{\n    ActiveSceneChangedEventArgs activeSceneChangedEventArgs = ReferencePool.Acquire<ActiveSceneChangedEventArgs>();\n    activeSceneChangedEventArgs.LastActiveScene = lastActiveScene;\n    activeSceneChangedEventArgs.ActiveScene = activeScene;\n    return activeSceneChangedEventArgs;\n}",
        "import_statements": [
            "using GameFramework",
            "using GameFramework.Event",
            "using UnityEngine.SceneManagement"
        ],
        "reference_api": [
            "ReferencePool.Acquire<ActiveSceneChangedEventArgs>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ReferencePool.Acquire<ActiveSceneChangedEventArgs>"
        ]
    },
    {
        "subclass": "Unity3D",
        "owner/repo": "EllanJiang/UnityGameFramework",
        "function_declaration": "public void LoadScene(string sceneAssetName, int priority, object userData)",
        "start_line": "285",
        "end_line": "300",
        "file_path": "Scripts/Runtime/Scene/SceneComponent.cs",
        "docstring": "This function, LoadScene, loads a scene given its name, priority, and user data.\\nIt first checks if the scene asset name is valid and logs an error if it is not.\\nIt ensures the name starts with \"Assets/\" and ends with \".unity\"; otherwise, it logs an error.\\nIf the name is valid, it calls the LoadScene method on the scene manager with the provided parameters.",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "aba13f34251c",
        "ground_truth": "public void LoadScene(string sceneAssetName, int priority, object userData)\n{\n    if (string.IsNullOrEmpty(sceneAssetName))\n    {\n        Log.Error(\"Scene asset name is invalid.\");\n        return;\n    }\n    if (!sceneAssetName.StartsWith(\"Assets/\", StringComparison.Ordinal) || !sceneAssetName.EndsWith(\".unity\", StringComparison.Ordinal))\n    {\n        Log.Error(\"Scene asset name '{0}' is invalid.\", sceneAssetName);\n        return;\n    }\n    m_SceneManager.LoadScene(sceneAssetName, priority, userData);\n}",
        "import_statements": [
            "using GameFramework",
            "using GameFramework.Resource",
            "using GameFramework.Scene",
            "using System",
            "using System.Collections.Generic",
            "using UnityEngine",
            "using UnityEngine.SceneManagement"
        ],
        "reference_api": [
            "sceneAssetName.EndsWith",
            "m_SceneManager.LoadScene",
            "string.IsNullOrEmpty",
            "Log.Error",
            "sceneAssetName.StartsWith"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "sceneAssetName.EndsWith",
            "m_SceneManager.LoadScene",
            "string.IsNullOrEmpty",
            "Log.Error",
            "sceneAssetName.StartsWith"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "hxhb/HotPatcher",
        "function_declaration": "void FBinariesPatchFeatureModule::StartupModule()",
        "start_line": "26",
        "end_line": "35",
        "file_path": "HotPatcher/Source/BinariesPatchFeature/Private/BinariesPatchFeature.cpp",
        "docstring": "This function, FBinariesPatchFeatureModule::StartupModule, initializes the binaries patch feature module.\\nIt retrieves registered feature implementations and appends their names to the binaries patch feature enumerations.\\nIt also sets up callbacks for when modular features are registered or unregistered.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3fe99fba3ce8",
        "ground_truth": "void FBinariesPatchFeatureModule::StartupModule()\n{\n TArray<IBinariesDiffPatchFeature*> RegistedFeatures = IModularFeatures::Get().GetModularFeatureImplementations<IBinariesDiffPatchFeature>(BINARIES_DIFF_PATCH_FEATURE_NAME);\n for(const auto& Featue:RegistedFeatures)\n {\n  THotPatcherTemplateHelper::AppendEnumeraters<EBinariesPatchFeature>(TArray<FString>{Featue->GetFeatureName()});\n }\n IModularFeatures::Get().OnModularFeatureRegistered().AddStatic(&OnBinariesModularFeatureRegistered);\n IModularFeatures::Get().OnModularFeatureUnregistered().AddStatic(&OnBinariesModularFeatureUnRegistered);\n}",
        "import_statements": [
            "#include \"BinariesPatchFeature.h\"\n",
            "#include \"HotPatcherTemplateHelper.hpp\"\n",
            "#include \"Resources/Version.h\"\n",
            "#include \"Features/IModularFeatures.h\"\n",
            "#include \"Misc/EnumRange.h\"\n",
            "#include \"Modules/ModuleManager.h\"\n",
            "#include \"UObject/Class.h\"\n"
        ],
        "reference_api": [
            "IModularFeatures::Get().OnModularFeatureUnregistered().AddStatic",
            "THotPatcherTemplateHelper::AppendEnumeraters<EBinariesPatchFeature>",
            "IModularFeatures::Get",
            "Featue->GetFeatureName",
            "IModularFeatures::Get().OnModularFeatureRegistered",
            "IModularFeatures::Get().OnModularFeatureRegistered().AddStatic",
            "IModularFeatures::Get().OnModularFeatureUnregistered",
            "IModularFeatures::Get().GetModularFeatureImplementations<IBinariesDiffPatchFeature>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "IModularFeatures::Get().OnModularFeatureUnregistered().AddStatic",
            "THotPatcherTemplateHelper::AppendEnumeraters<EBinariesPatchFeature>",
            "IModularFeatures::Get",
            "Featue->GetFeatureName",
            "IModularFeatures::Get().OnModularFeatureRegistered",
            "IModularFeatures::Get().OnModularFeatureRegistered().AddStatic",
            "IModularFeatures::Get().OnModularFeatureUnregistered",
            "IModularFeatures::Get().GetModularFeatureImplementations<IBinariesDiffPatchFeature>"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "hxhb/HotPatcher",
        "function_declaration": "TArray<FString> CommandletHelper::ParserPatchConfigByCommandline(const FString& Commandline,const FString& Token)",
        "start_line": "20",
        "end_line": "30",
        "file_path": "HotPatcher/Source/HotPatcherCore/Classes/Commandlets/CommandletHelper.cpp",
        "docstring": "This function, ParserPatchConfigByCommandline, parses a command line string for a specific token and returns an array of strings.\\nIt converts the command line into a map of key-value pairs and checks for the presence of the specified token.\\nIf the token is found, it splits the associated value by commas into an array and returns it.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c702cc0f74b5",
        "ground_truth": "TArray<FString> CommandletHelper::ParserPatchConfigByCommandline(const FString& Commandline,const FString& Token)\n{\n TArray<FString> result;\n TMap<FString, FString> KeyValues = THotPatcherTemplateHelper::GetCommandLineParamsMap(Commandline);\n if(KeyValues.Find(Token))\n {\n  FString AddPakListInfo = *KeyValues.Find(Token);\n  AddPakListInfo.ParseIntoArray(result,TEXT(\",\"));\n }\n return result;\n}",
        "import_statements": [
            "#include \"CommandletHelper.h\"\n",
            "#include \"ETargetPlatform.h\"\n",
            "#include \"FlibPatchParserHelper.h\"\n",
            "#include \"ThreadUtils/FProcWorkerThread.hpp\"\n",
            "#include \"HotPatcherLog.h\"\n",
            "#include \"Engine/Engine.h\"\n"
        ],
        "reference_api": [
            "THotPatcherTemplateHelper::GetCommandLineParamsMap",
            "KeyValues.Find",
            "AddPakListInfo.ParseIntoArray",
            "TEXT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "THotPatcherTemplateHelper::GetCommandLineParamsMap",
            "KeyValues.Find",
            "AddPakListInfo.ParseIntoArray",
            "TEXT"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "hxhb/HotPatcher",
        "function_declaration": "bool CommandletHelper::IsCookCommandlet()",
        "start_line": "141",
        "end_line": "156",
        "file_path": "HotPatcher/Source/HotPatcherCore/Classes/Commandlets/CommandletHelper.cpp",
        "docstring": "This function, IsCookCommandlet, checks if the current running commandlet is a cook commandlet.\\nIt first verifies if a commandlet is running and retrieves its name.\\nIf the commandlet name is not empty and matches \"cook\" (case-insensitive), it returns true.\\nOtherwise, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6a6382275b1d",
        "ground_truth": "bool CommandletHelper::IsCookCommandlet()\n{\n bool bIsCookCommandlet = false;\n  if(::IsRunningCommandlet())\n {\n  FString CommandletName;\n  bool bIsCommandlet = CommandletHelper::GetCommandletArg(TEXT(\"-run=\"),CommandletName); //FParse::Value(FCommandLine::Get(), TEXT(\"-run=\"), CommandletName);\n    if(bIsCommandlet && !CommandletName.IsEmpty())\n  {\n   bIsCookCommandlet = CommandletName.Equals(TEXT(\"cook\"),ESearchCase::IgnoreCase);\n  }\n }\n return bIsCookCommandlet;\n}",
        "import_statements": [
            "#include \"CommandletHelper.h\"\n",
            "#include \"ETargetPlatform.h\"\n",
            "#include \"FlibPatchParserHelper.h\"\n",
            "#include \"ThreadUtils/FProcWorkerThread.hpp\"\n",
            "#include \"HotPatcherLog.h\"\n",
            "#include \"Engine/Engine.h\"\n"
        ],
        "reference_api": [
            "TEXT",
            "CommandletHelper::GetCommandletArg",
            "::IsRunningCommandlet",
            "CommandletName.IsEmpty",
            "CommandletName.Equals"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "TEXT",
            "CommandletHelper::GetCommandletArg",
            "::IsRunningCommandlet",
            "CommandletName.IsEmpty",
            "CommandletName.Equals"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "hxhb/HotPatcher",
        "function_declaration": "void UHotPatcherCommandletBase::Update(const FString& Params)",
        "start_line": "60",
        "end_line": "79",
        "file_path": "HotPatcher/Source/HotPatcherCore/Classes/Commandlets/HotPatcherCommandletBase.cpp",
        "docstring": "This function, Update, processes commandlet parameters and updates the serverless counter if enabled.\\nIt extracts the commandlet name from the command line and checks if serverless counting is enabled in the settings.\\nIf enabled, it initializes the counter with server request and project information,\\nmodifying the project name to include the commandlet name if applicable, and then processes the counter.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6888ed47b6be",
        "ground_truth": "void UHotPatcherCommandletBase::Update(const FString& Params)\n{\n FString CommandletName;\n bool bIsCommandlet = FParse::Value(FCommandLine::Get(), TEXT(\"-run=\"), CommandletName);\n   if(GetDefault<UHotPatcherSettings>()->bServerlessCounterInCmdlet)\n {\n  Counter = MakeShareable(new FCountServerlessWrapper);\n  FServerRequestInfo RequestInfo = FCountServerlessWrapper::MakeServerRequestInfo();\n  auto ProjectInfo = FCountServerlessWrapper::MakeCurrentProject();\n  ProjectInfo.PluginVersion = FString::Printf(TEXT(\"%d.%d\"),GToolMainVersion,GToolPatchVersion);\n   if(bIsCommandlet)\n  {\n   ProjectInfo.ProjectName = FString::Printf(TEXT(\"%s_%s\"),*ProjectInfo.ProjectName,*CommandletName);\n  }\n  Counter->Init(RequestInfo,ProjectInfo);\n  Counter->Processor();\n }\n}",
        "import_statements": [
            "#include \"HotPatcherCommandletBase.h\"\n",
            "#include \"CreatePatch/FExportReleaseSettings.h\"\n",
            "#include \"CreatePatch/ReleaseProxy.h\"\n",
            "#include \"CommandletHelper.h\"\n",
            "#include \"CoreMinimal.h\"\n",
            "#include \"HotPatcherCore.h\"\n",
            "#include \"Misc/FileHelper.h\"\n",
            "#include \"Misc/CommandLine.h\"\n",
            "#include \"Misc/Paths.h\"\n"
        ],
        "reference_api": [
            "MakeShareable",
            "FParse::Value",
            "TEXT",
            "FCommandLine::Get",
            "Counter->Processor",
            "FCountServerlessWrapper::MakeCurrentProject",
            "Counter->Init",
            "FString::Printf",
            "FCountServerlessWrapper::MakeServerRequestInfo",
            "GetDefault<UHotPatcherSettings>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "MakeShareable",
            "FParse::Value",
            "TEXT",
            "FCommandLine::Get",
            "Counter->Processor",
            "FCountServerlessWrapper::MakeCurrentProject",
            "Counter->Init",
            "FString::Printf",
            "FCountServerlessWrapper::MakeServerRequestInfo",
            "GetDefault<UHotPatcherSettings>"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "hxhb/HotPatcher",
        "function_declaration": "bool UFlibHotCookerHelper::IsAppleMetalPlatform(ITargetPlatform* TargetPlatform)",
        "start_line": "100",
        "end_line": "114",
        "file_path": "HotPatcher/Source/HotPatcherCore/Private/Cooker/MultiCooker/FlibHotCookerHelper.cpp",
        "docstring": "This function, IsAppleMetalPlatform, determines if a given target platform is an Apple Metal platform.\\nIt checks if the platform name starts with \"IOS\", \"Mac\", or \"TVOS\" (case-insensitive).\\nIt returns true if a match is found; otherwise, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c467af995f29",
        "ground_truth": "bool UFlibHotCookerHelper::IsAppleMetalPlatform(ITargetPlatform* TargetPlatform)\n{\n SCOPED_NAMED_EVENT_TEXT(\"IsAppleMetalPlatform\",FColor::Red);\n bool bIsMatched = false;\n TArray<FString> ApplePlatforms = {TEXT(\"IOS\"),TEXT(\"Mac\"),TEXT(\"TVOS\")};\n for(const auto& Platform:ApplePlatforms)\n {\n  if(TargetPlatform->PlatformName().StartsWith(Platform,ESearchCase::IgnoreCase))\n  {\n   bIsMatched = true;\n   break;\n  }\n }\n return bIsMatched;\n}",
        "import_statements": [
            "#include \"Cooker/MultiCooker/FlibHotCookerHelper.h\"\n",
            "#include \"FlibHotPatcherCoreHelper.h\"\n",
            "#include \"FlibPatchParserHelper.h\"\n",
            "#include \"Cooker/MultiCooker/FCookShaderCollectionProxy.h\"\n",
            "#include \"Interfaces/IPluginManager.h\"\n",
            "#include \"ShaderLibUtils/FlibShaderCodeLibraryHelper.h\"\n"
        ],
        "reference_api": [
            "TargetPlatform->PlatformName",
            "TEXT",
            "TargetPlatform->PlatformName().StartsWith",
            "SCOPED_NAMED_EVENT_TEXT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "TargetPlatform->PlatformName",
            "TEXT",
            "TargetPlatform->PlatformName().StartsWith",
            "SCOPED_NAMED_EVENT_TEXT"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "hxhb/HotPatcher",
        "function_declaration": "void FFreezePackageTracker::NotifyUObjectCreated(const UObjectBase* Object, int32 Index)",
        "start_line": "34",
        "end_line": "51",
        "file_path": "HotPatcher/Source/HotPatcherCore/Private/Cooker/MultiCooker/SingleCookerProxy.cpp",
        "docstring": "This function, NotifyUObjectCreated, handles the creation of a UObject.\\nIt retrieves the outermost package of the object and checks if it is valid.\\nIf the package is not in CookerAssetsSet but is in AllAssetsSet and does not always require post-load processing,\\nit adds the object to the PackageObjectsMap and FreezeObjects list.\\nIt also clears the RF_NeedPostLoad and RF_NeedPostLoadSubobjects flags from the object.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3df342b1c6f8",
        "ground_truth": "void FFreezePackageTracker::NotifyUObjectCreated(const UObjectBase* Object, int32 Index)\n{\n // UObject* ObjectOuter = Object->GetOuter();\n auto ObjectOuter = const_cast<UObject*>(static_cast<const UObject*>(Object));\n UPackage* Package = ObjectOuter ? ObjectOuter->GetOutermost() : nullptr;\n if(Package)\n {\n         FName AssetPathName = FName(*Package->GetPathName());\n  if(!CookerAssetsSet.Contains(AssetPathName) && AllAssetsSet.Contains(AssetPathName) && !IsAlwayPostLoadClasses(Package, ObjectOuter))\n  {\n   PackageObjectsMap.FindOrAdd(AssetPathName).Add(ObjectOuter);\n   FreezeObjects.Add(ObjectOuter);\n   ObjectOuter->ClearFlags(RF_NeedPostLoad);\n   ObjectOuter->ClearFlags(RF_NeedPostLoadSubobjects);\n  }\n }\n}",
        "import_statements": [
            "#include \"Cooker/MultiCooker/SingleCookerProxy.h\"\n",
            "#include \"FlibHotPatcherCoreHelper.h\"\n",
            "#include \"HotPatcherCore.h\"\n",
            "#include \"HotPatcherRuntime.h\"\n",
            "#include \"Cooker/MultiCooker/FlibHotCookerHelper.h\"\n",
            "#include \"ShaderCompiler.h\"\n",
            "#include \"UObject/UObjectHash.h\"\n",
            "#include \"UObject/UObjectIterator.h\"\n",
            "#include \"Async/ParallelFor.h\"\n",
            "#include \"ShaderLibUtils/FlibShaderCodeLibraryHelper.h\"\n",
            "#include \"ThreadUtils/FThreadUtils.hpp\"\n",
            "#include \"Cooker/MultiCooker/FCookShaderCollectionProxy.h\"\n",
            "#include \"Engine/Engine.h\"\n",
            "#include \"Misc/ScopeExit.h\"\n",
            "#include \"Engine/AssetManager.h\"\n",
            "#include \"Interfaces/ITargetPlatform.h\"\n",
            "#include \"Misc/EngineVersionComparison.h\"\n"
        ],
        "reference_api": [
            "ObjectOuter->ClearFlags",
            "FreezeObjects.Add",
            "PackageObjectsMap.FindOrAdd",
            "CookerAssetsSet.Contains",
            "IsAlwayPostLoadClasses",
            "ObjectOuter->GetOutermost",
            "FName",
            "PackageObjectsMap.FindOrAdd(AssetPathName).Add",
            "static_cast<const UObject*>",
            "Package->GetPathName",
            "const_cast<UObject*>",
            "AllAssetsSet.Contains"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "IsAlwayPostLoadClasses",
                "code": "bool IsAlwayPostLoadClasses(UPackage* Package, UObject* Object)\n{\n\treturn true;\n}"
            }
        ],
        "third_party": [
            "ObjectOuter->ClearFlags",
            "FreezeObjects.Add",
            "PackageObjectsMap.FindOrAdd",
            "CookerAssetsSet.Contains",
            "ObjectOuter->GetOutermost",
            "FName",
            "PackageObjectsMap.FindOrAdd(AssetPathName).Add",
            "static_cast<const UObject*>",
            "Package->GetPathName",
            "const_cast<UObject*>",
            "AllAssetsSet.Contains"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "hxhb/HotPatcher",
        "function_declaration": "void FHotPatcherPackageWriter::CollectForSaveBulkData(FRecord& Record, FCommitContext& Context)\n{",
        "start_line": "86",
        "end_line": "109",
        "file_path": "HotPatcher/Source/HotPatcherCore/Private/Cooker/PackageWriter/HotPatcherPackageWriter.cpp",
        "docstring": "This function, CollectForSaveBulkData, processes bulk data records within a given record and commit context.\\nIt iterates through each bulk data record and checks the bulk data type.\\nFor bulk data appended to exports, it adds the export buffer to the corresponding export buffer list in the context.\\nFor other bulk data types, it creates an output file entry in the context's output files, setting its properties such as filename, buffer, regions, and flags for sidecar status and hash contribution.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fac8b2878c3c",
        "ground_truth": "void FHotPatcherPackageWriter::CollectForSaveBulkData(FRecord& Record, FCommitContext& Context)\n{\n for (FBulkDataRecord& BulkRecord : Record.BulkDatas)\n {\n  if (BulkRecord.Info.BulkDataType == FBulkDataInfo::AppendToExports)\n  {\n   if (Record.bCompletedExportsArchiveForDiff)\n   {\n    // Already Added in CompleteExportsArchiveForDiff\n    continue;\n   }\n   Context.ExportsBuffers[BulkRecord.Info.MultiOutputIndex].Add(FExportBuffer{ BulkRecord.Buffer, MoveTemp(BulkRecord.Regions) });\n  }\n  else\n  {\n   FWriteFileData& OutputFile = Context.OutputFiles.Emplace_GetRef();\n   OutputFile.Filename = BulkRecord.Info.LooseFilePath;\n   OutputFile.Buffer = FCompositeBuffer(BulkRecord.Buffer);\n   OutputFile.Regions = MoveTemp(BulkRecord.Regions);\n   OutputFile.bIsSidecar = true;\n   OutputFile.bContributeToHash = BulkRecord.Info.MultiOutputIndex == 0; // Only caculate the main package output hash\n  }\n }\n}",
        "import_statements": [
            "#include \"Cooker/PackageWriter/HotPatcherPackageWriter.h\"\n"
        ],
        "reference_api": [
            "Context.OutputFiles.Emplace_GetRef",
            "FCompositeBuffer",
            "Context.ExportsBuffers[BulkRecord.Info.MultiOutputIndex].Add",
            "MoveTemp"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Context.OutputFiles.Emplace_GetRef",
            "FCompositeBuffer",
            "Context.ExportsBuffers[BulkRecord.Info.MultiOutputIndex].Add",
            "MoveTemp"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "hxhb/HotPatcher",
        "function_declaration": "void FHotPatcherPackageWriter::CollectForSaveExportsFooter(FRecord& Record, FCommitContext& Context)",
        "start_line": "137",
        "end_line": "151",
        "file_path": "HotPatcher/Source/HotPatcherCore/Private/Cooker/PackageWriter/HotPatcherPackageWriter.cpp",
        "docstring": "This function, CollectForSaveExportsFooter, adds a footer to export buffers if not already added.\\nIt checks if the export archive for diff is completed and returns if so.\\nOtherwise, it creates a footer buffer with the package file tag and adds this buffer to each package's export buffers in the context.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bf46051105c9",
        "ground_truth": "void FHotPatcherPackageWriter::CollectForSaveExportsFooter(FRecord& Record, FCommitContext& Context)\n{\n if (Record.bCompletedExportsArchiveForDiff)\n {\n  // Already Added in CompleteExportsArchiveForDiff\n  return;\n }\n  uint32 FooterData = PACKAGE_FILE_TAG;\n FSharedBuffer Buffer = FSharedBuffer::Clone(&FooterData, sizeof(FooterData));\n for (FPackageWriterRecords::FWritePackage& Package : Record.Packages)\n {\n  Context.ExportsBuffers[Package.Info.MultiOutputIndex].Add(FExportBuffer{ Buffer, TArray<FFileRegion>() });\n }\n}",
        "import_statements": [
            "#include \"Cooker/PackageWriter/HotPatcherPackageWriter.h\"\n"
        ],
        "reference_api": [
            "Context.ExportsBuffers[Package.Info.MultiOutputIndex].Add",
            "FSharedBuffer::Clone",
            "TArray<FFileRegion>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Context.ExportsBuffers[Package.Info.MultiOutputIndex].Add",
            "FSharedBuffer::Clone",
            "TArray<FFileRegion>"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "void UGDCharacterMovementComponent::FGDSavedMove::SetMoveFor(ACharacter * Character, float InDeltaTime, FVector const & NewAccel, FNetworkPredictionData_Client_Character & ClientData)",
        "start_line": "136",
        "end_line": "146",
        "file_path": "Source/GASDocumentation/Private/Characters/GDCharacterMovementComponent.cpp",
        "docstring": "This function, SetMoveFor, sets the movement parameters for a character.\\nIt calls the base class's SetMoveFor method, then casts the character's movement component to UGDCharacterMovementComponent.\\nIf the cast is successful, it saves the character's sprinting and aiming down sights (ADS) requests into the move.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c0966eddf1ee",
        "ground_truth": "void UGDCharacterMovementComponent::FGDSavedMove::SetMoveFor(ACharacter * Character, float InDeltaTime, FVector const & NewAccel, FNetworkPredictionData_Client_Character & ClientData)\n{\n Super::SetMoveFor(Character, InDeltaTime, NewAccel, ClientData);\n  UGDCharacterMovementComponent* CharacterMovement = Cast<UGDCharacterMovementComponent>(Character->GetCharacterMovement());\n if (CharacterMovement)\n {\n  SavedRequestToStartSprinting = CharacterMovement->RequestToStartSprinting;\n  SavedRequestToStartADS = CharacterMovement->RequestToStartADS;\n }\n}",
        "import_statements": [
            "#include \"Characters/GDCharacterMovementComponent.h\"\n",
            "#include \"AbilitySystemComponent.h\"\n",
            "#include \"Characters/GDCharacterBase.h\"\n",
            "#include \"GameplayTagContainer.h\"\n"
        ],
        "reference_api": [
            "Character->GetCharacterMovement",
            "Cast<UGDCharacterMovementComponent>",
            "Super::SetMoveFor"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Character->GetCharacterMovement",
            "Cast<UGDCharacterMovementComponent>",
            "Super::SetMoveFor"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributeChange(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute)",
        "start_line": "6",
        "end_line": "21",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/AsyncTaskAttributeChanged.cpp",
        "docstring": "This function, ListenForAttributeChange, creates and initializes an asynchronous task to listen for changes to a specified gameplay attribute on an ability system component.\\nIt validates the ability system component and attribute, and if valid, adds a delegate to handle attribute value changes.\\nIf either is invalid, it removes the task from the root and returns null.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f73106356e9d",
        "ground_truth": "UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributeChange(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute)\n{\n UAsyncTaskAttributeChanged* WaitForAttributeChangedTask = NewObject<UAsyncTaskAttributeChanged>();\n WaitForAttributeChangedTask->ASC = AbilitySystemComponent;\n WaitForAttributeChangedTask->AttributeToListenFor = Attribute;\n  if (!IsValid(AbilitySystemComponent) || !Attribute.IsValid())\n {\n  WaitForAttributeChangedTask->RemoveFromRoot();\n  return nullptr;\n }\n  AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject(WaitForAttributeChangedTask, &UAsyncTaskAttributeChanged::AttributeChanged);\n  return WaitForAttributeChangedTask;\n}",
        "import_statements": [
            "#include \"Characters/Abilities/AsyncTaskAttributeChanged.h\"\n"
        ],
        "reference_api": [
            "NewObject<UAsyncTaskAttributeChanged>",
            "IsValid",
            "AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate",
            "Attribute.IsValid",
            "WaitForAttributeChangedTask->RemoveFromRoot",
            "AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "NewObject<UAsyncTaskAttributeChanged>",
            "IsValid",
            "AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate",
            "Attribute.IsValid",
            "WaitForAttributeChangedTask->RemoveFromRoot",
            "AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "void UAsyncTaskCooldownChanged::EndTask()",
        "start_line": "32",
        "end_line": "49",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/AsyncTaskCooldownChanged.cpp",
        "docstring": "This function, EndTask, ends an asynchronous cooldown change task.\\nIt checks if the ASC (Ability System Component) is valid, then removes all delegates related to gameplay effect additions and cooldown tag events.\\nIt marks the task as ready to be destroyed and designates it as garbage.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a581424c2b31",
        "ground_truth": "void UAsyncTaskCooldownChanged::EndTask()\n{\n if (IsValid(ASC))\n {\n  ASC->OnActiveGameplayEffectAddedDelegateToSelf.RemoveAll(this);\n   TArray<FGameplayTag> CooldownTagArray;\n  CooldownTags.GetGameplayTagArray(CooldownTagArray);\n   for (FGameplayTag CooldownTag : CooldownTagArray)\n  {\n   ASC->RegisterGameplayTagEvent(CooldownTag, EGameplayTagEventType::NewOrRemoved).RemoveAll(this);\n  }\n }\n  SetReadyToDestroy();\n MarkAsGarbage();\n}",
        "import_statements": [
            "#include \"Characters/Abilities/AsyncTaskCooldownChanged.h\"\n"
        ],
        "reference_api": [
            "CooldownTags.GetGameplayTagArray",
            "ASC->RegisterGameplayTagEvent(CooldownTag, EGameplayTagEventType::NewOrRemoved).RemoveAll",
            "IsValid",
            "SetReadyToDestroy",
            "ASC->RegisterGameplayTagEvent",
            "MarkAsGarbage",
            "ASC->OnActiveGameplayEffectAddedDelegateToSelf.RemoveAll"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "CooldownTags.GetGameplayTagArray",
            "ASC->RegisterGameplayTagEvent(CooldownTag, EGameplayTagEventType::NewOrRemoved).RemoveAll",
            "IsValid",
            "SetReadyToDestroy",
            "ASC->RegisterGameplayTagEvent",
            "MarkAsGarbage",
            "ASC->OnActiveGameplayEffectAddedDelegateToSelf.RemoveAll"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "void UAsyncTaskEffectStackChanged::OnRemoveGameplayEffectCallback(const FActiveGameplayEffect & EffectRemoved)",
        "start_line": "57",
        "end_line": "69",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/AsyncTaskEffectStackChanged.cpp",
        "docstring": "This function, OnRemoveGameplayEffectCallback, is triggered when a gameplay effect is removed.\\nIt retrieves asset and granted tags from the removed effect.\\nIf either tag container contains the specified EffectGameplayTag, it broadcasts an effect stack change event with the tag, effect handle, and stack change details.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5029df3a2033",
        "ground_truth": "void UAsyncTaskEffectStackChanged::OnRemoveGameplayEffectCallback(const FActiveGameplayEffect & EffectRemoved)\n{\n FGameplayTagContainer AssetTags;\n EffectRemoved.Spec.GetAllAssetTags(AssetTags);\n  FGameplayTagContainer GrantedTags;\n EffectRemoved.Spec.GetAllGrantedTags(GrantedTags);\n  if (AssetTags.HasTagExact(EffectGameplayTag) || GrantedTags.HasTagExact(EffectGameplayTag))\n {\n  OnGameplayEffectStackChange.Broadcast(EffectGameplayTag, EffectRemoved.Handle, 0, 1);\n }\n}",
        "import_statements": [
            "#include \"Characters/Abilities/AsyncTaskEffectStackChanged.h\"\n"
        ],
        "reference_api": [
            "GrantedTags.HasTagExact",
            "EffectRemoved.Spec.GetAllGrantedTags",
            "EffectRemoved.Spec.GetAllAssetTags",
            "OnGameplayEffectStackChange.Broadcast",
            "AssetTags.HasTagExact"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GrantedTags.HasTagExact",
            "EffectRemoved.Spec.GetAllGrantedTags",
            "EffectRemoved.Spec.GetAllAssetTags",
            "OnGameplayEffectStackChange.Broadcast",
            "AssetTags.HasTagExact"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "UAsyncTaskEffectStackChanged * UAsyncTaskEffectStackChanged::ListenForGameplayEffectStackChange(UAbilitySystemComponent * AbilitySystemComponent, FGameplayTag InEffectGameplayTag)",
        "start_line": "6",
        "end_line": "22",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/AsyncTaskEffectStackChanged.cpp",
        "docstring": "This function, ListenForGameplayEffectStackChange, creates and initializes a UAsyncTaskEffectStackChanged object to listen for gameplay effect stack changes.\\nIt sets the AbilitySystemComponent and EffectGameplayTag, validating them.\\nIf valid, it registers callbacks for when gameplay effects are added or removed.\\nIf invalid, it ends the task and returns null.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cb1d2823d203",
        "ground_truth": "UAsyncTaskEffectStackChanged * UAsyncTaskEffectStackChanged::ListenForGameplayEffectStackChange(UAbilitySystemComponent * AbilitySystemComponent, FGameplayTag InEffectGameplayTag)\n{\n UAsyncTaskEffectStackChanged* ListenForGameplayEffectStackChange = NewObject<UAsyncTaskEffectStackChanged>();\n ListenForGameplayEffectStackChange->ASC = AbilitySystemComponent;\n ListenForGameplayEffectStackChange->EffectGameplayTag = InEffectGameplayTag;\n  if (!IsValid(AbilitySystemComponent) || !InEffectGameplayTag.IsValid())\n {\n  ListenForGameplayEffectStackChange->EndTask();\n  return nullptr;\n }\n  AbilitySystemComponent->OnActiveGameplayEffectAddedDelegateToSelf.AddUObject(ListenForGameplayEffectStackChange, &UAsyncTaskEffectStackChanged::OnActiveGameplayEffectAddedCallback);\n AbilitySystemComponent->OnAnyGameplayEffectRemovedDelegate().AddUObject(ListenForGameplayEffectStackChange, &UAsyncTaskEffectStackChanged::OnRemoveGameplayEffectCallback);\n  return ListenForGameplayEffectStackChange;\n}",
        "import_statements": [
            "#include \"Characters/Abilities/AsyncTaskEffectStackChanged.h\"\n"
        ],
        "reference_api": [
            "AbilitySystemComponent->OnAnyGameplayEffectRemovedDelegate",
            "InEffectGameplayTag.IsValid",
            "AbilitySystemComponent->OnAnyGameplayEffectRemovedDelegate().AddUObject",
            "NewObject<UAsyncTaskEffectStackChanged>",
            "AbilitySystemComponent->OnActiveGameplayEffectAddedDelegateToSelf.AddUObject",
            "IsValid",
            "ListenForGameplayEffectStackChange->EndTask"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "AbilitySystemComponent->OnAnyGameplayEffectRemovedDelegate",
            "InEffectGameplayTag.IsValid",
            "AbilitySystemComponent->OnAnyGameplayEffectRemovedDelegate().AddUObject",
            "NewObject<UAsyncTaskEffectStackChanged>",
            "AbilitySystemComponent->OnActiveGameplayEffectAddedDelegateToSelf.AddUObject",
            "IsValid",
            "ListenForGameplayEffectStackChange->EndTask"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "void UAsyncTaskEffectStackChanged::OnRemoveGameplayEffectCallback(const FActiveGameplayEffect & EffectRemoved)",
        "start_line": "57",
        "end_line": "69",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/AsyncTaskEffectStackChanged.cpp",
        "docstring": "This function, OnRemoveGameplayEffectCallback, is called when a gameplay effect is removed.\\nIt retrieves the asset and granted tags from the removed effect.\\nIf either tag container has the specified EffectGameplayTag, it broadcasts a stack change event with the tag, effect handle, and stack change details.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6659c2592e93",
        "ground_truth": "void UAsyncTaskEffectStackChanged::OnRemoveGameplayEffectCallback(const FActiveGameplayEffect & EffectRemoved)\n{\n FGameplayTagContainer AssetTags;\n EffectRemoved.Spec.GetAllAssetTags(AssetTags);\n  FGameplayTagContainer GrantedTags;\n EffectRemoved.Spec.GetAllGrantedTags(GrantedTags);\n  if (AssetTags.HasTagExact(EffectGameplayTag) || GrantedTags.HasTagExact(EffectGameplayTag))\n {\n  OnGameplayEffectStackChange.Broadcast(EffectGameplayTag, EffectRemoved.Handle, 0, 1);\n }\n}",
        "import_statements": [
            "#include \"Characters/Abilities/AsyncTaskEffectStackChanged.h\"\n"
        ],
        "reference_api": [
            "GrantedTags.HasTagExact",
            "EffectRemoved.Spec.GetAllGrantedTags",
            "EffectRemoved.Spec.GetAllAssetTags",
            "OnGameplayEffectStackChange.Broadcast",
            "AssetTags.HasTagExact"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GrantedTags.HasTagExact",
            "EffectRemoved.Spec.GetAllGrantedTags",
            "EffectRemoved.Spec.GetAllAssetTags",
            "OnGameplayEffectStackChange.Broadcast",
            "AssetTags.HasTagExact"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "void UGDGameplayAbility::OnAvatarSet(const FGameplayAbilityActorInfo * ActorInfo, const FGameplayAbilitySpec & Spec)",
        "start_line": "18",
        "end_line": "26",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/GDGameplayAbility.cpp",
        "docstring": "This function, OnAvatarSet, is called when an avatar is set for a gameplay ability.\\nIt first calls the base class's OnAvatarSet method.\\nIf the ActivateAbilityOnGranted flag is set, it attempts to activate the ability using the ability system component from the actor info.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a8f7dcc3f1fa",
        "ground_truth": "void UGDGameplayAbility::OnAvatarSet(const FGameplayAbilityActorInfo * ActorInfo, const FGameplayAbilitySpec & Spec)\n{\n Super::OnAvatarSet(ActorInfo, Spec);\n  if (ActivateAbilityOnGranted)\n {\n  ActorInfo->AbilitySystemComponent->TryActivateAbility(Spec.Handle, false);\n }\n}",
        "import_statements": [
            "#include \"Characters/Abilities/GDGameplayAbility.h\"\n",
            "#include \"AbilitySystemComponent.h\"\n",
            "#include \"GameplayTagContainer.h\"\n"
        ],
        "reference_api": [
            "Super::OnAvatarSet",
            "ActorInfo->AbilitySystemComponent->TryActivateAbility"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Super::OnAvatarSet",
            "ActorInfo->AbilitySystemComponent->TryActivateAbility"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "void UGDAT_PlayMontageAndWaitForEvent::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)",
        "start_line": "69",
        "end_line": "80",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/AbilityTasks/GDAT_PlayMontageAndWaitForEvent.cpp",
        "docstring": "This function, OnMontageEnded, is called when an animation montage ends.\\nIf the montage was not interrupted and the ability task should broadcast delegates,\\nit broadcasts the OnCompleted event with default gameplay tag and event data.\\nFinally, it ends the task.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "72a7ce4b848c",
        "ground_truth": "void UGDAT_PlayMontageAndWaitForEvent::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)\n{\n if (!bInterrupted)\n {\n  if (ShouldBroadcastAbilityTaskDelegates())\n  {\n   OnCompleted.Broadcast(FGameplayTag(), FGameplayEventData());\n  }\n }\n  EndTask();\n}",
        "import_statements": [
            "#include \"Characters/Abilities/AbilityTasks/GDAT_PlayMontageAndWaitForEvent.h\"\n",
            "#include \"AbilitySystemComponent.h\"\n",
            "#include \"AbilitySystemGlobals.h\"\n",
            "#include \"Animation/AnimInstance.h\"\n",
            "#include \"Characters/Abilities/GDAbilitySystemComponent.h\"\n",
            "#include \"Characters/Abilities/GDGameplayAbility.h\"\n",
            "#include \"GASDocumentation/GASDocumentation.h\"\n",
            "#include \"GameFramework/Character.h\"\n"
        ],
        "reference_api": [
            "FGameplayEventData",
            "OnCompleted.Broadcast",
            "ShouldBroadcastAbilityTaskDelegates",
            "EndTask",
            "FGameplayTag"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "FGameplayEventData",
            "OnCompleted.Broadcast",
            "ShouldBroadcastAbilityTaskDelegates",
            "EndTask",
            "FGameplayTag"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "void UGDAT_PlayMontageAndWaitForEvent::OnDestroy(bool AbilityEnded)",
        "start_line": "185",
        "end_line": "207",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/AbilityTasks/GDAT_PlayMontageAndWaitForEvent.cpp",
        "docstring": "This function, OnDestroy, handles the cleanup process when the ability ends or is destroyed.\\nIt removes the cancellation handler from the ability and stops playing the montage if the ability has ended and the stop flag is set.\\nIt also removes the event tag container delegate from the ability system component, if valid.\\nFinally, it calls the base class's OnDestroy method.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cc1cdd579bd4",
        "ground_truth": "void UGDAT_PlayMontageAndWaitForEvent::OnDestroy(bool AbilityEnded)\n{\n // Note: Clearing montage end delegate isn't necessary since its not a multicast and will be cleared when the next montage plays.\n // (If we are destroyed, it will detect this and not do anything)\n  // This delegate, however, should be cleared as it is a multicast\n if (Ability)\n {\n  Ability->OnGameplayAbilityCancelled.Remove(CancelledHandle);\n  if (AbilityEnded && bStopWhenAbilityEnds)\n  {\n   StopPlayingMontage();\n  }\n }\n  if (AbilitySystemComponent.IsValid())\n {\n  AbilitySystemComponent->RemoveGameplayEventTagContainerDelegate(EventTags, EventHandle);\n }\n  Super::OnDestroy(AbilityEnded);\n }",
        "import_statements": [
            "#include \"Characters/Abilities/AbilityTasks/GDAT_PlayMontageAndWaitForEvent.h\"\n",
            "#include \"AbilitySystemComponent.h\"\n",
            "#include \"AbilitySystemGlobals.h\"\n",
            "#include \"Animation/AnimInstance.h\"\n",
            "#include \"Characters/Abilities/GDAbilitySystemComponent.h\"\n",
            "#include \"Characters/Abilities/GDGameplayAbility.h\"\n",
            "#include \"GASDocumentation/GASDocumentation.h\"\n",
            "#include \"GameFramework/Character.h\"\n"
        ],
        "reference_api": [
            "AbilitySystemComponent->RemoveGameplayEventTagContainerDelegate",
            "AbilitySystemComponent.IsValid",
            "StopPlayingMontage",
            "Ability->OnGameplayAbilityCancelled.Remove",
            "Super::OnDestroy"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "StopPlayingMontage",
                "code": "bool UGDAT_PlayMontageAndWaitForEvent::StopPlayingMontage()\n{\n\tconst FGameplayAbilityActorInfo* ActorInfo = Ability->GetCurrentActorInfo();\n\tif (!ActorInfo)\n\t{\n\t\treturn false;\n\t}\n\n\tUAnimInstance* AnimInstance = ActorInfo->GetAnimInstance();\n\tif (AnimInstance == nullptr)\n\t{\n\t\treturn false;\n\t}\n\n\t// Check if the montage is still playing\n\t// The ability would have been interrupted, in which case we should automatically stop the montage\n\tif (AbilitySystemComponent.IsValid() && Ability)\n\t{\n\t\tif (AbilitySystemComponent->GetAnimatingAbility() == Ability\n\t\t\t&& AbilitySystemComponent->GetCurrentMontage() == MontageToPlay)\n\t\t{\n\t\t\t// Unbind delegates so they don't get called as well\n\t\t\tFAnimMontageInstance* MontageInstance = AnimInstance->GetActiveInstanceForMontage(MontageToPlay);\n\t\t\tif (MontageInstance)\n\t\t\t{\n\t\t\t\tMontageInstance->OnMontageBlendingOutStarted.Unbind();\n\t\t\t\tMontageInstance->OnMontageEnded.Unbind();\n\t\t\t}\n\n\t\t\tAbilitySystemComponent->CurrentMontageStop();\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
            }
        ],
        "third_party": [
            "AbilitySystemComponent->RemoveGameplayEventTagContainerDelegate",
            "AbilitySystemComponent.IsValid",
            "Ability->OnGameplayAbilityCancelled.Remove",
            "Super::OnDestroy"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tranek/GASDocumentation",
        "function_declaration": "bool UGDAT_PlayMontageAndWaitForEvent::StopPlayingMontage()",
        "start_line": "209",
        "end_line": "244",
        "file_path": "Source/GASDocumentation/Private/Characters/Abilities/AbilityTasks/GDAT_PlayMontageAndWaitForEvent.cpp",
        "docstring": "This function, StopPlayingMontage, stops a montage from playing if it is currently active for the ability.\\nIt first retrieves the actor info and animation instance.\\nIf the ability system component is valid and the montage is playing, it unbinds the delegates for the montage instance and stops the current montage using the ability system component.\\nIt returns true if the montage was successfully stopped, otherwise false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5932070df16f",
        "ground_truth": "bool UGDAT_PlayMontageAndWaitForEvent::StopPlayingMontage()\n{\n const FGameplayAbilityActorInfo* ActorInfo = Ability->GetCurrentActorInfo();\n if (!ActorInfo)\n {\n  return false;\n }\n  UAnimInstance* AnimInstance = ActorInfo->GetAnimInstance();\n if (AnimInstance == nullptr)\n {\n  return false;\n }\n  // Check if the montage is still playing\n // The ability would have been interrupted, in which case we should automatically stop the montage\n if (AbilitySystemComponent.IsValid() && Ability)\n {\n  if (AbilitySystemComponent->GetAnimatingAbility() == Ability\n   && AbilitySystemComponent->GetCurrentMontage() == MontageToPlay)\n  {\n   // Unbind delegates so they don't get called as well\n   FAnimMontageInstance* MontageInstance = AnimInstance->GetActiveInstanceForMontage(MontageToPlay);\n   if (MontageInstance)\n   {\n    MontageInstance->OnMontageBlendingOutStarted.Unbind();\n    MontageInstance->OnMontageEnded.Unbind();\n   }\n    AbilitySystemComponent->CurrentMontageStop();\n   return true;\n  }\n }\n  return false;\n}",
        "import_statements": [
            "#include \"Characters/Abilities/AbilityTasks/GDAT_PlayMontageAndWaitForEvent.h\"\n",
            "#include \"AbilitySystemComponent.h\"\n",
            "#include \"AbilitySystemGlobals.h\"\n",
            "#include \"Animation/AnimInstance.h\"\n",
            "#include \"Characters/Abilities/GDAbilitySystemComponent.h\"\n",
            "#include \"Characters/Abilities/GDGameplayAbility.h\"\n",
            "#include \"GASDocumentation/GASDocumentation.h\"\n",
            "#include \"GameFramework/Character.h\"\n"
        ],
        "reference_api": [
            "AbilitySystemComponent.IsValid",
            "AnimInstance->GetActiveInstanceForMontage",
            "AbilitySystemComponent->GetCurrentMontage",
            "ActorInfo->GetAnimInstance",
            "Ability->GetCurrentActorInfo",
            "MontageInstance->OnMontageBlendingOutStarted.Unbind",
            "AbilitySystemComponent->CurrentMontageStop",
            "AbilitySystemComponent->GetAnimatingAbility",
            "MontageInstance->OnMontageEnded.Unbind"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "AbilitySystemComponent.IsValid",
            "AnimInstance->GetActiveInstanceForMontage",
            "AbilitySystemComponent->GetCurrentMontage",
            "ActorInfo->GetAnimInstance",
            "Ability->GetCurrentActorInfo",
            "MontageInstance->OnMontageBlendingOutStarted.Unbind",
            "AbilitySystemComponent->CurrentMontageStop",
            "AbilitySystemComponent->GetAnimatingAbility",
            "MontageInstance->OnMontageEnded.Unbind"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USBTService_CheckAttackRange::TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds)",
        "start_line": "19",
        "end_line": "44",
        "file_path": "Source/ActionRoguelike/Private/AI/SBTService_CheckAttackRange.cpp",
        "docstring": "This function, TickNode, is called periodically to check if an AI pawn is within attack range of its target.\\nIt retrieves the target actor from the blackboard and calculates the distance to the AI pawn.\\nIf the target is within the maximum attack range, it checks for line of sight to the target.\\nThe result is then stored in the blackboard, indicating whether the target is within range and visible.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7049be7f0c75",
        "ground_truth": "void USBTService_CheckAttackRange::TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds)\n{\n Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);\n  // Check distance between ai pawn and target actor\n UBlackboardComponent* BlackBoardComp = OwnerComp.GetBlackboardComponent();\n check(BlackBoardComp);\n   AActor* TargetActor = Cast<AActor>(BlackBoardComp->GetValueAsObject(TargetActorKey.SelectedKeyName));\n if (TargetActor)\n {\n  AAIController* MyController = OwnerComp.GetAIOwner();\n  check(MyController);\n     const float DistanceTo = FVector::Distance(TargetActor->GetActorLocation(), MyController->GetPawn()->GetActorLocation());\n  const bool bWithinRange = DistanceTo < MaxAttackRange;\n   bool bHasLOS = false;\n  if (bWithinRange)\n  {\n   bHasLOS = MyController->LineOfSightTo(TargetActor);\n  }\n   BlackBoardComp->SetValueAsBool(AttackRangeKey.SelectedKeyName, (bWithinRange && bHasLOS));\n }\n}",
        "import_statements": [
            "#include \"AI/SBTService_CheckAttackRange.h\"\n",
            "#include \"BehaviorTree/BlackboardComponent.h\"\n",
            "#include \"AIController.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SBTService_CheckAttackRange)\n"
        ],
        "reference_api": [
            "BlackBoardComp->SetValueAsBool",
            "check",
            "MyController->LineOfSightTo",
            "Cast<AActor>",
            "OwnerComp.GetBlackboardComponent",
            "MyController->GetPawn",
            "FVector::Distance",
            "OwnerComp.GetAIOwner",
            "Super::TickNode",
            "MyController->GetPawn()->GetActorLocation",
            "BlackBoardComp->GetValueAsObject",
            "TargetActor->GetActorLocation"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "BlackBoardComp->SetValueAsBool",
            "check",
            "MyController->LineOfSightTo",
            "Cast<AActor>",
            "OwnerComp.GetBlackboardComponent",
            "MyController->GetPawn",
            "FVector::Distance",
            "OwnerComp.GetAIOwner",
            "Super::TickNode",
            "MyController->GetPawn()->GetActorLocation",
            "BlackBoardComp->GetValueAsObject",
            "TargetActor->GetActorLocation"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "EBTNodeResult::Type USBTTask_HealSelf::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)",
        "start_line": "11",
        "end_line": "22",
        "file_path": "Source/ActionRoguelike/Private/AI/SBTTask_HealSelf.cpp",
        "docstring": "This function, ExecuteTask, is part of a behavior tree task that heals the AI's pawn to its maximum health.\\nIt retrieves the pawn from the AI owner and gets its attribute component.\\nIf the attribute component is valid, it applies a health change to restore the pawn's health to maximum.\\nThe function returns a success result.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "031bd0ec3e3c",
        "ground_truth": "EBTNodeResult::Type USBTTask_HealSelf::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n APawn* MyPawn = OwnerComp.GetAIOwner()->GetPawn();\n  USAttributeComponent* AttributeComp = USAttributeComponent::GetAttributes(MyPawn);\n if (ensure(AttributeComp))\n {\n  AttributeComp->ApplyHealthChange(MyPawn, AttributeComp->GetHealthMax());\n }\n  return EBTNodeResult::Succeeded;\n}",
        "import_statements": [
            "#include \"AI/SBTTask_HealSelf.h\"\n",
            "#include \"SAttributeComponent.h\"\n",
            "#include \"AIController.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SBTTask_HealSelf)\n"
        ],
        "reference_api": [
            "OwnerComp.GetAIOwner()->GetPawn",
            "AttributeComp->ApplyHealthChange",
            "USAttributeComponent::GetAttributes",
            "AttributeComp->GetHealthMax",
            "ensure",
            "OwnerComp.GetAIOwner"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "OwnerComp.GetAIOwner()->GetPawn",
            "AttributeComp->ApplyHealthChange",
            "USAttributeComponent::GetAttributes",
            "AttributeComp->GetHealthMax",
            "ensure",
            "OwnerComp.GetAIOwner"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USProjectileMovementComponent::BeginPlay()",
        "start_line": "10",
        "end_line": "17",
        "file_path": "Source/ActionRoguelike/Private/Components/SProjectileMovementComponent.cpp",
        "docstring": "This function, BeginPlay, is called when the projectile movement component begins play.\\nIt calls the base class's BeginPlay method and then registers the component's primary tick with the USTickablesSubsystem in the world.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6cd6e778e91b",
        "ground_truth": "void USProjectileMovementComponent::BeginPlay()\n{\n Super::BeginPlay();\n   // BeginPlay on the component will be called after the tick has been registered via the owning Actor\n USTickablesSubsystem* Tickables = GetWorld()->GetSubsystem<USTickablesSubsystem>();\n Tickables->RegisterComponent(&PrimaryComponentTick);\n}",
        "import_statements": [
            "#include \"Components/SProjectileMovementComponent.h\"\n",
            "#include \"Subsystems/STickablesSubsystem.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SProjectileMovementComponent)\n"
        ],
        "reference_api": [
            "Tickables->RegisterComponent",
            "GetWorld()->GetSubsystem<USTickablesSubsystem>",
            "Super::BeginPlay",
            "GetWorld"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Tickables->RegisterComponent",
            "GetWorld()->GetSubsystem<USTickablesSubsystem>",
            "Super::BeginPlay",
            "GetWorld"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USProjectileMovementComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)",
        "start_line": "20",
        "end_line": "26",
        "file_path": "Source/ActionRoguelike/Private/Components/SProjectileMovementComponent.cpp",
        "docstring": "This function, EndPlay, is called when the projectile movement component is ending play.\\nIt first calls the base class's EndPlay method.\\nThen, it retrieves the USTickablesSubsystem from the world and deregisters the component's primary tick function from the tickables subsystem.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e90ff27c7f16",
        "ground_truth": "void USProjectileMovementComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n Super::EndPlay(EndPlayReason);\n   USTickablesSubsystem* Tickables = GetWorld()->GetSubsystem<USTickablesSubsystem>();\n Tickables->DeRegisterComponent(&PrimaryComponentTick);\n}",
        "import_statements": [
            "#include \"Components/SProjectileMovementComponent.h\"\n",
            "#include \"Subsystems/STickablesSubsystem.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SProjectileMovementComponent)\n"
        ],
        "reference_api": [
            "GetWorld()->GetSubsystem<USTickablesSubsystem>",
            "Tickables->DeRegisterComponent",
            "GetWorld",
            "Super::EndPlay"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GetWorld()->GetSubsystem<USTickablesSubsystem>",
            "Tickables->DeRegisterComponent",
            "GetWorld",
            "Super::EndPlay"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USSignificanceComponent::BeginPlay()",
        "start_line": "39",
        "end_line": "71",
        "file_path": "Source/ActionRoguelike/Private/Components/SSignificanceComponent.cpp",
        "docstring": "This function, BeginPlay, initializes the significance component when play begins.\\nIf managing significance is enabled, it checks if the owner implements the significance interface.\\nDepending on the bWaitOneFrame flag, it either registers the component with the manager immediately or schedules it for the next tick.\\nIt also manages particle significance for any particle system components owned by the actor.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "be3e542c07ea",
        "ground_truth": "void USSignificanceComponent::BeginPlay()\n{\n Super::BeginPlay();\n  // Register\n if (bManageSignificance)\n {\n  bHasImplementedInterface = GetOwner()->Implements<USSignificanceInterface>();\n   // Optionally wait one frame\n  if (bWaitOneFrame)\n  {\n   GetWorld()->GetTimerManager().SetTimerForNextTick(this, &USSignificanceComponent::RegisterWithManager);\n  }\n  else\n  {\n   RegisterWithManager();\n  }\n   // Manage particle components\n  if (bManageOwnerParticleSignificance)\n  {\n   // Cascade (deprecated)\n   TArray<UParticleSystemComponent*> CascadeParticles;\n   GetOwner()->GetComponents<UParticleSystemComponent>(CascadeParticles);\n    for (UParticleSystemComponent* Comp : CascadeParticles)\n   {\n    Comp->SetManagingSignificance(true);\n   }\n  }\n }\n}",
        "import_statements": [
            "#include \"Components/SSignificanceComponent.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"NiagaraComponent.h\"\n",
            "#include \"SSignificanceInterface.h\"\n",
            "#include \"ParticleHelper.h\"\n",
            "#include \"Particles/ParticleSystemComponent.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SSignificanceComponent)\n"
        ],
        "reference_api": [
            "Comp->SetManagingSignificance",
            "GetOwner()->Implements<USSignificanceInterface>",
            "GetOwner()->GetComponents<UParticleSystemComponent>",
            "GetWorld()->GetTimerManager",
            "Super::BeginPlay",
            "GetWorld",
            "GetOwner",
            "RegisterWithManager",
            "GetWorld()->GetTimerManager().SetTimerForNextTick"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RegisterWithManager",
                "code": "void USSignificanceComponent::RegisterWithManager()\n{\n\tif (USignificanceManager* SignificanceManager = USignificanceManager::Get(GetWorld()))\n\t{\n\t\tauto SignificanceFunc = [&](USignificanceManager::FManagedObjectInfo* ObjectInfo, const FTransform& Viewpoint) -> float\n\t\t{\n\t\t\treturn CalcSignificance(ObjectInfo, Viewpoint);\n\t\t};\n\t\t\n\t\tauto PostSignificanceFunc = [&](USignificanceManager::FManagedObjectInfo* ObjectInfo, float OldSignificance, float Significance, bool bFinal)\n\t\t{\n\t\t\tPostSignificanceUpdate(ObjectInfo, OldSignificance, Significance, bFinal);\n\t\t};\n\n\t\t// Register\n\t\t// for 'EPostSignificanceType::Concurrent' you need 'thread safe' post significance function\n\t\t// our sigman update runs during the game viewport update tick, so it should *probably* be ok so long as no other non-GT logic is interacting with the objects.\n\t\tFName Tag = GetOwner()->GetClass()->GetFName();\n\t\tSignificanceManager->RegisterObject(this, Tag, SignificanceFunc, USignificanceManager::EPostSignificanceType::Concurrent, PostSignificanceFunc);\n\t}\n}"
            }
        ],
        "third_party": [
            "Comp->SetManagingSignificance",
            "GetOwner()->Implements<USSignificanceInterface>",
            "GetOwner()->GetComponents<UParticleSystemComponent>",
            "GetWorld()->GetTimerManager",
            "Super::BeginPlay",
            "GetWorld",
            "GetOwner",
            "GetWorld()->GetTimerManager().SetTimerForNextTick"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USSignificanceComponent::RegisterWithManager()",
        "start_line": "74",
        "end_line": "94",
        "file_path": "Source/ActionRoguelike/Private/Components/SSignificanceComponent.cpp",
        "docstring": "This function, RegisterWithManager, registers the significance component with the significance manager.\\nIt retrieves the significance manager from the world and defines two lambda functions for calculating significance and handling post-significance updates.\\nIt then registers the component with the manager using the owner's class name as the tag and specifies the lambda functions for significance calculation and updates.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "77824b6415d0",
        "ground_truth": "void USSignificanceComponent::RegisterWithManager()\n{\n if (USignificanceManager* SignificanceManager = USignificanceManager::Get(GetWorld()))\n {\n  auto SignificanceFunc = [&](USignificanceManager::FManagedObjectInfo* ObjectInfo, const FTransform& Viewpoint) -> float\n  {\n   return CalcSignificance(ObjectInfo, Viewpoint);\n  };\n     auto PostSignificanceFunc = [&](USignificanceManager::FManagedObjectInfo* ObjectInfo, float OldSignificance, float Significance, bool bFinal)\n  {\n   PostSignificanceUpdate(ObjectInfo, OldSignificance, Significance, bFinal);\n  };\n   // Register\n  // for 'EPostSignificanceType::Concurrent' you need 'thread safe' post significance function\n  // our sigman update runs during the game viewport update tick, so it should *probably* be ok so long as no other non-GT logic is interacting with the objects.\n  FName Tag = GetOwner()->GetClass()->GetFName();\n  SignificanceManager->RegisterObject(this, Tag, SignificanceFunc, USignificanceManager::EPostSignificanceType::Concurrent, PostSignificanceFunc);\n }\n}",
        "import_statements": [
            "#include \"Components/SSignificanceComponent.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"NiagaraComponent.h\"\n",
            "#include \"SSignificanceInterface.h\"\n",
            "#include \"ParticleHelper.h\"\n",
            "#include \"Particles/ParticleSystemComponent.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SSignificanceComponent)\n"
        ],
        "reference_api": [
            "USignificanceManager::Get",
            "CalcSignificance",
            "SignificanceManager->RegisterObject",
            "PostSignificanceUpdate",
            "GetWorld",
            "GetOwner",
            "GetOwner()->GetClass",
            "GetOwner()->GetClass()->GetFName"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "CalcSignificance",
                "code": "float USSignificanceComponent::CalcSignificance(USignificanceManager::FManagedObjectInfo* ObjectInfo,\tconst FTransform& Viewpoint) const\n{\n\tif (GForcedSignificance >= 0.0f)\n\t{\n\t\treturn GForcedSignificance;\n\t}\n\t\n\tif (bInsignificantWhenOwnerIsHidden && GetOwner()->IsHidden())\n\t{\n\t\treturn static_cast<float>(ESignificanceValue::Hidden);\n\t}\n\n\t// Use Actor implemented override if present\n\tif (bHasImplementedInterface)\n\t{\n\t\tfloat Significance = 0.0f;\n\t\tif (ISSignificanceInterface::Execute_CalcSignificanceOverride(GetOwner(), Significance))\n\t\t{\n\t\t\treturn Significance;\n\t\t}\n\t}\n\n\tFVector OriginLocation = GetOwner()->GetActorLocation();\n\tif (bHasImplementedInterface)\n\t{\n\t\tFVector OverriddenOrigin = FVector::ZeroVector;\n\t\tif (ISSignificanceInterface::Execute_GetSignificanceLocation(GetOwner(), Viewpoint, OverriddenOrigin))\n\t\t{\n\t\t\tOriginLocation = OverriddenOrigin;\n\t\t}\n\t}\n\t\n\tconst float DistanceSqrd = (OriginLocation - Viewpoint.GetLocation()).SizeSquared();\n\treturn GetSignificanceByDistance(DistanceSqrd);\n}"
            },
            {
                "name": "PostSignificanceUpdate",
                "code": "void USSignificanceComponent::PostSignificanceUpdate(USignificanceManager::FManagedObjectInfo* ObjectInfo, float OldSignificance, float Significance, bool bFinal)\n{\n\tif (OldSignificance == Significance)\n\t{\n\t\t// disabled to run cascade update every frame (for now)\n\t\t//return;\n\t}\n\n\tif (Significance != OldSignificance || CurrentSignificance == ESignificanceValue::Invalid)\n\t{\n\t\tCurrentSignificance = static_cast<ESignificanceValue>(Significance);\n\t\tUE_LOGFMT(LogGame, Log, \"Significance for {owner} changed to {significance}\", GetNameSafe(GetOwner()), UEnum::GetValueAsString(CurrentSignificance));\n\t\tOnSignificanceChanged.Broadcast(CurrentSignificance);\n\t}\n\n\t// Running this every frame for now (commented out the above early out) as otherwise we can't properly cull the cascade VFX (to be re-worked later)\n\tif (!bManageOwnerParticleSignificance)\n\t{\n\t\tUpdateParticleSignificance(Significance);\n\t}\n}"
            }
        ],
        "third_party": [
            "USignificanceManager::Get",
            "SignificanceManager->RegisterObject",
            "GetWorld",
            "GetOwner",
            "GetOwner()->GetClass",
            "GetOwner()->GetClass()->GetFName"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "bool USActorPoolingSubsystem::ReleaseToPool(AActor* Actor)",
        "start_line": "28",
        "end_line": "39",
        "file_path": "Source/ActionRoguelike/Private/Subsystems/SActorPoolingSubsystem.cpp",
        "docstring": "This function, ReleaseToPool, attempts to release an actor to the pooling subsystem.\\nIt first checks if pooling is enabled for the actor.\\nIf so, it retrieves the pooling subsystem from the actor's world and calls an internal method to release the actor to the pool.\\nIf pooling is not enabled, it destroys the actor and returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dca342410d64",
        "ground_truth": "bool USActorPoolingSubsystem::ReleaseToPool(AActor* Actor)\n{\n if (IsPoolingEnabled(Actor))\n {\n  USActorPoolingSubsystem* PoolingSubsystem = Actor->GetWorld()->GetSubsystem<USActorPoolingSubsystem>();\n  return PoolingSubsystem->ReleaseToPool_Internal(Actor);\n }\n  SCOPED_NAMED_EVENT(DestroyActorNoPool, FColor::Red);\n Actor->Destroy();\n return false;\n}",
        "import_statements": [
            "#include \"Subsystems/SActorPoolingSubsystem.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"SActorPoolingInterface.h\"\n",
            "#include \"Logging/StructuredLog.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SActorPoolingSubsystem)\n"
        ],
        "reference_api": [
            "IsPoolingEnabled",
            "Actor->GetWorld",
            "Actor->Destroy",
            "SCOPED_NAMED_EVENT",
            "PoolingSubsystem->ReleaseToPool_Internal",
            "Actor->GetWorld()->GetSubsystem<USActorPoolingSubsystem>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "IsPoolingEnabled",
            "Actor->GetWorld",
            "Actor->Destroy",
            "SCOPED_NAMED_EVENT",
            "PoolingSubsystem->ReleaseToPool_Internal",
            "Actor->GetWorld()->GetSubsystem<USActorPoolingSubsystem>"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USActorPoolingSubsystem::PrimeActorPool(TSubclassOf<AActor> ActorClass, int32 Amount)",
        "start_line": "61",
        "end_line": "76",
        "file_path": "Source/ActionRoguelike/Private/Subsystems/SActorPoolingSubsystem.cpp",
        "docstring": "This function, PrimeActorPool, initializes a pool of actors of a specified class.\\nIt logs the start of the pooling process and creates a scoped event for profiling.\\nIt then spawns the specified number of actors using the provided actor class and default spawn parameters,\\nand immediately releases them to the pool.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5c285130f782",
        "ground_truth": "void USActorPoolingSubsystem::PrimeActorPool(TSubclassOf<AActor> ActorClass, int32 Amount)\n{\n UE_LOGFMT(LogGame, Log, \"Priming Pool for {actorclass} ({amount})\", GetNameSafe(ActorClass), Amount);\n SCOPED_NAMED_EVENT(PrimeActorPool, FColor::Blue);\n   // Prime a set number of pooled actors, this reduces memory fragmentation and any potential initial hitches during gameplay\n for (int i = 0; i < Amount; ++i)\n {\n  FActorSpawnParameters Params;\n  Params.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n     AActor* NewActor = GetWorld()->SpawnActor<AActor>(ActorClass, FTransform::Identity, Params);\n   ReleaseToPool(NewActor);\n }\n}",
        "import_statements": [
            "#include \"Subsystems/SActorPoolingSubsystem.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"SActorPoolingInterface.h\"\n",
            "#include \"Logging/StructuredLog.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SActorPoolingSubsystem)\n"
        ],
        "reference_api": [
            "ReleaseToPool",
            "SCOPED_NAMED_EVENT",
            "GetNameSafe",
            "GetWorld",
            "GetWorld()->SpawnActor<AActor>",
            "UE_LOGFMT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ReleaseToPool",
            "SCOPED_NAMED_EVENT",
            "GetNameSafe",
            "GetWorld",
            "GetWorld()->SpawnActor<AActor>",
            "UE_LOGFMT"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USLoadingScreenSubsystem::BeginLoadingScreen(const FString& MapName)",
        "start_line": "21",
        "end_line": "29",
        "file_path": "Source/ActionRoguelike/Private/Subsystems/SLoadingScreenSubsystem.cpp",
        "docstring": "This function, BeginLoadingScreen, initiates a loading screen for a specified map.\\nIt creates a FLoadingScreenAttributes object, assigns a new loading screen widget to it, and sets up the loading screen using the movie player.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "43c013653d6d",
        "ground_truth": "void USLoadingScreenSubsystem::BeginLoadingScreen(const FString& MapName)\n{\n FLoadingScreenAttributes LoadingScreen;\n //LoadingScreen.bAutoCompleteWhenLoadingCompletes = false;\n //LoadingScreen.bWaitForManualStop = true;\n LoadingScreen.WidgetLoadingScreen = FLoadingScreenAttributes::NewTestLoadingScreenWidget();\n  GetMoviePlayer()->SetupLoadingScreen(LoadingScreen);\n}",
        "import_statements": [
            "#include \"Subsystems/SLoadingScreenSubsystem.h\"\n",
            "#include \"MoviePlayer.h\"\n"
        ],
        "reference_api": [
            "GetMoviePlayer",
            "GetMoviePlayer()->SetupLoadingScreen",
            "FLoadingScreenAttributes::NewTestLoadingScreenWidget"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GetMoviePlayer",
            "GetMoviePlayer()->SetupLoadingScreen",
            "FLoadingScreenAttributes::NewTestLoadingScreenWidget"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USAction::StartAction_Implementation(AActor* Instigator)",
        "start_line": "36",
        "end_line": "52",
        "file_path": "Source/ActionRoguelike/Private/SAction.cpp",
        "docstring": "This function, StartAction_Implementation, begins an action for a specified instigator actor.\\nIt logs the start of the action, appends granted tags to the owning component's active gameplay tags, and updates the replication data.\\nIf the component's owner role is authoritative, it records the start time.\\nFinally, it broadcasts an action started event from the owning component.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a6979eb925a5",
        "ground_truth": "void USAction::StartAction_Implementation(AActor* Instigator)\n{\n UE_LOGFMT(LogGame, Log, \"Started: {ActionName}\", GetName());\n  USActionComponent* Comp = GetOwningComponent();\t\n Comp->ActiveGameplayTags.AppendTags(GrantsTags);\n  RepData.bIsRunning = true;\n RepData.Instigator = Instigator;\n  if (GetOwningComponent()->GetOwnerRole() == ROLE_Authority)\n {\n  TimeStarted = GetWorld()->TimeSeconds; \n }\n  GetOwningComponent()->OnActionStarted.Broadcast(GetOwningComponent(), this);\n}",
        "import_statements": [
            "#include \"SAction.h\"\n",
            "#include \"SActionComponent.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"Net/UnrealNetwork.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SAction)\n"
        ],
        "reference_api": [
            "GetOwningComponent()->GetOwnerRole",
            "GetWorld",
            "GetName",
            "UE_LOGFMT",
            "Comp->ActiveGameplayTags.AppendTags",
            "GetOwningComponent",
            "GetOwningComponent()->OnActionStarted.Broadcast"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GetOwningComponent()->GetOwnerRole",
            "GetWorld",
            "GetName",
            "UE_LOGFMT",
            "Comp->ActiveGameplayTags.AppendTags",
            "GetOwningComponent",
            "GetOwningComponent()->OnActionStarted.Broadcast"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "float USActionEffect::GetTimeRemaining() const",
        "start_line": "58",
        "end_line": "68",
        "file_path": "Source/ActionRoguelike/Private/SActionEffect.cpp",
        "docstring": "This function, GetTimeRemaining, calculates the remaining time for an action effect.\\nIt checks if the game state is available and uses the server's world time to determine the remaining time.\\nIf the game state is not available, it returns the full duration of the effect.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bdec7bf3e2d7",
        "ground_truth": "float USActionEffect::GetTimeRemaining() const\n{\n // Possibly nullptr early on if joining as a client in multiplayer (server spawns GameState and replicates the actor instance to clients)\n if (AGameStateBase* GS = GetWorld()->GetGameState<AGameStateBase>())\n {\n  float EndTime = TimeStarted + Duration;\n  return EndTime - GS->GetServerWorldTimeSeconds();\n }\n  return Duration;\n}",
        "import_statements": [
            "#include \"SActionEffect.h\"\n",
            "#include \"SActionComponent.h\"\n",
            "#include \"GameFramework/GameStateBase.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SActionEffect)\n"
        ],
        "reference_api": [
            "GetWorld()->GetGameState<AGameStateBase>",
            "GS->GetServerWorldTimeSeconds",
            "GetWorld"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GetWorld()->GetGameState<AGameStateBase>",
            "GS->GetServerWorldTimeSeconds",
            "GetWorld"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USInteractionComponent::ServerInteract_Implementation(AActor* InFocus)",
        "start_line": "123",
        "end_line": "133",
        "file_path": "Source/ActionRoguelike/Private/SInteractionComponent.cpp",
        "docstring": "This function, ServerInteract_Implementation, handles interaction with a specified actor on the server.\\nIf the actor is null, it displays a debug message. Otherwise, it retrieves the owning pawn and calls the Interact method on the focus actor using the pawn.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "db3a7508643b",
        "ground_truth": "void USInteractionComponent::ServerInteract_Implementation(AActor* InFocus)\n{\n if (InFocus == nullptr)\n {\n  GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Red, \"No Focus Actor to interact.\");\n  return;\n }\n  APawn* MyPawn = CastChecked<APawn>(GetOwner());\n ISGameplayInterface::Execute_Interact(InFocus, MyPawn);\n}",
        "import_statements": [
            "#include \"SInteractionComponent.h\"\n",
            "#include \"SGameplayInterface.h\"\n",
            "#include \"DrawDebugHelpers.h\"\n",
            "#include \"SWorldUserWidget.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SInteractionComponent)\n"
        ],
        "reference_api": [
            "CastChecked<APawn>",
            "GEngine->AddOnScreenDebugMessage",
            "GetOwner",
            "ISGameplayInterface::Execute_Interact"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "CastChecked<APawn>",
            "GEngine->AddOnScreenDebugMessage",
            "GetOwner",
            "ISGameplayInterface::Execute_Interact"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "bool USGameplayFunctionLibrary::ApplyDamage(AActor* DamageCauser, AActor* TargetActor, float DamageAmount)",
        "start_line": "11",
        "end_line": "19",
        "file_path": "Source/ActionRoguelike/Private/SGameplayFunctionLibrary.cpp",
        "docstring": "This function, ApplyDamage, applies damage to a target actor.\\nIt retrieves the target actor's attribute component and, if it exists, applies a negative health change equal to the damage amount caused by the damage causer.\\nThe function returns true if the damage was successfully applied, otherwise it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e6a5224079e6",
        "ground_truth": "bool USGameplayFunctionLibrary::ApplyDamage(AActor* DamageCauser, AActor* TargetActor, float DamageAmount)\n{\n USAttributeComponent* AttributeComp = USAttributeComponent::GetAttributes(TargetActor);\n if (AttributeComp)\n {\n  return AttributeComp->ApplyHealthChange(DamageCauser, -DamageAmount);\n }\n return false;\n}",
        "import_statements": [
            "#include \"SGameplayFunctionLibrary.h\"\n",
            "#include \"SAttributeComponent.h\"\n",
            "#include \"ShaderPipelineCache.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SGameplayFunctionLibrary)\n"
        ],
        "reference_api": [
            "USAttributeComponent::GetAttributes",
            "AttributeComp->ApplyHealthChange"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "USAttributeComponent::GetAttributes",
            "AttributeComp->ApplyHealthChange"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "bool ASPlayerState::UpdatePersonalRecord(float NewTime)",
        "start_line": "49",
        "end_line": "64",
        "file_path": "Source/ActionRoguelike/Private/SPlayerState.cpp",
        "docstring": "This function, UpdatePersonalRecord, updates the player's personal record time if the new time is higher.\\nIf the new time is greater than the current personal record, it updates the record, broadcasts the change, and returns true.\\nIf not, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "084a7501fc08",
        "ground_truth": "bool ASPlayerState::UpdatePersonalRecord(float NewTime)\n{\n // Higher time is better\n if (NewTime > PersonalRecordTime)\n {\n  float OldRecord = PersonalRecordTime;\n   PersonalRecordTime = NewTime;\n   OnRecordTimeChanged.Broadcast(this, PersonalRecordTime, OldRecord);\n   return true;\n }\n  return false;\n}",
        "import_statements": [
            "#include \"SPlayerState.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"SSaveGame.h\"\n",
            "#include \"Net/UnrealNetwork.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SPlayerState)\n"
        ],
        "reference_api": [
            "OnRecordTimeChanged.Broadcast"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "OnRecordTimeChanged.Broadcast"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void ASPowerup_HealthPotion::Interact_Implementation(APawn* InstigatorPawn)",
        "start_line": "20",
        "end_line": "40",
        "file_path": "Source/ActionRoguelike/Private/SPowerup_HealthPotion.cpp",
        "docstring": "This function, Interact_Implementation, handles the interaction with a health potion power-up.\\nIt checks if the instigator pawn is valid and retrieves its attribute component.\\nIf the attribute component exists and the pawn is not at full health, it then checks if the player state can remove the required credits.\\nIf successful, it applies a health change to the pawn and triggers the power-up cooldown.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8e0ccc856566",
        "ground_truth": "void ASPowerup_HealthPotion::Interact_Implementation(APawn* InstigatorPawn)\n{\n if (!ensure(InstigatorPawn))\n {\n  return;\n }\n  USAttributeComponent* AttributeComp = USAttributeComponent::GetAttributes(InstigatorPawn);\n // Check if not already at max health\n if (ensure(AttributeComp) && !AttributeComp->IsFullHealth())\n {\n  if (ASPlayerState* PS = InstigatorPawn->GetPlayerState<ASPlayerState>())\n  {\n   if (PS->RemoveCredits(CreditCost) && AttributeComp->ApplyHealthChange(this, AttributeComp->GetHealthMax()))\n   {\n    // Only activate if healed successfully\n    HideAndCooldownPowerup();\n   }\n  }\n }\n}",
        "import_statements": [
            "#include \"SPowerup_HealthPotion.h\"\n",
            "#include \"SAttributeComponent.h\"\n",
            "#include \"SPlayerState.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SPowerup_HealthPotion)\n"
        ],
        "reference_api": [
            "AttributeComp->IsFullHealth",
            "AttributeComp->ApplyHealthChange",
            "USAttributeComponent::GetAttributes",
            "AttributeComp->GetHealthMax",
            "PS->RemoveCredits",
            "InstigatorPawn->GetPlayerState<ASPlayerState>",
            "ensure",
            "HideAndCooldownPowerup"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "AttributeComp->IsFullHealth",
            "AttributeComp->ApplyHealthChange",
            "USAttributeComponent::GetAttributes",
            "AttributeComp->GetHealthMax",
            "PS->RemoveCredits",
            "InstigatorPawn->GetPlayerState<ASPlayerState>",
            "ensure",
            "HideAndCooldownPowerup"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void ASProjectileBase::Explode_Implementation()",
        "start_line": "115",
        "end_line": "128",
        "file_path": "Source/ActionRoguelike/Private/SProjectileBase.cpp",
        "docstring": "This function, Explode_Implementation, handles the explosion effects of a projectile.\\nIt spawns an impact visual effect at the projectile's location, plays an impact sound, and triggers a camera shake.\\nAfter these effects, it releases the projectile back to the actor pool using the actor pooling subsystem.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "39a680859a89",
        "ground_truth": "void ASProjectileBase::Explode_Implementation()\n{\n // Auto-managed particle pooling\n UGameplayStatics::SpawnEmitterAtLocation(this, ImpactVFX, GetActorLocation(), GetActorRotation(), true, EPSCPoolMethod::AutoRelease);\n  UGameplayStatics::PlaySoundAtLocation(this, ImpactSound, GetActorLocation());\n  UGameplayStatics::PlayWorldCameraShake(this, ImpactShake, GetActorLocation(), GetImpactShakeInnerRadius(), GetImpactShakeOuterRadius());\n  //Destroy();\n // Release back to pool instead of destroying\n USActorPoolingSubsystem* PoolingSubsystem = GetWorld()->GetSubsystem<USActorPoolingSubsystem>();\n PoolingSubsystem->ReleaseToPool(this);\n}",
        "import_statements": [
            "#include \"SProjectileBase.h\"\n",
            "#include \"Components/SphereComponent.h\"\n",
            "#include \"Components/SProjectileMovementComponent.h\"\n",
            "#include \"NiagaraComponent.h\"\n",
            "#include \"NiagaraComponentPoolMethodEnum.h\"\n",
            "#include \"Kismet/GameplayStatics.h\"\n",
            "#include \"Components/AudioComponent.h\"\n",
            "#include \"Sound/SoundCue.h\"\n",
            "#include \"ProfilingDebugging/CountersTrace.h\"\n",
            "#include \"Subsystems/SActorPoolingSubsystem.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SProjectileBase)\n"
        ],
        "reference_api": [
            "PoolingSubsystem->ReleaseToPool",
            "GetActorRotation",
            "UGameplayStatics::SpawnEmitterAtLocation",
            "GetWorld()->GetSubsystem<USActorPoolingSubsystem>",
            "GetWorld",
            "GetImpactShakeOuterRadius",
            "UGameplayStatics::PlaySoundAtLocation",
            "UGameplayStatics::PlayWorldCameraShake",
            "GetActorLocation",
            "GetImpactShakeInnerRadius"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "PoolingSubsystem->ReleaseToPool",
            "GetActorRotation",
            "UGameplayStatics::SpawnEmitterAtLocation",
            "GetWorld()->GetSubsystem<USActorPoolingSubsystem>",
            "GetWorld",
            "GetImpactShakeOuterRadius",
            "UGameplayStatics::PlaySoundAtLocation",
            "UGameplayStatics::PlayWorldCameraShake",
            "GetActorLocation",
            "GetImpactShakeInnerRadius"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "FPlayerSaveData* USSaveGame::GetPlayerData(APlayerState* PlayerState)",
        "start_line": "12",
        "end_line": "39",
        "file_path": "Source/ActionRoguelike/Private/SSaveGame.cpp",
        "docstring": "This function, GetPlayerData, retrieves the saved data for a player based on their PlayerState.\\nIf the PlayerState is null, it returns null.\\nIn Play-In-Editor (PIE) mode, it logs a message and returns the first saved player entry if available.\\nOtherwise, it uses the player's unique ID to find and return the corresponding saved player data.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a95c41c6d7b5",
        "ground_truth": "FPlayerSaveData* USSaveGame::GetPlayerData(APlayerState* PlayerState)\n{\n if (PlayerState == nullptr)\n {\n  return nullptr;\n }\n  // Will not give unique ID while PIE so we skip that step while testing in editor.\n // UObjects don't have access to UWorld, so we grab it via PlayerState instead\n if (PlayerState->GetWorld()->IsPlayInEditor())\n {\n  UE_LOGFMT(LogGame, Log, \"During PIE we cannot use PlayerID to retrieve Saved Player data. Using first entry in array if available.\");\n   if (SavedPlayers.IsValidIndex(0))\n  {\n   return &SavedPlayers[0];\n  }\n   // No saved player data available\n  return nullptr;\n }\n  // Easiest way to deal with the different IDs is as FString (original Steam id is uint64)\n // Keep in mind that GetUniqueId() returns the online id, where GetUniqueID() is a function from UObject (very confusing...)\n FString PlayerID = PlayerState->GetUniqueId().ToString();\n // Iterate the array and match by PlayerID (eg. unique ID provided by Steam)\n return SavedPlayers.FindByPredicate([&](const FPlayerSaveData& Data) { return Data.PlayerID == PlayerID; });\n}",
        "import_statements": [
            "#include \"SSaveGame.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"GameFramework/PlayerState.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SSaveGame)\n"
        ],
        "reference_api": [
            "PlayerState->GetWorld()->IsPlayInEditor",
            "PlayerState->GetUniqueId",
            "UE_LOGFMT",
            "SavedPlayers.IsValidIndex",
            "PlayerState->GetWorld",
            "PlayerState->GetUniqueId().ToString",
            "SavedPlayers.FindByPredicate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "PlayerState->GetWorld()->IsPlayInEditor",
            "PlayerState->GetUniqueId",
            "UE_LOGFMT",
            "SavedPlayers.IsValidIndex",
            "PlayerState->GetWorld",
            "PlayerState->GetUniqueId().ToString",
            "SavedPlayers.FindByPredicate"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USSaveGameSubsystem::HandleStartingNewPlayer(AController* NewPlayer)",
        "start_line": "34",
        "end_line": "41",
        "file_path": "Source/ActionRoguelike/Private/SSaveGameSubsystem.cpp",
        "docstring": "This function, HandleStartingNewPlayer, is called when a new player starts the game.\\nIt retrieves the player's state and ensures it is valid.\\nIf valid, it loads the player's state from the current save game.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "58a03c087c47",
        "ground_truth": "void USSaveGameSubsystem::HandleStartingNewPlayer(AController* NewPlayer)\n{\n ASPlayerState* PS = NewPlayer->GetPlayerState<ASPlayerState>();\n if (ensure(PS))\n {\n  PS->LoadPlayerState(CurrentSaveGame);\n }\n}",
        "import_statements": [
            "#include \"SSaveGameSubsystem.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"EngineUtils.h\"\n",
            "#include \"SGameplayInterface.h\"\n",
            "#include \"SPlayerState.h\"\n",
            "#include \"SSaveGame.h\"\n",
            "#include \"SSaveGameSettings.h\"\n",
            "#include \"GameFramework/GameStateBase.h\"\n",
            "#include \"Kismet/GameplayStatics.h\"\n",
            "#include \"Serialization/ObjectAndNameAsStringProxyArchive.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SSaveGameSubsystem)\n"
        ],
        "reference_api": [
            "ensure",
            "NewPlayer->GetPlayerState<ASPlayerState>",
            "PS->LoadPlayerState"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ensure",
            "NewPlayer->GetPlayerState<ASPlayerState>",
            "PS->LoadPlayerState"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "tomlooman/ActionRoguelike",
        "function_declaration": "void USSaveGameSubsystem::WriteSaveGame()",
        "start_line": "90",
        "end_line": "144",
        "file_path": "Source/ActionRoguelike/Private/SSaveGameSubsystem.cpp",
        "docstring": "This function, WriteSaveGame, saves the current game state by clearing existing saved player and actor data in CurrentSaveGame.\\nIt retrieves the game state and saves player data for each player in the game state.\\nThen, it iterates through all actors in the world, saving those that implement a specific interface.\\nActor data, including name, transform, and serialized data, is stored in the CurrentSaveGame.\\nFinally, the save game is written to a slot, and an event is broadcast to signal the save is complete.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c5bd4c059b71",
        "ground_truth": "void USSaveGameSubsystem::WriteSaveGame()\n{\n // Clear arrays, may contain data from previously loaded SaveGame\n CurrentSaveGame->SavedPlayers.Empty();\n CurrentSaveGame->SavedActors.Empty();\n  AGameStateBase* GS = GetWorld()->GetGameState();\n if (GS == nullptr)\n {\n  // Warn about failure to save?\n  return;\n }\n   // Iterate all player states, we don't have proper ID to match yet (requires Steam or EOS)\n for (int32 i = 0; i < GS->PlayerArray.Num(); i++)\n {\n  ASPlayerState* PS = CastChecked<ASPlayerState>(GS->PlayerArray[i]);\n  if (PS)\n  {\n   PS->SavePlayerState(CurrentSaveGame);\n   break; // single player only supported at this point\n  }\n }\n  // Iterate the entire world of actors\n for (FActorIterator It(GetWorld()); It; ++It)\n {\n  AActor* Actor = *It;\n  // Only interested in our 'gameplay actors', skip actors that are being destroyed\n  // Note: You might instead use a dedicated SavableObject interface for Actors you want to save instead of re-using GameplayInterface\n  if (!IsValid(Actor) || !Actor->Implements<USGameplayInterface>())\n  {\n   continue;\n  }\n   FActorSaveData ActorData;\n  ActorData.ActorName = Actor->GetFName();\n  ActorData.Transform = Actor->GetActorTransform();\n     // Pass the array to fill with data from Actor\n  FMemoryWriter MemWriter(ActorData.ByteData);\n   FObjectAndNameAsStringProxyArchive Ar(MemWriter, true);\n  // Find only variables with UPROPERTY(SaveGame)\n  Ar.ArIsSaveGame = true;\n  // Converts Actor's SaveGame UPROPERTIES into binary array\n  Actor->Serialize(Ar);\n   CurrentSaveGame->SavedActors.Add(ActorData);\n }\n  UGameplayStatics::SaveGameToSlot(CurrentSaveGame, CurrentSlotName, 0);\n  OnSaveGameWritten.Broadcast(CurrentSaveGame);\n}",
        "import_statements": [
            "#include \"SSaveGameSubsystem.h\"\n",
            "#include \"ActionRoguelike.h\"\n",
            "#include \"EngineUtils.h\"\n",
            "#include \"SGameplayInterface.h\"\n",
            "#include \"SPlayerState.h\"\n",
            "#include \"SSaveGame.h\"\n",
            "#include \"SSaveGameSettings.h\"\n",
            "#include \"GameFramework/GameStateBase.h\"\n",
            "#include \"Kismet/GameplayStatics.h\"\n",
            "#include \"Serialization/ObjectAndNameAsStringProxyArchive.h\"\n",
            "#include UE_INLINE_GENERATED_CPP_BY_NAME(SSaveGameSubsystem)\n"
        ],
        "reference_api": [
            "Actor->Implements<USGameplayInterface>",
            "UGameplayStatics::SaveGameToSlot",
            "CastChecked<ASPlayerState>",
            "CurrentSaveGame->SavedPlayers.Empty",
            "IsValid",
            "CurrentSaveGame->SavedActors.Empty",
            "Actor->GetFName",
            "GetWorld",
            "Actor->Serialize",
            "Actor->GetActorTransform",
            "CurrentSaveGame->SavedActors.Add",
            "OnSaveGameWritten.Broadcast",
            "PS->SavePlayerState",
            "GS->PlayerArray.Num",
            "GetWorld()->GetGameState"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Actor->Implements<USGameplayInterface>",
            "UGameplayStatics::SaveGameToSlot",
            "CastChecked<ASPlayerState>",
            "CurrentSaveGame->SavedPlayers.Empty",
            "IsValid",
            "CurrentSaveGame->SavedActors.Empty",
            "Actor->GetFName",
            "GetWorld",
            "Actor->Serialize",
            "Actor->GetActorTransform",
            "CurrentSaveGame->SavedActors.Add",
            "OnSaveGameWritten.Broadcast",
            "PS->SavePlayerState",
            "GS->PlayerArray.Num",
            "GetWorld()->GetGameState"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "praydog/UEVR",
        "function_declaration": "void FrameworkConfig::draw_themes()",
        "start_line": "31",
        "end_line": "37",
        "file_path": "src/mods/FrameworkConfig.cpp",
        "docstring": "This function, draw_themes, displays a GUI for selecting a theme and adjusting the font size.\\nIt draws the theme selection UI and checks if the font size has been changed.\\nIf the font size is modified, it updates the font size in the framework.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0d7043a0bff0",
        "ground_truth": "void FrameworkConfig::draw_themes() {\n    get_imgui_theme()->draw(\"Select GUI Theme\");\n     if (m_font_size->draw(\"Font Size\")) {\n        g_framework->set_font_size(m_font_size->value());\n    }\n}",
        "import_statements": [
            "#include \"Framework.hpp\"\n",
            "#include \"FrameworkConfig.hpp\"\n"
        ],
        "reference_api": [
            "m_font_size->value",
            "get_imgui_theme()->draw",
            "get_imgui_theme",
            "m_font_size->draw",
            "g_framework->set_font_size"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "m_font_size->value",
            "get_imgui_theme()->draw",
            "get_imgui_theme",
            "m_font_size->draw",
            "g_framework->set_font_size"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "praydog/UEVR",
        "function_declaration": "void FrameworkConfig::draw_main() ",
        "start_line": "14",
        "end_line": "29",
        "file_path": "src/mods/FrameworkConfig.cpp",
        "docstring": "This function, draw_main, displays the main configuration settings for the framework.\\nIt includes options for menu key, show cursor key, remembering menu state, enabling L3 + R3 toggle, always showing the cursor, and log level.\\nIf the log level is changed and is within a valid range, it updates the log level using spdlog.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e7f81d1dee95",
        "ground_truth": "void FrameworkConfig::draw_main() {\n    m_menu_key->draw(\"Menu Key\");\n    m_show_cursor_key->draw(\"Show Cursor Key\");\n    m_remember_menu_state->draw(\"Remember Menu Open/Closed State\");\n    m_enable_l3_r3_toggle->draw(\"Enable L3 + R3 Toggle\");\n    ImGui::SameLine();\n    m_l3_r3_long_press->draw(\"L3 + R3 Long Press Menu Toggle\");\n    m_always_show_cursor->draw(\"Always Show Cursor\");\n     ImGui::Separator();\n    if (m_log_level->draw(\"Log Level\")) {\n        if (m_log_level->value() >= 0 && m_log_level->value() <= spdlog::level::level_enum::n_levels) {\n            spdlog::set_level((spdlog::level::level_enum)m_log_level->value());   \n        }\n    }\n}",
        "import_statements": [
            "#include \"Framework.hpp\"\n",
            "#include \"FrameworkConfig.hpp\"\n"
        ],
        "reference_api": [
            "m_always_show_cursor->draw",
            "spdlog::set_level",
            "m_log_level->draw",
            "ImGui::Separator",
            "m_remember_menu_state->draw",
            "m_l3_r3_long_press->draw",
            "ImGui::SameLine",
            "m_menu_key->draw",
            "m_log_level->value",
            "m_show_cursor_key->draw",
            "m_enable_l3_r3_toggle->draw"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "m_always_show_cursor->draw",
            "spdlog::set_level",
            "m_log_level->draw",
            "ImGui::Separator",
            "m_remember_menu_state->draw",
            "m_l3_r3_long_press->draw",
            "ImGui::SameLine",
            "m_menu_key->draw",
            "m_log_level->value",
            "m_show_cursor_key->draw",
            "m_enable_l3_r3_toggle->draw"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "ue4plugins/StreetMap",
        "function_declaration": "bool FOSMFile::LoadOpenStreetMapFile( FString& OSMFilePath, const bool bIsFilePathActuallyTextBuffer, FFeedbackContext* FeedbackContext )",
        "start_line": "34",
        "end_line": "70",
        "file_path": "Source/StreetMapImporting/OSMFile.cpp",
        "docstring": "This function, LoadOpenStreetMapFile, loads an OpenStreetMap XML file and processes its data.\\nIt uses FFastXml to parse the file or text buffer and handles feedback through a context.\\nIf parsing is successful, it calculates the average latitude and longitude from the node data and returns true.\\nIf parsing fails, it logs an error message with the error details and returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "83fa7f401579",
        "ground_truth": "bool FOSMFile::LoadOpenStreetMapFile( FString& OSMFilePath, const bool bIsFilePathActuallyTextBuffer, FFeedbackContext* FeedbackContext )\n{\n const bool bShowSlowTaskDialog = true;\n const bool bShowCancelButton = true;\n  FText ErrorMessage;\n int32 ErrorLineNumber;\n if( FFastXml::ParseXmlFile( \n  this, \n  bIsFilePathActuallyTextBuffer ? nullptr : *OSMFilePath, \n  bIsFilePathActuallyTextBuffer ? OSMFilePath.GetCharArray().GetData() : nullptr, \n  FeedbackContext, \n  bShowSlowTaskDialog, \n  bShowCancelButton, \n  /* Out */ ErrorMessage, \n  /* Out */ ErrorLineNumber ) )\n {\n  if( NodeMap.Num() > 0 )\n  {\n   AverageLatitude /= NodeMap.Num();\n   AverageLongitude /= NodeMap.Num();\n  }\n   return true;\n }\n  if( FeedbackContext != nullptr )\n {\n  FeedbackContext->Logf(\n   ELogVerbosity::Error,\n   TEXT( \"Failed to load OpenStreetMap XML file ('%s', Line %i)\" ),\n   *ErrorMessage.ToString(),\n   ErrorLineNumber );\n }\n  return false;\n}",
        "import_statements": [
            "#include \"OSMFile.h\"\n",
            "#include \"Misc/FeedbackContext.h\"\n"
        ],
        "reference_api": [
            "FeedbackContext->Logf",
            "TEXT",
            "FFastXml::ParseXmlFile",
            "NodeMap.Num",
            "ErrorMessage.ToString",
            "OSMFilePath.GetCharArray",
            "OSMFilePath.GetCharArray().GetData"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "FeedbackContext->Logf",
            "TEXT",
            "FFastXml::ParseXmlFile",
            "NodeMap.Num",
            "ErrorMessage.ToString",
            "OSMFilePath.GetCharArray",
            "OSMFilePath.GetCharArray().GetData"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "ue4plugins/StreetMap",
        "function_declaration": "void UStreetMapActorFactory::PostSpawnActor(UObject* Asset, AActor* NewActor)",
        "start_line": "14",
        "end_line": "24",
        "file_path": "Source/StreetMapImporting/StreetMapActorFactory.cpp",
        "docstring": "This function, PostSpawnActor, is called after a new actor is spawned.\\nIt first calls the base class's PostSpawnActor method.\\nIf the asset is a UStreetMap, it casts the new actor to AStreetMapActor,\\nretrieves its UStreetMapComponent, and sets the street map asset for the component.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7349d775edf6",
        "ground_truth": "void UStreetMapActorFactory::PostSpawnActor(UObject* Asset, AActor* NewActor)\n{\n Super::PostSpawnActor(Asset, NewActor);\n  if (UStreetMap* StreetMapAsset = Cast<UStreetMap>(Asset))\n {\n  AStreetMapActor* StreetMapActor = CastChecked<AStreetMapActor>(NewActor);\n  UStreetMapComponent* StreetMapComponent = StreetMapActor->GetStreetMapComponent();\n  StreetMapComponent->SetStreetMap(StreetMapAsset, false, true);\n }\n}",
        "import_statements": [
            "#include \"StreetMapActorFactory.h\"\n",
            "#include \"AssetRegistry/AssetData.h\"\n",
            "#include \"StreetMapActor.h\"\n",
            "#include \"StreetMapComponent.h\"\n",
            "#include \"StreetMap.h\"\n"
        ],
        "reference_api": [
            "Super::PostSpawnActor",
            "CastChecked<AStreetMapActor>",
            "Cast<UStreetMap>",
            "StreetMapActor->GetStreetMapComponent",
            "StreetMapComponent->SetStreetMap"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Super::PostSpawnActor",
            "CastChecked<AStreetMapActor>",
            "Cast<UStreetMap>",
            "StreetMapActor->GetStreetMapComponent",
            "StreetMapComponent->SetStreetMap"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "ue4plugins/StreetMap",
        "function_declaration": "FReply FStreetMapComponentDetails::OnBuildMeshClicked()",
        "start_line": "335",
        "end_line": "348",
        "file_path": "Source/StreetMapImporting/StreetMapComponentDetails.cpp",
        "docstring": "This function, OnBuildMeshClicked, handles the event when the \"Build Mesh\" button is clicked.\\nIf a street map component is selected, it calls the BuildMesh method on the selected component and refreshes the details view.\\nThe function returns a handled reply.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f160ac6d0353",
        "ground_truth": "FReply FStreetMapComponentDetails::OnBuildMeshClicked()\n{\n  if(SelectedStreetMapComponent != nullptr)\n {\n  //\n  SelectedStreetMapComponent->BuildMesh();\n   // regenerates details panel layouts , to take in consideration new changes.\n  RefreshDetails();\n }\n  return FReply::Handled();\n}",
        "import_statements": [
            "#include \"StreetMapComponentDetails.h\"\n",
            "#include \"AssetToolsModule.h\"\n",
            "#include \"RawMesh.h\"\n",
            "#include \"PropertyEditorModule.h\"\n",
            "#include \"DetailLayoutBuilder.h\"\n",
            "#include \"DetailCategoryBuilder.h\"\n",
            "#include \"DetailWidgetRow.h\"\n",
            "#include \"IDetailsView.h\"\n",
            "#include \"IDetailCustomization.h\"\n",
            "#include \"AssetRegistry/AssetRegistryModule.h\"\n",
            "#include \"Dialogs/DlgPickAssetPath.h\"\n",
            "#include \"Widgets/Notifications/SNotificationList.h\"\n",
            "#include \"Framework/Notifications/NotificationManager.h\"\n",
            "#include \"Misc/AssertionMacros.h\"\n",
            "#include \"StreetMapComponent.h\"\n"
        ],
        "reference_api": [
            "SelectedStreetMapComponent->BuildMesh",
            "RefreshDetails",
            "FReply::Handled"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RefreshDetails",
                "code": "void FStreetMapComponentDetails::RefreshDetails()\n{\n\tif(LastDetailBuilderPtr != nullptr)\n\t{\n\t\tLastDetailBuilderPtr->ForceRefreshDetails();\n\t}\n}"
            }
        ],
        "third_party": [
            "SelectedStreetMapComponent->BuildMesh",
            "FReply::Handled"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "ue4plugins/StreetMap",
        "function_declaration": "void FStreetMapImportingModule::StartupModule()",
        "start_line": "24",
        "end_line": "38",
        "file_path": "Source/StreetMapImporting/StreetMapImporting.cpp",
        "docstring": "This function, StartupModule, initializes the StreetMap importing module.\\nIt registers the StreetMap asset type with the asset tools, initializes the StreetMap style, and registers a custom class layout for the StreetMapComponent in the property editor module.\\nIt then notifies the property editor module that the customization module has changed.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b23f1f2b29fa",
        "ground_truth": "void FStreetMapImportingModule::StartupModule()\n{\n // Register asset types\n IAssetTools& AssetTools = FModuleManager::LoadModuleChecked<FAssetToolsModule>( \"AssetTools\" ).Get();\n StreetMapAssetTypeActions = MakeShareable( new FStreetMapAssetTypeActions() );\n AssetTools.RegisterAssetTypeActions( StreetMapAssetTypeActions.ToSharedRef() );\n  // Initialize & Register StreetMap Style\n FStreetMapStyle::Initialize();\n  // Register StreetMapComponent Detail Customization\n FPropertyEditorModule& PropertyModule = FModuleManager::GetModuleChecked<FPropertyEditorModule>(\"PropertyEditor\");\n PropertyModule.RegisterCustomClassLayout(\"StreetMapComponent\", FOnGetDetailCustomizationInstance::CreateStatic(&FStreetMapComponentDetails::MakeInstance));\n PropertyModule.NotifyCustomizationModuleChanged();\n}",
        "import_statements": [
            "#include \"StreetMapImporting.h\"\n",
            "#include \"StreetMapAssetTypeActions.h\"\n",
            "#include \"Modules/ModuleManager.h\"\n",
            "#include \"StreetMapStyle.h\"\n",
            "#include \"StreetMapComponentDetails.h\"\n"
        ],
        "reference_api": [
            "MakeShareable",
            "FStreetMapStyle::Initialize",
            "FModuleManager::LoadModuleChecked<FAssetToolsModule>",
            "PropertyModule.NotifyCustomizationModuleChanged",
            "AssetTools.RegisterAssetTypeActions",
            "StreetMapAssetTypeActions.ToSharedRef",
            "FModuleManager::GetModuleChecked<FPropertyEditorModule>",
            "FOnGetDetailCustomizationInstance::CreateStatic",
            "PropertyModule.RegisterCustomClassLayout",
            "FModuleManager::LoadModuleChecked<FAssetToolsModule>( \"AssetTools\" ).Get"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "MakeShareable",
            "FStreetMapStyle::Initialize",
            "FModuleManager::LoadModuleChecked<FAssetToolsModule>",
            "PropertyModule.NotifyCustomizationModuleChanged",
            "AssetTools.RegisterAssetTypeActions",
            "StreetMapAssetTypeActions.ToSharedRef",
            "FModuleManager::GetModuleChecked<FPropertyEditorModule>",
            "FOnGetDetailCustomizationInstance::CreateStatic",
            "PropertyModule.RegisterCustomClassLayout",
            "FModuleManager::LoadModuleChecked<FAssetToolsModule>( \"AssetTools\" ).Get"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "ue4plugins/StreetMap",
        "function_declaration": "FPrimitiveSceneProxy* UStreetMapComponent::CreateSceneProxy()",
        "start_line": "46",
        "end_line": "57",
        "file_path": "Source/StreetMapRuntime/StreetMapComponent.cpp",
        "docstring": "This function, CreateSceneProxy, creates a scene proxy for the street map component.\\nIf the component has a valid mesh, it instantiates a new FStreetMapSceneProxy, initializes it with the component's vertices and indices, and returns the proxy.\\nIf the mesh is not valid, it returns nullptr.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1da549fe84e3",
        "ground_truth": "FPrimitiveSceneProxy* UStreetMapComponent::CreateSceneProxy()\n{\n FStreetMapSceneProxy* StreetMapSceneProxy = nullptr;\n  if( HasValidMesh() )\n {\n  StreetMapSceneProxy = new FStreetMapSceneProxy( this );\n  StreetMapSceneProxy->Init( this, Vertices, Indices );\n }\n   return StreetMapSceneProxy;\n}",
        "import_statements": [
            "#include \"StreetMapComponent.h\"\n",
            "#include \"StreetMapSceneProxy.h\"\n",
            "#include \"NavigationSystem.h\"\n",
            "#include \"Runtime/Engine/Classes/Engine/StaticMesh.h\"\n",
            "#include \"Runtime/Engine/Public/StaticMeshResources.h\"\n",
            "#include \"PolygonTools.h\"\n",
            "#include \"PhysicsEngine/BodySetup.h\"\n"
        ],
        "reference_api": [
            "StreetMapSceneProxy->Init",
            "HasValidMesh"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "StreetMapSceneProxy->Init",
            "HasValidMesh"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "void AARCharacter::OnAbility01Ready(FAFAbilitySpec Spec, FAFAbilitySpecHandle ServerHandle, FAFAbilitySpecHandle ClientHandle)",
        "start_line": "235",
        "end_line": "242",
        "file_path": "Source/ActionRPGGame/Private/ARCharacter.cpp",
        "docstring": "This function, OnAbility01Ready, is called when Ability01 is ready.\\nIt assigns the server handle to TestAbility01Handle.\\nIt then creates an array of input IDs, adds the ID for Ability01, and binds the ability to these input IDs using the server handle.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d0ee3b2e023e",
        "ground_truth": "void AARCharacter::OnAbility01Ready(FAFAbilitySpec Spec, FAFAbilitySpecHandle ServerHandle, FAFAbilitySpecHandle ClientHandle)\n{\n TestAbility01Handle = ServerHandle;\n  TArray<uint8> InputIds;\n InputIds.Add(static_cast<uint8>(AbilityInput::Ability01));\n Abilities->BindAbilityToInputIDs(ServerHandle, InputIds);\n}",
        "import_statements": [
            "#include \"ARCharacter.h\"\n",
            "#include \"Camera/CameraComponent.h\"\n",
            "#include \"Components/CapsuleComponent.h\"\n",
            "#include \"Components/InputComponent.h\"\n",
            "#include \"GameFramework/CharacterMovementComponent.h\"\n",
            "#include \"GameFramework/Controller.h\"\n",
            "#include \"GameFramework/SpringArmComponent.h\"\n",
            "#include \"Net/UnrealNetwork.h\"\n",
            "#include \"Engine/ActorChannel.h\"\n",
            "#include \"Weapons/ARWeaponBase.h\"\n",
            "#include \"UI/ARUIComponent.h\"\n",
            "#include \"Weapons/ARWeaponInventoryComponent.h\"\n",
            "#include \"ARCharacterMovementComponent.h\"\n",
            "#include \"ARPlayerController.h\"\n",
            "#include \"ARAbilityBase.h\"\n"
        ],
        "reference_api": [
            "InputIds.Add",
            "Abilities->BindAbilityToInputIDs",
            "static_cast<uint8>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "InputIds.Add",
            "Abilities->BindAbilityToInputIDs",
            "static_cast<uint8>"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "void AARCharacter::MoveForward(float Value)",
        "start_line": "305",
        "end_line": "317",
        "file_path": "Source/ActionRPGGame/Private/ARCharacter.cpp",
        "docstring": "This function, MoveForward, handles forward movement for a character.\\nIf the controller is valid and the input value is non-zero, it calculates the forward direction based on the controller's yaw rotation.\\nThen, it adds movement input in that direction with the given value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e62f1b2cd4bd",
        "ground_truth": "void AARCharacter::MoveForward(float Value)\n{\n if ((Controller != NULL) && (Value != 0.0f))\n {\n  // find out which way is forward\n  const FRotator Rotation = Controller->GetControlRotation();\n  const FRotator YawRotation(0, Rotation.Yaw, 0);\n   // get forward vector\n  const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n  AddMovementInput(Direction, Value);\n }\n}",
        "import_statements": [
            "#include \"ARCharacter.h\"\n",
            "#include \"Camera/CameraComponent.h\"\n",
            "#include \"Components/CapsuleComponent.h\"\n",
            "#include \"Components/InputComponent.h\"\n",
            "#include \"GameFramework/CharacterMovementComponent.h\"\n",
            "#include \"GameFramework/Controller.h\"\n",
            "#include \"GameFramework/SpringArmComponent.h\"\n",
            "#include \"Net/UnrealNetwork.h\"\n",
            "#include \"Engine/ActorChannel.h\"\n",
            "#include \"Weapons/ARWeaponBase.h\"\n",
            "#include \"UI/ARUIComponent.h\"\n",
            "#include \"Weapons/ARWeaponInventoryComponent.h\"\n",
            "#include \"ARCharacterMovementComponent.h\"\n",
            "#include \"ARPlayerController.h\"\n",
            "#include \"ARAbilityBase.h\"\n"
        ],
        "reference_api": [
            "FRotationMatrix",
            "Controller->GetControlRotation",
            "FRotationMatrix(YawRotation).GetUnitAxis",
            "AddMovementInput"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "FRotationMatrix",
            "Controller->GetControlRotation",
            "FRotationMatrix(YawRotation).GetUnitAxis",
            "AddMovementInput"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "FVector AARCharacter::GetMainWeaponSocket(const FName& Socket) const",
        "start_line": "406",
        "end_line": "413",
        "file_path": "Source/ActionRPGGame/Private/ARCharacter.cpp",
        "docstring": "This function, GetMainWeaponSocket, returns the location of a specified socket on the main weapon of the character.\\nIf the main weapon mesh component is not available, it defaults to returning the location of the \"headSocket\" on the character's mesh.\\nOtherwise, it returns the location of the specified socket on the main weapon mesh component.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a77cdc67ee00",
        "ground_truth": "FVector AARCharacter::GetMainWeaponSocket(const FName& Socket) const\n{\n USkeletalMeshComponent* Component = GetMainWeaponMesh();\n if (!Component)\n  return GetMesh()->GetSocketLocation(TEXT(\"headSocket\"));\n  return Component->GetSocketLocation(Socket);\n}",
        "import_statements": [
            "#include \"ARCharacter.h\"\n",
            "#include \"Camera/CameraComponent.h\"\n",
            "#include \"Components/CapsuleComponent.h\"\n",
            "#include \"Components/InputComponent.h\"\n",
            "#include \"GameFramework/CharacterMovementComponent.h\"\n",
            "#include \"GameFramework/Controller.h\"\n",
            "#include \"GameFramework/SpringArmComponent.h\"\n",
            "#include \"Net/UnrealNetwork.h\"\n",
            "#include \"Engine/ActorChannel.h\"\n",
            "#include \"Weapons/ARWeaponBase.h\"\n",
            "#include \"UI/ARUIComponent.h\"\n",
            "#include \"Weapons/ARWeaponInventoryComponent.h\"\n",
            "#include \"ARCharacterMovementComponent.h\"\n",
            "#include \"ARPlayerController.h\"\n",
            "#include \"ARAbilityBase.h\"\n"
        ],
        "reference_api": [
            "Component->GetSocketLocation",
            "TEXT",
            "GetMesh",
            "GetMainWeaponMesh",
            "GetMesh()->GetSocketLocation"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Component->GetSocketLocation",
            "TEXT",
            "GetMesh",
            "GetMainWeaponMesh",
            "GetMesh()->GetSocketLocation"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "void AAREnemySpawner::OnEnemyKilled(AARAICharacter* InEnemy)",
        "start_line": "43",
        "end_line": "53",
        "file_path": "Source/ActionRPGGame/Private/AREnemySpawner.cpp",
        "docstring": "This function, OnEnemyKilled, handles the event when an enemy is killed.\\nIt removes the killed enemy from the list of spawned enemies.\\nIf the number of spawned enemies falls below a minimum threshold, it sets up the spawner to respawn enemies.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f021203f736a",
        "ground_truth": "void AAREnemySpawner::OnEnemyKilled(AARAICharacter* InEnemy)\n{\n if (SpawnedEnemies.Num() > 0)\n {\n  SpawnedEnemies.Remove(InEnemy);\n }\n if (SpawnedEnemies.Num() < MinRespawn)\n {\n  SetupSpawner();\n }\n}",
        "import_statements": [
            "#include \"AREnemySpawner.h\"\n",
            "#include \"Engine/World.h\"\n",
            "#include \"AI/ARAICharacter.h\"\n"
        ],
        "reference_api": [
            "SetupSpawner",
            "SpawnedEnemies.Remove",
            "SpawnedEnemies.Num"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SetupSpawner",
                "code": "void AAREnemySpawner::SetupSpawner()\n{\n\tif (Role == ROLE_Authority)\n\t{\n\t\tFTimerDelegate Delegate = FTimerDelegate::CreateUObject(this, &AAREnemySpawner::HandleSpawn);\n\n\t\tFTimerManager& Timer = GetWorld()->GetTimerManager();\n\t\tTimer.SetTimer(SpawnerHandle, Delegate, TimeBetweenSpawns, true);\n\t}\n}"
            }
        ],
        "third_party": [
            "SpawnedEnemies.Remove",
            "SpawnedEnemies.Num"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "FString AARGameSession::ApproveLogin(const FString& Options)",
        "start_line": "10",
        "end_line": "29",
        "file_path": "Source/ActionRPGGame/Private/ARGameSession.cpp",
        "docstring": "This function, ApproveLogin, overrides the base class method to approve a login attempt.\\nIt first calls the parent class's ApproveLogin method and stores the result.\\nIt then parses the options string into an array of parameters, searches for the \"PlayerId\" parameter,\\nand extracts the player ID value. The function finally returns the result from the parent method.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dbab72cb539f",
        "ground_truth": "FString AARGameSession::ApproveLogin(const FString& Options)\n{\n FString Output = Super::ApproveLogin(Options);\n  TArray<FString> OutParams;\n Options.ParseIntoArray(OutParams, TEXT(\"?\"));\n   TArray<FString> OutPlayerId;\n FString Left;\n FString PlayerId;\n for (FString& str : OutParams)\n {\n  if (str.Split(\"PlayerId=\", &Left, &PlayerId))\n  {\n   break;\n  }\n }\n  return Output;\n}",
        "import_statements": [
            "#include \"ARGameSession.h\"\n",
            "#include \"ARGameInstance.h\"\n",
            "#include \"ARGameMode.h\"\n",
            "#include \"ARPlayerController.h\"\n"
        ],
        "reference_api": [
            "Super::ApproveLogin",
            "Options.ParseIntoArray",
            "TEXT",
            "str.Split"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Super::ApproveLogin",
            "Options.ParseIntoArray",
            "TEXT",
            "str.Split"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "void UARRegisterView::OnRegisterClicked()",
        "start_line": "16",
        "end_line": "43",
        "file_path": "Source/ActionRPGGame/Private/Menu/ARRegisterView.cpp",
        "docstring": "This function, OnRegisterClicked, handles the registration process when the register button is clicked.\\nIt retrieves the username, display name, and password from input fields.\\nIt checks if any of these fields are empty and displays a warning message if so.\\nIf all fields are valid, it hides the register button and calls the RegisterNewPlayer method from the game instance to register the new player.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "85ea02df92a5",
        "ground_truth": "void UARRegisterView::OnRegisterClicked()\n{\n FString UserName = UserNameBox->GetText().ToString();\n FString DisplayName = DisplayNameBox->GetText().ToString();\n FString Password = PasswordBox->GetText().ToString();\n  if (UserName.Len() <= 0)\n {\n  WarrningText->SetText(FText::FromString(\"Invalid Username\"));\n  return;\n }\n if (DisplayName.Len() <= 0)\n {\n  WarrningText->SetText(FText::FromString(\"Invalid DisplayName\"));\n  return;\n }\n if (Password.Len() <= 0)\n {\n  WarrningText->SetText(FText::FromString(\"Invalid Password\"));\n  return;\n }\n  if (UARGameInstance* GI = Cast<UARGameInstance>(GetOwningPlayer()->GetGameInstance()))\n {\n  RegisterButton->SetVisibility(ESlateVisibility::HitTestInvisible);\n  GI->RegisterNewPlayer(UserName, DisplayName, Password);\n }\n}",
        "import_statements": [
            "#include \"ARRegisterView.h\"\n",
            "#include \"ARGameInstance.h\"\n"
        ],
        "reference_api": [
            "RegisterButton->SetVisibility",
            "UserNameBox->GetText().ToString",
            "FText::FromString",
            "Cast<UARGameInstance>",
            "GetOwningPlayer()->GetGameInstance",
            "DisplayNameBox->GetText().ToString",
            "DisplayName.Len",
            "UserName.Len",
            "PasswordBox->GetText().ToString",
            "GetOwningPlayer",
            "PasswordBox->GetText",
            "DisplayNameBox->GetText",
            "Password.Len",
            "GI->RegisterNewPlayer",
            "UserNameBox->GetText",
            "WarrningText->SetText"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "RegisterButton->SetVisibility",
            "UserNameBox->GetText().ToString",
            "FText::FromString",
            "Cast<UARGameInstance>",
            "GetOwningPlayer()->GetGameInstance",
            "DisplayNameBox->GetText().ToString",
            "DisplayName.Len",
            "UserName.Len",
            "PasswordBox->GetText().ToString",
            "GetOwningPlayer",
            "PasswordBox->GetText",
            "DisplayNameBox->GetText",
            "Password.Len",
            "GI->RegisterNewPlayer",
            "UserNameBox->GetText",
            "WarrningText->SetText"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "void AARHUD::OnEnemyDamageCaused(const FAFAttributeChangedData& InMod)",
        "start_line": "166",
        "end_line": "182",
        "file_path": "Source/ActionRPGGame/Private/UI/ARHUD.cpp",
        "docstring": "This function, OnEnemyDamageCaused, updates the floating combat text when an enemy takes damage.\\nIt checks if the target actor exists and projects the damage location to screen coordinates.\\nIt then sets the floating combat text with the damage value and screen location.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b33bb5886dd9",
        "ground_truth": "void AARHUD::OnEnemyDamageCaused(const FAFAttributeChangedData& InMod)\n{\n AActor* Target = EnemyHitResult.GetActor();\n if (Target)\n {\n  FVector2D ScreeLoc;\n   UGameplayStatics::ProjectWorldToScreen(ARPC, EnemyHitResult.Location, ScreeLoc, false);\n  FloatingCombatText->SetInfo(InMod.Mod.Value, ScreeLoc);\n }\n else\n {\n  FVector2D ScreeLoc;\n  UGameplayStatics::ProjectWorldToScreen(ARPC, InMod.Location, ScreeLoc, false);\n  FloatingCombatText->SetInfo(InMod.Mod.Value, ScreeLoc);\n }\n}",
        "import_statements": [
            "#include \"ARHUD.h\"\n",
            "#include \"Engine/GameViewportClient.h\"\n",
            "#include \"Engine/LocalPlayer.h\"\n",
            "#include \"Camera/CameraComponent.h\"\n",
            "#include \"Kismet/GameplayStatics.h\"\n",
            "#include \"ARCharacter.h\"\n",
            "#include \"Attributes/ARCharacterAttributes.h\"\n",
            "#include \"UI/Inventory/ARUIInventoryComponent.h\"\n",
            "#include \"AFAbilityInterface.h\"\n",
            "#include \"AFAbilityComponent.h\"\n",
            "#include \"UI/HUD/ARHUDEnemyHealthBar.h\"\n",
            "#include \"UI/HUD/ARHUDFloatingCombatText.h\"\n",
            "#include \"ARPlayerController.h\"\n"
        ],
        "reference_api": [
            "UGameplayStatics::ProjectWorldToScreen",
            "FloatingCombatText->SetInfo",
            "EnemyHitResult.GetActor"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "UGameplayStatics::ProjectWorldToScreen",
            "FloatingCombatText->SetInfo",
            "EnemyHitResult.GetActor"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "void UARItemWeapon::AddMagazineUpgrade(class UARMagazineUpgradeItem* InMagazineUpgrade)",
        "start_line": "37",
        "end_line": "63",
        "file_path": "Source/ActionRPGGame/Private/Weapons/ARItemWeapon.cpp",
        "docstring": "This function, AddMagazineUpgrade, adds a magazine upgrade to a weapon item.\\nIt first checks if the ability instance is valid. Then, it retrieves the weapon component and character owning the weapon.\\nIf valid, it duplicates the magazine upgrade and, if the character has server authority, updates the magazine upgrade value and applies the upgrade effect to the ability instance.\\nFinally, it calls the OnMagazineUpdateAdded function.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "177d36e7e076",
        "ground_truth": "void UARItemWeapon::AddMagazineUpgrade(class UARMagazineUpgradeItem* InMagazineUpgrade)\n{\n if (!AbilityInstance)\n {\n  return; //add log.\n }\n  UARWeaponInventoryComponent* WeaponComponent = Cast<UARWeaponInventoryComponent>(GetOuter());\n //might also check for PC inventory.\n  if (!WeaponComponent)\n  return;\n  AARCharacter* Character = Cast<AARCharacter>(WeaponComponent->GetOwner());\n if (!Character)\n  return;\n  MagazineModification = DuplicateObject<UARMagazineUpgradeItem>(InMagazineUpgrade, this);\n  //this part only on server.\n if (Character->Role >= ENetRole::ROLE_Authority)\n {\n  MagazineUpgradeValue = InMagazineUpgrade->MagazineUpgradeValue;\n  AbilityInstance->AddMagazineUpgrade(InMagazineUpgrade->UpgradeEffect, MagazineUpgradeValue);\n }\n OnMagazineUpdateAdded();\n}",
        "import_statements": [
            "#include \"ARItemWeapon.h\"\n",
            "#include \"Effects/GABlueprintLibrary.h\"\n",
            "#include \"IFInventoryComponent.h\"\n",
            "#include \"ARCharacter.h\"\n",
            "#include \"ARPlayerController.h\"\n",
            "#include \"Attributes/ARGunAttributes.h\"\n",
            "#include \"UI/ARHUD.h\"\n",
            "#include \"UI/Inventory/ARUIInventoryComponent.h\"\n",
            "#include \"UI/Inventory/ARInventoryScreenWidget.h\"\n",
            "#include \"UI/Inventory/Weapons/Modifications/ARItemMagazineView.h\"\n",
            "#include \"Weapons/ARWeaponAbilityBase.h\"\n",
            "#include \"Weapons/ARMagazineUpgradeItem.h\"\n",
            "#include \"Weapons/ARWeaponInventoryComponent.h\"\n",
            "#include \"Weapons/ARMagazineUpgradeEffect.h\"\n"
        ],
        "reference_api": [
            "Cast<AARCharacter>",
            "WeaponComponent->GetOwner",
            "DuplicateObject<UARMagazineUpgradeItem>",
            "OnMagazineUpdateAdded",
            "Cast<UARWeaponInventoryComponent>",
            "AbilityInstance->AddMagazineUpgrade",
            "GetOuter"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "OnMagazineUpdateAdded",
                "code": "void UARItemWeapon::OnMagazineUpdateAdded()\n{\n}"
            }
        ],
        "third_party": [
            "Cast<AARCharacter>",
            "WeaponComponent->GetOwner",
            "DuplicateObject<UARMagazineUpgradeItem>",
            "Cast<UARWeaponInventoryComponent>",
            "AbilityInstance->AddMagazineUpgrade",
            "GetOuter"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "void UARWeaponInventoryComponent::OnWeaponReady(TSoftClassPtr<UARWeaponAbilityBase> InAbilityTag, int8 LocalIndex)",
        "start_line": "107",
        "end_line": "117",
        "file_path": "Source/ActionRPGGame/Private/Weapons/ARWeaponInventoryComponent.cpp",
        "docstring": "This function, OnWeaponReady, is called when a weapon is ready.\\nIt casts the owner to an AARCharacter and retrieves its ability component.\\nIt then gets the ability by its handle from the server weapon abilities using the provided local index,\\ncasts it to UGAAbilityBase, and sets this ability to the corresponding item using SetAbilityToItem.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "404276da398b",
        "ground_truth": "void UARWeaponInventoryComponent::OnWeaponReady(TSoftClassPtr<UARWeaponAbilityBase> InAbilityTag, int8 LocalIndex)\n{\n AARCharacter* Character = Cast<AARCharacter>(POwner);\n if (!Character)\n  return;\n  UAFAbilityComponent* AbilityComp = Character->GetAbilityComp();\n  UGAAbilityBase* Ability = Cast<UGAAbilityBase>(AbilityComp->BP_GetAbilityByHandle(ServerWeaponAbilities[LocalIndex]));\n SetAbilityToItem(LocalIndex, Ability);\n}",
        "import_statements": [
            "#include \"ARWeaponInventoryComponent.h\"\n",
            "#include \"Engine/AssetManager.h\"\n",
            "#include \"ARItemWeapon.h\"\n",
            "#include \"Weapons/ARWeaponAbilityBase.h\"\n",
            "#include \"ARCharacter.h\"\n",
            "#include \"ARPlayerController.h\"\n",
            "#include \"AFAbilityComponent.h\"\n"
        ],
        "reference_api": [
            "Character->GetAbilityComp",
            "Cast<AARCharacter>",
            "SetAbilityToItem",
            "AbilityComp->BP_GetAbilityByHandle",
            "Cast<UGAAbilityBase>"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SetAbilityToItem",
                "code": "void UARWeaponInventoryComponent::SetAbilityToItem(int8 InLocalIndex, class UGAAbilityBase* InAbility)\n{\n\tUARItemWeapon* ItemWeapon = GetItem<UARItemWeapon>(InLocalIndex);\n\n\tif (!ItemWeapon)\n\t\treturn;\n\n\tItemWeapon->SetAbility(Cast<UARWeaponAbilityBase>(InAbility));\n}"
            }
        ],
        "third_party": [
            "Character->GetAbilityComp",
            "Cast<AARCharacter>",
            "AbilityComp->BP_GetAbilityByHandle",
            "Cast<UGAAbilityBase>"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "iniside/ActionRPGGame",
        "function_declaration": "void UARWeaponInventoryComponent::OnItemRemoved(uint8 LocalIndex)",
        "start_line": "127",
        "end_line": "145",
        "file_path": "Source/ActionRPGGame/Private/Weapons/ARWeaponInventoryComponent.cpp",
        "docstring": "This function, OnItemRemoved, handles the removal of an item from the weapon inventory.\\nIt casts the owner to an AARCharacter and initializes an FARWeaponRPC struct to reset the weapon data.\\nIt sets the weapon data and updates the corresponding component based on the local index.\\nIf the removed item is the current weapon, it triggers the unequip action.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2e97aab98981",
        "ground_truth": "void UARWeaponInventoryComponent::OnItemRemoved(uint8 LocalIndex)\n{\n AARCharacter* Character = Cast<AARCharacter>(POwner);\n  //Character->GetAbilityComp()->NativeRemoveAbility(WeaponAbilities[LocalIndex]);\n  FARWeaponRPC Data;\n Data.Weapon.Reset();\n //Data.SocketName = InWeapon->Socket;\n Data.Position = FVector::ZeroVector;\n Data.Rotation = FRotator::ZeroRotator;\n Data.AttachSlot = static_cast<EARWeaponPosition>(LocalIndex);\n  SetWeapon(Data, GroupToComponent[LocalIndex]);\n if (LocalIndex == CurrentWeaponIndex)\n {\n  Unequip(LocalIndex);\n }\n}",
        "import_statements": [
            "#include \"ARWeaponInventoryComponent.h\"\n",
            "#include \"Engine/AssetManager.h\"\n",
            "#include \"ARItemWeapon.h\"\n",
            "#include \"Weapons/ARWeaponAbilityBase.h\"\n",
            "#include \"ARCharacter.h\"\n",
            "#include \"ARPlayerController.h\"\n",
            "#include \"AFAbilityComponent.h\"\n"
        ],
        "reference_api": [
            "Data.Weapon.Reset",
            "Cast<AARCharacter>",
            "SetWeapon",
            "Unequip",
            "static_cast<EARWeaponPosition>"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SetWeapon",
                "code": "void UARWeaponInventoryComponent::SetWeapon(const FARWeaponRPC& InWeapon, UChildActorComponent* Component)\n{\n\t//if (InWeapon.Weapon.IsValid() || InWeapon.Weapon.IsNull())\n\t{\n\t\tTSubclassOf<AARWeaponBase> WpnClass = TSoftClassPtr<AARWeaponBase>(InWeapon.Weapon).LoadSynchronous();\n\t\tComponent->SetChildActorClass(WpnClass);\n\t\tComponent->SetRelativeLocation(FVector(0, 0, 0));\n\t\tComponent->SetRelativeRotation(FRotator(0, 0, 0));\n\n\t\tComponent->SetRelativeLocation(InWeapon.Position);\n\t\tComponent->SetRelativeRotation(InWeapon.Rotation);\n\t}\n}"
            },
            {
                "name": "Unequip",
                "code": "void UARWeaponInventoryComponent::Unequip(int8 WeaponIndex)\n{\n\tUARItemWeapon* EquipedWeapon = GetItem<UARItemWeapon>(WeaponIndex);\n\tif (!EquipedWeapon)\n\t\treturn;\n\tif (AARCharacter* Character = Cast<AARCharacter>(POwner))\n\t{\n\t\tif (!Character->GetEquipedMainWeapon()->GetChildActor())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tCharacter->GetEquipedMainWeapon()->SetChildActorClass(nullptr);\n\t}\n\tFARWeaponRPC Data;\n\tData.Weapon = EquipedWeapon->Weapon.ToString();\n\t//Data.SocketName = InWeapon->Socket;\n\tData.Position = EquipedWeapon->HolsteredPosition;\n\tData.Rotation = EquipedWeapon->HolsteredRotation;\n\tData.AttachSlot = static_cast<EARWeaponPosition>(WeaponIndex);\n\tSetWeapon(Data, GroupToComponent[WeaponIndex]);\n\tServerHolster(Data);\n\tCurrentWeaponIndex = -1;\n}"
            }
        ],
        "third_party": [
            "Data.Weapon.Reset",
            "Cast<AARCharacter>",
            "static_cast<EARWeaponPosition>"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "truong-bui/AsyncLoadingScreen",
        "function_declaration": "void FAsyncLoadingScreenModule::ShutdownModule()",
        "start_line": "48",
        "end_line": "57",
        "file_path": "Source/AsyncLoadingScreen/Private/AsyncLoadingScreen.cpp",
        "docstring": "This function, ShutdownModule, shuts down the asynchronous loading screen module.\\nIf the application is not running as a dedicated server, it removes all loading screen preparation handlers associated with the module from the movie player.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "13cc35e5ecac",
        "ground_truth": "void FAsyncLoadingScreenModule::ShutdownModule()\n{\n // This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n // we call this function before unloading the module.\n if (!IsRunningDedicatedServer())\n {\n  // TODO: Unregister later\n  GetMoviePlayer()->OnPrepareLoadingScreen().RemoveAll(this);\n }\n}",
        "import_statements": [
            "#include \"AsyncLoadingScreen.h\"\n",
            "#include \"MoviePlayer.h\"\n",
            "#include \"LoadingScreenSettings.h\"\n",
            "#include \"SCenterLayout.h\"\n",
            "#include \"SClassicLayout.h\"\n",
            "#include \"SLetterboxLayout.h\"\n",
            "#include \"SSidebarLayout.h\"\n",
            "#include \"SDualSidebarLayout.h\"\n",
            "#include \"Framework/Application/SlateApplication.h\"\n",
            "#include \"AsyncLoadingScreenLibrary.h\"\n",
            "#include \"Engine/Texture2D.h\"\n"
        ],
        "reference_api": [
            "GetMoviePlayer()->OnPrepareLoadingScreen().RemoveAll",
            "GetMoviePlayer()->OnPrepareLoadingScreen",
            "GetMoviePlayer",
            "IsRunningDedicatedServer"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GetMoviePlayer()->OnPrepareLoadingScreen().RemoveAll",
            "GetMoviePlayer()->OnPrepareLoadingScreen",
            "GetMoviePlayer",
            "IsRunningDedicatedServer"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "truong-bui/AsyncLoadingScreen",
        "function_declaration": "void FAsyncLoadingScreenModule::PreSetupLoadingScreen()",
        "start_line": "69",
        "end_line": "79",
        "file_path": "Source/AsyncLoadingScreen/Private/AsyncLoadingScreen.cpp",
        "docstring": "This function, PreSetupLoadingScreen, prepares the loading screen configuration.\\nIt logs the start of the setup process and checks if the loading screen is enabled.\\nIf enabled, it retrieves the default loading screen settings, sets the startup flag to false, and sets up the loading screen using the default settings.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2ee3ac60a8f3",
        "ground_truth": "void FAsyncLoadingScreenModule::PreSetupLoadingScreen()\n{\t\n UE_LOG(LogTemp, Warning, TEXT(\"PreSetupLoadingScreen\"));\n const bool bIsEnableLoadingScreen = UAsyncLoadingScreenLibrary::GetIsEnableLoadingScreen();\n if (bIsEnableLoadingScreen)\n {\n  const ULoadingScreenSettings* Settings = GetDefault<ULoadingScreenSettings>();\n  bIsStartupLoadingScreen = false;\n  SetupLoadingScreen(Settings->DefaultLoadingScreen);\n }\t\n}",
        "import_statements": [
            "#include \"AsyncLoadingScreen.h\"\n",
            "#include \"MoviePlayer.h\"\n",
            "#include \"LoadingScreenSettings.h\"\n",
            "#include \"SCenterLayout.h\"\n",
            "#include \"SClassicLayout.h\"\n",
            "#include \"SLetterboxLayout.h\"\n",
            "#include \"SSidebarLayout.h\"\n",
            "#include \"SDualSidebarLayout.h\"\n",
            "#include \"Framework/Application/SlateApplication.h\"\n",
            "#include \"AsyncLoadingScreenLibrary.h\"\n",
            "#include \"Engine/Texture2D.h\"\n"
        ],
        "reference_api": [
            "TEXT",
            "UE_LOG",
            "GetDefault<ULoadingScreenSettings>",
            "UAsyncLoadingScreenLibrary::GetIsEnableLoadingScreen",
            "SetupLoadingScreen"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SetupLoadingScreen",
                "code": "void FAsyncLoadingScreenModule::SetupLoadingScreen(const FALoadingScreenSettings& LoadingScreenSettings)\n{\n\tTArray<FString> MoviesList = LoadingScreenSettings.MoviePaths;\n\n\t// Shuffle the movies list\n\tif (LoadingScreenSettings.bShuffle == true)\n\t{\n\t\tShuffleMovies(MoviesList);\n\t}\n\t\t\n\tif (LoadingScreenSettings.bSetDisplayMovieIndexManually == true)\n\t{\n\t\tMoviesList.Empty();\n\n\t\t// Show specific movie if valid otherwise show original movies list\n\t\tif (LoadingScreenSettings.MoviePaths.IsValidIndex(UAsyncLoadingScreenLibrary::GetDisplayMovieIndex()))\n\t\t{\n\t\t\tMoviesList.Add(LoadingScreenSettings.MoviePaths[UAsyncLoadingScreenLibrary::GetDisplayMovieIndex()]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMoviesList = LoadingScreenSettings.MoviePaths;\n\t\t}\n\t}\n\n\tFLoadingScreenAttributes LoadingScreen;\n\tLoadingScreen.MinimumLoadingScreenDisplayTime = LoadingScreenSettings.MinimumLoadingScreenDisplayTime;\n\tLoadingScreen.bAutoCompleteWhenLoadingCompletes = LoadingScreenSettings.bAutoCompleteWhenLoadingCompletes;\n\tLoadingScreen.bMoviesAreSkippable = LoadingScreenSettings.bMoviesAreSkippable;\n\tLoadingScreen.bWaitForManualStop = LoadingScreenSettings.bWaitForManualStop;\n\tLoadingScreen.bAllowInEarlyStartup = LoadingScreenSettings.bAllowInEarlyStartup;\n\tLoadingScreen.bAllowEngineTick = LoadingScreenSettings.bAllowEngineTick;\n\tLoadingScreen.MoviePaths = MoviesList;\n\tLoadingScreen.PlaybackType = LoadingScreenSettings.PlaybackType;\n\n\tif (LoadingScreenSettings.bShowWidgetOverlay)\n\t{\n\t\tconst ULoadingScreenSettings* Settings = GetDefault<ULoadingScreenSettings>();\n\n\t\tswitch (LoadingScreenSettings.Layout)\n\t\t{\n\t\tcase EAsyncLoadingScreenLayout::ALSL_Classic:\n\t\t\tLoadingScreen.WidgetLoadingScreen = SNew(SClassicLayout, LoadingScreenSettings, Settings->Classic);\n\t\t\tbreak;\n\t\tcase EAsyncLoadingScreenLayout::ALSL_Center:\n\t\t\tLoadingScreen.WidgetLoadingScreen = SNew(SCenterLayout, LoadingScreenSettings, Settings->Center);\n\t\t\tbreak;\n\t\tcase EAsyncLoadingScreenLayout::ALSL_Letterbox:\n\t\t\tLoadingScreen.WidgetLoadingScreen = SNew(SLetterboxLayout, LoadingScreenSettings, Settings->Letterbox);\n\t\t\tbreak;\n\t\tcase EAsyncLoadingScreenLayout::ALSL_Sidebar:\n\t\t\tLoadingScreen.WidgetLoadingScreen = SNew(SSidebarLayout, LoadingScreenSettings, Settings->Sidebar);\n\t\t\tbreak;\n\t\tcase EAsyncLoadingScreenLayout::ALSL_DualSidebar:\n\t\t\tLoadingScreen.WidgetLoadingScreen = SNew(SDualSidebarLayout, LoadingScreenSettings, Settings->DualSidebar);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\n\tGetMoviePlayer()->SetupLoadingScreen(LoadingScreen);\n}"
            }
        ],
        "third_party": [
            "TEXT",
            "UE_LOG",
            "GetDefault<ULoadingScreenSettings>",
            "UAsyncLoadingScreenLibrary::GetIsEnableLoadingScreen"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "truong-bui/AsyncLoadingScreen",
        "function_declaration": "void FAsyncLoadingScreenModule::LoadBackgroundImages()",
        "start_line": "160",
        "end_line": "186",
        "file_path": "Source/AsyncLoadingScreen/Private/AsyncLoadingScreen.cpp",
        "docstring": "This function, LoadBackgroundImages, loads background images for the loading screens.\\nIt first removes all existing background images and retrieves the loading screen settings.\\nIt then loads and adds images for both the startup and default loading screens to their respective lists.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c095588f550c",
        "ground_truth": "void FAsyncLoadingScreenModule::LoadBackgroundImages()\n{\n // Empty all background images array\n RemoveAllBackgroundImages();\n  const ULoadingScreenSettings* Settings = GetDefault<ULoadingScreenSettings>();\n   // Preload startup background images\n for (auto& Image : Settings->StartupLoadingScreen.Background.Images)\n {\n  UTexture2D* LoadedImage = Cast<UTexture2D>(Image.TryLoad());\n  if (LoadedImage)\n  {\n   StartupBackgroundImages.Add(LoadedImage);\n  }\n }\n  // Preload default background images\n for (auto& Image : Settings->DefaultLoadingScreen.Background.Images)\n {\n  UTexture2D* LoadedImage = Cast<UTexture2D> (Image.TryLoad());\n  if (LoadedImage)\n  {\n   DefaultBackgroundImages.Add(LoadedImage);\n  }\t\t\n }\n}",
        "import_statements": [
            "#include \"AsyncLoadingScreen.h\"\n",
            "#include \"MoviePlayer.h\"\n",
            "#include \"LoadingScreenSettings.h\"\n",
            "#include \"SCenterLayout.h\"\n",
            "#include \"SClassicLayout.h\"\n",
            "#include \"SLetterboxLayout.h\"\n",
            "#include \"SSidebarLayout.h\"\n",
            "#include \"SDualSidebarLayout.h\"\n",
            "#include \"Framework/Application/SlateApplication.h\"\n",
            "#include \"AsyncLoadingScreenLibrary.h\"\n",
            "#include \"Engine/Texture2D.h\"\n"
        ],
        "reference_api": [
            "StartupBackgroundImages.Add",
            "GetDefault<ULoadingScreenSettings>",
            "DefaultBackgroundImages.Add",
            "Cast<UTexture2D>",
            "RemoveAllBackgroundImages",
            "Image.TryLoad"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RemoveAllBackgroundImages",
                "code": "void FAsyncLoadingScreenModule::RemoveAllBackgroundImages()\n{\n\tStartupBackgroundImages.Empty();\n\tDefaultBackgroundImages.Empty();\n}"
            }
        ],
        "third_party": [
            "StartupBackgroundImages.Add",
            "GetDefault<ULoadingScreenSettings>",
            "DefaultBackgroundImages.Add",
            "Cast<UTexture2D>",
            "Image.TryLoad"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "truong-bui/AsyncLoadingScreen",
        "function_declaration": "EActiveTimerReturnType SLoadingCompleteText::AnimateText(double InCurrentTime, float InDeltaTime)",
        "start_line": "50",
        "end_line": "78",
        "file_path": "Source/AsyncLoadingScreen/Private/SLoadingCompleteText.cpp",
        "docstring": "This function, AnimateText, animates the alpha transparency of the loading complete text.\\nIt adjusts the text's alpha value between a minimum and maximum range based on the elapsed time and animation speed.\\nThe animation direction reverses when the alpha reaches either extreme, creating a pulsing effect.\\nThe function returns a status indicating the animation should continue.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4ffd56e2a326",
        "ground_truth": "EActiveTimerReturnType SLoadingCompleteText::AnimateText(double InCurrentTime, float InDeltaTime)\n{\n const float MinAlpha = 0.1f;\n const float MaxAlpha = 1.0f;\n  float TextAlpha = CompleteTextColor.A;\n  if (TextAlpha >= MaxAlpha)\n {\n  bCompleteTextReverseAnim = true;\n }\n else if (TextAlpha <= MinAlpha)\n {\n  bCompleteTextReverseAnim = false;\n }\n  if (!bCompleteTextReverseAnim)\n {\n  TextAlpha += InDeltaTime * CompleteTextAnimationSpeed;\n }\n else\n {\n  TextAlpha -= InDeltaTime * CompleteTextAnimationSpeed;\n }\n  CompleteTextColor.A = TextAlpha;\n  return EActiveTimerReturnType::Continue;\n}",
        "import_statements": [
            "#include \"SLoadingCompleteText.h\"\n",
            "#include \"LoadingScreenSettings.h\"\n",
            "#include \"MoviePlayer.h\"\n",
            "#include \"Widgets/Text/STextBlock.h\"\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "landelare/ue5coro",
        "function_declaration": "bool FRaceAwaiter::await_ready()",
        "start_line": "137",
        "end_line": "147",
        "file_path": "Plugins/UE5Coro/Source/UE5Coro/Private/AggregateAwaiters.cpp",
        "docstring": "This function, await_ready, checks if a race condition is ready.\\nIt locks the data, checks if the index is not -1, and unlocks the data if true.\\nIf the index is not -1, it returns true; otherwise, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7420af124c78",
        "ground_truth": "bool FRaceAwaiter::await_ready()\n{\n Data->Lock.lock();\n if (Data->Index != -1)\n {\n  Data->Lock.unlock();\n  return true;\n }\n else\n  return false; // Passing the lock to Suspend\n}",
        "import_statements": [
            "#include \"UE5Coro/AggregateAwaiters.h\"\n"
        ],
        "reference_api": [
            "Data->Lock.lock",
            "Data->Lock.unlock"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Data->Lock.lock",
            "Data->Lock.unlock"
        ]
    },
    {
        "subclass": "Unreal_Engine",
        "owner/repo": "landelare/ue5coro",
        "function_declaration": "bool ShouldResumeFindPath(void* State, bool bCleanup)",
        "start_line": "54",
        "end_line": "66",
        "file_path": "Plugins/UE5CoroAI/Source/UE5CoroAI/Private/AIAwaiters.cpp",
        "docstring": "This function, ShouldResumeFindPath, determines whether to resume a pathfinding operation or clean up resources.\\nIf cleanup is required and the query ID is valid, it aborts the async find path request and deletes the state.\\nIt returns true if the query ID is invalid, indicating the pathfinding should not resume.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fab9fe81573a",
        "ground_truth": "bool ShouldResumeFindPath(void* State, bool bCleanup)\n{\n auto* This = static_cast<FFindPathSharedPtr*>(State);\n if (UNLIKELY(bCleanup))\n {\n  if (auto* NS1 = (*This)->NS1.Get();\n      NS1 && (*This)->QueryID != INVALID_NAVQUERYID)\n   NS1->AbortAsyncFindPathRequest((*This)->QueryID);\n  delete This;\n }\n  return (*This)->QueryID == INVALID_NAVQUERYID;\n}",
        "import_statements": [
            "#include \"UE5CoroAI/AIAwaiters.h\"\n",
            "#include \"AIController.h\"\n",
            "#include \"NavigationSystem.h\"\n",
            "#include \"UE5CoroAICallbackTarget.h\"\n"
        ],
        "reference_api": [
            "(*This)->NS1.Get",
            "UNLIKELY",
            "NS1->AbortAsyncFindPathRequest",
            "static_cast<FFindPathSharedPtr*>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "(*This)->NS1.Get",
            "UNLIKELY",
            "NS1->AbortAsyncFindPathRequest",
            "static_cast<FFindPathSharedPtr*>"
        ]
    },
    {
        "subclass": "Godot_Engine",
        "owner/repo": "godotengine/godot",
        "function_declaration": "void AudioListener2D::_notification(int p_what)",
        "start_line": "63",
        "end_line": "82",
        "file_path": "scene/2d/audio_listener_2d.cpp",
        "docstring": "This function, _notification, handles notifications for the AudioListener2D component.\\nUpon entering the scene tree, it makes the listener current if it is not part of the edited scene and there is an existing current listener.\\nUpon exiting the scene tree, it clears the current listener status if it is not part of the edited scene, preserving the current status if it was previously current.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0656af2cb3eb",
        "ground_truth": "void AudioListener2D::_notification(int p_what) {\n switch (p_what) {\n  case NOTIFICATION_ENTER_TREE: {\n   if (!is_part_of_edited_scene() && current) {\n    make_current();\n   }\n  } break;\n   case NOTIFICATION_EXIT_TREE: {\n   if (!is_part_of_edited_scene()) {\n    if (is_current()) {\n     clear_current();\n     current = true; // Keep it true.\n    } else {\n     current = false;\n    }\n   }\n  } break;\n }\n}",
        "import_statements": [
            "#include \"audio_listener_2d.h\"\n"
        ],
        "reference_api": [
            "is_part_of_edited_scene",
            "is_current",
            "make_current",
            "clear_current"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "is_current",
                "code": "bool AudioListener2D::is_current() const {\n\tif (is_inside_tree() && !is_part_of_edited_scene()) {\n\t\treturn get_viewport()->get_audio_listener_2d() == this;\n\t} else {\n\t\treturn current;\n\t}\n}"
            },
            {
                "name": "make_current",
                "code": "void AudioListener2D::make_current() {\n\tcurrent = true;\n\tif (!is_inside_tree()) {\n\t\treturn;\n\t}\n\tget_viewport()->_audio_listener_2d_set(this);\n}"
            },
            {
                "name": "clear_current",
                "code": "void AudioListener2D::clear_current() {\n\tcurrent = false;\n\tif (!is_inside_tree()) {\n\t\treturn;\n\t}\n\tget_viewport()->_audio_listener_2d_remove(this);\n}"
            }
        ],
        "third_party": [
            "is_part_of_edited_scene"
        ]
    },
    {
        "subclass": "Godot_Engine",
        "owner/repo": "godotengine/godot",
        "function_declaration": "void AudioDriverDummy::mix_audio(int p_frames, int32_t *p_buffer)",
        "start_line": "114",
        "end_line": "134",
        "file_path": "servers/audio/audio_driver_dummy.cpp",
        "docstring": "This function, mix_audio, mixes audio frames into a provided buffer.\\nIt checks if the audio driver is active and not using threads. It then processes the audio frames in chunks, locking and unlocking around the processing.\\nThe mixed audio samples are copied into the output buffer, and the process continues until all frames are mixed.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9aadd2c91e67",
        "ground_truth": "void AudioDriverDummy::mix_audio(int p_frames, int32_t *p_buffer) {\n ERR_FAIL_COND(!active.is_set()); // If not active, should not mix.\n ERR_FAIL_COND(use_threads == true); // If using threads, this will not work well.\n  uint32_t todo = p_frames;\n while (todo) {\n  uint32_t to_mix = MIN(buffer_frames, todo);\n  lock();\n  audio_server_process(to_mix, samples_in);\n  unlock();\n   uint32_t total_samples = to_mix * channels;\n   for (uint32_t i = 0; i < total_samples; i++) {\n   p_buffer[i] = samples_in[i];\n  }\n   todo -= to_mix;\n  p_buffer += total_samples;\n }\n}",
        "import_statements": [
            "#include \"audio_driver_dummy.h\"\n",
            "#include \"core/config/project_settings.h\"\n",
            "#include \"core/os/os.h\"\n"
        ],
        "reference_api": [
            "audio_server_process",
            "ERR_FAIL_COND",
            "active.is_set",
            "unlock",
            "MIN",
            "lock"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "audio_server_process",
                "code": "void AudioDriver::audio_server_process(int p_frames, int32_t *p_buffer, bool p_update_mix_time) {\n\tif (p_update_mix_time) {\n\t\tupdate_mix_time(p_frames);\n\t}\n\n\tif (AudioServer::get_singleton()) {\n\t\tAudioServer::get_singleton()->_driver_process(p_frames, p_buffer);\n\t}\n}"
            },
            {
                "name": "unlock",
                "code": "void AudioDriverDummy::unlock() {\n\tmutex.unlock();\n}"
            },
            {
                "name": "MIN",
                "code": "constexpr auto MIN(const T m_a, const T2 m_b) {\n\treturn m_a < m_b ? m_a : m_b;\n}"
            },
            {
                "name": "lock",
                "code": "void AudioDriverDummy::lock() {\n\tmutex.lock();\n}"
            }
        ],
        "third_party": [
            "ERR_FAIL_COND",
            "active.is_set"
        ]
    },
    {
        "subclass": "Godot_Engine",
        "owner/repo": "godotengine/godot",
        "function_declaration": "void GodotArea2D::compute_gravity(const Vector2 &p_position, Vector2 &r_gravity) const",
        "start_line": "286",
        "end_line": "304",
        "file_path": "servers/physics_2d/godot_area_2d.cpp",
        "docstring": "This function, compute_gravity, calculates the gravity effect at a given position based on the area's gravity settings.\\nIf the gravity is point-based, it adjusts the gravity strength inversely proportional to the square of the distance from the point.\\nOtherwise, it applies a uniform gravity vector. The computed gravity is stored in the provided r_gravity variable.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "56df08c77b69",
        "ground_truth": "void GodotArea2D::compute_gravity(const Vector2 &p_position, Vector2 &r_gravity) const {\n if (is_gravity_point()) {\n  const real_t gr_unit_dist = get_gravity_point_unit_distance();\n  Vector2 v = get_transform().xform(get_gravity_vector()) - p_position;\n  if (gr_unit_dist > 0) {\n   const real_t v_length_sq = v.length_squared();\n   if (v_length_sq > 0) {\n    const real_t gravity_strength = get_gravity() * gr_unit_dist * gr_unit_dist / v_length_sq;\n    r_gravity = v.normalized() * gravity_strength;\n   } else {\n    r_gravity = Vector2();\n   }\n  } else {\n   r_gravity = v.normalized() * get_gravity();\n  }\n } else {\n  r_gravity = get_gravity_vector() * get_gravity();\n }\n}",
        "import_statements": [
            "#include \"godot_area_2d.h\"\n",
            "#include \"godot_body_2d.h\"\n",
            "#include \"godot_space_2d.h\"\n"
        ],
        "reference_api": [
            "v.normalized",
            "v.length_squared",
            "Vector2",
            "get_transform().xform",
            "get_gravity",
            "get_gravity_point_unit_distance",
            "is_gravity_point",
            "get_transform",
            "get_gravity_vector"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "v.normalized",
            "v.length_squared",
            "Vector2",
            "get_transform().xform",
            "get_gravity",
            "get_gravity_point_unit_distance",
            "is_gravity_point",
            "get_transform",
            "get_gravity_vector"
        ]
    },
    {
        "subclass": "Godot_Engine",
        "owner/repo": "godotengine/godot",
        "function_declaration": "void GodotBody2D::wakeup_neighbours()",
        "start_line": "656",
        "end_line": "676",
        "file_path": "servers/physics_2d/godot_body_2d.cpp",
        "docstring": "This function, wakeup_neighbours, activates neighboring bodies connected by constraints.\\nIt iterates through the list of constraints, checking each connected body.\\nIf a body is in rigid mode and not currently active, it sets the body to active.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f8c60f8d0caa",
        "ground_truth": "void GodotBody2D::wakeup_neighbours() {\n for (const Pair<GodotConstraint2D *, int> &E : constraint_list) {\n  const GodotConstraint2D *c = E.first;\n  GodotBody2D **n = c->get_body_ptr();\n  int bc = c->get_body_count();\n   for (int i = 0; i < bc; i++) {\n   if (i == E.second) {\n    continue;\n   }\n   GodotBody2D *b = n[i];\n   if (b->mode < PhysicsServer2D::BODY_MODE_RIGID) {\n    continue;\n   }\n    if (!b->is_active()) {\n    b->set_active(true);\n   }\n  }\n }\n}",
        "import_statements": [
            "#include \"godot_body_2d.h\"\n",
            "#include \"godot_area_2d.h\"\n",
            "#include \"godot_body_direct_state_2d.h\"\n",
            "#include \"godot_space_2d.h\"\n"
        ],
        "reference_api": [
            "b->is_active",
            "c->get_body_count",
            "b->set_active",
            "c->get_body_ptr"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "b->is_active",
            "c->get_body_count",
            "b->set_active",
            "c->get_body_ptr"
        ]
    },
    {
        "subclass": "Godot_Engine",
        "owner/repo": "godotengine/godot",
        "function_declaration": "void GodotArea3D::_queue_monitor_update() ",
        "start_line": "213",
        "end_line": "219",
        "file_path": "servers/physics_3d/godot_area_3d.cpp",
        "docstring": "This function, _queue_monitor_update, ensures that the area is added to the monitor query list for updates.\\nIt checks if the space is valid and, if the monitor query list is not already in the list, adds it to the space's monitor query list.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0c6f6c00da9a",
        "ground_truth": "void GodotArea3D::_queue_monitor_update() {\n ERR_FAIL_NULL(get_space());\n  if (!monitor_query_list.in_list()) {\n  get_space()->area_add_to_monitor_query_list(&monitor_query_list);\n }\n}",
        "import_statements": [
            "#include \"godot_area_3d.h\"\n",
            "#include \"godot_body_3d.h\"\n",
            "#include \"godot_soft_body_3d.h\"\n",
            "#include \"godot_space_3d.h\"\n"
        ],
        "reference_api": [
            "monitor_query_list.in_list",
            "get_space()->area_add_to_monitor_query_list",
            "get_space",
            "ERR_FAIL_NULL"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "monitor_query_list.in_list",
            "get_space()->area_add_to_monitor_query_list",
            "get_space",
            "ERR_FAIL_NULL"
        ]
    },
    {
        "subclass": "Godot_Engine",
        "owner/repo": "godotengine/godot",
        "function_declaration": "void GodotBody3D::_update_transform_dependent()",
        "start_line": "43",
        "end_line": "53",
        "file_path": "servers/physics_3d/godot_body_3d.cpp",
        "docstring": "This function, _update_transform_dependent, updates the transform-dependent properties of a 3D body.\\nIt recalculates the center of mass and principal inertia axes using the body's current transform.\\nIt then updates the inertia tensor by transforming the inverse inertia with the principal inertia axes.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "efc39df0e3a3",
        "ground_truth": "void GodotBody3D::_update_transform_dependent() {\n center_of_mass = get_transform().basis.xform(center_of_mass_local);\n principal_inertia_axes = get_transform().basis * principal_inertia_axes_local;\n  // Update inertia tensor.\n Basis tb = principal_inertia_axes;\n Basis tbt = tb.transposed();\n Basis diag;\n diag.scale(_inv_inertia);\n _inv_inertia_tensor = tb * diag * tbt;\n}",
        "import_statements": [
            "#include \"godot_body_3d.h\"\n",
            "#include \"godot_area_3d.h\"\n",
            "#include \"godot_body_direct_state_3d.h\"\n",
            "#include \"godot_space_3d.h\"\n"
        ],
        "reference_api": [
            "diag.scale",
            "tb.transposed",
            "get_transform().basis.xform",
            "get_transform"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "diag.scale",
            "tb.transposed",
            "get_transform().basis.xform",
            "get_transform"
        ]
    },
    {
        "subclass": "Godot_Engine",
        "owner/repo": "godotengine/godot",
        "function_declaration": "void AudioDriver::audio_server_process(int p_frames, int32_t *p_buffer, bool p_update_mix_time) ",
        "start_line": "64",
        "end_line": "72",
        "file_path": "servers/audio_server.cpp",
        "docstring": "This function, audio_server_process, handles audio processing for a given number of frames.\\nIf the update_mix_time flag is set, it updates the mix time based on the frame count.\\nIt then checks for an instance of AudioServer and processes the audio data using the provided frame count and buffer.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "aebafb4094a1",
        "ground_truth": "void AudioDriver::audio_server_process(int p_frames, int32_t *p_buffer, bool p_update_mix_time) {\n if (p_update_mix_time) {\n  update_mix_time(p_frames);\n }\n  if (AudioServer::get_singleton()) {\n  AudioServer::get_singleton()->_driver_process(p_frames, p_buffer);\n }\n}",
        "import_statements": [
            "#include \"audio_server.h\"\n",
            "#include \"core/config/project_settings.h\"\n",
            "#include \"core/debugger/engine_debugger.h\"\n",
            "#include \"core/error/error_macros.h\"\n",
            "#include \"core/io/file_access.h\"\n",
            "#include \"core/io/resource_loader.h\"\n",
            "#include \"core/math/audio_frame.h\"\n",
            "#include \"core/os/os.h\"\n",
            "#include \"core/string/string_name.h\"\n",
            "#include \"core/templates/pair.h\"\n",
            "#include \"scene/resources/audio_stream_wav.h\"\n",
            "#include \"scene/scene_string_names.h\"\n",
            "#include \"servers/audio/audio_driver_dummy.h\"\n",
            "#include \"servers/audio/effects/audio_effect_compressor.h\"\n",
            "#include <cstring>\n"
        ],
        "reference_api": [
            "AudioServer::get_singleton()->_driver_process",
            "update_mix_time",
            "AudioServer::get_singleton"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "update_mix_time",
                "code": "void AudioDriver::update_mix_time(int p_frames) {\n\t_last_mix_frames = p_frames;\n\tif (OS::get_singleton()) {\n\t\t_last_mix_time = OS::get_singleton()->get_ticks_usec();\n\t}\n}"
            }
        ],
        "third_party": [
            "AudioServer::get_singleton()->_driver_process",
            "AudioServer::get_singleton"
        ]
    },
    {
        "subclass": "Godot_Engine",
        "owner/repo": "godotengine/godot",
        "function_declaration": "void CameraServer::remove_feed(const Ref<CameraFeed> &p_feed)",
        "start_line": "114",
        "end_line": "129",
        "file_path": "servers/camera_server.cpp",
        "docstring": "This function, remove_feed, removes a camera feed from the CameraServer.\\nIt iterates through the list of feeds to find and remove the specified feed, logging the feed's details upon removal.\\nAfter removing the feed, it emits a signal indicating the feed has been removed, providing the feed's ID.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "160bb23e8010",
        "ground_truth": "void CameraServer::remove_feed(const Ref<CameraFeed> &p_feed) {\n for (int i = 0; i < feeds.size(); i++) {\n  if (feeds[i] == p_feed) {\n   int feed_id = p_feed->get_id();\n    print_verbose(\"CameraServer: Removed camera \" + p_feed->get_name() + \" with ID \" + itos(feed_id) + \" and position \" + itos(p_feed->get_position()));\n    // remove it from our array, if this results in our feed being unreferenced it will be destroyed\n   feeds.remove_at(i);\n    // let whomever is interested know\n   emit_signal(SNAME(\"camera_feed_removed\"), feed_id);\n   return;\n  };\n };\n};",
        "import_statements": [
            "#include \"camera_server.h\"\n",
            "#include \"core/variant/typed_array.h\"\n",
            "#include \"rendering_server.h\"\n",
            "#include \"servers/camera/camera_feed.h\"\n"
        ],
        "reference_api": [
            "print_verbose",
            "itos",
            "feeds.remove_at",
            "p_feed->get_id",
            "p_feed->get_position",
            "emit_signal",
            "feeds.size",
            "p_feed->get_name",
            "SNAME"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "print_verbose",
                "code": "void VariantUtilityFunctions::print_verbose(const Variant **p_args, int p_arg_count, Callable::CallError &r_error) {\n\tif (OS::get_singleton()->is_stdout_verbose()) {\n\t\tString s;\n\t\tfor (int i = 0; i < p_arg_count; i++) {\n\t\t\tString os = p_args[i]->operator String();\n\n\t\t\tif (i == 0) {\n\t\t\t\ts = os;\n\t\t\t} else {\n\t\t\t\ts += os;\n\t\t\t}\n\t\t}\n\n\t\t// No need to use `print_verbose()` as this call already only happens\n\t\t// when verbose mode is enabled. This avoids performing string argument concatenation\n\t\t// when not needed.\n\t\tprint_line(s);\n\t}\n\n\tr_error.error = Callable::CallError::CALL_OK;\n}"
            },
            {
                "name": "emit_signal",
                "code": "Error emit_signal(const StringName &p_name, VarArgs... p_args) {\n\t\tVariant args[sizeof...(p_args) + 1] = { p_args..., Variant() }; // +1 makes sure zero sized arrays are also supported.\n\t\tconst Variant *argptrs[sizeof...(p_args) + 1];\n\t\tfor (uint32_t i = 0; i < sizeof...(p_args); i++) {\n\t\t\targptrs[i] = &args[i];\n\t\t}\n\t\treturn emit_signalp(p_name, sizeof...(p_args) == 0 ? nullptr : (const Variant **)argptrs, sizeof...(p_args));\n\t}"
            }
        ],
        "third_party": [
            "itos",
            "feeds.remove_at",
            "p_feed->get_id",
            "p_feed->get_position",
            "feeds.size",
            "p_feed->get_name",
            "SNAME"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "EaseRateAction* EaseRateAction::create(ActionInterval* action, float rate)",
        "start_line": "107",
        "end_line": "120",
        "file_path": "cocos/2d/CCActionEase.cpp",
        "docstring": "This function, create, initializes and returns an EaseRateAction object.\\nIt asserts that the provided action is not null, then creates a new EaseRateAction instance.\\nIf initialization with the given action and rate is successful, it autoreleases the instance and returns it.\\nIf not, it safely deletes the instance and returns null.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bef3cf110c45",
        "ground_truth": "EaseRateAction* EaseRateAction::create(ActionInterval* action, float rate)\n{\n    CCASSERT(action != nullptr, \"action cannot be nullptr!\");\n     EaseRateAction *easeRateAction = new (std::nothrow) EaseRateAction();\n    if (easeRateAction && easeRateAction->initWithAction(action, rate))\n    {\n        easeRateAction->autorelease();\n        return easeRateAction;\n    }\n     CC_SAFE_DELETE(easeRateAction);\n    return nullptr;\n}",
        "import_statements": [
            "#include \"2d/CCActionEase.h\"\n",
            "#include \"2d/CCTweenFunction.h\"\n"
        ],
        "reference_api": [
            "CC_SAFE_DELETE",
            "easeRateAction->autorelease",
            "easeRateAction->initWithAction",
            "CCASSERT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "CC_SAFE_DELETE",
            "easeRateAction->autorelease",
            "easeRateAction->initWithAction",
            "CCASSERT"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "Node* findChildByNameRecursively(Node* node, const std::string &childName)",
        "start_line": "131",
        "end_line": "145",
        "file_path": "cocos/3d/CCAnimate3D.cpp",
        "docstring": "This function, findChildByNameRecursively, searches for a child node by name within a node hierarchy.\\nIt first checks if the current node's name matches the target name and returns the node if it does.\\nIf not, it recursively searches through the node's children, returning the matching child node if found.\\nIf no matching node is found, it returns nullptr.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "97fc6f86ad54",
        "ground_truth": "Node* findChildByNameRecursively(Node* node, const std::string &childName)\n{\n    const std::string& name = node->getName();\n    if (name == childName)\n        return node;\n         const Vector<Node*>& children = node->getChildren();\n    for (const auto& child : children)\n    {\n        Node* findNode = findChildByNameRecursively(child, childName);\n        if (findNode)\n            return findNode;\n    }\n    return nullptr;\n}",
        "import_statements": [
            "#include \"3d/CCAnimate3D.h\"\n",
            "#include \"3d/CCSprite3D.h\"\n",
            "#include \"3d/CCSkeleton3D.h\"\n",
            "#include \"platform/CCFileUtils.h\"\n",
            "#include \"base/CCConfiguration.h\"\n",
            "#include \"base/CCEventCustom.h\"\n",
            "#include \"base/CCDirector.h\"\n",
            "#include \"base/CCEventDispatcher.h\"\n"
        ],
        "reference_api": [
            "findChildByNameRecursively",
            "node->getChildren",
            "node->getName"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "findChildByNameRecursively",
            "node->getChildren",
            "node->getName"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "void Animate3D::removeFromMap()",
        "start_line": "515",
        "end_line": "532",
        "file_path": "cocos/3d/CCAnimate3D.cpp",
        "docstring": "This function, removeFromMap, removes the current animation action from various maps.\\nIf the target exists, it searches for and erases the action from fade-in, fade-out, and running animation maps if it matches the current instance.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5fcbe1fedcd2",
        "ground_truth": "void Animate3D::removeFromMap()\n{\n    //remove this action from map\n    if (_target)\n    {\n        auto it = s_fadeInAnimates.find(_target);\n        if (it != s_fadeInAnimates.end() && it->second == this)\n            s_fadeInAnimates.erase(it);\n                 it = s_fadeOutAnimates.find(_target);\n        if (it != s_fadeOutAnimates.end() && it->second == this)\n            s_fadeOutAnimates.erase(it);\n                 it = s_runningAnimates.find(_target);\n        if (it != s_runningAnimates.end() && it->second == this)\n            s_runningAnimates.erase(it);\n    }\n}",
        "import_statements": [
            "#include \"3d/CCAnimate3D.h\"\n",
            "#include \"3d/CCSprite3D.h\"\n",
            "#include \"3d/CCSkeleton3D.h\"\n",
            "#include \"platform/CCFileUtils.h\"\n",
            "#include \"base/CCConfiguration.h\"\n",
            "#include \"base/CCEventCustom.h\"\n",
            "#include \"base/CCDirector.h\"\n",
            "#include \"base/CCEventDispatcher.h\"\n"
        ],
        "reference_api": [
            "s_runningAnimates.find",
            "s_fadeOutAnimates.find",
            "s_fadeOutAnimates.erase",
            "s_fadeInAnimates.find",
            "s_runningAnimates.erase",
            "s_fadeInAnimates.erase",
            "s_runningAnimates.end",
            "s_fadeInAnimates.end",
            "s_fadeOutAnimates.end"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "s_runningAnimates.find",
            "s_fadeOutAnimates.find",
            "s_fadeOutAnimates.erase",
            "s_fadeInAnimates.find",
            "s_runningAnimates.erase",
            "s_fadeInAnimates.erase",
            "s_runningAnimates.end",
            "s_fadeInAnimates.end",
            "s_fadeOutAnimates.end"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "Animation3D* Animation3D::create(const std::string& fileName, const std::string& animationName)",
        "start_line": "32",
        "end_line": "51",
        "file_path": "cocos/3d/CCAnimation3D.cpp",
        "docstring": "This function, create, creates or retrieves an Animation3D object based on a file name and animation name.\\nIt generates a unique key and checks the cache for an existing animation.\\nIf not found, it initializes a new Animation3D object, attempts to initialize it with the given file and animation name, and returns the object.\\nIf initialization fails, it deletes the new Animation3D object.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "db8d394f7bc4",
        "ground_truth": "Animation3D* Animation3D::create(const std::string& fileName, const std::string& animationName)\n{\n    std::string fullPath = FileUtils::getInstance()->fullPathForFilename(fileName);\n    std::string key = fullPath + \"#\" + animationName;\n    auto animation = Animation3DCache::getInstance()->getAnimation(key);\n    if (animation != nullptr)\n        return animation;\n         animation = new (std::nothrow) Animation3D();\n    if(animation->initWithFile(fileName, animationName))\n    {\n        animation->autorelease();\n    }\n    else\n    {\n        CC_SAFE_DELETE(animation);\n    }\n         return animation;\n}",
        "import_statements": [
            "#include \"3d/CCAnimation3D.h\"\n",
            "#include \"3d/CCBundle3D.h\"\n",
            "#include \"platform/CCFileUtils.h\"\n"
        ],
        "reference_api": [
            "FileUtils::getInstance",
            "CC_SAFE_DELETE",
            "Animation3DCache::getInstance",
            "animation->initWithFile",
            "animation->autorelease",
            "Animation3DCache::getInstance()->getAnimation",
            "FileUtils::getInstance()->fullPathForFilename"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "FileUtils::getInstance",
            "CC_SAFE_DELETE",
            "Animation3DCache::getInstance",
            "animation->initWithFile",
            "animation->autorelease",
            "Animation3DCache::getInstance()->getAnimation",
            "FileUtils::getInstance()->fullPathForFilename"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "void Animation3DCache::removeUnusedAnimation()",
        "start_line": "231",
        "end_line": "242",
        "file_path": "cocos/3d/CCAnimation3D.cpp",
        "docstring": "This function, removeUnusedAnimation, iterates through the animation cache and removes animations that are no longer in use.\\nIf an animation's reference count is 1, it releases the animation and removes it from the cache.\\nThe iteration continues for all entries in the animation cache.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cdf28d98d3ff",
        "ground_truth": "void Animation3DCache::removeUnusedAnimation()\n{\n    for (auto itor = _animations.begin(); itor != _animations.end(); ) {\n        if (itor->second->getReferenceCount() == 1)\n        {\n            itor->second->release();\n            itor = _animations.erase(itor);\n        }\n        else\n            ++itor;\n    }\n}",
        "import_statements": [
            "#include \"3d/CCAnimation3D.h\"\n",
            "#include \"3d/CCBundle3D.h\"\n",
            "#include \"platform/CCFileUtils.h\"\n"
        ],
        "reference_api": [
            "itor->second->release",
            "_animations.erase",
            "itor->second->getReferenceCount",
            "_animations.end",
            "_animations.begin"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "itor->second->release",
            "_animations.erase",
            "itor->second->getReferenceCount",
            "_animations.end",
            "_animations.begin"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "BillBoard* BillBoard::createWithTexture(Texture2D *texture, Mode mode)",
        "start_line": "47",
        "end_line": "58",
        "file_path": "cocos/3d/CCBillBoard.cpp",
        "docstring": "This function, createWithTexture, creates a BillBoard object with a specified texture and mode.\\nIt initializes a new BillBoard instance and sets its mode if the initialization is successful.\\nIf successful, it autoreleases the BillBoard and returns it; otherwise, it deletes the instance and returns nullptr.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "de7926871eb8",
        "ground_truth": "BillBoard* BillBoard::createWithTexture(Texture2D *texture, Mode mode)\n{\n    BillBoard *billboard = new (std::nothrow) BillBoard();\n    if (billboard && billboard->initWithTexture(texture))\n    {\n        billboard->_mode = mode;\n        billboard->autorelease();\n        return billboard;\n    }\n    CC_SAFE_DELETE(billboard);\n    return nullptr;\n}",
        "import_statements": [
            "#include \"3d/CCBillBoard.h\"\n",
            "#include \"2d/CCSpriteFrameCache.h\"\n",
            "#include \"base/CCDirector.h\"\n",
            "#include \"2d/CCCamera.h\"\n",
            "#include \"renderer/CCRenderer.h\"\n"
        ],
        "reference_api": [
            "billboard->initWithTexture",
            "CC_SAFE_DELETE",
            "billboard->autorelease"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "billboard->initWithTexture",
            "CC_SAFE_DELETE",
            "billboard->autorelease"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "bool Bundle3D::load(const std::string& path)",
        "start_line": "173",
        "end_line": "203",
        "file_path": "cocos/3d/CCBundle3D.cpp",
        "docstring": "This function, load, loads a 3D bundle from a given file path.\\nIt first checks if the path is empty or already loaded. Then, it determines the file extension to decide the loading method.\\nIf the extension is .c3t, it loads the file as JSON; if .c3b, it loads as binary. It logs a warning for invalid formats.\\nOn success, it sets the internal path and returns true; otherwise, it clears the path and returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "eef1c2206d68",
        "ground_truth": "bool Bundle3D::load(const std::string& path)\n{\n    if (path.empty())\n        return false;\n         if (_path == path)\n        return true;\n     getModelRelativePath(path);\n     bool ret = false;\n    std::string ext = FileUtils::getInstance()->getFileExtension(path);\n    if (ext == \".c3t\")\n    {\n        _isBinary = false;\n        ret = loadJson(path);\n    }\n    else if (ext == \".c3b\")\n    {\n        _isBinary = true;\n        ret = loadBinary(path);\n    }\n    else \n    {\n        CCLOG(\"warning: %s is invalid file formate\", path.c_str());\n    }\n     ret?(_path = path):(_path = \"\");\n     return ret;\n}",
        "import_statements": [
            "#include \"3d/CCBundle3D.h\"\n",
            "#include \"3d/CCObjLoader.h\"\n",
            "#include \"base/ccMacros.h\"\n",
            "#include \"platform/CCFileUtils.h\"\n",
            "#include \"3d/CCBundleReader.h\"\n",
            "#include \"base/CCData.h\"\n"
        ],
        "reference_api": [
            "path.empty",
            "FileUtils::getInstance",
            "FileUtils::getInstance()->getFileExtension",
            "CCLOG",
            "getModelRelativePath",
            "loadBinary",
            "loadJson",
            "path.c_str"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getModelRelativePath",
                "code": "void Bundle3D::getModelRelativePath(const std::string& path)\n{\n    ssize_t index = path.find_last_of('/');\n    std::string fullModelPath;\n    _modelPath = path.substr(0, index + 1);\n}"
            },
            {
                "name": "loadBinary",
                "code": "bool Bundle3D::loadBinary(const std::string& path)\n{\n    clear();\n    \n    // get file data\n    _binaryBuffer.clear();\n    _binaryBuffer = FileUtils::getInstance()->getDataFromFile(path);\n    if (_binaryBuffer.isNull())\n    {\n        clear();\n        CCLOG(\"warning: Failed to read file: %s\", path.c_str());\n        return false;\n    }\n    \n    // Initialise bundle reader\n    _binaryReader.init( (char*)_binaryBuffer.getBytes(),  _binaryBuffer.getSize() );\n    \n    // Read identifier info\n    char identifier[] = { 'C', '3', 'B', '\\0'};\n    char sig[4];\n    if (_binaryReader.read(sig, 1, 4) != 4 || memcmp(sig, identifier, 4) != 0)\n    {\n        clear();\n        CCLOG(\"warning: Invalid identifier: %s\", path.c_str());\n        return false;\n    }\n    \n    // Read version\n    unsigned char ver[2];\n    if (_binaryReader.read(ver, 1, 2)!= 2){\n        CCLOG(\"warning: Failed to read version:\");\n        return false;\n    }\n    \n    char version[20] = {0};\n    sprintf(version, \"%d.%d\", ver[0], ver[1]);\n    _version = version;\n    \n    // Read ref table size\n    if (_binaryReader.read(&_referenceCount, 4, 1) != 1)\n    {\n        clear();\n        CCLOG(\"warning: Failed to read ref table size '%s'.\", path.c_str());\n        return false;\n    }\n    \n    // Read all refs\n    CC_SAFE_DELETE_ARRAY(_references);\n    _references = new (std::nothrow) Reference[_referenceCount];\n    for (unsigned int i = 0; i < _referenceCount; ++i)\n    {\n        if ((_references[i].id = _binaryReader.readString()).empty() ||\n            _binaryReader.read(&_references[i].type, 4, 1) != 1 ||\n            _binaryReader.read(&_references[i].offset, 4, 1) != 1)\n        {\n            clear();\n            CCLOG(\"warning: Failed to read ref number %u for bundle '%s'.\", i, path.c_str());\n            CC_SAFE_DELETE_ARRAY(_references);\n            return false;\n        }\n    }\n    \n    return true;\n}"
            },
            {
                "name": "loadJson",
                "code": "bool Bundle3D::loadJson(const std::string& path)\n{\n    clear();\n\n    _jsonBuffer = FileUtils::getInstance()->getStringFromFile(path);\n\n    if (_jsonReader.ParseInsitu<0>((char*)_jsonBuffer.c_str()).HasParseError())\n    {\n        clear();\n        CCLOG(\"Parse json failed in Bundle3D::loadJson function\");\n        return false;\n    }\n\n    const rapidjson::Value& mash_data_array = _jsonReader[VERSION];\n    if (mash_data_array.IsArray()) // Compatible with the old version\n        _version = \"1.2\";\n    else\n        _version = mash_data_array.GetString();\n    \n    return true;\n}"
            }
        ],
        "third_party": [
            "path.empty",
            "FileUtils::getInstance",
            "FileUtils::getInstance()->getFileExtension",
            "CCLOG",
            "path.c_str"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "bool Bundle3D::loadSkinData(const std::string& /*id*/, SkinData* skindata)",
        "start_line": "329",
        "end_line": "341",
        "file_path": "cocos/3d/CCBundle3D.cpp",
        "docstring": "This function, loadSkinData, loads skin data into a SkinData object.\\nIt first resets the skin data. Depending on whether the data is in binary format or not, it calls the appropriate method to load the skin data: loadSkinDataBinary for binary or loadSkinDataJson for JSON.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "37b6acea681e",
        "ground_truth": "bool Bundle3D::loadSkinData(const std::string& /*id*/, SkinData* skindata)\n{\n    skindata->resetData();\n     if (_isBinary)\n    {\n        return loadSkinDataBinary(skindata);\n    }\n    else\n    {\n        return loadSkinDataJson(skindata);\n    }\n}",
        "import_statements": [
            "#include \"3d/CCBundle3D.h\"\n",
            "#include \"3d/CCObjLoader.h\"\n",
            "#include \"base/ccMacros.h\"\n",
            "#include \"platform/CCFileUtils.h\"\n",
            "#include \"3d/CCBundleReader.h\"\n",
            "#include \"base/CCData.h\"\n"
        ],
        "reference_api": [
            "loadSkinDataBinary",
            "loadSkinDataJson",
            "skindata->resetData"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "loadSkinDataBinary",
                "code": "bool Bundle3D::loadSkinDataBinary(SkinData* skindata)\n{\n    if (!seekToFirstType(BUNDLE_TYPE_MESHSKIN))\n        return false;\n    \n    std::string boneName = _binaryReader.readString();\n    \n    // transform\n    float bindShape[16];\n    if (!_binaryReader.readMatrix(bindShape))\n    {\n        CCLOG(\"warning: Failed to read SkinData: bindShape matrix  '%s'.\", _path.c_str());\n        return false;\n    }\n    \n    // bone count\n    unsigned int boneNum;\n    if (!_binaryReader.read(&boneNum))\n    {\n        CCLOG(\"warning: Failed to read SkinData: boneNum  '%s'.\", _path.c_str());\n        return false;\n    }\n    \n    // Fix bug: check if the bone number is 0.\n    if (boneNum == 0)\n        return false;\n    \n    // bone names and bind pos\n    float bindpos[16];\n    for (unsigned int i = 0; i < boneNum; ++i)\n    {\n        std::string skinBoneName = _binaryReader.readString();\n        skindata->skinBoneNames.push_back(skinBoneName);\n        if (!_binaryReader.readMatrix(bindpos))\n        {\n            CCLOG(\"warning: Failed to load SkinData: bindpos '%s'.\", _path.c_str());\n            return false;\n        }\n        skindata->inverseBindPoseMatrices.push_back(bindpos);\n    }\n    \n    skindata->skinBoneOriginMatrices.resize(boneNum);\n    \n    boneName = _binaryReader.readString();\n    \n    // bind shape\n    _binaryReader.readMatrix(bindShape);\n    int rootIndex = skindata->getSkinBoneNameIndex(boneName);\n    if(rootIndex < 0)\n    {\n        skindata->addNodeBoneNames(boneName);\n        rootIndex = skindata->getBoneNameIndex(boneName);\n        skindata->nodeBoneOriginMatrices.push_back(bindShape);\n    }\n    else\n    {\n        skindata->skinBoneOriginMatrices[rootIndex] = bindShape;\n    }\n    \n    // set root bone index\n    skindata->rootBoneIndex = rootIndex;\n    \n    // read parent and child relationship map\n    float transform[16];\n    unsigned int linkNum;\n    _binaryReader.read(&linkNum);\n    for (unsigned int i = 0; i < linkNum; ++i)\n    {\n        std::string id = _binaryReader.readString();\n        int index = skindata->getSkinBoneNameIndex(id);\n        \n        \n        std::string parentid = _binaryReader.readString();\n        \n        if (!_binaryReader.readMatrix(transform))\n        {\n            CCLOG(\"warning: Failed to load SkinData: transform '%s'.\", _path.c_str());\n            return false;\n        }\n        \n        if(index < 0)\n        {\n            skindata->addNodeBoneNames(id);\n            index = skindata->getBoneNameIndex(id);\n            skindata->nodeBoneOriginMatrices.push_back(transform);\n        }\n        else\n        {\n            skindata->skinBoneOriginMatrices[index] = transform;\n        }\n        \n        int parentIndex = skindata->getSkinBoneNameIndex(parentid);\n        if(parentIndex < 0)\n        {\n            skindata->addNodeBoneNames(parentid);\n            parentIndex = skindata->getBoneNameIndex(parentid);\n        }\n        \n        skindata->boneChild[parentIndex].push_back(index);\n        \n    }\n    \n    return true;\n}"
            },
            {
                "name": "loadSkinDataJson",
                "code": "bool Bundle3D::loadSkinDataJson(SkinData* skindata)\n{\n    if (!_jsonReader.HasMember(SKIN )) return false;\n\n    const rapidjson::Value& skin_data_array = _jsonReader[SKIN ];\n\n    CCASSERT(skin_data_array.IsArray(), \"skin data is not an array\");\n    const rapidjson::Value& skin_data_array_val_0 = skin_data_array[(rapidjson::SizeType)0];\n\n    if (!skin_data_array_val_0.HasMember(BONES))\n        return false;\n\n    const rapidjson::Value& skin_data_bones = skin_data_array_val_0[BONES];\n    for (rapidjson::SizeType i = 0; i < skin_data_bones.Size(); ++i)\n    {\n        const rapidjson::Value& skin_data_bone = skin_data_bones[i];\n        std::string name = skin_data_bone[NODE].GetString();\n        skindata->addSkinBoneNames(name);\n\n        Mat4 mat_bind_pos;\n        const rapidjson::Value& bind_pos = skin_data_bone[BINDSHAPE];\n        for (rapidjson::SizeType j = 0; j < bind_pos.Size(); ++j)\n        {\n            mat_bind_pos.m[j] = bind_pos[j].GetFloat();\n        }\n        skindata->inverseBindPoseMatrices.push_back(mat_bind_pos);\n    }\n\n    // set root bone information\n    const rapidjson::Value& skin_data_1 = skin_data_array[1];\n\n    // parent and child relationship map\n    skindata->skinBoneOriginMatrices.resize(skindata->skinBoneNames.size());\n    getChildMap(skindata->boneChild, skindata, skin_data_1);\n    return true;\n}"
            }
        ],
        "third_party": [
            "skindata->resetData"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "size_t AudioDecoder::fileRead(void* ptr, size_t size, size_t nmemb, void* datasource)",
        "start_line": "39",
        "end_line": "50",
        "file_path": "cocos/audio/android/AudioDecoder.cpp",
        "docstring": "This function, fileRead, reads data from an audio file into a buffer.\\nIt calculates the number of bytes to read based on the remaining data size and the requested amount.\\nIf there are bytes to read, it copies the data into the provided buffer and updates the current file position.\\nIt returns the number of bytes read.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "97449825e4ef",
        "ground_truth": "size_t AudioDecoder::fileRead(void* ptr, size_t size, size_t nmemb, void* datasource)\n{\n    AudioDecoder* thiz = (AudioDecoder*)datasource;\n    ssize_t toReadBytes = std::min((ssize_t)(thiz->_fileData.getSize() - thiz->_fileCurrPos), (ssize_t)(nmemb * size));\n    if (toReadBytes > 0)\n    {\n        memcpy(ptr, (unsigned char*) thiz->_fileData.getBytes() + thiz->_fileCurrPos, toReadBytes);\n        thiz->_fileCurrPos += toReadBytes;\n    }\n    // ALOGD(\"File size: %d, After fileRead _fileCurrPos %d\", (int)thiz->_fileData.getSize(), thiz->_fileCurrPos);\n    return toReadBytes;\n}",
        "import_statements": [
            "#include \"audio/android/AudioDecoder.h\"\n",
            "#include \"audio/android/AudioResampler.h\"\n",
            "#include \"audio/android/PcmBufferProvider.h\"\n",
            "#include \"audio/android/AudioResampler.h\"\n",
            "#include <thread>\n",
            "#include <chrono>\n",
            "#include <stdlib.h>\n"
        ],
        "reference_api": [
            "thiz->_fileData.getBytes",
            "std::min",
            "thiz->_fileData.getSize",
            "memcpy"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "thiz->_fileData.getBytes",
            "thiz->_fileData.getSize"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "AudioDecoder::AudioDecoder()\n        : _fileCurrPos(0), _sampleRate(-1)",
        "start_line": "75",
        "end_line": "81",
        "file_path": "cocos/audio/android/AudioDecoder.cpp",
        "docstring": "This constructor, AudioDecoder, initializes an AudioDecoder object.\\nIt sets the current file position to 0 and the sample rate to -1.\\nIt creates a shared pointer to a vector for the PCM buffer, reserves 4096 bytes for it, and assigns it to the result's PCM buffer.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0f4db164ba5d",
        "ground_truth": "AudioDecoder::AudioDecoder()\n        : _fileCurrPos(0), _sampleRate(-1)\n{\n    auto pcmBuffer = std::make_shared<std::vector<char>>();\n    pcmBuffer->reserve(4096);\n    _result.pcmBuffer = pcmBuffer;\n}",
        "import_statements": [
            "#include \"audio/android/AudioDecoder.h\"\n",
            "#include \"audio/android/AudioResampler.h\"\n",
            "#include \"audio/android/PcmBufferProvider.h\"\n",
            "#include \"audio/android/AudioResampler.h\"\n",
            "#include <thread>\n",
            "#include <chrono>\n",
            "#include <stdlib.h>\n"
        ],
        "reference_api": [
            "std::make_shared<std::vector<char>>",
            "pcmBuffer->reserve"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "pcmBuffer->reserve"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "cocos2d/cocos2d-x",
        "function_declaration": "static cocos2d::network::DownloaderAndroid* _findDownloaderAndroid(int id)",
        "start_line": "62",
        "end_line": "71",
        "file_path": "cocos/network/CCDownloader-android.cpp",
        "docstring": "This function, _findDownloaderAndroid, retrieves a DownloaderAndroid object by its ID from a map.\\nIt locks a mutex for thread safety, searches the map for the given ID, and returns the corresponding DownloaderAndroid object if found.\\nIf the ID is not found, it returns nullptr.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0f88663615c6",
        "ground_truth": "static cocos2d::network::DownloaderAndroid* _findDownloaderAndroid(int id)\n{\n    std::lock_guard<std::mutex> guard(sDownloaderMutex);\n    auto iter = sDownloaderMap.find(id);\n    if (sDownloaderMap.end() == iter) {\n        return nullptr;\n    } else {\n        return iter->second;\n    }\n}",
        "import_statements": [
            "#include \"network/CCDownloader-android.h\"\n",
            "#include \"network/CCDownloader.h\"\n",
            "#include \"platform/android/jni/JniHelper.h\"\n",
            "#include <mutex>\n"
        ],
        "reference_api": [
            "sDownloaderMap.end",
            "sDownloaderMap.find"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "sDownloaderMap.end",
            "sDownloaderMap.find"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function M.playMusic(filename, isLoop)",
        "start_line": "36",
        "end_line": "42",
        "file_path": "runtime/win32/AudioEngine.lua",
        "docstring": "This function, playMusic, plays background music using the SimpleAudioEngine.\\nIt takes a filename and an optional loop parameter. If the loop parameter is provided, it sets the loop value accordingly.\\nIt then calls the playMusic method with the filename and loop value.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a5aafaaa944c",
        "ground_truth": "function M.playMusic(filename, isLoop)\n    local loopValue = false\n    if nil ~= isLoop then\n        loopValue = isLoop\n    end\n    cc.SimpleAudioEngine:getInstance():playMusic(filename, loopValue)\nend",
        "import_statements": [],
        "reference_api": [
            "cc.SimpleAudioEngine:getInstance:playMusic",
            "cc.SimpleAudioEngine:getInstance"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cc.SimpleAudioEngine:getInstance:playMusic",
            "cc.SimpleAudioEngine:getInstance"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function ccs.TriggerObj:detect()",
        "start_line": "106",
        "end_line": "120",
        "file_path": "runtime/win32/CocoStudio.lua",
        "docstring": "This function, detect, checks the conditions of a TriggerObj.\\nIt returns true if the trigger is not enabled or if there are no conditions.\\nOtherwise, it iterates through the conditions, invoking their detect method, and returns the combined result of all detections.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "16f2ad4bb4e8",
        "ground_truth": "function ccs.TriggerObj:detect()\n    if (not self._enable) or (table.getn(self._cons) == 0) then\n        return true\n    end \n     local ret = true\n    local obj = nil\n    for i = 1 , table.getn(self._cons) do\n        obj = self._cons[i]\n        if nil ~= obj and nil ~= obj.detect then\n            ret = ret and obj:detect()\n        end\n    end\n    return ret\nend",
        "import_statements": [
            "require \"json\"",
            "require \"extern\""
        ],
        "reference_api": [
            "obj:detect",
            "table.getn"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "obj:detect",
            "table.getn"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function ccs.TriggerObj:removeAll()",
        "start_line": "136",
        "end_line": "153",
        "file_path": "runtime/win32/CocoStudio.lua",
        "docstring": "This function, removeAll, clears all conditions and actions of a TriggerObj.\\nIt iterates through the conditions and actions, calling their removeAll method if they exist.\\nFinally, it resets the conditions and actions lists to empty.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e73b10418cb6",
        "ground_truth": "function ccs.TriggerObj:removeAll()\n    local obj = nil\n    for i=1, table.getn(self._cons) do\n        obj = self._cons[i]\n        if nil ~= obj then\n            obj:removeAll()\n        end\n    end\n    self._cons = {}\n     for i=1, table.getn(self._acts) do\n        obj = self._acts[i]\n        if nil ~= obj then\n            obj:removeAll()\n        end\n    end\n    self._acts = {}\nend",
        "import_statements": [
            "require \"json\"",
            "require \"extern\""
        ],
        "reference_api": [
            "table.getn",
            "obj:removeAll"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "table.getn",
            "obj:removeAll"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function BasicCollider:hurtEffect(target)",
        "start_line": "82",
        "end_line": "91",
        "file_path": "src/AttackCommand.lua",
        "docstring": "This function, hurtEffect, applies a hurt visual effect to a target.\\nIt creates an animation from a cached \"hurtAnimation\" and a billboard for the effect.\\nThe effect is scaled, positioned, and set to run the animation followed by self-removal.\\nFinally, the effect is added as a child to the target with a specific camera mask.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d5a1333d794d",
        "ground_truth": "function BasicCollider:hurtEffect(target)\n         local hurtAction = cc.Animate:create(animationCache:getAnimation(\"hurtAnimation\"))\n    local hurtEffect = cc.BillBoard:create()\n    hurtEffect:setScale(1.5)\n    hurtEffect:runAction(cc.Sequence:create(hurtAction, cc.RemoveSelf:create()))\n    hurtEffect:setPosition3D(cc.V3(0,0,50))\n    hurtEffect:setCameraMask(UserCameraFlagMask)\n    target:addChild(hurtEffect)\nend",
        "import_statements": [
            "require \"Helper\"",
            "require \"Manager\"",
            "require \"GlobalVariables\""
        ],
        "reference_api": [
            "cc.BillBoard:create",
            "animationCache:getAnimation",
            "hurtEffect:setCameraMask",
            "cc.V3",
            "cc.Sequence:create",
            "hurtEffect:runAction",
            "hurtEffect:setPosition3D",
            "target:addChild",
            "cc.Animate:create",
            "cc.RemoveSelf:create",
            "hurtEffect:setScale"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cc.BillBoard:create",
            "animationCache:getAnimation",
            "hurtEffect:setCameraMask",
            "cc.V3",
            "cc.Sequence:create",
            "hurtEffect:runAction",
            "hurtEffect:setPosition3D",
            "target:addChild",
            "cc.Animate:create",
            "cc.RemoveSelf:create",
            "hurtEffect:setScale"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function MageNormalAttack:onTimeOut()",
        "start_line": "176",
        "end_line": "195",
        "file_path": "src/AttackCommand.lua",
        "docstring": "This function, onTimeOut, handles the timeout event for MageNormalAttack.\\nIt stops two particle systems and initiates a sequence to remove the object after a delay.\\nIt then creates and configures a new particle system, adds it as a child, and sets its properties.\\nFinally, it updates the sprite texture, runs a fade-out action, and adjusts the sprite scale.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f478d7e70ea6",
        "ground_truth": "function MageNormalAttack:onTimeOut()\n    self.part1:stopSystem()\n    self.part2:stopSystem()\n    self:runAction(cc.Sequence:create(cc.DelayTime:create(1),cc.RemoveSelf:create()))\n         local magic = cc.ParticleSystemQuad:create(ParticleManager:getInstance():getPlistData(\"magic\"))\n    local magicf = cc.SpriteFrameCache:getInstance():getSpriteFrame(\"particle.png\")\n    magic:setTextureWithRect(magicf:getTexture(), magicf:getRect())\n    magic:setScale(1.5)\n    magic:setRotation3D({x=90, y=0, z=0})\n    self:addChild(magic)\n    magic:setGlobalZOrder(0)\n    magic:setPositionZ(0)\n    self:setCameraMask(UserCameraFlagMask)\n         self.sp:setTextureRect(RECTS.iceSpike)\n    self.sp:runAction(cc.FadeOut:create(1))\n    self.sp:setScale(4)\n end",
        "import_statements": [
            "require \"Helper\"",
            "require \"Manager\"",
            "require \"GlobalVariables\""
        ],
        "reference_api": [
            "self:runAction",
            "cc.Sequence:create",
            "ParticleManager:getInstance",
            "self.part1:stopSystem",
            "magic:setScale",
            "self.sp:runAction",
            "cc.SpriteFrameCache:getInstance:getSpriteFrame",
            "cc.ParticleSystemQuad:create",
            "ParticleManager:getInstance:getPlistData",
            "cc.SpriteFrameCache:getInstance",
            "magic:setGlobalZOrder",
            "cc.FadeOut:create",
            "cc.DelayTime:create",
            "self.sp:setScale",
            "cc.RemoveSelf:create",
            "magic:setTextureWithRect",
            "magic:setRotation3D",
            "self.part2:stopSystem",
            "self:addChild",
            "magic:setPositionZ",
            "magicf:getRect",
            "self:setCameraMask",
            "magicf:getTexture",
            "self.sp:setTextureRect"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self:runAction",
            "cc.Sequence:create",
            "ParticleManager:getInstance",
            "self.part1:stopSystem",
            "magic:setScale",
            "self.sp:runAction",
            "cc.SpriteFrameCache:getInstance:getSpriteFrame",
            "cc.ParticleSystemQuad:create",
            "ParticleManager:getInstance:getPlistData",
            "cc.SpriteFrameCache:getInstance",
            "magic:setGlobalZOrder",
            "cc.FadeOut:create",
            "cc.DelayTime:create",
            "self.sp:setScale",
            "cc.RemoveSelf:create",
            "magic:setTextureWithRect",
            "magic:setRotation3D",
            "self.part2:stopSystem",
            "self:addChild",
            "magic:setPositionZ",
            "magicf:getRect",
            "self:setCameraMask",
            "magicf:getTexture",
            "self.sp:setTextureRect"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function BattlefieldUI:heroDead(hero)",
        "start_line": "298",
        "end_line": "316",
        "file_path": "src/BattleFieldUI.lua",
        "docstring": "This function, heroDead, updates the UI to reflect a hero's death.\\nDepending on the hero's name (Knight, Mage, or Archer), it applies a grey shader to the hero's image and frame.\\nIt also hides the hero's anger full signal and anger clone UI elements.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d735c4ea6358",
        "ground_truth": "function BattlefieldUI:heroDead(hero)\n     if hero._name ==\"Knight\" then\n        cc.GreyShader:setGreyShader(self.KnightPng)\n        cc.GreyShader:setGreyShader(self.KnightPngFrame)    \n        self.KnightAngryFullSignal:setVisible(false)   \n        self.KnightAngryClone:setVisible(false)\n    elseif hero._name ==\"Mage\" then\n        cc.GreyShader:setGreyShader(self.MagePng)\n        cc.GreyShader:setGreyShader(self.MagePngFrame)\n        self.MageAngryFullSignal:setVisible(false)\n        self.MageAngryClone:setVisible(false)\n    elseif hero._name==\"Archer\" then\n        cc.GreyShader:setGreyShader(self.ArcherPng)\n        cc.GreyShader:setGreyShader(self.ArcherPngFrame)\n        self.ArcherAngryFullSignal:setVisible(false)\n        self.ArcherAngryClone:setVisible(false)                \n    end\nend",
        "import_statements": [
            "require \"GlobalVariables\"",
            "require \"Actor\"",
            "require(\"ChooseRoleScene\")"
        ],
        "reference_api": [
            "self.ArcherAngryClone:setVisible",
            "self.ArcherAngryFullSignal:setVisible",
            "self.MageAngryClone:setVisible",
            "self.MageAngryFullSignal:setVisible",
            "self.KnightAngryClone:setVisible",
            "cc.GreyShader:setGreyShader",
            "self.KnightAngryFullSignal:setVisible"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self.ArcherAngryClone:setVisible",
            "self.ArcherAngryFullSignal:setVisible",
            "self.MageAngryClone:setVisible",
            "self.MageAngryFullSignal:setVisible",
            "self.KnightAngryClone:setVisible",
            "cc.GreyShader:setGreyShader",
            "self.KnightAngryFullSignal:setVisible"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "local function moveCamera(dt)",
        "start_line": "16",
        "end_line": "34",
        "file_path": "src/BattleScene.lua",
        "docstring": "This function, moveCamera, adjusts the camera position based on the elapsed time (dt).\\nIf a special camera is active, it interpolates the camera position towards a special target and sets the camera to look at a specified point.\\nIf there are active heroes, it interpolates the camera position towards the focus point of the heroes and sets the camera to look at that point.\\nThe camera position and orientation are updated accordingly.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "009f167d3ab2",
        "ground_truth": "local function moveCamera(dt)\n    --cclog(\"moveCamera\")\n    if camera == nil then return end\n     local cameraPosition = getPosTable(camera)\n    local focusPoint = getFocusPointOfHeros()\n    if specialCamera.valid == true then\n        local position = cc.pLerp(cameraPosition, cc.p(specialCamera.position.x, (cameraOffset.y + focusPoint.y-size.height*3/4)*0.5), 5*dt)\n                 camera:setPosition(position)\n        camera:lookAt(cc.V3(position.x, specialCamera.position.y, 50.0), cc.V3(0.0, 1.0, 0.0))\n    elseif List.getSize(HeroManager) > 0 then\n        local temp = cc.pLerp(cameraPosition, cc.p(focusPoint.x+cameraOffset.x, cameraOffset.y + focusPoint.y-size.height*3/4), 2*dt)\n        local position = cc.V3(temp.x, temp.y, size.height/2-100)\n        camera:setPosition3D(position)\n        camera:lookAt(cc.V3(position.x, focusPoint.y, 50.0), cc.V3(0.0, 0.0, 1.0))\n        --cclog(\"\\ncalf %f %f %f \\ncalf %f %f 50.000000\", position.x, position.y, position.z, focusPoint.x, focusPoint.y)            \n    end\nend",
        "import_statements": [
            "require \"Helper\"",
            "require \"Manager\"",
            "require \"MessageDispatchCenter\"",
            "require \"GlobalVariables\"",
            "require(\"BattleFieldUI\")",
            "require(\"GameMaster\")"
        ],
        "reference_api": [
            "cc.pLerp",
            "getFocusPointOfHeros",
            "camera:setPosition",
            "List.getSize",
            "camera:setPosition3D",
            "getPosTable",
            "cc.V3",
            "cc.p",
            "camera:lookAt"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getFocusPointOfHeros",
                "code": "getFocusPointOfHeros"
            },
            {
                "name": "getPosTable",
                "code": "getPosTable"
            }
        ],
        "third_party": [
            "cc.pLerp",
            "camera:setPosition",
            "List.getSize",
            "camera:setPosition3D",
            "cc.V3",
            "cc.p",
            "camera:lookAt"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "local function updateParticlePos()",
        "start_line": "36",
        "end_line": "44",
        "file_path": "src/BattleScene.lua",
        "docstring": "This function, updateParticlePos, updates the positions of particle effect nodes for all heroes managed by HeroManager.\\nIt iterates through the heroes, and if a hero has an effect node, it sets the node's position based on the hero's current position.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f7f5e7fe1dc2",
        "ground_truth": "local function updateParticlePos()\n    --cclog(\"updateParticlePos\")\n    for val = HeroManager.first, HeroManager.last do\n        local sprite = HeroManager[val]\n        if sprite._effectNode ~= nil then        \n            sprite._effectNode:setPosition(getPosTable(sprite))\n        end\n    end\nend",
        "import_statements": [
            "require \"Helper\"",
            "require \"Manager\"",
            "require \"MessageDispatchCenter\"",
            "require \"GlobalVariables\"",
            "require(\"BattleFieldUI\")",
            "require(\"GameMaster\")"
        ],
        "reference_api": [
            "sprite._effectNode:setPosition",
            "getPosTable"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getPosTable",
                "code": "getPosTable"
            }
        ],
        "third_party": [
            "sprite._effectNode:setPosition"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function ChooseRoleScene:playAudioWhenRotate()",
        "start_line": "510",
        "end_line": "521",
        "file_path": "src/ChooseRoleScene.lua",
        "docstring": "This function, playAudioWhenRotate, plays an audio clip based on the currently selected hero in the ChooseRoleScene.\\nIt retrieves the hero by tag, gets the hero's race type, and then plays a specific audio clip depending on whether the hero is a Knight, Archer, or Mage.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "77829ef7341e",
        "ground_truth": "function ChooseRoleScene:playAudioWhenRotate()\n      local hero = self.layer:getChildByTag(sortorder[2])\n    local type = hero:getRaceType()\n    if hero._name == \"Knight\" then\n        ccexp.AudioEngine:play2d(WarriorProperty.kickit, false,1)\n    elseif hero._name == \"Archer\" then\n        ccexp.AudioEngine:play2d(Archerproperty.iwillfight, false,1)\n    elseif hero._name == \"Mage\" then\n        ccexp.AudioEngine:play2d(MageProperty.letstrade, false,1)\n    end\nend",
        "import_statements": [
            "require \"Actor\"",
            "require \"Knight\"",
            "require \"Archer\"",
            "require \"Mage\"",
            "require(\"BattleScene\")"
        ],
        "reference_api": [
            "ccexp.AudioEngine:play2d",
            "hero:getRaceType",
            "self.layer:getChildByTag"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ccexp.AudioEngine:play2d",
            "hero:getRaceType",
            "self.layer:getChildByTag"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function GameMaster:AddHeros()",
        "start_line": "155",
        "end_line": "174",
        "file_path": "src/GameMaster.lua",
        "docstring": "This function, AddHeros, creates and adds three hero characters (Knight, Mage, Archer) to the game.\\nIt positions each hero at a specific location, adds them to the current layer, sets them to idle mode,\\nand pushes them to the HeroManager list.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2b35fdb15a13",
        "ground_truth": "function GameMaster:AddHeros()\n  local knight = Knight:create()\n    knight:setPosition(battleSiteX[1], 10)\n    currentLayer:addChild(knight)\n    knight:idleMode()\n    List.pushlast(HeroManager, knight)\n  local mage = Mage:create()\n    mage:setPosition(battleSiteX[1], 100)\n    currentLayer:addChild(mage)\n    mage:idleMode()\n    List.pushlast(HeroManager, mage)\n         local archer = Archer:create()\n    archer:setPosition(battleSiteX[1], -80)\n    currentLayer:addChild(archer)\n    archer:idleMode()\n    List.pushlast(HeroManager, archer)\nend",
        "import_statements": [
            "require \"Manager\"",
            "require \"Knight\"",
            "require \"Mage\"",
            "require \"Actor\"",
            "require \"GlobalVariables\"",
            "require \"Piglet\"",
            "require \"Slime\"",
            "require \"Rat\"",
            "require \"Dragon\"",
            "require \"Archer\""
        ],
        "reference_api": [
            "knight:idleMode",
            "mage:setPosition",
            "List.pushlast",
            "knight:setPosition",
            "Archer:create",
            "mage:idleMode",
            "Knight:create",
            "Mage:create",
            "archer:setPosition",
            "currentLayer:addChild",
            "archer:idleMode"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "knight:idleMode",
            "mage:setPosition",
            "List.pushlast",
            "knight:setPosition",
            "Archer:create",
            "mage:idleMode",
            "Knight:create",
            "Mage:create",
            "archer:setPosition",
            "currentLayer:addChild",
            "archer:idleMode"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function GameMaster:showBoss()",
        "start_line": "327",
        "end_line": "342",
        "file_path": "src/GameMaster.lua",
        "docstring": "This function, showBoss, creates and displays a boss character in the game.\\nIt initializes a Rat object, sets its camera mask, and adds it to the current layer.\\nThe boss's position and facing direction are set, and AI is disabled initially.\\nThe boss then performs a bounce-out move and enables AI afterward.\\nFinally, the boss is added to the MonsterManager list.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cdfbc82ff3cd",
        "ground_truth": "function GameMaster:showBoss()\n    local boss = Rat:create()\n    boss:setCameraMask(UserCameraFlagMask)\n    currentLayer:addChild(boss)\n    boss:reset()\n    local appearPos = cc.V3(500,200,300)\n    boss:setPosition3D(appearPos)\n    boss._myPos = {x = appearPos.x,y = appearPos.y}\n    boss:setFacing(180)\n    boss._goRight = false\n    local function enableAI()\n        boss:setAIEnabled(true)\n    end\n    boss:runAction(cc.Sequence:create(cc.EaseBounceOut:create(cc.MoveBy:create(0.5,cc.V3(0,0,-300))),cc.CallFunc:create(enableAI)))\n    List.pushlast(MonsterManager, boss)\nend",
        "import_statements": [
            "require \"Manager\"",
            "require \"Knight\"",
            "require \"Mage\"",
            "require \"Actor\"",
            "require \"GlobalVariables\"",
            "require \"Piglet\"",
            "require \"Slime\"",
            "require \"Rat\"",
            "require \"Dragon\"",
            "require \"Archer\""
        ],
        "reference_api": [
            "boss:setAIEnabled"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "boss:setAIEnabled"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function createAnimation(file, begin, finish, speed)",
        "start_line": "59",
        "end_line": "66",
        "file_path": "src/Helper.lua",
        "docstring": "This function, createAnimation, creates a 3D animation from a file.\\nIt initializes an Animation3D object with the specified file, and an Animate3D object with the animation segment defined by the begin and finish frames.\\nIt sets the animation speed, retains the animate3d object, and returns it.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fa7b402853bb",
        "ground_truth": "function createAnimation(file, begin, finish, speed)\n--TODO: we don't need to create the same Animation3D all the time\n    local animation3d = cc.Animation3D:create(file)\n    local animate3d = cc.Animate3D:create(animation3d, begin/30,(finish-begin)/30)\n    animate3d:setSpeed(speed)\n    animate3d:retain()\n    return animate3d\nend",
        "import_statements": [],
        "reference_api": [
            "cc.Animation3D:create",
            "animate3d:setSpeed",
            "animate3d:retain",
            "cc.Animate3D:create"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cc.Animation3D:create",
            "animate3d:setSpeed",
            "animate3d:retain",
            "cc.Animate3D:create"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function removeAll(table)",
        "start_line": "89",
        "end_line": "95",
        "file_path": "src/Helper.lua",
        "docstring": "The function createAnimation(file, begin, finish, speed) generates a 3D animation by loading a file and creating an animation segment from begin to finish frames at a specified speed. It returns the configured animation object.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0725f2413b6b",
        "ground_truth": "function removeAll(table)\n    while true do\n        local k =next(table)\n        if not k then break end\n        table[k] = nil\n    end\nend",
        "import_statements": [],
        "reference_api": [
            "next"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function delayExecute(target, func, delay)",
        "start_line": "180",
        "end_line": "183",
        "file_path": "src/Helper.lua",
        "docstring": "The function delayExecute(target, func, delay) schedules a function to be executed on a target object after a specified delay. It creates a delay action and sequences it with the function call, then runs the sequence on the target.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "526d10bb37bb",
        "ground_truth": "function delayExecute(target, func, delay)\n    local wait = cc.DelayTime:create(delay)\n    target:runAction(cc.Sequence:create(wait, cc.CallFunc:create(func)))\nend",
        "import_statements": [],
        "reference_api": [
            "cc.Sequence:create",
            "cc.CallFunc:create",
            "target:runAction",
            "cc.DelayTime:create"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cc.Sequence:create",
            "cc.CallFunc:create",
            "target:runAction",
            "cc.DelayTime:create"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function LoadingScene:addLoadingText(layer)",
        "start_line": "104",
        "end_line": "114",
        "file_path": "src/LoadingScene.lua",
        "docstring": "The function LoadingScene:addLoadingText(layer) creates and configures \"loading\" text labels using a specified font, sets their position on the screen, and adds them to the provided layer. It stores these labels in the object's _loading property.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3b277bd3d0d0",
        "ground_truth": "function LoadingScene:addLoadingText(layer)\n    local ttfconfig = {outlineSize=5,fontSize=55,fontFilePath=\"chooseRole/actor_param.ttf\"}\n    local loading = {}\n    for i,v in pairs({\"l\",\"o\",\"a\",\"d\",\"i\",\"n\",\"g\"}) do\n        loading[i] = cc.Label:createWithTTF(ttfconfig,v)\n        loading[i]:enableOutline(cc.c4b(104,151,161,255))\n        loading[i]:setPosition(self.size.width*0.13+self.size.width*0.1*i,self.size.height*0.6)\n        layer:addChild(loading[i])\n    end\n    self._loading = loading\nend",
        "import_statements": [
            "require \"ParticleManager\"",
            "require \"Slime\"",
            "require(\"MainMenuScene\")"
        ],
        "reference_api": [
            "layer:addChild",
            "cc.Label:createWithTTF",
            "cc.c4b",
            "pairs"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "layer:addChild",
            "cc.Label:createWithTTF",
            "cc.c4b"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function MainMenuScene.create()",
        "start_line": "20",
        "end_line": "27",
        "file_path": "src/MainMenuScene.lua",
        "docstring": "The function MainMenuScene.create() initializes a new main menu scene, adds a layer to it, and then returns the configured scene object.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "68250ae97644",
        "ground_truth": "function MainMenuScene.create()\n    local scene = MainMenuScene.new()\n    --add layer\n    local layer = scene:createLayer()\n    scene:addChild(layer)\n         return scene\nend",
        "import_statements": [
            "require \"Helper\"",
            "require \"GlobalVariables\"",
            "require(\"ChooseRoleScene\")"
        ],
        "reference_api": [
            "MainMenuScene.new",
            "scene:createLayer",
            "scene:addChild"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "MainMenuScene.new",
            "scene:createLayer",
            "scene:addChild"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "local function collision(object)\n",
        "start_line": "50",
        "end_line": "64",
        "file_path": "src/Manager.lua",
        "docstring": "The function collision(object) checks for collisions between a given object and all alive heroes and monsters managed by HeroManager and MonsterManager, respectively. If a collision is detected, it resolves the collision using the solveCollision function.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "81470efbb6ff",
        "ground_truth": "local function collision(object)\n    for val = HeroManager.first, HeroManager.last do\n        local sprite = HeroManager[val]\n        if sprite._isalive and sprite ~= object then\n            solveCollision(sprite, object)\n        end\n    end\n     for val = MonsterManager.first, MonsterManager.last do\n        local sprite = MonsterManager[val]\n        if sprite._isalive == true and sprite ~= object then\n            solveCollision(sprite, object)\n        end                  \n    end      \nend",
        "import_statements": [
            "require \"Helper\""
        ],
        "reference_api": [
            "solveCollision"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "solveCollision",
                "code": "solveCollision"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function collisionDetect(dt)",
        "start_line": "88",
        "end_line": "110",
        "file_path": "src/Manager.lua",
        "docstring": "The function collisionDetect(dt) iterates through HeroManager and MonsterManager lists in reverse order to check if each sprite is alive. For alive sprites, it performs collision detection and boundary checks, and updates their position if they belong to HeroManager. Dead sprites are removed from their respective lists.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f8915bebdc0e",
        "ground_truth": "function collisionDetect(dt)\n    --cclog(\"collisionDetect\")\n    for val = HeroManager.last, HeroManager.first, -1 do\n        local sprite = HeroManager[val]\n        if sprite._isalive == true then\n            collision(sprite)\n            isOutOfBound(sprite)\n            sprite._effectNode:setPosition(sprite._myPos)\n        else\n            List.remove(HeroManager, val)\n        end\n    end\n     for val = MonsterManager.last, MonsterManager.first, -1 do\n        local sprite = MonsterManager[val]\n        if sprite._isalive == true then\n            collision(sprite)\n            isOutOfBound(sprite)          \n        else\n            List.remove(MonsterManager, val)\n        end\n    end           \nend",
        "import_statements": [
            "require \"Helper\""
        ],
        "reference_api": [
            "List.remove",
            "sprite._effectNode:setPosition",
            "collision",
            "isOutOfBound"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "collision",
                "code": "collision"
            },
            {
                "name": "isOutOfBound",
                "code": "isOutOfBound"
            }
        ],
        "third_party": [
            "List.remove",
            "sprite._effectNode:setPosition"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function Actor:specialAttack()",
        "start_line": "188",
        "end_line": "191",
        "file_path": "src/actors/Actor.lua",
        "docstring": "The function Actor:specialAttack() initiates a special attack by creating a collider at the actor's current position and facing direction with specified attack properties. It also plays the associated sound effects for the special attack.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fc081bb122f5",
        "ground_truth": "function Actor:specialAttack()\n    BasicCollider.create(self._myPos, self._curFacing, self._specialAttack)\n    self:specialAttackSoundEffects()\nend",
        "import_statements": [
            "require \"Helper\"",
            "require \"AttackCommand\"",
            "require \"GlobalVariables\"",
            "require \"HPCounter\""
        ],
        "reference_api": [
            "BasicCollider.create",
            "self:specialAttackSoundEffects"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "BasicCollider.create",
            "self:specialAttackSoundEffects"
        ]
    },
    {
        "subclass": "cocos2d-x",
        "owner/repo": "chukong/SampleGame-FantasyWarrior3D",
        "function_declaration": "function Slime:angryFace(trueFalse)",
        "start_line": "88",
        "end_line": "97",
        "file_path": "src/actors/Slime.lua",
        "docstring": "The function Slime:angryFace(trueFalse) changes the texture of the slime's 3D sprite based on the trueFalse parameter. If the parameter is true, it sets an \"angry\" texture; if false, it sets a \"normal\" texture. It only updates the texture if the current state differs from the new state.",
        "language": "Lua",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bfc98809aacb",
        "ground_truth": "function Slime:angryFace(trueFalse)\n    if self._angryFace ~= trueFalse then\n        self._angryFace = trueFalse\n        if trueFalse then\n            self._sprite3d:setTexture(\"model/slime/baozi2.jpg\")\n        else\n            self._sprite3d:setTexture(\"model/slime/baozi.jpg\")\n        end\n    end   \nend",
        "import_statements": [
            "require \"GlobalVariables\"",
            "require \"MessageDispatchCenter\"",
            "require \"Helper\"",
            "require \"AttackCommand\"",
            "require \"Actor\""
        ],
        "reference_api": [
            "self._sprite3d:setTexture"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "self._sprite3d:setTexture"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "override fun getCharPixmap(char: Char): Pixmap",
        "start_line": "93",
        "end_line": "116",
        "file_path": "android/src/com/unciv/app/AndroidFont.kt",
        "docstring": "The function getCharPixmap(symbolString: String): Pixmap generates a Pixmap representation of a given character string. It calculates the text dimensions, creates a bitmap, draws the text onto the bitmap, converts the bitmap to pixel data, and then constructs a Pixmap object with the pixel data, ensuring correct pixel format. The bitmap is recycled after use.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "546a0b8fb77b",
        "ground_truth": "override fun getCharPixmap(symbolString: String): Pixmap {\n    val metric = getMetrics()  // Use our interpretation instead of paint.fontMetrics because it fixes some bad metrics\n    var width = paint.measureText(symbolString).toInt()\n    var height = ceil(metric.height).toInt()\n    if (width == 0) {\n        height = getFontSize()\n        width = height\n    }\n    val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)\n    val canvas = Canvas(bitmap)\n    canvas.drawText(symbolString, 0f, metric.leading + metric.ascent + 1f, paint)\n    val pixmap = Pixmap(width, height, Pixmap.Format.RGBA8888)\n    val data = IntArray(width * height)\n    bitmap.getPixels(data, 0, width, 0, 0, width, height) // faster than bitmap[x, y]\n    for (x in 0 until width) {\n        for (y in 0 until height) {\n            pixmap.drawPixel(x, y, Integer.rotateLeft(data[x + (y * width)], 8))\n        }\n    }\n    bitmap.recycle()\n    return pixmap\n}",
        "import_statements": [
            "import android.graphics.Bitmap",
            "import android.graphics.Canvas",
            "import android.graphics.Paint",
            "import android.graphics.Typeface",
            "import android.graphics.fonts.Font",
            "import android.graphics.fonts.FontFamily",
            "import android.graphics.fonts.FontStyle",
            "import android.graphics.fonts.SystemFonts",
            "import android.os.Build",
            "import androidx.annotation.RequiresApi",
            "import com.badlogic.gdx.Gdx",
            "import com.badlogic.gdx.graphics.Pixmap",
            "import com.unciv.ui.components.fonts.FontFamilyData",
            "import com.unciv.ui.components.fonts.FontImplementation",
            "import com.unciv.ui.components.fonts.FontMetricsCommon",
            "import com.unciv.ui.components.fonts.Fonts",
            "import com.unciv.utils.Log",
            "import java.util.Locale",
            "import kotlin.math.abs",
            "import kotlin.math.ceil"
        ],
        "reference_api": [
            "Pixmap",
            "getFontSize",
            "getMetrics",
            "Canvas",
            "ceil",
            "IntArray"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Pixmap",
                "code": "override fun getCharPixmap(symbolString: String): Pixmap {\n        val metric = getMetrics()  // Use our interpretation instead of paint.fontMetrics because it fixes some bad metrics\n        var width = paint.measureText(symbolString).toInt()\n        var height = ceil(metric.height).toInt()\n        if (width == 0) {\n            height = getFontSize()\n            width = height\n        }\n\n        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)\n        val canvas = Canvas(bitmap)\n        canvas.drawText(symbolString, 0f, metric.leading + metric.ascent + 1f, paint)\n\n        val pixmap = Pixmap(width, height, Pixmap.Format.RGBA8888)\n        val data = IntArray(width * height)\n        bitmap.getPixels(data, 0, width, 0, 0, width, height) // faster than bitmap[x, y]\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                pixmap.drawPixel(x, y, Integer.rotateLeft(data[x + (y * width)], 8))\n            }\n        }\n        bitmap.recycle()\n        return pixmap\n    }"
            },
            {
                "name": "getFontSize",
                "code": "override fun getFontSize(): Int {\n        return paint.textSize.toInt()\n    }"
            },
            {
                "name": "getMetrics",
                "code": "override fun getCharPixmap(symbolString: String): Pixmap {\n        val metric = getMetrics()  // Use our interpretation instead of paint.fontMetrics because it fixes some bad metrics\n        var width = paint.measureText(symbolString).toInt()\n        var height = ceil(metric.height).toInt()\n        if (width == 0) {\n            height = getFontSize()\n            width = height\n        }\n\n        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)\n        val canvas = Canvas(bitmap)\n        canvas.drawText(symbolString, 0f, metric.leading + metric.ascent + 1f, paint)\n\n        val pixmap = Pixmap(width, height, Pixmap.Format.RGBA8888)\n        val data = IntArray(width * height)\n        bitmap.getPixels(data, 0, width, 0, 0, width, height) // faster than bitmap[x, y]\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                pixmap.drawPixel(x, y, Integer.rotateLeft(data[x + (y * width)], 8))\n            }\n        }\n        bitmap.recycle()\n        return pixmap\n    }"
            },
            {
                "name": "Canvas",
                "code": "override fun getCharPixmap(symbolString: String): Pixmap {\n        val metric = getMetrics()  // Use our interpretation instead of paint.fontMetrics because it fixes some bad metrics\n        var width = paint.measureText(symbolString).toInt()\n        var height = ceil(metric.height).toInt()\n        if (width == 0) {\n            height = getFontSize()\n            width = height\n        }\n\n        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)\n        val canvas = Canvas(bitmap)\n        canvas.drawText(symbolString, 0f, metric.leading + metric.ascent + 1f, paint)\n\n        val pixmap = Pixmap(width, height, Pixmap.Format.RGBA8888)\n        val data = IntArray(width * height)\n        bitmap.getPixels(data, 0, width, 0, 0, width, height) // faster than bitmap[x, y]\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                pixmap.drawPixel(x, y, Integer.rotateLeft(data[x + (y * width)], 8))\n            }\n        }\n        bitmap.recycle()\n        return pixmap\n    }"
            },
            {
                "name": "ceil",
                "code": "override fun getCharPixmap(symbolString: String): Pixmap {\n        val metric = getMetrics()  // Use our interpretation instead of paint.fontMetrics because it fixes some bad metrics\n        var width = paint.measureText(symbolString).toInt()\n        var height = ceil(metric.height).toInt()\n        if (width == 0) {\n            height = getFontSize()\n            width = height\n        }\n\n        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)\n        val canvas = Canvas(bitmap)\n        canvas.drawText(symbolString, 0f, metric.leading + metric.ascent + 1f, paint)\n\n        val pixmap = Pixmap(width, height, Pixmap.Format.RGBA8888)\n        val data = IntArray(width * height)\n        bitmap.getPixels(data, 0, width, 0, 0, width, height) // faster than bitmap[x, y]\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                pixmap.drawPixel(x, y, Integer.rotateLeft(data[x + (y * width)], 8))\n            }\n        }\n        bitmap.recycle()\n        return pixmap\n    }"
            },
            {
                "name": "IntArray",
                "code": "override fun getCharPixmap(symbolString: String): Pixmap {\n        val metric = getMetrics()  // Use our interpretation instead of paint.fontMetrics because it fixes some bad metrics\n        var width = paint.measureText(symbolString).toInt()\n        var height = ceil(metric.height).toInt()\n        if (width == 0) {\n            height = getFontSize()\n            width = height\n        }\n\n        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)\n        val canvas = Canvas(bitmap)\n        canvas.drawText(symbolString, 0f, metric.leading + metric.ascent + 1f, paint)\n\n        val pixmap = Pixmap(width, height, Pixmap.Format.RGBA8888)\n        val data = IntArray(width * height)\n        bitmap.getPixels(data, 0, width, 0, 0, width, height) // faster than bitmap[x, y]\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                pixmap.drawPixel(x, y, Integer.rotateLeft(data[x + (y * width)], 8))\n            }\n        }\n        bitmap.recycle()\n        return pixmap\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": " override fun saveGame(\n        data: String,\n        suggestedLocation: String,\n        onSaved: (location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    )",
        "start_line": "27",
        "end_line": "54",
        "file_path": "android/src/com/unciv/app/AndroidSaverLoader.kt",
        "docstring": "The function saveGame(data: String, suggestedLocation: String, onSaved: (location: String) -> Unit, onError: (ex: Exception) -> Unit) saves game data to a specified location. It parses the suggested location URI, determines the filename, and defines a callback for file selection. Upon file selection, it attempts to write data to the chosen URI and invokes the onSaved callback if successful or onError in case of an exception. The function also opens a file chooser for user to select save location.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9c1ce2567ce1",
        "ground_truth": "override fun saveGame(\n    data: String,\n    suggestedLocation: String,\n    onSaved: (location: String) -> Unit,\n    onError: (ex: Exception) -> Unit\n) {\n    // When we loaded, we returned a \"content://\" URI as file location.\n    val suggestedUri = Uri.parse(suggestedLocation)\n    val fileName = getFilename(suggestedUri, suggestedLocation)\n    val onFileChosen = { uri: Uri ->\n        var stream: OutputStream? = null\n        try {\n            stream = contentResolver.openOutputStream(uri, \"rwt\")\n            stream!!.writer().use { it.write(data) }\n            onSaved(uri.toString())\n        } catch (ex: Exception) {\n            onError(ex)\n        } finally {\n            stream?.close()\n        }\n    }\n    requests[requestCode] = Request(onFileChosen, onError)\n    openSaveFileChooser(fileName, suggestedUri, requestCode)\n    requestCode += 1\n}",
        "import_statements": [
            "import android.app.Activity",
            "import android.content.Intent",
            "import android.net.Uri",
            "import android.provider.DocumentsContract",
            "import android.provider.OpenableColumns",
            "import com.unciv.logic.files.PlatformSaverLoader",
            "import com.unciv.utils.Log",
            "import java.io.InputStream",
            "import java.io.OutputStream"
        ],
        "reference_api": [
            "onError",
            "openSaveFileChooser",
            "Request",
            "onSaved",
            "getFilename"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "onError",
                "code": "onError(PlatformSaverLoader.Cancelled())"
            },
            {
                "name": "openSaveFileChooser",
                "code": "override fun saveGame(\n        data: String,\n        suggestedLocation: String,\n        onSaved: (location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    ) {\n\n        // When we loaded, we returned a \"content://\" URI as file location.\n        val suggestedUri = Uri.parse(suggestedLocation)\n        val fileName = getFilename(suggestedUri, suggestedLocation)\n\n        val onFileChosen = { uri: Uri ->\n            var stream: OutputStream? = null\n            try {\n                stream = contentResolver.openOutputStream(uri, \"rwt\")\n                stream!!.writer().use { it.write(data) }\n                onSaved(uri.toString())\n            } catch (ex: Exception) {\n                onError(ex)\n            } finally {\n                stream?.close()\n            }\n        }\n\n        requests[requestCode] = Request(onFileChosen, onError)\n        openSaveFileChooser(fileName, suggestedUri, requestCode)\n        requestCode += 1\n    }"
            },
            {
                "name": "Request",
                "code": "override fun saveGame(\n        data: String,\n        suggestedLocation: String,\n        onSaved: (location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    ) {\n\n        // When we loaded, we returned a \"content://\" URI as file location.\n        val suggestedUri = Uri.parse(suggestedLocation)\n        val fileName = getFilename(suggestedUri, suggestedLocation)\n\n        val onFileChosen = { uri: Uri ->\n            var stream: OutputStream? = null\n            try {\n                stream = contentResolver.openOutputStream(uri, \"rwt\")\n                stream!!.writer().use { it.write(data) }\n                onSaved(uri.toString())\n            } catch (ex: Exception) {\n                onError(ex)\n            } finally {\n                stream?.close()\n            }\n        }\n\n        requests[requestCode] = Request(onFileChosen, onError)\n        openSaveFileChooser(fileName, suggestedUri, requestCode)\n        requestCode += 1\n    }"
            },
            {
                "name": "onSaved",
                "code": "override fun saveGame(\n        data: String,\n        suggestedLocation: String,\n        onSaved: (location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    ) {\n\n        // When we loaded, we returned a \"content://\" URI as file location.\n        val suggestedUri = Uri.parse(suggestedLocation)\n        val fileName = getFilename(suggestedUri, suggestedLocation)\n\n        val onFileChosen = { uri: Uri ->\n            var stream: OutputStream? = null\n            try {\n                stream = contentResolver.openOutputStream(uri, \"rwt\")\n                stream!!.writer().use { it.write(data) }\n                onSaved(uri.toString())\n            } catch (ex: Exception) {\n                onError(ex)\n            } finally {\n                stream?.close()\n            }\n        }\n\n        requests[requestCode] = Request(onFileChosen, onError)\n        openSaveFileChooser(fileName, suggestedUri, requestCode)\n        requestCode += 1\n    }"
            },
            {
                "name": "getFilename",
                "code": "override fun saveGame(\n        data: String,\n        suggestedLocation: String,\n        onSaved: (location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    ) {\n\n        // When we loaded, we returned a \"content://\" URI as file location.\n        val suggestedUri = Uri.parse(suggestedLocation)\n        val fileName = getFilename(suggestedUri, suggestedLocation)\n\n        val onFileChosen = { uri: Uri ->\n            var stream: OutputStream? = null\n            try {\n                stream = contentResolver.openOutputStream(uri, \"rwt\")\n                stream!!.writer().use { it.write(data) }\n                onSaved(uri.toString())\n            } catch (ex: Exception) {\n                onError(ex)\n            } finally {\n                stream?.close()\n            }\n        }\n\n        requests[requestCode] = Request(onFileChosen, onError)\n        openSaveFileChooser(fileName, suggestedUri, requestCode)\n        requestCode += 1\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "override fun loadGame(\n        onLoaded: (data: String, location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    )",
        "start_line": "56",
        "end_line": "77",
        "file_path": "android/src/com/unciv/app/AndroidSaverLoader.kt",
        "docstring": "The function loadGame(onLoaded: (data: String, location: String) -> Unit, onError: (ex: Exception) -> Unit) loads game data from a user-selected file. It defines a callback to handle file selection, attempts to read the file's content, and invokes onLoaded with the data and file location if successful, or onError if an exception occurs. The function opens a file chooser for the user to select the file to load.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ea556fe12030",
        "ground_truth": "override fun loadGame(\n    onLoaded: (data: String, location: String) -> Unit,\n    onError: (ex: Exception) -> Unit\n) {\n    val onFileChosen = {uri: Uri ->\n        var stream: InputStream? = null\n        try {\n            stream = contentResolver.openInputStream(uri)\n            val text = stream!!.reader().use { it.readText() }\n            onLoaded(text, uri.toString())\n        } catch (ex: Exception) {\n            onError(ex)\n        } finally {\n            stream?.close()\n        }\n    }\n    requests[requestCode] = Request(onFileChosen, onError)\n    openLoadFileChooser(requestCode)\n    requestCode += 1\n}",
        "import_statements": [
            "import android.app.Activity",
            "import android.content.Intent",
            "import android.net.Uri",
            "import android.provider.DocumentsContract",
            "import android.provider.OpenableColumns",
            "import com.unciv.logic.files.PlatformSaverLoader",
            "import com.unciv.utils.Log",
            "import java.io.InputStream",
            "import java.io.OutputStream"
        ],
        "reference_api": [
            "onError",
            "Request",
            "onLoaded",
            "openLoadFileChooser"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "onError",
                "code": "onError(PlatformSaverLoader.Cancelled())"
            },
            {
                "name": "Request",
                "code": "override fun saveGame(\n        data: String,\n        suggestedLocation: String,\n        onSaved: (location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    ) {\n\n        // When we loaded, we returned a \"content://\" URI as file location.\n        val suggestedUri = Uri.parse(suggestedLocation)\n        val fileName = getFilename(suggestedUri, suggestedLocation)\n\n        val onFileChosen = { uri: Uri ->\n            var stream: OutputStream? = null\n            try {\n                stream = contentResolver.openOutputStream(uri, \"rwt\")\n                stream!!.writer().use { it.write(data) }\n                onSaved(uri.toString())\n            } catch (ex: Exception) {\n                onError(ex)\n            } finally {\n                stream?.close()\n            }\n        }\n\n        requests[requestCode] = Request(onFileChosen, onError)\n        openSaveFileChooser(fileName, suggestedUri, requestCode)\n        requestCode += 1\n    }"
            },
            {
                "name": "onLoaded",
                "code": "override fun loadGame(\n        onLoaded: (data: String, location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    ) {\n\n        val onFileChosen = {uri: Uri ->\n            var stream: InputStream? = null\n            try {\n                stream = contentResolver.openInputStream(uri)\n                val text = stream!!.reader().use { it.readText() }\n                onLoaded(text, uri.toString())\n            } catch (ex: Exception) {\n                onError(ex)\n            } finally {\n                stream?.close()\n            }\n        }\n\n        requests[requestCode] = Request(onFileChosen, onError)\n        openLoadFileChooser(requestCode)\n        requestCode += 1\n    }"
            },
            {
                "name": "openLoadFileChooser",
                "code": "override fun loadGame(\n        onLoaded: (data: String, location: String) -> Unit,\n        onError: (ex: Exception) -> Unit\n    ) {\n\n        val onFileChosen = {uri: Uri ->\n            var stream: InputStream? = null\n            try {\n                stream = contentResolver.openInputStream(uri)\n                val text = stream!!.reader().use { it.readText() }\n                onLoaded(text, uri.toString())\n            } catch (ex: Exception) {\n                onError(ex)\n            } finally {\n                stream?.close()\n            }\n        }\n\n        requests[requestCode] = Request(onFileChosen, onError)\n        openLoadFileChooser(requestCode)\n        requestCode += 1\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "private fun openSaveFileChooser(fileName: String, uri: Uri, requestCode: Int)",
        "start_line": "87",
        "end_line": "94",
        "file_path": "android/src/com/unciv/app/AndroidSaverLoader.kt",
        "docstring": "The function openSaveFileChooser(fileName: String, uri: Uri, requestCode: Int) initiates an intent to open a save file chooser dialog. It sets the document type to JSON, specifies the suggested file name, and sets the initial URI if the scheme is \"content\". The function then starts the activity to handle the save action with a request code.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "813990d9bb4d",
        "ground_truth": "private fun openSaveFileChooser(fileName: String, uri: Uri, requestCode: Int) {\n    val intent = Intent(Intent.ACTION_CREATE_DOCUMENT)\n    intent.type = \"application/json\"\n    intent.putExtra(Intent.EXTRA_TITLE, fileName)\n    if (uri.scheme == \"content\")\n        intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, uri)\n    activity.startActivityForResult(intent, requestCode)\n}",
        "import_statements": [
            "import android.app.Activity",
            "import android.content.Intent",
            "import android.net.Uri",
            "import android.provider.DocumentsContract",
            "import android.provider.OpenableColumns",
            "import com.unciv.logic.files.PlatformSaverLoader",
            "import com.unciv.utils.Log",
            "import java.io.InputStream",
            "import java.io.OutputStream"
        ],
        "reference_api": [
            "Intent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Intent",
                "code": "private fun openSaveFileChooser(fileName: String, uri: Uri, requestCode: Int) {\n        val intent = Intent(Intent.ACTION_CREATE_DOCUMENT)\n        intent.type = \"application/json\"\n        intent.putExtra(Intent.EXTRA_TITLE, fileName)\n        if (uri.scheme == \"content\")\n            intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, uri)\n        activity.startActivityForResult(intent, requestCode)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "fun createNotificationChannelInfo(appContext: Context)",
        "start_line": "94",
        "end_line": "106",
        "file_path": "android/src/com/unciv/app/MultiplayerTurnCheckWorker.kt",
        "docstring": "The function openSaveFileChooser(fileName: String, uri: Uri, requestCode: Int) initiates a file save dialog with a specified filename and MIME type. It sets the initial URI if the scheme is \"content\" and starts the activity to handle the result using the provided request code.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a423b39ba6fe",
        "ground_truth": "fun createNotificationChannelInfo(appContext: Context) {\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) return\n    val name = appContext.resources.getString(R.string.Notify_ChannelInfo_Short)\n    val descriptionText = appContext.resources.getString(R.string.Notify_ChannelInfo_Long)\n    val importance = NotificationManager.IMPORTANCE_HIGH\n    val mChannel = NotificationChannel(NOTIFICATION_CHANNEL_ID_INFO, name, importance)\n    mChannel.description = descriptionText\n    mChannel.setShowBadge(true)\n    mChannel.lockscreenVisibility = NotificationCompat.VISIBILITY_PUBLIC\n    val notificationManager = appContext.getSystemService(AndroidApplication.NOTIFICATION_SERVICE) as NotificationManager\n    notificationManager.createNotificationChannel(mChannel)\n}",
        "import_statements": [
            "import android.app.NotificationChannel",
            "import android.app.NotificationManager",
            "import android.app.PendingIntent",
            "import android.app.PendingIntent.FLAG_IMMUTABLE",
            "import android.app.PendingIntent.FLAG_UPDATE_CURRENT",
            "import android.content.Context",
            "import android.content.ContextWrapper",
            "import android.content.Intent",
            "import android.graphics.Color",
            "import android.net.Uri",
            "import android.os.Build",
            "import android.util.Log",
            "import androidx.core.app.NotificationCompat",
            "import androidx.core.app.NotificationCompat.DEFAULT_VIBRATE",
            "import androidx.core.app.NotificationManagerCompat",
            "import androidx.work.Constraints",
            "import androidx.work.Data",
            "import androidx.work.NetworkType",
            "import androidx.work.OneTimeWorkRequestBuilder",
            "import androidx.work.WorkManager",
            "import androidx.work.Worker",
            "import androidx.work.WorkerParameters",
            "import androidx.work.workDataOf",
            "import com.badlogic.gdx.Gdx",
            "import com.badlogic.gdx.backends.android.AndroidApplication",
            "import com.badlogic.gdx.backends.android.DefaultAndroidFiles",
            "import com.unciv.logic.GameInfo",
            "import com.unciv.logic.files.UncivFiles",
            "import com.unciv.logic.multiplayer.storage.FileStorageRateLimitReached",
            "import com.unciv.logic.multiplayer.storage.OnlineMultiplayerServer",
            "import com.unciv.models.metadata.GameSettings.GameSettingsMultiplayer",
            "import java.io.FileNotFoundException",
            "import java.io.PrintWriter",
            "import java.io.StringWriter",
            "import java.io.Writer",
            "import java.time.Duration",
            "import java.util.GregorianCalendar",
            "import java.util.concurrent.TimeUnit",
            "import kotlinx.coroutines.runBlocking"
        ],
        "reference_api": [
            "NotificationChannel"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "NotificationChannel",
                "code": "fun createNotificationChannelInfo(appContext: Context) {\n            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) return\n            val name = appContext.resources.getString(R.string.Notify_ChannelInfo_Short)\n            val descriptionText = appContext.resources.getString(R.string.Notify_ChannelInfo_Long)\n            val importance = NotificationManager.IMPORTANCE_HIGH\n            val mChannel = NotificationChannel(NOTIFICATION_CHANNEL_ID_INFO, name, importance)\n            mChannel.description = descriptionText\n            mChannel.setShowBadge(true)\n            mChannel.lockscreenVisibility = NotificationCompat.VISIBILITY_PUBLIC\n\n            val notificationManager = appContext.getSystemService(AndroidApplication.NOTIFICATION_SERVICE) as NotificationManager\n            notificationManager.createNotificationChannel(mChannel)\n        }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "fun packImages(workingPath: String)",
        "start_line": "59",
        "end_line": "78",
        "file_path": "buildSrc/src/main/kotlin/AndroidImagePacker.kt",
        "docstring": "The function packImages(workingPath: String) generates image atlases for a specified working path and its subdirectories. It first packs images for the main assets folder, then scans a \"mods\" directory to pack images for each mod, skipping hidden files. If an error occurs during the process, it is caught and printed.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4f3e7f77a567",
        "ground_truth": "fun packImages(workingPath: String) {\n    val defaultSettings = getDefaultSettings()\n    // Scan for Image folders and build one atlas each\n    packImagesPerMod(workingPath, \"$workingPath/assets/\", defaultSettings)\n    // pack for mods\n    val modDirectory = File(\"mods\")\n    if (!modDirectory.exists())\n        return\n    for (mod in modDirectory.listFiles()!!) {\n        if (mod.isHidden)\n            continue\n        try {\n            packImagesPerMod(mod.path, mod.path, defaultSettings)\n        } catch (ex: Throwable) {\n            ex.printStackTrace()\n        }\n    }\n}",
        "import_statements": [
            "import com.badlogic.gdx.graphics.Texture",
            "import com.badlogic.gdx.tools.texturepacker.TexturePacker",
            "import com.badlogic.gdx.utils.Json",
            "import com.unciv.build.AndroidImagePacker.packImages",
            "import java.io.File",
            "import java.nio.file.Files",
            "import java.nio.file.attribute.BasicFileAttributes"
        ],
        "reference_api": [
            "File",
            "getDefaultSettings",
            "packImagesPerMod"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getDefaultSettings",
                "code": "private fun getDefaultSettings() = TexturePacker.Settings().apply {\n        // Apparently some chipsets, like NVIDIA Tegra 3 graphics chipset (used in Asus TF700T tablet),\n        // don't support non-power-of-two texture sizes - kudos @yuroller!\n        // https://github.com/yairm210/Unciv/issues/1340\n\n        /**\n         * These should be as big as possible in order to accommodate ALL the images together in one big file.\n         * Why? Because the rendering function of the main screen renders all the images consecutively, and every time it needs to switch between textures,\n         * this causes a delay, leading to horrible lag if there are enough switches.\n         * The cost of this specific solution is that the entire game.png needs be be kept in-memory constantly.\n         * Now here we come to what Fred Colon would call an Imp Arse.\n         * On the one hand, certain tilesets (ahem 5hex ahem) are really big.\n         * You wouldn't believe how hugely mindbogglingly big they are. So theoretically we should want all of their images to be together.\n         * HOWEVER certain chipsets (see https://github.com/yairm210/Unciv/issues/3330) only seem to support to up to 2048 width*height so this is maximum we can have.\n         * Practically this means that big custom tilesets will have to reload the texture a lot when covering the map and so the\n         *    panning on the map will tend to lag a lot :(\n         *\n         *    TL;DR this should be 2048.\n         */\n        maxWidth = 2048\n        maxHeight = 2048\n\n        // Trying to disable the subdirectory combine lead to even worse results. Don't.\n        combineSubdirectories = true\n        pot = true  // powers of two only for width/height\n        fast = true  // with pot on this just sorts by width\n        // settings.rotation - do not set. Allows rotation, potentially packing tighter.\n        //      Proper rendering is mostly automatic - except borders which overwrite rotation.\n\n        // Set some additional padding and enable duplicatePadding to prevent image edges from bleeding into each other due to mipmapping\n        paddingX = 8\n        paddingY = 8\n        duplicatePadding = true\n        filterMin = Texture.TextureFilter.MipMapLinearLinear\n        filterMag = Texture.TextureFilter.MipMapLinearLinear // I'm pretty sure this doesn't make sense for magnification, but setting it to Linear gives strange results\n    }"
            },
            {
                "name": "packImagesPerMod",
                "code": "fun packImages(workingPath: String) {\n        val defaultSettings = getDefaultSettings()\n\n        // Scan for Image folders and build one atlas each\n        packImagesPerMod(workingPath, \"$workingPath/assets/\", defaultSettings)\n\n        // pack for mods\n        val modDirectory = File(\"mods\")\n        if (!modDirectory.exists())\n            return\n        for (mod in modDirectory.listFiles()!!) {\n            if (mod.isHidden)\n                continue\n            try {\n                packImagesPerMod(mod.path, mod.path, defaultSettings)\n            } catch (ex: Throwable) {\n                ex.printStackTrace()\n            }\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "suspend fun reloadWorldscreen()",
        "start_line": "250",
        "end_line": "256",
        "file_path": "core/src/com/unciv/UncivGame.kt",
        "docstring": "The function packImages(workingPath: String) creates image atlases for the specified working path and for each mod in the \"mods\" directory. It first packs images located in the assets folder of the working path using default settings, then scans the \"mods\" directory to pack images for each mod, skipping hidden mods and handling exceptions by printing stack traces.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "206dbb3c21eb",
        "ground_truth": "suspend fun reloadWorldscreen() {\n    val curWorldScreen = worldScreen\n    val curGameInfo = gameInfo\n    if (curWorldScreen == null || curGameInfo == null) return\n    loadGame(curGameInfo)\n}",
        "import_statements": [
            "import com.badlogic.gdx.Application",
            "import com.badlogic.gdx.Game",
            "import com.badlogic.gdx.Gdx",
            "import com.badlogic.gdx.Input",
            "import com.badlogic.gdx.Screen",
            "import com.badlogic.gdx.scenes.scene2d.actions.Actions",
            "import com.unciv.logic.GameInfo",
            "import com.unciv.logic.IsPartOfGameInfoSerialization",
            "import com.unciv.logic.UncivShowableException",
            "import com.unciv.logic.civilization.PlayerType",
            "import com.unciv.logic.files.UncivFiles",
            "import com.unciv.logic.multiplayer.OnlineMultiplayer",
            "import com.unciv.models.metadata.GameSettings",
            "import com.unciv.models.ruleset.RulesetCache",
            "import com.unciv.models.skins.SkinCache",
            "import com.unciv.models.tilesets.TileSetCache",
            "import com.unciv.models.translations.Translations",
            "import com.unciv.models.translations.tr",
            "import com.unciv.ui.audio.MusicController",
            "import com.unciv.ui.audio.MusicMood",
            "import com.unciv.ui.audio.MusicTrackChooserFlags",
            "import com.unciv.ui.audio.SoundPlayer",
            "import com.unciv.ui.components.extensions.center",
            "import com.unciv.ui.components.fonts.Fonts",
            "import com.unciv.ui.crashhandling.CrashScreen",
            "import com.unciv.ui.crashhandling.wrapCrashHandlingUnit",
            "import com.unciv.ui.images.ImageGetter",
            "import com.unciv.ui.popups.ConfirmPopup",
            "import com.unciv.ui.popups.Popup",
            "import com.unciv.ui.screens.LanguagePickerScreen",
            "import com.unciv.ui.screens.LoadingScreen",
            "import com.unciv.ui.screens.basescreen.BaseScreen",
            "import com.unciv.ui.screens.mainmenuscreen.MainMenuScreen",
            "import com.unciv.ui.screens.savescreens.LoadGameScreen",
            "import com.unciv.ui.screens.worldscreen.PlayerReadyScreen",
            "import com.unciv.ui.screens.worldscreen.WorldScreen",
            "import com.unciv.ui.screens.worldscreen.unit.AutoPlay",
            "import com.unciv.utils.Concurrency",
            "import com.unciv.utils.DebugUtils",
            "import com.unciv.utils.Display",
            "import com.unciv.utils.Log",
            "import com.unciv.utils.PlatformSpecific",
            "import com.unciv.utils.debug",
            "import com.unciv.utils.launchOnGLThread",
            "import com.unciv.utils.withGLContext",
            "import com.unciv.utils.withThreadPoolContext",
            "import kotlinx.coroutines.CancellationException",
            "import java.io.PrintWriter",
            "import java.util.EnumSet",
            "import java.util.UUID",
            "import kotlin.reflect.KClass"
        ],
        "reference_api": [
            "loadGame"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "loadGame",
                "code": "suspend fun loadGame(newGameInfo: GameInfo, autoPlay: AutoPlay = AutoPlay(settings.autoPlay), callFromLoadScreen: Boolean = false): WorldScreen = withThreadPoolContext toplevel@{\n        val prevGameInfo = gameInfo\n        gameInfo = newGameInfo\n\n\n        if (gameInfo?.gameParameters?.isOnlineMultiplayer == true\n                && gameInfo?.gameParameters?.anyoneCanSpectate == false\n                && gameInfo!!.civilizations.none { it.playerId == settings.multiplayer.userId }) {\n            throw UncivShowableException(\"You are not allowed to spectate!\")\n        }\n\n        initializeResources(newGameInfo)\n\n        val isLoadingSameGame = worldScreen != null && prevGameInfo != null && prevGameInfo.gameId == newGameInfo.gameId\n        val worldScreenRestoreState = if (!callFromLoadScreen && isLoadingSameGame) worldScreen!!.getRestoreState() else null\n\n        lateinit var loadingScreen: LoadingScreen\n\n        withGLContext {\n            // this is not merged with the below GL context block so that our loading screen gets a chance to show - otherwise\n            // we do it all in one swoop on the same thread and the application just \"freezes\" without loading screen for the duration.\n            loadingScreen = LoadingScreen(getScreen())\n            setScreen(loadingScreen)\n        }\n\n        return@toplevel withGLContext {\n            for (screen in screenStack) screen.dispose()\n            screenStack.clear()\n\n            worldScreen = null // This allows the GC to collect our old WorldScreen, otherwise we keep two WorldScreens in memory.\n            val newWorldScreen = WorldScreen(newGameInfo, autoPlay, newGameInfo.getPlayerToViewAs(), worldScreenRestoreState)\n            worldScreen = newWorldScreen\n\n            val moreThanOnePlayer = newGameInfo.civilizations.count { it.playerType == PlayerType.Human } > 1\n            val isSingleplayer = !newGameInfo.gameParameters.isOnlineMultiplayer\n            val screenToShow = if (moreThanOnePlayer && isSingleplayer) {\n                PlayerReadyScreen(newWorldScreen)\n            } else {\n                newWorldScreen\n            }\n\n            screenStack.addLast(screenToShow)\n            setScreen(screenToShow)\n            loadingScreen.dispose()\n\n            return@withGLContext newWorldScreen\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "fun goToMainMenu(): MainMenuScreen",
        "start_line": "472",
        "end_line": "480",
        "file_path": "core/src/com/unciv/UncivGame.kt",
        "docstring": "The function packImages(workingPath: String) creates image atlases from image folders. It first packs images from a specified working path using default settings. Then, it scans a \"mods\" directory, and for each non-hidden mod folder, it attempts to pack images using the same default settings, handling any exceptions that occur during the process.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2d8fdcb5ad6f",
        "ground_truth": "fun goToMainMenu(): MainMenuScreen {\n    val curGameInfo = gameInfo\n    if (curGameInfo != null) {\n        files.autosaves.requestAutoSaveUnCloned(curGameInfo) // Can save gameInfo directly because the user can't modify it on the MainMenuScreen\n    }\n    val mainMenuScreen = MainMenuScreen()\n    pushScreen(mainMenuScreen)\n    return mainMenuScreen\n}",
        "import_statements": [
            "import com.badlogic.gdx.Application",
            "import com.badlogic.gdx.Game",
            "import com.badlogic.gdx.Gdx",
            "import com.badlogic.gdx.Input",
            "import com.badlogic.gdx.Screen",
            "import com.badlogic.gdx.scenes.scene2d.actions.Actions",
            "import com.unciv.logic.GameInfo",
            "import com.unciv.logic.IsPartOfGameInfoSerialization",
            "import com.unciv.logic.UncivShowableException",
            "import com.unciv.logic.civilization.PlayerType",
            "import com.unciv.logic.files.UncivFiles",
            "import com.unciv.logic.multiplayer.OnlineMultiplayer",
            "import com.unciv.models.metadata.GameSettings",
            "import com.unciv.models.ruleset.RulesetCache",
            "import com.unciv.models.skins.SkinCache",
            "import com.unciv.models.tilesets.TileSetCache",
            "import com.unciv.models.translations.Translations",
            "import com.unciv.models.translations.tr",
            "import com.unciv.ui.audio.MusicController",
            "import com.unciv.ui.audio.MusicMood",
            "import com.unciv.ui.audio.MusicTrackChooserFlags",
            "import com.unciv.ui.audio.SoundPlayer",
            "import com.unciv.ui.components.extensions.center",
            "import com.unciv.ui.components.fonts.Fonts",
            "import com.unciv.ui.crashhandling.CrashScreen",
            "import com.unciv.ui.crashhandling.wrapCrashHandlingUnit",
            "import com.unciv.ui.images.ImageGetter",
            "import com.unciv.ui.popups.ConfirmPopup",
            "import com.unciv.ui.popups.Popup",
            "import com.unciv.ui.screens.LanguagePickerScreen",
            "import com.unciv.ui.screens.LoadingScreen",
            "import com.unciv.ui.screens.basescreen.BaseScreen",
            "import com.unciv.ui.screens.mainmenuscreen.MainMenuScreen",
            "import com.unciv.ui.screens.savescreens.LoadGameScreen",
            "import com.unciv.ui.screens.worldscreen.PlayerReadyScreen",
            "import com.unciv.ui.screens.worldscreen.WorldScreen",
            "import com.unciv.ui.screens.worldscreen.unit.AutoPlay",
            "import com.unciv.utils.Concurrency",
            "import com.unciv.utils.DebugUtils",
            "import com.unciv.utils.Display",
            "import com.unciv.utils.Log",
            "import com.unciv.utils.PlatformSpecific",
            "import com.unciv.utils.debug",
            "import com.unciv.utils.launchOnGLThread",
            "import com.unciv.utils.withGLContext",
            "import com.unciv.utils.withThreadPoolContext",
            "import kotlinx.coroutines.CancellationException",
            "import java.io.PrintWriter",
            "import java.util.EnumSet",
            "import java.util.UUID",
            "import kotlin.reflect.KClass"
        ],
        "reference_api": [
            "MainMenuScreen",
            "pushScreen"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "MainMenuScreen",
                "code": "override fun create() {\n        isInitialized = false // this could be on reload, therefore we need to keep setting this to false\n        Gdx.input.setCatchKey(Input.Keys.BACK, true)\n        if (Gdx.app.type != Application.ApplicationType.Desktop) {\n            DebugUtils.VISIBLE_MAP = false\n        }\n        Current = this\n        files = UncivFiles(Gdx.files)\n        Concurrency.run {\n            // Delete temporary files created when downloading mods\n            val tempFiles = Gdx.files.local(\"mods\").list().filter { !it.isDirectory && it.name().startsWith(\"temp-\") }\n            for (file in tempFiles) file.delete()\n        }\n\n        // If this takes too long players, especially with older phones, get ANR problems.\n        // Whatever needs graphics needs to be done on the main thread,\n        // So it's basically a long set of deferred actions.\n\n        /** When we recreate the GL context for whatever reason (say - we moved to a split screen on Android),\n         * ALL objects that were related to the old context - need to be recreated.\n         * So far we have:\n         * - All textures (hence the texture atlas)\n         * - SpriteBatch (hence BaseScreen uses a new SpriteBatch for each screen)\n         * - Skin (hence BaseScreen.setSkin())\n         * - Font (hence Fonts.resetFont() inside setSkin())\n         */\n        settings = files.getGeneralSettings() // needed for the screen\n        Display.setScreenMode(settings.screenMode, settings)\n        setAsRootScreen(GameStartScreen())  // NOT dependent on any atlas or skin\n\n        musicController = MusicController()  // early, but at this point does only copy volume from settings\n        installAudioHooks()\n\n        onlineMultiplayer = OnlineMultiplayer()\n\n        Concurrency.run {\n            // Check if the server is available in case the feature set has changed\n            try {\n                onlineMultiplayer.multiplayerServer.checkServerStatus()\n            } catch (ex: Exception) {\n                debug(\"Couldn't connect to server: \" + ex.message)\n            }\n        }\n\n        ImageGetter.resetAtlases()\n        ImageGetter.reloadImages()  // This needs to come after the settings, since we may have default visual mods\n        val imageGetterTilesets = ImageGetter.getAvailableTilesets()\n        val availableTileSets = TileSetCache.getAvailableTilesets(imageGetterTilesets)\n        if (settings.tileSet !in availableTileSets) { // If the configured tileset is no longer available, default back\n            settings.tileSet = Constants.defaultTileset\n        }\n\n        Gdx.graphics.isContinuousRendering = settings.continuousRendering\n\n        Concurrency.run(\"LoadJSON\") {\n            RulesetCache.loadRulesets()\n            translations.tryReadTranslationForCurrentLanguage()\n            translations.loadPercentageCompleteOfLanguages()\n            TileSetCache.loadTileSetConfigs()\n            SkinCache.loadSkinConfigs()\n\n            val vanillaRuleset = RulesetCache.getVanillaRuleset()\n\n            if (settings.multiplayer.userId.isEmpty()) { // assign permanent user id\n                settings.multiplayer.userId = UUID.randomUUID().toString()\n                settings.save()\n            }\n\n            // Loading available fonts can take a long time on Android phones.\n            // Therefore we initialize the lazy parameters in the font implementation, while we're in another thread, to avoid ANRs on main thread\n            Fonts.fontImplementation.setFontFamily(settings.fontFamilyData, settings.getFontSize())\n\n            // This stuff needs to run on the main thread because it needs the GL context\n            launchOnGLThread {\n                BaseScreen.setSkin() // needs to come AFTER the Texture reset, since the buttons depend on it and after loadSkinConfigs to be able to use the SkinConfig\n\n                musicController.chooseTrack(suffixes = listOf(MusicMood.Menu, MusicMood.Ambient),\n                    flags = EnumSet.of(MusicTrackChooserFlags.SuffixMustMatch))\n\n                ImageGetter.ruleset = vanillaRuleset // so that we can enter the map editor without having to load a game first\n\n                when {\n                    settings.isFreshlyCreated -> setAsRootScreen(LanguagePickerScreen())\n                    deepLinkedMultiplayerGame == null -> setAsRootScreen(MainMenuScreen())\n                    else -> tryLoadDeepLinkedGame()\n                }\n\n                isInitialized = true\n            }\n        }\n    }"
            },
            {
                "name": "pushScreen",
                "code": "fun pushScreen(newScreen: BaseScreen) {\n        screenStack.addLast(newScreen)\n        setScreen(newScreen)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": " protected fun setWindowedMode(settings: GameSettings): Boolean",
        "start_line": "54",
        "end_line": "72",
        "file_path": "desktop/src/com/unciv/app/desktop/DesktopDisplay.kt",
        "docstring": "The function setWindowedMode(settings: GameSettings): Boolean sets the game window to windowed mode based on provided settings. It retrieves the maximum window bounds, adjusts the window size within these bounds, and updates the window configuration and graphics mode. It returns true if the window size matches the maximum bounds.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "df60142d384c",
        "ground_truth": "protected fun setWindowedMode(settings: GameSettings): Boolean {\n    // Calling AWT after Gdx is fully initialized seems icky, but seems to have no side effects\n    // Found no equivalent in Gdx - available _desktop_ surface without taskbars etc\n    // *for the primary monitor* - no saving window sizes that span over several monitors\n    val maximumWindowBounds = getMaximumWindowBounds()\n    // Make sure an inappropriate saved size doesn't make the window unusable\n    val (width, height) = settings.windowState.coerceIn(maximumWindowBounds)\n    // Kludge - see also DesktopLauncher - without, moving the window might revert to the size stored in config\n    (Lwjgl3Application::class.java).getDeclaredField(\"config\").run {\n        isAccessible = true\n        get(Gdx.app) as Lwjgl3ApplicationConfiguration\n    }.setWindowedMode(width, height)\n    Gdx.graphics.setWindowedMode(width, height)\n    return width == maximumWindowBounds.width && height == maximumWindowBounds.height\n}",
        "import_statements": [
            "import com.badlogic.gdx.Gdx",
            "import com.badlogic.gdx.Graphics.Monitor",
            "import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application",
            "import com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration",
            "import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Graphics",
            "import com.unciv.models.metadata.GameSettings",
            "import com.unciv.models.translations.tr",
            "import com.unciv.utils.PlatformDisplay",
            "import com.unciv.utils.ScreenMode",
            "import java.awt.GraphicsConfiguration",
            "import java.awt.GraphicsDevice",
            "import java.awt.GraphicsEnvironment",
            "import java.awt.Toolkit",
            "import kotlin.math.roundToInt"
        ],
        "reference_api": [
            "get",
            "getMaximumWindowBounds"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get",
                "code": "protected fun setWindowedMode(settings: GameSettings): Boolean {\n        // Calling AWT after Gdx is fully initialized seems icky, but seems to have no side effects\n        // Found no equivalent in Gdx - available _desktop_ surface without taskbars etc\n        // *for the primary monitor* - no saving window sizes that span over several monitors\n        val maximumWindowBounds = getMaximumWindowBounds()\n\n        // Make sure an inappropriate saved size doesn't make the window unusable\n        val (width, height) = settings.windowState.coerceIn(maximumWindowBounds)\n\n        // Kludge - see also DesktopLauncher - without, moving the window might revert to the size stored in config\n        (Lwjgl3Application::class.java).getDeclaredField(\"config\").run {\n            isAccessible = true\n            get(Gdx.app) as Lwjgl3ApplicationConfiguration\n        }.setWindowedMode(width, height)\n\n        Gdx.graphics.setWindowedMode(width, height)\n\n        return width == maximumWindowBounds.width && height == maximumWindowBounds.height\n    }"
            },
            {
                "name": "getMaximumWindowBounds",
                "code": "protected fun setWindowedMode(settings: GameSettings): Boolean {\n        // Calling AWT after Gdx is fully initialized seems icky, but seems to have no side effects\n        // Found no equivalent in Gdx - available _desktop_ surface without taskbars etc\n        // *for the primary monitor* - no saving window sizes that span over several monitors\n        val maximumWindowBounds = getMaximumWindowBounds()\n\n        // Make sure an inappropriate saved size doesn't make the window unusable\n        val (width, height) = settings.windowState.coerceIn(maximumWindowBounds)\n\n        // Kludge - see also DesktopLauncher - without, moving the window might revert to the size stored in config\n        (Lwjgl3Application::class.java).getDeclaredField(\"config\").run {\n            isAccessible = true\n            get(Gdx.app) as Lwjgl3ApplicationConfiguration\n        }.setWindowedMode(width, height)\n\n        Gdx.graphics.setWindowedMode(width, height)\n\n        return width == maximumWindowBounds.width && height == maximumWindowBounds.height\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "private fun getLinuxDistro(): String",
        "start_line": "87",
        "end_line": "98",
        "file_path": "desktop/src/com/unciv/app/desktop/SystemUtils.kt",
        "docstring": "The function getLinuxDistro(): String retrieves the Linux distribution name by reading and parsing the \"/etc/os-release\" file into a map. If the \"NAME\" key is not found, it returns an empty string. Otherwise, it returns the \"PRETTY_NAME\" value or a combination of the \"NAME\" and \"VERSION\" values.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a8b17234c4e5",
        "ground_truth": "private fun getLinuxDistro(): String {\n    val osRelease: Map<String,String> = try {\n        FileHandle(\"/etc/os-release\")\n            .readString()\n            .split('\\n')\n            .map { it.split('=') }\n            .filter { it.size == 2 }\n            .associate { it[0] to it[1].removeSuffix(\"\\\"\").removePrefix(\"\\\"\") }\n    } catch (_: Throwable) { mapOf() }\n    if (\"NAME\" !in osRelease) return \"\"\n    return osRelease[\"PRETTY_NAME\"] ?: \"${osRelease[\"NAME\"]} ${osRelease[\"VERSION\"]}\"\n}",
        "import_statements": [
            "import com.badlogic.gdx.files.FileHandle",
            "import java.nio.charset.Charset"
        ],
        "reference_api": [
            "FileHandle",
            "mapOf"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "FileHandle",
                "code": "private fun getLinuxDistro(): String {\n        val osRelease: Map<String,String> = try {\n            FileHandle(\"/etc/os-release\")\n                .readString()\n                .split('\\n')\n                .map { it.split('=') }\n                .filter { it.size == 2 }\n                .associate { it[0] to it[1].removeSuffix(\"\\\"\").removePrefix(\"\\\"\") }\n        } catch (_: Throwable) { mapOf() }\n        if (\"NAME\" !in osRelease) return \"\"\n        return osRelease[\"PRETTY_NAME\"] ?: \"${osRelease[\"NAME\"]} ${osRelease[\"VERSION\"]}\"\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "yairm210/Unciv",
        "function_declaration": "private fun flashWindow()",
        "start_line": "56",
        "end_line": "75",
        "file_path": "desktop/src/com/unciv/app/desktop/UncivWindowListener.kt",
        "docstring": "The function flashWindow() attempts to flash the application window to notify the user if the window is not focused. It uses platform-specific APIs to achieve this, with a fallback method if the primary method is unavailable. Errors during this process are caught and logged without interrupting execution.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "36a1d2e56540",
        "ground_truth": "private fun flashWindow() {\n    try {\n        if (window == null || hasFocus) return\n        if (user32 == null)\n            // Use Cross-Platform implementation\n            return window!!.flash()\n        // Windows-specific implementation:\n        val flashwinfo = WinUser.FLASHWINFO()\n        val hwnd = GLFWNativeWin32.glfwGetWin32Window(window!!.windowHandle)\n        flashwinfo.hWnd = WinNT.HANDLE(Pointer.createConstant(hwnd))\n        flashwinfo.dwFlags = 3 // FLASHW_ALL\n        flashwinfo.uCount = 3\n        // FlashWindow (no binding in Java's User32) instead of FlashWindowEx would flash just once\n        user32.FlashWindowEx(flashwinfo)\n    } catch (e: Throwable) {\n        /** try to ignore even if we get an [Error], just log it */\n        Log.error(\"Error while notifying the user of their turn\", e)\n    }\n}",
        "import_statements": [
            "import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Window",
            "import com.badlogic.gdx.backends.lwjgl3.Lwjgl3WindowAdapter",
            "import com.sun.jna.Native",
            "import com.sun.jna.Pointer",
            "import com.sun.jna.platform.win32.User32",
            "import com.sun.jna.platform.win32.WinNT",
            "import com.sun.jna.platform.win32.WinUser",
            "import com.unciv.utils.Log",
            "import org.lwjgl.glfw.GLFWNativeWin32"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public void onFullBackup(FullBackupDataOutput data)",
        "start_line": "47",
        "end_line": "68",
        "file_path": "android/src/main/java/com/shatteredpixel/shatteredpixeldungeon/android/AndroidBackupHandler.java",
        "docstring": "The function onFullBackup(FullBackupDataOutput data) performs a full backup of the application data. It first backs up the shared preferences file, then sequentially backs up game data files related to rankings, badges, and journal entries if they exist.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8e3c7096415a",
        "ground_truth": "public void onFullBackup(FullBackupDataOutput data) {\n //fully overrides super.onFullBackup, meaning only files specified here are backed up\n   //does not backup runs in progress, to prevent cheating.\n   //store shared preferences\n fullBackupFile(new File(getFilesDir().getParent() + \"/shared_prefs/ShatteredPixelDungeon.xml\"), data);\n   //store game data\n File file = getFile( getFilesDir(), Rankings.RANKINGS_FILE );\n if (file != null){\n  fullBackupFile( file , data);\n }\n file = getFile( getFilesDir(), Badges.BADGES_FILE );\n if (file != null){\n  fullBackupFile( file , data);\n }\n file = getFile( getFilesDir(), Journal.JOURNAL_FILE );\n if (file != null){\n  fullBackupFile( file , data);\n }\n}",
        "import_statements": [
            "import android.annotation.TargetApi;",
            "import android.app.backup.BackupAgent;",
            "import android.app.backup.BackupDataInput;",
            "import android.app.backup.BackupDataOutput;",
            "import android.app.backup.FullBackupDataOutput;",
            "import android.os.ParcelFileDescriptor;",
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Rankings;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Journal;",
            "import java.io.File;"
        ],
        "reference_api": [
            "getFilesDir",
            "fullBackupFile",
            "getFile",
            "getParent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getFile",
                "code": "private static File getFile( File base, String name ){\n\t\tFile file = new File(base, name);\n\t\tif (!file.exists() || !file.isDirectory()){\n\t\t\treturn file;\n\t\t}\n\t\treturn null;\n\t}"
            }
        ],
        "third_party": [
            "getFilesDir",
            "fullBackupFile",
            "getParent"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public boolean connectedToUnmeteredNetwork()",
        "start_line": "154",
        "end_line": "167",
        "file_path": "android/src/main/java/com/shatteredpixel/shatteredpixeldungeon/android/AndroidPlatformSupport.java",
        "docstring": "The function connectedToUnmeteredNetwork() checks if the device is connected to an unmetered network. For Android Lollipop and above, it uses the isActiveNetworkMetered() method. For earlier versions, it checks if the active network is connected and of type WIFI, WIMAX, BLUETOOTH, or ETHERNET.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "583999724a15",
        "ground_truth": "public boolean connectedToUnmeteredNetwork() {\n //Returns true if using unmetered connection, use shortcut method if available\n ConnectivityManager cm = (ConnectivityManager) AndroidLauncher.instance.getSystemService(Context.CONNECTIVITY_SERVICE);\n if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP){\n  return !cm.isActiveNetworkMetered();\n } else {\n  NetworkInfo activeNetwork = cm.getActiveNetworkInfo();\n  return activeNetwork != null && activeNetwork.isConnectedOrConnecting() &&\n    (activeNetwork.getType() == ConnectivityManager.TYPE_WIFI\n    || activeNetwork.getType() == ConnectivityManager.TYPE_WIMAX\n    || activeNetwork.getType() == ConnectivityManager.TYPE_BLUETOOTH\n    || activeNetwork.getType() == ConnectivityManager.TYPE_ETHERNET);\n }\n}",
        "import_statements": [
            "import android.annotation.SuppressLint;",
            "import android.content.Context;",
            "import android.content.pm.ActivityInfo;",
            "import android.net.ConnectivityManager;",
            "import android.net.NetworkInfo;",
            "import android.opengl.GLSurfaceView;",
            "import android.os.Build;",
            "import android.view.View;",
            "import android.view.WindowManager;",
            "import com.badlogic.gdx.Gdx;",
            "import com.badlogic.gdx.backends.android.AndroidGraphics;",
            "import com.badlogic.gdx.graphics.Pixmap;",
            "import com.badlogic.gdx.graphics.g2d.PixmapPacker;",
            "import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;",
            "import com.shatteredpixel.shatteredpixeldungeon.SPDSettings;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.PixelScene;",
            "import com.watabou.noosa.Game;",
            "import com.watabou.utils.PlatformSupport;",
            "import java.util.HashMap;",
            "import java.util.regex.Matcher;",
            "import java.util.regex.Pattern;"
        ],
        "reference_api": [
            "isConnectedOrConnecting",
            "getActiveNetworkInfo",
            "isActiveNetworkMetered",
            "getSystemService",
            "getType"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "isConnectedOrConnecting",
            "getActiveNetworkInfo",
            "isActiveNetworkMetered",
            "getSystemService",
            "getType"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "protected boolean affectHero( Hero hero )",
        "start_line": "48",
        "end_line": "69",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/blobs/WaterOfHealth.java",
        "docstring": "The function affectHero(Hero hero) restores the hero's health and provides various benefits if the hero is alive. It plays a sound, cures any ailments, removes curses from equipped items, satisfies the hero's hunger, fully restores health, and displays visual effects. The function interrupts the hero's current action and logs a message, returning true if successful.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f8bd6cd4826b",
        "ground_truth": "protected boolean affectHero( Hero hero ) {\n   if (!hero.isAlive()) return false;\n   Sample.INSTANCE.play( Assets.Sounds.DRINK );\n PotionOfHealing.cure( hero );\n hero.belongings.uncurseEquipped();\n hero.buff( Hunger.class ).satisfy( Hunger.STARVING );\n hero.HP = hero.HT;\n hero.sprite.emitter().start( Speck.factory( Speck.HEALING ), 0.4f, 4 );\n hero.sprite.showStatusWithIcon(CharSprite.POSITIVE, Integer.toString(hero.HT), FloatingText.HEALING);\n   CellEmitter.get( hero.pos ).start( ShaftParticle.FACTORY, 0.2f, 3 );\n Dungeon.hero.interrupt();\n  GLog.p( Messages.get(this, \"procced\") );\n   return true;\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Assets;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Hunger;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.Hero;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.BlobEmitter;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.CellEmitter;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.FloatingText;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.Speck;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.particles.ShadowParticle;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.particles.ShaftParticle;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Ankh;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Item;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Waterskin;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.PotionOfHealing;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.ScrollOfRemoveCurse;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Notes.Landmark;",
            "import com.shatteredpixel.shatteredpixeldungeon.messages.Messages;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.CharSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.utils.GLog;",
            "import com.watabou.noosa.audio.Sample;"
        ],
        "reference_api": [
            "emitter",
            "showStatusWithIcon",
            "satisfy",
            "factory",
            "p",
            "cure",
            "toString",
            "buff",
            "interrupt",
            "get",
            "play",
            "uncurseEquipped",
            "start",
            "isAlive"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "emitter",
            "showStatusWithIcon",
            "satisfy",
            "factory",
            "p",
            "cure",
            "buff",
            "interrupt",
            "get",
            "play",
            "uncurseEquipped",
            "start",
            "isAlive"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "protected Item affectItem( Item item, int pos )",
        "start_line": "72",
        "end_line": "91",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/blobs/WaterOfHealth.java",
        "docstring": "The function affectItem(item, pos) applies special effects to the given item based on its type and state. It fills a Waterskin if not full, blesses an Ankh if not blessed, or removes curses from uncursable items, triggering visual and audio effects for each action. If no conditions are met, it returns null.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3a94f2e84c83",
        "ground_truth": "protected Item affectItem( Item item, int pos ) {\n if (item instanceof Waterskin && !((Waterskin)item).isFull()) {\n  ((Waterskin)item).fill();\n  CellEmitter.get( pos ).start( Speck.factory( Speck.HEALING ), 0.4f, 4 );\n  Sample.INSTANCE.play( Assets.Sounds.DRINK );\n  return item;\n } else if ( item instanceof Ankh && !(((Ankh) item).isBlessed())){\n  ((Ankh) item).bless();\n  CellEmitter.get( pos ).start(Speck.factory(Speck.LIGHT), 0.2f, 3);\n  Sample.INSTANCE.play( Assets.Sounds.DRINK );\n  return item;\n } else if (ScrollOfRemoveCurse.uncursable(item)) {\n  if (ScrollOfRemoveCurse.uncurse( null, item )){\n   CellEmitter.get( pos ).start( ShadowParticle.UP, 0.05f, 10 );\n  }\n  Sample.INSTANCE.play( Assets.Sounds.DRINK );\n  return item;\n }\n return null;\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Assets;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Hunger;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.Hero;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.BlobEmitter;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.CellEmitter;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.FloatingText;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.Speck;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.particles.ShadowParticle;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.particles.ShaftParticle;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Ankh;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Item;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Waterskin;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.PotionOfHealing;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.ScrollOfRemoveCurse;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Notes.Landmark;",
            "import com.shatteredpixel.shatteredpixeldungeon.messages.Messages;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.CharSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.utils.GLog;",
            "import com.watabou.noosa.audio.Sample;"
        ],
        "reference_api": [
            "uncurse",
            "factory",
            "isFull",
            "fill",
            "isBlessed",
            "get",
            "bless",
            "play",
            "start",
            "uncursable"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "uncurse",
            "factory",
            "isFull",
            "fill",
            "isBlessed",
            "get",
            "bless",
            "play",
            "start",
            "uncursable"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public static void affectAndLoot(Mob enemy, Hero hero, Class<?extends AllyBuff> buffCls)",
        "start_line": "53",
        "end_line": "76",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/buffs/AllyBuff.java",
        "docstring": "The function affectAndLoot(Mob enemy, Hero hero, Class<?extends AllyBuff> buffCls) applies a specified buff to an enemy, checks if the enemy was aligned as an enemy, and if so, rolls for loot, updates kill statistics, and processes ascension challenges. It grants experience to the hero based on level comparison and buffs the hero with additional energy if they are a Monk subclass.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d322228d1a3e",
        "ground_truth": "public static void affectAndLoot(Mob enemy, Hero hero, Class<?extends AllyBuff> buffCls){\n boolean wasEnemy = enemy.alignment == Char.Alignment.ENEMY || enemy instanceof Mimic;\n Buff.affect(enemy, buffCls);\n if (enemy.buff(buffCls) != null && wasEnemy){\n  enemy.rollToDropLoot();\n  Statistics.enemiesSlain++;\n  Badges.validateMonstersSlain();\n  Statistics.qualifiedForNoKilling = false;\n  AscensionChallenge.processEnemyKill(enemy);\n  int exp = hero.lvl <= enemy.maxLvl ? enemy.EXP : 0;\n  if (exp > 0) {\n   hero.sprite.showStatusWithIcon(CharSprite.POSITIVE, Integer.toString(exp), FloatingText.EXPERIENCE);\n  }\n  hero.earnExp(exp, enemy.getClass());\n  if (hero.subClass == HeroSubClass.MONK){\n   Buff.affect(hero, MonkEnergy.class).gainEnergy(enemy);\n  }\n }\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Statistics;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Char;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.Hero;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.HeroSubClass;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mimic;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.FloatingText;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.CharSprite;"
        ],
        "reference_api": [
            "validateMonstersSlain",
            "affect",
            "toString",
            "buff",
            "processEnemyKill",
            "gainEnergy",
            "getClass",
            "rollToDropLoot",
            "showStatusWithIcon",
            "earnExp"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "validateMonstersSlain",
            "affect",
            "buff",
            "processEnemyKill",
            "gainEnergy",
            "getClass",
            "rollToDropLoot",
            "showStatusWithIcon",
            "earnExp"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public static void processEnemyKill(Char enemy)",
        "start_line": "159",
        "end_line": "200",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/buffs/AscensionChallenge.java",
        "docstring": "The function processEnemyKill(Char enemy) handles the processing of an enemy kill within the Ascension Challenge context. It checks if the AscensionChallenge buff is active on the hero and verifies the enemy type, reverting any transformed enemies to their original state if necessary. If the enemy is valid and not boosted, it reduces the challenge stacks based on the enemy type. It also logs a weakening message if stacks drop below a threshold, grants experience if the hero is at max level, and refreshes the hero's buff indicators.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9ee21c0149f3",
        "ground_truth": "public static void processEnemyKill(Char enemy){\n AscensionChallenge chal = Dungeon.hero.buff(AscensionChallenge.class);\n if (chal == null) return;\n if (enemy instanceof Ratmogrify.TransmogRat){\n  enemy = ((Ratmogrify.TransmogRat) enemy).getOriginal();\n  if (enemy == null) return;\n }\n //only enemies that are boosted count\n if (enemy.buff(AscensionBuffBlocker.class) != null){\n  return;\n }\n boolean found = false;\n for (Class<?extends Mob> cls : modifiers.keySet()){\n  if (cls.isAssignableFrom(enemy.getClass())){\n   found = true;\n   break;\n  }\n }\n if (!found) return;\n float oldStacks = chal.stacks;\n if (enemy instanceof Ghoul || enemy instanceof RipperDemon){\n  chal.stacks -= 0.5f;\n } else {\n  chal.stacks -= 1;\n }\n chal.stacks = Math.max(0, chal.stacks);\n if (chal.stacks < 8f && (int)(chal.stacks/2) != (int)(oldStacks/2f)){\n  GLog.p(Messages.get(AscensionChallenge.class, \"weaken\"));\n }\n //if the hero is at the max level, grant them 10 effective xp per stack cleared\n // for the purposes of on-xp gain effects\n if (oldStacks > chal.stacks && Dungeon.hero.lvl == Hero.MAX_LEVEL){\n  Dungeon.hero.earnExp(Math.round(10*(oldStacks - chal.stacks)), chal.getClass());\n }\n BuffIndicator.refreshHero();\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.Statistics;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Actor;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Char;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.Hero;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.Ratmogrify;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Bat;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Brute;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Crab;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.DM100;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.DM200;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Elemental;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Eye;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Ghoul;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Gnoll;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Golem;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Guard;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Monk;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Necromancer;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Rat;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.RipperDemon;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Scorpio;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Shaman;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Skeleton;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Slime;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Snake;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Spinner;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Succubus;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Swarm;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Thief;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Warlock;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.npcs.Shopkeeper;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Amulet;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.DriedRose;",
            "import com.shatteredpixel.shatteredpixeldungeon.messages.Messages;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.BuffIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.utils.GLog;",
            "import com.watabou.noosa.Image;",
            "import com.watabou.utils.Bundle;",
            "import java.util.HashMap;"
        ],
        "reference_api": [
            "keySet",
            "isAssignableFrom",
            "p",
            "round",
            "buff",
            "refreshHero",
            "get",
            "max",
            "getClass",
            "getOriginal",
            "earnExp"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "keySet",
            "isAssignableFrom",
            "p",
            "round",
            "buff",
            "refreshHero",
            "get",
            "max",
            "getClass",
            "getOriginal",
            "earnExp"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public static int AscensionCorruptResist(Mob m)",
        "start_line": "202",
        "end_line": "228",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/buffs/AscensionChallenge.java",
        "docstring": "The function AscensionCorruptResist(Mob m) calculates the corruption resistance of a mob during an Ascension Challenge. It defaults to the mob's EXP value if no challenge is active. For transformed mobs, it uses their original form. If the mob has a buff blocking ascension effects, it returns the mob's EXP. Special cases include RipperDemons with a fixed resistance of 10, Ghouls with 7, and other specific mobs with a minimum resistance of 13 or their EXP value, whichever is higher.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4fc9c3c1fcce",
        "ground_truth": "public static int AscensionCorruptResist(Mob m){\n //default to just using their EXP value if no ascent challenge is happening\n if (Dungeon.hero.buff(AscensionChallenge.class) == null){\n  return m.EXP;\n }\n if (m instanceof Ratmogrify.TransmogRat){\n  m = ((Ratmogrify.TransmogRat) m).getOriginal();\n }\n if (m.buff(AscensionBuffBlocker.class) != null){\n  return m.EXP;\n }\n if (m instanceof RipperDemon){\n  return 10; //reduced due to their numbers\n } else if (m instanceof Ghoul){\n  return 7; //half of 13, rounded up\n } else {\n  for (Class<?extends Mob> cls : modifiers.keySet()){\n   if (cls.isAssignableFrom(m.getClass())){\n    return Math.max(13, m.EXP); //same exp as an eye\n   }\n  }\n }\n return m.EXP;\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.Statistics;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Actor;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Char;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.Hero;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.Ratmogrify;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Bat;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Brute;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Crab;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.DM100;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.DM200;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Elemental;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Eye;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Ghoul;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Gnoll;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Golem;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Guard;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Monk;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Necromancer;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Rat;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.RipperDemon;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Scorpio;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Shaman;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Skeleton;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Slime;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Snake;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Spinner;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Succubus;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Swarm;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Thief;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Warlock;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.npcs.Shopkeeper;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Amulet;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.DriedRose;",
            "import com.shatteredpixel.shatteredpixeldungeon.messages.Messages;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.BuffIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.utils.GLog;",
            "import com.watabou.noosa.Image;",
            "import com.watabou.utils.Bundle;",
            "import java.util.HashMap;"
        ],
        "reference_api": [
            "keySet",
            "isAssignableFrom",
            "buff",
            "max",
            "getClass",
            "getOriginal"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "keySet",
            "isAssignableFrom",
            "buff",
            "max",
            "getClass",
            "getOriginal"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public void hit( Char enemy )",
        "start_line": "91",
        "end_line": "113",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/buffs/Combo.java",
        "docstring": "The function hit(Char enemy) increments the combo count and sets a combo timer when the player hits an enemy. If the enemy is dead or has a Corruption buff with full health, the combo timer is extended based on the player's talent points in Cleave. It updates the initial combo time, triggers action indicators, validates mastery combos, logs the combo count, and refreshes the hero's buff indicator visually.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bdc8df5952c7",
        "ground_truth": "public void hit( Char enemy ) {\n count++;\n comboTime = 5f;\n if (!enemy.isAlive() || (enemy.buff(Corruption.class) != null && enemy.HP == enemy.HT)){\n  comboTime = Math.max(comboTime, 15*((Hero)target).pointsInTalent(Talent.CLEAVE));\n }\n initialComboTime = comboTime;\n if ((getHighestMove() != null)) {\n  ActionIndicator.setAction( this );\n  Badges.validateMasteryCombo( count );\n  GLog.p( Messages.get(this, \"combo\", count) );\n    }\n BuffIndicator.refreshHero(); //refresh the buff visually on-hit\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Assets;",
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Actor;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Char;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.Hero;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.Talent;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.DwarfKing;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.FloatingText;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.BrokenSeal;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.wands.WandOfBlastWave;",
            "import com.shatteredpixel.shatteredpixeldungeon.mechanics.Ballistica;",
            "import com.shatteredpixel.shatteredpixeldungeon.messages.Messages;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.CellSelector;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.GameScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.PixelScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.CharSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.ActionIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.AttackIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.BuffIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.HeroIcon;",
            "import com.watabou.utils.BArray;",
            "import com.shatteredpixel.shatteredpixeldungeon.utils.GLog;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndCombo;",
            "import com.watabou.noosa.BitmapText;",
            "import com.watabou.noosa.Image;",
            "import com.watabou.noosa.Visual;",
            "import com.watabou.noosa.audio.Sample;",
            "import com.watabou.utils.Bundle;",
            "import com.watabou.utils.Callback;",
            "import com.watabou.utils.PathFinder;"
        ],
        "reference_api": [
            "pointsInTalent",
            "p",
            "validateMasteryCombo",
            "buff",
            "getHighestMove",
            "setAction",
            "refreshHero",
            "get",
            "max",
            "isAlive"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getHighestMove",
                "code": "public ComboMove getHighestMove(){\n\t\tComboMove best = null;\n\t\tfor (ComboMove move : ComboMove.values()){\n\t\t\tif (count >= move.comboReq){\n\t\t\t\tbest = move;\n\t\t\t}\n\t\t}\n\t\treturn best;\n\t}"
            }
        ],
        "third_party": [
            "pointsInTalent",
            "p",
            "validateMasteryCombo",
            "buff",
            "setAction",
            "refreshHero",
            "get",
            "max",
            "isAlive"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public int capacity()",
        "start_line": "54",
        "end_line": "66",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/hero/Belongings.java",
        "docstring": "The function capacity() calculates the total capacity by starting with the base capacity, then incrementing for each Bag item in the inventory. If the hero has a secondary weapon equipped, it decrements the capacity. Finally, it returns the adjusted capacity.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "abf7c664b4dd",
        "ground_truth": "public int capacity(){\n int cap = super.capacity();\n for (Item item : items){\n  if (item instanceof Bag){\n   cap++;\n  }\n }\n if (Dungeon.hero != null && Dungeon.hero.belongings.secondWep != null){\n  //secondary weapons still occupy an inv. slot\n  cap--;\n }\n return cap;\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.GamesInProgress;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.LostInventory;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.EquipableItem;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Item;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.KindOfWeapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.KindofMisc;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.Armor;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.ClassArmor;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.Artifact;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.bags.Bag;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.Ring;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.ScrollOfRemoveCurse;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.wands.Wand;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.ItemSpriteSheet;",
            "import com.watabou.utils.Bundle;",
            "import com.watabou.utils.Random;",
            "import java.util.ArrayList;",
            "import java.util.Iterator;"
        ],
        "reference_api": [
            "capacity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "capacity",
                "code": "public int capacity(){\n\t\t\tint cap = super.capacity();\n\t\t\tfor (Item item : items){\n\t\t\t\tif (item instanceof Bag){\n\t\t\t\t\tcap++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Dungeon.hero != null && Dungeon.hero.belongings.secondWep != null){\n\t\t\t\t//secondary weapons still occupy an inv. slot\n\t\t\t\tcap--;\n\t\t\t}\n\t\t\treturn cap;\n\t\t}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public void updateHT( boolean boostHP )",
        "start_line": "235",
        "end_line": "250",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/hero/Hero.java",
        "docstring": "The function updateHT(boolean boostHP) recalculates the character's maximum health (HT) based on their level, boosts, and multipliers. It applies a base formula, adjusts for any active RingOfMight and ElixirOfMight buffs, and optionally increases current health (HP) if boostHP is true. Finally, it ensures HP does not exceed the new HT value.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b97e41e092d2",
        "ground_truth": "public void updateHT( boolean boostHP ){\n int curHT = HT;\n   HT = 20 + 5*(lvl-1) + HTBoost;\n float multiplier = RingOfMight.HTMultiplier(this);\n HT = Math.round(multiplier * HT);\n   if (buff(ElixirOfMight.HTBoost.class) != null){\n  HT += buff(ElixirOfMight.HTBoost.class).boost();\n }\n   if (boostHP){\n  HP += Math.max(HT - curHT, 0);\n }\n HP = Math.min(HP, HT);\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Assets;",
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Bones;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.GamesInProgress;",
            "import com.shatteredpixel.shatteredpixeldungeon.SPDSettings;",
            "import com.shatteredpixel.shatteredpixeldungeon.ShatteredPixelDungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.Statistics;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Actor;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Char;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.blobs.SacrificialFire;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AdrenalineSurge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AnkhInvulnerability;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.ArtifactRecharge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AscensionChallenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Awareness;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Barkskin;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Barrier;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Berserk;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Bless;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Buff;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Burning;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Charm;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Combo;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Drowsy;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Foresight;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.HoldFast;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Hunger;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Invisibility;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Levitation;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.LostInventory;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.MindVision;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Momentum;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.MonkEnergy;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Paralysis;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.PhysicalEmpower;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Recharging;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Regeneration;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.SnipersMark;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Vertigo;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.ArmorAbility;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.duelist.Challenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.duelist.ElementalStrike;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.huntress.NaturesPower;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.warrior.Endure;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mimic;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Monk;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Snake;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.CellEmitter;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.CheckedCell;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.FloatingText;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.Speck;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.SpellSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.Splash;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Ankh;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Dewdrop;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.EquipableItem;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Heap;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Heap.Type;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Item;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.KindOfWeapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.Armor;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.ClassArmor;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.AntiMagic;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.Brimstone;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.Viscosity;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.AlchemistsToolkit;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.CapeOfThorns;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.CloakOfShadows;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.DriedRose;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.EtherealChains;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.HornOfPlenty;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.MasterThievesArmband;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.TalismanOfForesight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.TimekeepersHourglass;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.bags.MagicalHolster;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.journal.Guidebook;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.CrystalKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.GoldenKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.IronKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.Key;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.SkeletonKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.Potion;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.PotionOfExperience;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.PotionOfHealing;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.elixirs.ElixirOfMight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.exotic.PotionOfDivineInspiration;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.quest.DarkGold;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.quest.Pickaxe;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfAccuracy;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfEvasion;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfForce;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfFuror;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfHaste;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfMight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfTenacity;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.Scroll;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.ScrollOfMagicMapping;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.exotic.ScrollOfChallenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.wands.Wand;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.wands.WandOfLivingEarth;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.SpiritBow;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.Weapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Flail;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.MagesStaff;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Quarterstaff;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.RoundShield;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Sai;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Scimitar;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.missiles.MissileWeapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Document;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Notes;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.Level;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.MiningLevel;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.Terrain;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.features.Chasm;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.features.LevelTransition;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.traps.Trap;",
            "import com.shatteredpixel.shatteredpixeldungeon.mechanics.Ballistica;",
            "import com.shatteredpixel.shatteredpixeldungeon.mechanics.ShadowCaster;",
            "import com.shatteredpixel.shatteredpixeldungeon.messages.Messages;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.AlchemyScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.GameScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.PixelScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.CharSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.HeroSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.AttackIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.BuffIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.QuickSlotButton;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.StatusPane;",
            "import com.shatteredpixel.shatteredpixeldungeon.utils.GLog;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndHero;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndResurrect;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndTradeItem;",
            "import com.watabou.noosa.Game;",
            "import com.watabou.noosa.audio.Sample;",
            "import com.watabou.noosa.tweeners.Delayer;",
            "import com.watabou.utils.Bundle;",
            "import com.watabou.utils.Callback;",
            "import com.watabou.utils.GameMath;",
            "import com.watabou.utils.PathFinder;",
            "import com.watabou.utils.Point;",
            "import com.watabou.utils.Random;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.LinkedHashMap;"
        ],
        "reference_api": [
            "min",
            "round",
            "HTMultiplier",
            "buff",
            "max",
            "boost"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "min",
            "round",
            "HTMultiplier",
            "buff",
            "max",
            "boost"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public boolean shoot( Char enemy, MissileWeapon wep )",
        "start_line": "442",
        "end_line": "464",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/hero/Hero.java",
        "docstring": "The function shoot(Char enemy, MissileWeapon wep) handles the action of shooting a missile weapon at an enemy. It checks if the enemy is aligned as an enemy or a neutral mimic, then attempts the attack while setting and clearing the thrown weapon. If the attack hits and the character is a Gladiator or Duelist, it applies respective buffs for combo effects. The function returns whether the attack was successful.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b72bd91544e7",
        "ground_truth": "public boolean shoot( Char enemy, MissileWeapon wep ) {\n this.enemy = enemy;\n boolean wasEnemy = enemy.alignment == Alignment.ENEMY\n   || (enemy instanceof Mimic && enemy.alignment == Alignment.NEUTRAL);\n //temporarily set the hero's weapon to the missile weapon being used\n //TODO improve this!\n belongings.thrownWeapon = wep;\n boolean hit = attack( enemy );\n Invisibility.dispel();\n belongings.thrownWeapon = null;\n if (hit && subClass == HeroSubClass.GLADIATOR && wasEnemy){\n  Buff.affect( this, Combo.class ).hit( enemy );\n }\n if (hit && heroClass == HeroClass.DUELIST && wasEnemy){\n  Buff.affect( this, Sai.ComboStrikeTracker.class).addHit();\n }\n return hit;\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Assets;",
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Bones;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.GamesInProgress;",
            "import com.shatteredpixel.shatteredpixeldungeon.SPDSettings;",
            "import com.shatteredpixel.shatteredpixeldungeon.ShatteredPixelDungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.Statistics;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Actor;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Char;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.blobs.SacrificialFire;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AdrenalineSurge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AnkhInvulnerability;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.ArtifactRecharge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AscensionChallenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Awareness;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Barkskin;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Barrier;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Berserk;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Bless;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Buff;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Burning;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Charm;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Combo;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Drowsy;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Foresight;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.HoldFast;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Hunger;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Invisibility;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Levitation;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.LostInventory;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.MindVision;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Momentum;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.MonkEnergy;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Paralysis;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.PhysicalEmpower;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Recharging;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Regeneration;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.SnipersMark;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Vertigo;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.ArmorAbility;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.duelist.Challenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.duelist.ElementalStrike;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.huntress.NaturesPower;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.warrior.Endure;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mimic;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Monk;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Snake;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.CellEmitter;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.CheckedCell;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.FloatingText;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.Speck;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.SpellSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.Splash;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Ankh;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Dewdrop;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.EquipableItem;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Heap;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Heap.Type;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Item;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.KindOfWeapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.Armor;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.ClassArmor;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.AntiMagic;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.Brimstone;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.Viscosity;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.AlchemistsToolkit;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.CapeOfThorns;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.CloakOfShadows;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.DriedRose;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.EtherealChains;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.HornOfPlenty;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.MasterThievesArmband;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.TalismanOfForesight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.TimekeepersHourglass;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.bags.MagicalHolster;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.journal.Guidebook;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.CrystalKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.GoldenKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.IronKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.Key;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.SkeletonKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.Potion;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.PotionOfExperience;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.PotionOfHealing;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.elixirs.ElixirOfMight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.exotic.PotionOfDivineInspiration;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.quest.DarkGold;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.quest.Pickaxe;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfAccuracy;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfEvasion;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfForce;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfFuror;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfHaste;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfMight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfTenacity;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.Scroll;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.ScrollOfMagicMapping;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.exotic.ScrollOfChallenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.wands.Wand;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.wands.WandOfLivingEarth;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.SpiritBow;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.Weapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Flail;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.MagesStaff;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Quarterstaff;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.RoundShield;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Sai;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Scimitar;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.missiles.MissileWeapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Document;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Notes;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.Level;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.MiningLevel;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.Terrain;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.features.Chasm;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.features.LevelTransition;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.traps.Trap;",
            "import com.shatteredpixel.shatteredpixeldungeon.mechanics.Ballistica;",
            "import com.shatteredpixel.shatteredpixeldungeon.mechanics.ShadowCaster;",
            "import com.shatteredpixel.shatteredpixeldungeon.messages.Messages;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.AlchemyScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.GameScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.PixelScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.CharSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.HeroSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.AttackIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.BuffIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.QuickSlotButton;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.StatusPane;",
            "import com.shatteredpixel.shatteredpixeldungeon.utils.GLog;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndHero;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndResurrect;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndTradeItem;",
            "import com.watabou.noosa.Game;",
            "import com.watabou.noosa.audio.Sample;",
            "import com.watabou.noosa.tweeners.Delayer;",
            "import com.watabou.utils.Bundle;",
            "import com.watabou.utils.Callback;",
            "import com.watabou.utils.GameMath;",
            "import com.watabou.utils.PathFinder;",
            "import com.watabou.utils.Point;",
            "import com.watabou.utils.Random;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.LinkedHashMap;"
        ],
        "reference_api": [
            "addHit",
            "affect",
            "dispel",
            "hit",
            "attack"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "addHit",
            "affect",
            "dispel",
            "hit",
            "attack"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "00-Evan/shattered-pixel-dungeon",
        "function_declaration": "public int attackSkill( Char target )",
        "start_line": "467",
        "end_line": "490",
        "file_path": "core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/hero/Hero.java",
        "docstring": "The function attackSkill(Char target) calculates the attack skill value against a target by considering the character's weapon, various accuracy multipliers, and any relevant buffs. It adjusts accuracy based on the weapon type, proximity to the target, and active buffs. The final attack skill value is computed by applying these factors to the base attack skill.",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f265b39b6677",
        "ground_truth": "public int attackSkill( Char target ) {\n KindOfWeapon wep = belongings.attackingWeapon();\n   float accuracy = 1;\n accuracy *= RingOfAccuracy.accuracyMultiplier( this );\n   if (wep instanceof MissileWeapon){\n  if (Dungeon.level.adjacent( pos, target.pos )) {\n   accuracy *= (0.5f + 0.2f*pointsInTalent(Talent.POINT_BLANK));\n  } else {\n   accuracy *= 1.5f;\n  }\n }\n if (buff(Scimitar.SwordDance.class) != null){\n  accuracy *= 1.50f;\n }\n   if (!RingOfForce.fightingUnarmed(this)) {\n  return (int)(attackSkill * accuracy * wep.accuracyFactor( this, target ));\n } else {\n  return (int)(attackSkill * accuracy);\n }\n}",
        "import_statements": [
            "import com.shatteredpixel.shatteredpixeldungeon.Assets;",
            "import com.shatteredpixel.shatteredpixeldungeon.Badges;",
            "import com.shatteredpixel.shatteredpixeldungeon.Bones;",
            "import com.shatteredpixel.shatteredpixeldungeon.Dungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.GamesInProgress;",
            "import com.shatteredpixel.shatteredpixeldungeon.SPDSettings;",
            "import com.shatteredpixel.shatteredpixeldungeon.ShatteredPixelDungeon;",
            "import com.shatteredpixel.shatteredpixeldungeon.Statistics;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Actor;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.Char;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.blobs.SacrificialFire;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AdrenalineSurge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AnkhInvulnerability;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.ArtifactRecharge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.AscensionChallenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Awareness;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Barkskin;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Barrier;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Berserk;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Bless;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Buff;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Burning;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Charm;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Combo;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Drowsy;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Foresight;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.HoldFast;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Hunger;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Invisibility;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Levitation;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.LostInventory;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.MindVision;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Momentum;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.MonkEnergy;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Paralysis;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.PhysicalEmpower;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Recharging;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Regeneration;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.SnipersMark;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Vertigo;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.ArmorAbility;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.duelist.Challenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.duelist.ElementalStrike;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.huntress.NaturesPower;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.hero.abilities.warrior.Endure;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mimic;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Monk;",
            "import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Snake;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.CellEmitter;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.CheckedCell;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.FloatingText;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.Speck;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.SpellSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.effects.Splash;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Ankh;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Dewdrop;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.EquipableItem;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Heap;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Heap.Type;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.Item;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.KindOfWeapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.Armor;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.ClassArmor;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.AntiMagic;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.Brimstone;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.armor.glyphs.Viscosity;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.AlchemistsToolkit;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.CapeOfThorns;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.CloakOfShadows;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.DriedRose;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.EtherealChains;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.HornOfPlenty;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.MasterThievesArmband;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.TalismanOfForesight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.TimekeepersHourglass;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.bags.MagicalHolster;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.journal.Guidebook;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.CrystalKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.GoldenKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.IronKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.Key;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.keys.SkeletonKey;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.Potion;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.PotionOfExperience;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.PotionOfHealing;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.elixirs.ElixirOfMight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.potions.exotic.PotionOfDivineInspiration;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.quest.DarkGold;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.quest.Pickaxe;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfAccuracy;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfEvasion;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfForce;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfFuror;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfHaste;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfMight;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.rings.RingOfTenacity;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.Scroll;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.ScrollOfMagicMapping;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.exotic.ScrollOfChallenge;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.wands.Wand;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.wands.WandOfLivingEarth;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.SpiritBow;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.Weapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Flail;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.MagesStaff;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Quarterstaff;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.RoundShield;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Sai;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.Scimitar;",
            "import com.shatteredpixel.shatteredpixeldungeon.items.weapon.missiles.MissileWeapon;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Document;",
            "import com.shatteredpixel.shatteredpixeldungeon.journal.Notes;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.Level;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.MiningLevel;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.Terrain;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.features.Chasm;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.features.LevelTransition;",
            "import com.shatteredpixel.shatteredpixeldungeon.levels.traps.Trap;",
            "import com.shatteredpixel.shatteredpixeldungeon.mechanics.Ballistica;",
            "import com.shatteredpixel.shatteredpixeldungeon.mechanics.ShadowCaster;",
            "import com.shatteredpixel.shatteredpixeldungeon.messages.Messages;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.AlchemyScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.GameScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.scenes.PixelScene;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.CharSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.sprites.HeroSprite;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.AttackIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.BuffIndicator;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.QuickSlotButton;",
            "import com.shatteredpixel.shatteredpixeldungeon.ui.StatusPane;",
            "import com.shatteredpixel.shatteredpixeldungeon.utils.GLog;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndHero;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndResurrect;",
            "import com.shatteredpixel.shatteredpixeldungeon.windows.WndTradeItem;",
            "import com.watabou.noosa.Game;",
            "import com.watabou.noosa.audio.Sample;",
            "import com.watabou.noosa.tweeners.Delayer;",
            "import com.watabou.utils.Bundle;",
            "import com.watabou.utils.Callback;",
            "import com.watabou.utils.GameMath;",
            "import com.watabou.utils.PathFinder;",
            "import com.watabou.utils.Point;",
            "import com.watabou.utils.Random;",
            "import java.util.ArrayList;",
            "import java.util.Collections;",
            "import java.util.LinkedHashMap;"
        ],
        "reference_api": [
            "pointsInTalent",
            "accuracyFactor",
            "buff",
            "attackingWeapon",
            "accuracyMultiplier",
            "fightingUnarmed",
            "adjacent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "pointsInTalent",
                "code": "public int pointsInTalent( Talent talent ){\n\t\tfor (LinkedHashMap<Talent, Integer> tier : talents){\n\t\t\tfor (Talent f : tier.keySet()){\n\t\t\t\tif (f == talent) return tier.get(f);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}"
            }
        ],
        "third_party": [
            "accuracyFactor",
            "buff",
            "attackingWeapon",
            "accuracyMultiplier",
            "fightingUnarmed",
            "adjacent"
        ]
    },
    {
        "subclass": "libgdx",
        "owner/repo": "libktx/ktx",
        "function_declaration": "inline fun PerformanceCounter.profile(\n  repeats: Int = if (time.mean != null) time.mean.windowSize else 10,\n  printResults: Boolean = true,\n  operation: () -> Unit,\n)",
        "start_line": "40",
        "end_line": "55",
        "file_path": "app/src/main/kotlin/ktx/app/profiling.kt",
        "docstring": "The function profile(repeats: Int, printResults: Boolean, operation: () -> Unit) inlines a performance profiling routine for a given operation. It sets up a repeat count, starts timing, executes the operation, and stops timing for each repeat. Optionally, it prints the profiling results after completion.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9e50c198348d",
        "ground_truth": "inline fun PerformanceCounter.profile(\n  repeats: Int = if (time.mean != null) time.mean.windowSize else 10,\n  printResults: Boolean = true,\n  operation: () -> Unit,\n) {\n  if (this.time.count == 0) tick()\n  repeat(repeats) {\n    this.start()\n    operation()\n    this.stop()\n    this.tick()\n  }\n  if (printResults) {\n    prettyPrint()\n  }\n}",
        "import_statements": [
            "import com.badlogic.gdx.Gdx",
            "import com.badlogic.gdx.utils.PerformanceCounter"
        ],
        "reference_api": [
            "operation",
            "repeat",
            "prettyPrint",
            "tick"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "operation",
                "code": "inline fun profile(\n  name: String = \"Profiler\",\n  repeats: Int = 10,\n  printResults: Boolean = true,\n  operation: () -> Unit,\n): PerformanceCounter {\n  val performanceCounter = PerformanceCounter(name, repeats)\n  performanceCounter.profile(repeats, printResults, operation)\n  return performanceCounter\n}"
            },
            {
                "name": "repeat",
                "code": "inline fun PerformanceCounter.profile(\n  repeats: Int = if (time.mean != null) time.mean.windowSize else 10,\n  printResults: Boolean = true,\n  operation: () -> Unit,\n) {\n  if (this.time.count == 0) tick()\n  repeat(repeats) {\n    this.start()\n    operation()\n    this.stop()\n    this.tick()\n  }\n  if (printResults) {\n    prettyPrint()\n  }\n}"
            },
            {
                "name": "prettyPrint",
                "code": "inline fun PerformanceCounter.profile(\n  repeats: Int = if (time.mean != null) time.mean.windowSize else 10,\n  printResults: Boolean = true,\n  operation: () -> Unit,\n) {\n  if (this.time.count == 0) tick()\n  repeat(repeats) {\n    this.start()\n    operation()\n    this.stop()\n    this.tick()\n  }\n  if (printResults) {\n    prettyPrint()\n  }\n}"
            },
            {
                "name": "tick",
                "code": "inline fun PerformanceCounter.profile(\n  repeats: Int = if (time.mean != null) time.mean.windowSize else 10,\n  printResults: Boolean = true,\n  operation: () -> Unit,\n) {\n  if (this.time.count == 0) tick()\n  repeat(repeats) {\n    this.start()\n    operation()\n    this.stop()\n    this.tick()\n  }\n  if (printResults) {\n    prettyPrint()\n  }\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "libgdx",
        "owner/repo": "libktx/ktx",
        "function_declaration": "inline fun <E> behaviorTree(\n  rootTask: Task<E>? = null,\n  blackboard: E? = null,\n  init: (@GdxAiDsl BehaviorTree<E>).() -> Unit = {},\n): BehaviorTree<E>",
        "start_line": "62",
        "end_line": "71",
        "file_path": "ai/src/main/kotlin/ktx/ai/behaviorTree.kt",
        "docstring": "The function behaviorTree(rootTask: Task<E>?, blackboard: E?, init: BehaviorTree<E>.() -> Unit): BehaviorTree<E> creates and initializes a behavior tree with an optional root task and blackboard. It ensures the initialization block is called exactly once and returns the configured behavior tree.",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5f6e11998a1f",
        "ground_truth": "inline fun <E> behaviorTree(\n  rootTask: Task<E>? = null,\n  blackboard: E? = null,\n  init: (@GdxAiDsl BehaviorTree<E>).() -> Unit = {},\n): BehaviorTree<E> {\n  contract { callsInPlace(init, InvocationKind.EXACTLY_ONCE) }\n  val behaviorTree = BehaviorTree(rootTask, blackboard)\n  behaviorTree.init()\n  return behaviorTree\n}",
        "import_statements": [
            "import com.badlogic.gdx.ai.btree.BehaviorTree",
            "import com.badlogic.gdx.ai.btree.Task",
            "import com.badlogic.gdx.ai.btree.branch.DynamicGuardSelector",
            "import com.badlogic.gdx.ai.btree.branch.Parallel",
            "import com.badlogic.gdx.ai.btree.branch.Parallel.Orchestrator",
            "import com.badlogic.gdx.ai.btree.branch.Parallel.Policy",
            "import com.badlogic.gdx.ai.btree.branch.RandomSelector",
            "import com.badlogic.gdx.ai.btree.branch.RandomSequence",
            "import com.badlogic.gdx.ai.btree.decorator.AlwaysFail",
            "import com.badlogic.gdx.ai.btree.decorator.AlwaysSucceed",
            "import com.badlogic.gdx.ai.btree.decorator.Include",
            "import com.badlogic.gdx.ai.btree.decorator.Invert",
            "import com.badlogic.gdx.ai.btree.decorator.Repeat",
            "import com.badlogic.gdx.ai.btree.decorator.SemaphoreGuard",
            "import com.badlogic.gdx.ai.btree.decorator.UntilFail",
            "import com.badlogic.gdx.ai.btree.decorator.UntilSuccess",
            "import com.badlogic.gdx.ai.btree.leaf.Failure",
            "import com.badlogic.gdx.ai.btree.leaf.Success",
            "import com.badlogic.gdx.ai.btree.leaf.Wait",
            "import com.badlogic.gdx.ai.utils.random.ConstantFloatDistribution",
            "import com.badlogic.gdx.ai.utils.random.ConstantIntegerDistribution",
            "import com.badlogic.gdx.ai.utils.random.FloatDistribution",
            "import com.badlogic.gdx.ai.utils.random.IntegerDistribution",
            "import com.badlogic.gdx.utils.Array",
            "import kotlin.contracts.ExperimentalContracts",
            "import kotlin.contracts.InvocationKind",
            "import kotlin.contracts.contract"
        ],
        "reference_api": [
            "callsInPlace",
            "contract",
            "BehaviorTree"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "callsInPlace",
                "code": "@OptIn(ExperimentalContracts::class)\n@GdxAiDsl\ninline fun <E> behaviorTree(\n  rootTask: Task<E>? = null,\n  blackboard: E? = null,\n  init: (@GdxAiDsl BehaviorTree<E>).() -> Unit = {},\n): BehaviorTree<E> {\n  contract { callsInPlace(init, InvocationKind.EXACTLY_ONCE) }\n  val behaviorTree = BehaviorTree(rootTask, blackboard)\n  behaviorTree.init()\n  return behaviorTree\n}"
            },
            {
                "name": "contract",
                "code": "@OptIn(ExperimentalContracts::class)\n@GdxAiDsl\ninline fun <E> behaviorTree(\n  rootTask: Task<E>? = null,\n  blackboard: E? = null,\n  init: (@GdxAiDsl BehaviorTree<E>).() -> Unit = {},\n): BehaviorTree<E> {\n  contract { callsInPlace(init, InvocationKind.EXACTLY_ONCE) }\n  val behaviorTree = BehaviorTree(rootTask, blackboard)\n  behaviorTree.init()\n  return behaviorTree\n}"
            },
            {
                "name": "BehaviorTree",
                "code": "@OptIn(ExperimentalContracts::class)\n@GdxAiDsl\ninline fun <E> behaviorTree(\n  rootTask: Task<E>? = null,\n  blackboard: E? = null,\n  init: (@GdxAiDsl BehaviorTree<E>).() -> Unit = {},\n): BehaviorTree<E> {\n  contract { callsInPlace(init, InvocationKind.EXACTLY_ONCE) }\n  val behaviorTree = BehaviorTree(rootTask, blackboard)\n  behaviorTree.init()\n  return behaviorTree\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "phaser",
        "owner/repo": "nicholas-ochoa/OpenSC2K",
        "function_declaration": "onPointerOver ()",
        "start_line": "57",
        "end_line": "79",
        "file_path": "src/cell/cell.js",
        "docstring": "The function onPointerOver() updates the selected cell coordinates in the map and highlights the current cell and its related cells by changing their tint color. It also adjusts the transparency of the cell's heightmap polygons if they exist.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cdda12e45fb9",
        "ground_truth": "onPointerOver () {\n  this.scene.city.map.selectedCell.x = this.x;\n  this.scene.city.map.selectedCell.y = this.y;\n  this.tiles.sprites.forEach((sprite) => {\n    if (sprite.visible) sprite.setTint(0xaa0000);\n  });\n  this.related.forEach((cell) => {\n    cell.tiles.sprites.forEach((sprite) => {\n      if (sprite.visible) sprite.setTint(0xaa0000);\n    });\n  });\n  if (this.tiles.heightmap) {\n    if (this.tiles.heightmap.polygon.top){\n      this.tiles.heightmap.polygon.top.fillAlpha = 0.5;\n    }\n    if (this.tiles.heightmap.polygon.slope){\n      this.tiles.heightmap.polygon.slope.fillAlpha = 0.5;\n    }\n  }\n}",
        "import_statements": [
            "./tiles",
            "../constants",
            "./position",
            "./surrounding",
            "./related"
        ],
        "reference_api": [
            "onPointerOver",
            "cell.tiles.sprites.forEach",
            "sprite.setTint",
            "this.related.forEach",
            "this.tiles.sprites.forEach"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "onPointerOver",
                "code": "onPointerOver () {\n    this.scene.city.map.selectedCell.x = this.x;\n    this.scene.city.map.selectedCell.y = this.y;\n\n    this.tiles.sprites.forEach((sprite) => {\n      if (sprite.visible) sprite.setTint(0xaa0000);\n    });\n\n    this.related.forEach((cell) => {\n      cell.tiles.sprites.forEach((sprite) => {\n        if (sprite.visible) sprite.setTint(0xaa0000);\n      });\n    });\n\n    if (this.tiles.heightmap) {\n      if (this.tiles.heightmap.polygon.top){\n        this.tiles.heightmap.polygon.top.fillAlpha = 0.5;\n      }\n      if (this.tiles.heightmap.polygon.slope){\n        this.tiles.heightmap.polygon.slope.fillAlpha = 0.5;\n      }\n    }\n  }"
            }
        ],
        "third_party": [
            "cell.tiles.sprites.forEach",
            "sprite.setTint",
            "this.related.forEach",
            "this.tiles.sprites.forEach"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "nicholas-ochoa/OpenSC2K",
        "function_declaration": "getTrafficDensity ()",
        "start_line": "22",
        "end_line": "31",
        "file_path": "src/simulation/micro/traffic.js",
        "docstring": "The function getTrafficDensity() determines traffic density based on the current value relative to predefined thresholds. It returns 'light' if the current value is between the light and heavy thresholds, 'heavy' if it is above the heavy threshold, and null if it is below the light threshold.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "850931ce3401",
        "ground_truth": "getTrafficDensity () {\n  if (this.current < this.lightThreshold)\n    return null;\n  if (this.current >= this.lightThreshold && this.current < this.heavyThreshold)\n    return 'light';\n  if (this.current >= this.heavyThreshold)\n    return 'heavy';\n}",
        "import_statements": [
            "./simulation"
        ],
        "reference_api": [
            "getTrafficDensity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getTrafficDensity",
                "code": "getTrafficDensity () {\n    if (this.current < this.lightThreshold)\n      return null;\n\n    if (this.current >= this.lightThreshold && this.current < this.heavyThreshold)\n      return 'light';\n\n    if (this.current >= this.heavyThreshold)\n      return 'heavy';\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "restart: function ()",
        "start_line": "224",
        "end_line": "244",
        "file_path": "src/animation/Animation.js",
        "docstring": "The function getTrafficDensity() returns traffic density based on the current value. It returns null if the current value is below the light threshold, 'light' if it is between the light and heavy thresholds, and 'heavy' if it is above the heavy threshold.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5958478bf873",
        "ground_truth": "restart: function ()\n{\n    this.isPlaying = true;\n    this.isFinished = false;\n    this.paused = false;\n    this.loopCount = 0;\n    this._timeLastFrame = this.game.time.deltaTotal;\n    this._timeNextFrame = this.game.time.deltaTotal + this.delay;\n    this._frameIndex = 0;\n    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n    this._parent.setFrame(this.currentFrame);\n    this._parent.animations.currentAnim = this;\n    this._parent.animations.currentFrame = this.currentFrame;\n    this.onStart.dispatch(this._parent, this);\n},",
        "import_statements": [],
        "reference_api": [
            "this._frameData.getFrame",
            "this.onStart.dispatch",
            "this._parent.setFrame"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this._frameData.getFrame",
            "this.onStart.dispatch",
            "this._parent.setFrame"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "flash: function (color, duration, force, alpha)",
        "start_line": "441",
        "end_line": "465",
        "file_path": "src/core/Camera.js",
        "docstring": "The function flash(color, duration, force, alpha) creates a flash effect on an object with specified color, duration, and transparency. It sets default values for parameters if undefined, clears any existing effect, draws a rectangle with the given color and alpha, and sets the effect duration. It returns false if certain conditions are not met, otherwise true.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d2441e586d58",
        "ground_truth": "flash: function (color, duration, force, alpha)\n{\n    if (color === undefined) { color = 0xffffff; }\n    if (duration === undefined) { duration = 500; }\n    if (force === undefined) { force = false; }\n    if (alpha === undefined) { alpha = 1; }\n    if (!this.fx || (!force && this._fxDuration > 0))\n    {\n        return false;\n    }\n    this.fx.clear();\n    this.fx.beginFill(color, alpha);\n    this.fx.drawRect(0, 0, this.width, this.height);\n    this.fx.endFill();\n    this.fx.alpha = 1;\n    this._fxDuration = duration;\n    this._fxType = 0;\n    return true;\n},",
        "import_statements": [],
        "reference_api": [
            "this.fx.drawRect",
            "this.fx.endFill",
            "this.fx.beginFill",
            "this.fx.clear"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.fx.drawRect",
            "this.fx.endFill",
            "this.fx.beginFill",
            "this.fx.clear"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "createFluidLayer: function (children, addToWorld)",
        "start_line": "145",
        "end_line": "164",
        "file_path": "src/core/FlexGrid.js",
        "docstring": "The function createFluidLayer(children, addToWorld) creates a new FlexLayer with specified fluid properties. If addToWorld is true, it adds the layer to the game world. The new layer is added to the layers list and any provided children are added to the layer. It returns the created layer.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "48b26381d975",
        "ground_truth": "createFluidLayer: function (children, addToWorld)\n{\n    if (addToWorld === undefined) { addToWorld = true; }\n    var layer = new Phaser.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);\n    if (addToWorld)\n    {\n        this.game.world.add(layer);\n    }\n    this.layers.push(layer);\n    if (children)\n    {\n        layer.addMultiple(children);\n    }\n    return layer;\n},",
        "import_statements": [],
        "reference_api": [
            "this.layers.push",
            "layer.addMultiple",
            "this.game.world.add"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.layers.push",
            "layer.addMultiple",
            "this.game.world.add"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "createFullLayer: function (children)",
        "start_line": "173",
        "end_line": "187",
        "file_path": "src/core/FlexGrid.js",
        "docstring": "The function createFullLayer(children) creates a new Phaser FlexLayer with specified position, bounds, and scale, adds it to the game world, and stores it in the layers array. If children are provided, it adds them to the new layer before returning it.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "624c9e2eb19f",
        "ground_truth": "createFullLayer: function (children)\n{\n    var layer = new Phaser.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);\n    this.game.world.add(layer);\n    this.layers.push(layer);\n    if (typeof children !== 'undefined')\n    {\n        layer.addMultiple(children);\n    }\n    return layer;\n},",
        "import_statements": [],
        "reference_api": [
            "this.layers.push",
            "layer.addMultiple",
            "this.game.world.add"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.layers.push",
            "layer.addMultiple",
            "this.game.world.add"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "crop: function (rect, copy)",
        "start_line": "49",
        "end_line": "77",
        "file_path": "src/gameobjects/components/Crop.js",
        "docstring": "The function crop(rect, copy) sets or resets the cropping rectangle for an object. If a rectangle is provided, it either updates or creates a new crop rectangle based on the copy parameter. If no rectangle is provided, it resets the cropping. It also calls updateCrop() or resetFrame() accordingly.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1c7529bca3ce",
        "ground_truth": "crop: function (rect, copy)\n{\n    if (copy === undefined) { copy = false; }\n    if (rect)\n    {\n        if (copy && this.cropRect !== null)\n        {\n            this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height);\n        }\n        else if (copy && this.cropRect === null)\n        {\n            this.cropRect = new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height);\n        }\n        else\n        {\n            this.cropRect = rect;\n        }\n        this.updateCrop();\n    }\n    else\n    {\n        this._crop = null;\n        this.cropRect = null;\n        this.resetFrame();\n    }\n},",
        "import_statements": [],
        "reference_api": [
            "this.resetFrame",
            "this.updateCrop",
            "this.cropRect.setTo"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.resetFrame",
            "this.updateCrop",
            "this.cropRect.setTo"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "move: function (x, y, wrap)",
        "start_line": "248",
        "end_line": "261",
        "file_path": "src/gameobjects/BitmapData.js",
        "docstring": "The function move(x, y, wrap) moves an object horizontally by x units and vertically by y units if the respective values are non-zero. It calls moveH for horizontal movement and moveV for vertical movement, both potentially using wrapping. The function returns the object itself.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d767b9ea9212",
        "ground_truth": "move: function (x, y, wrap)\n{\n    if (x !== 0)\n    {\n        this.moveH(x, wrap);\n    }\n    if (y !== 0)\n    {\n        this.moveV(y, wrap);\n    }\n    return this;\n},",
        "import_statements": [],
        "reference_api": [
            "this.moveV",
            "this.moveH"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.moveV",
            "this.moveH"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "Phaser.Button.prototype.changeStateFrame = function (state)",
        "start_line": "280",
        "end_line": "304",
        "file_path": "src/gameobjects/Button.js",
        "docstring": "The function Phaser.Button.prototype.changeStateFrame(state) changes the frame of a button based on its state unless frames are frozen. It determines the appropriate frame using a key based on the state, and updates the button's frame if it is a valid string or number, returning true if successful and false otherwise.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c7cf015114f3",
        "ground_truth": "Phaser.Button.prototype.changeStateFrame = function (state)\n{\n    if (this.freezeFrames)\n    {\n        return false;\n    }\n     var frameKey = '_on' + state + 'Frame';\n    var frame = this[frameKey];\n     if (typeof frame === 'string')\n    {\n        this.frameName = frame;\n        return true;\n    }\n    else if (typeof frame === 'number')\n    {\n        this.frame = frame;\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n};",
        "import_statements": [],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "weapon: function (quantity, key, frame, group, bulletClass)",
        "start_line": "67",
        "end_line": "79",
        "file_path": "src/gameobjects/GameObjectFactory.js",
        "docstring": "The function weapon(quantity, key, frame, group, bulletClass) initializes a new Phaser.Weapon plugin, optionally sets a custom bullet class, creates a specified quantity of bullets with given parameters, and returns the configured weapon instance.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e0294cb83ca3",
        "ground_truth": "weapon: function (quantity, key, frame, group, bulletClass)\n{\n    var weapon = this.game.plugins.add(Phaser.Weapon);\n    if (bulletClass)\n    {\n        weapon.bulletClass = bulletClass;\n    }\n    weapon.createBullets(quantity, key, frame, group);\n    return weapon;\n},",
        "import_statements": [],
        "reference_api": [
            "weapon.createBullets",
            "this.game.plugins.add"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "weapon.createBullets",
            "this.game.plugins.add"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "Phaser.Graphics.prototype.drawTriangle = function (points, cull)",
        "start_line": "294",
        "end_line": "316",
        "file_path": "src/gameobjects/Graphics.js",
        "docstring": "The function drawTriangle(points, cull) extends Phaser.Graphics to draw a triangle defined by given points. If culling is enabled, it calculates the face normal and only draws the triangle if it is facing the camera. Otherwise, it directly draws the triangle without culling.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2fca91787d6c",
        "ground_truth": "Phaser.Graphics.prototype.drawTriangle = function (points, cull)\n{\n    if (cull === undefined) { cull = false; }\n     var triangle = new Phaser.Polygon(points);\n     if (cull)\n    {\n        var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y);\n        var ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y);\n        var cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y);\n        var faceNormal = cb.cross(ab);\n         if (cameraToFace.dot(faceNormal) > 0)\n        {\n            this.drawPolygon(triangle);\n        }\n    }\n    else\n    {\n        this.drawPolygon(triangle);\n    }\n};",
        "import_statements": [],
        "reference_api": [
            "this.drawPolygon",
            "cb.cross",
            "cameraToFace.dot"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.drawPolygon",
            "cb.cross",
            "cameraToFace.dot"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "checkVideoProgress: function ()",
        "start_line": "1041",
        "end_line": "1064",
        "file_path": "src/gameobjects/Video.js",
        "docstring": "The function checkVideoProgress() monitors the loading state of a video. If the video is ready, it stops any pending source changes and updates the texture for playback. If not, it decrements a retry counter and sets a timeout to check progress again, warning if the video fails to start downloading within the allowed retries.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5d227ea7f97b",
        "ground_truth": "checkVideoProgress: function ()\n{\n    // if (this.video.readyState === 2 || this.video.readyState === 4)\n    if (this.video.readyState === 4)\n    {\n        this._pendingChangeSource = false;\n        //  We've got enough data to update the texture for playback\n        this.updateTexture();\n    }\n    else\n    {\n        this.retry--;\n        if (this.retry > 0)\n        {\n            this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\n        }\n        else\n        {\n            console.warn('Phaser.Video: Unable to start downloading video in time', this.isStreaming);\n        }\n    }\n},",
        "import_statements": [],
        "reference_api": [
            "console.warn",
            "window.setTimeout",
            "this.checkVideoProgress.bind",
            "this.updateTexture"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "window.setTimeout",
            "this.checkVideoProgress.bind",
            "this.updateTexture"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "start: function (event, value)",
        "start_line": "152",
        "end_line": "175",
        "file_path": "src/input/DeviceButton.js",
        "docstring": "The function start(event, value) sets the state to \"down\" if it is not already, initializes timing and repeat counters, and assigns event and value parameters. If an event is provided, it captures the state of modifier keys (alt, shift, ctrl). Finally, it dispatches an onDown event with the current state and value.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e48c3c53f00a",
        "ground_truth": "start: function (event, value)\n{\n    if (this.isDown)\n    {\n        return;\n    }\n    this.isDown = true;\n    this.isUp = false;\n    this.timeDown = this.game.time.time;\n    this.repeats = 0;\n    this.event = event;\n    this.value = value;\n    if (event)\n    {\n        this.altKey = event.altKey;\n        this.shiftKey = event.shiftKey;\n        this.ctrlKey = event.ctrlKey;\n    }\n    this.onDown.dispatch(this, value);\n},",
        "import_statements": [],
        "reference_api": [
            "this.onDown.dispatch"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.onDown.dispatch"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "onMouseDown: function (event)",
        "start_line": "257",
        "end_line": "279",
        "file_path": "src/input/Mouse.js",
        "docstring": "The function onMouseDown(event) handles mouse down events by storing the event, optionally preventing default behavior, and invoking a callback if set. If input is enabled, it initializes the mouse pointer with the event.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a2cb3bdacb1e",
        "ground_truth": "onMouseDown: function (event)\n{\n    this.event = event;\n    if (this.capture)\n    {\n        event.preventDefault();\n    }\n    if (this.mouseDownCallback)\n    {\n        this.mouseDownCallback.call(this.callbackContext, event);\n    }\n    if (!this.input.enabled || !this.enabled)\n    {\n        return;\n    }\n    event.identifier = 0;\n    this.input.mousePointer.start(event);\n},",
        "import_statements": [],
        "reference_api": [
            "event.preventDefault",
            "this.mouseDownCallback.call",
            "this.input.mousePointer.start"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "event.preventDefault",
            "this.mouseDownCallback.call",
            "this.input.mousePointer.start"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "onMouseUpGlobal: function (event)",
        "start_line": "345",
        "end_line": "358",
        "file_path": "src/input/Mouse.js",
        "docstring": "The function onMouseDown(event) handles mouse down events by storing the event, optionally preventing default behavior, and invoking a mouse down callback if defined. If input is enabled, it assigns an identifier to the event and starts the mouse pointer input process.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "88538a5b66e8",
        "ground_truth": "onMouseUpGlobal: function (event)\n{\n    if (!this.input.mousePointer.withinGame)\n    {\n        if (this.mouseUpCallback)\n        {\n            this.mouseUpCallback.call(this.callbackContext, event);\n        }\n        event.identifier = 0;\n        this.input.mousePointer.stop(event);\n    }\n},",
        "import_statements": [],
        "reference_api": [
            "this.mouseUpCallback.call",
            "this.input.mousePointer.stop"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this.mouseUpCallback.call",
            "this.input.mousePointer.stop"
        ]
    },
    {
        "subclass": "phaser",
        "owner/repo": "phaserjs/phaser-ce",
        "function_declaration": "onTouchEnter: function (event)",
        "start_line": "286",
        "end_line": "304",
        "file_path": "src/input/Touch.js",
        "docstring": "The function onTouchEnter(event) handles touch enter events by storing the event, calling a touchEnterCallback if defined, and preventing the default action if specified. It also checks if game input and the object are enabled before taking any action.",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bf8b43ab3487",
        "ground_truth": "onTouchEnter: function (event)\n{\n    this.event = event;\n    if (this.touchEnterCallback)\n    {\n        this.touchEnterCallback.call(this.callbackContext, event);\n    }\n    if (!this.game.input.enabled || !this.enabled)\n    {\n        return;\n    }\n    if (this.preventDefault)\n    {\n        event.preventDefault();\n    }\n},",
        "import_statements": [],
        "reference_api": [
            "event.preventDefault",
            "this.touchEnterCallback.call"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "event.preventDefault",
            "this.touchEnterCallback.call"
        ]
    }
]