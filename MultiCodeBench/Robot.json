[
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const",
        "start_line": "205",
        "end_line": "222",
        "file_path": "LibCarla/source/carla/client/detail/Client.cpp",
        "docstring": "This function, Client::GetRequiredFiles, retrieves a list of required files from a specified folder.\\nIf the download flag is set to true, it checks if each file exists locally.\\nIf a file is not found, it requests the file and logs the download action.\\nIf the file exists, it logs that the file is found in the cache.\\nFinally, the function returns the list of required files.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "24fd3857dd7d",
        "ground_truth": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const {\n  // Get the list of required files\n  auto requiredFiles = _pimpl->CallAndWait<std::vector<std::string>>(\"get_required_files\", folder);\n  if (download) {\n    // For each required file, check if it exists and request it otherwise\n    for (auto requiredFile : requiredFiles) {\n      if (!FileTransfer::FileExists(requiredFile)) {\n        RequestFile(requiredFile);\n        log_info(\"Could not find the required file in cache, downloading... \", requiredFile);\n      } else {\n        log_info(\"Found the required file in cache! \", requiredFile);\n      }\n    }\n  }\n  return requiredFiles;\n}",
        "import_statements": [
            "#include \"carla/client/detail/Client.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/Version.h\"\n",
            "#include \"carla/client/FileTransfer.h\"\n",
            "#include \"carla/client/TimeoutException.h\"\n",
            "#include \"carla/rpc/AckermannControllerSettings.h\"\n",
            "#include \"carla/rpc/ActorDescription.h\"\n",
            "#include \"carla/rpc/BoneTransformDataIn.h\"\n",
            "#include \"carla/rpc/Client.h\"\n",
            "#include \"carla/rpc/DebugShape.h\"\n",
            "#include \"carla/rpc/Response.h\"\n",
            "#include \"carla/rpc/VehicleAckermannControl.h\"\n",
            "#include \"carla/rpc/VehicleControl.h\"\n",
            "#include \"carla/rpc/VehicleLightState.h\"\n",
            "#include \"carla/rpc/WalkerBoneControlIn.h\"\n",
            "#include \"carla/rpc/WalkerBoneControlOut.h\"\n",
            "#include \"carla/rpc/WalkerControl.h\"\n",
            "#include \"carla/streaming/Client.h\"\n",
            "#include <rpc/rpc_error.h>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "RequestFile",
            "log_info",
            "_pimpl->CallAndWait<std::vector<std::string>>",
            "FileTransfer::FileExists"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RequestFile",
                "code": "void Client::RequestFile(const std::string &name) const {\n    // Download the binary content of the file from the server and write it on the client\n    auto content = _pimpl->CallAndWait<std::vector<uint8_t>>(\"request_file\", name);\n    FileTransfer::WriteFile(name, content);\n  }"
            }
        ],
        "third_party": [
            "log_info",
            "_pimpl->CallAndWait<std::vector<std::string>>",
            "FileTransfer::FileExists"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)",
        "start_line": "337",
        "end_line": "362",
        "file_path": "LibCarla/source/carla/client/detail/Client.cpp",
        "docstring": "This function, Client::SpawnActorWithParent, spawns an actor with a specified parent using the provided description, transform, parent ID, attachment type, and socket name.\\nIf the attachment type is SpringArm or SpringArmGhost, it checks the validity of the transformation to avoid ill-formed transformations when the translation is only in the 'z' axis and issues a warning if necessary.\\nFinally, it calls an internal function to complete the actor spawning process and returns the spawned actor.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6b9f65da12c7",
        "ground_truth": "rpc::Actor Client::SpawnActorWithParent(\n  const rpc::ActorDescription &description,\n  const geom::Transform &transform,\n  rpc::ActorId parent,\n  rpc::AttachmentType attachment_type,\n  const std::string& socket_name) {\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost)\n  {\n    const auto a = transform.location.MakeSafeUnitVector(std::numeric_limits<float>::epsilon());\n    const auto z = geom::Vector3D(0.0f, 0.f, 1.0f);\n    constexpr float OneEps = 1.0f - std::numeric_limits<float>::epsilon();\n    if (geom::Math::Dot(a, z) > OneEps) {\n      std::cout << \"WARNING: Transformations with translation only in the 'z' axis are ill-formed when \\\n        using SpringArm or SpringArmGhost attachment. Please, be careful with that.\" << std::endl;\n    }\n  }\nreturn _pimpl->CallAndWait<rpc::Actor>(\"spawn_actor_with_parent\",\n    description,\n    transform,\n    parent,\n    attachment_type,\n    socket_name);\n}",
        "import_statements": [
            "#include \"carla/client/detail/Client.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/Version.h\"\n",
            "#include \"carla/client/FileTransfer.h\"\n",
            "#include \"carla/client/TimeoutException.h\"\n",
            "#include \"carla/rpc/AckermannControllerSettings.h\"\n",
            "#include \"carla/rpc/ActorDescription.h\"\n",
            "#include \"carla/rpc/BoneTransformDataIn.h\"\n",
            "#include \"carla/rpc/Client.h\"\n",
            "#include \"carla/rpc/DebugShape.h\"\n",
            "#include \"carla/rpc/Response.h\"\n",
            "#include \"carla/rpc/VehicleAckermannControl.h\"\n",
            "#include \"carla/rpc/VehicleControl.h\"\n",
            "#include \"carla/rpc/VehicleLightState.h\"\n",
            "#include \"carla/rpc/WalkerBoneControlIn.h\"\n",
            "#include \"carla/rpc/WalkerBoneControlOut.h\"\n",
            "#include \"carla/rpc/WalkerControl.h\"\n",
            "#include \"carla/streaming/Client.h\"\n",
            "#include <rpc/rpc_error.h>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "geom::Vector3D",
            "std::numeric_limits<float>::epsilon",
            "_pimpl->CallAndWait<rpc::Actor>",
            "transform.location.MakeSafeUnitVector",
            "geom::Math::Dot"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "geom::Vector3D",
            "_pimpl->CallAndWait<rpc::Actor>",
            "transform.location.MakeSafeUnitVector",
            "geom::Math::Dot"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)",
        "start_line": "682",
        "end_line": "691",
        "file_path": "LibCarla/source/carla/client/detail/Client.cpp",
        "docstring": "This function, Client::SubscribeToGBuffer, subscribes to a G-buffer for a given ActorId and GBufferId.\\nIt retrieves a token for the G-buffer, copies the token data, and then subscribes to the streaming client using the provided callback function.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cdd344751245",
        "ground_truth": "void Client::SubscribeToGBuffer(\n    rpc::ActorId ActorId,\n    uint32_t GBufferId,\n    std::function<void(Buffer)> callback)\n{\n  std::vector<unsigned char> token_data = _pimpl->CallAndWait<std::vector<unsigned char>>(\"get_gbuffer_token\", ActorId, GBufferId);\n  streaming::Token token;\n  std::memcpy(&token.data[0u], token_data.data(), token_data.size());\n  _pimpl->streaming_client.Subscribe(token, std::move(callback));\n}",
        "import_statements": [
            "#include \"carla/client/detail/Client.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/Version.h\"\n",
            "#include \"carla/client/FileTransfer.h\"\n",
            "#include \"carla/client/TimeoutException.h\"\n",
            "#include \"carla/rpc/AckermannControllerSettings.h\"\n",
            "#include \"carla/rpc/ActorDescription.h\"\n",
            "#include \"carla/rpc/BoneTransformDataIn.h\"\n",
            "#include \"carla/rpc/Client.h\"\n",
            "#include \"carla/rpc/DebugShape.h\"\n",
            "#include \"carla/rpc/Response.h\"\n",
            "#include \"carla/rpc/VehicleAckermannControl.h\"\n",
            "#include \"carla/rpc/VehicleControl.h\"\n",
            "#include \"carla/rpc/VehicleLightState.h\"\n",
            "#include \"carla/rpc/WalkerBoneControlIn.h\"\n",
            "#include \"carla/rpc/WalkerBoneControlOut.h\"\n",
            "#include \"carla/rpc/WalkerControl.h\"\n",
            "#include \"carla/streaming/Client.h\"\n",
            "#include <rpc/rpc_error.h>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "_pimpl->CallAndWait<std::vector<unsigned char>>",
            "token_data.size",
            "std::memcpy",
            "std::move",
            "token_data.data",
            "_pimpl->streaming_client.Subscribe"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_pimpl->CallAndWait<std::vector<unsigned char>>",
            "token_data.size",
            "token_data.data",
            "_pimpl->streaming_client.Subscribe"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()",
        "start_line": "152",
        "end_line": "162",
        "file_path": "LibCarla/source/carla/client/detail/Episode.cpp",
        "docstring": "This function, Episode::CreateNavigationIfMissing, ensures a WalkerNavigation object is created if it does not already exist.\\nIt repeatedly checks if the navigation object is null, and if so, it creates a new WalkerNavigation instance and attempts to set it.\\nThe function returns the existing or newly created WalkerNavigation object.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "01180aa289fa",
        "ground_truth": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing() {\n  std::shared_ptr<WalkerNavigation> nav;\n  do {\n    nav = _walker_navigation.load();\n    if (nav == nullptr) {\n      auto new_nav = std::make_shared<WalkerNavigation>(_simulator);\n      _walker_navigation.compare_exchange(&nav, new_nav);\n    }\n  } while (nav == nullptr);\n  return nav;\n}",
        "import_statements": [
            "#include \"carla/client/detail/Episode.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/client/detail/Client.h\"\n",
            "#include \"carla/client/detail/WalkerNavigation.h\"\n",
            "#include \"carla/sensor/Deserializer.h\"\n",
            "#include \"carla/trafficmanager/TrafficManager.h\"\n",
            "#include <exception>\n"
        ],
        "reference_api": [
            "_walker_navigation.load",
            "std::make_shared<WalkerNavigation>",
            "_walker_navigation.compare_exchange"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_walker_navigation.load",
            "_walker_navigation.compare_exchange"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)",
        "start_line": "49",
        "end_line": "66",
        "file_path": "LibCarla/source/carla/client/detail/Simulator.cpp",
        "docstring": "This function, SynchronizeFrame, attempts to synchronize a given frame with the episode state within a specified timeout duration.\\nIt continuously checks if the current frame of the episode state is less than the given frame and yields control if true.\\nIf the timeout duration is exceeded, the function returns false.\\nIf synchronization is successful within the timeout, it triggers a tick in the TrafficManager and returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3f2aef3641f8",
        "ground_truth": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout) {\n  bool result = true;\n  auto start = std::chrono::system_clock::now();\n  while (frame > episode.GetState()->GetTimestamp().frame) {\n    std::this_thread::yield();\n    auto end = std::chrono::system_clock::now();\n    auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(end-start);\n    if(timeout.to_chrono() < diff) {\n      result = false;\n      break;\n    }\n  }\n  if(result) {\n    carla::traffic_manager::TrafficManager::Tick();\n  }\n  return result;\n}",
        "import_statements": [
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/Debug.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/RecurrentSharedFuture.h\"\n",
            "#include \"carla/client/BlueprintLibrary.h\"\n",
            "#include \"carla/client/FileTransfer.h\"\n",
            "#include \"carla/client/Map.h\"\n",
            "#include \"carla/client/Sensor.h\"\n",
            "#include \"carla/client/TimeoutException.h\"\n",
            "#include \"carla/client/WalkerAIController.h\"\n",
            "#include \"carla/client/detail/ActorFactory.h\"\n",
            "#include \"carla/client/detail/WalkerNavigation.h\"\n",
            "#include \"carla/trafficmanager/TrafficManager.h\"\n",
            "#include \"carla/sensor/Deserializer.h\"\n",
            "#include <exception>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "episode.GetState()->GetTimestamp",
            "std::this_thread::yield",
            "std::chrono::system_clock::now",
            "carla::traffic_manager::TrafficManager::Tick",
            "std::chrono::duration_cast<std::chrono::milliseconds>",
            "episode.GetState",
            "timeout.to_chrono"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "episode.GetState()->GetTimestamp",
            "carla::traffic_manager::TrafficManager::Tick",
            "episode.GetState",
            "timeout.to_chrono"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)",
        "start_line": "87",
        "end_line": "113",
        "file_path": "LibCarla/source/carla/client/detail/Simulator.cpp",
        "docstring": "The function Simulator::LoadEpisode loads a new episode with a specified map name, reset settings, and map layers.\\nIt attempts to connect to the new episode within a certain timeout period, checking repeatedly if the episode ID has changed.\\nIf the new episode is successfully loaded, it returns the episode object.\\nIf it fails to connect within the allowed attempts, it throws a runtime exception.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4429195cd1ee",
        "ground_truth": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers) {\n  const auto id = GetCurrentEpisode().GetId();\n  _client.LoadEpisode(std::move(map_name), reset_settings, map_layers);\n  // We are waiting 50ms for the server to reload the episode.\n  // If in this time we have not detected a change of episode, we try again\n  // 'number_of_attempts' times.\n  // TODO This time is completly arbitrary so we need to improve\n  // this pipeline to not depend in this time because this timeout\n  // could result that the client resume the simulation in different\n  // initial ticks when loading a map in syncronous mode.\n  size_t number_of_attempts = _client.GetTimeout().milliseconds() / 50u;\n  for (auto i = 0u; i < number_of_attempts; ++i) {\n    using namespace std::literals::chrono_literals;\n    if (_client.GetEpisodeSettings().synchronous_mode)\n      _client.SendTickCue();\n    _episode->WaitForState(50ms);\n    auto episode = GetCurrentEpisode();\n    if (episode.GetId() != id) {\n      return episode;\n    }\n  }\n  throw_exception(std::runtime_error(\"failed to connect to newly created map\"));\n}",
        "import_statements": [
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/Debug.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/RecurrentSharedFuture.h\"\n",
            "#include \"carla/client/BlueprintLibrary.h\"\n",
            "#include \"carla/client/FileTransfer.h\"\n",
            "#include \"carla/client/Map.h\"\n",
            "#include \"carla/client/Sensor.h\"\n",
            "#include \"carla/client/TimeoutException.h\"\n",
            "#include \"carla/client/WalkerAIController.h\"\n",
            "#include \"carla/client/detail/ActorFactory.h\"\n",
            "#include \"carla/client/detail/WalkerNavigation.h\"\n",
            "#include \"carla/trafficmanager/TrafficManager.h\"\n",
            "#include \"carla/sensor/Deserializer.h\"\n",
            "#include <exception>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "episode.GetId",
            "_client.GetEpisodeSettings",
            "GetCurrentEpisode",
            "_episode->WaitForState",
            "std::runtime_error",
            "std::move",
            "_client.LoadEpisode",
            "throw_exception",
            "GetCurrentEpisode().GetId",
            "_client.GetTimeout",
            "_client.SendTickCue",
            "_client.GetTimeout().milliseconds"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetCurrentEpisode",
                "code": "EpisodeProxy Simulator::GetCurrentEpisode() {\n    GetReadyCurrentEpisode();\n    return EpisodeProxy{shared_from_this()};\n  }"
            }
        ],
        "third_party": [
            "episode.GetId",
            "_client.GetEpisodeSettings",
            "_episode->WaitForState",
            "_client.LoadEpisode",
            "throw_exception",
            "GetCurrentEpisode().GetId",
            "_client.GetTimeout",
            "_client.SendTickCue",
            "_client.GetTimeout().milliseconds"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void Simulator::RegisterAIController(const WalkerAIController &controller)",
        "start_line": "301",
        "end_line": "310",
        "file_path": "LibCarla/source/carla/client/detail/Simulator.cpp",
        "docstring": "This function, Simulator::RegisterAIController, registers an AI controller with a walker in the simulation.\\nIt retrieves the walker associated with the controller and throws an exception if the walker is not found.\\nIt asserts that the episode is not null, creates navigation if it is missing, and registers the walker with the controller's ID.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5b517adc0516",
        "ground_truth": "void Simulator::RegisterAIController(const WalkerAIController &controller) {\n  auto walker = controller.GetParent();\n  if (walker == nullptr) {\n    throw_exception(std::runtime_error(controller.GetDisplayId() + \": not attached to walker\"));\n    return;\n  }\n  DEBUG_ASSERT(_episode != nullptr);\n  auto nav = _episode->CreateNavigationIfMissing();\n  nav->RegisterWalker(walker->GetId(), controller.GetId());\n}",
        "import_statements": [
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/Debug.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/RecurrentSharedFuture.h\"\n",
            "#include \"carla/client/BlueprintLibrary.h\"\n",
            "#include \"carla/client/FileTransfer.h\"\n",
            "#include \"carla/client/Map.h\"\n",
            "#include \"carla/client/Sensor.h\"\n",
            "#include \"carla/client/TimeoutException.h\"\n",
            "#include \"carla/client/WalkerAIController.h\"\n",
            "#include \"carla/client/detail/ActorFactory.h\"\n",
            "#include \"carla/client/detail/WalkerNavigation.h\"\n",
            "#include \"carla/trafficmanager/TrafficManager.h\"\n",
            "#include \"carla/sensor/Deserializer.h\"\n",
            "#include <exception>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "controller.GetDisplayId",
            "DEBUG_ASSERT",
            "std::runtime_error",
            "walker->GetId",
            "throw_exception",
            "controller.GetId",
            "controller.GetParent",
            "_episode->CreateNavigationIfMissing",
            "nav->RegisterWalker"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "controller.GetDisplayId",
            "DEBUG_ASSERT",
            "walker->GetId",
            "throw_exception",
            "controller.GetId",
            "controller.GetParent",
            "_episode->CreateNavigationIfMissing",
            "nav->RegisterWalker"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)",
        "start_line": "345",
        "end_line": "375",
        "file_path": "LibCarla/source/carla/client/detail/Simulator.cpp",
        "docstring": "This function, Simulator::SpawnActor, spawns an actor in the simulation using a specified blueprint and transform.\\nIf a parent actor is provided, it spawns the new actor as a child of the parent with a specified attachment type and socket name.\\nOtherwise, it spawns the actor independently.\\nThe function registers the new actor in the current episode, applies the appropriate garbage collection policy, and logs the creation details.\\nFinally, it returns a shared pointer to the newly created actor.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4bf89f90fc59",
        "ground_truth": "SharedPtr<Actor> Simulator::SpawnActor(\n  const ActorBlueprint &blueprint,\n  const geom::Transform &transform,\n  Actor *parent,\n  rpc::AttachmentType attachment_type,\n  GarbageCollectionPolicy gc,\n  const std::string& socket_name) {\nrpc::Actor actor;\nif (parent != nullptr) {\n  actor = _client.SpawnActorWithParent(\n      blueprint.MakeActorDescription(),\n      transform,\n      parent->GetId(),\n      attachment_type,\n      socket_name);\n} else {\n  actor = _client.SpawnActor(\n      blueprint.MakeActorDescription(),\n      transform);\n}\nDEBUG_ASSERT(_episode != nullptr);\n_episode->RegisterActor(actor);\nconst auto gca = (gc == GarbageCollectionPolicy::Inherit ? _gc_policy : gc);\nauto result = ActorFactory::MakeActor(GetCurrentEpisode(), actor, gca);\nlog_debug(\n    result->GetDisplayId(),\n    \"created\",\n    gca == GarbageCollectionPolicy::Enabled ? \"with\" : \"without\",\n    \"garbage collection\");\nreturn result;\n}",
        "import_statements": [
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/Debug.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/RecurrentSharedFuture.h\"\n",
            "#include \"carla/client/BlueprintLibrary.h\"\n",
            "#include \"carla/client/FileTransfer.h\"\n",
            "#include \"carla/client/Map.h\"\n",
            "#include \"carla/client/Sensor.h\"\n",
            "#include \"carla/client/TimeoutException.h\"\n",
            "#include \"carla/client/WalkerAIController.h\"\n",
            "#include \"carla/client/detail/ActorFactory.h\"\n",
            "#include \"carla/client/detail/WalkerNavigation.h\"\n",
            "#include \"carla/trafficmanager/TrafficManager.h\"\n",
            "#include \"carla/sensor/Deserializer.h\"\n",
            "#include <exception>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "GetCurrentEpisode",
            "result->GetDisplayId",
            "blueprint.MakeActorDescription",
            "DEBUG_ASSERT",
            "parent->GetId",
            "_episode->RegisterActor",
            "_client.SpawnActor",
            "log_debug",
            "ActorFactory::MakeActor",
            "_client.SpawnActorWithParent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetCurrentEpisode",
                "code": "EpisodeProxy Simulator::GetCurrentEpisode() {\n    GetReadyCurrentEpisode();\n    return EpisodeProxy{shared_from_this()};\n  }"
            }
        ],
        "third_party": [
            "result->GetDisplayId",
            "blueprint.MakeActorDescription",
            "DEBUG_ASSERT",
            "parent->GetId",
            "_episode->RegisterActor",
            "_client.SpawnActor",
            "log_debug",
            "ActorFactory::MakeActor",
            "_client.SpawnActorWithParent"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)",
        "start_line": "394",
        "end_line": "405",
        "file_path": "LibCarla/source/carla/client/detail/Simulator.cpp",
        "docstring": "This function, Simulator::SubscribeToSensor, subscribes to a sensor's data stream and sets up a callback to handle the incoming sensor data.\\nIt first ensures that the episode is valid, then subscribes to the sensor's data stream using the client's SubscribeToStream method.\\nThe callback is set to deserialize the incoming data, associate it with the current episode, and then invoke the provided callback with the sensor data.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "120588756f18",
        "ground_truth": "void Simulator::SubscribeToSensor(\n    const Sensor &sensor,\n    std::function<void(SharedPtr<sensor::SensorData>)> callback) {\n  DEBUG_ASSERT(_episode != nullptr);\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [cb=std::move(callback), ep=WeakEpisodeProxy{shared_from_this()}](auto buffer) {\n        auto data = sensor::Deserializer::Deserialize(std::move(buffer));\n        data->_episode = ep.TryLock();\n        cb(std::move(data));\n      });\n}",
        "import_statements": [
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/Debug.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/RecurrentSharedFuture.h\"\n",
            "#include \"carla/client/BlueprintLibrary.h\"\n",
            "#include \"carla/client/FileTransfer.h\"\n",
            "#include \"carla/client/Map.h\"\n",
            "#include \"carla/client/Sensor.h\"\n",
            "#include \"carla/client/TimeoutException.h\"\n",
            "#include \"carla/client/WalkerAIController.h\"\n",
            "#include \"carla/client/detail/ActorFactory.h\"\n",
            "#include \"carla/client/detail/WalkerNavigation.h\"\n",
            "#include \"carla/trafficmanager/TrafficManager.h\"\n",
            "#include \"carla/sensor/Deserializer.h\"\n",
            "#include <exception>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "_client.SubscribeToStream",
            "shared_from_this",
            "DEBUG_ASSERT",
            "std::move",
            "sensor::Deserializer::Deserialize",
            "ep.TryLock",
            "cb",
            "sensor.GetActorDescription().GetStreamToken",
            "sensor.GetActorDescription"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_client.SubscribeToStream",
            "shared_from_this",
            "DEBUG_ASSERT",
            "sensor::Deserializer::Deserialize",
            "ep.TryLock",
            "cb",
            "sensor.GetActorDescription().GetStreamToken",
            "sensor.GetActorDescription"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)",
        "start_line": "33",
        "end_line": "81",
        "file_path": "LibCarla/source/carla/client/detail/WalkerNavigation.cpp",
        "docstring": "This function, WalkerNavigation::Tick, performs several actions on walkers in a simulation episode.\\nIt first loads the current walkers and checks if the list is empty, returning if so.\\nIt retrieves the current state of the episode and removes any walkers that no longer exist.\\nThe function updates the vehicles in the crowd and the crowd itself in the navigation module.\\nFor each walker, it gets their transform and speed, then applies these states in a batch to the simulator.\\nFinally, it checks if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a8ef7cb73186",
        "ground_truth": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode) {\n  auto walkers = _walkers.Load();\n  if (walkers->empty()) {\n    return;\n  }\n  // get current state\n  std::shared_ptr<const EpisodeState> state = episode->GetState();\n  // purge all possible dead walkers\n  CheckIfWalkerExist(*walkers, *state);\n  // add/update/delete all vehicles in crowd\n  UpdateVehiclesInCrowd(episode, false);\n  // update crowd in navigation module\n  _nav.UpdateCrowd(*state);\n  carla::geom::Transform trans;\n  using Cmd = rpc::Command;\n  std::vector<Cmd> commands;\n  commands.reserve(walkers->size());\n  for (auto handle : *walkers) {\n    // get the transform of the walker\n    if (_nav.GetWalkerTransform(handle.walker, trans)) {\n      float speed = _nav.GetWalkerSpeed(handle.walker);\n      commands.emplace_back(Cmd::ApplyWalkerState{ handle.walker, trans, speed });\n    }\n  }\n  _simulator.lock()->ApplyBatchSync(std::move(commands), false);\n  // check if any agent has been killed\n  bool alive;\n  for (auto handle : *walkers) {\n    // get the agent state\n    if (_nav.IsWalkerAlive(handle.walker, alive)) {\n      if (!alive) {\n        _simulator.lock()->SetActorCollisions(handle.walker, true);\n        _simulator.lock()->SetActorDead(handle.walker);\n        // remove from the crowd\n        _nav.RemoveAgent(handle.walker);\n        // destroy the controller\n        _simulator.lock()->DestroyActor(handle.controller);\n        // unregister from list\n        UnregisterWalker(handle.walker, handle.controller);\n      }\n    }\n  }\n}",
        "import_statements": [
            "#include \"carla/client/detail/WalkerNavigation.h\"\n",
            "#include \"carla/client/detail/Client.h\"\n",
            "#include \"carla/client/detail/Episode.h\"\n",
            "#include \"carla/client/detail/EpisodeState.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/nav/Navigation.h\"\n",
            "#include \"carla/rpc/Command.h\"\n",
            "#include \"carla/rpc/DebugShape.h\"\n",
            "#include \"carla/rpc/WalkerControl.h\"\n",
            "#include <sstream>\n"
        ],
        "reference_api": [
            "_walkers.Load",
            "_nav.GetWalkerSpeed",
            "commands.emplace_back",
            "_nav.IsWalkerAlive",
            "_simulator.lock()->SetActorCollisions",
            "UpdateVehiclesInCrowd",
            "CheckIfWalkerExist",
            "_simulator.lock()->SetActorDead",
            "_nav.UpdateCrowd",
            "std::move",
            "walkers->size",
            "_nav.GetWalkerTransform",
            "commands.reserve",
            "_simulator.lock",
            "_nav.RemoveAgent",
            "UnregisterWalker",
            "_simulator.lock()->DestroyActor",
            "episode->GetState",
            "_simulator.lock()->ApplyBatchSync",
            "walkers->empty"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "UpdateVehiclesInCrowd",
                "code": "void WalkerNavigation::UpdateVehiclesInCrowd(std::shared_ptr<Episode> episode, bool show_debug) {\n    std::vector<carla::nav::VehicleCollisionInfo> vehicles;\n\n    // get current state\n    std::shared_ptr<const EpisodeState> state = episode->GetState();\n\n    // get all vehicles from episode\n    for (auto &&actor : episode->GetActors()) {\n      // only vehicles\n      if (actor.description.id.rfind(\"vehicle.\", 0) == 0) {\n        // get the snapshot\n        ActorSnapshot snapshot = state->GetActorSnapshot(actor.id);\n        // add to the vector\n        vehicles.emplace_back(carla::nav::VehicleCollisionInfo{actor.id, snapshot.transform, actor.bounding_box});\n      }\n    }\n\n    // update the vehicles found\n    _nav.UpdateVehicles(vehicles);\n\n    // optional debug info\n    if (show_debug) {\n      if (_nav.GetCrowd() == nullptr) return;\n\n      // draw bounding boxes for debug\n      for (int i = 0; i < _nav.GetCrowd()->getAgentCount(); ++i) {\n        // get the agent\n        const dtCrowdAgent *agent = _nav.GetCrowd()->getAgent(i);\n        if (agent && agent->params.useObb) {\n          // draw for debug\n          carla::geom::Location p1, p2, p3, p4;\n          p1.x = agent->params.obb[0];\n          p1.z = agent->params.obb[1];\n          p1.y = agent->params.obb[2];\n          p2.x = agent->params.obb[3];\n          p2.z = agent->params.obb[4];\n          p2.y = agent->params.obb[5];\n          p3.x = agent->params.obb[6];\n          p3.z = agent->params.obb[7];\n          p3.y = agent->params.obb[8];\n          p4.x = agent->params.obb[9];\n          p4.z = agent->params.obb[10];\n          p4.y = agent->params.obb[11];\n          carla::rpc::DebugShape line1;\n          line1.life_time = 0.01f;\n          line1.persistent_lines = false;\n          // line 1\n          line1.primitive = carla::rpc::DebugShape::Line {p1, p2, 0.2f};\n          line1.color = { 0, 255, 0 };\n          _simulator.lock()->DrawDebugShape(line1);\n          // line 2\n          line1.primitive = carla::rpc::DebugShape::Line {p2, p3, 0.2f};\n          line1.color = { 255, 0, 0 };\n          _simulator.lock()->DrawDebugShape(line1);\n          // line 3\n          line1.primitive = carla::rpc::DebugShape::Line {p3, p4, 0.2f};\n          line1.color = { 0, 0, 255 };\n          _simulator.lock()->DrawDebugShape(line1);\n          // line 4\n          line1.primitive = carla::rpc::DebugShape::Line {p4, p1, 0.2f};\n          line1.color = { 255, 255, 0 };\n          _simulator.lock()->DrawDebugShape(line1);\n        }\n      }\n\n      // draw some text for debug\n      for (int i = 0; i < _nav.GetCrowd()->getAgentCount(); ++i) {\n        // get the agent\n        const dtCrowdAgent *agent = _nav.GetCrowd()->getAgent(i);\n        if (agent) {\n          // draw for debug\n          carla::geom::Location p1(agent->npos[0], agent->npos[2], agent->npos[1] + 1);\n          if (agent->params.userData) {\n            std::ostringstream out;\n            out << *(reinterpret_cast<const float *>(agent->params.userData));\n            carla::rpc::DebugShape text;\n            text.life_time = 0.01f;\n            text.persistent_lines = false;\n            text.primitive = carla::rpc::DebugShape::String {p1, out.str(), false};\n            text.color = { 0, 255, 0 };\n            _simulator.lock()->DrawDebugShape(text);\n          }\n        }\n      }\n    }\n  }"
            },
            {
                "name": "CheckIfWalkerExist",
                "code": "void WalkerNavigation::CheckIfWalkerExist(std::vector<WalkerHandle> walkers, const EpisodeState &state) {\n\n    // check with total\n    if (_next_check_index >= walkers.size())\n      _next_check_index = 0;\n\n    // check the existence\n    if (!state.ContainsActorSnapshot(walkers[_next_check_index].walker)) {\n      // remove from the crowd\n      _nav.RemoveAgent(walkers[_next_check_index].walker);\n      // destroy the controller\n      _simulator.lock()->DestroyActor(walkers[_next_check_index].controller);\n      // unregister from list\n      UnregisterWalker(walkers[_next_check_index].walker, walkers[_next_check_index].controller);\n    }\n\n    ++_next_check_index;\n\n  }"
            }
        ],
        "third_party": [
            "_walkers.Load",
            "_nav.GetWalkerSpeed",
            "commands.emplace_back",
            "_nav.IsWalkerAlive",
            "_simulator.lock()->SetActorCollisions",
            "_simulator.lock()->SetActorDead",
            "_nav.UpdateCrowd",
            "walkers->size",
            "_nav.GetWalkerTransform",
            "commands.reserve",
            "_simulator.lock",
            "_nav.RemoveAgent",
            "UnregisterWalker",
            "_simulator.lock()->DestroyActor",
            "episode->GetState",
            "_simulator.lock()->ApplyBatchSync",
            "walkers->empty"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const",
        "start_line": "54",
        "end_line": "63",
        "file_path": "LibCarla/source/carla/client/ActorBlueprint.cpp",
        "docstring": "This function, ActorBlueprint::MakeActorDescription, creates an rpc::ActorDescription object.\\nIt initializes the description with the UID and ID of the actor.\\nIt then reserves space for the attributes and copies each attribute from the ActorBlueprint to the description.\\nFinally, it returns the fully constructed rpc::ActorDescription object.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "89785106fdc3",
        "ground_truth": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const {\n  rpc::ActorDescription description;\n  description.uid = _uid;\n  description.id = _id;\n  description.attributes.reserve(_attributes.size());\n  for (const auto &attribute : *this) {\n    description.attributes.push_back(attribute);\n  }\n  return description;\n}",
        "import_statements": [
            "#include \"carla/client/ActorBlueprint.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include \"carla/StringUtil.h\"\n",
            "#include <algorithm>\n"
        ],
        "reference_api": [
            "_attributes.size",
            "description.attributes.push_back",
            "description.attributes.reserve"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_attributes.size",
            "description.attributes.push_back",
            "description.attributes.reserve"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const",
        "start_line": "36",
        "end_line": "65",
        "file_path": "LibCarla/source/carla/client/BlueprintLibrary.cpp",
        "docstring": "This function, BlueprintLibrary::FilterByAttribute, filters blueprints by a specified attribute name and value.\\nIt iterates through the blueprints, checks if the attribute exists, and compares its value or recommended values to the specified value.\\nMatching blueprints are added to the result.\\nFinally, it returns a new BlueprintLibrary containing the filtered blueprints.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "34df2bcf0cec",
        "ground_truth": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n    const std::string &name, const std::string& value) const {\n  map_type result;\n  for (auto &pair : _blueprints) {\n    if (!pair.second.ContainsAttribute(name))\n      continue;\n    const ActorAttribute &Attribute = pair.second.GetAttribute(name);\n    const std::vector<std::string> &Values = Attribute.GetRecommendedValues();\n    if (Values.empty())\n    {\n      const std::string &AttributeValue = Attribute.GetValue();\n      if (value == AttributeValue)\n        result.emplace(pair);\n    }\n    else\n    {\n      for (const std::string &Value : Values)\n      {\n        if (Value == value)\n        {\n          result.emplace(pair);\n          break;\n        }\n      }\n    }\n  }\n  return SharedPtr<BlueprintLibrary>{new BlueprintLibrary(result)};\n}",
        "import_statements": [
            "#include \"carla/client/BlueprintLibrary.h\"\n",
            "#include \"carla/Exception.h\"\n",
            "#include <algorithm>\n",
            "#include <iterator>\n"
        ],
        "reference_api": [
            "Values.empty",
            "Attribute.GetRecommendedValues",
            "pair.second.ContainsAttribute",
            "result.emplace",
            "Attribute.GetValue",
            "pair.second.GetAttribute"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Values.empty",
            "Attribute.GetRecommendedValues",
            "pair.second.ContainsAttribute",
            "result.emplace",
            "Attribute.GetValue",
            "pair.second.GetAttribute"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)",
        "start_line": "46",
        "end_line": "67",
        "file_path": "LibCarla/source/carla/client/FIleTransfer.cpp",
        "docstring": "This function, FileTransfer::WriteFile, writes a given content to a specified path.\\nIt constructs the full file path using a base folder and version information, validates the file path, and opens the file in binary mode to truncate its contents.\\nIf the file is successfully opened, it writes the content and closes the file, returning true.\\nIf the file cannot be opened, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6514a623a4e4",
        "ground_truth": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content) {\n  std::string writePath = _filesBaseFolder;\n  writePath += \"/\";\n  writePath += ::carla::version();\n  writePath += \"/\";\n  writePath += path;\n  // Validate and create the file path\n  carla::FileSystem::ValidateFilePath(writePath);\n  // Open the file to truncate it in binary mode\n  std::ofstream out(writePath, std::ios::trunc | std::ios::binary);\n  if(!out.good()) return false;\n  // Write the content on and close it\n  for(auto file : content) {\n        out << file;\n  }\n  out.close();\n  return true;\n}",
        "import_statements": [
            "#include \"FileTransfer.h\"\n",
            "#include \"carla/Version.h\"\n"
        ],
        "reference_api": [
            "out.good",
            "carla::FileSystem::ValidateFilePath",
            "out.close",
            "::carla::version"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "out.good",
            "carla::FileSystem::ValidateFilePath",
            "out.close",
            "::carla::version"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const",
        "start_line": "125",
        "end_line": "136",
        "file_path": "LibCarla/source/carla/client/LaneInvasionSensor.cpp",
        "docstring": "This function, LaneInvasionCallback::MakeBounds, creates a bounding box for a given frame and transform.\\nIt calculates the location by adding the parent's bounding box location to the transform's location.\\nIt then computes the four corners of the bounding box by rotating the extents based on the yaw angle.\\nFinally, it returns a shared pointer to a Bounds object containing the frame number and the calculated corners.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d4e7e6a9bb84",
        "ground_truth": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n    const size_t frame,\n    const geom::Transform &transform) const {\n  const auto &box = _parent_bounding_box;\n  const auto location = transform.location + box.location;\n  const auto yaw = transform.rotation.yaw;\n  return std::make_shared<Bounds>(Bounds{frame, {\n      location + Rotate(yaw, geom::Location( box.extent.x,  box.extent.y, 0.0f)),\n      location + Rotate(yaw, geom::Location(-box.extent.x,  box.extent.y, 0.0f)),\n      location + Rotate(yaw, geom::Location( box.extent.x, -box.extent.y, 0.0f)),\n      location + Rotate(yaw, geom::Location(-box.extent.x, -box.extent.y, 0.0f))}});\n}",
        "import_statements": [
            "#include \"carla/client/LaneInvasionSensor.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/client/Map.h\"\n",
            "#include \"carla/client/Vehicle.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/geom/Location.h\"\n",
            "#include \"carla/geom/Math.h\"\n",
            "#include \"carla/sensor/data/LaneInvasionEvent.h\"\n",
            "#include <exception>\n"
        ],
        "reference_api": [
            "Rotate",
            "geom::Location",
            "std::make_shared<Bounds>"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Rotate",
                "code": "static geom::Location Rotate(float yaw, const geom::Location &location) {\n    yaw *= geom::Math::Pi<float>() / 180.0f;\n    const float c = std::cos(yaw);\n    const float s = std::sin(yaw);\n    return {\n        c * location.x - s * location.y,\n        s * location.x + c * location.y,\n        location.z};\n  }"
            }
        ],
        "third_party": [
            "geom::Location"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void LightManager::QueryLightsStateToServer()",
        "start_line": "273",
        "end_line": "294",
        "file_path": "LibCarla/source/carla/client/LightManager.cpp",
        "docstring": "This function, LightManager::QueryLightsStateToServer, queries the current state of lights from the server.\\nIt locks a mutex to ensure thread safety and retrieves the light states from the server.\\nIt then updates the local light states and creates new light objects if they do not already exist in the _lights map.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "88c28ecd93f2",
        "ground_truth": "void LightManager::QueryLightsStateToServer() {\n  std::lock_guard<std::mutex> lock(_mutex);\n  // Send blocking query\n  std::vector<rpc::LightState> lights_snapshot = _episode.Lock()->QueryLightsStateToServer();\n   // Update lights\n  SharedPtr<LightManager> lm = _episode.Lock()->GetLightManager();\n   for(const auto& it : lights_snapshot) {\n    _lights_state[it._id] = LightState(\n        it._intensity,\n        Color(it._color.r, it._color.g, it._color.b),\n        static_cast<LightState::LightGroup>(it._group),\n        it._active\n    );\n     if(_lights.find(it._id) == _lights.end())\n    {\n      _lights[it._id] = Light(lm, it._location, it._id);\n    }\n  }\n}",
        "import_statements": [
            "#include \"carla/client/LightManager.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n"
        ],
        "reference_api": [
            "_episode.Lock",
            "Color",
            "static_cast<LightState::LightGroup>",
            "_episode.Lock()->GetLightManager",
            "_lights.end",
            "_lights.find",
            "LightState",
            "_episode.Lock()->QueryLightsStateToServer",
            "Light"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_episode.Lock",
            "Color",
            "static_cast<LightState::LightGroup>",
            "_episode.Lock()->GetLightManager",
            "_lights.end",
            "_lights.find",
            "LightState",
            "_episode.Lock()->QueryLightsStateToServer",
            "Light"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void LightManager::UpdateServerLightsState(bool discard_client)",
        "start_line": "296",
        "end_line": "321",
        "file_path": "LibCarla/source/carla/client/LightManager.cpp",
        "docstring": "This function, LightManager::UpdateServerLightsState, updates the server with the current state of lights if there have been changes.\\nIt locks a mutex to ensure thread safety and checks if there are any changes.\\nIf there are, it creates a message containing the updated light states and sends it to the server.\\nAfter updating, it clears the changes and resets the dirty flag.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4fa452091640",
        "ground_truth": "void LightManager::UpdateServerLightsState(bool discard_client) {\n  std::lock_guard<std::mutex> lock(_mutex);\n   if(_dirty) {\n    std::vector<rpc::LightState> message;\n    for(auto it : _lights_changes) {\n      auto it_light = _lights.find(it.first);\n      if(it_light != _lights.end()) {\n        rpc::LightState state(\n          it_light->second.GetLocation(),\n          it.second._intensity,\n          it.second._group,\n          rpc::Color(it.second._color.r, it.second._color.g, it.second._color.b),\n          it.second._active\n        );\n        state._id = it.first;\n        // Add to command\n        message.push_back(state);\n      }\n    }\n    _episode.Lock()->UpdateServerLightsState(message, discard_client);\n     _lights_changes.clear();\n    _dirty = false;\n  }\n}",
        "import_statements": [
            "#include \"carla/client/LightManager.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n"
        ],
        "reference_api": [
            "_episode.Lock",
            "it_light->second.GetLocation",
            "rpc::Color",
            "_episode.Lock()->UpdateServerLightsState",
            "_lights.end",
            "_lights.find",
            "_lights_changes.clear",
            "message.push_back"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_episode.Lock",
            "it_light->second.GetLocation",
            "rpc::Color",
            "_episode.Lock()->UpdateServerLightsState",
            "_lights.end",
            "_lights.find",
            "_lights_changes.clear",
            "message.push_back"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void ServerSideSensor::Send(std::string message)",
        "start_line": "58",
        "end_line": "66",
        "file_path": "LibCarla/source/carla/client/ServerSideSensor.cpp",
        "docstring": "This function, ServerSideSensor::Send, logs a debug message when called.\\nIt checks if the sensor's ID is \"sensor.other.v2x_custom\" and logs a warning if it is not, then returns.\\nIf the sensor's ID matches, it sends a message to the episode using the sensor's context.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "55f2a92d098d",
        "ground_truth": "void ServerSideSensor::Send(std::string message) {\n  log_debug(\"calling sensor Send() \", GetDisplayId());\n  if (GetActorDescription().description.id != \"sensor.other.v2x_custom\")\n  {\n    log_warning(\"Send methods are not supported on non-V2x sensors (sensor.other.v2x_custom).\");\n    return;\n  }\n  GetEpisode().Lock()->Send(*this,message);\n}",
        "import_statements": [
            "#include \"carla/client/ServerSideSensor.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include <exception>\n"
        ],
        "reference_api": [
            "GetActorDescription",
            "GetEpisode().Lock",
            "log_debug",
            "GetEpisode",
            "GetEpisode().Lock()->Send",
            "GetDisplayId",
            "log_warning"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GetActorDescription",
            "GetEpisode().Lock",
            "log_debug",
            "GetEpisode",
            "GetEpisode().Lock()->Send",
            "GetDisplayId",
            "log_warning"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)",
        "start_line": "38",
        "end_line": "45",
        "file_path": "LibCarla/source/carla/client/Vehicle.cpp",
        "docstring": "This function, Vehicle::SetAutopilot, enables or disables the autopilot for a vehicle.\\nIt takes a boolean flag and a traffic manager port number as parameters.\\nIf the flag is true, it registers the vehicle with the traffic manager.\\nIf the flag is false, it unregisters the vehicle from the traffic manager.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "15ad3fa28627",
        "ground_truth": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port) {\n  TM tm(GetEpisode(), tm_port);\n  if (enabled) {\n    tm.RegisterVehicles({shared_from_this()});\n  } else {\n    tm.UnregisterVehicles({shared_from_this()});\n  }\n}",
        "import_statements": [
            "#include \"carla/client/Vehicle.h\"\n",
            "#include \"carla/client/ActorList.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/client/TrafficLight.h\"\n",
            "#include \"carla/Memory.h\"\n",
            "#include \"carla/rpc/TrafficLightState.h\"\n",
            "#include \"carla/trafficmanager/TrafficManager.h\"\n"
        ],
        "reference_api": [
            "tm.RegisterVehicles",
            "shared_from_this",
            "tm.UnregisterVehicles"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "tm.RegisterVehicles",
            "shared_from_this",
            "tm.UnregisterVehicles"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void WalkerAIController::Start()",
        "start_line": "18",
        "end_line": "32",
        "file_path": "LibCarla/source/carla/client/WalkerAIController.cpp",
        "docstring": "This function, WalkerAIController::Start, registers the AI controller with the episode.\\nIt retrieves the walker actor and adds it to the navigation system with its current location.\\nIt then disables the physics simulation and collisions for the walker actor.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d47601663346",
        "ground_truth": "void WalkerAIController::Start() {\n  GetEpisode().Lock()->RegisterAIController(*this);\n  // add the walker in the Recast & Detour\n  auto walker = GetParent();\n  if (walker != nullptr) {\n    auto nav = GetEpisode().Lock()->GetNavigation();\n    if (nav != nullptr) {\n      nav->AddWalker(walker->GetId(), walker->GetLocation());\n      // disable physics and collision of walker actor\n      GetEpisode().Lock()->SetActorSimulatePhysics(*walker, false);\n      GetEpisode().Lock()->SetActorCollisions(*walker, false);\n    }\n  }\n}",
        "import_statements": [
            "#include \"carla/client/WalkerAIController.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/client/detail/WalkerNavigation.h\"\n"
        ],
        "reference_api": [
            "nav->AddWalker",
            "GetEpisode().Lock()->SetActorCollisions",
            "walker->GetLocation",
            "GetEpisode().Lock()->RegisterAIController",
            "GetEpisode().Lock",
            "walker->GetId",
            "GetEpisode().Lock()->SetActorSimulatePhysics",
            "GetParent",
            "GetEpisode",
            "GetEpisode().Lock()->GetNavigation"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "nav->AddWalker",
            "GetEpisode().Lock()->SetActorCollisions",
            "walker->GetLocation",
            "GetEpisode().Lock()->RegisterAIController",
            "GetEpisode().Lock",
            "walker->GetId",
            "GetEpisode().Lock()->SetActorSimulatePhysics",
            "GetParent",
            "GetEpisode",
            "GetEpisode().Lock()->GetNavigation"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void WalkerAIController::SetMaxSpeed(const float max_speed)",
        "start_line": "69",
        "end_line": "81",
        "file_path": "LibCarla/source/carla/client/WalkerAIController.cpp",
        "docstring": "This function, WalkerAIController::SetMaxSpeed, sets the maximum speed for a walker.\\nIt retrieves the navigation instance from the current episode and checks if it is valid.\\nIf valid, it retrieves the parent walker and attempts to set its maximum speed using the navigation instance.\\nIf setting the speed fails or the walker is not found, appropriate warning messages are logged.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d35f70145bed",
        "ground_truth": "void WalkerAIController::SetMaxSpeed(const float max_speed) {\n  auto nav = GetEpisode().Lock()->GetNavigation();\n  if (nav != nullptr) {\n    auto walker = GetParent();\n    if (walker != nullptr) {\n      if (!nav->SetWalkerMaxSpeed(walker->GetId(), max_speed)) {\n        log_warning(\"NAV: failed to set max speed\");\n      }\n    } else {\n      log_warning(\"NAV: failed to set max speed (parent does not exist)\");\n    }\n  }\n}",
        "import_statements": [
            "#include \"carla/client/WalkerAIController.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/client/detail/WalkerNavigation.h\"\n"
        ],
        "reference_api": [
            "GetEpisode().Lock",
            "walker->GetId",
            "GetParent",
            "GetEpisode",
            "GetEpisode().Lock()->GetNavigation",
            "nav->SetWalkerMaxSpeed",
            "log_warning"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GetEpisode().Lock",
            "walker->GetId",
            "GetParent",
            "GetEpisode",
            "GetEpisode().Lock()->GetNavigation",
            "nav->SetWalkerMaxSpeed",
            "log_warning"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const",
        "start_line": "60",
        "end_line": "68",
        "file_path": "LibCarla/source/carla/client/Waypoint.cpp",
        "docstring": "This function, Waypoint::GetPrevious, retrieves previous waypoints at a specified distance.\\nIt calls the parent map to get the previous waypoints and stores them in a vector.\\nFor each retrieved waypoint, it creates a new Waypoint object and adds it to the result vector.\\nFinally, it returns the vector of SharedPtr<Waypoint> objects.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "97c4d0a8b802",
        "ground_truth": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const {\n  auto waypoints = _parent->GetMap().GetPrevious(_waypoint, distance);\n  std::vector<SharedPtr<Waypoint>> result;\n  result.reserve(waypoints.size());\n  for (auto &waypoint : waypoints) {\n    result.emplace_back(SharedPtr<Waypoint>(new Waypoint(_parent, std::move(waypoint))));\n  }\n  return result;\n}",
        "import_statements": [
            "#include \"carla/client/Waypoint.h\"\n",
            "#include \"carla/client/Map.h\"\n",
            "#include \"carla/client/Junction.h\"\n",
            "#include \"carla/client/Landmark.h\"\n",
            "#include <unordered_set>\n"
        ],
        "reference_api": [
            "result.emplace_back",
            "waypoints.size",
            "SharedPtr<Waypoint>",
            "std::move",
            "_parent->GetMap().GetPrevious",
            "result.reserve",
            "_parent->GetMap"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "result.emplace_back",
            "waypoints.size",
            "SharedPtr<Waypoint>",
            "_parent->GetMap().GetPrevious",
            "result.reserve",
            "_parent->GetMap"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const",
        "start_line": "218",
        "end_line": "234",
        "file_path": "LibCarla/source/carla/client/Waypoint.cpp",
        "docstring": "This function, Waypoint::GetAllLandmarksInDistance, retrieves all landmarks within a specified distance from the waypoint.\\nIt calls GetSignalsInDistance to get the signals and checks for repeated signals to avoid duplicates.\\nFor each unique signal, it creates a new Waypoint and Landmark, adding them to the result.\\nFinally, it returns a vector of SharedPtr<Landmark> objects representing the landmarks found within the distance.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3f789cd118c7",
        "ground_truth": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n    double distance, bool stop_at_junction) const {\n  std::vector<SharedPtr<Landmark>> result;\n  auto signals = _parent->GetMap().GetSignalsInDistance(\n      _waypoint, distance, stop_at_junction);\n  std::unordered_set<const road::element::RoadInfoSignal*> added_signals; // check for repeated signals\n  for(auto &signal_data : signals){\n    if(added_signals.count(signal_data.signal) > 0) {\n      continue;\n    }\n    added_signals.insert(signal_data.signal);\n    auto waypoint = SharedPtr<Waypoint>(new Waypoint(_parent, signal_data.waypoint));\n    result.emplace_back(\n        new Landmark(waypoint, _parent, signal_data.signal, signal_data.accumulated_s));\n  }\n  return result;\n}",
        "import_statements": [
            "#include \"carla/client/Waypoint.h\"\n",
            "#include \"carla/client/Map.h\"\n",
            "#include \"carla/client/Junction.h\"\n",
            "#include \"carla/client/Landmark.h\"\n",
            "#include <unordered_set>\n"
        ],
        "reference_api": [
            "result.emplace_back",
            "SharedPtr<Waypoint>",
            "_parent->GetMap().GetSignalsInDistance",
            "_parent->GetMap",
            "added_signals.insert",
            "added_signals.count"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "result.emplace_back",
            "SharedPtr<Waypoint>",
            "_parent->GetMap().GetSignalsInDistance",
            "_parent->GetMap",
            "added_signals.insert",
            "added_signals.count"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)",
        "start_line": "56",
        "end_line": "84",
        "file_path": "LibCarla/source/carla/client/World.cpp",
        "docstring": "This function, World::ApplySettings, applies the provided episode settings to the world and returns a unique identifier.\\nIt sets a local timeout based on the provided timeout or the episode's networking timeout.\\nIf the settings include a fixed delta time, it attempts to verify the accuracy of this setting over a series of ticks.\\nIf the setting is not correctly applied after a number of attempts, a warning is logged.\\nFinally, it returns the identifier of the applied settings.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e71bab655973",
        "ground_truth": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout) {\n  rpc::EpisodeSettings new_settings = settings;\n  uint64_t id = _episode.Lock()->SetEpisodeSettings(settings);\n  time_duration local_timeout = timeout.milliseconds() == 0 ?\n      _episode.Lock()->GetNetworkingTimeout() : timeout;\n  if (settings.fixed_delta_seconds.has_value()) {\n    using namespace std::literals::chrono_literals;\n    const auto number_of_attemps = 30u;\n    uint64_t tics_correct = 0;\n    for (auto i = 0u; i < number_of_attemps; i++) {\n      const auto curr_snapshot = GetSnapshot();\n      const double error = abs(new_settings.fixed_delta_seconds.get() - curr_snapshot.GetTimestamp().delta_seconds);\n      if (error < std::numeric_limits<float>::epsilon())\n        tics_correct++;\n      if (tics_correct >= 2)\n        return id;\n      Tick(local_timeout);\n    }\n    log_warning(\"World::ApplySettings: After\", number_of_attemps, \" attemps, the settings were not correctly set. Please check that everything is consistent.\");\n  }\n  return id;\n}",
        "import_statements": [
            "#include \"carla/client/World.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/client/Actor.h\"\n",
            "#include \"carla/client/ActorBlueprint.h\"\n",
            "#include \"carla/client/ActorList.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/StringUtil.h\"\n",
            "#include \"carla/road/SignalType.h\"\n",
            "#include \"carla/road/Junction.h\"\n",
            "#include \"carla/client/TrafficLight.h\"\n",
            "#include <exception>\n"
        ],
        "reference_api": [
            "GetSnapshot",
            "Tick",
            "_episode.Lock()->GetNetworkingTimeout",
            "_episode.Lock",
            "timeout.milliseconds",
            "curr_snapshot.GetTimestamp",
            "std::numeric_limits<float>::epsilon",
            "_episode.Lock()->SetEpisodeSettings",
            "abs",
            "new_settings.fixed_delta_seconds.get",
            "settings.fixed_delta_seconds.has_value",
            "log_warning"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "GetSnapshot",
                "code": "WorldSnapshot World::GetSnapshot() const {\n    return _episode.Lock()->GetWorldSnapshot();\n  }"
            },
            {
                "name": "Tick",
                "code": "uint64_t World::Tick(time_duration timeout) {\n    time_duration local_timeout = timeout.milliseconds() == 0 ?\n        _episode.Lock()->GetNetworkingTimeout() : timeout;\n    return _episode.Lock()->Tick(local_timeout);\n  }"
            }
        ],
        "third_party": [
            "_episode.Lock()->GetNetworkingTimeout",
            "_episode.Lock",
            "timeout.milliseconds",
            "curr_snapshot.GetTimestamp",
            "_episode.Lock()->SetEpisodeSettings",
            "new_settings.fixed_delta_seconds.get",
            "settings.fixed_delta_seconds.has_value",
            "log_warning"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "std::pair<float, float> Math::DistanceSegmentToPoint",
        "start_line": "18",
        "end_line": "31",
        "file_path": "LibCarla/source/carla/geom/Math.cpp",
        "docstring": "This function, Math::DistanceSegmentToPoint, calculates the shortest distance from a point to a line segment in 2D space.\\nIt first computes the squared length of the segment and its length.\\nIf the segment length is zero, it returns zero and the distance from the point to one endpoint.\\nOtherwise, it projects the point onto the segment, clamps the projection, and returns the distance along the segment and the distance from the projection to the point.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2dee4d311009",
        "ground_truth": "std::pair<float, float> Math::DistanceSegmentToPoint(\n    const Vector3D &p,\n    const Vector3D &v,\n    const Vector3D &w) {\n  const float l2 = DistanceSquared2D(v, w);\n  const float l = std::sqrt(l2);\n  if (l2 == 0.0f) {\n    return std::make_pair(0.0f, Distance2D(v, p));\n  }\n  const float dot_p_w = Dot2D(p - v, w - v);\n  const float t = Clamp(dot_p_w / l2);\n  const Vector3D projection = v + t * (w - v);\n  return std::make_pair(t * l, Distance2D(projection, p));\n}",
        "import_statements": [
            "#include \"carla/geom/Math.h\"\n",
            "#include \"carla/geom/Rotation.h\"\n"
        ],
        "reference_api": [
            "Distance2D",
            "Clamp",
            "std::sqrt",
            "DistanceSquared2D",
            "std::make_pair",
            "Dot2D"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Distance2D",
            "Clamp",
            "DistanceSquared2D",
            "Dot2D"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)",
        "start_line": "76",
        "end_line": "87",
        "file_path": "LibCarla/source/carla/geom/Mesh.cpp",
        "docstring": "This function, Mesh::AddTriangleFan, adds a triangle fan to the mesh using a provided list of vertices.\\nIt first asserts that there are at least three vertices.\\nIt then records the initial index and adds the vertices to the mesh.\\nThe function iteratively adds indices to form triangles, connecting the initial vertex with each subsequent pair of vertices in the list.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ded98caeb2fc",
        "ground_truth": "void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices) {\n  DEBUG_ASSERT(vertices.size() >= 3);\n  const size_t initial_index = GetVerticesNum() + 1;\n  size_t i = GetVerticesNum() + 2;\n  AddVertices(vertices);\n  while (i < GetVerticesNum()) {\n    AddIndex(initial_index);\n    AddIndex(i);\n    AddIndex(i + 1);\n    ++i;\n  }\n}",
        "import_statements": [
            "#include <carla/geom/Mesh.h>\n",
            "#include <string>\n",
            "#include <sstream>\n",
            "#include <ios>\n",
            "#include <iostream>\n",
            "#include <fstream>\n",
            "#include <carla/geom/Math.h>\n"
        ],
        "reference_api": [
            "AddVertices",
            "GetVerticesNum",
            "DEBUG_ASSERT",
            "vertices.size",
            "AddIndex"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "AddVertices",
                "code": "void Mesh::AddVertices(const std::vector<Mesh::vertex_type> &vertices) {\n    std::copy(vertices.begin(), vertices.end(), std::back_inserter(_vertices));\n  }"
            },
            {
                "name": "GetVerticesNum",
                "code": "size_t Mesh::GetVerticesNum() const {\n    return _vertices.size();\n  }"
            },
            {
                "name": "AddIndex",
                "code": "void Mesh::AddIndex(index_type index) {\n    _indexes.push_back(index);\n  }"
            }
        ],
        "third_party": [
            "DEBUG_ASSERT",
            "vertices.size"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)",
        "start_line": "68",
        "end_line": "96",
        "file_path": "LibCarla/source/carla/multigpu/primary.cpp",
        "docstring": "This function, Primary::Write, sends a message using asynchronous write operations.\\nIt first ensures the message is valid and then posts a lambda function to the strand for execution.\\nWithin the lambda, it checks if the socket is open, sets a timeout, and initiates an asynchronous write.\\nThe handle_sent lambda handles the result, logging errors and closing the connection if needed.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e563ae11ea5a",
        "ground_truth": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(!message->empty());\n  std::weak_ptr<Primary> weak = shared_from_this();\n  boost::asio::post(_strand, [=]() {\n    auto self = weak.lock();\n    if (!self) return;\n    if (!self->_socket.is_open()) {\n      return;\n    }\n    auto handle_sent = [weak, message](const boost::system::error_code &ec, size_t DEBUG_ONLY(bytes)) {\n      auto self = weak.lock();\n      if (!self) return;\n      if (ec) {\n        log_error(\"session \", self->_session_id, \": error sending data: \", ec.message());\n        self->CloseNow(ec);\n      } else {\n        // DEBUG_ASSERT_EQ(bytes, sizeof(message_size_type) + message->size());\n      }\n    };\n    self->_deadline.expires_from_now(self->_timeout);\n    boost::asio::async_write(\n        self->_socket,\n        message->GetBufferSequence(),\n        boost::asio::bind_executor(self->_strand, handle_sent));\n  });\n}",
        "import_statements": [
            "#include \"carla/multigpu/primary.h\"\n",
            "#include \"carla/Debug.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/multigpu/incomingMessage.h\"\n",
            "#include \"carla/multigpu/listener.h\"\n",
            "#include <boost/asio/read.hpp>\n",
            "#include <boost/asio/write.hpp>\n",
            "#include <boost/asio/bind_executor.hpp>\n",
            "#include <boost/asio/post.hpp>\n",
            "#include <atomic>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "boost::asio::post",
            "message->empty",
            "self->CloseNow",
            "shared_from_this",
            "log_error",
            "DEBUG_ASSERT",
            "boost::asio::bind_executor",
            "ec.message",
            "self->_deadline.expires_from_now",
            "message->GetBufferSequence",
            "weak.lock",
            "self->_socket.is_open",
            "boost::asio::async_write"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "boost::asio::post",
            "message->empty",
            "self->CloseNow",
            "shared_from_this",
            "log_error",
            "DEBUG_ASSERT",
            "boost::asio::bind_executor",
            "ec.message",
            "self->_deadline.expires_from_now",
            "message->GetBufferSequence",
            "weak.lock",
            "self->_socket.is_open",
            "boost::asio::async_write"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void Primary::CloseNow(boost::system::error_code ec)",
        "start_line": "203",
        "end_line": "215",
        "file_path": "LibCarla/source/carla/multigpu/primary.cpp",
        "docstring": "This function, Primary::CloseNow, handles closing a socket connection.\\nIt first cancels the deadline timer.\\nIf no error code is provided and the socket is open, it attempts to shut down and close the socket.\\nAfterwards, it triggers the on_closed callback and logs that the session has been closed.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "152dbc61bfef",
        "ground_truth": "void Primary::CloseNow(boost::system::error_code ec) {\n  _deadline.cancel();\n  if (!ec)\n  {\n    if (_socket.is_open()) {\n      boost::system::error_code ec2;\n      _socket.shutdown(boost::asio::socket_base::shutdown_both, ec2);\n      _socket.close();\n    }\n  }\n  _on_closed(shared_from_this());\n  log_debug(\"session\", _session_id, \"closed\");\n}",
        "import_statements": [
            "#include \"carla/multigpu/primary.h\"\n",
            "#include \"carla/Debug.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/multigpu/incomingMessage.h\"\n",
            "#include \"carla/multigpu/listener.h\"\n",
            "#include <boost/asio/read.hpp>\n",
            "#include <boost/asio/write.hpp>\n",
            "#include <boost/asio/bind_executor.hpp>\n",
            "#include <boost/asio/post.hpp>\n",
            "#include <atomic>\n",
            "#include <thread>\n"
        ],
        "reference_api": [
            "_socket.shutdown",
            "_socket.close",
            "shared_from_this",
            "_socket.is_open",
            "_on_closed",
            "log_debug",
            "_deadline.cancel"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_socket.shutdown",
            "_socket.close",
            "shared_from_this",
            "_socket.is_open",
            "_on_closed",
            "log_debug",
            "_deadline.cancel"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void PrimaryCommands::SendIsAlive()",
        "start_line": "57",
        "end_line": "64",
        "file_path": "LibCarla/source/carla/multigpu/primaryCommands.cpp",
        "docstring": "This function, PrimaryCommands::SendIsAlive, sends a message \"Are you alive?\" to check if the system is responsive.\\nIt creates a buffer from the message, logs the sending action, and writes the buffer to the next router with the command YOU_ALIVE.\\nThe function then waits for and logs the response from the system.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3d3ca7907fca",
        "ground_truth": "void PrimaryCommands::SendIsAlive() {\n  std::string msg(\"Are you alive?\");\n  carla::Buffer buf((unsigned char *) msg.c_str(), (size_t) msg.size());\n  log_info(\"sending is alive command\");\n  auto fut = _router->WriteToNext(MultiGPUCommand::YOU_ALIVE, std::move(buf));\n  auto response = fut.get();\n  log_info(\"response from alive command: \", response.buffer.data());\n}",
        "import_statements": [
            "#include \"carla/multigpu/primaryCommands.h\"\n",
            "#include \"carla/multigpu/commands.h\"\n",
            "#include \"carla/multigpu/primary.h\"\n",
            "#include \"carla/multigpu/router.h\"\n",
            "#include \"carla/streaming/detail/tcp/Message.h\"\n",
            "#include \"carla/streaming/detail/Token.h\"\n",
            "#include \"carla/streaming/detail/Types.h\"\n"
        ],
        "reference_api": [
            "msg.size",
            "response.buffer.data",
            "fut.get",
            "std::move",
            "log_info",
            "_router->WriteToNext",
            "msg.c_str"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "msg.size",
            "response.buffer.data",
            "fut.get",
            "log_info",
            "_router->WriteToNext",
            "msg.c_str"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)",
        "start_line": "66",
        "end_line": "79",
        "file_path": "LibCarla/source/carla/multigpu/primaryCommands.cpp",
        "docstring": "This function, PrimaryCommands::SendEnableForROS, checks if a sensor has been activated on any secondary server.\\nIf found, it creates a buffer with the sensor ID and sends an ENABLE_ROS command to the server using the router.\\nIt then waits for and processes the server's response.\\nIf the sensor is not found on any server, it logs an error message.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "234b198bb14e",
        "ground_truth": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id) {\n  // search if the sensor has been activated in any secondary server\n  auto it = _servers.find(sensor_id);\n  if (it != _servers.end()) {\n    carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                      (size_t) sizeof(stream_id));\n    auto fut = _router->WriteToOne(it->second, MultiGPUCommand::ENABLE_ROS, std::move(buf));\n     auto response = fut.get();\n    bool res = (*reinterpret_cast<bool *>(response.buffer.data()));\n  } else {\n    log_error(\"enable_for_ros for sensor\", sensor_id, \" not found on any server\");\n  }\n}",
        "import_statements": [
            "#include \"carla/multigpu/primaryCommands.h\"\n",
            "#include \"carla/multigpu/commands.h\"\n",
            "#include \"carla/multigpu/primary.h\"\n",
            "#include \"carla/multigpu/router.h\"\n",
            "#include \"carla/streaming/detail/tcp/Message.h\"\n",
            "#include \"carla/streaming/detail/Token.h\"\n",
            "#include \"carla/streaming/detail/Types.h\"\n"
        ],
        "reference_api": [
            "reinterpret_cast<bool *>",
            "_router->WriteToOne",
            "response.buffer.data",
            "fut.get",
            "log_error",
            "_servers.find",
            "std::move",
            "_servers.end"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "reinterpret_cast<bool *>",
            "_router->WriteToOne",
            "response.buffer.data",
            "fut.get",
            "log_error",
            "_servers.find",
            "_servers.end"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "token_type PrimaryCommands::GetToken(stream_id sensor_id)",
        "start_line": "113",
        "end_line": "131",
        "file_path": "LibCarla/source/carla/multigpu/primaryCommands.cpp",
        "docstring": "This function, PrimaryCommands::GetToken, retrieves a token for a given sensor_id.\\nIt first checks if the sensor is already activated and if so, returns the existing token, logging the action.\\nIf the sensor is not activated, it enables the sensor on a secondary server, retrieves a new token, updates the maps, logs the action, and returns the new token.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "76bb90fe6a09",
        "ground_truth": "token_type PrimaryCommands::GetToken(stream_id sensor_id) {\n  // search if the sensor has been activated in any secondary server\n  auto it = _tokens.find(sensor_id);\n  if (it != _tokens.end()) {\n    // return already activated sensor token\n    log_debug(\"Using token from already activated sensor: \", it->second.get_stream_id(), \", \", it->second.get_port());\n    return it->second;\n  }\n  else {\n    // enable the sensor on one secondary server\n    auto server = _router->GetNextServer();\n    auto token = SendGetToken(sensor_id);\n    // add to the maps\n    _tokens[sensor_id] = token;\n    _servers[sensor_id] = server;\n    log_debug(\"Using token from new activated sensor: \", token.get_stream_id(), \", \", token.get_port());\n    return token;\n  }\n}",
        "import_statements": [
            "#include \"carla/multigpu/primaryCommands.h\"\n",
            "#include \"carla/multigpu/commands.h\"\n",
            "#include \"carla/multigpu/primary.h\"\n",
            "#include \"carla/multigpu/router.h\"\n",
            "#include \"carla/streaming/detail/tcp/Message.h\"\n",
            "#include \"carla/streaming/detail/Token.h\"\n",
            "#include \"carla/streaming/detail/Types.h\"\n"
        ],
        "reference_api": [
            "_tokens.find",
            "_router->GetNextServer",
            "SendGetToken",
            "token.get_port",
            "it->second.get_port",
            "token.get_stream_id",
            "log_debug",
            "_tokens.end",
            "it->second.get_stream_id"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "SendGetToken",
                "code": "token_type PrimaryCommands::SendGetToken(stream_id sensor_id) {\n  log_info(\"asking for a token\");\n  carla::Buffer buf((carla::Buffer::value_type *) &sensor_id,\n                    (size_t) sizeof(stream_id));\n  auto fut = _router->WriteToNext(MultiGPUCommand::GET_TOKEN, std::move(buf));\n\n  auto response = fut.get();\n  token_type new_token(*reinterpret_cast<carla::streaming::detail::token_data *>(response.buffer.data()));\n  log_info(\"got a token: \", new_token.get_stream_id(), \", \", new_token.get_port());\n  return new_token;\n}"
            }
        ],
        "third_party": [
            "_tokens.find",
            "_router->GetNextServer",
            "token.get_port",
            "it->second.get_port",
            "token.get_stream_id",
            "log_debug",
            "_tokens.end",
            "it->second.get_stream_id"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "bool Navigation::Load(const std::string &filename)",
        "start_line": "83",
        "end_line": "97",
        "file_path": "LibCarla/source/carla/nav/Navigation.cpp",
        "docstring": "This function, Navigation::Load, loads a file specified by the filename.\\nIt opens the file in binary mode and reads its entire content into a vector.\\nIf the file cannot be opened, it returns false.\\nAfter reading, it closes the file and parses the content by calling another Load function with the file data.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8c99bd334140",
        "ground_truth": "bool Navigation::Load(const std::string &filename) {\n  std::ifstream f;\n  std::istream_iterator<uint8_t> start(f), end;\n  // read the whole file\n  f.open(filename, std::ios::binary);\n  if (!f.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> content(start, end);\n  f.close();\n  // parse the content\n  return Load(std::move(content));\n}",
        "import_statements": [
            "#include <cmath>\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/nav/Navigation.h\"\n",
            "#include \"carla/nav/WalkerManager.h\"\n",
            "#include \"carla/geom/Math.h\"\n",
            "#include <iterator>\n",
            "#include <fstream>\n",
            "#include <mutex>\n"
        ],
        "reference_api": [
            "f.is_open",
            "Load",
            "std::move",
            "f.open",
            "f.close"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Load",
                "code": "bool Navigation::Load(const std::string &filename) {\n    std::ifstream f;\n    std::istream_iterator<uint8_t> start(f), end;\n\n    // read the whole file\n    f.open(filename, std::ios::binary);\n    if (!f.is_open()) {\n      return false;\n    }\n    std::vector<uint8_t> content(start, end);\n    f.close();\n\n    // parse the content\n    return Load(std::move(content));\n  }"
            }
        ],
        "third_party": [
            "f.is_open",
            "f.open",
            "f.close"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "bool Navigation::RemoveAgent(ActorId id)",
        "start_line": "663",
        "end_line": "706",
        "file_path": "LibCarla/source/carla/nav/Navigation.cpp",
        "docstring": "This function, Navigation::RemoveAgent, attempts to remove an agent identified by id from the navigation system.\\nIt first checks if the system is ready and asserts the crowd object is not null.\\nIt then searches for the agent id in the walker and vehicle mappings.\\nIf found, it enters a critical section to safely remove the agent from the crowd, updates the walker or vehicle manager, and removes the id from the mappings.\\nThe function returns true if the agent is successfully removed, otherwise false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1026c106ca90",
        "ground_truth": "bool Navigation::RemoveAgent(ActorId id) {\n  // check if all is ready\n  if (!_ready) {\n    return false;\n  }\n  DEBUG_ASSERT(_crowd != nullptr);\n  // get the internal walker index\n  auto it = _mapped_walkers_id.find(id);\n  if (it != _mapped_walkers_id.end()) {\n    // remove from crowd\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      _crowd->removeAgent(it->second);\n    }\n    _walker_manager.RemoveWalker(id);\n    // remove from mapping\n    _mapped_walkers_id.erase(it);\n    _mapped_by_index.erase(it->second);\n    return true;\n  }\n  // get the internal vehicle index\n  it = _mapped_vehicles_id.find(id);\n  if (it != _mapped_vehicles_id.end()) {\n    // remove from crowd\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      _crowd->removeAgent(it->second);\n    }\n    // remove from mapping\n    _mapped_vehicles_id.erase(it);\n    _mapped_by_index.erase(it->second);\n    return true;\n  }\n  return false;\n}",
        "import_statements": [
            "#include <cmath>\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/nav/Navigation.h\"\n",
            "#include \"carla/nav/WalkerManager.h\"\n",
            "#include \"carla/geom/Math.h\"\n",
            "#include <iterator>\n",
            "#include <fstream>\n",
            "#include <mutex>\n"
        ],
        "reference_api": [
            "_crowd->removeAgent",
            "_mapped_vehicles_id.find",
            "_mapped_vehicles_id.end",
            "_mapped_walkers_id.find",
            "_walker_manager.RemoveWalker",
            "DEBUG_ASSERT",
            "_mapped_walkers_id.erase",
            "_mapped_walkers_id.end",
            "_mapped_by_index.erase",
            "_mapped_vehicles_id.erase"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_crowd->removeAgent",
            "_mapped_vehicles_id.find",
            "_mapped_vehicles_id.end",
            "_mapped_walkers_id.find",
            "_walker_manager.RemoveWalker",
            "DEBUG_ASSERT",
            "_mapped_walkers_id.erase",
            "_mapped_walkers_id.end",
            "_mapped_by_index.erase",
            "_mapped_vehicles_id.erase"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)",
        "start_line": "709",
        "end_line": "732",
        "file_path": "LibCarla/source/carla/nav/Navigation.cpp",
        "docstring": "This function, Navigation::UpdateVehicles, updates the state of vehicles based on a provided vector of VehicleCollisionInfo.\\nIt first collects the IDs of currently mapped vehicles into a set.\\nThen, it adds or updates vehicles from the provided list, marking them as updated.\\nVehicles not marked as updated are removed, indicating they do not exist in the current frame.\\nThe function returns true upon completion.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bba5a06a03fb",
        "ground_truth": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles) {\n  std::unordered_set<carla::rpc::ActorId> updated;\n  // add all current mapped vehicles in the set\n  for (auto &&entry : _mapped_vehicles_id) {\n    updated.insert(entry.first);\n  }\n  // add all vehicles (if already exists, it gets updated only)\n  for (auto &&entry : vehicles) {\n    // try to add or update the vehicle\n    AddOrUpdateVehicle(entry);\n    // mark as updated (to avoid removing it in this frame)\n    updated.erase(entry.id);\n  }\n  // remove all vehicles not updated (they don't exist in this frame)\n  for (auto &&entry : updated) {\n    // remove agent not updated\n    RemoveAgent(entry);\n  }\n  return true;\n}",
        "import_statements": [
            "#include <cmath>\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/nav/Navigation.h\"\n",
            "#include \"carla/nav/WalkerManager.h\"\n",
            "#include \"carla/geom/Math.h\"\n",
            "#include <iterator>\n",
            "#include <fstream>\n",
            "#include <mutex>\n"
        ],
        "reference_api": [
            "updated.insert",
            "AddOrUpdateVehicle",
            "updated.erase",
            "RemoveAgent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "AddOrUpdateVehicle",
                "code": "bool Navigation::AddOrUpdateVehicle(VehicleCollisionInfo &vehicle) {\n    namespace cg = carla::geom;\n    dtCrowdAgentParams params;\n\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // get the bounding box extension plus some space around\n    float marge = 0.8f;\n    float hx = vehicle.bounding.extent.x + marge;\n    float hy = vehicle.bounding.extent.y + marge;\n    // define the 4 corners of the bounding box\n    cg::Vector3D box_corner1 {-hx, -hy, 0};\n    cg::Vector3D box_corner2 { hx + 0.2f, -hy, 0};\n    cg::Vector3D box_corner3 { hx + 0.2f,  hy, 0};\n    cg::Vector3D box_corner4 {-hx,  hy, 0};\n    // rotate the points\n    float angle = cg::Math::ToRadians(vehicle.transform.rotation.yaw);\n    box_corner1 = cg::Math::RotatePointOnOrigin2D(box_corner1, angle);\n    box_corner2 = cg::Math::RotatePointOnOrigin2D(box_corner2, angle);\n    box_corner3 = cg::Math::RotatePointOnOrigin2D(box_corner3, angle);\n    box_corner4 = cg::Math::RotatePointOnOrigin2D(box_corner4, angle);\n    // translate to world position\n    box_corner1 += vehicle.transform.location;\n    box_corner2 += vehicle.transform.location;\n    box_corner3 += vehicle.transform.location;\n    box_corner4 += vehicle.transform.location;\n\n    // check if this actor exists\n    auto it = _mapped_vehicles_id.find(vehicle.id);\n    if (it != _mapped_vehicles_id.end()) {\n      // get the index found\n      int index = it->second;\n      if (index != -1) {\n        // get the agent\n        dtCrowdAgent *agent;\n        {\n          // critical section, force single thread running this\n          std::lock_guard<std::mutex> lock(_mutex);\n          agent = _crowd->getEditableAgent(index);\n        }\n        if (agent) {\n          // update its position\n          agent->npos[0] = vehicle.transform.location.x;\n          agent->npos[1] = vehicle.transform.location.z;\n          agent->npos[2] = vehicle.transform.location.y;\n          // update its oriented bounding box\n          agent->params.obb[0]  = box_corner1.x;\n          agent->params.obb[1]  = box_corner1.z;\n          agent->params.obb[2]  = box_corner1.y;\n          agent->params.obb[3]  = box_corner2.x;\n          agent->params.obb[4]  = box_corner2.z;\n          agent->params.obb[5]  = box_corner2.y;\n          agent->params.obb[6]  = box_corner3.x;\n          agent->params.obb[7]  = box_corner3.z;\n          agent->params.obb[8]  = box_corner3.y;\n          agent->params.obb[9]  = box_corner4.x;\n          agent->params.obb[10] = box_corner4.z;\n          agent->params.obb[11] = box_corner4.y;\n        }\n        return true;\n      }\n    }\n\n    // set parameters\n    memset(&params, 0, sizeof(params));\n    params.radius = 2;\n    params.height = AGENT_HEIGHT;\n    params.maxAcceleration = 0.0f;\n    params.maxSpeed = 1.47f;\n    params.collisionQueryRange = 0;\n    params.obstacleAvoidanceType = 0;\n    params.separationWeight = 100.0f;\n\n    // flags\n    params.updateFlags = 0;\n    params.updateFlags |= DT_CROWD_SEPARATION;\n\n    // update its oriented bounding box\n    // data: [x][y][z] [x][y][z] [x][y][z] [x][y][z]\n    params.useObb = true;\n    params.obb[0]  = box_corner1.x;\n    params.obb[1]  = box_corner1.z;\n    params.obb[2]  = box_corner1.y;\n    params.obb[3]  = box_corner2.x;\n    params.obb[4]  = box_corner2.z;\n    params.obb[5]  = box_corner2.y;\n    params.obb[6]  = box_corner3.x;\n    params.obb[7]  = box_corner3.z;\n    params.obb[8]  = box_corner3.y;\n    params.obb[9]  = box_corner4.x;\n    params.obb[10] = box_corner4.z;\n    params.obb[11] = box_corner4.y;\n\n    // from Unreal coordinates (vertical is Z) to Recast coordinates (vertical is Y)\n    float point_from[3] = { vehicle.transform.location.x,\n                            vehicle.transform.location.z,\n                            vehicle.transform.location.y };\n\n    // add walker\n    int index;\n    {\n      // critical section, force single thread running this\n      std::lock_guard<std::mutex> lock(_mutex);\n      index = _crowd->addAgent(point_from, &params);\n      if (index == -1) {\n        logging::log(\"Vehicle agent not added to the crowd by some problem!\");\n        return false;\n      }\n\n      // mark as valid\n      dtCrowdAgent *agent = _crowd->getEditableAgent(index);\n      if (agent) {\n        agent->state = DT_CROWDAGENT_STATE_WALKING;\n      }\n    }\n\n    // save the id\n    _mapped_vehicles_id[vehicle.id] = index;\n    _mapped_by_index[index] = vehicle.id;\n\n    return true;\n  }"
            },
            {
                "name": "RemoveAgent",
                "code": "bool Navigation::RemoveAgent(ActorId id) {\n\n    // check if all is ready\n    if (!_ready) {\n      return false;\n    }\n\n    DEBUG_ASSERT(_crowd != nullptr);\n\n    // get the internal walker index\n    auto it = _mapped_walkers_id.find(id);\n    if (it != _mapped_walkers_id.end()) {\n      // remove from crowd\n      {\n        // critical section, force single thread running this\n        std::lock_guard<std::mutex> lock(_mutex);\n        _crowd->removeAgent(it->second);\n      }\n      _walker_manager.RemoveWalker(id);\n      // remove from mapping\n      _mapped_walkers_id.erase(it);\n      _mapped_by_index.erase(it->second);\n\n      return true;\n    }\n\n    // get the internal vehicle index\n    it = _mapped_vehicles_id.find(id);\n    if (it != _mapped_vehicles_id.end()) {\n      // remove from crowd\n      {\n        // critical section, force single thread running this\n        std::lock_guard<std::mutex> lock(_mutex);\n        _crowd->removeAgent(it->second);\n      }\n      // remove from mapping\n      _mapped_vehicles_id.erase(it);\n      _mapped_by_index.erase(it->second);\n\n      return true;\n    }\n\n    return false;\n  }"
            }
        ],
        "third_party": [
            "updated.insert",
            "updated.erase"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)",
        "start_line": "1157",
        "end_line": "1175",
        "file_path": "LibCarla/source/carla/nav/Navigation.cpp",
        "docstring": "This function, Navigation::HasVehicleNear, checks if there is a vehicle near a given actor within a specified distance and direction.\\nIt first searches for the actor in the mapped walkers and vehicles.\\nIf found, it enters a critical section, computes the squared distance, and uses the crowd system to determine if a vehicle is nearby.\\nThe result is then returned.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "314091490a89",
        "ground_truth": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction) {\n  // get the internal index (walker or vehicle)\n  auto it = _mapped_walkers_id.find(id);\n  if (it == _mapped_walkers_id.end()) {\n    it = _mapped_vehicles_id.find(id);\n    if (it == _mapped_vehicles_id.end()) {\n      return false;\n    }\n  }\n  float dir[3] = { direction.x, direction.z, direction.y };\n  bool result;\n  {\n    // critical section, force single thread running this\n    std::lock_guard<std::mutex> lock(_mutex);\n    result = _crowd->hasVehicleNear(it->second, distance * distance, dir, false);\n  }\n  return result;\n}",
        "import_statements": [
            "#include <cmath>\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/nav/Navigation.h\"\n",
            "#include \"carla/nav/WalkerManager.h\"\n",
            "#include \"carla/geom/Math.h\"\n",
            "#include <iterator>\n",
            "#include <fstream>\n",
            "#include <mutex>\n"
        ],
        "reference_api": [
            "_mapped_vehicles_id.find",
            "_mapped_vehicles_id.end",
            "_mapped_walkers_id.find",
            "_crowd->hasVehicleNear",
            "_mapped_walkers_id.end"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_mapped_vehicles_id.find",
            "_mapped_vehicles_id.end",
            "_mapped_walkers_id.find",
            "_crowd->hasVehicleNear",
            "_mapped_walkers_id.end"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)",
        "start_line": "267",
        "end_line": "275",
        "file_path": "LibCarla/source/carla/nav/WalkerManager.cpp",
        "docstring": "This function, WalkerManager::ExecuteEvent, executes an event for a walker identified by id.\\nIt retrieves the current route point for the walker from the WalkerInfo structure.\\nIt then creates a WalkerEventVisitor with the current context and uses it to process the event at the current route point using boost::variant2::visit.\\nFinally, it returns the result of the event execution.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "048b2b6668b5",
        "ground_truth": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta) {\n    // go to the event\n    WalkerRoutePoint &rp = info.route[info.currentIndex];\n    // build the visitor structure\n    WalkerEventVisitor visitor(this, id, delta);\n    // run the event\n    return boost::variant2::visit(visitor, rp.event);\n}",
        "import_statements": [
            "#include \"carla/nav/WalkerManager.h\"\n",
            "#include \"carla/Logging.h\"\n",
            "#include \"carla/client/ActorSnapshot.h\"\n",
            "#include \"carla/client/Waypoint.h\"\n",
            "#include \"carla/client/World.h\"\n",
            "#include \"carla/client/detail/Simulator.h\"\n",
            "#include \"carla/nav/Navigation.h\"\n",
            "#include \"carla/rpc/Actor.h\"\n"
        ],
        "reference_api": [
            "boost::variant2::visit"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "boost::variant2::visit"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)",
        "start_line": "187",
        "end_line": "218",
        "file_path": "LibCarla/source/carla/opendrive/parser/LaneParser.cpp",
        "docstring": "This function, LaneParser::Parse, processes an XML document containing road data and updates a MapBuilder object.\\nIt iterates through each road node, extracts the road ID, and processes each lane section within the lanes node.\\nFor each lane section, it retrieves the left, center, and right lane nodes and parses them using the ParseLanes method, updating the map builder accordingly.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e6582512af3b",
        "ground_truth": "void LaneParser::Parse(\n    const pugi::xml_document &xml,\n    carla::road::MapBuilder &map_builder) {\n  pugi::xml_node open_drive_node = xml.child(\"OpenDRIVE\");\n  // Lanes\n  for (pugi::xml_node road_node : open_drive_node.children(\"road\")) {\n    road::RoadId road_id = road_node.attribute(\"id\").as_uint();\n    for (pugi::xml_node lanes_node : road_node.children(\"lanes\")) {\n      for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n        double s = lane_section_node.attribute(\"s\").as_double();\n        pugi::xml_node left_node = lane_section_node.child(\"left\");\n        if (left_node) {\n          ParseLanes(road_id, s, left_node, map_builder);\n        }\n        pugi::xml_node center_node = lane_section_node.child(\"center\");\n        if (center_node) {\n          ParseLanes(road_id, s, center_node, map_builder);\n        }\n        pugi::xml_node right_node = lane_section_node.child(\"right\");\n        if (right_node) {\n          ParseLanes(road_id, s, right_node, map_builder);\n        }\n      }\n    }\n  }\n}",
        "import_statements": [
            "#include \"carla/opendrive/parser/LaneParser.h\"\n",
            "#include \"carla/road/MapBuilder.h\"\n",
            "#include <pugixml/pugixml.hpp>\n"
        ],
        "reference_api": [
            "lanes_node.children",
            "lane_section_node.attribute",
            "ParseLanes",
            "xml.child",
            "lane_section_node.attribute(\"s\").as_double",
            "road_node.attribute",
            "open_drive_node.children",
            "road_node.children",
            "lane_section_node.child",
            "road_node.attribute(\"id\").as_uint"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ParseLanes",
                "code": "static void ParseLanes(\n      road::RoadId road_id,\n      double s,\n      const pugi::xml_node &parent_node,\n      carla::road::MapBuilder &map_builder) {\n    for (pugi::xml_node lane_node : parent_node.children(\"lane\")) {\n\n      road::LaneId lane_id = lane_node.attribute(\"id\").as_int();\n\n      road::Lane *lane = map_builder.GetLane(road_id, lane_id, s);\n\n      // Lane Width\n      int width_count = 0;\n      for (pugi::xml_node lane_width_node : lane_node.children(\"width\")) {\n        const double s_offset = lane_width_node.attribute(\"sOffset\").as_double();\n        const double a = lane_width_node.attribute(\"a\").as_double();\n        const double b = lane_width_node.attribute(\"b\").as_double();\n        const double c = lane_width_node.attribute(\"c\").as_double();\n        const double d = lane_width_node.attribute(\"d\").as_double();\n\n        // Call Map builder create Lane Width function\n        map_builder.CreateLaneWidth(lane, s_offset + s, a, b, c, d);\n        width_count++;\n      }\n      if (width_count == 0 && lane->GetId() != 0) {\n        map_builder.CreateLaneWidth(lane, s, 0.0, 0.0, 0.0, 0.0);\n        std::cout << \"WARNING: In road \" << lane->GetRoad()->GetId() << \" lane \" << lane->GetId() <<\n        \" no \\\"<width>\\\" parameter found under \\\"<lane>\\\" tag. Using default values.\" << std::endl;\n      }\n\n      // Lane Border\n      for (pugi::xml_node lane_border_node : lane_node.children(\"border\")) {\n        const double s_offset = lane_border_node.attribute(\"sOffset\").as_double();\n        const double a = lane_border_node.attribute(\"a\").as_double();\n        const double b = lane_border_node.attribute(\"b\").as_double();\n        const double c = lane_border_node.attribute(\"c\").as_double();\n        const double d = lane_border_node.attribute(\"d\").as_double();\n\n        // Call Map builder create Lane Border function\n        map_builder.CreateLaneBorder(lane, s_offset + s, a, b, c, d);\n      }\n\n      // Lane Road Mark\n      int road_mark_id = 0;\n      for (pugi::xml_node lane_road_mark : lane_node.children(\"roadMark\")) {\n        pugi::xml_node road_mark_type;\n        {\n          const double s_offset = lane_road_mark.attribute(\"sOffset\").as_double();\n          const std::string type = lane_road_mark.attribute(\"type\").value();\n          const std::string weight = lane_road_mark.attribute(\"weight\").value();\n          const std::string color = lane_road_mark.attribute(\"color\").value();\n          const std::string material = lane_road_mark.attribute(\"material\").value();\n          const double width = lane_road_mark.attribute(\"width\").as_double();\n          const std::string lane_change = lane_road_mark.attribute(\"laneChange\").value();\n          const double height = lane_road_mark.attribute(\"height\").as_double();\n\n          // Call map builder for LaneRoadMarkType\n\n          std::string type_name = \"\";\n          double type_width = 0.0;\n          road_mark_type = lane_road_mark.child(\"type\");\n          if (road_mark_type) {\n            type_name = road_mark_type.attribute(\"name\").value();\n            type_width = road_mark_type.attribute(\"width\").as_double();\n          }\n\n          // Call map builder for LaneRoadMark\n          map_builder.CreateRoadMark(\n              lane,\n              road_mark_id,\n              s_offset + s,\n              type,\n              weight,\n              color,\n              material,\n              width,\n              lane_change,\n              height,\n              type_name,\n              type_width);\n        }\n\n        for (pugi::xml_node road_mark_type_line_node : road_mark_type.children(\"line\")) {\n\n          const double length = road_mark_type_line_node.attribute(\"length\").as_double();\n          const double space = road_mark_type_line_node.attribute(\"space\").as_double();\n          const double t = road_mark_type_line_node.attribute(\"tOffset\").as_double();\n          const double s_offset = road_mark_type_line_node.attribute(\"sOffset\").as_double();\n          const std::string rule = road_mark_type_line_node.attribute(\"rule\").value();\n          const double width = road_mark_type_line_node.attribute(\"width\").as_double();\n\n          // Call map builder for LaneRoadMarkType LaneRoadMarkTypeLine\n          map_builder.CreateRoadMarkTypeLine(\n              lane,\n              road_mark_id,\n              length,\n              space,\n              t,\n              s_offset + s,\n              rule,\n              width);\n        }\n        ++road_mark_id;\n      }\n\n      // Lane Material\n      for (pugi::xml_node lane_material_node : lane_node.children(\"material\")) {\n\n        const double s_offset = lane_material_node.attribute(\"sOffset\").as_double();\n        const std::string surface = lane_material_node.attribute(\"surface\").value();\n        const double friction = lane_material_node.attribute(\"friction\").as_double();\n        const double roughness = lane_material_node.attribute(\"roughness\").as_double();\n\n        // Create map builder for Lane Material\n        map_builder.CreateLaneMaterial(lane, s_offset + s, surface, friction, roughness);\n      }\n\n      // Lane Visibility\n      for (pugi::xml_node lane_visibility_node : lane_node.children(\"visibility\")) {\n        const double s_offset = lane_visibility_node.attribute(\"sOffset\").as_double();\n        const double forward = lane_visibility_node.attribute(\"forward\").as_double();\n        const double back = lane_visibility_node.attribute(\"back\").as_double();\n        const double left = lane_visibility_node.attribute(\"left\").as_double();\n        const double right = lane_visibility_node.attribute(\"right\").as_double();\n\n        // Create map builder for Lane Visibility\n        map_builder.CreateLaneVisibility(lane, s_offset + s, forward, back, left, right);\n      }\n\n      // Lane Speed\n      for (pugi::xml_node lane_speed_node : lane_node.children(\"speed\")) {\n        const double s_offset = lane_speed_node.attribute(\"sOffset\").as_double();\n        const double max = lane_speed_node.attribute(\"max\").as_double();\n        std::string unit = lane_speed_node.attribute(\"unit\").value();\n\n        // Create map builder for Lane Speed\n        map_builder.CreateLaneSpeed(lane, s_offset + s, max, unit);\n      }\n\n      // Lane Access\n      for (pugi::xml_node lane_access_node : lane_node.children(\"access\")) {\n        const double s_offset = lane_access_node.attribute(\"sOffset\").as_double();\n        const std::string restriction = lane_access_node.attribute(\"restriction\").value();\n\n        // Create map builder for Lane Access\n        map_builder.CreateLaneAccess(lane, s_offset + s, restriction);\n      }\n\n      // Lane Height\n      for (pugi::xml_node lane_height_node : lane_node.children(\"height\")) {\n        const double s_offset = lane_height_node.attribute(\"sOffset\").as_double();\n        const double inner = lane_height_node.attribute(\"inner\").as_double();\n        const double outer = lane_height_node.attribute(\"outer\").as_double();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneHeight(lane, s_offset + s, inner, outer);\n      }\n\n      // Lane Rule\n      for (pugi::xml_node lane_rule_node : lane_node.children(\"rule\")) {\n        const double s_offset = lane_rule_node.attribute(\"sOffset\").as_double();\n        const std::string value = lane_rule_node.attribute(\"value\").value();\n\n        // Create map builder for Lane Height\n        map_builder.CreateLaneRule(lane, s_offset + s, value);\n      }\n\n    }\n  }"
            }
        ],
        "third_party": [
            "lanes_node.children",
            "lane_section_node.attribute",
            "xml.child",
            "lane_section_node.attribute(\"s\").as_double",
            "road_node.attribute",
            "open_drive_node.children",
            "road_node.children",
            "lane_section_node.child",
            "road_node.attribute(\"id\").as_uint"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)",
        "start_line": "25",
        "end_line": "36",
        "file_path": "LibCarla/source/carla/ros2/listeners/CarlaListener.cpp",
        "docstring": "This function, CarlaListenerImpl::on_publication_matched, updates the listener's state based on changes in publication matching.\\nIf a new match is detected, it sets the matched count and marks the first connection.\\nIf a match is lost, it updates the matched count.\\nFor invalid count changes, it logs an error message.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ba3155bc7ea0",
        "ground_truth": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\n{\n  if (info.current_count_change == 1) {\n      _matched = info.total_count;\n      _first_connected = true;\n  } else if (info.current_count_change == -1) {\n      _matched = info.total_count;\n  } else {\n      std::cerr << info.current_count_change\n              << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n  }\n}",
        "import_statements": [
            "#include \"CarlaListener.h\"\n",
            "#include <iostream>\n",
            "#include <fastdds/dds/publisher/DataWriterListener.hpp>\n",
            "#include <fastdds/dds/core/status/PublicationMatchedStatus.hpp>\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)",
        "start_line": "33",
        "end_line": "47",
        "file_path": "LibCarla/source/carla/ros2/listeners/CarlaSubscriberListener.cpp",
        "docstring": "This function, CarlaSubscriberListenerImpl::on_subscription_matched, handles changes in subscription status for a DataReader.\\nIf a new subscription is matched, it updates the matched count and sets the first_connected flag.\\nIf a subscription is unmatched, it updates the matched count and destroys the subscriber if there are no remaining matches.\\nIf the change count is invalid, it logs an error message.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9745f41ab1c1",
        "ground_truth": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\n{\n  if (info.current_count_change == 1) {\n      _matched = info.total_count;\n      _first_connected = true;\n  } else if (info.current_count_change == -1) {\n      _matched = info.total_count;\n      if (_matched == 0) {\n        _owner->DestroySubscriber();\n      }\n  } else {\n      std::cerr << info.current_count_change\n              << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n  }\n}",
        "import_statements": [
            "#include \"CarlaSubscriberListener.h\"\n",
            "#include <iostream>\n",
            "#include <fastdds/dds/subscriber/DataReader.hpp>\n",
            "#include <fastdds/dds/subscriber/DataReaderListener.hpp>\n",
            "#include <fastdds/dds/core/status/SubscriptionMatchedStatus.hpp>\n",
            "#include <fastdds/dds/subscriber/SampleInfo.hpp>\n",
            "#include \"carla/ros2/types/CarlaEgoVehicleControl.h\"\n",
            "#include \"carla/ros2/subscribers/CarlaEgoVehicleControlSubscriber.h\"\n",
            "#include \"carla/ros2/ROS2CallbackData.h\"\n"
        ],
        "reference_api": [
            "_owner->DestroySubscriber"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_owner->DestroySubscriber"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)",
        "start_line": "133",
        "end_line": "170",
        "file_path": "LibCarla/source/carla/ros2/types/CarlaCollisionEventPubSubTypes.cpp",
        "docstring": "This function, CarlaCollisionEventPubSubType::getKey, retrieves the key for a CarlaCollisionEvent instance.\\nIt first checks if key retrieval is defined and returns false if not.\\nIt then serializes the key and, depending on conditions, either computes an MD5 hash or directly copies the key into the handle.\\nFinally, it returns true indicating successful key retrieval.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "140d0e12ec58",
        "ground_truth": "bool CarlaCollisionEventPubSubType::getKey(\n        void* data,\n        InstanceHandle_t* handle,\n        bool force_md5)\n{\n    if (!m_isGetKeyDefined)\n    {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16)\n    {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i)\n        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else\n    {\n        for (uint8_t i = 0; i < 16; ++i)\n        {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}",
        "import_statements": [
            "#include <fastcdr/FastBuffer.h>\n",
            "#include <fastcdr/Cdr.h>\n",
            "#include \"CarlaCollisionEventPubSubTypes.h\"\n"
        ],
        "reference_api": [
            "static_cast<unsigned int>",
            "static_cast<CarlaCollisionEvent*>",
            "m_md5.finalize",
            "ser.getSerializedDataLength",
            "p_type->serializeKey",
            "m_md5.update",
            "CarlaCollisionEvent::getKeyMaxCdrSerializedSize",
            "m_md5.init"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "static_cast<unsigned int>",
            "static_cast<CarlaCollisionEvent*>",
            "m_md5.finalize",
            "ser.getSerializedDataLength",
            "p_type->serializeKey",
            "m_md5.update",
            "CarlaCollisionEvent::getKeyMaxCdrSerializedSize",
            "m_md5.init"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "carla-simulator/carla",
        "function_declaration": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)",
        "start_line": "53",
        "end_line": "80",
        "file_path": "LibCarla/source/carla/ros2/types/CarlaEgoVehicleControlPubSubTypes.cpp",
        "docstring": "This function, CarlaEgoVehicleControlPubSubType::serialize, serializes a CarlaEgoVehicleControl object into a payload buffer.\\nIt initializes a FastBuffer and a Cdr object for serialization, sets the payload encapsulation based on endianness, and attempts to serialize the object.\\nIf successful, it updates the payload length with the serialized data length and returns true.\\nIf there is a memory exception, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "96581065f962",
        "ground_truth": "bool CarlaEgoVehicleControlPubSubType::serialize(\n        void* data,\n        SerializedPayload_t* payload)\n{\n    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}",
        "import_statements": [
            "#include <fastcdr/FastBuffer.h>\n",
            "#include <fastcdr/Cdr.h>\n",
            "#include \"CarlaEgoVehicleControlPubSubTypes.h\"\n"
        ],
        "reference_api": [
            "ser.serialize_encapsulation",
            "ser.getSerializedDataLength",
            "static_cast<uint32_t>",
            "ser.endianness",
            "static_cast<CarlaEgoVehicleControl*>",
            "reinterpret_cast<char*>",
            "p_type->serialize"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ser.serialize_encapsulation",
            "ser.getSerializedDataLength",
            "static_cast<uint32_t>",
            "ser.endianness",
            "static_cast<CarlaEgoVehicleControl*>",
            "reinterpret_cast<char*>",
            "p_type->serialize"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)",
        "start_line": "370",
        "end_line": "401",
        "file_path": "AntennaTracker/GCS_Mavlink.cpp",
        "docstring": "This function, GCS_MAVLINK_Tracker::mavlink_check_target, checks if the target has been set for tracking using MAVLink messages.\\nIf the target is already set, it exits immediately.\\nIt decodes the MAVLink message and exits if the message type is not one that should be tracked.\\nIf the target system ID is not set, it sets the sysid to the target and requests position and air pressure data streams from the target.\\nFinally, it flags that the target has been set.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "94085ddc10d3",
        "ground_truth": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\n{\n    // exit immediately if the target has already been set\n    if (tracker.target_set) {\n        return;\n    }\n     // decode\n    mavlink_heartbeat_t packet;\n    mavlink_msg_heartbeat_decode(&msg, &packet);\n     // exit immediately if this is not a vehicle we would track\n    if ((packet.type == MAV_TYPE_ANTENNA_TRACKER) ||\n        (packet.type == MAV_TYPE_GCS) ||\n        (packet.type == MAV_TYPE_ONBOARD_CONTROLLER) ||\n        (packet.type == MAV_TYPE_GIMBAL)) {\n        return;\n    }\n     // set our sysid to the target, this ensures we lock onto a single vehicle\n    if (tracker.g.sysid_target == 0) {\n        tracker.g.sysid_target.set(msg.sysid);\n    }\n     // send data stream request to target on all channels\n    //  Note: this doesn't check success for all sends meaning it's not guaranteed the vehicle's positions will be sent at 1hz\n    tracker.gcs().request_datastream_position(msg.sysid, msg.compid);\n    tracker.gcs().request_datastream_airpressure(msg.sysid, msg.compid);\n     // flag target has been set\n    tracker.target_set = true;\n}",
        "import_statements": [
            "#include \"GCS_Mavlink.h\"\n",
            "#include \"Tracker.h\"\n"
        ],
        "reference_api": [
            "tracker.g.sysid_target.set",
            "mavlink_msg_heartbeat_decode",
            "tracker.gcs().request_datastream_position",
            "tracker.gcs().request_datastream_airpressure",
            "tracker.gcs"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "tracker.g.sysid_target.set",
            "mavlink_msg_heartbeat_decode",
            "tracker.gcs().request_datastream_position",
            "tracker.gcs().request_datastream_airpressure",
            "tracker.gcs"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)",
        "start_line": "408",
        "end_line": "416",
        "file_path": "AntennaTracker/GCS_Mavlink.cpp",
        "docstring": "This function, GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro, processes a preflight calibration command for the barometer.\\nIt calls the base class handler and if the result is MAV_RESULT_ACCEPTED, it sets a flag to indicate that altitude calibration is needed on the next barometer update.\\nThe function then returns the result of the base class handler.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "88fefdf78944",
        "ground_truth": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\n{\n    MAV_RESULT ret = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (ret == MAV_RESULT_ACCEPTED) {\n        // zero the altitude difference on next baro update\n        tracker.nav_status.need_altitude_calibration = true;\n    }\n    return ret;\n}",
        "import_statements": [
            "#include \"GCS_Mavlink.h\"\n",
            "#include \"Tracker.h\"\n"
        ],
        "reference_api": [
            "GCS_MAVLINK::_handle_command_preflight_calibration_baro"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "GCS_MAVLINK::_handle_command_preflight_calibration_baro"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)",
        "start_line": "418",
        "end_line": "429",
        "file_path": "AntennaTracker/GCS_Mavlink.cpp",
        "docstring": "This function, GCS_MAVLINK_Tracker::handle_command_component_arm_disarm, handles arm and disarm commands for servos.\\nIf the command parameter is 1.0, it arms the servos and returns MAV_RESULT_ACCEPTED.\\nIf the command parameter is 0, it disarms the servos and returns MAV_RESULT_ACCEPTED.\\nFor any other parameter value, it returns MAV_RESULT_UNSUPPORTED.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3a4502c288b4",
        "ground_truth": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\n{\n    if (is_equal(packet.param1,1.0f)) {\n        tracker.arm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (is_zero(packet.param1))  {\n        tracker.disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}",
        "import_statements": [
            "#include \"GCS_Mavlink.h\"\n",
            "#include \"Tracker.h\"\n"
        ],
        "reference_api": [
            "is_zero",
            "is_equal",
            "tracker.disarm_servos",
            "tracker.arm_servos"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "is_zero",
            "is_equal",
            "tracker.disarm_servos",
            "tracker.arm_servos"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)",
        "start_line": "9",
        "end_line": "23",
        "file_path": "AntennaTracker/GCS_Tracker.cpp",
        "docstring": "This function, GCS_Tracker::request_datastream_position, sends a request to start streaming position data for a specified system and component ID.\\nIt iterates over the available GCS channels and checks for available payload space.\\nIf space is available, it sends a request to start the data stream on the corresponding channel with the specified update rate.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "82ee329fd6e4",
        "ground_truth": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\n{\n    for (uint8_t i=0; i < num_gcs(); i++) {\n            // request position\n            if (HAVE_PAYLOAD_SPACE((mavlink_channel_t)i, DATA_STREAM)) {\n                mavlink_msg_request_data_stream_send(\n                    (mavlink_channel_t)i,\n                    sysid,\n                    compid,\n                    MAV_DATA_STREAM_POSITION,\n                    tracker.g.mavlink_update_rate,\n                    1); // start streaming\n            }\n    }\n}",
        "import_statements": [
            "#include \"GCS_Tracker.h\"\n",
            "#include \"Tracker.h\"\n"
        ],
        "reference_api": [
            "HAVE_PAYLOAD_SPACE",
            "num_gcs",
            "mavlink_msg_request_data_stream_send"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "HAVE_PAYLOAD_SPACE",
            "num_gcs",
            "mavlink_msg_request_data_stream_send"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)",
        "start_line": "112",
        "end_line": "123",
        "file_path": "AntennaTracker/mode.cpp",
        "docstring": "This function, Mode::convert_bf_to_ef, converts body frame pitch and yaw angles to earth frame angles.\\nIt first retrieves the AHRS instance and checks for a zero pitch cosine to avoid division by zero.\\nIf the pitch cosine is not zero, it calculates the earth frame pitch and yaw using trigonometric conversions and returns true.\\nIf the pitch cosine is zero, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3220d1062a93",
        "ground_truth": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\n{\n    const AP_AHRS &ahrs = AP::ahrs();\n    // avoid divide by zero\n    if (is_zero(ahrs.cos_pitch())) {\n        return false;\n    }\n    // convert earth frame angle or rates to body frame\n    ef_pitch = ahrs.cos_roll() * pitch - ahrs.sin_roll() * yaw;\n    ef_yaw = (ahrs.sin_roll() / ahrs.cos_pitch()) * pitch + (ahrs.cos_roll() / ahrs.cos_pitch()) * yaw;\n    return true;\n}",
        "import_statements": [
            "#include \"mode.h\"\n",
            "#include \"Tracker.h\"\n"
        ],
        "reference_api": [
            "is_zero",
            "AP::ahrs",
            "ahrs.sin_roll",
            "ahrs.cos_pitch",
            "ahrs.cos_roll"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "is_zero",
            "AP::ahrs",
            "ahrs.sin_roll",
            "ahrs.cos_pitch",
            "ahrs.cos_roll"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Mode::update_auto(void)",
        "start_line": "5",
        "end_line": "27",
        "file_path": "AntennaTracker/mode.cpp",
        "docstring": "This function, Mode::update_auto, updates the target yaw and pitch for the tracker based on navigation status and parameters.\\nIt calculates the yaw and pitch in centidegrees, checks if the direction is reversed, and computes the angle error.\\nIt then converts the errors from earth frame to body frame.\\nIf the target distance is valid or no minimum distance is set, it updates the pitch and yaw servos accordingly.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a71eaa3dc4f4",
        "ground_truth": "void Mode::update_auto(void)\n{\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n     Parameters &g = tracker.g;\n     float yaw = wrap_180_cd((nav_status.bearing+g.yaw_trim)*100); // target yaw in centidegrees\n    float pitch = constrain_float(nav_status.pitch+g.pitch_trim, g.pitch_min, g.pitch_max) * 100; // target pitch in centidegrees\n     bool direction_reversed = get_ef_yaw_direction();\n     calc_angle_error(pitch, yaw, direction_reversed);\n     float bf_pitch;\n    float bf_yaw;\n    convert_ef_to_bf(pitch, yaw, bf_pitch, bf_yaw);\n     // only move servos if target is at least distance_min away if we  have a target\n    if ((g.distance_min <= 0) || (nav_status.distance >= g.distance_min) || !tracker.vehicle.location_valid) {\n        tracker.update_pitch_servo(bf_pitch);\n        tracker.update_yaw_servo(bf_yaw);\n    }\n}",
        "import_statements": [
            "#include \"mode.h\"\n",
            "#include \"Tracker.h\"\n"
        ],
        "reference_api": [
            "wrap_180_cd",
            "tracker.update_yaw_servo",
            "get_ef_yaw_direction",
            "convert_ef_to_bf",
            "tracker.update_pitch_servo",
            "constrain_float",
            "calc_angle_error"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "get_ef_yaw_direction",
                "code": "bool Mode::get_ef_yaw_direction()\n{\n    // calculating distances from current pitch/yaw to lower and upper limits in centi-degrees\n    Parameters &g = tracker.g;\n    float yaw_angle_limit_lower =   (-g.yaw_range * 100.0f / 2.0f) - tracker.yaw_servo_out_filt.get();\n    float yaw_angle_limit_upper =   (g.yaw_range * 100.0f / 2.0f) - tracker.yaw_servo_out_filt.get();\n    float pitch_angle_limit_lower = (g.pitch_min * 100.0f) - tracker.pitch_servo_out_filt.get();\n    float pitch_angle_limit_upper = (g.pitch_max * 100.0f) - tracker.pitch_servo_out_filt.get();\n\n    // distances to earthframe angle limits in centi-degrees\n    float ef_yaw_limit_lower = yaw_angle_limit_lower;\n    float ef_yaw_limit_upper = yaw_angle_limit_upper;\n    float ef_pitch_limit_lower = pitch_angle_limit_lower;\n    float ef_pitch_limit_upper = pitch_angle_limit_upper;\n    convert_bf_to_ef(pitch_angle_limit_lower, yaw_angle_limit_lower, ef_pitch_limit_lower, ef_yaw_limit_lower);\n    convert_bf_to_ef(pitch_angle_limit_upper, yaw_angle_limit_upper, ef_pitch_limit_upper, ef_yaw_limit_upper);\n\n    const AP_AHRS &ahrs = AP::ahrs();\n    float ef_yaw_current = wrap_180_cd(ahrs.yaw_sensor);\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    float ef_yaw_target = wrap_180_cd((nav_status.bearing+g.yaw_trim)*100);\n    float ef_yaw_angle_error = wrap_180_cd(ef_yaw_target - ef_yaw_current);\n\n    // calculate angle error to target in both directions (i.e. moving up/right or lower/left)\n    float yaw_angle_error_upper;\n    float yaw_angle_error_lower;\n    if (ef_yaw_angle_error >= 0) {\n        yaw_angle_error_upper = ef_yaw_angle_error;\n        yaw_angle_error_lower = ef_yaw_angle_error - 36000;\n    } else {\n        yaw_angle_error_upper = 36000 + ef_yaw_angle_error;\n        yaw_angle_error_lower = ef_yaw_angle_error;\n    }\n\n    // checks that the vehicle is outside the tracker's range\n    if ((yaw_angle_error_lower < ef_yaw_limit_lower) && (yaw_angle_error_upper > ef_yaw_limit_upper)) {\n        // if the tracker is trying to move clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving counter-clockwise then set direction_reversed to true\n        if (ef_yaw_angle_error>0 && ((ef_yaw_limit_lower - yaw_angle_error_lower) < (yaw_angle_error_upper - ef_yaw_limit_upper))) {\n            return true;\n        }\n        // if the tracker is trying to move counter-clockwise to reach the vehicle,\n        // but the tracker could get closer to the vehicle by moving then set direction_reversed to true\n        if (ef_yaw_angle_error<0 && ((ef_yaw_limit_lower - yaw_angle_error_lower) > (yaw_angle_error_upper - ef_yaw_limit_upper))) {\n            return true;\n        }\n    }\n\n    // if we get this far we can use the regular, shortest path to the target\n    return false;\n}"
            },
            {
                "name": "convert_ef_to_bf",
                "code": "void Mode::convert_ef_to_bf(float pitch, float yaw, float& bf_pitch, float& bf_yaw)\n{\n\t// earth frame to body frame pitch and yaw conversion\n    const AP_AHRS &ahrs = AP::ahrs();\n    bf_pitch = ahrs.cos_roll() * pitch + ahrs.sin_roll() * ahrs.cos_pitch() * yaw;\n    bf_yaw = -ahrs.sin_roll() * pitch + ahrs.cos_pitch() * ahrs.cos_roll() * yaw;\n}"
            },
            {
                "name": "calc_angle_error",
                "code": "void Mode::calc_angle_error(float pitch, float yaw, bool direction_reversed)\n{\n    // Pitch angle error in centidegrees\n    // Positive error means the target is above current pitch\n    // Negative error means the target is below current pitch\n    const AP_AHRS &ahrs = AP::ahrs();\n    float ahrs_pitch = ahrs.pitch_sensor;\n    int32_t ef_pitch_angle_error = pitch - ahrs_pitch;\n\n    // Yaw angle error in centidegrees\n    // Positive error means the target is right of current yaw\n    // Negative error means the target is left of current yaw\n    int32_t ahrs_yaw_cd = wrap_180_cd(ahrs.yaw_sensor);\n    int32_t ef_yaw_angle_error = wrap_180_cd(yaw - ahrs_yaw_cd);\n    if (direction_reversed) {\n        if (ef_yaw_angle_error > 0) {\n            ef_yaw_angle_error = (yaw - ahrs_yaw_cd) - 36000;\n        } else {\n            ef_yaw_angle_error = 36000 + (yaw - ahrs_yaw_cd);\n        }\n    }\n\n    // earth frame to body frame angle error conversion\n    float bf_pitch_err;\n    float bf_yaw_err;\n    convert_ef_to_bf(ef_pitch_angle_error, ef_yaw_angle_error, bf_pitch_err, bf_yaw_err);\n    struct Tracker::NavStatus &nav_status = tracker.nav_status;\n    nav_status.angle_error_pitch = bf_pitch_err;\n    nav_status.angle_error_yaw = bf_yaw_err;\n\n    // set actual and desired for logging, note we are using angles not rates\n    Parameters &g = tracker.g;\n    g.pidPitch2Srv.set_target_rate(pitch * 0.01);\n    g.pidPitch2Srv.set_actual_rate(ahrs_pitch * 0.01);\n    g.pidYaw2Srv.set_target_rate(yaw * 0.01);\n    g.pidYaw2Srv.set_actual_rate(ahrs_yaw_cd * 0.01);\n}"
            }
        ],
        "third_party": [
            "wrap_180_cd",
            "tracker.update_yaw_servo",
            "tracker.update_pitch_servo",
            "constrain_float"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Tracker::update_GPS(void)",
        "start_line": "31",
        "end_line": "59",
        "file_path": "AntennaTracker/sensors.cpp",
        "docstring": "This function, Tracker::update_GPS, updates the GPS data and handles initialization for setting the home location.\\nIt updates the GPS and checks if the last message time has changed and if the GPS status is at least 3D fix.\\nIt manages a countdown for ground start, and once the countdown reaches one, it sets the home location if the current location is valid.\\nIf the location is invalid, it resets the countdown.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4bab01816a64",
        "ground_truth": "void Tracker::update_GPS(void)\n{\n    gps.update();\n     static uint32_t last_gps_msg_ms;\n    static uint8_t ground_start_count = 5;\n    if (gps.last_message_time_ms() != last_gps_msg_ms && \n        gps.status() >= AP_GPS::GPS_OK_FIX_3D) {\n        last_gps_msg_ms = gps.last_message_time_ms();\n                 if (ground_start_count > 1) {\n            ground_start_count--;\n        } else if (ground_start_count == 1) {\n            // We countdown N number of good GPS fixes\n            // so that the altitude is more accurate\n            // -------------------------------------\n            if (current_loc.lat == 0 && current_loc.lng == 0) {\n                ground_start_count = 5;\n             } else {\n                // Now have an initial GPS position\n                // use it as the HOME position in future startups\n                current_loc = gps.location();\n                IGNORE_RETURN(set_home(current_loc, false));\n                ground_start_count = 0;\n            }\n        }\n    }\n}",
        "import_statements": [
            "#include \"Tracker.h\"\n"
        ],
        "reference_api": [
            "gps.status",
            "IGNORE_RETURN",
            "gps.update",
            "gps.location",
            "set_home",
            "gps.last_message_time_ms"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "gps.status",
            "IGNORE_RETURN",
            "gps.update",
            "gps.location",
            "set_home",
            "gps.last_message_time_ms"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Tracker::update_pitch_onoff_servo(float pitch) const",
        "start_line": "104",
        "end_line": "121",
        "file_path": "AntennaTracker/servos.cpp",
        "docstring": "This function, Tracker::update_GPS, updates the GPS data and handles initialization for setting the home location.\\nIt updates the GPS and checks if the last message time has changed and if the GPS status is at least 3D fix.\\nIt manages a countdown for ground start, and once the countdown reaches one, it sets the home location if the current location is valid.\\nIf the location is invalid, it resets the countdown.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8af34a0b0216",
        "ground_truth": "void Tracker::update_pitch_onoff_servo(float pitch) const\n{\n    int32_t pitch_min_cd = g.pitch_min*100;\n    int32_t pitch_max_cd = g.pitch_max*100;\n     float acceptable_error = g.onoff_pitch_rate * g.onoff_pitch_mintime;\n    if (fabsf(nav_status.angle_error_pitch) < acceptable_error) {\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 0);\n    } else if ((nav_status.angle_error_pitch > 0) && (pitch*100>pitch_min_cd)) {\n        // positive error means we are pointing too low, so push the\n        // servo up\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, -9000);\n    } else if (pitch*100<pitch_max_cd) {\n        // negative error means we are pointing too high, so push the\n        // servo down\n        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 9000);\n    }\n}",
        "import_statements": [
            "#include \"Tracker.h\"\n"
        ],
        "reference_api": [
            "SRV_Channels::set_output_scaled",
            "fabsf"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "SRV_Channels::set_output_scaled",
            "fabsf"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool AP_Arming_Copter::barometer_checks(bool display_failure)",
        "start_line": "114",
        "end_line": "136",
        "file_path": "ArduCopter/AP_Arming.cpp",
        "docstring": "This function, AP_Arming_Copter::barometer_checks, performs barometer checks during the arming process.\\nIt first calls the base class's barometer_checks function.\\nIf the ARMING_CHECK_BARO is enabled, it checks the barometer reference and compares the barometer altitude with the inertial navigation altitude.\\nIf the disparity exceeds a predefined limit, it logs a failure and returns false.\\nOtherwise, it returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6b7fe72cd11e",
        "ground_truth": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\n{\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n     bool ret = true;\n    // check Baro\n    if (check_enabled(ARMING_CHECK_BARO)) {\n        // Check baro & inav alt are within 1m if EKF is operating in an absolute position mode.\n        // Do not check if intending to operate in a ground relative height mode as EKF will output a ground relative height\n        // that may differ from the baro height due to baro drift.\n        nav_filter_status filt_status = copter.inertial_nav.get_filter_status();\n        bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);\n        if (using_baro_ref) {\n            if (fabsf(copter.inertial_nav.get_position_z_up_cm() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {\n                check_failed(ARMING_CHECK_BARO, display_failure, \"Altitude disparity\");\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}",
        "import_statements": [
            "#include \"Copter.h\"\n"
        ],
        "reference_api": [
            "check_enabled",
            "copter.inertial_nav.get_position_z_up_cm",
            "AP_Arming::barometer_checks",
            "copter.inertial_nav.get_filter_status",
            "fabsf",
            "check_failed"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "check_enabled",
            "copter.inertial_nav.get_position_z_up_cm",
            "AP_Arming::barometer_checks",
            "copter.inertial_nav.get_filter_status",
            "fabsf",
            "check_failed"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool AP_Arming_Copter::terrain_database_required() const",
        "start_line": "173",
        "end_line": "186",
        "file_path": "ArduCopter/AP_Arming.cpp",
        "docstring": "This function, AP_Arming_Copter::terrain_database_required, determines if a terrain database is required for arming.\\nIf the terrain source is from a rangefinder, it returns false.\\nIf the terrain source is from the terrain database and the RTL altitude type is terrain, it returns true.\\nOtherwise, it defers to the base class implementation of terrain_database_required.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d57f2afc4550",
        "ground_truth": "bool AP_Arming_Copter::terrain_database_required() const\n{\n     if (copter.wp_nav->get_terrain_source() == AC_WPNav::TerrainSource::TERRAIN_FROM_RANGEFINDER) {\n        // primary terrain source is from rangefinder, allow arming without terrain database\n        return false;\n    }\n     if (copter.wp_nav->get_terrain_source() == AC_WPNav::TerrainSource::TERRAIN_FROM_TERRAINDATABASE &&\n        copter.mode_rtl.get_alt_type() == ModeRTL::RTLAltType::RTL_ALTTYPE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}",
        "import_statements": [
            "#include \"Copter.h\"\n"
        ],
        "reference_api": [
            "copter.wp_nav->get_terrain_source",
            "AP_Arming::terrain_database_required",
            "copter.mode_rtl.get_alt_type"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "copter.wp_nav->get_terrain_source",
            "AP_Arming::terrain_database_required",
            "copter.mode_rtl.get_alt_type"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Copter::run_rate_controller()",
        "start_line": "9",
        "end_line": "19",
        "file_path": "ArduCopter/Attitude.cpp",
        "docstring": "This function, Copter::run_rate_controller, sets the loop time for attitude, position, and motor controllers using the last loop time from the scheduler.\\nIt then runs the low-level rate controllers that require only IMU data by invoking the rate_controller_run method of the attitude control.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9a0065e79a57",
        "ground_truth": "void Copter::run_rate_controller()\n{\n    // set attitude and position controller loop time\n    const float last_loop_time_s = AP::scheduler().get_last_loop_time_s();\n    motors->set_dt(last_loop_time_s);\n    attitude_control->set_dt(last_loop_time_s);\n    pos_control->set_dt(last_loop_time_s);\n     // run low level rate controllers that only require IMU data\n    attitude_control->rate_controller_run(); \n}",
        "import_statements": [
            "#include \"Copter.h\"\n"
        ],
        "reference_api": [
            "AP::scheduler",
            "attitude_control->rate_controller_run",
            "AP::scheduler().get_last_loop_time_s",
            "pos_control->set_dt",
            "motors->set_dt",
            "attitude_control->set_dt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "AP::scheduler",
            "attitude_control->rate_controller_run",
            "AP::scheduler().get_last_loop_time_s",
            "pos_control->set_dt",
            "motors->set_dt",
            "attitude_control->set_dt"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)",
        "start_line": "458",
        "end_line": "473",
        "file_path": "ArduCopter/Copter.cpp",
        "docstring": "This function, Copter::update_target_location, updates the target location if conditions are met.\\nIt retrieves the next waypoint location and checks if the old location matches this waypoint and if the altitude frames of the old and new locations are the same.\\nIf these conditions are not met, it returns false.\\nOtherwise, it sets the new location as the target and returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9fe9459ec4d1",
        "ground_truth": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\n{\n    /*\n      by checking the caller has provided the correct old target\n      location we prevent a race condition where the user changes mode\n      or commands a different target in the controlling lua script\n    */\n    Location next_WP_loc;\n    flightmode->get_wp(next_WP_loc);\n    if (!old_loc.same_loc_as(next_WP_loc) ||\n         old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n     return set_target_location(new_loc);\n}",
        "import_statements": [
            "#include \"Copter.h\"\n",
            "#include \"version.h\"\n"
        ],
        "reference_api": [
            "new_loc.get_alt_frame",
            "flightmode->get_wp",
            "set_target_location",
            "old_loc.get_alt_frame",
            "old_loc.same_loc_as"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "set_target_location",
                "code": "bool Copter::set_target_location(const Location& target_loc)\n{\n    // exit if vehicle is not in Guided mode or Auto-Guided mode\n    if (!flightmode->in_guided_mode()) {\n        return false;\n    }\n\n    return mode_guided.set_destination(target_loc);\n}"
            }
        ],
        "third_party": [
            "new_loc.get_alt_frame",
            "flightmode->get_wp",
            "old_loc.get_alt_frame",
            "old_loc.same_loc_as"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)",
        "start_line": "141",
        "end_line": "157",
        "file_path": "ArduCopter/RC_Channel.cpp",
        "docstring": "This function, RC_Channel_Copter::do_aux_function_change_mode, changes the copter's flight mode based on the AuxSwitchPos.\\nIf the switch is in the HIGH position, it attempts to set the mode using the copter's set_mode method.\\nIf the switch is not in the HIGH position and the current flight mode matches the given mode, it resets the mode switch using rc().reset_mode_switch.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e4f49f57ad52",
        "ground_truth": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\n{\n    switch(ch_flag) {\n    case AuxSwitchPos::HIGH: {\n        // engage mode (if not possible we remain in current flight mode)\n        copter.set_mode(mode, ModeReason::AUX_FUNCTION);\n        break;\n    }\n    default:\n        // return to flight mode switch's flight mode if we are currently\n        // in this mode\n        if (copter.flightmode->mode_number() == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}",
        "import_statements": [
            "#include \"Copter.h\"\n",
            "#include \"RC_Channel.h\"\n",
            "#include <RC_Channel/RC_Channels_VarInfo.h>\n"
        ],
        "reference_api": [
            "rc().reset_mode_switch",
            "copter.flightmode->mode_number",
            "rc",
            "copter.set_mode"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rc().reset_mode_switch",
            "copter.flightmode->mode_number",
            "rc",
            "copter.set_mode"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Copter::save_trim()",
        "start_line": "689",
        "end_line": "697",
        "file_path": "ArduCopter/RC_Channel.cpp",
        "docstring": "This function, Copter::save_trim, saves the roll and pitch trim values.\\nIt calculates the trim values from the control inputs of the roll and pitch channels, converts them to radians, and adds them to the AHRS trim.\\nIt then logs the event and sends a confirmation message with MAV_SEVERITY_INFO.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b8fd7e165620",
        "ground_truth": "void Copter::save_trim()\n{\n    // save roll and pitch trim\n    float roll_trim = ToRad((float)channel_roll->get_control_in()/100.0f);\n    float pitch_trim = ToRad((float)channel_pitch->get_control_in()/100.0f);\n    ahrs.add_trim(roll_trim, pitch_trim);\n    LOGGER_WRITE_EVENT(LogEvent::SAVE_TRIM);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Trim saved\");\n}",
        "import_statements": [
            "#include \"Copter.h\"\n",
            "#include \"RC_Channel.h\"\n",
            "#include <RC_Channel/RC_Channels_VarInfo.h>\n"
        ],
        "reference_api": [
            "channel_roll->get_control_in",
            "channel_pitch->get_control_in",
            "LOGGER_WRITE_EVENT",
            "gcs",
            "ahrs.add_trim",
            "ToRad",
            "gcs().send_text"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "channel_roll->get_control_in",
            "channel_pitch->get_control_in",
            "LOGGER_WRITE_EVENT",
            "gcs",
            "ahrs.add_trim",
            "ToRad",
            "gcs().send_text"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "float Mode::AutoYaw::look_ahead_yaw()",
        "start_line": "12",
        "end_line": "21",
        "file_path": "ArduCopter/autoyaw.cpp",
        "docstring": "This function, Mode::AutoYaw::look_ahead_yaw, calculates the yaw angle for a copter to look ahead based on its velocity.\\nIt retrieves the copter's velocity, calculates the speed squared, and if the copter's position is valid and the speed exceeds a minimum threshold, it updates the look-ahead yaw angle using the arctangent of the velocity components.\\nFinally, it returns the computed look-ahead yaw angle.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8cdc9cd2135b",
        "ground_truth": "float Mode::AutoYaw::look_ahead_yaw()\n{\n    const Vector3f& vel = copter.inertial_nav.get_velocity_neu_cms();\n    const float speed_sq = vel.xy().length_squared();\n    // Commanded Yaw to automatically look ahead.\n    if (copter.position_ok() && (speed_sq > (YAW_LOOK_AHEAD_MIN_SPEED * YAW_LOOK_AHEAD_MIN_SPEED))) {\n        _look_ahead_yaw = degrees(atan2f(vel.y,vel.x));\n    }\n    return _look_ahead_yaw;\n}",
        "import_statements": [
            "#include \"Copter.h\"\n"
        ],
        "reference_api": [
            "copter.position_ok",
            "vel.xy().length_squared",
            "copter.inertial_nav.get_velocity_neu_cms",
            "vel.xy",
            "atan2f",
            "degrees"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "copter.position_ok",
            "vel.xy().length_squared",
            "copter.inertial_nav.get_velocity_neu_cms",
            "vel.xy",
            "atan2f",
            "degrees"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)",
        "start_line": "251",
        "end_line": "288",
        "file_path": "ArduPlane/AP_Arming.cpp",
        "docstring": "This function, AP_Arming_Plane::arm_checks, performs arming checks for a plane based on the specified method.\\nFor the RUDDER method, it checks if rudder arming is disabled or if the throttle is not zero, returning false in either case.\\nIf arming checks are disabled or the watchdog was armed, it bypasses the checks and returns true.\\nFinally, it calls and returns the result of the parent class's arm_checks method.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b6aa851ecabd",
        "ground_truth": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\n{\n    if (method == AP_Arming::Method::RUDDER) {\n        const AP_Arming::RudderArming arming_rudder = get_rudder_arming_type();\n         if (arming_rudder == AP_Arming::RudderArming::IS_DISABLED) {\n            //parameter disallows rudder arming/disabling\n             // if we emit a message here then someone doing surface\n            // checks may be bothered by the message being emitted.\n            // check_failed(true, \"Rudder arming disabled\");\n            return false;\n        }\n         // if throttle is not down, then pilot cannot rudder arm/disarm\n        if (!is_zero(plane.get_throttle_input())){\n            check_failed(true, \"Non-zero throttle\");\n            return false;\n        }\n    }\n     //are arming checks disabled?\n    if (checks_to_perform == 0) {\n        return true;\n    }\n     if (hal.util->was_watchdog_armed()) {\n        // on watchdog reset bypass arming checks to allow for\n        // in-flight arming if we were armed before the reset. This\n        // allows a reset on a BVLOS flight to return home if the\n        // operator can command arming over telemetry\n        gcs().send_text(MAV_SEVERITY_WARNING, \"watchdog: Bypassing arming checks\");\n        return true;\n    }\n     // call parent class checks\n    return AP_Arming::arm_checks(method);\n}",
        "import_statements": [
            "#include \"AP_Arming.h\"\n",
            "#include \"Plane.h\"\n",
            "#include \"qautotune.h\"\n"
        ],
        "reference_api": [
            "is_zero",
            "AP_Arming::arm_checks",
            "gcs",
            "get_rudder_arming_type",
            "plane.get_throttle_input",
            "hal.util->was_watchdog_armed",
            "gcs().send_text",
            "check_failed"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "is_zero",
            "AP_Arming::arm_checks",
            "gcs",
            "get_rudder_arming_type",
            "plane.get_throttle_input",
            "hal.util->was_watchdog_armed",
            "gcs().send_text",
            "check_failed"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)",
        "start_line": "301",
        "end_line": "327",
        "file_path": "ArduPlane/AP_Arming.cpp",
        "docstring": "This function, AP_Arming_Plane::arm, attempts to arm the plane using a specified method and optional arming checks.\\nIf successful, it updates the home location and sets it in the AHRS system.\\nIt then updates the current location, changes the arm state, sets a delay arming flag, and sends a status text indicating that the throttle is armed.\\nThe function returns true if the arming process is successful, otherwise it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5a4cace96cc9",
        "ground_truth": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\n{\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n     if (plane.update_home()) {\n        // after update_home the home position could still be\n        // different from the current_loc if the EKF refused the\n        // resetHeightDatum call. If we are updating home then we want\n        // to force the home to be the current_loc so relative alt\n        // takeoffs work correctly\n        if (plane.ahrs.set_home(plane.current_loc)) {\n            // update current_loc\n            plane.update_current_loc();\n        }\n    }\n     change_arm_state();\n     // rising edge of delay_arming oneshot\n    delay_arming = true;\n     send_arm_disarm_statustext(\"Throttle armed\");\n     return true;\n}",
        "import_statements": [
            "#include \"AP_Arming.h\"\n",
            "#include \"Plane.h\"\n",
            "#include \"qautotune.h\"\n"
        ],
        "reference_api": [
            "change_arm_state",
            "plane.update_home",
            "AP_Arming::arm",
            "plane.update_current_loc",
            "send_arm_disarm_statustext",
            "plane.ahrs.set_home"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "change_arm_state",
                "code": "void AP_Arming_Plane::change_arm_state(void)\n{\n    update_soft_armed();\n#if HAL_QUADPLANE_ENABLED\n    plane.quadplane.set_armed(hal.util->get_soft_armed());\n#endif\n}"
            }
        ],
        "third_party": [
            "plane.update_home",
            "AP_Arming::arm",
            "plane.update_current_loc",
            "send_arm_disarm_statustext",
            "plane.ahrs.set_home"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)",
        "start_line": "44",
        "end_line": "56",
        "file_path": "ArduSub/AP_Arming_Sub.cpp",
        "docstring": "This function, AP_Arming_Sub::pre_arm_checks, performs pre-arm checks for the vehicle.\\nIf the vehicle is already armed, it returns true.\\nIt checks if a disarm button is configured and if not, it displays a failure message if requested and returns false.\\nIf the disarm button is configured, it proceeds with the standard pre-arm checks by calling AP_Arming::pre_arm_checks.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7a25ae8fa8a2",
        "ground_truth": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\n{\n    if (armed) {\n        return true;\n    }\n    // don't allow arming unless there is a disarm button configured\n    if (!has_disarm_function()) {\n        check_failed(display_failure, \"Must assign a disarm or arm_toggle button\");\n        return false;\n    }\n     return AP_Arming::pre_arm_checks(display_failure);\n}",
        "import_statements": [
            "#include \"AP_Arming_Sub.h\"\n",
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "check_failed",
            "AP_Arming::pre_arm_checks",
            "has_disarm_function"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "has_disarm_function",
                "code": "bool AP_Arming_Sub::has_disarm_function() const {\n    bool has_shift_function = false;\n    // make sure the craft has a disarm button assigned before it is armed\n    // check all the standard btn functions\n    for (uint8_t i = 0; i < 16; i++) {\n        switch (sub.get_button(i)->function(false)) {\n            case JSButton::k_shift :\n                has_shift_function = true;\n                break;\n            case JSButton::k_arm_toggle :\n                return true;\n            case JSButton::k_disarm :\n                return true;\n        }\n    }\n\n    // check all the shift functions if there's shift assigned\n    if (has_shift_function) {\n        for (uint8_t i = 0; i < 16; i++) {\n            switch (sub.get_button(i)->function(true)) {\n                case JSButton::k_arm_toggle :\n                case JSButton::k_disarm :\n                    return true;\n            }\n        }\n    }\n    return false;\n}"
            }
        ],
        "third_party": [
            "check_failed",
            "AP_Arming::pre_arm_checks"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Sub::rotate_body_frame_to_NE(float &x, float &y)",
        "start_line": "127",
        "end_line": "133",
        "file_path": "ArduSub/Attitude.cpp",
        "docstring": "This function, Sub::rotate_body_frame_to_NE, rotates the coordinates x and y from the body frame to the North-East frame using the yaw angle from the AHRS.\\nIt calculates the new coordinates ne_x and ne_y by applying the rotation matrix, then updates x and y with these new values.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "29ab883ed0b2",
        "ground_truth": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\n{\n    float ne_x = x*ahrs.cos_yaw() - y*ahrs.sin_yaw();\n    float ne_y = x*ahrs.sin_yaw() + y*ahrs.cos_yaw();\n    x = ne_x;\n    y = ne_y;\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "ahrs.cos_yaw",
            "ahrs.sin_yaw"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ahrs.cos_yaw",
            "ahrs.sin_yaw"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)",
        "start_line": "529",
        "end_line": "542",
        "file_path": "ArduSub/GCS_Mavlink.cpp",
        "docstring": "This function, GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW, processes a MAVLink command to adjust the yaw condition.\\nIt checks if the yaw angle and param4 values are within acceptable ranges.\\nIf valid, it sets the yaw heading using the provided parameters and returns MAV_RESULT_ACCEPTED.\\nIf not valid, it returns MAV_RESULT_DENIED.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cc11e8079f6d",
        "ground_truth": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\n{\n        // param1 : target angle [0-360]\n        // param2 : speed during change [deg per second]\n        // param3 : direction (-1:ccw, +1:cw)\n        // param4 : relative offset (1) or absolute angle (0)\n        if ((packet.param1 >= 0.0f)   &&\n            (packet.param1 <= 360.0f) &&\n            (is_zero(packet.param4) || is_equal(packet.param4,1.0f))) {\n            sub.mode_auto.set_auto_yaw_look_at_heading(packet.param1, packet.param2, (int8_t)packet.param3, (uint8_t)packet.param4);\n            return MAV_RESULT_ACCEPTED;\n        }\n        return MAV_RESULT_DENIED;\n}",
        "import_statements": [
            "#include \"Sub.h\"\n",
            "#include \"GCS_Mavlink.h\"\n",
            "#include <AP_RPM/AP_RPM_config.h>\n"
        ],
        "reference_api": [
            "sub.mode_auto.set_auto_yaw_look_at_heading",
            "is_zero",
            "is_equal"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "sub.mode_auto.set_auto_yaw_look_at_heading",
            "is_zero",
            "is_equal"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const",
        "start_line": "880",
        "end_line": "888",
        "file_path": "ArduSub/GCS_Mavlink.cpp",
        "docstring": "This function, GCS_MAVLINK_Sub::high_latency_tgt_heading, returns the target heading in degrees divided by 2.\\nIf the control mode is AUTO or GUIDED, it converts the waypoint bearing from -18000->18000 to 0->360 and then divides by 2.\\nIf the control mode is not AUTO or GUIDED, it returns 0.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ffe0f0f67d97",
        "ground_truth": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\n{\n    // return units are deg/2\n    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {\n        // need to convert -18000->18000 to 0->360/2\n        return wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination()) / 200;\n    }\n    return 0;      \n}",
        "import_statements": [
            "#include \"Sub.h\"\n",
            "#include \"GCS_Mavlink.h\"\n",
            "#include <AP_RPM/AP_RPM_config.h>\n"
        ],
        "reference_api": [
            "sub.wp_nav.get_wp_bearing_to_destination",
            "wrap_360_cd"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "sub.wp_nav.get_wp_bearing_to_destination",
            "wrap_360_cd"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Sub::Log_Write_Data(LogDataID id, int32_t value)",
        "start_line": "121",
        "end_line": "132",
        "file_path": "ArduSub/Log.cpp",
        "docstring": "This function, Sub::Log_Write_Data, logs a 32-bit integer value if logging is enabled.\\nIt creates a log packet with the current time, log data ID, and value, then writes this packet to the logger as a critical block.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "33e0b011f6a7",
        "ground_truth": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\n{\n    if (should_log(MASK_LOG_ANY)) {\n        struct log_Data_Int32t pkt = {\n            LOG_PACKET_HEADER_INIT(LOG_DATA_INT32_MSG),\n            time_us  : AP_HAL::micros64(),\n            id          : (uint8_t)id,\n            data_value  : value\n        };\n        logger.WriteCriticalBlock(&pkt, sizeof(pkt));\n    }\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "LOG_PACKET_HEADER_INIT",
            "logger.WriteCriticalBlock",
            "should_log",
            "AP_HAL::micros64"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "LOG_PACKET_HEADER_INIT",
            "logger.WriteCriticalBlock",
            "should_log",
            "AP_HAL::micros64"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Sub::update_home_from_EKF()",
        "start_line": "4",
        "end_line": "20",
        "file_path": "ArduSub/commands.cpp",
        "docstring": "This function, Sub::update_home_from_EKF, updates the home location based on EKF data.\\nIf the home is already set, it exits immediately.\\nIf the motors are armed, it sets the home to the current location in-flight.\\nIf the motors are not armed, it attempts to set the home to the current EKF location and ignores any failure in this attempt.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9d8f6294ccf1",
        "ground_truth": "void Sub::update_home_from_EKF()\n{\n    // exit immediately if home already set\n    if (ahrs.home_is_set()) {\n        return;\n    }\n     // special logic if home is set in-flight\n    if (motors.armed()) {\n        set_home_to_current_location_inflight();\n    } else {\n        // move home to current ekf location (this will set home_state to HOME_SET)\n        if (!set_home_to_current_location(false)) {\n            // ignore this failure\n        }\n    }\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "set_home_to_current_location",
            "set_home_to_current_location_inflight",
            "ahrs.home_is_set",
            "motors.armed"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "set_home_to_current_location",
                "code": "bool Sub::set_home_to_current_location(bool lock)\n{\n    // get current location from EKF\n    Location temp_loc;\n    if (ahrs.get_location(temp_loc)) {\n\n        // Make home always at the water's surface.\n        // This allows disarming and arming again at depth.\n        // This also ensures that mission items with relative altitude frame, are always\n        // relative to the water's surface, whether in a high elevation lake, or at sea level.\n        temp_loc.alt -= barometer.get_altitude() * 100.0f;\n        return set_home(temp_loc, lock);\n    }\n    return false;\n}"
            },
            {
                "name": "set_home_to_current_location_inflight",
                "code": "void Sub::set_home_to_current_location_inflight()\n{\n    // get current location from EKF\n    Location temp_loc;\n    Location ekf_origin;\n    if (ahrs.get_location(temp_loc) && ahrs.get_origin(ekf_origin)) {\n        temp_loc.alt = ekf_origin.alt;\n        if (!set_home(temp_loc, false)) {\n            // ignore this failure\n        }\n    }\n}"
            }
        ],
        "third_party": [
            "ahrs.home_is_set",
            "motors.armed"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void ModeAcro::run()",
        "start_line": "19",
        "end_line": "46",
        "file_path": "ArduSub/mode_acro.cpp",
        "docstring": "This function, ModeAcro::run, controls the copter's behavior in Acro mode.\\nIf the motors are not armed, it sets the throttle to zero, adjusts the spool state, relaxes the attitude controllers, and exits.\\nIf armed, it sets the spool state to unlimited throttle, converts pilot inputs to desired body frame rates, and runs the attitude controller with these rates.\\nIt outputs the pilot's throttle input without angle boost and sets the forward and lateral motor inputs based on pilot controls.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3f01d797b484",
        "ground_truth": "void ModeAcro::run()\n{\n    float target_roll, target_pitch, target_yaw;\n     // if not armed set throttle to zero and exit immediately\n    if (!motors.armed()) {\n        motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->set_throttle_out(0,true,g.throttle_filt);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n     motors.set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n     // convert the input to the desired body frame rate\n    get_pilot_desired_angle_rates(channel_roll->get_control_in(), channel_pitch->get_control_in(), channel_yaw->get_control_in(), target_roll, target_pitch, target_yaw);\n     // run attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw);\n     // output pilot's throttle without angle boost\n    attitude_control->set_throttle_out(channel_throttle->norm_input(), false, g.throttle_filt);\n     //control_in is range 0-1000\n    //radio_in is raw pwm value\n    motors.set_forward(channel_forward->norm_input());\n    motors.set_lateral(channel_lateral->norm_input());\n}",
        "import_statements": [
            "#include \"Sub.h\"\n",
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "channel_forward->norm_input",
            "channel_roll->get_control_in",
            "channel_pitch->get_control_in",
            "motors.set_lateral",
            "get_pilot_desired_angle_rates",
            "attitude_control->input_rate_bf_roll_pitch_yaw",
            "motors.armed",
            "channel_yaw->get_control_in",
            "channel_throttle->norm_input",
            "motors.set_forward",
            "attitude_control->set_throttle_out",
            "channel_lateral->norm_input",
            "motors.set_desired_spool_state",
            "attitude_control->relax_attitude_controllers"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "channel_forward->norm_input",
            "channel_roll->get_control_in",
            "channel_pitch->get_control_in",
            "motors.set_lateral",
            "get_pilot_desired_angle_rates",
            "attitude_control->input_rate_bf_roll_pitch_yaw",
            "motors.armed",
            "channel_yaw->get_control_in",
            "channel_throttle->norm_input",
            "motors.set_forward",
            "attitude_control->set_throttle_out",
            "channel_lateral->norm_input",
            "motors.set_desired_spool_state",
            "attitude_control->relax_attitude_controllers"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void ModeGuided::guided_pos_control_start()",
        "start_line": "78",
        "end_line": "97",
        "file_path": "ArduSub/mode_guided.cpp",
        "docstring": "This function, ModeGuided::guided_pos_control_start, initializes guided position control mode by setting it to position control mode and initializing the waypoint controller.\\nIt retrieves the stopping point, sets it as the waypoint destination, and initializes the yaw using the default auto yaw mode.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b2f5c47e5e03",
        "ground_truth": "void ModeGuided::guided_pos_control_start()\n{\n    // set to position control mode\n    sub.guided_mode = Guided_WP;\n     // initialise waypoint controller\n    sub.wp_nav.wp_and_spline_init();\n     // initialise wpnav to stopping point at current altitude\n    // To-Do: set to current location if disarmed?\n    // To-Do: set to stopping point altitude?\n    Vector3f stopping_point;\n    sub.wp_nav.get_wp_stopping_point(stopping_point);\n     // no need to check return status because terrain data is not used\n    sub.wp_nav.set_wp_destination(stopping_point, false);\n     // initialise yaw\n    set_auto_yaw_mode(get_default_auto_yaw_mode(false));\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "sub.wp_nav.set_wp_destination",
            "sub.wp_nav.get_wp_stopping_point",
            "set_auto_yaw_mode",
            "get_default_auto_yaw_mode",
            "sub.wp_nav.wp_and_spline_init"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "set_auto_yaw_mode",
                "code": "void ModeGuided::set_auto_yaw_mode(autopilot_yaw_mode yaw_mode)\n{\n    // return immediately if no change\n    if (sub.auto_yaw_mode == yaw_mode) {\n        return;\n    }\n    sub.auto_yaw_mode = yaw_mode;\n\n    // perform initialisation\n    switch (sub.auto_yaw_mode) {\n    \n    case AUTO_YAW_HOLD:\n        // pilot controls the heading\n        break;\n\n    case AUTO_YAW_LOOK_AT_NEXT_WP:\n        // wpnav will initialise heading when wpnav's set_destination method is called\n        break;\n\n    case AUTO_YAW_ROI:\n        // point towards a location held in yaw_look_at_WP\n        sub.yaw_look_at_WP_bearing = ahrs.yaw_sensor;\n        break;\n\n    case AUTO_YAW_LOOK_AT_HEADING:\n        // keep heading pointing in the direction held in yaw_look_at_heading\n        // caller should set the yaw_look_at_heading\n        break;\n\n    case AUTO_YAW_LOOK_AHEAD:\n        // Commanded Yaw to automatically look ahead.\n        sub.yaw_look_ahead_bearing = ahrs.yaw_sensor;\n        break;\n\n    case AUTO_YAW_RESETTOARMEDYAW:\n        // initial_armed_bearing will be set during arming so no init required\n        break;\n    \n    case AUTO_YAW_RATE:\n        // set target yaw rate to yaw_look_at_heading_slew\n        break;\n    }\n}"
            },
            {
                "name": "get_default_auto_yaw_mode",
                "code": "autopilot_yaw_mode ModeGuided::get_default_auto_yaw_mode(bool rtl) const\n{\n    switch (g.wp_yaw_behavior) {\n\n    case WP_YAW_BEHAVIOR_NONE:\n        return AUTO_YAW_HOLD;\n        break;\n\n    case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP_EXCEPT_RTL:\n        if (rtl) {\n            return AUTO_YAW_HOLD;\n        } else {\n            return AUTO_YAW_LOOK_AT_NEXT_WP;\n        }\n        break;\n\n    case WP_YAW_BEHAVIOR_LOOK_AHEAD:\n        return AUTO_YAW_LOOK_AHEAD;\n        break;\n\n    case WP_YAW_BEHAVIOR_CORRECT_XTRACK:\n        return AUTO_YAW_CORRECT_XTRACK;\n        break;\n\n    case WP_YAW_BEHAVIOR_LOOK_AT_NEXT_WP:\n    default:\n        return AUTO_YAW_LOOK_AT_NEXT_WP;\n        break;\n    }\n}"
            }
        ],
        "third_party": [
            "sub.wp_nav.set_wp_destination",
            "sub.wp_nav.get_wp_stopping_point",
            "sub.wp_nav.wp_and_spline_init"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void ModeGuided::guided_vel_control_start()",
        "start_line": "100",
        "end_line": "115",
        "file_path": "ArduSub/mode_guided.cpp",
        "docstring": "This function, ModeGuided::guided_vel_control_start, sets the guided mode to velocity controller.\\nIt initializes vertical maximum speeds and acceleration using pilot-defined parameters.\\nIt then initializes the vertical and horizontal velocity controllers.\\nFinally, it sets the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "324de618ad6c",
        "ground_truth": "void ModeGuided::guided_vel_control_start()\n{\n    // set guided_mode to velocity controller\n    sub.guided_mode = Guided_Velocity;\n     // initialize vertical maximum speeds and acceleration\n    position_control->set_max_speed_accel_z(-sub.get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n    position_control->set_correction_speed_accel_z(-sub.get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n     // initialise velocity controller\n    position_control->init_z_controller();\n    position_control->init_xy_controller();\n     // pilot always controls yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "position_control->init_xy_controller",
            "position_control->set_max_speed_accel_z",
            "position_control->init_z_controller",
            "position_control->set_correction_speed_accel_z",
            "set_auto_yaw_mode",
            "sub.get_pilot_speed_dn"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "set_auto_yaw_mode",
                "code": "void ModeGuided::set_auto_yaw_mode(autopilot_yaw_mode yaw_mode)\n{\n    // return immediately if no change\n    if (sub.auto_yaw_mode == yaw_mode) {\n        return;\n    }\n    sub.auto_yaw_mode = yaw_mode;\n\n    // perform initialisation\n    switch (sub.auto_yaw_mode) {\n    \n    case AUTO_YAW_HOLD:\n        // pilot controls the heading\n        break;\n\n    case AUTO_YAW_LOOK_AT_NEXT_WP:\n        // wpnav will initialise heading when wpnav's set_destination method is called\n        break;\n\n    case AUTO_YAW_ROI:\n        // point towards a location held in yaw_look_at_WP\n        sub.yaw_look_at_WP_bearing = ahrs.yaw_sensor;\n        break;\n\n    case AUTO_YAW_LOOK_AT_HEADING:\n        // keep heading pointing in the direction held in yaw_look_at_heading\n        // caller should set the yaw_look_at_heading\n        break;\n\n    case AUTO_YAW_LOOK_AHEAD:\n        // Commanded Yaw to automatically look ahead.\n        sub.yaw_look_ahead_bearing = ahrs.yaw_sensor;\n        break;\n\n    case AUTO_YAW_RESETTOARMEDYAW:\n        // initial_armed_bearing will be set during arming so no init required\n        break;\n    \n    case AUTO_YAW_RATE:\n        // set target yaw rate to yaw_look_at_heading_slew\n        break;\n    }\n}"
            }
        ],
        "third_party": [
            "position_control->init_xy_controller",
            "position_control->set_max_speed_accel_z",
            "position_control->init_z_controller",
            "position_control->set_correction_speed_accel_z",
            "sub.get_pilot_speed_dn"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool ModeGuided::guided_limit_check()",
        "start_line": "851",
        "end_line": "881",
        "file_path": "ArduSub/mode_guided.cpp",
        "docstring": "This function, ModeGuided::guided_limit_check, checks various limits to determine if guided mode should be terminated.\\nIt verifies if a timeout has been exceeded, if the current altitude is below a minimum or above a maximum threshold, and if the horizontal distance moved exceeds a specified limit.\\nIf any of these conditions are met, it returns true; otherwise, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3100e2efb0fe",
        "ground_truth": "bool ModeGuided::guided_limit_check()\n{\n    // check if we have passed the timeout\n    if ((guided_limit.timeout_ms > 0) && (AP_HAL::millis() - guided_limit.start_time >= guided_limit.timeout_ms)) {\n        return true;\n    }\n     // get current location\n    const Vector3f& curr_pos = inertial_nav.get_position_neu_cm();\n     // check if we have gone below min alt\n    if (!is_zero(guided_limit.alt_min_cm) && (curr_pos.z < guided_limit.alt_min_cm)) {\n        return true;\n    }\n     // check if we have gone above max alt\n    if (!is_zero(guided_limit.alt_max_cm) && (curr_pos.z > guided_limit.alt_max_cm)) {\n        return true;\n    }\n     // check if we have gone beyond horizontal limit\n    if (guided_limit.horiz_max_cm > 0.0f) {\n        const float horiz_move = get_horizontal_distance_cm(guided_limit.start_pos.xy(), curr_pos.xy());\n        if (horiz_move > guided_limit.horiz_max_cm) {\n            return true;\n        }\n    }\n     // if we got this far we must be within limits\n    return false;\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "is_zero",
            "AP_HAL::millis",
            "curr_pos.xy",
            "get_horizontal_distance_cm",
            "guided_limit.start_pos.xy",
            "inertial_nav.get_position_neu_cm"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "is_zero",
            "AP_HAL::millis",
            "curr_pos.xy",
            "get_horizontal_distance_cm",
            "guided_limit.start_pos.xy",
            "inertial_nav.get_position_neu_cm"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool Sub::verify_motor_test()",
        "start_line": "65",
        "end_line": "83",
        "file_path": "ArduSub/motors.cpp",
        "docstring": "This function, Sub::verify_motor_test, verifies the motor test by checking if motor test requests are received at least every 2 Hz.\\nIf the requests time out, it sends a timeout message, sets the pass flag to false, disables the motor test, disarms the system, records the failure time, and returns false.\\nIf the test passes, it returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5b8f035aca37",
        "ground_truth": "bool Sub::verify_motor_test()\n{\n    bool pass = true;\n     // Require at least 2 Hz incoming do_set_motor requests\n    if (AP_HAL::millis() > last_do_motor_test_ms + 500) {\n        gcs().send_text(MAV_SEVERITY_INFO, \"Motor test timed out!\");\n        pass = false;\n    }\n     if (!pass) {\n        ap.motor_test = false;\n        AP::arming().disarm(AP_Arming::Method::MOTORTEST);\n        last_do_motor_test_fail_ms = AP_HAL::millis();\n        return false;\n    }\n     return true;\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "AP::arming",
            "AP_HAL::millis",
            "AP::arming().disarm",
            "gcs",
            "gcs().send_text"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "AP::arming",
            "AP_HAL::millis",
            "AP::arming().disarm",
            "gcs",
            "gcs().send_text"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)",
        "start_line": "138",
        "end_line": "152",
        "file_path": "ArduSub/motors.cpp",
        "docstring": "This function, Sub::translate_wpnav_rp, retrieves roll and pitch targets from wp_nav in centidegrees.\\nIt constrains these targets within a specified maximum angle range, normalizes them, and assigns the normalized values to lateral_out and forward_out.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b2afbbd2ff1f",
        "ground_truth": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\n{\n    // get roll and pitch targets in centidegrees\n    int32_t lateral = wp_nav.get_roll();\n    int32_t forward = -wp_nav.get_pitch(); // output is reversed\n     // constrain target forward/lateral values\n    // The outputs of wp_nav.get_roll and get_pitch should already be constrained to these values\n    lateral = constrain_int16(lateral, -aparm.angle_max, aparm.angle_max);\n    forward = constrain_int16(forward, -aparm.angle_max, aparm.angle_max);\n     // Normalize\n    lateral_out = (float)lateral/(float)aparm.angle_max;\n    forward_out = (float)forward/(float)aparm.angle_max;\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "wp_nav.get_pitch",
            "wp_nav.get_roll",
            "constrain_int16"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "wp_nav.get_pitch",
            "wp_nav.get_roll",
            "constrain_int16"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "void Sub::read_barometer()",
        "start_line": "4",
        "end_line": "16",
        "file_path": "ArduSub/sensors.cpp",
        "docstring": "This function, Sub::read_barometer, updates the barometer data.\\nIf the altitude is above zero, it updates the barometer calibration.\\nIf a depth sensor is present, it updates the sensor health status based on the barometer's health.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8237462c02d4",
        "ground_truth": "void Sub::read_barometer()\n{\n    barometer.update();\n    // If we are reading a positive altitude, the sensor needs calibration\n    // Even a few meters above the water we should have no significant depth reading\n    if(barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n     if (ap.depth_sensor_present) {\n        sensor_health.depth = barometer.healthy(depth_sensor_idx);\n    }\n}",
        "import_statements": [
            "#include \"Sub.h\"\n"
        ],
        "reference_api": [
            "barometer.get_altitude",
            "barometer.update",
            "barometer.healthy",
            "barometer.update_calibration"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "barometer.get_altitude",
            "barometer.update",
            "barometer.healthy",
            "barometer.update_calibration"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool Sub::ekf_position_ok()",
        "start_line": "192",
        "end_line": "209",
        "file_path": "ArduSub/system.cpp",
        "docstring": "This function, Sub::ekf_position_ok, checks the validity of the EKF position for navigation.\\nIf inertial navigation is not available, it returns false.\\nIf the motors are disarmed, it accepts a predicted horizontal position.\\nIf the motors are armed, it requires a good absolute position and ensures the EKF is not in constant position mode.\\nIt returns true if these conditions are met.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fa05e0fdd752",
        "ground_truth": "bool Sub::ekf_position_ok()\n{\n    if (!ahrs.have_inertial_nav()) {\n        // do not allow navigation with dcm position\n        return false;\n    }\n     // with EKF use filter status and ekf check\n    nav_filter_status filt_status = inertial_nav.get_filter_status();\n     // if disarmed we accept a predicted horizontal position\n    if (!motors.armed()) {\n        return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));\n    }\n     // once armed we require a good absolute position and EKF must not be in const_pos_mode\n    return (filt_status.flags.horiz_pos_abs && !filt_status.flags.const_pos_mode);\n}",
        "import_statements": [
            "#include \"Sub.h\"\n",
            "#include <AP_AdvancedFailsafe/AP_AdvancedFailsafe.h>\n",
            "#include <AP_Avoidance/AP_Avoidance.h>\n",
            "#include <AP_ADSB/AP_ADSB.h>\n"
        ],
        "reference_api": [
            "inertial_nav.get_filter_status",
            "motors.armed",
            "ahrs.have_inertial_nav"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "inertial_nav.get_filter_status",
            "motors.armed",
            "ahrs.have_inertial_nav"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool AP_Arming_Rover::gps_checks(bool display_failure)",
        "start_line": "35",
        "end_line": "70",
        "file_path": "Rover/AP_Arming.cpp",
        "docstring": "This function, AP_Arming_Rover::gps_checks, performs GPS checks for a rover.\\nIf the current control mode does not require position or velocity, it returns true.\\nIt calls the parent class's GPS checks and returns false if they fail.\\nIt checks if the AHRS system is ready and if the EKF failsafe is active, returning false if either check fails.\\nIt also ensures the position estimate is valid, returning false if not.\\nIf all checks pass, it returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "86658e22ec4a",
        "ground_truth": "bool AP_Arming_Rover::gps_checks(bool display_failure)\n{\n    if (!rover.control_mode->requires_position() && !rover.control_mode->requires_velocity()) {\n        // we don't care!\n        return true;\n    }\n     // call parent gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n     const AP_AHRS &ahrs = AP::ahrs();\n     // always check if inertial nav has started and is ready\n    char failure_msg[50] = {};\n    if (!ahrs.pre_arm_check(true, failure_msg, sizeof(failure_msg))) {\n        check_failed(display_failure, \"AHRS: %s\", failure_msg);\n        return false;\n    }\n     // check for ekf failsafe\n    if (rover.failsafe.ekf) {\n        check_failed(display_failure, \"EKF failsafe\");\n        return false;\n    }\n     // ensure position estimate is ok\n    if (!rover.ekf_position_ok()) {\n        // vehicle level position estimate checks\n        check_failed(display_failure, \"Need Position Estimate\");\n        return false;\n    }\n     return true;\n}",
        "import_statements": [
            "#include \"AP_Arming.h\"\n",
            "#include \"Rover.h\"\n"
        ],
        "reference_api": [
            "rover.control_mode->requires_position",
            "AP::ahrs",
            "ahrs.pre_arm_check",
            "rover.control_mode->requires_velocity",
            "AP_Arming::gps_checks",
            "rover.ekf_position_ok",
            "check_failed"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rover.control_mode->requires_position",
            "AP::ahrs",
            "ahrs.pre_arm_check",
            "rover.control_mode->requires_velocity",
            "AP_Arming::gps_checks",
            "rover.ekf_position_ok",
            "check_failed"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ArduPilot/ardupilot",
        "function_declaration": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)",
        "start_line": "119",
        "end_line": "140",
        "file_path": "Rover/AP_Arming.cpp",
        "docstring": "This function, AP_Arming_Rover::arm, attempts to arm the rover using the specified method and performs arming checks if required.\\nIf arming fails, it sets an arming_failed event and returns false.\\nIf arming succeeds, it sets the SmartRTL home location, initializes the simple mode heading, records the home heading for sail vehicles, updates the soft armed status, sends an arm/disarm status text, and returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ec68de91b0e9",
        "ground_truth": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\n{\n    if (!AP_Arming::arm(method, do_arming_checks)) {\n        AP_Notify::events.arming_failed = true;\n        return false;\n    }\n     // Set the SmartRTL home location. If activated, SmartRTL will ultimately try to land at this point\n    rover.g2.smart_rtl.set_home(true);\n     // initialize simple mode heading\n    rover.mode_simple.init_heading();\n     // save home heading for use in sail vehicles\n    rover.g2.windvane.record_home_heading();\n     update_soft_armed();\n     send_arm_disarm_statustext(\"Throttle armed\");\n     return true;\n}",
        "import_statements": [
            "#include \"AP_Arming.h\"\n",
            "#include \"Rover.h\"\n"
        ],
        "reference_api": [
            "update_soft_armed",
            "rover.g2.smart_rtl.set_home",
            "rover.mode_simple.init_heading",
            "AP_Arming::arm",
            "rover.g2.windvane.record_home_heading",
            "send_arm_disarm_statustext"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "update_soft_armed",
                "code": "void AP_Arming_Rover::update_soft_armed()\n{\n    hal.util->set_soft_armed(is_armed() &&\n                             hal.util->safety_switch_state() != AP_HAL::Util::SAFETY_DISARMED);\n#if HAL_LOGGING_ENABLED\n    AP::logger().set_vehicle_armed(hal.util->get_soft_armed());\n#endif\n}"
            }
        ],
        "third_party": [
            "rover.g2.smart_rtl.set_home",
            "rover.mode_simple.init_heading",
            "AP_Arming::arm",
            "rover.g2.windvane.record_home_heading",
            "send_arm_disarm_statustext"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ClemensElflein/OpenMower",
        "function_declaration": "void updateChargingEnabled()",
        "start_line": "611",
        "end_line": "631",
        "file_path": "Firmware/LowLevel/src/main.cpp",
        "docstring": "This function, updateChargingEnabled, controls the charging state based on the charging_allowed flag.\\nIf charging is allowed but should not continue, it disables charging and records the time.\\nIf charging is not allowed, it retries enabling charging after a specified delay, checking the conditions again to decide whether to enable or continue disabling charging.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f27a1a799e44",
        "ground_truth": "void updateChargingEnabled() {\n    if (charging_allowed) {\n        if (!checkShouldCharge()) {\n            digitalWrite(PIN_ENABLE_CHARGE, LOW);\n            charging_allowed = false;\n            charging_disabled_time = millis();\n        }\n    } else {\n        // enable charging after CHARGING_RETRY_MILLIS\n        if (millis() - charging_disabled_time > CHARGING_RETRY_MILLIS) {\n            if (!checkShouldCharge()) {\n                digitalWrite(PIN_ENABLE_CHARGE, LOW);\n                charging_allowed = false;\n                charging_disabled_time = millis();\n            } else {\n                digitalWrite(PIN_ENABLE_CHARGE, HIGH);\n                charging_allowed = true;\n            }\n        }\n    }\n}",
        "import_statements": [
            "#include <NeoPixelConnect.h>\n",
            "#include <Arduino.h>\n",
            "#include <FastCRC.h>\n",
            "#include <PacketSerial.h>\n",
            "#include \"datatypes.h\"\n",
            "#include \"pins.h\"\n",
            "#include \"ui_board.h\"\n",
            "#include \"imu.h\"\n"
        ],
        "reference_api": [
            "digitalWrite",
            "checkShouldCharge",
            "millis"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "checkShouldCharge",
                "code": "bool checkShouldCharge() {\n    return status_message.v_charge < 30.0 && status_message.charging_current < 1.5 && status_message.v_battery < 29.0;\n}"
            }
        ],
        "third_party": [
            "digitalWrite",
            "millis"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ClemensElflein/OpenMower",
        "function_declaration": "void sendMessage(void *message, size_t size)",
        "start_line": "756",
        "end_line": "773",
        "file_path": "Firmware/LowLevel/src/main.cpp",
        "docstring": "This function, sendMessage, sends a message if ROS is running.\\nIt first checks if ROS is running and the message size is at least 4 bytes.\\nIt calculates a CRC for the message, appends it to the message, and sends the message using packetSerial.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "519b3db03cbf",
        "ground_truth": "void sendMessage(void *message, size_t size) {\n    // Only send messages, if ROS is running, else Raspi sometimes doesn't boot\n    if (!ROS_running)\n        return;\n\n    // packages need to be at least 1 byte of type, 1 byte of data and 2 bytes of CRC\n    if (size < 4) {\n        return;\n    }\n    uint8_t *data_pointer = (uint8_t *) message;\n\n    // calculate the CRC\n    uint16_t crc = CRC16.ccitt((uint8_t *) message, size - 2);\n    data_pointer[size - 1] = (crc >> 8) & 0xFF;\n    data_pointer[size - 2] = crc & 0xFF;\n\n    packetSerial.send((uint8_t *) message, size);\n}",
        "import_statements": [
            "#include <NeoPixelConnect.h>\n",
            "#include <Arduino.h>\n",
            "#include <FastCRC.h>\n",
            "#include <PacketSerial.h>\n",
            "#include \"datatypes.h\"\n",
            "#include \"pins.h\"\n",
            "#include \"ui_board.h\"\n",
            "#include \"imu.h\"\n"
        ],
        "reference_api": [
            "packetSerial.send",
            "CRC16.ccitt"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "packetSerial.send",
            "CRC16.ccitt"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ClemensElflein/OpenMower",
        "function_declaration": "bool MP3Sound::begin()",
        "start_line": "36",
        "end_line": "49",
        "file_path": "Firmware/LowLevel/src/soundsystem.cpp",
        "docstring": "This function, MP3Sound::begin, initializes the serial communication for the sound module and clears any existing data in the buffer.\\nIt then initializes the sound module and retrieves the number of sound files available on the SD card.\\nThe function returns true if there are one or more sound files available, indicating successful initialization.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0ac148219164",
        "ground_truth": "bool MP3Sound::begin()\n               {\n     // serial stream init for soundmodule\n    soundSerial.begin(9600);\n    soundSerial.flush();\n    while (soundSerial.available())\n        soundSerial.read();\n    // init soundmodule\n    sound_available = myMP3.begin(soundSerial,true);    \n    this->anzSoundfiles = myMP3.numSdTracks();\n    return this->anzSoundfiles > 0;\n}",
        "import_statements": [
            "#include <soundsystem.h>\n"
        ],
        "reference_api": [
            "myMP3.numSdTracks",
            "soundSerial.read",
            "myMP3.begin",
            "soundSerial.available",
            "soundSerial.begin",
            "soundSerial.flush"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "myMP3.numSdTracks",
            "soundSerial.read",
            "myMP3.begin",
            "soundSerial.available",
            "soundSerial.begin",
            "soundSerial.flush"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ClemensElflein/OpenMower",
        "function_declaration": "int MP3Sound::processSounds()",
        "start_line": "94",
        "end_line": "106",
        "file_path": "Firmware/LowLevel/src/soundsystem.cpp",
        "docstring": "This function, MP3Sound::processSounds, processes active sounds.\\nIt first checks the number of active sounds and returns this number if there are no sounds or if an MP3 is currently playing.\\nIf an MP3 is not playing, it retrieves and plays the last sound from the active sounds list, removes it from the list, and returns the updated number of active sounds.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "54f11991cc01",
        "ground_truth": "int MP3Sound::processSounds()\n{\n   int n = active_sounds.size(); \n   if (n == 0) return(n);\n   if (myMP3.isPlaying()) return(n);\n       int file2play = active_sounds.back();\n   myMP3.play(file2play);\n   active_sounds.pop_back();\n    return active_sounds.size();\n }",
        "import_statements": [
            "#include <soundsystem.h>\n"
        ],
        "reference_api": [
            "active_sounds.pop_back",
            "myMP3.play",
            "myMP3.isPlaying",
            "active_sounds.size",
            "active_sounds.back"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "active_sounds.pop_back",
            "myMP3.play",
            "myMP3.isPlaying",
            "active_sounds.size",
            "active_sounds.back"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)",
        "start_line": "67",
        "end_line": "83",
        "file_path": "src/controller/c/abstract_camera.c",
        "docstring": "This function, wb_abstract_camera_handle_command, processes commands for an abstract camera device.\\nIf the command is C_CAMERA_MEMORY_MAPPED_FILE, it cleans up any existing memory-mapped file and sets up a new one using the provided request.\\nFor any other command, it sets the command_handled flag to false.\\nIt returns whether the command was handled.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fb7393f9ebef",
        "ground_truth": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command) {\n  bool command_handled = true;\n  AbstractCamera *c = d->pdata;\n   switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      // Cleanup the previous memory mapped file if any.\n      image_cleanup(c->image);\n      image_setup(c->image, r);\n      break;\n     default:\n      command_handled = false;\n      break;\n  }\n  return command_handled;\n}",
        "import_statements": [
            "#include \"abstract_camera.h\"\n",
            "#include <stdio.h>\n",
            "#include <stdlib.h>\n",
            "#include <string.h>\n",
            "#include <webots/robot.h>\n",
            "#include \"messages.h\"\n",
            "#include \"robot_private.h\"\n"
        ],
        "reference_api": [
            "image_cleanup",
            "image_setup"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "image_cleanup",
            "image_setup"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "int wb_abstract_camera_get_height(WbDevice *d)",
        "start_line": "133",
        "end_line": "141",
        "file_path": "src/controller/c/abstract_camera.c",
        "docstring": "This function, wb_abstract_camera_get_height, retrieves the height of an abstract camera associated with a given device.\\nIt locks a mutex, accesses the height from the camera's data if available, unlocks the mutex, and returns the height or -1 if the camera data is not available.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4b123b2ae40e",
        "ground_truth": "int wb_abstract_camera_get_height(const WbDevice *d) {\n  int result = -1;\n  robot_mutex_lock();\n  const AbstractCamera *ac = d->pdata;\n  if (ac)\n    result = ac->height;\n  robot_mutex_unlock();\n  return result;\n}",
        "import_statements": [
            "#include \"abstract_camera.h\"\n",
            "#include <stdio.h>\n",
            "#include <stdlib.h>\n",
            "#include <string.h>\n",
            "#include <webots/robot.h>\n",
            "#include \"messages.h\"\n",
            "#include \"robot_private.h\"\n"
        ],
        "reference_api": [
            "robot_mutex_lock",
            "robot_mutex_unlock"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "robot_mutex_lock",
            "robot_mutex_unlock"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)",
        "start_line": "168",
        "end_line": "178",
        "file_path": "src/controller/c/accelerometer.c",
        "docstring": "This function, wb_accelerometer_get_sampling_period, retrieves the sampling period of an accelerometer given its device tag.\\nIt locks a mutex, gets the accelerometer structure, and if valid, sets the sampling period from the structure.\\nIf the device tag is invalid, it prints an error message.\\nFinally, it unlocks the mutex and returns the sampling period.",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "87059b84045d",
        "ground_truth": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag) {\n  int sampling_period = 0;\n  robot_mutex_lock();\n  const Accelerometer *acc = accelerometer_get_struct(tag);\n  if (acc)\n    sampling_period = acc->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\\n\", __FUNCTION__);\n  robot_mutex_unlock();\n  return sampling_period;\n}",
        "import_statements": [
            "#include <stdio.h>\n",
            "#include <stdlib.h>  // malloc and free\n",
            "#include <webots/accelerometer.h>\n",
            "#include <webots/nodes.h>\n",
            "#include <webots/robot.h>\n",
            "#include \"device_private.h\"\n",
            "#include \"messages.h\"\n",
            "#include \"robot_private.h\"\n"
        ],
        "reference_api": [
            "fprintf",
            "robot_mutex_lock",
            "accelerometer_get_struct",
            "robot_mutex_unlock"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "robot_mutex_lock",
            "accelerometer_get_struct",
            "robot_mutex_unlock"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)",
        "start_line": "52",
        "end_line": "57",
        "file_path": "src/controller/cpp/GPS.cpp",
        "docstring": "This function, GPS::convertToDegreesMinutesSeconds, converts a decimal degree value to a degrees, minutes, and seconds (DMS) format string.\\nIt uses the wb_gps_convert_to_degrees_minutes_seconds function to perform the conversion, stores the result in a std::string, frees the allocated memory, and returns the DMS string.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3550d350877a",
        "ground_truth": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree) {\n  const char *coordinatesString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  std::string coordinates = string(coordinatesString);\n  free(static_cast<void *>(const_cast<char *>(coordinatesString)));\n  return coordinates;\n}",
        "import_statements": [
            "#include <webots/gps.h>\n",
            "#include <webots/GPS.hpp>\n",
            "#include <cstdlib>\n"
        ],
        "reference_api": [
            "string",
            "static_cast<void *>",
            "wb_gps_convert_to_degrees_minutes_seconds",
            "free",
            "const_cast<char *>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "string",
            "static_cast<void *>",
            "wb_gps_convert_to_degrees_minutes_seconds",
            "const_cast<char *>"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)",
        "start_line": "64",
        "end_line": "92",
        "file_path": "src/ode/ode/src/fluid_dynamics/immersion_box.cpp",
        "docstring": "This function, dGeomBoxGetTangentPlane, calculates the tangent plane at a given point on a box geometry.\\nIt ensures the geometry is a box, computes the relative position of the point to the box center, and checks each axis for proximity to the box's surface.\\nThe function then sets the plane's normal and distance based on the closest surface.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "21eca9880c41",
        "ground_truth": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\n {\n   dUASSERT (g && g->type == dBoxClass,\"argument not a box\");\n    const dxBox *const b = (dxBox*) g;\n   const dReal *const center = b->final_posr->pos;\n   dVector3 p = { x - center[0], y - center[1], z - center[2] };\n   const dReal *const R = b->final_posr->R;\n   const dReal *const side = b->side;\n    static const dReal ZERO_THRESHOLD = 1e-3;\n   dReal sign = 0.0;\n   int i;\n   for (i = 0; i < 3; ++i) {\n     const dReal l = dCalcVectorDot3_41(R + i, p);\n     if (dFabs(l - 0.5 * side[i]) < ZERO_THRESHOLD) {\n       sign = 1.0;\n       break;\n     } else if (dFabs(l + 0.5 * side[i]) < ZERO_THRESHOLD) {\n       sign = -1.0;\n       break;\n     }\n   }\n    plane[0] =  sign * R[i];\n   plane[1] =  sign * R[i + 4];\n   plane[2] =  sign * R[i + 8];\n   plane[3] = x * plane[0] + y * plane[1] + z * plane[2];\n }",
        "import_statements": [
            "#include \"immersion_box.h\"\n",
            "#include <ode/objects.h>\n",
            "#include \"../collision_kernel.h\"\n",
            "#include <ode/fluid_dynamics/fluid_dynamics.h>\n",
            "#include <ode/fluid_dynamics/odemath_fluid_dynamics.h>\n",
            "#include \"immersion_kernel.h\"\n",
            "#include \"immersion_outline.h\"\n",
            "#include \"immersion_std.h\"\n",
            "#include <algorithm>\n"
        ],
        "reference_api": [
            "dUASSERT",
            "dFabs",
            "dCalcVectorDot3_41"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "dUASSERT",
            "dFabs",
            "dCalcVectorDot3_41"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)",
        "start_line": "530",
        "end_line": "539",
        "file_path": "src/ode/ode/src/fluid_dynamics/immersion_box.cpp",
        "docstring": "This function, dImmerseBox, checks the immersion of a dxBox object in a fluid plane.\\nIt asserts that the box has a body and the flags are valid.\\nIt initializes an sBoxImmersionData object with the box, fluid plane, immersion, and flags.\\nFinally, it performs the immersion checking and returns the result.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "78037ded1d5d",
        "ground_truth": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\n{\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(box->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n   sBoxImmersionData data(box, fluidPlane, immersion, flags);\n   return data.performImmersionChecking();\n}",
        "import_statements": [
            "#include \"immersion_box.h\"\n",
            "#include <ode/objects.h>\n",
            "#include \"../collision_kernel.h\"\n",
            "#include <ode/fluid_dynamics/fluid_dynamics.h>\n",
            "#include <ode/fluid_dynamics/odemath_fluid_dynamics.h>\n",
            "#include \"immersion_kernel.h\"\n",
            "#include \"immersion_outline.h\"\n",
            "#include \"immersion_std.h\"\n",
            "#include <algorithm>\n"
        ],
        "reference_api": [
            "dUASSERT",
            "data.performImmersionChecking",
            "dIASSERT"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "dUASSERT",
            "data.performImmersionChecking",
            "dIASSERT"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)",
        "start_line": "563",
        "end_line": "583",
        "file_path": "src/ode/ode/src/fluid_dynamics/immersion_box.cpp",
        "docstring": "This function, dImmerseBoxCapsule, checks for collisions between a box and a capsule.\\nIt first validates the input arguments.\\nIf a collision is detected, it sets the immersion parameters and computes the immersion plane for the capsule.\\nFinally, it calls dImmerseBox to process the immersion of the box in the fluid.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8a0465e493b5",
        "ground_truth": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\n{\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseBoxCapsule has no body or the second has no fluid\");\n   dContactGeom c[1];\n  const int collision = dCollideCapsuleBox(o2, o1, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n   dxBox *const box = (dxBox *) o1;\n  dxCapsule *const capsule = (dxCapsule *) o2;\n   immersion->g1 = o1;\n  immersion->g2 = o2;\n   dVector4 fluidPlane;\n  dGeomCapsuleGetImmersionPlane(capsule, fluidPlane);\n   return dImmerseBox (box, fluidPlane, flags, immersion);\n}",
        "import_statements": [
            "#include \"immersion_box.h\"\n",
            "#include <ode/objects.h>\n",
            "#include \"../collision_kernel.h\"\n",
            "#include <ode/fluid_dynamics/fluid_dynamics.h>\n",
            "#include <ode/fluid_dynamics/odemath_fluid_dynamics.h>\n",
            "#include \"immersion_kernel.h\"\n",
            "#include \"immersion_outline.h\"\n",
            "#include \"immersion_std.h\"\n",
            "#include <algorithm>\n"
        ],
        "reference_api": [
            "dCollideCapsuleBox",
            "dUASSERT",
            "dGeomCapsuleGetImmersionPlane",
            "dImmerseBox",
            "dIASSERT"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "dImmerseBox",
                "code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\n{\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(box->body, \"This box has no body and hence cannot be tested for immersion into a fluid\");\n\n  sBoxImmersionData data(box, fluidPlane, immersion, flags);\n\n  return data.performImmersionChecking();\n}"
            }
        ],
        "third_party": [
            "dCollideCapsuleBox",
            "dUASSERT",
            "dGeomCapsuleGetImmersionPlane",
            "dIASSERT"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const",
        "start_line": "147",
        "end_line": "156",
        "file_path": "src/ode/ode/src/fluid_dynamics/immersion_capsule.cpp",
        "docstring": "This function, sCapsuleImmersionData::normalizedImmersedHemisphereVolume, calculates the normalized volume of an immersed hemisphere using Simpson's rule for numerical integration.\\nIt divides the integration into two parts to handle potential singularities and sums the results to return the total volume.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "61daf30a6976",
        "ground_truth": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const {\n  static const int n = 50;\n  static const dReal singularityFactor = 0.9;\n   const dReal singularityStart = singularityFactor * sinTheta1;\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  dReal volume = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(0.0, singularityStart, n, data);\n  volume += simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>(singularityStart, sinTheta1, n, data);\n  return volume;\n}",
        "import_statements": [
            "#include <ode/objects.h>\n",
            "#include <ode/common.h>\n",
            "#include <ode/fluid_dynamics/immersion.h>\n",
            "#include <ode/fluid_dynamics/fluid_dynamics.h>\n",
            "#include <ode/fluid_dynamics/odemath_fluid_dynamics.h>\n",
            "#include \"immersion_revolution_data.h\"\n",
            "#include \"../collision_kernel.h\"\n",
            "#include \"../collision_std.h\"\n",
            "#include \"../collision_trimesh_internal.h\"\n",
            "#include \"immersion_std.h\"\n",
            "#include \"immersion_kernel.h\"\n",
            "#include \"immersion_outline.h\"\n"
        ],
        "reference_api": [
            "simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::volumeIntegrand>"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const",
        "start_line": "158",
        "end_line": "163",
        "file_path": "src/ode/ode/src/fluid_dynamics/immersion_capsule.cpp",
        "docstring": "This function, sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter, calculates the x-coordinate of the buoyancy center for an immersed hemisphere.\\nIt uses Simpson's rule for numerical integration over the hemisphere's surface.\\nThe function takes the immersion depth ratio, tangent of the initial angle, sine of the final angle, and volume as inputs.\\nIt returns the x-coordinate of the buoyancy center scaled by the radius and adjusted by the volume.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a56f300e5305",
        "ground_truth": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const {\n  static const int n = 100;\n  const sHemisphereIntegrationData data(zIOverR, 1.0 / tanTheta0);\n  const dReal xb = simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>(0.0, sinTheta1, n, data);\n  return (2.0 / 3.0) * m_fRadius * xb / volume;\n}",
        "import_statements": [
            "#include <ode/objects.h>\n",
            "#include <ode/common.h>\n",
            "#include <ode/fluid_dynamics/immersion.h>\n",
            "#include <ode/fluid_dynamics/fluid_dynamics.h>\n",
            "#include <ode/fluid_dynamics/odemath_fluid_dynamics.h>\n",
            "#include \"immersion_revolution_data.h\"\n",
            "#include \"../collision_kernel.h\"\n",
            "#include \"../collision_std.h\"\n",
            "#include \"../collision_trimesh_internal.h\"\n",
            "#include \"immersion_std.h\"\n",
            "#include \"immersion_kernel.h\"\n",
            "#include \"immersion_outline.h\"\n"
        ],
        "reference_api": [
            "simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "simpson<sHemisphereIntegrationData, &sHemisphereIntegrationData::xCenterOfMassIntegrand>"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "cyberbotics/webots",
        "function_declaration": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)",
        "start_line": "482",
        "end_line": "499",
        "file_path": "src/ode/ode/src/fluid_dynamics/immersion_capsule.cpp",
        "docstring": "This function, sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter, calculates the x-coordinate of the buoyancy center for an immersed hemisphere.\\nIt uses Simpson's rule for numerical integration over the hemisphere's surface.\\nThe function takes the immersion depth ratio, tangent of the initial angle, sine of the final angle, and volume as inputs.\\nIt returns the x-coordinate of the buoyancy center scaled by the radius and adjusted by the volume.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1b2c92a2e577",
        "ground_truth": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\n{\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT (o1->body && o2->fluid, \"The first argument of dImmerseCapsuleTrimesh has no body or the second has no fluid\");\n   dContactGeom c[1];\n  const int collision = dCollideCCTL(o2, o1, 1, c, sizeof(dContact));\n  if (collision == 0)\n    return 0;\n   immersion->g1 = o1;\n  immersion->g2 = o2;\n   dVector4 fluidPlane;\n  dGeomTriMeshGetImmersionPlane(o2, fluidPlane);\n   return dImmerseCapsule ((dxCapsule *) o1, fluidPlane, flags, immersion);\n}",
        "import_statements": [
            "#include <ode/objects.h>\n",
            "#include <ode/common.h>\n",
            "#include <ode/fluid_dynamics/immersion.h>\n",
            "#include <ode/fluid_dynamics/fluid_dynamics.h>\n",
            "#include <ode/fluid_dynamics/odemath_fluid_dynamics.h>\n",
            "#include \"immersion_revolution_data.h\"\n",
            "#include \"../collision_kernel.h\"\n",
            "#include \"../collision_std.h\"\n",
            "#include \"../collision_trimesh_internal.h\"\n",
            "#include \"immersion_std.h\"\n",
            "#include \"immersion_kernel.h\"\n",
            "#include \"immersion_outline.h\"\n"
        ],
        "reference_api": [
            "dCollideCCTL",
            "dGeomTriMeshGetImmersionPlane",
            "dUASSERT",
            "dImmerseCapsule",
            "dIASSERT"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "dImmerseCapsule",
                "code": "int dImmerseCapsule (const dxCapsule *capsule, const dReal *fluidPlane, int flags, dImmersionGeom *immersion)\n{\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n  dUASSERT(capsule->body, \"This capsule has no body and hence cannot be tested for immersion into a fluid\");\n\n  sCapsuleImmersionData data(capsule, fluidPlane, flags, immersion);\n  return data.performImmersionChecking();\n}"
            }
        ],
        "third_party": [
            "dCollideCCTL",
            "dGeomTriMeshGetImmersionPlane",
            "dUASSERT",
            "dIASSERT"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "NodeStatus SleepNode::onStart()",
        "start_line": "10",
        "end_line": "37",
        "file_path": "src/actions/sleep_node.cpp",
        "docstring": "This function, SleepNode::onStart, initializes the node by retrieving the sleep duration in milliseconds from the input.\\nIf the duration is missing or non-positive, it returns SUCCESS.\\nOtherwise, it sets the node status to RUNNING, starts a timer, and sets a callback to emit a wake-up signal when the timer expires.\\nIf the timer is aborted, it ensures the timer_waiting_ flag is reset.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "18924c6af690",
        "ground_truth": "NodeStatus SleepNode::onStart()\n{\n  unsigned msec = 0;\n  if(!getInput(\"msec\", msec))\n  {\n    throw RuntimeError(\"Missing parameter [msec] in SleepNode\");\n  }\n   if(msec <= 0)\n  {\n    return NodeStatus::SUCCESS;\n  }\n   setStatus(NodeStatus::RUNNING);\n   timer_waiting_ = true;\n   timer_id_ = timer_.add(std::chrono::milliseconds(msec), [this](bool aborted) {\n    std::unique_lock<std::mutex> lk(delay_mutex_);\n    if(!aborted)\n    {\n      emitWakeUpSignal();\n    }\n    timer_waiting_ = false;\n  });\n   return NodeStatus::RUNNING;\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/actions/sleep_node.h\"\n"
        ],
        "reference_api": [
            "RuntimeError",
            "std::chrono::milliseconds",
            "getInput",
            "timer_.add",
            "setStatus",
            "emitWakeUpSignal"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "RuntimeError",
            "getInput",
            "timer_.add",
            "setStatus",
            "emitWakeUpSignal"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "NodeStatus EntryUpdatedAction::tick()",
        "start_line": "39",
        "end_line": "67",
        "file_path": "src/actions/updated_action.cpp",
        "docstring": "This function, EntryUpdatedAction::tick, checks if an entry in the blackboard has been updated.\\nIt retrieves the entry and locks its mutex.\\nIt compares the current sequence ID with the previously stored sequence ID.\\nIf the IDs differ, it updates the stored sequence ID and returns NodeStatus::SUCCESS.\\nIf the IDs are the same or the entry is not found, it returns NodeStatus::FAILURE.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "decdbb003812",
        "ground_truth": "NodeStatus EntryUpdatedAction::tick()\n{\n  if(auto entry = config().blackboard->getEntry(entry_key_))\n  {\n    std::unique_lock lk(entry->entry_mutex);\n    const uint64_t current_id = entry->sequence_id;\n    const uint64_t previous_id = sequence_id_;\n    sequence_id_ = current_id;\n    /*\n    uint64_t previous_id = 0;\n    auto& previous_id_registry = details::GlobalSequenceRegistry();\n     // find the previous id in the registry.\n    auto it = previous_id_registry.find(entry.get());\n    if(it != previous_id_registry.end())\n    {\n      previous_id = it->second;\n    }\n    if(previous_id != current_id)\n    {\n      previous_id_registry[entry.get()] = current_id;\n    }*/\n    return (previous_id != current_id) ? NodeStatus::SUCCESS : NodeStatus::FAILURE;\n  }\n  else\n  {\n    return NodeStatus::FAILURE;\n  }\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/actions/updated_action.h\"\n",
            "#include \"behaviortree_cpp/bt_factory.h\"\n"
        ],
        "reference_api": [
            "config().blackboard->getEntry",
            "config"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "config().blackboard->getEntry",
            "config"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "size_t ParallelNode::successThreshold() const",
        "start_line": "147",
        "end_line": "157",
        "file_path": "src/controls/parallel_node.cpp",
        "docstring": "This function, ParallelNode::successThreshold, calculates the success threshold for a parallel node.\\nIf the success threshold is negative, it adjusts the value based on the number of child nodes, ensuring the result is non-negative.\\nIf the success threshold is non-negative, it returns it directly as a size_t.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d1eac9aa9b89",
        "ground_truth": "size_t ParallelNode::successThreshold() const\n{\n  if(success_threshold_ < 0)\n  {\n    return size_t(std::max(int(children_nodes_.size()) + success_threshold_ + 1, 0));\n  }\n  else\n  {\n    return size_t(success_threshold_);\n  }\n}",
        "import_statements": [
            "#include <algorithm>\n",
            "#include <cstddef>\n",
            "#include \"behaviortree_cpp/controls/parallel_node.h\"\n"
        ],
        "reference_api": [
            "size_t",
            "std::max",
            "int",
            "children_nodes_.size"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "size_t",
            "int",
            "children_nodes_.size"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "void Groot2Publisher::heartbeatLoop()",
        "start_line": "497",
        "end_line": "516",
        "file_path": "src/loggers/groot2_publisher.cpp",
        "docstring": "This function, Groot2Publisher::heartbeatLoop, continuously checks the status of a server's heartbeat.\\nIt runs in a loop, sleeping for 10 milliseconds between iterations.\\nThe function compares the current time with the last recorded heartbeat time to determine if the heartbeat is still active.\\nIf the heartbeat status changes, it enables or disables all breakpoints accordingly.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e5a42d88e4e1",
        "ground_truth": "void Groot2Publisher::heartbeatLoop()\n{\n  bool has_heartbeat = true;\n   while(_p->active_server)\n  {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n     auto now = std::chrono::system_clock::now();\n    bool prev_heartbeat = has_heartbeat;\n     has_heartbeat = (now - _p->last_heartbeat < _p->max_heartbeat_delay);\n     // if we loose or gain heartbeat, disable/enable all breakpoints\n    if(has_heartbeat != prev_heartbeat)\n    {\n      enableAllHooks(has_heartbeat);\n    }\n  }\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/loggers/groot2_publisher.h\"\n",
            "#include \"behaviortree_cpp/loggers/groot2_protocol.h\"\n",
            "#include \"behaviortree_cpp/xml_parsing.h\"\n",
            "#include \"cppzmq/zmq.hpp\"\n",
            "#include \"cppzmq/zmq_addon.hpp\"\n"
        ],
        "reference_api": [
            "std::this_thread::sleep_for",
            "enableAllHooks",
            "std::chrono::system_clock::now",
            "std::chrono::milliseconds"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "enableAllHooks",
                "code": "void BT::Groot2Publisher::enableAllHooks(bool enable)\n{\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  for(auto& [node_uid, hook] : _p->pre_hooks)\n  {\n    std::unique_lock<std::mutex> lk(hook->mutex);\n    hook->enabled = enable;\n    // when disabling, remember to wake up blocked ones\n    if(!hook->enabled && hook->mode == Monitor::Hook::Mode::BREAKPOINT)\n    {\n      lk.unlock();\n      hook->wakeup.notify_all();\n    }\n  }\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)",
        "start_line": "518",
        "end_line": "537",
        "file_path": "src/loggers/groot2_publisher.cpp",
        "docstring": "This function, Groot2Publisher::generateBlackboardsDump, generates a dump of specified blackboards in MessagePack format.\\nIt splits the input string of blackboard names and iterates through them.\\nFor each blackboard name, it finds the corresponding subtree and locks it.\\nIf the subtree is valid, it exports the blackboard to JSON and adds it to the JSON object.\\nFinally, it converts the JSON object to MessagePack format and returns it as a vector of uint8_t.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2b3229ac1588",
        "ground_truth": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\n{\n  auto json = nlohmann::json();\n  auto const bb_names = BT::splitString(bb_list, ';');\n  for(auto name : bb_names)\n  {\n    std::string const bb_name(name);\n    auto it = _p->subtrees.find(bb_name);\n     if(it != _p->subtrees.end())\n    {\n      // lock the weak pointer\n      if(auto subtree = it->second.lock())\n      {\n        json[bb_name] = ExportBlackboardToJSON(*subtree->blackboard);\n      }\n    }\n  }\n  return nlohmann::json::to_msgpack(json);\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/loggers/groot2_publisher.h\"\n",
            "#include \"behaviortree_cpp/loggers/groot2_protocol.h\"\n",
            "#include \"behaviortree_cpp/xml_parsing.h\"\n",
            "#include \"cppzmq/zmq.hpp\"\n",
            "#include \"cppzmq/zmq_addon.hpp\"\n"
        ],
        "reference_api": [
            "it->second.lock",
            "nlohmann::json::to_msgpack",
            "_p->subtrees.end",
            "BT::splitString",
            "_p->subtrees.find",
            "nlohmann::json",
            "ExportBlackboardToJSON"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "it->second.lock",
            "nlohmann::json::to_msgpack",
            "_p->subtrees.end",
            "BT::splitString",
            "_p->subtrees.find",
            "nlohmann::json",
            "ExportBlackboardToJSON"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)",
        "start_line": "598",
        "end_line": "630",
        "file_path": "src/loggers/groot2_publisher.cpp",
        "docstring": "This function, Groot2Publisher::unlockBreakpoint, attempts to unlock a breakpoint for a given node.\\nIt searches for the node by its UID and checks if the node exists and is valid.\\nIt retrieves the associated hook and locks its mutex.\\nIf the hook is in BREAKPOINT mode, it sets the desired status and removal flag, marks it as ready, and notifies all waiting threads.\\nThe function returns true if successful, otherwise false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "de734043ce56",
        "ground_truth": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\n{\n  auto it = _p->nodes_by_uid.find(node_uid);\n  if(it == _p->nodes_by_uid.end())\n  {\n    return false;\n  }\n  TreeNode::Ptr node = it->second.lock();\n  if(!node)\n  {\n    return false;\n  }\n   auto hook = getHook(pos, node_uid);\n  if(!hook)\n  {\n    return false;\n  }\n   {\n    std::unique_lock<std::mutex> lk(hook->mutex);\n    hook->desired_status = result;\n    hook->remove_when_done |= remove;\n    if(hook->mode == Monitor::Hook::Mode::BREAKPOINT)\n    {\n      hook->ready = true;\n      lk.unlock();\n      hook->wakeup.notify_all();\n    }\n  }\n  return true;\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/loggers/groot2_publisher.h\"\n",
            "#include \"behaviortree_cpp/loggers/groot2_protocol.h\"\n",
            "#include \"behaviortree_cpp/xml_parsing.h\"\n",
            "#include \"cppzmq/zmq.hpp\"\n",
            "#include \"cppzmq/zmq_addon.hpp\"\n"
        ],
        "reference_api": [
            "it->second.lock",
            "_p->nodes_by_uid.end",
            "hook->wakeup.notify_all",
            "getHook",
            "_p->nodes_by_uid.find",
            "lk.unlock"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getHook",
                "code": "Monitor::Hook::Ptr Groot2Publisher::getHook(Position pos, uint16_t node_uid)\n{\n  auto hooks = pos == Position::PRE ? &_p->pre_hooks : &_p->post_hooks;\n  std::unique_lock<std::mutex> lk(_p->hooks_map_mutex);\n  auto bk_it = hooks->find(node_uid);\n  if(bk_it == hooks->end())\n  {\n    return {};\n  }\n  return bk_it->second;\n}"
            }
        ],
        "third_party": [
            "it->second.lock",
            "_p->nodes_by_uid.end",
            "hook->wakeup.notify_all",
            "_p->nodes_by_uid.find",
            "lk.unlock"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "NodeStatus BT::ThreadedAction::executeTick()",
        "start_line": "189",
        "end_line": "231",
        "file_path": "src/action_node.cpp",
        "docstring": "This function, BT::ThreadedAction::executeTick, manages the execution of a tick action in a separate thread.\\nIf the node status is IDLE, it sets the status to RUNNING, resets halt_requested_, and starts a new asynchronous thread to run the tick function.\\nIf the tick function completes without a halt request, it updates the node status.\\nIf an exception occurs, it catches the exception, logs an error, and sets the node status to IDLE.\\nThe function also checks for any stored exceptions and rethrows them if present.\\nFinally, it returns the current status of the node.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3845c5a83a5d",
        "ground_truth": "NodeStatus BT::ThreadedAction::executeTick()\n{\n  using lock_type = std::unique_lock<std::mutex>;\n  //send signal to other thread.\n  // The other thread is in charge for changing the status\n  if(status() == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_ = false;\n    thread_handle_ = std::async(std::launch::async, [this]() {\n      try\n      {\n        auto status = tick();\n        if(!isHaltRequested())\n        {\n          setStatus(status);\n        }\n      }\n      catch(std::exception&)\n      {\n        std::cerr << \"\\nUncaught exception from tick(): [\" << registrationName() << \"/\"\n                  << name() << \"]\\n\"\n                  << std::endl;\n        // Set the exception pointer and the status atomically.\n        lock_type l(mutex_);\n        exptr_ = std::current_exception();\n        setStatus(BT::NodeStatus::IDLE);\n      }\n      emitWakeUpSignal();\n    });\n  }\n   lock_type l(mutex_);\n  if(exptr_)\n  {\n    // The official interface of std::exception_ptr does not define any move\n    // semantics. Thus, we copy and reset exptr_ manually.\n    const auto exptr_copy = exptr_;\n    exptr_ = nullptr;\n    std::rethrow_exception(exptr_copy);\n  }\n  return status();\n}",
        "import_statements": [
            "#include \"minicoro/minicoro.h\"\n",
            "#include \"behaviortree_cpp/action_node.h\"\n"
        ],
        "reference_api": [
            "registrationName",
            "isHaltRequested",
            "name",
            "std::async",
            "std::current_exception",
            "std::rethrow_exception",
            "tick",
            "setStatus",
            "emitWakeUpSignal",
            "status"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "isHaltRequested",
                "code": "bool StatefulActionNode::isHaltRequested() const\n{\n  return halt_requested_.load();\n}"
            },
            {
                "name": "tick",
                "code": "NodeStatus SimpleActionNode::tick()\n{\n  NodeStatus prev_status = status();\n\n  if(prev_status == NodeStatus::IDLE)\n  {\n    setStatus(NodeStatus::RUNNING);\n    prev_status = NodeStatus::RUNNING;\n  }\n\n  NodeStatus status = tick_functor_(*this);\n  if(status != prev_status)\n  {\n    setStatus(status);\n  }\n  return status;\n}"
            }
        ],
        "third_party": [
            "registrationName",
            "name",
            "setStatus",
            "emitWakeUpSignal",
            "status"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)",
        "start_line": "66",
        "end_line": "99",
        "file_path": "src/behavior_tree.cpp",
        "docstring": "This function, printTreeRecursively, prints a tree structure starting from the root_node to the provided output stream.\\nIt defines a recursive lambda function to handle the printing.\\nThe lambda function indents the output based on the node's depth, prints the node's name, and recursively prints the children for ControlNode or the child for DecoratorNode.\\nThe function begins and ends with separator lines.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "22e1acefc954",
        "ground_truth": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\n{\n  std::function<void(unsigned, const BT::TreeNode*)> recursivePrint;\n   recursivePrint = [&recursivePrint, &stream](unsigned indent, const BT::TreeNode* node) {\n    for(unsigned i = 0; i < indent; i++)\n    {\n      stream << \"   \";\n    }\n    if(!node)\n    {\n      stream << \"!nullptr!\" << std::endl;\n      return;\n    }\n    stream << node->name() << std::endl;\n    indent++;\n     if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n    {\n      for(const auto& child : control->children())\n      {\n        recursivePrint(indent, child);\n      }\n    }\n    else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n    {\n      recursivePrint(indent, decorator->child());\n    }\n  };\n   stream << \"----------------\" << std::endl;\n  recursivePrint(0, root_node);\n  stream << \"----------------\" << std::endl;\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/behavior_tree.h\"\n",
            "#include <cstring>\n"
        ],
        "reference_api": [
            "dynamic_cast<const BT::ControlNode*>",
            "decorator->child",
            "dynamic_cast<const BT::DecoratorNode*>",
            "node->name",
            "control->children",
            "recursivePrint"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "dynamic_cast<const BT::ControlNode*>",
            "decorator->child",
            "dynamic_cast<const BT::DecoratorNode*>",
            "node->name",
            "control->children",
            "recursivePrint"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)",
        "start_line": "18",
        "end_line": "39",
        "file_path": "src/behavior_tree.cpp",
        "docstring": "This function, applyRecursiveVisitor, applies a visitor function to a tree node and its children recursively.\\nIf the node is null, it throws a LogicError.\\nIt first applies the visitor function to the given node.\\nIf the node is a ControlNode, it recursively applies the visitor to all its children.\\nIf the node is a DecoratorNode, it recursively applies the visitor to its single child.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cf05b794dd43",
        "ground_truth": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\n{\n  if(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n   visitor(node);\n   if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/behavior_tree.h\"\n",
            "#include <cstring>\n"
        ],
        "reference_api": [
            "dynamic_cast<const BT::ControlNode*>",
            "decorator->child",
            "dynamic_cast<const BT::DecoratorNode*>",
            "applyRecursiveVisitor",
            "LogicError",
            "static_cast<const TreeNode*>",
            "control->children",
            "visitor"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "applyRecursiveVisitor",
                "code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\n{\n  if(!node)\n  {\n    throw LogicError(\"One of the children of a DecoratorNode or ControlNode is nullptr\");\n  }\n\n  visitor(node);\n\n  if(auto control = dynamic_cast<const BT::ControlNode*>(node))\n  {\n    for(const auto& child : control->children())\n    {\n      applyRecursiveVisitor(static_cast<const TreeNode*>(child), visitor);\n    }\n  }\n  else if(auto decorator = dynamic_cast<const BT::DecoratorNode*>(node))\n  {\n    applyRecursiveVisitor(decorator->child(), visitor);\n  }\n}"
            }
        ],
        "third_party": [
            "dynamic_cast<const BT::ControlNode*>",
            "decorator->child",
            "dynamic_cast<const BT::DecoratorNode*>",
            "LogicError",
            "static_cast<const TreeNode*>",
            "control->children",
            "visitor"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)",
        "start_line": "140",
        "end_line": "151",
        "file_path": "src/bt_factory.cpp",
        "docstring": "This function, BehaviorTreeFactory::registerBuilder, registers a new node builder with a given manifest.\\nIt first checks if the registration ID already exists in the builders map.\\nIf the ID is already registered, it throws a BehaviorTreeException.\\nIf not, it inserts the builder and manifest into their respective maps using the registration ID.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "72dfdacfbdb4",
        "ground_truth": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\n{\n  auto it = _p->builders.find(manifest.registration_ID);\n  if(it != _p->builders.end())\n  {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID, \"] already registered\");\n  }\n   _p->builders.insert({ manifest.registration_ID, builder });\n  _p->manifests.insert({ manifest.registration_ID, manifest });\n}",
        "import_statements": [
            "#include <filesystem>\n",
            "#include \"behaviortree_cpp/bt_factory.h\"\n",
            "#include \"behaviortree_cpp/utils/shared_library.h\"\n",
            "#include \"behaviortree_cpp/contrib/json.hpp\"\n",
            "#include \"behaviortree_cpp/xml_parsing.h\"\n",
            "#include \"wildcards/wildcards.hpp\"\n"
        ],
        "reference_api": [
            "_p->manifests.insert",
            "BehaviorTreeException",
            "_p->builders.end",
            "_p->builders.insert",
            "_p->builders.find"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "_p->manifests.insert",
            "BehaviorTreeException",
            "_p->builders.end",
            "_p->builders.insert",
            "_p->builders.find"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)",
        "start_line": "166",
        "end_line": "177",
        "file_path": "src/bt_factory.cpp",
        "docstring": "This function, BehaviorTreeFactory::registerSimpleAction, registers a simple action node with a specified ID, tick functor, and ports list.\\nIt creates a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\\nIt then creates a TreeNodeManifest with the action node type, ID, and ports list.\\nFinally, it calls registerBuilder to register the manifest and builder.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "856bf8e3afb7",
        "ground_truth": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\n{\n  NodeBuilder builder = [tick_functor, ID](const std::string& name,\n                                           const NodeConfig& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n   TreeNodeManifest manifest = { NodeType::ACTION, ID, std::move(ports), {} };\n  registerBuilder(manifest, builder);\n}",
        "import_statements": [
            "#include <filesystem>\n",
            "#include \"behaviortree_cpp/bt_factory.h\"\n",
            "#include \"behaviortree_cpp/utils/shared_library.h\"\n",
            "#include \"behaviortree_cpp/contrib/json.hpp\"\n",
            "#include \"behaviortree_cpp/xml_parsing.h\"\n",
            "#include \"wildcards/wildcards.hpp\"\n"
        ],
        "reference_api": [
            "std::make_unique<SimpleActionNode>",
            "registerBuilder",
            "std::move"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "registerBuilder",
                "code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\n{\n  auto it = _p->builders.find(manifest.registration_ID);\n  if(it != _p->builders.end())\n  {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID, \"] already registered\");\n  }\n\n  _p->builders.insert({ manifest.registration_ID, builder });\n  _p->manifests.insert({ manifest.registration_ID, manifest });\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)",
        "start_line": "688",
        "end_line": "698",
        "file_path": "src/bt_factory.cpp",
        "docstring": "This function, BlackboardBackup, creates a backup of the blackboards in a given tree.\\nIt initializes a vector of blackboard pointers and reserves space based on the number of subtrees.\\nFor each subtree, it creates a new blackboard, clones the contents of the subtree's blackboard into the new blackboard, and adds it to the vector.\\nThe function returns the vector of blackboard backups.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ed0fde814599",
        "ground_truth": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\n{\n  std::vector<Blackboard::Ptr> bb;\n  bb.reserve(tree.subtrees.size());\n  for(const auto& sub : tree.subtrees)\n  {\n    bb.push_back(BT::Blackboard::create());\n    sub->blackboard->cloneInto(*bb.back());\n  }\n  return bb;\n}",
        "import_statements": [
            "#include <filesystem>\n",
            "#include \"behaviortree_cpp/bt_factory.h\"\n",
            "#include \"behaviortree_cpp/utils/shared_library.h\"\n",
            "#include \"behaviortree_cpp/contrib/json.hpp\"\n",
            "#include \"behaviortree_cpp/xml_parsing.h\"\n",
            "#include \"wildcards/wildcards.hpp\"\n"
        ],
        "reference_api": [
            "bb.push_back",
            "sub->blackboard->cloneInto",
            "bb.reserve",
            "BT::Blackboard::create",
            "tree.subtrees.size",
            "bb.back"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "bb.push_back",
            "sub->blackboard->cloneInto",
            "bb.reserve",
            "BT::Blackboard::create",
            "tree.subtrees.size",
            "bb.back"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)",
        "start_line": "57",
        "end_line": "68",
        "file_path": "src/script_parser.cpp",
        "docstring": "This function, ParseScriptAndExecute, parses a script and executes it within a given environment.\\nIt calls ParseScript to get an executor.\\nIf parsing is successful, it executes the script using the environment and returns the result.\\nIf parsing fails, it forwards the error using nonstd::make_unexpected.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2179772e74ec",
        "ground_truth": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\n{\n  auto executor = ParseScript(script);\n  if(executor)\n  {\n    return executor.value()(env);\n  }\n  else  // forward the error\n  {\n    return nonstd::make_unexpected(executor.error());\n  }\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/scripting/script_parser.hpp\"\n",
            "#include \"behaviortree_cpp/scripting/operators.hpp\"\n",
            "#include <lexy/action/parse.hpp>\n",
            "#include <lexy/action/validate.hpp>\n",
            "#include <lexy_ext/report_error.hpp>\n",
            "#include <lexy/input/string_input.hpp>\n"
        ],
        "reference_api": [
            "executor.value()",
            "nonstd::make_unexpected",
            "executor.error",
            "executor.value",
            "ParseScript"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ParseScript",
                "code": "Expected<ScriptFunction> ParseScript(const std::string& script)\n{\n  char error_msgs_buffer[2048];\n\n  auto input = lexy::string_input<lexy::utf8_encoding>(script);\n  auto result =\n      lexy::parse<BT::Grammar::stmt>(input, ErrorReport().to(error_msgs_buffer));\n  if(result.has_value() && result.error_count() == 0)\n  {\n    try\n    {\n      std::vector<BT::Ast::ExprBase::Ptr> exprs = LEXY_MOV(result).value();\n      if(exprs.empty())\n      {\n        return nonstd::make_unexpected(\"Empty Script\");\n      }\n\n      return [exprs, script](Ast::Environment& env) -> Any {\n        try\n        {\n          for(auto i = 0u; i < exprs.size() - 1; ++i)\n          {\n            exprs[i]->evaluate(env);\n          }\n          return exprs.back()->evaluate(env);\n        }\n        catch(RuntimeError& err)\n        {\n          throw RuntimeError(StrCat(\"Error in script [\", script, \"]\\n\", err.what()));\n        }\n      };\n    }\n    catch(std::runtime_error& err)\n    {\n      return nonstd::make_unexpected(err.what());\n    }\n  }\n  else\n  {\n    return nonstd::make_unexpected(error_msgs_buffer);\n  }\n}"
            }
        ],
        "third_party": [
            "executor.value()",
            "nonstd::make_unexpected",
            "executor.error",
            "executor.value"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "void SharedLibrary::load(const std::string& path, int)",
        "start_line": "14",
        "end_line": "30",
        "file_path": "src/shared_library_UNIX.cpp",
        "docstring": "This function, SharedLibrary::load, loads a shared library from the specified path.\\nIt acquires a unique lock on a mutex to ensure thread safety.\\nIf a library is already loaded, it throws a RuntimeError.\\nIt attempts to load the library using dlopen with RTLD_NOW and RTLD_GLOBAL flags.\\nIf the load fails, it retrieves the error message and throws a RuntimeError.\\nIf successful, it stores the path of the loaded library.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "22dd2cc593f1",
        "ground_truth": "void SharedLibrary::load(const std::string& path, int)\n{\n  std::unique_lock<std::mutex> lock(_mutex);\n   if(_handle)\n  {\n    throw RuntimeError(\"Library already loaded: \" + path);\n  }\n   _handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if(!_handle)\n  {\n    const char* err = dlerror();\n    throw RuntimeError(\"Could not load library: \" + (err ? std::string(err) : path));\n  }\n  _path = path;\n}",
        "import_statements": [
            "#include <string>\n",
            "#include <mutex>\n",
            "#include <dlfcn.h>\n",
            "#include \"behaviortree_cpp/utils/shared_library.h\"\n",
            "#include \"behaviortree_cpp/exceptions.h\"\n"
        ],
        "reference_api": [
            "std::string",
            "RuntimeError",
            "dlerror",
            "dlopen",
            "path.c_str"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "RuntimeError",
            "dlerror",
            "dlopen",
            "path.c_str"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "BehaviorTree/BehaviorTree.CPP",
        "function_declaration": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)",
        "start_line": "369",
        "end_line": "393",
        "file_path": "src/tree_node.cpp",
        "docstring": "This function, TreeNode::isBlackboardPointer, checks if a given string is a valid blackboard pointer.\\nIt first ensures the string is at least 3 characters long.\\nIt then strips leading and trailing spaces.\\nNext, it checks if the stripped string starts with '{' and ends with '}'.\\nIf valid and a stripped_pointer is provided, it assigns the inner content to stripped_pointer.\\nFinally, it returns whether the string is a valid blackboard pointer.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0a1b4487dc57",
        "ground_truth": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\n{\n  if(str.size() < 3)\n  {\n    return false;\n  }\n  // strip leading and following spaces\n  size_t front_index = 0;\n  size_t last_index = str.size() - 1;\n  while(str[front_index] == ' ' && front_index <= last_index)\n  {\n    front_index++;\n  }\n  while(str[last_index] == ' ' && front_index <= last_index)\n  {\n    last_index--;\n  }\n  const auto size = (last_index - front_index) + 1;\n  auto valid = size >= 3 && str[front_index] == '{' && str[last_index] == '}';\n  if(valid && stripped_pointer)\n  {\n    *stripped_pointer = StringView(&str[front_index + 1], size - 2);\n  }\n  return valid;\n}",
        "import_statements": [
            "#include \"behaviortree_cpp/tree_node.h\"\n",
            "#include <cstring>\n",
            "#include <array>\n"
        ],
        "reference_api": [
            "StringView",
            "str.size"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "StringView",
            "str.size"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const",
        "start_line": "116",
        "end_line": "132",
        "file_path": "base_local_planner/src/costmap_model.cpp",
        "docstring": "This function, CostmapModel::lineCost, calculates the cost of a line between two points (x0, y0) and (x1, y1).\\nIt initializes the line cost and iterates through each point on the line using a LineIterator.\\nFor each point, it calculates the point cost.\\nIf the point cost is negative, it returns the point cost immediately.\\nOtherwise, it updates the line cost if the point cost is higher.\\nFinally, it returns the total line cost.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2476cdfee74c",
        "ground_truth": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const {\n  double line_cost = 0.0;\n  double point_cost = -1.0;\n  for( LineIterator line( x0, y0, x1, y1 ); line.isValid(); line.advance() )\n  {\n    point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n    if(point_cost < 0)\n      return point_cost;\n    if(line_cost < point_cost)\n      line_cost = point_cost;\n  }\n  return line_cost;\n}",
        "import_statements": [
            "#include <base_local_planner/line_iterator.h>\n",
            "#include <base_local_planner/costmap_model.h>\n",
            "#include <costmap_2d/cost_values.h>\n"
        ],
        "reference_api": [
            "line.getY",
            "line.advance",
            "line.isValid",
            "pointCost",
            "line.getX"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "pointCost",
                "code": "double CostmapModel::pointCost(int x, int y) const {\n    unsigned char cost = costmap_.getCost(x, y);\n    //if the cell is in an obstacle the path is invalid\n    if(cost == NO_INFORMATION)\n      return -2;\n    if(cost == LETHAL_OBSTACLE)\n      return -1;\n\n    return cost;\n  }"
            }
        ],
        "third_party": [
            "line.getY",
            "line.advance",
            "line.isValid",
            "line.getX"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) ",
        "start_line": "58",
        "end_line": "75",
        "file_path": "base_local_planner/src/goal_functions.cpp",
        "docstring": "This function, publishPlan, publishes a given path as a nav_msgs::Path message using a ROS publisher.\\nIf the path is empty, it returns without doing anything.\\nIt creates a nav_msgs::Path message and initializes its header with the frame_id and timestamp from the first pose in the path.\\nThe function then copies each pose from the input path to the path message and publishes it using the provided ROS publisher.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ba84c4c8709a",
        "ground_truth": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n  //given an empty path we won't do anything\n  if(path.empty())\n    return;\n  //create a path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for(unsigned int i=0; i < path.size(); i++){\n    gui_path.poses[i] = path[i];\n  }\n  pub.publish(gui_path);\n}",
        "import_statements": [
            "#include <base_local_planner/goal_functions.h>\n",
            "#include <tf2/LinearMath/Matrix3x3.h>\n",
            "#include <tf2/utils.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n"
        ],
        "reference_api": [
            "path.empty",
            "pub.publish",
            "path.size",
            "gui_path.poses.resize"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "path.empty",
            "pub.publish",
            "path.size",
            "gui_path.poses.resize"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)",
        "start_line": "239",
        "end_line": "244",
        "file_path": "base_local_planner/src/goal_functions.cpp",
        "docstring": "This function, stopped, checks if a robot has stopped based on its odometry data.\\nIt compares the angular and linear velocities from the odometry message to the given thresholds for rotational and translational stopped velocities.\\nIf all velocities are below or equal to their respective thresholds, it returns true, indicating the robot has stopped.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4918505c2f31",
        "ground_truth": "bool stopped(const nav_msgs::Odometry& base_odom, \n    const double& rot_stopped_velocity, const double& trans_stopped_velocity){\n  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity \n    && fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity\n    && fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}",
        "import_statements": [
            "#include <base_local_planner/goal_functions.h>\n",
            "#include <tf2/LinearMath/Matrix3x3.h>\n",
            "#include <tf2/utils.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n"
        ],
        "reference_api": [
            "fabs"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)",
        "start_line": "59",
        "end_line": "71",
        "file_path": "base_local_planner/src/local_planner_util.cpp",
        "docstring": "This function, LocalPlannerUtil::reconfigureCB, reconfigures the local planner limits based on the provided configuration.\\nIf the setup flag is true and restore_defaults is requested, it resets the configuration to default limits.\\nIf setup is not yet done, it initializes the default limits with the provided configuration and sets up the flag.\\nFinally, it locks the configuration mutex and updates the current limits with the new configuration.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f80c5118823c",
        "ground_truth": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\n{\n  if(setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n   if(!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n  limits_ = LocalPlannerLimits(config);\n}",
        "import_statements": [
            "#include <base_local_planner/local_planner_util.h>\n",
            "#include <base_local_planner/goal_functions.h>\n"
        ],
        "reference_api": [
            "LocalPlannerLimits"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "LocalPlannerLimits"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)",
        "start_line": "103",
        "end_line": "121",
        "file_path": "base_local_planner/src/map_grid.cpp",
        "docstring": "This function, MapGrid::updatePathCell, updates the target distance of a cell in the pathfinding grid.\\nIt first checks the cost of the cell using the costmap.\\nIf the cell is an obstacle or has no information, it sets the cell's target distance to the maximum obstacle cost and returns false.\\nIf the cell is not an obstacle, it calculates a new target distance and updates the cell's target distance if the new distance is shorter.\\nFinally, it returns true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f826f9eac433",
        "ground_truth": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n    const costmap_2d::Costmap2D& costmap){\n  //if the cell is an obstacle set the max path distance\n  unsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if(! getCell(check_cell->cx, check_cell->cy).within_robot &&\n      (cost == costmap_2d::LETHAL_OBSTACLE ||\n       cost == costmap_2d::INSCRIBED_INFLATED_OBSTACLE ||\n       cost == costmap_2d::NO_INFORMATION)){\n    check_cell->target_dist = obstacleCosts();\n    return false;\n  }\n  double new_target_dist = current_cell->target_dist + 1;\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n  }\n  return true;\n}",
        "import_statements": [
            "#include <base_local_planner/map_grid.h>\n",
            "#include <costmap_2d/cost_values.h>\n"
        ],
        "reference_api": [
            "getCell",
            "costmap.getCost",
            "obstacleCosts"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getCell",
            "costmap.getCost",
            "obstacleCosts"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)",
        "start_line": "74",
        "end_line": "100",
        "file_path": "base_local_planner/src/obstacle_cost_function.cpp",
        "docstring": "This function, ObstacleCostFunction::scoreTrajectory, calculates the cost of a given trajectory.\\nIt initializes the cost and scaling factor based on the trajectory and speed parameters.\\nIf the footprint specification is empty, it logs an error and returns -9.\\nFor each point in the trajectory, it calculates the footprint cost.\\nIf the footprint cost is negative, it returns the cost immediately.\\nOtherwise, it either sums the scores or takes the maximum score based on the sum_scores_ flag.\\nFinally, it returns the total cost.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0e460baae05f",
        "ground_truth": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj) {\n  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, max_trans_vel_, max_scaling_factor_);\n  double px, py, pth;\n  if (footprint_spec_.size() == 0) {\n    // Bug, should never happen\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint?\");\n    return -9;\n  }\n   for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    traj.getPoint(i, px, py, pth);\n    double f_cost = footprintCost(px, py, pth,\n        scale, footprint_spec_,\n        costmap_, world_model_);\n     if(f_cost < 0){\n        return f_cost;\n    }\n     if(sum_scores_)\n        cost +=  f_cost;\n    else\n        cost = std::max(cost, f_cost);\n  }\n  return cost;\n}",
        "import_statements": [
            "#include <base_local_planner/obstacle_cost_function.h>\n",
            "#include <cmath>\n",
            "#include <Eigen/Core>\n",
            "#include <ros/console.h>\n"
        ],
        "reference_api": [
            "traj.getPoint",
            "std::max",
            "footprint_spec_.size",
            "footprintCost",
            "ROS_ERROR",
            "getScalingFactor",
            "traj.getPointsSize"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "footprintCost",
                "code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model) {\n\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for(unsigned int i  = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point new_pt;\n    new_pt.x = scale * footprint_spec[i].x;\n    new_pt.y = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(new_pt);\n  }\n\n  //check if the footprint is legal\n  // TODO: Cache inscribed radius\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n  unsigned int cell_x, cell_y;\n\n  //we won't allow trajectories that go off the map... shouldn't happen that often anyways\n  if ( ! costmap->worldToMap(x, y, cell_x, cell_y)) {\n    return -7.0;\n  }\n\n  double occ_cost = std::max(std::max(0.0, footprint_cost), double(costmap->getCost(cell_x, cell_y)));\n\n  return occ_cost;\n}"
            },
            {
                "name": "getScalingFactor",
                "code": "double ObstacleCostFunction::getScalingFactor(Trajectory &traj, double scaling_speed, double max_trans_vel, double max_scaling_factor) {\n  double vmag = hypot(traj.xv_, traj.yv_);\n\n  //if we're over a certain speed threshold, we'll scale the robot's\n  //footprint to make it either slow down or stay further from walls\n  double scale = 1.0;\n  if (vmag > scaling_speed) {\n    //scale up to the max scaling factor linearly... this could be changed later\n    double ratio = (vmag - scaling_speed) / (max_trans_vel - scaling_speed);\n    scale = max_scaling_factor * ratio + 1.0;\n  }\n  return scale;\n}"
            }
        ],
        "third_party": [
            "traj.getPoint",
            "footprint_spec_.size",
            "ROS_ERROR",
            "traj.getPointsSize"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)",
        "start_line": "116",
        "end_line": "150",
        "file_path": "base_local_planner/src/obstacle_cost_function.cpp",
        "docstring": "This function, ObstacleCostFunction::footprintCost, calculates the cost of a robot's footprint at a given position and orientation on a costmap.\\nIt scales the footprint points by a given scale factor.\\nThen, it computes the footprint cost using a world model.\\nIf the cost is negative, it returns -6.0.\\nIf the position is off the map, it returns -7.0.\\nOtherwise, it returns the maximum cost between the footprint cost and the cell cost at the given position.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8c6b01297181",
        "ground_truth": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model) {\n   std::vector<geometry_msgs::Point> scaled_footprint;\n  for(unsigned int i  = 0; i < footprint_spec.size(); ++i) {\n    geometry_msgs::Point new_pt;\n    new_pt.x = scale * footprint_spec[i].x;\n    new_pt.y = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(new_pt);\n  }\n   //check if the footprint is legal\n  // TODO: Cache inscribed radius\n  double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n   if (footprint_cost < 0) {\n    return -6.0;\n  }\n  unsigned int cell_x, cell_y;\n   //we won't allow trajectories that go off the map... shouldn't happen that often anyways\n  if ( ! costmap->worldToMap(x, y, cell_x, cell_y)) {\n    return -7.0;\n  }\n   double occ_cost = std::max(std::max(0.0, footprint_cost), double(costmap->getCost(cell_x, cell_y)));\n   return occ_cost;\n}",
        "import_statements": [
            "#include <base_local_planner/obstacle_cost_function.h>\n",
            "#include <cmath>\n",
            "#include <Eigen/Core>\n",
            "#include <ros/console.h>\n"
        ],
        "reference_api": [
            "costmap->worldToMap",
            "world_model->footprintCost",
            "double",
            "std::max",
            "scaled_footprint.push_back",
            "footprint_spec.size",
            "costmap->getCost"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "costmap->worldToMap",
            "world_model->footprintCost",
            "double",
            "scaled_footprint.push_back",
            "footprint_spec.size",
            "costmap->getCost"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)",
        "start_line": "88",
        "end_line": "104",
        "file_path": "base_local_planner/src/odometry_helper_ros.cpp",
        "docstring": "This function, OdometryHelperRos::setOdomTopic, sets a new odometry topic.\\nIf the new topic differs from the current one, it updates the topic.\\nIf the new topic is not empty, it subscribes to the new odometry topic with a callback to odomCallback.\\nIf the new topic is empty, it shuts down the existing subscription.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a1427185da52",
        "ground_truth": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\n{\n  if( odom_topic != odom_topic_ )\n  {\n    odom_topic_ = odom_topic;\n     if( odom_topic_ != \"\" )\n    {\n      ros::NodeHandle gn;\n      odom_sub_ = gn.subscribe<nav_msgs::Odometry>( odom_topic_, 1, [this](auto& msg){ odomCallback(msg); });\n    }\n    else\n    {\n      odom_sub_.shutdown();\n    }\n  }\n}",
        "import_statements": [
            "#include <base_local_planner/odometry_helper_ros.h>\n",
            "#include <tf2/LinearMath/Quaternion.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n",
            "#include <tf2/convert.h>\n"
        ],
        "reference_api": [
            "gn.subscribe<nav_msgs::Odometry>",
            "odom_sub_.shutdown",
            "odomCallback"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "odomCallback",
                "code": "void OdometryHelperRos::odomCallback(const nav_msgs::Odometry::ConstPtr& msg) {\n    ROS_INFO_ONCE(\"odom received!\");\n\n  //we assume that the odometry is published in the frame of the base\n  boost::mutex::scoped_lock lock(odom_mutex_);\n  base_odom_.twist.twist.linear.x = msg->twist.twist.linear.x;\n  base_odom_.twist.twist.linear.y = msg->twist.twist.linear.y;\n  base_odom_.twist.twist.angular.z = msg->twist.twist.angular.z;\n  base_odom_.child_frame_id = msg->child_frame_id;\n//  ROS_DEBUG_NAMED(\"dwa_local_planner\", \"In the odometry callback with velocity values: (%.2f, %.2f, %.2f)\",\n//      base_odom_.twist.twist.linear.x, base_odom_.twist.twist.linear.y, base_odom_.twist.twist.angular.z);\n}"
            }
        ],
        "third_party": [
            "gn.subscribe<nav_msgs::Odometry>",
            "odom_sub_.shutdown"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)",
        "start_line": "70",
        "end_line": "82",
        "file_path": "base_local_planner/src/oscillation_cost_function.cpp",
        "docstring": "This function, OscillationCostFunction::resetOscillationFlagsIfPossible, resets oscillation flags based on the distance and angle between the current and previous positions.\\nIt calculates the squared distance and the angular difference.\\nIf the squared distance exceeds a threshold or the angular difference is greater than a set angle, it resets the oscillation flags.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "328bb3066bf7",
        "ground_truth": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev) {\n  double x_diff = pos[0] - prev[0];\n  double y_diff = pos[1] - prev[1];\n  double sq_dist = x_diff * x_diff + y_diff * y_diff;\n   double th_diff = pos[2] - prev[2];\n   //if we've moved far enough... we can reset our flags\n  if (sq_dist > oscillation_reset_dist_ * oscillation_reset_dist_ ||\n      fabs(th_diff) > oscillation_reset_angle_) {\n    resetOscillationFlags();\n  }\n}",
        "import_statements": [
            "#include <base_local_planner/oscillation_cost_function.h>\n",
            "#include <cmath>\n"
        ],
        "reference_api": [
            "resetOscillationFlags",
            "fabs"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "resetOscillationFlags",
                "code": "void OscillationCostFunction::resetOscillationFlags() {\n  strafe_pos_only_ = false;\n  strafe_neg_only_ = false;\n  strafing_pos_ = false;\n  strafing_neg_ = false;\n\n  rot_pos_only_ = false;\n  rot_neg_only_ = false;\n  rotating_pos_ = false;\n  rotating_neg_ = false;\n\n  forward_pos_only_ = false;\n  forward_neg_only_ = false;\n  forward_pos_ = false;\n  forward_neg_ = false;\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void PointGrid::insert(const geometry_msgs::Point32& pt)",
        "start_line": "211",
        "end_line": "229",
        "file_path": "base_local_planner/src/point_grid.cpp",
        "docstring": "This function, PointGrid::insert, adds a point to a grid.\\nIt first determines the grid coordinates of the point.\\nIf the coordinates are outside the grid bounds or the point is too close to its nearest neighbor, the function returns without inserting the point.\\nIf valid, it calculates the grid index and inserts the point into the corresponding cell.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "51049617b91b",
        "ground_truth": "void PointGrid::insert(const geometry_msgs::Point32& pt){\n  //get the grid coordinates of the point\n  unsigned int gx, gy;\n  //if the grid coordinates are outside the bounds of the grid... return\n  if(!gridCoords(pt, gx, gy))\n    return;\n  //if the point is too close to its nearest neighbor... return\n  if(nearestNeighborDistance(pt) < sq_min_separation_)\n    return;\n  //get the associated index\n  unsigned int pt_index = gridIndex(gx, gy);\n  //insert the point into the grid at the correct location\n  cells_[pt_index].push_back(pt);\n  //printf(\"Index: %d, size: %d\\n\", pt_index, cells_[pt_index].size());\n}",
        "import_statements": [
            "#include <base_local_planner/point_grid.h>\n",
            "#include <ros/console.h>\n",
            "#include <math.h>\n",
            "#include <cstdio>\n",
            "#include <sensor_msgs/point_cloud2_iterator.h>\n"
        ],
        "reference_api": [
            "gridIndex",
            "cells_[pt_index].push_back",
            "nearestNeighborDistance",
            "gridCoords"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "nearestNeighborDistance",
                "code": "double PointGrid::nearestNeighborDistance(const geometry_msgs::Point32& pt){\n    //get the grid coordinates of the point\n    unsigned int gx, gy;\n\n    gridCoords(pt, gx, gy);\n\n    //get the bounds of the grid cell in world coords\n    geometry_msgs::Point lower_left, upper_right;\n    getCellBounds(gx, gy, lower_left, upper_right);\n\n    //now we need to check what cells could contain the nearest neighbor\n    geometry_msgs::Point32 check_point;\n    double sq_dist = DBL_MAX;\n    double neighbor_sq_dist = DBL_MAX;\n    \n    //left\n    if(gx > 0){\n      check_point.x = lower_left.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy));\n    }\n\n    //upper left\n    if(gx > 0 && gy < height_ - 1){\n      check_point.x = lower_left.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy + 1));\n    }\n\n    //top\n    if(gy < height_ - 1){\n      check_point.x = pt.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx, gy + 1));\n    }\n\n    //upper right\n    if(gx < width_ - 1 && gy < height_ - 1){\n      check_point.x = upper_right.x;\n      check_point.y = upper_right.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx + 1, gy + 1));\n    }\n\n    //right\n    if(gx < width_ - 1){\n      check_point.x = upper_right.x;\n      check_point.y = pt.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx + 1, gy));\n    }\n\n    //lower right\n    if(gx < width_ - 1 && gy > 0){\n      check_point.x = upper_right.x;\n      check_point.y = lower_left.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx + 1, gy - 1));\n    }\n\n    //bottom\n    if(gy > 0){\n      check_point.x = pt.x;\n      check_point.y = lower_left.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx, gy - 1));\n    }\n\n    //lower left\n    if(gx > 0 && gy > 0){\n      check_point.x = lower_left.x;\n      check_point.y = lower_left.y;\n      sq_dist = sq_distance(pt, check_point);\n      if(sq_dist < sq_min_separation_)\n        neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx - 1, gy - 1));\n    }\n\n    //we must also check within the cell we're in for a nearest neighbor\n    neighbor_sq_dist = min(neighbor_sq_dist, getNearestInCell(pt, gx, gy));\n\n    return neighbor_sq_dist;\n  }"
            }
        ],
        "third_party": [
            "gridIndex",
            "cells_[pt_index].push_back",
            "gridCoords"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)",
        "start_line": "269",
        "end_line": "280",
        "file_path": "base_local_planner/src/simple_trajectory_generator.cpp",
        "docstring": "This function, SimpleTrajectoryGenerator::computeNewVelocities, computes new velocities for an object based on target velocities, current velocities, acceleration limits, and time delta.\\nIt initializes a new velocity vector to zero.\\nFor each of the three velocity components, it increases or decreases the current velocity towards the target velocity within the acceleration limits.\\nFinally, it returns the new velocity vector.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bd34be6d6931",
        "ground_truth": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt) {\n  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; ++i) {\n    if (vel[i] < sample_target_vel[i]) {\n      new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}",
        "import_statements": [
            "#include <base_local_planner/simple_trajectory_generator.h>\n",
            "#include <cmath>\n",
            "#include <base_local_planner/velocity_iterator.h>\n"
        ],
        "reference_api": [
            "double",
            "std::min",
            "Eigen::Vector3f::Zero",
            "std::max"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "double",
            "Eigen::Vector3f::Zero"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)",
        "start_line": "372",
        "end_line": "386",
        "file_path": "base_local_planner/src/trajectory_planner.cpp",
        "docstring": "This function, TrajectoryPlanner::headingDiff, calculates the difference in heading between the robot's current position and a goal point on the path.\\nIt iterates through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell.\\nIf a valid point is found, it converts the goal cell coordinates to world coordinates and returns the absolute value of the shortest angular distance between the current heading and the direction to the goal point.\\nIf no valid point is found, it returns DBL_MAX.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e15bd73d0415",
        "ground_truth": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){\n  unsigned int goal_cell_x, goal_cell_y;\n  // find a clear line of sight from the robot's cell to a farthest point on the path\n  for (int i = global_plan_.size() - 1; i >=0; --i) {\n    if (costmap_.worldToMap(global_plan_[i].pose.position.x, global_plan_[i].pose.position.y, goal_cell_x, goal_cell_y)) {\n      if (lineCost(cell_x, goal_cell_x, cell_y, goal_cell_y) >= 0) {\n        double gx, gy;\n        costmap_.mapToWorld(goal_cell_x, goal_cell_y, gx, gy);\n        return fabs(angles::shortest_angular_distance(heading, atan2(gy - y, gx - x)));\n      }\n    }\n  }\n  return DBL_MAX;\n}",
        "import_statements": [
            "#include <base_local_planner/trajectory_planner.h>\n",
            "#include <costmap_2d/footprint.h>\n",
            "#include <string>\n",
            "#include <sstream>\n",
            "#include <math.h>\n",
            "#include <angles/angles.h>\n",
            "#include <boost/algorithm/string.hpp>\n",
            "#include <ros/console.h>\n",
            "#include <queue>\n",
            "#include <tf2/LinearMath/Matrix3x3.h>\n",
            "#include <tf2/utils.h>\n"
        ],
        "reference_api": [
            "atan2",
            "fabs",
            "costmap_.mapToWorld",
            "costmap_.worldToMap",
            "global_plan_.size",
            "angles::shortest_angular_distance",
            "lineCost"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "lineCost",
                "code": "double TrajectoryPlanner::lineCost(int x0, int x1,\n      int y0, int y1){\n    //Bresenham Ray-Tracing\n    int deltax = abs(x1 - x0);        // The difference between the x's\n    int deltay = abs(y1 - y0);        // The difference between the y's\n    int x = x0;                       // Start x off at the first pixel\n    int y = y0;                       // Start y off at the first pixel\n\n    int xinc1, xinc2, yinc1, yinc2;\n    int den, num, numadd, numpixels;\n\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    if (x1 >= x0)                 // The x-values are increasing\n    {\n      xinc1 = 1;\n      xinc2 = 1;\n    }\n    else                          // The x-values are decreasing\n    {\n      xinc1 = -1;\n      xinc2 = -1;\n    }\n\n    if (y1 >= y0)                 // The y-values are increasing\n    {\n      yinc1 = 1;\n      yinc2 = 1;\n    }\n    else                          // The y-values are decreasing\n    {\n      yinc1 = -1;\n      yinc2 = -1;\n    }\n\n    if (deltax >= deltay)         // There is at least one x-value for every y-value\n    {\n      xinc1 = 0;                  // Don't change the x when numerator >= denominator\n      yinc2 = 0;                  // Don't change the y for every iteration\n      den = deltax;\n      num = deltax / 2;\n      numadd = deltay;\n      numpixels = deltax;         // There are more x-values than y-values\n    } else {                      // There is at least one y-value for every x-value\n      xinc2 = 0;                  // Don't change the x for every iteration\n      yinc1 = 0;                  // Don't change the y when numerator >= denominator\n      den = deltay;\n      num = deltay / 2;\n      numadd = deltax;\n      numpixels = deltay;         // There are more y-values than x-values\n    }\n\n    for (int curpixel = 0; curpixel <= numpixels; curpixel++) {\n      point_cost = pointCost(x, y); //Score the current point\n\n      if (point_cost < 0) {\n        return -1;\n      }\n\n      if (line_cost < point_cost) {\n        line_cost = point_cost;\n      }\n\n      num += numadd;              // Increase the numerator by the top of the fraction\n      if (num >= den) {           // Check if numerator >= denominator\n        num -= den;               // Calculate the new numerator value\n        x += xinc1;               // Change the x as appropriate\n        y += yinc1;               // Change the y as appropriate\n      }\n      x += xinc2;                 // Change the x as appropriate\n      y += yinc2;                 // Change the y as appropriate\n    }\n\n    return line_cost;\n  }"
            }
        ],
        "third_party": [
            "costmap_.mapToWorld",
            "costmap_.worldToMap",
            "global_plan_.size",
            "angles::shortest_angular_distance"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)",
        "start_line": "503",
        "end_line": "517",
        "file_path": "base_local_planner/src/trajectory_planner.cpp",
        "docstring": "This function, TrajectoryPlanner::checkTrajectory, evaluates a trajectory based on given position, orientation, and velocity parameters.\\nIt computes the cost of the trajectory using scoreTrajectory.\\nIf the cost is non-negative, the trajectory is considered valid, and the function returns true.\\nIf the cost is negative, it logs a warning with the sample velocities and cost, then returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f64442fc88fb",
        "ground_truth": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n    double vtheta, double vx_samp, double vy_samp, double vtheta_samp){\n  Trajectory t;\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  //if the trajectory is a legal one... the check passes\n  if(cost >= 0) {\n    return true;\n  }\n  ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, cost);\n  //otherwise the check fails\n  return false;\n}",
        "import_statements": [
            "#include <base_local_planner/trajectory_planner.h>\n",
            "#include <costmap_2d/footprint.h>\n",
            "#include <string>\n",
            "#include <sstream>\n",
            "#include <math.h>\n",
            "#include <angles/angles.h>\n",
            "#include <boost/algorithm/string.hpp>\n",
            "#include <ros/console.h>\n",
            "#include <queue>\n",
            "#include <tf2/LinearMath/Matrix3x3.h>\n",
            "#include <tf2/utils.h>\n"
        ],
        "reference_api": [
            "scoreTrajectory",
            "ROS_WARN"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "scoreTrajectory",
                "code": "double TrajectoryPlanner::scoreTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp) {\n    Trajectory t;\n    double impossible_cost = path_map_.obstacleCosts();\n    generateTrajectory(x, y, theta,\n                       vx, vy, vtheta,\n                       vx_samp, vy_samp, vtheta_samp,\n                       acc_lim_x_, acc_lim_y_, acc_lim_theta_,\n                       impossible_cost, t);\n\n    // return the cost.\n    return double( t.cost_ );\n  }"
            }
        ],
        "third_party": [
            "ROS_WARN"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void ClearCostmapRecovery::runBehavior()",
        "start_line": "89",
        "end_line": "129",
        "file_path": "clear_costmap_recovery/src/clear_costmap_recovery.cpp",
        "docstring": "This function, ClearCostmapRecovery::runBehavior, clears specified costmaps in a ROS-based navigation system.\\nIt first checks if the object is initialized and if the costmaps are not NULL, logging errors if these conditions are not met.\\nDepending on the invert_area_to_clear_ flag, it logs a warning about clearing inside or outside a specified area.\\nIt then clears the global and/or local costmap based on the affected_maps_ setting, optionally forcing an update, and logs the time taken for each operation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f553316a468e",
        "ground_truth": "void ClearCostmapRecovery::runBehavior(){\n  if(!initialized_){\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n   if(global_costmap_ == NULL || local_costmap_ == NULL){\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n   if (!invert_area_to_clear_){\n    ROS_WARN(\"Clearing %s costmap%s outside a square (%.2fm) large centered on the robot.\", affected_maps_.c_str(),\n           affected_maps_ == \"both\" ? \"s\" : \"\", reset_distance_);\n  }else {\n    ROS_WARN(\"Clearing %s costmap%s inside a square (%.2fm) large centered on the robot.\", affected_maps_.c_str(),\n           affected_maps_ == \"both\" ? \"s\" : \"\", reset_distance_);\n  }\n   ros::WallTime t0 = ros::WallTime::now();\n  if (affected_maps_ == \"global\" || affected_maps_ == \"both\")\n  {\n    clear(global_costmap_);\n     if (force_updating_)\n      global_costmap_->updateMap();\n     ROS_DEBUG(\"Global costmap cleared in %fs\", (ros::WallTime::now() - t0).toSec());\n  }\n   t0 = ros::WallTime::now();\n  if (affected_maps_ == \"local\" || affected_maps_ == \"both\")\n  {\n    clear(local_costmap_);\n     if (force_updating_)\n      local_costmap_->updateMap();\n     ROS_DEBUG(\"Local costmap cleared in %fs\", (ros::WallTime::now() - t0).toSec());\n  }\n}",
        "import_statements": [
            "#include <clear_costmap_recovery/clear_costmap_recovery.h>\n",
            "#include <pluginlib/class_list_macros.hpp>\n",
            "#include <boost/pointer_cast.hpp>\n",
            "#include <vector>\n"
        ],
        "reference_api": [
            "affected_maps_.c_str",
            "local_costmap_->updateMap",
            "ROS_WARN",
            "global_costmap_->updateMap",
            "clear",
            "ROS_ERROR",
            "ROS_DEBUG",
            "ros::WallTime::now",
            "(ros::WallTime::now() - t0).toSec"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "clear",
                "code": "void ClearCostmapRecovery::clear(costmap_2d::Costmap2DROS* costmap){\n  std::vector<boost::shared_ptr<costmap_2d::Layer> >* plugins = costmap->getLayeredCostmap()->getPlugins();\n\n  geometry_msgs::PoseStamped pose;\n\n  if(!costmap->getRobotPose(pose)){\n    ROS_ERROR(\"Cannot clear map because pose cannot be retrieved\");\n    return;\n  }\n\n  double x = pose.pose.position.x;\n  double y = pose.pose.position.y;\n\n  for (std::vector<boost::shared_ptr<costmap_2d::Layer> >::iterator pluginp = plugins->begin(); pluginp != plugins->end(); ++pluginp) {\n    boost::shared_ptr<costmap_2d::Layer> plugin = *pluginp;\n    std::string name = plugin->getName();\n    int slash = name.rfind('/');\n    if( slash != std::string::npos ){\n        name = name.substr(slash+1);\n    }\n\n    if(clearable_layers_.count(name)!=0){\n\n      // check if the value is convertable\n      if(!dynamic_cast<costmap_2d::CostmapLayer*>(plugin.get())){\n        ROS_ERROR_STREAM(\"Layer \" << name << \" is not derived from costmap_2d::CostmapLayer\");\n        continue;\n      }\n\n      boost::shared_ptr<costmap_2d::CostmapLayer> costmap;\n      costmap = boost::static_pointer_cast<costmap_2d::CostmapLayer>(plugin);\n      clearMap(costmap, x, y);\n    }\n  }\n}"
            }
        ],
        "third_party": [
            "affected_maps_.c_str",
            "local_costmap_->updateMap",
            "ROS_WARN",
            "global_costmap_->updateMap",
            "ROS_ERROR",
            "ROS_DEBUG",
            "ros::WallTime::now",
            "(ros::WallTime::now() - t0).toSec"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)",
        "start_line": "344",
        "end_line": "357",
        "file_path": "costmap_2d/src/costmap_2d.cpp",
        "docstring": "This function, Costmap2D::polygonOutlineCells, gathers the cells that form the outline of a given polygon.\\nIt initializes a PolygonOutlineCells object to collect the cells.\\nThe function iterates through the polygon vertices, using raytraceLine to gather cells between each consecutive pair of points.\\nIf the polygon is not empty, it also closes the polygon by connecting the last point to the first.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a89157df3cad",
        "ground_truth": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\n{\n  PolygonOutlineCells cell_gatherer(*this, costmap_, polygon_cells);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i)\n  {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n  if (!polygon.empty())\n  {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n}",
        "import_statements": [
            "#include <costmap_2d/costmap_2d.h>\n",
            "#include <cstdio>\n"
        ],
        "reference_api": [
            "raytraceLine",
            "polygon.empty",
            "polygon.size"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "raytraceLine",
            "polygon.empty",
            "polygon.size"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)",
        "start_line": "83",
        "end_line": "87",
        "file_path": "costmap_2d/src/costmap_2d_publisher.cpp",
        "docstring": "This function, Costmap2DPublisher::onNewSubscription, prepares the grid data and publishes it to a new subscriber.\\nIt first calls prepareGrid to set up the grid data.\\nThen, it publishes the prepared grid using the provided publisher.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "10e1ddf5f77d",
        "ground_truth": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\n{\n  prepareGrid();\n  pub.publish(grid_);\n}",
        "import_statements": [
            "#include <boost/bind.hpp>\n",
            "#include <costmap_2d/costmap_2d_publisher.h>\n",
            "#include <costmap_2d/cost_values.h>\n"
        ],
        "reference_api": [
            "prepareGrid",
            "pub.publish"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "prepareGrid",
                "code": "void Costmap2DPublisher::prepareGrid()\n{\n  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n\n  grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  saved_origin_x_ = costmap_->getOriginX();\n  saved_origin_y_ = costmap_->getOriginY();\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++)\n  {\n    grid_.data[i] = cost_translation_table_[ data[ i ]];\n  }\n}"
            }
        ],
        "third_party": [
            "pub.publish"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void Costmap2DPublisher::prepareGrid()",
        "start_line": "90",
        "end_line": "118",
        "file_path": "costmap_2d/src/costmap_2d_publisher.cpp",
        "docstring": "This function, Costmap2DPublisher::prepareGrid, prepares the occupancy grid for publishing.\\nIt locks the costmap mutex and retrieves the resolution.\\nIt sets the grid's header, resolution, width, and height.\\nThe function converts the map coordinates to world coordinates for the origin and sets the origin's position and orientation.\\nIt saves the origin coordinates and resizes the grid data vector.\\nFinally, it populates the grid data from the costmap's character map using a translation table.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bc176301608b",
        "ground_truth": "void Costmap2DPublisher::prepareGrid()\n{\n  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n   grid_.header.frame_id = global_frame_;\n  grid_.header.stamp = ros::Time::now();\n  grid_.info.resolution = resolution;\n   grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n   double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n  saved_origin_x_ = costmap_->getOriginX();\n  saved_origin_y_ = costmap_->getOriginY();\n   grid_.data.resize(grid_.info.width * grid_.info.height);\n   unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++)\n  {\n    grid_.data[i] = cost_translation_table_[ data[ i ]];\n  }\n}",
        "import_statements": [
            "#include <boost/bind.hpp>\n",
            "#include <costmap_2d/costmap_2d_publisher.h>\n",
            "#include <costmap_2d/cost_values.h>\n"
        ],
        "reference_api": [
            "costmap_->getMutex",
            "costmap_->getOriginX",
            "costmap_->getOriginY",
            "costmap_->getCharMap",
            "costmap_->getResolution",
            "grid_.data.size",
            "grid_.data.resize",
            "costmap_->getSizeInCellsX",
            "ros::Time::now",
            "costmap_->mapToWorld",
            "costmap_->getSizeInCellsY"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "costmap_->getMutex",
            "costmap_->getOriginX",
            "costmap_->getOriginY",
            "costmap_->getCharMap",
            "costmap_->getResolution",
            "grid_.data.size",
            "grid_.data.resize",
            "costmap_->getSizeInCellsX",
            "ros::Time::now",
            "costmap_->mapToWorld",
            "costmap_->getSizeInCellsY"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)",
        "start_line": "358",
        "end_line": "388",
        "file_path": "costmap_2d/src/costmap_2d_ros.cpp",
        "docstring": "This function, Costmap2DROS::readFootprintFromConfig, updates the robot footprint based on the new configuration.\\nIf the footprint and robot radius in the new and old configurations are the same, it returns immediately.\\nIf the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\\nIf the footprint string is invalid, it logs an error.\\nIf no valid footprint string is provided, it sets the footprint based on the robot radius.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5e4677d452b7",
        "ground_truth": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\n{\n  // Only change the footprint if footprint or robot_radius has\n  // changed.  Otherwise we might overwrite a footprint sent on a\n  // topic by a dynamic_reconfigure call which was setting some other\n  // variable.\n  if (new_config.footprint == old_config.footprint &&\n      new_config.robot_radius == old_config.robot_radius)\n  {\n    return;\n  }\n   if (new_config.footprint != \"\" && new_config.footprint != \"[]\")\n  {\n    std::vector<geometry_msgs::Point> new_footprint;\n    if (makeFootprintFromString(new_config.footprint, new_footprint))\n    {\n        setUnpaddedRobotFootprint(new_footprint);\n    }\n    else\n    {\n        ROS_ERROR(\"Invalid footprint string from dynamic reconfigure\");\n    }\n  }\n  else\n  {\n    // robot_radius may be 0, but that must be intended at this point.\n    setUnpaddedRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n  }\n}",
        "import_statements": [
            "#include <costmap_2d/layered_costmap.h>\n",
            "#include <costmap_2d/costmap_2d_ros.h>\n",
            "#include <cstdio>\n",
            "#include <string>\n",
            "#include <algorithm>\n",
            "#include <vector>\n",
            "#include <tf2/convert.h>\n",
            "#include <tf2/utils.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n"
        ],
        "reference_api": [
            "setUnpaddedRobotFootprint",
            "ROS_ERROR",
            "makeFootprintFromRadius",
            "makeFootprintFromString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "setUnpaddedRobotFootprint",
                "code": "void Costmap2DROS::setUnpaddedRobotFootprint(const std::vector<geometry_msgs::Point>& points)\n{\n  unpadded_footprint_ = points;\n  padded_footprint_ = points;\n  padFootprint(padded_footprint_, footprint_padding_);\n\n  layered_costmap_->setFootprint(padded_footprint_);\n}"
            }
        ],
        "third_party": [
            "ROS_ERROR",
            "makeFootprintFromRadius",
            "makeFootprintFromString"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)",
        "start_line": "399",
        "end_line": "410",
        "file_path": "costmap_2d/src/costmap_2d_ros.cpp",
        "docstring": "This function, Costmap2DROS::movementCB, is a callback for handling robot movement events.\\nIt attempts to get the robot's current pose and stores it in new_pose.\\nIf it fails to retrieve the pose, it logs a warning message and cancels reconfiguration.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b059bebd3800",
        "ground_truth": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\n{\n  // don't allow configuration to happen while this check occurs\n  // boost::recursive_mutex::scoped_lock mcl(configuration_mutex_);\n   geometry_msgs::PoseStamped new_pose;\n   if (!getRobotPose(new_pose))\n  {\n    ROS_WARN_THROTTLE(1.0, \"Could not get robot pose, cancelling reconfiguration\");\n  }\n}",
        "import_statements": [
            "#include <costmap_2d/layered_costmap.h>\n",
            "#include <costmap_2d/costmap_2d_ros.h>\n",
            "#include <cstdio>\n",
            "#include <string>\n",
            "#include <algorithm>\n",
            "#include <vector>\n",
            "#include <tf2/convert.h>\n",
            "#include <tf2/utils.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n"
        ],
        "reference_api": [
            "ROS_WARN_THROTTLE",
            "getRobotPose"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getRobotPose",
                "code": "bool Costmap2DROS::getRobotPose(geometry_msgs::PoseStamped& global_pose) const\n{\n  tf2::toMsg(tf2::Transform::getIdentity(), global_pose.pose);\n  geometry_msgs::PoseStamped robot_pose;\n  tf2::toMsg(tf2::Transform::getIdentity(), robot_pose.pose);\n  robot_pose.header.frame_id = robot_base_frame_;\n  robot_pose.header.stamp = ros::Time();\n  ros::Time current_time = ros::Time::now();  // save time for checking tf delay later\n\n  // get the global pose of the robot\n  try\n  {\n    // use current time if possible (makes sure it's not in the future)\n    if (tf_.canTransform(global_frame_, robot_base_frame_, current_time))\n    {\n      geometry_msgs::TransformStamped transform = tf_.lookupTransform(global_frame_, robot_base_frame_, current_time);\n      tf2::doTransform(robot_pose, global_pose, transform);\n    }\n    // use the latest otherwise\n    else\n    {\n      tf_.transform(robot_pose, global_pose, global_frame_);\n    }\n  }\n  catch (tf2::LookupException& ex)\n  {\n    ROS_ERROR_THROTTLE(1.0, \"No Transform available Error looking up robot pose: %s\\n\", ex.what());\n    return false;\n  }\n  catch (tf2::ConnectivityException& ex)\n  {\n    ROS_ERROR_THROTTLE(1.0, \"Connectivity Error looking up robot pose: %s\\n\", ex.what());\n    return false;\n  }\n  catch (tf2::ExtrapolationException& ex)\n  {\n    ROS_ERROR_THROTTLE(1.0, \"Extrapolation Error looking up robot pose: %s\\n\", ex.what());\n    return false;\n  }\n  // check global_pose timeout\n  if (!global_pose.header.stamp.isZero() && current_time.toSec() - global_pose.header.stamp.toSec() > transform_tolerance_)\n  {\n    ROS_WARN_THROTTLE(1.0,\n                      \"Costmap2DROS transform timeout. Current time: %.4f, global_pose stamp: %.4f, tolerance: %.4f\",\n                      current_time.toSec(), global_pose.header.stamp.toSec(), transform_tolerance_);\n    return false;\n  }\n\n  return true;\n}"
            }
        ],
        "third_party": [
            "ROS_WARN_THROTTLE"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void Costmap2DROS::start()",
        "start_line": "480",
        "end_line": "501",
        "file_path": "costmap_2d/src/costmap_2d_ros.cpp",
        "docstring": "This function, Costmap2DROS::start, starts the costmap by reactivating its plugins if they were stopped.\\nIt retrieves the list of plugins and checks if the costmap was stopped.\\nIf stopped, it re-subscribes to topics by activating each plugin and sets the stopped flag to false.\\nIt also sets stop_updates_ to false.\\nThe function then waits in a loop until ROS is running, the costmap is initialized, and the map update thread is active.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "923b41db08fa",
        "ground_truth": "void Costmap2DROS::start()\n{\n  std::vector < boost::shared_ptr<Layer> > *plugins = layered_costmap_->getPlugins();\n  // check if we're stopped or just paused\n  if (stopped_)\n  {\n    // if we're stopped we need to re-subscribe to topics\n    for (vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin != plugins->end();\n        ++plugin)\n    {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n  stop_updates_ = false;\n   // block until the costmap is re-initialized.. meaning one update cycle has run\n  // note: this does not hold, if the user has disabled map-updates allgother\n  ros::Rate r(100.0);\n  while (ros::ok() && !initialized_ && map_update_thread_)\n    r.sleep();\n}",
        "import_statements": [
            "#include <costmap_2d/layered_costmap.h>\n",
            "#include <costmap_2d/costmap_2d_ros.h>\n",
            "#include <cstdio>\n",
            "#include <string>\n",
            "#include <algorithm>\n",
            "#include <vector>\n",
            "#include <tf2/convert.h>\n",
            "#include <tf2/utils.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n"
        ],
        "reference_api": [
            "r.sleep",
            "ros::ok",
            "plugins->begin",
            "plugins->end",
            "layered_costmap_->getPlugins",
            "(*plugin)->activate"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "r.sleep",
            "ros::ok",
            "plugins->begin",
            "plugins->end",
            "layered_costmap_->getPlugins",
            "(*plugin)->activate"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void ObservationBuffer::purgeStaleObservations()",
        "start_line": "205",
        "end_line": "229",
        "file_path": "costmap_2d/src/observation_buffer.cpp",
        "docstring": "This function, ObservationBuffer::purgeStaleObservations, removes outdated observations from the observation list.\\nIf the observation_keep_time_ is zero, it keeps only the most recent observation.\\nOtherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7f33ea4f2b6c",
        "ground_truth": "void ObservationBuffer::purgeStaleObservations()\n{\n  if (!observation_list_.empty())\n  {\n    list<Observation>::iterator obs_it = observation_list_.begin();\n    // if we're keeping observations for no time... then we'll only keep one observation\n    if (observation_keep_time_ == ros::Duration(0.0))\n    {\n      observation_list_.erase(++obs_it, observation_list_.end());\n      return;\n    }\n     // otherwise... we'll have to loop through the observations to see which ones are stale\n    for (obs_it = observation_list_.begin(); obs_it != observation_list_.end(); ++obs_it)\n    {\n      Observation& obs = *obs_it;\n      // check if the observation is out of date... and if it is, remove it and those that follow from the list\n      if ((last_updated_ - obs.cloud_->header.stamp) > observation_keep_time_)\n      {\n        observation_list_.erase(obs_it, observation_list_.end());\n        return;\n      }\n    }\n  }\n}",
        "import_statements": [
            "#include <costmap_2d/observation_buffer.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n",
            "#include <tf2_sensor_msgs/tf2_sensor_msgs.h>\n",
            "#include <sensor_msgs/point_cloud2_iterator.h>\n"
        ],
        "reference_api": [
            "observation_list_.begin",
            "observation_list_.empty",
            "observation_list_.end",
            "ros::Duration",
            "observation_list_.erase"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "observation_list_.begin",
            "observation_list_.empty",
            "observation_list_.end",
            "ros::Duration",
            "observation_list_.erase"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)",
        "start_line": "121",
        "end_line": "132",
        "file_path": "global_planner/src/orientation_filter.cpp",
        "docstring": "This function, OrientationFilter::interpolate, interpolates the orientation of poses in a path between given start and end indices.\\nIt calculates the yaw angles at the start and end indices and determines the shortest angular distance between them.\\nIt then computes the incremental change in angle for each pose and updates the orientation of each pose in the specified range accordingly.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "71ce07e3ac3c",
        "ground_truth": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\n{\n    const double start_yaw = tf2::getYaw(path[start_index].pose.orientation),\n                 end_yaw   = tf2::getYaw(path[end_index  ].pose.orientation);\n    double diff = angles::shortest_angular_distance(start_yaw, end_yaw);\n    double increment = diff/(end_index-start_index);\n    for(int i=start_index; i<=end_index; i++){\n        double angle = start_yaw + increment * i;\n        set_angle(&path[i], angle);\n    }\n}",
        "import_statements": [
            "#include <global_planner/orientation_filter.h>\n",
            "#include <tf2/LinearMath/Matrix3x3.h>\n",
            "#include <tf2/utils.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n",
            "#include <angles/angles.h>\n"
        ],
        "reference_api": [
            "angles::shortest_angular_distance",
            "tf2::getYaw",
            "set_angle"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "set_angle",
                "code": "void set_angle(geometry_msgs::PoseStamped* pose, double angle)\n{\n  tf2::Quaternion q;\n  q.setRPY(0, 0, angle);\n  tf2::convert(q, pose->pose.orientation);\n}"
            }
        ],
        "third_party": [
            "angles::shortest_angular_distance",
            "tf2::getYaw"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)",
        "start_line": "67",
        "end_line": "79",
        "file_path": "global_planner/src/plan_node.cpp",
        "docstring": "This function, PlannerWithCostmap::makePlanService, processes a request to create a navigation plan.\\nIt sets the frame_id of the start and goal to \"map\" and calls makePlan to generate a path.\\nThe function then updates the response with the success status and the generated path if a plan is found.\\nFinally, it returns true to indicate that the service was processed.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "627b7bd5cdcc",
        "ground_truth": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp) {\n    vector<PoseStamped> path;\n     req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    bool success = makePlan(req.start, req.goal, path);\n    resp.plan_found = success;\n    if (success) {\n        resp.path = path;\n    }\n     return true;\n}",
        "import_statements": [
            "#include <global_planner/planner_core.h>\n",
            "#include <navfn/MakeNavPlan.h>\n",
            "#include <boost/shared_ptr.hpp>\n",
            "#include <costmap_2d/costmap_2d_ros.h>\n",
            "#include <tf2_ros/transform_listener.h>\n"
        ],
        "reference_api": [
            "makePlan"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "makePlan"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())",
        "start_line": "88",
        "end_line": "94",
        "file_path": "global_planner/src/plan_node.cpp",
        "docstring": "This constructor, PlannerWithCostmap::PlannerWithCostmap, initializes a PlannerWithCostmap object with a given name and Costmap2DROS pointer.\\nIt calls the base class constructor with the planner name, costmap, and global frame ID.\\nIt sets up a private ROS node handle, advertises a \"make_plan\" service, and subscribes to the \"goal\" topic to receive PoseStamped messages for planning purposes.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2375e2cf5e04",
        "ground_truth": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID()) {\n    ros::NodeHandle private_nh(\"~\");\n    cmap_ = cmap;\n    make_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    pose_sub_ = private_nh.subscribe<rm::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::poseCallback, this);\n}",
        "import_statements": [
            "#include <global_planner/planner_core.h>\n",
            "#include <navfn/MakeNavPlan.h>\n",
            "#include <boost/shared_ptr.hpp>\n",
            "#include <costmap_2d/costmap_2d_ros.h>\n",
            "#include <tf2_ros/transform_listener.h>\n"
        ],
        "reference_api": [
            "cmap->getGlobalFrameID",
            "cmap->getCostmap",
            "private_nh.advertiseService",
            "private_nh.subscribe<rm::PoseStamped>"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cmap->getGlobalFrameID",
            "cmap->getCostmap",
            "private_nh.advertiseService",
            "private_nh.subscribe<rm::PoseStamped>"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)",
        "start_line": "197",
        "end_line": "211",
        "file_path": "global_planner/src/planner_core.cpp",
        "docstring": "This function, GlobalPlanner::worldToMap, converts world coordinates (wx, wy) to map coordinates (mx, my).\\nIt checks if the world coordinates are within the bounds of the costmap's origin.\\nIf so, it calculates the map coordinates using the costmap's resolution and an offset.\\nIt returns true if the map coordinates are within the costmap's size limits; otherwise, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dd43b1eec476",
        "ground_truth": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my) {\n    double origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n    double resolution = costmap_->getResolution();\n     if (wx < origin_x || wy < origin_y)\n        return false;\n     mx = (wx - origin_x) / resolution - convert_offset_;\n    my = (wy - origin_y) / resolution - convert_offset_;\n     if (mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY())\n        return true;\n     return false;\n}",
        "import_statements": [
            "#include <global_planner/planner_core.h>\n",
            "#include <pluginlib/class_list_macros.hpp>\n",
            "#include <costmap_2d/cost_values.h>\n",
            "#include <costmap_2d/costmap_2d.h>\n",
            "#include <global_planner/dijkstra.h>\n",
            "#include <global_planner/astar.h>\n",
            "#include <global_planner/grid_path.h>\n",
            "#include <global_planner/gradient_path.h>\n",
            "#include <global_planner/quadratic_calculator.h>\n"
        ],
        "reference_api": [
            "costmap_->getOriginX",
            "costmap_->getOriginY",
            "costmap_->getResolution",
            "costmap_->getSizeInCellsX",
            "costmap_->getSizeInCellsY"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "costmap_->getOriginX",
            "costmap_->getOriginY",
            "costmap_->getResolution",
            "costmap_->getSizeInCellsX",
            "costmap_->getSizeInCellsY"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) ",
        "start_line": "324",
        "end_line": "344",
        "file_path": "global_planner/src/planner_core.cpp",
        "docstring": "This function, GlobalPlanner::publishPlan, publishes a given path as a nav_msgs::Path message.\\nIt first checks if the planner is initialized, logging an error and returning if not.\\nIt creates a Path message, sets its header with the frame ID and current time, and copies the poses from the input path.\\nFinally, it publishes the Path message using the plan_pub_ publisher.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a872b0e4c5a1",
        "ground_truth": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n    if (!initialized_) {\n        ROS_ERROR(\n                \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n     //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n     gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n     // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n     plan_pub_.publish(gui_path);\n}",
        "import_statements": [
            "#include <global_planner/planner_core.h>\n",
            "#include <pluginlib/class_list_macros.hpp>\n",
            "#include <costmap_2d/cost_values.h>\n",
            "#include <costmap_2d/costmap_2d.h>\n",
            "#include <global_planner/dijkstra.h>\n",
            "#include <global_planner/astar.h>\n",
            "#include <global_planner/grid_path.h>\n",
            "#include <global_planner/gradient_path.h>\n",
            "#include <global_planner/quadratic_calculator.h>\n"
        ],
        "reference_api": [
            "plan_pub_.publish",
            "ROS_ERROR",
            "gui_path.poses.resize",
            "ros::Time::now",
            "path.size"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "plan_pub_.publish",
            "ROS_ERROR",
            "gui_path.poses.resize",
            "ros::Time::now",
            "path.size"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)",
        "start_line": "275",
        "end_line": "282",
        "file_path": "move_base/src/move_base.cpp",
        "docstring": "This function, MoveBase::goalCB, is a callback that processes a new goal in the form of a PoseStamped message.\\nIt logs a debug message indicating it is wrapping the goal in an action message.\\nThe function creates a MoveBaseActionGoal, sets its timestamp to the current time, assigns the received goal to the target_pose, and publishes the action goal to the action_goal_pub_ topic.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d951b6aa5415",
        "ground_truth": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){\n  ROS_DEBUG_NAMED(\"move_base\",\"In ROS goal callback, wrapping the PoseStamped in the action message and re-sending to the server.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}",
        "import_statements": [
            "#include <move_base/move_base.h>\n",
            "#include <move_base_msgs/RecoveryStatus.h>\n",
            "#include <cmath>\n",
            "#include <boost/algorithm/string.hpp>\n",
            "#include <boost/thread.hpp>\n",
            "#include <geometry_msgs/Twist.h>\n",
            "#include <tf2_geometry_msgs/tf2_geometry_msgs.h>\n"
        ],
        "reference_api": [
            "action_goal_pub_.publish",
            "ROS_DEBUG_NAMED",
            "ros::Time::now"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "action_goal_pub_.publish",
            "ROS_DEBUG_NAMED",
            "ros::Time::now"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)",
        "start_line": "169",
        "end_line": "184",
        "file_path": "move_slow_and_clear/src/move_slow_and_clear.cpp",
        "docstring": "This function, MoveSlowAndClear::distanceCheck, checks if the robot has moved a sufficient distance by comparing the squared limited distance to the squared current distance.\\nIf the robot has moved far enough, it logs a message, joins and deletes any existing remove limit thread, starts a new thread to remove the speed limit, and stops the distance check timer.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c0a0aa52bf2a",
        "ground_truth": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\n{\n  if(limited_distance_ * limited_distance_ <= getSqDistance())\n  {\n    ROS_INFO(\"Moved far enough, removing speed limit.\");\n    //have to do this because a system call within a timer cb does not seem to play nice\n    if(remove_limit_thread_)\n    {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    distance_check_timer_.stop();\n  }\n}",
        "import_statements": [
            "#include <move_slow_and_clear/move_slow_and_clear.h>\n",
            "#include <pluginlib/class_list_macros.hpp>\n",
            "#include <costmap_2d/obstacle_layer.h>\n"
        ],
        "reference_api": [
            "getSqDistance",
            "boost::bind",
            "ROS_INFO",
            "distance_check_timer_.stop",
            "remove_limit_thread_->join"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getSqDistance",
                "code": "double MoveSlowAndClear::getSqDistance()\n  {\n    geometry_msgs::PoseStamped global_pose;\n    global_costmap_->getRobotPose(global_pose);\n    double x1 = global_pose.pose.position.x;\n    double y1 = global_pose.pose.position.y;\n\n    double x2 = speed_limit_pose_.pose.position.x;\n    double y2 = speed_limit_pose_.pose.position.y;\n\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  }"
            }
        ],
        "third_party": [
            "boost::bind",
            "ROS_INFO",
            "distance_check_timer_.stop",
            "remove_limit_thread_->join"
        ]
    },
    {
        "subclass": "ROS",
        "owner/repo": "ros-planning/navigation",
        "function_declaration": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)",
        "start_line": "83",
        "end_line": "88",
        "file_path": "navfn/src/navfn_node.cpp",
        "docstring": "This function, NavfnWithCostmap::poseCallback, is a callback for handling pose updates.\\nIt retrieves the current global pose of the robot using getRobotPose.\\nIt then generates a path from the current pose to the goal pose by calling makePlan with the global pose, goal pose, and an empty path vector.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1dfe1160ebc8",
        "ground_truth": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal) {\n  geometry_msgs::PoseStamped global_pose;\n  cmap_->getRobotPose(global_pose);\n  vector<PoseStamped> path;\n  makePlan(global_pose, *goal, path);\n}",
        "import_statements": [
            "#include <navfn/navfn_ros.h>\n",
            "#include <navfn/MakeNavPlan.h>\n",
            "#include <boost/shared_ptr.hpp>\n",
            "#include <costmap_2d/costmap_2d_ros.h>\n",
            "#include <tf2_ros/transform_listener.h>\n"
        ],
        "reference_api": [
            "cmap_->getRobotPose",
            "makePlan"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cmap_->getRobotPose",
            "makePlan"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)",
        "start_line": "50",
        "end_line": "56",
        "file_path": "Modules/communication/src/autonomous_landing_topic.cpp",
        "docstring": "This function, AutonomousLanding::gimbalParamSetServer, sets gimbal parameters by creating a ParamSet service request.\\nIt assigns the parameter ID and value from the provided GimbalParamSet structure to the service request.\\nThe function then calls the param_set_client_ to send the request.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b676d86cb556",
        "ground_truth": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\n{\n    mavros_msgs::ParamSet srv;\n    srv.request.param_id = param_set.param_id;\n    srv.request.value.real = param_set.real;\n    this->param_set_client_.call(srv);\n}",
        "import_statements": [
            "#include \"autonomous_landing_topic.hpp\"\n"
        ],
        "reference_api": [
            "this->param_set_client_.call"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->param_set_client_.call"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void CommunicationBridge::serverFun()",
        "start_line": "92",
        "end_line": "127",
        "file_path": "Modules/communication/src/communication_bridge.cpp",
        "docstring": "This function, CommunicationBridge::serverFun, handles server-side TCP communication.\\nIt first waits for a connection from the ground station on a specified port.\\nOnce connected, it enters a loop to accept incoming connections, receive data, and process it.\\nIf data is received successfully, it decodes the message and publishes it.\\nIf the received message length is zero or less, it logs an error and closes the socket.\\nThe loop continues to handle further connections.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "62e31971c89c",
        "ground_truth": "void CommunicationBridge::serverFun()\n{\n    int valread;\n    if (waitConnectionFromGroundStation(TCP_PORT) < 0)\n    {\n        ROS_ERROR(\"[bridge_node]Socket recever creation error!\");\n        exit(EXIT_FAILURE);\n    }\n     while (true)\n    {\n        // \u7b49\u5f85\u8fde\u63a5\u961f\u5217\u4e2d\u62bd\u53d6\u7b2c\u4e00\u4e2a\u8fde\u63a5\uff0c\u521b\u5efa\u4e00\u4e2a\u4e0es\u540c\u7c7b\u7684\u65b0\u7684\u5957\u63a5\u53e3\u5e76\u8fd4\u56de\u53e5\u67c4\u3002\n        if ((recv_sock = accept(server_fd, (struct sockaddr *)NULL, NULL)) < 0)\n        {\n            perror(\"accept\");\n            exit(EXIT_FAILURE);\n        }\n         // recv\u51fd\u6570\u4eceTCP\u8fde\u63a5\u7684\u53e6\u4e00\u7aef\u63a5\u6536\u6570\u636e\n        valread = recv(recv_sock, tcp_recv_buf, BUF_LEN, 0);\n         if (valread <= 0)\n        {\n            ROS_ERROR(\"Received message length <= 0, maybe connection has lost\");\n            close(recv_sock);\n            continue;\n        }\n         // std::lock_guard<std::mutex> lg(g_m);\n         std::cout << \"tcp valread: \" << valread << std::endl;\n        // char *ptr = tcp_recv_buf;\n        pubMsg(decodeMsg(tcp_recv_buf, Send_Mode::TCP));\n        close(recv_sock);\n    }\n}",
        "import_statements": [
            "#include \"communication_bridge.hpp\"\n",
            "#include <boost/thread/mutex.hpp>\n",
            "#include <boost/thread/shared_mutex.hpp>\n"
        ],
        "reference_api": [
            "recv",
            "waitConnectionFromGroundStation",
            "pubMsg",
            "accept",
            "decodeMsg",
            "perror",
            "ROS_ERROR",
            "close",
            "exit"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "recv",
            "waitConnectionFromGroundStation",
            "pubMsg",
            "accept",
            "decodeMsg",
            "ROS_ERROR",
            "close"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)",
        "start_line": "139",
        "end_line": "159",
        "file_path": "Modules/communication/src/communication_bridge.cpp",
        "docstring": "This function, CommunicationBridge::recvData, processes incoming UAV commands.\\nIf not in simulation mode, it publishes the command to a single UAV using uav_basic_.\\nIn simulation mode, it finds the corresponding UAV by ID from swarm_control_simulation_ and publishes the command to the matching UAV.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5821c289e637",
        "ground_truth": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\n{\n    // \u975e\u4eff\u771f\u60c5\u51b5 \u53ea\u6709\u4e00\u4e2aUAV\n    if (this->is_simulation_ == 0)\n    {\n        if (this->uav_basic_ == NULL)\n        {\n            return;\n        }\n        this->uav_basic_->uavCmdPub(uav_cmd);\n    }\n    // \u4eff\u771f\u60c5\u51b5\u4e0b \u53ef\u80fd\u5b58\u5728\u591a\u4e2aUAV \u627e\u5230\u5bf9\u5e94ID\u8fdb\u884c\u53d1\u5e03\u5bf9\u5e94\u7684\u63a7\u5236\u547d\u4ee4\n    else\n    {\n        auto it = this->swarm_control_simulation_.find(recv_id);\n        if (it != this->swarm_control_simulation_.end())\n        {\n            (*it).second->uavCmdPub(uav_cmd);\n        }\n    }\n}",
        "import_statements": [
            "#include \"communication_bridge.hpp\"\n",
            "#include <boost/thread/mutex.hpp>\n",
            "#include <boost/thread/shared_mutex.hpp>\n"
        ],
        "reference_api": [
            "this->uav_basic_->uavCmdPub",
            "(*it).second->uavCmdPub",
            "this->swarm_control_simulation_.end",
            "this->swarm_control_simulation_.find"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->uav_basic_->uavCmdPub",
            "(*it).second->uavCmdPub",
            "this->swarm_control_simulation_.end",
            "this->swarm_control_simulation_.find"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)",
        "start_line": "515",
        "end_line": "534",
        "file_path": "Modules/communication/src/communication_bridge.cpp",
        "docstring": "This function, CommunicationBridge::modeSwitch, handles mode switching based on the provided ModeSelection struct.\\nIt executes system commands for REBOOTNX and EXITNX modes.\\nAdditionally, it calls createMode or deleteMode functions based on the use_mode field of the mode_selection.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5c3d44ff8f30",
        "ground_truth": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\n{\n    if (mode_selection.mode == ModeSelection::Mode::REBOOTNX)\n    {\n        system(REBOOTNXCMD);\n    }\n    else if (mode_selection.mode == ModeSelection::Mode::EXITNX)\n    {\n        system(EXITNXCMD);\n    }\n     if (mode_selection.use_mode == ModeSelection::UseMode::UM_CREATE)\n    {\n        createMode(mode_selection);\n    }\n    else if (mode_selection.use_mode == ModeSelection::UseMode::UM_DELETE)\n    {\n        deleteMode(mode_selection);\n    }\n}",
        "import_statements": [
            "#include \"communication_bridge.hpp\"\n",
            "#include <boost/thread/mutex.hpp>\n",
            "#include <boost/thread/shared_mutex.hpp>\n"
        ],
        "reference_api": [
            "deleteMode",
            "system",
            "createMode"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "deleteMode",
            "createMode"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)",
        "start_line": "1338",
        "end_line": "1376",
        "file_path": "Modules/communication/src/communication_bridge.cpp",
        "docstring": "This function, CommunicationBridge::checkHeartbeatState, monitors the heartbeat status to ensure connectivity.\\nIt uses a counter to track missed heartbeats.\\nIf the heartbeat count remains unchanged for a specified number of attempts, it prints an error message and triggers appropriate actions based on the type of vehicle (swarm, UAV, or UGV).\\nIf connectivity is lost, it sets the disconnect_flag to true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bcf7b6ccf539",
        "ground_truth": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\n{\n    static int disconnect = 0;\n    if (!disconnect_flag && this->is_heartbeat_ready_)\n    {\n        static long count = 0;\n        if (count != this->heartbeat_count)\n        {\n            count = heartbeat_count;\n            disconnect = 0;\n        }\n        else\n        {\n            disconnect++;\n            if (disconnect > try_connect_num)\n            {\n                std::cout << \"conenect ground station failed, please check the ground station IP!\" << std::endl;\n                // \u5982\u679c\u662f\u96c6\u7fa4\u6a21\u5f0f \u7531\u96c6\u7fa4\u6a21\u5757\u89e6\u53d1\u964d\u843d\n                if (this->swarm_num_ != 0 && this->swarm_control_ != NULL)\n                {\n                    triggerSwarmControl();\n                }\n                // \u65e0\u4eba\u673a \u89e6\u53d1\u964d\u843d\u6216\u8005\u8fd4\u822a\n                else if (this->uav_basic_ != NULL)\n                {\n                    triggerUAV();\n                }\n                // \u65e0\u4eba\u8f66  \u505c\u6b62\u5c0f\u8f66\n                else if (this->ugv_basic_ != NULL)\n                {\n                    // \u505c\u6b62\u5c0f\u8f66\n                    triggerUGV();\n                }\n                disconnect_flag = true;\n                // this->is_heartbeat_ready_ = false;\n            }\n        }\n    }\n}",
        "import_statements": [
            "#include \"communication_bridge.hpp\"\n",
            "#include <boost/thread/mutex.hpp>\n",
            "#include <boost/thread/shared_mutex.hpp>\n"
        ],
        "reference_api": [
            "triggerUAV",
            "triggerSwarmControl",
            "triggerUGV"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "triggerUAV",
            "triggerSwarmControl",
            "triggerUGV"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)",
        "start_line": "65",
        "end_line": "96",
        "file_path": "Modules/communication/src/ego_planner_swarm_topic.cpp",
        "docstring": "This function, EGOPlannerSwarm::multitrajSubTcpCb, processes incoming MultiBsplines messages.\\nIt extracts the drone ID and trajectory data from the message.\\nFor each trajectory, it initializes a Bspline struct, sets its attributes, and populates its knots, position points, and yaw points.\\nFinally, it encodes the MultiBsplines data and sends it via TCP using the communication module.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9902ba9e57ac",
        "ground_truth": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\n{\n    struct MultiBsplines multi_bsplines;\n    multi_bsplines.drone_id_from = msg->drone_id_from;\n    for (int i = 0; i < msg->traj.size(); i++)\n    {\n        struct Bspline bspline;\n        bspline.drone_id = msg->traj[i].drone_id;\n        bspline.order = msg->traj[i].order;\n        bspline.traj_id = msg->traj[i].traj_id;\n        bspline.sec = msg->traj[i].start_time.toSec();\n        bspline.drone_id = msg->traj[i].drone_id;\n        for (int j = 0; j < msg->traj[i].knots.size(); j++)\n        {\n            bspline.knots.push_back(msg->traj[i].knots[j]);\n        }\n        for (int j = 0; j < msg->traj[i].pos_pts.size(); j++)\n        {\n            struct Point point;\n            point.x = msg->traj[i].pos_pts[j].x;\n            point.y = msg->traj[i].pos_pts[j].y;\n            point.z = msg->traj[i].pos_pts[j].z;\n            bspline.pos_pts.push_back(point);\n        }\n        for (int j = 0; j < msg->traj[i].yaw_pts.size(); j++)\n        {\n            bspline.yaw_pts.push_back(msg->traj[i].yaw_pts[j]);\n        }\n        bspline.yaw_dt = msg->traj[i].yaw_dt;\n    }\n    this->communication->sendMsgByTcp(this->communication->encodeMsg(Send_Mode::TCP, multi_bsplines), tcp_ip_);\n}",
        "import_statements": [
            "#include \"ego_planner_swarm_topic.hpp\"\n"
        ],
        "reference_api": [
            "msg->traj.size",
            "bspline.knots.push_back",
            "msg->traj[i].knots.size",
            "msg->traj[i].yaw_pts.size",
            "bspline.pos_pts.push_back",
            "bspline.yaw_pts.push_back",
            "msg->traj[i].start_time.toSec",
            "this->communication->sendMsgByTcp",
            "msg->traj[i].pos_pts.size",
            "this->communication->encodeMsg"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "msg->traj.size",
            "bspline.knots.push_back",
            "msg->traj[i].knots.size",
            "msg->traj[i].yaw_pts.size",
            "bspline.pos_pts.push_back",
            "bspline.yaw_pts.push_back",
            "msg->traj[i].start_time.toSec",
            "this->communication->sendMsgByTcp",
            "msg->traj[i].pos_pts.size",
            "this->communication->encodeMsg"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)",
        "start_line": "273",
        "end_line": "305",
        "file_path": "Modules/communication/src/rviz_reduce_the_frequency.cpp",
        "docstring": "This function, ReduceTheFrequency::compressed, compresses a PointCloud2 message using an octree compression technique.\\nIt converts the input message to a pcl::PointCloud, compresses the point cloud, and stores the compressed data.\\nIt then creates a new PointCloud2 message with the compressed data and returns it, ensuring to release dynamically allocated memory.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "06a33ff38797",
        "ground_truth": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\n{\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n     // \u521b\u5efaOctree\u538b\u7f29\u5bf9\u8c61\n    pcl::io::OctreePointCloudCompression<pcl::PointXYZ> octree_compression;\n    octree_compression.setInputCloud(cloud);\n     // \u538b\u7f29\u70b9\u4e91\u6570\u636e\n    std::stringstream compressed_data;\n    octree_compression.encodePointCloud(cloud,compressed_data);\n     // \u83b7\u53d6\u538b\u7f29\u6570\u636e\u7684\u5927\u5c0f\n    std::string compressed_str = compressed_data.str();\n    size_t compressed_size = compressed_str.size();\n     // \u521b\u5efa\u52a8\u6001\u5206\u914d\u7684\u5185\u5b58\u5e76\u590d\u5236\u538b\u7f29\u6570\u636e\n    uint8_t* compressed_data_ptr = new uint8_t[compressed_size];\n    std::memcpy(compressed_data_ptr, compressed_str.data(), compressed_size);\n     // \u521b\u5efa\u538b\u7f29\u540e\u7684PointCloud2\u6d88\u606f\n    sensor_msgs::PointCloud2 compressed_cloud_msg;\n    compressed_cloud_msg.header = msg.header;\n    compressed_cloud_msg.row_step = compressed_size;  // \u538b\u7f29\u6570\u636e\u7684\u5927\u5c0f\u4f5c\u4e3a\u884c\u6b65\u957f\n    compressed_cloud_msg.is_dense = true;\n    compressed_cloud_msg.data = std::vector<uint8_t>(compressed_data_ptr, compressed_data_ptr + compressed_size);\n     // \u91ca\u653e\u52a8\u6001\u5206\u914d\u7684\u5185\u5b58\n    delete[] compressed_data_ptr;// \u83b7\u53d6\u538b\u7f29\u6570\u636e\u7684\u5927\u5c0f\n     return compressed_cloud_msg;\n}",
        "import_statements": [
            "#include \"rviz_reduce_the_frequency.hpp\"\n"
        ],
        "reference_api": [
            "octree_compression.encodePointCloud",
            "compressed_str.size",
            "octree_compression.setInputCloud",
            "pcl::fromROSMsg",
            "std::memcpy",
            "compressed_str.data",
            "std::vector<uint8_t>",
            "compressed_data.str"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "octree_compression.encodePointCloud",
            "compressed_str.size",
            "octree_compression.setInputCloud",
            "pcl::fromROSMsg",
            "compressed_str.data",
            "compressed_data.str"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)",
        "start_line": "272",
        "end_line": "283",
        "file_path": "Modules/communication/src/swarm_control_topic.cpp",
        "docstring": "This function, SwarmControl::updateAllUAVState, updates the state of a specific UAV in the multi_uav_state_ list.\\nIt iterates through the list of UAV states and replaces the matching UAV state with the new uav_state data based on the UAV ID.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b40ab9b96523",
        "ground_truth": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\n{\n    // \u66f4\u65b0\u6570\u636e\n    for (int i = 0; i < this->multi_uav_state_.uav_state_all.size(); i++)\n    {\n        if (this->multi_uav_state_.uav_state_all[i].uav_id == uav_state.uav_id)\n        {\n            this->multi_uav_state_.uav_state_all[i] = uav_state;\n            break;\n        }\n    }\n}",
        "import_statements": [
            "#include \"swarm_control_topic.hpp\"\n"
        ],
        "reference_api": [
            "this->multi_uav_state_.uav_state_all.size"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->multi_uav_state_.uav_state_all.size"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)",
        "start_line": "397",
        "end_line": "424",
        "file_path": "Modules/communication/src/swarm_control_topic.cpp",
        "docstring": "This function, SwarmControl::allUGVStatePub, publishes the state of all UGVs.\\nIt initializes a MultiUGVState message and iterates through each UGV state in the provided MultiUGVState structure.\\nFor each UGV, it populates the UGVState message with ID, battery, position, velocity, and attitude data.\\nThe function increments the UGV count and adds each UGVState to the MultiUGVState message.\\nFinally, it publishes the assembled MultiUGVState message.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2b10d764e7d1",
        "ground_truth": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\n{\n    prometheus_msgs::MultiUGVState multi_ugv_state;\n    multi_ugv_state.swarm_num_ugv = 0;\n     for (auto it = m_multi_ugv_state.ugv_state_all.begin(); it != m_multi_ugv_state.ugv_state_all.end(); it++)\n    {\n        prometheus_msgs::UGVState ugv_state;\n        ugv_state.ugv_id = (*it).ugv_id;\n        ugv_state.battery = (*it).battery;\n        for (int i = 0; i < 3; i++)\n        {\n            ugv_state.position[i] = (*it).position[i];\n            ugv_state.velocity[i] = (*it).velocity[i];\n            ugv_state.attitude[i] = (*it).attitude[i];\n        };\n        ugv_state.attitude_q.x = (*it).attitude_q.x;\n        ugv_state.attitude_q.y = (*it).attitude_q.y;\n        ugv_state.attitude_q.z = (*it).attitude_q.z;\n        ugv_state.attitude_q.w = (*it).attitude_q.w;\n         multi_ugv_state.swarm_num_ugv++;\n        multi_ugv_state.ugv_state_all.push_back(ugv_state);\n    }\n     // \u53d1\u5e03\u8bdd\u9898\n    this->all_ugv_state_pub_.publish(multi_ugv_state);\n}",
        "import_statements": [
            "#include \"swarm_control_topic.hpp\"\n"
        ],
        "reference_api": [
            "this->all_ugv_state_pub_.publish",
            "m_multi_ugv_state.ugv_state_all.begin",
            "m_multi_ugv_state.ugv_state_all.end",
            "multi_ugv_state.ugv_state_all.push_back"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "this->all_ugv_state_pub_.publish",
            "m_multi_ugv_state.ugv_state_all.begin",
            "m_multi_ugv_state.ugv_state_all.end",
            "multi_ugv_state.ugv_state_all.push_back"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)",
        "start_line": "829",
        "end_line": "862",
        "file_path": "Modules/ego_planner_swarm/bspline_opt/src/bspline_optimizer.cpp",
        "docstring": "This function, BsplineOptimizer::calcMovingObjCost, calculates the cost and gradient of a B-spline trajectory concerning moving objects.\\nIt iterates through control points of the B-spline, computes the predicted positions of moving objects, and evaluates the distance between control points and these objects.\\nIf the distance is less than a specified clearance, it updates the cost and gradient based on the distance error.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4a018cebf34b",
        "ground_truth": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n{\n  cost = 0.0;\n  int end_idx = q.cols() - order_;\n  constexpr double CLEARANCE = 1.5;\n  double t_now = ros::Time::now().toSec();\n  for (int i = order_; i < end_idx; i++)\n  {\n    double time = ((double)(order_ - 1) / 2 + (i - order_ + 1)) * bspline_interval_;\n    for (int id = 0; id < moving_objs_->getObjNums(); id++)\n    {\n      Eigen::Vector3d obj_prid = moving_objs_->evaluateConstVel(id, t_now + time);\n      double dist = (cps_.points.col(i) - obj_prid).norm();\n      //cout /*<< \"cps_.points.col(i)=\" << cps_.points.col(i).transpose()*/ << \" moving_objs_=\" << obj_prid.transpose() << \" dist=\" << dist << endl;\n      double dist_err = CLEARANCE - dist;\n      Eigen::Vector3d dist_grad = (cps_.points.col(i) - obj_prid).normalized();\n      if (dist_err < 0)\n      {\n        /* do nothing */\n      }\n      else\n      {\n        cost += pow(dist_err, 2);\n        gradient.col(i) += -2.0 * dist_err * dist_grad;\n      }\n    }\n    // cout << \"time=\" << time << \" i=\" << i << \" order_=\" << order_ << \" end_idx=\" << end_idx << endl;\n    // cout << \"--\" << endl;\n  }\n  // cout << \"---------------\" << endl;\n}",
        "import_statements": [
            "#include \"bspline_opt/bspline_optimizer.h\"\n",
            "#include \"bspline_opt/gradient_descent_optimizer.h\"\n"
        ],
        "reference_api": [
            "ros::Time::now().toSec",
            "(cps_.points.col(i) - obj_prid).norm",
            "gradient.col",
            "moving_objs_->evaluateConstVel",
            "cps_.points.col",
            "pow",
            "(cps_.points.col(i) - obj_prid).normalized",
            "q.cols",
            "moving_objs_->getObjNums",
            "ros::Time::now"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ros::Time::now().toSec",
            "(cps_.points.col(i) - obj_prid).norm",
            "gradient.col",
            "moving_objs_->evaluateConstVel",
            "cps_.points.col",
            "(cps_.points.col(i) - obj_prid).normalized",
            "q.cols",
            "moving_objs_->getObjNums",
            "ros::Time::now"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)",
        "start_line": "905",
        "end_line": "933",
        "file_path": "Modules/ego_planner_swarm/bspline_opt/src/bspline_optimizer.cpp",
        "docstring": "This function, BsplineOptimizer::calcFitnessCost, calculates the fitness cost and its gradient for a B-spline trajectory.\\nIt initializes the cost to zero and iterates through the control points of the trajectory.\\nFor each point, it computes the positional error relative to reference points and a velocity vector.\\nThe cost function is based on the squared dot product and cross product of these vectors, normalized by constants a2 and b2.\\nThe gradient is updated for each control point using the computed derivatives.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e805f5d0beea",
        "ground_truth": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n{\n  cost = 0.0;\n  int end_idx = q.cols() - order_;\n  // def: f = |x*v|^2/a^2 + |x\u00d7v|^2/b^2\n  double a2 = 25, b2 = 1;\n  for (auto i = order_ - 1; i < end_idx + 1; ++i)\n  {\n    Eigen::Vector3d x = (q.col(i - 1) + 4 * q.col(i) + q.col(i + 1)) / 6.0 - ref_pts_[i - 1];\n    Eigen::Vector3d v = (ref_pts_[i] - ref_pts_[i - 2]).normalized();\n    double xdotv = x.dot(v);\n    Eigen::Vector3d xcrossv = x.cross(v);\n    double f = pow((xdotv), 2) / a2 + pow(xcrossv.norm(), 2) / b2;\n    cost += f;\n    Eigen::Matrix3d m;\n    m << 0, -v(2), v(1), v(2), 0, -v(0), -v(1), v(0), 0;\n    Eigen::Vector3d df_dx = 2 * xdotv / a2 * v + 2 / b2 * m * xcrossv;\n    gradient.col(i - 1) += df_dx / 6;\n    gradient.col(i) += 4 * df_dx / 6;\n    gradient.col(i + 1) += df_dx / 6;\n  }\n}",
        "import_statements": [
            "#include \"bspline_opt/bspline_optimizer.h\"\n",
            "#include \"bspline_opt/gradient_descent_optimizer.h\"\n"
        ],
        "reference_api": [
            "q.col",
            "gradient.col",
            "x.cross",
            "pow",
            "x.dot",
            "(ref_pts_[i] - ref_pts_[i - 2]).normalized",
            "xcrossv.norm",
            "q.cols",
            "v"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "q.col",
            "gradient.col",
            "x.cross",
            "x.dot",
            "(ref_pts_[i] - ref_pts_[i - 2]).normalized",
            "xcrossv.norm",
            "q.cols",
            "v"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "double UniformBspline::getJerk()",
        "start_line": "306",
        "end_line": "324",
        "file_path": "Modules/ego_planner_swarm/bspline_opt/src/uniform_bspline.cpp",
        "docstring": "This function, UniformBspline::getJerk, calculates the jerk of a uniform B-spline trajectory.\\nIt first computes the third derivative of the spline to obtain the jerk trajectory.\\nIt then retrieves the knot times and control points of the jerk trajectory.\\nThe function iterates through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times.\\nFinally, it returns the total jerk value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "265612743518",
        "ground_truth": "double UniformBspline::getJerk()\n{\n  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n  Eigen::VectorXd times = jerk_traj.getKnot();\n  Eigen::MatrixXd ctrl_pts = jerk_traj.getControlPoint();\n  int dimension = ctrl_pts.rows();\n  double jerk = 0.0;\n  for (int i = 0; i < ctrl_pts.cols(); ++i)\n  {\n    for (int j = 0; j < dimension; ++j)\n    {\n      jerk += (times(i + 1) - times(i)) * ctrl_pts(j, i) * ctrl_pts(j, i);\n    }\n  }\n  return jerk;\n}",
        "import_statements": [
            "#include \"bspline_opt/uniform_bspline.h\"\n",
            "#include <ros/ros.h>\n"
        ],
        "reference_api": [
            "getDerivative().getDerivative().getDerivative",
            "jerk_traj.getControlPoint",
            "getDerivative().getDerivative",
            "getDerivative",
            "times",
            "ctrl_pts.cols",
            "ctrl_pts.rows",
            "jerk_traj.getKnot",
            "ctrl_pts"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getDerivative",
                "code": "UniformBspline UniformBspline::getDerivative()\n  {\n    Eigen::MatrixXd ctp = getDerivativeControlPoints();\n    UniformBspline derivative(ctp, p_ - 1, interval_);\n\n    /* cut the first and last knot */\n    Eigen::VectorXd knot(u_.rows() - 2);\n    knot = u_.segment(1, u_.rows() - 2);\n    derivative.setKnot(knot);\n\n    return derivative;\n  }"
            }
        ],
        "third_party": [
            "getDerivative().getDerivative().getDerivative",
            "jerk_traj.getControlPoint",
            "getDerivative().getDerivative",
            "times",
            "ctrl_pts.cols",
            "ctrl_pts.rows",
            "jerk_traj.getKnot",
            "ctrl_pts"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) ",
        "start_line": "87",
        "end_line": "95",
        "file_path": "Modules/ego_planner_swarm/drone_detect/src/drone_detector.cpp",
        "docstring": "This function, DroneDetector::depth2Pos, calculates the 3D position of a point in camera coordinates from its 2D pixel coordinates and depth.\\nIt uses intrinsic camera parameters (cx_, cy_, fx_, fy_) to transform the pixel coordinates (u, v) and depth into a 4D position vector in the camera frame.\\nThe function returns this 4D position vector.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "87e33e1ff32a",
        "ground_truth": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \n{\n  Eigen::Vector4d pose_in_camera;\n  pose_in_camera(0) = (u - cx_) * depth / fx_;\n  pose_in_camera(1) = (v - cy_) * depth / fy_;\n  pose_in_camera(2) = depth; \n  pose_in_camera(3) = 1.0;\n  return pose_in_camera;\n}",
        "import_statements": [
            "#include \"drone_detector/drone_detector.h\"\n",
            "#include <string>\n"
        ],
        "reference_api": [
            "pose_in_camera"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "pose_in_camera"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)",
        "start_line": "269",
        "end_line": "281",
        "file_path": "Modules/ego_planner_swarm/drone_detect/src/drone_detector.cpp",
        "docstring": "This function, DroneDetector::rcvDroneXOdomCallback, processes odometry messages for drones.\\nIt extracts the drone ID from the child_frame_id field of the odometry message.\\nIt then calls rcvDroneOdomCallbackBase with the odometry data and drone ID.\\nIf extracting the drone ID fails, it catches and prints the exception.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f3fb61d01c80",
        "ground_truth": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\n{\n  std::string numstr = odom.child_frame_id.substr(6);\n  try\n  {\n    int drone_id = std::stoi(numstr);\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  }\n  catch(const std::exception& e)\n  {\n    std::cout << e.what() << '\\n';\n  }\n}",
        "import_statements": [
            "#include \"drone_detector/drone_detector.h\"\n",
            "#include <string>\n"
        ],
        "reference_api": [
            "rcvDroneOdomCallbackBase",
            "std::stoi",
            "odom.child_frame_id.substr",
            "e.what"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "rcvDroneOdomCallbackBase",
            "odom.child_frame_id.substr",
            "e.what"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)",
        "start_line": "396",
        "end_line": "417",
        "file_path": "Modules/ego_planner_swarm/drone_detect/src/drone_detector.cpp",
        "docstring": "This function, DroneDetector::detect, attempts to detect a drone based on its ID and true pixel position.\\nIt calculates the true pose of the drone in the camera frame and checks for its presence.\\nIf found, it computes the pose error between the camera and world coordinates, updates the debug result, and publishes the pose error.\\nIf not found, it updates the debug result to indicate failure.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6710d78c1118",
        "ground_truth": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\n{\n  Eigen::Vector4d true_pose_cam, pose_error;\n  bool found = countPixel(drone_id, true_pixel, true_pose_cam); \n  if (found) {\n    // ROS_WARN(\"FOUND\");\n    pose_error = cam2world_*true_pose_cam - drone_pose_world_[drone_id];\n    debug_detect_result_[drone_id] = 2;\n     geometry_msgs::PoseStamped out_msg;\n    out_msg.header.stamp = my_last_camera_stamp_;\n    out_msg.header.frame_id = \"/drone_detect\";\n    out_msg.pose.position.x = pose_error(0);\n    out_msg.pose.position.y = pose_error(1);\n    out_msg.pose.position.z = pose_error(2);\n    drone_pose_err_pub_[drone_id].publish(out_msg);\n   } else {\n    // ROS_WARN(\"NOT FOUND\");\n    debug_detect_result_[drone_id] = 1;\n  }\n}",
        "import_statements": [
            "#include \"drone_detector/drone_detector.h\"\n",
            "#include <string>\n"
        ],
        "reference_api": [
            "countPixel",
            "drone_pose_err_pub_[drone_id].publish",
            "pose_error"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "countPixel",
            "drone_pose_err_pub_[drone_id].publish",
            "pose_error"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)",
        "start_line": "77",
        "end_line": "89",
        "file_path": "Modules/ego_planner_swarm/path_searching/src/dyn_a_star.cpp",
        "docstring": "This function, AStar::retrievePath, constructs a path by tracing back from a given node to the start node.\\nIt initializes a path vector with the current node and iteratively follows the cameFrom pointers to previous nodes, adding each to the path, until it reaches the start node.\\nThe function returns the constructed path.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d06c9f07769a",
        "ground_truth": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\n{\n    vector<GridNodePtr> path;\n    path.push_back(current);\n     while (current->cameFrom != NULL)\n    {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n     return path;\n}",
        "import_statements": [
            "#include \"path_searching/dyn_a_star.h\"\n"
        ],
        "reference_api": [
            "path.push_back"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "path.push_back"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)",
        "start_line": "91",
        "end_line": "119",
        "file_path": "Modules/ego_planner_swarm/path_searching/src/dyn_a_star.cpp",
        "docstring": "This function, AStar::ConvertToIndexAndAdjustStartEndPoints, converts 3D coordinates of start and end points to grid indices and adjusts them if they are inside obstacles.\\nIt first attempts to convert the coordinates to indices.\\nIf the start or end point is inside an obstacle, it iteratively adjusts the point by moving it away from the other point until it is no longer in an obstacle.\\nIt returns true if successful, and false if the conversion or adjustment fails.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "22b98a6c5348",
        "ground_truth": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\n{\n    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n        return false;\n     if (checkOccupancy(Index2Coord(start_idx)))\n    {\n        //ROS_WARN(\"Start point is insdide an obstacle.\");\n        do\n        {\n            start_pt = (start_pt - end_pt).normalized() * step_size_ + start_pt;\n            if (!Coord2Index(start_pt, start_idx))\n                return false;\n        } while (checkOccupancy(Index2Coord(start_idx)));\n    }\n     if (checkOccupancy(Index2Coord(end_idx)))\n    {\n        //ROS_WARN(\"End point is insdide an obstacle.\");\n        do\n        {\n            end_pt = (end_pt - start_pt).normalized() * step_size_ + end_pt;\n            if (!Coord2Index(end_pt, end_idx))\n                return false;\n        } while (checkOccupancy(Index2Coord(end_idx)));\n    }\n     return true;\n}",
        "import_statements": [
            "#include \"path_searching/dyn_a_star.h\"\n"
        ],
        "reference_api": [
            "Coord2Index",
            "checkOccupancy",
            "(start_pt - end_pt).normalized",
            "Index2Coord",
            "(end_pt - start_pt).normalized"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Coord2Index",
            "checkOccupancy",
            "(start_pt - end_pt).normalized",
            "Index2Coord",
            "(end_pt - start_pt).normalized"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)",
        "start_line": "201",
        "end_line": "213",
        "file_path": "Modules/ego_planner_swarm/plan_env/src/grid_map.cpp",
        "docstring": "This function, GridMap::resetBuffer, resets the occupancy and distance buffer within a specified 3D region.\\nIt iterates over the grid coordinates from min_id to max_id and sets the corresponding elements in the occupancy_buffer_inflate_ to zero.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4c5e9b3dd1d9",
        "ground_truth": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\n{\n   Eigen::Vector3i min_id, max_id;\n   /* reset occ and dist buffer */\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z)\n      {\n        md_.occupancy_buffer_inflate_[toAddress(x, y, z)] = 0;\n      }\n}",
        "import_statements": [
            "#include \"plan_env/grid_map.h\"\n"
        ],
        "reference_api": [
            "toAddress",
            "max_id",
            "min_id"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "toAddress",
            "max_id",
            "min_id"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)",
        "start_line": "542",
        "end_line": "566",
        "file_path": "Modules/ego_planner_swarm/plan_env/src/grid_map.cpp",
        "docstring": "This function, GridMap::closetPointInMap, computes the closest point within the map boundaries relative to a given point and a camera position.\\nIt calculates the difference vector between the point and the camera position, then determines the maximum and minimum translation coefficients along each axis.\\nIt iterates through each axis to find the minimum positive scaling factor that keeps the point within map boundaries, and returns the adjusted point near the boundary.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "83b0066d4e0c",
        "ground_truth": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\n{\n  Eigen::Vector3d diff = pt - camera_pt;\n  Eigen::Vector3d max_tc = mp_.map_max_boundary_ - camera_pt;\n  Eigen::Vector3d min_tc = mp_.map_min_boundary_ - camera_pt;\n   double min_t = 1000000;\n   for (int i = 0; i < 3; ++i)\n  {\n    if (fabs(diff[i]) > 0)\n    {\n       double t1 = max_tc[i] / diff[i];\n      if (t1 > 0 && t1 < min_t)\n        min_t = t1;\n       double t2 = min_tc[i] / diff[i];\n      if (t2 > 0 && t2 < min_t)\n        min_t = t2;\n    }\n  }\n   return camera_pt + (min_t - 1e-3) * diff;\n}",
        "import_statements": [
            "#include \"plan_env/grid_map.h\"\n"
        ],
        "reference_api": [
            "fabs"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)",
        "start_line": "709",
        "end_line": "755",
        "file_path": "Modules/ego_planner_swarm/plan_env/src/grid_map.cpp",
        "docstring": "This function, GridMap::updateOccupancyCallback, updates the occupancy grid based on the latest sensor data.\\nIt first updates the last occupancy update time.\\nIf an update is needed, it projects the depth image into points and processes them with raycasting.\\nIf the local map has been updated, it clears and inflates the local map.\\nIt also handles timeout errors for odometry or depth data and sets relevant flags.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9d60c28d75a3",
        "ground_truth": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\n{\n  // if (md_.last_occ_update_time_.toSec() < 1.0 ) md_.last_occ_update_time_ = ros::Time::now();\n  md_.last_occ_update_time_ = ros::Time::now();\n     if (!md_.occ_need_update_)\n  {\n    if ( md_.flag_use_depth_fusion && (ros::Time::now() - md_.last_occ_update_time_).toSec() > mp_.odom_depth_timeout_ )\n    {\n      ROS_ERROR(\"odom or depth lost! ros::Time::now()=%f, md_.last_occ_update_time_=%f, mp_.odom_depth_timeout_=%f\", \n        ros::Time::now().toSec(), md_.last_occ_update_time_.toSec(), mp_.odom_depth_timeout_);\n      md_.flag_depth_odom_timeout_ = true;\n    }\n    return;\n  }\n   // std::cout << \"updateOccupancyCallback 1!\" << std::endl;\n  md_.last_occ_update_time_ = ros::Time::now();\n   /* update occupancy */\n  // ros::Time t1, t2, t3, t4;\n  // t1 = ros::Time::now();\n   // \u5c06\u6df1\u5ea6\u8f6c\u6362\u4e3a\u6295\u5f71\u70b9\n  projectDepthImage();\n  // t2 = ros::Time::now();\n  raycastProcess();\n  // t3 = ros::Time::now();\n   if (md_.local_updated_)\n    clearAndInflateLocalMap();\n   // t4 = ros::Time::now();\n   // cout << setprecision(7);\n  // cout << \"t2=\" << (t2-t1).toSec() << \" t3=\" << (t3-t2).toSec() << \" t4=\" << (t4-t3).toSec() << endl;;\n   // md_.fuse_time_ += (t2 - t1).toSec();\n  // md_.max_fuse_time_ = max(md_.max_fuse_time_, (t2 - t1).toSec());\n   // if (mp_.show_occ_time_)\n  //   ROS_WARN(\"Fusion: cur t = %lf, avg t = %lf, max t = %lf\", (t2 - t1).toSec(),\n  //            md_.fuse_time_ / md_.update_num_, md_.max_fuse_time_);\n   md_.occ_need_update_ = false;\n  md_.local_updated_ = false;\n}",
        "import_statements": [
            "#include \"plan_env/grid_map.h\"\n"
        ],
        "reference_api": [
            "ros::Time::now().toSec",
            "md_.last_occ_update_time_.toSec",
            "(ros::Time::now() - md_.last_occ_update_time_).toSec",
            "clearAndInflateLocalMap",
            "ROS_ERROR",
            "projectDepthImage",
            "ros::Time::now",
            "raycastProcess"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ros::Time::now().toSec",
            "md_.last_occ_update_time_.toSec",
            "(ros::Time::now() - md_.last_occ_update_time_).toSec",
            "clearAndInflateLocalMap",
            "ROS_ERROR",
            "projectDepthImage",
            "ros::Time::now",
            "raycastProcess"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)",
        "start_line": "409",
        "end_line": "426",
        "file_path": "Modules/future_aircraft/src/ellipse_detector/ellipse_detector.cpp",
        "docstring": "This function, _ellipse_evaluate, calculates the average F-measure for ellipse detection across multiple images.\\nIt iterates through the provided image filenames, loading each image along with its corresponding ground truth and detected ellipses.\\nFor each image, it evaluates the detection performance and accumulates the F-measure.\\nFinally, it returns the average F-measure by dividing the accumulated value by the number of images.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "195347f7698b",
        "ground_truth": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\n{\n    float fmeasure(0.f);\n    for (int i = 0; i < image_fns.size(); i++) {\n        Mat3b image = imread(image_fns[i]);\n         vector<Ellipse> ell_gt, ell_dt;\n        _load_ellipse_GT(gt_fns[i], ell_gt, gt_angle_radians);\n        _load_ellipse_DT(dt_fns[i], ell_dt);\n         int tp, fn, fp;\n        fmeasure += _ellipse_evaluate_one(ell_gt, ell_dt, image);\n     }\n     fmeasure /= image_fns.size();\n    return fmeasure;\n}",
        "import_statements": [
            "#include \"ellipse_detector.h\"\n",
            "#include <numeric>\n",
            "#include <time.h>\n"
        ],
        "reference_api": [
            "imread",
            "image_fns.size",
            "_ellipse_evaluate_one",
            "_load_ellipse_GT",
            "_load_ellipse_DT"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "_ellipse_evaluate_one",
                "code": "float _ellipse_evaluate_one(const vector<Ellipse>& ell_gt, const vector<Ellipse>& ell_dt, const Mat3b& img)\n{\n    float threshold_overlap = 0.8f;\n    // float threshold = 0.95f;\n\n    unsigned sz_gt = ell_gt.size();\n    unsigned sz_dt = ell_dt.size();\n\n    unsigned sz_dt_min = unsigned(min(1000, int(sz_dt)));\n\n    vector<Mat1b> mat_gts(sz_gt);\n    vector<Mat1b> mat_dts(sz_dt_min);\n\n    // Draw each ground-Truth ellipse\n    for (unsigned i = 0; i<sz_gt; ++i)\n    {\n        const Ellipse& e = ell_gt[i];\n\n        Mat1b tmp(img.rows, img.cols, uchar(0));\n        ellipse(tmp, Point((int)e.xc_, (int)e.yc_), Size((int)e.a_, (int)e.b_), e.rad_ * 180.0 / CV_PI, 0.0, 360.0, Scalar(255), -1);\n        mat_gts[i] = tmp;\n    }\n\n    // Draw each detected ellipse\n    for (unsigned i = 0; i<sz_dt_min; ++i)\n    {\n        const Ellipse& e = ell_dt[i];\n\n        Mat1b tmp(img.rows, img.cols, uchar(0));\n        ellipse(tmp, Point((int)e.xc_, (int)e.yc_), Size((int)e.a_, (int)e.b_), e.rad_ * 180.0 / CV_PI, 0.0, 360.0, Scalar(255), -1);\n        mat_dts[i] = tmp;\n    }\n\n    Mat1b overlap(sz_gt, sz_dt_min, uchar(0));\n    for (int r = 0; r < overlap.rows; ++r)\n    {\n        for (int c = 0; c < overlap.cols; ++c)\n        {\n            // The proportion of overlapping areas to the true area (If biger than, assign to 255)\n            overlap(r, c) = _ellipse_overlap(mat_gts[r], mat_dts[c], threshold_overlap) ? uchar(255) : uchar(0);\n        }\n    }\n\n    int counter = 0;\n    vector<bool> vec_gt(sz_gt, false);\n    vector<bool> vec_dt(sz_dt_min, false);\n\n    // Each row in the matrix has one means the ellipse be found\n    for (unsigned int i = 0; i < sz_dt_min; ++i)\n    {\n        for (unsigned int j = 0; j < sz_gt; ++j)\n        {\n            bool b_found = overlap(j, i) != 0;\n            if (b_found)\n            {\n                vec_gt[j] = true;\n                vec_dt[i] = true;\n            }\n        }\n    }\n\n    float tp = _bool_count(vec_gt);\n    float fn = int(sz_gt) - tp;\n    float fp = sz_dt - _bool_count(vec_dt); // !!!! sz_dt - _bool_count(vec_dt); //\n\n    float pr(0.f);\n    float re(0.f);\n    float fmeasure(0.f);\n\n    if (tp == 0) {\n        if (fp == 0) {\n            pr = 1.f;\n            re = 0.f;\n            fmeasure = (2.f * pr * re) / (pr + re);\n        }\n        else {\n            pr = 0.f;\n            re = 0.f;\n            fmeasure = 0.f;\n        }\n    }\n    else {\n        pr = float(tp) / float(tp + fp);\n        re = float(tp) / float(tp + fn);\n        fmeasure = (2.f * pr * re) / (pr + re);\n    }\n\n    return fmeasure;\n}"
            },
            {
                "name": "_load_ellipse_GT",
                "code": "void _load_ellipse_GT(const string& gt_file_name, vector<Ellipse>& gt_ellipses, bool is_angle_radians)\n{\n    ifstream in(gt_file_name);\n    if (!in.good())\n    {\n        cout << \"Error opening: \" << gt_file_name << endl;\n        return;\n    }\n\n    unsigned n;\n    in >> n;\n\n    gt_ellipses.clear();\n    gt_ellipses.reserve(n);\n\n    while (in.good() && n--)\n    {\n        Ellipse e;\n        in >> e.xc_ >> e.yc_ >> e.a_ >> e.b_ >> e.rad_;\n\n        if (!is_angle_radians)\n        {\n            // convert to radians\n            e.rad_ = float(e.rad_ * CV_PI / 180.0);\n        }\n\n        if (e.a_ < e.b_)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        gt_ellipses.push_back(e);\n    }\n    in.close();\n}"
            },
            {
                "name": "_load_ellipse_DT",
                "code": "void _load_ellipse_DT(const string& dt_file_name, vector<Ellipse>& dt_ellipses, bool is_angle_radians)\n{\n    ifstream in(dt_file_name);\n    if (!in.good())\n    {\n        cout << \"Error opening: \" << dt_file_name << endl;\n        return;\n    }\n\n    unsigned n;\n    in >> n;\n\n    dt_ellipses.clear();\n    dt_ellipses.reserve(n);\n\n    while (in.good() && n--)\n    {\n        Ellipse e;\n        in >> e.xc_ >> e.yc_ >> e.a_ >> e.b_ >> e.rad_ >> e.score_;\n\n        if (!is_angle_radians)\n        {\n            // convert to radians\n            e.rad_ = float(e.rad_ * CV_PI / 180.0);\n        }\n\n        if (e.a_ < e.b_)\n        {\n            float temp = e.a_;\n            e.a_ = e.b_;\n            e.b_ = temp;\n\n            e.rad_ = e.rad_ + float(0.5*CV_PI);\n        }\n\n        e.rad_ = fmod(float(e.rad_ + 2.f*CV_PI), float(CV_PI));\n        e.score_ = 1.f;\n        dt_ellipses.push_back(e);\n    }\n    in.close();\n}"
            }
        ],
        "third_party": [
            "imread",
            "image_fns.size"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "float _ellipse_normal_angle(float x, float y, float *foci)",
        "start_line": "560",
        "end_line": "574",
        "file_path": "Modules/future_aircraft/src/ellipse_detector/ellipse_detector.cpp",
        "docstring": "This function, _ellipse_normal_angle, calculates the normal angle at a point (x, y) on an ellipse defined by its foci.\\nIt checks if the foci parameter is non-null and then computes the angles from the point to each focus.\\nThe signed difference between these angles is used to calculate the normal angle, which is adjusted to lie within the range [-\u03c0, \u03c0] before returning.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "33d20170f6d2",
        "ground_truth": "float _ellipse_normal_angle(float x, float y, float *foci)\n{\n    float tmp1, tmp2, tmp3, theta;\n    /* check parameters */\n    if (foci == NULL) fprintf(stderr, \"ellipse_normal_angle: 'foci' must be non null\");\n     tmp1 = atan2(y - foci[1], x - foci[0]);\n    tmp2 = atan2(y - foci[3], x - foci[2]);\n    tmp3 = angle_diff_signed(tmp1, tmp2);\n     theta = tmp1 - tmp3 / 2.0;\n    while (theta <= -M_PI) theta += M_2__PI;\n    while (theta >   M_PI) theta -= M_2__PI;\n    return theta;\n}",
        "import_statements": [
            "#include \"ellipse_detector.h\"\n",
            "#include <numeric>\n",
            "#include <time.h>\n"
        ],
        "reference_api": [
            "angle_diff_signed",
            "fprintf",
            "atan2"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "angle_diff_signed",
                "code": "float angle_diff_signed(float a, float b)\n{\n    a -= b;\n    while (a <= -M_PI) a += M_2__PI;\n    while (a >   M_PI) a -= M_2__PI;\n    return a;\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "bool inline concave_check(VP& vp1, int start, int end)",
        "start_line": "3710",
        "end_line": "3732",
        "file_path": "Modules/future_aircraft/src/ellipse_detector/ellipse_detector.cpp",
        "docstring": "This function, concave_check, determines if a section of a polygon is concave between the specified start and end indices.\\nIt calculates the minimum and maximum x and y coordinates of the points in the section.\\nIt then computes the integral above and below the polygon section.\\nIf the integral above is less than the integral below, the function returns false, indicating the section is convex; otherwise, it returns true, indicating the section is concave.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2c1daf41f894",
        "ground_truth": "bool inline concave_check(VP& vp1, int start, int end)\n{\n    int x_min(4096), x_max(0), y_min(4096), y_max(0);\n    int integral_u(0), integral_d(0);\n    for (int i = start; i <= end; i++)\n    {\n        Point& val = vp1[i];\n        x_min = MIN(x_min, val.x);\n        x_max = MAX(x_max, val.x);\n        y_min = MIN(y_min, val.y);\n        y_max = MAX(y_max, val.y);\n    }\n    for (int i = start; i <= end; i++)\n    {\n        Point& val = vp1[i];\n        integral_u += (val.y - y_min);\n        integral_d += (y_max - val.y);\n    }\n    if (integral_u < integral_d)\n        return false;\n    else\n        return true;\n}",
        "import_statements": [
            "#include \"ellipse_detector.h\"\n",
            "#include <numeric>\n",
            "#include <time.h>\n"
        ],
        "reference_api": [
            "MIN",
            "MAX"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "MIN",
            "MAX"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)",
        "start_line": "61",
        "end_line": "90",
        "file_path": "Modules/future_aircraft/src/future_aircraft.cpp",
        "docstring": "This function, ellipse_det_cb, processes detection information from a MultiDetectionInfo message.\\nIt iterates through each detection info and updates the ellipse_det variable.\\nIf an object named \"T\" is detected, it increments the num_regain counter and resets num_lost.\\nOtherwise, it resets num_regain and increments num_lost.\\nIf num_lost exceeds VISION_THRES, it sets is_detected to false.\\nIf num_regain exceeds VISION_THRES, it sets is_detected to true.\\nIt also swaps the sight_angle values of ellipse_det.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7e8e0befa54d",
        "ground_truth": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\n{\n    // g_ellipse_det. = false;\n    for(auto &ellipes : msg->detection_infos)\n    {\n        ellipse_det = ellipes;\n        if (ellipse_det.detected && ellipse_det.object_name == \"T\")\n        {\n            num_regain++;\n            num_lost = 0;\n        }\n        else{\n            num_regain = 0;\n            num_lost++;\n        }\n        if(num_lost > VISION_THRES)\n        {\n            is_detected = false;\n            // PCOUT(1, GREEN, \"no detect\");\n        }\n        if(num_regain > VISION_THRES){\n            is_detected = true;\n            // PCOUT(1, GREEN, \"detected\");\n        }\n        ellipse_det.sight_angle[0] = ellipes.sight_angle[1];\n        ellipse_det.sight_angle[1] = ellipes.sight_angle[0];\n        // ellipse_det.position[2] = -ellipes.position[2];\n    }\n     }",
        "import_statements": [
            "#include <ros/ros.h>\n",
            "#include <prometheus_msgs/UAVCommand.h>\n",
            "#include <prometheus_msgs/UAVState.h>\n",
            "#include <prometheus_msgs/UAVControlState.h>\n",
            "#include <prometheus_msgs/DetectionInfo.h>\n",
            "#include <prometheus_msgs/MultiDetectionInfo.h>\n",
            "#include <sstream>\n",
            "#include <unistd.h>\n",
            "#include <math.h>\n",
            "#include <Eigen/Eigen>\n",
            "#include \"printf_utils.h\"\n",
            "#include \"mission_utils.h\"\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)",
        "start_line": "360",
        "end_line": "365",
        "file_path": "Modules/global_planner_ugv/src/A_star.cpp",
        "docstring": "This function, Astar::check_safety, checks the safety of a given position.\\nIt takes the current position and a safety distance as inputs and returns a boolean value indicating whether the position is safe based on the check performed by the Occupy_map_ptr.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f16741953a68",
        "ground_truth": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\n{\n  bool is_safety;\n  is_safety = Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n  return is_safety;\n}",
        "import_statements": [
            "#include \"A_star.h\"\n"
        ],
        "reference_api": [
            "Occupy_map_ptr->check_safety"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Occupy_map_ptr->check_safety"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void Astar::retrievePath(NodePtr end_node)",
        "start_line": "237",
        "end_line": "253",
        "file_path": "Modules/global_planner_ugv/src/A_star.cpp",
        "docstring": "This function, Astar::retrievePath, constructs the path from the end node to the start node in an A* search algorithm.\\nStarting from the end node, it follows the parent pointers to trace the path back to the start node, storing each node in path_nodes_.\\nAfter reaching the start node, it reverses the order of path_nodes_ to present the path from start to end.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "34633c5633a4",
        "ground_truth": "void Astar::retrievePath(NodePtr end_node)\n{\n  NodePtr cur_node = end_node;\n  path_nodes_.push_back(cur_node);\n   while (cur_node->parent != NULL)\n  {\n    cur_node = cur_node->parent;\n    path_nodes_.push_back(cur_node);\n  }\n   // \u53cd\u8f6c\u987a\u5e8f\n  reverse(path_nodes_.begin(), path_nodes_.end());\n    // \u76f4\u63a5\u5728\u8fd9\u91cc\u751f\u6210\u8def\u5f84\uff1f\n}",
        "import_statements": [
            "#include \"A_star.h\"\n"
        ],
        "reference_api": [
            "reverse",
            "path_nodes_.push_back",
            "path_nodes_.end",
            "path_nodes_.begin"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "reverse",
            "path_nodes_.push_back",
            "path_nodes_.end",
            "path_nodes_.begin"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) ",
        "start_line": "126",
        "end_line": "149",
        "file_path": "Modules/global_planner_ugv/src/global_planner_ugv.cpp",
        "docstring": "This function, GlobalPlannerUGV::nei_odom_cb, updates the state of a neighboring UGV based on its odometry data.\\nIt assigns the UGV's position and height to the state_nei array.\\nIn simulation mode, it checks the distance from the start position and sets the get_nei_state flag to false if the distance exceeds 5 meters.\\nOtherwise, it sets the get_nei_state flag to true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4a6cd1a5a77a",
        "ground_truth": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \n{\n    //odom_nei[id] << odom->pose.pose.position.x, odom->pose.pose.position.y, ugv_height; \n    state_nei[id][0] = all_ugv_states_[id - 1].position[0];\n    state_nei[id][1] = all_ugv_states_[id - 1].position[1];\n    state_nei[id][0] = ugv_height;\n      // \u8ddd\u79bb\u5927\u4e8e\u6700\u5927\u8ddd\u79bb\u7684\u5176\u4ed6\u65e0\u4eba\u8f66\u4e0d\u8003\u8651\n    if(sim_mode)\n    {\n        if((start_pos-state_nei[id]).norm() > 5.0 /*\u7c73*/ )\n        {\n            get_nei_state[id] = false;\n        }else\n        {\n            get_nei_state[id] = true;\n        }\n    }\n    else\n    {\n        get_nei_state[id] = true;\n    }\n}",
        "import_statements": [
            "#include \"global_planner_ugv.h\"\n"
        ],
        "reference_api": [
            "(start_pos-state_nei[id]).norm"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "(start_pos-state_nei[id]).norm"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)",
        "start_line": "231",
        "end_line": "247",
        "file_path": "Modules/global_planner_ugv/src/global_planner_ugv.cpp",
        "docstring": "This function, GlobalPlannerUGV::Gpointcloud_cb, processes incoming point cloud data for the UGV.\\nIf odometry is not ready, it returns immediately.\\nOnce odometry is ready, it sets the sensor_ready flag to true and increments an update counter.\\nEvery fifth update, it updates the Astar map with the new point cloud data and resets the update counter.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e7507a698cf6",
        "ground_truth": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\n{\n    if (!odom_ready) \n    {\n        return;\n    }\n    sensor_ready = true;\n    static int update_num=0;\n    update_num++;\n    // \u6b64\u5904\u6539\u4e3a\u6839\u636e\u5faa\u73af\u65f6\u95f4\u8ba1\u7b97\u7684\u6570\u503c\n    if(update_num == 5)\n    {\n        // \u5bf9Astar\u4e2d\u7684\u5730\u56fe\u8fdb\u884c\u66f4\u65b0\n        Astar_ptr->Occupy_map_ptr->map_update_gpcl(msg);\n        update_num = 0;\n    }\n}",
        "import_statements": [
            "#include \"global_planner_ugv.h\"\n"
        ],
        "reference_api": [
            "Astar_ptr->Occupy_map_ptr->map_update_gpcl"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Astar_ptr->Occupy_map_ptr->map_update_gpcl"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)",
        "start_line": "167",
        "end_line": "180",
        "file_path": "Modules/global_planner_ugv/src/occupy_map.cpp",
        "docstring": "This function, Occupy_map::map_update_gpcl, updates the global map with point cloud data from a sensor message.\\nIt ensures the global map is updated only once by checking the get_gpcl flag.\\nIf the global map has not been updated yet, it sets the flag, converts the sensor message to a point cloud, stores it, and then inflates the point cloud.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8606e2b94164",
        "ground_truth": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\n{\n    // \u5168\u5c40\u5730\u56fe\u53ea\u66f4\u65b0\u4e00\u6b21\n    if(get_gpcl)\n    {\n        return;\n    }\n     get_gpcl = true;\n    has_global_point = true;\n    pcl::fromROSMsg(*global_point,*input_point_cloud);\n    global_point_cloud_map = input_point_cloud;\n    inflate_point_cloud(); \n}",
        "import_statements": [
            "#include <occupy_map.h>\n"
        ],
        "reference_api": [
            "pcl::fromROSMsg",
            "inflate_point_cloud"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "pcl::fromROSMsg",
            "inflate_point_cloud"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)",
        "start_line": "225",
        "end_line": "240",
        "file_path": "Modules/global_planner_ugv/src/occupy_map.cpp",
        "docstring": "This function, Occupy_map::map_update_laser, updates the occupancy map using laser scan data and odometry information.\\nIt projects the laser scan into a PointCloud2 format and converts it to a pcl::PointCloud.\\nIf not in simulation mode, it merges the local map with the provided odometry data.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fbce91db4aed",
        "ground_truth": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\n{\n    // \u53c2\u8003\u7f51\u9875:http://wiki.ros.org/laser_geometry\n    // sensor_msgs::LaserScan \u8f6c\u4e3a sensor_msgs::PointCloud2 \u683c\u5f0f\n    projector_.projectLaser(*local_point, input_laser_scan);\n    // \u518d\u7531sensor_msgs::PointCloud2 \u8f6c\u4e3a pcl::PointCloud<pcl::PointXYZ>\n    pcl::fromROSMsg(input_laser_scan,*input_point_cloud);\n     if(sim_mode)\n    {\n        // to do\n    }else\n    {\n        local_map_merge_odom(odom);\n    }\n}",
        "import_statements": [
            "#include <occupy_map.h>\n"
        ],
        "reference_api": [
            "local_map_merge_odom",
            "projector_.projectLaser",
            "pcl::fromROSMsg"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "local_map_merge_odom",
            "projector_.projectLaser",
            "pcl::fromROSMsg"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)",
        "start_line": "482",
        "end_line": "497",
        "file_path": "Modules/global_planner_ugv/src/occupy_map.cpp",
        "docstring": "This function, Occupy_map::pub_pcl_cb, publishes point cloud data at regular intervals.\\nIt converts the global point cloud map to a ROS message and publishes it with the frame ID \"world\" to the global_pcl_pub topic.\\nIt also converts and publishes the inflated point cloud to the inflate_pcl_pub topic with the same frame ID.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6cd475e88f70",
        "ground_truth": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\n{\n    // \u53d1\u5e03\u672a\u81a8\u80c0\u70b9\u4e91\n    sensor_msgs::PointCloud2 global_env_;\n    // \u5047\u8bbe\u6b64\u65f6\u6536\u5230\u7684\u5c31\u662f\u5168\u5c40pcl\n    pcl::toROSMsg(*global_point_cloud_map,global_env_);\n    global_env_.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_env_);\n     // \u53d1\u5e03\u81a8\u80c0\u70b9\u4e91\n    sensor_msgs::PointCloud2 map_inflate_vis;\n    pcl::toROSMsg(*cloud_inflate_vis_, map_inflate_vis);\n    map_inflate_vis.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(map_inflate_vis);\n }",
        "import_statements": [
            "#include <occupy_map.h>\n"
        ],
        "reference_api": [
            "global_pcl_pub.publish",
            "pcl::toROSMsg",
            "inflate_pcl_pub.publish"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "global_pcl_pub.publish",
            "pcl::toROSMsg",
            "inflate_pcl_pub.publish"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "amov-lab/Prometheus",
        "function_declaration": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)",
        "start_line": "345",
        "end_line": "354",
        "file_path": "Modules/motion_planning/global_planner/src/global_planner.cpp",
        "docstring": "This function, GlobalPlanner::Lpointcloud_cb, processes incoming point cloud messages.\\nIf odometry is ready, it sets the sensor_ready flag to true.\\nIt then updates the A* algorithm's map using the new point cloud data and current UAV odometry.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "09046bbcadb4",
        "ground_truth": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\n{\n    if (!odom_ready)\n    {\n        return;\n    }\n    sensor_ready = true;\n    // \u5bf9Astar\u4e2d\u7684\u5730\u56fe(\u5c40\u90e8\u70b9\u4e91+odom)\u8fdb\u884c\u66f4\u65b0\n    Astar_ptr->Occupy_map_ptr->map_update_lpcl(msg, uav_odom);\n}",
        "import_statements": [
            "#include \"global_planner.h\"\n"
        ],
        "reference_api": [
            "Astar_ptr->Occupy_map_ptr->map_update_lpcl"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Astar_ptr->Occupy_map_ptr->map_update_lpcl"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "chvmp/champ",
        "function_declaration": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)",
        "start_line": "92",
        "end_line": "104",
        "file_path": "champ_base/src/quadruped_controller.cpp",
        "docstring": "This function, QuadrupedController::controlLoop_, executes a control loop for a quadruped robot.\\nIt calculates target foot positions based on the desired pose using the body controller.\\nThen, it computes velocity commands for the legs and performs inverse kinematics to determine target joint positions.\\nFinally, it publishes foot contact information and joint positions.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2202d147daad",
        "ground_truth": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\n{\n    float target_joint_positions[12];\n    geometry::Transformation target_foot_positions[4];\n    bool foot_contacts[4];\n     body_controller_.poseCommand(target_foot_positions, req_pose_);\n    leg_controller_.velocityCommand(target_foot_positions, req_vel_, rosTimeToChampTime(ros::Time::now()));\n    kinematics_.inverse(target_joint_positions, target_foot_positions);\n         publishFootContacts_(foot_contacts);\n    publishJoints_(target_joint_positions);\n}",
        "import_statements": [
            "#include <quadruped_controller.h>\n"
        ],
        "reference_api": [
            "leg_controller_.velocityCommand",
            "rosTimeToChampTime",
            "publishJoints_",
            "publishFootContacts_",
            "body_controller_.poseCommand",
            "ros::Time::now",
            "kinematics_.inverse"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "rosTimeToChampTime",
                "code": "champ::PhaseGenerator::Time rosTimeToChampTime(const ros::Time& time)\n{\n  return time.toNSec() / 1000ul;\n}"
            },
            {
                "name": "publishJoints_",
                "code": "void QuadrupedController::publishJoints_(float target_joints[12])\n{\n    if(publish_joint_control_)\n    {\n        trajectory_msgs::JointTrajectory joints_cmd_msg;\n        joints_cmd_msg.header.stamp = ros::Time::now();\n        joints_cmd_msg.joint_names = joint_names_;\n\n        trajectory_msgs::JointTrajectoryPoint point;\n        point.positions.resize(12);\n\n        point.time_from_start = ros::Duration(1.0 / 60.0);\n        for(size_t i = 0; i < 12; i++)\n        {\n            point.positions[i] = target_joints[i];\n        }\n\n        joints_cmd_msg.points.push_back(point);\n        joint_commands_publisher_.publish(joints_cmd_msg);\n    }\n\n    if(publish_joint_states_ && !in_gazebo_)\n    {\n        sensor_msgs::JointState joints_msg;\n\n        joints_msg.header.stamp = ros::Time::now();\n        joints_msg.name.resize(joint_names_.size());\n        joints_msg.position.resize(joint_names_.size());\n        joints_msg.name = joint_names_;\n\n        for (size_t i = 0; i < joint_names_.size(); ++i)\n        {    \n            joints_msg.position[i]= target_joints[i];\n        }\n\n        joint_states_publisher_.publish(joints_msg);\n    }\n}"
            },
            {
                "name": "publishFootContacts_",
                "code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\n{\n    if(publish_foot_contacts_ && !in_gazebo_)\n    {\n        champ_msgs::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n        contacts_msg.contacts.resize(4);\n\n        for(size_t i = 0; i < 4; i++)\n        {\n            //This is only published when there's no feedback on the robot\n            //that a leg is in contact with the ground\n            //For such cases, we use the stance phase in the gait for foot contacts\n            contacts_msg.contacts[i] = base_.legs[i]->gait_phase();\n        }\n\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}"
            }
        ],
        "third_party": [
            "leg_controller_.velocityCommand",
            "body_controller_.poseCommand",
            "ros::Time::now",
            "kinematics_.inverse"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "chvmp/champ",
        "function_declaration": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])",
        "start_line": "172",
        "end_line": "190",
        "file_path": "champ_base/src/quadruped_controller.cpp",
        "docstring": "This function, QuadrupedController::publishFootContacts_, publishes the foot contact states of a quadruped robot.\\nIf foot contact publishing is enabled and the robot is not in Gazebo, it creates a ContactsStamped message.\\nThe message is populated with the current gait phase of each leg and then published using foot_contacts_publisher_.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1445b899d973",
        "ground_truth": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\n{\n    if(publish_foot_contacts_ && !in_gazebo_)\n    {\n        champ_msgs::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n        contacts_msg.contacts.resize(4);\n         for(size_t i = 0; i < 4; i++)\n        {\n            //This is only published when there's no feedback on the robot\n            //that a leg is in contact with the ground\n            //For such cases, we use the stance phase in the gait for foot contacts\n            contacts_msg.contacts[i] = base_.legs[i]->gait_phase();\n        }\n         foot_contacts_publisher_.publish(contacts_msg);\n    }\n}",
        "import_statements": [
            "#include <quadruped_controller.h>\n"
        ],
        "reference_api": [
            "base_.legs[i]->gait_phase",
            "contacts_msg.contacts.resize",
            "foot_contacts_publisher_.publish",
            "ros::Time::now"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "base_.legs[i]->gait_phase",
            "contacts_msg.contacts.resize",
            "foot_contacts_publisher_.publish",
            "ros::Time::now"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "chvmp/champ",
        "function_declaration": "def joints_cmd_callback(self, joints)",
        "start_line": "54",
        "end_line": "69",
        "file_path": "champ_bringup/scripts/joint_calibrator_relay.py",
        "docstring": "This function, joints_cmd_callback, processes incoming joint commands.\\nIt creates a minimal joints message with the first 12 joint positions and publishes it.\\nIt then constructs a joint trajectory message with the same positions and a specified duration.\\nThe trajectory message is published to the joint trajectory topic.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7bcb5cb4a4e6",
        "ground_truth": "def joints_cmd_callback(self, joints):\n    joint_minimal_msg = Joints()\n    for i in range(12):\n        joint_minimal_msg.position.append(joints.position[i])\n    self.joint_minimal_pub.publish(joint_minimal_msg)\n    joint_trajectory_msg = JointTrajectory()\n    joint_trajectory_msg.joint_names = self.joint_names\n    point = JointTrajectoryPoint()\n    point.time_from_start = rospy.Duration(1.0 / 60.0)\n    point.positions = joint_minimal_msg.position    \n    joint_trajectory_msg.points.append(point)\n    self.joint_trajectory_pub.publish(joint_trajectory_msg)",
        "import_statements": [
            "import rospy",
            "from champ_msgs.msg import Joints",
            "from sensor_msgs.msg import JointState",
            "from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint",
            "import rosparam",
            "import os, sys"
        ],
        "reference_api": [
            "Joints()",
            "publish"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "chvmp/champ",
        "function_declaration": "void gazeboCallback_(ConstContactsPtr &_msg)",
        "start_line": "54",
        "end_line": "76",
        "file_path": "champ_gazebo/src/contact_sensor.cpp",
        "docstring": "This function, gazeboCallback_, processes contact messages from Gazebo.\\nIt initializes foot contact states to false.\\nFor each contact in the message, it splits the collision string to identify the contact link.\\nIf a contact matches one of the foot links, it sets the corresponding foot contact state to true.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "955237744a73",
        "ground_truth": "void gazeboCallback_(ConstContactsPtr &_msg)\n{\n for(size_t i = 0; i < 4; i++)\n {\n  foot_contacts_[i] = false;\n }\n for (int i = 0; i < _msg->contact_size(); ++i) \n {\n  std::vector<std::string> results;\n  std::string collision = _msg->contact(i).collision1();\n  boost::split(results, collision, [](char c){return c == ':';});\n  for(size_t j = 0; j < 4; j++)\n  {\n   if(foot_links_[j] == results[2])\n   {\n    foot_contacts_[j] = true;\n    break;\n   }\n  }\n }\n}",
        "import_statements": [
            "#include \"ros/ros.h\"\n",
            "#include <iostream>\n",
            "#include <champ/utils/urdf_loader.h>\n",
            "#include <gazebo/transport/transport.hh>\n",
            "#include <gazebo/msgs/msgs.hh>\n",
            "#include <gazebo/gazebo_client.hh>\n",
            "#include <boost/algorithm/string.hpp>\n",
            "#include <champ_msgs/ContactsStamped.h>\n"
        ],
        "reference_api": [
            "boost::split",
            "_msg->contact",
            "_msg->contact(i).collision1",
            "_msg->contact_size"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "boost::split",
            "_msg->contact",
            "_msg->contact(i).collision1",
            "_msg->contact_size"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const",
        "start_line": "55",
        "end_line": "82",
        "file_path": "rotors_control/src/library/lee_position_controller.cpp",
        "docstring": "This function, LeePositionController::CalculateRotorVelocities, computes the rotor velocities for a vehicle.\\nIt first ensures the input and parameters are valid.\\nIf the controller is not active, it sets all rotor velocities to zero.\\nOtherwise, it calculates the desired acceleration and angular acceleration.\\nIt then projects thrust onto the body z-axis and combines angular acceleration and thrust into a single vector.\\nThe rotor velocities are computed by multiplying with a predefined matrix, ensuring non-negative values, and taking the square root of each component.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9ff80dc14572",
        "ground_truth": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const {\n  assert(rotor_velocities);\n  assert(initialized_params_);\n   rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  // Return 0 velocities on all rotors, until the first command is received.\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n   Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n   Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n   // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n   Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n   *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}",
        "import_statements": [
            "#include \"rotors_control/lee_position_controller.h\"\n"
        ],
        "reference_api": [
            "angular_acceleration_thrust.block<3, 1>",
            "Eigen::VectorXd::Zero",
            "acceleration.dot",
            "ComputeDesiredAngularAcc",
            "odometry_.orientation.toRotationMatrix().col",
            "rotor_velocities->rows",
            "rotor_velocities->resize",
            "ComputeDesiredAcceleration",
            "rotor_velocities->cwiseSqrt",
            "rotor_velocities->cwiseMax",
            "vehicle_parameters_.rotor_configuration_.rotors.size",
            "angular_acceleration_thrust",
            "assert",
            "odometry_.orientation.toRotationMatrix"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ComputeDesiredAngularAcc",
                "code": "void LeePositionController::ComputeDesiredAngularAcc(const Eigen::Vector3d& acceleration,\n                                                     Eigen::Vector3d* angular_acceleration) const {\n  assert(angular_acceleration);\n\n  Eigen::Matrix3d R = odometry_.orientation.toRotationMatrix();\n\n  // Get the desired rotation matrix.\n  Eigen::Vector3d b1_des;\n  double yaw = command_trajectory_.getYaw();\n  b1_des << cos(yaw), sin(yaw), 0;\n\n  Eigen::Vector3d b3_des;\n  b3_des = -acceleration / acceleration.norm();\n\n  Eigen::Vector3d b2_des;\n  b2_des = b3_des.cross(b1_des);\n  b2_des.normalize();\n\n  Eigen::Matrix3d R_des;\n  R_des.col(0) = b2_des.cross(b3_des);\n  R_des.col(1) = b2_des;\n  R_des.col(2) = b3_des;\n\n  // Angle error according to lee et al.\n  Eigen::Matrix3d angle_error_matrix = 0.5 * (R_des.transpose() * R - R.transpose() * R_des);\n  Eigen::Vector3d angle_error;\n  vectorFromSkewMatrix(angle_error_matrix, &angle_error);\n\n  // TODO(burrimi) include angular rate references at some point.\n  Eigen::Vector3d angular_rate_des(Eigen::Vector3d::Zero());\n  angular_rate_des[2] = command_trajectory_.getYawRate();\n\n  Eigen::Vector3d angular_rate_error = odometry_.angular_velocity - R_des.transpose() * R * angular_rate_des;\n\n  *angular_acceleration = -1 * angle_error.cwiseProduct(normalized_attitude_gain_)\n                           - angular_rate_error.cwiseProduct(normalized_angular_rate_gain_)\n                           + odometry_.angular_velocity.cross(odometry_.angular_velocity); // we don't need the inertia matrix here\n}"
            },
            {
                "name": "ComputeDesiredAcceleration",
                "code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const {\n  assert(acceleration);\n\n  Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n\n  // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n\n  Eigen::Vector3d e_3(Eigen::Vector3d::UnitZ());\n\n  *acceleration = (position_error.cwiseProduct(controller_parameters_.position_gain_)\n      + velocity_error.cwiseProduct(controller_parameters_.velocity_gain_)) / vehicle_parameters_.mass_\n      - vehicle_parameters_.gravity_ * e_3 - command_trajectory_.acceleration_W;\n}"
            }
        ],
        "third_party": [
            "angular_acceleration_thrust.block<3, 1>",
            "Eigen::VectorXd::Zero",
            "acceleration.dot",
            "odometry_.orientation.toRotationMatrix().col",
            "rotor_velocities->rows",
            "rotor_velocities->resize",
            "rotor_velocities->cwiseSqrt",
            "rotor_velocities->cwiseMax",
            "vehicle_parameters_.rotor_configuration_.rotors.size",
            "angular_acceleration_thrust",
            "assert",
            "odometry_.orientation.toRotationMatrix"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const",
        "start_line": "94",
        "end_line": "111",
        "file_path": "rotors_control/src/library/lee_position_controller.cpp",
        "docstring": "This function, LeePositionController::ComputeDesiredAcceleration, calculates the desired acceleration for the vehicle.\\nIt computes the position and velocity errors by comparing the current odometry data with the command trajectory.\\nThe function transforms the vehicle's velocity to the world frame and computes the velocity error.\\nUsing these errors, it calculates the desired acceleration by incorporating position and velocity gains, adjusting for vehicle mass, gravity, and the commanded acceleration.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4f7b2beea6a5",
        "ground_truth": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const {\n  assert(acceleration);\n   Eigen::Vector3d position_error;\n  position_error = odometry_.position - command_trajectory_.position_W;\n   // Transform velocity to world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W =  R_W_I * odometry_.velocity;\n  Eigen::Vector3d velocity_error;\n  velocity_error = velocity_W - command_trajectory_.velocity_W;\n   Eigen::Vector3d e_3(Eigen::Vector3d::UnitZ());\n   *acceleration = (position_error.cwiseProduct(controller_parameters_.position_gain_)\n      + velocity_error.cwiseProduct(controller_parameters_.velocity_gain_)) / vehicle_parameters_.mass_\n      - vehicle_parameters_.gravity_ * e_3 - command_trajectory_.acceleration_W;\n}",
        "import_statements": [
            "#include \"rotors_control/lee_position_controller.h\"\n"
        ],
        "reference_api": [
            "assert",
            "velocity_error.cwiseProduct",
            "position_error.cwiseProduct",
            "odometry_.orientation.toRotationMatrix"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "assert",
            "velocity_error.cwiseProduct",
            "position_error.cwiseProduct",
            "odometry_.orientation.toRotationMatrix"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const",
        "start_line": "86",
        "end_line": "102",
        "file_path": "rotors_control/src/attitude_controller_samy.cpp",
        "docstring": "This function, AttitudeControllerSamy::CalculateRotorVelocities, computes the rotor velocities for a vehicle.\\nIt ensures the input and parameters are valid, then resizes the rotor velocities vector to match the number of rotors.\\nIt calculates the desired angular acceleration and combines it with the thrust reference into a single vector.\\nThe rotor velocities are computed by multiplying with a predefined matrix, ensuring they are at least one, and taking the square root of each component.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e56a7d85a6c8",
        "ground_truth": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const {\n  assert(rotor_velocities);\n  assert(initialized_params_);\n   rotor_velocities->resize(amount_rotors_);\n   Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(&angular_acceleration);\n   Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = control_attitude_thrust_reference_(3);\n   *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Ones(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}",
        "import_statements": [
            "#include \"rotors_control/attitude_controller_samy.h\"\n",
            "#include <iostream>\n"
        ],
        "reference_api": [
            "angular_acceleration_thrust.block<3, 1>",
            "ComputeDesiredAngularAcc",
            "rotor_velocities->cwiseSqrt",
            "rotor_velocities->rows",
            "rotor_velocities->resize",
            "rotor_velocities->cwiseMax",
            "angular_acceleration_thrust",
            "control_attitude_thrust_reference_",
            "assert",
            "Eigen::VectorXd::Ones"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "ComputeDesiredAngularAcc",
                "code": "void AttitudeControllerSamy::ComputeDesiredAngularAcc(Eigen::Vector3d* angular_acceleration) const {\n  assert(angular_acceleration);\n\n  Eigen::Matrix3d R = attitude_.toRotationMatrix();\n\n  // get desired rotation matrix\n  Eigen::Matrix3d R_des;\n  double yaw = atan2(R(1, 0), R(0, 0));\n  R_des = Eigen::AngleAxisd(yaw, Eigen::Vector3d::UnitZ()) // yaw\n        * Eigen::AngleAxisd(control_attitude_thrust_reference_(0), Eigen::Vector3d::UnitX()) // roll\n        * Eigen::AngleAxisd(control_attitude_thrust_reference_(1), Eigen::Vector3d::UnitY()); // pitch\n\n  Eigen::Vector3d b3_des = R.transpose() * R_des.col(2);\n  Eigen::Vector3d angle_error = b3_des.cross(Eigen::Vector3d::UnitZ());\n\n  Eigen::Vector3d angular_rate_des(Eigen::Vector3d::Zero());\n  angular_rate_des[2] = control_attitude_thrust_reference_(2);\n\n  Eigen::Vector3d angular_rate_error = angular_rate_ - R_des.transpose() * R * angular_rate_des;\n\n  *angular_acceleration = -1 * angle_error.cwiseProduct(gain_attitude_)\n                           - angular_rate_error.cwiseProduct(gain_angular_rate_)\n                           + angular_rate_.cross(angular_rate_); // we don't need the inertia matrix here\n}"
            }
        ],
        "third_party": [
            "angular_acceleration_thrust.block<3, 1>",
            "rotor_velocities->cwiseSqrt",
            "rotor_velocities->rows",
            "rotor_velocities->resize",
            "rotor_velocities->cwiseMax",
            "angular_acceleration_thrust",
            "control_attitude_thrust_reference_",
            "assert",
            "Eigen::VectorXd::Ones"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "def slice(self, start_time, end_time)",
        "start_line": "37",
        "end_line": "45",
        "file_path": "rotors_evaluation/src/rosbag_tools/analyze_bag.py",
        "docstring": "This function, slice, creates a copy of the object and slices its attributes between the specified start_time and end_time.\\nIt finds the corresponding indices for the start and end times, makes a deep copy of the object, and updates each attribute of the copied object to contain only the sliced data.\\nFinally, it returns the copied and sliced object.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cdf0e9e497da",
        "ground_truth": "def slice(self, start_time, end_time):\n    \"\"\"Copy the object and slice it between start_time and end_time.\"\"\"\n    start_index = self.get_next_index(start_time)\n    end_index = self.get_next_index(end_time)\n    copied_obj = copy.deepcopy(self)\n    for key in self.__dict__:\n        copied_obj.__setattr__(\n            key, copied_obj.__getattribute__(key)[start_index:end_index])\n    return copied_obj",
        "import_statements": [
            "import rosbag",
            "import tf",
            "import copy",
            "import math",
            "import matplotlib",
            "from matplotlib import pyplot",
            "import numpy",
            "from scipy import signal",
            "from geometry_msgs.msg import PoseStamped, Quaternion, Point"
        ],
        "reference_api": [
            "copy.deepcopy",
            "copied_obj.__getattribute__",
            "copied_obj.__setattr__",
            "self.get_next_index"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.get_next_index",
                "code": "def get_next_index(self, time):\n        \"\"\"Get the index of the next value after time.\"\"\"\n        try:\n            index = next(idx for idx, val in enumerate(self.time) if val > time)\n        except StopIteration:\n            index = len(self.time)\n        except Exception, e:\n            raise e\n        return index"
            },
            {
                "name": "self.get_next_index",
                "code": "def get_next_index(self, time):\n        \"\"\"Get the index of the next value after time.\"\"\"\n        try:\n            index = next(idx for idx, val in enumerate(self.time) if val > time)\n        except StopIteration:\n            index = len(self.time)\n        except Exception, e:\n            raise e\n        return index"
            }
        ],
        "third_party": [
            "copied_obj.__setattr__",
            "copied_obj.__getattribute__"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)",
        "start_line": "165",
        "end_line": "185",
        "file_path": "rotors_evaluation/src/rosbag_tools/analyze_bag.py",
        "docstring": "This function, append_waypoint, appends data from a waypoint message to its corresponding arrays.\\nIt extracts the position and rotation, converts the rotation to Euler angles, and creates a Point object.\\nIt checks if the current waypoint is different from the last one by comparing position and yaw values.\\nIf the waypoint is different, it appends the new point, yaw, and corresponding times to their respective arrays.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6a6adb6de4fd",
        "ground_truth": "def append_waypoint(self, waypoint_msg, msg_time, bag_time):\n    \"\"\"Append data from a waypoint to its arrays.\"\"\"\n    position = waypoint_msg.points[0].transforms[0].translation\n    rotation = waypoint_msg.points[0].transforms[0].rotation\n    quaternion = (rotation.x, rotation.y, rotation.z, rotation.w)\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n    point_msg = Point(position.x, position.y, position.z)\n    yaw = euler[2]\n    # Check if the waypoint is different from the last one.\n    try:\n        different_waypoint = (self.yaw[-1] != yaw or\n                              self.x[-1] != point_msg.x or\n                              self.y[-1] != point_msg.y or\n                              self.z[-1] != point_msg.z)\n    except IndexError:\n        different_waypoint = True\n    # Append new waypoint.\n    if (different_waypoint):\n        self.append_point(point_msg)\n        self.yaw = numpy.append(self.yaw, yaw)\n        self.append_times(msg_time, bag_time)",
        "import_statements": [
            "import rosbag",
            "import tf",
            "import copy",
            "import math",
            "import matplotlib",
            "from matplotlib import pyplot",
            "import numpy",
            "from scipy import signal",
            "from geometry_msgs.msg import PoseStamped, Quaternion, Point"
        ],
        "reference_api": [
            "Point",
            "self.append_times",
            "self.append_point",
            "euler_from_quaternion",
            "numpy.append"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.append_point",
                "code": "def append_point(self, point_msg):\n        \"\"\"Append the x, y, z components from a point to its arrays.\"\"\"\n        self.x = numpy.append(self.x, point_msg.x)\n        self.y = numpy.append(self.y, point_msg.y)\n        self.z = numpy.append(self.z, point_msg.z)"
            },
            {
                "name": "self.append_times",
                "code": "def append_times(self, msg_time, bag_time):\n        \"\"\"Append the msg_time and the bag_time.\"\"\"\n        self.time = numpy.append(self.time, msg_time)\n        self.bag_time = numpy.append(self.bag_time, bag_time)"
            }
        ],
        "third_party": [
            "euler_from_quaternion",
            "Point",
            "numpy.append"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "def extract_imu_topics(self, topic, msg, bag_time)",
        "start_line": "323",
        "end_line": "331",
        "file_path": "rotors_evaluation/src/rosbag_tools/analyze_bag.py",
        "docstring": "This function, extract_imu_topics, appends IMU topic message content to acceleration attributes.\\nIt converts the message timestamp to seconds.\\nFor each IMU topic, if the topic matches, it appends the linear acceleration data to the corresponding x, y, and z attributes.\\nIt also appends the message time and bag time to the time attributes.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "06de545616c1",
        "ground_truth": "def extract_imu_topics(self, topic, msg, bag_time):\n    \"\"\"Append the imu topic msg content to the acc attributes.\"\"\"\n    msg_time = msg.header.stamp.to_sec()\n    for index, imu_topic in enumerate(self.imu_topics):\n        if topic == imu_topic:\n            self.acc[index].x.append(msg.linear_acceleration.x)\n            self.acc[index].y.append(msg.linear_acceleration.y)\n            self.acc[index].z.append(msg.linear_acceleration.z)\n            self.acc[index].append_times(msg_time, bag_time)",
        "import_statements": [
            "import rosbag",
            "import tf",
            "import copy",
            "import math",
            "import matplotlib",
            "from matplotlib import pyplot",
            "import numpy",
            "from scipy import signal",
            "from geometry_msgs.msg import PoseStamped, Quaternion, Point"
        ],
        "reference_api": [
            "append",
            "enumerate",
            "append_times",
            "to_sec"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "append_times",
                "code": "def append_times(self, msg_time, bag_time):\n        \"\"\"Append the msg_time and the bag_time.\"\"\"\n        self.time = numpy.append(self.time, msg_time)\n        self.bag_time = numpy.append(self.bag_time, bag_time)"
            }
        ],
        "third_party": [
            "to_sec",
            "append",
            "append",
            "append"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "def plot_accelerations(self, plot_suffix=None)",
        "start_line": "586",
        "end_line": "603",
        "file_path": "rotors_evaluation/src/rosbag_tools/analyze_bag.py",
        "docstring": "This function, plot_accelerations, generates and saves a plot of acceleration data.\\nIt creates a figure with a title and a subplot for accelerations.\\nFor each acceleration dataset, it plots the x, y, and z components over time with different colors and labels.\\nIt adds labels for the x and y axes and includes a legend.\\nIf saving plots is enabled, it constructs a filename based on a prefix and optional suffix and saves the plot as a PNG file.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d98100201d22",
        "ground_truth": "def plot_accelerations(self, plot_suffix=None):\n    \"\"\"Plot all acceleration lists.\"\"\"\n    fig = pyplot.figure()\n    fig.suptitle(\"Accelerations\")\n    a_x = fig.add_subplot(111)\n    for index, acc in enumerate(self.acc):\n        a_x.plot(acc.time, acc.x, 'b', label='x' + self.imu_topics[index])\n        a_x.plot(acc.time, acc.y, 'r', label='y' + self.imu_topics[index])\n        a_x.plot(acc.time, acc.z, 'g', label='z' + self.imu_topics[index])\n    pyplot.xlabel('time [s]')\n    pyplot.ylabel('acceleration [m/s^2]')\n    pyplot.legend()\n    if self.save_plots:\n        file_name = self.prefix + '_acc' if self.prefix else 'acc'\n        if plot_suffix:\n            file_name += '_' + str(plot_suffix)\n        file_name += '.png'\n        pyplot.savefig(file_name)",
        "import_statements": [
            "import rosbag",
            "import tf",
            "import copy",
            "import math",
            "import matplotlib",
            "from matplotlib import pyplot",
            "import numpy",
            "from scipy import signal",
            "from geometry_msgs.msg import PoseStamped, Quaternion, Point"
        ],
        "reference_api": [
            "a_x.plot",
            "fig.suptitle",
            "pyplot.ylabel",
            "pyplot.savefig",
            "pyplot.figure",
            "fig.add_subplot",
            "str",
            "enumerate",
            "pyplot.legend",
            "pyplot.xlabel"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "pyplot.figure",
            "fig.suptitle",
            "fig.add_subplot",
            "a_x.plot",
            "a_x.plot",
            "a_x.plot",
            "pyplot.xlabel",
            "pyplot.ylabel",
            "pyplot.legend",
            "pyplot.savefig"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "def compare_positions(self, pose_indeces)",
        "start_line": "606",
        "end_line": "619",
        "file_path": "rotors_evaluation/src/rosbag_tools/analyze_bag.py",
        "docstring": "This function, compare_positions, compares the positions of multiple poses based on their indices.\\nIt requires at least two pose indices to perform comparisons.\\nFor each pose index, it compares the position with all subsequent pose indices using the compare_two_xyz function.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7bd2685135d8",
        "ground_truth": "def compare_positions(self, pose_indeces):\n    \"\"\"\n    Compare the position lists of pose_topics.\n    Args:\n       pose_indeces (list): Indeces of pose_topics for comparison.\n    \"\"\"\n    if len(pose_indeces) < 2:\n        print(\"At least two pose_indeces need to be provided to make a \"\n              \"comparison\")\n    for index, pose_index in enumerate(pose_indeces):\n        for pose_index_cmp in pose_indeces[index+1:]:\n            compare_two_xyz(self.pos[pose_index],\n                            self.pos[pose_index_cmp])",
        "import_statements": [
            "import rosbag",
            "import tf",
            "import copy",
            "import math",
            "import matplotlib",
            "from matplotlib import pyplot",
            "import numpy",
            "from scipy import signal",
            "from geometry_msgs.msg import PoseStamped, Quaternion, Point"
        ],
        "reference_api": [
            "compare_two_xyz",
            "print",
            "len",
            "enumerate"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "compare_two_xyz",
                "code": "def compare_two_xyz(xyz_one, xyz_two):\n    # TODO(ff): Implement some position comparison\n    pass"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "def get_collisions(self, start_time=None, end_time=None)",
        "start_line": "621",
        "end_line": "630",
        "file_path": "rotors_evaluation/src/rosbag_tools/analyze_bag.py",
        "docstring": "This function, get_collisions, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "faac3e9c9c1e",
        "ground_truth": "def get_collisions(self, start_time=None, end_time=None):\n    \"\"\"Get the collision times.\"\"\"\n    collision_times = []\n    for collision in self.wrench:\n        for t in collision.time:\n            if t >= (start_time or 0) and t <= (end_time or\n                                                max(collision.time)):\n                collision_times.append(t)\n    return collision_times",
        "import_statements": [
            "import rosbag",
            "import tf",
            "import copy",
            "import math",
            "import matplotlib",
            "from matplotlib import pyplot",
            "import numpy",
            "from scipy import signal",
            "from geometry_msgs.msg import PoseStamped, Quaternion, Point"
        ],
        "reference_api": [
            "collision_times.append",
            "max"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "collision_times.append"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)",
        "start_line": "289",
        "end_line": "301",
        "file_path": "rotors_evaluation/src/rosbag_tools/helpers.py",
        "docstring": "This function, plot_angular_velocities, plots angular velocities over a specified time range.\\nIt calculates the absolute settling time by adding the settling time to the start time.\\nThen, it calls analyze_bag.plot_angular_velocities with the specified start time, end time, settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5].",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2e743142ebc7",
        "ground_truth": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix):\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])",
        "import_statements": [
            "import optparse",
            "from rosbag_tools import analyze_bag"
        ],
        "reference_api": [
            "analyze_bag.plot_angular_velocities"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "analyze_bag.plot_angular_velocities",
                "code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix):\n    try:\n        absolute_settling_time = settling_time + start_time\n    except:\n        absolute_settling_time = None\n    analyze_bag.plot_angular_velocities(\n        start_time=start_time,\n        end_time=end_time,\n        settling_time=absolute_settling_time,\n        x_range=x_range,\n        plot_suffix=plot_suffix,\n        y_range=[-1.5, 1.5])"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)",
        "start_line": "25",
        "end_line": "50",
        "file_path": "rotors_gazebo_plugins/src/depth_noise_model.cpp",
        "docstring": "This function, D435DepthNoiseModel::ApplyNoise, applies noise to depth data for a specified image width and height.\\nIt first checks if the data pointer is null and returns if it is.\\nIt calculates a multiplier based on camera parameters and maps the data to an Eigen vector.\\nIt then computes the RMS noise and the noise values.\\nFor each pixel, it adds noise if the pixel value is in range, otherwise it sets the pixel to a bad point value.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c1bd86aa7eb8",
        "ground_truth": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data) {\n  if (data == nullptr) {\n    return;\n  }\n   float f = 0.5f * (width / tanf(h_fov / 2.0f));\n  float multiplier = (subpixel_err) / (f * baseline * 1e6f);\n  Eigen::Map<Eigen::VectorXf> data_vector_map(data, width * height);\n   // Formula taken from the Intel Whitepaper:\n  // \"Best-Known-Methods for Tuning Intel RealSense\u00e2\u201e\u00a2 D400 Depth Cameras for Best Performance\".\n  // We are using the theoretical RMS model formula.\n  Eigen::VectorXf rms_noise = (data_vector_map * 1000.0).array().square() * multiplier;\n  Eigen::VectorXf noise = rms_noise.array().square();\n   // Sample noise for each pixel and transform variance according to error at this depth.\n  for (int i = 0; i < width * height; ++i) {\n    if (InRange(data_vector_map[i])) {\n      data_vector_map[i] +=\n          this->dist(this->gen) * std::min(((float)noise(i)), max_stdev);\n    } else {\n      data_vector_map[i] = this->bad_point;\n    }\n  }\n}",
        "import_statements": [
            "#include <algorithm>\n",
            "#include <iostream>\n",
            "#include <rotors_gazebo_plugins/depth_noise_model.hpp>\n"
        ],
        "reference_api": [
            "this->dist",
            "std::min",
            "(data_vector_map * 1000.0).array().square",
            "rms_noise.array().square",
            "InRange",
            "rms_noise.array",
            "(data_vector_map * 1000.0).array",
            "tanf",
            "noise"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "InRange",
                "code": "inline bool DepthNoiseModel::InRange(const float depth) const {\n  return depth > this->min_depth && depth < this->max_depth;\n}"
            }
        ],
        "third_party": [
            "this->dist",
            "(data_vector_map * 1000.0).array().square",
            "rms_noise.array().square",
            "rms_noise.array",
            "(data_vector_map * 1000.0).array",
            "tanf",
            "noise"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)",
        "start_line": "271",
        "end_line": "276",
        "file_path": "rotors_gazebo_plugins/src/gazebo_bag_plugin.cpp",
        "docstring": "This function, GazeboBagPlugin::WaypointCallback, handles waypoint messages for a trajectory.\\nIt retrieves the current simulation time and converts it to ROS time.\\nThen, it writes the trajectory message to a bag file using the specified namespace and waypoint topic.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "52103858b08c",
        "ground_truth": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg) {\n  common::Time now = world_->SimTime();\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n  writeBag(namespace_ + \"/\" + waypoint_topic_, ros_now, trajectory_msg);\n}",
        "import_statements": [
            "#include \"rotors_gazebo_plugins/gazebo_bag_plugin.h\"\n",
            "#include <ctime>\n",
            "#include <mav_msgs/Actuators.h>\n"
        ],
        "reference_api": [
            "world_->SimTime",
            "ros::Time",
            "writeBag"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "world_->SimTime",
            "ros::Time",
            "writeBag"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)",
        "start_line": "314",
        "end_line": "330",
        "file_path": "rotors_gazebo_plugins/src/gazebo_bag_plugin.cpp",
        "docstring": "This function, GazeboBagPlugin::LogMotorVelocities, logs the motor velocities at a given simulation time.\\nIt converts the simulation time to ROS time and prepares a message for actuator velocities.\\nIt iterates through the motor joints, calculates the slowed-down rotational velocities, and assigns them to the message.\\nThe message timestamp is set, and the data is written to a bag file using the specified namespace and motor topic.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c657cbed871c",
        "ground_truth": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now) {\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n   mav_msgs::Actuators rot_velocities_msg;\n  rot_velocities_msg.angular_velocities.resize(motor_joints_.size());\n   MotorNumberToJointMap::iterator m;\n  for (m = motor_joints_.begin(); m != motor_joints_.end(); ++m) {\n    double motor_rot_vel =\n        m->second->GetVelocity(0) * rotor_velocity_slowdown_sim_;\n    rot_velocities_msg.angular_velocities[m->first] = motor_rot_vel;\n  }\n  rot_velocities_msg.header.stamp.sec = now.sec;\n  rot_velocities_msg.header.stamp.nsec = now.nsec;\n   writeBag(namespace_ + \"/\" + motor_topic_, ros_now, rot_velocities_msg);\n}",
        "import_statements": [
            "#include \"rotors_gazebo_plugins/gazebo_bag_plugin.h\"\n",
            "#include <ctime>\n",
            "#include <mav_msgs/Actuators.h>\n"
        ],
        "reference_api": [
            "motor_joints_.end",
            "ros::Time",
            "writeBag",
            "motor_joints_.begin",
            "motor_joints_.size",
            "m->second->GetVelocity",
            "rot_velocities_msg.angular_velocities.resize"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "motor_joints_.end",
            "ros::Time",
            "writeBag",
            "motor_joints_.begin",
            "motor_joints_.size",
            "m->second->GetVelocity",
            "rot_velocities_msg.angular_velocities.resize"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)",
        "start_line": "378",
        "end_line": "394",
        "file_path": "rotors_gazebo_plugins/src/gazebo_fw_dynamics_plugin.cpp",
        "docstring": "This function, GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback, processes roll, pitch, yaw rate, and thrust messages.\\nIf debug printing is enabled, it logs that the callback was called.\\nIt converts the normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\\nIt also sets the throttle value from the thrust message.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d35abe9c3114",
        "ground_truth": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg) {\n  if (kPrintOnMsgCallback) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n   delta_aileron_left_ = NormalizedInputToAngle(vehicle_params_.aileron_left,\n      roll_pitch_yawrate_thrust_msg->roll());\n  delta_aileron_right_ = -NormalizedInputToAngle(vehicle_params_.aileron_right,\n      roll_pitch_yawrate_thrust_msg->roll());\n  delta_elevator_ = NormalizedInputToAngle(vehicle_params_.elevator,\n      roll_pitch_yawrate_thrust_msg->pitch());\n  delta_rudder_ = NormalizedInputToAngle(vehicle_params_.rudder,\n      roll_pitch_yawrate_thrust_msg->yaw_rate());\n   throttle_ = roll_pitch_yawrate_thrust_msg->thrust().x();\n}",
        "import_statements": [
            "#include \"rotors_gazebo_plugins/gazebo_fw_dynamics_plugin.h\"\n",
            "#include \"ConnectRosToGazeboTopic.pb.h\"\n"
        ],
        "reference_api": [
            "roll_pitch_yawrate_thrust_msg->thrust().x",
            "roll_pitch_yawrate_thrust_msg->yaw_rate",
            "NormalizedInputToAngle",
            "roll_pitch_yawrate_thrust_msg->roll",
            "roll_pitch_yawrate_thrust_msg->thrust",
            "roll_pitch_yawrate_thrust_msg->pitch"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "NormalizedInputToAngle",
                "code": "double GazeboFwDynamicsPlugin::NormalizedInputToAngle(\n    const ControlSurface& surface, double input) {\n  return (surface.deflection_max + surface.deflection_min) * 0.5 +\n      (surface.deflection_max - surface.deflection_min) * 0.5 * input;\n}"
            }
        ],
        "third_party": [
            "roll_pitch_yawrate_thrust_msg->thrust().x",
            "roll_pitch_yawrate_thrust_msg->yaw_rate",
            "roll_pitch_yawrate_thrust_msg->roll",
            "roll_pitch_yawrate_thrust_msg->thrust",
            "roll_pitch_yawrate_thrust_msg->pitch"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)",
        "start_line": "629",
        "end_line": "657",
        "file_path": "rotors_gazebo_plugins/src/gazebo_mavlink_interface.cpp",
        "docstring": "This function, GazeboMavlinkInterface::pollForMAVLinkMessages, polls for MAVLink messages within a specified timeout.\\nIt converts the timeout to a timeval structure and performs a poll operation on file descriptors.\\nIf data is available, it receives the data and parses MAVLink messages from the buffer.\\nParsed messages are optionally forwarded to a serial connection and then handled accordingly.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b025e662fa03",
        "ground_truth": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs) {\n  // convert timeout in ms to timeval\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000UL;\n   // poll\n  ::poll(&fds[0], (sizeof(fds[0]) / sizeof(fds[0])), 0);\n   if (fds[0].revents & POLLIN) {\n    int len = recvfrom(\n        _fd, buf_, sizeof(buf_), 0, (struct sockaddr*)&srcaddr_, &addrlen_);\n    if (len > 0) {\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      for (unsigned i = 0; i < len; ++i) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, buf_[i], &msg, &status)) {\n          if (serial_enabled_) {\n            // forward message from qgc to serial\n            send_mavlink_message(&msg);\n          }\n          // have a message, handle it\n          handle_message(&msg);\n        }\n      }\n    }\n  }\n}",
        "import_statements": [
            "#include <rotors_gazebo_plugins/gazebo_mavlink_interface.h>\n"
        ],
        "reference_api": [
            "mavlink_parse_char",
            "send_mavlink_message",
            "::poll",
            "recvfrom",
            "handle_message"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "send_mavlink_message",
                "code": "void GazeboMavlinkInterface::send_mavlink_message(\n    const mavlink_message_t* message, const int destination_port) {\n  if (serial_enabled_ && destination_port == 0) {\n    assert(message != nullptr);\n    if (!is_open()) {\n      gzerr << \"Serial port closed! \\n\";\n      return;\n    }\n\n    {\n      lock_guard lock(mutex_);\n\n      if (tx_q_.size() >= MAX_TXQ_SIZE) {\n        //         gzwarn << \"TX queue overflow. \\n\";\n      }\n      tx_q_.emplace_back(message);\n    }\n    io_service_.post(std::bind(&GazeboMavlinkInterface::do_write, this, true));\n  }\n\n  else {\n    uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n    int packetlen = mavlink_msg_to_send_buffer(buffer, message);\n\n    struct sockaddr_in dest_addr;\n    memcpy(&dest_addr, &srcaddr_, sizeof(srcaddr_));\n\n    if (destination_port != 0) {\n      dest_addr.sin_port = htons(destination_port);\n    }\n\n    ssize_t len = sendto(\n        _fd, buffer, packetlen, 0, (struct sockaddr*)&srcaddr_,\n        sizeof(srcaddr_));\n\n    if (len <= 0) {\n      printf(\"Failed sending mavlink message\\n\");\n    }\n  }\n}"
            },
            {
                "name": "handle_message",
                "code": "void GazeboMavlinkInterface::handle_message(mavlink_message_t* msg) {\n  switch (msg->msgid) {\n    case MAVLINK_MSG_ID_HIL_ACTUATOR_CONTROLS:\n      mavlink_hil_actuator_controls_t controls;\n      mavlink_msg_hil_actuator_controls_decode(msg, &controls);\n      bool armed = false;\n\n      if ((controls.mode & MAV_MODE_FLAG_SAFETY_ARMED) > 0) {\n        armed = true;\n      }\n\n      last_actuator_time_ = world_->SimTime();\n\n      for (unsigned i = 0; i < kNOutMax; i++) {\n        input_index_[i] = i;\n      }\n\n      // Set rotor speeds and controller targets for flagged messages.\n      if (controls.flags == kMotorSpeedFlag) {\n        input_reference_.resize(kNOutMax);\n        for (unsigned i = 0; i < kNumMotors; ++i) {\n          if (armed) {\n            input_reference_[i] =\n                (controls.controls[input_index_[i]] + input_offset_[i]) *\n                    input_scaling_[i] +\n                zero_position_armed_[i];\n          } else {\n            input_reference_[i] = zero_position_disarmed_[i];\n          }\n        }\n        received_first_reference_ = true;\n      } else if (controls.flags == kServoPositionFlag) {\n        for (unsigned i = kNumMotors; i < (kNumMotors + kNumServos); ++i) {\n          if (armed) {\n            input_reference_[i] =\n                (controls.controls[input_index_[i - kNumMotors]] +\n                 input_offset_[i]) *\n                    input_scaling_[i] +\n                zero_position_armed_[i];\n          } else {\n            input_reference_[i] = zero_position_disarmed_[i];\n          }\n        }\n      }\n      // Set rotor speeds, controller targets for unflagged messages.\n      else {\n        input_reference_.resize(kNOutMax);\n        for (unsigned i = 0; i < kNOutMax; ++i) {\n          if (armed) {\n            input_reference_[i] =\n                (controls.controls[input_index_[i]] + input_offset_[i]) *\n                    input_scaling_[i] +\n                zero_position_armed_[i];\n          } else {\n            input_reference_[i] = zero_position_disarmed_[i];\n          }\n        }\n        received_first_reference_ = true;\n      }\n      break;\n  }\n}"
            }
        ],
        "third_party": [
            "mavlink_parse_char",
            "::poll",
            "recvfrom"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "void GazeboMavlinkInterface::close() ",
        "start_line": "774",
        "end_line": "784",
        "file_path": "rotors_gazebo_plugins/src/gazebo_mavlink_interface.cpp",
        "docstring": "This function, GazeboMavlinkInterface::close, safely closes the interface.\\nIt locks a mutex to ensure thread safety and checks if the interface is open.\\nIf open, it stops the I/O service and closes the serial device.\\nIf the I/O thread is joinable, it joins the thread to clean up resources.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7fe2d4d0db74",
        "ground_truth": "void GazeboMavlinkInterface::close() {\n  lock_guard lock(mutex_);\n  if (!is_open())\n    return;\n   io_service_.stop();\n  serial_dev_.close();\n   if (io_thread_.joinable())\n    io_thread_.join();\n}",
        "import_statements": [
            "#include <rotors_gazebo_plugins/gazebo_mavlink_interface.h>\n"
        ],
        "reference_api": [
            "io_thread_.join",
            "serial_dev_.close",
            "io_service_.stop",
            "io_thread_.joinable",
            "is_open"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "io_thread_.join",
            "serial_dev_.close",
            "io_service_.stop",
            "io_thread_.joinable",
            "is_open"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "ethz-asl/rotors_simulator",
        "function_declaration": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation",
        "start_line": "409",
        "end_line": "414",
        "file_path": "rotors_gazebo_plugins/src/gazebo_wind_plugin.cpp",
        "docstring": "This function, GazeboWindPlugin::LinearInterpolation, performs linear interpolation for a given position.\\nIt calculates the interpolated value between two points using their corresponding values and returns the resulting vector.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9b62cd0071d5",
        "ground_truth": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation(\n  double position, ignition::math::Vector3d * values, double* points) const {\n  ignition::math::Vector3d value = values[0] + (values[1] - values[0]) /\n                        (points[1] - points[0]) * (position - points[0]);\n  return value;\n}",
        "import_statements": [
            "#include \"rotors_gazebo_plugins/gazebo_wind_plugin.h\"\n",
            "#include <fstream>\n",
            "#include <math.h>\n",
            "#include \"ConnectGazeboToRosTopic.pb.h\"\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "gazebosim/gazebo-classic",
        "function_declaration": "void Animation::SetTime(double _time)",
        "start_line": "68",
        "end_line": "87",
        "file_path": "gazebo/common/Animation.cc",
        "docstring": "This function, Animation::SetTime, sets the animation time position to a specified value.\\nIf the new time differs from the current time, it updates the time position.\\nIf looping is enabled, it wraps the time within the animation length.\\nIf looping is disabled, it clamps the time between 0 and the animation length.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "203d2baabb52",
        "ground_truth": "void Animation::SetTime(double _time)\n{\n  if (!ignition::math::equal(_time, this->timePos))\n  {\n    this->timePos = _time;\n    if (this->loop)\n    {\n      this->timePos = fmod(this->timePos, this->length);\n      if (this->timePos < 0)\n        this->timePos += this->length;\n    }\n    else\n    {\n      if (this->timePos < 0)\n        this->timePos = 0;\n      else if (this->timePos > this->length)\n        this->timePos = this->length;\n    }\n  }\n}",
        "import_statements": [
            "#include <algorithm>\n",
            "#include <ignition/math/Spline.hh>\n",
            "#include <ignition/math/RotationSpline.hh>\n",
            "#include \"gazebo/common/Console.hh\"\n",
            "#include \"gazebo/common/KeyFrame.hh\"\n",
            "#include \"gazebo/common/Animation.hh\"\n"
        ],
        "reference_api": [
            "ignition::math::equal",
            "fmod"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "ignition::math::equal"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def hover(self)",
        "start_line": "194",
        "end_line": "198",
        "file_path": "communication/multirotor_communication.py",
        "docstring": "This function, hover, sets the vehicle's coordinate frame to 1 and motion type to 0.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8552ade39b9a",
        "ground_truth": "def hover(self):\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n    print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)",
        "import_statements": [
            "import rospy",
            "from mavros_msgs.msg import PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode, ParamSet",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist",
            "from std_msgs.msg import String",
            "from pyquaternion import Quaternion",
            "import sys"
        ],
        "reference_api": [
            "print",
            "self.construct_target"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.construct_target",
                "code": "def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n        \n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n        \n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if(self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW_RATE\n        if(self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                            + PositionTarget.IGNORE_YAW\n        if(self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                            + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                            + PositionTarget.IGNORE_YAW\n\n        return target_raw_pose"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def flight_mode_switch(self)",
        "start_line": "200",
        "end_line": "209",
        "file_path": "communication/multirotor_communication.py",
        "docstring": "This function, flight_mode_switch, changes the flight mode of a vehicle.\\nIf the flight mode is 'HOVER', it sets the hover flag to 1 and calls the hover method.\\nFor other modes, it attempts to switch modes using flightModeService.\\nIt prints a success message if the mode switch is successful, and a failure message otherwise.\\nThe function returns True if the mode switch succeeds, and False if it fails.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "05c2de81ac63",
        "ground_truth": "def flight_mode_switch(self):\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    elif self.flightModeService(custom_mode=self.flight_mode):\n        print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode)\n        return True\n    else:\n        print(self.vehicle_type+'_'+self.vehicle_id+\": \"+self.flight_mode+\"failed\")\n        return False",
        "import_statements": [
            "import rospy",
            "from mavros_msgs.msg import PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode, ParamSet",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist",
            "from std_msgs.msg import String",
            "from pyquaternion import Quaternion",
            "import sys"
        ],
        "reference_api": [
            "self.hover",
            "print",
            "self.flightModeService"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.hover",
                "code": "def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x,y=self.current_position.y,z=self.current_position.z,yaw=self.current_yaw)\n        print(self.vehicle_type+'_'+self.vehicle_id+\":\"+self.flight_mode)"
            }
        ],
        "third_party": [
            "self.flightModeService"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def cmd_vel_enu_callback(self, msg)",
        "start_line": "158",
        "end_line": "166",
        "file_path": "communication/multirotor_communication_enhanced.py",
        "docstring": "This function, cmd_vel_enu_callback, processes velocity commands in the ENU frame.\\nIt first calls hover_state_transition with the linear and angular components of the message.\\nIf the hover_flag is not set, it calls hold_state_transition with the same components and the 'enu' frame.\\nIf both hover_flag and hold_flag are not set, it sets the coordinate_frame and motion_type to 1, and constructs the target motion using the message components.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f32a06290dc6",
        "ground_truth": "def cmd_vel_enu_callback(self, msg):\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if self.hover_flag == 0 and self.hold_flag == 0:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = self.construct_target(vx=msg.linear.x, vy=msg.linear.y, vz=msg.linear.z,\n                                                   yaw_rate=msg.angular.z)",
        "import_statements": [
            "import rospy",
            "from mavros_msgs.msg import PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist",
            "from std_msgs.msg import String",
            "from pyquaternion import Quaternion",
            "import sys",
            "import math"
        ],
        "reference_api": [
            "self.hold_state_transition",
            "self.construct_target",
            "self.hover_state_transition"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.hover_state_transition",
                "code": "def hover_state_transition(self, x, y, z, w):\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n        elif not self.flight_mode == \"HOVER\":\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover()"
            },
            {
                "name": "self.hold_state_transition",
                "code": "def hold_state_transition(self, x, y, z, w, vel_type):\n        if vel_type == 'flu':\n            if abs(x) < 0.02 and abs(y) < 0.02:\n                if self.hold_x_flag == 0 or self.hold_y_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_position_y = self.current_position.y\n                    self.hold_x_flag = 1\n                    self.hold_y_flag = 1\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_position_y = self.current_position.y\n                    self.hold_x_flag = 1\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag and self.hold_y_flag and (self.hold_z_flag != 1):\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_x_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.cos(self.current_yaw) \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.sin(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_y_flag and self.hold_yaw_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                y = self.hold_kp_x * (self.current_position.x - self.hold_position_x) * math.sin(self.current_yaw)  \\\n                    - self.hold_kp_y * (self.current_position.y - self.hold_position_y) * math.cos(self.current_yaw)\n                self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                           yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            elif self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 8\n                self.motion_type = 1\n                if self.hold_yaw_flag == 0:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z,\n                                                               yaw_rate=-self.hold_kp_yaw * (self.current_yaw - self.hold_yaw))\n            else:\n                self.hold_flag = 0\n\n        elif vel_type == 'enu':\n            if abs(x) < 0.02:\n                if self.hold_x_flag == 0:\n                    self.hold_position_x = self.current_position.x\n                    self.hold_x_flag = 1\n                x = -self.hold_kp_x * (self.current_position.x - self.hold_position_x)\n            else:\n                self.hold_x_flag = 0\n            if abs(y) < 0.02:\n                if self.hold_y_flag == 0:\n                    self.hold_position_y = self.current_position.y\n                    self.hold_y_flag = 1\n                y = -self.hold_kp_y * (self.current_position.y - self.hold_position_y)\n            else:\n                self.hold_y_flag = 0\n            if abs(z) < 0.02:\n                if self.hold_z_flag == 0:\n                    self.hold_position_z = self.current_position.z\n                    self.hold_z_flag = 1\n                z = -self.hold_kp_z * (self.current_position.z - self.hold_position_z)\n            else:\n                self.hold_z_flag = 0\n            if abs(w) < 0.005:\n                if self.hold_yaw_flag == 0:\n                    self.hold_yaw = self.current_yaw\n                    self.hold_yaw_flag = 1\n            else:\n                self.hold_yaw_flag = 0\n\n            if self.hold_x_flag or self.hold_y_flag or self.hold_z_flag:\n                self.hold_flag = 1\n                self.coordinate_frame = 1\n                if self.hold_yaw_flag == 0:\n                    self.motion_type = 1\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw_rate=w)\n                else:\n                    self.motion_type = 3\n                    self.target_motion = self.construct_target(vx=x, vy=y, vz=z, yaw=self.hold_yaw)\n            else:\n                self.hold_flag = 0"
            },
            {
                "name": "self.construct_target",
                "code": "def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def hover_state_transition(self, x, y, z, w)",
        "start_line": "184",
        "end_line": "191",
        "file_path": "communication/multirotor_communication_enhanced.py",
        "docstring": "This function, hover_state_transition, transitions the drone's flight mode based on positional and rotational thresholds.\\nIf any of the x, y, z values exceed 0.02 or w exceeds 0.005, it sets hover_flag to 0 and changes the flight mode to 'OFFBOARD'.\\nIf the flight mode is not \"HOVER\" and the conditions are met, it sets hover_flag to 1, changes the flight mode to 'HOVER', and initiates the hover action.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "26dec8bb97ca",
        "ground_truth": "def hover_state_transition(self, x, y, z, w):\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n    elif not self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()",
        "import_statements": [
            "import rospy",
            "from mavros_msgs.msg import PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist",
            "from std_msgs.msg import String",
            "from pyquaternion import Quaternion",
            "import sys",
            "import math"
        ],
        "reference_api": [
            "self.hover",
            "abs"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.hover",
                "code": "def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def q2yaw(self, q)",
        "start_line": "333",
        "end_line": "340",
        "file_path": "communication/multirotor_communication_enhanced.py",
        "docstring": "This function, q2yaw, calculates the yaw rotation in radians from a quaternion.\\nIt checks if the input is an instance of Quaternion.\\nIf it is, it extracts the yaw component directly.\\nOtherwise, it creates a Quaternion from the input components and then extracts the yaw component.\\nThe function returns the yaw rotation in radians.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "76f2f38d2d3a",
        "ground_truth": "def q2yaw(self, q):\n    if isinstance(q, Quaternion):\n        rotate_z_rad = q.yaw_pitch_roll[0]\n    else:\n        q_ = Quaternion(q.w, q.x, q.y, q.z)\n        rotate_z_rad = q_.yaw_pitch_roll[0]\n    return rotate_z_rad",
        "import_statements": [
            "import rospy",
            "from mavros_msgs.msg import PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist",
            "from std_msgs.msg import String",
            "from pyquaternion import Quaternion",
            "import sys",
            "import math"
        ],
        "reference_api": [
            "Quaternion",
            "isinstance"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Quaternion"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def hover(self)",
        "start_line": "356",
        "end_line": "361",
        "file_path": "communication/multirotor_communication_enhanced.py",
        "docstring": "This function, hover, sets the vehicle to hover mode.\\nIt updates the coordinate frame and motion type.\\nIt constructs a target motion using the current position and yaw values.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e9600f2db7f4",
        "ground_truth": "def hover(self):\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                               z=self.current_position.z, yaw=self.current_yaw)\n    print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)",
        "import_statements": [
            "import rospy",
            "from mavros_msgs.msg import PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist",
            "from std_msgs.msg import String",
            "from pyquaternion import Quaternion",
            "import sys",
            "import math"
        ],
        "reference_api": [
            "print",
            "self.construct_target"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.construct_target",
                "code": "def construct_target(self, x=0, y=0, z=0, vx=0, vy=0, vz=0, afx=0, afy=0, afz=0, yaw=0, yaw_rate=0):\n        target_raw_pose = PositionTarget()\n        target_raw_pose.coordinate_frame = self.coordinate_frame\n\n        target_raw_pose.position.x = x\n        target_raw_pose.position.y = y\n        target_raw_pose.position.z = z\n\n        target_raw_pose.velocity.x = vx\n        target_raw_pose.velocity.y = vy\n        target_raw_pose.velocity.z = vz\n\n        target_raw_pose.acceleration_or_force.x = afx\n        target_raw_pose.acceleration_or_force.y = afy\n        target_raw_pose.acceleration_or_force.z = afz\n\n        target_raw_pose.yaw = yaw\n        target_raw_pose.yaw_rate = yaw_rate\n\n        if (self.motion_type == 0):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n        if (self.motion_type == 1):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 2):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_VX + PositionTarget.IGNORE_VY + PositionTarget.IGNORE_VZ \\\n                                        + PositionTarget.IGNORE_YAW\n        if (self.motion_type == 3):\n            target_raw_pose.type_mask = PositionTarget.IGNORE_PX + PositionTarget.IGNORE_PY + PositionTarget.IGNORE_PZ \\\n                                        + PositionTarget.IGNORE_AFX + PositionTarget.IGNORE_AFY + PositionTarget.IGNORE_AFZ \\\n                                        + PositionTarget.IGNORE_YAW_RATE\n\n        return target_raw_pose"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def flight_mode_switch(self)",
        "start_line": "363",
        "end_line": "372",
        "file_path": "communication/multirotor_communication_enhanced.py",
        "docstring": "This function, flight_mode_switch, switches the flight mode of a vehicle.\\nIf the flight mode is 'HOVER', it sets the hover flag and calls the hover method.\\nOtherwise, it attempts to switch the flight mode using flightModeService.\\nIf successful, it prints the new flight mode and returns True.\\nIf unsuccessful, it prints a failure message and returns False.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "28e24810b7e7",
        "ground_truth": "def flight_mode_switch(self):\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n    elif self.flightModeService(custom_mode=self.flight_mode):\n        print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode)\n        return True\n    else:\n        print(self.vehicle_type + '_' + self.vehicle_id + \": \" + self.flight_mode + \"failed\")\n        return False",
        "import_statements": [
            "import rospy",
            "from mavros_msgs.msg import PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist",
            "from std_msgs.msg import String",
            "from pyquaternion import Quaternion",
            "import sys",
            "import math"
        ],
        "reference_api": [
            "self.hover",
            "print",
            "self.flightModeService"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.hover",
                "code": "def hover(self):\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.target_motion = self.construct_target(x=self.current_position.x, y=self.current_position.y,\n                                                   z=self.current_position.z, yaw=self.current_yaw)\n        print(self.vehicle_type + '_' + self.vehicle_id + \":\" + self.flight_mode)"
            }
        ],
        "third_party": [
            "self.flightModeService"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def run(self, assignment, algorithm, play, rond)",
        "start_line": "77",
        "end_line": "84",
        "file_path": "contributer_demo/demo1/src/formation/script/enviroment.py",
        "docstring": "This function, run, sets the assignment, algorithm, play, and rond attributes.\\nIt then calls get_total_reward to calculate the total reward.\\nIf visualization is enabled, it calls the visualize method.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4c0ba39b2a66",
        "ground_truth": "def run(self, assignment, algorithm, play, rond):\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualized:\n        self.visualize()",
        "import_statements": [
            "import random"
        ],
        "reference_api": [
            "self.get_total_reward",
            "self.visualize"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.get_total_reward",
                "code": "def get_total_reward(self):\n        for i in range(len(self.assignment)):\n            speed = self.vehicles_speed[i]\n            for j in range(len(self.assignment[i])):\n                position = self.targets[self.assignment[i][j],:4]\n                self.total_reward = self.total_reward + position[2]\n                if j == 0:\n                    self.vehicles_lefttime[i] = self.vehicles_lefttime[i] - np.linalg.norm(position[:2]) / speed - position[3]\n                else:\n                    self.vehicles_lefttime[i] = self.vehicles_lefttime[i] - np.linalg.norm(position[:2]-position_last[:2]) / speed - position[3]\n                position_last = position\n                if self.vehicles_lefttime[i] > self.time_lim:\n                    self.end = True\n                    break\n            if self.end:\n                self.total_reward = 0\n                break"
            },
            {
                "name": "self.visualize",
                "code": "def visualize(self):\n        if self.assignment == None:\n            plt.scatter(x=0,y=0,s=200,c='k')\n            plt.scatter(x=self.targets[1:,0],y=self.targets[1:,1],s=self.targets[1:,2]*10,c='r')\n            plt.title('Target distribution')\n            plt.savefig('task_pic/'+'/'+self.algorithm+ \"-%d-%d.png\" % (self.play,self.rond))\n            plt.cla()\n        else:\n            plt.title('Task assignment by '+self.algorithm +', total reward : '+str(self.total_reward))\n            plt.scatter(x=0,y=0,s=200,c='k')\n            plt.scatter(x=self.targets[1:,0],y=self.targets[1:,1],s=self.targets[1:,2]*10,c='r')\n            for i in range(len(self.assignment)):\n                trajectory = np.array([[0,0,20]])\n                for j in range(len(self.assignment[i])):\n                    position = self.targets[self.assignment[i][j],:3]\n                    trajectory = np.insert(trajectory,j+1,values=position,axis=0)\n                plt.scatter(x=trajectory[1:,0],y=trajectory[1:,1],s=trajectory[1:,2]*10,c='b')\n                plt.plot(trajectory[:,0], trajectory[:,1])\n            plt.savefig('task_picture/'+self.algorithm+ \"-%d-%d.png\" % (self.play,self.rond))\n            plt.cla()"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def local_pose_callback(self, msg, i)",
        "start_line": "245",
        "end_line": "255",
        "file_path": "contributer_demo/demo1/src/formation/script/formation_sim.py",
        "docstring": "This function, local_pose_callback, updates the UAV's local and global pose based on incoming messages.\\nIf the message index matches the UAV ID, it sets the local_pose to the message.\\nDepending on the ground control station (GCS) command, it updates the takeoff_target_pose and hover_target_pose.\\nIt also updates the global_pose for the UAV, applying a bias to the position coordinates.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "655d3710840c",
        "ground_truth": "def local_pose_callback(self, msg, i):\n    if i == uav_id:\n        self.local_pose = copy.deepcopy(msg)\n    if self.gcs_cmd != 'TAKEOFF':\n        self.takeoff_target_pose = copy.deepcopy(self.local_pose)\n    if self.gcs_cmd !='HOVER':\n        self.hover_target_pose = copy.deepcopy(self.local_pose)\n    self.global_pose[i] = copy.deepcopy(msg)\n    self.global_pose[i].pose.position.x += uav_bias[i][0]\n    self.global_pose[i].pose.position.y += uav_bias[i][1]\n    self.global_pose[i].pose.position.z += uav_bias[i][2]",
        "import_statements": [
            "import time",
            "from pyquaternion import Quaternion",
            "from mpi4py import MPI",
            "import rospy",
            "from mavros_msgs.msg import State, PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode, SetMavFrame",
            "from geometry_msgs.msg import PoseStamped, TwistStamped",
            "from sensor_msgs.msg import Imu, NavSatFix",
            "from std_msgs.msg import String",
            "import copy",
            "from fuzzy_pid import FuzzyPID"
        ],
        "reference_api": [
            "copy.deepcopy"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def takeoff_detection(self)",
        "start_line": "306",
        "end_line": "310",
        "file_path": "contributer_demo/demo1/src/formation/script/formation_sim.py",
        "docstring": "This function, takeoff_detection, checks if a UAV has taken off.\\nIt returns True if the UAV's altitude is greater than 0.2 meters and the arm_state is active.\\nOtherwise, it returns False.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "63ba33d45de2",
        "ground_truth": "def takeoff_detection(self):\n    if self.local_pose.pose.position.z > 0.2 and self.arm_state:\n        return True\n    else:\n        return False",
        "import_statements": [
            "import time",
            "from pyquaternion import Quaternion",
            "from mpi4py import MPI",
            "import rospy",
            "from mavros_msgs.msg import State, PositionTarget",
            "from mavros_msgs.srv import CommandBool, SetMode, SetMavFrame",
            "from geometry_msgs.msg import PoseStamped, TwistStamped",
            "from sensor_msgs.msg import Imu, NavSatFix",
            "from std_msgs.msg import String",
            "import copy",
            "from fuzzy_pid import FuzzyPID"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def build_graph(self, orig_formation, change_formation)",
        "start_line": "81",
        "end_line": "87",
        "file_path": "ros2/fomation_demo/leader.py",
        "docstring": "This function, build_graph, constructs a distance matrix for UAV formations.\\nIt calculates the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\\nThe distances are adjusted by subtracting them from 50 and converted to integers.\\nThe resulting distance matrix is returned.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f53f1a3b1fc1",
        "ground_truth": "def build_graph(self, orig_formation, change_formation):\n    distance = [[0 for i in range(self.uav_num - 1)] for j in range(self.uav_num - 1)]\n    for i in range(self.uav_num - 1):\n        for j in range(self.uav_num - 1):\n            distance[i][j] = numpy.linalg.norm(orig_formation[:, i] - change_formation[:, j])\n            distance[i][j] = int(50 - distance[i][j])\n    return distance",
        "import_statements": [
            "import rclpy",
            "import time",
            "import sys",
            "import numpy",
            "from rclpy.node import Node",
            "from std_msgs.msg import String,Float32MultiArray,Int32MultiArray",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist,Vector3"
        ],
        "reference_api": [
            "int",
            "norm",
            "range"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "norm"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def find_path(self, i)",
        "start_line": "90",
        "end_line": "103",
        "file_path": "ros2/fomation_demo/leader.py",
        "docstring": "This function, find_path, attempts to find an augmenting path in a bipartite graph for matching purposes.\\nIt marks the left vertex as visited and iterates through adjacent right vertices.\\nIf a right vertex is already visited, it continues.\\nIt calculates the gap between labels and match weight.\\nIf the gap is zero, it marks the right vertex as visited and checks if it can either find a path or update the match.\\nIf the gap is not zero, it updates the slack value for the right vertex.\\nThe function returns True if a path is found, otherwise False.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f08b0e0bcb22",
        "ground_truth": "def find_path(self, i):\n    self.visit_left[i] = True\n    for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n        if self.visit_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - match_weight\n        if gap == 0:\n            self.visit_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack_right[j] = min(gap, self.slack_right[j])\n    return False",
        "import_statements": [
            "import rclpy",
            "import time",
            "import sys",
            "import numpy",
            "from rclpy.node import Node",
            "from std_msgs.msg import String,Float32MultiArray,Int32MultiArray",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist,Vector3"
        ],
        "reference_api": [
            "self.find_path",
            "enumerate",
            "min"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.find_path",
                "code": "def find_path(self, i):\n        self.visit_left[i] = True\n        for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n            if self.visit_right[j]:\n                continue\n            gap = self.label_left[i] + self.label_right[j] - match_weight\n            if gap == 0:\n                self.visit_right[j] = True\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(gap, self.slack_right[j])\n        return False"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def KM(self)",
        "start_line": "106",
        "end_line": "125",
        "file_path": "ros2/fomation_demo/leader.py",
        "docstring": "This function, KM, implements the Kuhn-Munkres algorithm to find the maximum matching in a bipartite graph.\\nIt iterates over UAVs, initializing slack variables and resetting visit arrays for each UAV.\\nIf no path is found, it adjusts the labels based on the minimum slack value.\\nThis process continues until a path is found for each UAV.\\nFinally, it returns the match results for the right side of the bipartite graph.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ff38be7544dc",
        "ground_truth": "def KM(self):\n    for i in range(self.uav_num - 1):\n        self.slack_right = numpy.array([100] * (self.uav_num - 1))\n        while True:\n            self.visit_left = numpy.array([0] * (self.uav_num - 1))\n            self.visit_right = numpy.array([0] * (self.uav_num - 1))\n            if self.find_path(i):\n                break\n            d = numpy.inf\n            for j, slack in enumerate(self.slack_right):\n                if not self.visit_right[j]:\n                    d = min(d, slack)\n            for k in range(self.uav_num - 1):\n                if self.visit_left[k]:\n                    self.label_left[k] -= d\n                if self.visit_right[k]:\n                    self.label_right[k] += d\n                else:\n                    self.slack_right[k] -= d\n    return self.match_right",
        "import_statements": [
            "import rclpy",
            "import time",
            "import sys",
            "import numpy",
            "from rclpy.node import Node",
            "from std_msgs.msg import String,Float32MultiArray,Int32MultiArray",
            "from geometry_msgs.msg import PoseStamped, Pose, Twist,Vector3"
        ],
        "reference_api": [
            "min",
            "self.find_path",
            "numpy.array",
            "enumerate",
            "range"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "self.find_path",
                "code": "def find_path(self, i):\n        self.visit_left[i] = True\n        for j, match_weight in enumerate(self.adj_matrix[i], start=0):\n            if self.visit_right[j]:\n                continue\n            gap = self.label_left[i] + self.label_right[j] - match_weight\n            if gap == 0:\n                self.visit_right[j] = True\n                if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                    self.match_right[j] = i\n                    return True\n            else:\n                self.slack_right[j] = min(gap, self.slack_right[j])\n        return False"
            }
        ],
        "third_party": [
            "numpy.array",
            "numpy.array",
            "numpy.array"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "def yellow_dectection(image)",
        "start_line": "34",
        "end_line": "42",
        "file_path": "sensing/lane_detection/lane_detection_rover.py",
        "docstring": "This function, yellow_detection, detects yellow color in an image.\\nIt converts the image to HSV color space and creates a mask for yellow color using specified lower and upper HSV bounds.\\nThe function then applies the mask to the original image using bitwise_and and returns the result.",
        "language": "Python",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "681b1afafb29",
        "ground_truth": "def yellow_dectection(image):\n    # create hsv\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.uint8([ 30, 150, 101])\n    upper = np.uint8([ 100, 255, 255])\n    yellow_mask = cv2.inRange(hsv, lower, upper)\n    result = cv2.bitwise_and(image, image,mask=yellow_mask)\n     return result   ",
        "import_statements": [
            "import cv2",
            "import rospy",
            "from sensor_msgs.msg import Image",
            "from std_msgs.msg import Int16",
            "from cv_bridge import CvBridge"
        ],
        "reference_api": [
            "cv2.cvtColor",
            "np.uint8",
            "cv2.inRange",
            "cv2.bitwise_and"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "cv2.cvtColor",
            "np.uint8",
            "np.uint8",
            "cv2.inRange",
            "cv2.bitwise_and"
        ]
    },
    {
        "subclass": "gazebo",
        "owner/repo": "robin-shaun/XTDrone",
        "function_declaration": "bool TagDetector::findStandaloneTagDescription",
        "start_line": "727",
        "end_line": "743",
        "file_path": "sensing/object_detection_and_tracking/apriltag/apriltag_ros/src/common_functions.cpp",
        "docstring": "This function, TagDetector::findStandaloneTagDescription, searches for a standalone tag description by ID.\\nIt checks the standalone_tag_descriptions_ map for the given ID.\\nIf the description is not found and printWarning is true, it logs a warning message.\\nIf found, it sets the descriptionContainer to the tag's description and returns true; otherwise, it returns false.",
        "language": "CPP",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6b245978b261",
        "ground_truth": "bool TagDetector::findStandaloneTagDescription (\n    int id, StandaloneTagDescription*& descriptionContainer, bool printWarning)\n{\n  std::map<int, StandaloneTagDescription>::iterator description_itr =\n      standalone_tag_descriptions_.find(id);\n  if (description_itr == standalone_tag_descriptions_.end())\n  {\n    if (printWarning)\n    {\n      ROS_WARN_THROTTLE(10.0, \"Requested description of standalone tag ID [%d],\"\n                        \" but no description was found...\",id);\n    }\n    return false;\n  }\n  descriptionContainer = &(description_itr->second);\n  return true;\n}",
        "import_statements": [
            "#include \"apriltag_ros/common_functions.h\"\n",
            "#include \"image_geometry/pinhole_camera_model.h\"\n",
            "#include \"common/homography.h\"\n",
            "#include \"tag36h11.h\"\n",
            "#include \"tag25h9.h\"\n",
            "#include \"tag16h5.h\"\n"
        ],
        "reference_api": [
            "standalone_tag_descriptions_.end",
            "standalone_tag_descriptions_.find",
            "ROS_WARN_THROTTLE"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "standalone_tag_descriptions_.end",
            "standalone_tag_descriptions_.find",
            "ROS_WARN_THROTTLE"
        ]
    }
]