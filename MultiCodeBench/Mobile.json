[
    {
        "subclass": "IOS",
        "owner/repo": "fastlane/fastlane",
        "function_declaration": "func laneParameters() -> [String: String]",
        "start_line": "74",
        "end_line": "84",
        "file_path": "fastlane/swift/ArgumentProcessor.swift",
        "docstring": "The function laneParameters() -> [String: String] filters out specific arguments from an input array named args, excluding those with names timeoutseconds, lane, and logmode. It then constructs and returns a dictionary containing the remaining argument names as keys and their corresponding values as values.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "312f8ccaaf7b",
        "ground_truth": "func laneParameters() -> [String: String] {\n    let laneParametersArgs = args.filter { arg in\n        let lowercasedName = arg.name.lowercased()\n        return lowercasedName != \"timeoutseconds\" && lowercasedName != \"lane\" && lowercasedName != \"logmode\"\n    }\n    var laneParameters = [String: String]()\n    for arg in laneParametersArgs {\n        laneParameters[arg.name] = arg.value\n    }\n    return laneParameters\n}",
        "import_statements": [
            "import Foundation"
        ],
        "reference_api": ["args.filter","arg.name.lowercased"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "airbnb/lottie-ios",
        "function_declaration": "override func display()",
        "start_line": "156",
        "end_line": "187",
        "file_path": "Sources/Private/CoreAnimation/CoreAnimationLayer.swift",
        "docstring": "The override func display() checks if there is a pending animation configuration, modifies it if necessary, and attempts to set up the animation. If the setup fails due to a compatibility issue, it updates the playback state and reports the issue. Regardless of success or failure, it reports any compatibility issues after attempting setup.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "59b41fe26c86",
        "ground_truth": "override func display() {\n  // We intentionally don't call `super.display()`, since this layer\n  // doesn't directly render any content.\n  //  - This fixes an issue where certain animations would unexpectedly\n  //    allocate a very large amount of memory (400mb+).\n  //  - Alternatively this layer could subclass `CATransformLayer`,\n  //    but this causes Core Animation to emit unnecessary logs.\n  if var pendingAnimationConfiguration {\n    pendingAnimationConfigurationModification?(&pendingAnimationConfiguration.animationConfiguration)\n    pendingAnimationConfigurationModification = nil\n    self.pendingAnimationConfiguration = nil\n    do {\n      try setupAnimation(for: pendingAnimationConfiguration.animationConfiguration)\n    } catch {\n      if case CompatibilityTracker.Error.encounteredCompatibilityIssue(let compatibilityIssue) = error {\n        // Even though the animation setup failed, we still update the layer's playback state\n        // so it can be read by the parent `LottieAnimationView` when handling this error\n        currentPlaybackState = pendingAnimationConfiguration.playbackState\n        didSetUpAnimation?([compatibilityIssue])\n        return\n      }\n    }\n    currentPlaybackState = pendingAnimationConfiguration.playbackState\n    compatibilityTracker.reportCompatibilityIssues { compatibilityIssues in\n      didSetUpAnimation?(compatibilityIssues)\n    }\n  }\n}",
        "import_statements": [
            "import QuartzCore\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "airbnb/lottie-ios",
        "function_declaration": "func makeSectionedChangeset(from other: Self) -> SectionedChangeset",
        "start_line": "180",
        "end_line": "201",
        "file_path": "Sources/Private/EmbeddedLibraries/EpoxyCore/Diffing/Collection+Diff.swift",
        "docstring": "The function makeSectionedChangeset(from other: Self) -> SectionedChangeset creates a SectionedChangeset by first generating a section changeset using makeIndexSetChangeset(from: other). It then iterates through sections of the input to map item changes from the source to the target, accumulating these changes into an item changeset. Finally, it returns a SectionedChangeset combining both the section and item changesets.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2c08ee0d01e5",
        "ground_truth": "func makeSectionedChangeset(from other: Self) -> SectionedChangeset {\n  let sectionChangeset = makeIndexSetChangeset(from: other)\n  var itemChangeset = IndexPathChangeset()\n  for fromSectionIndex in other.indices {\n    guard let toSectionIndex = sectionChangeset.newIndices[fromSectionIndex] else {\n      continue\n    }\n    let fromItems = other[fromSectionIndex].diffableItems\n    let toItems = self[toSectionIndex].diffableItems\n    let itemIndexChangeset = toItems.makeIndexPathChangeset(\n      from: fromItems,\n      fromSection: fromSectionIndex,\n      toSection: toSectionIndex)\n    itemChangeset += itemIndexChangeset\n  }\n  return SectionedChangeset(sectionChangeset: sectionChangeset, itemChangeset: itemChangeset)\n}",
        "import_statements": [],
        "reference_api": ["makeIndexSetChangeset","IndexPathChangeset","toItems.makeIndexPathChangeset","SectionedChangeset"],
        "repo_defined_api_with_code": [
            {
                "name":"makeIndexSetChangeset",
                "code":"func makeIndexSetChangeset(from other: Self) -> IndexSetChangeset {\n    let indexChangeset = makeChangeset(from: other)\n\n    return IndexSetChangeset(\n      inserts: .init(indexChangeset.inserts),\n      deletes: .init(indexChangeset.deletes),\n      updates: indexChangeset.updates,\n      moves: indexChangeset.moves,\n      newIndices: indexChangeset.newIndices,\n      duplicates: indexChangeset.duplicates.map { .init($0) })\n  }"
            },
            {
                "name": "toItems.makeIndexPathChangeset",
                "code":"func makeIndexPathChangeset(\n    from other: Self,\n    fromSection: Int = 0,\n    toSection: Int = 0)\n    -> IndexPathChangeset\n  {\n    let indexChangeset = makeChangeset(from: other)\n\n    return IndexPathChangeset(\n      inserts: indexChangeset.inserts.map { index in\n        [toSection, index]\n      },\n      deletes: indexChangeset.deletes.map { index in\n        [fromSection, index]\n      },\n      updates: indexChangeset.updates.map { fromIndex, toIndex in\n        ([fromSection, fromIndex], [toSection, toIndex])\n      },\n      moves: indexChangeset.moves.map { fromIndex, toIndex in\n        ([fromSection, fromIndex], [toSection, toIndex])\n      },\n      duplicates: indexChangeset.duplicates.map { duplicate in\n        duplicate.map { index in\n          [toSection, index]\n        }\n      })\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "airbnb/lottie-ios",
        "function_declaration": "  static func swiftUIView(\n    content: Content,\n    style: Style,\n    behaviors: Behaviors? = nil)\n    -> SwiftUIView<Self, (content: Content, style: Style)>",
        "start_line": "26",
        "end_line": "51",
        "file_path": "Sources/Private/EmbeddedLibraries/EpoxyCore/SwiftUI/EpoxyableView+SwiftUIView.swift",
        "docstring": "The static function swiftUIView(content:style:behaviors:) creates and configures a SwiftUIView instance with given content, style, and optional behaviors. It ensures the view updates appropriately when style or content changes, recreating the view if the style changes and updating the content if it changes, while also setting the behaviors.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0f976a79914e",
        "ground_truth": "static func swiftUIView(\n  content: Content,\n  style: Style,\n  behaviors: Behaviors? = nil)\n  -> SwiftUIView<Self, (content: Content, style: Style)>\n{\n  SwiftUIView(storage: (content: content, style: style)) {\n    let view = Self(style: style)\n    view.setContent(content, animated: false)\n    return view\n  }\n  .configure { context in\n    // We need to create a new view instance when the style changes.\n    if context.oldStorage.style != style {\n      context.view = Self(style: style)\n      context.view.setContent(content, animated: context.animated)\n    }\n    // Otherwise, if the just the content changes, we need to update it.\n    else if context.oldStorage.content != content {\n      context.view.setContent(content, animated: context.animated)\n      context.container.invalidateIntrinsicContentSize()\n    }\n    context.view.setBehaviors(behaviors)\n  }\n}",
        "import_statements": [
            "import SwiftUI\n"
        ],
        "reference_api": ["SwiftUIView","setContent","invalidateIntrinsicContentSize","setBehaviors"],
        "repo_defined_api_with_code": [
            {
                "name":"invalidateIntrinsicContentSize",
                "code":"override func invalidateIntrinsicContentSize() {\n    super.invalidateIntrinsicContentSize()\n\n    // Invalidate the resolved strategy in case it changes with the re-measurement as it relies on\n    // the intrinsic size.\n    _resolvedStrategy = nil\n    _measuredFittingSize = nil\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "public func data(with image: KFCrossPlatformImage, original: Data?) -> Data? ",
        "start_line": "104",
        "end_line": "117",
        "file_path": "Sources/Cache/CacheSerializer.swift",
        "docstring": "The function data(with image: KFCrossPlatformImage, original: Data?) -> Data? returns either the original data if preferCacheOriginalData is true and original data is available, or it generates new data from the image using specified format and compression quality.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0f8186f7bc62",
        "ground_truth": "public func data(with image: KFCrossPlatformImage, original: Data?) -> Data? {\n    if preferCacheOriginalData {\n        return original ??\n            image.kf.data(\n                format: original?.kf.imageFormat ?? .unknown,\n                compressionQuality: compressionQuality\n            )\n    } else {\n        return image.kf.data(\n            format: original?.kf.imageFormat ?? .unknown,\n            compressionQuality: compressionQuality\n        )\n    }\n}",
        "import_statements": [
            "import Foundation",
            "import CoreGraphics",
            "import AppKit",
            "import UIKit"
        ],
        "reference_api": [
            "image.kf.data"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "private func prepareDirectory() throws ",
        "start_line": "119",
        "end_line": "134",
        "file_path": "Sources/Cache/DiskStorage.swift",
        "docstring": "The private function prepareDirectory() checks if a directory exists at a specified path using a file manager. If the directory does not exist, it attempts to create it with intermediate directories. If creation fails, it sets storageReady to false and throws a cacheError with details about the failure.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "67c8f8eab9bb",
        "ground_truth": "private func prepareDirectory() throws {\n    let fileManager = config.fileManager\n    let path = directoryURL.path\n    guard !fileManager.fileExists(atPath: path) else { return }\n    do {\n        try fileManager.createDirectory(\n            atPath: path,\n            withIntermediateDirectories: true,\n            attributes: nil)\n    } catch {\n        self.storageReady = false\n        throw KingfisherError.cacheError(reason: .cannotCreateDirectory(path: path, error: error))\n    }\n}",
        "import_statements": [
            "import Foundation"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "func removeAll(skipCreatingDirectory: Bool) throws",
        "start_line": "326",
        "end_line": "331",
        "file_path": "Sources/Cache/DiskStorage.swift",
        "docstring": "The function removeAll(skipCreatingDirectory: Bool) throws deletes the directory at directoryURL using config.fileManager. If skipCreatingDirectory is false, it attempts to recreate the directory by calling prepareDirectory().\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8718cce2e11d",
        "ground_truth": "func removeAll(skipCreatingDirectory: Bool) throws {\n    try config.fileManager.removeItem(at: directoryURL)\n    if !skipCreatingDirectory {\n        try prepareDirectory()\n    }\n}",
        "import_statements": [
            "import Foundation"
        ],
        "reference_api": [
            "config.fileManager.removeItem",
            "prepareDirectory"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"prepareDirectory",
                "code":"private func prepareDirectory() throws {\n            let fileManager = config.fileManager\n            let path = directoryURL.path\n\n            guard !fileManager.fileExists(atPath: path) else { return }\n\n            do {\n                try fileManager.createDirectory(\n                    atPath: path,\n                    withIntermediateDirectories: true,\n                    attributes: nil)\n            } catch {\n                self.storageReady = false\n                throw KingfisherError.cacheError(reason: .cannotCreateDirectory(path: path, error: error))\n            }\n        }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "func removeExpiredValues(referenceDate: Date) throws -> [URL]",
        "start_line": "386",
        "end_line": "409",
        "file_path": "Sources/Cache/DiskStorage.swift",
        "docstring": "The function removeExpiredValues(referenceDate: Date) throws -> [URL] retrieves all file URLs with specific properties, filters out directories, and identifies files that have expired based on the referenceDate. It then deletes these expired files and returns their URLs.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4a5258f81092",
        "ground_truth": "func removeExpiredValues(referenceDate: Date) throws -> [URL] {\n    let propertyKeys: [URLResourceKey] = [\n        .isDirectoryKey,\n        .contentModificationDateKey\n    ]\n    let urls = try allFileURLs(for: propertyKeys)\n    let keys = Set(propertyKeys)\n    let expiredFiles = urls.filter { fileURL in\n        do {\n            let meta = try FileMeta(fileURL: fileURL, resourceKeys: keys)\n            if meta.isDirectory {\n                return false\n            }\n            return meta.expired(referenceDate: referenceDate)\n        } catch {\n            return true\n        }\n    }\n    try expiredFiles.forEach { url in\n        try removeFile(at: url)\n    }\n    return expiredFiles\n}",
        "import_statements": [
            "import Foundation"
        ],
        "reference_api": [
            "allFileURLs",
            "FileMeta",
            "meta.expired",
            "removeFile"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"allFileURLs",
                "code":"func allFileURLs(for propertyKeys: [URLResourceKey]) throws -> [URL] {\n            let fileManager = config.fileManager\n\n            guard let directoryEnumerator = fileManager.enumerator(\n                at: directoryURL, includingPropertiesForKeys: propertyKeys, options: .skipsHiddenFiles) else\n            {\n                throw KingfisherError.cacheError(reason: .fileEnumeratorCreationFailed(url: directoryURL))\n            }\n\n            guard let urls = directoryEnumerator.allObjects as? [URL] else {\n                throw KingfisherError.cacheError(reason: .invalidFileEnumeratorContent(url: directoryURL))\n            }\n            return urls\n        }"
            },
            {
                "name":"removeFile",
                "code":"func removeFile(at url: URL) throws {\n            try config.fileManager.removeItem(at: url)\n        }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "var localFileCacheKey: String",
        "start_line": "113",
        "end_line": "127",
        "file_path": "Sources/General/ImageSource/Resource.swift",
        "docstring": "The computed property localFileCacheKey constructs a cache key from pathComponents. It collects components in reverse order until encountering a component ending with .app or .appex, then reverses them back and joins with a prefix. If a query exists, it appends it to the path; otherwise, it returns the path as is.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6e9ee5b74a28",
        "ground_truth": "var localFileCacheKey: String {\n    var validComponents: [String] = []\n    for part in pathComponents.reversed() {\n        validComponents.append(part)\n        if part.hasSuffix(\".app\") || part.hasSuffix(\".appex\") {\n            break\n        }\n    }\n    let fixedPath = \"\\(Self.localFileCacheKeyPrefix)/\\(validComponents.reversed().joined(separator: \"/\"))\"\n    if let q = query {\n        return \"\\(fixedPath)?\\(q)\"\n    } else {\n        return fixedPath\n    }\n}",
        "import_statements": [
            "pathComponents.reversed",
            "hasSuffix"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "public static func getFrameDuration(from gifInfo: [String: Any]?) -> TimeInterval ",
        "start_line": "107",
        "end_line": "117",
        "file_path": "Sources/Image/GIFAnimatedImage.swift",
        "docstring": "The function getFrameDuration(from gifInfo: [String: Any]?) -> TimeInterval returns the frame duration of a GIF. It uses a default value of 0.1 if gifInfo is nil. It checks for unclamped and clamped delay times in gifInfo, and returns the duration if it's greater than 0.011 seconds, otherwise it returns the default value.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fc0904041eda",
        "ground_truth": "public static func getFrameDuration(from gifInfo: [String: Any]?) -> TimeInterval {\n    let defaultFrameDuration = 0.1\n    guard let gifInfo = gifInfo else { return defaultFrameDuration }\n         let unclampedDelayTime = gifInfo[kCGImagePropertyGIFUnclampedDelayTime as String] as? NSNumber\n    let delayTime = gifInfo[kCGImagePropertyGIFDelayTime as String] as? NSNumber\n    let duration = unclampedDelayTime ?? delayTime\n         guard let frameDuration = duration else { return defaultFrameDuration }\n    return frameDuration.doubleValue > 0.011 ? frameDuration.doubleValue : defaultFrameDuration\n}",
        "import_statements": [
            "import Foundation",
            "import ImageIO"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "public var normalized: KFCrossPlatformImage",
        "start_line": "152",
        "end_line": "162",
        "file_path": "Sources/Image/Image.swift",
        "docstring": "The function normalized returns a KFCrossPlatformImage. If the image is animated (e.g., a GIF), it returns a copy of the base image. If the image orientation is already .up, it also returns a copy of the base image. Otherwise, it draws the image to a new size, inverting and fixing its orientation.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fd076233656a",
        "ground_truth": "public var normalized: KFCrossPlatformImage {\n    // prevent animated image (GIF) lose it's images\n    guard images == nil else { return base.copy() as! KFCrossPlatformImage }\n    // No need to do anything if already up\n    guard base.imageOrientation != .up else { return base.copy() as! KFCrossPlatformImage }\n    return draw(to: size, inverting: true, refImage: KFCrossPlatformImage()) {\n        fixOrientation(in: $0)\n        return true\n    }\n}",
        "import_statements": [],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "open func downloadImage(\n        with url: URL,\n        options: KingfisherParsedOptionsInfo,\n        completionHandler: (@Sendable (Result<ImageLoadingResult, KingfisherError>) -> Void)? = nil) -> DownloadTask",
        "start_line": "477",
        "end_line": "507",
        "file_path": "Sources/Networking/ImageDownloader.swift",
        "docstring": "The function downloadImage(with url: URL, options: KingfisherParsedOptionsInfo, completionHandler: ((Result<ImageLoadingResult, KingfisherError>) -> Void)? = nil) -> DownloadTask initializes a download task and creates a download context. If successful, it starts the actual download task, links it to the initial task, and triggers any request modifiers. If it fails, it executes the completion handler with an error on the specified callback queue.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "edd25f6a987a",
        "ground_truth": "open func downloadImage(\n    with url: URL,\n    options: KingfisherParsedOptionsInfo,\n    completionHandler: (@Sendable (Result<ImageLoadingResult, KingfisherError>) -> Void)? = nil) -> DownloadTask\n{\n    let downloadTask = DownloadTask()\n    createDownloadContext(with: url, options: options) { result in\n        switch result {\n        case .success(let context):\n            // `downloadTask` will be set if the downloading started immediately. This is the case when no request\n            // modifier or a sync modifier (`ImageDownloadRequestModifier`) is used. Otherwise, when an\n            // `AsyncImageDownloadRequestModifier` is used the returned `downloadTask` of this method will be `nil`\n            // and the actual \"delayed\" task is given in `AsyncImageDownloadRequestModifier.onDownloadTaskStarted`\n            // callback.\n            let actualDownloadTask = self.startDownloadTask(\n                context: context,\n                callback: self.createTaskCallback(completionHandler, options: options)\n            )\n            downloadTask.linkToTask(actualDownloadTask)\n            if let modifier = options.requestModifier {\n                modifier.onDownloadTaskStarted?(downloadTask)\n            }\n        case .failure(let error):\n            options.callbackQueue.execute {\n                completionHandler?(.failure(error))\n            }\n        }\n    }\n    return downloadTask\n}",
        "import_statements": [
            "import AppKit",
            "import UIKit"
        ],
        "reference_api": [
            "DownloadTask",
            "createDownloadContext",
            "startDownloadTask",
            "createTaskCallback",
            "linkToTask"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"createDownloadContext",
                "code":"private func createDownloadContext(\n        with url: URL,\n        options: KingfisherParsedOptionsInfo,\n        done: @escaping (@Sendable (Result<DownloadingContext, KingfisherError>) -> Void)\n    )\n    {\n        @Sendable func checkRequestAndDone(r: URLRequest) {\n            // There is a possibility that request modifier changed the url to `nil` or empty.\n            // In this case, throw an error.\n            guard let url = r.url, !url.absoluteString.isEmpty else {\n                done(.failure(KingfisherError.requestError(reason: .invalidURL(request: r))))\n                return\n            }\n            done(.success(DownloadingContext(url: url, request: r, options: options)))\n        }\n\n        // Creates default request.\n        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: downloadTimeout)\n        request.httpShouldUsePipelining = requestsUsePipelining\n        if #available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *) , options.lowDataModeSource != nil {\n            request.allowsConstrainedNetworkAccess = false\n        }\n        \n        guard let requestModifier = options.requestModifier else {\n            checkRequestAndDone(r: request)\n            return\n        }\n        \n        // Modifies request before sending.\n        // FIXME: A temporary solution for keep the sync `ImageDownloadRequestModifier` behavior as before.\n        // We should be able to combine two cases once the full async support can be introduced to Kingfisher.\n        if let m = requestModifier as? ImageDownloadRequestModifier {\n            guard let result = m.modified(for: request) else {\n                done(.failure(KingfisherError.requestError(reason: .emptyRequest)))\n                return\n            }\n            checkRequestAndDone(r: result)\n        } else  {\n            Task { [request] in\n                guard let result = await requestModifier.modified(for: request) else {\n                    done(.failure(KingfisherError.requestError(reason: .emptyRequest)))\n                    return\n                }\n                checkRequestAndDone(r: result)\n            }\n        }\n    }"
            },
            {
                "name":"startDownloadTask",
                "code":"private func startDownloadTask(\n        context: DownloadingContext,\n        callback: SessionDataTask.TaskCallback\n    ) -> DownloadTask\n    {\n        let downloadTask = addDownloadTask(context: context, callback: callback)\n\n        guard let sessionTask = downloadTask.sessionTask, !sessionTask.started else {\n            return downloadTask\n        }\n\n        sessionTask.onTaskDone.delegate(on: self) { (self, done) in\n            // Underlying downloading finishes.\n            // result: Result<(Data, URLResponse?)>, callbacks: [TaskCallback]\n            let (result, callbacks) = done\n\n            // Before processing the downloaded data.\n            self.reportDidDownloadImageData(result: result, url: context.url)\n\n            switch result {\n            // Download finished. Now process the data to an image.\n            case .success(let (data, response)):\n                let processor = ImageDataProcessor(\n                    data: data, callbacks: callbacks, processingQueue: context.options.processingQueue\n                )\n                processor.onImageProcessed.delegate(on: self) { (self, done) in\n                    // `onImageProcessed` will be called for `callbacks.count` times, with each\n                    // `SessionDataTask.TaskCallback` as the input parameter.\n                    // result: Result<Image>, callback: SessionDataTask.TaskCallback\n                    let (result, callback) = done\n\n                    self.reportDidProcessImage(result: result, url: context.url, response: response)\n\n                    let imageResult = result.map { ImageLoadingResult(image: $0, url: context.url, originalData: data) }\n                    let queue = callback.options.callbackQueue\n                    queue.execute { callback.onCompleted?.call(imageResult) }\n                }\n                processor.process()\n\n            case .failure(let error):\n                callbacks.forEach { callback in\n                    let queue = callback.options.callbackQueue\n                    queue.execute { callback.onCompleted?.call(.failure(error)) }\n                }\n            }\n        }\n\n        reportWillDownloadImage(url: context.url, request: context.request)\n        sessionTask.resume()\n        return downloadTask\n    }"
            },
            {
                "name":"createTaskCallback",
                "code":"private func createTaskCallback(\n        _ completionHandler: ((DownloadResult) -> Void)?,\n        options: KingfisherParsedOptionsInfo\n    ) -> SessionDataTask.TaskCallback\n    {\n        SessionDataTask.TaskCallback(\n            onCompleted: createCompletionCallBack(completionHandler),\n            options: options\n        )\n    }"
            },
            {
                "name":"linkToTask",
                "code":"func linkToTask(_ task: DownloadTask) {\n        self.sessionTask = task.sessionTask\n        self.cancelToken = task.cancelToken\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "onevcat/Kingfisher",
        "function_declaration": "private func renderedImage() -> some View ",
        "start_line": "92",
        "end_line": "102",
        "file_path": "Sources/SwiftUI/KFImageRenderer.swift",
        "docstring": "The function renderedImage() -> some View processes an image using configurations from context, starting with an initial image created from binder.loadedImage. It applies each configuration in context.configurations to the image. If context has a contentConfiguration, it applies this to the configured image; otherwise, it returns the configured image as is.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "878fab6f8a0b",
        "ground_truth": "private func renderedImage() -> some View {\n    let configuredImage = context.configurations\n        .reduce(HoldingView.created(from: binder.loadedImage, context: context)) {\n            current, config in config(current)\n        }\n    if let contentConfiguration = context.contentConfiguration {\n        contentConfiguration(configuredImage)\n    } else {\n        configuredImage\n    }\n}",
        "import_statements": [
            "import SwiftUI",
            "import Combine"
        ],
        "reference_api": [
            "contentConfiguration"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "override func apply(state: HeroTargetState)",
        "start_line": "345",
        "end_line": "357",
        "file_path": "Sources/Animator/HeroCoreAnimationViewContext.swift",
        "docstring": "The function apply(state: HeroTargetState) overrides a method to update the target state by iterating through targetState, initializing state values if nil, and performing animations by calling animate() with specific parameters, temporarily storing and restoring the animations list.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "698c06e63929",
        "ground_truth": "override func apply(state: HeroTargetState) {\n  let targetState = viewState(targetState: state)\n  for (key, targetValue) in targetState {\n    if self.state[key] == nil {\n      let current = currentValue(key: key)\n      self.state[key] = (current, current)\n    }\n    let oldAnimations = animations\n    animations = []\n    _ = animate(key: key, beginTime: 0, duration: 100, fromValue: targetValue, toValue: targetValue)\n    animations = oldAnimations\n  }\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "viewState",
            "currentValue",
            "animate"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"viewState",
                "code":"func viewState(targetState: HeroTargetState) -> [String: Any?] {\n    var targetState = targetState\n    var rtn = [String: Any?]()\n\n    if let size = targetState.size {\n      if targetState.useScaleBasedSizeChange ?? self.targetState.useScaleBasedSizeChange ?? false {\n        let currentSize = snapshot.bounds.size\n        targetState.append(.scale(x: size.width / currentSize.width,\n                                  y: size.height / currentSize.height))\n      } else {\n        rtn[\"bounds.size\"] = NSValue(cgSize: size)\n      }\n    }\n    if let position = targetState.position {\n      rtn[\"position\"] = NSValue(cgPoint: position)\n    }\n    if let opacity = targetState.opacity, !(snapshot is UIVisualEffectView) {\n      rtn[\"opacity\"] = NSNumber(value: opacity)\n    }\n    if let cornerRadius = targetState.cornerRadius {\n      rtn[\"cornerRadius\"] = NSNumber(value: cornerRadius.native)\n    }\n    if let backgroundColor = targetState.backgroundColor {\n      rtn[\"backgroundColor\"] = backgroundColor\n    }\n    if let zPosition = targetState.zPosition {\n      rtn[\"zPosition\"] = NSNumber(value: zPosition.native)\n    }\n    if let anchorPoint = targetState.anchorPoint {\n      rtn[\"anchorPoint\"] = NSValue(cgPoint: anchorPoint)\n    }\n\n    if let borderWidth = targetState.borderWidth {\n      rtn[\"borderWidth\"] = NSNumber(value: borderWidth.native)\n    }\n    if let borderColor = targetState.borderColor {\n      rtn[\"borderColor\"] = borderColor\n    }\n    if let masksToBounds = targetState.masksToBounds {\n      rtn[\"masksToBounds\"] = masksToBounds\n    }\n\n    if targetState.displayShadow {\n      if let shadowColor = targetState.shadowColor {\n        rtn[\"shadowColor\"] = shadowColor\n      }\n      if let shadowRadius = targetState.shadowRadius {\n        rtn[\"shadowRadius\"] = NSNumber(value: shadowRadius.native)\n      }\n      if let shadowOpacity = targetState.shadowOpacity {\n        rtn[\"shadowOpacity\"] = NSNumber(value: shadowOpacity)\n      }\n      if let shadowPath = targetState.shadowPath {\n        rtn[\"shadowPath\"] = shadowPath\n      }\n      if let shadowOffset = targetState.shadowOffset {\n        rtn[\"shadowOffset\"] = NSValue(cgSize: shadowOffset)\n      }\n    }\n\n    if let contentsRect = targetState.contentsRect {\n      rtn[\"contentsRect\"] = NSValue(cgRect: contentsRect)\n    }\n\n    if let contentsScale = targetState.contentsScale {\n      rtn[\"contentsScale\"] = NSNumber(value: contentsScale.native)\n    }\n\n    if let transform = targetState.transform {\n      rtn[\"transform\"] = NSValue(caTransform3D: transform)\n    }\n\n    if let (color, opacity) = targetState.overlay {\n      rtn[\"overlay.backgroundColor\"] = color\n      rtn[\"overlay.opacity\"] = NSNumber(value: opacity.native)\n    }\n    return rtn\n  }"
            },
            {
                "name":"currentValue",
                "code":"func currentValue(key: String) -> Any? {\n    if let key = overlayKeyFor(key: key) {\n      return (overlayLayer?.presentation() ?? overlayLayer)?.value(forKeyPath: key)\n    }\n    if snapshot.layer.animationKeys()?.isEmpty != false {\n      return snapshot.layer.value(forKeyPath: key)\n    }\n    return (snapshot.layer.presentation() ?? snapshot.layer).value(forKeyPath: key)\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "public func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval",
        "start_line": "63",
        "end_line": "75",
        "file_path": "Sources/Animator/HeroDefaultAnimator.swift",
        "docstring": "The function resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval updates the duration of each viewContext based on the optimized duration or its own duration plus the time passed. It calls resume on each viewContext with the given timePassed and reverse parameters, and returns the maximum duration until all viewContexts have stopped.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "893b3bb18d25",
        "ground_truth": "public func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval {\n  var duration: TimeInterval = 0\n  for (_, viewContext) in viewContexts {\n    if viewContext.targetState.duration == nil {\n      viewContext.duration = max(viewContext.duration,\n                                 calculateOptimizedDuration(snapshot: viewContext.snapshot,\n                                                            targetState: viewContext.targetState) + timePassed)\n    }\n    let timeUntilStopped = viewContext.resume(timePassed: timePassed, reverse: reverse)\n    duration = max(duration, timeUntilStopped)\n  }\n  return duration\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "max",
            "calculateOptimizedDuration",
            "resume"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"calculateOptimizedDuration",
                "code":"func calculateOptimizedDuration(snapshot: UIView, targetState: HeroTargetState) -> TimeInterval {\n    return snapshot.optimizedDurationTo(position: targetState.position,\n                                        size: targetState.size,\n                                        transform: targetState.transform)\n  }"
            },
            {
                "name":"resume",
                "code":"public func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval {\n    var duration: TimeInterval = 0\n    for (_, viewContext) in viewContexts {\n      if viewContext.targetState.duration == nil {\n        viewContext.duration = max(viewContext.duration,\n                                   calculateOptimizedDuration(snapshot: viewContext.snapshot,\n                                                              targetState: viewContext.targetState) + timePassed)\n      }\n      let timeUntilStopped = viewContext.resume(timePassed: timePassed, reverse: reverse)\n      duration = max(duration, timeUntilStopped)\n    }\n    return duration\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "  override func startAnimations() -> TimeInterval",
        "start_line": "75",
        "end_line": "87",
        "file_path": "Sources/Animator/HeroViewPropertyViewContext.swift",
        "docstring": "The function startAnimations() -> TimeInterval overrides a method to initiate visual effect animations on a UIVisualEffectView. It determines the starting and ending effects based on the target state's opacity and whether the effect is appearing or disappearing. It creates and starts a UIViewPropertyAnimator with a linear animation curve, updating the visual effect. The function returns the animation duration.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d144ced05213",
        "ground_truth": "override func startAnimations() -> TimeInterval {\n  guard let visualEffectView = snapshot as? UIVisualEffectView else { return 0 }\n  let appearedEffect = visualEffectView.effect\n  let disappearedEffect = targetState.opacity == 0 ? nil : visualEffectView.effect\n  startEffect = appearing ? disappearedEffect : appearedEffect\n  endEffect = appearing ? appearedEffect : disappearedEffect\n  visualEffectView.effect = startEffect\n  viewPropertyAnimator = UIViewPropertyAnimator(duration: duration, curve: .linear) {\n    visualEffectView.effect = self.endEffect\n  }\n  viewPropertyAnimator.startAnimation()\n  return duration\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "UIViewPropertyAnimator"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "func flatTransformTo(layer: CALayer) -> CATransform3D",
        "start_line": "38",
        "end_line": "46",
        "file_path": "Sources/Extensions/CALayer+Hero.swift",
        "docstring": "The function flatTransformTo(layer: CALayer) -> CATransform3D calculates and returns the combined transform of a given layer and its superlayers up to a specified point, concatenating each superlayer's transform until it reaches the current layer, a UIWindow delegate, or a nil superlayer.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ad9611022a36",
        "ground_truth": "func flatTransformTo(layer: CALayer) -> CATransform3D {\n  var layer = layer\n  var trans = layer.transform\n  while let superlayer = layer.superlayer, superlayer != self, !(superlayer.delegate is UIWindow) {\n    trans = CATransform3DConcat(superlayer.transform, trans)\n    layer = superlayer\n  }\n  return trans\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "CATransform3DConcat"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "public func tokenize() -> [Token]",
        "start_line": "35",
        "end_line": "62",
        "file_path": "Sources/Parser/Lexer.swift",
        "docstring": "The function tokenize() -> [Token] processes the input string to generate a list of tokens. It iterates through the input, matching patterns from tokenList to generate tokens, and appends them to the tokens array. If no pattern matches, it adds a default token and continues processing the remaining input until it's empty, then returns the list of tokens.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c3c30f633484",
        "ground_truth": "public func tokenize() -> [Token] {\n  var tokens = [Token]()\n  var content = input\n  while !content.isEmpty {\n    var matched = false\n    for (pattern, generator) in tokenList {\n      if let (m, r) = content.match(regex: pattern) {\n        if let t = generator(m, r) {\n          tokens.append(t)\n        }\n        content = String(content[content.index(content.startIndex, offsetBy: m.count)...])\n        matched = true\n        break\n      }\n    }\n    if !matched {\n      let index = content.index(content.startIndex, offsetBy: 1)\n      let intIndex = content.distance(from: content.startIndex, to: index)\n      tokens.append(.other(String(content[..<index]), intIndex..<intIndex+1))\n      content = String(content[index...])\n    }\n  }\n  return tokens\n}",
        "import_statements": [
            "import Foundation\n"
        ],
        "reference_api": [
            "match",
            "generator",
            "distance"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "func parseBinaryOp(node: ExprNode, exprPrecedence: Int = 0) throws -> ExprNode",
        "start_line": "134",
        "end_line": "154",
        "file_path": "Sources/Parser/Parser.swift",
        "docstring": "The function parseBinaryOp(node: ExprNode, exprPrecedence: Int = 0) throws -> ExprNode parses a binary operation expression. It iterates through tokens, comparing their precedence to the current expression precedence. If the token has lower precedence, it returns the left-hand side node. Otherwise, it pops the current token, parses the right-hand side expression, and compares the next token's precedence. If necessary, it recursively parses the right-hand side with increased precedence. Finally, it constructs and updates the left-hand side node as a BinaryOpNode with the operator and parsed nodes.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c3b9f98b1ab8",
        "ground_truth": "func parseBinaryOp(node: ExprNode, exprPrecedence: Int = 0) throws -> ExprNode {\n  var lhs = node\n  while true {\n    let tokenPrecedence = try getCurrentTokenPrecedence()\n    if tokenPrecedence < exprPrecedence {\n      return lhs\n    }\n    guard case let .other(op, _) = popCurrentToken() else {\n      throw ParseError.unexpectToken\n    }\n    var rhs = try parsePrimary()\n    let nextPrecedence = try getCurrentTokenPrecedence()\n    if tokenPrecedence < nextPrecedence {\n      rhs = try parseBinaryOp(node: rhs, exprPrecedence: tokenPrecedence+1)\n    }\n    lhs = BinaryOpNode(name: op, lhs: lhs, rhs: rhs)\n  }\n}",
        "import_statements": [
            "import Foundation\n"
        ],
        "reference_api": [
            "getCurrentTokenPrecedence",
            "popCurrentToken",
            "parsePrimary",
            "parseBinaryOp",
            "BinaryOpNode"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"getCurrentTokenPrecedence",
                "code":"func getCurrentTokenPrecedence() throws -> Int {\n    guard index < tokens.count else {\n      return -1\n    }\n\n    guard case let .other(op, _) = peekCurrentToken() else {\n      return -1\n    }\n\n    guard let precedence = operatorPrecedence[op] else {\n      throw ParseError.undefinedOperator(op)\n    }\n\n    return precedence\n  }"
            },
            {
                "name":"popCurrentToken",
                "code":"func popCurrentToken() -> Token {\n    defer { index += 1 }\n    return tokens[index]\n  }"
            },
            {
                "name":"parsePrimary",
                "code":"func parsePrimary() throws -> ExprNode {\n    switch peekCurrentToken() {\n    case .identifier:\n      return try parseIdentifier()\n    case .number:\n      return try parseNumber()\n    case .parensOpen:\n      return try parseParens()\n    default:\n      throw ParseError.expectExpression\n    }\n  }"
            },
            {
                "name":"parseBinaryOp",
                "code":"func parseBinaryOp(node: ExprNode, exprPrecedence: Int = 0) throws -> ExprNode {\n    var lhs = node\n    while true {\n      let tokenPrecedence = try getCurrentTokenPrecedence()\n      if tokenPrecedence < exprPrecedence {\n        return lhs\n      }\n\n      guard case let .other(op, _) = popCurrentToken() else {\n        throw ParseError.unexpectToken\n      }\n\n      var rhs = try parsePrimary()\n      let nextPrecedence = try getCurrentTokenPrecedence()\n\n      if tokenPrecedence < nextPrecedence {\n        rhs = try parseBinaryOp(node: rhs, exprPrecedence: tokenPrecedence+1)\n      }\n      lhs = BinaryOpNode(name: op, lhs: lhs, rhs: rhs)\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "func match(regex: String) -> (String, CountableRange<Int>)? ",
        "start_line": "13",
        "end_line": "31",
        "file_path": "Sources/Parser/Regex.swift",
        "docstring": "The function match(regex: String) -> (String, CountableRange<Int>)? checks if a given regex pattern exists in a cached dictionary of NSRegularExpression objects. If not, it compiles the regex and caches it. It then searches for the pattern at the beginning of the string and returns the matched substring and its range if found, otherwise returns nil.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "fd96fe6ea2a6",
        "ground_truth": "func match(regex: String) -> (String, CountableRange<Int>)? {\n  let expression: NSRegularExpression\n  if let exists = expressions[regex] {\n    expression = exists\n  } else {\n    do {\n      expression = try NSRegularExpression(pattern: \"^\\(regex)\", options: [])\n      expressions[regex] = expression\n    } catch {\n      return nil\n    }\n  }\n  let range = expression.rangeOfFirstMatch(in: self, options: [], range: NSRange(0 ..< self.utf16.count))\n  if range.location != NSNotFound {\n    return ((self as NSString).substring(with: range), range.location ..< range.location + range.length )\n  }\n  return nil\n}",
        "import_statements": [
            "import Foundation\n"
        ],
        "reference_api": [
            "NSRegularExpression",
            "rangeOfFirstMatch"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "func process(views: [UIView])",
        "start_line": "33",
        "end_line": "49",
        "file_path": "Sources/Preprocessors/IgnoreSubviewModifiersPreprocessor.swift",
        "docstring": "The function process(views: [UIView]) iterates through an array of UIView objects. For each view, it checks a context dictionary for an ignoreSubviewModifiers flag. If the view is a UITableView, it sets the parentView to its first subview. Depending on the flag, it either calls cleanSubviewModifiers on the parentView or clears the context for each of its subviews.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "90e4632493f5",
        "ground_truth": "func process(views: [UIView]) {\n  for view in views {\n    guard let recursive = context[view]?.ignoreSubviewModifiers else { continue }\n    var parentView = view\n    if view is UITableView, let wrapperView = view.subviews.get(0) {\n      parentView = wrapperView\n    }\n    if recursive {\n      cleanSubviewModifiers(parentView)\n    } else {\n      for subview in parentView.subviews {\n        context[subview] = nil\n      }\n    }\n  }\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "cleanSubviewModifiers"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"cleanSubviewModifiers",
                "code":"private func cleanSubviewModifiers(_ parentView: UIView) {\n    for view in parentView.subviews {\n      context[view] = nil\n      cleanSubviewModifiers(view)\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "HeroTransitions/Hero",
        "function_declaration": "public func cancel(animate: Bool = true)",
        "start_line": "66",
        "end_line": "82",
        "file_path": "Sources/Transition/HeroTransition+Interactive.swift",
        "docstring": "The function cancel(animate: Bool = true) stops the animation process if the current state is .animating, .notified, or .starting. If animate is false, it completes immediately. Otherwise, it calculates the maximum remaining time for all animators, resumes them in reverse based on progress, and completes after the maximum time.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ccabb6085977",
        "ground_truth": "public func cancel(animate: Bool = true) {\n  guard state == .animating || state == .notified || state == .starting else { return }\n  if !animate {\n    self.complete(finished: false)\n    return\n  }\n  var maxTime: TimeInterval = 0\n  for animator in self.animators {\n    var adjustedProgress = self.progress\n    if adjustedProgress < 0 {\n      adjustedProgress = -adjustedProgress\n    }\n    maxTime = max(maxTime, animator.resume(timePassed: adjustedProgress * self.totalDuration,\n                                           reverse: true))\n  }\n  self.complete(after: maxTime, finishing: false)\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "self.complete",
            "max",
            "animator.resume"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"animator.resume",
                "code":"public func resume(timePassed: TimeInterval, reverse: Bool) -> TimeInterval {\n    var duration: TimeInterval = 0\n    for (_, viewContext) in viewContexts {\n      if viewContext.targetState.duration == nil {\n        viewContext.duration = max(viewContext.duration,\n                                   calculateOptimizedDuration(snapshot: viewContext.snapshot,\n                                                              targetState: viewContext.targetState) + timePassed)\n      }\n      let timeUntilStopped = viewContext.resume(timePassed: timePassed, reverse: reverse)\n      duration = max(duration, timeUntilStopped)\n    }\n    return duration\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "dotnet/maui",
        "function_declaration": "public override bool OnCreateWindow(Android.Webkit.WebView? view, bool isDialog, bool isUserGesture, Message? resultMsg)",
        "start_line": "17",
        "end_line": "30",
        "file_path": "src/BlazorWebView/src/Maui/Android/BlazorWebChromeClient.cs",
        "docstring": "The function OnCreateWindow(Android.Webkit.WebView? view, bool isDialog, bool isUserGesture, Message? resultMsg) overrides a method to handle new window requests in a WebView. It retrieves the URL from the hit test result of the view, creates an intent to open this URL in an external browser, and starts the activity using the view's context. It always returns false, indicating that a new WebView window should not be created.\\n",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2a58ee5bb252",
        "ground_truth": "public override bool OnCreateWindow(Android.Webkit.WebView? view, bool isDialog, bool isUserGesture, Message? resultMsg)\n{\n if (view?.Context is not null)\n {\n  // Intercept _blank target <a> tags to always open in device browser\n  // regardless of UrlLoadingStrategy.OpenInWebview\n  var requestUrl = view.GetHitTestResult().Extra;\n  var intent = new Intent(Intent.ActionView, Uri.Parse(requestUrl));\n  view.Context.StartActivity(intent);\n }\n // We don't actually want to create a new WebView window so we just return false \n return false;\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using System.Linq",
            "using System.Threading.Tasks",
            "using Android.Content",
            "using Android.Net",
            "using Android.OS",
            "using Android.Webkit",
            "using Microsoft.Maui",
            "using Microsoft.Maui.Devices",
            "using Microsoft.Maui.Storage",
            "using File = Java.IO.File"
        ],
        "reference_api": [
            "view.GetHitTestResult",
            "view.Context.StartActivity",
            "Uri.Parse"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "view.GetHitTestResult",
            "view.Context.StartActivity",
            "Uri.Parse"
        ]
    },
    {
        "subclass": "IOS",
        "owner/repo": "dotnet/maui",
        "function_declaration": "private static PickOptions? GetPickOptions(FileChooserParams? fileChooserParams)",
        "start_line": "78",
        "end_line": "97",
        "file_path": "src/BlazorWebView/src/Maui/Android/BlazorWebChromeClient.cs",
        "docstring": "The function GetPickOptions(FileChooserParams? fileChooserParams) returns a PickOptions object if acceptedFileTypes from fileChooserParams are valid. It checks if acceptedFileTypes is null or empty, returning null if true. Otherwise, it initializes PickOptions with FileTypes set to acceptedFileTypes for the Android platform and returns it.\\n",
        "language": "CSharp",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "16ba78b0f496",
        "ground_truth": "private static PickOptions? GetPickOptions(FileChooserParams? fileChooserParams)\n{\n var acceptedFileTypes = fileChooserParams?.GetAcceptTypes();\n if (acceptedFileTypes is null ||\n  // When the accept attribute isn't provided GetAcceptTypes returns: [ \"\" ]\n  // this must be filtered out.\n  (acceptedFileTypes.Length == 1 && string.IsNullOrEmpty(acceptedFileTypes[0])))\n {\n  return null;\n }\n var pickOptions = new PickOptions()\n {\n  FileTypes = new FilePickerFileType(new Dictionary<DevicePlatform, IEnumerable<string>>\n  {\n   { DevicePlatform.Android, acceptedFileTypes }\n  })\n };\n return pickOptions;\n}",
        "import_statements": [
            "using System.Collections.Generic",
            "using System.Linq",
            "using System.Threading.Tasks",
            "using Android.Content",
            "using Android.Net",
            "using Android.OS",
            "using Android.Webkit",
            "using Microsoft.Maui",
            "using Microsoft.Maui.Devices",
            "using Microsoft.Maui.Storage",
            "using File = Java.IO.File"
        ],
        "reference_api": [
            "fileChooserParams?.GetAcceptTypes",
            "string.IsNullOrEmpty"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "fileChooserParams?.GetAcceptTypes",
            "string.IsNullOrEmpty"
        ]
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "func makeBody(configuration: Configuration) -> some View ",
        "start_line": "30",
        "end_line": "54",
        "file_path": "CodeEdit/Features/About/Views/BlurButtonStyle.swift",
        "docstring": "The function makeBody(configuration: Configuration) -> some View constructs a button view with specific styling. It sets the frame height and button style, then applies a background color based on the colorScheme (dark or light) with various overlays and blend modes. It also adjusts the overlay opacity when the button is pressed and clips the shape to a rounded rectangle with a corner radius of 6.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "852891893a00",
        "ground_truth": "func makeBody(configuration: Configuration) -> some View {\n    configuration.label\n        .frame(height: height)\n        .buttonStyle(.bordered)\n        .background {\n            switch colorScheme {\n            case .dark:\n                Color\n                    .gray\n                    .opacity(0.001)\n                    .overlay(.regularMaterial.blendMode(.plusLighter))\n                    .overlay(Color.gray.opacity(0.30))\n                    .overlay(Color.white.opacity(configuration.isPressed ? 0.20 : 0.00))\n            case .light:\n                Color\n                    .gray\n                    .opacity(0.001)\n                    .overlay(.regularMaterial.blendMode(.darken))\n                    .overlay(Color.gray.opacity(0.15).blendMode(.plusDarker))\n            @unknown default:\n                Color.black\n            }\n        }\n        .clipShape(RoundedRectangle(cornerRadius: 6))\n}",
        "import_statements": [
            "import SwiftUI"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func createTask(task: [AnyHashable: Any])",
        "start_line": "151",
        "end_line": "171",
        "file_path": "CodeEdit/Features/ActivityViewer/TaskNotificationHandler.swift",
        "docstring": "The function createTask(task: [AnyHashable: Any]) checks for required keys (title, id, action) in the task dictionary and initializes a TaskNotificationModel with optional message, percentage, and isLoading values. Depending on the action value, it either appends or inserts the task into the notifications array.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f2a51642b62c",
        "ground_truth": "private func createTask(task: [AnyHashable: Any]) {\n    guard let title = task[\"title\"] as? String,\n          let id = task[\"id\"] as? String,\n          let action = task[\"action\"] as? String else {\n        return\n    }\n    let task = TaskNotificationModel(\n        id: id,\n        title: title,\n        message: task[\"message\"] as? String,\n        percentage: task[\"percentage\"] as? Double,\n        isLoading: task[\"isLoading\"] as? Bool ?? false\n    )\n    if action == \"create\" {\n        notifications.append(task)\n    } else {\n        notifications.insert(task, at: 0)\n    }\n}",
        "import_statements": [
            "import Foundation",
            "import Combine"
        ],
        "reference_api": [
            "TaskNotificationModel"

        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "public func duplicate(file: CEWorkspaceFile)",
        "start_line": "136",
        "end_line": "154",
        "file_path": "CodeEdit/Features/CEWorkspace/Models/CEWorkspaceFileManager+FileManagement.swift",
        "docstring": "The function duplicate(file: CEWorkspaceFile) creates a copy of the specified file. It modifies the file name by appending \"copy\" until a unique name is found, then copies the file to the new location. If the file already exists at the original path, it performs the copy operation, and in case of an error, it triggers a fatal error with the error's description.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c0e9bfe1a2e4",
        "ground_truth": "public func duplicate(file: CEWorkspaceFile) {\n    // If a file/folder with the same name exists, add \"copy\" to the end\n    var fileUrl = file.url\n    while fileManager.fileExists(atPath: fileUrl.path) {\n        let previousName = fileUrl.lastPathComponent\n        let fileExtension = fileUrl.pathExtension.isEmpty ? \"\" : \".\\(fileUrl.pathExtension)\"\n        let fileName = fileExtension.isEmpty ? previousName :\n        previousName.replacingOccurrences(of: fileExtension, with: \"\")\n        fileUrl = fileUrl.deletingLastPathComponent().appendingPathComponent(\"\\(fileName) copy\\(fileExtension)\")\n    }\n    if fileManager.fileExists(atPath: file.url.path) {\n        do {\n            try fileManager.copyItem(at: file.url, to: fileUrl)\n        } catch {\n            fatalError(error.localizedDescription)\n        }\n    }\n}",
        "import_statements": [
            "import Foundation",
            "import AppKit"
        ],
        "reference_api": [
            "fileExists",
            "replacingOccurrences",
            "deletingLastPathComponent",
            "appendingPathComponent",
            "fatalError"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func savePreferences(_ data: CEWorkspaceSettingsData) throws ",
        "start_line": "57",
        "end_line": "71",
        "file_path": "CodeEdit/Features/CEWorkspace/Models/CEWorkspaceSettings.swift",
        "docstring": "The function savePreferences(_ data: CEWorkspaceSettingsData) throws saves user settings if they are not empty. It ensures the folder exists, creates it if necessary, encodes the data to JSON, formats it to pretty-printed JSON, and writes it to settingsURL using atomic write options.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4cc8acdd5494",
        "ground_truth": "private func savePreferences(_ data: CEWorkspaceSettingsData) throws {\n    // If the user doesn't have any settings to save, don't save them.\n    guard !data.isEmpty() else { return }\n    guard let folderURL, let settingsURL else { return }\n    if !fileManager.fileExists(atPath: folderURL.path()) {\n        try fileManager.createDirectory(at: folderURL, withIntermediateDirectories: true)\n    }\n    let data = try JSONEncoder().encode(data)\n    let json = try JSONSerialization.jsonObject(with: data)\n    let prettyJSON = try JSONSerialization.data(withJSONObject: json, options: [.prettyPrinted])\n    try prettyJSON.write(to: settingsURL, options: .atomic)\n}",
        "import_statements": [
            "import SwiftUI",
            "import Combine"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "func iconsView(size: CGSize) -> some View",
        "start_line": "73",
        "end_line": "91",
        "file_path": "CodeEdit/Features/CodeEditUI/Views/AreaTabBar.swift",
        "docstring": "The function iconsView(size: CGSize) -> some View creates a view with icons arranged in either a horizontal or vertical layout based on the position property. It iterates through items, generating icons with offsets and background geometry readers, and applies drag gestures. If the position is set to .side, a spacer is added at the end.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "88e40db30749",
        "ground_truth": "func iconsView(size: CGSize) -> some View {\n    let layout = position == .top\n        ? AnyLayout(HStackLayout(spacing: 0))\n        : AnyLayout(VStackLayout(spacing: 0))\n    layout {\n        ForEach(items) { tab in\n            makeIcon(tab: tab, size: size)\n                .offset(\n                    x: (position == .top) ? (tabOffsets[tab] ?? 0) : 0,\n                    y: (position == .side) ? (tabOffsets[tab] ?? 0) : 0\n                )\n                .background(makeTabItemGeometryReader(tab: tab))\n                .simultaneousGesture(makeAreaTabDragGesture(tab: tab))\n        }\n        if position == .side {\n            Spacer()\n        }\n    }\n}",
        "import_statements": [
            "import SwiftUI"
        ],
        "reference_api": [
            "AnyLayout",
            "HStackLayout",
            "VStackLayout",
            "makeIcon",
            "Spacer"
        ],
        "repo_defined_api_with_code": [
            {"name":"makeIcon",
            "code":"private func makeIcon(\n        tab: Tab,\n        scale: Image.Scale = .medium,\n        size: CGSize\n    ) -> some View {\n        Button {\n            selection = tab\n        } label: {\n            getSafeImage(named: tab.systemImage, accessibilityDescription: tab.title)\n                .font(.system(size: 12.5))\n                .symbolVariant(tab == selection ? .fill : .none)\n                .help(tab.title)\n        }\n        .buttonStyle(\n            .icon(\n                isActive: tab == selection,\n                size: CGSize(\n                    width: position == .side ? 40 : 24,\n                    height: position == .side ? 28 : size.height\n                )\n            )\n        )\n        .focusable(false)\n        .accessibilityIdentifier(\"TabAreaTab-\\(tab.title)\")\n        .accessibilityLabel(tab.title)\n    }"
        }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "public func selectionBackground(\n        _ isFocused: Bool = false\n    ) -> some View",
        "start_line": "57",
        "end_line": "77",
        "file_path": "CodeEdit/Features/CodeEditUI/Views/PaneTextField.swift",
        "docstring": "The function selectionBackground(_ isFocused: Bool = false) -> some View determines the background color for a selection based on the control's active state, whether the text is empty, and if it has value. It returns different colors depending on the focus state and the current color scheme.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8b44f4f38fe7",
        "ground_truth": "public func selectionBackground(\n    _ isFocused: Bool = false\n) -> some View {\n    if self.controlActive != .inactive || !text.isEmpty || hasValue {\n        if isFocused || !text.isEmpty || hasValue {\n            Color(.textBackgroundColor)\n        } else {\n            if colorScheme == .light {\n                Color.black.opacity(0.06)\n            } else {\n                Color.white.opacity(0.24)\n            }\n        }\n    } else {\n        if colorScheme == .light {\n            Color.clear\n        } else {\n            Color.white.opacity(0.14)\n        }\n    }\n}",
        "import_statements": [
            "import SwiftUI",
            "import Combine"
        ],
        "reference_api": [
            "Color.black.opacity",
            "Color.white.opacity"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "Color.black.opacity",
            "Color.white.opacity"
        ]
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func calculateContentOffset",
        "start_line": "91",
        "end_line": "100",
        "file_path": "CodeEdit/Features/CodeEditUI/Views/TrackableScrollView.swift",
        "docstring": "The function calculateContentOffset(fromOutsideProxy: GeometryProxy, insideProxy: GeometryProxy) -> CGFloat computes the content offset between two geometry proxies. It returns the vertical offset if axes is set to .vertical, and the horizontal offset otherwise.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c72c9ce81793",
        "ground_truth": "private func calculateContentOffset(\n    fromOutsideProxy outsideProxy: GeometryProxy,\n    insideProxy: GeometryProxy\n) -> CGFloat {\n    if axes == .vertical {\n        return insideProxy.frame(in: .global).minY - outsideProxy.frame(in: .global).minY\n    } else {\n        return insideProxy.frame(in: .global).minX - outsideProxy.frame(in: .global).minX\n    }\n}",
        "import_statements": [
            "import SwiftUI"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "override func removeDocument(_ document: NSDocument)",
        "start_line": "79",
        "end_line": "93",
        "file_path": "CodeEdit/Features/Documents/Controllers/CodeEditDocumentController.swift",
        "docstring": "The function removeDocument(_ document: NSDocument) overrides the superclass method to remove a document. After removal, if there are no remaining documents, it checks the user settings and either opens the welcome window, quits the application, or does nothing based on the specified reopenWindowAfterClose preference.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "dc3a6b5f0cc1",
        "ground_truth": "override func removeDocument(_ document: NSDocument) {\n    super.removeDocument(document)\n    if CodeEditDocumentController.shared.documents.isEmpty {\n        switch Settings[\\.general].reopenWindowAfterClose {\n        case .showWelcomeWindow:\n            // Opens the welcome window\n            openWindow(sceneID: .welcome)\n        case .quit:\n            // Quits CodeEdit\n            NSApplication.shared.terminate(nil)\n        case .doNothing: break\n        }\n    }\n}",
        "import_statements": [
            "import Cocoa",
            "import SwiftUI"
        ],
        "reference_api": [
            "super.removeDocument",
            "openWindow",
            "NSApplication.shared.terminate"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"super.removeDocument",
                "code":"public func removeDocument(url: URL) -> Bool {\n        let document = SKDocumentCreateWithURL(url as CFURL).takeRetainedValue()\n        return self.remove(document: document)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "override func splitViewDidResizeSubviews(_ notification: Notification) ",
        "start_line": "171",
        "end_line": "184",
        "file_path": "CodeEdit/Features/Documents/Controllers/CodeEditSplitViewController.swift",
        "docstring": "The function splitViewDidResizeSubviews(_ notification: Notification) overrides a method to handle the resizing of subviews in a split view. It checks if the resized divider is the first one and, if so, retrieves the width of the first panel. If the width is greater than 0, it updates the workspace state with the new width.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b57ba902b808",
        "ground_truth": "override func splitViewDidResizeSubviews(_ notification: Notification) {\n    super.splitViewDidResizeSubviews(notification)\n    guard let resizedDivider = notification.userInfo?[\"NSSplitViewDividerIndex\"] as? Int else {\n        return\n    }\n\n    if resizedDivider == 0 {\n        let panel = splitView.subviews[0]\n        let width = panel.frame.size.width\n        if width > 0 {\n            workspace?.addToWorkspaceState(key: .splitViewWidth, value: width)\n        }\n    }\n}",
        "import_statements": [
            "import Cocoa",
            "import SwiftUI"
        ],
        "reference_api": [
            "super.splitViewDidResizeSubviews",
            "workspace.addToWorkspaceState"
        ],
        "repo_defined_api_with_code": [{
            "name":"workspace.addToWorkspaceState",
            "code":"func addToWorkspaceState(key: WorkspaceStateKey, value: Any?) {\n        if let value {\n            workspaceState.updateValue(value, forKey: key.rawValue)\n        } else {\n            workspaceState.removeValue(forKey: key.rawValue)\n        }\n    }"
        }],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "public func addFile(fileURL: URL, mimeType: String? = nil, canReplace: Bool = true) -> Bool",
        "start_line": "59",
        "end_line": "71",
        "file_path": "CodeEdit/Features/Documents/Indexer/SearchIndexer+Add.swift",
        "docstring": "The function addFile(fileURL: URL, mimeType: String? = nil, canReplace: Bool = true) -> Bool attempts to add a file to the index. It ensures the data extractor is loaded and the index is available, creates a document from the file URL, detects the mime type if not provided, and adds the document to the index, returning true on success.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "74f1c40d4d90",
        "ground_truth": "public func addFile(fileURL: URL, mimeType: String? = nil, canReplace: Bool = true) -> Bool {\n    guard self.dataExtractorLoaded,\n          let index = self.index,\n          let document = SKDocumentCreateWithURL(fileURL as CFURL) else {\n        return false\n    }\n    // Try to detect the mime type if it wasn't specified\n    let mime = mimeType ?? self.detectMimeType(fileURL)\n    return modifyIndexQueue.sync {\n        SKIndexAddDocument(index, document.takeRetainedValue(), mime as CFString?, canReplace)\n    }\n}",
        "import_statements": [
            "import Foundation"
        ],
        "reference_api": [
            "SKDocumentCreateWithURL",
            "self.detectMimeType",
            "SKIndexAddDocument",
            "document.takeRetainedValue"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"self.detectMimeType",
                "code":"func detectMimeType(_ url: URL) -> String? {\n        if let type = UTType(filenameExtension: url.pathExtension) {\n            if let mimeType = type.preferredMIMEType {\n                return mimeType\n            }\n        }\n        return nil\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "override func makeWindowControllers()",
        "start_line": "98",
        "end_line": "120",
        "file_path": "CodeEdit/Features/Documents/CodeFileDocument.swift",
        "docstring": "The function makeWindowControllers() overrides a method to create and configure a new NSWindow and its NSWindowController. It sets the window's properties, assigns a view to its contentView, and manages window positioning and autosaving based on the presence of a fileURL, centering the window if no saved frame exists.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "81863c764401",
        "ground_truth": "override func makeWindowControllers() {\n    let window = NSWindow(\n        contentRect: NSRect(x: 0, y: 0, width: 750, height: 800),\n        styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView],\n        backing: .buffered, defer: false\n    )\n    let windowController = NSWindowController(window: window)\n    if let fileURL {\n        windowController.shouldCascadeWindows = false\n        windowController.windowFrameAutosaveName = fileURL.path\n    }\n    addWindowController(windowController)\n    window.contentView = NSHostingView(rootView: SettingsInjector {\n        WindowCodeFileView(codeFile: self)\n    })\n    window.makeKeyAndOrderFront(nil)\n    if let fileURL, UserDefaults.standard.object(forKey: \"NSWindow Frame \\(fileURL.path)\") == nil {\n        window.center()\n    }\n}",
        "import_statements": [
            "import AppKit",
            "import Foundation",
            "import SwiftUI",
            "import UniformTypeIdentifiers",
            "import CodeEditSourceEditor",
            "import CodeEditTextView",
            "import CodeEditLanguages",
            "import Combine"
        ],
        "reference_api": [
            "NSWindow",
            "contentRect: NSRect",
            "NSWindowController",
            "addWindowController",
            "NSHostingView",
            "WindowCodeFileView",
            "makeKeyAndOrderFront"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "func getFileContent(from filePaths: [URL]) async -> [SearchIndexer.AsyncManager.TextFile]",
        "start_line": "93",
        "end_line": "103",
        "file_path": "CodeEdit/Features/Documents/WorkspaceDocument+Index.swift",
        "docstring": "The function getFileContent(from filePaths: [URL]) async -> [SearchIndexer.AsyncManager.TextFile] reads the content of files from the provided file paths. It returns an array of TextFile objects containing the standardized file URLs and their corresponding text content, skipping files that cannot be read.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2b78e1062d94",
        "ground_truth": "func getFileContent(from filePaths: [URL]) async -> [SearchIndexer.AsyncManager.TextFile] {\n    var textFiles = [SearchIndexer.AsyncManager.TextFile]()\n    for file in filePaths {\n        if let content = try? String(contentsOf: file) {\n            textFiles.append(\n                SearchIndexer.AsyncManager.TextFile(url: file.standardizedFileURL, text: content)\n            )\n        }\n    }\n    return textFiles\n}",
        "import_statements": [
            "import Foundation"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "override func makeWindowControllers()",
        "start_line": "77",
        "end_line": "107",
        "file_path": "CodeEdit/Features/Documents/WorkspaceDocument.swift",
        "docstring": "A new NSWindow is created with specified dimensions and style, then associated with a CodeEditWindowController along with the workspace and taskNotificationHandler. If a saved window size is available, it sets the window frame accordingly; otherwise, it sets a default frame and centers the window. Accessibility identifiers are set for the window, and the window controller is added to the workspace.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4008682d1843",
        "ground_truth": "override func makeWindowControllers() {\n    let window = NSWindow(\n        contentRect: NSRect(x: 0, y: 0, width: 1400, height: 900),\n        styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView],\n        backing: .buffered,\n        defer: false\n    )\n    // Note For anyone hoping to switch back to a Root-SwiftUI window:\n    // See Commit 0200c87 for more details and to see what was previously here.\n    // -----\n    // Setting the \"min size\" like this is hacky, but SwiftUI overrides the contentRect and\n    // any of the built-in window size functions & autosave stuff. So we have to set it like this.\n    // SwiftUI also ignores this value, so it just manages to set the initial window size. *Hopefully* this\n    // is fixed in the future.\n    // ----\n    let windowController = CodeEditWindowController(\n        window: window,\n        workspace: self,\n        taskNotificationHandler: taskNotificationHandler\n    )\n    if let rectString = getFromWorkspaceState(.workspaceWindowSize) as? String {\n        window.setFrame(NSRectFromString(rectString), display: true, animate: false)\n    } else {\n        window.setFrame(NSRect(x: 0, y: 0, width: 1400, height: 900), display: true, animate: false)\n        window.center()\n    }\n    self.addWindowController(windowController)\n}\n// MARK: Set Up Workspace",
        "import_statements": [
            "import AppKit",
            "import SwiftUI",
            "import Combine",
            "import Foundation",
            "import LanguageServerProtocol"
        ],
        "reference_api": [
            "CodeEditWindowController",
            "getFromWorkspaceState",
            "window.setFrame",
            "window.center()",
            "self.addWindowController"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"getFromWorkspaceState",
                "code":"func getFromWorkspaceState(_ key: WorkspaceStateKey) -> Any? {\n        return workspaceState[key.rawValue]\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func openFile(item: Tab) throws",
        "start_line": "208",
        "end_line": "222",
        "file_path": "CodeEdit/Features/Editor/Models/Editor.swift",
        "docstring": "The function openFile(item: Tab) throws attempts to open a file associated with a Tab item. If the file is not already open, it retrieves the file's content type, creates a CodeFileDocument with the file's contents and type, assigns it to item.file.fileDocument, and adds the document to CodeEditDocumentController.shared.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "122dddd4a2b5",
        "ground_truth": "private func openFile(item: Tab) throws {\n        guard item.file.fileDocument == nil else {\n            return\n        }\n\n        let contentType = try item.file.url.resourceValues(forKeys: [.contentTypeKey]).contentType\n        let codeFile = try CodeFileDocument(\n            for: item.file.url,\n            // TODO: FILE CONTENTS ARE READ MULTIPLE TIMES\n            withContentsOf: item.file.url,\n            ofType: contentType?.identifier ?? \"\"\n        )\n        item.file.fileDocument = codeFile\n        CodeEditDocumentController.shared.addDocument(codeFile)\n    }",
        "import_statements": [
            "import Foundation",
            "import OrderedCollections",
            "import DequeModule",
            "import AppKit"
        ],
        "reference_api": [
            "item.file.url.resourceValues",
            "CodeFileDocument"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "func menu(_ menu: NSMenu, willHighlight item: NSMenuItem?)",
        "start_line": "39",
        "end_line": "45",
        "file_path": "CodeEdit/Features/Editor/PathBar/Views/EditorPathBarMenu.swift",
        "docstring": "The function menu(_ menu: NSMenu, willHighlight item: NSMenuItem?) checks if the highlighted menu item has an empty submenu and a represented object of type CEWorkspaceFile. If so, it generates and assigns a new submenu using generateSubmenu(highlightedFileItem).\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "40b584ff8c49",
        "ground_truth": "func menu(_ menu: NSMenu, willHighlight item: NSMenuItem?) {\n    if let highlightedItem = item, let submenuItems = highlightedItem.submenu?.items, submenuItems.isEmpty {\n        if let highlightedFileItem = highlightedItem.representedObject as? CEWorkspaceFile {\n            highlightedItem.submenu = generateSubmenu(highlightedFileItem)\n        }\n    }\n}",
        "import_statements": [
            "import AppKit"
        ],
        "reference_api": [
            "generateSubmenu"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"generateSubmenu",
                "code":"private func generateSubmenu(_ fileItem: CEWorkspaceFile) -> EditorPathBarMenu? {\n        if let fileManager = fileManager,\n           let children = fileManager.childrenOfFile(fileItem) {\n            let menu = EditorPathBarMenu(\n                fileItems: children,\n                fileManager: fileManager,\n                tappedOpenFile: tappedOpenFile\n            )\n            return menu\n        }\n        return nil\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func generateSubmenu(_ fileItem: CEWorkspaceFile) -> EditorPathBarMenu?",
        "start_line": "47",
        "end_line": "58",
        "file_path": "CodeEdit/Features/Editor/PathBar/Views/EditorPathBarMenu.swift",
        "docstring": "The function generateSubmenu(_ fileItem: CEWorkspaceFile) -> EditorPathBarMenu? creates and returns an EditorPathBarMenu for the given fileItem if the fileManager and its children are available. If not, it returns nil.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7f0ce36a925e",
        "ground_truth": "private func generateSubmenu(_ fileItem: CEWorkspaceFile) -> EditorPathBarMenu? {\n    if let fileManager = fileManager,\n       let children = fileManager.childrenOfFile(fileItem) {\n        let menu = EditorPathBarMenu(\n            fileItems: children,\n            fileManager: fileManager,\n            tappedOpenFile: tappedOpenFile\n        )\n        return menu\n    }\n    return nil\n}",
        "import_statements": [
            "import AppKit"
        ],
        "reference_api": [
            "fileManager.childrenOfFile",
            "EditorPathBarMenu"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func copyRelativePath(item: CEWorkspaceFile)",
        "start_line": "147",
        "end_line": "170",
        "file_path": "CodeEdit/Features/Editor/TabBar/Views/EditorTabBarContextMenu.swift",
        "docstring": "The function copyRelativePath(item: CEWorkspaceFile) calculates the relative path from the workspace root to the given item and copies it to the clipboard. It compares and removes common path components from both paths, constructs the relative path, and uses NSPasteboard to set the result.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "26cdbc164b80",
        "ground_truth": "private func copyRelativePath(item: CEWorkspaceFile) {\n    guard let rootPath = workspace.workspaceFileManager?.folderUrl else {\n        return\n    }\n    // Calculate the relative path\n    var rootComponents = rootPath.standardizedFileURL.pathComponents\n    var destinationComponents = item.url.standardizedFileURL.pathComponents\n    // Remove any same path components\n    while !rootComponents.isEmpty && !destinationComponents.isEmpty\n            && rootComponents.first == destinationComponents.first {\n        rootComponents.remove(at: 0)\n        destinationComponents.remove(at: 0)\n    }\n    // Make a \"../\" for each remaining component in the root URL\n    var relativePath: String = String(repeating: \"../\", count: rootComponents.count)\n    // Add the remaining components for the destination url.\n    relativePath += destinationComponents.joined(separator: \"/\")\n    // Copy it to the clipboard\n    NSPasteboard.general.clearContents()\n    NSPasteboard.general.setString(relativePath, forType: .string)\n}",
        "import_statements": [
            "import SwiftUI",
            "import Combine",
            "import CodeEditSymbols"
        ],
        "reference_api": [
            "NSPasteboard.general.clearContents",
            "NSPasteboard.general.setString"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func attachPDFDocumentToView (_ pdfView: PDFView) -> PDFView ",
        "start_line": "49",
        "end_line": "57",
        "file_path": "CodeEdit/Features/Editor/Views/PDFFileView.swift",
        "docstring": "The function attachPDFDocumentToView(_ pdfView: PDFView) -> PDFView attempts to create a PDFDocument from a fileURL and attach it to the given PDFView. If successful, it sets the document and background color of the PDFView; otherwise, it returns the original PDFView without modification.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "456ba49cf901",
        "ground_truth": "private func attachPDFDocumentToView (_ pdfView: PDFView) -> PDFView {\n    guard let pdfDocument = PDFDocument(url: fileURL) else {\n        // What can happen is the view doesn't redraw, so whatever was in the editor area view remains as is.\n        return pdfView\n    }\n    pdfView.document = pdfDocument\n    pdfView.backgroundColor = NSColor.controlBackgroundColor\n    return pdfView\n}",
        "import_statements": [
            "import SwiftUI",
            "import PDFKit.PDFView"
        ],
        "reference_api": [
            "PDFDocument"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func loadKeybindings()",
        "start_line": "36",
        "end_line": "50",
        "file_path": "CodeEdit/Features/Keybindings/KeybindingManager.swift",
        "docstring": "The function loadKeybindings() loads default keybindings from a JSON file, decodes them into an array of KeyboardShortcutWrapper objects, and adds each shortcut using addNewShortcut(). If an error occurs during decoding, it prints the error.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "304341d1d8b6",
        "ground_truth": "private func loadKeybindings() {\n    let bindingsURL = Bundle.main.url(forResource: \"default_keybindings.json\", withExtension: nil)\n    if let json = try? Data(contentsOf: bindingsURL!) {\n        do {\n            let prefs = try JSONDecoder().decode([KeyboardShortcutWrapper].self, from: json)\n            for pref in prefs {\n                addNewShortcut(shortcut: pref, name: pref.id)\n            }\n            } catch {\n                print(\"error:\\(error)\")\n            }\n    }\n    return\n}",
        "import_statements": [
            "import Foundation",
            "import SwiftUI"
        ],
        "reference_api": [
            "Bundle.main.url",
            "addNewShortcut"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"addNewShortcut",
                "code":"func addNewShortcut(shortcut: KeyboardShortcutWrapper, name: String) {\n        keyboardShortcuts[name] = shortcut\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "private func deleteSelectedItem()",
        "start_line": "85",
        "end_line": "113",
        "file_path": "CodeEdit/Features/NavigatorArea/FindNavigator/FindNavigatorResultList/FindNavigatorListViewController.swift",
        "docstring": "The function deleteSelectedItem() removes the currently selected item from an outline view. If the selected item is a SearchResultMatchModel, it also removes the item from search results and its parent if necessary. Otherwise, it removes the selected item directly. The function updates the outline view and reselects the previously selected row.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2107327c1158",
        "ground_truth": "private func deleteSelectedItem() {\n    let selectedRow = outlineView.selectedRow\n    guard selectedRow >= 0,\n          let selectedItem = outlineView.item(atRow: selectedRow) else { return }\n    if selectedItem is SearchResultMatchModel {\n        guard let parent = outlineView.parent(forItem: selectedItem) else { return }\n        // Remove the item from the search results\n        let parentIndex = outlineView.childIndex(forItem: parent)\n        let childIndex = outlineView.childIndex(forItem: selectedItem)\n        searchItems[parentIndex].lineMatches.remove(at: childIndex)\n        // If this was the last child, we need to remove the parent or we'll\n        // hit an exception\n        if searchItems[parentIndex].lineMatches.isEmpty {\n            searchItems.remove(at: parentIndex)\n            outlineView.removeItems(at: IndexSet([parentIndex]), inParent: nil)\n        } else {\n            outlineView.removeItems(at: IndexSet([childIndex]), inParent: parent)\n        }\n    } else {\n        let index = outlineView.childIndex(forItem: selectedItem)\n        searchItems.remove(at: index)\n        outlineView.removeItems(at: IndexSet([index]), inParent: nil)\n    }\n    outlineView.selectRowIndexes(IndexSet([selectedRow]), byExtendingSelection: false)\n}",
        "import_statements": [
            "import SwiftUI"
        ],
        "reference_api": [
            "outlineView.childIndex",
            "searchItems.remove",
            "outlineView.removeItems"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CodeEditApp/CodeEdit",
        "function_declaration": "func updateNSView(_ nsView: NSScrollView, context: Context)",
        "start_line": "48",
        "end_line": "60",
        "file_path": "CodeEdit/Features/OpenQuickly/Views/NSTableViewWrapper.swift",
        "docstring": "The function updateNSView(_ nsView: NSScrollView, context: Context) updates the NSScrollView's document view if it is an NSTableView. It reloads the table data, selects and scrolls to the specified selection if it exists, or clears the selection otherwise. It also updates the coordinator's parent to self.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "256473c854ff",
        "ground_truth": "func updateNSView(_ nsView: NSScrollView, context: Context) {\n    context.coordinator.parent = self\n    if let view = nsView.documentView as? NSTableView {\n        view.reloadData()\n        if let selection, let item = data.firstIndex(of: selection) {\n            view.selectRowIndexes([item], byExtendingSelection: false)\n            view.scrollRowToVisible(item)\n        } else {\n            view.selectRowIndexes([], byExtendingSelection: false)\n        }\n    }\n}",
        "import_statements": [
            "import SwiftUI",
            "import AppKit"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Juanpe/SkeletonView",
        "function_declaration": "func showOrUpdateGradientSkeleton()",
        "start_line": "124",
        "end_line": "131",
        "file_path": "Examples/iOS Example/Sources/ViewController.swift",
        "docstring": "The function showOrUpdateGradientSkeleton() updates the view with a gradient skeleton based on the background color of colorSelectedView. If switchAnimated is on, it updates the view with an animated gradient skeleton; otherwise, it updates with a static gradient skeleton.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "10af5f60dbc9",
        "ground_truth": "func showOrUpdateGradientSkeleton() {\n    let gradient = SkeletonGradient(baseColor: colorSelectedView.backgroundColor!)\n    if switchAnimated.isOn {\n        view.updateAnimatedGradientSkeleton(usingGradient: gradient)\n    } else {\n        view.updateGradientSkeleton(usingGradient: gradient)\n    }\n}",
        "import_statements": [
            "import UIKit\ni",
            "import SkeletonView\n\n"
        ],
        "reference_api": [
            "SkeletonGradient",
            "view.updateAnimatedGradientSkeleton",
            "view.updateGradientSkeleton"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"view.updateAnimatedGradientSkeleton",
                "code":"func updateAnimatedGradientSkeleton(usingGradient gradient: SkeletonGradient = SkeletonAppearance.default.gradient, animation: SkeletonLayerAnimation? = nil) {\n        let config = SkeletonConfig(type: .gradient, colors: gradient.colors, animated: true, animation: animation)\n        updateSkeleton(skeletonConfig: config)\n    }"
            },
            {
                "name":"view.updateGradientSkeleton",
                "code":"func updateGradientSkeleton(usingGradient gradient: SkeletonGradient = SkeletonAppearance.default.gradient) {\n        let config = SkeletonConfig(type: .gradient, colors: gradient.colors)\n        updateSkeleton(skeletonConfig: config)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Juanpe/SkeletonView",
        "function_declaration": "func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int",
        "start_line": "71",
        "end_line": "83",
        "file_path": "SkeletonViewCore/Sources/Internal/Collections/SkeletonCollectionDataSource.swift",
        "docstring": "The function collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int returns the number of items in a given section. It checks the originalCollectionViewDataSource for the number of items, and if the number equals UICollectionView.automaticNumberOfSkeletonItems, it returns the collectionView's estimated number of rows; otherwise, it returns the actual number of items.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "eacfc85ce028",
        "ground_truth": "func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n    guard let originalCollectionViewDataSource = originalCollectionViewDataSource else {\n        return 0\n    }\n    let numberOfItems = originalCollectionViewDataSource.collectionSkeletonView(collectionView, numberOfItemsInSection: section)\n    if numberOfItems == UICollectionView.automaticNumberOfSkeletonItems {\n        return collectionView.estimatedNumberOfRows\n    } else {\n        return numberOfItems\n    }\n}",
        "import_statements": [
            "import UIKit\n\n"
        ],
        "reference_api": [
            "originalCollectionViewDataSource.collectionSkeletonView"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Juanpe/SkeletonView",
        "function_declaration": "func skeletonizeViewIfContainerSkeletonIsActive(container: UIView, view: UIView)",
        "start_line": "59",
        "end_line": "70",
        "file_path": "SkeletonViewCore/Sources/Internal/Collections/SkeletonCollectionDelegate.swift",
        "docstring": "The function skeletonizeViewIfContainerSkeletonIsActive(container: UIView, view: UIView) activates the skeleton view on the specified view if the container's skeleton is active by using the container's current skeleton configuration. If the container's skeleton is not active, it returns without doing anything.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5273702f0fbb",
        "ground_truth": "func skeletonizeViewIfContainerSkeletonIsActive(container: UIView, view: UIView) {\n    guard container.sk.isSkeletonActive,\n          let skeletonConfig = container._currentSkeletonConfig\n    else {\n        return\n    }\n    view.showSkeleton(\n        skeletonConfig: skeletonConfig,\n        notifyDelegate: false\n    )\n}",
        "import_statements": [
            "import UIKit\n\n"
        ],
        "reference_api": [
            "view.showSkeleton"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"view.showSkeleton",
                "code":"func showSkeleton(\n        skeletonConfig config: SkeletonConfig,\n        notifyDelegate: Bool = true\n    ) {\n        _isSkeletonAnimated = config.animated\n        \n        if notifyDelegate {\n            _flowDelegate = SkeletonFlowHandler()\n            _flowDelegate?.willBeginShowingSkeletons(rootView: self)\n        }\n        \n        recursiveShowSkeleton(skeletonConfig: config, root: self)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Juanpe/SkeletonView",
        "function_declaration": "override func recoverViewState(forced: Bool)",
        "start_line": "60",
        "end_line": "80",
        "file_path": "SkeletonViewCore/Sources/Internal/SkeletonExtensions/Recoverable.swift",
        "docstring": "The function recoverViewState(forced: Bool) overrides a method to recover the view state, calling the superclass's method first. It starts a transition to restore the label state, deactivates skeleton height constraints, restores backup height constraints if needed, and restores the text color and text if they are clear or if forced is true.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ab76b1628b3c",
        "ground_truth": "override func recoverViewState(forced: Bool) {\n    super.recoverViewState(forced: forced)\n    startTransition { [weak self] in\n        guard let self = self,\n              let storedLabelState = self.labelState else {\n            return\n        }\n                 NSLayoutConstraint.deactivate(self.skeletonHeightConstraints)\n        self.restoreBackupHeightConstraintsIfNeeded()\n                 if self.textColor == .clear || forced {\n            self.textColor = storedLabelState.textColor\n            if let attributedText = storedLabelState.attributedText {\n                self.attributedText = attributedText\n            } else {\n                self.text = storedLabelState.text\n            }\n        }\n    }\n}",
        "import_statements": [
            "import UIKit\n\n"
        ],
        "reference_api": [
            "super.recoverViewState",
            "startTransition",
            "NSLayoutConstraint.deactivate",
            "self.restoreBackupHeightConstraintsIfNeeded"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"startTransition",
                "code":"func startTransition(transitionBlock: @escaping () -> Void) {\n        guard let transitionStyle = _currentSkeletonConfig?.transition,\n              transitionStyle != .none else {\n            transitionBlock()\n            return\n        }\n        \n        if case let .crossDissolve(duration) = transitionStyle {\n            UIView.transition(with: self,\n                              duration: duration,\n                              options: .transitionCrossDissolve,\n                              animations: transitionBlock,\n                              completion: nil)\n        }\n    }"
            },
            {
                "name":"self.restoreBackupHeightConstraintsIfNeeded",
                "code":"func restoreBackupHeightConstraintsIfNeeded() {\n        guard !backupHeightConstraints.isEmpty else { return }\n        NSLayoutConstraint.activate(backupHeightConstraints)\n        backupHeightConstraints.removeAll()\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CosmicMind/Material",
        "function_declaration": "func canSelect(at index: Int) -> Bool",
        "start_line": "266",
        "end_line": "286",
        "file_path": "Sources/iOS/BottomTabBar/BottomNavigationController.swift",
        "docstring": "The function canSelect(at index: Int) -> Bool determines whether a tab at the given index can be selected. It checks if the index is different from the selectedIndex, within valid bounds, not the last tab linked to moreNavigationController, and if the delegate allows the selection of the viewController at that index. Returns true if all conditions are met.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6da772281323",
        "ground_truth": "func canSelect(at index: Int) -> Bool {\n  guard index != selectedIndex else {\n    return false\n  }\n     let lastTabIndex = (tabBar.items?.count ?? 1) - 1\n  guard (0...lastTabIndex).contains(index) else {\n    return false\n  }\n     guard !(index == lastTabIndex && tabBar.items?.last == moreNavigationController.tabBarItem) else {\n    return false\n  }\n     let vc = viewControllers![index]\n  guard delegate?.tabBarController?(self, shouldSelect: vc) != false else {\n    return false\n  }\n     return true\n}",
        "import_statements": [
            "import UIKit",
            "import Motion"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CosmicMind/Material",
        "function_declaration": "override func layoutSublayers()",
        "start_line": "107",
        "end_line": "116",
        "file_path": "Sources/iOS/Button/RadioButton.swift",
        "docstring": "The function layoutSublayers() overrides a method to layout sublayers. It first calls the superclass's method, then checks if isAnimating is false. If not animating, it sets the frame for centerDot, adjusts the size of outerCircle, and sets the corner radius for both centerDot and outerCircle, as well as the border width for outerCircle.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "692bfa1928b3",
        "ground_truth": "override func layoutSublayers() {\n  super.layoutSublayers()\n  guard !isAnimating else { return }\n     centerDot.frame = CGRect(x: centerDotDiameter / 2.0, y: centerDotDiameter / 2.0, width: centerDotDiameter, height: centerDotDiameter)\n  outerCircle.frame.size = CGSize(width: sideLength, height: sideLength)\n  centerDot.cornerRadius = centerDot.bounds.width / 2\n  outerCircle.cornerRadius = sideLength / 2\n  outerCircle.borderWidth = outerCircleBorderWidth\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "super.layoutSublayers",
            "CGRect",
            "CGSize"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CosmicMind/Material",
        "function_declaration": "func updateScrollView()",
        "start_line": "362",
        "end_line": "372",
        "file_path": "Sources/iOS/Chip/ChipBar.swift",
        "docstring": "The function updateScrollView() adjusts the scroll view's content offset to ensure the selectedChipItem is visible within the scroll view's bounds. If the item is not within the current visible bounds, it calculates a new content offset and updates the scroll view with animation.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0972ff0c7c27",
        "ground_truth": "func updateScrollView() {\n  guard let v = selectedChipItem else {\n    return\n  }\n     if !scrollView.bounds.contains(v.frame) {\n    let contentOffsetX = (v.frame.origin.x < scrollView.bounds.minX) ? v.frame.origin.x : v.frame.maxX - scrollView.bounds.width\n    let normalizedOffsetX = min(max(contentOffsetX, 0), scrollView.contentSize.width - scrollView.bounds.width)\n    scrollView.setContentOffset(CGPoint(x: normalizedOffsetX, y: 0), animated: true)\n  }\n}",
        "import_statements": [
            "import UIKit",
            "import Motion"
        ],
        "reference_api": [
            "scrollView.bounds.contains",
            "min",
            "max",
            "scrollView.setContentOffset"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CosmicMind/Material",
        "function_declaration": "open override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]?",
        "start_line": "185",
        "end_line": "193",
        "file_path": "Sources/iOS/Collection/CollectionViewLayout.swift",
        "docstring": "The function layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? returns an array of UICollectionViewLayoutAttributes for elements that intersect with the given rect by iterating through layoutItems and checking for intersections.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "12503fc307b5",
        "ground_truth": "open override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {\n  var layoutAttributes = [UICollectionViewLayoutAttributes]()\n  for (attribute, _) in layoutItems {\n    if rect.intersects(attribute.frame) {\n      layoutAttributes.append(attribute)\n    }\n  }\n  return layoutAttributes\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "rect.intersects"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CosmicMind/Material",
        "function_declaration": "func layoutScrollView()",
        "start_line": "338",
        "end_line": "346",
        "file_path": "Sources/iOS/Dialogs/DialogView.swift",
        "docstring": "The function layoutScrollView() adjusts the size and position of the scrollView based on the combined heights of titleArea and buttonArea, and the available height within the frame. It sets the scrollView's size, position, and content size accordingly.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "10a584e1b8ff",
        "ground_truth": "func layoutScrollView() {\n  let h = titleArea.frame.height + buttonArea.frame.height\n  let allowed = min(frame.height - h, contentArea.frame.height)\n     scrollView.frame.size = CGSize(width: frame.width, height: max(allowed, 0))\n  scrollView.frame.origin.y = titleArea.frame.maxY\n     scrollView.contentSize = contentArea.frame.size\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "CosmicMind/Material",
        "function_declaration": "static func loadFontIfNeeded(name: String)",
        "start_line": "97",
        "end_line": "120",
        "file_path": "Sources/iOS/Font/Font.swift",
        "docstring": "The function loadFontIfNeeded(name: String) checks if a font with the given name is already loaded. If not, and if UIFont cannot find the font, it attempts to load the font from the appropriate bundle URL. It then registers the font with CTFontManagerRegisterGraphicsFont, raising an exception if registration fails.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "625aeec3f261",
        "ground_truth": "static func loadFontIfNeeded(name: String) {\n  let loadedFont: String? = FontLoader.loadedFonts[name]\n     if nil == loadedFont && nil == UIFont(name: name, size: 1) {\n    FontLoader.loadedFonts[name] = name\n         let bundle = Bundle(for: FontLoader.self)\n    let identifier = bundle.bundleIdentifier\n    let fontURL = true == identifier?.hasPrefix(\"org.cocoapods\") ? bundle.url(forResource: name, withExtension: \"ttf\", subdirectory: \"com.cosmicmind.material.fonts.bundle\") : bundle.url(forResource: name, withExtension: \"ttf\")\n         if let v = fontURL {\n      let data = NSData(contentsOf: v as URL)!\n      let provider = CGDataProvider(data: data)!\n      let font = CGFont(provider)\n             var error: Unmanaged<CFError>?\n      if !CTFontManagerRegisterGraphicsFont(font!, &error) {\n        let errorDescription = CFErrorCopyDescription(error!.takeUnretainedValue())\n        let nsError = error!.takeUnretainedValue() as Any as! Error\n        NSException(name: .internalInconsistencyException, reason: errorDescription as String?, userInfo: [NSUnderlyingErrorKey: nsError as Any]).raise()\n      }\n    }\n  }\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "UIFont",
            "Bundle",
            "hasPrefix",
            "CGDataProvider",
            "CTFontManagerRegisterGraphicsFont",
            "CFErrorCopyDescription",
            "NSException"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"Bundle",
                "code":"public static var bundle: Bundle {\n    if nil == Icon.internalBundle {\n      Icon.internalBundle = Bundle(for: View.self)\n      let url = Icon.internalBundle!.resourceURL!\n      let b = Bundle(url: url.appendingPathComponent(\"com.cosmicmind.material.icons.bundle\"))\n      if let v = b {\n        Icon.internalBundle = v\n      }\n    }\n    return Icon.internalBundle!\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "private func imageTopTitleBottom(_ button : UIButton)",
        "start_line": "115",
        "end_line": "123",
        "file_path": "Example/Example/CustomCells.swift",
        "docstring": "The function imageTopTitleBottom(_ button: UIButton) adjusts the title and image insets of the given button to position the image above the title with a specific spacing. It first calculates the image and title sizes, then sets the titleEdgeInsets and imageEdgeInsets accordingly.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "636fcf057954",
        "ground_truth": "private func imageTopTitleBottom(_ button : UIButton){\n    guard let imageSize = button.imageView?.image?.size else { return }\n    let spacing : CGFloat = 3.0\n    button.titleEdgeInsets = UIEdgeInsets(top: 0.0, left: -imageSize.width, bottom: -(imageSize.height + spacing), right: 0.0)\n    guard let titleLabel = button.titleLabel, let title = titleLabel.text else { return }\n    let titleSize = title.size(withAttributes: [.font: titleLabel.font!])\n    button.imageEdgeInsets = UIEdgeInsets(top: -(titleSize.height + spacing), left: 0, bottom: 0, right: -titleSize.width)\n}",
        "import_statements": [
            "import Foundation",
            "import UIKit",
            "import MapKit",
            "import Eureka"
        ],
        "reference_api": [
            "UIEdgeInsets"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "public func textFieldDidEndEditing(_ textField: UITextField)",
        "start_line": "264",
        "end_line": "269",
        "file_path": "Example/Example/CustomCells.swift",
        "docstring": "The function textFieldDidEndEditing(_ textField: UITextField) handles the end of editing for a text field. It calls endEditing and textInputDidEndEditing on the formViewController, triggers textFieldDidChange, and updates the textField's text with a formatted display value if a formatter is available.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "979d1895bbd2",
        "ground_truth": "public func textFieldDidEndEditing(_ textField: UITextField) {\n    formViewController()?.endEditing(of: self)\n    formViewController()?.textInputDidEndEditing(textField, cell: self)\n    textFieldDidChange(textField)\n    textField.text = displayValue(useFormatter: (row as? FormatterConformance)?.formatter != nil)\n}",
        "import_statements": [
            "import Foundation",
            "import UIKit",
            "import MapKit",
            "import Eureka"
        ],
        "reference_api": [
            "formViewController",
            "textInputDidEndEditing",
            "textFieldDidChange"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"formViewController",
                "code":"public func formViewController() -> FormViewController? {\n        var responder: UIResponder? = self\n        while responder != nil {\n            if let formVC = responder as? FormViewController {\n              return formVC\n            }\n            responder = responder?.next\n        }\n        return nil\n    }"
            },
            {
                "name":"textFieldDidChange",
                "code":"open func textFieldDidChange(_ textField: UITextField) {\n    guard textField.markedTextRange == nil else { return }\n\n    guard let textValue = textField.text else {\n        row.value = nil\n        return\n    }\n    guard let fieldRow = row as? FieldRowConformance, let formatter = fieldRow.formatter else {\n        row.value = textValue.isEmpty ? nil : (T.init(string: textValue) ?? row.value)\n        return\n    }\n    if fieldRow.useFormatterDuringInput {\n        let unsafePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)\n        defer {\n            unsafePointer.deallocate()\n        }\n        let value: AutoreleasingUnsafeMutablePointer<AnyObject?> = AutoreleasingUnsafeMutablePointer<AnyObject?>.init(unsafePointer)\n        let errorDesc: AutoreleasingUnsafeMutablePointer<NSString?>? = nil\n        if formatter.getObjectValue(value, for: textValue, errorDescription: errorDesc) {\n            row.value = value.pointee as? T\n            guard var selStartPos = textField.selectedTextRange?.start else { return }\n            let oldVal = textField.text\n            textField.text = row.displayValueFor?(row.value)\n            selStartPos = (formatter as? FormatterProtocol)?.getNewPosition(forPosition: selStartPos, inTextInput: textField, oldValue: oldVal, newValue: textField.text) ?? selStartPos\n            textField.selectedTextRange = textField.textRange(from: selStartPos, to: selStartPos)\n            return\n        }\n    } else {\n        let unsafePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)\n        defer {\n            unsafePointer.deallocate()\n        }\n        let value: AutoreleasingUnsafeMutablePointer<AnyObject?> = AutoreleasingUnsafeMutablePointer<AnyObject?>.init(unsafePointer)\n        let errorDesc: AutoreleasingUnsafeMutablePointer<NSString?>? = nil\n        if formatter.getObjectValue(value, for: textValue, errorDescription: errorDesc) {\n            row.value = value.pointee as? T\n        } else {\n            row.value = textValue.isEmpty ? nil : (T.init(string: textValue) ?? row.value)\n        }\n    }\n}"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "public final func evaluateHidden()",
        "start_line": "164",
        "end_line": "177",
        "file_path": "Source/Core/BaseRow.swift",
        "docstring": "The function evaluateHidden() determines the visibility of a row based on its hidden property and the form it belongs to. It updates hiddenCache using a callback or predicate evaluation, and then hides or shows the row in its section accordingly.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "58b4d4829d30",
        "ground_truth": "public final func evaluateHidden() {\n    guard let h = hidden, let form = section?.form else { return }\n    switch h {\n    case .function(_, let callback):\n        hiddenCache = callback(form)\n    case .predicate(let predicate):\n        hiddenCache = predicate.evaluate(with: self, substitutionVariables: form.dictionaryValuesToEvaluatePredicate())\n    }\n    if hiddenCache {\n        section?.hide(row: self)\n    } else {\n        section?.show(row: self)\n    }\n}",
        "import_statements": [
            "import Foundation",
            "import UIKit"
        ],
        "reference_api": [
            "form.dictionaryValuesToEvaluatePredicate",
            "hide",
            "show"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"form.dictionaryValuesToEvaluatePredicate",
                "code":"func dictionaryValuesToEvaluatePredicate() -> [String: Any] {\n        return tagToValues\n    }"
            },
            {
                "name":"hide",
                "code":"func hide(row: BaseRow) {\n        row.baseCell.cellResignFirstResponder()\n        (row as? BaseInlineRowType)?.collapseInlineRow()\n        kvoWrapper.rows.remove(row)\n    }"
            },
            {
                "name":"show",
                "code":"func show(row: BaseRow) {\n        guard !kvoWrapper.rows.contains(row) else { return }\n        guard var index = kvoWrapper._allRows.firstIndex(of: row) else { return }\n        var formIndex = NSNotFound\n        while formIndex == NSNotFound && index > 0 {\n            index = index - 1\n            let previous = kvoWrapper._allRows[index]\n            formIndex = kvoWrapper.rows.index(of: previous)\n        }\n        kvoWrapper.rows.insert(row, at: formIndex == NSNotFound ? 0 : formIndex + 1)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "open func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)",
        "start_line": "845",
        "end_line": "871",
        "file_path": "Source/Core/Core.swift",
        "docstring": "The function tableView(_:commit:forRowAt:) handles row insertion and deletion in a UITableView. For deletion, it removes the row from its section, ending editing if necessary. For insertion, it adds a new row at the specified position, toggles table view editing, scrolls to the new row, and sets it as the first responder if possible.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e664e2b8fae5",
        "ground_truth": "open func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {\n    if editingStyle == .delete {\n        let row = form[indexPath]\n        let section = row.section!\n        if let _ = row.baseCell.findFirstResponder() {\n            tableView.endEditing(true)\n        }\n        section.remove(at: indexPath.row)\n    } else if editingStyle == .insert {\n        guard var section = form[indexPath.section] as? BaseMultivaluedSection else { return }\n        guard let multivaluedRowToInsertAt = section.multivaluedRowToInsertAt else {\n            fatalError(\"Multivalued section multivaluedRowToInsertAt property must be set up\")\n        }\n        let newRow = multivaluedRowToInsertAt(max(0, section.count - 1))\n        section.insert(newRow, at: max(0, section.count - 1))\n        DispatchQueue.main.async {\n            tableView.isEditing = !tableView.isEditing\n            tableView.isEditing = !tableView.isEditing\n        }\n        tableView.scrollToRow(at: IndexPath(row: section.count - 1, section: indexPath.section), at: .bottom, animated: true)\n        if newRow.baseCell.cellCanBecomeFirstResponder() {\n            newRow.baseCell.cellBecomeFirstResponder()\n        } else if let inlineRow = newRow as? BaseInlineRowType {\n            inlineRow.expandInlineRow()\n        }\n    }\n}",
        "import_statements": [
            "import Foundation",
            "import UIKit"
        ],
        "reference_api": [
            "row.baseCell.findFirstResponder()",
            "tableView.endEditing",
            "section.remove",
            "multivaluedRowToInsertAt",
            "scrollToRow",
            "inlineRow.expandInlineRow"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"row.baseCell.findFirstResponder()",
                "code":"public func findFirstResponder() -> UIView? {\n        if isFirstResponder { return self }\n        for subView in subviews {\n            if let firstResponder = subView.findFirstResponder() {\n                return firstResponder\n            }\n        }\n        return nil\n    }"
            },
            {
                "name":"section.remove",
                "code":"public func remove(at position: Int) -> BaseRow {\n        let row = kvoWrapper.rows.object(at: position) as! BaseRow\n        row.willBeRemovedFromSection()\n        kvoWrapper.rows.removeObject(at: position)\n        if let index = kvoWrapper._allRows.firstIndex(of: row) {\n            kvoWrapper._allRows.remove(at: index)\n        }\n\n        return row\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "public func removeAll(where shouldBeRemoved: (Section) throws -> Bool) rethrows",
        "start_line": "271",
        "end_line": "283",
        "file_path": "Source/Core/Form.swift",
        "docstring": "The function removeAll(where shouldBeRemoved: (Section) throws -> Bool) rethrows removes sections from kvoWrapper._allSections based on the given predicate. It identifies the indices of sections to remove, removes them in reverse order, updates kvoWrapper.sections, and calls willBeRemovedFromForm() on each removed section.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "95967f7f2187",
        "ground_truth": "public func removeAll(where shouldBeRemoved: (Section) throws -> Bool) rethrows {\n    let indices = try kvoWrapper._allSections.enumerated()\n        .filter { try shouldBeRemoved($0.element)}\n        .map { $0.offset }\n    var removedSections = [Section]()\n    for index in indices.reversed() {\n        removedSections.append(kvoWrapper._allSections.remove(at: index))\n    }\n    kvoWrapper.sections.removeObjects(in: removedSections)\n    removedSections.forEach { $0.willBeRemovedFromForm() }\n}",
        "import_statements": [
            "import Foundation"
        ],
        "reference_api": [
            "shouldBeRemoved",
            "kvoWrapper.sections.removeObjects",
            "willBeRemovedFromForm"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"willBeRemovedFromForm",
                "code":"final func willBeRemovedFromForm() {\n        (self as? BaseInlineRowType)?.collapseInlineRow()\n        if let t = tag {\n            section?.form?.rowsByTag[t] = nil\n            section?.form?.tagToValues[t] = nil\n        }\n        removeFromRowObservers()\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "public static var defaultCellSetup: ((Cell, Self) -> Void)?",
        "start_line": "131",
        "end_line": "145",
        "file_path": "Source/Core/RowType.swift",
        "docstring": "The computed property defaultCellSetup provides a getter and setter for a closure that configures a cell. The setter stores the closure in RowDefaults.cellSetup and RowDefaults.rawCellSetup using a type-casted wrapper. If nil is assigned, it removes the closures from RowDefaults. The getter retrieves the closure from RowDefaults.rawCellSetup.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d3af710b4eb4",
        "ground_truth": "public static var defaultCellSetup: ((Cell, Self) -> Void)? {\n    set {\n        if let newValue = newValue {\n            let wrapper: (BaseCell, BaseRow) -> Void = { (baseCell: BaseCell, baseRow: BaseRow) in\n                newValue(baseCell as! Cell, baseRow as! Self)\n            }\n            RowDefaults.cellSetup[\"\\(self)\"] = wrapper\n            RowDefaults.rawCellSetup[\"\\(self)\"] = newValue\n        } else {\n            RowDefaults.cellSetup[\"\\(self)\"] = nil\n            RowDefaults.rawCellSetup[\"\\(self)\"] = nil\n        }\n    }\n    get { return RowDefaults.rawCellSetup[\"\\(self)\"] as? ((Cell, Self) -> Void) }\n}",
        "import_statements": [],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "open override func layoutSubviews()",
        "start_line": "473",
        "end_line": "493",
        "file_path": "Source/Rows/Common/FieldRow.swift",
        "docstring": "The function layoutSubviews() overrides the superclass method to adjust the layout of subviews. It checks if the row conforms to FieldRowConformance and calculates the target title width based on the row's titlePercentage, adjusting for the presence of an imageView and titleLabel, and considering the interface layout direction. Finally, it updates the calculatedTitlePercentage and triggers constraint updates.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2c8a573a2457",
        "ground_truth": "open override func layoutSubviews() {\n super.layoutSubviews()\n guard let row = (row as? FieldRowConformance) else { return }\n defer {\n  // As titleLabel is the textLabel, iOS may re-layout without updating constraints, for example:\n  // swiping, showing alert or actionsheet from the same section.\n  // thus we need forcing update to use customConstraints()\n  setNeedsUpdateConstraints()\n  updateConstraintsIfNeeded()\n }\n guard let titlePercentage = row.titlePercentage else  { return }\n var targetTitleWidth = bounds.size.width * titlePercentage\n if let imageView = imageView, let _ = imageView.image, let titleLabel = titleLabel {\n  var extraWidthToSubtract = titleLabel.frame.minX - imageView.frame.minX // Left-to-right interface layout\n           if UIView.userInterfaceLayoutDirection(for: self.semanticContentAttribute) == .rightToLeft {\n               extraWidthToSubtract = imageView.frame.maxX - titleLabel.frame.maxX\n           }\n  targetTitleWidth -= extraWidthToSubtract\n }\n calculatedTitlePercentage = targetTitleWidth / contentView.bounds.size.width\n}",
        "import_statements": [
            "import Foundation",
            "import UIKit"
        ],
        "reference_api": [
            "super.layoutSubviews",
            "setNeedsUpdateConstraints",
            "updateConstraintsIfNeeded",
            "UIView.userInterfaceLayoutDirection"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "open func optionsBySections(with options: [OptionsRow.OptionsProviderType.Option]) -> [(String, [Row.Cell.Value])]?",
        "start_line": "96",
        "end_line": "109",
        "file_path": "Source/Rows/Controllers/MultipleSelectorViewController.swift",
        "docstring": "The function optionsBySections(with options: [OptionsRow.OptionsProviderType.Option]) -> [(String, [Row.Cell.Value])]? groups options into sections based on a section key derived from each option. It returns the sections sorted by their keys. If sectionKeyForValue is nil, it returns nil.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0760d4281c60",
        "ground_truth": "open func optionsBySections(with options: [OptionsRow.OptionsProviderType.Option]) -> [(String, [Row.Cell.Value])]? {\n    guard let sectionKeyForValue = sectionKeyForValue else { return nil }\n    let sections = options.reduce([:]) { (reduced, option) -> [String: [Row.Cell.Value]] in\n        var reduced = reduced\n        let key = sectionKeyForValue(option)\n        var items = reduced[key] ?? []\n        items.append(option)\n        reduced[key] = items\n        return reduced\n    }\n    return sections.sorted(by: { (lhs, rhs) in lhs.0 < rhs.0 })\n}",
        "import_statements": [
            "import Foundation",
            "import UIKit"
        ],
        "reference_api": [
            "sectionKeyForValue"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "xmartlabs/Eureka",
        "function_declaration": "open override func viewDidLoad()",
        "start_line": "67",
        "end_line": "78",
        "file_path": "Source/Rows/Controllers/SelectorAlertController.swift",
        "docstring": "The function viewDidLoad() overrides the superclass method, loading options from optionsProviderRow. It sets up a cancel action with a default or localized title and adds actions for each option, updating row.value and invoking onDismissCallback upon selection.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "635c78bca72c",
        "ground_truth": "open override func viewDidLoad() {\n    super.viewDidLoad()\n    guard let options = optionsProviderRow.options else { return }\n    let cancelTitle = optionsProviderRow.cancelTitle ?? NSLocalizedString(\"Cancel\", comment: \"\")\n    addAction(UIAlertAction(title: cancelTitle, style: .cancel, handler: nil))\n    for option in options {\n        addAction(UIAlertAction(title: row.displayValueFor?(option), style: .default, handler: { [weak self] _ in\n            self?.row.value = option\n            self?.onDismissCallback?(self!)\n        }))\n    }\n}",
        "import_statements": [
            "import Foundation",
            "import UIKit"
        ],
        "reference_api": [
            "addAction",
            "UIAlertAction"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Ramotion/animated-tab-bar",
        "function_declaration": "func playBounceAnimation(_ icon: UIImageView)",
        "start_line": "75",
        "end_line": "89",
        "file_path": "RAMAnimatedTabBarController/Animations/BounceAnimation/RAMBounceAnimation.swift",
        "docstring": "The function playBounceAnimation(_ icon: UIImageView) applies a bounce animation to the provided UIImageView using a CAKeyframeAnimation with predefined scale values and duration. It also changes the icon's image rendering mode to alwaysTemplate and sets its tint color to iconSelectedColor.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7d7376f3f4f2",
        "ground_truth": "func playBounceAnimation(_ icon: UIImageView) {\n    let bounceAnimation = CAKeyframeAnimation(keyPath: Constants.AnimationKeys.scale)\n    bounceAnimation.values = [1.0, 1.4, 0.9, 1.15, 0.95, 1.02, 1.0]\n    bounceAnimation.duration = TimeInterval(duration)\n    bounceAnimation.calculationMode = CAAnimationCalculationMode.cubic\n    icon.layer.add(bounceAnimation, forKey: nil)\n    if let iconImage = icon.image {\n        let renderImage = iconImage.withRenderingMode(.alwaysTemplate)\n        icon.image = renderImage\n        icon.tintColor = iconSelectedColor\n    }\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "CAKeyframeAnimation",
            "TimeInterval",
            "iconImage.withRenderingMode"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Ramotion/animated-tab-bar",
        "function_declaration": "open override func playAnimation(_ icon: UIImageView, textLabel: UILabel)",
        "start_line": "35",
        "end_line": "45",
        "file_path": "RAMAnimatedTabBarController/Animations/FumeAnimation/RAMFumeAnimation.swift",
        "docstring": "The function playAnimation(_ icon: UIImageView, textLabel: UILabel) overrides a method to animate the icon and text label. It calls playMoveIconAnimation with specific y-values for the icon and playLabelAnimation for the text label. It also updates the text color to textSelectedColor and changes the icon's image rendering mode to alwaysTemplate, setting its tint color to iconSelectedColor.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e858ea6a0f7d",
        "ground_truth": "open override func playAnimation(_ icon: UIImageView, textLabel: UILabel) {\n    playMoveIconAnimation(icon, values: [icon.center.y as AnyObject, (icon.center.y + 4.0) as AnyObject])\n    playLabelAnimation(textLabel)\n    textLabel.textColor = textSelectedColor\n    if let iconImage = icon.image {\n        let renderImage = iconImage.withRenderingMode(.alwaysTemplate)\n        icon.image = renderImage\n        icon.tintColor = iconSelectedColor\n    }\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "playMoveIconAnimation",
            "playLabelAnimation",
            "iconImage.withRenderingMode"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"playMoveIconAnimation",
                "code":"func playMoveIconAnimation(_ icon: UIImageView, values: [AnyObject]) {\n\n        let yPositionAnimation = createAnimation(Constants.AnimationKeys.positionY, values: values, duration: duration / 2)\n\n        icon.layer.add(yPositionAnimation, forKey: nil)\n    }"
            },
            {
                "name":"playLabelAnimation",
                "code":"func playLabelAnimation(_ textLabel: UILabel) {\n\n        let yPositionAnimation = createAnimation(Constants.AnimationKeys.positionY, values: [textLabel.center.y as AnyObject, (textLabel.center.y - 60.0) as AnyObject], duration: duration)\n        yPositionAnimation.fillMode = CAMediaTimingFillMode.removed\n        yPositionAnimation.isRemovedOnCompletion = true\n        textLabel.layer.add(yPositionAnimation, forKey: nil)\n\n        let scaleAnimation = createAnimation(Constants.AnimationKeys.scale, values: [1.0 as AnyObject, 2.0 as AnyObject], duration: duration)\n        scaleAnimation.fillMode = CAMediaTimingFillMode.removed\n        scaleAnimation.isRemovedOnCompletion = true\n        textLabel.layer.add(scaleAnimation, forKey: nil)\n\n        let opacityAnimation = createAnimation(Constants.AnimationKeys.opacity, values: [1.0 as AnyObject, 0.0 as AnyObject], duration: duration)\n        textLabel.layer.add(opacityAnimation, forKey: nil)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Ramotion/animated-tab-bar",
        "function_declaration": "open override func selectedState(_ icon: UIImageView, textLabel: UILabel)",
        "start_line": "76",
        "end_line": "87",
        "file_path": "RAMAnimatedTabBarController/Animations/FumeAnimation/RAMFumeAnimation.swift",
        "docstring": "The function selectedState(_ icon: UIImageView, textLabel: UILabel) is an override that applies a move animation to the icon, sets the textLabel's alpha to 0 and changes its text color to textSelectedColor. It also modifies the icon's image rendering mode to alwaysTemplate and sets its tint color to iconSelectedColor.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7774aa0fb3bf",
        "ground_truth": "open override func selectedState(_ icon: UIImageView, textLabel: UILabel) {\n    playMoveIconAnimation(icon, values: [(icon.center.y + 12.0) as AnyObject])\n    textLabel.alpha = 0\n    textLabel.textColor = textSelectedColor\n    if let iconImage = icon.image {\n        let renderImage = iconImage.withRenderingMode(.alwaysTemplate)\n        icon.image = renderImage\n        icon.tintColor = iconSelectedColor\n    }\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "playMoveIconAnimation",
            "iconImage.withRenderingMode"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"playMoveIconAnimation",
                "code":"func playMoveIconAnimation(_ icon: UIImageView, values: [AnyObject]) {\n\n        let yPositionAnimation = createAnimation(Constants.AnimationKeys.positionY, values: values, duration: duration / 2)\n\n        icon.layer.add(yPositionAnimation, forKey: nil)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Ramotion/animated-tab-bar",
        "function_declaration": "func playDeselectLabelAnimation(_ textLabel: UILabel)",
        "start_line": "127",
        "end_line": "134",
        "file_path": "RAMAnimatedTabBarController/Animations/FumeAnimation/RAMFumeAnimation.swift",
        "docstring": "The function playDeselectLabelAnimation(_ textLabel: UILabel) animates the deselection of a UILabel by creating and adding a vertical position animation and an opacity animation to the label's layer, using predefined values and duration.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9809d77a84eb",
        "ground_truth": "func playDeselectLabelAnimation(_ textLabel: UILabel) {\n    let yPositionAnimation = createAnimation(Constants.AnimationKeys.positionY, values: [(textLabel.center.y + 15) as AnyObject, textLabel.center.y as AnyObject], duration: duration)\n    textLabel.layer.add(yPositionAnimation, forKey: nil)\n    let opacityAnimation = createAnimation(Constants.AnimationKeys.opacity, values: [0 as AnyObject, 1 as AnyObject], duration: duration)\n    textLabel.layer.add(opacityAnimation, forKey: nil)\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "createAnimation"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"createAnimation",
                "code":"func createAnimation(_ keyPath: String, values: [AnyObject], duration: CGFloat) -> CAKeyframeAnimation {\n\n        let animation = CAKeyframeAnimation(keyPath: keyPath)\n        animation.values = values\n        animation.duration = TimeInterval(duration)\n        animation.calculationMode = CAAnimationCalculationMode.cubic\n        animation.fillMode = CAMediaTimingFillMode.forwards\n        animation.isRemovedOnCompletion = false\n        return animation\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "ninjaprox/NVActivityIndicatorView",
        "function_declaration": "func circleAt(angle: CGFloat, size: CGFloat, origin: CGPoint, containerSize: CGSize, color: UIColor) -> CALayer",
        "start_line": "79",
        "end_line": "91",
        "file_path": "Sources/Base/Animations/NVActivityIndicatorAnimationBallSpinFadeLoader.swift",
        "docstring": "The function circleAt(angle: CGFloat, size: CGFloat, origin: CGPoint, containerSize: CGSize, color: UIColor) -> CALayer creates and returns a CALayer representing a circle. It positions the circle based on the specified angle, size, origin, and container size, and sets its color.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "14c83e07d7f8",
        "ground_truth": "func circleAt(angle: CGFloat, size: CGFloat, origin: CGPoint, containerSize: CGSize, color: UIColor) -> CALayer {\n    let radius = containerSize.width / 2 - size / 2\n    let circle = NVActivityIndicatorShape.circle.layerWith(size: CGSize(width: size, height: size), color: color)\n    let frame = CGRect(\n        x: origin.x + radius * (cos(angle) + 1),\n        y: origin.y + radius * (sin(angle) + 1),\n        width: size,\n        height: size)\n    circle.frame = frame\n    return circle\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "NVActivityIndicatorShape.circle.layerWith"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "ninjaprox/NVActivityIndicatorView",
        "function_declaration": "func createRotateXTransform(angle: CGFloat) -> CATransform3D",
        "start_line": "65",
        "end_line": "71",
        "file_path": "Sources/Base/Animations/NVActivityIndicatorAnimationSquareSpin.swift",
        "docstring": "The function createRotateXTransform(angle: CGFloat) -> CATransform3D creates and returns a CATransform3D object representing a rotation by the specified angle around the x-axis, with a perspective applied by setting the m34 property.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "014d45f07080",
        "ground_truth": "func createRotateXTransform(angle: CGFloat) -> CATransform3D {\n    var transform = CATransform3DMakeRotation(angle, 1, 0, 0)\n    transform.m34 = CGFloat(-1) / 100\n    return transform\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": ["CATransform3DMakeRotation"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "ninjaprox/NVActivityIndicatorView",
        "function_declaration": "func stopAnimating(presenter: NVActivityIndicatorPresenter, _ fadeOutAnimation: FadeOutAnimation?)",
        "start_line": "136",
        "end_line": "145",
        "file_path": "Sources/Extended/NVActivityIndicatorPresenter.swift",
        "docstring": "The function stopAnimating(presenter: NVActivityIndicatorPresenter, _ fadeOutAnimation: FadeOutAnimation?) stops the animation of the given presenter after ensuring the minimum display time has passed. It checks the presenter\u2019s state and invokes stopAnimating with an optional fadeOutAnimation, setting the presenter\u2019s state to waitingToStop.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "18154d046fcc",
        "ground_truth": "func stopAnimating(presenter: NVActivityIndicatorPresenter, _ fadeOutAnimation: FadeOutAnimation?) {\n    guard let activityData = presenter.data else { return }\n    DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(activityData.minimumDisplayTime)) {\n        guard presenter.state == .waitingToStop else { return }\n        presenter.stopAnimating(fadeOutAnimation)\n    }\n    presenter.state = .waitingToStop\n}",
        "import_statements": [
            "import UIKit",
            "import NVActivityIndicatorView"
        ],
        "reference_api": ["DispatchQueue.main.asyncAfter","presenter.stopAnimating"],
        "repo_defined_api_with_code": [
            {
                "name":"presenter.stopAnimating",
                "code":"func stopAnimating(_ fadeOutAnimation: FadeOutAnimation? = NVActivityIndicatorView.DEFAULT_FADE_OUT_ANIMATION) {\n        NVActivityIndicatorPresenter.sharedInstance.stopAnimating(fadeOutAnimation)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "ninjaprox/NVActivityIndicatorView",
        "function_declaration": "fileprivate func hide(_ fadeOutAnimation: FadeOutAnimation?) ",
        "start_line": "324",
        "end_line": "337",
        "file_path": "Sources/Extended/NVActivityIndicatorPresenter.swift",
        "docstring": "The function hide(_ fadeOutAnimation: FadeOutAnimation?) removes subviews with a specific restorationIdentifier from all application windows. If a fadeOutAnimation is provided, it applies the animation before removing the subview; otherwise, it removes the subview immediately.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b12cbc40f2c5",
        "ground_truth": "fileprivate func hide(_ fadeOutAnimation: FadeOutAnimation?) {\n    for window in UIApplication.shared.windows {\n        for item in window.subviews\n            where item.restorationIdentifier == restorationIdentifier {\n                if let fadeOutAnimation = fadeOutAnimation {\n                    fadeOutAnimation(item) {\n                        item.removeFromSuperview()\n                    }\n                } else {\n                    item.removeFromSuperview()\n                }\n        }\n    }\n}",
        "import_statements": [
            "import UIKit",
            "import NVActivityIndicatorView"
        ],
        "reference_api": [
            "fadeOutAnimation",
            "item.removeFromSuperview"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "AudioKit/AudioKit",
        "function_declaration": "internal func completionProxy(error: Error?,\n                                  deleteOutputOnError: Bool = true,\n                                  completionHandler: FormatConverterCallback? = nil)",
        "start_line": "242",
        "end_line": "263",
        "file_path": "Sources/AudioKit/Audio Files/Format Converter/FormatConverter.swift",
        "docstring": "The function completionProxy(error: Error?, deleteOutputOnError: Bool = true, completionHandler: FormatConverterCallback? = nil) handles errors by optionally deleting the output file if an error occurs and deleteOutputOnError is true. It logs the deletion attempt and error, if any, and finally calls the completionHandler with the error.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e0bc1f58a60a",
        "ground_truth": "internal func completionProxy(error: Error?,\n                              deleteOutputOnError: Bool = true,\n                              completionHandler: FormatConverterCallback? = nil)\n{\n    guard error != nil,\n          deleteOutputOnError,\n          let outputURL = outputURL,\n          FileManager.default.fileExists(atPath: outputURL.path)\n    else {\n        completionHandler?(error)\n        return\n    }\n    do {\n        Log(\"Deleting on error\", outputURL.path)\n        try FileManager.default.removeItem(at: outputURL)\n    } catch let err as NSError {\n        Log(\"Failed to remove file\", outputURL, err)\n    }\n    completionHandler?(error)\n}",
        "import_statements": [
            "FileManager.default.removeItem("
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "AudioKit/AudioKit",
        "function_declaration": "func toAVAudioPCMBuffer() -> AVAudioPCMBuffer?",
        "start_line": "32",
        "end_line": "46",
        "file_path": "Sources/AudioKit/Audio Files/AVAudioFile+Utilities.swift",
        "docstring": "The function toAVAudioPCMBuffer() -> AVAudioPCMBuffer? creates an AVAudioPCMBuffer using the processingFormat and frameCapacity based on the length. It attempts to read data into the buffer, logs the creation or any errors, and returns the buffer or nil if creation fails.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9963fd15d50c",
        "ground_truth": "func toAVAudioPCMBuffer() -> AVAudioPCMBuffer? {\n    guard let buffer = AVAudioPCMBuffer(pcmFormat: processingFormat,\n                                        frameCapacity: AVAudioFrameCount(length)) else { return nil }\n    do {\n        framePosition = 0\n        try read(into: buffer)\n        Log(\"Created buffer with format\", processingFormat)\n    } catch let error as NSError {\n        Log(\"Cannot read into buffer \" + error.localizedDescription, log: OSLog.fileHandling, type: .error)\n    }\n    return buffer\n}",
        "import_statements": [
            "import Accelerate",
            "import AVFoundation"
        ],
        "reference_api": [
            "AVAudioPCMBuffer",
            "frameCapacity: AVAudioFrameCount"

        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "AudioKit/AudioKit",
        "function_declaration": "func disconnect(input: AVAudioNode, format: AVAudioFormat)",
        "start_line": "7",
        "end_line": "27",
        "file_path": "Sources/AudioKit/Internals/Engine/AudioEngine.swift",
        "docstring": "The function disconnect(input: AVAudioNode, format: AVAudioFormat) manages disconnection of an input AVAudioNode from the current node in an AVAudioEngine. It collects and updates connections, filtering out those related to the current node, and either disconnects or reconnects nodes based on the remaining connections.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3b5f45232113",
        "ground_truth": "func disconnect(input: AVAudioNode, format: AVAudioFormat) {\n    if let engine = engine {\n        var newConnections: [AVAudioNode: [AVAudioConnectionPoint]] = [:]\n        for bus in 0 ..< inputCount {\n            if let cp = engine.inputConnectionPoint(for: self, inputBus: bus) {\n                if cp.node === input {\n                    let points = engine.outputConnectionPoints(for: input, outputBus: 0)\n                    newConnections[input] = points.filter { $0.node != self }\n                }\n            }\n        }\n        for (node, connections) in newConnections {\n            if connections.isEmpty {\n                engine.disconnectNodeOutput(node)\n            } else {\n                engine.connect(node, to: connections, fromBus: 0, format: format)\n            }\n        }\n    }\n}",
        "import_statements": [
            "import AVFoundation"
        ],
        "reference_api": [
            "engine.inputConnectionPoint",
            "engine.outputConnectionPoints",
            "engine.disconnectNodeOutput",
            "engine.connect"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "AudioKit/AudioKit",
        "function_declaration": "func connect(input: AVAudioNode, bus: Int, format: AVAudioFormat)",
        "start_line": "30",
        "end_line": "39",
        "file_path": "Sources/AudioKit/Internals/Engine/AudioEngine.swift",
        "docstring": "The function connect(input: AVAudioNode, bus: Int, format: AVAudioFormat) connects an AVAudioNode to the audio engine. It first checks if the node is already connected to the specified bus, and if not, adds the connection point and establishes the connection using the provided format.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "750c3d966091",
        "ground_truth": "func connect(input: AVAudioNode, bus: Int, format: AVAudioFormat) {\n    if let engine = engine {\n        var points = engine.outputConnectionPoints(for: input, outputBus: 0)\n        if points.contains(where: {\n            $0.node === self && $0.bus == bus\n        }) { return }\n        points.append(AVAudioConnectionPoint(node: self, bus: bus))\n        engine.connect(input, to: points, fromBus: 0, format: format)\n    }\n}",
        "import_statements": [
            "import AVFoundation"
        ],
        "reference_api": [
            "engine.outputConnectionPoints",
            "points.contains",
            "AVAudioConnectionPoint"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "AudioKit/AudioKit",
        "function_declaration": "public convenience init?(file: AVAudioFile)",
        "start_line": "167",
        "end_line": "176",
        "file_path": "Sources/AudioKit/Internals/Table/Table.swift",
        "docstring": "The convenience initializer init?(file: AVAudioFile) initializes an object with the length of the AVAudioFile. It retrieves the file's float channel data, and if successful, populates the object's data with the values from the first channel of the audio file.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7d7f72a20499",
        "ground_truth": "public convenience init?(file: AVAudioFile) {\n    let size = Int(file.length)\n    self.init(count: size)\n    guard let data = file.toFloatChannelData() else { return nil }\n    // Note: this is only taking the first channel of a file\n    for i in 0 ..< size {\n        self[i] = data[0][i]\n    }\n}",
        "import_statements": ["import AVFoundation"],
        "reference_api": ["file.toFloatChannelData"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "AudioKit/AudioKit",
        "function_declaration": "private func nextResponderAsViewController(responder: UIResponder?) -> UIViewController? ",
        "start_line": "62",
        "end_line": "71",
        "file_path": "Sources/AudioKit/MIDI/BluetoothMIDIButton.swift",
        "docstring": "The function nextResponderAsViewController(responder: UIResponder?) -> UIViewController? recursively traverses the responder chain to find and return the next UIResponder that is a UIViewController. If no such responder is found, it returns nil.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e4c008d13790",
        "ground_truth": "private func nextResponderAsViewController(responder: UIResponder?) -> UIViewController? {\n    let next: UIResponder? = responder?.next\n    if let viewController = next as? UIViewController {\n        return viewController\n    } else if next == nil {\n        return nil\n    } else {\n        return nextResponderAsViewController(responder: next)\n    }\n}",
        "import_statements": [
            "import CoreAudioKit"
        ],
        "reference_api": ["nextResponderAsViewController"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "AudioKit/AudioKit",
        "function_declaration": "func clearTempoEvents(_ track: MusicTrack)",
        "start_line": "312",
        "end_line": "320",
        "file_path": "Sources/AudioKit/Sequencing/Apple Sequencer/AppleSequencer.swift",
        "docstring": "The function clearTempoEvents(_ track: MusicTrack) iterates through the events in a MusicTrack and deletes any event of type kMusicEventType_ExtendedTempo using the MusicEventIteratorDeleteEvent function.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ef9de16c8707",
        "ground_truth": "func clearTempoEvents(_ track: MusicTrack) {\n    MusicTrackManager.iterateMusicTrack(track) { iterator, _, eventType, _, _, isReadyForNextEvent in\n        isReadyForNextEvent = true\n        if eventType == kMusicEventType_ExtendedTempo {\n            MusicEventIteratorDeleteEvent(iterator)\n            isReadyForNextEvent = false\n        }\n    }\n}",
        "import_statements": [
            "import AVFoundation"
        ],
        "reference_api": [
            "MusicTrackManager.iterateMusicTrack",
            "MusicEventIteratorDeleteEvent"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "AudioKit/AudioKit",
        "function_declaration": "public func loadMIDIFile(_ filename: String)",
        "start_line": "563",
        "end_line": "571",
        "file_path": "Sources/AudioKit/Sequencing/Apple Sequencer/AppleSequencer.swift",
        "docstring": "The function loadMIDIFile(_ filename: String) loads a MIDI file from the main bundle by constructing its path using the provided filename. If the file is found, it creates a URL and calls loadMIDIFile(fromURL:). If not, it logs an error message.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "27412925490c",
        "ground_truth": "public func loadMIDIFile(_ filename: String) {\n    let bundle = Bundle.main\n    guard let file = bundle.path(forResource: filename, ofType: \"mid\") else {\n        Log(\"No midi file found\")\n        return\n    }\n    let fileURL = URL(fileURLWithPath: file)\n    loadMIDIFile(fromURL: fileURL)\n}",
        "import_statements": [
            "import AVFoundation"
        ],
        "reference_api": [
            "loadMIDIFile"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"loadMIDIFile",
                "code":"public func loadMIDIFile(fromURL fileURL: URL) {\n        removeTracks()\n        if let existingSequence = sequence {\n            let status: OSStatus = MusicSequenceFileLoad(existingSequence,\n                                                         fileURL as CFURL,\n                                                         .midiType,\n                                                         MusicSequenceLoadFlags())\n            if status != OSStatus(noErr) {\n                Log(\"error reading midi file url: \\(fileURL), read status: \\(status)\")\n            }\n        }\n        initTracks()\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Ramotion/folding-cell",
        "function_declaration": "private func configureDefaultState()",
        "start_line": "81",
        "end_line": "99",
        "file_path": "FoldingCell/FoldingCell/FoldingCell.swift",
        "docstring": "The function configureDefaultState() sets up the initial state by configuring layout constraints and view properties. It ensures foregroundViewTop and containerViewTop are set, aligns their constants, sets containerView's alpha to 0, adjusts the foregroundView's anchor point and constant based on its height constraint, applies a 3D transform, creates an animation view, and brings the foregroundView to the front of the contentView.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1f7c7b285b61",
        "ground_truth": "private func configureDefaultState() {\n         guard let foregroundViewTop = self.foregroundViewTop,\n        let containerViewTop = self.containerViewTop else {\n            fatalError(\"set foregroundViewTop or containerViewTop outlets in storyboard\")\n    }\n         containerViewTop.constant = foregroundViewTop.constant\n    containerView.alpha = 0\n         if let height = (foregroundView.constraints.filter { $0.firstAttribute == .height && $0.secondItem == nil }).first?.constant {\n        foregroundView.layer.anchorPoint = CGPoint(x: 0.5, y: 1)\n        foregroundViewTop.constant += height / 2\n    }\n    foregroundView.layer.transform = foregroundView.transform3d()\n         createAnimationView()\n    contentView.bringSubviewToFront(foregroundView)\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "foregroundView.transform3d",
            "createAnimationView",
            "contentView.bringSubviewToFront"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "foregroundView.transform3d",
                "code":"func transform3d() -> CATransform3D {\n        var transform = CATransform3DIdentity\n        transform.m34 = 2.5 / -2000\n        return transform\n    }"
            },
            {
                "name":"createAnimationView",
                "code":"func createAnimationView() {\n        animationView = UIView(frame: containerView.frame)\n        animationView?.layer.cornerRadius = foregroundView.layer.cornerRadius\n        animationView?.backgroundColor = .clear\n        animationView?.translatesAutoresizingMaskIntoConstraints = false\n        animationView?.alpha = 0\n        \n        guard let animationView = self.animationView else { return }\n        \n        self.contentView.addSubview(animationView)\n        \n        // copy constraints from containerView\n        var newConstraints = [NSLayoutConstraint]()\n        for constraint in self.contentView.constraints {\n            if let item = constraint.firstItem as? UIView, item == containerView {\n                let newConstraint = NSLayoutConstraint(item: animationView, attribute: constraint.firstAttribute,\n                                                       relatedBy: constraint.relation, toItem: constraint.secondItem, attribute: constraint.secondAttribute,\n                                                       multiplier: constraint.multiplier, constant: constraint.constant)\n                \n                newConstraints.append(newConstraint)\n            } else if let firstItem = constraint.firstItem as? UIView, let secondItem: UIView = constraint.secondItem as? UIView, secondItem == containerView {\n                let newConstraint = NSLayoutConstraint(item: firstItem, attribute: constraint.firstAttribute,\n                                                       relatedBy: constraint.relation, toItem: animationView, attribute: constraint.secondAttribute,\n                                                       multiplier: constraint.multiplier, constant: constraint.constant)\n                \n                newConstraints.append(newConstraint)\n            }\n        }\n        self.contentView.addConstraints(newConstraints)\n        \n        for constraint in containerView.constraints { // added height constraint\n            if constraint.firstAttribute == .height, let item: UIView = constraint.firstItem as? UIView, item == containerView {\n                let newConstraint = NSLayoutConstraint(item: animationView, attribute: constraint.firstAttribute,\n                                                       relatedBy: constraint.relation, toItem: nil, attribute: constraint.secondAttribute,\n                                                       multiplier: constraint.multiplier, constant: constraint.constant)\n                \n                animationView.addConstraint(newConstraint)\n            }\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "Ramotion/folding-cell",
        "function_declaration": "private func createAnimationItemView() -> [RotatedView]",
        "start_line": "101",
        "end_line": "120",
        "file_path": "FoldingCell/FoldingCell/FoldingCell.swift",
        "docstring": "The function createAnimationItemView() -> [RotatedView] creates and returns an array of RotatedView items. It starts by adding foregroundView to the items array, then collects and sorts RotatedView subviews from animationView, including their backViews, and appends them to the items array.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0372df96b702",
        "ground_truth": "private func createAnimationItemView() -> [RotatedView] {\n         var items = [RotatedView]()\n    items.append(foregroundView)\n    var rotatedViews = [RotatedView]()\n         animationView?.subviews\n        .lazy\n        .compactMap({ $0 as? RotatedView })\n        .sorted(by: { $0.tag < $1.tag })\n        .forEach { itemView in\n            rotatedViews.append(itemView)\n            if let backView = itemView.backView {\n                rotatedViews.append(backView)\n            }\n    }\n         items.append(contentsOf: rotatedViews)\n    return items\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "mac-cain13/R.swift",
        "function_declaration": "static public func parse(url: URL) throws -> AssetCatalog",
        "start_line": "23",
        "end_line": "33",
        "file_path": "Sources/RswiftParsers/Resources/AssetCatalog+Parser.swift",
        "docstring": "The function parse(url: URL) throws -> AssetCatalog attempts to parse an AssetCatalog from the provided URL. It extracts the filename without extension, parses the directory at the URL, creates a namespace from the directory, and returns an AssetCatalog with the filename and namespace. If the filename extraction fails, it throws a ResourceParsingError.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "feb85b8c093b",
        "ground_truth": "static public func parse(url: URL) throws -> AssetCatalog {\n    guard let basename = url.filenameWithoutExtension else {\n        throw ResourceParsingError(\"Couldn't extract filename from URL: \\(url)\")\n    }\n    let directory = try parseDirectory(catalogURL: url)\n    let namespace = try createNamespace(directory: directory, path: [])\n    return AssetCatalog(filename: basename, root: namespace)\n}",
        "import_statements": [
            "import Foundation",
            "import RswiftResources"
        ],
        "reference_api": [
            "ResourceParsingError",
            "parseDirectory",
            "createNamespace",
            "AssetCatalog"
        ],
        "repo_defined_api_with_code": [
            {
                "name":"parseDirectory",
                "code":"static private func parseDirectory(catalogURL: URL) throws -> NamespaceDirectory {\n        let fileManager = FileManager.default\n        func errorHandler(_ url: URL, _ error: Error) -> Bool {\n            assertionFailure((error as NSError).debugDescription)\n            return true\n        }\n        let options: FileManager.DirectoryEnumerationOptions\n        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *) {\n            #if !os(Linux)\n            options = [.skipsHiddenFiles, .producesRelativePathURLs]\n            #else\n            options = [.skipsHiddenFiles]\n            #endif\n        } else {\n            options = [.skipsHiddenFiles]\n        }\n        guard let directoryEnumerator = fileManager.enumerator(at: catalogURL, includingPropertiesForKeys: [.isDirectoryKey], options: options, errorHandler: errorHandler) else {\n            throw ResourceParsingError(\"Supposed AssetCatalog \\(catalogURL) can't be enumerated\")\n        }\n\n        let root = NamespaceDirectory()\n        var namespaces: [URL: NamespaceDirectory] = [URL(fileURLWithPath: \".\", relativeTo: catalogURL): root]\n\n        for case let fileURL as URL in directoryEnumerator {\n            guard fileURL.baseURL?.resolvingSymlinksInPath() == catalogURL.resolvingSymlinksInPath() else {\n                throw ResourceParsingError(\"File \\(fileURL) is not in AssetCatalog \\(catalogURL)\")\n            }\n\n            let resourceValues = try fileURL.resourceValues(forKeys: [.isDirectoryKey])\n            let isDirectory = resourceValues.isDirectory!\n\n            guard let filename = fileURL.filenameWithoutExtension else {\n                throw ResourceParsingError(\"Missing filename in \\(fileURL)\")\n            }\n            let pathExtension = fileURL.pathExtension\n\n            let relativeURL = URL(fileURLWithPath: fileURL.relativePath, relativeTo: catalogURL)\n            var parentURL = relativeURL\n            var parent: NamespaceDirectory?\n            for _ in 0..<directoryEnumerator.level {\n                parentURL = parentURL.deletingLastPathComponent()\n                parent = namespaces[parentURL]\n                if parent != nil { break }\n            }\n\n            guard let parent = parent else {\n                throw ResourceParsingError(\"Can't find namespace in AssetCatalog \\(catalogURL) for \\(fileURL)\")\n            }\n\n            if imageExtensions.contains(pathExtension) {\n                parent.images.append(fileURL)\n            } else if colorExtensions.contains(pathExtension) {\n                parent.colors.append(fileURL)\n            } else if datasetExtensions.contains(pathExtension) {\n                parent.dataAssets.append(fileURL)\n            } else if ignoredExtensions.contains(pathExtension) {\n                directoryEnumerator.skipDescendants()\n            } else if isDirectory && parseProvidesNamespace(directory: fileURL) {\n                let ns = NamespaceDirectory()\n                namespaces[relativeURL] = ns\n                parent.subnamespaces[filename] = ns\n            } else if isDirectory {\n                // Ignore\n            } else {\n                // Unknown\n            }\n        }\n\n        return root\n    }"
            },
            {
                "name":"createNamespace",
                "code":"static private func createNamespace(directory: NamespaceDirectory, path: [String]) throws -> Namespace {\n\n        var subnamespaces: [String: AssetCatalog.Namespace] = [:]\n        for (name, directory) in directory.subnamespaces {\n            let namespace = try createNamespace(directory: directory, path: path + [name])\n            subnamespaces[name] = namespace\n        }\n\n        var colors: [ColorResource] = []\n        for fileURL in directory.colors {\n            let name = fileURL.filenameWithoutExtension!\n            colors.append(.init(name: name, path: path, bundle: .temp))\n        }\n\n        var images: [ImageResource] = []\n        for fileURL in directory.images {\n            let name = fileURL.filenameWithoutExtension!\n            let tags = parseOnDemandResourceTags(directory: fileURL)\n            images.append(.init(name: name, path: path, bundle: .temp, locale: nil, onDemandResourceTags: tags))\n        }\n\n        var dataAssets: [DataResource] = []\n        for fileURL in directory.dataAssets {\n            let name = fileURL.filenameWithoutExtension!\n            let tags = parseOnDemandResourceTags(directory: fileURL)\n            dataAssets.append(.init(name: name, path: path, bundle: .temp, onDemandResourceTags: tags))\n        }\n\n        return AssetCatalog.Namespace(\n            subnamespaces: subnamespaces,\n            colors: colors,\n            images: images,\n            dataAssets: dataAssets\n        )\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "mac-cain13/R.swift",
        "function_declaration": "private func parseProvidesNamespace(directory: URL) -> Bool",
        "start_line": "155",
        "end_line": "162",
        "file_path": "Sources/RswiftParsers/Resources/AssetCatalog+Parser.swift",
        "docstring": "The function parseProvidesNamespace(directory: URL) -> Bool checks if the provided directory contains a Contents.json file and parses it. If the file exists and has a providesNamespace property, it returns its value; otherwise, it returns false.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "89dc73f30d68",
        "ground_truth": "private func parseProvidesNamespace(directory: URL) -> Bool {\n    guard\n        let contents = try? ContentsJson.parse(directory: directory),\n        let providesNamespace = contents.properties.providesNamespace\n    else { return false }\n     return providesNamespace\n}",
        "import_statements": [
            "import Foundation",
            "import RswiftResources"
        ],
        "reference_api": ["ContentsJson.parse"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "mac-cain13/R.swift",
        "function_declaration": "private func parseStringsdictParams(_ format: String, dict: [String: AnyObject]) throws -> [StringParam]",
        "start_line": "102",
        "end_line": "117",
        "file_path": "Sources/RswiftParsers/Resources/StringsTable+Parser.swift",
        "docstring": "The function parseStringsdictParams(_ format: String, dict: [String: AnyObject]) throws -> [StringParam] parses a format string into parts and processes each part. It handles references by looking them up in the provided dictionary and adds format specifiers directly to the params array, ultimately returning the array of StringParam.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3409224b04bb",
        "ground_truth": "private func parseStringsdictParams(_ format: String, dict: [String: AnyObject]) throws -> [StringParam] {\n    var params: [StringParam] = []\n     let parts = FormatPart.formatParts(formatString: format)\n    for part in parts {\n        switch part {\n        case .reference(let reference):\n            params += try lookup(key: reference, in: dict)\n         case .spec(let formatSpecifier):\n            params.append(StringParam(name: nil, spec: formatSpecifier))\n        }\n    }\n     return params\n}",
        "import_statements": [
            "import Foundation",
            "import RswiftResources"
        ],
        "reference_api": [
            "FormatPart.formatParts",
            "lookup"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "mac-cain13/R.swift",
        "function_declaration": "private func findTarget(name: String) throws -> PBXTarget",
        "start_line": "48",
        "end_line": "57",
        "file_path": "Sources/RswiftParsers/Shared/Xcodeproj.swift",
        "docstring": "The function findTarget(name: String) throws -> PBXTarget searches for a target with the given name in the project file. If the target is not found, it throws a ResourceParsingError with a message listing the available targets.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9e668d5ac53f",
        "ground_truth": "private func findTarget(name: String) throws -> PBXTarget {\n    // Look for target in project file\n    let allTargets = projectFile.project.targets.compactMap { $0.value }\n    guard let target = allTargets.filter({ $0.name == name }).first else {\n        let availableTargets = allTargets.compactMap { $0.name }.joined(separator: \", \")\n        throw ResourceParsingError(\"Target '\\(name)' not found in project file, available targets are: \\(availableTargets)\")\n    }\n    return target\n}",
        "import_statements": [
            "import Foundation",
            "import XcodeEdit"
        ],
        "reference_api": ["ResourceParsingError"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "IBAnimatable/IBAnimatable",
        "function_declaration": "override func viewDidLoad()",
        "start_line": "13",
        "end_line": "19",
        "file_path": "IBAnimatableApp/IBAnimatableApp/Playground/Presentations/PresentedViewController.swift",
        "docstring": "The function viewDidLoad() overrides the superclass method to perform additional setup after the view loads. It checks if the view is of type AnimatableView and, if so, assigns it a random predefined gradient using the makeRandomGradient() function.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "73ef64c3d03e",
        "ground_truth": "override func viewDidLoad() {\n  super.viewDidLoad()\n  if let animatableView = view as? AnimatableView {\n    animatableView.predefinedGradient = makeRandomGradient()\n  }\n}",
        "import_statements": [
            "mport UIKit\n",
            "mport IBAnimatable\n"
        ],
        "reference_api": ["makeRandomGradient"],
        "repo_defined_api_with_code": [
            {
                "name":"makeRandomGradient",
                "code":"func makeRandomGradient() -> GradientType {\n    var predefinedGradients = [GradientType]()\n    iterateEnum(GradientType.self).forEach {\n      predefinedGradients.append($0)\n    }\n\n    let randomIndex: Int = Int.random(in: 0..<predefinedGradients.count)\n    return predefinedGradients[randomIndex]\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "IBAnimatable/IBAnimatable",
        "function_declaration": "public func refresh(_ refreshControl: UIRefreshControl)",
        "start_line": "19",
        "end_line": "32",
        "file_path": "IBAnimatableApp/IBAnimatableApp/Playground/Refresh Control/RefreshControlTableViewController.swift",
        "docstring": "The function refresh(_ refreshControl: UIRefreshControl) initiates a refresh action with a fixed duration of 5 seconds, updating a message via updateMessage(refreshControl:time:). After the specified time, it stops the refresh animation by calling endRefreshing() on the main thread.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bbb7276690c2",
        "ground_truth": "public func refresh(_ refreshControl: UIRefreshControl) {\n  // could update attributedTitle of refreshControl here\n  // Simulate an asynchrone refresh, could be a network request...\n  let time: TimeInterval = 5\n  updateMessage(refreshControl: refreshControl, time: time)\n  DispatchQueue.background.after(time) {\n    // could update attributedTitle at each step\n    // end refreshing, maybe reload table data if you do not implement table delegate to update each insert, update and delete events\n    DispatchQueue.main.async {\n      refreshControl.endRefreshing()\n    }\n  }\n}",
        "import_statements": [
            "import UIKit\n",
            "import IBAnimatable\n"
        ],
        "reference_api": ["updateMessage","DispatchQueue.background.after","refreshControl.endRefreshing"],
        "repo_defined_api_with_code": [
            {
                "name":"updateMessage",
                "code":"func updateMessage(refreshControl: UIRefreshControl, time: TimeInterval) {\n    guard time >= 0 else {\n      return\n    }\n\n    var attributes = [NSAttributedString.Key: Any]()\n    if let color = tableView.refreshControlTintColor {\n      attributes[NSAttributedString.Key.foregroundColor] = color\n    }\n    refreshControl.attributedTitle = NSAttributedString(string: \"\\(Int(time))\", attributes: attributes )\n\n    DispatchQueue.main.after(1) {\n      self.updateMessage(refreshControl: refreshControl, time: time - 1)\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "IBAnimatable/IBAnimatable",
        "function_declaration": "func updateMessage(refreshControl: UIRefreshControl, time: TimeInterval)",
        "start_line": "35",
        "end_line": "49",
        "file_path": "IBAnimatableApp/IBAnimatableApp/Playground/Refresh Control/RefreshControlTableViewController.swift",
        "docstring": "The function updateMessage(refreshControl: UIRefreshControl, time: TimeInterval) updates the title of a UIRefreshControl with the remaining time. If time is non-negative, it sets the attributed title with optional color attributes and recursively calls itself every second, decrementing the time.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d43714625da9",
        "ground_truth": "func updateMessage(refreshControl: UIRefreshControl, time: TimeInterval) {\n  guard time >= 0 else {\n    return\n  }\n  var attributes = [NSAttributedString.Key: Any]()\n  if let color = refreshControlTintColor {\n    attributes[NSAttributedString.Key.foregroundColor] = color\n  }\n  refreshControl.attributedTitle = NSAttributedString(string: \"\\(Int(time))\", attributes: attributes )\n  DispatchQueue.main.after(1) {\n    self.updateMessage(refreshControl: refreshControl, time: time - 1)\n  }\n}",
        "import_statements": [
            "import UIKit\n",
            "import IBAnimatable\n"
        ],
        "reference_api": [
            "NSAttributedString"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "IBAnimatable/IBAnimatable",
        "function_declaration": "public func refresh(_ refreshControl: UIRefreshControl) ",
        "start_line": "33",
        "end_line": "46",
        "file_path": "IBAnimatableApp/IBAnimatableApp/Playground/Refresh Control/RefreshControlTableViewViewController.swift",
        "docstring": "The function refresh(_ refreshControl: UIRefreshControl) initiates a refresh operation with a fixed time interval of 5 seconds. It updates the message using updateMessage(refreshControl:time:), then schedules the end of the refreshing state on the main thread after the specified time interval using DispatchQueue.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "db1bb9d6a67f",
        "ground_truth": "public func refresh(_ refreshControl: UIRefreshControl) {\n  // could update attributedTitle of refreshControl here\n  // Simulate an asynchrone refresh, could be a network request...\n  let time: TimeInterval = 5\n  updateMessage(refreshControl: refreshControl, time: time)\n  DispatchQueue.background.after(time) {\n    // could update attributedTitle at each step\n    // end refreshing, maybe reload table data if you do not implement table delegate to update each insert, update and delete events\n    DispatchQueue.main.async {\n      refreshControl.endRefreshing()\n    }\n  }\n}",
        "import_statements": [
            "import UIKit\n",
            "import IBAnimatable\n"
        ],
        "reference_api": ["updateMessage"],
        "repo_defined_api_with_code": [
            {
                "name":"updateMessage",
                "code":"func updateMessage(refreshControl: UIRefreshControl, time: TimeInterval) {\n    guard time >= 0 else {\n      return\n    }\n\n    var attributes = [NSAttributedString.Key: Any]()\n    if let color = tableView.refreshControlTintColor {\n      attributes[NSAttributedString.Key.foregroundColor] = color\n    }\n    refreshControl.attributedTitle = NSAttributedString(string: \"\\(Int(time))\", attributes: attributes )\n\n    DispatchQueue.main.after(1) {\n      self.updateMessage(refreshControl: refreshControl, time: time - 1)\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "IBAnimatable/IBAnimatable",
        "function_declaration": "func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView",
        "start_line": "54",
        "end_line": "61",
        "file_path": "IBAnimatableApp/IBAnimatableApp/Playground/UserInterfaces/Gradients/GradientViewController.swift",
        "docstring": "The function pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView creates and returns a UILabel for the given row and component in a UIPickerView. The label is configured with white text color, centered text alignment, a minimum scale factor of 0.5, and sets its text to the title of the component value at the specified row.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3271370cf1f0",
        "ground_truth": "func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView {\n  let label = UILabel()\n  label.textColor = .white\n  label.textAlignment = .center\n  label.minimumScaleFactor = 0.5\n  label.text = componentValues[component].title(at: row)\n  return label\n}",
        "import_statements": [
            "import UIKit\n",
            "import IBAnimatable\n"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "IBAnimatable/IBAnimatable",
        "function_declaration": "override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell",
        "start_line": "27",
        "end_line": "35",
        "file_path": "IBAnimatableApp/IBAnimatableApp/Playground/UserInterfaces/Gradients/PredefinedGradientCollectionViewController.swift",
        "docstring": "The function collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell overrides the method to dequeue a reusable cell and configure it. If the dequeued cell is of type PredefinedGradientCollectionViewCell, it sets the cell's nameLabel text and predefinedGradient based on the gradientTypes array at the corresponding indexPath row.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "89f92efa1d65",
        "ground_truth": "override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n  let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"cell\", for: indexPath)\n  if let cell = cell as? PredefinedGradientCollectionViewCell {\n    let type = gradientTypes[indexPath.row]\n    cell.nameLabel.text = type.rawValue\n    cell.predefinedGradient = type\n  }\n  return cell\n}",
        "import_statements": [
            "import UIKit\n",
            "import IBAnimatable\n"
        ],
        "reference_api": ["collectionView.dequeueReusableCell"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "IBAnimatable/IBAnimatable",
        "function_declaration": "func retrieveGestureText(interactiveGestureType: InteractiveGestureType, transitionAnimationType: TransitionAnimationType, exit: String) -> String",
        "start_line": "21",
        "end_line": "36",
        "file_path": "IBAnimatableApp/IBAnimatableApp/Playground/Utils/UIViewControllerExtension.swift",
        "docstring": "The function retrieveGestureText(interactiveGestureType: InteractiveGestureType, transitionAnimationType: TransitionAnimationType, exit: String) -> String returns a descriptive string based on the provided gesture type. For the default gesture type, it checks if the transition animator has an interactive gesture type and returns a corresponding string. For other gesture types, it directly returns a string describing the gesture to perform the exit action.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1b584c58c3e7",
        "ground_truth": "func retrieveGestureText(interactiveGestureType: InteractiveGestureType, transitionAnimationType: TransitionAnimationType, exit: String) -> String {\n  switch interactiveGestureType {\n  case .default:\n    // Default gesture\n    let transitionAnimator = AnimatorFactory.makeAnimator(transitionAnimationType: transitionAnimationType)\n    if let interactiveGestureType = transitionAnimator?.interactiveGestureType {\n      return String(\"or use \\(interactiveGestureType.stringValueWithoutQualification) gesture to \\(exit)\")\n    }\n    // The transition animator doesn't have default `interactiveGestureType`\n    return \"\"\n  default:\n    // Specified gesture\n    return String(\"or use \\(interactiveGestureType.stringValueWithoutQualification) gesture to \\(exit)\")\n  }\n}",
        "import_statements": [
            "import UIKit\n",
            "import IBAnimatable\n"
        ],
        "reference_api": [
            "AnimatorFactory.makeAnimator"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "kickstarter/ios-oss",
        "function_declaration": "fileprivate func present(project: Project, refTag: RefTag)",
        "start_line": "199",
        "end_line": "210",
        "file_path": "Kickstarter-iOS/Features/Activities/Controller/ActivitiesViewController.swift",
        "docstring": "The function present(project: Project, refTag: RefTag) presents a ProjectPageViewController configured with the given project and refTag. It embeds the view controller in a NavigationController and sets its modal presentation style based on the device type before presenting it modally with animation.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "15cf3f988a5b",
        "ground_truth": "fileprivate func present(project: Project, refTag: RefTag) {\n  let projectParam = Either<Project, Param>(left: project)\n  let vc = ProjectPageViewController.configuredWith(\n    projectOrParam: projectParam,\n    refInfo: RefInfo(refTag)\n  )\n  let nav = NavigationController(rootViewController: vc)\n  nav.modalPresentationStyle = self.traitCollection.userInterfaceIdiom == .pad ? .fullScreen : .formSheet\n  self.present(nav, animated: true, completion: nil)\n}",
        "import_statements": [
            "import KsApi",
            "import Library",
            "import Prelude",
            "import ReactiveSwift",
            "import UIKit"
        ],
        "reference_api": ["ProjectPageViewController.configuredWith"],
        "repo_defined_api_with_code": [
            {
                "name":"ProjectPageViewController.configuredWith",
                "code":"internal static func configuredWith(project: Project, update: Update, context _: KSRAnalytics.UpdateContext)\n    -> UpdateViewController {\n    let vc = Storyboard.Update.instantiate(UpdateViewController.self)\n    vc.viewModel.inputs.configureWith(project: project, update: update)\n    vc.shareViewModel.inputs.configureWith(shareContext: .update(project, update), shareContextView: nil)\n\n    return vc\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "kickstarter/ios-oss",
        "function_declaration": "private func selectButton(atTab tab: BackerDashboardTab)",
        "start_line": "238",
        "end_line": "245",
        "file_path": "Kickstarter-iOS/Features/BackerDashboardPages/Controller/BackerDashboardViewController.swift",
        "docstring": "The function selectButton(atTab tab: BackerDashboardTab) sets the selected state of a button corresponding to the given tab. It finds the button index using pagesDataSource.indexFor(tab:), then iterates over menuButtonsStackView's subviews, setting the isSelected property of the UIButton at the found index to true and others to false.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "db84f34688e9",
        "ground_truth": "private func selectButton(atTab tab: BackerDashboardTab) {\n  guard let index = self.pagesDataSource.indexFor(tab: tab) else { return }\n  for (idx, button) in self.menuButtonsStackView.arrangedSubviews.enumerated() {\n    _ = (button as? UIButton)\n      ?|> UIButton.lens.isSelected .~ (idx == index)\n  }\n}",
        "import_statements": [
            "import KsApi",
            "import Library",
            "import Prelude",
            "import UIKit"
        ],
        "reference_api": ["self.pagesDataSource.indexFor"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "soapyigu/Swift-30-Projects",
        "function_declaration": "override func tableView(_ tableView: UITableView,\n                            cellForRowAt indexPath: IndexPath) -> UITableViewCell",
        "start_line": "47",
        "end_line": "60",
        "file_path": "Project 01 - GoodAsOldPhones/GoodAsOldPhones/ProductsTableViewController.swift",
        "docstring": "The function tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell overrides the UITableViewDataSource method to configure and return a cell. It dequeues a reusable cell, sets its text label to the product name at the given indexPath, and sets the image if an image name is available.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "85b821a03deb",
        "ground_truth": "override func tableView(_ tableView: UITableView,\n                        cellForRowAt indexPath: IndexPath) -> UITableViewCell\n{\n    let cell = tableView.dequeueReusableCell(withIdentifier: identifer, for: indexPath)\n    guard let products = products else { return cell }\n    cell.textLabel?.text = products[indexPath.row].name\n    if let imageName = products[indexPath.row].cellImageName {\n        cell.imageView?.image = UIImage(named: imageName)\n    }\n    return cell;\n}",
        "import_statements": [
            "import UIKit\n"
        ],
        "reference_api": [
            "tableView.dequeueReusableCell",
            "UIImage"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "soapyigu/Swift-30-Projects",
        "function_declaration": "override func prepare(for segue: UIStoryboardSegue, sender: Any?)",
        "start_line": "27",
        "end_line": "35",
        "file_path": "Project 01 - GoodAsOldPhones/GoodAsOldPhones/ProductsTableViewController.swift",
        "docstring": "The function prepare(for segue: UIStoryboardSegue, sender: Any?) overrides the method to configure the destination view controller before a segue. If the segue identifier is \"showProduct\", it retrieves the selected cell and its indexPath, then sets the product property of the destination ProductViewController to the corresponding product.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4e9fe861470c",
        "ground_truth": "override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n  if segue.identifier == \"showProduct\" {\n    if let cell = sender as? UITableViewCell,\n      let indexPath = tableView.indexPath(for: cell),\n      let productVC = segue.destination as? ProductViewController {\n      productVC.product = products?[indexPath.row]\n    }\n  }\n}",
        "import_statements": [
            "import UIKit\n"
        ],
        "reference_api": ["tableView.indexPath"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "soapyigu/Swift-30-Projects",
        "function_declaration": "func configCell(with item: ToDoItem, isChecked: Bool = false)",
        "start_line": "32",
        "end_line": "51",
        "file_path": "Project 04 - TodoTDD/ToDo/Views/ItemCell.swift",
        "docstring": "The function configCell(with item: ToDoItem, isChecked: Bool = false) configures the cell's appearance based on the ToDoItem and isChecked flag. If isChecked is true, it sets the titleLabel with a strikethrough style and clears the dateLabel and locationLabel. Otherwise, it sets the titleLabel with the item title, dateLabel with the formatted date if a timestamp is available, and locationLabel with the location name if available.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4d25d9a3a34a",
        "ground_truth": "func configCell(with item: ToDoItem, isChecked: Bool = false) {\n    if isChecked {\n        let attributedString = NSAttributedString(string: item.title, attributes: [NSAttributedString.Key.strikethroughStyle: NSUnderlineStyle.single.rawValue])\n                 titleLabel.attributedText = attributedString\n        dateLabel.text = nil\n        locationLabel.text = nil\n    } else {\n        titleLabel.text = item.title\n                 if let timestamp = item.timestamp {\n            let date = Date(timeIntervalSince1970: timestamp)\n            dateLabel.text = dateFormatter.string(from: date)\n        }\n                 if let location = item.location {\n            locationLabel.text = location.name\n        }\n    }\n}",
        "import_statements": [
            "import UIKit\n"
        ],
        "reference_api": ["NSAttributedString"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "soapyigu/Swift-30-Projects",
        "function_declaration": "  override func prepare(for segue: UIStoryboardSegue, sender: Any?)",
        "start_line": "121",
        "end_line": "136",
        "file_path": "Project 06 - CandySearch/CandySearch/MasterViewController.swift",
        "docstring": "The function prepare(for segue: UIStoryboardSegue, sender: Any?) overrides the method to configure the destination view controller before a segue. If the segue identifier is \"showDetail\" and a row is selected, it determines the selected candy from either filteredCandies or candies based on the search controller's state. It then sets the candy to the detail view controller and configures its navigation items.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "eac7c203a2e2",
        "ground_truth": "override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n  if segue.identifier == \"showDetail\" {\n    if let indexPath = tableView.indexPathForSelectedRow {\n      let candy: Candy\n      if searchController.isActive {\n        candy = filteredCandies[(indexPath as NSIndexPath).row]\n      } else {\n        candy = candies[(indexPath as NSIndexPath).row]\n      }\n      let controller = (segue.destination as! UINavigationController).topViewController as! DetailViewController\n      controller.detailCandy = candy\n      controller.navigationItem.leftBarButtonItem = splitViewController?.displayModeButtonItem\n      controller.navigationItem.leftItemsSupplementBackButton = true\n    }\n  }\n}",
        "import_statements": [
            "import UIKit"
        ],
        "reference_api": [
            "controller.detailCandy"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "IOS",
        "owner/repo": "soapyigu/Swift-30-Projects",
        "function_declaration": "private mutating func bubbleToLowerPriority(_ initialUnbalancedIndex: Int)",
        "start_line": "83",
        "end_line": "107",
        "file_path": "Project 07 - PokedexGo/Pods/RxCocoa/Platform/DataStructures/PriorityQueue.swift",
        "docstring": "The function bubbleToLowerPriority(_ initialUnbalancedIndex: Int) adjusts the position of an element at the given index in a heap by repeatedly swapping it with its higher priority child until it reaches a position where it has a lower priority than both its children, ensuring the heap property is maintained.\\n",
        "language": "Swift",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "1ecd1788aecb",
        "ground_truth": "private mutating func bubbleToLowerPriority(_ initialUnbalancedIndex: Int) {\n    precondition(initialUnbalancedIndex >= 0)\n    precondition(initialUnbalancedIndex < _elements.count)\n    var unbalancedIndex = initialUnbalancedIndex\n    while true {\n        let leftChildIndex = unbalancedIndex * 2 + 1\n        let rightChildIndex = unbalancedIndex * 2 + 2\n        var highestPriorityIndex = unbalancedIndex\n        if leftChildIndex < _elements.count && _hasHigherPriority(_elements[leftChildIndex], _elements[highestPriorityIndex]) {\n            highestPriorityIndex = leftChildIndex\n        }\n        if rightChildIndex < _elements.count && _hasHigherPriority(_elements[rightChildIndex], _elements[highestPriorityIndex]) {\n            highestPriorityIndex = rightChildIndex\n        }\n        guard highestPriorityIndex != unbalancedIndex else { break }\n        swap(&_elements[highestPriorityIndex], &_elements[unbalancedIndex])\n        unbalancedIndex = highestPriorityIndex\n    }\n}",
        "import_statements": [
            "import Foundation\n"
        ],
        "reference_api": ["precondition","_hasHigherPriority"],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "Genymobile/scrcpy",
        "function_declaration": "process_check_success_intr(struct sc_intr *intr, sc_pid pid, const char *name,\n                           unsigned flags)",
        "start_line": "152",
        "end_line": "170",
        "file_path": "app/src/adb/adb.c",
        "docstring": "The function process_check_success_intr(struct sc_intr *intr, sc_pid pid, const char *name, unsigned flags) checks if a process is successful. It attempts to set the process in intr and, if unsuccessful, returns false. It then calls process_check_success_internal with the specified parameters and close set to false. Afterward, it resets intr and closes the process before returning the result of process_check_success_internal.\\n",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8ea8dd329ef4",
        "ground_truth": "process_check_success_intr(struct sc_intr *intr, sc_pid pid, const char *name,\n                           unsigned flags) {\n    if (intr && !sc_intr_set_process(intr, pid)) {\n        // Already interrupted\n        return false;\n    }\n     // Always pass close=false, interrupting would be racy otherwise\n    bool ret = process_check_success_internal(pid, name, false, flags);\n     if (intr) {\n        sc_intr_set_process(intr, SC_PROCESS_NONE);\n    }\n     // Close separately\n    sc_process_close(pid);\n     return ret;\n}",
        "import_statements": [
            "#include \"adb.h\"\n",
            "#include <assert.h>\n",
            "#include <stdio.h>\n",
            "#include <stdlib.h>\n",
            "#include <string.h>\n",
            "#include \"adb_device.h\"\n",
            "#include \"adb_parser.h\"\n",
            "#include \"util/file.h\"\n",
            "#include \"util/log.h\"\n",
            "#include \"util/process_intr.h\"\n",
            "#include \"util/str.h\"\n"
        ],
        "reference_api": [
            "sc_intr_set_process",
            "sc_process_close",
            "process_check_success_internal"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "process_check_success_internal",
                "code": "static bool\nprocess_check_success_internal(sc_pid pid, const char *name, bool close,\n                               unsigned flags) {\n    bool log_errors = !(flags & SC_ADB_NO_LOGERR);\n\n    if (pid == SC_PROCESS_NONE) {\n        if (log_errors) {\n            LOGE(\"Could not execute \\\"%s\\\"\", name);\n        }\n        return false;\n    }\n    sc_exit_code exit_code = sc_process_wait(pid, close);\n    if (exit_code) {\n        if (log_errors) {\n            if (exit_code != SC_EXIT_CODE_NONE) {\n                LOGE(\"\\\"%s\\\" returned with value %\" SC_PRIexitcode, name,\n                     exit_code);\n            } else {\n                LOGE(\"\\\"%s\\\" exited unexpectedly\", name);\n            }\n        }\n        return false;\n    }\n    return true;\n}"
            }
        ],
        "third_party": [
            "sc_intr_set_process",
            "sc_process_close"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "Genymobile/scrcpy",
        "function_declaration": "bool\nsc_adb_disconnect(struct sc_intr *intr, const char *ip_port, unsigned flags)",
        "start_line": "412",
        "end_line": "419",
        "file_path": "app/src/adb/adb.c",
        "docstring": "The function sc_adb_disconnect(struct sc_intr *intr, const char *ip_port, unsigned flags) initiates an ADB disconnect command for the specified IP and port using sc_adb_execute. It then checks if the process executed successfully with process_check_success_intr and returns the result as a boolean.\\n",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9f04f9c664c2",
        "ground_truth": "bool\nsc_adb_disconnect(struct sc_intr *intr, const char *ip_port, unsigned flags) {\n    assert(ip_port);\n    const char *const argv[] = SC_ADB_COMMAND(\"disconnect\", ip_port);\n     sc_pid pid = sc_adb_execute(argv, flags);\n    return process_check_success_intr(intr, pid, \"adb disconnect\", flags);\n}",
        "import_statements": [
            "#include \"adb.h\"\n",
            "#include <assert.h>\n",
            "#include <stdio.h>\n",
            "#include <stdlib.h>\n",
            "#include <string.h>\n",
            "#include \"adb_device.h\"\n",
            "#include \"adb_parser.h\"\n",
            "#include \"util/file.h\"\n",
            "#include \"util/log.h\"\n",
            "#include \"util/process_intr.h\"\n",
            "#include \"util/str.h\"\n"
        ],
        "reference_api": [
            "assert",
            "SC_ADB_COMMAND",
            "process_check_success_intr",
            "sc_adb_execute"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "process_check_success_intr",
                "code": "static bool\nprocess_check_success_intr(struct sc_intr *intr, sc_pid pid, const char *name,\n                           unsigned flags) {\n    if (intr && !sc_intr_set_process(intr, pid)) {\n        // Already interrupted\n        return false;\n    }\n\n    // Always pass close=false, interrupting would be racy otherwise\n    bool ret = process_check_success_internal(pid, name, false, flags);\n\n    if (intr) {\n        sc_intr_set_process(intr, SC_PROCESS_NONE);\n    }\n\n    // Close separately\n    sc_process_close(pid);\n\n    return ret;\n}"
            },
            {
                "name": "sc_adb_execute",
                "code": "sc_pid\nsc_adb_execute(const char *const argv[], unsigned flags) {\n    return sc_adb_execute_p(argv, flags, NULL);\n}"
            }
        ],
        "third_party": [
            "assert",
            "SC_ADB_COMMAND"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "Genymobile/scrcpy",
        "function_declaration": "bool\nsc_adb_tunnel_open(struct sc_adb_tunnel *tunnel, struct sc_intr *intr,\n                   const char *serial, const char *device_socket_name,\n                   struct sc_port_range port_range, bool force_adb_forward)",
        "start_line": "124",
        "end_line": "145",
        "file_path": "app/src/adb/adb_tunnel.c",
        "docstring": "The function sc_adb_tunnel_open attempts to open an ADB tunnel by first trying \"adb reverse\" with the provided parameters. If this fails or if force_adb_forward is true, it falls back to using \"adb forward\" to establish the tunnel, returning the success status of the operation.\\n",
        "language": "C",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8a6f7b9e5f11",
        "ground_truth": "bool\nsc_adb_tunnel_open(struct sc_adb_tunnel *tunnel, struct sc_intr *intr,\n                   const char *serial, const char *device_socket_name,\n                   struct sc_port_range port_range, bool force_adb_forward) {\n    assert(!tunnel->enabled);\n     if (!force_adb_forward) {\n        // Attempt to use \"adb reverse\"\n        if (enable_tunnel_reverse_any_port(tunnel, intr, serial,\n                                           device_socket_name, port_range)) {\n            return true;\n        }\n         // if \"adb reverse\" does not work (e.g. over \"adb connect\"), it\n        // fallbacks to \"adb forward\", so the app socket is the client\n         LOGW(\"'adb reverse' failed, fallback to 'adb forward'\");\n    }\n     return enable_tunnel_forward_any_port(tunnel, intr, serial,\n                                          device_socket_name, port_range);\n}",
        "import_statements": [
            "#include \"adb_tunnel.h\"\n",
            "#include <assert.h>\n",
            "#include \"adb.h\"\n",
            "#include \"util/log.h\"\n",
            "#include \"util/net_intr.h\"\n",
            "#include \"util/process_intr.h\"\n"
        ],
        "reference_api": [
            "assert",
            "LOGW",
            "enable_tunnel_forward_any_port",
            "enable_tunnel_reverse_any_port"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "enable_tunnel_forward_any_port",
                "code": "static bool\nenable_tunnel_forward_any_port(struct sc_adb_tunnel *tunnel,\n                               struct sc_intr *intr, const char *serial,\n                               const char *device_socket_name,\n                               struct sc_port_range port_range) {\n    tunnel->forward = true;\n\n    uint16_t port = port_range.first;\n    for (;;) {\n        if (sc_adb_forward(intr, serial, port, device_socket_name,\n                           SC_ADB_NO_STDOUT)) {\n            // success\n            tunnel->local_port = port;\n            tunnel->enabled = true;\n            return true;\n        }\n\n        if (sc_intr_is_interrupted(intr)) {\n            // Stop immediately\n            return false;\n        }\n\n        if (port < port_range.last) {\n            LOGW(\"Could not forward port %\" PRIu16\", retrying on %\" PRIu16,\n                 port, (uint16_t) (port + 1));\n            port++;\n            continue;\n        }\n\n        if (port_range.first == port_range.last) {\n            LOGE(\"Could not forward port %\" PRIu16, port_range.first);\n        } else {\n            LOGE(\"Could not forward any port in range %\" PRIu16 \":%\" PRIu16,\n                 port_range.first, port_range.last);\n        }\n        return false;\n    }\n}"
            },
            {
                "name": "enable_tunnel_reverse_any_port",
                "code": "static bool\nenable_tunnel_reverse_any_port(struct sc_adb_tunnel *tunnel,\n                               struct sc_intr *intr, const char *serial,\n                               const char *device_socket_name,\n                               struct sc_port_range port_range) {\n    uint16_t port = port_range.first;\n    for (;;) {\n        if (!sc_adb_reverse(intr, serial, device_socket_name, port,\n                            SC_ADB_NO_STDOUT)) {\n            // the command itself failed, it will fail on any port\n            return false;\n        }\n\n        // At the application level, the device part is \"the server\" because it\n        // serves video stream and control. However, at the network level, the\n        // client listens and the server connects to the client. That way, the\n        // client can listen before starting the server app, so there is no\n        // need to try to connect until the server socket is listening on the\n        // device.\n        sc_socket server_socket = net_socket();\n        if (server_socket != SC_SOCKET_NONE) {\n            bool ok = listen_on_port(intr, server_socket, port);\n            if (ok) {\n                // success\n                tunnel->server_socket = server_socket;\n                tunnel->local_port = port;\n                tunnel->enabled = true;\n                return true;\n            }\n\n            net_close(server_socket);\n        }\n\n        if (sc_intr_is_interrupted(intr)) {\n            // Stop immediately\n            return false;\n        }\n\n        // failure, disable tunnel and try another port\n        if (!sc_adb_reverse_remove(intr, serial, device_socket_name,\n                                SC_ADB_NO_STDOUT)) {\n            LOGW(\"Could not remove reverse tunnel on port %\" PRIu16, port);\n        }\n\n        // check before incrementing to avoid overflow on port 65535\n        if (port < port_range.last) {\n            LOGW(\"Could not listen on port %\" PRIu16\", retrying on %\" PRIu16,\n                 port, (uint16_t) (port + 1));\n            port++;\n            continue;\n        }\n\n        if (port_range.first == port_range.last) {\n            LOGE(\"Could not listen on port %\" PRIu16, port_range.first);\n        } else {\n            LOGE(\"Could not listen on any port in range %\" PRIu16 \":%\" PRIu16,\n                 port_range.first, port_range.last);\n        }\n        return false;\n    }\n}"
            }
        ],
        "third_party": [
            "assert",
            "LOGW"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "override fun intercept(chain: Interceptor.Chain): Response",
        "start_line": "29",
        "end_line": "42",
        "file_path": "okhttp-brotli/src/main/kotlin/okhttp3/brotli/BrotliInterceptor.kt",
        "docstring": "The function intercept(chain: Interceptor.Chain): Response overrides the Interceptor method to check if the \"Accept-Encoding\" header is absent in the request. If so, it adds the \"Accept-Encoding\" header with values \"br,gzip\" and proceeds with the modified request, then uncompresses the response. If the header is already present, it proceeds with the original request.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9099a0624f7c",
        "ground_truth": "override fun intercept(chain: Interceptor.Chain): Response {\n  return if (chain.request().header(\"Accept-Encoding\") == null) {\n    val request =\n      chain.request().newBuilder()\n        .header(\"Accept-Encoding\", \"br,gzip\")\n        .build()\n    val response = chain.proceed(request)\n    uncompress(response)\n  } else {\n    chain.proceed(chain.request())\n  }\n}",
        "import_statements": [
            "import okhttp3.Interceptor",
            "import okhttp3.Response",
            "import okhttp3.brotli.internal.uncompress"
        ],
        "reference_api": [
            "uncompress"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "uncompress",
                "code": "override fun intercept(chain: Interceptor.Chain): Response {\n    return if (chain.request().header(\"Accept-Encoding\") == null) {\n      val request =\n        chain.request().newBuilder()\n          .header(\"Accept-Encoding\", \"br,gzip\")\n          .build()\n\n      val response = chain.proceed(request)\n\n      uncompress(response)\n    } else {\n      chain.proceed(chain.request())\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "  override fun loadForRequest(url: HttpUrl): List<Cookie>",
        "start_line": "51",
        "end_line": "78",
        "file_path": "okhttp-java-net-cookiejar/src/main/kotlin/okhttp3/java/net/cookiejar/JavaNetCookieJar.kt",
        "docstring": "The function loadForRequest(url: HttpUrl): List<Cookie> overrides a method to load cookies for the given URL. It retrieves cookie headers using a cookie handler, handles potential IOExceptions, and processes the headers to decode and collect cookies. The function returns an unmodifiable list of cookies if any are found, otherwise, it returns an empty list.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e20805e86ddb",
        "ground_truth": "override fun loadForRequest(url: HttpUrl): List<Cookie> {\n  val cookieHeaders =\n    try {\n      // The RI passes all headers. We don't have 'em, so we don't pass 'em!\n      cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())\n    } catch (e: IOException) {\n      Platform.get().log(\"Loading cookies failed for \" + url.resolve(\"/...\")!!, WARN, e)\n      return emptyList()\n    }\n  var cookies: MutableList<Cookie>? = null\n  for ((key, value) in cookieHeaders) {\n    if ((\"Cookie\".equals(key, ignoreCase = true) || \"Cookie2\".equals(key, ignoreCase = true)) &&\n      value.isNotEmpty()\n    ) {\n      for (header in value) {\n        if (cookies == null) cookies = mutableListOf()\n        cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))\n      }\n    }\n  }\n  return if (cookies != null) {\n    Collections.unmodifiableList(cookies)\n  } else {\n    emptyList()\n  }\n}",
        "import_statements": [
            "import java.io.IOException",
            "import java.net.CookieHandler",
            "import java.net.HttpCookie",
            "import java.util.Collections",
            "import okhttp3.Cookie",
            "import okhttp3.CookieJar",
            "import okhttp3.HttpUrl",
            "import okhttp3.internal.cookieToString",
            "import okhttp3.internal.delimiterOffset",
            "import okhttp3.internal.platform.Platform",
            "import okhttp3.internal.platform.Platform.Companion.WARN",
            "import okhttp3.internal.trimSubstring"
        ],
        "reference_api": [
            "emptyMap",
            "decodeHeaderAsJavaNetCookies",
            "mutableListOf",
            "emptyList"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "emptyMap",
                "code": "override fun loadForRequest(url: HttpUrl): List<Cookie> {\n    val cookieHeaders =\n      try {\n        // The RI passes all headers. We don't have 'em, so we don't pass 'em!\n        cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())\n      } catch (e: IOException) {\n        Platform.get().log(\"Loading cookies failed for \" + url.resolve(\"/...\")!!, WARN, e)\n        return emptyList()\n      }\n\n    var cookies: MutableList<Cookie>? = null\n    for ((key, value) in cookieHeaders) {\n      if ((\"Cookie\".equals(key, ignoreCase = true) || \"Cookie2\".equals(key, ignoreCase = true)) &&\n        value.isNotEmpty()\n      ) {\n        for (header in value) {\n          if (cookies == null) cookies = mutableListOf()\n          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))\n        }\n      }\n    }\n\n    return if (cookies != null) {\n      Collections.unmodifiableList(cookies)\n    } else {\n      emptyList()\n    }\n  }"
            },
            {
                "name": "decodeHeaderAsJavaNetCookies",
                "code": "override fun loadForRequest(url: HttpUrl): List<Cookie> {\n    val cookieHeaders =\n      try {\n        // The RI passes all headers. We don't have 'em, so we don't pass 'em!\n        cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())\n      } catch (e: IOException) {\n        Platform.get().log(\"Loading cookies failed for \" + url.resolve(\"/...\")!!, WARN, e)\n        return emptyList()\n      }\n\n    var cookies: MutableList<Cookie>? = null\n    for ((key, value) in cookieHeaders) {\n      if ((\"Cookie\".equals(key, ignoreCase = true) || \"Cookie2\".equals(key, ignoreCase = true)) &&\n        value.isNotEmpty()\n      ) {\n        for (header in value) {\n          if (cookies == null) cookies = mutableListOf()\n          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))\n        }\n      }\n    }\n\n    return if (cookies != null) {\n      Collections.unmodifiableList(cookies)\n    } else {\n      emptyList()\n    }\n  }"
            },
            {
                "name": "emptyList",
                "code": "override fun loadForRequest(url: HttpUrl): List<Cookie> {\n    val cookieHeaders =\n      try {\n        // The RI passes all headers. We don't have 'em, so we don't pass 'em!\n        cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())\n      } catch (e: IOException) {\n        Platform.get().log(\"Loading cookies failed for \" + url.resolve(\"/...\")!!, WARN, e)\n        return emptyList()\n      }\n\n    var cookies: MutableList<Cookie>? = null\n    for ((key, value) in cookieHeaders) {\n      if ((\"Cookie\".equals(key, ignoreCase = true) || \"Cookie2\".equals(key, ignoreCase = true)) &&\n        value.isNotEmpty()\n      ) {\n        for (header in value) {\n          if (cookies == null) cookies = mutableListOf()\n          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))\n        }\n      }\n    }\n\n    return if (cookies != null) {\n      Collections.unmodifiableList(cookies)\n    } else {\n      emptyList()\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "internal fun redactUrl(url: HttpUrl): String",
        "start_line": "325",
        "end_line": "337",
        "file_path": "okhttp-logging-interceptor/src/main/kotlin/okhttp3/logging/HttpLoggingInterceptor.kt",
        "docstring": "The function redactUrl(url: HttpUrl): String returns a redacted URL string. If queryParamsNameToRedact is empty or there are no query parameters, it returns the original URL. Otherwise, it rebuilds the URL, replacing the values of specified query parameters with \"\u2588\u2588\".\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8a5fc20eb24c",
        "ground_truth": "internal fun redactUrl(url: HttpUrl): String {\n  if (queryParamsNameToRedact.isEmpty() || url.querySize == 0) {\n    return url.toString()\n  }\n  return url.newBuilder().query(null).apply {\n    for (i in 0 until url.querySize) {\n      val parameterName = url.queryParameterName(i)\n      val newValue = if (parameterName in queryParamsNameToRedact) \"\u2588\u2588\" else url.queryParameterValue(i)\n      addEncodedQueryParameter(parameterName, newValue)\n    }\n  }.toString()\n}",
        "import_statements": [
            "import java.io.IOException",
            "import java.nio.charset.Charset",
            "import java.util.TreeSet",
            "import java.util.concurrent.TimeUnit",
            "import okhttp3.Headers",
            "import okhttp3.HttpUrl",
            "import okhttp3.Interceptor",
            "import okhttp3.OkHttpClient",
            "import okhttp3.Response",
            "import okhttp3.internal.charsetOrUtf8",
            "import okhttp3.internal.http.promisesBody",
            "import okhttp3.internal.platform.Platform",
            "import okhttp3.logging.internal.isProbablyUtf8",
            "import okio.Buffer",
            "import okio.GzipSource"
        ],
        "reference_api": [
            "addEncodedQueryParameter"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "addEncodedQueryParameter"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun createFactory(callFactory: Call.Factory): EventSource.Factory",
        "start_line": "32",
        "end_line": "45",
        "file_path": "okhttp-sse/src/main/kotlin/okhttp3/sse/EventSources.kt",
        "docstring": "The function createFactory(callFactory: Call.Factory): EventSource.Factory returns an EventSource.Factory that creates a RealEventSource with the given request and listener. It ensures the request has an \"Accept\" header set to \"text/event-stream\" if not already present and connects the RealEventSource using the provided callFactory.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "de6dd4818bbf",
        "ground_truth": "fun createFactory(callFactory: Call.Factory): EventSource.Factory {\n  return EventSource.Factory { request, listener ->\n    val actualRequest =\n      if (request.header(\"Accept\") == null) {\n        request.newBuilder().addHeader(\"Accept\", \"text/event-stream\").build()\n      } else {\n        request\n      }\n    RealEventSource(actualRequest, listener).apply {\n      connect(callFactory)\n    }\n  }\n}",
        "import_statements": [
            "import okhttp3.Call",
            "import okhttp3.OkHttpClient",
            "import okhttp3.Response",
            "import okhttp3.sse.internal.RealEventSource"
        ],
        "reference_api": [
            "connect",
            "RealEventSource"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "connect",
                "code": "@JvmStatic\n  fun createFactory(callFactory: Call.Factory): EventSource.Factory {\n    return EventSource.Factory { request, listener ->\n      val actualRequest =\n        if (request.header(\"Accept\") == null) {\n          request.newBuilder().addHeader(\"Accept\", \"text/event-stream\").build()\n        } else {\n          request\n        }\n\n      RealEventSource(actualRequest, listener).apply {\n        connect(callFactory)\n      }\n    }\n  }"
            },
            {
                "name": "RealEventSource",
                "code": "@JvmStatic\n  fun createFactory(callFactory: Call.Factory): EventSource.Factory {\n    return EventSource.Factory { request, listener ->\n      val actualRequest =\n        if (request.header(\"Accept\") == null) {\n          request.newBuilder().addHeader(\"Accept\", \"text/event-stream\").build()\n        } else {\n          request\n        }\n\n      RealEventSource(actualRequest, listener).apply {\n        connect(callFactory)\n      }\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun allocate(count: Int): List<InetAddress> ",
        "start_line": "64",
        "end_line": "73",
        "file_path": "okhttp-testing-support/src/main/kotlin/okhttp3/FakeDns.kt",
        "docstring": "The function allocate(count: Int): List<InetAddress> allocates a list of InetAddress objects starting from nextAddress and increments nextAddress by count. It returns a list of InetAddress objects created from the allocated address range.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a75da229304d",
        "ground_truth": "fun allocate(count: Int): List<InetAddress> {\n  val from = nextAddress\n  nextAddress += count\n  return (from until nextAddress)\n    .map {\n      return@map InetAddress.getByAddress(\n        Buffer().writeInt(it.toInt()).readByteArray(),\n      )\n    }\n}",
        "import_statements": [
            "import assertk.assertThat",
            "import assertk.assertions.containsExactly",
            "import java.net.InetAddress",
            "import java.net.UnknownHostException",
            "import okio.Buffer"
        ],
        "reference_api": [
            "Buffer"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Buffer",
                "code": "fun allocate(count: Int): List<InetAddress> {\n    val from = nextAddress\n    nextAddress += count\n    return (from until nextAddress)\n      .map {\n        return@map InetAddress.getByAddress(\n          Buffer().writeInt(it.toInt()).readByteArray(),\n        )\n      }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun newClient(): OkHttpClient",
        "start_line": "143",
        "end_line": "156",
        "file_path": "okhttp-testing-support/src/main/kotlin/okhttp3/OkHttpClientTestRule.kt",
        "docstring": "The function newClient() creates and returns a new OkHttpClient instance. It first checks if testClient is null. If so, it initializes the client with a builder that sets DNS, an event listener, and configures connection and dispatcher locks. The created client is then stored in testClient. Finally, it returns the client.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b61712d9df24",
        "ground_truth": "fun newClient(): OkHttpClient {\n  var client = testClient\n  if (client == null) {\n    client =\n      initialClientBuilder()\n        .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.\n        .eventListenerFactory { ClientRuleEventListener(logger = ::addEvent) }\n        .build()\n    connectionListener.forbidLock(RealConnectionPool.get(client.connectionPool))\n    connectionListener.forbidLock(client.dispatcher)\n    testClient = client\n  }\n  return client\n}",
        "import_statements": [
            "import android.annotation.SuppressLint",
            "import java.util.concurrent.ThreadFactory",
            "import java.util.concurrent.TimeUnit",
            "import java.util.logging.Handler",
            "import java.util.logging.Level",
            "import java.util.logging.LogManager",
            "import java.util.logging.LogRecord",
            "import java.util.logging.Logger",
            "import kotlin.concurrent.withLock",
            "import okhttp3.internal.buildConnectionPool",
            "import okhttp3.internal.concurrent.TaskRunner",
            "import okhttp3.internal.connection.RealConnectionPool",
            "import okhttp3.internal.http2.Http2",
            "import okhttp3.internal.taskRunnerInternal",
            "import okhttp3.testing.Flaky",
            "import okhttp3.testing.PlatformRule.Companion.LOOM_PROPERTY",
            "import okhttp3.testing.PlatformRule.Companion.getPlatformSystemProperty",
            "import org.junit.jupiter.api.Assertions.assertEquals",
            "import org.junit.jupiter.api.Assertions.fail",
            "import org.junit.jupiter.api.extension.AfterEachCallback",
            "import org.junit.jupiter.api.extension.BeforeEachCallback",
            "import org.junit.jupiter.api.extension.ExtensionContext"
        ],
        "reference_api": [
            "initialClientBuilder",
            "ClientRuleEventListener"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "initialClientBuilder",
                "code": "fun newClient(): OkHttpClient {\n    var client = testClient\n    if (client == null) {\n      client =\n        initialClientBuilder()\n          .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.\n          .eventListenerFactory { ClientRuleEventListener(logger = ::addEvent) }\n          .build()\n      connectionListener.forbidLock(RealConnectionPool.get(client.connectionPool))\n      connectionListener.forbidLock(client.dispatcher)\n      testClient = client\n    }\n    return client\n  }"
            },
            {
                "name": "ClientRuleEventListener",
                "code": "fun wrap(eventListener: EventListener) = EventListener.Factory { ClientRuleEventListener(eventListener, ::addEvent) }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun ensureAllConnectionsReleased()",
        "start_line": "209",
        "end_line": "227",
        "file_path": "okhttp-testing-support/src/main/kotlin/okhttp3/OkHttpClientTestRule.kt",
        "docstring": "The function ensureAllConnectionsReleased() checks if testClient is non-null, then evicts all connections from its connection pool. If connections remain, it waits for 500 milliseconds and checks again. Finally, it asserts that no connections remain open, printing a message if any are still open.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6f73bbdb9045",
        "ground_truth": "fun ensureAllConnectionsReleased() {\n  testClient?.let {\n    val connectionPool = it.connectionPool\n    connectionPool.evictAll()\n    if (connectionPool.connectionCount() > 0) {\n      // Minimise test flakiness due to possible race conditions with connections closing.\n      // Some number of tests will report here, but not fail due to this delay.\n      println(\"Delaying to avoid flakes\")\n      Thread.sleep(500L)\n      println(\"After delay: \" + connectionPool.connectionCount())\n    }\n    connectionPool.evictAll()\n    assertEquals(0, connectionPool.connectionCount()) {\n      \"Still ${connectionPool.connectionCount()} connections open\"\n    }\n  }\n}",
        "import_statements": [
            "import android.annotation.SuppressLint",
            "import java.util.concurrent.ThreadFactory",
            "import java.util.concurrent.TimeUnit",
            "import java.util.logging.Handler",
            "import java.util.logging.Level",
            "import java.util.logging.LogManager",
            "import java.util.logging.LogRecord",
            "import java.util.logging.Logger",
            "import kotlin.concurrent.withLock",
            "import okhttp3.internal.buildConnectionPool",
            "import okhttp3.internal.concurrent.TaskRunner",
            "import okhttp3.internal.connection.RealConnectionPool",
            "import okhttp3.internal.http2.Http2",
            "import okhttp3.internal.taskRunnerInternal",
            "import okhttp3.testing.Flaky",
            "import okhttp3.testing.PlatformRule.Companion.LOOM_PROPERTY",
            "import okhttp3.testing.PlatformRule.Companion.getPlatformSystemProperty",
            "import org.junit.jupiter.api.Assertions.assertEquals",
            "import org.junit.jupiter.api.Assertions.fail",
            "import org.junit.jupiter.api.extension.AfterEachCallback",
            "import org.junit.jupiter.api.extension.BeforeEachCallback",
            "import org.junit.jupiter.api.extension.ExtensionContext"
        ],
        "reference_api": [
            "println",
            "assertEquals"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "assertEquals",
                "code": "fun ensureAllConnectionsReleased() {\n    testClient?.let {\n      val connectionPool = it.connectionPool\n\n      connectionPool.evictAll()\n      if (connectionPool.connectionCount() > 0) {\n        // Minimise test flakiness due to possible race conditions with connections closing.\n        // Some number of tests will report here, but not fail due to this delay.\n        println(\"Delaying to avoid flakes\")\n        Thread.sleep(500L)\n        println(\"After delay: \" + connectionPool.connectionCount())\n      }\n\n      connectionPool.evictAll()\n      assertEquals(0, connectionPool.connectionCount()) {\n        \"Still ${connectionPool.connectionCount()} connections open\"\n      }\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "override fun createSocket(): Socket ",
        "start_line": "40",
        "end_line": "52",
        "file_path": "okhttp-testing-support/src/main/kotlin/okhttp3/SpecificHostSocketFactory.kt",
        "docstring": "The function createSocket() overrides the method to return a custom Socket object. This Socket overrides the connect method to map the endpoint address using hostMapping or defaultAddress, logs the connection details, and then calls the superclass's connect method with the mapped address and timeout.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a9eb2ee98111",
        "ground_truth": "override fun createSocket(): Socket {\n  return object : Socket() {\n    override fun connect(\n      endpoint: SocketAddress?,\n      timeout: Int,\n    ) {\n      val requested = (endpoint as InetSocketAddress)\n      val inetSocketAddress = hostMapping[requested.address] ?: defaultAddress ?: requested\n      Platform.get().log(\"Socket connection to: $inetSocketAddress was: $requested\")\n      super.connect(inetSocketAddress, timeout)\n    }\n  }\n}",
        "import_statements": [
            "import java.net.InetAddress",
            "import java.net.InetSocketAddress",
            "import java.net.Socket",
            "import java.net.SocketAddress",
            "import okhttp3.internal.platform.Platform"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun checkServerTrusted(\n    chain: Array<out X509Certificate>,\n    authType: String,\n    host: String,\n  ): List<Certificate>",
        "start_line": "44",
        "end_line": "58",
        "file_path": "okhttp-tls/src/main/kotlin/okhttp3/tls/internal/InsecureAndroidTrustManager.kt",
        "docstring": "The function checkServerTrusted(chain: Array<out X509Certificate>, authType: String, host: String) -> List<Certificate> checks if the server can be trusted. If the host is in the insecureHosts list, it returns an empty list. Otherwise, it invokes the checkServerTrustedMethod on the delegate with the provided parameters and returns the result. If an InvocationTargetException occurs, it throws the target exception.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8a8c08ac6d94",
        "ground_truth": "fun checkServerTrusted(\n  chain: Array<out X509Certificate>,\n  authType: String,\n  host: String,\n): List<Certificate> {\n  if (host in insecureHosts) return listOf()\n  try {\n    val method =\n      checkServerTrustedMethod\n        ?: throw CertificateException(\"Failed to call checkServerTrusted\")\n    return method.invoke(delegate, chain, authType, host) as List<Certificate>\n  } catch (e: InvocationTargetException) {\n    throw e.targetException\n  }\n}",
        "import_statements": [
            "import java.lang.reflect.InvocationTargetException",
            "import java.lang.reflect.Method",
            "import java.security.cert.Certificate",
            "import java.security.cert.CertificateException",
            "import java.security.cert.X509Certificate",
            "import javax.net.ssl.X509TrustManager"
        ],
        "reference_api": [
            "listOf",
            "CertificateException"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "CertificateException",
                "code": "@Suppress(\"unused\", \"UNCHECKED_CAST\")\n  fun checkServerTrusted(\n    chain: Array<out X509Certificate>,\n    authType: String,\n    host: String,\n  ): List<Certificate> {\n    if (host in insecureHosts) return listOf()\n    try {\n      val method =\n        checkServerTrustedMethod\n          ?: throw CertificateException(\"Failed to call checkServerTrusted\")\n      return method.invoke(delegate, chain, authType, host) as List<Certificate>\n    } catch (e: InvocationTargetException) {\n      throw e.targetException\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "private fun signatureAlgorithm(signedByKeyPair: KeyPair): AlgorithmIdentifier",
        "start_line": "480",
        "end_line": "493",
        "file_path": "okhttp-tls/src/main/kotlin/okhttp3/tls/HeldCertificate.kt",
        "docstring": "The function signatureAlgorithm(signedByKeyPair: KeyPair) -> AlgorithmIdentifier returns an AlgorithmIdentifier based on the type of the private key in the provided KeyPair. It uses SHA256_WITH_RSA_ENCRYPTION for RSAPrivateKey and SHA256_WITH_ECDSA for other types, setting appropriate parameters for each algorithm.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "69e9be6ced1d",
        "ground_truth": "private fun signatureAlgorithm(signedByKeyPair: KeyPair): AlgorithmIdentifier {\n  return when (signedByKeyPair.private) {\n    is RSAPrivateKey ->\n      AlgorithmIdentifier(\n        algorithm = SHA256_WITH_RSA_ENCRYPTION,\n        parameters = null,\n      )\n    else ->\n      AlgorithmIdentifier(\n        algorithm = SHA256_WITH_ECDSA,\n        parameters = ByteString.EMPTY,\n      )\n  }\n}",
        "import_statements": [
            "import java.math.BigInteger",
            "import java.net.InetAddress",
            "import java.security.GeneralSecurityException",
            "import java.security.KeyFactory",
            "import java.security.KeyPair",
            "import java.security.KeyPairGenerator",
            "import java.security.PrivateKey",
            "import java.security.PublicKey",
            "import java.security.SecureRandom",
            "import java.security.Signature",
            "import java.security.cert.X509Certificate",
            "import java.security.interfaces.ECPublicKey",
            "import java.security.interfaces.RSAPrivateKey",
            "import java.security.interfaces.RSAPublicKey",
            "import java.security.spec.PKCS8EncodedKeySpec",
            "import java.util.UUID",
            "import java.util.concurrent.TimeUnit",
            "import okhttp3.internal.canParseAsIpAddress",
            "import okhttp3.tls.internal.der.AlgorithmIdentifier",
            "import okhttp3.tls.internal.der.AttributeTypeAndValue",
            "import okhttp3.tls.internal.der.BasicConstraints",
            "import okhttp3.tls.internal.der.BitString",
            "import okhttp3.tls.internal.der.Certificate",
            "import okhttp3.tls.internal.der.CertificateAdapters",
            "import okhttp3.tls.internal.der.CertificateAdapters.generalNameDnsName",
            "import okhttp3.tls.internal.der.CertificateAdapters.generalNameIpAddress",
            "import okhttp3.tls.internal.der.Extension",
            "import okhttp3.tls.internal.der.ObjectIdentifiers",
            "import okhttp3.tls.internal.der.ObjectIdentifiers.BASIC_CONSTRAINTS",
            "import okhttp3.tls.internal.der.ObjectIdentifiers.ORGANIZATIONAL_UNIT_NAME",
            "import okhttp3.tls.internal.der.ObjectIdentifiers.SHA256_WITH_ECDSA",
            "import okhttp3.tls.internal.der.ObjectIdentifiers.SHA256_WITH_RSA_ENCRYPTION",
            "import okhttp3.tls.internal.der.ObjectIdentifiers.SUBJECT_ALTERNATIVE_NAME",
            "import okhttp3.tls.internal.der.TbsCertificate",
            "import okhttp3.tls.internal.der.Validity",
            "import okio.ByteString",
            "import okio.ByteString.Companion.decodeBase64",
            "import okio.ByteString.Companion.toByteString"
        ],
        "reference_api": [
            "AlgorithmIdentifier"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "AlgorithmIdentifier"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun compute(): CacheStrategy",
        "start_line": "129",
        "end_line": "138",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/cache/CacheStrategy.kt",
        "docstring": "The function compute() -> CacheStrategy calculates a CacheStrategy by first computing a candidate using computeCandidate(). If a network request is needed but the cache control is set to onlyIfCached, it returns an empty CacheStrategy. Otherwise, it returns the computed candidate.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ca53ac17682b",
        "ground_truth": "fun compute(): CacheStrategy {\n  val candidate = computeCandidate()\n  // We're forbidden from using the network and the cache is insufficient.\n  if (candidate.networkRequest != null && request.cacheControl.onlyIfCached) {\n    return CacheStrategy(null, null)\n  }\n  return candidate\n}",
        "import_statements": [
            "import java.net.HttpURLConnection.HTTP_BAD_METHOD",
            "import java.net.HttpURLConnection.HTTP_GONE",
            "import java.net.HttpURLConnection.HTTP_MOVED_PERM",
            "import java.net.HttpURLConnection.HTTP_MOVED_TEMP",
            "import java.net.HttpURLConnection.HTTP_MULT_CHOICE",
            "import java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE",
            "import java.net.HttpURLConnection.HTTP_NOT_FOUND",
            "import java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED",
            "import java.net.HttpURLConnection.HTTP_NO_CONTENT",
            "import java.net.HttpURLConnection.HTTP_OK",
            "import java.net.HttpURLConnection.HTTP_REQ_TOO_LONG",
            "import java.util.Date",
            "import java.util.concurrent.TimeUnit.SECONDS",
            "import okhttp3.Request",
            "import okhttp3.Response",
            "import okhttp3.internal.http.HTTP_PERM_REDIRECT",
            "import okhttp3.internal.http.HTTP_TEMP_REDIRECT",
            "import okhttp3.internal.http.toHttpDateOrNull",
            "import okhttp3.internal.toNonNegativeInt"
        ],
        "reference_api": [
            "CacheStrategy",
            "computeCandidate"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "CacheStrategy",
                "code": "fun compute(): CacheStrategy {\n      val candidate = computeCandidate()\n\n      // We're forbidden from using the network and the cache is insufficient.\n      if (candidate.networkRequest != null && request.cacheControl.onlyIfCached) {\n        return CacheStrategy(null, null)\n      }\n\n      return candidate\n    }"
            },
            {
                "name": "computeCandidate",
                "code": "fun compute(): CacheStrategy {\n      val candidate = computeCandidate()\n\n      // We're forbidden from using the network and the cache is insufficient.\n      if (candidate.networkRequest != null && request.cacheControl.onlyIfCached) {\n        return CacheStrategy(null, null)\n      }\n\n      return candidate\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "private fun computeFreshnessLifetime(): Long",
        "start_line": "232",
        "end_line": "255",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/cache/CacheStrategy.kt",
        "docstring": "The function computeFreshnessLifetime() -> Long calculates the freshness lifetime of a cached response. It checks the max-age directive from the cache control headers, the expires header, and the last modified date, returning the appropriate freshness duration in milliseconds. If none are available, it returns 0.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bb97ef56101b",
        "ground_truth": "private fun computeFreshnessLifetime(): Long {\n  val responseCaching = cacheResponse!!.cacheControl\n  if (responseCaching.maxAgeSeconds != -1) {\n    return SECONDS.toMillis(responseCaching.maxAgeSeconds.toLong())\n  }\n  val expires = this.expires\n  if (expires != null) {\n    val servedMillis = servedDate?.time ?: receivedResponseMillis\n    val delta = expires.time - servedMillis\n    return if (delta > 0L) delta else 0L\n  }\n  if (lastModified != null && cacheResponse.request.url.query == null) {\n    // As recommended by the HTTP RFC and implemented in Firefox, the max age of a document\n    // should be defaulted to 10% of the document's age at the time it was served. Default\n    // expiration dates aren't used for URIs containing a query.\n    val servedMillis = servedDate?.time ?: sentRequestMillis\n    val delta = servedMillis - lastModified!!.time\n    return if (delta > 0L) delta / 10 else 0L\n  }\n  return 0L\n}",
        "import_statements": [
            "import java.net.HttpURLConnection.HTTP_BAD_METHOD",
            "import java.net.HttpURLConnection.HTTP_GONE",
            "import java.net.HttpURLConnection.HTTP_MOVED_PERM",
            "import java.net.HttpURLConnection.HTTP_MOVED_TEMP",
            "import java.net.HttpURLConnection.HTTP_MULT_CHOICE",
            "import java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE",
            "import java.net.HttpURLConnection.HTTP_NOT_FOUND",
            "import java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED",
            "import java.net.HttpURLConnection.HTTP_NO_CONTENT",
            "import java.net.HttpURLConnection.HTTP_OK",
            "import java.net.HttpURLConnection.HTTP_REQ_TOO_LONG",
            "import java.util.Date",
            "import java.util.concurrent.TimeUnit.SECONDS",
            "import okhttp3.Request",
            "import okhttp3.Response",
            "import okhttp3.internal.http.HTTP_PERM_REDIRECT",
            "import okhttp3.internal.http.HTTP_TEMP_REDIRECT",
            "import okhttp3.internal.http.toHttpDateOrNull",
            "import okhttp3.internal.toNonNegativeInt"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun shutdown()",
        "start_line": "218",
        "end_line": "227",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/concurrent/TaskQueue.kt",
        "docstring": "The function shutdown() sets the shutdown flag to true within a locked context, ensuring thread safety. It first asserts that the lock is not held, then uses taskRunner's lock to synchronize. If cancelAllAndDecide() returns true, it calls taskRunner.kickCoordinator(this) to coordinate the shutdown process.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3cc8e31173bd",
        "ground_truth": "fun shutdown() {\n  lock.assertNotHeld()\n  taskRunner.lock.withLock {\n    shutdown = true\n    if (cancelAllAndDecide()) {\n      taskRunner.kickCoordinator(this)\n    }\n  }\n}",
        "import_statements": [
            "import java.util.concurrent.CountDownLatch",
            "import java.util.concurrent.RejectedExecutionException",
            "import java.util.concurrent.locks.ReentrantLock",
            "import kotlin.concurrent.withLock",
            "import okhttp3.internal.assertNotHeld",
            "import okhttp3.internal.okHttpName"
        ],
        "reference_api": [
            "cancelAllAndDecide"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "cancelAllAndDecide",
                "code": "fun cancelAll() {\n    lock.assertNotHeld()\n\n    taskRunner.lock.withLock {\n      if (cancelAllAndDecide()) {\n        taskRunner.kickCoordinator(this)\n      }\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "private fun runTask(task: Task) ",
        "start_line": "133",
        "end_line": "147",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/concurrent/TaskRunner.kt",
        "docstring": "The function runTask(task: Task) changes the current thread's name to the task's name, runs the task, and captures any delay in nanoseconds. After running the task, it restores the original thread name and calls afterRun(task, delayNanos) within a lock to ensure thread safety.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ee69b5c3cff9",
        "ground_truth": "private fun runTask(task: Task) {\n  val currentThread = Thread.currentThread()\n  val oldName = currentThread.name\n  currentThread.name = task.name\n  var delayNanos = -1L\n  try {\n    delayNanos = task.runOnce()\n  } finally {\n    lock.withLock {\n      afterRun(task, delayNanos)\n    }\n    currentThread.name = oldName\n  }\n}",
        "import_statements": [
            "import java.util.concurrent.BlockingQueue",
            "import java.util.concurrent.SynchronousQueue",
            "import java.util.concurrent.ThreadFactory",
            "import java.util.concurrent.ThreadPoolExecutor",
            "import java.util.concurrent.TimeUnit",
            "import java.util.concurrent.locks.Condition",
            "import java.util.concurrent.locks.ReentrantLock",
            "import java.util.logging.Logger",
            "import kotlin.concurrent.withLock",
            "import okhttp3.internal.addIfAbsent",
            "import okhttp3.internal.assertHeld",
            "import okhttp3.internal.concurrent.TaskRunner.Companion.INSTANCE",
            "import okhttp3.internal.okHttpName",
            "import okhttp3.internal.threadFactory"
        ],
        "reference_api": [
            "afterRun"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "afterRun",
                "code": "private fun runTask(task: Task) {\n    val currentThread = Thread.currentThread()\n    val oldName = currentThread.name\n    currentThread.name = task.name\n\n    var delayNanos = -1L\n    try {\n      delayNanos = task.runOnce()\n    } finally {\n      lock.withLock {\n        afterRun(task, delayNanos)\n      }\n      currentThread.name = oldName\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "private fun connectSocket()",
        "start_line": "258",
        "end_line": "292",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt",
        "docstring": "The function connectSocket() initializes a rawSocket based on the proxy type of the route. It sets the socket timeout and attempts to connect using Platform.get().connectSocket(). If the connection is successful, it assigns buffered source and sink streams to the rawSocket. If canceled or if an exception occurs, appropriate errors are thrown.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "de178339d1c6",
        "ground_truth": "private fun connectSocket() {\n  val rawSocket =\n    when (route.proxy.type()) {\n      Proxy.Type.DIRECT, Proxy.Type.HTTP -> route.address.socketFactory.createSocket()!!\n      else -> Socket(route.proxy)\n    }\n  this.rawSocket = rawSocket\n  // Handle the race where cancel() precedes connectSocket(). We don't want to miss a cancel.\n  if (canceled) {\n    throw IOException(\"canceled\")\n  }\n  rawSocket.soTimeout = socketReadTimeoutMillis\n  try {\n    Platform.get().connectSocket(rawSocket, route.socketAddress, socketConnectTimeoutMillis)\n  } catch (e: ConnectException) {\n    throw ConnectException(\"Failed to connect to ${route.socketAddress}\").apply {\n      initCause(e)\n    }\n  }\n  // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0\n  // More details:\n  // https://github.com/square/okhttp/issues/3245\n  // https://android-review.googlesource.com/#/c/271775/\n  try {\n    source = rawSocket.source().buffer()\n    sink = rawSocket.sink().buffer()\n  } catch (npe: NullPointerException) {\n    if (npe.message == NPE_THROW_WITH_NULL) {\n      throw IOException(npe)\n    }\n  }\n}",
        "import_statements": [
            "import java.io.IOException",
            "import java.net.ConnectException",
            "import java.net.HttpURLConnection",
            "import java.net.ProtocolException",
            "import java.net.Proxy",
            "import java.net.Socket",
            "import java.net.UnknownServiceException",
            "import java.security.cert.X509Certificate",
            "import java.util.concurrent.TimeUnit",
            "import javax.net.ssl.SSLPeerUnverifiedException",
            "import javax.net.ssl.SSLSocket",
            "import kotlin.concurrent.withLock",
            "import okhttp3.CertificatePinner",
            "import okhttp3.ConnectionSpec",
            "import okhttp3.Handshake",
            "import okhttp3.Handshake.Companion.handshake",
            "import okhttp3.Protocol",
            "import okhttp3.Request",
            "import okhttp3.Route",
            "import okhttp3.internal.closeQuietly",
            "import okhttp3.internal.concurrent.TaskRunner",
            "import okhttp3.internal.connection.Locks.withLock",
            "import okhttp3.internal.connection.RoutePlanner.ConnectResult",
            "import okhttp3.internal.http.ExchangeCodec",
            "import okhttp3.internal.http1.Http1ExchangeCodec",
            "import okhttp3.internal.platform.Platform",
            "import okhttp3.internal.tls.OkHostnameVerifier",
            "import okhttp3.internal.toHostHeader",
            "import okio.BufferedSink",
            "import okio.BufferedSource",
            "import okio.buffer",
            "import okio.sink",
            "import okio.source"
        ],
        "reference_api": [
            "IOException",
            "Socket",
            "initCause",
            "ConnectException"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "IOException",
                "code": "override fun connectTlsEtc(): ConnectResult {\n    check(rawSocket != null) { \"TCP not connected\" }\n    check(!isReady) { \"already connected\" }\n\n    val connectionSpecs = route.address.connectionSpecs\n    var retryTlsConnection: ConnectPlan? = null\n    var success = false\n\n    // Tell the call about the connecting call so async cancels work.\n    user.addPlanToCancel(this)\n    try {\n      if (tunnelRequest != null) {\n        val tunnelResult = connectTunnel()\n\n        // Tunnel didn't work. Start it all again.\n        if (tunnelResult.nextPlan != null || tunnelResult.throwable != null) {\n          return tunnelResult\n        }\n      }\n\n      if (route.address.sslSocketFactory != null) {\n        // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If\n        // that happens, then we will have buffered bytes that are needed by the SSLSocket!\n        // This check is imperfect: it doesn't tell us whether a handshake will succeed, just\n        // that it will almost certainly fail because the proxy has sent unexpected data.\n        if (source?.buffer?.exhausted() == false || sink?.buffer?.exhausted() == false) {\n          throw IOException(\"TLS tunnel buffered too many bytes!\")\n        }\n\n        user.secureConnectStart()\n\n        // Create the wrapper over the connected socket.\n        val sslSocket =\n          route.address.sslSocketFactory.createSocket(\n            rawSocket,\n            route.address.url.host,\n            route.address.url.port,\n            // autoClose:\n            true,\n          ) as SSLSocket\n\n        val tlsEquipPlan = planWithCurrentOrInitialConnectionSpec(connectionSpecs, sslSocket)\n        val connectionSpec = connectionSpecs[tlsEquipPlan.connectionSpecIndex]\n\n        // Figure out the next connection spec in case we need a retry.\n        retryTlsConnection = tlsEquipPlan.nextConnectionSpec(connectionSpecs, sslSocket)\n\n        connectionSpec.apply(sslSocket, isFallback = tlsEquipPlan.isTlsFallback)\n        connectTls(sslSocket, connectionSpec)\n        user.secureConnectEnd(handshake)\n      } else {\n        socket = rawSocket\n        protocol =\n          when {\n            Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols -> Protocol.H2_PRIOR_KNOWLEDGE\n            else -> Protocol.HTTP_1_1\n          }\n      }\n\n      val connection =\n        RealConnection(\n          taskRunner = taskRunner,\n          connectionPool = connectionPool,\n          route = route,\n          rawSocket = rawSocket,\n          socket = socket,\n          handshake = handshake,\n          protocol = protocol,\n          source = source,\n          sink = sink,\n          pingIntervalMillis = pingIntervalMillis,\n          connectionListener = connectionPool.connectionListener,\n        )\n      this.connection = connection\n      connection.start()\n\n      // Success.\n      user.callConnectEnd(route, protocol)\n      success = true\n      return ConnectResult(plan = this)\n    } catch (e: IOException) {\n      user.connectFailed(route, null, e)\n\n      if (!retryOnConnectionFailure || !retryTlsHandshake(e)) {\n        retryTlsConnection = null\n      }\n\n      return ConnectResult(\n        plan = this,\n        nextPlan = retryTlsConnection,\n        throwable = e,\n      )\n    } finally {\n      user.removePlanToCancel(this)\n      if (!success) {\n        socket?.closeQuietly()\n        rawSocket?.closeQuietly()\n      }\n    }\n  }"
            },
            {
                "name": "Socket",
                "code": "@Throws(IOException::class)\n  private fun connectSocket() {\n    val rawSocket =\n      when (route.proxy.type()) {\n        Proxy.Type.DIRECT, Proxy.Type.HTTP -> route.address.socketFactory.createSocket()!!\n        else -> Socket(route.proxy)\n      }\n    this.rawSocket = rawSocket\n\n    // Handle the race where cancel() precedes connectSocket(). We don't want to miss a cancel.\n    if (canceled) {\n      throw IOException(\"canceled\")\n    }\n\n    rawSocket.soTimeout = socketReadTimeoutMillis\n    try {\n      Platform.get().connectSocket(rawSocket, route.socketAddress, socketConnectTimeoutMillis)\n    } catch (e: ConnectException) {\n      throw ConnectException(\"Failed to connect to ${route.socketAddress}\").apply {\n        initCause(e)\n      }\n    }\n\n    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0\n    // More details:\n    // https://github.com/square/okhttp/issues/3245\n    // https://android-review.googlesource.com/#/c/271775/\n    try {\n      source = rawSocket.source().buffer()\n      sink = rawSocket.sink().buffer()\n    } catch (npe: NullPointerException) {\n      if (npe.message == NPE_THROW_WITH_NULL) {\n        throw IOException(npe)\n      }\n    }\n  }"
            },
            {
                "name": "initCause",
                "code": "@Throws(IOException::class)\n  private fun connectSocket() {\n    val rawSocket =\n      when (route.proxy.type()) {\n        Proxy.Type.DIRECT, Proxy.Type.HTTP -> route.address.socketFactory.createSocket()!!\n        else -> Socket(route.proxy)\n      }\n    this.rawSocket = rawSocket\n\n    // Handle the race where cancel() precedes connectSocket(). We don't want to miss a cancel.\n    if (canceled) {\n      throw IOException(\"canceled\")\n    }\n\n    rawSocket.soTimeout = socketReadTimeoutMillis\n    try {\n      Platform.get().connectSocket(rawSocket, route.socketAddress, socketConnectTimeoutMillis)\n    } catch (e: ConnectException) {\n      throw ConnectException(\"Failed to connect to ${route.socketAddress}\").apply {\n        initCause(e)\n      }\n    }\n\n    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0\n    // More details:\n    // https://github.com/square/okhttp/issues/3245\n    // https://android-review.googlesource.com/#/c/271775/\n    try {\n      source = rawSocket.source().buffer()\n      sink = rawSocket.sink().buffer()\n    } catch (npe: NullPointerException) {\n      if (npe.message == NPE_THROW_WITH_NULL) {\n        throw IOException(npe)\n      }\n    }\n  }"
            },
            {
                "name": "ConnectException",
                "code": "@Throws(IOException::class)\n  private fun connectSocket() {\n    val rawSocket =\n      when (route.proxy.type()) {\n        Proxy.Type.DIRECT, Proxy.Type.HTTP -> route.address.socketFactory.createSocket()!!\n        else -> Socket(route.proxy)\n      }\n    this.rawSocket = rawSocket\n\n    // Handle the race where cancel() precedes connectSocket(). We don't want to miss a cancel.\n    if (canceled) {\n      throw IOException(\"canceled\")\n    }\n\n    rawSocket.soTimeout = socketReadTimeoutMillis\n    try {\n      Platform.get().connectSocket(rawSocket, route.socketAddress, socketConnectTimeoutMillis)\n    } catch (e: ConnectException) {\n      throw ConnectException(\"Failed to connect to ${route.socketAddress}\").apply {\n        initCause(e)\n      }\n    }\n\n    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0\n    // More details:\n    // https://github.com/square/okhttp/issues/3245\n    // https://android-review.googlesource.com/#/c/271775/\n    try {\n      source = rawSocket.source().buffer()\n      sink = rawSocket.sink().buffer()\n    } catch (npe: NullPointerException) {\n      if (npe.message == NPE_THROW_WITH_NULL) {\n        throw IOException(npe)\n      }\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun readResponseHeaders(expectContinue: Boolean): Response.Builder?",
        "start_line": "112",
        "end_line": "122",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/connection/Exchange.kt",
        "docstring": "The function readResponseHeaders(expectContinue: Boolean): Response.Builder? reads response headers using codec.readResponseHeaders(expectContinue). If successful, it initializes the exchange with the result and returns it. If an IOException occurs, it logs the failure with eventListener, tracks the failure, and rethrows the exception.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a02b661d36fa",
        "ground_truth": "fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {\n  try {\n    val result = codec.readResponseHeaders(expectContinue)\n    result?.initExchange(this)\n    return result\n  } catch (e: IOException) {\n    eventListener.responseFailed(call, e)\n    trackFailure(e)\n    throw e\n  }\n}",
        "import_statements": [
            "import java.io.IOException",
            "import java.net.ProtocolException",
            "import java.net.SocketException",
            "import okhttp3.EventListener",
            "import okhttp3.Headers",
            "import okhttp3.Request",
            "import okhttp3.Response",
            "import okhttp3.ResponseBody",
            "import okhttp3.internal.http.ExchangeCodec",
            "import okhttp3.internal.http.RealResponseBody",
            "import okhttp3.internal.ws.RealWebSocket",
            "import okio.Buffer",
            "import okio.ForwardingSink",
            "import okio.ForwardingSource",
            "import okio.Sink",
            "import okio.Source",
            "import okio.buffer"
        ],
        "reference_api": [
            "trackFailure"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "trackFailure",
                "code": "@Throws(IOException::class)\n  fun writeRequestHeaders(request: Request) {\n    try {\n      eventListener.requestHeadersStart(call)\n      codec.writeRequestHeaders(request)\n      eventListener.requestHeadersEnd(call, request)\n    } catch (e: IOException) {\n      eventListener.requestFailed(call, e)\n      trackFailure(e)\n      throw e\n    }\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "private fun awaitTcpConnect(\n    timeout: Long,\n    unit: TimeUnit,\n  ): ConnectResult?",
        "start_line": "156",
        "end_line": "167",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/connection/FastFallbackExchangeFinder.kt",
        "docstring": "The function awaitTcpConnect(timeout: Long, unit: TimeUnit): ConnectResult? waits for a TCP connection result from connectResults within the specified timeout. If no connections are in flight or no result is available within the timeout, it returns null. Otherwise, it removes the connection plan from tcpConnectsInFlight and returns the result.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c1bdf86a2ee4",
        "ground_truth": "private fun awaitTcpConnect(\n  timeout: Long,\n  unit: TimeUnit,\n): ConnectResult? {\n  if (tcpConnectsInFlight.isEmpty()) return null\n  val result = connectResults.poll(timeout, unit) ?: return null\n  tcpConnectsInFlight.remove(result.plan)\n  return result\n}",
        "import_statements": [
            "import java.io.IOException",
            "import java.util.concurrent.CopyOnWriteArrayList",
            "import java.util.concurrent.LinkedBlockingDeque",
            "import java.util.concurrent.TimeUnit",
            "import okhttp3.internal.concurrent.Task",
            "import okhttp3.internal.concurrent.TaskRunner",
            "import okhttp3.internal.connection.RoutePlanner.ConnectResult",
            "import okhttp3.internal.connection.RoutePlanner.Plan",
            "import okhttp3.internal.okHttpName"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "internal fun releaseConnectionNoEvents(): Socket?",
        "start_line": "405",
        "end_line": "424",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt",
        "docstring": "The function releaseConnectionNoEvents(): Socket? releases the current connection by removing this call from the connection's call list. If the call list becomes empty, it updates the connection's idle time and checks if the connection can be returned to the pool. It returns the connection's socket if it became idle; otherwise, it returns null.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "911400407999",
        "ground_truth": "internal fun releaseConnectionNoEvents(): Socket? {\n  val connection = this.connection!!\n  connection.lock.assertHeld()\n  val calls = connection.calls\n  val index = calls.indexOfFirst { it.get() == this@RealCall }\n  check(index != -1)\n  calls.removeAt(index)\n  this.connection = null\n  if (calls.isEmpty()) {\n    connection.idleAtNs = System.nanoTime()\n    if (connectionPool.connectionBecameIdle(connection)) {\n      return connection.socket()\n    }\n  }\n  return null\n}",
        "import_statements": [
            "import java.io.IOException",
            "import java.io.InterruptedIOException",
            "import java.lang.ref.WeakReference",
            "import java.net.Socket",
            "import java.util.concurrent.CopyOnWriteArrayList",
            "import java.util.concurrent.ExecutorService",
            "import java.util.concurrent.RejectedExecutionException",
            "import java.util.concurrent.TimeUnit.MILLISECONDS",
            "import java.util.concurrent.atomic.AtomicBoolean",
            "import java.util.concurrent.atomic.AtomicInteger",
            "import java.util.concurrent.locks.ReentrantLock",
            "import okhttp3.Call",
            "import okhttp3.Callback",
            "import okhttp3.EventListener",
            "import okhttp3.Interceptor",
            "import okhttp3.OkHttpClient",
            "import okhttp3.Request",
            "import okhttp3.Response",
            "import okhttp3.internal.assertHeld",
            "import okhttp3.internal.assertNotHeld",
            "import okhttp3.internal.assertThreadDoesntHoldLock",
            "import okhttp3.internal.cache.CacheInterceptor",
            "import okhttp3.internal.closeQuietly",
            "import okhttp3.internal.connection.Locks.withLock",
            "import okhttp3.internal.http.BridgeInterceptor",
            "import okhttp3.internal.http.CallServerInterceptor",
            "import okhttp3.internal.http.RealInterceptorChain",
            "import okhttp3.internal.http.RetryAndFollowUpInterceptor",
            "import okhttp3.internal.platform.Platform",
            "import okhttp3.internal.threadName",
            "import okio.AsyncTimeout",
            "import okio.Timeout"
        ],
        "reference_api": [
            "check"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "private fun resetNextProxy(\n    url: HttpUrl,\n    proxy: Proxy?,\n  )",
        "start_line": "96",
        "end_line": "119",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt",
        "docstring": "The function resetNextProxy(url: HttpUrl, proxy: Proxy?) selects and resets the list of proxies for a given URL. If a proxy is specified, it uses that proxy. Otherwise, it uses the ProxySelector to select proxies based on the URL's host. The selected proxies are stored, and the selection process is logged with connectionUser.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "d0fb8849faec",
        "ground_truth": "private fun resetNextProxy(\n  url: HttpUrl,\n  proxy: Proxy?,\n) {\n  fun selectProxies(): List<Proxy> {\n    // If the user specifies a proxy, try that and only that.\n    if (proxy != null) return listOf(proxy)\n    // If the URI lacks a host (as in \"http://</\"), don't call the ProxySelector.\n    val uri = url.toUri()\n    if (uri.host == null) return immutableListOf(Proxy.NO_PROXY)\n    // Try each of the ProxySelector choices until one connection succeeds.\n    val proxiesOrNull = address.proxySelector.select(uri)\n    if (proxiesOrNull.isNullOrEmpty()) return immutableListOf(Proxy.NO_PROXY)\n    return proxiesOrNull.toImmutableList()\n  }\n  connectionUser.proxySelectStart(url)\n  proxies = selectProxies()\n  nextProxyIndex = 0\n  connectionUser.proxySelectEnd(url, proxies)\n}",
        "import_statements": [
            "import java.io.IOException",
            "import java.net.InetAddress",
            "import java.net.InetSocketAddress",
            "import java.net.Proxy",
            "import java.net.SocketException",
            "import java.net.UnknownHostException",
            "import java.util.NoSuchElementException",
            "import okhttp3.Address",
            "import okhttp3.HttpUrl",
            "import okhttp3.Route",
            "import okhttp3.internal.canParseAsIpAddress",
            "import okhttp3.internal.immutableListOf",
            "import okhttp3.internal.toImmutableList"
        ],
        "reference_api": [
            "listOf",
            "immutableListOf"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "immutableListOf",
                "code": "private fun resetNextProxy(\n    url: HttpUrl,\n    proxy: Proxy?,\n  ) {\n    fun selectProxies(): List<Proxy> {\n      // If the user specifies a proxy, try that and only that.\n      if (proxy != null) return listOf(proxy)\n\n      // If the URI lacks a host (as in \"http://</\"), don't call the ProxySelector.\n      val uri = url.toUri()\n      if (uri.host == null) return immutableListOf(Proxy.NO_PROXY)\n\n      // Try each of the ProxySelector choices until one connection succeeds.\n      val proxiesOrNull = address.proxySelector.select(uri)\n      if (proxiesOrNull.isNullOrEmpty()) return immutableListOf(Proxy.NO_PROXY)\n\n      return proxiesOrNull.toImmutableList()\n    }\n\n    connectionUser.proxySelectStart(url)\n    proxies = selectProxies()\n    nextProxyIndex = 0\n    connectionUser.proxySelectEnd(url, proxies)\n  }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "private fun enableLogging(\n    logger: String,\n    tag: String,\n  )",
        "start_line": "111",
        "end_line": "127",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/platform/android/AndroidLog.kt",
        "docstring": "The function enableLogging(logger: String, tag: String) sets up logging for a specified logger. It retrieves the logger, configures it if not already added, disables parent handlers, sets the logging level based on the tag's loggability, and adds an AndroidLogHandler.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2babc0452fee",
        "ground_truth": "private fun enableLogging(\n  logger: String,\n  tag: String,\n) {\n  val logger = Logger.getLogger(logger)\n  if (configuredLoggers.add(logger)) {\n    logger.useParentHandlers = false\n    // log based on levels at startup to avoid logging each frame\n    logger.level =\n      when {\n        Log.isLoggable(tag, Log.DEBUG) -> Level.FINE\n        Log.isLoggable(tag, Log.INFO) -> Level.INFO\n        else -> Level.WARNING\n      }\n    logger.addHandler(AndroidLogHandler)\n  }\n}",
        "import_statements": [
            "import android.util.Log",
            "import java.util.concurrent.CopyOnWriteArraySet",
            "import java.util.logging.Handler",
            "import java.util.logging.Level",
            "import java.util.logging.LogRecord",
            "import java.util.logging.Logger",
            "import okhttp3.OkHttpClient",
            "import okhttp3.internal.SuppressSignatureCheck",
            "import okhttp3.internal.concurrent.TaskRunner",
            "import okhttp3.internal.http2.Http2",
            "import okhttp3.internal.platform.android.AndroidLog.androidLog"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "square/okhttp",
        "function_declaration": "fun factory(packageName: String): DeferredSocketAdapter.Factory",
        "start_line": "121",
        "end_line": "129",
        "file_path": "okhttp/src/main/kotlin/okhttp3/internal/platform/android/AndroidSocketAdapter.kt",
        "docstring": "The function factory(packageName: String): DeferredSocketAdapter.Factory returns an anonymous implementation of DeferredSocketAdapter.Factory. The matchesSocket method checks if the SSLSocket's class name starts with the specified packageName, and the create method builds a SocketAdapter for the given SSLSocket's class.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "036449b52d54",
        "ground_truth": "fun factory(packageName: String): DeferredSocketAdapter.Factory {\n  return object : DeferredSocketAdapter.Factory {\n    override fun matchesSocket(sslSocket: SSLSocket): Boolean = sslSocket.javaClass.name.startsWith(\"$packageName.\")\n    override fun create(sslSocket: SSLSocket): SocketAdapter {\n      return build(sslSocket.javaClass)\n    }\n  }\n}",
        "import_statements": [
            "import android.os.Build",
            "import java.lang.reflect.InvocationTargetException",
            "import java.lang.reflect.Method",
            "import javax.net.ssl.SSLSocket",
            "import okhttp3.Protocol",
            "import okhttp3.internal.platform.AndroidPlatform",
            "import okhttp3.internal.platform.Platform"
        ],
        "reference_api": [
            "build"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "build",
                "code": "private fun build(actualSSLSocketClass: Class<in SSLSocket>): AndroidSocketAdapter {\n      var possibleClass: Class<in SSLSocket>? = actualSSLSocketClass\n      while (possibleClass != null && possibleClass.simpleName != \"OpenSSLSocketImpl\") {\n        possibleClass = possibleClass.superclass\n\n        if (possibleClass == null) {\n          throw AssertionError(\n            \"No OpenSSLSocketImpl superclass of socket of type $actualSSLSocketClass\",\n          )\n        }\n      }\n\n      return AndroidSocketAdapter(possibleClass!!)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "laurent22/joplin",
        "function_declaration": "public folderDepth(folders: FolderEntity[], folderId: string)",
        "start_line": "64",
        "end_line": "73",
        "file_path": "packages/app-cli/app/gui/FolderListWidget.ts",
        "docstring": "The function folderDepth(folders: FolderEntity[], folderId: String) calculates the depth of a folder within a hierarchy by iteratively finding its parent folder until no parent is found, incrementing the depth counter with each iteration. It returns the depth level as an integer.\\n",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f7abb5c84bdf",
        "ground_truth": "public folderDepth(folders: FolderEntity[], folderId: string) {\n let output = 0;\n while (true) {\n  const folder = BaseModel.byId(folders, folderId);\n  const folderParentId = getDisplayParentId(folder, folders.find(f => f.id === folder.parent_id));\n  if (!folder || !folderParentId) return output;\n  output++;\n  folderId = folderParentId;\n }\n}",
        "import_statements": [
            "import Folder from '@joplin/lib/models/Folder';",
            "Folder",
            "import Tag from '@joplin/lib/models/Tag';",
            "Tag",
            "import BaseModel from '@joplin/lib/BaseModel';",
            "BaseModel",
            "import Setting from '@joplin/lib/models/Setting';",
            "Setting",
            "import { _ } from '@joplin/lib/locale';",
            "{ _ }",
            "{ _ }",
            "_",
            "import { FolderEntity } from '@joplin/lib/services/database/types';",
            "{ FolderEntity }",
            "{ FolderEntity }",
            "FolderEntity",
            "import { getDisplayParentId, getTrashFolderId } from '@joplin/lib/services/trash';",
            "{ getDisplayParentId, getTrashFolderId }",
            "{ getDisplayParentId, getTrashFolderId }",
            "getDisplayParentId",
            "getTrashFolderId"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "laurent22/joplin",
        "function_declaration": "function createConsoleWrapper(pluginId: string)",
        "start_line": "12",
        "end_line": "29",
        "file_path": "packages/app-cli/app/services/plugins/PluginRunner.ts",
        "docstring": "The function createConsoleWrapper(pluginId: string) creates a wrapper around the console object, prefixing each console method call with the plugin ID. It iterates over the console properties, and for each one, it defines a new function that adds the prefix to the arguments before calling the original console method. It returns the wrapped console object.\\n",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e179bdb11fd7",
        "ground_truth": "function createConsoleWrapper(pluginId: string) {\n // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Old code before rule was applied\n const wrapper: any = {};\n  for (const n in console) {\n  // eslint-disable-next-line no-console\n  if (!console.hasOwnProperty(n)) continue;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Old code before rule was applied\n  wrapper[n] = (...args: any[]) => {\n   const newArgs = args.slice();\n   newArgs.splice(0, 0, `Plugin \"${pluginId}\":`);\n   // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Old code before rule was applied\n   return (console as any)[n](...newArgs);\n  };\n }\n  return wrapper;\n}",
        "import_statements": [
            "import * as vm from 'vm';",
            "* as vm",
            "* as vm",
            "import Plugin from '@joplin/lib/services/plugins/Plugin';",
            "Plugin",
            "import BasePluginRunner from '@joplin/lib/services/plugins/BasePluginRunner';",
            "BasePluginRunner",
            "import executeSandboxCall from '@joplin/lib/services/plugins/utils/executeSandboxCall';",
            "executeSandboxCall",
            "import Global from '@joplin/lib/services/plugins/api/Global';",
            "Global",
            "import mapEventHandlersToIds, { EventHandlers } from '@joplin/lib/services/plugins/utils/mapEventHandlersToIds';",
            "mapEventHandlersToIds, { EventHandlers }",
            "{ EventHandlers }",
            "EventHandlers",
            "import uuid from '@joplin/lib/uuid';",
            "uuid",
            "import Joplin from '@joplin/lib/services/plugins/api/Joplin';",
            "Joplin",
            "import { Console } from 'console';",
            "{ Console }",
            "{ Console }",
            "Console"
        ],
        "reference_api": [
            "(console as any)[n]",
            "newArgs.splice",
            "args.slice"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "(console as any)[n]",
                "code": "."
            },
            {
                "name": "newArgs.splice",
                "code": "."
            },
            {
                "name": "args.slice",
                "code": "."
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "laurent22/joplin",
        "function_declaration": "public async loadItem(type: ModelType | 'folderOrNote', pattern: string, options: any = null)",
        "start_line": "55",
        "end_line": "77",
        "file_path": "packages/app-cli/app/app.ts",
        "docstring": "The function loadItem(type: ModelType | 'folderOrNote', pattern: string, options: any = null) asynchronously loads items matching the specified type and pattern using loadItems(). If more than one item matches, it throws an error. Otherwise, it returns the single matching item or null if no match is found.\\n",
        "language": "TypeScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e9339126ef5b",
        "ground_truth": "public async loadItem(type: ModelType | 'folderOrNote', pattern: string, options: any = null) {\n const output = await this.loadItems(type, pattern, options);\n if (output.length > 1) {\n  // output.sort((a, b) => { return a.user_updated_time < b.user_updated_time ? +1 : -1; });\n  // let answers = { 0: _('[Cancel]') };\n  // for (let i = 0; i < output.length; i++) {\n  // \tanswers[i + 1] = output[i].title;\n  // }\n  // Not really useful with new UI?\n  throw new Error(_('More than one item match \"%s\". Please narrow down your query.', pattern));\n  // let msg = _('More than one item match \"%s\". Please select one:', pattern);\n  // const response = await cliUtils.promptMcq(msg, answers);\n  // if (!response) return null;\n  // return output[response - 1];\n } else {\n  return output.length ? output[0] : null;\n }\n}",
        "import_statements": [
            "import BaseApplication from '@joplin/lib/BaseApplication';",
            "BaseApplication",
            "import { refreshFolders } from '@joplin/lib/folders-screen-utils.js';",
            "{ refreshFolders }",
            "{ refreshFolders }",
            "refreshFolders",
            "import ResourceService from '@joplin/lib/services/ResourceService';",
            "ResourceService",
            "import BaseModel, { ModelType } from '@joplin/lib/BaseModel';",
            "BaseModel, { ModelType }",
            "{ ModelType }",
            "ModelType",
            "import Folder from '@joplin/lib/models/Folder';",
            "Folder",
            "import BaseItem from '@joplin/lib/models/BaseItem';",
            "BaseItem",
            "import Note from '@joplin/lib/models/Note';",
            "Note",
            "import Tag from '@joplin/lib/models/Tag';",
            "Tag",
            "import Setting from '@joplin/lib/models/Setting';",
            "Setting",
            "import { reg } from '@joplin/lib/registry.js';",
            "{ reg }",
            "{ reg }",
            "reg",
            "import { fileExtension } from '@joplin/lib/path-utils';",
            "{ fileExtension }",
            "{ fileExtension }",
            "fileExtension",
            "import { splitCommandString } from '@joplin/utils';",
            "{ splitCommandString }",
            "{ splitCommandString }",
            "splitCommandString",
            "import { _ } from '@joplin/lib/locale';",
            "{ _ }",
            "{ _ }",
            "_",
            "import { pathExists, readFile, readdirSync } from 'fs-extra';",
            "{ pathExists, readFile, readdirSync }",
            "{ pathExists, readFile, readdirSync }",
            "pathExists",
            "readFile",
            "readdirSync",
            "import RevisionService from '@joplin/lib/services/RevisionService';",
            "RevisionService",
            "import shim from '@joplin/lib/shim';",
            "shim",
            "import setupCommand from './setupCommand';",
            "setupCommand",
            "import { FolderEntity, NoteEntity } from '@joplin/lib/services/database/types';",
            "{ FolderEntity, NoteEntity }",
            "{ FolderEntity, NoteEntity }",
            "FolderEntity",
            "NoteEntity"
        ],
        "reference_api": [
            "loadItem",
            "_",
            "this.loadItems"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "loadItem",
                "code": "t"
            },
            {
                "name": "_",
                "code": "t"
            },
            {
                "name": "this.loadItems",
                "code": "t"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "dcloudio/uni-app",
        "function_declaration": "function buildI18nLocale(locale, namespace, dir)",
        "start_line": "26",
        "end_line": "31",
        "file_path": "scripts/i18n.js",
        "docstring": "The function buildI18nLocale(locale, namespace, dir) loads a locale-specific JSON file from the specified directory, then builds and returns internationalization module messages using the loaded data and the provided namespace by calling buildI18nModuleMessages().\\n",
        "language": "JavaScript",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8c77ab345c2e",
        "ground_truth": "function buildI18nLocale(locale, namespace, dir) {\n  return buildI18nModuleMessages(\n    require(path.resolve(dir, locale + '.json')),\n    namespace\n  )\n}",
        "import_statements": [],
        "reference_api": [
            "path.resolve",
            "require",
            "buildI18nModuleMessages"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "path.resolve",
            "require",
            "buildI18nModuleMessages"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "private SpannableString generateCenterText()",
        "start_line": "58",
        "end_line": "63",
        "file_path": "MPChartExample/src/main/java/com/xxmassdeveloper/mpchartexample/fragments/PieChartFrag.java",
        "docstring": "The function generateCenterText() creates a SpannableString with the text \"Revenues\\nQuarters 2015\", applying a relative size span of 2x to the word \"Revenues\" and a gray foreground color span to the text \"Quarters 2015\", then returns the formatted SpannableString.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3696d5a3545b",
        "ground_truth": "private SpannableString generateCenterText() {\n    SpannableString s = new SpannableString(\"Revenues\\nQuarters 2015\");\n    s.setSpan(new RelativeSizeSpan(2f), 0, 8, 0);\n    s.setSpan(new ForegroundColorSpan(Color.GRAY), 8, s.length(), 0);\n    return s;\n}",
        "import_statements": [
            "import android.graphics.Color;",
            "import android.graphics.Typeface;",
            "import android.os.Bundle;",
            "import androidx.annotation.NonNull;",
            "import androidx.fragment.app.Fragment;",
            "import android.text.SpannableString;",
            "import android.text.style.ForegroundColorSpan;",
            "import android.text.style.RelativeSizeSpan;",
            "import android.view.LayoutInflater;",
            "import android.view.View;",
            "import android.view.ViewGroup;",
            "import com.github.mikephil.charting.charts.PieChart;",
            "import com.github.mikephil.charting.components.Legend;",
            "import com.xxmassdeveloper.mpchartexample.R;"
        ],
        "reference_api": [
            "setSpan",
            "length"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setSpan"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "protected void onCreate(Bundle savedInstanceState)",
        "start_line": "29",
        "end_line": "55",
        "file_path": "MPChartExample/src/main/java/com/xxmassdeveloper/mpchartexample/fragments/SimpleChartDemo.java",
        "docstring": "The function onCreate(Bundle savedInstanceState) sets up the activity by enabling full-screen mode, setting the content view to activity_awesomedesign, and configuring a ViewPager with a PageAdapter and an offscreen page limit of 3. It also creates and displays an AlertDialog to inform the user about the ViewPager functionality.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "436463e56da1",
        "ground_truth": "protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,\n            WindowManager.LayoutParams.FLAG_FULLSCREEN);\n    setContentView(R.layout.activity_awesomedesign);\n    setTitle(\"SimpleChartDemo\");\n    ViewPager pager = findViewById(R.id.pager);\n    pager.setOffscreenPageLimit(3);\n    PageAdapter a = new PageAdapter(getSupportFragmentManager());\n    pager.setAdapter(a);\n    AlertDialog.Builder b = new AlertDialog.Builder(this);\n    b.setTitle(\"This is a ViewPager.\");\n    b.setMessage(\"Swipe left and right for more awesome design examples!\");\n    b.setPositiveButton(\"OK\", new OnClickListener() {\n        @Override\n        public void onClick(DialogInterface dialog, int which) {\n            dialog.dismiss();\n        }\n    });\n    b.show();\n}",
        "import_statements": [
            "import android.app.AlertDialog;",
            "import android.content.DialogInterface;",
            "import android.content.DialogInterface.OnClickListener;",
            "import android.content.Intent;",
            "import android.net.Uri;",
            "import android.os.Bundle;",
            "import androidx.fragment.app.Fragment;",
            "import androidx.fragment.app.FragmentManager;",
            "import androidx.fragment.app.FragmentPagerAdapter;",
            "import androidx.viewpager.widget.ViewPager;",
            "import android.view.Menu;",
            "import android.view.MenuItem;",
            "import android.view.WindowManager;",
            "import com.xxmassdeveloper.mpchartexample.R;",
            "import com.xxmassdeveloper.mpchartexample.notimportant.DemoBase;"
        ],
        "reference_api": [
            "dismiss"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "dismiss"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "protected BarData generateBarData(int dataSets, float range, int count) ",
        "start_line": "55",
        "end_line": "75",
        "file_path": "MPChartExample/src/main/java/com/xxmassdeveloper/mpchartexample/fragments/SimpleFragment.java",
        "docstring": "The function generateBarData(int dataSets, float range, int count) creates and returns BarData containing the specified number of data sets. Each data set consists of BarEntry objects with random values within the given range. The data sets are labeled and colored using predefined templates, and the BarData object has a specific typeface applied.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bbf453d590c4",
        "ground_truth": "protected BarData generateBarData(int dataSets, float range, int count) {\n    ArrayList<IBarDataSet> sets = new ArrayList<>();\n    for(int i = 0; i < dataSets; i++) {\n        ArrayList<BarEntry> entries = new ArrayList<>();\n        for(int j = 0; j < count; j++) {\n            entries.add(new BarEntry(j, (float) (Math.random() * range) + range / 4));\n        }\n        BarDataSet ds = new BarDataSet(entries, getLabel(i));\n        ds.setColors(ColorTemplate.VORDIPLOM_COLORS);\n        sets.add(ds);\n    }\n    BarData d = new BarData(sets);\n    d.setValueTypeface(tf);\n    return d;\n}",
        "import_statements": [
            "import android.content.Context;",
            "import android.graphics.Color;",
            "import android.graphics.Typeface;",
            "import android.os.Bundle;",
            "import androidx.annotation.NonNull;",
            "import androidx.fragment.app.Fragment;",
            "import android.view.LayoutInflater;",
            "import android.view.View;",
            "import android.view.ViewGroup;",
            "import com.github.mikephil.charting.charts.ScatterChart;",
            "import com.github.mikephil.charting.data.BarData;",
            "import com.github.mikephil.charting.data.BarDataSet;",
            "import com.github.mikephil.charting.data.BarEntry;",
            "import com.github.mikephil.charting.data.Entry;",
            "import com.github.mikephil.charting.data.LineData;",
            "import com.github.mikephil.charting.data.LineDataSet;",
            "import com.github.mikephil.charting.data.PieData;",
            "import com.github.mikephil.charting.data.PieDataSet;",
            "import com.github.mikephil.charting.data.PieEntry;",
            "import com.github.mikephil.charting.data.ScatterData;",
            "import com.github.mikephil.charting.data.ScatterDataSet;",
            "import com.github.mikephil.charting.interfaces.datasets.IBarDataSet;",
            "import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;",
            "import com.github.mikephil.charting.interfaces.datasets.IScatterDataSet;",
            "import com.github.mikephil.charting.utils.ColorTemplate;",
            "import com.github.mikephil.charting.utils.FileUtils;",
            "import java.util.ArrayList;"
        ],
        "reference_api": [
            "setValueTypeface",
            "random",
            "setColors",
            "getLabel",
            "add"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getLabel",
                "code": "private String getLabel(int i) {\n        return mLabels[i];\n    }"
            }
        ],
        "third_party": [
            "setValueTypeface",
            "random",
            "setColors",
            "add"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults)",
        "start_line": "62",
        "end_line": "71",
        "file_path": "MPChartExample/src/main/java/com/xxmassdeveloper/mpchartexample/notimportant/DemoBase.java",
        "docstring": "The function onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) handles the result of a permission request. If the request code is PERMISSION_STORAGE and the permission is granted, it calls saveToGallery(). Otherwise, it displays a \"Saving FAILED!\" toast message.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5197a23ff42b",
        "ground_truth": "public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n    if (requestCode == PERMISSION_STORAGE) {\n        if (grantResults.length == 1 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n            saveToGallery();\n        } else {\n            Toast.makeText(getApplicationContext(), \"Saving FAILED!\", Toast.LENGTH_SHORT)\n                    .show();\n        }\n    }\n}",
        "import_statements": [
            "import android.Manifest;",
            "import android.content.pm.PackageManager;",
            "import android.graphics.Typeface;",
            "import android.os.Bundle;",
            "import androidx.annotation.NonNull;",
            "import androidx.annotation.Nullable;",
            "import com.google.android.material.snackbar.Snackbar;",
            "import androidx.appcompat.app.AppCompatActivity;",
            "import androidx.core.app.ActivityCompat;",
            "import android.view.View;",
            "import android.widget.Toast;",
            "import com.github.mikephil.charting.charts.Chart;",
            "import com.xxmassdeveloper.mpchartexample.R;"
        ],
        "reference_api": [
            "saveToGallery",
            "show",
            "getApplicationContext",
            "makeText"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "saveToGallery",
                "code": "protected void saveToGallery(Chart chart, String name) {\n        if (chart.saveToGallery(name + \"_\" + System.currentTimeMillis(), 70))\n            Toast.makeText(getApplicationContext(), \"Saving SUCCESSFUL!\",\n                    Toast.LENGTH_SHORT).show();\n        else\n            Toast.makeText(getApplicationContext(), \"Saving FAILED!\", Toast.LENGTH_SHORT)\n                    .show();\n    }"
            }
        ],
        "third_party": [
            "show",
            "getApplicationContext",
            "makeText"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "protected void saveToGallery(Chart chart, String name)",
        "start_line": "89",
        "end_line": "96",
        "file_path": "MPChartExample/src/main/java/com/xxmassdeveloper/mpchartexample/notimportant/DemoBase.java",
        "docstring": "The function saveToGallery(Chart chart, String name) attempts to save the given chart to the gallery with a unique name based on the current timestamp and a quality of 70. It shows a toast message indicating whether the saving operation was successful or failed.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4b2489954ebc",
        "ground_truth": "protected void saveToGallery(Chart chart, String name) {\n    if (chart.saveToGallery(name + \"_\" + System.currentTimeMillis(), 70))\n        Toast.makeText(getApplicationContext(), \"Saving SUCCESSFUL!\",\n                Toast.LENGTH_SHORT).show();\n    else\n        Toast.makeText(getApplicationContext(), \"Saving FAILED!\", Toast.LENGTH_SHORT)\n                .show();\n}",
        "import_statements": [
            "import android.Manifest;",
            "import android.content.pm.PackageManager;",
            "import android.graphics.Typeface;",
            "import android.os.Bundle;",
            "import androidx.annotation.NonNull;",
            "import androidx.annotation.Nullable;",
            "import com.google.android.material.snackbar.Snackbar;",
            "import androidx.appcompat.app.AppCompatActivity;",
            "import androidx.core.app.ActivityCompat;",
            "import android.view.View;",
            "import android.widget.Toast;",
            "import com.github.mikephil.charting.charts.Chart;",
            "import com.xxmassdeveloper.mpchartexample.R;"
        ],
        "reference_api": [
            "getApplicationContext",
            "saveToGallery",
            "currentTimeMillis",
            "makeText",
            "show"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "saveToGallery",
                "code": "protected void saveToGallery(Chart chart, String name) {\n        if (chart.saveToGallery(name + \"_\" + System.currentTimeMillis(), 70))\n            Toast.makeText(getApplicationContext(), \"Saving SUCCESSFUL!\",\n                    Toast.LENGTH_SHORT).show();\n        else\n            Toast.makeText(getApplicationContext(), \"Saving FAILED!\", Toast.LENGTH_SHORT)\n                    .show();\n    }"
            }
        ],
        "third_party": [
            "getApplicationContext",
            "currentTimeMillis",
            "makeText",
            "show"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "private void addEntry()",
        "start_line": "56",
        "end_line": "90",
        "file_path": "MPChartExample/src/main/java/com/xxmassdeveloper/mpchartexample/DynamicalAddingActivity.java",
        "docstring": "The function addEntry() adds a new entry to a chart's data. It checks if the chart has data, and if not, initializes it. It retrieves or creates a dataset, selects a random dataset, and adds a new entry with a random value to it. The function then updates the chart, adjusts the visible range, and moves the view to the latest entries.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "52511e11a8a2",
        "ground_truth": "private void addEntry() {\n    LineData data = chart.getData();\n    if (data == null) {\n        data = new LineData();\n        chart.setData(data);\n    }\n    ILineDataSet set = data.getDataSetByIndex(0);\n    // set.addEntry(...); // can be called as well\n    if (set == null) {\n        set = createSet();\n        data.addDataSet(set);\n    }\n    // choose a random dataSet\n    int randomDataSetIndex = (int) (Math.random() * data.getDataSetCount());\n    ILineDataSet randomSet = data.getDataSetByIndex(randomDataSetIndex);\n    float value = (float) (Math.random() * 50) + 50f * (randomDataSetIndex + 1);\n    data.addEntry(new Entry(randomSet.getEntryCount(), value), randomDataSetIndex);\n    data.notifyDataChanged();\n    // let the chart know it's data has changed\n    chart.notifyDataSetChanged();\n    chart.setVisibleXRangeMaximum(6);\n    //chart.setVisibleYRangeMaximum(15, AxisDependency.LEFT);\n//\n//            // this automatically refreshes the chart (calls invalidate())\n    chart.moveViewTo(data.getEntryCount() - 7, 50f, AxisDependency.LEFT);\n}",
        "import_statements": [
            "import android.Manifest;",
            "import android.content.Intent;",
            "import android.content.pm.PackageManager;",
            "import android.graphics.Color;",
            "import android.net.Uri;",
            "import android.os.Bundle;",
            "import androidx.core.content.ContextCompat;",
            "import android.view.Menu;",
            "import android.view.MenuItem;",
            "import android.view.WindowManager;",
            "import android.widget.Toast;",
            "import com.github.mikephil.charting.charts.LineChart;",
            "import com.github.mikephil.charting.components.YAxis.AxisDependency;",
            "import com.github.mikephil.charting.data.Entry;",
            "import com.github.mikephil.charting.data.LineData;",
            "import com.github.mikephil.charting.data.LineDataSet;",
            "import com.github.mikephil.charting.highlight.Highlight;",
            "import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;",
            "import com.github.mikephil.charting.listener.OnChartValueSelectedListener;",
            "import com.github.mikephil.charting.utils.ColorTemplate;",
            "import com.xxmassdeveloper.mpchartexample.notimportant.DemoBase;",
            "import java.util.ArrayList;"
        ],
        "reference_api": [
            "getDataSetByIndex",
            "getData",
            "random",
            "getEntryCount",
            "notifyDataChanged",
            "createSet",
            "notifyDataSetChanged",
            "addEntry",
            "getDataSetCount",
            "moveViewTo",
            "addDataSet",
            "setVisibleXRangeMaximum",
            "setData"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "createSet",
                "code": "private LineDataSet createSet() {\n\n        LineDataSet set = new LineDataSet(null, \"DataSet 1\");\n        set.setLineWidth(2.5f);\n        set.setCircleRadius(4.5f);\n        set.setColor(Color.rgb(240, 99, 99));\n        set.setCircleColor(Color.rgb(240, 99, 99));\n        set.setHighLightColor(Color.rgb(190, 190, 190));\n        set.setAxisDependency(AxisDependency.LEFT);\n        set.setValueTextSize(10f);\n\n        return set;\n    }"
            },
            {
                "name": "addEntry",
                "code": "private void addEntry() {\n\n        LineData data = chart.getData();\n\n        if (data == null) {\n            data = new LineData();\n            chart.setData(data);\n        }\n\n        ILineDataSet set = data.getDataSetByIndex(0);\n        // set.addEntry(...); // can be called as well\n\n        if (set == null) {\n            set = createSet();\n            data.addDataSet(set);\n        }\n\n        // choose a random dataSet\n        int randomDataSetIndex = (int) (Math.random() * data.getDataSetCount());\n        ILineDataSet randomSet = data.getDataSetByIndex(randomDataSetIndex);\n        float value = (float) (Math.random() * 50) + 50f * (randomDataSetIndex + 1);\n\n        data.addEntry(new Entry(randomSet.getEntryCount(), value), randomDataSetIndex);\n        data.notifyDataChanged();\n\n        // let the chart know it's data has changed\n        chart.notifyDataSetChanged();\n\n        chart.setVisibleXRangeMaximum(6);\n        //chart.setVisibleYRangeMaximum(15, AxisDependency.LEFT);\n//\n//            // this automatically refreshes the chart (calls invalidate())\n        chart.moveViewTo(data.getEntryCount() - 7, 50f, AxisDependency.LEFT);\n\n    }"
            },
            {
                "name": "addDataSet",
                "code": "private void addDataSet() {\n\n        LineData data = chart.getData();\n\n        if (data == null) {\n            chart.setData(new LineData());\n        } else {\n            int count = (data.getDataSetCount() + 1);\n            int amount = data.getDataSetByIndex(0).getEntryCount();\n\n            ArrayList<Entry> values = new ArrayList<>();\n\n            for (int i = 0; i < amount; i++) {\n                values.add(new Entry(i, (float) (Math.random() * 50f) + 50f * count));\n            }\n\n            LineDataSet set = new LineDataSet(values, \"DataSet \" + count);\n            set.setLineWidth(2.5f);\n            set.setCircleRadius(4.5f);\n\n            int color = colors[count % colors.length];\n\n            set.setColor(color);\n            set.setCircleColor(color);\n            set.setHighLightColor(color);\n            set.setValueTextSize(10f);\n            set.setValueTextColor(color);\n\n            data.addDataSet(set);\n            data.notifyDataChanged();\n            chart.notifyDataSetChanged();\n            chart.invalidate();\n        }\n    }"
            }
        ],
        "third_party": [
            "getDataSetByIndex",
            "getData",
            "random",
            "getEntryCount",
            "notifyDataChanged",
            "notifyDataSetChanged",
            "getDataSetCount",
            "moveViewTo",
            "setVisibleXRangeMaximum",
            "setData"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "private void moveOffScreen()",
        "start_line": "130",
        "end_line": "143",
        "file_path": "MPChartExample/src/main/java/com/xxmassdeveloper/mpchartexample/HalfPieChartActivity.java",
        "docstring": "The function moveOffScreen() moves a chart view off the screen by adjusting its bottom margin. It calculates 65% of the screen height and sets this as a negative bottom margin for the chart using RelativeLayout.LayoutParams.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7472e976bec3",
        "ground_truth": "private void moveOffScreen() {\n    DisplayMetrics displayMetrics = new DisplayMetrics();\n    getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);\n    int height = displayMetrics.heightPixels;\n    int offset = (int)(height * 0.65); /* percent to move */\n    RelativeLayout.LayoutParams rlParams =\n            (RelativeLayout.LayoutParams) chart.getLayoutParams();\n    rlParams.setMargins(0, 0, 0, -offset);\n    chart.setLayoutParams(rlParams);\n}",
        "import_statements": [
            "import android.content.Intent;",
            "import android.graphics.Color;",
            "import android.graphics.Typeface;",
            "import android.net.Uri;",
            "import android.os.Bundle;",
            "import android.text.SpannableString;",
            "import android.text.style.ForegroundColorSpan;",
            "import android.text.style.RelativeSizeSpan;",
            "import android.text.style.StyleSpan;",
            "import android.util.DisplayMetrics;",
            "import android.view.Menu;",
            "import android.view.MenuItem;",
            "import android.view.WindowManager;",
            "import android.widget.RelativeLayout;",
            "import com.github.mikephil.charting.animation.Easing;",
            "import com.github.mikephil.charting.charts.PieChart;",
            "import com.github.mikephil.charting.components.Legend;",
            "import com.github.mikephil.charting.data.PieData;",
            "import com.github.mikephil.charting.data.PieDataSet;",
            "import com.github.mikephil.charting.data.PieEntry;",
            "import com.github.mikephil.charting.formatter.PercentFormatter;",
            "import com.github.mikephil.charting.utils.ColorTemplate;",
            "import com.xxmassdeveloper.mpchartexample.notimportant.DemoBase;",
            "import java.util.ArrayList;"
        ],
        "reference_api": [
            "getLayoutParams",
            "setMargins",
            "getDefaultDisplay",
            "getWindowManager",
            "getMetrics",
            "setLayoutParams"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getLayoutParams",
            "setMargins",
            "getDefaultDisplay",
            "getWindowManager",
            "getMetrics",
            "setLayoutParams"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "public void animateXY(int durationMillisX, int durationMillisY, EasingFunction easingX,\n                          EasingFunction easingY)",
        "start_line": "122",
        "end_line": "136",
        "file_path": "MPChartLib/src/main/java/com/github/mikephil/charting/animation/ChartAnimator.java",
        "docstring": "The function animateXY(int durationMillisX, int durationMillisY, EasingFunction easingX, EasingFunction easingY) creates and starts X and Y axis animations with specified durations and easing functions. It adds an update listener to the animator with the longer duration, then starts both animators.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6dbd6f3e2e8f",
        "ground_truth": "public void animateXY(int durationMillisX, int durationMillisY, EasingFunction easingX,\n                      EasingFunction easingY) {\n    ObjectAnimator xAnimator = xAnimator(durationMillisX, easingX);\n    ObjectAnimator yAnimator = yAnimator(durationMillisY, easingY);\n    if (durationMillisX > durationMillisY) {\n        xAnimator.addUpdateListener(mListener);\n    } else {\n        yAnimator.addUpdateListener(mListener);\n    }\n    xAnimator.start();\n    yAnimator.start();\n}",
        "import_statements": [
            "import android.animation.ObjectAnimator;",
            "import android.animation.ValueAnimator.AnimatorUpdateListener;",
            "import androidx.annotation.RequiresApi;",
            "import com.github.mikephil.charting.animation.Easing.EasingFunction;"
        ],
        "reference_api": [
            "xAnimator",
            "addUpdateListener",
            "yAnimator",
            "start"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "xAnimator",
                "code": "@RequiresApi(11)\n    private ObjectAnimator xAnimator(int duration, EasingFunction easing) {\n\n        ObjectAnimator animatorX = ObjectAnimator.ofFloat(this, \"phaseX\", 0f, 1f);\n        animatorX.setInterpolator(easing);\n        animatorX.setDuration(duration);\n\n        return animatorX;\n    }"
            },
            {
                "name": "yAnimator",
                "code": "@RequiresApi(11)\n    private ObjectAnimator yAnimator(int duration, EasingFunction easing) {\n\n        ObjectAnimator animatorY = ObjectAnimator.ofFloat(this, \"phaseY\", 0f, 1f);\n        animatorY.setInterpolator(easing);\n        animatorY.setDuration(duration);\n\n        return animatorY;\n    }"
            }
        ],
        "third_party": [
            "addUpdateListener",
            "start"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "public void notifyDataSetChanged()",
        "start_line": "333",
        "end_line": "357",
        "file_path": "MPChartLib/src/main/java/com/github/mikephil/charting/charts/BarLineChartBase.java",
        "docstring": "The function notifyDataSetChanged() checks if mData is null and logs a message if logging is enabled. If mData is not null, it logs a preparation message, initializes buffers if mRenderer is not null, calculates min and max values, and updates the axis renderers for left, right, and x-axis. It also updates the legend if mLegend is not null and recalculates offsets.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3f7cb12597b5",
        "ground_truth": "public void notifyDataSetChanged() {\n    if (mData == null) {\n        if (mLogEnabled)\n            Log.i(LOG_TAG, \"Preparing... DATA NOT SET.\");\n        return;\n    } else {\n        if (mLogEnabled)\n            Log.i(LOG_TAG, \"Preparing...\");\n    }\n    if (mRenderer != null)\n        mRenderer.initBuffers();\n    calcMinMax();\n    mAxisRendererLeft.computeAxis(mAxisLeft.mAxisMinimum, mAxisLeft.mAxisMaximum, mAxisLeft.isInverted());\n    mAxisRendererRight.computeAxis(mAxisRight.mAxisMinimum, mAxisRight.mAxisMaximum, mAxisRight.isInverted());\n    mXAxisRenderer.computeAxis(mXAxis.mAxisMinimum, mXAxis.mAxisMaximum, false);\n    if (mLegend != null)\n        mLegendRenderer.computeLegend(mData);\n    calculateOffsets();\n}",
        "import_statements": [
            "import android.annotation.SuppressLint;",
            "import android.annotation.TargetApi;",
            "import android.content.Context;",
            "import android.graphics.Canvas;",
            "import android.graphics.Color;",
            "import android.graphics.Matrix;",
            "import android.graphics.Paint;",
            "import android.graphics.Paint.Style;",
            "import android.graphics.RectF;",
            "import android.util.AttributeSet;",
            "import android.util.Log;",
            "import android.view.MotionEvent;",
            "import com.github.mikephil.charting.components.XAxis.XAxisPosition;",
            "import com.github.mikephil.charting.components.YAxis;",
            "import com.github.mikephil.charting.components.YAxis.AxisDependency;",
            "import com.github.mikephil.charting.data.BarLineScatterCandleBubbleData;",
            "import com.github.mikephil.charting.data.Entry;",
            "import com.github.mikephil.charting.highlight.ChartHighlighter;",
            "import com.github.mikephil.charting.highlight.Highlight;",
            "import com.github.mikephil.charting.interfaces.dataprovider.BarLineScatterCandleBubbleDataProvider;",
            "import com.github.mikephil.charting.interfaces.datasets.IBarLineScatterCandleBubbleDataSet;",
            "import com.github.mikephil.charting.jobs.AnimatedMoveViewJob;",
            "import com.github.mikephil.charting.jobs.AnimatedZoomJob;",
            "import com.github.mikephil.charting.jobs.MoveViewJob;",
            "import com.github.mikephil.charting.jobs.ZoomJob;",
            "import com.github.mikephil.charting.listener.BarLineChartTouchListener;",
            "import com.github.mikephil.charting.listener.OnDrawListener;",
            "import com.github.mikephil.charting.renderer.XAxisRenderer;",
            "import com.github.mikephil.charting.renderer.YAxisRenderer;",
            "import com.github.mikephil.charting.utils.MPPointD;",
            "import com.github.mikephil.charting.utils.MPPointF;",
            "import com.github.mikephil.charting.utils.Transformer;",
            "import com.github.mikephil.charting.utils.Utils;"
        ],
        "reference_api": [
            "calculateOffsets",
            "isInverted",
            "i",
            "calcMinMax",
            "computeLegend",
            "computeAxis",
            "initBuffers"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "calculateOffsets",
                "code": "@Override\n    public void calculateOffsets() {\n\n        if (!mCustomViewPortEnabled) {\n\n            float offsetLeft = 0f, offsetRight = 0f, offsetTop = 0f, offsetBottom = 0f;\n\n            calculateLegendOffsets(mOffsetsBuffer);\n\n            offsetLeft += mOffsetsBuffer.left;\n            offsetTop += mOffsetsBuffer.top;\n            offsetRight += mOffsetsBuffer.right;\n            offsetBottom += mOffsetsBuffer.bottom;\n\n            // offsets for y-labels\n            if (mAxisLeft.needsOffset()) {\n                offsetLeft += mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft\n                        .getPaintAxisLabels());\n            }\n\n            if (mAxisRight.needsOffset()) {\n                offsetRight += mAxisRight.getRequiredWidthSpace(mAxisRendererRight\n                        .getPaintAxisLabels());\n            }\n\n            if (mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled()) {\n\n                float xLabelHeight = mXAxis.mLabelRotatedHeight + mXAxis.getYOffset();\n\n                // offsets for x-labels\n                if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {\n\n                    offsetBottom += xLabelHeight;\n\n                } else if (mXAxis.getPosition() == XAxisPosition.TOP) {\n\n                    offsetTop += xLabelHeight;\n\n                } else if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {\n\n                    offsetBottom += xLabelHeight;\n                    offsetTop += xLabelHeight;\n                }\n            }\n\n            offsetTop += getExtraTopOffset();\n            offsetRight += getExtraRightOffset();\n            offsetBottom += getExtraBottomOffset();\n            offsetLeft += getExtraLeftOffset();\n\n            float minOffset = Utils.convertDpToPixel(mMinOffset);\n\n            mViewPortHandler.restrainViewPort(\n                    Math.max(minOffset, offsetLeft),\n                    Math.max(minOffset, offsetTop),\n                    Math.max(minOffset, offsetRight),\n                    Math.max(minOffset, offsetBottom));\n\n            if (mLogEnabled) {\n                Log.i(LOG_TAG, \"offsetLeft: \" + offsetLeft + \", offsetTop: \" + offsetTop\n                        + \", offsetRight: \" + offsetRight + \", offsetBottom: \" + offsetBottom);\n                Log.i(LOG_TAG, \"Content: \" + mViewPortHandler.getContentRect().toString());\n            }\n        }\n\n        prepareOffsetMatrix();\n        prepareValuePxMatrix();\n    }"
            },
            {
                "name": "isInverted",
                "code": "@Override\n    public boolean isInverted(AxisDependency axis) {\n        return getAxis(axis).isInverted();\n    }"
            },
            {
                "name": "calcMinMax",
                "code": "@Override\n    protected void calcMinMax() {\n\n        mXAxis.calculate(mData.getXMin(), mData.getXMax());\n\n        // calculate axis range (min / max) according to provided data\n        mAxisLeft.calculate(mData.getYMin(AxisDependency.LEFT), mData.getYMax(AxisDependency.LEFT));\n        mAxisRight.calculate(mData.getYMin(AxisDependency.RIGHT), mData.getYMax(AxisDependency\n                .RIGHT));\n    }"
            }
        ],
        "third_party": [
            "i",
            "computeLegend",
            "computeAxis",
            "initBuffers"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": " protected void autoScale()",
        "start_line": "362",
        "end_line": "382",
        "file_path": "MPChartLib/src/main/java/com/github/mikephil/charting/charts/BarLineChartBase.java",
        "docstring": "The function autoScale() recalculates the visible data range and updates the axis limits accordingly. It determines the lowest and highest visible X values, recalculates the Y-axis min and max values for the given range, updates the X-axis limits, and adjusts the left and right Y-axis limits if they are enabled. Finally, it recalculates the chart offsets.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "26e85edb150e",
        "ground_truth": "protected void autoScale() {\n    final float fromX = getLowestVisibleX();\n    final float toX = getHighestVisibleX();\n    mData.calcMinMaxY(fromX, toX);\n    mXAxis.calculate(mData.getXMin(), mData.getXMax());\n    // calculate axis range (min / max) according to provided data\n    if (mAxisLeft.isEnabled())\n        mAxisLeft.calculate(mData.getYMin(AxisDependency.LEFT),\n                mData.getYMax(AxisDependency.LEFT));\n    if (mAxisRight.isEnabled())\n        mAxisRight.calculate(mData.getYMin(AxisDependency.RIGHT),\n                mData.getYMax(AxisDependency.RIGHT));\n    calculateOffsets();\n}",
        "import_statements": [
            "import android.annotation.SuppressLint;",
            "import android.annotation.TargetApi;",
            "import android.content.Context;",
            "import android.graphics.Canvas;",
            "import android.graphics.Color;",
            "import android.graphics.Matrix;",
            "import android.graphics.Paint;",
            "import android.graphics.Paint.Style;",
            "import android.graphics.RectF;",
            "import android.util.AttributeSet;",
            "import android.util.Log;",
            "import android.view.MotionEvent;",
            "import com.github.mikephil.charting.components.XAxis.XAxisPosition;",
            "import com.github.mikephil.charting.components.YAxis;",
            "import com.github.mikephil.charting.components.YAxis.AxisDependency;",
            "import com.github.mikephil.charting.data.BarLineScatterCandleBubbleData;",
            "import com.github.mikephil.charting.data.Entry;",
            "import com.github.mikephil.charting.highlight.ChartHighlighter;",
            "import com.github.mikephil.charting.highlight.Highlight;",
            "import com.github.mikephil.charting.interfaces.dataprovider.BarLineScatterCandleBubbleDataProvider;",
            "import com.github.mikephil.charting.interfaces.datasets.IBarLineScatterCandleBubbleDataSet;",
            "import com.github.mikephil.charting.jobs.AnimatedMoveViewJob;",
            "import com.github.mikephil.charting.jobs.AnimatedZoomJob;",
            "import com.github.mikephil.charting.jobs.MoveViewJob;",
            "import com.github.mikephil.charting.jobs.ZoomJob;",
            "import com.github.mikephil.charting.listener.BarLineChartTouchListener;",
            "import com.github.mikephil.charting.listener.OnDrawListener;",
            "import com.github.mikephil.charting.renderer.XAxisRenderer;",
            "import com.github.mikephil.charting.renderer.YAxisRenderer;",
            "import com.github.mikephil.charting.utils.MPPointD;",
            "import com.github.mikephil.charting.utils.MPPointF;",
            "import com.github.mikephil.charting.utils.Transformer;",
            "import com.github.mikephil.charting.utils.Utils;"
        ],
        "reference_api": [
            "getYMax",
            "getHighestVisibleX",
            "calcMinMaxY",
            "calculateOffsets",
            "isEnabled",
            "getYMin",
            "getXMax",
            "calculate",
            "getLowestVisibleX",
            "getXMin"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getHighestVisibleX",
                "code": "@Override\n    public float getHighestVisibleX() {\n        getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentRight(),\n                mViewPortHandler.contentBottom(), posForGetHighestVisibleX);\n        float result = (float) Math.min(mXAxis.mAxisMaximum, posForGetHighestVisibleX.x);\n        return result;\n    }"
            },
            {
                "name": "calculateOffsets",
                "code": "@Override\n    public void calculateOffsets() {\n\n        if (!mCustomViewPortEnabled) {\n\n            float offsetLeft = 0f, offsetRight = 0f, offsetTop = 0f, offsetBottom = 0f;\n\n            calculateLegendOffsets(mOffsetsBuffer);\n\n            offsetLeft += mOffsetsBuffer.left;\n            offsetTop += mOffsetsBuffer.top;\n            offsetRight += mOffsetsBuffer.right;\n            offsetBottom += mOffsetsBuffer.bottom;\n\n            // offsets for y-labels\n            if (mAxisLeft.needsOffset()) {\n                offsetLeft += mAxisLeft.getRequiredWidthSpace(mAxisRendererLeft\n                        .getPaintAxisLabels());\n            }\n\n            if (mAxisRight.needsOffset()) {\n                offsetRight += mAxisRight.getRequiredWidthSpace(mAxisRendererRight\n                        .getPaintAxisLabels());\n            }\n\n            if (mXAxis.isEnabled() && mXAxis.isDrawLabelsEnabled()) {\n\n                float xLabelHeight = mXAxis.mLabelRotatedHeight + mXAxis.getYOffset();\n\n                // offsets for x-labels\n                if (mXAxis.getPosition() == XAxisPosition.BOTTOM) {\n\n                    offsetBottom += xLabelHeight;\n\n                } else if (mXAxis.getPosition() == XAxisPosition.TOP) {\n\n                    offsetTop += xLabelHeight;\n\n                } else if (mXAxis.getPosition() == XAxisPosition.BOTH_SIDED) {\n\n                    offsetBottom += xLabelHeight;\n                    offsetTop += xLabelHeight;\n                }\n            }\n\n            offsetTop += getExtraTopOffset();\n            offsetRight += getExtraRightOffset();\n            offsetBottom += getExtraBottomOffset();\n            offsetLeft += getExtraLeftOffset();\n\n            float minOffset = Utils.convertDpToPixel(mMinOffset);\n\n            mViewPortHandler.restrainViewPort(\n                    Math.max(minOffset, offsetLeft),\n                    Math.max(minOffset, offsetTop),\n                    Math.max(minOffset, offsetRight),\n                    Math.max(minOffset, offsetBottom));\n\n            if (mLogEnabled) {\n                Log.i(LOG_TAG, \"offsetLeft: \" + offsetLeft + \", offsetTop: \" + offsetTop\n                        + \", offsetRight: \" + offsetRight + \", offsetBottom: \" + offsetBottom);\n                Log.i(LOG_TAG, \"Content: \" + mViewPortHandler.getContentRect().toString());\n            }\n        }\n\n        prepareOffsetMatrix();\n        prepareValuePxMatrix();\n    }"
            },
            {
                "name": "getLowestVisibleX",
                "code": "@Override\n    public float getLowestVisibleX() {\n        getTransformer(AxisDependency.LEFT).getValuesByTouchPoint(mViewPortHandler.contentLeft(),\n                mViewPortHandler.contentBottom(), posForGetLowestVisibleX);\n        float result = (float) Math.max(mXAxis.mAxisMinimum, posForGetLowestVisibleX.x);\n        return result;\n    }"
            }
        ],
        "third_party": [
            "getYMax",
            "calcMinMaxY",
            "isEnabled",
            "getYMin",
            "getXMax",
            "calculate",
            "getXMin"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": " protected void drawDescription(Canvas c) ",
        "start_line": "434",
        "end_line": "459",
        "file_path": "MPChartLib/src/main/java/com/github/mikephil/charting/charts/Chart.java",
        "docstring": "The function drawDescription(Canvas c) draws a description on the provided canvas if the description is enabled. It sets up the paint properties from the description, determines the position to draw the text, and then draws the text on the canvas at the calculated position.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6ccb197af720",
        "ground_truth": "protected void drawDescription(Canvas c) {\n    // check if description should be drawn\n    if (mDescription != null && mDescription.isEnabled()) {\n        MPPointF position = mDescription.getPosition();\n        mDescPaint.setTypeface(mDescription.getTypeface());\n        mDescPaint.setTextSize(mDescription.getTextSize());\n        mDescPaint.setColor(mDescription.getTextColor());\n        mDescPaint.setTextAlign(mDescription.getTextAlign());\n        float x, y;\n        // if no position specified, draw on default position\n        if (position == null) {\n            x = getWidth() - mViewPortHandler.offsetRight() - mDescription.getXOffset();\n            y = getHeight() - mViewPortHandler.offsetBottom() - mDescription.getYOffset();\n        } else {\n            x = position.x;\n            y = position.y;\n        }\n        c.drawText(mDescription.getText(), x, y, mDescPaint);\n    }\n}",
        "import_statements": [
            "import android.animation.ValueAnimator;",
            "import android.animation.ValueAnimator.AnimatorUpdateListener;",
            "import android.content.ContentValues;",
            "import android.content.Context;",
            "import android.graphics.Bitmap;",
            "import android.graphics.Bitmap.CompressFormat;",
            "import android.graphics.Canvas;",
            "import android.graphics.Color;",
            "import android.graphics.Paint;",
            "import android.graphics.Paint.Align;",
            "import android.graphics.RectF;",
            "import android.graphics.Typeface;",
            "import android.graphics.drawable.Drawable;",
            "import android.os.Build;",
            "import android.os.Environment;",
            "import android.provider.MediaStore.Images;",
            "import androidx.annotation.RequiresApi;",
            "import android.text.TextUtils;",
            "import android.util.AttributeSet;",
            "import android.util.Log;",
            "import android.view.View;",
            "import android.view.ViewGroup;",
            "import android.view.ViewParent;",
            "import com.github.mikephil.charting.animation.ChartAnimator;",
            "import com.github.mikephil.charting.animation.Easing;",
            "import com.github.mikephil.charting.animation.Easing.EasingFunction;",
            "import com.github.mikephil.charting.components.Description;",
            "import com.github.mikephil.charting.components.IMarker;",
            "import com.github.mikephil.charting.components.Legend;",
            "import com.github.mikephil.charting.components.XAxis;",
            "import com.github.mikephil.charting.data.ChartData;",
            "import com.github.mikephil.charting.data.Entry;",
            "import com.github.mikephil.charting.formatter.DefaultValueFormatter;",
            "import com.github.mikephil.charting.formatter.IValueFormatter;",
            "import com.github.mikephil.charting.highlight.ChartHighlighter;",
            "import com.github.mikephil.charting.highlight.Highlight;",
            "import com.github.mikephil.charting.highlight.IHighlighter;",
            "import com.github.mikephil.charting.interfaces.dataprovider.ChartInterface;",
            "import com.github.mikephil.charting.interfaces.datasets.IDataSet;",
            "import com.github.mikephil.charting.listener.ChartTouchListener;",
            "import com.github.mikephil.charting.listener.OnChartGestureListener;",
            "import com.github.mikephil.charting.listener.OnChartValueSelectedListener;",
            "import com.github.mikephil.charting.renderer.DataRenderer;",
            "import com.github.mikephil.charting.renderer.LegendRenderer;",
            "import com.github.mikephil.charting.utils.MPPointF;",
            "import com.github.mikephil.charting.utils.Utils;",
            "import com.github.mikephil.charting.utils.ViewPortHandler;",
            "import java.io.File;",
            "import java.io.FileOutputStream;",
            "import java.io.IOException;",
            "import java.io.OutputStream;",
            "import java.util.ArrayList;"
        ],
        "reference_api": [
            "setTextSize",
            "getTextAlign",
            "getYOffset",
            "getWidth",
            "setColor",
            "getTextColor",
            "offsetBottom",
            "drawText",
            "offsetRight",
            "isEnabled",
            "setTextAlign",
            "getTypeface",
            "getXOffset",
            "getPosition",
            "setTypeface",
            "getHeight",
            "getText",
            "getTextSize"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setTextSize",
            "getTextAlign",
            "getYOffset",
            "getWidth",
            "setColor",
            "getTextColor",
            "offsetBottom",
            "drawText",
            "offsetRight",
            "isEnabled",
            "setTextAlign",
            "getTypeface",
            "getXOffset",
            "getPosition",
            "setTypeface",
            "getHeight",
            "getText",
            "getTextSize"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "PhilJay/MPAndroidChart",
        "function_declaration": "protected void onDraw(Canvas canvas)",
        "start_line": "126",
        "end_line": "146",
        "file_path": "MPChartLib/src/main/java/com/github/mikephil/charting/charts/PieChart.java",
        "docstring": "The function onDraw(Canvas canvas) overrides the superclass method to draw various components on the canvas. It checks if mData is null, then proceeds to draw data, highlighted values, extras, values, the legend, description, and markers using mRenderer and mLegendRenderer.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f976b4e310bb",
        "ground_truth": "protected void onDraw(Canvas canvas) {\n    super.onDraw(canvas);\n    if (mData == null)\n        return;\n    mRenderer.drawData(canvas);\n    if (valuesToHighlight())\n        mRenderer.drawHighlighted(canvas, mIndicesToHighlight);\n    mRenderer.drawExtras(canvas);\n    mRenderer.drawValues(canvas);\n    mLegendRenderer.renderLegend(canvas);\n    drawDescription(canvas);\n    drawMarkers(canvas);\n}",
        "import_statements": [
            "import android.content.Context;",
            "import android.graphics.Canvas;",
            "import android.graphics.Paint;",
            "import android.graphics.RectF;",
            "import android.graphics.Typeface;",
            "import android.util.AttributeSet;",
            "import com.github.mikephil.charting.components.XAxis;",
            "import com.github.mikephil.charting.data.PieData;",
            "import com.github.mikephil.charting.highlight.Highlight;",
            "import com.github.mikephil.charting.highlight.PieHighlighter;",
            "import com.github.mikephil.charting.interfaces.datasets.IPieDataSet;",
            "import com.github.mikephil.charting.renderer.PieChartRenderer;",
            "import com.github.mikephil.charting.utils.MPPointF;",
            "import com.github.mikephil.charting.utils.Utils;",
            "import java.util.List;"
        ],
        "reference_api": [
            "drawHighlighted",
            "drawValues",
            "renderLegend",
            "drawDescription",
            "valuesToHighlight",
            "drawExtras",
            "onDraw",
            "drawMarkers",
            "drawData"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "onDraw",
                "code": "@Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (mData == null)\n            return;\n\n        mRenderer.drawData(canvas);\n\n        if (valuesToHighlight())\n            mRenderer.drawHighlighted(canvas, mIndicesToHighlight);\n\n        mRenderer.drawExtras(canvas);\n\n        mRenderer.drawValues(canvas);\n\n        mLegendRenderer.renderLegend(canvas);\n\n        drawDescription(canvas);\n\n        drawMarkers(canvas);\n    }"
            }
        ],
        "third_party": [
            "drawHighlighted",
            "drawValues",
            "renderLegend",
            "drawDescription",
            "valuesToHighlight",
            "drawExtras",
            "drawMarkers",
            "drawData"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "suspend fun flatten(depth: Int, connect: suspend (URL) -> URLConnection): Acl",
        "start_line": "154",
        "end_line": "172",
        "file_path": "core/src/main/java/com/github/shadowsocks/acl/Acl.kt",
        "docstring": "The suspend function flatten(depth: Int, connect: suspend (URL) -> URLConnection): Acl recursively processes URLs to build and merge Acl objects. For each URL, it creates an Acl from the connected URL stream, follows redirects if necessary, and calls flatten on the child Acl with a decremented depth. It handles conflicting bypass modes by clearing conflicting subnets and merging bypass hostnames, proxy hostnames, and subnets. Finally, it clears the URLs list and returns the modified Acl.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5735b70e8332",
        "ground_truth": "suspend fun flatten(depth: Int, connect: suspend (URL) -> URLConnection): Acl {\n    if (depth > 0) for (url in urls.asIterable()) {\n        val child = Acl().fromReader(connect(url).also {\n            (it as? HttpURLConnection)?.instanceFollowRedirects = true\n        }.getInputStream().bufferedReader(), bypass)\n        child.flatten(depth - 1, connect)\n        if (bypass != child.bypass) {\n            Timber.w(\"Imported network ACL has a conflicting mode set. \" +\n                    \"This will probably not work as intended. URL: $url\")\n            child.subnets.clear() // subnets for the different mode are discarded\n            child.bypass = bypass\n        }\n        for (item in child.bypassHostnames.asIterable()) bypassHostnames.add(item)\n        for (item in child.proxyHostnames.asIterable()) proxyHostnames.add(item)\n        for (item in child.subnets.asIterable()) subnets.add(item)\n    }\n    urls.clear()\n    return this\n}",
        "import_statements": [
            "import android.content.Context",
            "import androidx.recyclerview.widget.SortedList",
            "import com.github.shadowsocks.Core",
            "import com.github.shadowsocks.net.Subnet",
            "import com.github.shadowsocks.utils.BaseSorter",
            "import com.github.shadowsocks.utils.URLSorter",
            "import com.github.shadowsocks.utils.asIterable",
            "import kotlinx.coroutines.Job",
            "import kotlinx.coroutines.ensureActive",
            "import kotlinx.coroutines.runBlocking",
            "import timber.log.Timber",
            "import java.io.File",
            "import java.io.IOException",
            "import java.io.Reader",
            "import java.net.HttpURLConnection",
            "import java.net.URL",
            "import java.net.URLConnection",
            "import kotlin.coroutines.coroutineContext"
        ],
        "reference_api": [
            "Acl",
            "connect"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Acl",
                "code": "Acl()"
            },
            {
                "name": "connect",
                "code": "suspend fun flatten(depth: Int, connect: suspend (URL) -> URLConnection): Acl {\n        if (depth > 0) for (url in urls.asIterable()) {\n            val child = Acl().fromReader(connect(url).also {\n                (it as? HttpURLConnection)?.instanceFollowRedirects = true\n            }.getInputStream().bufferedReader(), bypass)\n            child.flatten(depth - 1, connect)\n            if (bypass != child.bypass) {\n                Timber.w(\"Imported network ACL has a conflicting mode set. \" +\n                        \"This will probably not work as intended. URL: $url\")\n                child.subnets.clear() // subnets for the different mode are discarded\n                child.bypass = bypass\n            }\n            for (item in child.bypassHostnames.asIterable()) bypassHostnames.add(item)\n            for (item in child.proxyHostnames.asIterable()) proxyHostnames.add(item)\n            for (item in child.subnets.asIterable()) subnets.add(item)\n        }\n        urls.clear()\n        return this\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "override fun onServiceConnected(name: ComponentName?, binder: IBinder)",
        "start_line": "97",
        "end_line": "109",
        "file_path": "core/src/main/java/com/github/shadowsocks/aidl/ShadowsocksConnection.kt",
        "docstring": "The function onServiceConnected(name: ComponentName?, binder: IBinder) sets up the connection to a service by initializing the binder and service instances. It registers a callback for service death if required, registers the service callback, and starts listening for bandwidth if a timeout is set. Finally, it notifies that the service is connected.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2e773868068a",
        "ground_truth": "override fun onServiceConnected(name: ComponentName?, binder: IBinder) {\n    this.binder = binder\n    val service = IShadowsocksService.Stub.asInterface(binder)!!\n    this.service = service\n    try {\n        if (listenForDeath) binder.linkToDeath(this, 0)\n        check(!callbackRegistered)\n        service.registerCallback(serviceCallback)\n        callbackRegistered = true\n        if (bandwidthTimeout > 0) service.startListeningForBandwidth(serviceCallback, bandwidthTimeout)\n    } catch (_: RemoteException) { }\n    callback!!.onServiceConnected(service)\n}",
        "import_statements": [
            "import android.content.ComponentName",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.ServiceConnection",
            "import android.os.IBinder",
            "import android.os.RemoteException",
            "import com.github.shadowsocks.bg.BaseService",
            "import com.github.shadowsocks.bg.ProxyService",
            "import com.github.shadowsocks.bg.TransproxyService",
            "import com.github.shadowsocks.bg.VpnService",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.Action",
            "import com.github.shadowsocks.utils.Key",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.GlobalScope",
            "import kotlinx.coroutines.launch"
        ],
        "reference_api": [
            "check"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "override fun binderDied()",
        "start_line": "118",
        "end_line": "122",
        "file_path": "core/src/main/java/com/github/shadowsocks/aidl/ShadowsocksConnection.kt",
        "docstring": "The function binderDied() overrides a method to handle the event when a binder dies. It sets service to null and callbackRegistered to false, then launches a coroutine on the main dispatcher to call the onBinderDied() method on the callback if it exists.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6a6960437c41",
        "ground_truth": "override fun binderDied() {\n    service = null\n    callbackRegistered = false\n    callback?.also { GlobalScope.launch(Dispatchers.Main.immediate) { it.onBinderDied() } }\n}",
        "import_statements": [
            "import android.content.ComponentName",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.ServiceConnection",
            "import android.os.IBinder",
            "import android.os.RemoteException",
            "import com.github.shadowsocks.bg.BaseService",
            "import com.github.shadowsocks.bg.ProxyService",
            "import com.github.shadowsocks.bg.TransproxyService",
            "import com.github.shadowsocks.bg.VpnService",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.Action",
            "import com.github.shadowsocks.utils.Key",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.GlobalScope",
            "import kotlinx.coroutines.launch"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "fun connect(context: Context, callback: Callback)",
        "start_line": "132",
        "end_line": "139",
        "file_path": "core/src/main/java/com/github/shadowsocks/aidl/ShadowsocksConnection.kt",
        "docstring": "The function connect(context: Context, callback: Callback) establishes a service connection if one is not already active. It sets connectionActive to true, assigns the provided callback, and binds the service using an intent with a specified action and service class.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "604f0e17b4f9",
        "ground_truth": "fun connect(context: Context, callback: Callback) {\n    if (connectionActive) return\n    connectionActive = true\n    check(this.callback == null)\n    this.callback = callback\n    val intent = Intent(context, serviceClass).setAction(Action.SERVICE)\n    context.bindService(intent, this, Context.BIND_AUTO_CREATE)\n}",
        "import_statements": [
            "import android.content.ComponentName",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.ServiceConnection",
            "import android.os.IBinder",
            "import android.os.RemoteException",
            "import com.github.shadowsocks.bg.BaseService",
            "import com.github.shadowsocks.bg.ProxyService",
            "import com.github.shadowsocks.bg.TransproxyService",
            "import com.github.shadowsocks.bg.VpnService",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.Action",
            "import com.github.shadowsocks.utils.Key",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.GlobalScope",
            "import kotlinx.coroutines.launch"
        ],
        "reference_api": [
            "check",
            "Intent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Intent",
                "code": "fun connect(context: Context, callback: Callback) {\n        if (connectionActive) return\n        connectionActive = true\n        check(this.callback == null)\n        this.callback = callback\n        val intent = Intent(context, serviceClass).setAction(Action.SERVICE)\n        context.bindService(intent, this, Context.BIND_AUTO_CREATE)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "fun disconnect(context: Context) ",
        "start_line": "141",
        "end_line": "156",
        "file_path": "core/src/main/java/com/github/shadowsocks/aidl/ShadowsocksConnection.kt",
        "docstring": "The function disconnect(context: Context) handles the disconnection process by unregistering a callback, unbinding a service if active, unlinking a binder to avoid listening for death, and stopping service bandwidth listening. It catches and ignores specific exceptions, then resets related variables to null.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "64e0f447d3c9",
        "ground_truth": "fun disconnect(context: Context) {\n    unregisterCallback()\n    if (connectionActive) try {\n        context.unbindService(this)\n    } catch (_: IllegalArgumentException) { }   // ignore\n    connectionActive = false\n    if (listenForDeath) try {\n        binder?.unlinkToDeath(this, 0)\n    } catch (_: NoSuchElementException) { }\n    binder = null\n    try {\n        service?.stopListeningForBandwidth(serviceCallback)\n    } catch (_: RemoteException) { }\n    service = null\n    callback = null\n}",
        "import_statements": [
            "import android.content.ComponentName",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.ServiceConnection",
            "import android.os.IBinder",
            "import android.os.RemoteException",
            "import com.github.shadowsocks.bg.BaseService",
            "import com.github.shadowsocks.bg.ProxyService",
            "import com.github.shadowsocks.bg.TransproxyService",
            "import com.github.shadowsocks.bg.VpnService",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.Action",
            "import com.github.shadowsocks.utils.Key",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.GlobalScope",
            "import kotlinx.coroutines.launch"
        ],
        "reference_api": [
            "unregisterCallback"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "unregisterCallback",
                "code": "override fun onServiceDisconnected(name: ComponentName?) {\n        unregisterCallback()\n        callback?.onServiceDisconnected()\n        service = null\n        binder = null\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": " private fun broadcast(work: (IShadowsocksServiceCallback) -> Unit) ",
        "start_line": "121",
        "end_line": "135",
        "file_path": "core/src/main/java/com/github/shadowsocks/bg/BaseService.kt",
        "docstring": "The function broadcast(work: (IShadowsocksServiceCallback) -> Unit) iterates over a list of callback items, applying the provided work function to each. It handles RemoteException silently and logs other exceptions using Timber. The broadcast process is properly finalized using callbacks.finishBroadcast().\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "cf4b0590d644",
        "ground_truth": "private fun broadcast(work: (IShadowsocksServiceCallback) -> Unit) {\n    val count = callbacks.beginBroadcast()\n    try {\n        repeat(count) {\n            try {\n                work(callbacks.getBroadcastItem(it))\n            } catch (_: RemoteException) {\n            } catch (e: Exception) {\n                Timber.w(e)\n            }\n        }\n    } finally {\n        callbacks.finishBroadcast()\n    }\n}",
        "import_statements": [
            "import android.app.Service",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.IntentFilter",
            "import android.os.Build",
            "import android.os.IBinder",
            "import android.os.RemoteCallbackList",
            "import android.os.RemoteException",
            "import androidx.core.content.ContextCompat",
            "import com.github.shadowsocks.BootReceiver",
            "import com.github.shadowsocks.Core",
            "import com.github.shadowsocks.Core.app",
            "import com.github.shadowsocks.acl.Acl",
            "import com.github.shadowsocks.aidl.IShadowsocksService",
            "import com.github.shadowsocks.aidl.IShadowsocksServiceCallback",
            "import com.github.shadowsocks.aidl.TrafficStats",
            "import com.github.shadowsocks.core.R",
            "import com.github.shadowsocks.net.DnsResolverCompat",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.Action",
            "import com.github.shadowsocks.utils.broadcastReceiver",
            "import com.github.shadowsocks.utils.readableMessage",
            "import com.google.firebase.analytics.FirebaseAnalytics",
            "import com.google.firebase.analytics.ktx.analytics",
            "import com.google.firebase.analytics.ktx.logEvent",
            "import com.google.firebase.ktx.Firebase",
            "import kotlinx.coroutines.*",
            "import timber.log.Timber",
            "import java.io.File",
            "import java.io.IOException",
            "import java.net.URL"
        ],
        "reference_api": [
            "work",
            "repeat"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "work",
                "code": "private fun broadcast(work: (IShadowsocksServiceCallback) -> Unit) {\n            val count = callbacks.beginBroadcast()\n            try {\n                repeat(count) {\n                    try {\n                        work(callbacks.getBroadcastItem(it))\n                    } catch (_: RemoteException) {\n                    } catch (e: Exception) {\n                        Timber.w(e)\n                    }\n                }\n            } finally {\n                callbacks.finishBroadcast()\n            }\n        }"
            },
            {
                "name": "repeat",
                "code": "private fun broadcast(work: (IShadowsocksServiceCallback) -> Unit) {\n            val count = callbacks.beginBroadcast()\n            try {\n                repeat(count) {\n                    try {\n                        work(callbacks.getBroadcastItem(it))\n                    } catch (_: RemoteException) {\n                    } catch (e: Exception) {\n                        Timber.w(e)\n                    }\n                }\n            } finally {\n                callbacks.finishBroadcast()\n            }\n        }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": " fun killAll() ",
        "start_line": "38",
        "end_line": "54",
        "file_path": "core/src/main/java/com/github/shadowsocks/bg/Executable.kt",
        "docstring": "The function killAll() iterates through all processes in the /proc directory and attempts to kill processes with executable names found in the EXECUTABLES list by sending a SIGKILL signal. It handles potential IOExceptions and logs warnings if the kill operation fails for reasons other than the process not existing.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "27ef1985c39f",
        "ground_truth": "fun killAll() {\n    for (process in File(\"/proc\").listFiles { _, name -> TextUtils.isDigitsOnly(name) } ?: return) {\n        val exe = File(try {\n            File(process, \"cmdline\").inputStream().bufferedReader().readText()\n        } catch (_: IOException) {\n            continue\n        }.split(Character.MIN_VALUE, limit = 2).first())\n        if (EXECUTABLES.contains(exe.name)) try {\n            Os.kill(process.name.toInt(), OsConstants.SIGKILL)\n        } catch (e: ErrnoException) {\n            if (e.errno != OsConstants.ESRCH) {\n                Timber.w(\"SIGKILL ${exe.absolutePath} (${process.name}) failed\")\n                Timber.w(e)\n            }\n        }\n    }\n}",
        "import_statements": [
            "import android.system.ErrnoException",
            "import android.system.Os",
            "import android.system.OsConstants",
            "import android.text.TextUtils",
            "import timber.log.Timber",
            "import java.io.File",
            "import java.io.IOException"
        ],
        "reference_api": [
            "File"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "private val callback: IShadowsocksServiceCallback by lazy",
        "start_line": "54",
        "end_line": "71",
        "file_path": "core/src/main/java/com/github/shadowsocks/bg/ServiceNotification.kt",
        "docstring": "The function defines a lazy-initialized IShadowsocksServiceCallback object with three overridden methods: stateChanged(state: Int, profileName: String?, msg: String?), trafficUpdated(profileId: Long, stats: TrafficStats), and trafficPersisted(profileId: Long). The trafficUpdated method updates and displays traffic statistics if the profileId is 0.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "576274bdfabd",
        "ground_truth": "private val callback: IShadowsocksServiceCallback by lazy {\n    object : IShadowsocksServiceCallback.Stub() {\n        override fun stateChanged(state: Int, profileName: String?, msg: String?) { }   // ignore\n        override fun trafficUpdated(profileId: Long, stats: TrafficStats) {\n            if (profileId != 0L) return\n            builder.apply {\n                setContentText((service as Context).getString(R.string.traffic,\n                        service.getString(R.string.speed, Formatter.formatFileSize(service, stats.txRate)),\n                        service.getString(R.string.speed, Formatter.formatFileSize(service, stats.rxRate))))\n                setSubText(service.getString(R.string.traffic,\n                        Formatter.formatFileSize(service, stats.txTotal),\n                        Formatter.formatFileSize(service, stats.rxTotal)))\n            }\n            show()\n        }\n        override fun trafficPersisted(profileId: Long) { }\n    }\n}",
        "import_statements": [
            "import android.app.PendingIntent",
            "import android.app.Service",
            "import android.content.BroadcastReceiver",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.IntentFilter",
            "import android.os.Build",
            "import android.os.PowerManager",
            "import android.text.format.Formatter",
            "import androidx.core.app.NotificationCompat",
            "import androidx.core.app.ServiceCompat",
            "import androidx.core.content.ContextCompat",
            "import androidx.core.content.getSystemService",
            "import com.github.shadowsocks.Core",
            "import com.github.shadowsocks.aidl.IShadowsocksServiceCallback",
            "import com.github.shadowsocks.aidl.TrafficStats",
            "import com.github.shadowsocks.core.R",
            "import com.github.shadowsocks.utils.Action"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "fun persistStats(id: Long)",
        "start_line": "91",
        "end_line": "110",
        "file_path": "core/src/main/java/com/github/shadowsocks/bg/TrafficMonitor.kt",
        "docstring": "The function persistStats(id: Long) updates the persisted stats for a profile. It ensures no data loss has occurred by checking the current stats against persisted stats. It fetches the profile by id, updates its tx and rx values, and saves the profile. If an IOException occurs and DataStore is not direct boot aware, it handles the exception by updating the profile through DirectBoot, marking it as dirty, and listening for device unlock.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0b43df3afa22",
        "ground_truth": "fun persistStats(id: Long) {\n    val current = current\n    check(persisted == null || persisted == current) { \"Data loss occurred\" }\n    persisted = current\n    try {\n        // profile may have host, etc. modified and thus a re-fetch is necessary (possible race condition)\n        val profile = ProfileManager.getProfile(id) ?: return\n        profile.tx += current.txTotal\n        profile.rx += current.rxTotal\n        ProfileManager.updateProfile(profile)\n    } catch (e: IOException) {\n        if (!DataStore.directBootAware) throw e // we should only reach here because we're in direct boot\n        val profile = DirectBoot.getDeviceProfile()!!.toList().single { it.id == id }\n        profile.tx += current.txTotal\n        profile.rx += current.rxTotal\n        profile.dirty = true\n        DirectBoot.update(profile)\n        DirectBoot.listenForUnlock()\n    }\n}",
        "import_statements": [
            "import android.net.LocalSocket",
            "import android.os.SystemClock",
            "import com.github.shadowsocks.aidl.TrafficStats",
            "import com.github.shadowsocks.database.ProfileManager",
            "import com.github.shadowsocks.net.LocalSocketListener",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.DirectBoot",
            "import java.io.File",
            "import java.io.IOException",
            "import java.nio.ByteBuffer",
            "import java.nio.ByteOrder"
        ],
        "reference_api": [
            "check"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "private suspend fun sendFd(fd: FileDescriptor)",
        "start_line": "234",
        "end_line": "249",
        "file_path": "core/src/main/java/com/github/shadowsocks/bg/VpnService.kt",
        "docstring": "The function sendFd(fd: FileDescriptor) is a suspending function that attempts to send a file descriptor through a local socket connection. It retries up to five times with increasing delays if an IOException occurs, using a specified socket path from Core.deviceStorage.noBackupFilesDir.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "5b55bd08918f",
        "ground_truth": "private suspend fun sendFd(fd: FileDescriptor) {\n    var tries = 0\n    val path = File(Core.deviceStorage.noBackupFilesDir, \"sock_path\").absolutePath\n    while (true) try {\n        delay(50L shl tries)\n        LocalSocket().use { localSocket ->\n            localSocket.connect(LocalSocketAddress(path, LocalSocketAddress.Namespace.FILESYSTEM))\n            localSocket.setFileDescriptorsForSend(arrayOf(fd))\n            localSocket.outputStream.write(42)\n        }\n        return\n    } catch (e: IOException) {\n        if (tries > 5) throw e\n        tries += 1\n    }\n}",
        "import_statements": [
            "import android.app.Service",
            "import android.content.Intent",
            "import android.content.pm.PackageManager",
            "import android.net.LocalSocket",
            "import android.net.LocalSocketAddress",
            "import android.net.Network",
            "import android.os.Build",
            "import android.os.ParcelFileDescriptor",
            "import android.system.ErrnoException",
            "import android.system.Os",
            "import android.system.OsConstants",
            "import com.github.shadowsocks.Core",
            "import com.github.shadowsocks.VpnRequestActivity",
            "import com.github.shadowsocks.acl.Acl",
            "import com.github.shadowsocks.core.R",
            "import com.github.shadowsocks.net.ConcurrentLocalSocketListener",
            "import com.github.shadowsocks.net.DefaultNetworkListener",
            "import com.github.shadowsocks.net.DnsResolverCompat",
            "import com.github.shadowsocks.net.Subnet",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.Key",
            "import com.github.shadowsocks.utils.int",
            "import kotlinx.coroutines.CoroutineScope",
            "import kotlinx.coroutines.delay",
            "import kotlinx.coroutines.launch",
            "import timber.log.Timber",
            "import java.io.File",
            "import java.io.FileDescriptor",
            "import java.io.IOException",
            "import java.net.URL",
            "import android.net.VpnService. as as BaseVpnService"
        ],
        "reference_api": [
            "File",
            "arrayOf",
            "LocalSocketAddress",
            "delay",
            "LocalSocket"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "LocalSocketAddress",
                "code": "private suspend fun sendFd(fd: FileDescriptor) {\n        var tries = 0\n        val path = File(Core.deviceStorage.noBackupFilesDir, \"sock_path\").absolutePath\n        while (true) try {\n            delay(50L shl tries)\n            LocalSocket().use { localSocket ->\n                localSocket.connect(LocalSocketAddress(path, LocalSocketAddress.Namespace.FILESYSTEM))\n                localSocket.setFileDescriptorsForSend(arrayOf(fd))\n                localSocket.outputStream.write(42)\n            }\n            return\n        } catch (e: IOException) {\n            if (tries > 5) throw e\n            tries += 1\n        }\n    }"
            },
            {
                "name": "LocalSocket",
                "code": "private suspend fun sendFd(fd: FileDescriptor) {\n        var tries = 0\n        val path = File(Core.deviceStorage.noBackupFilesDir, \"sock_path\").absolutePath\n        while (true) try {\n            delay(50L shl tries)\n            LocalSocket().use { localSocket ->\n                localSocket.connect(LocalSocketAddress(path, LocalSocketAddress.Namespace.FILESYSTEM))\n                localSocket.setFileDescriptorsForSend(arrayOf(fd))\n                localSocket.outputStream.write(42)\n            }\n            return\n        } catch (e: IOException) {\n            if (tries > 5) throw e\n            tries += 1\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "fun parseJson(json: JsonElement, feature: Profile? = null, create: (Profile) -> Profile) ",
        "start_line": "238",
        "end_line": "248",
        "file_path": "core/src/main/java/com/github/shadowsocks/database/Profile.kt",
        "docstring": "The function parseJson(json: JsonElement, feature: Profile? = null, create: (Profile) -> Profile) parses a JSON element using a JsonParser initialized with an optional Profile. It processes the JSON, updates indices with created profiles, handles fallbacks, and finalizes the parsing process using the create function.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "80c5a74fcfb7",
        "ground_truth": "fun parseJson(json: JsonElement, feature: Profile? = null, create: (Profile) -> Profile) {\n    JsonParser(feature).run {\n        process(json)\n        for (i in indices) {\n            val fallback = fallbackMap.remove(this[i])\n            this[i] = create(this[i])\n            fallback?.also { fallbackMap[this[i]] = it }\n        }\n        finalize(create)\n    }\n}",
        "import_statements": [
            "import android.annotation.TargetApi",
            "import android.net.Uri",
            "import android.os.Parcelable",
            "import android.util.Base64",
            "import android.util.LongSparseArray",
            "import androidx.core.net.toUri",
            "import androidx.room.*",
            "import com.github.shadowsocks.plugin.PluginConfiguration",
            "import com.github.shadowsocks.plugin.PluginOptions",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.Key",
            "import com.github.shadowsocks.utils.parsePort",
            "import com.google.gson.JsonArray",
            "import com.google.gson.JsonElement",
            "import com.google.gson.JsonObject",
            "import com.google.gson.JsonPrimitive",
            "import kotlinx.parcelize.Parcelize",
            "import org.json.JSONArray",
            "import org.json.JSONObject",
            "import timber.log.Timber",
            "import java.io.Serializable",
            "import java.net.URI",
            "import java.net.URISyntaxException",
            "import java.util.*"
        ],
        "reference_api": [
            "process",
            "JsonParser",
            "finalize",
            "create"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "process",
                "code": "fun process(json: JsonElement?) {\n                when (json) {\n                    is JsonObject -> {\n                        val profile = tryParse(json)\n                        if (profile != null) add(profile) else for ((_, value) in json.entrySet()) process(value)\n                    }\n                    is JsonArray -> json.asIterable().forEach(this::process)\n                    // ignore other types\n                }\n            }"
            },
            {
                "name": "JsonParser",
                "code": "fun parseJson(json: JsonElement, feature: Profile? = null, create: (Profile) -> Profile) {\n            JsonParser(feature).run {\n                process(json)\n                for (i in indices) {\n                    val fallback = fallbackMap.remove(this[i])\n                    this[i] = create(this[i])\n                    fallback?.also { fallbackMap[this[i]] = it }\n                }\n                finalize(create)\n            }\n        }"
            },
            {
                "name": "finalize",
                "code": "fun finalize(create: (Profile) -> Profile) {\n                val profiles = ProfileManager.getAllProfiles() ?: emptyList()\n                for ((profile, fallback) in fallbackMap) {\n                    val match = profiles.firstOrNull {\n                        fallback.host == it.host && fallback.remotePort == it.remotePort &&\n                                fallback.password == it.password && fallback.method == it.method &&\n                                it.plugin.isNullOrEmpty()\n                    }\n                    profile.udpFallback = (match ?: create(fallback)).id\n                    ProfileManager.updateProfile(profile)\n                }\n            }"
            },
            {
                "name": "create",
                "code": "fun finalize(create: (Profile) -> Profile) {\n                val profiles = ProfileManager.getAllProfiles() ?: emptyList()\n                for ((profile, fallback) in fallbackMap) {\n                    val match = profiles.firstOrNull {\n                        fallback.host == it.host && fallback.remotePort == it.remotePort &&\n                                fallback.password == it.password && fallback.method == it.method &&\n                                it.plugin.isNullOrEmpty()\n                    }\n                    profile.udpFallback = (match ?: create(fallback)).id\n                    ProfileManager.updateProfile(profile)\n                }\n            }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": " fun createProfilesFromJson(jsons: Sequence<InputStream>, replace: Boolean = false)",
        "start_line": "67",
        "end_line": "86",
        "file_path": "core/src/main/java/com/github/shadowsocks/database/ProfileManager.kt",
        "docstring": "The function createProfilesFromJson(jsons: Sequence<InputStream>, replace: Boolean = false) processes a sequence of JSON input streams to create profiles. If replace is true, it fetches existing profiles and clears them before processing new profiles. It parses each JSON input stream to create a profile and, if replacing, copies stats from existing profiles with the same address before creating the new profile.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "194e5aea7771",
        "ground_truth": "fun createProfilesFromJson(jsons: Sequence<InputStream>, replace: Boolean = false) {\n    val profiles = if (replace) getAllProfiles()?.associateBy { it.formattedAddress } else null\n    val feature = if (replace) {\n        profiles?.values?.singleOrNull { it.id == DataStore.profileId }\n    } else Core.currentProfile?.main\n    val lazyClear = lazy { clear() }\n    jsons.asIterable().forEachTry { json ->\n        Profile.parseJson(JsonStreamParser(json.bufferedReader()).asSequence().single(), feature) {\n            if (replace) {\n                lazyClear.value\n                // if two profiles has the same address, treat them as the same profile and copy stats over\n                profiles?.get(it.formattedAddress)?.apply {\n                    it.tx = tx\n                    it.rx = rx\n                }\n            }\n            createProfile(it)\n        }\n    }\n}",
        "import_statements": [
            "import android.database.sqlite.SQLiteCantOpenDatabaseException",
            "import android.util.LongSparseArray",
            "import com.github.shadowsocks.Core",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.DirectBoot",
            "import com.github.shadowsocks.utils.forEachTry",
            "import com.google.gson.JsonStreamParser",
            "import org.json.JSONArray",
            "import timber.log.Timber",
            "import java.io.IOException",
            "import java.io.InputStream",
            "import java.io.Serializable",
            "import java.sql.SQLException"
        ],
        "reference_api": [
            "getAllProfiles",
            "JsonStreamParser",
            "createProfile",
            "clear",
            "lazy"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getAllProfiles",
                "code": "fun createProfilesFromJson(jsons: Sequence<InputStream>, replace: Boolean = false) {\n        val profiles = if (replace) getAllProfiles()?.associateBy { it.formattedAddress } else null\n        val feature = if (replace) {\n            profiles?.values?.singleOrNull { it.id == DataStore.profileId }\n        } else Core.currentProfile?.main\n        val lazyClear = lazy { clear() }\n        jsons.asIterable().forEachTry { json ->\n            Profile.parseJson(JsonStreamParser(json.bufferedReader()).asSequence().single(), feature) {\n                if (replace) {\n                    lazyClear.value\n                    // if two profiles has the same address, treat them as the same profile and copy stats over\n                    profiles?.get(it.formattedAddress)?.apply {\n                        it.tx = tx\n                        it.rx = rx\n                    }\n                }\n                createProfile(it)\n            }\n        }\n    }"
            },
            {
                "name": "JsonStreamParser",
                "code": "fun createProfilesFromJson(jsons: Sequence<InputStream>, replace: Boolean = false) {\n        val profiles = if (replace) getAllProfiles()?.associateBy { it.formattedAddress } else null\n        val feature = if (replace) {\n            profiles?.values?.singleOrNull { it.id == DataStore.profileId }\n        } else Core.currentProfile?.main\n        val lazyClear = lazy { clear() }\n        jsons.asIterable().forEachTry { json ->\n            Profile.parseJson(JsonStreamParser(json.bufferedReader()).asSequence().single(), feature) {\n                if (replace) {\n                    lazyClear.value\n                    // if two profiles has the same address, treat them as the same profile and copy stats over\n                    profiles?.get(it.formattedAddress)?.apply {\n                        it.tx = tx\n                        it.rx = rx\n                    }\n                }\n                createProfile(it)\n            }\n        }\n    }"
            },
            {
                "name": "createProfile",
                "code": "@Throws(SQLException::class)\n    fun createProfile(profile: Profile = Profile()): Profile {\n        profile.id = 0\n        profile.userOrder = PrivateDatabase.profileDao.nextOrder() ?: 0\n        profile.id = PrivateDatabase.profileDao.create(profile)\n        listener?.onAdd(profile)\n        return profile\n    }"
            },
            {
                "name": "clear",
                "code": "fun createProfilesFromJson(jsons: Sequence<InputStream>, replace: Boolean = false) {\n        val profiles = if (replace) getAllProfiles()?.associateBy { it.formattedAddress } else null\n        val feature = if (replace) {\n            profiles?.values?.singleOrNull { it.id == DataStore.profileId }\n        } else Core.currentProfile?.main\n        val lazyClear = lazy { clear() }\n        jsons.asIterable().forEachTry { json ->\n            Profile.parseJson(JsonStreamParser(json.bufferedReader()).asSequence().single(), feature) {\n                if (replace) {\n                    lazyClear.value\n                    // if two profiles has the same address, treat them as the same profile and copy stats over\n                    profiles?.get(it.formattedAddress)?.apply {\n                        it.tx = tx\n                        it.rx = rx\n                    }\n                }\n                createProfile(it)\n            }\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "fun ensureNotEmpty() ",
        "start_line": "128",
        "end_line": "138",
        "file_path": "core/src/main/java/com/github/shadowsocks/database/ProfileManager.kt",
        "docstring": "The function ensureNotEmpty() checks if the profile database is not empty by querying PrivateDatabase.profileDao.isNotEmpty(). If an SQLiteCantOpenDatabaseException occurs, it throws an IOException. If a SQLException occurs, it logs a warning and assumes the database is empty. If the database is empty, it creates a new profile and sets DataStore.profileId to the new profile's ID.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ce357349e4d2",
        "ground_truth": "fun ensureNotEmpty() {\n    val nonEmpty = try {\n        PrivateDatabase.profileDao.isNotEmpty()\n    } catch (ex: SQLiteCantOpenDatabaseException) {\n        throw IOException(ex)\n    } catch (ex: SQLException) {\n        Timber.w(ex)\n        false\n    }\n    if (!nonEmpty) DataStore.profileId = createProfile().id\n}",
        "import_statements": [
            "import android.database.sqlite.SQLiteCantOpenDatabaseException",
            "import android.util.LongSparseArray",
            "import com.github.shadowsocks.Core",
            "import com.github.shadowsocks.preference.DataStore",
            "import com.github.shadowsocks.utils.DirectBoot",
            "import com.github.shadowsocks.utils.forEachTry",
            "import com.google.gson.JsonStreamParser",
            "import org.json.JSONArray",
            "import timber.log.Timber",
            "import java.io.IOException",
            "import java.io.InputStream",
            "import java.io.Serializable",
            "import java.sql.SQLException"
        ],
        "reference_api": [
            "IOException",
            "createProfile"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "IOException",
                "code": "@Throws(IOException::class)\n    fun getProfile(id: Long): Profile? = try {\n        PrivateDatabase.profileDao[id]\n    } catch (ex: SQLiteCantOpenDatabaseException) {\n        throw IOException(ex)\n    } catch (ex: SQLException) {\n        Timber.w(ex)\n        null\n    }"
            },
            {
                "name": "createProfile",
                "code": "@Throws(SQLException::class)\n    fun createProfile(profile: Profile = Profile()): Profile {\n        profile.id = 0\n        profile.userOrder = PrivateDatabase.profileDao.nextOrder() ?: 0\n        profile.id = PrivateDatabase.profileDao.create(profile)\n        listener?.onAdd(profile)\n        return profile\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "shadowsocks/shadowsocks-android",
        "function_declaration": "override suspend fun resolve(network: Network, host: String): Array<InetAddress>",
        "start_line": "150",
        "end_line": "162",
        "file_path": "core/src/main/java/com/github/shadowsocks/net/DnsResolverCompat.kt",
        "docstring": "The function override suspend fun resolve(network: Network, host: String): Array<InetAddress> asynchronously resolves a host to an array of InetAddress using DnsResolver. It supports cancellation and handles DNS query results by resuming with the resolved addresses or throwing an IOException on error.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7ff51842d6c3",
        "ground_truth": "override suspend fun resolve(network: Network, host: String): Array<InetAddress> {\n    return suspendCancellableCoroutine { cont ->\n        val signal = CancellationSignal()\n        cont.invokeOnCancellation { signal.cancel() }\n        // retry should be handled by client instead\n        DnsResolver.getInstance().query(network, host, DnsResolver.FLAG_NO_RETRY, this,\n                signal, object : DnsResolver.Callback<Collection<InetAddress>> {\n            override fun onAnswer(answer: Collection<InetAddress>, rcode: Int) =\n                    cont.resume(answer.toTypedArray())\n            override fun onError(error: DnsResolver.DnsException) = cont.resumeWithException(IOException(error))\n        })\n    }\n}",
        "import_statements": [
            "import android.annotation.TargetApi",
            "import android.net.DnsResolver",
            "import android.net.Network",
            "import android.os.Build",
            "import android.os.CancellationSignal",
            "import com.github.shadowsocks.Core",
            "import kotlinx.coroutines.*",
            "import org.xbill.DNS.*",
            "import java.io.IOException",
            "import java.net.Inet4Address",
            "import java.net.Inet6Address",
            "import java.net.InetAddress",
            "import java.util.concurrent.Executor",
            "import java.util.concurrent.Executors",
            "import kotlin.coroutines.resume",
            "import kotlin.coroutines.resumeWithException"
        ],
        "reference_api": [
            "IOException"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "IOException",
                "code": "private suspend fun resolveRaw(query: ByteArray, networkSpecified: Boolean = true,\n                                       hostResolver: suspend (String) -> Array<InetAddress>): ByteArray {\n            val request = try {\n                Message(query)\n            } catch (e: IOException) {\n                throw UnsupportedOperationException(e)  // unrecognized packet\n            }\n            when (val opcode = request.header.opcode) {\n                Opcode.QUERY -> { }\n                else -> throw UnsupportedOperationException(\"Unsupported opcode $opcode\")\n            }\n            val question = request.question\n            val isIpv6 = when (val type = question?.type) {\n                Type.A -> false\n                Type.AAAA -> true\n                Type.PTR -> {\n                    /* Android does not provide a PTR lookup API for Network prior to Android 10 */\n                    if (networkSpecified) throw IOException(UnsupportedOperationException(\"Network unspecified\"))\n                    val ip = try {\n                        ReverseMap.fromName(question.name)\n                    } catch (e: IOException) {\n                        throw UnsupportedOperationException(e)  // unrecognized PTR name\n                    }\n                    val hostname = withContext(unboundedIO) { ip.hostName }.let { hostname ->\n                        if (hostname == ip.hostAddress) null else Name.fromString(\"$hostname.\")\n                    }\n                    return prepareDnsResponse(request).apply {\n                        hostname?.let { addRecord(PTRRecord(question.name, DClass.IN, TTL, it), Section.ANSWER) }\n                    }.toWire()\n                }\n                else -> throw UnsupportedOperationException(\"Unsupported query type $type\")\n            }\n            val host = question.name.canonicalize().toString(true)\n            return prepareDnsResponse(request).apply {\n                for (address in hostResolver(host).asIterable().run {\n                    if (isIpv6) filterIsInstance<Inet6Address>() else filterIsInstance<Inet4Address>()\n                }) addRecord(when (address) {\n                    is Inet4Address -> ARecord(question.name, DClass.IN, TTL, address)\n                    is Inet6Address -> AAAARecord(question.name, DClass.IN, TTL, address)\n                    else -> error(\"Unsupported address $address\")\n                }, Section.ANSWER)\n            }.toWire()\n        }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "private void blockCopyLinesDown(int srcInternal, int len) ",
        "start_line": "363",
        "end_line": "375",
        "file_path": "terminal-emulator/src/main/java/com/termux/terminal/TerminalBuffer.java",
        "docstring": "The function blockCopyLinesDown(int srcInternal, int len) shifts a block of lines down by one position within a circular buffer of terminal rows. It preserves the line to be overwritten and places it above the block after shifting. The process is done from bottom to top.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4807a008917d",
        "ground_truth": "private void blockCopyLinesDown(int srcInternal, int len) {\n    if (len == 0) return;\n    int totalRows = mTotalRows;\n    int start = len - 1;\n    // Save away line to be overwritten:\n    TerminalRow lineToBeOverWritten = mLines[(srcInternal + start + 1) % totalRows];\n    // Do the copy from bottom to top.\n    for (int i = start; i >= 0; --i)\n        mLines[(srcInternal + i + 1) % totalRows] = mLines[(srcInternal + i) % totalRows];\n    // Put back overwritten line, now above the block:\n    mLines[(srcInternal) % totalRows] = lineToBeOverWritten;\n}",
        "import_statements": [
            "import java.util.Arrays;"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public void scrollDownOneLine(int topMargin, int bottomMargin, long style) ",
        "start_line": "384",
        "end_line": "406",
        "file_path": "terminal-emulator/src/main/java/com/termux/terminal/TerminalBuffer.java",
        "docstring": "The function scrollDownOneLine(int topMargin, int bottomMargin, long style) scrolls the terminal screen content down by one line within specified margins. It ensures margins are valid, copies lines to maintain their positions, updates the screen's location in the ring buffer, adjusts the active transcript rows, and clears the newly revealed line above the bottom margin with the specified style.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0dad63a11d57",
        "ground_truth": "public void scrollDownOneLine(int topMargin, int bottomMargin, long style) {\n    if (topMargin > bottomMargin - 1 || topMargin < 0 || bottomMargin > mScreenRows)\n        throw new IllegalArgumentException(\"topMargin=\" + topMargin + \", bottomMargin=\" + bottomMargin + \", mScreenRows=\" + mScreenRows);\n    // Copy the fixed topMargin lines one line down so that they remain on screen in same position:\n    blockCopyLinesDown(mScreenFirstRow, topMargin);\n    // Copy the fixed mScreenRows-bottomMargin lines one line down so that they remain on screen in same\n    // position:\n    blockCopyLinesDown(externalToInternalRow(bottomMargin), mScreenRows - bottomMargin);\n    // Update the screen location in the ring buffer:\n    mScreenFirstRow = (mScreenFirstRow + 1) % mTotalRows;\n    // Note that the history has grown if not already full:\n    if (mActiveTranscriptRows < mTotalRows - mScreenRows) mActiveTranscriptRows++;\n    // Blank the newly revealed line above the bottom margin:\n    int blankRow = externalToInternalRow(bottomMargin - 1);\n    if (mLines[blankRow] == null) {\n        mLines[blankRow] = new TerminalRow(mColumns, style);\n    } else {\n        mLines[blankRow].clear(style);\n    }\n}",
        "import_statements": [
            "import java.util.Arrays;"
        ],
        "reference_api": [
            "externalToInternalRow",
            "clear",
            "blockCopyLinesDown"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "externalToInternalRow",
                "code": "public int externalToInternalRow(int externalRow) {\n        if (externalRow < -mActiveTranscriptRows || externalRow > mScreenRows)\n            throw new IllegalArgumentException(\"extRow=\" + externalRow + \", mScreenRows=\" + mScreenRows + \", mActiveTranscriptRows=\" + mActiveTranscriptRows);\n        final int internalRow = mScreenFirstRow + externalRow;\n        return (internalRow < 0) ? (mTotalRows + internalRow) : (internalRow % mTotalRows);\n    }"
            },
            {
                "name": "blockCopyLinesDown",
                "code": "private void blockCopyLinesDown(int srcInternal, int len) {\n        if (len == 0) return;\n        int totalRows = mTotalRows;\n\n        int start = len - 1;\n        // Save away line to be overwritten:\n        TerminalRow lineToBeOverWritten = mLines[(srcInternal + start + 1) % totalRows];\n        // Do the copy from bottom to top.\n        for (int i = start; i >= 0; --i)\n            mLines[(srcInternal + i + 1) % totalRows] = mLines[(srcInternal + i) % totalRows];\n        // Put back overwritten line, now above the block:\n        mLines[(srcInternal) % totalRows] = lineToBeOverWritten;\n    }"
            }
        ],
        "third_party": [
            "clear"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static void setWindowLayoutType(PopupWindow popupWindow, int layoutType)",
        "start_line": "34",
        "end_line": "52",
        "file_path": "terminal-view/src/main/java/com/termux/view/support/PopupWindowCompatGingerbread.java",
        "docstring": "The function setWindowLayoutType(PopupWindow popupWindow, int layoutType) uses reflection to set the window layout type of a PopupWindow. It attempts to retrieve and invoke the setWindowLayoutType method. If the method or invocation fails, it handles the exceptions silently.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e838b8bfbb8c",
        "ground_truth": "public static void setWindowLayoutType(PopupWindow popupWindow, int layoutType) {\n    if (!sSetWindowLayoutTypeMethodAttempted) {\n        try {\n            sSetWindowLayoutTypeMethod = PopupWindow.class.getDeclaredMethod(\n                \"setWindowLayoutType\", int.class);\n            sSetWindowLayoutTypeMethod.setAccessible(true);\n        } catch (Exception e) {\n            // Reflection method fetch failed. Oh well.\n        }\n        sSetWindowLayoutTypeMethodAttempted = true;\n    }\n    if (sSetWindowLayoutTypeMethod != null) {\n        try {\n            sSetWindowLayoutTypeMethod.invoke(popupWindow, layoutType);\n        } catch (Exception e) {\n            // Reflection call failed. Oh well.\n        }\n    }\n}",
        "import_statements": [
            "import android.util.Log;",
            "import android.widget.PopupWindow;",
            "import java.lang.reflect.Method;"
        ],
        "reference_api": [
            "setAccessible",
            "invoke",
            "getDeclaredMethod"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "setAccessible",
            "invoke",
            "getDeclaredMethod"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public boolean onScroll(MotionEvent e, float distanceX, float distanceY)",
        "start_line": "132",
        "end_line": "148",
        "file_path": "terminal-view/src/main/java/com/termux/view/TerminalView.java",
        "docstring": "The function onScroll(MotionEvent e, float distanceX, float distanceY) handles scroll events. If mEmulator is null, it returns true. If mouse tracking is active and the event is from a mouse source, it sends a mouse event code. Otherwise, it processes scrolling with a finger, calculates the number of rows to scroll based on distanceY and font line spacing, updates the scroll remainder, and performs the scroll action.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "0479ed80c1f7",
        "ground_truth": "public boolean onScroll(MotionEvent e, float distanceX, float distanceY) {\n    if (mEmulator == null) return true;\n    if (mEmulator.isMouseTrackingActive() && e.isFromSource(InputDevice.SOURCE_MOUSE)) {\n        // If moving with mouse pointer while pressing button, report that instead of scroll.\n        // This means that we never report moving with button press-events for touch input,\n        // since we cannot just start sending these events without a starting press event,\n        // which we do not do for touch input, only mouse in onTouchEvent().\n        sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON_MOVED, true);\n    } else {\n        scrolledWithFinger = true;\n        distanceY += mScrollRemainder;\n        int deltaRows = (int) (distanceY / mRenderer.mFontLineSpacing);\n        mScrollRemainder = distanceY - deltaRows * mRenderer.mFontLineSpacing;\n        doScroll(e, deltaRows);\n    }\n    return true;\n}",
        "import_statements": [
            "import android.annotation.SuppressLint;",
            "import android.annotation.TargetApi;",
            "import android.app.Activity;",
            "import android.content.ClipData;",
            "import android.content.ClipboardManager;",
            "import android.content.Context;",
            "import android.graphics.Canvas;",
            "import android.graphics.Typeface;",
            "import android.os.Build;",
            "import android.os.Handler;",
            "import android.os.Looper;",
            "import android.os.SystemClock;",
            "import android.text.Editable;",
            "import android.text.InputType;",
            "import android.text.TextUtils;",
            "import android.util.AttributeSet;",
            "import android.view.ActionMode;",
            "import android.view.HapticFeedbackConstants;",
            "import android.view.InputDevice;",
            "import android.view.KeyCharacterMap;",
            "import android.view.KeyEvent;",
            "import android.view.Menu;",
            "import android.view.MotionEvent;",
            "import android.view.View;",
            "import android.view.ViewConfiguration;",
            "import android.view.ViewTreeObserver;",
            "import android.view.accessibility.AccessibilityManager;",
            "import android.view.autofill.AutofillValue;",
            "import android.view.inputmethod.BaseInputConnection;",
            "import android.view.inputmethod.EditorInfo;",
            "import android.view.inputmethod.InputConnection;",
            "import android.widget.Scroller;",
            "import androidx.annotation.Nullable;",
            "import androidx.annotation.RequiresApi;",
            "import com.termux.terminal.KeyHandler;",
            "import com.termux.terminal.TerminalEmulator;",
            "import com.termux.terminal.TerminalSession;",
            "import com.termux.view.textselection.TextSelectionCursorController;"
        ],
        "reference_api": [
            "doScroll",
            "isFromSource",
            "sendMouseEventCode",
            "isMouseTrackingActive"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "doScroll",
                "code": "void doScroll(MotionEvent event, int rowsDown) {\n        boolean up = rowsDown < 0;\n        int amount = Math.abs(rowsDown);\n        for (int i = 0; i < amount; i++) {\n            if (mEmulator.isMouseTrackingActive()) {\n                sendMouseEventCode(event, up ? TerminalEmulator.MOUSE_WHEELUP_BUTTON : TerminalEmulator.MOUSE_WHEELDOWN_BUTTON, true);\n            } else if (mEmulator.isAlternateBufferActive()) {\n                // Send up and down key events for scrolling, which is what some terminals do to make scroll work in\n                // e.g. less, which shifts to the alt screen without mouse handling.\n                handleKeyCode(up ? KeyEvent.KEYCODE_DPAD_UP : KeyEvent.KEYCODE_DPAD_DOWN, 0);\n            } else {\n                mTopRow = Math.min(0, Math.max(-(mEmulator.getScreen().getActiveTranscriptRows()), mTopRow + (up ? -1 : 1)));\n                if (!awakenScrollBars()) invalidate();\n            }\n        }\n    }"
            },
            {
                "name": "sendMouseEventCode",
                "code": "void sendMouseEventCode(MotionEvent e, int button, boolean pressed) {\n        int[] columnAndRow = getColumnAndRow(e, false);\n        int x = columnAndRow[0] + 1;\n        int y = columnAndRow[1] + 1;\n        if (pressed && (button == TerminalEmulator.MOUSE_WHEELDOWN_BUTTON || button == TerminalEmulator.MOUSE_WHEELUP_BUTTON)) {\n            if (mMouseStartDownTime == e.getDownTime()) {\n                x = mMouseScrollStartX;\n                y = mMouseScrollStartY;\n            } else {\n                mMouseStartDownTime = e.getDownTime();\n                mMouseScrollStartX = x;\n                mMouseScrollStartY = y;\n            }\n        }\n        mEmulator.sendMouseEvent(button, x, y, pressed);\n    }"
            }
        ],
        "third_party": [
            "isFromSource",
            "isMouseTrackingActive"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public boolean commitText(CharSequence text, int newCursorPosition)",
        "start_line": "316",
        "end_line": "328",
        "file_path": "terminal-view/src/main/java/com/termux/view/TerminalView.java",
        "docstring": "The function commitText(CharSequence text, int newCursorPosition) logs the input text and cursor position if logging is enabled, calls the superclass method to commit the text, and if mEmulator is not null, sends the text to the terminal and clears the content. It returns true.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "296fc5fbfb62",
        "ground_truth": "public boolean commitText(CharSequence text, int newCursorPosition) {\n    if (TERMINAL_VIEW_KEY_LOGGING_ENABLED) {\n        mClient.logInfo(LOG_TAG, \"IME: commitText(\\\"\" + text + \"\\\", \" + newCursorPosition + \")\");\n    }\n    super.commitText(text, newCursorPosition);\n    if (mEmulator == null) return true;\n    Editable content = getEditable();\n    sendTextToTerminal(content);\n    content.clear();\n    return true;\n}",
        "import_statements": [
            "import android.annotation.SuppressLint;",
            "import android.annotation.TargetApi;",
            "import android.app.Activity;",
            "import android.content.ClipData;",
            "import android.content.ClipboardManager;",
            "import android.content.Context;",
            "import android.graphics.Canvas;",
            "import android.graphics.Typeface;",
            "import android.os.Build;",
            "import android.os.Handler;",
            "import android.os.Looper;",
            "import android.os.SystemClock;",
            "import android.text.Editable;",
            "import android.text.InputType;",
            "import android.text.TextUtils;",
            "import android.util.AttributeSet;",
            "import android.view.ActionMode;",
            "import android.view.HapticFeedbackConstants;",
            "import android.view.InputDevice;",
            "import android.view.KeyCharacterMap;",
            "import android.view.KeyEvent;",
            "import android.view.Menu;",
            "import android.view.MotionEvent;",
            "import android.view.View;",
            "import android.view.ViewConfiguration;",
            "import android.view.ViewTreeObserver;",
            "import android.view.accessibility.AccessibilityManager;",
            "import android.view.autofill.AutofillValue;",
            "import android.view.inputmethod.BaseInputConnection;",
            "import android.view.inputmethod.EditorInfo;",
            "import android.view.inputmethod.InputConnection;",
            "import android.widget.Scroller;",
            "import androidx.annotation.Nullable;",
            "import androidx.annotation.RequiresApi;",
            "import com.termux.terminal.KeyHandler;",
            "import com.termux.terminal.TerminalEmulator;",
            "import com.termux.terminal.TerminalSession;",
            "import com.termux.view.textselection.TextSelectionCursorController;"
        ],
        "reference_api": [
            "sendTextToTerminal",
            "logInfo",
            "getEditable",
            "clear",
            "commitText"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "sendTextToTerminal",
                "code": "void sendTextToTerminal(CharSequence text) {\n                stopTextSelectionMode();\n                final int textLengthInChars = text.length();\n                for (int i = 0; i < textLengthInChars; i++) {\n                    char firstChar = text.charAt(i);\n                    int codePoint;\n                    if (Character.isHighSurrogate(firstChar)) {\n                        if (++i < textLengthInChars) {\n                            codePoint = Character.toCodePoint(firstChar, text.charAt(i));\n                        } else {\n                            // At end of string, with no low surrogate following the high:\n                            codePoint = TerminalEmulator.UNICODE_REPLACEMENT_CHAR;\n                        }\n                    } else {\n                        codePoint = firstChar;\n                    }\n\n                    // Check onKeyDown() for details.\n                    if (mClient.readShiftKey())\n                        codePoint = Character.toUpperCase(codePoint);\n\n                    boolean ctrlHeld = false;\n                    if (codePoint <= 31 && codePoint != 27) {\n                        if (codePoint == '\\n') {\n                            // The AOSP keyboard and descendants seems to send \\n as text when the enter key is pressed,\n                            // instead of a key event like most other keyboard apps. A terminal expects \\r for the enter\n                            // key (although when icrnl is enabled this doesn't make a difference - run 'stty -icrnl' to\n                            // check the behaviour).\n                            codePoint = '\\r';\n                        }\n\n                        // E.g. penti keyboard for ctrl input.\n                        ctrlHeld = true;\n                        switch (codePoint) {\n                            case 31:\n                                codePoint = '_';\n                                break;\n                            case 30:\n                                codePoint = '^';\n                                break;\n                            case 29:\n                                codePoint = ']';\n                                break;\n                            case 28:\n                                codePoint = '\\\\';\n                                break;\n                            default:\n                                codePoint += 96;\n                                break;\n                        }\n                    }\n\n                    inputCodePoint(KEY_EVENT_SOURCE_SOFT_KEYBOARD, codePoint, ctrlHeld, false);\n                }\n            }"
            },
            {
                "name": "commitText",
                "code": "@Override\n            public boolean commitText(CharSequence text, int newCursorPosition) {\n                if (TERMINAL_VIEW_KEY_LOGGING_ENABLED) {\n                    mClient.logInfo(LOG_TAG, \"IME: commitText(\\\"\" + text + \"\\\", \" + newCursorPosition + \")\");\n                }\n                super.commitText(text, newCursorPosition);\n\n                if (mEmulator == null) return true;\n\n                Editable content = getEditable();\n                sendTextToTerminal(content);\n                content.clear();\n                return true;\n            }"
            }
        ],
        "third_party": [
            "logInfo",
            "getEditable",
            "clear"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "void doScroll(MotionEvent event, int rowsDown)",
        "start_line": "536",
        "end_line": "551",
        "file_path": "terminal-view/src/main/java/com/termux/view/TerminalView.java",
        "docstring": "The function doScroll(MotionEvent event, int rowsDown) handles scrolling in a terminal emulator. It determines the scroll direction, iterates the scroll amount, and performs different actions based on the emulator's state: sending mouse event codes if mouse tracking is active, handling key codes if the alternate buffer is active, or adjusting the top row and updating the display otherwise.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b85dcf13a35f",
        "ground_truth": "void doScroll(MotionEvent event, int rowsDown) {\n    boolean up = rowsDown < 0;\n    int amount = Math.abs(rowsDown);\n    for (int i = 0; i < amount; i++) {\n        if (mEmulator.isMouseTrackingActive()) {\n            sendMouseEventCode(event, up ? TerminalEmulator.MOUSE_WHEELUP_BUTTON : TerminalEmulator.MOUSE_WHEELDOWN_BUTTON, true);\n        } else if (mEmulator.isAlternateBufferActive()) {\n            // Send up and down key events for scrolling, which is what some terminals do to make scroll work in\n            // e.g. less, which shifts to the alt screen without mouse handling.\n            handleKeyCode(up ? KeyEvent.KEYCODE_DPAD_UP : KeyEvent.KEYCODE_DPAD_DOWN, 0);\n        } else {\n            mTopRow = Math.min(0, Math.max(-(mEmulator.getScreen().getActiveTranscriptRows()), mTopRow + (up ? -1 : 1)));\n            if (!awakenScrollBars()) invalidate();\n        }\n    }\n}",
        "import_statements": [
            "import android.annotation.SuppressLint;",
            "import android.annotation.TargetApi;",
            "import android.app.Activity;",
            "import android.content.ClipData;",
            "import android.content.ClipboardManager;",
            "import android.content.Context;",
            "import android.graphics.Canvas;",
            "import android.graphics.Typeface;",
            "import android.os.Build;",
            "import android.os.Handler;",
            "import android.os.Looper;",
            "import android.os.SystemClock;",
            "import android.text.Editable;",
            "import android.text.InputType;",
            "import android.text.TextUtils;",
            "import android.util.AttributeSet;",
            "import android.view.ActionMode;",
            "import android.view.HapticFeedbackConstants;",
            "import android.view.InputDevice;",
            "import android.view.KeyCharacterMap;",
            "import android.view.KeyEvent;",
            "import android.view.Menu;",
            "import android.view.MotionEvent;",
            "import android.view.View;",
            "import android.view.ViewConfiguration;",
            "import android.view.ViewTreeObserver;",
            "import android.view.accessibility.AccessibilityManager;",
            "import android.view.autofill.AutofillValue;",
            "import android.view.inputmethod.BaseInputConnection;",
            "import android.view.inputmethod.EditorInfo;",
            "import android.view.inputmethod.InputConnection;",
            "import android.widget.Scroller;",
            "import androidx.annotation.Nullable;",
            "import androidx.annotation.RequiresApi;",
            "import com.termux.terminal.KeyHandler;",
            "import com.termux.terminal.TerminalEmulator;",
            "import com.termux.terminal.TerminalSession;",
            "import com.termux.view.textselection.TextSelectionCursorController;"
        ],
        "reference_api": [
            "min",
            "getScreen",
            "isAlternateBufferActive",
            "invalidate",
            "isMouseTrackingActive",
            "abs",
            "awakenScrollBars",
            "sendMouseEventCode",
            "handleKeyCode",
            "max",
            "getActiveTranscriptRows"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "sendMouseEventCode",
                "code": "void sendMouseEventCode(MotionEvent e, int button, boolean pressed) {\n        int[] columnAndRow = getColumnAndRow(e, false);\n        int x = columnAndRow[0] + 1;\n        int y = columnAndRow[1] + 1;\n        if (pressed && (button == TerminalEmulator.MOUSE_WHEELDOWN_BUTTON || button == TerminalEmulator.MOUSE_WHEELUP_BUTTON)) {\n            if (mMouseStartDownTime == e.getDownTime()) {\n                x = mMouseScrollStartX;\n                y = mMouseScrollStartY;\n            } else {\n                mMouseStartDownTime = e.getDownTime();\n                mMouseScrollStartX = x;\n                mMouseScrollStartY = y;\n            }\n        }\n        mEmulator.sendMouseEvent(button, x, y, pressed);\n    }"
            },
            {
                "name": "handleKeyCode",
                "code": "public boolean handleKeyCode(int keyCode, int keyMod) {\n        // Ensure cursor is shown when a key is pressed down like long hold on (arrow) keys\n        if (mEmulator != null)\n            mEmulator.setCursorBlinkState(true);\n\n        if (handleKeyCodeAction(keyCode, keyMod))\n            return true;\n\n        TerminalEmulator term = mTermSession.getEmulator();\n        String code = KeyHandler.getCode(keyCode, keyMod, term.isCursorKeysApplicationMode(), term.isKeypadApplicationMode());\n        if (code == null) return false;\n        mTermSession.write(code);\n        return true;\n    }"
            }
        ],
        "third_party": [
            "min",
            "getScreen",
            "isAlternateBufferActive",
            "invalidate",
            "isMouseTrackingActive",
            "abs",
            "awakenScrollBars",
            "max",
            "getActiveTranscriptRows"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": " protected void onNewIntent(Intent intent)",
        "start_line": "98",
        "end_line": "109",
        "file_path": "termux-shared/src/main/java/com/termux/shared/activities/ReportActivity.java",
        "docstring": "The function onNewIntent(Intent intent) overrides the superclass method to handle new intents. It logs a message, sets the new intent, deletes a report info file, updates a bundle with intent extras, and calls updateUI() if the intent is not null.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "97e5b207533c",
        "ground_truth": "protected void onNewIntent(Intent intent) {\n    super.onNewIntent(intent);\n    Logger.logVerbose(LOG_TAG, \"onNewIntent\");\n    setIntent(intent);\n    if (intent != null) {\n        deleteReportInfoFile(this, mReportInfoFilePath);\n        mBundle = intent.getExtras();\n        updateUI();\n    }\n}",
        "import_statements": [
            "import androidx.annotation.NonNull;",
            "import androidx.appcompat.app.ActionBar;",
            "import androidx.appcompat.app.AppCompatActivity;",
            "import androidx.appcompat.widget.Toolbar;",
            "import androidx.recyclerview.widget.LinearLayoutManager;",
            "import androidx.recyclerview.widget.RecyclerView;",
            "import android.content.BroadcastReceiver;",
            "import android.content.Context;",
            "import android.content.Intent;",
            "import android.content.pm.PackageManager;",
            "import android.os.Bundle;",
            "import android.view.Menu;",
            "import android.view.MenuInflater;",
            "import android.view.MenuItem;",
            "import com.termux.shared.R;",
            "import com.termux.shared.activity.media.AppCompatActivityUtils;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.file.FileUtils;",
            "import com.termux.shared.file.filesystem.FileType;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.termux.TermuxConstants;",
            "import com.termux.shared.markdown.MarkdownUtils;",
            "import com.termux.shared.interact.ShareUtils;",
            "import com.termux.shared.models.ReportInfo;",
            "import com.termux.shared.theme.NightMode;",
            "import org.commonmark.node.FencedCodeBlock;",
            "import org.jetbrains.annotations.NotNull;",
            "import io.noties.markwon.Markwon;",
            "import io.noties.markwon.recycler.MarkwonAdapter;",
            "import io.noties.markwon.recycler.SimpleEntry;"
        ],
        "reference_api": [
            "updateUI",
            "logVerbose",
            "deleteReportInfoFile",
            "setIntent",
            "onNewIntent",
            "getExtras"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "updateUI",
                "code": "private void updateUI() {\n\n        if (mBundle == null) {\n            finish(); return;\n        }\n\n        mReportInfo = null;\n        mReportInfoFilePath = null;\n\n        if (mBundle.containsKey(EXTRA_REPORT_INFO_OBJECT_FILE_PATH)) {\n            mReportInfoFilePath = mBundle.getString(EXTRA_REPORT_INFO_OBJECT_FILE_PATH);\n            Logger.logVerbose(LOG_TAG, ReportInfo.class.getSimpleName() + \" serialized object will be read from file at path \\\"\" + mReportInfoFilePath + \"\\\"\");\n            if (mReportInfoFilePath != null) {\n                try {\n                    FileUtils.ReadSerializableObjectResult result = FileUtils.readSerializableObjectFromFile(ReportInfo.class.getSimpleName(), mReportInfoFilePath, ReportInfo.class, false);\n                    if (result.error != null) {\n                        Logger.logErrorExtended(LOG_TAG, result.error.toString());\n                        Logger.showToast(this, Error.getMinimalErrorString(result.error), true);\n                        finish(); return;\n                    } else {\n                        if (result.serializableObject != null)\n                            mReportInfo = (ReportInfo) result.serializableObject;\n                    }\n                } catch (Exception e) {\n                    Logger.logErrorAndShowToast(this, LOG_TAG, e.getMessage());\n                    Logger.logStackTraceWithMessage(LOG_TAG, \"Failure while getting \" + ReportInfo.class.getSimpleName() + \" serialized object from file at path \\\"\" + mReportInfoFilePath + \"\\\"\", e);\n                }\n            }\n        } else {\n            mReportInfo = (ReportInfo) mBundle.getSerializable(EXTRA_REPORT_INFO_OBJECT);\n        }\n\n        if (mReportInfo == null) {\n            finish(); return;\n        }\n\n\n        final ActionBar actionBar = getSupportActionBar();\n        if (actionBar != null) {\n            if (mReportInfo.reportTitle != null)\n                actionBar.setTitle(mReportInfo.reportTitle);\n            else\n                actionBar.setTitle(TermuxConstants.TERMUX_APP_NAME + \" App Report\");\n        }\n\n\n        RecyclerView recyclerView = findViewById(R.id.recycler_view);\n\n        final Markwon markwon = MarkdownUtils.getRecyclerMarkwonBuilder(this);\n\n        final MarkwonAdapter adapter = MarkwonAdapter.builderTextViewIsRoot(R.layout.markdown_adapter_node_default)\n            .include(FencedCodeBlock.class, SimpleEntry.create(R.layout.markdown_adapter_node_code_block, R.id.code_text_view))\n            .build();\n\n        recyclerView.setLayoutManager(new LinearLayoutManager(this));\n        recyclerView.setAdapter(adapter);\n\n        generateReportActivityMarkdownString();\n        adapter.setMarkdown(markwon, mReportActivityMarkdownString);\n        adapter.notifyDataSetChanged();\n    }"
            },
            {
                "name": "deleteReportInfoFile",
                "code": "private static void deleteReportInfoFile(Context context, String reportInfoFilePath) {\n        if (context == null || reportInfoFilePath == null) return;\n\n        // Extra protection for mainly if someone set `exported=\"true\"` for ReportActivityBroadcastReceiver\n        String reportInfoDirectoryPath = getReportInfoDirectoryPath(context);\n        reportInfoFilePath = FileUtils.getCanonicalPath(reportInfoFilePath, null);\n        if(!reportInfoFilePath.equals(reportInfoDirectoryPath) && reportInfoFilePath.startsWith(reportInfoDirectoryPath + \"/\")) {\n            Logger.logVerbose(LOG_TAG, \"Deleting \" + ReportInfo.class.getSimpleName() + \" serialized object file at path \\\"\" + reportInfoFilePath + \"\\\"\");\n            Error error = FileUtils.deleteRegularFile(ReportInfo.class.getSimpleName(), reportInfoFilePath, true);\n            if (error != null) {\n                Logger.logErrorExtended(LOG_TAG, error.toString());\n            }\n        } else {\n            Logger.logError(LOG_TAG, \"Not deleting \" + ReportInfo.class.getSimpleName() + \" serialized object file at path \\\"\" + reportInfoFilePath + \"\\\" since its not under \\\"\" + reportInfoDirectoryPath + \"\\\"\");\n        }\n    }"
            },
            {
                "name": "onNewIntent",
                "code": "@Override\n    protected void onNewIntent(Intent intent) {\n        super.onNewIntent(intent);\n        Logger.logVerbose(LOG_TAG, \"onNewIntent\");\n\n        setIntent(intent);\n\n        if (intent != null) {\n            deleteReportInfoFile(this, mReportInfoFilePath);\n            mBundle = intent.getExtras();\n            updateUI();\n        }\n    }"
            }
        ],
        "third_party": [
            "logVerbose",
            "setIntent",
            "getExtras"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public boolean onCreateOptionsMenu(final Menu menu) ",
        "start_line": "193",
        "end_line": "204",
        "file_path": "termux-shared/src/main/java/com/termux/shared/activities/ReportActivity.java",
        "docstring": "The function onCreateOptionsMenu(final Menu menu) inflates the menu with items from R.menu.menu_report using a MenuInflater. It then checks if mReportInfo.reportSaveFilePath is null, and if so, disables the menu item with ID R.id.menu_item_save_report_to_file. The function returns true to indicate the menu was created successfully.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e5cd4aa5b7a9",
        "ground_truth": "public boolean onCreateOptionsMenu(final Menu menu) {\n    final MenuInflater inflater = getMenuInflater();\n    inflater.inflate(R.menu.menu_report, menu);\n    if (mReportInfo.reportSaveFilePath == null) {\n        MenuItem item = menu.findItem(R.id.menu_item_save_report_to_file);\n        if (item != null)\n            item.setEnabled(false);\n    }\n    return true;\n}",
        "import_statements": [
            "import androidx.annotation.NonNull;",
            "import androidx.appcompat.app.ActionBar;",
            "import androidx.appcompat.app.AppCompatActivity;",
            "import androidx.appcompat.widget.Toolbar;",
            "import androidx.recyclerview.widget.LinearLayoutManager;",
            "import androidx.recyclerview.widget.RecyclerView;",
            "import android.content.BroadcastReceiver;",
            "import android.content.Context;",
            "import android.content.Intent;",
            "import android.content.pm.PackageManager;",
            "import android.os.Bundle;",
            "import android.view.Menu;",
            "import android.view.MenuInflater;",
            "import android.view.MenuItem;",
            "import com.termux.shared.R;",
            "import com.termux.shared.activity.media.AppCompatActivityUtils;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.file.FileUtils;",
            "import com.termux.shared.file.filesystem.FileType;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.termux.TermuxConstants;",
            "import com.termux.shared.markdown.MarkdownUtils;",
            "import com.termux.shared.interact.ShareUtils;",
            "import com.termux.shared.models.ReportInfo;",
            "import com.termux.shared.theme.NightMode;",
            "import org.commonmark.node.FencedCodeBlock;",
            "import org.jetbrains.annotations.NotNull;",
            "import io.noties.markwon.Markwon;",
            "import io.noties.markwon.recycler.MarkwonAdapter;",
            "import io.noties.markwon.recycler.SimpleEntry;"
        ],
        "reference_api": [
            "inflate",
            "getMenuInflater",
            "setEnabled",
            "findItem"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "inflate",
            "getMenuInflater",
            "setEnabled",
            "findItem"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static Error startActivity(Context context, @NonNull Intent intent,\n                                      boolean logErrorMessage, boolean showErrorMessage) ",
        "start_line": "38",
        "end_line": "60",
        "file_path": "termux-shared/src/main/java/com/termux/shared/activity/ActivityUtils.java",
        "docstring": "The function startActivity(Context context, @NonNull Intent intent, boolean logErrorMessage, boolean showErrorMessage) attempts to start an activity using the provided context and intent. If the context is null, it logs and optionally shows an error message. If an exception occurs while starting the activity, it logs and optionally shows the error message based on the given flags, and returns the error. If successful, it returns null.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "eea8a58101c1",
        "ground_truth": "public static Error startActivity(Context context, @NonNull Intent intent,\n                                  boolean logErrorMessage, boolean showErrorMessage) {\n    Error error;\n    String activityName = intent.getComponent() != null ? intent.getComponent().getClassName() : \"Unknown\";\n    if (context == null) {\n        error = ActivityErrno.ERRNO_STARTING_ACTIVITY_WITH_NULL_CONTEXT.getError(activityName);\n        if (logErrorMessage)\n            error.logErrorAndShowToast(null, LOG_TAG);\n        return error;\n    }\n    try {\n        context.startActivity(intent);\n    } catch (Exception e) {\n        error = ActivityErrno.ERRNO_START_ACTIVITY_FAILED_WITH_EXCEPTION.getError(e, activityName, e.getMessage());\n        if (logErrorMessage)\n            error.logErrorAndShowToast(showErrorMessage ? context : null, LOG_TAG);\n        return error;\n    }\n    return null;\n}",
        "import_statements": [
            "import android.app.Activity;",
            "import android.content.Context;",
            "import android.content.Intent;",
            "import androidx.activity.result.ActivityResultLauncher;",
            "import androidx.annotation.NonNull;",
            "import androidx.annotation.Nullable;",
            "import androidx.appcompat.app.AppCompatActivity;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.errors.FunctionErrno;"
        ],
        "reference_api": [
            "getComponent",
            "getError",
            "logErrorAndShowToast",
            "getMessage",
            "getClassName",
            "startActivity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "startActivity",
                "code": "public static Error startActivity(@NonNull Context context, @NonNull Intent intent) {\n        return startActivity(context, intent, true, true);\n    }"
            }
        ],
        "third_party": [
            "getComponent",
            "getError",
            "logErrorAndShowToast",
            "getMessage",
            "getClassName"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static boolean checkPermissions(@NonNull Context context, @NonNull String[] permissions)",
        "start_line": "63",
        "end_line": "82",
        "file_path": "termux-shared/src/main/java/com/termux/shared/android/PermissionUtils.java",
        "docstring": "The function checkPermissions(@NonNull Context context, @NonNull String[] permissions) verifies if all specified permissions are granted. It first checks if any permissions were not requested and logs an error if so. Then, it iterates through each permission, returning false if any permission is not granted, and true if all permissions are granted.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "3302cd0804ac",
        "ground_truth": "public static boolean checkPermissions(@NonNull Context context, @NonNull String[] permissions) {\n    // checkSelfPermission may return true for permissions not even requested\n    List<String> permissionsNotRequested = getPermissionsNotRequested(context, permissions);\n    if (permissionsNotRequested.size() > 0) {\n        Logger.logError(LOG_TAG,\n            context.getString(R.string.error_attempted_to_check_for_permissions_not_requested,\n                Joiner.on(\", \").join(permissionsNotRequested)));\n        return false;\n    }\n    int result;\n    for (String permission : permissions) {\n        result = ContextCompat.checkSelfPermission(context, permission);\n        if (result != PackageManager.PERMISSION_GRANTED) {\n            return false;\n        }\n    }\n    return true;\n}",
        "import_statements": [
            "import android.Manifest;",
            "import android.annotation.SuppressLint;",
            "import android.app.Activity;",
            "import android.app.Service;",
            "import android.content.Context;",
            "import android.content.Intent;",
            "import android.content.pm.PackageInfo;",
            "import android.content.pm.PackageManager;",
            "import android.net.Uri;",
            "import android.os.Build;",
            "import android.os.Environment;",
            "import android.os.PowerManager;",
            "import android.provider.Settings;",
            "import androidx.annotation.NonNull;",
            "import androidx.annotation.RequiresApi;",
            "import androidx.appcompat.app.AppCompatActivity;",
            "import androidx.core.content.ContextCompat;",
            "import com.google.common.base.Joiner;",
            "import com.termux.shared.R;",
            "import com.termux.shared.file.FileUtils;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.errors.FunctionErrno;",
            "import com.termux.shared.activity.ActivityUtils;",
            "import java.util.ArrayList;",
            "import java.util.Arrays;",
            "import java.util.Collections;",
            "import java.util.List;"
        ],
        "reference_api": [
            "join",
            "getString",
            "on",
            "checkSelfPermission",
            "getPermissionsNotRequested",
            "size",
            "logError"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getPermissionsNotRequested",
                "code": "@NonNull\n    public static List<String> getPermissionsNotRequested(@NonNull Context context, @NonNull String[] permissions) {\n        List<String> permissionsNotRequested = new ArrayList<>();\n        Collections.addAll(permissionsNotRequested, permissions);\n\n        PackageInfo packageInfo = PackageUtils.getPackageInfoForPackage(context, PackageManager.GET_PERMISSIONS);\n        if (packageInfo == null) {\n            return permissionsNotRequested;\n        }\n\n        // If no permissions are requested, then nothing to check\n        if (packageInfo.requestedPermissions == null || packageInfo.requestedPermissions.length == 0)\n            return permissionsNotRequested;\n\n        List<String> requestedPermissionsList = Arrays.asList(packageInfo.requestedPermissions);\n        for (String permission : permissions) {\n            if (requestedPermissionsList.contains(permission)) {\n                permissionsNotRequested.remove(permission);\n            }\n        }\n\n        return permissionsNotRequested;\n    }"
            }
        ],
        "third_party": [
            "join",
            "getString",
            "on",
            "checkSelfPermission",
            "size",
            "logError"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static List<String> getPermissionsNotRequested(@NonNull Context context, @NonNull String[] permissions) ",
        "start_line": "184",
        "end_line": "205",
        "file_path": "termux-shared/src/main/java/com/termux/shared/android/PermissionUtils.java",
        "docstring": "The function getPermissionsNotRequested(@NonNull Context context, @NonNull String[] permissions) returns a list of permissions that have not been requested by the app. It compares the provided permissions against the requested permissions in the app's package info, removing those that have been requested from the result list.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "809a0848c9fd",
        "ground_truth": "public static List<String> getPermissionsNotRequested(@NonNull Context context, @NonNull String[] permissions) {\n    List<String> permissionsNotRequested = new ArrayList<>();\n    Collections.addAll(permissionsNotRequested, permissions);\n    PackageInfo packageInfo = PackageUtils.getPackageInfoForPackage(context, PackageManager.GET_PERMISSIONS);\n    if (packageInfo == null) {\n        return permissionsNotRequested;\n    }\n    // If no permissions are requested, then nothing to check\n    if (packageInfo.requestedPermissions == null || packageInfo.requestedPermissions.length == 0)\n        return permissionsNotRequested;\n    List<String> requestedPermissionsList = Arrays.asList(packageInfo.requestedPermissions);\n    for (String permission : permissions) {\n        if (requestedPermissionsList.contains(permission)) {\n            permissionsNotRequested.remove(permission);\n        }\n    }\n    return permissionsNotRequested;\n}",
        "import_statements": [
            "import android.Manifest;",
            "import android.annotation.SuppressLint;",
            "import android.app.Activity;",
            "import android.app.Service;",
            "import android.content.Context;",
            "import android.content.Intent;",
            "import android.content.pm.PackageInfo;",
            "import android.content.pm.PackageManager;",
            "import android.net.Uri;",
            "import android.os.Build;",
            "import android.os.Environment;",
            "import android.os.PowerManager;",
            "import android.provider.Settings;",
            "import androidx.annotation.NonNull;",
            "import androidx.annotation.RequiresApi;",
            "import androidx.appcompat.app.AppCompatActivity;",
            "import androidx.core.content.ContextCompat;",
            "import com.google.common.base.Joiner;",
            "import com.termux.shared.R;",
            "import com.termux.shared.file.FileUtils;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.errors.FunctionErrno;",
            "import com.termux.shared.activity.ActivityUtils;",
            "import java.util.ArrayList;",
            "import java.util.Arrays;",
            "import java.util.Collections;",
            "import java.util.List;"
        ],
        "reference_api": [
            "asList",
            "contains",
            "addAll",
            "remove",
            "getPackageInfoForPackage"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "asList",
            "addAll",
            "remove",
            "getPackageInfoForPackage"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static String getContext()",
        "start_line": "26",
        "end_line": "42",
        "file_path": "termux-shared/src/main/java/com/termux/shared/android/SELinuxUtils.java",
        "docstring": "The function getContext() uses reflection to invoke the getContext method of the ANDROID_OS_SELINUX_CLASS class. It first bypasses hidden API reflection restrictions, then attempts to find and invoke the method. If successful, it returns the method's result as a String. If any error occurs, it logs the error and returns null.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "676f0ed05eba",
        "ground_truth": "public static String getContext() {\n    ReflectionUtils.bypassHiddenAPIReflectionRestrictions();\n    String methodName = \"getContext\";\n    try {\n        @SuppressLint(\"PrivateApi\") Class<?> clazz = Class.forName(ANDROID_OS_SELINUX_CLASS);\n        Method method = ReflectionUtils.getDeclaredMethod(clazz, methodName);\n        if (method == null) {\n            Logger.logError(LOG_TAG, \"Failed to get \" + methodName + \"() method of \" + ANDROID_OS_SELINUX_CLASS + \" class\");\n            return null;\n        }\n        return (String) ReflectionUtils.invokeMethod(method, null).value;\n    } catch (Exception e) {\n        Logger.logStackTraceWithMessage(LOG_TAG, \"Failed to call \" + methodName + \"() method of \" + ANDROID_OS_SELINUX_CLASS + \" class\", e);\n        return null;\n    }\n}",
        "import_statements": [
            "import android.annotation.SuppressLint;",
            "import androidx.annotation.NonNull;",
            "import androidx.annotation.Nullable;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.reflection.ReflectionUtils;",
            "import java.lang.reflect.Method;"
        ],
        "reference_api": [
            "getDeclaredMethod",
            "bypassHiddenAPIReflectionRestrictions",
            "forName",
            "logError",
            "logStackTraceWithMessage",
            "invokeMethod"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getDeclaredMethod",
            "bypassHiddenAPIReflectionRestrictions",
            "forName",
            "logError",
            "logStackTraceWithMessage",
            "invokeMethod"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static String convertFileTypeFlagsToNamesString(int fileTypeFlags) ",
        "start_line": "19",
        "end_line": "34",
        "file_path": "termux-shared/src/main/java/com/termux/shared/file/filesystem/FileTypes.java",
        "docstring": "The function convertFileTypeFlagsToNamesString(int fileTypeFlags) constructs a comma-separated string of file type names based on the provided fileTypeFlags. It iterates through a predefined list of FileType values, appending the name of each file type if its corresponding flag is set. It removes the trailing comma before returning the final string.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6bc930bfb395",
        "ground_truth": "public static String convertFileTypeFlagsToNamesString(int fileTypeFlags) {\n    StringBuilder fileTypeFlagsStringBuilder = new StringBuilder();\n    FileType[] fileTypes = {FileType.REGULAR, FileType.DIRECTORY, FileType.SYMLINK, FileType.CHARACTER, FileType.FIFO, FileType.BLOCK, FileType.UNKNOWN};\n    for (FileType fileType : fileTypes) {\n        if ((fileTypeFlags & fileType.getValue()) > 0)\n            fileTypeFlagsStringBuilder.append(fileType.getName()).append(\",\");\n    }\n    String fileTypeFlagsString = fileTypeFlagsStringBuilder.toString();\n    if (fileTypeFlagsString.endsWith(\",\"))\n        fileTypeFlagsString = fileTypeFlagsString.substring(0, fileTypeFlagsString.lastIndexOf(\",\"));\n    return fileTypeFlagsString;\n}",
        "import_statements": [
            "import android.system.Os;",
            "import androidx.annotation.NonNull;",
            "import com.termux.shared.logger.Logger;",
            "import java.io.File;"
        ],
        "reference_api": [
            "getName",
            "endsWith",
            "getValue",
            "toString",
            "append",
            "lastIndexOf",
            "substring"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getName",
            "endsWith",
            "getValue",
            "append"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static FileType getFileType(final String filePath, final boolean followLinks)",
        "start_line": "86",
        "end_line": "98",
        "file_path": "termux-shared/src/main/java/com/termux/shared/file/filesystem/FileTypes.java",
        "docstring": "The function getFileType(final String filePath, final boolean followLinks) determines the file type of the given filePath. It returns FileType.NO_EXIST if the filePath is null or empty. It attempts to retrieve file attributes and determine the file type, logging an error if an exception other than ENOENT occurs, and returns FileType.NO_EXIST if the file does not exist.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "13e7a0ac9cab",
        "ground_truth": "public static FileType getFileType(final String filePath, final boolean followLinks) {\n    if (filePath == null || filePath.isEmpty()) return FileType.NO_EXIST;\n    try {\n        FileAttributes fileAttributes = FileAttributes.get(filePath, followLinks);\n        return getFileType(fileAttributes);\n    } catch (Exception e) {\n        // If not a ENOENT (No such file or directory) exception\n        if (e.getMessage() != null && !e.getMessage().contains(\"ENOENT\"))\n            Logger.logError(\"Failed to get file type for file at path \\\"\" + filePath + \"\\\": \" + e.getMessage());\n        return FileType.NO_EXIST;\n    }\n}",
        "import_statements": [
            "import android.system.Os;",
            "import androidx.annotation.NonNull;",
            "import com.termux.shared.logger.Logger;",
            "import java.io.File;"
        ],
        "reference_api": [
            "getMessage",
            "logError",
            "getFileType",
            "get",
            "contains",
            "isEmpty"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getFileType",
                "code": "@NonNull\n    public static FileType getFileType(final String filePath, final boolean followLinks) {\n        if (filePath == null || filePath.isEmpty()) return FileType.NO_EXIST;\n\n        try {\n            FileAttributes fileAttributes = FileAttributes.get(filePath, followLinks);\n            return getFileType(fileAttributes);\n        } catch (Exception e) {\n            // If not a ENOENT (No such file or directory) exception\n            if (e.getMessage() != null && !e.getMessage().contains(\"ENOENT\"))\n                Logger.logError(\"Failed to get file type for file at path \\\"\" + filePath + \"\\\": \" + e.getMessage());\n            return FileType.NO_EXIST;\n        }\n    }"
            }
        ],
        "third_party": [
            "getMessage",
            "logError",
            "get",
            "isEmpty"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static String getCanonicalPath(String path, final String prefixForNonAbsolutePath)",
        "start_line": "71",
        "end_line": "92",
        "file_path": "termux-shared/src/main/java/com/termux/shared/file/FileUtils.java",
        "docstring": "The function getCanonicalPath(String path, final String prefixForNonAbsolutePath) returns the canonical path of a given path. If the path is relative, it prepends a specified prefix or a default root. It attempts to convert the path to its canonical form, returning the absolute path if an exception occurs.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "707b846a91e4",
        "ground_truth": "public static String getCanonicalPath(String path, final String prefixForNonAbsolutePath) {\n    if (path == null) path = \"\";\n    String absolutePath;\n    // If path is already an absolute path\n    if (path.startsWith(\"/\")) {\n        absolutePath = path;\n    } else {\n        if (prefixForNonAbsolutePath != null)\n            absolutePath = prefixForNonAbsolutePath + \"/\" + path;\n        else\n            absolutePath = \"/\" + path;\n    }\n    try {\n        return new File(absolutePath).getCanonicalPath();\n    } catch(Exception e) {\n    }\n    return absolutePath;\n}",
        "import_statements": [
            "import android.os.Build;",
            "import android.system.Os;",
            "import androidx.annotation.NonNull;",
            "import androidx.annotation.Nullable;",
            "import com.google.common.io.RecursiveDeleteOption;",
            "import com.termux.shared.file.filesystem.FileType;",
            "import com.termux.shared.file.filesystem.FileTypes;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.errors.Errno;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.errors.FunctionErrno;",
            "import org.apache.commons.io.filefilter.AgeFileFilter;",
            "import org.apache.commons.io.filefilter.IOFileFilter;",
            "import java.io.BufferedReader;",
            "import java.io.BufferedWriter;",
            "import java.io.Closeable;",
            "import java.io.File;",
            "import java.io.FileInputStream;",
            "import java.io.FileOutputStream;",
            "import java.io.IOException;",
            "import java.io.InputStreamReader;",
            "import java.io.ObjectInputStream;",
            "import java.io.ObjectOutputStream;",
            "import java.io.OutputStreamWriter;",
            "import java.io.Serializable;",
            "import java.nio.charset.Charset;",
            "import java.nio.file.LinkOption;",
            "import java.nio.file.StandardCopyOption;",
            "import java.util.Arrays;",
            "import java.util.Calendar;",
            "import java.util.Collections;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.regex.Pattern;"
        ],
        "reference_api": [
            "startsWith",
            "getCanonicalPath"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getCanonicalPath",
                "code": "public static String getCanonicalPath(String path, final String prefixForNonAbsolutePath) {\n        if (path == null) path = \"\";\n\n        String absolutePath;\n\n        // If path is already an absolute path\n        if (path.startsWith(\"/\")) {\n            absolutePath = path;\n        } else {\n            if (prefixForNonAbsolutePath != null)\n                absolutePath = prefixForNonAbsolutePath + \"/\" + path;\n            else\n                absolutePath = \"/\" + path;\n        }\n\n        try {\n            return new File(absolutePath).getCanonicalPath();\n        } catch(Exception e) {\n        }\n\n        return absolutePath;\n    }"
            }
        ],
        "third_party": [
            "startsWith"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static String normalizePath(String path)",
        "start_line": "103",
        "end_line": "114",
        "file_path": "termux-shared/src/main/java/com/termux/shared/file/FileUtils.java",
        "docstring": "The function normalizePath(String path) standardizes a given file path string by replacing multiple slashes with a single slash, removing occurrences of \"./\", and trimming trailing slashes. It returns the normalized path or null if the input is null.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8e2c4540f644",
        "ground_truth": "public static String normalizePath(String path) {\n    if (path == null) return null;\n    path = path.replaceAll(\"/+\", \"/\");\n    path = path.replaceAll(\"\\\\./\", \"\");\n    if (path.endsWith(\"/\")) {\n        path = path.replaceAll(\"/+$\", \"\");\n    }\n    return path;\n}",
        "import_statements": [
            "import android.os.Build;",
            "import android.system.Os;",
            "import androidx.annotation.NonNull;",
            "import androidx.annotation.Nullable;",
            "import com.google.common.io.RecursiveDeleteOption;",
            "import com.termux.shared.file.filesystem.FileType;",
            "import com.termux.shared.file.filesystem.FileTypes;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.errors.Errno;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.errors.FunctionErrno;",
            "import org.apache.commons.io.filefilter.AgeFileFilter;",
            "import org.apache.commons.io.filefilter.IOFileFilter;",
            "import java.io.BufferedReader;",
            "import java.io.BufferedWriter;",
            "import java.io.Closeable;",
            "import java.io.File;",
            "import java.io.FileInputStream;",
            "import java.io.FileOutputStream;",
            "import java.io.IOException;",
            "import java.io.InputStreamReader;",
            "import java.io.ObjectInputStream;",
            "import java.io.ObjectOutputStream;",
            "import java.io.OutputStreamWriter;",
            "import java.io.Serializable;",
            "import java.nio.charset.Charset;",
            "import java.nio.file.LinkOption;",
            "import java.nio.file.StandardCopyOption;",
            "import java.util.Arrays;",
            "import java.util.Calendar;",
            "import java.util.Collections;",
            "import java.util.Iterator;",
            "import java.util.List;",
            "import java.util.regex.Pattern;"
        ],
        "reference_api": [
            "replaceAll",
            "endsWith"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "replaceAll",
            "endsWith"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public static void copyTextToClipboard(Context context, @Nullable final String clipDataLabel,\n                                           final String text, final String toastString)",
        "start_line": "104",
        "end_line": "117",
        "file_path": "termux-shared/src/main/java/com/termux/shared/interact/ShareUtils.java",
        "docstring": "The function copyTextToClipboard(Context context, @Nullable final String clipDataLabel, final String text, final String toastString) copies the given text to the clipboard if the context and text are not null. It truncates the text if necessary and shows a toast message if provided.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ecacb8a2fc9b",
        "ground_truth": "public static void copyTextToClipboard(Context context, @Nullable final String clipDataLabel,\n                                       final String text, final String toastString) {\n    if (context == null || text == null) return;\n    ClipboardManager clipboardManager = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n    if (clipboardManager == null) return;\n    clipboardManager.setPrimaryClip(ClipData.newPlainText(clipDataLabel,\n        DataUtils.getTruncatedCommandOutput(text, DataUtils.TRANSACTION_SIZE_LIMIT_IN_BYTES,\n            true, false, false)));\n    if (toastString != null && !toastString.isEmpty())\n        Logger.showToast(context, toastString, true);\n}",
        "import_statements": [
            "import android.Manifest;",
            "import android.app.Activity;",
            "import android.content.ActivityNotFoundException;",
            "import android.content.ClipData;",
            "import android.content.ClipboardManager;",
            "import android.content.Context;",
            "import android.content.Intent;",
            "import android.net.Uri;",
            "import android.os.Build;",
            "import android.os.Environment;",
            "import androidx.appcompat.app.AppCompatActivity;",
            "import com.termux.shared.R;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.data.IntentUtils;",
            "import com.termux.shared.file.FileUtils;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.android.PermissionUtils;",
            "import java.nio.charset.Charset;",
            "import javax.annotation.Nullable;"
        ],
        "reference_api": [
            "showToast",
            "newPlainText",
            "getTruncatedCommandOutput",
            "getSystemService",
            "setPrimaryClip",
            "isEmpty"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "showToast",
            "newPlainText",
            "getTruncatedCommandOutput",
            "getSystemService",
            "setPrimaryClip",
            "isEmpty"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public synchronized Error closeClientSocket(boolean logErrorMessage)",
        "start_line": "69",
        "end_line": "80",
        "file_path": "termux-shared/src/main/java/com/termux/shared/net/socket/local/LocalClientSocket.java",
        "docstring": "The function closeClientSocket(boolean logErrorMessage) attempts to close the client socket, returning an error if an IOException occurs. If logErrorMessage is true, it logs the error. It returns null if the socket closes successfully.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "4fbe5c369960",
        "ground_truth": "public synchronized Error closeClientSocket(boolean logErrorMessage) {\n    try {\n        close();\n    } catch (IOException e) {\n        Error error = LocalSocketErrno.ERRNO_CLOSE_CLIENT_SOCKET_FAILED_WITH_EXCEPTION.getError(e, mLocalSocketRunConfig.getTitle(), e.getMessage());\n        if (logErrorMessage)\n            Logger.logErrorExtended(LOG_TAG, error.getErrorLogString());\n        return error;\n    }\n    return null;\n}",
        "import_statements": [
            "import androidx.annotation.NonNull;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.jni.models.JniResult;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.markdown.MarkdownUtils;",
            "import java.io.BufferedWriter;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.io.InputStream;",
            "import java.io.InputStreamReader;",
            "import java.io.OutputStream;",
            "import java.io.OutputStreamWriter;"
        ],
        "reference_api": [
            "logErrorExtended",
            "getErrorLogString",
            "getMessage",
            "getTitle",
            "close",
            "getError"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "close",
                "code": "@Override\n    public void close() throws IOException {\n        if (mFD >= 0) {\n            Logger.logVerbose(LOG_TAG, \"Client socket close for \\\"\" + mLocalSocketRunConfig.getTitle() + \"\\\" server: \" + getPeerCred().getMinimalString());\n            JniResult result = LocalSocketManager.closeSocket(mLocalSocketRunConfig.getLogTitle() + \" (client)\", mFD);\n            if (result == null || result.retval != 0) {\n                throw new IOException(JniResult.getErrorString(result));\n            }\n            // Update fd to signify that client socket has been closed\n            setFD(-1);\n        }\n    }"
            }
        ],
        "third_party": [
            "logErrorExtended",
            "getErrorLogString",
            "getMessage",
            "getTitle",
            "getError"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public Error send(@NonNull byte[] data)",
        "start_line": "158",
        "end_line": "173",
        "file_path": "termux-shared/src/main/java/com/termux/shared/net/socket/local/LocalClientSocket.java",
        "docstring": "The function send(@NonNull byte[] data) attempts to send data through a local socket. It first checks if the file descriptor (mFD) is valid, returning an error if not. It then calls LocalSocketManager.send() with relevant parameters. If the result is null or indicates failure, it returns an error. Otherwise, it returns null indicating success.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "f92921e26069",
        "ground_truth": "public Error send(@NonNull byte[] data) {\n    if (mFD < 0) {\n        return LocalSocketErrno.ERRNO_USING_CLIENT_SOCKET_WITH_INVALID_FD.getError(mFD,\n            mLocalSocketRunConfig.getTitle());\n    }\n    JniResult result = LocalSocketManager.send(mLocalSocketRunConfig.getLogTitle() + \" (client)\",\n        mFD, data,\n        mLocalSocketRunConfig.getDeadline() > 0 ? mCreationTime + mLocalSocketRunConfig.getDeadline() : 0);\n    if (result == null || result.retval != 0) {\n        return LocalSocketErrno.ERRNO_SEND_DATA_TO_CLIENT_SOCKET_FAILED.getError(\n            mLocalSocketRunConfig.getTitle(), JniResult.getErrorString(result));\n    }\n    return null;\n}",
        "import_statements": [
            "import androidx.annotation.NonNull;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.jni.models.JniResult;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.markdown.MarkdownUtils;",
            "import java.io.BufferedWriter;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.io.InputStream;",
            "import java.io.InputStreamReader;",
            "import java.io.OutputStream;",
            "import java.io.OutputStreamWriter;"
        ],
        "reference_api": [
            "getLogTitle",
            "getDeadline",
            "getErrorString",
            "getTitle",
            "send",
            "getError"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "send",
                "code": "public Error send(@NonNull byte[] data) {\n        if (mFD < 0) {\n            return LocalSocketErrno.ERRNO_USING_CLIENT_SOCKET_WITH_INVALID_FD.getError(mFD,\n                mLocalSocketRunConfig.getTitle());\n        }\n\n        JniResult result = LocalSocketManager.send(mLocalSocketRunConfig.getLogTitle() + \" (client)\",\n            mFD, data,\n            mLocalSocketRunConfig.getDeadline() > 0 ? mCreationTime + mLocalSocketRunConfig.getDeadline() : 0);\n        if (result == null || result.retval != 0) {\n            return LocalSocketErrno.ERRNO_SEND_DATA_TO_CLIENT_SOCKET_FAILED.getError(\n                mLocalSocketRunConfig.getTitle(), JniResult.getErrorString(result));\n        }\n\n        return null;\n    }"
            }
        ],
        "third_party": [
            "getLogTitle",
            "getDeadline",
            "getErrorString",
            "getTitle",
            "getError"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public Error readDataOnInputStream(@NonNull StringBuilder data, boolean closeStreamOnFinish)",
        "start_line": "187",
        "end_line": "213",
        "file_path": "termux-shared/src/main/java/com/termux/shared/net/socket/local/LocalClientSocket.java",
        "docstring": "The function readDataOnInputStream(@NonNull StringBuilder data, boolean closeStreamOnFinish) reads data from an InputStreamReader into a StringBuilder. It handles IOException and general exceptions by returning specific error objects. If closeStreamOnFinish is true, it attempts to close the InputStreamReader in the finally block. The function returns null if successful.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bd52ba917a30",
        "ground_truth": "public Error readDataOnInputStream(@NonNull StringBuilder data, boolean closeStreamOnFinish) {\n    int c;\n    InputStreamReader inputStreamReader = getInputStreamReader();\n    try {\n        while ((c = inputStreamReader.read()) > 0) {\n            data.append((char) c);\n        }\n    } catch (IOException e) {\n        // The SocketInputStream.read() throws the Error message in an IOException,\n        // so just read the exception message and not the stack trace, otherwise it would result\n        // in a messy nested error message.\n        return LocalSocketErrno.ERRNO_READ_DATA_FROM_INPUT_STREAM_OF_CLIENT_SOCKET_FAILED_WITH_EXCEPTION.getError(\n            mLocalSocketRunConfig.getTitle(), DataUtils.getSpaceIndentedString(e.getMessage(), 1));\n    } catch (Exception e) {\n        return LocalSocketErrno.ERRNO_READ_DATA_FROM_INPUT_STREAM_OF_CLIENT_SOCKET_FAILED_WITH_EXCEPTION.getError(\n            e, mLocalSocketRunConfig.getTitle(), e.getMessage());\n    } finally {\n        if (closeStreamOnFinish) {\n            try { inputStreamReader.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n    return null;\n}",
        "import_statements": [
            "import androidx.annotation.NonNull;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.jni.models.JniResult;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.markdown.MarkdownUtils;",
            "import java.io.BufferedWriter;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.io.InputStream;",
            "import java.io.InputStreamReader;",
            "import java.io.OutputStream;",
            "import java.io.OutputStreamWriter;"
        ],
        "reference_api": [
            "read",
            "getTitle",
            "append",
            "getInputStreamReader",
            "getSpaceIndentedString",
            "getMessage",
            "close",
            "getError"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "read",
                "code": "public Error read(@NonNull byte[] data, MutableInt bytesRead) {\n        bytesRead.value = 0;\n\n        if (mFD < 0) {\n            return LocalSocketErrno.ERRNO_USING_CLIENT_SOCKET_WITH_INVALID_FD.getError(mFD,\n                mLocalSocketRunConfig.getTitle());\n        }\n\n        JniResult result = LocalSocketManager.read(mLocalSocketRunConfig.getLogTitle() + \" (client)\",\n            mFD, data,\n            mLocalSocketRunConfig.getDeadline() > 0 ? mCreationTime + mLocalSocketRunConfig.getDeadline() : 0);\n        if (result == null || result.retval != 0) {\n            return LocalSocketErrno.ERRNO_READ_DATA_FROM_CLIENT_SOCKET_FAILED.getError(\n                mLocalSocketRunConfig.getTitle(), JniResult.getErrorString(result));\n        }\n\n        bytesRead.value = result.intData;\n        return null;\n    }"
            },
            {
                "name": "getInputStreamReader",
                "code": "@NonNull\n    public InputStreamReader getInputStreamReader() {\n        return new InputStreamReader(getInputStream());\n    }"
            },
            {
                "name": "close",
                "code": "@Override\n    public void close() throws IOException {\n        if (mFD >= 0) {\n            Logger.logVerbose(LOG_TAG, \"Client socket close for \\\"\" + mLocalSocketRunConfig.getTitle() + \"\\\" server: \" + getPeerCred().getMinimalString());\n            JniResult result = LocalSocketManager.closeSocket(mLocalSocketRunConfig.getLogTitle() + \" (client)\", mFD);\n            if (result == null || result.retval != 0) {\n                throw new IOException(JniResult.getErrorString(result));\n            }\n            // Update fd to signify that client socket has been closed\n            setFD(-1);\n        }\n    }"
            }
        ],
        "third_party": [
            "getTitle",
            "append",
            "getSpaceIndentedString",
            "getMessage",
            "getError"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public Error sendDataToOutputStream(@NonNull String data, boolean closeStreamOnFinish)",
        "start_line": "226",
        "end_line": "253",
        "file_path": "termux-shared/src/main/java/com/termux/shared/net/socket/local/LocalClientSocket.java",
        "docstring": "The function sendDataToOutputStream(@NonNull String data, boolean closeStreamOnFinish) writes data to an output stream using a BufferedWriter. It handles IOExceptions and other exceptions, returning specific error messages. If closeStreamOnFinish is true, it closes the OutputStreamWriter in the finally block. Returns null if successful.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "105be5a6c36a",
        "ground_truth": "public Error sendDataToOutputStream(@NonNull String data, boolean closeStreamOnFinish) {\n    OutputStreamWriter outputStreamWriter = getOutputStreamWriter();\n    try (BufferedWriter byteStreamWriter = new BufferedWriter(outputStreamWriter)) {\n        byteStreamWriter.write(data);\n        byteStreamWriter.flush();\n    } catch (IOException e) {\n        // The SocketOutputStream.write() throws the Error message in an IOException,\n        // so just read the exception message and not the stack trace, otherwise it would result\n        // in a messy nested error message.\n        return LocalSocketErrno.ERRNO_SEND_DATA_TO_OUTPUT_STREAM_OF_CLIENT_SOCKET_FAILED_WITH_EXCEPTION.getError(\n            mLocalSocketRunConfig.getTitle(), DataUtils.getSpaceIndentedString(e.getMessage(), 1));\n    } catch (Exception e) {\n        return LocalSocketErrno.ERRNO_SEND_DATA_TO_OUTPUT_STREAM_OF_CLIENT_SOCKET_FAILED_WITH_EXCEPTION.getError(\n            e, mLocalSocketRunConfig.getTitle(), e.getMessage());\n    } finally {\n        if (closeStreamOnFinish) {\n            try {\n                outputStreamWriter.close();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n    return null;\n}",
        "import_statements": [
            "import androidx.annotation.NonNull;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.jni.models.JniResult;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.markdown.MarkdownUtils;",
            "import java.io.BufferedWriter;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.io.InputStream;",
            "import java.io.InputStreamReader;",
            "import java.io.OutputStream;",
            "import java.io.OutputStreamWriter;"
        ],
        "reference_api": [
            "getOutputStreamWriter",
            "write",
            "getTitle",
            "getSpaceIndentedString",
            "getMessage",
            "flush",
            "close",
            "getError"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getOutputStreamWriter",
                "code": "@NonNull\n    public OutputStreamWriter getOutputStreamWriter() {\n        return new OutputStreamWriter(getOutputStream());\n    }"
            },
            {
                "name": "write",
                "code": "@Override\n        public void write(int b) throws IOException {\n            mBytes[0] = (byte) b;\n\n            Error error = LocalClientSocket.this.send(mBytes);\n            if (error != null) {\n                throw new IOException(error.getErrorMarkdownString());\n            }\n        }"
            },
            {
                "name": "close",
                "code": "@Override\n    public void close() throws IOException {\n        if (mFD >= 0) {\n            Logger.logVerbose(LOG_TAG, \"Client socket close for \\\"\" + mLocalSocketRunConfig.getTitle() + \"\\\" server: \" + getPeerCred().getMinimalString());\n            JniResult result = LocalSocketManager.closeSocket(mLocalSocketRunConfig.getLogTitle() + \" (client)\", mFD);\n            if (result == null || result.retval != 0) {\n                throw new IOException(JniResult.getErrorString(result));\n            }\n            // Update fd to signify that client socket has been closed\n            setFD(-1);\n        }\n    }"
            }
        ],
        "third_party": [
            "getTitle",
            "getSpaceIndentedString",
            "getMessage",
            "flush",
            "getError"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public Error available(MutableInt available, boolean checkDeadline)",
        "start_line": "265",
        "end_line": "285",
        "file_path": "termux-shared/src/main/java/com/termux/shared/net/socket/local/LocalClientSocket.java",
        "docstring": "The function available(MutableInt available, boolean checkDeadline) sets the available value to 0 and checks if the file descriptor mFD is valid. If not, it returns an error. If checkDeadline is true and the deadline has passed, it returns null. It then checks the availability of data on the client socket using LocalSocketManager, updates the available value, and returns null if successful, or an error if the check fails.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "49e1c92eda70",
        "ground_truth": "public Error available(MutableInt available, boolean checkDeadline) {\n    available.value = 0;\n    if (mFD < 0) {\n        return LocalSocketErrno.ERRNO_USING_CLIENT_SOCKET_WITH_INVALID_FD.getError(mFD,\n            mLocalSocketRunConfig.getTitle());\n    }\n    if (checkDeadline && mLocalSocketRunConfig.getDeadline() > 0 && System.currentTimeMillis() > (mCreationTime + mLocalSocketRunConfig.getDeadline())) {\n        return null;\n    }\n    JniResult result = LocalSocketManager.available(mLocalSocketRunConfig.getLogTitle() + \" (client)\", mLocalSocketRunConfig.getFD());\n    if (result == null || result.retval != 0) {\n        return LocalSocketErrno.ERRNO_CHECK_AVAILABLE_DATA_ON_CLIENT_SOCKET_FAILED.getError(\n            mLocalSocketRunConfig.getTitle(), JniResult.getErrorString(result));\n    }\n    available.value = result.intData;\n    return null;\n}",
        "import_statements": [
            "import androidx.annotation.NonNull;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.jni.models.JniResult;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.markdown.MarkdownUtils;",
            "import java.io.BufferedWriter;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.io.InputStream;",
            "import java.io.InputStreamReader;",
            "import java.io.OutputStream;",
            "import java.io.OutputStreamWriter;"
        ],
        "reference_api": [
            "getFD",
            "available",
            "getLogTitle",
            "getDeadline",
            "getErrorString",
            "getTitle",
            "currentTimeMillis",
            "getError"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getFD",
                "code": "public int getFD() {\n        return mFD;\n    }"
            },
            {
                "name": "available",
                "code": "public Error available(MutableInt available) {\n        return available(available, true);\n    }"
            }
        ],
        "third_party": [
            "getLogTitle",
            "getDeadline",
            "getErrorString",
            "getTitle",
            "currentTimeMillis",
            "getError"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "termux/termux-app",
        "function_declaration": "public Error setReadTimeout()",
        "start_line": "290",
        "end_line": "300",
        "file_path": "termux-shared/src/main/java/com/termux/shared/net/socket/local/LocalClientSocket.java",
        "docstring": "The function setReadTimeout() sets the read timeout for a local socket if the file descriptor (mFD) is valid. It uses LocalSocketManager.setSocketReadTimeout() with parameters from mLocalSocketRunConfig. If the operation fails, it returns an appropriate error from LocalSocketErrno. Otherwise, it returns null.\\n",
        "language": "Java",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "a3def2e5ef9b",
        "ground_truth": "public Error setReadTimeout() {\n    if (mFD >= 0) {\n        JniResult result = LocalSocketManager.setSocketReadTimeout(mLocalSocketRunConfig.getLogTitle() + \" (client)\",\n            mFD, mLocalSocketRunConfig.getReceiveTimeout());\n        if (result == null || result.retval != 0) {\n            return LocalSocketErrno.ERRNO_SET_CLIENT_SOCKET_READ_TIMEOUT_FAILED.getError(\n                mLocalSocketRunConfig.getTitle(), mLocalSocketRunConfig.getReceiveTimeout(), JniResult.getErrorString(result));\n        }\n    }\n    return null;\n}",
        "import_statements": [
            "import androidx.annotation.NonNull;",
            "import com.termux.shared.data.DataUtils;",
            "import com.termux.shared.errors.Error;",
            "import com.termux.shared.jni.models.JniResult;",
            "import com.termux.shared.logger.Logger;",
            "import com.termux.shared.markdown.MarkdownUtils;",
            "import java.io.BufferedWriter;",
            "import java.io.Closeable;",
            "import java.io.IOException;",
            "import java.io.InputStream;",
            "import java.io.InputStreamReader;",
            "import java.io.OutputStream;",
            "import java.io.OutputStreamWriter;"
        ],
        "reference_api": [
            "getLogTitle",
            "getErrorString",
            "getTitle",
            "setSocketReadTimeout",
            "getReceiveTimeout",
            "getError"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getLogTitle",
            "getErrorString",
            "getTitle",
            "setSocketReadTimeout",
            "getReceiveTimeout",
            "getError"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "fun getV2rayPointDomainAndPort(): String",
        "start_line": "69",
        "end_line": "73",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/dto/ServerConfig.kt",
        "docstring": "The function getV2rayPointDomainAndPort(): String retrieves the server address and port from a proxy outbound configuration, formats them as an IPv6 address with the port appended, and returns the resulting string.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "7276c4d20dd1",
        "ground_truth": "fun getV2rayPointDomainAndPort(): String {\n    val address = getProxyOutbound()?.getServerAddress().orEmpty()\n    val port = getProxyOutbound()?.getServerPort()\n    return Utils.getIpv6Address(address) + \":\" + port\n}",
        "import_statements": [
            "import com.v2ray.ang.AppConfig.TAG_PROXY",
            "import com.v2ray.ang.AppConfig.TAG_BLOCKED",
            "import com.v2ray.ang.AppConfig.TAG_DIRECT",
            "import com.v2ray.ang.util.Utils"
        ],
        "reference_api": [
            "getProxyOutbound"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getProxyOutbound",
                "code": "fun getProxyOutbound(): V2rayConfig.OutboundBean? {\n        if (configType != EConfigType.CUSTOM) {\n            return outboundBean\n        }\n        return fullConfig?.getProxyOutbound()\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "fun populateTlsSettings(streamSecurity: String, allowInsecure: Boolean, sni: String, fingerprint: String?, alpns: String?,\n                                    publicKey: String?, shortId: String?, spiderX: String?) ",
        "start_line": "323",
        "end_line": "343",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/dto/V2rayConfig.kt",
        "docstring": "The function populateTlsSettings(streamSecurity: String, allowInsecure: Boolean, sni: String, fingerprint: String?, alpns: String?, publicKey: String?, shortId: String?, spiderX: String?) configures TLS settings based on the provided parameters. It creates a TlsSettingsBean with the given values, processes the ALPNs, and assigns the settings to either tlsSettings or realitySettings based on the streamSecurity value.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "022518d25c6b",
        "ground_truth": "fun populateTlsSettings(streamSecurity: String, allowInsecure: Boolean, sni: String, fingerprint: String?, alpns: String?,\n                        publicKey: String?, shortId: String?, spiderX: String?) {\n    security = streamSecurity\n    val tlsSetting = TlsSettingsBean(\n            allowInsecure = allowInsecure,\n            serverName = sni,\n            fingerprint = fingerprint,\n            alpn = if (alpns.isNullOrEmpty()) null else alpns.split(\",\").map { it.trim() }.filter { it.isNotEmpty() },\n            publicKey = publicKey,\n            shortId = shortId,\n            spiderX = spiderX\n    )\n    if (security == TLS) {\n        tlsSettings = tlsSetting\n        realitySettings = null\n    } else if (security == REALITY) {\n        tlsSettings = null\n        realitySettings = tlsSetting\n    }\n}\n}",
        "import_statements": [
            "import android.text.TextUtils",
            "import com.google.gson.GsonBuilder",
            "import com.google.gson.JsonPrimitive",
            "import com.google.gson.JsonSerializationContext",
            "import com.google.gson.JsonSerializer",
            "import com.google.gson.annotations.SerializedName",
            "import com.google.gson.reflect.TypeToken",
            "import java.lang.reflect.Type"
        ],
        "reference_api": [
            "TlsSettingsBean"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "TlsSettingsBean",
                "code": "fun populateTlsSettings(streamSecurity: String, allowInsecure: Boolean, sni: String, fingerprint: String?, alpns: String?,\n                                    publicKey: String?, shortId: String?, spiderX: String?) {\n                security = streamSecurity\n                val tlsSetting = TlsSettingsBean(\n                        allowInsecure = allowInsecure,\n                        serverName = sni,\n                        fingerprint = fingerprint,\n                        alpn = if (alpns.isNullOrEmpty()) null else alpns.split(\",\").map { it.trim() }.filter { it.isNotEmpty() },\n                        publicKey = publicKey,\n                        shortId = shortId,\n                        spiderX = spiderX\n                )\n                if (security == TLS) {\n                    tlsSettings = tlsSetting\n                    realitySettings = null\n                } else if (security == REALITY) {\n                    tlsSettings = null\n                    realitySettings = tlsSetting\n                }\n            }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "fun toPrettyPrinting(): String",
        "start_line": "526",
        "end_line": "536",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/dto/V2rayConfig.kt",
        "docstring": "The function toPrettyPrinting(): String converts an object to a pretty-printed JSON string using GsonBuilder. It disables HTML escaping and registers a custom serializer to handle Double values by converting them to integers. The function returns the resulting JSON string.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ff2b71268720",
        "ground_truth": "fun toPrettyPrinting(): String {\n    return GsonBuilder()\n            .setPrettyPrinting()\n            .disableHtmlEscaping()\n            .registerTypeAdapter( // custom serialiser is needed here since JSON by default parse number as Double, core will fail to start\n                    object : TypeToken<Double>() {}.type,\n                    JsonSerializer { src: Double?, _: Type?, _: JsonSerializationContext? -> JsonPrimitive(src?.toInt()) }\n            )\n            .create()\n            .toJson(this)\n}",
        "import_statements": [
            "import android.text.TextUtils",
            "import com.google.gson.GsonBuilder",
            "import com.google.gson.JsonPrimitive",
            "import com.google.gson.JsonSerializationContext",
            "import com.google.gson.JsonSerializer",
            "import com.google.gson.annotations.SerializedName",
            "import com.google.gson.reflect.TypeToken",
            "import java.lang.reflect.Type"
        ],
        "reference_api": [
            "JsonSerializer",
            "GsonBuilder",
            "JsonPrimitive"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "JsonSerializer",
                "code": "fun toPrettyPrinting(): String {\n        return GsonBuilder()\n                .setPrettyPrinting()\n                .disableHtmlEscaping()\n                .registerTypeAdapter( // custom serialiser is needed here since JSON by default parse number as Double, core will fail to start\n                        object : TypeToken<Double>() {}.type,\n                        JsonSerializer { src: Double?, _: Type?, _: JsonSerializationContext? -> JsonPrimitive(src?.toInt()) }\n                )\n                .create()\n                .toJson(this)\n    }"
            },
            {
                "name": "GsonBuilder",
                "code": "fun toPrettyPrinting(): String {\n        return GsonBuilder()\n                .setPrettyPrinting()\n                .disableHtmlEscaping()\n                .registerTypeAdapter( // custom serialiser is needed here since JSON by default parse number as Double, core will fail to start\n                        object : TypeToken<Double>() {}.type,\n                        JsonSerializer { src: Double?, _: Type?, _: JsonSerializationContext? -> JsonPrimitive(src?.toInt()) }\n                )\n                .create()\n                .toJson(this)\n    }"
            },
            {
                "name": "JsonPrimitive",
                "code": "fun toPrettyPrinting(): String {\n        return GsonBuilder()\n                .setPrettyPrinting()\n                .disableHtmlEscaping()\n                .registerTypeAdapter( // custom serialiser is needed here since JSON by default parse number as Double, core will fail to start\n                        object : TypeToken<Double>() {}.type,\n                        JsonSerializer { src: Double?, _: Type?, _: JsonSerializationContext? -> JsonPrimitive(src?.toInt()) }\n                )\n                .create()\n                .toJson(this)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": " override fun onReceive(context: Context, intent: Intent)",
        "start_line": "56",
        "end_line": "78",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/receiver/WidgetProvider.kt",
        "docstring": "The function onReceive(context: Context, intent: Intent) handles broadcast actions for widget clicks and activity state changes. If the widget is clicked, it toggles the V2Ray service. For activity state changes, it updates the widget background based on the service's running state by checking specific action types and message states.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bffb5badb2ae",
        "ground_truth": "override fun onReceive(context: Context, intent: Intent) {\n    super.onReceive(context, intent)\n    if (AppConfig.BROADCAST_ACTION_WIDGET_CLICK == intent.action) {\n        if (V2RayServiceManager.v2rayPoint.isRunning) {\n            Utils.stopVService(context)\n        } else {\n            Utils.startVServiceFromToggle(context)\n        }\n    } else if (AppConfig.BROADCAST_ACTION_ACTIVITY == intent.action) {\n        AppWidgetManager.getInstance(context)?.let { manager ->\n            when (intent.getIntExtra(\"key\", 0)) {\n                AppConfig.MSG_STATE_RUNNING, AppConfig.MSG_STATE_START_SUCCESS -> {\n                    updateWidgetBackground(context, manager, manager.getAppWidgetIds(ComponentName(context, WidgetProvider::class.java)),\n                            true)\n                }\n                AppConfig.MSG_STATE_NOT_RUNNING, AppConfig.MSG_STATE_START_FAILURE, AppConfig.MSG_STATE_STOP_SUCCESS -> {\n                    updateWidgetBackground(context, manager, manager.getAppWidgetIds(ComponentName(context, WidgetProvider::class.java)),\n                            false)\n                }\n            }\n        }\n    }\n}",
        "import_statements": [
            "import android.app.PendingIntent",
            "import android.appwidget.AppWidgetManager",
            "import android.appwidget.AppWidgetProvider",
            "import android.content.ComponentName",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.os.Build",
            "import android.widget.RemoteViews",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.Utils"
        ],
        "reference_api": [
            "updateWidgetBackground",
            "ComponentName"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "updateWidgetBackground",
            "ComponentName"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "override fun onStartListening()",
        "start_line": "35",
        "end_line": "46",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/QSTileService.kt",
        "docstring": "The function onStartListening() overrides a method to perform setup tasks when listening starts. It sets the Tile state to inactive, initializes a message receiver, and registers it with an intent filter based on the Android version. It also sends a registration message to a service.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2f0caed18ff4",
        "ground_truth": "override fun onStartListening() {\n    super.onStartListening()\n    setState(Tile.STATE_INACTIVE)\n    mMsgReceive = ReceiveMessageHandler(this)\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n        registerReceiver(mMsgReceive, IntentFilter(AppConfig.BROADCAST_ACTION_ACTIVITY), Context.RECEIVER_EXPORTED)\n    } else {\n        registerReceiver(mMsgReceive, IntentFilter(AppConfig.BROADCAST_ACTION_ACTIVITY))\n    }\n    MessageUtil.sendMsg2Service(this, AppConfig.MSG_REGISTER_CLIENT, \"\")\n}",
        "import_statements": [
            "import android.annotation.TargetApi",
            "import android.content.BroadcastReceiver",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.IntentFilter",
            "import android.graphics.drawable.Icon",
            "import android.os.Build",
            "import android.service.quicksettings.Tile",
            "import android.service.quicksettings.TileService",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.util.MessageUtil",
            "import com.v2ray.ang.util.Utils",
            "import java.lang.ref.SoftReference"
        ],
        "reference_api": [
            "registerReceiver",
            "ReceiveMessageHandler",
            "IntentFilter",
            "setState"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "registerReceiver",
                "code": "override fun onStartListening() {\n        super.onStartListening()\n        setState(Tile.STATE_INACTIVE)\n        mMsgReceive = ReceiveMessageHandler(this)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            registerReceiver(mMsgReceive, IntentFilter(AppConfig.BROADCAST_ACTION_ACTIVITY), Context.RECEIVER_EXPORTED)\n        } else {\n            registerReceiver(mMsgReceive, IntentFilter(AppConfig.BROADCAST_ACTION_ACTIVITY))\n        }\n\n        MessageUtil.sendMsg2Service(this, AppConfig.MSG_REGISTER_CLIENT, \"\")\n    }"
            },
            {
                "name": "ReceiveMessageHandler",
                "code": "override fun onStartListening() {\n        super.onStartListening()\n        setState(Tile.STATE_INACTIVE)\n        mMsgReceive = ReceiveMessageHandler(this)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            registerReceiver(mMsgReceive, IntentFilter(AppConfig.BROADCAST_ACTION_ACTIVITY), Context.RECEIVER_EXPORTED)\n        } else {\n            registerReceiver(mMsgReceive, IntentFilter(AppConfig.BROADCAST_ACTION_ACTIVITY))\n        }\n\n        MessageUtil.sendMsg2Service(this, AppConfig.MSG_REGISTER_CLIENT, \"\")\n    }"
            },
            {
                "name": "IntentFilter",
                "code": "override fun onStartListening() {\n        super.onStartListening()\n        setState(Tile.STATE_INACTIVE)\n        mMsgReceive = ReceiveMessageHandler(this)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            registerReceiver(mMsgReceive, IntentFilter(AppConfig.BROADCAST_ACTION_ACTIVITY), Context.RECEIVER_EXPORTED)\n        } else {\n            registerReceiver(mMsgReceive, IntentFilter(AppConfig.BROADCAST_ACTION_ACTIVITY))\n        }\n\n        MessageUtil.sendMsg2Service(this, AppConfig.MSG_REGISTER_CLIENT, \"\")\n    }"
            },
            {
                "name": "setState",
                "code": "fun setState(state: Int) {\n        if (state == Tile.STATE_INACTIVE) {\n            qsTile?.state = Tile.STATE_INACTIVE\n            qsTile?.label = getString(R.string.app_name)\n            qsTile?.icon = Icon.createWithResource(applicationContext, R.drawable.ic_stat_name)\n        } else if (state == Tile.STATE_ACTIVE) {\n            qsTile?.state = Tile.STATE_ACTIVE\n            qsTile?.label = V2RayServiceManager.currentConfig?.remarks\n            qsTile?.icon = Icon.createWithResource(applicationContext, R.drawable.ic_stat_name)\n        }\n\n        qsTile?.updateTile()\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "fun startV2Ray(context: Context)",
        "start_line": "65",
        "end_line": "86",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayServiceManager.kt",
        "docstring": "The function startV2Ray(context: Context) starts the V2Ray service if it is not already running. It retrieves the selected server's configuration and checks its status. Depending on the proxy sharing setting, it displays a toast message. Then, it determines the service mode (VPN or Proxy Only) and starts the appropriate service, using startForegroundService for newer Android versions.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "bad59f95bf6a",
        "ground_truth": "fun startV2Ray(context: Context) {\n    if (v2rayPoint.isRunning) return\n    val guid = mainStorage?.decodeString(MmkvManager.KEY_SELECTED_SERVER) ?: return\n    val result = V2rayConfigUtil.getV2rayConfig(context, guid)\n    if (!result.status) return\n    if (settingsStorage?.decodeBool(AppConfig.PREF_PROXY_SHARING) == true) {\n        context.toast(R.string.toast_warning_pref_proxysharing_short)\n    } else {\n        context.toast(R.string.toast_services_start)\n    }\n    val intent = if (settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\" == \"VPN\") {\n        Intent(context.applicationContext, V2RayVpnService::class.java)\n    } else {\n        Intent(context.applicationContext, V2RayProxyOnlyService::class.java)\n    }\n    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.N_MR1) {\n        context.startForegroundService(intent)\n    } else {\n        context.startService(intent)\n    }\n}",
        "import_statements": [
            "import android.app.Notification",
            "import android.app.NotificationChannel",
            "import android.app.NotificationManager",
            "import android.app.PendingIntent",
            "import android.content.BroadcastReceiver",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.IntentFilter",
            "import android.graphics.Color",
            "import android.os.Build",
            "import android.util.Log",
            "import androidx.annotation.RequiresApi",
            "import androidx.core.app.NotificationCompat",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.AppConfig.ANG_PACKAGE",
            "import com.v2ray.ang.AppConfig.TAG_DIRECT",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.dto.ServerConfig",
            "import com.v2ray.ang.extension.toSpeedString",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.ui.MainActivity",
            "import com.v2ray.ang.util.MessageUtil",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.util.V2rayConfigUtil",
            "import go.Seq",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.GlobalScope",
            "import kotlinx.coroutines.launch",
            "import libv2ray.Libv2ray",
            "import libv2ray.V2RayPoint",
            "import libv2ray.V2RayVPNServiceSupportsSet",
            "import rx.Observable",
            "import rx.Subscription",
            "import java.lang.ref.SoftReference",
            "import kotlin.math.min"
        ],
        "reference_api": [
            "Intent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "Intent",
                "code": "fun startV2Ray(context: Context) {\n        if (v2rayPoint.isRunning) return\n        val guid = mainStorage?.decodeString(MmkvManager.KEY_SELECTED_SERVER) ?: return\n        val result = V2rayConfigUtil.getV2rayConfig(context, guid)\n        if (!result.status) return\n\n        if (settingsStorage?.decodeBool(AppConfig.PREF_PROXY_SHARING) == true) {\n            context.toast(R.string.toast_warning_pref_proxysharing_short)\n        } else {\n            context.toast(R.string.toast_services_start)\n        }\n        val intent = if (settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\" == \"VPN\") {\n            Intent(context.applicationContext, V2RayVpnService::class.java)\n        } else {\n            Intent(context.applicationContext, V2RayProxyOnlyService::class.java)\n        }\n        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.N_MR1) {\n            context.startForegroundService(intent)\n        } else {\n            context.startService(intent)\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "fun stopV2rayPoint()",
        "start_line": "174",
        "end_line": "195",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayServiceManager.kt",
        "docstring": "The function stopV2rayPoint() stops the V2Ray service if it is running by calling stopLoop() within a coroutine. It sends a stop success message to the UI, cancels notifications, and attempts to unregister a broadcast receiver, logging any exceptions that occur during these operations.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c35288f32ac7",
        "ground_truth": "fun stopV2rayPoint() {\n    val service = serviceControl?.get()?.getService() ?: return\n    if (v2rayPoint.isRunning) {\n        GlobalScope.launch(Dispatchers.Default) {\n            try {\n                v2rayPoint.stopLoop()\n            } catch (e: Exception) {\n                Log.d(ANG_PACKAGE, e.toString())\n            }\n        }\n    }\n    MessageUtil.sendMsg2UI(service, AppConfig.MSG_STATE_STOP_SUCCESS, \"\")\n    cancelNotification()\n    try {\n        service.unregisterReceiver(mMsgReceive)\n    } catch (e: Exception) {\n        Log.d(ANG_PACKAGE, e.toString())\n    }\n}",
        "import_statements": [
            "import android.app.Notification",
            "import android.app.NotificationChannel",
            "import android.app.NotificationManager",
            "import android.app.PendingIntent",
            "import android.content.BroadcastReceiver",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.IntentFilter",
            "import android.graphics.Color",
            "import android.os.Build",
            "import android.util.Log",
            "import androidx.annotation.RequiresApi",
            "import androidx.core.app.NotificationCompat",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.AppConfig.ANG_PACKAGE",
            "import com.v2ray.ang.AppConfig.TAG_DIRECT",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.dto.ServerConfig",
            "import com.v2ray.ang.extension.toSpeedString",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.ui.MainActivity",
            "import com.v2ray.ang.util.MessageUtil",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.util.V2rayConfigUtil",
            "import go.Seq",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.GlobalScope",
            "import kotlinx.coroutines.launch",
            "import libv2ray.Libv2ray",
            "import libv2ray.V2RayPoint",
            "import libv2ray.V2RayVPNServiceSupportsSet",
            "import rx.Observable",
            "import rx.Subscription",
            "import java.lang.ref.SoftReference",
            "import kotlin.math.min"
        ],
        "reference_api": [
            "cancelNotification"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "cancelNotification",
                "code": "fun startV2rayPoint() {\n        val service = serviceControl?.get()?.getService() ?: return\n        val guid = mainStorage?.decodeString(MmkvManager.KEY_SELECTED_SERVER) ?: return\n        val config = MmkvManager.decodeServerConfig(guid) ?: return\n        if (v2rayPoint.isRunning) {\n            return\n        }\n        val result = V2rayConfigUtil.getV2rayConfig(service, guid)\n        if (!result.status)\n            return\n\n        try {\n            val mFilter = IntentFilter(AppConfig.BROADCAST_ACTION_SERVICE)\n            mFilter.addAction(Intent.ACTION_SCREEN_ON)\n            mFilter.addAction(Intent.ACTION_SCREEN_OFF)\n            mFilter.addAction(Intent.ACTION_USER_PRESENT)\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n                service.registerReceiver(mMsgReceive, mFilter, Context.RECEIVER_EXPORTED)\n            } else {\n                service.registerReceiver(mMsgReceive, mFilter)\n            }\n        } catch (e: Exception) {\n            Log.d(ANG_PACKAGE, e.toString())\n        }\n\n        v2rayPoint.configureFileContent = result.content\n        v2rayPoint.domainName = config.getV2rayPointDomainAndPort()\n        currentConfig = config\n\n        try {\n            v2rayPoint.runLoop(settingsStorage?.decodeBool(AppConfig.PREF_PREFER_IPV6) ?: false)\n        } catch (e: Exception) {\n            Log.d(ANG_PACKAGE, e.toString())\n        }\n\n        if (v2rayPoint.isRunning) {\n            MessageUtil.sendMsg2UI(service, AppConfig.MSG_STATE_START_SUCCESS, \"\")\n            showNotification()\n        } else {\n            MessageUtil.sendMsg2UI(service, AppConfig.MSG_STATE_START_FAILURE, \"\")\n            cancelNotification()\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun updateNotification(contentText: String?, proxyTraffic: Long, directTraffic: Long)",
        "start_line": "341",
        "end_line": "354",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/service/V2RayServiceManager.kt",
        "docstring": "The function updateNotification(contentText: String?, proxyTraffic: Long, directTraffic: Long) updates a notification's small icon and content based on traffic thresholds. It sets the icon based on the comparison of proxyTraffic and directTraffic against NOTIFICATION_ICON_THRESHOLD, then updates the notification's text and style, and notifies the NotificationManager.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "882b9e9ec134",
        "ground_truth": "private fun updateNotification(contentText: String?, proxyTraffic: Long, directTraffic: Long) {\n    if (mBuilder != null) {\n        if (proxyTraffic < NOTIFICATION_ICON_THRESHOLD && directTraffic < NOTIFICATION_ICON_THRESHOLD) {\n            mBuilder?.setSmallIcon(R.drawable.ic_stat_name)\n        } else if (proxyTraffic > directTraffic) {\n            mBuilder?.setSmallIcon(R.drawable.ic_stat_proxy)\n        } else {\n            mBuilder?.setSmallIcon(R.drawable.ic_stat_direct)\n        }\n        mBuilder?.setStyle(NotificationCompat.BigTextStyle().bigText(contentText))\n        mBuilder?.setContentText(contentText) // Emui4.1 need content text even if style is set as BigTextStyle\n        getNotificationManager()?.notify(NOTIFICATION_ID, mBuilder?.build())\n    }\n}",
        "import_statements": [
            "import android.app.Notification",
            "import android.app.NotificationChannel",
            "import android.app.NotificationManager",
            "import android.app.PendingIntent",
            "import android.content.BroadcastReceiver",
            "import android.content.Context",
            "import android.content.Intent",
            "import android.content.IntentFilter",
            "import android.graphics.Color",
            "import android.os.Build",
            "import android.util.Log",
            "import androidx.annotation.RequiresApi",
            "import androidx.core.app.NotificationCompat",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.AppConfig.ANG_PACKAGE",
            "import com.v2ray.ang.AppConfig.TAG_DIRECT",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.dto.ServerConfig",
            "import com.v2ray.ang.extension.toSpeedString",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.ui.MainActivity",
            "import com.v2ray.ang.util.MessageUtil",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.util.V2rayConfigUtil",
            "import go.Seq",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.GlobalScope",
            "import kotlinx.coroutines.launch",
            "import libv2ray.Libv2ray",
            "import libv2ray.V2RayPoint",
            "import libv2ray.V2RayVPNServiceSupportsSet",
            "import rx.Observable",
            "import rx.Subscription",
            "import java.lang.ref.SoftReference",
            "import kotlin.math.min"
        ],
        "reference_api": [
            "getNotificationManager"
        ],
        "repo_defined_api_with_code": [],
        "third_party": [
            "getNotificationManager"
        ]
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun importQRcode(forConfig: Boolean): Boolean",
        "start_line": "332",
        "end_line": "351",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/MainActivity.kt",
        "docstring": "The function importQRcode(forConfig: Boolean): Boolean requests camera permission using RxPermissions. If granted, it launches ScannerActivity to scan a QR code, either for configuration or a URL to custom configuration based on the forConfig parameter. If permission is denied, it displays a toast message. The function always returns true.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e17186e470c3",
        "ground_truth": "private fun importQRcode(forConfig: Boolean): Boolean {\n//        try {\n//            startActivityForResult(Intent(\"com.google.zxing.client.android.SCAN\")\n//                    .addCategory(Intent.CATEGORY_DEFAULT)\n//                    .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP), requestCode)\n//        } catch (e: Exception) {\n    RxPermissions(this)\n            .request(Manifest.permission.CAMERA)\n            .subscribe {\n                if (it)\n                    if (forConfig)\n                        scanQRCodeForConfig.launch(Intent(this, ScannerActivity::class.java))\n                    else\n                        scanQRCodeForUrlToCustomConfig.launch(Intent(this, ScannerActivity::class.java))\n                else\n                    toast(R.string.toast_permission_denied)\n            }\n//        }\n    return true\n}",
        "import_statements": [
            "import android.Manifest",
            "import android.content.ActivityNotFoundException",
            "import android.content.Intent",
            "import android.content.res.ColorStateList",
            "import android.net.Uri",
            "import android.net.VpnService",
            "import android.os.Build",
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.KeyEvent",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.widget.Toast",
            "import androidx.activity.OnBackPressedCallback",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import androidx.activity.viewModels",
            "import androidx.appcompat.app.ActionBarDrawerToggle",
            "import androidx.appcompat.app.AlertDialog",
            "import androidx.core.content.ContextCompat",
            "import androidx.core.view.GravityCompat",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.recyclerview.widget.ItemTouchHelper",
            "import androidx.recyclerview.widget.LinearLayoutManager",
            "import com.google.android.material.navigation.NavigationView",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityMainBinding",
            "import com.v2ray.ang.databinding.LayoutProgressBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.helper.SimpleItemTouchHelperCallback",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.AngConfigManager",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.viewmodel.MainViewModel",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.delay",
            "import kotlinx.coroutines.launch",
            "import me.drakeet.support.toast.ToastCompat",
            "import rx.Observable",
            "import rx.android.schedulers.AndroidSchedulers",
            "import java.util.concurrent.TimeUnit"
        ],
        "reference_api": [
            "toast",
            "RxPermissions",
            "Intent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "toast",
                "code": "override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n        title = getString(R.string.title_server)\n        setSupportActionBar(binding.toolbar)\n\n        binding.fab.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                Utils.stopVService(this)\n            } else if ((settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\") == \"VPN\") {\n                val intent = VpnService.prepare(this)\n                if (intent == null) {\n                    startV2Ray()\n                } else {\n                    requestVpnPermission.launch(intent)\n                }\n            } else {\n                startV2Ray()\n            }\n        }\n        binding.layoutTest.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                setTestState(getString(R.string.connection_test_testing))\n                mainViewModel.testCurrentServerRealPing()\n            } else {\n//                tv_test_state.text = getString(R.string.connection_test_fail)\n            }\n        }\n\n        binding.recyclerView.setHasFixedSize(true)\n        binding.recyclerView.layoutManager = LinearLayoutManager(this)\n        binding.recyclerView.adapter = adapter\n\n        val callback = SimpleItemTouchHelperCallback(adapter)\n        mItemTouchHelper = ItemTouchHelper(callback)\n        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)\n\n\n        val toggle = ActionBarDrawerToggle(\n                this, binding.drawerLayout, binding.toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close)\n        binding.drawerLayout.addDrawerListener(toggle)\n        toggle.syncState()\n        binding.navView.setNavigationItemSelectedListener(this)\n\n\n        setupViewModel()\n        mainViewModel.copyAssets(assets)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            RxPermissions(this)\n                .request(Manifest.permission.POST_NOTIFICATIONS)\n                .subscribe {\n                    if (!it)\n                        toast(R.string.toast_permission_denied)\n                }\n        }\n\n        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {\n            override fun handleOnBackPressed() {\n                if (binding.drawerLayout.isDrawerOpen(GravityCompat.START)) {\n                    binding.drawerLayout.closeDrawer(GravityCompat.START)\n                } else {\n                    //super.onBackPressed()\n                    onBackPressedDispatcher.onBackPressed()\n                }\n            }\n        })\n    }"
            },
            {
                "name": "RxPermissions",
                "code": "override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n        title = getString(R.string.title_server)\n        setSupportActionBar(binding.toolbar)\n\n        binding.fab.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                Utils.stopVService(this)\n            } else if ((settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\") == \"VPN\") {\n                val intent = VpnService.prepare(this)\n                if (intent == null) {\n                    startV2Ray()\n                } else {\n                    requestVpnPermission.launch(intent)\n                }\n            } else {\n                startV2Ray()\n            }\n        }\n        binding.layoutTest.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                setTestState(getString(R.string.connection_test_testing))\n                mainViewModel.testCurrentServerRealPing()\n            } else {\n//                tv_test_state.text = getString(R.string.connection_test_fail)\n            }\n        }\n\n        binding.recyclerView.setHasFixedSize(true)\n        binding.recyclerView.layoutManager = LinearLayoutManager(this)\n        binding.recyclerView.adapter = adapter\n\n        val callback = SimpleItemTouchHelperCallback(adapter)\n        mItemTouchHelper = ItemTouchHelper(callback)\n        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)\n\n\n        val toggle = ActionBarDrawerToggle(\n                this, binding.drawerLayout, binding.toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close)\n        binding.drawerLayout.addDrawerListener(toggle)\n        toggle.syncState()\n        binding.navView.setNavigationItemSelectedListener(this)\n\n\n        setupViewModel()\n        mainViewModel.copyAssets(assets)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            RxPermissions(this)\n                .request(Manifest.permission.POST_NOTIFICATIONS)\n                .subscribe {\n                    if (!it)\n                        toast(R.string.toast_permission_denied)\n                }\n        }\n\n        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {\n            override fun handleOnBackPressed() {\n                if (binding.drawerLayout.isDrawerOpen(GravityCompat.START)) {\n                    binding.drawerLayout.closeDrawer(GravityCompat.START)\n                } else {\n                    //super.onBackPressed()\n                    onBackPressedDispatcher.onBackPressed()\n                }\n            }\n        })\n    }"
            },
            {
                "name": "Intent",
                "code": "private fun importManually(createConfigType : Int) {\n        startActivity(\n            Intent()\n                .putExtra(\"createConfigType\", createConfigType)\n                .putExtra(\"subscriptionId\", mainViewModel.subscriptionId)\n                .setClass(this, ServerActivity::class.java)\n        )\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private val scanQRCodeForConfig = registerForActivityResult(ActivityResultContracts.StartActivityForResult())",
        "start_line": "353",
        "end_line": "357",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/MainActivity.kt",
        "docstring": "The variable scanQRCodeForConfig is an ActivityResultLauncher that registers for activity results using ActivityResultContracts.StartActivityForResult(). If the result is RESULT_OK, it calls importBatchConfig() with the scanned QR code result obtained from the intent data.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "ce36e872b013",
        "ground_truth": "private val scanQRCodeForConfig = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {\n    if (it.resultCode == RESULT_OK) {\n        importBatchConfig(it.data?.getStringExtra(\"SCAN_RESULT\"))\n    }\n}",
        "import_statements": [
            "import android.Manifest",
            "import android.content.ActivityNotFoundException",
            "import android.content.Intent",
            "import android.content.res.ColorStateList",
            "import android.net.Uri",
            "import android.net.VpnService",
            "import android.os.Build",
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.KeyEvent",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.widget.Toast",
            "import androidx.activity.OnBackPressedCallback",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import androidx.activity.viewModels",
            "import androidx.appcompat.app.ActionBarDrawerToggle",
            "import androidx.appcompat.app.AlertDialog",
            "import androidx.core.content.ContextCompat",
            "import androidx.core.view.GravityCompat",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.recyclerview.widget.ItemTouchHelper",
            "import androidx.recyclerview.widget.LinearLayoutManager",
            "import com.google.android.material.navigation.NavigationView",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityMainBinding",
            "import com.v2ray.ang.databinding.LayoutProgressBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.helper.SimpleItemTouchHelperCallback",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.AngConfigManager",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.viewmodel.MainViewModel",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.delay",
            "import kotlinx.coroutines.launch",
            "import me.drakeet.support.toast.ToastCompat",
            "import rx.Observable",
            "import rx.android.schedulers.AndroidSchedulers",
            "import java.util.concurrent.TimeUnit"
        ],
        "reference_api": [
            "getStringExtra"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun importClipboard()\n            : Boolean",
        "start_line": "368",
        "end_line": "378",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/MainActivity.kt",
        "docstring": "The function importClipboard() retrieves clipboard content using Utils.getClipboard(this) and imports it via importBatchConfig(clipboard). It returns true if successful, and false if an exception occurs, printing the stack trace.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "2dcc14115d9c",
        "ground_truth": "private fun importClipboard()\n        : Boolean {\n    try {\n        val clipboard = Utils.getClipboard(this)\n        importBatchConfig(clipboard)\n    } catch (e: Exception) {\n        e.printStackTrace()\n        return false\n    }\n    return true\n}",
        "import_statements": [
            "import android.Manifest",
            "import android.content.ActivityNotFoundException",
            "import android.content.Intent",
            "import android.content.res.ColorStateList",
            "import android.net.Uri",
            "import android.net.VpnService",
            "import android.os.Build",
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.KeyEvent",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.widget.Toast",
            "import androidx.activity.OnBackPressedCallback",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import androidx.activity.viewModels",
            "import androidx.appcompat.app.ActionBarDrawerToggle",
            "import androidx.appcompat.app.AlertDialog",
            "import androidx.core.content.ContextCompat",
            "import androidx.core.view.GravityCompat",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.recyclerview.widget.ItemTouchHelper",
            "import androidx.recyclerview.widget.LinearLayoutManager",
            "import com.google.android.material.navigation.NavigationView",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityMainBinding",
            "import com.v2ray.ang.databinding.LayoutProgressBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.helper.SimpleItemTouchHelperCallback",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.AngConfigManager",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.viewmodel.MainViewModel",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.delay",
            "import kotlinx.coroutines.launch",
            "import me.drakeet.support.toast.ToastCompat",
            "import rx.Observable",
            "import rx.android.schedulers.AndroidSchedulers",
            "import java.util.concurrent.TimeUnit"
        ],
        "reference_api": [
            "importBatchConfig"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "importBatchConfig",
                "code": "importBatchConfig(it.data?.getStringExtra(\"SCAN_RESULT\"))"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun importBatchConfig(server: String?)",
        "start_line": "380",
        "end_line": "399",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/MainActivity.kt",
        "docstring": "The function importBatchConfig(server: String?) displays a non-cancelable progress dialog, then launches a coroutine to import batch configurations from a server in the IO context. After a delay, it switches to the Main context to display a success or failure toast based on the import result and reloads the server list if successful. Finally, it dismisses the dialog.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c111da3f3f87",
        "ground_truth": "private fun importBatchConfig(server: String?) {\n    val dialog = AlertDialog.Builder(this)\n        .setView(LayoutProgressBinding.inflate(layoutInflater).root)\n        .setCancelable(false)\n        .show()\n    lifecycleScope.launch(Dispatchers.IO) {\n        val count = AngConfigManager.importBatchConfig(server, mainViewModel.subscriptionId, true)\n        delay(500L)\n        launch(Dispatchers.Main) {\n            if (count > 0) {\n                toast(R.string.toast_success)\n                mainViewModel.reloadServerList()\n            } else {\n                toast(R.string.toast_failure)\n            }\n            dialog.dismiss()\n        }\n    }\n}",
        "import_statements": [
            "import android.Manifest",
            "import android.content.ActivityNotFoundException",
            "import android.content.Intent",
            "import android.content.res.ColorStateList",
            "import android.net.Uri",
            "import android.net.VpnService",
            "import android.os.Build",
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.KeyEvent",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.widget.Toast",
            "import androidx.activity.OnBackPressedCallback",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import androidx.activity.viewModels",
            "import androidx.appcompat.app.ActionBarDrawerToggle",
            "import androidx.appcompat.app.AlertDialog",
            "import androidx.core.content.ContextCompat",
            "import androidx.core.view.GravityCompat",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.recyclerview.widget.ItemTouchHelper",
            "import androidx.recyclerview.widget.LinearLayoutManager",
            "import com.google.android.material.navigation.NavigationView",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityMainBinding",
            "import com.v2ray.ang.databinding.LayoutProgressBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.helper.SimpleItemTouchHelperCallback",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.AngConfigManager",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.viewmodel.MainViewModel",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.delay",
            "import kotlinx.coroutines.launch",
            "import me.drakeet.support.toast.ToastCompat",
            "import rx.Observable",
            "import rx.android.schedulers.AndroidSchedulers",
            "import java.util.concurrent.TimeUnit"
        ],
        "reference_api": [
            "launch",
            "delay",
            "toast"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "toast",
                "code": "override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n        title = getString(R.string.title_server)\n        setSupportActionBar(binding.toolbar)\n\n        binding.fab.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                Utils.stopVService(this)\n            } else if ((settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\") == \"VPN\") {\n                val intent = VpnService.prepare(this)\n                if (intent == null) {\n                    startV2Ray()\n                } else {\n                    requestVpnPermission.launch(intent)\n                }\n            } else {\n                startV2Ray()\n            }\n        }\n        binding.layoutTest.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                setTestState(getString(R.string.connection_test_testing))\n                mainViewModel.testCurrentServerRealPing()\n            } else {\n//                tv_test_state.text = getString(R.string.connection_test_fail)\n            }\n        }\n\n        binding.recyclerView.setHasFixedSize(true)\n        binding.recyclerView.layoutManager = LinearLayoutManager(this)\n        binding.recyclerView.adapter = adapter\n\n        val callback = SimpleItemTouchHelperCallback(adapter)\n        mItemTouchHelper = ItemTouchHelper(callback)\n        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)\n\n\n        val toggle = ActionBarDrawerToggle(\n                this, binding.drawerLayout, binding.toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close)\n        binding.drawerLayout.addDrawerListener(toggle)\n        toggle.syncState()\n        binding.navView.setNavigationItemSelectedListener(this)\n\n\n        setupViewModel()\n        mainViewModel.copyAssets(assets)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            RxPermissions(this)\n                .request(Manifest.permission.POST_NOTIFICATIONS)\n                .subscribe {\n                    if (!it)\n                        toast(R.string.toast_permission_denied)\n                }\n        }\n\n        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {\n            override fun handleOnBackPressed() {\n                if (binding.drawerLayout.isDrawerOpen(GravityCompat.START)) {\n                    binding.drawerLayout.closeDrawer(GravityCompat.START)\n                } else {\n                    //super.onBackPressed()\n                    onBackPressedDispatcher.onBackPressed()\n                }\n            }\n        })\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun readContentFromUri(uri: Uri)",
        "start_line": "522",
        "end_line": "542",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/MainActivity.kt",
        "docstring": "The function readContentFromUri(uri: Uri) requests appropriate read permissions based on the Android version. If granted, it attempts to read content from the provided URI using contentResolver, and processes the content with importCustomizeConfig(). If permission is denied, it displays a toast message.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "9a7e04c72108",
        "ground_truth": "private fun readContentFromUri(uri: Uri) {\n    val permission = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n        Manifest.permission.READ_MEDIA_IMAGES\n    } else {\n        Manifest.permission.READ_EXTERNAL_STORAGE\n    }\n    RxPermissions(this)\n            .request(permission)\n            .subscribe {\n                if (it) {\n                    try {\n                        contentResolver.openInputStream(uri).use { input ->\n                            importCustomizeConfig(input?.bufferedReader()?.readText())\n                        }\n                    } catch (e: Exception) {\n                        e.printStackTrace()\n                    }\n                } else\n                    toast(R.string.toast_permission_denied)\n            }\n}",
        "import_statements": [
            "import android.Manifest",
            "import android.content.ActivityNotFoundException",
            "import android.content.Intent",
            "import android.content.res.ColorStateList",
            "import android.net.Uri",
            "import android.net.VpnService",
            "import android.os.Build",
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.KeyEvent",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.widget.Toast",
            "import androidx.activity.OnBackPressedCallback",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import androidx.activity.viewModels",
            "import androidx.appcompat.app.ActionBarDrawerToggle",
            "import androidx.appcompat.app.AlertDialog",
            "import androidx.core.content.ContextCompat",
            "import androidx.core.view.GravityCompat",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.recyclerview.widget.ItemTouchHelper",
            "import androidx.recyclerview.widget.LinearLayoutManager",
            "import com.google.android.material.navigation.NavigationView",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityMainBinding",
            "import com.v2ray.ang.databinding.LayoutProgressBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.helper.SimpleItemTouchHelperCallback",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.AngConfigManager",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.viewmodel.MainViewModel",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.delay",
            "import kotlinx.coroutines.launch",
            "import me.drakeet.support.toast.ToastCompat",
            "import rx.Observable",
            "import rx.android.schedulers.AndroidSchedulers",
            "import java.util.concurrent.TimeUnit"
        ],
        "reference_api": [
            "importCustomizeConfig",
            "toast",
            "RxPermissions"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "importCustomizeConfig",
                "code": "private fun importConfigCustomClipboard()\n            : Boolean {\n        try {\n            val configText = Utils.getClipboard(this)\n            if (TextUtils.isEmpty(configText)) {\n                toast(R.string.toast_none_data_clipboard)\n                return false\n            }\n            importCustomizeConfig(configText)\n            return true\n        } catch (e: Exception) {\n            e.printStackTrace()\n            return false\n        }\n    }"
            },
            {
                "name": "toast",
                "code": "override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n        title = getString(R.string.title_server)\n        setSupportActionBar(binding.toolbar)\n\n        binding.fab.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                Utils.stopVService(this)\n            } else if ((settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\") == \"VPN\") {\n                val intent = VpnService.prepare(this)\n                if (intent == null) {\n                    startV2Ray()\n                } else {\n                    requestVpnPermission.launch(intent)\n                }\n            } else {\n                startV2Ray()\n            }\n        }\n        binding.layoutTest.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                setTestState(getString(R.string.connection_test_testing))\n                mainViewModel.testCurrentServerRealPing()\n            } else {\n//                tv_test_state.text = getString(R.string.connection_test_fail)\n            }\n        }\n\n        binding.recyclerView.setHasFixedSize(true)\n        binding.recyclerView.layoutManager = LinearLayoutManager(this)\n        binding.recyclerView.adapter = adapter\n\n        val callback = SimpleItemTouchHelperCallback(adapter)\n        mItemTouchHelper = ItemTouchHelper(callback)\n        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)\n\n\n        val toggle = ActionBarDrawerToggle(\n                this, binding.drawerLayout, binding.toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close)\n        binding.drawerLayout.addDrawerListener(toggle)\n        toggle.syncState()\n        binding.navView.setNavigationItemSelectedListener(this)\n\n\n        setupViewModel()\n        mainViewModel.copyAssets(assets)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            RxPermissions(this)\n                .request(Manifest.permission.POST_NOTIFICATIONS)\n                .subscribe {\n                    if (!it)\n                        toast(R.string.toast_permission_denied)\n                }\n        }\n\n        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {\n            override fun handleOnBackPressed() {\n                if (binding.drawerLayout.isDrawerOpen(GravityCompat.START)) {\n                    binding.drawerLayout.closeDrawer(GravityCompat.START)\n                } else {\n                    //super.onBackPressed()\n                    onBackPressedDispatcher.onBackPressed()\n                }\n            }\n        })\n    }"
            },
            {
                "name": "RxPermissions",
                "code": "override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n        title = getString(R.string.title_server)\n        setSupportActionBar(binding.toolbar)\n\n        binding.fab.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                Utils.stopVService(this)\n            } else if ((settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\") == \"VPN\") {\n                val intent = VpnService.prepare(this)\n                if (intent == null) {\n                    startV2Ray()\n                } else {\n                    requestVpnPermission.launch(intent)\n                }\n            } else {\n                startV2Ray()\n            }\n        }\n        binding.layoutTest.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                setTestState(getString(R.string.connection_test_testing))\n                mainViewModel.testCurrentServerRealPing()\n            } else {\n//                tv_test_state.text = getString(R.string.connection_test_fail)\n            }\n        }\n\n        binding.recyclerView.setHasFixedSize(true)\n        binding.recyclerView.layoutManager = LinearLayoutManager(this)\n        binding.recyclerView.adapter = adapter\n\n        val callback = SimpleItemTouchHelperCallback(adapter)\n        mItemTouchHelper = ItemTouchHelper(callback)\n        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)\n\n\n        val toggle = ActionBarDrawerToggle(\n                this, binding.drawerLayout, binding.toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close)\n        binding.drawerLayout.addDrawerListener(toggle)\n        toggle.syncState()\n        binding.navView.setNavigationItemSelectedListener(this)\n\n\n        setupViewModel()\n        mainViewModel.copyAssets(assets)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            RxPermissions(this)\n                .request(Manifest.permission.POST_NOTIFICATIONS)\n                .subscribe {\n                    if (!it)\n                        toast(R.string.toast_permission_denied)\n                }\n        }\n\n        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {\n            override fun handleOnBackPressed() {\n                if (binding.drawerLayout.isDrawerOpen(GravityCompat.START)) {\n                    binding.drawerLayout.closeDrawer(GravityCompat.START)\n                } else {\n                    //super.onBackPressed()\n                    onBackPressedDispatcher.onBackPressed()\n                }\n            }\n        })\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun importCustomizeConfig(server: String?)",
        "start_line": "547",
        "end_line": "565",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/MainActivity.kt",
        "docstring": "The function importCustomizeConfig(server: String?) attempts to import a custom server configuration. If the input server string is null or empty, it shows a toast message. It then tries to append the server configuration using mainViewModel, reloading the server list and showing a success or failure toast accordingly. If an exception occurs, it displays an error toast with the exception message.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "e171c7bc87e9",
        "ground_truth": "private fun importCustomizeConfig(server: String?) {\n    try {\n        if (server == null || TextUtils.isEmpty(server)) {\n            toast(R.string.toast_none_data)\n            return\n        }\n        if (mainViewModel.appendCustomConfigServer(server)) {\n            mainViewModel.reloadServerList()\n            toast(R.string.toast_success)\n        } else {\n            toast(R.string.toast_failure)\n        }\n        //adapter.notifyItemInserted(mainViewModel.serverList.lastIndex)\n    } catch (e: Exception) {\n        ToastCompat.makeText(this, \"${getString(R.string.toast_malformed_josn)} ${e.cause?.message}\", Toast.LENGTH_LONG).show()\n        e.printStackTrace()\n        return\n    }\n}",
        "import_statements": [
            "import android.Manifest",
            "import android.content.ActivityNotFoundException",
            "import android.content.Intent",
            "import android.content.res.ColorStateList",
            "import android.net.Uri",
            "import android.net.VpnService",
            "import android.os.Build",
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.KeyEvent",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.widget.Toast",
            "import androidx.activity.OnBackPressedCallback",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import androidx.activity.viewModels",
            "import androidx.appcompat.app.ActionBarDrawerToggle",
            "import androidx.appcompat.app.AlertDialog",
            "import androidx.core.content.ContextCompat",
            "import androidx.core.view.GravityCompat",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.recyclerview.widget.ItemTouchHelper",
            "import androidx.recyclerview.widget.LinearLayoutManager",
            "import com.google.android.material.navigation.NavigationView",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityMainBinding",
            "import com.v2ray.ang.databinding.LayoutProgressBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.helper.SimpleItemTouchHelperCallback",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.AngConfigManager",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import com.v2ray.ang.viewmodel.MainViewModel",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.delay",
            "import kotlinx.coroutines.launch",
            "import me.drakeet.support.toast.ToastCompat",
            "import rx.Observable",
            "import rx.android.schedulers.AndroidSchedulers",
            "import java.util.concurrent.TimeUnit"
        ],
        "reference_api": [
            "toast",
            "getString"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "toast",
                "code": "override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n        title = getString(R.string.title_server)\n        setSupportActionBar(binding.toolbar)\n\n        binding.fab.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                Utils.stopVService(this)\n            } else if ((settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\") == \"VPN\") {\n                val intent = VpnService.prepare(this)\n                if (intent == null) {\n                    startV2Ray()\n                } else {\n                    requestVpnPermission.launch(intent)\n                }\n            } else {\n                startV2Ray()\n            }\n        }\n        binding.layoutTest.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                setTestState(getString(R.string.connection_test_testing))\n                mainViewModel.testCurrentServerRealPing()\n            } else {\n//                tv_test_state.text = getString(R.string.connection_test_fail)\n            }\n        }\n\n        binding.recyclerView.setHasFixedSize(true)\n        binding.recyclerView.layoutManager = LinearLayoutManager(this)\n        binding.recyclerView.adapter = adapter\n\n        val callback = SimpleItemTouchHelperCallback(adapter)\n        mItemTouchHelper = ItemTouchHelper(callback)\n        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)\n\n\n        val toggle = ActionBarDrawerToggle(\n                this, binding.drawerLayout, binding.toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close)\n        binding.drawerLayout.addDrawerListener(toggle)\n        toggle.syncState()\n        binding.navView.setNavigationItemSelectedListener(this)\n\n\n        setupViewModel()\n        mainViewModel.copyAssets(assets)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            RxPermissions(this)\n                .request(Manifest.permission.POST_NOTIFICATIONS)\n                .subscribe {\n                    if (!it)\n                        toast(R.string.toast_permission_denied)\n                }\n        }\n\n        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {\n            override fun handleOnBackPressed() {\n                if (binding.drawerLayout.isDrawerOpen(GravityCompat.START)) {\n                    binding.drawerLayout.closeDrawer(GravityCompat.START)\n                } else {\n                    //super.onBackPressed()\n                    onBackPressedDispatcher.onBackPressed()\n                }\n            }\n        })\n    }"
            },
            {
                "name": "getString",
                "code": "override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        val view = binding.root\n        setContentView(view)\n        title = getString(R.string.title_server)\n        setSupportActionBar(binding.toolbar)\n\n        binding.fab.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                Utils.stopVService(this)\n            } else if ((settingsStorage?.decodeString(AppConfig.PREF_MODE) ?: \"VPN\") == \"VPN\") {\n                val intent = VpnService.prepare(this)\n                if (intent == null) {\n                    startV2Ray()\n                } else {\n                    requestVpnPermission.launch(intent)\n                }\n            } else {\n                startV2Ray()\n            }\n        }\n        binding.layoutTest.setOnClickListener {\n            if (mainViewModel.isRunning.value == true) {\n                setTestState(getString(R.string.connection_test_testing))\n                mainViewModel.testCurrentServerRealPing()\n            } else {\n//                tv_test_state.text = getString(R.string.connection_test_fail)\n            }\n        }\n\n        binding.recyclerView.setHasFixedSize(true)\n        binding.recyclerView.layoutManager = LinearLayoutManager(this)\n        binding.recyclerView.adapter = adapter\n\n        val callback = SimpleItemTouchHelperCallback(adapter)\n        mItemTouchHelper = ItemTouchHelper(callback)\n        mItemTouchHelper?.attachToRecyclerView(binding.recyclerView)\n\n\n        val toggle = ActionBarDrawerToggle(\n                this, binding.drawerLayout, binding.toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close)\n        binding.drawerLayout.addDrawerListener(toggle)\n        toggle.syncState()\n        binding.navView.setNavigationItemSelectedListener(this)\n\n\n        setupViewModel()\n        mainViewModel.copyAssets(assets)\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            RxPermissions(this)\n                .request(Manifest.permission.POST_NOTIFICATIONS)\n                .subscribe {\n                    if (!it)\n                        toast(R.string.toast_permission_denied)\n                }\n        }\n\n        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {\n            override fun handleOnBackPressed() {\n                if (binding.drawerLayout.isDrawerOpen(GravityCompat.START)) {\n                    binding.drawerLayout.closeDrawer(GravityCompat.START)\n                } else {\n                    //super.onBackPressed()\n                    onBackPressedDispatcher.onBackPressed()\n                }\n            }\n        })\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder",
        "start_line": "211",
        "end_line": "218",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/MainRecyclerAdapter.kt",
        "docstring": "The function onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder overrides the method to create and return a ViewHolder based on the viewType. It inflates the appropriate layout, either MainViewHolder for VIEW_TYPE_ITEM or FooterViewHolder for other types, and returns the corresponding ViewHolder instance.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "212add2ef0a1",
        "ground_truth": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder {\n    return when (viewType) {\n        VIEW_TYPE_ITEM ->\n            MainViewHolder(ItemRecyclerMainBinding.inflate(LayoutInflater.from(parent.context), parent, false))\n        else ->\n            FooterViewHolder(ItemRecyclerFooterBinding.inflate(LayoutInflater.from(parent.context), parent, false))\n    }\n}",
        "import_statements": [
            "import android.content.Intent",
            "import android.graphics.Color",
            "import android.text.TextUtils",
            "import android.view.LayoutInflater",
            "import android.view.View",
            "import android.view.ViewGroup",
            "import androidx.appcompat.app.AlertDialog",
            "import androidx.core.content.ContextCompat",
            "import androidx.recyclerview.widget.RecyclerView",
            "import com.google.gson.Gson",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AngApplication.Companion.application",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ItemQrcodeBinding",
            "import com.v2ray.ang.databinding.ItemRecyclerFooterBinding",
            "import com.v2ray.ang.databinding.ItemRecyclerMainBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.dto.SubscriptionItem",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.helper.ItemTouchHelperAdapter",
            "import com.v2ray.ang.helper.ItemTouchHelperViewHolder",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.AngConfigManager",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import rx.Observable",
            "import rx.android.schedulers.AndroidSchedulers",
            "import java.util.concurrent.TimeUnit"
        ],
        "reference_api": [
            "MainViewHolder",
            "FooterViewHolder"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "MainViewHolder",
                "code": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder {\n        return when (viewType) {\n            VIEW_TYPE_ITEM ->\n                MainViewHolder(ItemRecyclerMainBinding.inflate(LayoutInflater.from(parent.context), parent, false))\n            else ->\n                FooterViewHolder(ItemRecyclerFooterBinding.inflate(LayoutInflater.from(parent.context), parent, false))\n        }\n    }"
            },
            {
                "name": "FooterViewHolder",
                "code": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder {\n        return when (viewType) {\n            VIEW_TYPE_ITEM ->\n                MainViewHolder(ItemRecyclerMainBinding.inflate(LayoutInflater.from(parent.context), parent, false))\n            else ->\n                FooterViewHolder(ItemRecyclerFooterBinding.inflate(LayoutInflater.from(parent.context), parent, false))\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean",
        "start_line": "257",
        "end_line": "266",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/MainRecyclerAdapter.kt",
        "docstring": "The function onItemMove(fromPosition: Int, toPosition: Int): Boolean overrides the method to handle item movement in a list. It swaps items in the ViewModel, notifies that an item has moved, and updates the item range to reflect the position change. It returns true to indicate the move was handled.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "313889cac256",
        "ground_truth": "override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {\n    mActivity.mainViewModel.swapServer(fromPosition, toPosition)\n    notifyItemMoved(fromPosition, toPosition)\n    // position is changed, since position is used by click callbacks, need to update range\n    if (toPosition > fromPosition)\n        notifyItemRangeChanged(fromPosition, toPosition - fromPosition + 1)\n    else\n        notifyItemRangeChanged(toPosition, fromPosition - toPosition + 1)\n    return true\n}",
        "import_statements": [
            "import android.content.Intent",
            "import android.graphics.Color",
            "import android.text.TextUtils",
            "import android.view.LayoutInflater",
            "import android.view.View",
            "import android.view.ViewGroup",
            "import androidx.appcompat.app.AlertDialog",
            "import androidx.core.content.ContextCompat",
            "import androidx.recyclerview.widget.RecyclerView",
            "import com.google.gson.Gson",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AngApplication.Companion.application",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ItemQrcodeBinding",
            "import com.v2ray.ang.databinding.ItemRecyclerFooterBinding",
            "import com.v2ray.ang.databinding.ItemRecyclerMainBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.dto.SubscriptionItem",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.helper.ItemTouchHelperAdapter",
            "import com.v2ray.ang.helper.ItemTouchHelperViewHolder",
            "import com.v2ray.ang.service.V2RayServiceManager",
            "import com.v2ray.ang.util.AngConfigManager",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import rx.Observable",
            "import rx.android.schedulers.AndroidSchedulers",
            "import java.util.concurrent.TimeUnit"
        ],
        "reference_api": [
            "notifyItemRangeChanged",
            "notifyItemMoved"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "notifyItemRangeChanged",
                "code": "private  fun removeServer(guid: String,position:Int) {\n        mActivity.mainViewModel.removeServer(guid)\n        notifyItemRemoved(position)\n        notifyItemRangeChanged(position, mActivity.mainViewModel.serversCache.size)\n    }"
            },
            {
                "name": "notifyItemMoved",
                "code": "override fun onItemMove(fromPosition: Int, toPosition: Int): Boolean {\n        mActivity.mainViewModel.swapServer(fromPosition, toPosition)\n        notifyItemMoved(fromPosition, toPosition)\n        // position is changed, since position is used by click callbacks, need to update range\n        if (toPosition > fromPosition)\n            notifyItemRangeChanged(fromPosition, toPosition - fromPosition + 1)\n        else\n            notifyItemRangeChanged(toPosition, fromPosition - toPosition + 1)\n        return true\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "override fun onCreateOptionsMenu(menu: Menu): Boolean",
        "start_line": "184",
        "end_line": "204",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/PerAppProxyActivity.kt",
        "docstring": "The function onCreateOptionsMenu(menu: Menu): Boolean overrides the method to inflate a menu layout from R.menu.menu_bypass_list. It sets up a SearchView to filter items using filterProxyApp(newText) when the search text changes. The function returns the result of the superclass's onCreateOptionsMenu method.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "28ea29c3dbbd",
        "ground_truth": "override fun onCreateOptionsMenu(menu: Menu): Boolean {\n    menuInflater.inflate(R.menu.menu_bypass_list, menu)\n    val searchItem = menu.findItem(R.id.search_view)\n    if (searchItem != null) {\n        val searchView = searchItem.actionView as SearchView\n        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {\n            override fun onQueryTextSubmit(query: String?): Boolean {\n                return false\n            }\n            override fun onQueryTextChange(newText: String?): Boolean {\n                filterProxyApp(newText?:\"\")\n                return false\n            }\n        })\n    }\n    return super.onCreateOptionsMenu(menu)\n}",
        "import_statements": [
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.util.Log",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.view.View",
            "import androidx.appcompat.widget.SearchView",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.recyclerview.widget.DividerItemDecoration",
            "import androidx.recyclerview.widget.LinearLayoutManager",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.AppConfig.ANG_PACKAGE",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityBypassListBinding",
            "import com.v2ray.ang.dto.AppInfo",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.extension.v2RayApplication",
            "import com.v2ray.ang.util.AppManagerUtil",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.launch",
            "import rx.android.schedulers.AndroidSchedulers",
            "import rx.schedulers.Schedulers",
            "import java.text.Collator"
        ],
        "reference_api": [
            "filterProxyApp"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "filterProxyApp",
                "code": "override fun onCreateOptionsMenu(menu: Menu): Boolean {\n        menuInflater.inflate(R.menu.menu_bypass_list, menu)\n\n        val searchItem = menu.findItem(R.id.search_view)\n        if (searchItem != null) {\n            val searchView = searchItem.actionView as SearchView\n            searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {\n                override fun onQueryTextSubmit(query: String?): Boolean {\n                    return false\n                }\n\n                override fun onQueryTextChange(newText: String?): Boolean {\n                    filterProxyApp(newText?:\"\")\n                    return false\n                }\n            })\n        }\n\n\n        return super.onCreateOptionsMenu(menu)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun selectProxyApp() ",
        "start_line": "238",
        "end_line": "249",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/PerAppProxyActivity.kt",
        "docstring": "The function selectProxyApp() displays a toast message indicating the start of content downloading, retrieves content from a specified URL using a coroutine in the IO dispatcher, and then, on the main dispatcher, logs the content, calls selectProxyApp(content, true), and displays a success toast message.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "612f5c30d64a",
        "ground_truth": "private fun selectProxyApp() {\n    toast(R.string.msg_downloading_content)\n    val url = AppConfig.androidpackagenamelistUrl\n    lifecycleScope.launch(Dispatchers.IO) {\n        val content = Utils.getUrlContext(url, 5000)\n        launch(Dispatchers.Main) {\n            Log.d(ANG_PACKAGE, content)\n            selectProxyApp(content, true)\n            toast(R.string.toast_success)\n        }\n    }\n}",
        "import_statements": [
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.util.Log",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.view.View",
            "import androidx.appcompat.widget.SearchView",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.recyclerview.widget.DividerItemDecoration",
            "import androidx.recyclerview.widget.LinearLayoutManager",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.AppConfig.ANG_PACKAGE",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityBypassListBinding",
            "import com.v2ray.ang.dto.AppInfo",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.extension.v2RayApplication",
            "import com.v2ray.ang.util.AppManagerUtil",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.launch",
            "import rx.android.schedulers.AndroidSchedulers",
            "import rx.schedulers.Schedulers",
            "import java.text.Collator"
        ],
        "reference_api": [
            "launch",
            "toast",
            "selectProxyApp"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "toast",
                "code": "private fun selectProxyApp() {\n        toast(R.string.msg_downloading_content)\n        val url = AppConfig.androidpackagenamelistUrl\n        lifecycleScope.launch(Dispatchers.IO) {\n            val content = Utils.getUrlContext(url, 5000)\n            launch(Dispatchers.Main) {\n                Log.d(ANG_PACKAGE, content)\n                selectProxyApp(content, true)\n                toast(R.string.toast_success)\n            }\n        }\n    }"
            },
            {
                "name": "selectProxyApp",
                "code": "override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {\n        R.id.select_all -> adapter?.let {\n            val pkgNames = it.apps.map { it.packageName }\n            if (it.blacklist.containsAll(pkgNames)) {\n                it.apps.forEach {\n                    val packageName = it.packageName\n                    adapter?.blacklist?.remove(packageName)\n                }\n            } else {\n                it.apps.forEach {\n                    val packageName = it.packageName\n                    adapter?.blacklist?.add(packageName)\n                }\n            }\n            it.notifyDataSetChanged()\n            true\n        } ?: false\n        R.id.select_proxy_app -> {\n            selectProxyApp()\n            true\n        }\n        R.id.import_proxy_app -> {\n            importProxyApp()\n            true\n        }\n        R.id.export_proxy_app -> {\n            exportProxyApp()\n            true\n        }\n        else -> super.onOptionsItemSelected(item)\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder",
        "start_line": "31",
        "end_line": "47",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/PerAppProxyAdapter.kt",
        "docstring": "The function onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder overrides the method to create and return a ViewHolder based on the viewType. For VIEW_TYPE_HEADER, it creates a View with specific layout parameters. For other view types, it inflates an AppViewHolder using ItemRecyclerBypassListBinding and returns the corresponding ViewHolder instance.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6756f63d33b4",
        "ground_truth": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder {\n    val ctx = parent.context\n    return when (viewType) {\n        VIEW_TYPE_HEADER -> {\n            val view = View(ctx)\n            view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                    ctx.resources.getDimensionPixelSize(R.dimen.bypass_list_header_height) * 0)\n            BaseViewHolder(view)\n        }\n//            VIEW_TYPE_ITEM -> AppViewHolder(ctx.layoutInflater\n//                    .inflate(R.layout.item_recycler_bypass_list, parent, false))\n        else -> AppViewHolder(ItemRecyclerBypassListBinding.inflate(LayoutInflater.from(ctx), parent, false))\n    }\n}",
        "import_statements": [
            "import android.view.LayoutInflater",
            "import androidx.recyclerview.widget.RecyclerView",
            "import android.view.View",
            "import android.view.ViewGroup",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ItemRecyclerBypassListBinding",
            "import com.v2ray.ang.dto.AppInfo",
            "import java.util.*"
        ],
        "reference_api": [
            "AppViewHolder",
            "View",
            "BaseViewHolder"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "AppViewHolder",
                "code": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder {\n        val ctx = parent.context\n\n        return when (viewType) {\n            VIEW_TYPE_HEADER -> {\n                val view = View(ctx)\n                view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                        ctx.resources.getDimensionPixelSize(R.dimen.bypass_list_header_height) * 0)\n                BaseViewHolder(view)\n            }\n//            VIEW_TYPE_ITEM -> AppViewHolder(ctx.layoutInflater\n//                    .inflate(R.layout.item_recycler_bypass_list, parent, false))\n\n            else -> AppViewHolder(ItemRecyclerBypassListBinding.inflate(LayoutInflater.from(ctx), parent, false))\n\n        }\n    }"
            },
            {
                "name": "View",
                "code": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder {\n        val ctx = parent.context\n\n        return when (viewType) {\n            VIEW_TYPE_HEADER -> {\n                val view = View(ctx)\n                view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                        ctx.resources.getDimensionPixelSize(R.dimen.bypass_list_header_height) * 0)\n                BaseViewHolder(view)\n            }\n//            VIEW_TYPE_ITEM -> AppViewHolder(ctx.layoutInflater\n//                    .inflate(R.layout.item_recycler_bypass_list, parent, false))\n\n            else -> AppViewHolder(ItemRecyclerBypassListBinding.inflate(LayoutInflater.from(ctx), parent, false))\n\n        }\n    }"
            },
            {
                "name": "BaseViewHolder",
                "code": "override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BaseViewHolder {\n        val ctx = parent.context\n\n        return when (viewType) {\n            VIEW_TYPE_HEADER -> {\n                val view = View(ctx)\n                view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,\n                        ctx.resources.getDimensionPixelSize(R.dimen.bypass_list_header_height) * 0)\n                BaseViewHolder(view)\n            }\n//            VIEW_TYPE_ITEM -> AppViewHolder(ctx.layoutInflater\n//                    .inflate(R.layout.item_recycler_bypass_list, parent, false))\n\n            else -> AppViewHolder(ItemRecyclerBypassListBinding.inflate(LayoutInflater.from(ctx), parent, false))\n\n        }\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "fun scanQRcode(forReplace: Boolean): Boolean",
        "start_line": "92",
        "end_line": "111",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/RoutingSettingsFragment.kt",
        "docstring": "The function scanQRcode(forReplace: Boolean): Boolean requests camera permission using RxPermissions. If granted, it launches ScannerActivity with either scanQRCodeForReplace or scanQRCodeForAppend based on the forReplace flag. If permission is denied, it displays a toast message. The function returns true.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "c76f3015d70a",
        "ground_truth": "fun scanQRcode(forReplace: Boolean): Boolean {\n//        try {\n//            startActivityForResult(Intent(\"com.google.zxing.client.android.SCAN\")\n//                    .addCategory(Intent.CATEGORY_DEFAULT)\n//                    .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP), requestCode)\n//        } catch (e: Exception) {\n    RxPermissions(requireActivity())\n            .request(Manifest.permission.CAMERA)\n            .subscribe {\n                if (it)\n                    if (forReplace)\n                        scanQRCodeForReplace.launch(Intent(activity, ScannerActivity::class.java))\n                    else\n                        scanQRCodeForAppend.launch(Intent(activity, ScannerActivity::class.java))\n                else\n                    activity?.toast(R.string.toast_permission_denied)\n            }\n//        }\n    return true\n}",
        "import_statements": [
            "import android.Manifest",
            "import androidx.appcompat.app.AppCompatActivity.RESULT_OK",
            "import android.content.Intent",
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.*",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import androidx.fragment.app.Fragment",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.preference.PreferenceManager",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.FragmentRoutingSettingsBinding",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.extension.v2RayApplication",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.launch"
        ],
        "reference_api": [
            "RxPermissions",
            "Intent",
            "requireActivity"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "RxPermissions",
                "code": "fun scanQRcode(forReplace: Boolean): Boolean {\n//        try {\n//            startActivityForResult(Intent(\"com.google.zxing.client.android.SCAN\")\n//                    .addCategory(Intent.CATEGORY_DEFAULT)\n//                    .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP), requestCode)\n//        } catch (e: Exception) {\n        RxPermissions(requireActivity())\n                .request(Manifest.permission.CAMERA)\n                .subscribe {\n                    if (it)\n                        if (forReplace)\n                            scanQRCodeForReplace.launch(Intent(activity, ScannerActivity::class.java))\n                        else\n                            scanQRCodeForAppend.launch(Intent(activity, ScannerActivity::class.java))\n                    else\n                        activity?.toast(R.string.toast_permission_denied)\n                }\n//        }\n        return true\n    }"
            },
            {
                "name": "Intent",
                "code": "fun scanQRcode(forReplace: Boolean): Boolean {\n//        try {\n//            startActivityForResult(Intent(\"com.google.zxing.client.android.SCAN\")\n//                    .addCategory(Intent.CATEGORY_DEFAULT)\n//                    .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP), requestCode)\n//        } catch (e: Exception) {\n        RxPermissions(requireActivity())\n                .request(Manifest.permission.CAMERA)\n                .subscribe {\n                    if (it)\n                        if (forReplace)\n                            scanQRCodeForReplace.launch(Intent(activity, ScannerActivity::class.java))\n                        else\n                            scanQRCodeForAppend.launch(Intent(activity, ScannerActivity::class.java))\n                    else\n                        activity?.toast(R.string.toast_permission_denied)\n                }\n//        }\n        return true\n    }"
            },
            {
                "name": "requireActivity",
                "code": "fun scanQRcode(forReplace: Boolean): Boolean {\n//        try {\n//            startActivityForResult(Intent(\"com.google.zxing.client.android.SCAN\")\n//                    .addCategory(Intent.CATEGORY_DEFAULT)\n//                    .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP), requestCode)\n//        } catch (e: Exception) {\n        RxPermissions(requireActivity())\n                .request(Manifest.permission.CAMERA)\n                .subscribe {\n                    if (it)\n                        if (forReplace)\n                            scanQRCodeForReplace.launch(Intent(activity, ScannerActivity::class.java))\n                        else\n                            scanQRCodeForAppend.launch(Intent(activity, ScannerActivity::class.java))\n                    else\n                        activity?.toast(R.string.toast_permission_denied)\n                }\n//        }\n        return true\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private val scanQRCodeForReplace = registerForActivityResult(ActivityResultContracts.StartActivityForResult())",
        "start_line": "113",
        "end_line": "118",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/RoutingSettingsFragment.kt",
        "docstring": "The function scanQRCodeForReplace is an ActivityResultLauncher that handles the result of a QR code scanning activity. If the result is OK, it retrieves the scan result from the intent data, converts it to an editable format using Utils.getEditable(), and sets this value to binding.etRoutingContent.text.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "8f4419c77aee",
        "ground_truth": "private val scanQRCodeForReplace = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {\n    if (it.resultCode == RESULT_OK) {\n        val content = it.data?.getStringExtra(\"SCAN_RESULT\")\n        binding.etRoutingContent.text = Utils.getEditable(content)\n    }\n}",
        "import_statements": [
            "import android.Manifest",
            "import androidx.appcompat.app.AppCompatActivity.RESULT_OK",
            "import android.content.Intent",
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.*",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import androidx.fragment.app.Fragment",
            "import androidx.lifecycle.lifecycleScope",
            "import androidx.preference.PreferenceManager",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.FragmentRoutingSettingsBinding",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.extension.v2RayApplication",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import kotlinx.coroutines.Dispatchers",
            "import kotlinx.coroutines.launch"
        ],
        "reference_api": [
            "getStringExtra",
            "getEditable"
        ],
        "repo_defined_api_with_code": [],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun showFileChooser()",
        "start_line": "94",
        "end_line": "105",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/ScannerActivity.kt",
        "docstring": "The function showFileChooser() creates an intent to open a file chooser for selecting image files. It launches the file chooser using chooseFile.launch() with a custom title. If no file manager is found, it displays a toast message indicating the requirement of a file manager.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "6c43dd1d2be3",
        "ground_truth": "private fun showFileChooser() {\n    val intent = Intent(Intent.ACTION_GET_CONTENT)\n    intent.type = \"image/*\"\n    intent.addCategory(Intent.CATEGORY_OPENABLE)\n    //intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)\n    try {\n        chooseFile.launch(Intent.createChooser(intent, getString(R.string.title_file_chooser)))\n    } catch (ex: android.content.ActivityNotFoundException) {\n        toast(R.string.toast_require_file_manager)\n    }\n}",
        "import_statements": [
            "import android.Manifest",
            "import androidx.appcompat.app.AppCompatActivity",
            "import android.os.Bundle",
            "import android.content.Intent",
            "import android.graphics.BitmapFactory",
            "import android.os.Build",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import androidx.activity.result.contract.ActivityResultContracts",
            "import com.tbruyelle.rxpermissions.RxPermissions",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.AppConfig",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.QRCodeDecoder",
            "import io.github.g00fy2.quickie.QRResult",
            "import io.github.g00fy2.quickie.ScanCustomCode",
            "import io.github.g00fy2.quickie.config.ScannerConfig"
        ],
        "reference_api": [
            "getString",
            "toast",
            "Intent"
        ],
        "repo_defined_api_with_code": [
            {
                "name": "getString",
                "code": "private fun showFileChooser() {\n        val intent = Intent(Intent.ACTION_GET_CONTENT)\n        intent.type = \"image/*\"\n        intent.addCategory(Intent.CATEGORY_OPENABLE)\n        //intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)\n\n        try {\n            chooseFile.launch(Intent.createChooser(intent, getString(R.string.title_file_chooser)))\n        } catch (ex: android.content.ActivityNotFoundException) {\n            toast(R.string.toast_require_file_manager)\n        }\n    }"
            },
            {
                "name": "toast",
                "code": "override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {\n        R.id.scan_code -> {\n            launchScan()\n            true\n        }\n        R.id.select_photo -> {\n            val permission = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n                Manifest.permission.READ_MEDIA_IMAGES\n            } else {\n                Manifest.permission.READ_EXTERNAL_STORAGE\n            }\n            RxPermissions(this)\n                .request(permission)\n                .subscribe {\n                    if (it) {\n                        try {\n                            showFileChooser()\n                        } catch (e: Exception) {\n                            e.printStackTrace()\n                        }\n                    } else\n                        toast(R.string.toast_permission_denied)\n                }\n            true\n        }\n        else -> super.onOptionsItemSelected(item)\n    }"
            },
            {
                "name": "Intent",
                "code": "private fun finished(text: String) {\n        val intent = Intent()\n        intent.putExtra(\"SCAN_RESULT\", text)\n        setResult(AppCompatActivity.RESULT_OK, intent)\n        finish()\n    }"
            }
        ],
        "third_party": []
    },
    {
        "subclass": "android",
        "owner/repo": "2dust/v2rayNG",
        "function_declaration": "private fun bindingServer(config: ServerConfig): Boolean",
        "start_line": "57",
        "end_line": "66",
        "file_path": "V2rayNG/app/src/main/kotlin/com/v2ray/ang/ui/ServerCustomConfigActivity.kt",
        "docstring": "The function bindingServer(config: ServerConfig): Boolean updates the UI with the provided server configuration. It sets the remarks text field with the server remarks, checks if there is a raw configuration, and sets the editor content with either the pretty-printed full configuration or the raw configuration. It returns true.\\n",
        "language": "Kotlin",
        "created_time": "",
        "commit_sha": "",
        "instance_id": "b82e69018db6",
        "ground_truth": "private fun bindingServer(config: ServerConfig): Boolean {\n    binding.etRemarks.text = Utils.getEditable(config.remarks)\n    val raw = serverRawStorage?.decodeString(editGuid)\n    if (raw.isNullOrBlank()) {\n        binding.editor.setTextContent(Utils.getEditable(config.fullConfig?.toPrettyPrinting().orEmpty()))\n    } else {\n        binding.editor.setTextContent(Utils.getEditable(raw))\n    }\n    return true\n}",
        "import_statements": [
            "import android.os.Bundle",
            "import android.text.TextUtils",
            "import android.view.Menu",
            "import android.view.MenuItem",
            "import android.widget.Toast",
            "import androidx.appcompat.app.AlertDialog",
            "import com.blacksquircle.ui.editorkit.utils.EditorTheme",
            "import com.blacksquircle.ui.language.json.JsonLanguage",
            "import com.google.gson.*",
            "import com.tencent.mmkv.MMKV",
            "import com.v2ray.ang.R",
            "import com.v2ray.ang.databinding.ActivityServerCustomConfigBinding",
            "import com.v2ray.ang.dto.EConfigType",
            "import com.v2ray.ang.dto.ServerConfig",
            "import com.v2ray.ang.dto.V2rayConfig",
            "import com.v2ray.ang.extension.toast",
            "import com.v2ray.ang.util.MmkvManager",
            "import com.v2ray.ang.util.Utils",
            "import me.drakeet.support.toast.ToastCompat"
        ],
        "reference_api": [],
        "repo_defined_api_with_code": [],
        "third_party": []
    }
]