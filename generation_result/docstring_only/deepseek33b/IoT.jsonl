{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\twhile (desc->bLength != 0) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE\n\t\t\t\t*) desc + desc->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 29.262461619807507}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_conf_desc_t UDC_DESC_STORAGE * next = desc;\n\tdo {\n\t\tnext = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) next + next->bLength);\n\t} while (next->bDescriptorType != desc_id && next->bDescriptorType != USB_DESC_INTERFACE);\n\tif (next->bDescriptorType == desc_id) {\n\t\treturn next;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n", "CodeBleu_score": 28.10126722253729}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\twhile (desc != NULL) {\n\t\tif (desc->bDescriptorType == desc_id) {\n\t\t\treturn desc;\n\t\t}\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t UDC_DESC_STORAGE *) desc\n\t\t\t\t+ desc->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 32.176610064605725}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)    if (!udc_config_valid()) {\n        return false;\n    }\n    if (iface_num >= udc_config->bNumInterfaces) {\n        return false;\n    }\n\n    usb_desc_t *desc = udc_config_desc();\n    while (desc) {\n        if (desc->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n            usb_interface_desc_t *iface_desc = (usb_interface_desc_t *)desc;\n            if (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n                return true;\n            }\n        }\n        desc = desc->next;\n    }\n    return false;\n}\n", "CodeBleu_score": 39.71967859815659}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)    if (!udc_get_configuration())\n        return false;\n    if (iface_num >= USB_NUM_INTERFACES)\n        return false;\n\n    uint8_t *desc = udc_get_configuration_descriptor();\n    while (*desc) {\n        if (*desc == USB_DESC_TYPE_INTERFACE) {\n            if (desc[1] == iface_num && desc[2] == setting_num)\n                return true;\n        }\n        desc += desc[0];\n    }\n    return false;\n}\n", "CodeBleu_score": 21.71018197223437}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)    if (!udc_current_config) {\n        return false;\n    }\n    if (iface_num >= udc_current_config->bNumInterfaces) {\n        return false;\n    }\n    struct usb_desc_iface *iface_desc = (struct usb_desc_iface *)(udc_current_config + 1);\n    for (uint8_t i = 0; i < udc_current_config->bNumInterfaces; i++) {\n        if (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n            return true;\n        }\n        iface_desc = (struct usb_desc_iface *)((uint8_t *)iface_desc + iface_desc->bLength);\n    }\n    return false;\n}\n", "CodeBleu_score": 40.67127852776522}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void)    if (udc_req_len != sizeof(udc_ep_status)) {\n        return false;\n    }\n\n    udc_ep_status = udc_ep_is_halted(udc_req_wValue & 0x0F) ? 1 : 0;\n\n    udc_resp_pld_p = &udc_ep_status;\n    udc_resp_len = sizeof(udc_ep_status);\n\n    return true;\n}\n", "CodeBleu_score": 42.34794751126451}, {"code": "static bool udc_req_std_ep_get_status(void)    if (udc_req.wLength != sizeof(uint16_t)) {\n        return false;\n    }\n\n    uint8_t ep = udc_req.wValue & 0x0F;\n    uint8_t status = 0;\n\n    if (udc_ep_is_halted(ep)) {\n        status = UDC_EP_STATUS_HALTED;\n    }\n\n    udc_resp_payload[0] = 0;\n    udc_resp_payload[1] = status;\n    return true;\n}\n", "CodeBleu_score": 43.250164069302045}, {"code": "static bool udc_req_std_ep_get_status(void)  if (udc_req_len != sizeof(udc_ep_status)) {\n    return false;\n  }\n  udc_ep_status = (udc_ep_status & UDC_EP_STATUS_HALTED) ? UDC_EP_STATUS_HALTED : 0;\n  udc_setup_pkt_payload(&udc_ep_status, sizeof(udc_ep_status));\n  return true;\n}\n", "CodeBleu_score": 50.246568141866696}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void)    if (udc_state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n\n    if (udc_req.wIndex >= UDC_MAX_IFACE) {\n        return false;\n    }\n\n    udc_iface_desc_t *iface = &udc_iface_desc[udc_req.wIndex];\n\n    if (!udc_update_desc(iface->iface_desc, iface->iface_desc_size, iface->iface_desc_size)) {\n        return false;\n    }\n\n    if (!udc_update_desc(iface->alt_desc[iface->alt_setting], iface->alt_desc_size[iface->alt_setting], iface->alt_desc_size[iface->alt_setting])) {\n        return false;\n    }\n\n    return iface->udi_handler->setup(udc_req.bRequest, udc_req.wValue, udc_req.wIndex, udc_req.wLength);\n}\n", "CodeBleu_score": 53.214250734213486}, {"code": "static bool udc_req_iface(void)    bool ret;\n    if (udc_state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n    if (udc_setup.wIndex > udc_intf_count) {\n        return false;\n    }\n    udc_intf_desc_update(udc_setup.wIndex, 0);\n    udc_intf_desc_update(udc_setup.wIndex, udc_setup.wValue);\n    ret = udc_intf_handler[udc_setup.wIndex]->setup(udc_setup.bmRequestType, udc_setup.bRequest, udc_setup.wValue, udc_setup.wIndex, udc_setup.wLength);\n    return ret;\n}\n", "CodeBleu_score": 45.81843520027547}, {"code": "static bool udc_req_iface(void)    // Check if the device is in a configured state\n    if (!udc_is_configured()) {\n        return false;\n    }\n\n    // Check if the requested interface number is valid\n    if (udc_req_iface_num() >= udc_num_ifaces()) {\n        return false;\n    }\n\n    // Update the interface descriptor to the default setting\n    udc_iface_desc_default();\n\n    // Update the interface descriptor to the current alternate setting\n    udc_iface_desc_current();\n\n    // Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n    bool result = udc_req_handler();\n\n    // Return the result of the handler's setup function\n    return result;\n}", "CodeBleu_score": 23.51553828277661}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void)    if (udi_msc_luns_count() == 0) {\n        return false;\n    }\n\n    for (uint8_t i = 0; i < udi_msc_luns_count(); i++) {\n        udi_msc_lun_unload(i);\n    }\n\n    if (!udi_msc_external_enable()) {\n        return false;\n    }\n\n    while (udi_msc_cbw_is_pending()) {\n        /* Wait for a CBW reception */\n    }\n\n    return true;\n}\n", "CodeBleu_score": 37.854954609096794}, {"code": "bool udi_msc_enable(void)    // Set initial states for several flags\n    msc_state = MSC_STATE_ENABLED;\n    msc_suspended = false;\n    msc_luns_attached = 0;\n    msc_luns_enabled = 0;\n\n    // Retrieve the number of LUNs\n    msc_luns_attached = udi_msc_get_luns_attached();\n\n    // Check if there are any LUNs available\n    if (msc_luns_attached == 0) {\n        return false;\n    }\n\n    // Unload the medium on each LUN\n    for (uint8_t lun = 0; lun < msc_luns_attached; lun++) {\n        udi_msc_unload_lun(lun);\n    }\n\n    // Check if the external enable function fails\n    if (!udi_msc_external_enable()) {\n        return false;\n    }\n\n    // Start the MSC process by waiting for a CBW reception\n    while (!udi_msc_check_cbw_reception()) {\n        // Do nothing\n    }\n\n    return true;\n}\n", "CodeBleu_score": 51.58737642324604}, {"code": "bool udi_msc_enable(void)\tuint8_t i;\n\n\t/* Set initial state */\n\tudi_msc_state.enabled = false;\n\tudi_msc_state.suspended = false;\n\n\t/* Get number of LUNs */\n\tudi_msc_state.lun_nb = udi_msc_get_nb_lun();\n\n\t/* Check if there is at least one LUN */\n\tif (udi_msc_state.lun_nb == 0) {\n\t\treturn false;\n\t}\n\n\t/* Initialize each LUN */\n\tfor (i = 0; i < udi_msc_state.lun_nb; i++) {\n\t\tudi_msc_state.luns[i].media_present = false;\n\t\tudi_msc_state.luns[i].media_changed = false;\n\t\tudi_msc_state.luns[i].sense_data_available = false;\n\t}\n\n\t/* Check if external enable function is provided */\n\tif (udi_msc_enable_func != NULL) {\n\t\t/* Call external enable function */\n\t\tif (!udi_msc_enable_func()) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Unload the medium on each LUN */\n\tfor (i = 0; i < udi_msc_state.lun_nb; i++) {\n\t\tudi_msc_lun_unload(i);\n\t}\n\n\t/* Start MSC process */\n\twhile (!udi_msc_state.enabled) {\n\t\t/* Wait for CBW reception */\n\t\tudi_msc_wait_cbw();\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 45.10451159298917}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)    // Check the status of the transfer\n    if (status != UDD_EP_TRANSFER_OK) {\n        // If the transfer is not successful, wait for a MSC setup reset to restart CBW reception\n        udi_msc_wait_for_setup_reset();\n        return;\n    }\n\n    // Update the sense data\n    udi_msc_update_sense_data();\n\n    // Decrease the data residue in the CSW by the amount of data sent\n    udi_msc_cbw.dDataResidue -= nb_sent;\n\n    // Process the updated CSW\n    udi_msc_process_csw();\n}\n", "CodeBleu_score": 54.58621296210606}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)    if (status == UDD_EP_TRANSFER_OK) {\n        udi_msc_sense_data.data_residue -= nb_sent;\n        udi_msc_csw.dDataResidue -= nb_sent;\n    } else {\n        udi_msc_wait_for_msc_setup_reset();\n        return;\n    }\n\n    udi_msc_update_sense_data();\n\n    if (udi_msc_csw.dDataResidue == 0) {\n        udi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_CMD_OK;\n        udi_msc_csw.dTag = udi_msc_cbw.dTag;\n        udi_msc_csw.dDataResidue = 0;\n        udi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_CMD_OK;\n        udi_msc_csw_send();\n        udi_msc_wait_for_msc_setup_reset();\n    } else {\n        udi_msc_csw_send();\n    }\n}\n", "CodeBleu_score": 46.864402010892384}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)    if (status != UDD_EP_TRANSFER_OK) {\n        udi_msc_wait_for_msc_reset();\n        return;\n    }\n\n    udi_msc_update_sense_data(CSW_CMD_PASSED, SENSE_KEY_NO_SENSE);\n    udi_msc_csw.dDataResidue -= nb_sent;\n    udi_msc_process_csw();\n}\n", "CodeBleu_score": 55.50700643597416}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void)    uint8_t csw_status;\n    uint8_t csw_tag;\n    uint32_t csw_data_residue;\n    uint8_t csw_direction;\n    uint8_t csw_endpoint;\n\n    csw_tag = udi_msc_csw_tag;\n    csw_data_residue = udi_msc_csw_data_residue;\n    csw_direction = udi_msc_csw_direction;\n    csw_endpoint = udi_msc_csw_endpoint;\n\n    if (csw_data_residue != 0) {\n        udi_msc_stall_ep(csw_endpoint, csw_direction);\n    }\n\n    csw_status = UDI_MSC_CSW_STATUS_SUCCESS;\n\n    udi_msc_csw_tag = csw_tag;\n    udi_msc_csw_data_residue = 0;\n    udi_msc_csw_status = csw_status;\n\n    udi_msc_csw_send();\n}", "CodeBleu_score": 32.70015113969053}, {"code": "static void udi_msc_csw_process(void)    uint8_t direction;\n    uint32_t data_residue;\n\n    if (udi_msc_csw.b.dCSWSignature != UDI_MSC_CSW_SIGNATURE) {\n        return;\n    }\n\n    direction = udi_msc_cbw.b.bmCBWFlags & UDI_MSC_CBW_DIR_MASK;\n    data_residue = udi_msc_csw.b.dDataResidue;\n\n    if (data_residue != 0) {\n        if (direction == UDI_MSC_CBW_DIR_IN) {\n            udi_msc_ep_stall(UDI_MSC_EP_IN);\n        } else {\n            udi_msc_ep_stall(UDI_MSC_EP_OUT);\n        }\n    }\n\n    udi_msc_csw.b.bCSWStatus = UDI_MSC_CSW_CMD_PASSED;\n    udi_msc_csw.b.dTag = udi_msc_cbw.b.dTag;\n    udi_msc_csw.b.dDataResidue = data_residue;\n\n    udi_msc_ep_write(UDI_MSC_EP_IN, (uint8_t *)&udi_msc_csw, sizeof(udi_msc_csw));\n}", "CodeBleu_score": 40.51927874917689}, {"code": "static void udi_msc_csw_process(void)    uint8_t csw[13];\n    uint32_t csw_tag;\n    uint32_t csw_data_residue;\n    uint8_t csw_status;\n\n    csw_tag = udi_msc_csw.dwTag;\n    csw_data_residue = udi_msc_csw.dwDataResidue;\n    csw_status = udi_msc_csw.bStatus;\n\n    if (csw_data_residue != 0) {\n        if (udi_msc_cbw.bmFlags & USB_MSC_CBW_FLAG_OUT) {\n            udi_msc_ep_stall_out();\n        } else {\n            udi_msc_ep_stall_in();\n        }\n    }\n\n    csw[0] = 0x53;\n    csw[1] = 0x42;\n    csw[2] = 0x00;\n    csw[3] = 0x00;\n    csw[4] = 0x00;\n    csw[5] = 0x00;\n    csw[6] = csw_tag & 0xFF;\n    csw[7] = (csw_tag >> 8) & 0xFF;\n    csw[8] = (csw_tag >> 16) & 0xFF;\n    csw[9] = (csw_tag >> 24) & 0xFF;\n    csw[10] = csw_status;\n    csw[11] = 0x00;\n    csw[12] = 0x00;\n\n    udi_msc_ep_write(csw, 13);\n}\n", "CodeBleu_score": 37.12623469812433}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)    if (port == 0) {\n        if (b_enable) {\n            usb_task_cdc_dtr_enabled = true;\n            cancelReset();\n        } else {\n            usb_task_cdc_dtr_enabled = false;\n            if (usb_task_cdc_dtr_rate == 1200) {\n                initiateReset();\n            }\n        }\n    }\n}\n", "CodeBleu_score": 32.02202541409732}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)    if (port == 0) {\n        if (b_enable) {\n            usb_task_cdc_dtr_enabled = true;\n            cancelReset();\n        } else {\n            usb_task_cdc_dtr_enabled = false;\n            if (usb_task_cdc_dtr_rate == 1200) {\n                reset_controller_write_reset_enable(RESET_CONTROLLER_BASE, 1);\n                initiateReset(RESET_CONTROLLER_BASE);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 31.98675247215269}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)    if (port == 0) {\n        usb_task_cdc_dtr_0 = b_enable;\n        if (usb_task_cdc_rate_1200_0 && !b_enable) {\n            sys_reset_delay_1200ms();\n        } else {\n            sys_reset_cancel();\n        }\n    }\n}\n", "CodeBleu_score": 42.65259482764153}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)    switch (usb_setup.bRequest) {\n        case 0x04: {\n            // Microsoft-compatible ID\n            usb_control_payload_ptr = (uint8_t *)&usb_descriptor_ms_id;\n            usb_control_payload_size = sizeof(usb_descriptor_ms_id);\n            return true;\n        }\n        case 0x05: {\n            // Microsoft-compatible extended properties\n            usb_control_payload_ptr = (uint8_t *)&usb_descriptor_ms_extended_properties;\n            usb_control_payload_size = sizeof(usb_descriptor_ms_extended_properties);\n            return true;\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 16.15583324171484}, {"code": "bool usb_task_other_requests(void)    switch (usb_setup.bRequest) {\n        case 0x04:\n            usb_control_request_payload = (uint8_t *)&microsoft_id_descriptor;\n            usb_control_request_payload_size = sizeof(microsoft_id_descriptor);\n            return true;\n        case 0x05:\n            usb_control_request_payload = (uint8_t *)&microsoft_extended_properties_descriptor;\n            usb_control_request_payload_size = sizeof(microsoft_extended_properties_descriptor);\n            return true;\n        default:\n            return false;\n    }\n}", "CodeBleu_score": 17.80990671211687}, {"code": "bool usb_task_other_requests(void)    // Check if the request type is vendor-specific\n    if (usb_get_setup_request_type() == USB_SETUP_REQUEST_TYPE_VENDOR) {\n        // Check if the request index is 0x04 or 0x05\n        if (usb_get_setup_request_index() == 0x04 || usb_get_setup_request_index() == 0x05) {\n            // Set up pointers and sizes for Microsoft-compatible ID and extended properties descriptors\n            uint8_t *p_payload = NULL;\n            uint16_t payload_size = 0;\n\n            // Process request index 0x04\n            if (usb_get_setup_request_index() == 0x04) {\n                p_payload = (uint8_t *)&usb_descriptor_ms_id;\n                payload_size = sizeof(usb_descriptor_ms_id);\n            }\n\n            // Process request index 0x05\n            if (usb_get_setup_request_index() == 0x05) {\n                p_payload = (uint8_t *)&usb_descriptor_ms_ext_prop;\n                payload_size = sizeof(usb_descriptor_ms_ext_prop);\n            }\n\n            // Update the control request payload and size\n            usb_set_control_request_payload(p_payload, payload_size);\n\n            // Return true to indicate that the request is processed\n            return true;\n        }\n    }\n\n    // Return false to indicate that the request is not recognized\n    return false;\n}\n", "CodeBleu_score": 28.192753289632467}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0)\n\t\treturn;\n\n\tspiSend(0xFF);\n\twhile (--nbyte) {\n\t\tspiSend(0xFF);\n\t}\n\tbuf[nbyte] = spiRec();\n}\n", "CodeBleu_score": 35.04887613117386}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)  if (nbyte == 0)\n    return;\n\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    spiSend(0xFF);\n    buf[i] = spiRec();\n  }\n\n  spiSend(0xFF);\n  buf[nbyte - 1] = spiRec();\n}\n", "CodeBleu_score": 55.251035007973414}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tif (nbyte == 0) return;\n\tspiSend(0xFF);\n\twhile (--nbyte) {\n\t\tspiSend(0xFF);\n\t\t*buf++ = spiRec();\n\t}\n\t*buf = spiRec();\n}\n", "CodeBleu_score": 32.464362786568365}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    const uint32_t *pvtbl = (uint32_t *)SCB->VTOR;\n    uint32_t offset = irq + NVIC_USER_IRQ_OFFSET;\n    pfnISR_Handler oldHandler = (pfnISR_Handler)pvtbl[offset + 1];\n    __disable_irq();\n    pvtbl[offset + 1] = (uint32_t)newHandler;\n    __enable_irq();\n    return oldHandler;\n}\n", "CodeBleu_score": 51.76363817457948}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler;\n\tuint32_t *pNVIC_ISER;\n\tuint32_t *pNVIC_ICER;\n\tuint32_t *pNVIC_ICPR;\n\tuint32_t *pNVIC_IPR;\n\tuint32_t *pNVIC_IABR;\n\tuint32_t *pNVIC_IAPR;\n\tuint32_t *pNVIC_IP;\n\tuint32_t *pNVIC_ICFGR;\n\tuint32_t *pNVIC_ISFR;\n\tuint32_t *pNVIC_ISPR;\n\tuint32_t *pNVIC_ICPR;\n\tuint32_t *pNVIC_IAPR;\n\tuint32_t *pNVIC_IP;\n\tuint32_t *pNVIC_ICFGR;\n\tuint32_t *pNVIC_ISFR;\n\tuint32_t *pNVIC_ISPR;\n\tuint32_t *pNVIC_ICPR;\n\tuint32_t *pNVIC_IAPR;\n\tuint32_t *pNVIC_IP;\n\tuint32_t *pNVIC_ICFGR;\n\tuint32_t *pNVIC_ISFR;\n\tuint32_t *pNVIC_ISPR;\n\tuint32_t *pNVIC_ICPR;\n\tuint32_t *pNVIC_IAPR;\n\tuint32_t *pNVIC_IP;\n\tuint32_t *pNVIC_ICFGR;\n\tuint32_t *pNVIC_ISFR;\n\tuint32_t *pNVIC_ISPR;\n\tuint32_t *pNVIC_ICPR;\n\tuint32_t *pNVIC_IAPR;\n\tuint32_t *pNVIC_IP;\n\tuint32_t *pNVIC_ICFGR;\n\tuint32_t *pNVIC_ISFR;", "CodeBleu_score": 30.870399009442146}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    pfnISR_Handler oldHandler = NULL;\n    uint32_t *pNVIC_VectTable = (uint32_t *)SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_SYSRESETREQ_Msk;\n    uint32_t prioritygroup = NVIC_GetPriorityGrouping();\n    uint32_t priority = NVIC_GetPriority(irq);\n    uint32_t irqNum = irq;\n\n    // Disable global interrupts\n    __disable_irq();\n\n    // Get the current ISR handler\n    oldHandler = (pfnISR_Handler)pNVIC_VectTable[irqNum + 16];\n\n    // Replace the ISR handler with the new one\n    pNVIC_VectTable[irqNum + 16] = (uint32_t)newHandler;\n\n    // Set the priority of the IRQ\n    NVIC_SetPriority(irq, priority);\n\n    // Enable global interrupts\n    __enable_irq();\n\n    return oldHandler;\n}\n", "CodeBleu_score": 52.07335200034293}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek()  if (usb_cdc_enabled) {\n    int c = usb_rx_buffer.peek();\n    if (c < 0) return c;\n    if (c == DLE) {\n      usb_rx_buffer.drop();\n      c = usb_rx_buffer.peek();\n      if (c < 0) return c;\n      if (c == ETX) {\n        usb_rx_buffer.drop();\n        return DLE;\n      }\n      if (c == DLE) {\n        usb_rx_buffer.drop();\n        c = usb_rx_buffer.peek();\n        if (c < 0) return c;\n        if (c == EOT) {\n          usb_rx_buffer.drop();\n          return DLE;\n        }\n      }\n    }\n    return c;\n  }\n  return -1;\n}\n", "CodeBleu_score": 34.70921165530781}, {"code": "int MarlinSerialUSB::peek()  if (!is_enabled()) return -1;\n  if (rx_buffer_head == rx_buffer_tail) return -1;\n  return rx_buffer[rx_buffer_tail];\n}\n", "CodeBleu_score": 22.908816446318824}, {"code": "int MarlinSerialUSB::peek()  if (usb_cdc_enabled) {\n    int c;\n    if ((c = usb_serial_getchar()) >= 0) {\n      #if ENABLED(EMERGENCY_PARSER)\n        emergency_parser.update(c);\n      #endif\n      return c;\n    }\n  }\n  return -1;\n}\n", "CodeBleu_score": 38.496757449591335}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read()  if (usb_cdc_line_rtsdtr & 0x01) {\n    return usb_serial_getchar();\n  }\n  return -1;\n}\n", "CodeBleu_score": 7.148450111223275}, {"code": "int MarlinSerialUSB::read()    if (usb_serial_get_pending_data())\n        return usb_serial_getchar();\n    if (!usb_cdc_enabled())\n        return -1;\n    if (!tud_cdc_available())\n        return -1;\n    char c;\n    tud_cdc_read(&c, 1);\n    if (emergency_parser.enabled)\n        emergency_parser.update(c);\n    return c;\n}\n", "CodeBleu_score": 40.31460524953347}, {"code": "int MarlinSerialUSB::read()  int c = -1;\n\n  // If there's already a char here, return it\n  if (rx_buffer_head != rx_buffer_tail) {\n    c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n    return c;\n  }\n\n  // Nothing yet, but if the CDC connection is alive, try to get more\n  if (!is_active()) return -1;\n\n  // Get more from the serial\n  if (cdc_get_free_tx_buffer() >= TX_BUFFER_SIZE) {\n    cdc_read_bulk_block(cdc_rx_buffer, TX_BUFFER_SIZE);\n\n    // If we don't get a cr or lf, we can feed the parser.\n    // The feed-parser step can't be used with the USB-CDC because\n    // the read-a-character loop is also used for idle-slicing.\n    // The USB-CDC read is non-blocking so there's no problem.\n    if (c != '\\r' && c != '\\n')\n      emergency_parser.update(c);\n  }\n\n  // If there's something in the buffer, return it\n  if (rx_buffer_head != rx_buffer_tail) {\n    c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) % RX_BUFFER_SIZE;\n    return c;\n  }\n\n  // No more characters, so return failure\n  return -1;\n}\n", "CodeBleu_score": 45.7295928478524}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available()    if (usb_serial_available()) {\n        return usb_serial_get_available();\n    } else {\n        return 0;\n    }\n}\n", "CodeBleu_score": 14.693293817992975}, {"code": "int MarlinSerialUSB::available()  if (usb_serial_available()) {\n    return usb_serial_available();\n  }\n  return 0;\n}\n", "CodeBleu_score": 16.36983443287734}, {"code": "int MarlinSerialUSB::available()  int n = tud_cdc_available();\n  if (n)\n    return n;\n\n  if (tud_cdc_connected())\n    return 1;\n\n  return 0;\n}\n", "CodeBleu_score": 41.71345566818876}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)    for (size_t i = 0; i < size; ++i) {\n        uint8_t c = EEPROM.read(pos);\n        if (writing) {\n            *value = c;\n        }\n        crc16(crc, &c, 1);\n        ++pos;\n    }\n    return false;\n}\n", "CodeBleu_score": 60.63891761035547}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)    for (size_t i = 0; i < size; ++i) {\n        uint8_t c = EEPROM.read(pos);\n        if (writing) {\n            *value = c;\n        }\n        crc16(crc, &c, 1);\n        ++pos;\n    }\n    return false;\n}\n", "CodeBleu_score": 60.63891761035547}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)    for (size_t i = 0; i < size; i++) {\n        uint8_t c = EEPROM.read(pos);\n        if (writing) {\n            *value = c;\n            value++;\n        }\n        crc16(crc, &c, 1);\n        pos++;\n    }\n    return false;\n}\n", "CodeBleu_score": 64.42353398365499}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)    if (pin >= NUM_DIGITAL_PINS) return;\n    if (value == 0) {\n        digitalWrite(pin, LOW);\n        return;\n    }\n    if (value == res) {\n        digitalWrite(pin, HIGH);\n        return;\n    }\n    if (freq != PWM_FREQUENCY) {\n        // TODO: add support for different frequencies\n        return;\n    }\n    if (res != 8) {\n        // TODO: add support for different resolutions\n        return;\n    }\n    const uint8_t channel = pinToChannel(pin);\n    if (channel == NO_CHANNEL) {\n        // TODO: add support for software PWM\n        return;\n    }\n    ledcWrite(channel, value);\n}\n", "CodeBleu_score": 36.263746624378655}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)\tif(pin >= NUM_DIGITAL_PINS) return;\n\tpin_t p = digitalPinToPinName(pin);\n\tif(p == NOT_A_PIN) return;\n\n\tif(pwm_channels[p] != NOT_ON_TIMER) {\n\t\tuint32_t duty = (1 << res) - (((1 << res) * value) / 256);\n\t\tledcWrite(pwm_channels[p], duty);\n\t} else {\n\t\tuint8_t channel = pwm_next_channel++;\n\t\tif(channel >= PWM_CHANNELS) {\n\t\t\treturn;\n\t\t}\n\t\tpwm_channels[p] = channel;\n\t\tif(pwm_used_channels == 0) {\n\t\t\tpwm_timer_init(freq, res);\n\t\t}\n\t\tpwm_start(p, channel, freq, res, value);\n\t\t++pwm_used_channels;\n\t}\n}\n", "CodeBleu_score": 38.129978585660076}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)    if (pin < 0 || pin >= PINS_COUNT) return;\n    if (value > 1023) return;\n    if (freq < 1 || freq > 4000000) return;\n    if (res < 1 || res > 16) return;\n\n    if (pin < LED_BUILTIN) {\n        if (ledcWrite(pin, value)) return;\n    }\n\n    if (pin >= LED_BUILTIN) {\n        if (ledcWriteTone(pin, value)) return;\n    }\n\n    if (pin >= LED_BUILTIN) {\n        if (ledcSetupSoft(pin, freq, res)) return;\n    }\n\n    if (pin >= LED_BUILTIN) {\n        if (ledcAttachPin(pin, pin)) return;\n    }\n\n    if (pin >= LED_BUILTIN) {\n        if (ledcWrite(pin, value)) return;\n    }\n}\n", "CodeBleu_score": 33.67787426270107}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value)  static_assert(sizeof(servoDelay) / sizeof(int) == SERVO_CHANNELS, \"Servo delay array length does not match the number of servo channels\");\n  if (servo.attach(pin)) {\n    servo.write(value);\n    delay(servoDelay[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servo.detach();\n    }\n  }\n}\n", "CodeBleu_score": 45.498151376195025}, {"code": "void Servo::move(const int value)  static_assert(sizeof(servoDelay) / sizeof(servoDelay[0]) == NUM_OF_SERVOS, \"Servo delay array length is not equal to the number of servos\");\n  if (servo.attach(pin)) {\n    servo.write(value);\n    delay(servoDelay[servoChannel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servo.detach();\n    }\n  }\n}\n", "CodeBleu_score": 50.21426642566511}, {"code": "void Servo::move(const int value)  static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == NUM_SERVOS, \"servo_delay array length must match NUM_SERVOS\");\n  if (servo.attach(servo_pin)) {\n    servo.write(value);\n    delay(servo_delay[servo_channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servo.detach();\n    }\n  }\n}\n", "CodeBleu_score": 52.62505333757503}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample()    // Update PWM states for each pin\n    for (int i = 0; i < NUM_PINS; i++) {\n        if (pwm_duty_cycle[i] > 0) {\n            // PWM is active for this pin\n            if (pwm_tick_count[i] == 0) {\n                // Time to toggle the pin state\n                pwm_pin_state[i] = !pwm_pin_state[i];\n                pwm_tick_count[i] = pwm_duty_cycle[i];\n            } else {\n                // Decrement the tick count\n                pwm_tick_count[i]--;\n            }\n        } else {\n            // PWM is not active for this pin\n            pwm_pin_state[i] = LOW;\n            pwm_tick_count[i] = 0;\n        }\n    }\n\n    // Write the updated port data to the DMA buffer\n    uint32_t port_data = 0;\n    for (int i = 0; i < NUM_PINS; i++) {\n        if (pwm_pin_state[i]) {\n            port_data |= (1 << i);\n        }\n    }\n    dma_buffer[dma_buffer_pos] = port_data;\n    dma_buffer_pos++;\n}\n", "CodeBleu_score": 39.40268652137161}, {"code": "void i2s_push_sample()    // Update PWM states and write to DMA buffer\n    uint32_t port_data = 0;\n    for (int i = 0; i < NUM_PINS; i++) {\n        if (pwm_duty_cycles[i] > 0) {\n            if (pwm_tick_counts[i] == 0) {\n                // Toggle pin state\n                if (pwm_pin_states[i] == 0) {\n                    port_data |= (1 << pins[i]);\n                } else {\n                    port_data &= ~(1 << pins[i]);\n                }\n                // Set tick count for next transition\n                pwm_tick_counts[i] = pwm_periods[i] / 2;\n                // Toggle pin state\n                pwm_pin_states[i] = !pwm_pin_states[i];\n            } else {\n                pwm_tick_counts[i]--;\n            }\n        }\n    }\n    // Store port data into DMA buffer\n    dma_buffer[dma_buffer_pos] = port_data;\n    dma_buffer_pos++;\n}\n", "CodeBleu_score": 36.739355661288705}, {"code": "void i2s_push_sample()    uint32_t mask = 1;\n    for (uint i = 0; i < NUM_PINS; i++) {\n        if (pwm_duty[i]) {\n            if (--pwm_tick[i] == 0) {\n                pwm_tick[i] = pwm_period[i];\n                pwm_state[i] = !pwm_state[i];\n            }\n        }\n        if (pwm_state[i]) {\n            pwm_port_data |= mask;\n        } else {\n            pwm_port_data &= ~mask;\n        }\n        mask <<= 1;\n    }\n    pwm_dma_data[pwm_dma_index] = pwm_port_data;\n    pwm_dma_index = (pwm_dma_index + 1) % PWM_DMA_BUF_LEN;\n}\n", "CodeBleu_score": 30.8662766198598}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)    if (timer_num >= NUM_HW_TIMERS) {\n        return 0;\n    }\n    return timers[timer_num].counter;\n}\n", "CodeBleu_score": 20.89534691046317}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)    hal_timer_t count;\n    switch (timer_num) {\n        case 0:\n            count = TMR0;\n            break;\n        case 1:\n            count = TMR1;\n            break;\n        case 2:\n            count = TMR2;\n            break;\n        default:\n            count = 0;\n            break;\n    }\n    return count;\n}\n", "CodeBleu_score": 28.41371380894615}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)    // Check if the timer number is valid\n    if (timer_num >= NUM_HW_TIMERS) {\n        return 0;\n    }\n\n    // Retrieve the timer configuration\n    const timer_cfg_t *timer_cfg = &timer_config[timer_num];\n\n    // Fetch the current counter value from the timer\n    hal_timer_t count = timer_cfg->timer_regs->CNT;\n\n    // Return the counter value\n    return count;\n}\n", "CodeBleu_score": 41.62514123586263}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  while (size_t len = min(size, EEPROM.length() - pos)) {\n    uint8_t *buf = writing ? value : EEPROM.getDataPtr();\n    uint8_t *cur = EEPROM.getDataPtr() + pos;\n    while (len--) {\n      uint8_t v = eeprom_read_byte(cur++);\n      if (writing) *value++ = v;\n      crc16(crc, &v, 1);\n    }\n    pos += size - len;\n    if (!writing) break;\n  }\n  return false;\n}\n", "CodeBleu_score": 48.519212157222725}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)    while (size_t(pos) + size > EEPROM.length()) {\n        crc16(crc, 0);\n        if (writing) {\n            *value++ = 0;\n        } else {\n            ++pos;\n        }\n    }\n\n    uint8_t * const p = EEPROM.getDataPtr() + pos;\n    pos += size;\n    // maybe align reads (if size > 1)\n    while (size) {\n        uint8_t v = eeprom_read_byte(p);\n        crc16(crc, v);\n        if (writing) {\n            *value++ = v;\n        }\n        p++;\n        size--;\n    }\n    return false;\n}\n", "CodeBleu_score": 40.67124618584389}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  for (size_t i = 0; i < size; ++i) {\n    uint8_t c = EEPROM.read(pos);\n    if (writing) {\n      *value = c;\n      ++value;\n    }\n    crc16(crc, &c, 1);\n    ++pos;\n  }\n  return false;\n}\n", "CodeBleu_score": 63.13093734717378}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    if (sdio_handle == NULL || src == NULL) {\n        return false;\n    }\n\n    int retries = 0;\n    while (sdio_write(sdio_handle, block, src, 512) != 0) {\n        retries++;\n        if (retries >= 10) {\n            printf(\"SDIO_WriteBlock: Failed to write block %d\\n\", block);\n            return false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 32.59581024155461}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    assert(sdio_handle != NULL);\n    assert(src != NULL);\n\n    bool success = false;\n    for (int i = 0; i < SDIO_WRITE_RETRIES; i++) {\n        if (SDIO_WriteBlockRaw(block, src) == SD_OK) {\n            success = true;\n            break;\n        }\n    }\n\n    if (!success) {\n        printf(\"SDIO_WriteBlock failed\\n\");\n    }\n\n    return success;\n}\n", "CodeBleu_score": 34.33037564690944}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    assert(sdio_handle);\n    assert(src);\n\n    int retries = 0;\n    while (SDIO_WriteBlock_DMA(block, src) != true) {\n        if (retries++ >= SDIO_WRITE_RETRIES) {\n            printf(\"SDIO_WriteBlock failed\\n\");\n            return false;\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 27.900426596507987}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)    if (timer_num == TIMER_TEMP) {\n        // Set the prescaler to the desired value\n        TIMER_TEMP_PRESCALE = frequency;\n        // Set the callback priority for temperature\n        TIMER_TEMP_CALLBACK_PRIORITY = 2;\n        // Start the timer\n        TIMER_TEMP_START = 1;\n    } else if (timer_num == TIMER_STEP) {\n        // Set the prescaler to the desired value\n        TIMER_STEP_PRESCALE = frequency;\n        // Set the callback priority for stepper\n        TIMER_STEP_CALLBACK_PRIORITY = 1;\n        // Start the timer\n        TIMER_STEP_START = 1;\n    } else {\n        // Invalid timer channel\n        assert(0);\n    }\n}\n", "CodeBleu_score": 26.82412715389085}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)    switch (timer_num) {\n        case TIMER_CHANNEL_TEMP:\n            TIMER_init_timer(TIMER_TEMP, frequency, TIMER_PRESCALE_TEMP);\n            TIMER_set_callback(TIMER_TEMP, timer_callback_temp);\n            TIMER_set_callback_priority(TIMER_TEMP, TIMER_CALLBACK_PRIORITY_TEMP);\n            break;\n        case TIMER_CHANNEL_STEP:\n            TIMER_init_timer(TIMER_STEP, frequency, TIMER_PRESCALE_STEP);\n            TIMER_set_callback(TIMER_STEP, timer_callback_step);\n            TIMER_set_callback_priority(TIMER_STEP, TIMER_CALLBACK_PRIORITY_STEP);\n            break;\n        default:\n            assert(false);\n    }\n}\n", "CodeBleu_score": 27.748698538716827}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)    switch (timer_num) {\n    case TIMER_STEPPER:\n        timer_start(timer_num, frequency, STEPPER_TIMER_PRESCALE, STEPPER_TIMER_PRIORITY);\n        break;\n    case TIMER_TEMP:\n        timer_start(timer_num, frequency, TEMP_TIMER_PRESCALE, TEMP_TIMER_PRIORITY);\n        break;\n    default:\n        // Invalid timer channel\n        assert_param(0);\n    }\n}\n", "CodeBleu_score": 24.32210482963998}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start()  if (!file) {\n    file = fopen(filename, \"r+\");\n\n    if (!file) {\n      file = fopen(filename, \"w+\");\n\n      if (!file) {\n        return false;\n      }\n    }\n  }\n\n  if (file) {\n    fseek(file, 0, SEEK_END);\n    int32_t file_size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    if (file_size != EEPROM_SIZE) {\n      memset(buffer, erase_byte, EEPROM_SIZE);\n    }\n\n    if (file_size > EEPROM_SIZE) {\n      ftruncate(fileno(file), EEPROM_SIZE);\n    }\n\n    if (file_size > 0) {\n      fread(buffer, EEPROM_SIZE, 1, file);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n", "CodeBleu_score": 41.76245782583321}, {"code": "bool PersistentStore::access_start()  if (!file) {\n    return false;\n  }\n\n  size_t actual_size = file.size();\n\n  if (actual_size < EEPROM_SIZE) {\n    memset(eeprom_data, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n  } else {\n    file.read(eeprom_data, EEPROM_SIZE);\n  }\n\n  file.close();\n  return true;\n}\n", "CodeBleu_score": 22.40604471048005}, {"code": "bool PersistentStore::access_start()  if (!file) {\n    file = fopen(filename, \"r+\");\n    if (!file) {\n      file = fopen(filename, \"w+\");\n      if (!file) {\n        return false;\n      }\n    }\n  }\n  if (file) {\n    fseek(file, 0, SEEK_END);\n    long fsize = ftell(file);\n    fseek(file, 0, SEEK_SET);\n    if (fsize < EEPROM_SIZE) {\n      memset(buffer, EEPROM_ERASED_BYTE, EEPROM_SIZE);\n    } else {\n      fread(buffer, 1, EEPROM_SIZE, file);\n    }\n    fclose(file);\n    file = nullptr;\n  } else {\n    return false;\n  }\n  return true;\n}\n", "CodeBleu_score": 43.376307928294686}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t i;\n    uint8_t r = 0;\n    uint8_t bit;\n\n    for (i = 0; i < 8; i++) {\n        bit = b & 0x80;\n        b <<= 1;\n        HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, bit ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n        bit = HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN);\n        r <<= 1;\n        r |= bit;\n    }\n    HAL_Delay(1);\n    return r;\n}\n", "CodeBleu_score": 42.99367161029719}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t i;\n    uint8_t r = 0;\n    for (i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n        r <<= 1;\n        if (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET) {\n            r |= 0x01;\n        }\n        b <<= 1;\n    }\n    HAL_Delay(1);\n    return r;\n}\n", "CodeBleu_score": 41.93628991583578}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t r = 0;\n    for (int i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_CLK_GPIO_Port, SPI_CLK_Pin, GPIO_PIN_SET);\n        r = (r << 1) | (HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) == GPIO_PIN_SET);\n        b <<= 1;\n    }\n    HAL_Delay(1);\n    return r;\n}\n", "CodeBleu_score": 41.96582353330038}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)  /* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}\n", "CodeBleu_score": 81.27072745508528}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)    uint32_t tmpreg = 0;\n\n    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        /* Enable the selected AHB peripheral clock */\n        tmpreg = RCC->AHBENR;\n        tmpreg |= RCC_AHBPeriph;\n        RCC->AHBENR = tmpreg;\n    } else {\n        /* Disable the selected AHB peripheral clock */\n        tmpreg = RCC->AHBENR;\n        tmpreg &= ~RCC_AHBPeriph;\n        RCC->AHBENR = tmpreg;\n    }\n}\n", "CodeBleu_score": 68.32903052717842}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)  uint32_t tmpreg = 0;\n\n  /* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n  tmpreg = RCC->AHBENR;\n\n  if (NewState != DISABLE) {\n    /* Enable the selected AHB peripheral clock */\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    /* Disable the selected AHB peripheral clock */\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}\n", "CodeBleu_score": 76.11715708257447}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  // If no parity error occurs, read the byte and store it in the receive buffer if there is space available\n  if (!obj->parity_error) {\n    uint8_t data = obj->peripheral->DR;\n    if (!obj->_rx_buffer_overflow) {\n      obj->_rx_buffer_head = (obj->_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;\n      obj->_rx_buffer[obj->_rx_buffer_head] = data;\n      // If the head pointer is equal to the tail pointer, the buffer is full\n      if (obj->_rx_buffer_head == obj->_rx_buffer_tail) {\n        // Set the buffer overflow flag\n        obj->_rx_buffer_overflow = true;\n      }\n    }\n  }\n  // Calculate the next buffer index\n  obj->_rx_buffer_next = (obj->_rx_buffer_next + 1) % SERIAL_RX_BUFFER_SIZE;\n  // Update the head pointer\n  obj->_rx_buffer_head = obj->_rx_buffer_next;\n  // If enabled, update the emergency parser with the received byte\n  if (obj->emergency_parser) {\n    obj->emergency_parser->update(data);\n  }\n}\n", "CodeBleu_score": 40.45168653068689}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  // If the receive buffer is full, there's nothing we can do to receive more data.\n  if (rx_buffer_head == RX_BUFFER_SIZE)\n    return;\n\n  // If we get here, there's space in the buffer so we read the byte and\n  // store it in the buffer.\n  rx_buffer[rx_buffer_head] = obj->uart->DR;\n  if (obj->uart->ISR & USART_ISR_PE)\n    rx_buffer[rx_buffer_head] |= 0x80; // parity error\n  rx_buffer_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n\n  // If the emergency parser is enabled, update it with the received byte.\n  if (emergency_state != EMERGENCY_STATE_DISABLED)\n    emergency_parser(rx_buffer[rx_buffer_head]);\n}\n", "CodeBleu_score": 32.65090833723844}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  if (obj->is_parity_error) return;\n  if (obj->rx_buffer_head == obj->rx_buffer_tail) {\n    // Buffer overflow\n    obj->rx_buffer_overflow = true;\n    return;\n  }\n  // Store byte in buffer.\n  uint8_t data = obj->uart.RDR;\n  obj->rx_buffer[obj->rx_buffer_head] = data;\n  if (obj->rx_buffer_head >= obj->rx_buffer_size)\n    obj->rx_buffer_head = 0;\n  else\n    obj->rx_buffer_head++;\n  // Update emergency parser\n  if (obj->emergency_state == STATE_DATA) {\n    *obj->emergency_byte++ = data;\n    if (obj->emergency_byte >= obj->emergency_buffer + obj->emergency_size)\n      obj->emergency_byte = obj->emergency_buffer;\n  }\n}\n", "CodeBleu_score": 34.35842254249392}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)    if (timer_num == MF_TIMER_STEP) {\n        if (step_timer.is_initialized && !step_timer.has_interrupt) {\n            step_timer.has_interrupt = true;\n            attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, RISING);\n        }\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (temp_timer.is_initialized && !temp_timer.has_interrupt) {\n            temp_timer.has_interrupt = true;\n            attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, RISING);\n        }\n    }\n}\n", "CodeBleu_score": 34.703234880064535}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)    if (timer_num == MF_TIMER_STEP) {\n        if (!is_step_timer_initialized) {\n            return;\n        }\n        if (is_step_timer_interrupt_attached) {\n            return;\n        }\n        attachInterrupt(digitalPinToInterrupt(STEP_TIMER_INTERRUPT_PIN), Step_Handler, CHANGE);\n        is_step_timer_interrupt_attached = true;\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (!is_temp_timer_initialized) {\n            return;\n        }\n        if (is_temp_timer_interrupt_attached) {\n            return;\n        }\n        attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_INTERRUPT_PIN), Temp_Handler, CHANGE);\n        is_temp_timer_interrupt_attached = true;\n    }\n}\n", "CodeBleu_score": 29.329480572679877}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)    if (timer_num == MF_TIMER_STEP) {\n        if (timer_step_initialized) {\n            if (!timer_step_interrupt_attached) {\n                attachInterrupt(digitalPinToInterrupt(MF_TIMER_STEP_PIN), Step_Handler, CHANGE);\n                timer_step_interrupt_attached = true;\n            }\n        }\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (timer_temp_initialized) {\n            if (!timer_temp_interrupt_attached) {\n                attachInterrupt(digitalPinToInterrupt(MF_TIMER_TEMP_PIN), Temp_Handler, CHANGE);\n                timer_temp_interrupt_attached = true;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 30.878575436438066}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tn, m := len(s), len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif n < m {\n\t\treturn -1\n\t}\n\n\thashSubstring := Hash(sep)\n\tlast := Substring(s, n-m)\n\thashLast := Hash(last)\n\n\tif hashLast == hashSubstring && Equal(last, sep) {\n\t\treturn n - m\n\t}\n\n\thash := Hash(s[:m])\n\trabinKarp := RabinKarp(sep)\n\n\tfor i := m; i < n; {\n\t\thash = rabinKarp.Roll(hash, s[i], s[i-m])\n\t\ti++\n\n\t\tif hash == hashSubstring && Equal(s[i-m:i], sep) {\n\t\t\treturn i - m\n\t\t}\n\t}\n\n\treturn -1\n}", "CodeBleu_score": 37.363371575131765}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tn, m := len(s), len(sep)\n\tif m == 0 {\n\t\treturn n\n\t}\n\tif n < m {\n\t\treturn -1\n\t}\n\n\thashSep := hash(sep)\n\n\tfor i := n - m; i >= 0; i-- {\n\t\tif hash(s[i:i+m]) == hashSep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n", "CodeBleu_score": 31.983657885897337}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\n\thashSubStr := hash(sep)\n\tlast := len(s) - len(sep)\n\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\thashSubStr := hash(s[i : i+len(sep)])\n\t\tif hashSubStr == hash(sep) && s[i:i+len(sep)] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n", "CodeBleu_score": 32.70402934632408}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.waitTxc = false\n}\n", "CodeBleu_score": 5.404276235866588}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.waitTxc = false\n}\n", "CodeBleu_score": 5.404276235866588}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.waitTxc = false\n\tusbcdc.txBuf.tail = usbcdc.txBuf.head\n}\n", "CodeBleu_score": 20.753730822164695}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.Control.SetBits(1 << I2C_CONTROL_START)\n\ti2c.Control.SetBits(1 << I2C_CONTROL_CLEAR_START)\n\n\tfor !i2c.Control.HasBits(1 << I2C_CONTROL_START_CLEARED) {\n\t}\n\n\ti2c.Data.Set(uint32(address) << 1)\n\tif !write {\n\t\ti2c.Data.SetBits(1 << I2C_DATA_READ)\n\t}\n\n\ti2c.Control.SetBits(1 << I2C_CONTROL_ENABLE)\n\tfor !i2c.Control.HasBits(1 << I2C_CONTROL_ENABLED) {\n\t}\n\n\ti2c.Control.SetBits(1 << I2C_CONTROL_CLEAR_START)\n}\n", "CodeBleu_score": 36.869604581518665}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.bus.CONTROL.SetBits(1 << i2c_CONTROL_ENABLE_Pos)\n\ti2c.bus.CONTROL.SetBits(1 << i2c_CONTROL_START_Pos)\n\ti2c.wait()\n\ti2c.bus.TXDATA.Set(uint32(address & 0x7F))\n\ti2c.bus.CONTROL.SetBits(1 << i2c_CONTROL_START_Pos)\n\tif write {\n\t\ti2c.bus.CONTROL.ClearBits(1 << i2c_CONTROL_READ_Pos)\n\t} else {\n\t\ti2c.bus.CONTROL.SetBits(1 << i2c_CONTROL_READ_Pos)\n\t}\n\ti2c.wait()\n}\n", "CodeBleu_score": 28.495933190788946}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.ctrl.SetBits(1 << i2c.ctrlRdWrNBit)\n\tif write {\n\t\ti2c.ctrl.ClearBits(1 << i2c.ctrlRdWrNBit)\n\t}\n\ti2c.txd.Set(address)\n\ti2c.ctrl.SetBits(1 << i2c.ctrlI2CENBit)\n\n\tfor !i2c.ctrl.HasBits(1 << i2c.ctrlI2CENBit) {\n\t}\n}\n", "CodeBleu_score": 29.384377702693428}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tstartAddr := f.blockSize * start\n\tendAddr := f.blockSize * (start + len)\n\n\t// Wait for any flash operations to complete.\n\tf.waitForReady()\n\n\t// Set the flash to erase mode.\n\tf.setEraseMode(true)\n\n\t// Erase each block in the specified range.\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\tf.writeWord(addr, f.eraseWord)\n\n\t\t// Wait until the flash is no longer busy.\n\t\tf.waitForReady()\n\t}\n\n\t// Set the flash back to read mode.\n\tf.setEraseMode(false)\n\n\treturn nil\n}", "CodeBleu_score": 30.0217303227001}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tstartAddr := f.blockSize * start\n\tendAddr := f.blockSize * (start + len)\n\n\t// Wait for any flash operations to complete.\n\tf.waitForReady()\n\n\t// Set flash to erase mode.\n\terr := f.setEraseMode()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Erase blocks in flash memory.\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\terr := f.eraseBlock(addr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Wait until flash is no longer busy.\n\tf.waitForReady()\n\n\t// Set flash back to read mode.\n\terr = f.setReadMode()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 37.76088275841055}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tstartAddr := f.blockSize * start\n\tendAddr := f.blockSize * (start + len)\n\t_, err := f.waitForAnyBusyController()\n\tif err != nil {\n\t\treturn err\n\t}\n\tf.setErase()\n\tfor i := startAddr; i < endAddr; i += f.blockSize {\n\t\tf.writeWord(f.eraseBlockCommand, i)\n\t\tf.waitForAnyBusyController()\n\t}\n\tf.setRead()\n\treturn nil\n}\n", "CodeBleu_score": 33.70616561868221}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 {\n\t\treturn 0, errWriteAtNegativeOffset\n\t}\n\tif off >= int64(len(f.data)) {\n\t\treturn 0, io.EOF\n\t}\n\taddr := uint32(off)\n\tn = len(p)\n\tif n+int(addr) > len(f.data) {\n\t\tn = len(f.data) - int(addr)\n\t}\n\tif n == 0 {\n\t\treturn\n\t}\n\tp = pad(p[:n], f.writeSize)\n\n\tf.enableWrite()\n\tdefer f.disableWrite()\n\n\tfor len(p) > 0 {\n\t\terr = f.writeBlock(uint32(addr), p)\n\t\tif err != nil {\n\t\t\tn = len(p)\n\t\t\treturn\n\t\t}\n\t\taddr += f.writeSize\n\t\tp = p[f.writeSize:]\n\t}\n\treturn\n}", "CodeBleu_score": 30.912956389519486}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif uint32(len(p))+uint32(off) > f.size {\n\t\treturn 0, errWriteAtOutOfBounds\n\t}\n\n\taddr := f.startAddress + uint32(off)\n\tbuf := make([]uint32, f.writeSize/4)\n\tfor total := 0; n < len(p); {\n\t\tremaining := len(p) - n\n\t\tif remaining < len(buf)*4 {\n\t\t\tbuf = buf[:remaining/4]\n\t\t}\n\n\t\tbinary.Read(bytes.NewReader(p[n:]), binary.LittleEndian, buf)\n\n\t\tf.waitForReady()\n\t\tf.writeBlock(addr+uint32(n), buf)\n\t\tf.waitForReady()\n\n\t\tn += len(buf) * 4\n\t}\n\n\treturn n, nil\n}\n", "CodeBleu_score": 30.467316991431453}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\taddr := uintptr(unsafe.Pointer(f.ptr)) + uintptr(off)\n\tif addr < uintptr(unsafe.Pointer(f.ptr)) || addr >= uintptr(unsafe.Pointer(f.ptr))+uintptr(f.size) {\n\t\treturn 0, errors.New(\"write beyond end of flash memory\")\n\t}\n\n\t// pad to write block size\n\tpad := make([]byte, f.writeBlockSize-len(p)%f.writeBlockSize)\n\tp = append(p, pad...)\n\n\t// enable write mode\n\tf.writeEnable()\n\n\t// write in blocks\n\tfor i := 0; i < len(p); i += f.writeBlockSize {\n\t\tf.writeBlock(addr+uintptr(i), p[i:i+f.writeBlockSize])\n\t\tf.waitForReady()\n\t}\n\n\treturn len(p), nil\n}\n", "CodeBleu_score": 31.100998592907814}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(fd2)\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 61.834335074371424}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\td, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tr, err := syscall.Fdopendir(d)\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(d)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\treturn uintptr(r), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 58.39678202530677}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tfd2, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\tfor {\n\t\tdir, err := syscall.Fdopendir(fd2)\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, \"\", err\n\t\t\t}\n\t\t\treturn uintptr(unsafe.Pointer(dir)), \"\", nil\n\t\t}\n\t}\n}", "CodeBleu_score": 61.834335074371424}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response)    const esp_partition_t *partition = esp_ota_get_running_partition();\n    uint32_t total_size = partition->size;\n    uint32_t ota_size = 0;\n    if (esp_ota_get_partition_description(partition, NULL, &ota_size) == ESP_OK) {\n        if (response) {\n            return total_size - ota_size;\n        } else {\n            return ota_size;\n        }\n    } else {\n        return 0;\n    }\n}\n", "CodeBleu_score": 45.915002637673005}, {"code": "static uint32_t sketchSize(sketchSize_t response)    const esp_partition_t *partition = esp_ota_get_running_partition();\n    if (partition == NULL) {\n        return 0;\n    }\n    if (response == FREE_SPACE) {\n        return partition->size - partition->used_app_size;\n    }\n    return partition->used_app_size;\n}\n", "CodeBleu_score": 33.681925582788}, {"code": "static uint32_t sketchSize(sketchSize_t response)  const esp_partition_t *partition = esp_ota_get_running_partition();\n  if (partition == NULL) {\n    return 0;\n  }\n  uint32_t size = partition->size;\n  if (response) {\n    const esp_partition_t *updatePartition = esp_ota_get_next_update_partition(NULL);\n    if (updatePartition != NULL) {\n      size -= updatePartition->size;\n    }\n  }\n  return size;\n}\n", "CodeBleu_score": 43.9584303359194}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)    // Calculate the number of sectors needed for the disk\n    const uint32_t disk_sectors = (sizeof(msc_disk_t) + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    // Allocate memory for the disk\n    msc_disk_t *disk = (msc_disk_t *)malloc(disk_sectors * SECTOR_SIZE);\n    if (!disk) {\n        // Log an error if allocation fails\n        LOG_ERR(\"msc_update_setup_disk: Failed to allocate memory for disk\");\n        return false;\n    }\n\n    // Set up the boot sector\n    msc_boot_sector_t *boot_sector = &disk->boot_sector;\n    memset(boot_sector, 0, sizeof(*boot_sector));\n    boot_sector->sector_size = SECTOR_SIZE;\n    boot_sector->sectors_per_cluster = 1;\n    boot_sector->reserved_sectors = 1;\n    boot_sector->fat_count = 2;\n    boot_sector->root_entries = 0;\n    boot_sector->sectors_per_fat = disk_sectors - boot_sector->reserved_sectors;\n    boot_sector->media_descriptor = 0xF8;\n    boot_sector->sectors_per_track = 63;\n    boot_sector->heads = 255;\n    boot_sector->hidden_sectors = 0;\n    boot_sector->total_sectors = disk_sectors;\n    boot_sector->sectors_per_fat = disk_sectors - boot_sector->reserved_sectors;\n    boot_sector->drive_number = 0x80;\n    boot_sector->extended_boot_signature = 0x29;\n    boot_sector->volume_serial_number = serial_number;\n    strncpy(boot_sector->volume_label, volume_label, sizeof(boot_sector->volume", "CodeBleu_score": 28.013688836687393}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)    int32_t disk_sectors = MSC_UPDATE_DISK_SIZE / MSC_UPDATE_DISK_SECTOR_SIZE;\n    int32_t disk_size = disk_sectors * MSC_UPDATE_DISK_SECTOR_SIZE;\n    msc_update_disk = (uint8_t *) malloc(disk_size);\n    if (!msc_update_disk) {\n        LOG_ERR(\"failed to allocate memory for RAM disk\");\n        return false;\n    }\n    LOG_INF(\"allocated %d bytes for RAM disk\", disk_size);\n\n    // Set up the boot sector\n    struct msc_update_boot_sector *boot_sector = (struct msc_update_boot_sector *) msc_update_disk;\n    memset(boot_sector, 0, sizeof(struct msc_update_boot_sector));\n    boot_sector->jump_code[0] = 0xEB;\n    boot_sector->jump_code[1] = 0x58;\n    boot_sector->jump_code[2] = 0x90;\n    strncpy(boot_sector->oem_name, \"ZMK FW\", sizeof(boot_sector->oem_name));\n    boot_sector->bytes_per_sector = MSC_UPDATE_DISK_SECTOR_SIZE;\n    boot_sector->sectors_per_cluster = 1;\n    boot_sector->reserved_sectors = 1;\n    boot_sector->num_fats = 2;\n    boot_sector->num_dirents = 0;\n    boot_sector->media_descriptor = 0xF8;\n    boot_sector->sectors_per_fat = disk_sectors / boot_sector->bytes_per_sector;\n    boot_sector->sectors_per_track = 63;\n    boot_sector->num_heads = 255;\n    boot_sector->hidden_sectors = disk_sectors -", "CodeBleu_score": 26.56503111694417}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)    uint32_t disk_sectors;\n    uint32_t disk_size;\n    uint32_t fat_size;\n    uint32_t fat_sectors;\n    uint32_t root_dir_sectors;\n    uint32_t data_sectors;\n\n    // Calculate the number of disk sectors needed for the volume label and serial number\n    disk_sectors = 1 + strlen(volume_label) / 11 + 1 + sizeof(serial_number) / 4;\n\n    // Calculate the disk size in bytes\n    disk_size = disk_sectors * SECTOR_SIZE;\n\n    // Allocate memory for the RAM disk\n    ramdisk = (uint8_t *)malloc(disk_size);\n    if (ramdisk == NULL) {\n        // Log an error if memory allocation fails\n        log_error(\"Failed to allocate memory for RAM disk\");\n        return false;\n    }\n\n    // Calculate the size of the FAT in bytes\n    fat_size = disk_sectors * sizeof(uint32_t);\n\n    // Calculate the number of sectors needed for the FAT\n    fat_sectors = (fat_size + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    // Calculate the number of sectors needed for the root directory\n    root_dir_sectors = (sizeof(msc_file_t) * 2 + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n    // Calculate the number of sectors needed for the data\n    data_sectors = disk_sectors - fat_sectors - root_dir_sectors;\n\n    // Set up the boot sector\n    memset(ramdisk, 0, SECTOR_SIZE);\n    memcpy(ramdisk + BOOT_SECTOR_VOLUME_LABEL_OFFSET, volume_label, strlen(volume_label));\n    *(uint32_t *)(ramdisk + BOOT_SECTOR_SERIAL_NUMBER_OFFSET) = serial_number;\n    *(uint16_t *)(ramdisk + BOOT_SECT", "CodeBleu_score": 38.93871844746328}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    // Check if the given offset is aligned with the flash sector size\n    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        // If not, log an error message and return an error code\n        ESP_LOGE(TAG, \"Offset must be aligned with flash sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    // Erase the corresponding sector before writing new data\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        // If the erase operation fails, log an error message and return the error code\n        ESP_LOGE(TAG, \"Failed to erase partition\");\n        return err;\n    }\n\n    // Write the data to the specified offset\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        // If the write operation fails, log an error message and return the error code\n        ESP_LOGE(TAG, \"Failed to write partition\");\n        return err;\n    }\n\n    // Return the result of the write operation\n    return err;\n}\n", "CodeBleu_score": 52.30424082387605}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    esp_err_t ret = ESP_OK;\n\n    // Check if the offset is aligned with the flash sector size\n    if (offset % partition->size != 0) {\n        // If not aligned, erase the corresponding sector\n        ret = esp_partition_erase_range(partition, offset, partition->size);\n        if (ret != ESP_OK) {\n            // Log an error message and return the error code\n            ESP_LOGE(TAG, \"Failed to erase partition %s at offset %08x\", partition->label, offset);\n            return ret;\n        }\n    }\n\n    // Write the data to the specified offset\n    ret = esp_partition_write(partition, offset, data, size);\n    if (ret != ESP_OK) {\n        // Log an error message and return the error code\n        ESP_LOGE(TAG, \"Failed to write partition %s at offset %08x\", partition->label, offset);\n    }\n\n    return ret;\n}\n", "CodeBleu_score": 52.25157433991727}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    esp_err_t err;\n    uint32_t sector_size = partition->size / partition->sector_count;\n    uint32_t sector_start = offset / sector_size * sector_size;\n    uint32_t sector_end = (offset + size - 1) / sector_size * sector_size;\n\n    if (sector_start != sector_end) {\n        err = esp_partition_erase_range(partition, sector_start, sector_end - sector_start + 1);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase partition %s at offset 0x%x\", partition->label, sector_start);\n            return err;\n        }\n    }\n\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write to partition %s at offset 0x%x\", partition->label, offset);\n    }\n\n    return err;\n}\n", "CodeBleu_score": 51.81482474233703}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t i;\n    size_t len;\n    unsigned char c;\n    unsigned char c_accum;\n    unsigned char c_alpha;\n\n    len = 0;\n    c_accum = 0;\n    c_alpha = 0;\n    for (i = 0; i < strlen(in); i++) {\n        c = in[i];\n        if (c >= '0' && c <= '9') {\n            c_accum = (c_accum << 4) | (c - '0');\n            c_alpha = 1;\n        } else if ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) {\n            c_accum = (c_accum << 4) | (c - 'A' + 10);\n            c_alpha = 1;\n        } else {\n            if (c_alpha) {\n                if (len >= maxlen) {\n                    return len;\n                }\n                out[len] = c_accum;\n                len++;\n            }\n            c_accum = 0;\n            c_alpha = 0;\n        }\n    }\n    if (c_alpha) {\n        if (len >= maxlen) {\n            return len;\n        }\n        out[len] = c_accum;\n        len++;\n    }\n    return len;\n}\n", "CodeBleu_score": 39.76618898675761}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t i = 0;\n    size_t len = strlen(in);\n    if (len % 2) {\n        return 0;\n    }\n    if (maxlen < (len / 2)) {\n        return 0;\n    }\n    while (i < len) {\n        char c = in[i];\n        int value = 0;\n        if (c >= '0' && c <= '9') {\n            value = (c - '0');\n        } else if (c >= 'A' && c <= 'F') {\n            value = (10 + (c - 'A'));\n        } else if (c >= 'a' && c <= 'f') {\n            value = (10 + (c - 'a'));\n        } else {\n            return 0;\n        }\n        out[i / 2] = value << 4;\n        ++i;\n        c = in[i];\n        if (c >= '0' && c <= '9') {\n            value = (c - '0');\n        } else if (c >= 'A' && c <= 'F') {\n            value = (10 + (c - 'A'));\n        } else if (c >= 'a' && c <= 'f') {\n            value = (10 + (c - 'a'));\n        } else {\n            return 0;\n        }\n        out[i / 2] |= value;\n        ++i;\n    }\n    return len / 2;\n}\n", "CodeBleu_score": 46.238359763771044}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t i = 0;\n    size_t j = 0;\n    size_t len = strlen(in);\n    while (i < len && j < maxlen) {\n        if (in[i] >= '0' && in[i] <= '9') {\n            out[j] = (in[i] - '0') << 4;\n        } else if (in[i] >= 'A' && in[i] <= 'F') {\n            out[j] = (in[i] - 'A' + 10) << 4;\n        } else if (in[i] >= 'a' && in[i] <= 'f') {\n            out[j] = (in[i] - 'a' + 10) << 4;\n        } else {\n            i++;\n            continue;\n        }\n        i++;\n        if (i < len && in[i] >= '0' && in[i] <= '9') {\n            out[j] |= in[i] - '0';\n        } else if (i < len && in[i] >= 'A' && in[i] <= 'F') {\n            out[j] |= in[i] - 'A' + 10;\n        } else if (i < len && in[i] >= 'a' && in[i] <= 'f') {\n            out[j] |= in[i] - 'a' + 10;\n        } else {\n            break;\n        }\n        i++;\n        j++;\n    }\n    return j;\n}\n", "CodeBleu_score": 38.55569869388345}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void)    if (tx_ring_buffer == NULL || tx_lock == NULL) {\n        return 0;\n    }\n\n    if (xSemaphoreTake(tx_lock, TX_RING_BUFFER_LOCK_TIMEOUT) != pdTRUE) {\n        return 0;\n    }\n\n    size_t free_size = tx_ring_buffer->free();\n    xSemaphoreGive(tx_lock);\n    return free_size;\n}\n", "CodeBleu_score": 71.74268359116044}, {"code": "int HWCDC::availableForWrite(void)  if (tx_ring_buffer == NULL || tx_ring_buffer_lock == NULL) {\n    return 0;\n  }\n\n  if (xSemaphoreTake(tx_ring_buffer_lock, TX_RING_BUFFER_LOCK_TIMEOUT) == pdTRUE) {\n    int free_size = tx_ring_buffer->availableForWrite();\n    xSemaphoreGive(tx_ring_buffer_lock);\n    return free_size;\n  }\n\n  return 0;\n}\n", "CodeBleu_score": 60.7726750104091}, {"code": "int HWCDC::availableForWrite(void)\tint ret = 0;\n\tret = xSemaphoreTake(tx_ringbuffer_lock, 10);\n\tif (ret == pdTRUE) {\n\t\tret = uart_ringbuffer_available_for_write(&tx_ringbuffer);\n\t\txSemaphoreGive(tx_ringbuffer_lock);\n\t\treturn ret;\n\t} else {\n\t\treturn 0;\n\t}\n}\n", "CodeBleu_score": 39.089541882956546}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    lock();\n    _onReceiveCB = function;\n    _rxTimeoutOnly = onlyOnTimeout;\n    if (function) {\n        // set fifo full threshold\n        uint8_t threshold = _rxFifo.capacity() - 1;\n        if (threshold > MAX_RX_FIFO_THRESHOLD) {\n            threshold = MAX_RX_FIFO_THRESHOLD;\n        }\n        _uart->UART_IER = UART_IER_RXFNEIE | (threshold << UART_IER_RXFNEIE_Pos);\n        if (!_rxEventTask) {\n            _rxEventTask = new (std::nothrow) EventTask(this);\n            if (_rxEventTask) {\n                _rxEventTask->setCallback([](void* context) -> void {\n                    ((HardwareSerial*)context)->_onReceiveEvent();\n                });\n            }\n        }\n    } else {\n        _uart->UART_IER = UART_IER_RXFNEIE | (0 << UART_IER_RXFNEIE_Pos);\n    }\n    unlock();\n}\n", "CodeBleu_score": 42.12170014838788}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    std::lock_guard<std::recursive_mutex> lock(_mutex);\n    _onReceiveCB = function;\n    _onlyOnTimeout = onlyOnTimeout;\n    if(_onReceiveCB) {\n        _fifoFullThreshold = (_rx_buffer_size >> 1);\n        if(!_event_task_handle) {\n            _event_task_handle = xTaskCreate([](void* arg) {\n                auto* serial = static_cast<HardwareSerial*>(arg);\n                while(true) {\n                    if(ulTaskNotifyTake(pdTRUE, portMAX_DELAY) > 0) {\n                        if(serial->_onReceiveCB) {\n                            serial->_onReceiveCB();\n                        }\n                    }\n                }\n            }, \"serialEventTask\", 2048, this, 1, &_event_task_handle);\n        }\n    }\n}\n", "CodeBleu_score": 40.6437543417433}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    lock();\n    _onReceiveCB = function;\n    if (onlyOnTimeout) {\n        _rxTimeout = true;\n    } else {\n        _rxTimeout = false;\n    }\n    if (function != nullptr) {\n        _rxFIFOfullThreshold = UART_FIFO_FULL_THRESHOLD;\n        if (!_rxEventTask) {\n            _rxEventTask = new Task(\n                    \"HardwareSerial::onReceive\",\n                    [this]() {\n                        lock();\n                        while (true) {\n                            if (_onReceiveCB) {\n                                _onReceiveCB();\n                            }\n                            unlock();\n                            Task::yield();\n                        }\n                    },\n                    Task::PRIORITY_HIGH,\n                    1024,\n                    1);\n        }\n    }\n    unlock();\n}\n", "CodeBleu_score": 46.802945932896954}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)    if (length < 1) return 0;\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) break;\n        *buffer++ = (char)c;\n        index++;\n    }\n    return index; // return number of characters, not including null terminator\n}\n", "CodeBleu_score": 86.66340623857461}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)  if (length < 1) return 0;\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0 || c == terminator) break;\n    *buffer++ = (char)c;\n    index++;\n  }\n  return index; // return number of characters, not including null terminator\n}\n", "CodeBleu_score": 85.54418332987647}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)    if (length < 1) return 0;\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) break;\n        *buffer++ = (char)c;\n        index++;\n    }\n    return index; // return number of characters, not including null terminator\n}\n", "CodeBleu_score": 86.66340623857461}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  if (pin >= NUM_DIGITAL_PINS) {\n    log_e(\"Tone pin is not valid\");\n    return;\n  }\n\n  log_d(\"Tone pin: %d\", pin);\n  log_d(\"Tone frequency: %d\", frequency);\n  log_d(\"Tone duration: %d\", duration);\n\n  if (tone_is_available(pin)) {\n    log_d(\"Tone pin %d is available\", pin);\n    tone_init(pin);\n    send_tone_command(TONE_START, pin, frequency, duration);\n  } else {\n    log_e(\"Tone pin %d is already in use, please stop the current tone on this pin first\", pin);\n  }\n}\n", "CodeBleu_score": 41.52428329821372}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)    LOG_DEBUG(\"Tone on pin %d at %d Hz for %d ms\", pin, frequency, duration);\n    if (pin >= NUM_PINS) {\n        LOG_ERROR(\"Invalid pin %d\", pin);\n        return;\n    }\n    if (pin_state[pin] == PIN_STATE_IDLE) {\n        pin_state[pin] = PIN_STATE_ACTIVE;\n        queue_command(CMD_TONE_START, pin, frequency, duration);\n    } else {\n        LOG_ERROR(\"Pin %d is already in use, stop the current tone first\", pin);\n    }\n}\n", "CodeBleu_score": 42.94062202944687}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)    // Log the pin, frequency, and duration\n    Serial.print(\"Tone on pin \");\n    Serial.print(pin);\n    Serial.print(\" with frequency \");\n    Serial.print(frequency);\n    Serial.print(\" and duration \");\n    Serial.println(duration);\n\n    // Check if the pin is available or already in use\n    if (pin == TONE_PIN_UNAVAILABLE) {\n        Serial.println(\"Pin is unavailable.\");\n    } else if (pin == TONE_PIN_IN_USE) {\n        Serial.println(\"Pin is already in use. Stop the current tone first.\");\n    } else {\n        // Initialize the tone and send a start command with the pin, frequency, and duration to a queue\n        initTone(pin);\n        toneStart(pin, frequency, duration);\n    }\n}\n", "CodeBleu_score": 37.25064435528665}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled)\tif (enabled) {\n\t\tif (usb_version < 0x0210) {\n\t\t\tusb_version = 0x0210;\n\t\t\tusb_version_changed = true;\n\t\t}\n\t\twebUSB_enabled = true;\n\t}\n\telse {\n\t\twebUSB_enabled = false;\n\t}\n\treturn !usb_started;\n}\n", "CodeBleu_score": 53.283245193160525}, {"code": "bool ESPUSB::webUSB(bool enabled)  if (ESPUSB::usbStarted) {\n    if (enabled) {\n      usb_webusb_enable();\n    } else {\n      usb_webusb_disable();\n    }\n    return true;\n  } else {\n    ESPUSB::webUSBEnabled = enabled;\n    return false;\n  }\n}\n", "CodeBleu_score": 28.31947119705945}, {"code": "bool ESPUSB::webUSB(bool enabled)    if (enabled) {\n        if (!usb_started) {\n            web_usb_enabled = true;\n            if (usb_version < 0x0210) {\n                usb_version = 0x0210;\n            }\n            return true;\n        }\n    } else {\n        if (!usb_started) {\n            web_usb_enabled = false;\n            return true;\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 53.42731724559698}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX()    while (_rx_in_progress) {\n        int actual;\n\n        // Read from the bulk IN endpoint and store any errors\n        uint32_t result = tud_cdc_n_read(_itf, _rx_buffer, _rx_in_size);\n\n        // If the read was successful\n        if (result > 0) {\n            // Store the actual length of the data received\n            actual = result;\n\n            // Attempt to add the data to the receive queue\n            if (_rx_queue.full() || !_rx_queue.try_put((uint8_t*)_rx_buffer)) {\n                // If the queue is full or the data cannot be added, increment the overflow counter\n                _rx_overflow_error_count++;\n\n                // Trigger a console error if the number of overflows reaches the threshold\n                if (_rx_overflow_error_count > RX_QUEUE_OVERFLOW_ERROR_THRESHOLD) {\n                    printf(\"USB CDC RX queue overflow\\n\");\n                    _rx_overflow_error_count = 0;\n                }\n            }\n            // If the data was successfully added to the queue, trigger a receive event\n            _event_queue->call(mbed::callback(this, &USBCDC::event_callback), USBCDC_EVENT_RX_COMPLETE);\n        }\n    }\n}\n", "CodeBleu_score": 25.729886345979523}, {"code": "void USBCDC::_onRX()    uint8_t data[64];\n    uint32_t len = 0;\n    uint32_t dropped = 0;\n\n    while (tud_cdc_available()) {\n        uint32_t count = tud_cdc_read(data, sizeof(data));\n        for (uint32_t i = 0; i < count; i++) {\n            if (_rx_queue.try_put(data[i])) {\n                len++;\n            } else {\n                dropped++;\n            }\n        }\n    }\n\n    if (dropped) {\n        _rx_overflow.post(dropped);\n        MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER_USB, MBED_ERROR_CODE_USB_CDC_RX_OVERFLOW), \"USB CDC RX overflow\");\n    }\n\n    if (len) {\n        _rx_event.post(len);\n    }\n}\n", "CodeBleu_score": 33.64795538621001}, {"code": "void USBCDC::_onRX()    int32_t count = _rxBuff.remaining();\n    if (count > 0) {\n        count = _cdc.read(_rxBuff.getHead(), count);\n        if (count > 0) {\n            _rxBuff.push(count);\n            _rxBuff.notify_one();\n        }\n    }\n}\n", "CodeBleu_score": 9.943144421454663}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\tname := vars[\"name\"]\n\n\trobot, err := a.db.ReadRobot(name)\n\tif err != nil {\n\t\ta.log.WithFields(logrus.Fields{\"robot\": name, \"err\": err}).Warn(\"Failed to read robot.\")\n\t\ta.writeJSON(res, http.StatusNotFound, JSONError{Message: \"No robot with name \" + name + \" found.\"})\n\t\treturn\n\t}\n\n\tdevices := robot.Devices()\n\ta.writeJSON(res, http.StatusOK, devices)\n}\n", "CodeBleu_score": 35.94147119821957}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot_name\"]\n\trobot, err := a.db.ReadRobot(robotName)\n\tif err != nil {\n\t\ta.writeJSON(res, fmt.Sprintf(\"no robot with name %s exists\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\tdevices := []string{}\n\tfor _, d := range robot.Devices {\n\t\tdevices = append(devices, d.Name)\n\t}\n\ta.writeJSON(res, devices, http.StatusOK)\n}\n", "CodeBleu_score": 42.920983291171204}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\trobot, ok := a.db.GetRobot(robotName)\n\tif !ok {\n\t\ta.jsonError(res, http.StatusNotFound, fmt.Errorf(\"no robot with name %s\", robotName))\n\t\treturn\n\t}\n\tdevices := robot.GetDevices()\n\ta.writeJSON(res, http.StatusOK, devices)\n}", "CodeBleu_score": 25.603888984075475}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobot := strings.TrimPrefix(req.URL.Path, \"/robot/connections/\")\n\t_, ok := a.db.Load(robot)\n\tif !ok {\n\t\thttp.Error(res, \"no robot with that name exists\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections, err := a.db.Connections(robot)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(connections)\n}", "CodeBleu_score": 33.378945817264466}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := chi.URLParam(req, \"robotName\")\n\n\trobot, err := a.db.ReadRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections := make([]RobotConnection, len(robot.Connections))\n\tfor i, connection := range robot.Connections {\n\t\tconnections[i] = RobotConnection{\n\t\t\tName:       connection.Name,\n\t\t\tConnection: connection.Connection,\n\t\t}\n\t}\n\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 44.98666171362604}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := getRequestVar(req, \"robotName\")\n\trobot, ok := a.r.Robot(robotName)\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"no robot with name '%s' found\", robotName)))\n\t\treturn\n\t}\n\tres.WriteHeader(http.StatusOK)\n\tconnectionsJSON := []byte(\"[\")\n\tfirst := true\n\tfor _, c := range robot.Connections() {\n\t\tif !first {\n\t\t\tconnectionsJSON = append(connectionsJSON, []byte(\",\")...)\n\t\t} else {\n\t\t\tfirst = false\n\t\t}\n\t\tjsonBytes, err := json.Marshal(c)\n\t\tif err != nil {\n\t\t\ta.log.Error().Err(err).Str(\"robot\", robotName).Msg(\"unable to convert connection to json\")\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(fmt.Sprintf(\"unable to convert connection to json: %s\", err)))\n\t\t\treturn\n\t\t}\n\t\tconnectionsJSON = append(connectionsJSON, jsonBytes...)\n\t}\n\tconnectionsJSON = append(connectionsJSON, []byte(\"]\")...)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 43.63101929126225}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\tdevice, err := a.db.GetDeviceByName(robotName, deviceName)\n\tif err != nil {\n\t\ta.writeError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\"command\")\n\n\t_, err = device.ExecuteCommand(command)\n\tif err != nil {\n\t\ta.writeError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\ta.writeSuccess(res)\n}", "CodeBleu_score": 53.27702402850847}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\n\trobotName := vars[\"robotname\"]\n\tdeviceName := vars[\"devicename\"]\n\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\ta.writeError(res, http.StatusNotFound, fmt.Errorf(\"robot %s not found\", robotName))\n\t\treturn\n\t}\n\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err != nil {\n\t\ta.writeError(res, http.StatusNotFound, fmt.Errorf(\"device %s not found for robot %s\", deviceName, robotName))\n\t\treturn\n\t}\n\n\tcmd := &command{}\n\n\tjson.NewDecoder(req.Body).Decode(cmd)\n\n\t_, err = device.GetCommand(cmd.Name)\n\tif err != nil {\n\t\ta.writeError(res, http.StatusNotFound, fmt.Errorf(\"command %s not found for device %s on robot %s\", cmd.Name, deviceName, robotName))\n\t\treturn\n\t}\n\n\targs := make(map[string]interface{})\n\n\tfor _, arg := range cmd.Args {\n\t\targs[arg.Name] = arg.Value\n\t}\n\n\terr = device.Command(cmd.Name)(args)\n\tif err != nil {\n\t\ta.writeError(res, http.StatusInternalServerError, fmt.Errorf(\"command execution error: %s\", err))\n\t\treturn\n\t}\n\n\ta.writeSuccess(res, http.StatusOK, fmt.Sprintf(\"command %s executed successfully on device %s on robot %s\", cmd.Name, deviceName, robotName))\n}", "CodeBleu_score": 40.67833844578056}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\n\trobotName := vars[\"robotName\"]\n\tdeviceName := vars[\"deviceName\"]\n\n\trobot, err := a.findRobot(robotName)\n\tif err != nil {\n\t\ta.writeError(res, err)\n\t\treturn\n\t}\n\n\tdevice, err := robot.Device(deviceName)\n\tif err != nil {\n\t\ta.writeError(res, err)\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\"command\")\n\n\tswitch command {\n\tcase \"on\":\n\t\tif err := device.On(); err != nil {\n\t\t\ta.writeError(res, err)\n\t\t\treturn\n\t\t}\n\tcase \"off\":\n\t\tif err := device.Off(); err != nil {\n\t\t\ta.writeError(res, err)\n\t\t\treturn\n\t\t}\n\tcase \"toggle\":\n\t\tif err := device.Toggle(); err != nil {\n\t\t\ta.writeError(res, err)\n\t\t\treturn\n\t\t}\n\tdefault:\n\t\ta.writeError(res, fmt.Errorf(\"unknown command %s\", command))\n\t\treturn\n\t}\n\n\ta.writeSuccess(res)\n}", "CodeBleu_score": 48.67894647202753}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\texpectedAuth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tif r.Header.Get(\"Authorization\") != expectedAuth {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Authorization Required\\\"\")\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 65.15335639856363}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\texpected := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\t\tif auth := r.Header.Get(\"Authorization\"); auth != expected {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Authorization Required\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 62.424846325635784}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\texpected := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\tgot := r.Header.Get(\"Authorization\")\n\t\tif got != expected {\n\t\t\thttp.Error(w, \"Not authorized\", 401)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 58.523537836173986}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tok, err := a.connection.AnalogReadSupported()\n\tif !ok || err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := analogSensorScale(raw, a.h, a.l)\n\n\ta.rawValue = raw\n\ta.scaledValue = scaled\n\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 49.92944360332643}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.Lock()\n\tdefer a.Unlock()\n\n\tok := a.Connection().(gobot.AnalogReader).AnalogRead(a.Pin())\n\tif !ok {\n\t\treturn 0, 0.0, fmt.Errorf(\"analog read not supported by this platform\")\n\t}\n\n\tval, err := a.Connection().AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\traw := float64(val)\n\tscaled := ((raw/a.rawMax)*a.scaledMax + a.offset)\n\n\ta.lastval = raw\n\ta.lastscaled = scaled\n\n\treturn val, scaled, nil\n}\n", "CodeBleu_score": 46.936307885780224}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogModeSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"Analog reading not supported by this connection\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scaleReading(raw)\n\ta.lastRaw = raw\n\ta.lastValue = scaled\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 49.56462214143345}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\ts := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 1*time.Second, 8*10, a.DefaultScale()),\n\t\tDefaultName:       \"GroveSoundSensor\",\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase string:\n\t\t\ts.DefaultName = option.(string)\n\t\t}\n\t}\n\n\ts.AddEvent(SoundDetected)\n\ts.AddEvent(SoundNotDetected)\n\n\treturn s\n}\n", "CodeBleu_score": 37.171351677015586}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\td := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 1*time.Second, 10, \"GroveSoundSensor\"),\n\t}\n\n\tfor _, option := range opts {\n\t\toption.(func(*GroveSoundSensorDriver))(d)\n\t}\n\n\treturn d\n}\n", "CodeBleu_score": 34.153281071144754}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\ts := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 10*time.Millisecond, 100, \"GroveSoundSensor\"),\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase func(float64) float64:\n\t\t\ts.valueTransform = option.(func(float64) float64)\n\t\tcase string:\n\t\t\ts.name = option.(string)\n\t\t}\n\t}\n\n\ts.AddEvent(SoundDetected)\n\ts.AddEvent(SoundStopped)\n\n\treturn s\n}\n", "CodeBleu_score": 35.847860996836104}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tval, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&(1<<4) != 0 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 50.99462599077245}, {"code": "func (d *MFRC522Common) softReset() error\td.writeRegister(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tval, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif val&(1<<4) != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 51.46494309650074}, {"code": "func (d *MFRC522Common) softReset() error\td.writeReg(CommandReg, SoftReset)\n\ttime.Sleep(100 * time.Millisecond)\n\tif v, _ := d.readReg(CommandReg); v != 0x00 {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 31.82813446646538}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tn, err := d.ReadRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"bad length in fifo read (%d != %d)\", n, len(backData))\n\t}\n\t_, err = d.ReadRegister(FIFODataReg, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn, err = d.ReadRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn n & 0x07, nil\n}\n", "CodeBleu_score": 47.907532095492634}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tn, err := d.dev.ReadRegister(FIFOLevelReg, 1)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n[0] != uint8(len(backData)) {\n\t\treturn 0, errors.New(\"error: wrong length in readFifo()\")\n\t}\n\n\tn, err = d.dev.ReadRegister(FIFODataReg, len(backData))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tcopy(backData, n)\n\n\tn, err = d.dev.ReadRegister(ControlReg, 1)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn n[0], nil\n}\n", "CodeBleu_score": 43.03948542039877}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tn, err := d.readReg(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != len(backData) {\n\t\treturn 0, fmt.Errorf(\"received %d bytes from FIFO, expected %d\", n, len(backData))\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tbackData[i], err = d.readReg(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tlastBits, err := d.readReg(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits & 0x07, nil\n}", "CodeBleu_score": 55.38171544653076}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error\tif d.debugging {\n\t\td.log(\"Halting PICC...\")\n\t}\n\tbuff := []byte{byte(PICC_HALT)}\n\tcrc := d.calcCRC(buff)\n\tbuff = append(buff, byte(crc&0xFF))\n\tbuff = append(buff, byte((crc>>8)&0xFF))\n\t_, err := d.writeCommand(buff)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// The halt command is supposed to result in a 0x00 response.\n\t_, err = d.readResponse(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 37.204842425949955}, {"code": "func (d *MFRC522Common) piccHalt() error\tif d.debugging {\n\t\tlog.Println(\"Halting PICC...\")\n\t}\n\tbuff := []byte{0x50, 0x00, 0x00, 0x00, 0x00}\n\tcrc := d.calcCRC(buff[:4])\n\tbuff[4] = byte(crc)\n\t_, err := d.dev.Write(buff)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// The PICC must answer to a halt command with a 4 bit ACK.\n\t_, err = d.piccReadAckOrNAK()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 32.69722761703848}, {"code": "func (d *MFRC522Common) piccHalt() error\tif d.debugging {\n\t\tlog.Println(\"Halting PICC...\")\n\t}\n\tcmd := []byte{byte(PCD_Halt), 0}\n\tcrc := d.calcCRC(cmd, 1)\n\tcmd = append(cmd, byte(crc&0xFF))\n\t_, err := d.ToCard(PCD_TRANSCEIVE, cmd, nil, 0, nil, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}", "CodeBleu_score": 36.69043568586314}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tcmd := []byte{mfrc522.PiccCmdStdRead, block}\n\tcmd = append(cmd, d.crc(cmd)...)\n\n\t_, err := d.dev.Tx(cmd, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := make([]byte, 18)\n\t_, err = d.dev.Tx([]byte{mfrc522.PiccCmdStdTransceive}, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif data[0] != 0x00 || data[1] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"MFRC522: unexpected response: %v\", data[:2])\n\t}\n\n\treturn data[2 : 2+data[16]], nil\n}\n", "CodeBleu_score": 44.515023574137494}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\td.dev.Write([]byte{\n\t\tpiccRead,\n\t\tblock,\n\t})\n\tcrc := d.dev.CalculateCRC(d.dev.Status.LastBits, []byte{piccRead, block})\n\td.dev.Write([]byte{crc[0], crc[1]})\n\tif d.dev.WaitForCard(1) != nil {\n\t\treturn nil, errors.New(\"time out\")\n\t}\n\td.dev.Write([]byte{piccHalt})\n\tdata, err := d.dev.Read(16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn data, nil\n}\n", "CodeBleu_score": 39.0372543057739}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tbuffer := []byte{\n\t\tPICC_CMD_MF_READ,\n\t\tblock,\n\t}\n\tcrc := d.calculateCrc(buffer)\n\tbuffer = append(buffer, crc...)\n\t_, err := d.sendData(buffer)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuffer, err = d.receiveData()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(buffer) != 18 {\n\t\treturn nil, ErrReadData\n\t}\n\tif buffer[0] != 0 || buffer[1] != 0 {\n\t\treturn nil, ErrReadData\n\t}\n\tdata := buffer[2:10]\n\tcrc = buffer[10:12]\n\tbuffer = buffer[2:12]\n\tcalcCrc := d.calculateCrc(buffer)\n\tif calcCrc[0] != crc[0] || calcCrc[1] != crc[1] {\n\t\treturn nil, ErrReadData\n\t}\n\treturn data, nil\n}\n", "CodeBleu_score": 48.233380406565324}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer has too few bytes\")\n\t}\n\n\td.clearBitsInRegister(collReg, 0x80) // ValuesAfterColl=1 => Bits received after collision are cleared.\n\n\tswitch reqMode {\n\tcase piccRequestAll:\n\t\td.setRegisterBitMask(rxSelReg, 0x40) // RxWait=1 => Activate the receiver logic.\n\t\tbreak\n\tcase piccRequestAny:\n\t\td.clearBitsInRegister(rxSelReg, 0x40) // RxWait=0 => Deactivate the receiver logic.\n\t\tbreak\n\tdefault:\n\t\treturn errors.New(\"invalid request mode\")\n\t}\n\n\t// ClearBitMask(0x80, 0, 0, 0x10)\n\td.clearBitsInRegister(txControlReg, 0x10) // TxLastBists=0 => Send last data bit.\n\td.clearBitsInRegister(txControlReg, 0x20) // TxLastBists=0 => Send last data bit.\n\td.clearBitsInRegister(txControlReg, 0x40) // TxLastBists=0 => Send last data bit.\n\td.clearBitsInRegister(txControlReg, 0x80) // TxLastBists=0 => Send last data bit.\n\n\tresult := d.transceiveData(reqMode, nil, 0, answer, 2)\n\n\tif result != statusOK {\n\t\treturn errors.New(\"piccRequest failed\")\n\t}\n\n\tif len(answer) != 2 || answer[0] != reqMode {\n\t\treturn errors.New(\"piccRequest failed\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 43.5526367971455}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer has too few bytes (%d)\", len(answer))\n\t}\n\n\t// Clear collision register\n\td.writeRegister(collReg, 0x00)\n\n\t// For certain request modes, the card will only answer if the\n\t// following conditions are met:\n\t// - the antenna is in the Idle state\n\t// - the Data Mode register is in the NoCommunication state\n\t// - the TX Control register is in the Idle state\n\t//\n\t// The following code checks these conditions and sets the antenna to\n\t// the Idle state if necessary.\n\n\t// Set the antenna to the Idle state if it is not already in the Idle\n\t// state.\n\tif !d.isAntennaGpioHigh() {\n\t\td.setAntennaGpioHigh()\n\t}\n\n\t// Set the Data Mode register to the NoCommunication state if it is not\n\t// already in the NoCommunication state.\n\tif d.readRegister(txControlReg) != 0x00 {\n\t\td.writeRegister(txControlReg, 0x00)\n\t}\n\n\t// Set the TX Control register to the Idle state if it is not already in\n\t// the Idle state.\n\tif d.readRegister(txControlReg) != 0x00 {\n\t\td.writeRegister(txControlReg, 0x00)\n\t}\n\n\t// For certain request modes, the card will only answer if the\n\t// following conditions are met:\n\t// - the antenna is in the Idle state\n\t// - the Data Mode register is in the NoCommunication state\n\t// - the TX Control register is in the Idle state\n\t//\n\t// The following code checks these conditions and sets the antenna to\n\t// the Idle state if necessary.\n\n\t// Set the antenna to the Idle state if it is not already in the Idle\n\t// state.\n\tif !d.isAntennaGpioHigh() {\n\t\td.setAntennaGpioHigh()\n\t}\n\n\t// Set the Data Mode register to the NoCommunication state if it is not\n\t// already in the NoCommunication state.\n\tif d.readRegister(txControlReg) != 0x00", "CodeBleu_score": 37.92392647921965}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer is too small\")\n\t}\n\n\tswitch reqMode {\n\tcase PiccRequestIdle:\n\t\td.writeRegister(BitFramingReg, 0x80)\n\t\tbreak\n\tcase PiccRequestAll:\n\t\td.writeRegister(BitFramingReg, 0x96)\n\t\tbreak\n\tcase PiccRequestSystemCode:\n\t\td.writeRegister(BitFramingReg, 0x92)\n\t\tbreak\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown request mode\")\n\t}\n\n\td.writeRegister(ComIEnReg, 0x77)\n\td.clearRegisterBitMask(CollReg, 0x80)\n\td.writeRegister(ComIrqReg, 0x04)\n\td.setRegisterBitMask(FIFOLevelReg, 0x80)\n\td.writeRegister(CommandReg, reqMode)\n\n\tif reqMode == PiccRequestIdle || reqMode == PiccRequestSystemCode {\n\t\td.writeRegister(BitFramingReg, 0x87)\n\t}\n\n\ti := 2000\n\tfor {\n\t\tn, _ := d.readRegister(ComIrqReg)\n\t\ti--\n\t\tif i == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif (n & 0x01) != 0 {\n\t\t\tbreak\n\t\t}\n\t\tif (n & waitIRq) != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\terr := d.clearRegisterBitMask(ComIrqReg, 0x80)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif i != 0 {\n\t\tn, err := d.readRegister(FIFOLevelReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlastBits, err := d.readRegister(ControlReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlastBits &= 0x07\n\t\tif lastBits != 0 {\n\t\t\tn = (n-1)*8 + int(lastBits)", "CodeBleu_score": 48.098046419583}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.stepPin.Out(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\tif err := d.stepPin.Out(gpio.High); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\n\tif d.direction {\n\t\td.currentStep++\n\t\tif d.currentStep >= d.numberOfSteps {\n\t\t\td.currentStep = 0\n\t\t}\n\t} else {\n\t\td.currentStep--\n\t\tif d.currentStep < 0 {\n\t\t\td.currentStep = d.numberOfSteps - 1\n\t\t}\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 60.103546001546896}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.stepPin.Out(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\tif err := d.stepPin.Out(gpio.High); err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 65.21829776489567}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif err := d.StepPin.Out(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Duration(d.StepDelay) * time.Microsecond)\n\tif err := d.StepPin.Out(gpio.High); err != nil {\n\t\treturn err\n\t}\n\n\tif d.Direction {\n\t\td.StepNumber++\n\t\tif d.StepNumber == d.StepCount {\n\t\t\td.StepNumber = 0\n\t\t}\n\t} else {\n\t\tif d.StepNumber == 0 {\n\t\t\td.StepNumber = d.StepCount\n\t\t}\n\t\td.StepNumber--\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 60.23708250073098}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stopChan != nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopChan = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tdefer close(d.stopChan)\n\n\t\tticker := time.NewTicker(d.interval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distance = distance\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n", "CodeBleu_score": 49.44145125202732}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor is already running\")\n\t}\n\n\td.stopChan = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tticker := time.NewTicker(d.measurementInterval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\td.distance = distance\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\treturn nil\n}\n", "CodeBleu_score": 47.792133272010474}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.stopChan = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"Error measuring distance:\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"Distance: %.2f cm\", distance)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime.Sleep(d.measurementInterval)\n\t\t}\n\t}()\n\n\td.distanceMonitorRunning = true\n\treturn nil\n}\n", "CodeBleu_score": 46.90917225598268}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tstart := time.Now()\n\treturn func(pin int, dur time.Duration, event string, seq uint32, ts uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\tduration := time.Since(start)\n\t\t\td.pulse <- duration\n\t\t\tstart = time.Now()\n\t\t}\n\t}\n}", "CodeBleu_score": 36.3909889379857}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tstart := time.Now()\n\treturn func(pin int, duration time.Duration, event string, timestamp uint32, seqno uint32) {\n\t\tif event == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.durationChan <- time.Since(start)\n\t\t\tstart = time.Now()\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.90067151135462}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar startTimestamp time.Time\n\n\treturn func(event int, duration time.Duration, src string, timestamp uint32, seqno uint32) {\n\t\tswitch event {\n\t\tcase gpio.RisingEdge:\n\t\t\tstartTimestamp = time.Now()\n\t\tcase gpio.FallingEdge:\n\t\t\tduration := time.Since(startTimestamp)\n\t\t\td.pulseChannel <- duration\n\t\t\tstartTimestamp = time.Time{}\n\t\t}\n\t}\n}", "CodeBleu_score": 43.44220429071286}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\td.triggerPin.Low()\n\ttime.Sleep(2 * time.Microsecond)\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\t// Wait for the echo to be received or for a timeout to occur\n\tstartTime := time.Now()\n\tfor d.echoPin.Read() == gpio.Low && time.Since(startTime) < d.timeout {\n\t\ttime.Sleep(time.Microsecond)\n\t}\n\n\tif d.echoPin.Read() == gpio.Low {\n\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t}\n\n\tstartTime = time.Now()\n\tfor d.echoPin.Read() == gpio.High && time.Since(startTime) < d.timeout {\n\t\ttime.Sleep(time.Microsecond)\n\t}\n\n\tif d.echoPin.Read() == gpio.Low {\n\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t}\n\n\t// Calculate the distance in meters\n\telapsedTime := time.Since(startTime)\n\tdistance := elapsedTime.Seconds() * 343.0 / 2.0\n\n\t// Store the measured time in microseconds\n\td.measuredTime = elapsedTime\n\n\treturn nil\n}\n", "CodeBleu_score": 48.15824262083117}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.triggerPin.Low()\n\ttime.Sleep(60 * time.Microsecond)\n\td.triggerPin.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Low()\n\n\ttimeout := time.After(100 * time.Microsecond)\n\tfor d.echoPin.Read() == gpio.Low {\n\t\tselect {\n\t\tcase <-timeout:\n\t\t\treturn errors.New(\"timeout waiting for echo\")\n\t\tdefault:\n\t\t}\n\t}\n\n\tstart := time.Now()\n\tfor d.echoPin.Read() == gpio.High {\n\t}\n\tend := time.Now()\n\n\td.measuredTime = end.Sub(start)\n\treturn nil\n}\n", "CodeBleu_score": 47.5886682643574}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.trigger.High()\n\ttime.Sleep(10 * time.Microsecond)\n\td.trigger.Low()\n\n\tselect {\n\tcase <-d.echo.WaitForEdge(time.Second):\n\t\td.measuredTime = d.echo.HighTime()\n\t\treturn nil\n\tcase <-time.After(time.Second):\n\t\treturn errors.New(\"timeout waiting for echo signal\")\n\t}\n}\n", "CodeBleu_score": 43.78613575507387}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n    if self.token:\n        return self.token\n    if self.local_state.get(\"access_token\"):\n        if self.local_state.get(\"expires_at\") > time.time():\n            return self.local_state.get(\"access_token\")\n        elif self.local_state.get(\"refresh_token\"):\n            try:\n                new_auth_data = self.oauth.fetch_token(\n                    token_url=self.token_url,\n                    client_id=self.client_id,\n                    client_secret=self.client_secret,\n                    refresh_token=self.local_state.get(\"refresh_token\"),\n                )\n                self.local_state[\"access_token\"] = new_auth_data[\"access_token\"]\n                self.local_state[\"refresh_token\"] = new_auth_data[\"refresh_token\"]\n                self.local_state[\"expires_at\"] = new_auth_data[\"expires_at\"]\n                return new_auth_data[\"access_token\"]\n            except Exception as e:\n                pass\n    raise AccountNotAuthorized(\n        \"Account not authorized. Please authorize the application using the authorization URL.\"\n    )\n\n", "CodeBleu_score": 43.182039017927806}, {"code": "def fetch_authentication_token(self)\n    try:\n        if self.access_token is not None:\n            return self.access_token\n        else:\n            raise Exception\n    except:\n        try:\n            if self.refresh_token is not None:\n                self.access_token, self.refresh_token, self.expires_in = self.get_access_token(\n                    refresh_token=self.refresh_token\n                )\n                return self.access_token\n            else:\n                raise Exception\n        except:\n            raise AccountNotAuthorized(\n                \"Account not authorized. Please authorize the account using the 'authorize_account' function.\"\n            )\n\n", "CodeBleu_score": 28.219829037245386}, {"code": "def fetch_authentication_token(self)\n    if self.auth_token:\n        return self.auth_token\n    if self.refresh_token:\n        return self.refresh_token\n    if self.access_token and self.access_token_expiry:\n        if datetime.datetime.now() < self.access_token_expiry:\n            return self.access_token\n        if self.refresh_token:\n            try:\n                data = self.request(\n                    \"POST\",\n                    \"https://accounts.spotify.com/api/token\",\n                    data={\n                        \"grant_type\": \"refresh_token\",\n                        \"refresh_token\": self.refresh_token,\n                    },\n                    auth=(self.client_id, self.client_secret),\n                )\n                self.access_token = data[\"access_token\"]\n                self.access_token_expiry = datetime.datetime.now() + datetime.timedelta(\n                    seconds=data[\"expires_in\"]\n                )\n                self.save_state()\n                return self.access_token\n            except Exception as e:\n                print(e)\n    raise AccountNotAuthorized(\n        \"Please authorize the application using the `authorize` method.\"\n    )\n\n", "CodeBleu_score": 41.07471889031164}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n    try:\n        refresh_token = self.session.get('refresh_token')\n        self.session.delete()\n        self.session.post(\n            '/v1/logout',\n            json={'refresh_token': refresh_token},\n            headers={'Content-Type': 'application/json'}\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 55.40227285137782}, {"code": "def logout(self)\n    try:\n        refresh_token = self.get_refresh_token()\n        self.delete_session()\n        self.client.post(\"/v1/logout\", headers={\"Authorization\": f\"Bearer {refresh_token}\"})\n        return True\n    except AccountError:\n        pass\n", "CodeBleu_score": 48.2520037399034}, {"code": "def logout(self)\n    refresh_token = self.session.get(\"refresh_token\")\n    self.session.clear()\n    try:\n        self.post(\"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True\n", "CodeBleu_score": 49.45977400159165}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n    result = []\n    for pkg in self.packages:\n        if pkg.optional:\n            continue\n        result.append(pkg.name + '-' + pkg.version)\n        if pkg.metadata and pkg.metadata.get('external', False):\n            result.append('    ' + pkg.metadata['source_url'])\n    return result", "CodeBleu_score": 26.04466572817462}, {"code": "def dump_used_packages(self)\n    packages = []\n    for pkg in self.packages:\n        if pkg.optional:\n            continue\n        metadata = pkg.get_metadata()\n        packages.append(\n            {\n                \"name\": pkg.name,\n                \"version\": pkg.version,\n                \"source\": pkg.source if metadata.get(\"external\") else None,\n            }\n        )\n    return packages", "CodeBleu_score": 27.550863537312797}, {"code": "def dump_used_packages(self)\n    return [\n        (\n            pkg.name,\n            pkg.version,\n            pkg.source_url if pkg.source_url else None,\n        )\n        for pkg in self.packages\n        if not pkg.optional\n    ]", "CodeBleu_score": 11.686405410041436}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    try:\n        platform = cls.get_platform(env)\n    except UndefinedEnvPlatformError:\n        raise\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 37.97954617870688}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    from . import Project\n    from .exceptions import UndefinedEnvPlatformError\n    from .platforms import Platform\n\n    if not issubclass(cls, Project):\n        raise TypeError(\"cls must be a subclass of Project\")\n\n    platform_spec = cls.get_platform_spec(env)\n    if not platform_spec:\n        raise UndefinedEnvPlatformError(env)\n\n    platform = Platform.from_spec(platform_spec, autoinstall=autoinstall)\n    project = cls(platform, env=env)\n    project.configure_packages(targets)\n    return project\n\n", "CodeBleu_score": 38.21177120863798}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    try:\n        platform = cls.platforms[env]\n    except KeyError:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.project_env = env\n    instance.configure_packages(env, targets)\n    return instance\n\n", "CodeBleu_score": 41.3680253228053}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n\n  Wire.requestFrom(0x34, (int)Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire.read();\n  }\n}\n", "CodeBleu_score": 85.77622157946685}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)    Wire.beginTransmission(0x34);\n    Wire.write(Addr);\n    Wire.endTransmission();\n    Wire.requestFrom(0x34, (int)Size);\n    for (int i = 0; i < Size; i++) {\n        *(Buff + i) = Wire.read();\n    }\n}\n", "CodeBleu_score": 87.98588149876703}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n\n  Wire.requestFrom(0x34, (int)Size);\n  for (int i = 0; i < Size; i++) {\n    *(Buff + i) = Wire.read();\n  }\n}\n", "CodeBleu_score": 85.77622157946685}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us)  SetSleep(false);\n  if (time_in_us > 0) {\n    SetTimerWakeup(time_in_us);\n  } else {\n    DisableTimerWakeup();\n  }\n  SetLDO2(false);\n  SetLDO3(false);\n  SetDCDC3(false);\n  SetLDO0(false);\n  SetDCDC1(false);\n  SetExten(false);\n  SetAdcState(false);\n  SetAdcRate(ADC_125HZ);\n  SetAdcEnable(ADC_DISABLE);\n  SetAdcChannel(ADC_CURRENT_IN);\n  SetAdcChannel(ADC_VBUS_VOL);\n  SetAdcChannel(ADC_VBUS_CUR);\n  SetAdcChannel(ADC_BATT_VOL);\n  SetAdcChannel(ADC_BATT_CUR);\n  SetAdcChannel(ADC_APS_VOL);\n  SetAdcChannel(ADC_TS_PIN);\n  SetAdcSample(ADC_25);\n  SetAdcSample(ADC_25);\n  SetAdcSample(ADC_25);\n  SetAdcSample(ADC_25);\n  SetAdcSample(ADC_25);\n  SetAdcSample(ADC_25);\n  SetAdcSample(ADC_25);\n  SetAdcSample(ADC_25);\n  SetLDO3Mode(LDO3_MODE_DCIN);\n  SetLDO3Voltage(3300);\n  SetLDO2Voltage(3300);\n  SetDCDC3Voltage(3300);\n  SetLDOIO0Voltage(3300);\n  SetDC1IOSel(DC1_OUTPUT_VOLTAGE);\n  SetExtenVoltage(3300);\n  SetBusPowerMode(BUS_EXTERN);\n  SetLed(0x000000);\n  SetSpkEnable(SPK_DISABLE);\n  SetPower", "CodeBleu_score": 42.88586573626245}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)    SetSleep(false);\n    if (time_in_us != 0) {\n        SetTimerWakeup(time_in_us);\n    } else {\n        SetDSleepTimerWakeup(false);\n    }\n    SetLDO2(false);\n    SetDCDC3(false);\n    SetLDO3(false);\n    SetLDO4(false);\n    SetLDO3Float(false);\n    SetCharge(false);\n    SetAdcState(false);\n    SetCoulombcounter(false);\n    SetGPIO0(AXP192_GPIO0_LDO_MODE);\n    SetGPIO1(AXP192_GPIO1_LDO_MODE);\n    SetGPIO2(AXP192_GPIO2_LDO_MODE);\n    SetGPIO3(AXP192_GPIO3_LDO_MODE);\n    SetGPIO4(AXP192_GPIO4_LDO_MODE);\n    SetLed(false);\n    SetSpkEnable(false);\n    SetSysIPSOscPower(false);\n    SetTSPower(false);\n    SetDCDC1(false);\n    SetDCDC2(false);\n    SetLDO0(false);\n    SetLDO1(false);\n    SetLDO2(false);\n    SetLDO3(false);\n    SetLDO4(false);\n    SetLDO3Float(false);\n    SetCharge(false);\n    SetAdcState(false);\n    SetCoulombcounter(false);\n    SetGPIO0(AXP192_GPIO0_LDO_MODE);\n    SetGPIO1(AXP192_GPIO1_LDO_MODE);\n    SetGPIO2(AXP192_GPIO2_LDO_MODE);\n    SetGPIO3(AXP192_GPIO3_LDO_MODE);\n    SetGPIO4(AXP192_GPIO4_LDO_MODE);\n    SetLed(false);\n    SetSpkEnable(false);\n    SetSysIPSO", "CodeBleu_score": 34.13093216497973}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)  SetSleep(false);\n  if (time_in_us != 0) {\n    SetTimerWakeup(time_in_us);\n  } else {\n    SetDSleepTimerWakeup(false);\n  }\n  SetLDO2(false);\n  SetDCDC3(false);\n  SetLDO3(false);\n  SetLDO4(false);\n  SetLDO3Mode(LDO_DC_LDO);\n  SetLDO4Mode(LDO_DC_LDO);\n  SetBusPowerMode(0);\n  SetLDOVoltage(3, 3300);\n  SetLDOVoltage(4, 3300);\n  SetLDOEnable(3, false);\n  SetLDOEnable(4, false);\n  SetDCDC3Voltage(3300);\n  SetPowerOff();\n  if (time_in_us == 0) {\n    SetDSleep(false);\n  } else {\n    SetDSleep(true);\n  }\n}\n", "CodeBleu_score": 48.11593205618605}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)    int y = scroll_addr;\n    if (tteBar) {\n        tteBar = 0;\n        y = scroll_addr + 192;\n    }\n    fill_rect(0, y, 240, 22, color);\n    scroll_addr += 22;\n    if (scroll_addr > (240 - 22)) {\n        scroll_addr = 0;\n        tteBar = 1;\n    }\n    return y;\n}\n", "CodeBleu_score": 13.519758718306024}, {"code": "int Display::scroll_line(uint32_t color)    int y = _scroll_y;\n    int height = _tteBar ? _tteBarHeight : _height - _bottomFixedAreaHeight;\n    fill_rectangle(0, y, _width, height, color);\n    y = (y + height) % _height;\n    _scroll_y = y;\n    return y;\n}\n", "CodeBleu_score": 16.52518271839653}, {"code": "int Display::scroll_line(uint32_t color)    int y = scroll_y;\n    if (tteBar) {\n        y = scroll_y_tte;\n    }\n    fill_rect(0, y, width, height, color);\n    y += char_height;\n    if (y >= height - fixed_bottom) {\n        y = fixed_top;\n        if (tteBar) {\n            y = fixed_top_tte;\n        }\n    }\n    scroll_y = y;\n    return y;\n}\n", "CodeBleu_score": 20.053129943126603}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)    // Set up the access points\n    if (!set_access_points(ssids, access_points)) {\n        return false;\n    }\n\n    // Set up the HTML content\n    if (!set_html_content()) {\n        return false;\n       }\n\n    // Start the portal\n    if (!start_portal()) {\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 54.13036559655258}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if (!set_ssids(ssids)) {\n    return false;\n  }\n\n  if (!set_access_points(access_points)) {\n    return false;\n  }\n\n  if (!set_html()) {\n    return false;\n  }\n\n  start();\n  return true;\n}\n", "CodeBleu_score": 57.422473213119694}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if (!setup_access_points(ssids, access_points)) {\n    return false;\n  }\n  if (!setup_html_content()) {\n    return false;\n  }\n  start_portal();\n  return true;\n}\n", "CodeBleu_score": 60.69952967674275}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue()    if (queue_enabled_flag) {\n        // If the queue is already enabled, ensure that the queue, text, and text_in are initialized\n        queue = std::queue<std::string>();\n        text = \"\";\n        text_in = \"\";\n    } else {\n        // If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true\n        flush_queue();\n        queue_enabled_flag = true;\n    }\n}\n", "CodeBleu_score": 13.920932795040484}, {"code": "void GpsInterface::enable_queue()    if (!queue_enabled_flag) {\n        // Flush the existing queue\n        while (!queue.empty()) {\n            queue.pop();\n        }\n        // Set the queue_enabled_flag to true\n        queue_enabled_flag = true;\n    }\n}\n", "CodeBleu_score": 8.36052976429343}, {"code": "void GpsInterface::enable_queue()    if (queue_enabled_flag) {\n        queue.clear();\n        text.clear();\n        text_in.clear();\n    } else {\n        queue.flush();\n        queue_enabled_flag = true;\n    }\n}\n", "CodeBleu_score": 12.52282881279755}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea()    if (this->queue_nmea) {\n        if (this->queue_nmea->size() > 0) {\n            delete this->queue_nmea;\n            this->queue_nmea = new std::queue<std::string>();\n        }\n    } else {\n        this->queue_nmea = new std::queue<std::string>();\n    }\n}\n", "CodeBleu_score": 23.285799540954585}, {"code": "void GpsInterface::flush_queue_nmea()    if(this->queue_nmea != NULL) {\n        while(!this->queue_nmea->empty()) {\n            delete this->queue_nmea->front();\n            this->queue_nmea->pop();\n        }\n        delete this->queue_nmea;\n    }\n    this->queue_nmea = new std::queue<NMEA*>;\n}\n", "CodeBleu_score": 20.189044324023552}, {"code": "void GpsInterface::flush_queue_nmea()  if (this->queue_nmea != NULL) {\n    if (this->queue_nmea->size() > 0) {\n      delete this->queue_nmea;\n      this->queue_nmea = new std::queue<std::string>;\n    }\n  } else {\n    this->queue_nmea = new std::queue<std::string>;\n  }\n}\n", "CodeBleu_score": 23.209905793738628}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    // Start a write transaction\n    ili9341_write_cmd(ILI9341_CMD_CASET);\n    ili9341_write_data(area->x1 >> 8);\n    ili9341_write_data(area->x1 & 0xFF);\n    ili9341_write_data(area->x2 >> 8);\n    ili9341_write_data(area->x2 & 0xFF);\n    ili9341_write_cmd(ILI9341_CMD_PASET);\n    ili9341_write_data(area->y1 >> 8);\n    ili9341_write_data(area->y1 & 0xFF);\n    ili9341_write_data(area->y2 >> 8);\n    ili9341_write_data(area->y2 & 0xFF);\n    ili9341_write_cmd(ILI9341_CMD_RAMWR);\n\n    // Iterate through each pixel in the area and write the corresponding color\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        ili9341_write_color(color_p->full);\n        color_p++;\n      }\n    }\n\n    // End the write transaction\n    ili9341_write_cmd(0x00);\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }\n", "CodeBleu_score": 57.56553387226274}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    /* Get the display buffer */\n    uint8_t *buf = (uint8_t *)disp->buf;\n\n    /* Update the area */\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        uint32_t index = x + y * disp->hor_res;\n        buf[index] = color_p->full;\n        color_p++;\n      }\n    }\n\n    /* Indicate that the flush is complete */\n    lv_disp_flush_ready(disp);\n  }\n", "CodeBleu_score": 53.72195514525002}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    uint32_t w = (area->x2 - area->x1 + 1);\n    uint32_t h = (area->y2 - area->y1 + 1);\n\n    disp_flush(area->x1, area->y1, area->x2, area->y2, color_p);\n\n    lv_disp_flush_ready(disp);\n  }\n\n  /*\n   * The function \"lv_tick_handler\" is a timer callback function that updates the display driver with the current tick count.\\nIt calls the \"lv_tick_inc\" function to increment the tick count by one and then calls the \"lv_task_handler\" function to handle any pending tasks.\\nFinally, it calls the \"lv_timer_handler\" function to handle any pending timers.\n   */\n  void lv_tick_handler(void) {\n    lv_tick_inc(1);\n    lv_task_handler();\n    lv_timer_handler();\n  }\n\n  /*\n   * The function \"lv_init\" initializes the LittlevGL library.\\nIt sets the timer callback function and the display driver.\\nIt registers the display driver with LittlevGL.\\nIt initializes the input device driver.\\nIt registers the input device driver with LittlevGL.\\nIt initializes the file system driver.\\nIt registers the file system driver with LittlevGL.\\nIt initializes the theme.\\nIt registers the theme with LittlevGL.\\nIt initializes the font system.\\nIt registers the font system with LittlevGL.\\nIt initializes the animation system.\\nIt initializes the color system.\\nIt initializes the log system.\\nIt initializes the memory system.\\nIt initializes the object system.\\nIt initializes the style system.\\nIt initializes the text system.\\nIt initializes the image system.\\nIt initializes the animation system.\\nIt initializes the draw system.\\nIt initializes the input system.\\nIt initializes the task system.\\nIt initializes the timer system.\\nIt initializes the event system.\\nIt initializes the draw system.\\nIt initializes the input system.\\nIt initializes the task system.\\nIt initializes the timer system.\\nIt", "CodeBleu_score": 39.33794870117827}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tfor (int i = 0; i < menu->getMenuNodes().size(); i++) {\n\t\tMenuNode * node = menu->getMenuNodes().at(i);\n\t\tstd::cout << std::string(layer * 2, ' ') << node->getName() << std::endl;\n\t\tif (node->getMenu() != nullptr) {\n\t\t\tshowMenuList(node->getMenu(), layer + 1);\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}\n", "CodeBleu_score": 44.29450039401422}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    if (menu == nullptr) {\n        return;\n    }\n\n    for (MenuNode * node : menu->getMenuNodes()) {\n        for (int i = 0; i < layer; i++) {\n            std::cout << \"  \";\n        }\n\n        std::cout << node->getName() << std::endl;\n\n        if (node->getType() == MENU) {\n            showMenuList(node->getMenu(), layer + 1);\n        }\n    }\n\n    std::cout << std::endl;\n}\n", "CodeBleu_score": 43.78242823636126}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    for (int i = 0; i < menu->getMenuSize(); i++) {\n        for (int j = 0; j < layer; j++) {\n            cout << \"  \";\n        }\n        cout << menu->getMenuNode(i)->getMenuName() << endl;\n        if (menu->getMenuNode(i)->getMenuType() == MENU) {\n            showMenuList(menu->getMenuNode(i)->getMenu(), layer + 1);\n        }\n    }\n    cout << endl;\n}\n", "CodeBleu_score": 46.02821512798386}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count)  int n = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int i = 0; i < 6; i++) {\n      ssid += (char)random(33, 126);\n    }\n    int channel = random(1, 15);\n    String mac = \"\";\n    for (int i = 0; i < 6; i++) {\n      mac += String(random(0, 255), HEX);\n      if (i < 5) mac += \":\";\n    }\n    ssids[n] = ssid;\n    channels[n] = channel;\n    macs[n] = mac;\n    Serial.printf(\"%d: %s, %d, %s\\n\", n, ssid.c_str(), channel, mac.c_str());\n    n++;\n  }\n  return n;\n}\n", "CodeBleu_score": 42.690267989824704}, {"code": "int WiFiScan::generateSSIDs(int count)  int n = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int i = 0; i < 6; i++) {\n      ssid += (char)random(65, 91);\n    }\n    int ch = random(1, 12);\n    String mac = \"\";\n    for (int i = 0; i < 12; i++) {\n      mac += String(random(0, 16), HEX);\n    }\n    ssidList.add(ssid);\n    Serial.print(ssid);\n    Serial.print(\" \");\n    Serial.print(ch);\n    Serial.print(\" \");\n    Serial.println(mac);\n    n++;\n  }\n  return n;\n}\n", "CodeBleu_score": 45.945596887060304}, {"code": "int WiFiScan::generateSSIDs(int count)  int n = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int i = 0; i < 6; i++) {\n      ssid += (char)random(33, 126);\n    }\n    int channel = random(1, 13);\n    String mac = \"\";\n    for (int i = 0; i < 17; i++) {\n      mac += (char)random(48, 57);\n      if (i == 2 || i == 5 || i == 8 || i == 11 || i == 14) {\n        mac += \":\";\n      }\n    }\n    SSIDList.add(ssid);\n    Serial.println(ssid + \" on channel \" + channel + \" with MAC \" + mac);\n    n++;\n  }\n  return n;\n}\n", "CodeBleu_score": 41.774364466407775}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic created: {topic}\")\n\n", "CodeBleu_score": 70.0780759150971}, {"code": "def create_topic(project_id, topic_name)\n    from google.cloud import pubsub_v1\n\n    # Initialize a PublisherClient\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the topic path\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic '{topic.name}' created.\")\n\n", "CodeBleu_score": 68.9360700994525}, {"code": "def create_topic(project_id, topic_name)\n    from google.cloud import pubsub_v1\n\n    # Initialize a PublisherClient\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the topic path\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    # Print the topic details\n    print(f\"Topic created: {topic.name}\")\n\n", "CodeBleu_score": 69.7121745172126}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    import datetime\n    import jwt\n\n    token = {\n        # The time that the token was issued at\n        \"iat\": datetime.datetime.utcnow(),\n        # The time the token expires.\n        \"exp\": datetime.datetime.utcnow() + datetime.timedelta(minutes=60),\n        # The audience field should always be set to the GCP project id.\n        \"aud\": project_id,\n    }\n\n    # Read the private key file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Create the JWT.\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 67.44385257335705}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n    import jwt\n    import time\n\n    token = {\n        'iat': int(time.time()),\n        'exp': int(time.time()) + 3600,\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    return jwt.encode(token, private_key, algorithm=algorithm)\n", "CodeBleu_score": 55.36573622215498}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    import time\n    import jwt\n\n    token = {\n        # The time that the token was issued at\n        \"iat\": time.time(),\n        # The time the token expires.\n        \"exp\": time.time() + 3600,\n        # The audience field should always be set to the GCP project id.\n        \"aud\": project_id,\n    }\n\n    # Read the private key file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Create JWT\n    return jwt.encode(token, private_key, algorithm=algorithm)\n\n", "CodeBleu_score": 47.55944480325665}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(message.payload, message.topic, str(message.qos)))\n    if message.payload == 'on':\n        print('Camera on')\n        # capture a preview image\n        camera.capture('/home/pi/preview.jpg')\n        # upload the file to the bucket\n        storage_client.bucket(bucket_name).blob('preview.jpg').upload_from_filename('/home/pi/preview.jpg')\n        # publish the file's URL to the event topic\n        client.publish(event_topic, 'https://storage.googleapis.com/{}/preview.jpg'.format(bucket_name))\n    else:\n        print('Camera off')\n\n", "CodeBleu_score": 34.48370390672023}, {"code": "def on_message(unused_client, unused_userdata, message)\n    print(\"Received message '{}' on topic '{}' with QoS {}\".format(message.payload, message.topic, str(message.qos)))\n    if message.payload == b\"on\":\n        print(\"on\")\n        capture_preview()\n        upload_file(BUCKET_NAME, \"preview.jpg\", \"preview.jpg\")\n        client.publish(f\"projects/{PROJECT_ID}/topics/events\", \"https://storage.googleapis.com/{}/preview.jpg\".format(BUCKET_NAME))\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 25.067322958004134}, {"code": "def on_message(unused_client, unused_userdata, message)\n    print('Received message \\'{}\\' on topic \\'{}\\' with Qos {}'.format(\n        message.payload, message.topic, str(message.qos)))\n    if message.payload == b'on':\n        print('on')\n        capture_and_upload()\n        client.publish(\n            mqtt_topic_event,\n            'https://storage.googleapis.com/{}/{}'.format(\n                bucket_name,\n                datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S') + '.jpg'),\n            qos=1)\n    else:\n        print('off')\n", "CodeBleu_score": 37.89744381380979}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n    import argparse\n    import os\n\n    parser = argparse.ArgumentParser(\n        description=\"Example Google Cloud IoT MQTT device connection code.\"\n    )\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\"--subscription_name\", required=True, help=\"Cloud IoT subscription name\")\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        default=\"rsa_private.pem\",\n        required=False,\n        help=\"Path to private key file.\",\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=False,\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        default=100,\n        help=\"Number of messages to publish.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        choices=(888", "CodeBleu_score": 54.36319663032641}, {"code": "def parse_command_line_args()\n    import argparse\n    import os\n\n    parser = argparse.ArgumentParser(\n        description=\"Example Google Cloud IoT MQTT device connection code.\"\n    )\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        required=True,\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--subscription_name\",\n        required=True,\n        help=\"Cloud IoT Core MQTT topic name\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT Core registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT Core device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\", required=True, help=\"Path to private key file.\"\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        required=True,\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\"\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", choices=(8883, 443), default=8883, help=\"MQTT bridge port.\"\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\",", "CodeBleu_score": 56.685126517859615}, {"code": "def parse_command_line_args()\n    import argparse\n    import os\n\n    parser = argparse.ArgumentParser(description=\"Example Google Cloud IoT MQTT device connection code.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--subscription_name\",\n        default=os.environ.get(\"GOOGLE_CLOUD_SUBSCRIPTION\"),\n        help=\"GCP Pub/Sub subscription name\",\n    )\n    return parser.parse_args()\n\n", "CodeBleu_score": 66.07933848749451}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_account_credentials = ServiceAccountCredentials.from_json_keyfile_name(service_account_json, scopes=api_scopes)\n    service_name = 'cloudiotcore'\n    client = build(service_name, api_version, discoveryServiceUrl=discovery_api_url, credentials=service_account_credentials)\n    return client\n\n", "CodeBleu_score": 33.36772429150459}, {"code": "def get_client(service_account_json)\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_account_credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n    scoped_credentials = service_account_credentials.with_scopes(api_scopes)\n    discovery_api = discovery.build(\n        'cloudiotcore', api_version, discoveryServiceUrl=discovery_api_url, credentials=scoped_credentials)\n    return discovery_api\n\n", "CodeBleu_score": 33.354664654060194}, {"code": "def get_client(service_account_json)\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n    service_name = 'cloudiotcore'\n\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    discovery_url = '{}?version={}'.format(\n        discovery_api_url, api_version)\n\n    return discovery.build(\n        service_name,\n        api_version,\n        discoveryServiceUrl=discovery_url,\n        credentials=scoped_credentials)\n", "CodeBleu_score": 67.68367128314289}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n    try:\n        asn1 = ASN1_CODE[hash_method]\n    except KeyError:\n        raise ValueError(f\"Invalid hash method: {hash_method}\")\n\n    hash_value = asn1 + hash_value\n    padded_hash = pad_for_signing(hash_value, priv_key.size_in_bytes())\n    signature = encrypt(padded_hash, priv_key)\n    return signature\n\n", "CodeBleu_score": 32.43010829780247}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    asn1 = hash_method.asn1()\n    if asn1 is None:\n        raise ValueError(\"unsupported hash type\")\n\n    return priv_key.sign(\n        asn1 + hash_value,\n        padding.PKCS1v15(),\n        utils.Prehashed(hash_method),\n    )\n\n", "CodeBleu_score": 16.44457745725353}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    try:\n        hash_method_asn1 = hash_method.asn1_code\n    except AttributeError:\n        raise ValueError(f\"Invalid hash method: {hash_method}\")\n\n    hash_value_with_asn1 = hash_method_asn1 + hash_value\n\n    padded_hash_value = pad_for_signing(hash_value_with_asn1, priv_key.size_in_bytes())\n\n    encrypted_signature = priv_key.sign(padded_hash_value, padding.PKCS1v15(), hash_method)\n\n    return encrypted_signature\n\n", "CodeBleu_score": 32.126467303813236}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n    from Crypto.PublicKey import RSA\n    from Crypto.Signature import pkcs1_15\n    from Crypto.Hash import SHA256, SHA384, SHA512, SHA3_256, SHA3_512\n    from Crypto.Util.number import long_to_bytes\n    from base64 import b64decode\n    from binascii import Error\n\n    # Convert the signature to an integer and decrypt it to obtain the clear signature\n    try:\n        signature = int.from_bytes(b64decode(signature), byteorder='big')\n    except (TypeError, ValueError, Error):\n        raise ValueError(\"Invalid signature\")\n    try:\n        key = RSA.import_key(pub_key)\n    except (ValueError, TypeError):\n        raise ValueError(\"Invalid public key\")\n    cipher = pkcs1_15.new(key)\n    sentinel = None\n    try:\n        clear_signature = cipher.decrypt(signature, sentinel)\n    except ValueError:\n        raise ValueError(\"Invalid signature\")\n\n    # Determine the hash method used\n    hash_length = {\n        32: SHA256,\n        48: SHA384,\n        64: SHA512,\n        32: SHA3_256,\n        64: SHA3_512\n    }.get(len(clear_signature))\n    if not hash_length:\n        raise ValueError(\"Unsupported hash method\")\n\n    # Compute the hash of the message\n    h = hash_length.new(message.encode())\n    try:\n        digest = h.digest()\n    except TypeError:\n        raise ValueError(\"Unsupported hash method\")\n\n    # Reconstruct the expected padded hash\n    emLen = ((key.size() + 1) // 8)\n    if emLen < len(digest) + 11:\n        raise ValueError(\"Invalid signature\")\n    T = bytearray([0] * (emLen - len(digest) - 3))\n    T", "CodeBleu_score": 34.01808083226354}, {"code": "def verify(message, signature, pub_key)\n    from Crypto.PublicKey import RSA\n    from Crypto.Util.number import long_to_bytes\n    from Crypto.Util.number import bytes_to_long\n    from Crypto.Hash import SHA256, SHA512, SHA384, SHA224, SHA1, MD5\n    from Crypto.Signature import PKCS1_v1_5\n    from base64 import b64decode\n    hash_function = {\n        'sha-1': SHA1,\n        'sha-224': SHA224,\n        'sha-256': SHA256,\n        'sha-384': SHA384,\n        'sha-512': SHA512,\n        'md5': MD5\n    }\n    signature = bytes_to_long(b64decode(signature))\n    key = RSA.importKey(pub_key)\n    h = PKCS1_v1_5.new(key)\n    message = message.encode()\n    digest_name = None\n    for hash_algorithm in hash_function.keys():\n        try:\n            h.verify(message, (signature,))\n            digest_name = hash_algorithm\n        except ValueError:\n            continue\n    if digest_name is None:\n        raise ValueError('Verification failed')\n    hash_value = hash_function[digest_name].new(message)\n    padded_hash = b'\\x00\\x01' + b'\\xff' * ((key.size() // 8) - len(hash_value.digest()) - 3) + b'\\x00' + hash_value.digest()\n    if padded_hash != long_to_bytes(signature):\n        raise ValueError('Verification failed')\n    return digest_name\n\n", "CodeBleu_score": 32.72525682717669}, {"code": "def verify(message, signature, pub_key)\n    try:\n        from Crypto.PublicKey import RSA\n        from Crypto.Hash import SHA256, SHA384, SHA512\n        from Crypto.Signature import PKCS1_v1_5\n        from Crypto.Util.number import bytes_to_long\n        from base64 import b64decode\n\n        # Convert the signature from base64 to bytes\n        signature = b64decode(signature)\n\n        # Convert the signature from bytes to an integer\n        signature = bytes_to_long(signature)\n\n        # Decrypt the signature using the public key\n        pub_key = RSA.importKey(pub_key)\n        cipher = PKCS1_v1_5.new(pub_key)\n        clear_signature = cipher.decrypt(signature, None)\n\n        # Determine the hash method used\n        if len(clear_signature) == 256:\n            hash_method = \"SHA-256\"\n            hash_object = SHA256.new()\n        elif len(clear_signature) == 384:\n            hash_method = \"SHA-384\"\n            hash_object = SHA384.new()\n        elif len(clear_signature) == 512:\n            hash_method = \"SHA-512\"\n            hash_object = SHA512.new()\n        else:\n            raise ValueError(\"Invalid signature length\")\n\n        # Compute the hash of the message\n        hash_object.update(message.encode())\n        message_hash = hash_object.digest()\n\n        # Reconstruct the expected padded hash\n        padded_hash = b'\\x00' + b'\\x01' + b'\\xff' * (\n                len(clear_signature) - len(message_hash) - 3) + b'\\x00' + message_hash\n\n        # Verify the signature\n        if clear_signature != padded_hash:\n            raise ValueError(\"Signature verification failed\")\n\n        return hash_method\n    except Exception as e:\n        return f\"Error: {str(e)}\"", "CodeBleu_score": 34.65668002648915}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT()    time_t now;\n    time(&now);\n    if (now > 0) {\n        updateJWT(now);\n    }\n    connectToMQTT();\n    sendSubscribePacket = 1;\n    Serial.println(\"Attempting MQTT connection...\");\n}\n", "CodeBleu_score": 20.3746824447021}, {"code": "static void connectMQTT()  time_t now;\n  time(&now);\n  if (now > 0) {\n    updateJWT(now);\n  }\n  connectToMQTTClient();\n  sendMQTTSubscribe = true;\n  Serial.println(\"Attempting MQTT connection...\");\n}\n", "CodeBleu_score": 20.98007331765172}, {"code": "static void connectMQTT()    time_t now;\n    if (time(&now) > 0) {\n        updateJWT(now);\n    }\n    mqtt_client_connect(client, &connect_params);\n    send_subscribe_request = true;\n    ESP_LOGI(TAG, \"MQTT connection attempt\");\n}\n", "CodeBleu_score": 18.82068583560543}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t value = 0;\n    uint32_t max = 0xFFFFFFFF;\n    int i;\n\n    for (i = 0; i < width; i++) {\n        uint8_t digit = str[i] - '0';\n        if (digit > 9) {\n            return str;\n        }\n        if (value > max / 10 || (value == max / 10 && digit > max % 10)) {\n            return str;\n        }\n        value = value * 10 + digit;\n    }\n\n    *num = value;\n    return str + width;\n}\n", "CodeBleu_score": 27.37452168204587}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t val = 0;\n    while (width--) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9') {\n            return str - 1;\n        }\n        val = val * 10 + (c - '0');\n    }\n    *num = val;\n    return str;\n}\n", "CodeBleu_score": 16.480914906599647}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)  uint32_t value = 0;\n  int i;\n  for (i = 0; i < width; ++i) {\n    uint8_t c = str[i];\n    if (c < '0' || c > '9') {\n      return str;\n    }\n    value = (value * 10) + (c - '0');\n  }\n  *num = value;\n  return str + i;\n}\n", "CodeBleu_score": 23.374841650275723}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    int ret = ATCACERT_E_UNIMPLEMENTED;\n    if (build_state != NULL) {\n        ret = atcacert_cert_build_finish_internal(build_state);\n    }\n    return ret;\n}", "CodeBleu_score": 16.211791110529088}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    int ret = 0;\n    uint8_t* cert_bytes = NULL;\n    size_t cert_bytes_size = 0;\n    size_t cert_bytes_used = 0;\n    size_t cert_bytes_remaining = 0;\n    size_t cert_bytes_offset = 0;\n    size_t cert_bytes_offset_end = 0;\n    size_t cert_bytes_offset_start = 0;\n    size_t cert_bytes_offset_start_end = 0;\n    size_t cert_bytes_offset_start_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    size_t cert_bytes_offset_start_end_end_end_end_end_end_end_end_end_end_", "CodeBleu_score": 10.674046868971871}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    /*\n     * The function \"atcacert_date_dec_rfc5280_utc\" decodes a date in RFC5280 UTC format into a timestamp structure.\n     */\n    int ret = 0;\n    if (build_state->cert_def.cert_elements.subject.subject_name.common_name.len > 0) {\n        ret = atcacert_cert_def_subject_name_set(&build_state->cert_def, &build_state->cert_def.cert_elements.subject.subject_name);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    }\n    if (build_state->cert_def.cert_elements.subject.subject_public_key_info.public_key.key_type == ATCACERT_PUB_KEY_ECC_P256) {\n        ret = atcacert_cert_def_subject_public_key_info_set(&build_state->cert_def, &build_state->cert_def.cert_elements.subject.subject_public_key_info);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    }\n    if (build_state->cert_def.cert_elements.subject.subject_public_key_info.public_key.key_type == ATCACERT_PUB_KEY_RSA_2048) {\n        ret = atcacert_cert_def_subject_public_key_info_set(&build_state->cert_def, &build_state->cert_def.cert_elements.subject.subject_public_key_info);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n    }\n    return ret;\n}\n\n", "CodeBleu_score": 48.17364259689934}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int ret;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    if (atcacert_verify_signature(tbs_digest, signature, ca_public_key)) {\n        return ATCACERT_E_VERIFY;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}\n", "CodeBleu_score": 68.7145594404001}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    if (atcacert_verify_signature(tbs_digest, signature, ca_public_key) != ATCACERT_E_SUCCESS) {\n        return ATCACERT_E_VERIFY;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}\n", "CodeBleu_score": 72.3200872284002}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (cert_size < cert_def->cert_size) {\n        return ATCACERT_E_INVALID_CERT;\n    }\n\n    const uint8_t* cert_tbs = cert + cert_def->tbs_offset;\n    size_t         cert_tbs_size = cert_def->tbs_size;\n\n    uint8_t digest[64];\n    atcacert_calculate_tbs_digest(cert_tbs, cert_tbs_size, digest);\n\n    const uint8_t* cert_signature = cert + cert_def->signature_offset;\n    size_t         cert_signature_size = cert_def->signature_size;\n\n    int verify_result = atcacert_verify_signature_hw(ca_public_key, digest, cert_signature, cert_signature_size);\n\n    return verify_result == 0 ? ATCACERT_E_VERIFY_FAILED : ATCACERT_E_SUCCESS;\n}\n", "CodeBleu_score": 42.862452312028296}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{  bool ret = false;\n  timerStruct_t * volatile *p = list;\n  while (*p != NULL)\n  {\n    if (*p == timer)\n    {\n      *p = timer->next;\n      ret = true;\n      break;\n    }\n\n    p = &(*p)->next;\n  }\n\n  return ret;\n}", "CodeBleu_score": 26.86164606428207}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{  timerStruct_t * volatile *list;\n  timerStruct_t *timer;\n  bool retVal;\n  timerStruct_t * volatile *list_001;\n  timerStruct_t *timer_002;\n  timerStruct_t * volatile *list_003;\n  timerStruct_t *timer_004;\n  timerStruct_t * volatile *list_005;\n  timerStruct_t *timer_006;\n  timerStruct_t * volatile *list_007;\n  timerStruct_t *timer_008;\n  timerStruct_t * volatile *list_009;\n  timerStruct_t *timer_010;\n  timerStruct_t * volatile *list_011;\n  timerStruct_t *timer_012;\n  timerStruct_t * volatile *list_013;\n  timerStruct_t *timer_014;\n  timerStruct_t * volatile *list_015;\n  timerStruct_t *timer_016;\n  timerStruct_t * volatile *list_017;\n  timerStruct_t *timer_018;\n  timerStruct_t * volatile *list_019;\n  timerStruct_t *timer_020;\n  timerStruct_t * volatile *list_021;\n  timerStruct_t *timer_022;\n  timerStruct_t * volatile *list_023;\n  timerStruct_t *timer_024;\n  timerStruct_t * volatile *list_025;\n  timerStruct_t *timer_026;\n  timerStruct_t * volatile *list_027;\n  timerStruct_t *timer_028;\n  timerStruct_t * volatile *list_029;\n  timerStruct_t *timer_030;\n  timerStruct_t * volatile *list_031;\n  timerStruct_t *timer_032;\n  timerStruct_t * volatile *list_033;\n  timerStruct_t *timer_034;\n  timerStruct_t * volatile *list_", "CodeBleu_score": 8.672983162059186}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{  timerStruct_t * volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *volatile *", "CodeBleu_score": 9.646879677836598}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket)    struct socket_info *sock = get_socket(socket);\n    if (sock == NULL) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n    sock->state = NOT_A_SOCKET;\n    int ret = close(sock->fd);\n    if (ret < 0) {\n        if (errno == EBADF) {\n            errno = ENOTSOCK;\n        }\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 41.32770291066908}, {"code": "int BSD_close(int socket)    struct socket_info *socket_info = get_socket_info(socket);\n    if (socket_info == NULL) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n    socket_info->state = NOT_A_SOCKET;\n    int ret = close(socket);\n    if (ret == -1) {\n        switch (errno) {\n            case EBADF:\n                errno = ENOTSOCK;\n                break;\n            case EINTR:\n                errno = EINPROGRESS;\n                break;\n            case EIO:\n                errno = ENOTCONN;\n                break;\n        }\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 51.46093676311014}, {"code": "int BSD_close(int socket)    SOCKET *sock;\n\n    if ((sock = BSD_get_socket(socket)) == NULL) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n\n    sock->state = NOT_A_SOCKET;\n\n    if (close(sock->fd) == -1) {\n        switch (errno) {\n            case EBADF:\n                errno = EBADF;\n                break;\n            default:\n                errno = EINVAL;\n                break;\n        }\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 45.54788842231022}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog)    int response = listen(socket, backlog);\n    if (response == -1) {\n        BSD_ERROR_NUMBER = errno;\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 15.620815757189321}, {"code": "int BSD_listen(int socket, int backlog)    int response = listen(socket, backlog);\n    if (response < 0) {\n        errno = errno;\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 15.413023489705912}, {"code": "int BSD_listen(int socket, int backlog)    int response = listen(socket, backlog);\n    if (response < 0) {\n        BSD_set_error_number(errno);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 17.84855520488126}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)  int ret;\n  struct sockaddr * sockaddr;\n  socklen_t socklen;\n  switch (addr->sa_family) {\n  case AF_INET:\n    sockaddr = (struct sockaddr *) addr;\n    socklen = sizeof(struct sockaddr_in);\n    break;\n  case AF_INET6:\n    sockaddr = (struct sockaddr *) addr;\n    socklen = sizeof(struct sockaddr_in6);\n    break;\n  default:\n    errno = EAFNOSUPPORT;\n    return -1;\n  }\n  ret = accept(socket, sockaddr, addrlen);\n  if (ret < 0) {\n    if (socket < 0) {\n      errno = EBADF;\n    } else {\n      errno = errno;\n    }\n    return -1;\n  }\n  return ret;\n}\n", "CodeBleu_score": 46.2557077596082}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)    int ret;\n    struct sockaddr * addr_ptr = (struct sockaddr *) addr;\n    socklen_t * addrlen_ptr = (socklen_t *) addrlen;\n\n    if (addr_ptr == NULL) {\n        addr_ptr = (struct sockaddr *) &addr;\n    }\n\n    if (addrlen_ptr == NULL) {\n        addrlen_ptr = (socklen_t *) &addrlen;\n    }\n\n    if (addr_ptr->sa_family == AF_INET) {\n        ret = accept(socket, addr_ptr, addrlen_ptr);\n    } else {\n        errno = EAFNOSUPPORT;\n        return -1;\n    }\n\n    if (ret == -1) {\n        if (socket == -1) {\n            errno = EBADF;\n        } else if (socket == -2) {\n            errno = EINTR;\n        } else if (socket == -3) {\n            errno = EINVAL;\n        } else if (socket == -4) {\n            errno = ENOTSOCK;\n        } else if (socket == -5) {\n            errno = EOPNOTSUPP;\n        } else if (socket == -6) {\n            errno = EWOULDBLOCK;\n        } else if (socket == -7) {\n            errno = EAGAIN;\n        } else if (socket == -8) {\n            errno = ECONNABORTED;\n        } else if (socket == -9) {\n            errno = ECONNRESET;\n        } else if (socket == -10) {\n            errno = ENOBUFS;\n        } else if (socket == -11) {\n            errno = ENOTCONN;\n        } else if (socket == -12) {\n            errno = ESHUTDOWN;\n        } else if (socket == -13) {\n            errno = ETOOMANYREFS;\n        } else if (socket == -14) {\n            errno = ETIMEDOUT;\n        } else if (socket == -1", "CodeBleu_score": 37.63890142986429}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)  int ret;\n  struct sockaddr * saddr;\n  socklen_t saddrlen;\n  int saddr_size;\n\n  saddr = (struct sockaddr *) addr;\n  saddrlen = *addrlen;\n\n  if (saddr) {\n    saddr_size = sizeof(struct sockaddr_in6);\n  } else {\n    saddr_size = 0;\n  }\n\n  if (saddr && saddr_size > *addrlen) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (saddr_size) {\n    memset(saddr, 0, saddr_size);\n  }\n\n  ret = accept(socket, saddr, &saddrlen);\n  if (ret < 0) {\n    if (saddr && saddrlen) {\n      *addrlen = saddrlen;\n    }\n    return -1;\n  }\n\n  if (saddr) {\n    *addrlen = saddrlen;\n  }\n\n  return ret;\n}\n", "CodeBleu_score": 40.0586804300509}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT()  // Get current time in UNIX format\n  time_t now = time(NULL);\n\n  // Check if the time is valid\n  if (now < 0) {\n    Serial.println(\"Failed to obtain time\");\n    return;\n  }\n\n  // Update the JWT with the current time offset\n  jwt.setExpiration(now + 3600);\n\n  // Initiate the MQTT connection\n  mqttClient.begin(broker, port, net);\n  mqttClient.setOptions(180, true, 1000);\n  mqttClient.onMessage(messageReceived);\n\n  // Print a debug message\n  Serial.println(\"Attempting MQTT connection...\");\n\n  // Set a flag to send an MQTT SUBSCRIBE packet once the connection is established\n  connect_mqtt = true;\n}\n", "CodeBleu_score": 44.09830989653289}, {"code": "static void connectMQTT()    time_t now = time(NULL);\n    if (now > 0) {\n        updateJWT(now);\n        Serial.println(\"Connecting to MQTT...\");\n        mqttClient.connect();\n        Serial.println(\"MQTT Connected!\");\n        mqttClient.subscribe(MQTT_SUBSCRIBE_TOPIC);\n        mqttClient.onMessage(messageReceived);\n        sendMQTTSubscribe = true;\n    }\n}\n", "CodeBleu_score": 48.42700301227204}, {"code": "static void connectMQTT()  time_t now = time(NULL);\n  if (now < 0) {\n    return;\n  }\n  char time_str[20];\n  snprintf(time_str, sizeof(time_str), \"%lu\", now);\n  char jwt[1024];\n  snprintf(jwt, sizeof(jwt), \"{\\\"iat\\\":%s,\\\"exp\\\":%lu,\\\"aud\\\":\\\"%s\\\"}\", time_str, now + 60, project_id);\n  char signature[1024];\n  int signature_len = sign(jwt, signature);\n  if (signature_len < 0) {\n    return;\n  }\n  char username[1024];\n  snprintf(username, sizeof(username), \"unused:%s\", project_id);\n  char password[1024];\n  snprintf(password, sizeof(password), \"%s\", signature);\n  MQTTClient_connectOptions options = MQTTClient_connectOptions_initializer;\n  options.username = username;\n  options.password = password;\n  options.keepAliveInterval = 20;\n  options.cleansession = 1;\n  options.MQTTVersion = MQTTVERSION_3_1_1;\n  int rc = MQTTClient_connect(client, &options);\n  if (rc != MQTTCLIENT_SUCCESS) {\n    Serial.println(\"Failed to connect to MQTT broker\");\n    return;\n  }\n  Serial.println(\"Connected to MQTT broker\");\n  send_subscribe = 1;\n}\n", "CodeBleu_score": 38.67126491189358}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void)    MQTT_Client_t *client = MQTT_getClient();\n    MQTT_ClientConnection_t *connection = MQTT_getClientConnection();\n\n    if (client != NULL && connection != NULL) {\n        MQTT_LOG_D(\"Disconnecting from cloud service\");\n        MQTT_disconnect(client);\n    }\n}\n", "CodeBleu_score": 22.90519400211948}, {"code": "void CLOUD_disconnect(void)    if (MQTT_client.isConnected()) {\n        MQTT_client.disconnect();\n        log_debug(\"Disconnected from MQTT broker\");\n    }\n}\n", "CodeBleu_score": 25.483731973841362}, {"code": "void CLOUD_disconnect(void)    MQTT_Connection_t *connection;\n\n    if (mqttClient.state == MQTT_CONNECTED) {\n        connection = MQTT_getConnection(&mqttClient);\n        MQTT_disconnect(&mqttClient);\n        Log_Debug(\"Disconnected from %s:%d\\n\",\n                  connection->hostname, connection->port);\n    }\n}\n", "CodeBleu_score": 38.25255475470958}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  if (passed_wifi_creds) {\n    if (wifi_connectToAp(wifi_ssid, wifi_authmode, wifi_password)) {\n      return true;\n    }\n  } else {\n    if (wifi_connectToAp(default_wifi_ssid, default_wifi_authmode, default_wifi_password)) {\n      return true;\n    }\n  }\n  Serial.println(\"Failed to connect to WiFi\");\n  networking_error_status = 1;\n  return false;\n}\n", "CodeBleu_score": 44.08483767074731}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  if (passed_wifi_creds == 1) {\n    // If new credentials are provided, connect using them\n    if (!WiFi.begin(ssid, password)) {\n      // If the connection fails, log an error message and update the networking error status\n      Serial.println(\"Failed to connect to Wi-Fi using new credentials\");\n      networking_error_status = 1;\n      return false;\n    }\n  } else {\n    // If no new credentials are provided, connect using the default Wi-Fi settings\n    if (!WiFi.begin()) {\n      // If the connection fails, log an error message and update the networking error status\n      Serial.println(\"Failed to connect to Wi-Fi using default credentials\");\n      networking_error_status = 1;\n      return false;\n    }\n  }\n\n  // If the connection succeeds, return true\n  return true;\n}\n", "CodeBleu_score": 44.19808593728998}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  if (passed_wifi_creds) {\n    // If new credentials are provided, connect using them\n    WiFi.begin(ssid, pass);\n  } else {\n    // If no credentials are provided, connect using the default Wi-Fi settings\n    WiFi.begin();\n  }\n\n  // Wait for the connection to be established\n  for (int i = 0; i < 10 && WiFi.status() != WL_CONNECTED; i++) {\n    delay(1000);\n  }\n\n  // Check if the connection was successful\n  if (WiFi.status() != WL_CONNECTED) {\n    // If the connection failed, log an error message, update the networking error status, and return false\n    Serial.println(\"Failed to connect to Wi-Fi.\");\n    networking_error = true;\n    return false;\n  }\n\n  // If the connection was successful, return true\n  return true;\n}\n", "CodeBleu_score": 44.83829991805048}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map)  const client = new ApolloClient({\n    uri: 'http://localhost:4000/graphql',\n    cache: new InMemoryCache(),\n  });\n\n  try {\n    const { data } = await client.query({\n      query: gql`\n        query {\n          sensors {\n            id\n            name\n            latitude\n            longitude\n            battery\n            temperature\n            humidity\n            pressure\n            altitude\n            last_measurement\n          }\n        }\n      `,\n    });\n\n    console.log('API Response:', data);\n\n    if (data.sensors.length > 0) {\n      console.log('Retrieved sensors:', data.sensors);\n\n      data.sensors.forEach((sensor) => {\n        const marker = L.marker([sensor.latitude, sensor.longitude]).addTo(map);\n        marker.bindPopup(`\n          <h3>${sensor.name}</h3>\n          <p>Battery: ${sensor.battery}</p>\n          <p>Temperature: ${sensor.temperature}</p>\n          <p>Humidity: ${sensor.humidity}</p>\n          <p>Pressure: ${sensor.pressure}</p>\n          <p>Altitude: ${sensor.altitude}</p>\n          <p>Last Measurement: ${sensor.last_measurement}</p>\n        `);\n      });\n    }\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}", "CodeBleu_score": 35.557345957216384}, {"code": "async function DisplaySensors(map)  // Create a new Apollo client\n  const client = new ApolloClient({\n    uri: \"https://api.tfl.gov.uk/graphql\",\n  });\n\n  // Send a GraphQL query to fetch sensor data\n  const { data } = await client.query({\n    query: gql`\n      query {\n        road {\n          id\n          displayName\n          sensors {\n            values {\n              value\n              id\n              measuredTime\n              measuredTime_ISO8601\n            }\n          }\n        }\n      }\n    `,\n  });\n\n  // Log the API response\n  console.log(data);\n\n  // If the response contains data\n  if (data) {\n    // Log the retrieval of sensors\n    console.log(\"retrieved sensors\");\n\n    // Iterate through each sensor\n    data.road.forEach((sensor) => {\n      // Create a marker for the sensor\n      const marker = L.marker([\n        sensor.latitude,\n        sensor.longitude,\n      ]).addTo(map);\n    });\n  }\n}", "CodeBleu_score": 39.91555971570844}, {"code": "async function DisplaySensors(map)    const client = new ApolloClient({\n        uri: 'https://api.toumea.fr/graphql',\n        cache: new InMemoryCache(),\n    });\n\n    const { data } = await client.query({\n        query: gql`\n            query {\n                sensors {\n                    id\n                    name\n                    latitude\n                    longitude\n                }\n            }\n        `,\n    });\n\n    console.log(data);\n\n    if (data.sensors) {\n        console.log('Retrieving sensors...');\n        data.sensors.forEach(sensor => {\n            const marker = L.marker([sensor.latitude, sensor.longitude], {\n                icon: L.icon({\n                    iconUrl: 'https://unpkg.com/leaflet@1.6.0/dist/images/marker-icon.png',\n                    iconSize: [25, 41],\n                    iconAnchor: [12, 41],\n                }),\n            });\n            marker.addTo(map);\n        });\n    }\n}", "CodeBleu_score": 38.51631404263088}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>    const marker = document.createElement('div');\n    marker.id = sensor.id;\n    marker.className = 'marker';\n    marker.style.backgroundColor = '#000000';\n    marker.style.border = '1px solid #000000';\n    return marker;\n};\n", "CodeBleu_score": 35.03335134158684}, {"code": "const CreateSensorMarker = (sensor) =>    const marker = document.createElement(\"div\");\n    marker.id = sensor.id;\n    marker.className = \"marker\";\n    marker.style.backgroundColor = \"red\";\n    marker.style.border = \"1px solid black\";\n    return marker;\n}\n", "CodeBleu_score": 35.35137351074322}, {"code": "const CreateSensorMarker = (sensor) =>  const marker = document.createElement('div');\n  marker.id = `marker-${sensor.id}`;\n  marker.classList.add('marker');\n  marker.style.backgroundColor = 'red';\n  marker.style.border = '1px solid white';\n  return marker;\n};\n", "CodeBleu_score": 32.401674571643845}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"{__package__}.mfa.{module_name}\"\n    try:\n        module = import_module(module_path)\n    except ModuleNotFoundError as err:\n        _LOGGER.error(\"Failed to load module %s: %s\", module_path, err)\n        raise\n    if hasattr(module, \"REQUIREMENTS\") and not skip_pip_installation(hass):\n        await async_process_requirements(\n            hass, f\"{__package__}.mfa.{module_name}\", module.REQUIREMENTS\n        )\n    if module_name not in hass.data.get(DATA_MFA_AUTH_MODULES, []):\n        hass.data.setdefault(DATA_MFA_AUTH_MODULES, []).append(module_name)\n    return module\n\n", "CodeBleu_score": 36.816421563906175}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"{__package__}.{module_name}\"\n    try:\n        module = import_module(module_path)\n    except ModuleNotFoundError:\n        _LOGGER.error(\"Failed to find module %s\", module_path)\n        raise\n\n    if hasattr(module, \"REQUIREMENTS\") and not skip_pip_installation(hass):\n        await async_process_requirements(\n            hass, module_name, module.REQUIREMENTS\n        )\n\n    if module_path not in hass.data.get(DATA_MULTI_FACTOR_AUTH_MODULE_ALIASES, {}):\n        hass.data.setdefault(DATA_MULTI_FACTOR_AUTH_MODULE_ALIASES, {})[\n            module_path\n        ] = module_name\n\n    return module\n\n", "CodeBleu_score": 32.78243481758095}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"{__package__}.mfa.{module_name}\"\n    try:\n        module = import_module(module_path)\n    except ModuleNotFoundError as e:\n        _LOGGER.error(\"Failed to load MFA module %s: %s\", module_name, e)\n        raise\n    if hasattr(module, \"REQUIREMENTS\") and not skip_pip_installation(hass):\n        await async_process_requirements(\n            hass, f\"{__package__}.mfa.{module_name}\", module.REQUIREMENTS\n        )\n    return module\n\n", "CodeBleu_score": 30.02031216463017}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data[\"pin\"]\n    for index, data in enumerate(self.data[\"users\"]):\n        if data[\"user_id\"] == user_id:\n            self.data[\"users\"][index][\"pin\"] = pin\n            return\n    self.data[\"users\"].append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 55.64733875851622}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data[\"pin\"]\n    for data in self._data:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = pin\n            return\n    self._data.append({\"user_id\": user_id, \"pin\": pin})\n\n", "CodeBleu_score": 80.42675528111758}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data[\"pin\"]\n    for data in self.data[\"users\"]:\n        if data[\"user_id\"] == user_id:\n            data[\"pin\"] = pin\n            return self.async_create_entry(title=\"\", data=self.data)\n    self.data[\"users\"].append({\"user_id\": user_id, \"pin\": pin})\n    return self.async_create_entry(title=\"\", data=self.data)\n", "CodeBleu_score": 63.51892565127648}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        try:\n            data = await self._user_store.async_load()\n        except Exception as e:\n            self._logger.exception(\n                \"Error loading user settings from store. Using empty user settings.\",\n                exc_info=e,\n            )\n            data = {}\n\n        if data is None:\n            data = {}\n\n        self._user_settings = {\n            user_id: NotifySetting(\n                user_id,\n                notify_setting.get(\"notify_settings\", {}),\n                notify_setting.get(\"notify_settings_v2\", {}),\n            )\n            for user_id, notify_setting in data.items()\n        }\n\n", "CodeBleu_score": 41.53253641083779}, {"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._user_store.async_load()\n        if data is None:\n            data = {}\n\n        self._user_settings = {}\n        for user_id, user_data in data.items():\n            self._user_settings[user_id] = {\n                notify_type: NotifySetting(\n                    notify_type,\n                    notify_type in user_data[\"notify_types\"],\n                    user_data[\"notify_types\"][notify_type][\"notify_on_call\"],\n                    user_data[\"notify_types\"][notify_type][\"notify_on_ring\"],\n                )\n                for notify_type in user_data[\"notify_types\"]\n            }\n\n", "CodeBleu_score": 39.708330542894906}, {"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n\n        data = await self._user_store.async_load()\n        if data is None:\n            data = {}\n\n        self._user_settings = {}\n        for user_id, user_data in data.items():\n            self._user_settings[user_id] = {}\n            for notify_type, notify_data in user_data.items():\n                self._user_settings[user_id][notify_type] = NotifySetting(\n                    notify_type, notify_data\n                )\n\n", "CodeBleu_score": 39.329354453568534}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self.async_load_settings(user_id)\n    settings = self._settings.get(user_id)\n    if settings is None:\n        return False\n    notification_settings = settings.get(\"notification_settings\")\n    if notification_settings is None:\n        return False\n    otp = user_input.get(\"otp\")\n    if otp is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        lambda: self._validate_otp(notification_settings, otp)\n    )\n\n", "CodeBleu_score": 54.36510889779328}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self.async_load_user_settings(user_id)\n    settings = self._user_settings.get(user_id)\n    if not settings:\n        return False\n    otp = settings.get(\"otp\")\n    if not otp:\n        return False\n    loop = asyncio.get_running_loop()\n    result = await loop.run_in_executor(None, self._validate_otp, otp, user_input[\"otp\"])\n    return result\n\n", "CodeBleu_score": 46.44858652259627}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self.async_load_user_settings(user_id)\n    settings = self.user_settings.get(user_id)\n    if settings is None:\n        return False\n    otp = user_input.get(CONF_OTP)\n    if otp is None:\n        return False\n    return await self.hass.async_add_executor_job(\n        validate_otp, settings.secret, otp, settings.counter\n    )\n\n", "CodeBleu_score": 54.77735299311046}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    area_id = device_entry.area_id\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 79.21330451259959}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n    device_id = entity_entry.device_id\n    if device_id is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 67.62416786281416}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.entity_registry.async_get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.device_registry.async_get(entity_entry.device_id)\n    if device_entry is None or device_entry.area_id is None:\n        return None\n    return area_dict.get(device_entry.area_id)\n\n", "CodeBleu_score": 79.14617373095842}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = subcategories\n            else:\n                merged_policy[category] |= subcategories\n\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 49.25284839535737}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = subcategories\n            else:\n                merged_policy[category] = {\n                    **merged_policy[category],\n                    **subcategories,\n                }\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 47.72372555286659}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, subcategories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {\n                    subcategory: sum(\n                        policy.get(category, {}).get(subcategory, 0)\n                        for policy in policies\n                    )\n                    for subcategory in subcategories\n                }\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 47.5056782223144}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = await async_get_auth_provider_module(hass, provider)\n    except ImportError as err:\n        _LOGGER.error(\"Error trying to set up auth provider %s: %s\", provider, err)\n        raise HomeAssistantError() from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    processed = hass.data.get(DATA_SETUP_PROGRESS, set())\n    if module in processed:\n        return module\n\n    processed.add(module)\n    hass.data[DATA_SETUP_PROGRESS] = processed\n\n    await async_process_requirements(\n        hass, f\"auth_provider_{provider}\", module.REQUIREMENTS\n    )\n\n    return module\n\n", "CodeBleu_score": 48.909608934888034}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = await async_get_integration_with_requirements(\n            hass, provider, _LOGGER\n        )\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Error while importing %s: %s\", provider, err)\n        raise\n\n    if module.domain and module.domain in _MODULES_WITH_REQUIREMENTS:\n        processed = hass.data.get(DATA_PROCESSED)\n        if processed is None:\n            processed = hass.data[DATA_PROCESSED] = set()\n        if module.domain not in processed:\n            await process_requirements(\n                hass, provider, module.requirements\n            )\n            processed.add(module.domain)\n\n    return module\n\n", "CodeBleu_score": 43.28958954431194}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = await async_get_auth_provider_module(hass, provider)\n    except HomeAssistantError as err:\n        _LOGGER.error(\"Error loading auth provider %s: %s\", provider, err)\n        raise\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not module.REQUIREMENTS:\n        return module\n\n    processed = hass.data.get(DATA_SETUP_PROGRESS)\n    if processed is None:\n        processed = hass.data[DATA_SETUP_PROGRESS] = set()\n    processed.add(provider)\n\n    await async_process_requirements(\n        hass, f\"auth_provider {provider}\", module.REQUIREMENTS\n    )\n\n    return module\n\n", "CodeBleu_score": 50.361962716845454}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n    try:\n        data = await self._store.async_load()\n        if data is None:\n            data = {\"users\": []}\n    except Exception as e:\n        _LOGGER.error(\"Failed to load users\", exc_info=e)\n        data = {\"users\": []}\n    self._data = data\n    self._users = {user[\"id\"]: user for user in data[\"users\"]}\n\n    # Check for non-normalized usernames\n    for user in self._users.values():\n        if user[\"username\"] != user[\"username\"].lower():\n            _LOGGER.warning(\n                \"User %s has a non-normalized username. This will be fixed on save.\",\n                user[\"username\"],\n            )\n            user[\"username\"] = user[\"username\"].lower()\n\n", "CodeBleu_score": 37.076293377583866}, {"code": "async def async_load(self) -> None\n    try:\n        self.users = await self.store.async_load()\n    except Exception:\n        self.users = []\n\n    for user in self.users:\n        if user.username.lower() != user.username:\n            user.username = user.username.lower()\n\n", "CodeBleu_score": 27.013868560921328}, {"code": "async def async_load(self) -> None\n    try:\n        self._users = await self._store.async_load()\n    except Exception:\n        self._users = []\n    for user in self._users:\n        if \"username\" in user and not is_normalized_username(user[\"username\"]):\n            user[\"username\"] = normalize_username(user[\"username\"])\n\n", "CodeBleu_score": 29.53088066860979}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n    username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt()).decode()\n    for user in self.users:\n        if user.username == username:\n            hashed_password = user.password.encode()\n            if not bcrypt.checkpw(password.encode(), hashed_password):\n                raise InvalidAuth(\"Invalid username or password\")\n            return\n    bcrypt.checkpw(password.encode(), dummy_hash.encode())\n    raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 41.25804074306212}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.strip().lower()\n    dummy_hash = bcrypt.hashpw(password.encode(\"utf-8\"), bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            password_hash = base64.b64decode(user.password_hash.encode(\"utf-8\"))\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid username or password\")\n    # Perform a dummy hash check to prevent timing attacks\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 39.77113413850211}, {"code": "def validate_login(self, username: str, password: str) -> None\n    normalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == normalized_username:\n            password_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid password\")\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n    raise InvalidAuth(\"Invalid username\")", "CodeBleu_score": 40.32960983590503}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n    username = self.normalize_username(username)\n    found = False\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            found = True\n            break\n    if not found:\n        raise InvalidUser(\"user_not_found\")\n", "CodeBleu_score": 36.15517293340859}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = username.lower()\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")", "CodeBleu_score": 26.007322982359536}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = self._normalize_username(username)\n    user = await self._async_find_user(username)\n    if user is None:\n        raise InvalidUser(\"user_not_found\")\n    self.users.remove(user)\n\n", "CodeBleu_score": 28.523885585026466}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.data:\n        self.data = {}\n    try:\n        self.data.pop(credentials.data[CONF_USERNAME])\n    except KeyError:\n        pass\n    await self.async_save()\n\n", "CodeBleu_score": 37.62506528623103}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if self._data is None:\n        await self.async_initialize()\n    try:\n        self._data.pop(credentials.data[CONF_USERNAME])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 51.04750063011818}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self._data:\n        self._data = await self.async_load()\n\n    try:\n        self._data.pop(credentials.data[\"username\"])\n    except KeyError:\n        pass\n    await self.async_save(self._data)\n\n", "CodeBleu_score": 48.67581874253789}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    for thread in threads:\n        if not thread.is_alive():\n            continue\n        if not thread.ident:\n            continue\n        thread_timeout = timeout - (time() - thread.start_time)\n        if thread_timeout <= 0:\n            continue\n        thread.join(thread_timeout)\n        if not thread.is_alive():\n            continue\n        if not thread.ident:\n            continue\n        if log:\n            log_info(f\"Thread {thread.name} is still running\")\n        thread.raise_exception()\n    return {thread for thread in threads if not thread.is_alive()}\n\n", "CodeBleu_score": 42.66801225130929}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    for thread in threads:\n        thread.timeout = timeout\n        try:\n            thread.join(timeout)\n            if not thread.is_alive() or not thread.ident:\n                joined.add(thread)\n        except KeyboardInterrupt:\n            pass\n    if log:\n        for thread in threads - joined:\n            log.warning(f\"Thread {thread.name} is still running\")\n    for thread in threads - joined:\n        try:\n            thread.raise_exc(SystemExit)\n        except Exception:\n            pass\n    return joined", "CodeBleu_score": 43.468789779646634}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    for thread in threads:\n        timeout_for_thread = timeout / len(threads)\n        thread.join(timeout=timeout_for_thread)\n        if not thread.is_alive() or thread.ident is None:\n            joined.add(thread)\n        elif log:\n            print(f\"Thread {thread.ident} is still running.\")\n    for thread in threads - joined:\n        thread.raise_exception()\n    return joined\n\n", "CodeBleu_score": 53.361880317316654}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import logging\n    import time\n\n    # Get a list of all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon and t.is_alive()]\n\n    # Calculate a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads\n    timeout = SHUTDOWN_TIMEOUT / len(threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        thread.join(timeout)\n        if thread.is_alive():\n            logging.warning(f\"Thread {thread.name} did not shut down within the timeout\")\n", "CodeBleu_score": 46.71433674632354}, {"code": "def deadlock_safe_shutdown() -> None\n    # Get all non-main, non-daemon, alive threads\n    threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.daemon and t.is_alive()]\n\n    # Calculate timeout for each thread based on total shutdown timeout\n    timeout = SHUTDOWN_TIMEOUT / len(threads)\n\n    # Attempt to join each thread within timeout\n    for t in threads:\n        t.join(timeout)\n        if t.is_alive():\n            logging.warning(f\"Thread {t.name} did not shut down within {timeout} seconds.\")", "CodeBleu_score": 26.76279276611322}, {"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import time\n    import logging\n\n    logger = logging.getLogger(__name__)\n\n    def shutdown_thread(thread: threading.Thread, timeout: float) -> None:\n        \"\"\"Attempts to join the given thread within the given timeout.\n\n        Args:\n            thread (threading.Thread): The thread to join.\n            timeout (float): The timeout in seconds.\n\n        Returns:\n            None\n        \"\"\"\n        start_time = time.time()\n        while thread.is_alive():\n            thread.join(timeout=timeout)\n            if time.time() - start_time >= timeout:\n                logger.warning(f\"Thread {thread.name} did not join within {timeout} seconds.\")\n                break\n\n    def get_remaining_threads() -> list[threading.Thread]:\n        \"\"\"Returns a list of all non-main, non-daemon, alive threads.\n\n        Returns:\n            list[threading.Thread]: The list of remaining threads.\n        \"\"\"\n        return [thread for thread in threading.enumerate() if thread != threading.main_thread() and not thread.daemon and thread.is_alive()]\n\n    def calculate_timeout(remaining_threads: list[threading.Thread], total_timeout: float) -> float:\n        \"\"\"Calculates the timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\n\n        Args:\n            remaining_threads (list[threading.Thread]): The list of remaining threads.\n            total_timeout (float): The total shutdown timeout in seconds.\n\n        Returns:\n            float: The calculated timeout in seconds.\n        \"\"\"\n        return total_timeout / len(remaining_threads)\n\n    def shutdown(total_timeout: float) -> None:\n        \"\"\"Performs a shutdown that avoids deadlocks.\n\n        Args:\n            total_timeout (float): The total shutdown timeout in seconds.\n\n        Returns:\n            None\n        \"\"\"\n        remaining_threads = get_remaining_threads()\n        timeout = calculate_timeout(remaining_threads, total_timeout)\n        for thread in remaining_threads:", "CodeBleu_score": 41.26381980934889}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None    if remaining_with_setup_started or self._previous_state:\n        self.hass.helpers.dispatcher.async_dispatcher_send(\n            self.hass, self._internal_dispatcher_signal\n        )\n        self._previous_state = remaining_with_setup_started\n    else:\n        self._previous_state = None\n\n", "CodeBleu_score": 45.12465510664151}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None    if remaining_with_setup_started or self._previous_remaining_setups:\n        self._hass.helpers.dispatcher.async_dispatcher_send(\n            self.hass, self._internal_dispatcher_signal\n        )\n        self._previous_remaining_setups = remaining_with_setup_started", "CodeBleu_score": 46.253368470620735}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None    if remaining_with_setup_started or self._previous_state:\n        self.hass.helpers.dispatcher.async_dispatcher_send(\n            self._dispatcher_signal, remaining_with_setup_started\n        )\n    self._previous_state = remaining_with_setup_started", "CodeBleu_score": 46.45852805470595}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations, config)\n\n    if not config.specific_integrations:\n        return\n\n    if not (\n        bt_config := config.specific_integrations.get(\"bluetooth\", {})\n    ).get(\"path\"):\n        bt_config[\"path\"] = str(bluetooth_path)\n\n    current = config.path_cache.get(bluetooth_path, \"\").splitlines()\n    new = content.splitlines()\n\n    if current != new:\n        bt_config[\"content\"] = content\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n        )", "CodeBleu_score": 61.27664169685582}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\n    bluetooth_path = config.path(\"homeassistant/generated/bluetooth.py\")\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations, config)\n\n    if not gc[\"bluetooth\"] or gc[\"bluetooth\"] != content:\n        config.add_error(\"bluetooth\", \"File bluetooth.py is not up to date\")\n\n        if not config.specific_integrations:\n            current = config.path(\"homeassistant/components/bluetooth.py\").read_text()\n\n            if current != content:\n                config.add_error(\n                    \"bluetooth\", \"File bluetooth.py is not up to date\", fixable=True\n                )\n        return\n\n    with open(str(bluetooth_path), \"w\") as fp:\n        fp.write(config.cache[\"bluetooth\"])\n", "CodeBleu_score": 57.01477018580585}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    bluetooth_path = config.root / \"homeassistant/generated/bluetooth.py\"\n    config.cache[\"bluetooth\"] = content = generate_and_validate(integrations, config)\n\n    if not content:\n        return\n\n    with open(str(bluetooth_path), \"r\") as fp:\n        current = fp.read().strip()\n\n    if current != content:\n        config.add_error(\n            \"bluetooth\",\n            \"File bluetooth.py is not up to date. Run python3 -m script.hassfest\",\n            fixable=True,\n        )\n        return\n\n    with open(str(bluetooth_path), \"w\") as fp:\n        fp.write(f\"{content}\\n\")\n", "CodeBleu_score": 72.89853069960745}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error\tdata := url.Values{}\n\tdata.Set(\"grant_type\", \"refresh_token\")\n\tdata.Set(\"refresh_token\", d.refreshToken)\n\tdata.Set(\"client_id\", d.appKey)\n\tdata.Set(\"client_secret\", d.appSecret)\n\n\tresp, err := http.PostForm(\"https://api.dropboxapi.com/oauth2/token\", data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\trespBody, _ := io.ReadAll(resp.Body)\n\t\tlog.Printf(\"Error refreshing token: %s\", respBody)\n\t\treturn fmt.Errorf(\"error refreshing token: %s\", respBody)\n\t}\n\n\tvar tokenResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\n\tif err := json.NewDecoder(resp.Body).Decode(&tokenResponse); err != nil {\n\t\treturn err\n\t}\n\n\td.accessToken = tokenResponse.AccessToken\n\treturn nil\n}", "CodeBleu_score": 50.02638808945306}, {"code": "func (d *Dropbox) refreshToken() error\t// Set up the request body with the refresh token and app key and secret\n\tbody := map[string]string{\n\t\t\"grant_type\":    \"refresh_token\",\n\t\t\"refresh_token\": d.RefreshToken,\n\t\t\"client_id\":     d.AppKey,\n\t\t\"client_secret\": d.AppSecret,\n\t}\n\n\t// Encode the request body as URL-encoded form data\n\tdata := url.Values{}\n\tfor k, v := range body {\n\t\tdata.Set(k, v)\n\t}\n\n\t// Create a new HTTP request with the POST method and the token endpoint URL\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(data.Encode()))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers to specify that the request body is URL-encoded form data\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request and get the response\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read the response body\n\trespBody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the response status code is not 200 (OK), log the response and return an error\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"Error refreshing token: %s\", respBody)\n\t\treturn fmt.Errorf(\"error refreshing token: %s\", respBody)\n\t}\n\n\t// Parse the response body as JSON and extract the access token\n\tvar respData map[string]interface{}\n\terr = json.Unmarshal(respBody, &respData)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.AccessToken = respData[\"access_token\"].(string)\n\n\treturn nil\n}\n", "CodeBleu_score": 50.76733855625617}, {"code": "func (d *Dropbox) refreshToken() error\t// Prepare the request body\n\tdata := url.Values{}\n\tdata.Set(\"grant_type\", \"refresh_token\")\n\tdata.Set(\"refresh_token\", d.RefreshToken)\n\n\t// Send the POST request\n\tresp, err := http.PostForm(\"https://api.dropbox.com/oauth2/token\", data)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the response status code\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"Dropbox: Failed to refresh token. Status code: %d\", resp.StatusCode)\n\t\treturn fmt.Errorf(\"failed to refresh token. status code: %d\", resp.StatusCode)\n\t}\n\n\t// Parse the response body\n\tvar result struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn err\n\t}\n\n\t// Update the access token\n\td.AccessToken = result.AccessToken\n\n\treturn nil\n}", "CodeBleu_score": 50.69320403598226}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\tparams := req.URL.Query()\n\tparams.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = params.Encode()\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tclient := &http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode != http.StatusOK {\n\t\tif res.StatusCode == http.StatusUnauthorized {\n\t\t\td.RefreshToken()\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d: %s\", res.StatusCode, string(body))\n\t}\n\n\tif resp != nil {\n\t\tif err := json.Unmarshal(body, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}\n", "CodeBleu_score": 61.56558319254655}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tclient := &http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode == http.StatusUnauthorized {\n\t\ttoken, err := d.RefreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\td.AccessToken = token.AccessToken\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode != http.StatusOK {\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d: %s\", res.StatusCode, string(body))\n\t}\n\n\tif resp != nil {\n\t\tif err := json.Unmarshal(body, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 59.151615095820965}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\n\tvalues := req.URL.Query()\n\tvalues.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = values.Encode()\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tclient := http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res.StatusCode != http.StatusOK {\n\t\tif res.StatusCode == http.StatusUnauthorized {\n\t\t\ttoken, err := d.RefreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\td.AccessToken = token\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\treturn nil, fmt.Errorf(\"request failed with status code %d: %s\", res.StatusCode, string(body))\n\t}\n\n\tif resp != nil {\n\t\tif err := json.Unmarshal(body, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn body, nil\n}", "CodeBleu_score": 60.518503418607075}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\tchunkSize := d.chunkSize\n\tif chunkSize <= 0 {\n\t\tchunkSize = defaultChunkSize\n\t}\n\tchunkSize = maxChunkSize(chunkSize)\n\tchunkSize = minChunkSize(chunkSize)\n\n\toffset := int64(0)\n\tsize := stream.GetSize()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tchunk, err := stream.Read(chunkSize)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tchunkLen := len(chunk)\n\t\t\toffset += int64(chunkLen)\n\t\t\tif chunkLen == 0 {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, bytes.NewReader(chunk))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treq.ContentLength = int64(chunkLen)\n\t\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset-int64(chunkLen), offset-1, size))\n\t\t\treq.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", chunkLen))\n\t\t\tres, err := d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif res.StatusCode != http.StatusCreated && res.StatusCode != http.StatusOK {\n\t\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", res.StatusCode)\n\t\t\t}\n\t\t\tres.Body.Close()\n\t\t}\n\t}\n}", "CodeBleu_score": 46.66855737062098}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate the chunk size based on the file size.\n\tchunkSize := int64(math.Ceil(float64(stream.GetSize()) / float64(d.ChunkSize)))\n\tchunkSize = utils.Max(chunkSize, 256*1024)\n\n\t// Upload each chunk sequentially until the entire file is uploaded.\n\tfor {\n\t\t// Check for context cancellation.\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Read the next chunk of data from the file stream.\n\t\tchunk, err := stream.Read(chunkSize)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the chunk is empty, it means we've reached the end of the file.\n\t\tif len(chunk) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Create a new HTTP request for the chunk upload.\n\t\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, bytes.NewReader(chunk))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Set the required headers for the chunk upload.\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\treq.Header.Set(\"Content-Length\", strconv.Itoa(len(chunk)))\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", stream.GetReaded(), stream.GetReaded()+int64(len(chunk))-1, stream.GetSize()))\n\n\t\t// Send the HTTP request and handle the response.\n\t\tres, err := d.Client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer res.Body.Close()\n\n\t\t// Check the response status code.\n\t\tif res.StatusCode != http.StatusOK && res.StatusCode != http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"chunk upload failed with status code %d\", res.StatusCode)", "CodeBleu_score": 42.433147117115446}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\tchunkSize := d.conf.ChunkSize * 1024 * 1024\n\tfileSize := stream.GetSize()\n\tchunkNum := int(math.Ceil(float64(fileSize) / float64(chunkSize)))\n\tcurrentChunk := 0\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\tif currentChunk == chunkNum {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tstart := currentChunk * chunkSize\n\t\t\tend := start + chunkSize\n\t\t\tif end > fileSize {\n\t\t\t\tend = fileSize\n\t\t\t}\n\t\t\tdata := make([]byte, end-start)\n\t\t\t_, err := stream.Read(data)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, bytes.NewReader(data))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\t\treq.Header.Set(\"Content-Length\", strconv.Itoa(end-start))\n\t\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", start, end-1, fileSize))\n\t\t\tres, err := d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer res.Body.Close()\n\t\t\tif res.StatusCode != http.StatusOK {\n\t\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", res.StatusCode)\n\t\t\t}\n\t\t\tcurrentChunk++\n\t\t}\n\t}\n}", "CodeBleu_score": 49.66406926827134}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error\treq := ctx.Request().Context()\n\n\tdata := &models.Storage{}\n\tif err := ctx.Bind(data); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, models.Response{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\n\tif data.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, models.Response{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: \"mount point is required\",\n\t\t})\n\t}\n\n\tif err := storage.UnmountStorage(req, data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, models.Response{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\n\tconfig.DeleteStorage(data.MountPoint)\n\n\treturn ctx.JSON(http.StatusOK, models.Response{\n\t\tStatus:  \"success\",\n\t\tMessage: \"storage unmounted successfully\",\n\t})\n}", "CodeBleu_score": 41.9107169809737}, {"code": "func UmountStorage(ctx echo.Context) error\treq := ctx.Request()\n\tbody, err := io.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\n\tvar data map[string]string\n\terr = json.Unmarshal(body, &data)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err)\n\t}\n\n\tmountPoint := data[\"mount_point\"]\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point is required\")\n\t}\n\n\tcmd := exec.Command(\"umount\", mountPoint)\n\terr = cmd.Run()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\tdelete(config.Storage, mountPoint)\n\n\treturn ctx.JSON(http.StatusOK, \"Storage unmounted successfully\")\n}", "CodeBleu_score": 38.2780605624139}, {"code": "func UmountStorage(ctx echo.Context) error\tvar req Request\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, Error{Code: http.StatusBadRequest, Message: \"bad request\"})\n\t}\n\n\tmountPoint := req.MountPoint\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, Error{Code: http.StatusBadRequest, Message: \"bad request\"})\n\t}\n\n\tcmd := exec.Command(\"umount\", mountPoint)\n\tif err := cmd.Run(); err != nil {\n\t\treturn ctx.JSON(http.StatusServiceUnavailable, Error{Code: http.StatusServiceUnavailable, Message: \"unable to unmount storage\"})\n\t}\n\n\tdelete(config.Storage, mountPoint)\n\n\treturn ctx.JSON(http.StatusOK, Success{Code: http.StatusOK, Message: \"success\"})\n}", "CodeBleu_score": 45.51289318822155}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing path parameter\"})\n\t}\n\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\tdefer file.Close()\n\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 35.02451060242117}, {"code": "func GetLocalFile(ctx echo.Context) error\tpath := ctx.QueryParam(\"path\")\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing path parameter\"})\n\t}\n\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\tdefer file.Close()\n\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 35.02451060242117}, {"code": "func GetLocalFile(ctx echo.Context) error\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Missing file path\"})\n\t}\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t\t}\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\tdefer file.Close()\n\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}", "CodeBleu_score": 33.622962041729544}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": err.Error()})\n\t}\n\n\tSendNotification(name, message)\n\treturn ctx.JSON(http.StatusOK, map[string]string{\"message\": \"Notification sent successfully\"})\n}", "CodeBleu_score": 52.53626989254106}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\tSendNotification(name, message)\n\treturn ctx.JSON(http.StatusOK, \"Success\")\n}", "CodeBleu_score": 49.11471574559605}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]interface{})\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"error\": err.Error(),\n\t\t})\n\t}\n\n\tnotify.SendNotification(name, message)\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"Notification sent successfully\",\n\t})\n}", "CodeBleu_score": 52.671728909185475}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Ensure that the message sending service is running\n\tgo sendMessages()\n\n\tfor {\n\t\t// Read messages from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type and message\n\t\tlog.Println(\"Message type:\", messageType)\n\t\tlog.Println(\"Message:\", string(message))\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 48.48953999408499}, {"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP GET request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\twsConnections = append(wsConnections, ws)\n\n\t// Ensure that the message sending service is running\n\tgo messageSender()\n\n\t// Continuously read messages from the WebSocket connection\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// Remove the WebSocket connection from the list of connections\n\t\t\twsConnections = removeConnection(wsConnections, ws)\n\t\t\tbreak\n\t\t}\n\n\t\t// Print the message type and message\n\t\tfmt.Printf(\"Message Type: %s, Message: %s\\n\", messageType, string(message))\n\n\t\t// Print any errors\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 47.17470187658047}, {"code": "func NotifyWS(ctx echo.Context) error\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\twsConnections = append(wsConnections, ws)\n\n\tif !isSendingMessage {\n\t\tisSendingMessage = true\n\t\tgo sendMessages()\n\t}\n\n\tfor {\n\t\t// Read\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"%s\\n\", msg)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 48.44992178821599}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tdriveModel := \"Unknown\"\n\tdriveArchitecture := \"Unknown\"\n\n\tdriveInfo, err := GetDriveInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to retrieve drive information\"})\n\t}\n\n\tif driveInfo != nil {\n\t\tdriveModel = driveInfo.Model\n\t\tdriveArchitecture = driveInfo.Architecture\n\t}\n\n\tcpuInfo, err := GetCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to retrieve CPU information\"})\n\t}\n\n\tresponse := map[string]interface{}{\n\t\t\"success\": true,\n\t\t\"data\": map[string]interface{}{\n\t\t\t\"driveModel\":        driveModel,\n\t\t\t\"driveArchitecture\": driveArchitecture,\n\t\t\t\"cpuInfo\":           cpuInfo,\n\t\t},\n\t}\n\n\treturn ctx.JSON(http.StatusOK, response)\n}\n", "CodeBleu_score": 20.721745735605513}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tdriveModel, driveArchitecture, err := getDriveInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\tcpuInfo, err := getCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"driveModel\":       driveModel,\n\t\t\"driveArchitecture\": driveArchitecture,\n\t\t\"cpuInfo\":          cpuInfo,\n\t})\n}\n", "CodeBleu_score": 20.226744212385196}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get the drive model and architecture\n\tdriveModel, driveArchitecture, err := GetDriveModelAndArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to get drive model and architecture\"})\n\t}\n\n\t// Get the CPU information\n\tcpuInfo, err := GetCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": \"Failed to get CPU information\"})\n\t}\n\n\t// Return the system hardware information as a JSON response\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"drive_model\":         driveModel,\n\t\t\"drive_architecture\":  driveArchitecture,\n\t\t\"cpu_info\":            cpuInfo,\n\t\t\"success_message\":     \"System hardware information retrieved successfully\",\n\t\t\"error_message\":       \"Failed to retrieve system hardware information\",\n\t\t\"error_code\":          \"HARDWARE_INFO_ERROR\",\n\t\t\"error_status_code\":   http.StatusInternalServerError,\n\t\t\"error_status_text\":   http.StatusText(http.StatusInternalServerError),\n\t\t\"error_status_number\": http.StatusInternalServerError,\n\t})\n}\n", "CodeBleu_score": 19.179604482822665}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos.\") {\n\t\t\tif systemctl.IsEnabled(service) && systemctl.IsActive(service) {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{true: &running, false: &notRunning}, nil\n}", "CodeBleu_score": 59.878324883220714}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\tresult := make(map[bool]*[]string)\n\tresult[true] = &running\n\tresult[false] = &notRunning\n\n\treturn result, nil\n}", "CodeBleu_score": 72.79920345037276}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := make([]string, 0)\n\tnotRunning := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}", "CodeBleu_score": 75.73258382598551}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Println(\"error marshalling message:\", err)\n\t\treturn\n\t}\n\n\tresp, err := i.messageBus.Publish(context.Background(), name, msg)\n\tif err != nil {\n\t\tlog.Println(\"error publishing message:\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"message publishing failed with status code %d: %s\\n\", resp.StatusCode, resp.Details)\n\t}\n}", "CodeBleu_score": 35.41108203648838}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tmessage[\"name\"] = name\n\tmessageJson, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tres, err := i.messageBus.Publish(context.Background(), \"notify\", string(messageJson))\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\tif res.Status != \"OK\" {\n\t\tlog.Println(\"failure:\", res.Status, string(res.Data))\n\t}\n}", "CodeBleu_score": 14.773453617798188}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tmsg, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Println(\"Failed to serialize message:\", err)\n\t\treturn\n\t}\n\n\tresponse, err := i.publisher.Publish(context.Background(), name, msg)\n\tif err != nil {\n\t\tlog.Println(\"Failed to publish event:\", err)\n\t\treturn\n\t}\n\n\tif response.Status != http.StatusOK {\n\t\tlog.Printf(\"Failed to publish event %s. Response status code: %d. Response details: %s\\n\", name, response.Status, response.Details)\n\t}\n}", "CodeBleu_score": 38.475863156307966}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(c.server)\n\n\taddress, err := c.runtime.Get(c.messageBusAddressPath)\n\tif err != nil {\n\t\tclient.Server = \"error: \" + err.Error()\n\t\treturn client\n\t}\n\n\tclient.Server = address\n\treturn client\n}", "CodeBleu_score": 38.71594952658602}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(c.runtime.GetMessageBusAddress())\n\tif c.runtime.IsMessageBusAvailable() {\n\t\tclient.Server = c.runtime.GetMessageBusAddress()\n\t} else {\n\t\tclient.Server = \"error: message bus not available\"\n\t}\n\treturn client\n}", "CodeBleu_score": 33.742768935291764}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(\"\")\n\taddress, err := c.Runtime.Get(messageBusAddressRuntimePath)\n\tif err != nil {\n\t\tclient.Server = \"error: failed to retrieve message bus address\"\n\t} else {\n\t\tclient.Server = string(address)\n\t}\n\treturn client\n}", "CodeBleu_score": 39.506738602970806}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string\tforwarded := request.Header.Get(\"x-forwarded-for\")\n\tif forwarded != \"\" {\n\t\tip := strings.Split(forwarded, \",\")[0]\n\t\treturn strings.TrimSpace(ip)\n\t}\n\n\tip := request.Header.Get(\"X-Real-IP\")\n\tif ip != \"\" {\n\t\treturn strings.TrimSpace(ip)\n\t}\n\n\tip, _, err := net.SplitHostPort(request.RemoteAddr)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\tuserIP := net.ParseIP(ip)\n\tif userIP == nil {\n\t\treturn \"\"\n\t}\n\n\t// This will only be defined when site is accessed via non-anonymous proxy\n\t// and takes precedence over RemoteAddr\n\t// Header.Get is case-insensitive\n\tforwarded := request.Header.Get(\"X-Forwarded-For\")\n\n\tif forwarded != \"\" {\n\t\t// X-Forwarded-For is potentially a list of addresses separated with \",\"\n\t\tparts := strings.Split(forwarded, \",\")\n\t\tfor i, p := range parts {\n\t\t\tparts[i] = strings.TrimSpace(p)\n\t\t}\n\t\t// TODO: should return first non-local address\n\t\treturn parts[0]\n\t}\n\n\treturn ip\n}", "CodeBleu_score": 41.50465400844715}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.Contains(ip, \"::1\") || strings.Contains(ip, \"::ffff:127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 47.19678773792025}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.Split(ip, \",\")[0]\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 63.35007039835967}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\tmodulesDir := \"./modules\"\n\tentryFilePath := \"./modules/entry.json\"\n\n\t// Ensure the entry file exists\n\t_, err := os.Stat(entryFilePath)\n\tif os.IsNotExist(err) {\n\t\t_, err := os.Create(entryFilePath)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error creating entry file:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tmodules := []string{}\n\terr = filepath.Walk(modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif info.IsDir() && path != modulesDir {\n\t\t\tentryFile := filepath.Join(path, \"entry.json\")\n\t\t\t_, err := os.Stat(entryFile)\n\t\t\tif err == nil {\n\t\t\t\tmodules = append(modules, entryFile)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tlog.Println(\"Error reading modules directory:\", err)\n\t\treturn\n\t}\n\n\t// Concatenate the content of each entry.json file into a single JSON array\n\tentries := []map[string]interface{}{}\n\tfor _, module := range modules {\n\t\tcontent, err := ioutil.ReadFile(module)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading entry file:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar entry map[string]interface{}\n\t\terr = json.Unmarshal(content, &entry)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error unmarshaling entry file:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, entry)\n\t}\n\n\t// Write the consolidated JSON array to the entry file path\n\tjsonData, err := json.MarshalIndent(entries, \"\", \"  \")\n\tif err != nil {\n\t\tlog.Println(\"Error marshaling JSON:\", err)\n\t\treturn\n\t}", "CodeBleu_score": 47.940383235802855}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Define paths for the modules directory and the entry file\n\tmodulesDir := \"./modules\"\n\tentryFilePath := \"./entry.json\"\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t_, err = os.Create(entryFilePath)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error creating entry file:\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tentryFiles, err := filepath.Glob(filepath.Join(modulesDir, \"*/entry.json\"))\n\tif err != nil {\n\t\tlog.Println(\"Error reading module directories:\", err)\n\t\treturn\n\t}\n\n\t// Concatenate the content of entry.json files into a single JSON array\n\tvar entries []map[string]interface{}\n\tfor _, file := range entryFiles {\n\t\tcontent, err := os.ReadFile(file)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading entry file:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tvar moduleEntries []map[string]interface{}\n\t\terr = json.Unmarshal(content, &moduleEntries)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error parsing entry file:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, moduleEntries...)\n\t}\n\n\t// Write the consolidated JSON array to the entry file path\n\tentryJSON, err := json.MarshalIndent(entries, \"\", \"  \")\n\tif err != nil {\n\t\tlog.Println(\"Error marshaling JSON:\", err)\n\t\treturn\n\t}\n\n\terr = os.WriteFile(entryFilePath, entryJSON, 0644)\n\tif err != nil {\n\t\tlog.Println(\"Error writing entry file:\", err)\n\t\treturn\n\t}\n\n\tlog.Println(\"System entry generated successfully\")\n}", "CodeBleu_score": 44.892918758555666}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Define paths for the modules directory and the entry file\n\tmodulesDir := \"./modules\"\n\tentryFilePath := \"./modules/entry.json\"\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t_, err := os.Create(entryFilePath)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error creating entry file: %v\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read each module directory for entry.json files\n\tentryFiles, err := ioutil.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlog.Printf(\"Error reading modules directory: %v\", err)\n\t\treturn\n\t}\n\n\tvar entryData []byte\n\tfor _, file := range entryFiles {\n\t\tif file.IsDir() {\n\t\t\tmoduleEntryFilePath := filepath.Join(modulesDir, file.Name(), \"entry.json\")\n\t\t\tmoduleEntryData, err := ioutil.ReadFile(moduleEntryFilePath)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error reading entry file for module %s: %v\", file.Name(), err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif entryData == nil {\n\t\t\t\tentryData = moduleEntryData\n\t\t\t} else {\n\t\t\t\tentryData = append(entryData[:len(entryData)-1], []byte(\",\")...)\n\t\t\t\tentryData = append(entryData, moduleEntryData[1:]...)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Write the consolidated entry data to the entry file\n\terr = ioutil.WriteFile(entryFilePath, entryData, 0644)\n\tif err != nil {\n\t\tlog.Printf(\"Error writing entry file: %v\", err)\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.623503790000015}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"no network interface found with a matching name\")\n}\n", "CodeBleu_score": 65.00937775578734}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no network interface found\")\n}\n", "CodeBleu_score": 65.58009924737208}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworks, err := c.GetNetworks()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, network := range networks {\n\t\t\tif iface.Name == network {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No network interfaces found\")\n}", "CodeBleu_score": 65.67978622151298}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)    int32_t ret = SUCCESS;\n\n    if (pRequest == NULL || pTscObj == NULL) {\n        return NULL_POINTER;\n    }\n\n    pthread_mutex_lock(&(pTscObj->mutex));\n    pTscObj->requestCount++;\n    pthread_mutex_unlock(&(pTscObj->mutex));\n\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->requestSummary.totalRequestCount++;\n        pTscObj->pAppInfo->requestSummary.currentRequestCount++;\n    }\n\n    TAILQ_INSERT_TAIL(&pRequest->tscList, pTscObj, tscListEntry);\n\n    if (pTscObj->pAppInfo != NULL) {\n        pTscObj->pAppInfo->requestSummary.totalRequestCount++;\n        pTscObj->pAppInfo->requestSummary.currentRequestCount++;\n    }\n\n    logDebug(\"Request %p registered with TSC %p\", pRequest, pTscObj);\n\n    return ret;\n}\n", "CodeBleu_score": 40.73911393393647}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)    int32_t ret = TSDB_CODE_SUCCESS;\n\n    pTscObj->requests++;\n    pTscObj->pRequests = tListAppend(pTscObj->pRequests, pRequest);\n\n    if (pTscObj->pAppInfo) {\n        pTscObj->pAppInfo->requests++;\n        pTscObj->pAppInfo->currentRequests++;\n    }\n\n    taosLogDebug(\"register request:%p, tsc:%p, tsc->requests:%d, tsc->currentRequests:%d, app:%p, app->requests:%d, app->currentRequests:%d\",\n                 pRequest, pTscObj, pTscObj->requests, pTscObj->currentRequests, pTscObj->pAppInfo,\n                 pTscObj->pAppInfo->requests, pTscObj->pAppInfo->currentRequests);\n\n    return ret;\n}", "CodeBleu_score": 41.07023362210364}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)    int32_t ret = SUCCESS;\n    int32_t totalRequests = 0;\n    int32_t currentRequests = 0;\n    int32_t applicationId = 0;\n\n    if (pTscObj->pApplication) {\n        totalRequests = pTscObj->pApplication->requestSummary.totalRequests;\n        currentRequests = pTscObj->pApplication->requestSummary.currentRequests;\n        applicationId = pTscObj->pApplication->applicationId;\n    }\n\n    atomic_fetch_add(&pTscObj->requestCount, 1);\n\n    if (pTscObj->pApplication) {\n        pTscObj->pApplication->requestSummary.totalRequests = totalRequests + 1;\n        pTscObj->pApplication->requestSummary.currentRequests = currentRequests + 1;\n    }\n\n    logDebug(\"Registering request %p with TSC %p, applicationId %d, totalRequests %d, currentRequests %d\", pRequest, pTscObj, applicationId, totalRequests + 1, currentRequests + 1);\n\n    return ret;\n}\n", "CodeBleu_score": 45.13273803919671}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    if (strcmp(pRequest->db, exceptDb) == 0) {\n        return true;\n    }\n    for (int i = 0; i < pRequest->dbCount; ++i) {\n        char *db = pRequest->dbList[i];\n        char *p = strchr(db, '.');\n        if (p) {\n            db = p + 1;\n        }\n        if (strcmp(db, exceptDb) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 60.46984181375805}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    if (pRequest->db == NULL) {\n        return false;\n    }\n    if (strcmp(pRequest->db, exceptDb) == 0) {\n        return false;\n    }\n    if (pRequest->dbList == NULL) {\n        return true;\n    }\n    SStrList *pDbList = pRequest->dbList;\n    for (int i = 0; i < pDbList->size; i++) {\n        char *db = pDbList->str[i];\n        if (strcmp(db, exceptDb) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 59.58385099971731}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)  if (pRequest->db != exceptDb) {\n    char *db = pRequest->db;\n    for (int i = 0; i < pRequest->dbNum; ++i) {\n      if (db[i] == '.') {\n        db = db + i + 1;\n      }\n      if (strcmp(db, exceptDb) == 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n", "CodeBleu_score": 51.81758226352541}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    if (code == -1) {\n        return true;\n    }\n    if (code == -2) {\n        return true;\n    }\n    if (code == -3) {\n        return true;\n    }\n    if (code == -4) {\n        return true;\n    }\n    if (code == -5) {\n        return true;\n    }\n    if (code == -6) {\n        return true;\n    }\n    if (code == -7) {\n        return true;\n    }\n    if (code == -8) {\n        return true;\n    }\n    if (code == -9) {\n        return true;\n    }\n    if (code == -10) {\n        return true;\n    }\n    if (code == -11) {\n        return true;\n    }\n    if (code == -12) {\n        return true;\n    }\n    if (code == -13) {\n        return true;\n    }\n    if (code == -14) {\n        return true;\n    }\n    if (code == -15) {\n        return true;\n    }\n    if (code == -16) {\n        return true;\n    }\n    if (code == -17) {\n        return true;\n    }\n    if (code == -18) {\n        return true;\n    }\n    if (code == -19) {\n        return true;\n    }\n    if (code == -20) {\n        return true;\n    }\n    if (code == -21) {\n        return true;\n    }\n    if (code == -22) {\n        return true;\n    }\n    if (code == -23) {\n        return true;\n    }\n    if (code == -24) {\n        return true;\n    }\n    if (code == -25) {\n        return true;\n    }\n    if (code == -26) {\n        return true;\n    }\n    if (code == -27) {\n        return true;\n    }\n    if (code == -28", "CodeBleu_score": 27.81882985717755}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    if (code == MPI_ERR_PROC_FAILED) {\n        return true;\n    }\n    if (code == MPI_ERR_COMM) {\n        return true;\n    }\n    if (code == MPI_ERR_INTERN) {\n        return true;\n    }\n    if (code == MPI_ERR_OTHER) {\n        return true;\n    }\n    if (code == MPI_ERR_PENDING) {\n        return true;\n    }\n    if (code == MPI_ERR_REQUEST) {\n        return true;\n    }\n    if (code == MPI_ERR_ROOT) {\n        return true;\n    }\n    if (code == MPI_ERR_RANK) {\n        return true;\n    }\n    if (code == MPI_ERR_TRUNCATE) {\n        return true;\n    }\n    if (code == MPI_ERR_UNKNOWN) {\n        return true;\n    }\n    if (code == MPI_ERR_IN_STATUS) {\n        return true;\n    }\n    if (code == MPI_ERR_TYPE) {\n        return true;\n    }\n    if (code == MPI_ERR_WIN) {\n        return true;\n    }\n    if (code == MPI_ERR_KEYVAL) {\n        return true;\n    }\n    if (code == MPI_ERR_LOCKTYPE) {\n        return true;\n    }\n    if (code == MPI_ERR_SERVICE) {\n        return true;\n    }\n    if (code == MPI_ERR_BASE) {\n        return true;\n    }\n    if (code == MPI_ERR_INFO_VALUE) {\n        return true;\n    }\n    if (code == MPI_ERR_INFO_NOKEY) {\n        return true;\n    }\n    if (code == MPI_ERR_INFO) {\n        return true;\n    }\n    if (code == MPI_ERR_SPAWN) {\n        return true;\n    }\n    if (code == MPI_ERR_PORT) {\n        return true;", "CodeBleu_score": 37.68523097703244}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    if (code == EHOSTUNREACH || code == ENETUNREACH || code == ENETDOWN || code == EHOSTDOWN || code == ENETRESET || code == ECONNRESET || code == ETIMEDOUT || code == ECONNREFUSED || code == EHOSTUNREACH || code == ENETUNREACH || code == ENETDOWN || code == EHOSTDOWN || code == ENETRESET || code == ECONNRESET || code == ETIMEDOUT || code == ECONNREFUSED) {\n        return true;\n    }\n    if (msgType == TMSG_RMID || msgType == TMSG_MKDIR || msgType == TMSG_RMDIR || msgType == TMSG_RENAME || msgType == TMSG_SYMLINK || msgType == TMSG_READLINK || msgType == TMSG_GETATTR || msgType == TMSG_ACCESS || msgType == TMSG_SETATTR || msgType == TMSG_MKNOD || msgType == TMSG_CREATE || msgType == TMSG_OPEN || msgType == TMSG_READ || msgType == TMSG_WRITE || msgType == TMSG_LSEEK || msgType == TMSG_CLOSE || msgType == TMSG_FSYNC || msgType == TMSG_FLUSH || msgType == TMSG_RELEASE || msgType == TMSG_OPENDIR || msgType == TMSG_READDIR || msgType == TMSG_RELEASEDIR || msgType == TMSG_FSYNCDIR || msgType == TMSG_GETXATTR || msgType == TMSG_SETXATTR || msgType == TMSG_REMOVEXATTR || msgType == TMSG_LISTXATTR || msgType == TMSG_ACCESSDIR) {\n        return false;\n    }\n    return true;\n}\n", "CodeBleu_score": 45.49622747042977}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests)  int requestId;\n  for (int i = 0; i < pRequests->size; i++) {\n    requestId = pRequests->pRequests[i].requestId;\n    if (requestId > 0) {\n      SRequest *pRequest = getRequest(pRequests, requestId);\n      if (pRequest) {\n        stopQuery(pRequest->pQuery);\n        releaseRequest(pRequest);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 44.858633095083256}, {"code": "void stopAllRequests(SHashObj *pRequests)    int i;\n    for (i = 0; i < pRequests->size; i++) {\n        SRequest *pRequest = (SRequest *) SHashObj_get(pRequests, i);\n        if (pRequest) {\n            int requestId = pRequest->requestId;\n            SQuery *pQuery = getQuery(requestId);\n            if (pQuery) {\n                stopQuery(pQuery);\n                releaseQuery(pQuery);\n            }\n            releaseRequest(pRequest);\n        }\n    }\n}\n", "CodeBleu_score": 39.759766109117834}, {"code": "void stopAllRequests(SHashObj *pRequests)  SHashIterator *pIterator = NULL;\n  int requestId;\n  void *pRequest;\n\n  pIterator = taosHashIterInit(pRequests, NULL);\n  while ((pRequest = taosHashIterNext(pIterator)) != NULL) {\n    requestId = *(int *)taosHashIterKey(pIterator);\n    taosStopQuery(requestId);\n    taosHashIterRelease(pIterator);\n  }\n}\n", "CodeBleu_score": 43.08418528377381}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport()    if (!tscCrashReportingEnabled) {\n        return;\n    }\n\n    int expected = 0;\n    if (!__atomic_compare_exchange_n(&clientStop, &expected, 1, 0, __ATOMIC_SEQ_CST)) {\n        tscLog(TSC_LOG_INFO, \"Crash report thread is already stopped.\");\n        return;\n    }\n\n    while (clientStop) {\n        usleep(10000);\n    }\n}\n", "CodeBleu_score": 43.657818712866245}, {"code": "void tscStopCrashReport()    if (!g_tscEnabled) {\n        return;\n    }\n    int stop = 1;\n    if (!__atomic_compare_exchange_n(&g_tscClientStop, &stop, 0, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) {\n        tscLogMessage(TSC_LOG_DEBUG, \"Crash report thread already stopped\");\n        return;\n    }\n    while (g_tscClientStop) {\n        usleep(1000);\n    }\n}\n", "CodeBleu_score": 56.846463231182675}, {"code": "void tscStopCrashReport()    if (!crashReportEnabled) {\n        return;\n    }\n\n    int expected = 0;\n    if (!atomic_compare_exchange_strong(&clientStop, &expected, 1)) {\n        printf(\"Crash report thread is already stopped.\\n\");\n        return;\n    }\n\n    while (clientStop) {\n        // Wait for the clientStop flag to become 0\n    }\n}\n", "CodeBleu_score": 33.41905800176056}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)    int32_t ret = SUCCESS;\n    int32_t numOfViews = 0;\n    SViewMeta *pViewMeta = NULL;\n    int32_t i = 0;\n\n    SSdbMsg sdbMsg;\n    sdbMsg.pMsg = value;\n    sdbMsg.msgLen = valueLen;\n    sdbMsg.pData = NULL;\n\n    if (deserializeSdbMsg(&sdbMsg) != TSDB_CODE_SUCCESS) {\n        taosLog(\"deserialize hb view info rsp error, length: %d\", valueLen);\n        return TAOS_SYSTEM_ERROR(TSDB_CODE_DESERIALIZE_FAILED);\n    }\n\n    if (sdbMsg.code != TSDB_CODE_SUCCESS) {\n        taosLog(\"hb view info rsp error, code: %d\", sdbMsg.code);\n        return sdbMsg.code;\n    }\n\n    numOfViews = *(int32_t *)sdbMsg.pData;\n    pViewMeta = (SViewMeta *)(sdbMsg.pData + sizeof(int32_t));\n\n    for (i = 0; i < numOfViews; ++i) {\n        if (pViewMeta[i].numOfColumns == 0) {\n            ret = taosRemoveViewMeta(pCatalog, pViewMeta[i].viewName);\n        } else {\n            ret = taosUpdateViewMeta(pCatalog, &pViewMeta[i]);\n        }\n\n        if (ret != SUCCESS) {\n            taosLog(\"hb view info rsp error, code: %d\", ret);\n            return ret;\n        }\n    }\n\n    taosMemoryFree(sdbMsg.pData);\n    return ret;\n}\n", "CodeBleu_score": 42.62799115055259}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)  int32_t ret = SUCCESS;\n  int32_t numOfViews = 0;\n  int32_t numOfColumns = 0;\n  int32_t i = 0;\n  int32_t j = 0;\n  int32_t k = 0;\n  int32_t l = 0;\n  int32_t m = 0;\n  int32_t n = 0;\n  int32_t p = 0;\n  int32_t q = 0;\n  int32_t r = 0;\n  int32_t s = 0;\n  int32_t t = 0;\n  int32_t u = 0;\n  int32_t v = 0;\n  int32_t w = 0;\n  int32_t x = 0;\n  int32_t y = 0;\n  int32_t z = 0;\n  int32_t a = 0;\n  int32_t b = 0;\n  int32_t c = 0;\n  int32_t d = 0;\n  int32_t e = 0;\n  int32_t f = 0;\n  int32_t g = 0;\n  int32_t h = 0;\n  int32_t i = 0;\n  int32_t j = 0;\n  int32_t k = 0;\n  int32_t l = 0;\n  int32_t m = 0;\n  int32_t n = 0;\n  int32_t o = 0;\n  int32_t p = 0;\n  int32_t q = 0;\n  int32_t r = 0;\n  int32_t s = 0;\n  int32_t t = 0;\n  int32_t u = 0;\n  int32_t v = 0;\n  int32_t w = 0;\n  int32_t x = 0;\n  int32_t y = 0;\n  int32_t z = 0;", "CodeBleu_score": 8.38336690324401}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)    int32_t ret = SUCCESS;\n    SHeartbeatResp *pResp = (SHeartbeatResp *)value;\n    int32_t numOfViews = 0;\n    int32_t numOfColumns = 0;\n    int32_t numOfViewsInCatalog = 0;\n    int32_t numOfColumnsInCatalog = 0;\n    int32_t numOfViewsInResp = 0;\n    int32_t numOfColumnsInResp = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t l = 0;\n    int32_t m = 0;\n    int32_t n = 0;\n    int32_t o = 0;\n    int32_t p = 0;\n    int32_t q = 0;\n    int32_t r = 0;\n    int32_t s = 0;\n    int32_t t = 0;\n    int32_t u = 0;\n    int32_t v = 0;\n    int32_t w = 0;\n    int32_t x = 0;\n    int32_t y = 0;\n    int32_t z = 0;\n    int32_t a = 0;\n    int32_t b = 0;\n    int32_t c = 0;\n    int32_t d = 0;\n    int32_t e = 0;\n    int32_t f = 0;\n    int32_t g = 0;\n    int32_t h = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t l = 0;\n    int32_t m = 0;\n    int32_t n = 0;\n    int32_t o = 0;\n    int32_t p = 0;\n    int32_t q = 0", "CodeBleu_score": 9.961702968304293}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3Status status = S3StatusOK;\n    S3_CHECK_OR_RAISE(properties, S3StatusInvalidArgument, \"Invalid argument\");\n    S3_CHECK_OR_RAISE(callbackData, S3StatusInvalidArgument, \"Invalid argument\");\n    S3_CHECK_OR_RAISE(properties->getObjectContentLength, S3StatusInvalidArgument, \"Invalid argument\");\n\n    if (properties->getObjectContentLength > 0) {\n        ((S3GetObjectInfoCallbackData *)callbackData)->contentLength = properties->getObjectContentLength;\n    } else {\n        ((S3GetObjectInfoCallbackData *)callbackData)->contentLength = 0;\n    }\n\n    return status;\n}\n", "CodeBleu_score": 50.29709099365197}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3_CHECK_OR_DIE(properties != NULL, S3StatusInvalidArgument, \"responsePropertiesCallback\",\n                    \"properties is NULL\");\n    S3_CHECK_OR_DIE(callbackData != NULL, S3StatusInvalidArgument, \"responsePropertiesCallback\",\n                    \"callbackData is NULL\");\n\n    S3GetObjectMetadataResponse *response = (S3GetObjectMetadataResponse *)callbackData;\n    if (properties->getContentLength() > 0) {\n        response->contentLength = properties->getContentLength();\n    } else {\n        response->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}\n", "CodeBleu_score": 54.26448467490535}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    GET_CONTENT_LENGTH_CALLBACK_DATA *callbackDataCast = (GET_CONTENT_LENGTH_CALLBACK_DATA *)callbackData;\n    if (properties->getContentLengthResult.isPresent) {\n        callbackDataCast->contentLength = properties->getContentLengthResult.value;\n    } else {\n        callbackDataCast->contentLength = 0;\n    }\n    return S3StatusOK;\n}\n", "CodeBleu_score": 58.56942650701016}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync()    if (mkdir(checkpointBackupDir, 0777) == -1) {\n        perror(\"Error creating checkpoint backup directory\");\n        return;\n    }\n\n    removeEmptyDirectories(checkpointBackupDir);\n\n    if (!generateRsyncConfigFile()) {\n        perror(\"Error generating Rsync configuration file\");\n        return;\n    }\n\n    char command[256];\n    sprintf(command, \"rsync --daemon --config=%s --port=%d\", rsyncConfigFile, rsyncPort);\n\n    if (system(command) == 0) {\n        printf(\"Rsync server started successfully.\\n\");\n    } else {\n        perror(\"Error starting Rsync server\");\n    }\n}\n", "CodeBleu_score": 26.750941133966037}, {"code": "void startRsync()    if (mkdir(CHECKPOINT_BACKUP_DIR, 0755) == -1) {\n        logError(\"Failed to create checkpoint backup directory\");\n        return;\n    }\n\n    removeEmptyDirectories();\n\n    if (generateRsyncConfig() == -1) {\n        logError(\"Failed to generate Rsync configuration file\");\n        return;\n    }\n\n    char command[100];\n    sprintf(command, \"rsync --daemon --port=%d --config=%s\", RSYNC_PORT, RSYNC_CONFIG_FILE);\n\n    if (system(command) == -1) {\n        logError(\"Failed to start Rsync server\");\n    } else {\n        logInfo(\"Rsync server started successfully\");\n    }\n}\n", "CodeBleu_score": 26.841180837891}, {"code": "void startRsync()    if (mkdir(CHECKPOINT_BACKUP_DIR, 0777) == -1) {\n        perror(\"Error creating checkpoint backup directory\");\n    }\n\n    removeEmptyDirectories(CHECKPOINT_BACKUP_DIR);\n\n    if (generateRsyncConfig() != 0) {\n        fprintf(stderr, \"Error generating Rsync configuration file\\n\");\n        return;\n    }\n\n    char command[100];\n    snprintf(command, sizeof(command), \"rsync --daemon --port=%d --config=%s\", RSYNC_PORT, RSYNC_CONFIG_FILE);\n\n    if (system(command) == 0) {\n        printf(\"Rsync server started successfully\\n\");\n    } else {\n        fprintf(stderr, \"Error starting Rsync server\\n\");\n    }\n}\n", "CodeBleu_score": 31.067545499151546}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID '\" + dispatcherId + \"' is not registered.\");\n    }\n    dispatcher.shutdown();\n}", "CodeBleu_score": 64.06282873768873}, {"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.shutdown();\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID '\" + dispatcherId + \"' is not registered.\");\n    }\n}", "CodeBleu_score": 71.20076685169921}, {"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.shutdown();\n}", "CodeBleu_score": 63.99725088336684}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)        List<TbActorId> children = actorChildren.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                try {\n                    if (highPriority) {\n                        actorSystemContext.getActor(child).sendOneWay(msg, true);\n                    } else {\n                        actorSystemContext.getActor(child).sendOneWay(msg);\n                    }\n                } catch (ActorNotFoundException e) {\n                    log.warn(\"Failed to send message to child actor [{}] due to: {}\", child, e.getMessage());\n                }\n            });\n        }\n    }\n\n    /**\n     * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n     */\n    private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg) {\n        broadcastToChildren(parent, childFilter, msg, false);\n    }\n\n    /**\n     * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n     */\n    private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority) {\n        List<TbActorId> children = actorChildren.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                try {\n                    if (highPriority) {\n                        actorSystemContext.getActor(child).sendOneWay(msg, true);\n                    } else {", "CodeBleu_score": 48.40848542904702}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)        List<TbActorId> children = childrenMap.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                TbActorRef childRef = actorSystemContext.getActor(child);\n                if (childRef != null) {\n                    childRef.tell(msg, highPriority);\n                } else {\n                    log.warn(\"[{}] Failed to find actor: {}\", parent, child);\n                }\n            });\n        }\n    }\n\n    /**\n     * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n     */\n    private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg) {\n        broadcastToChildren(parent, childFilter, msg, false);\n    }\n\n    /**\n     * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n     */\n    private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority) {\n        List<TbActorId> children = childrenMap.get(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                TbActorRef childRef = actorSystemContext.getActor(child);\n                if (childRef != null) {\n                    childRef.tell(msg, highPriority);\n                } else {\n                    log.warn(\"[{}] Failed to find actor: {}\", parent, child);", "CodeBleu_score": 45.30201858055957}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)        Collection<TbActorId> children = getChildren(parent);\n        if (children != null) {\n            children.stream().filter(childFilter).forEach(child -> {\n                try {\n                    if (highPriority) {\n                        actorSystem.sendMsg(child, msg, true);\n                    } else {\n                        actorSystem.sendMsg(child, msg);\n                    }\n                } catch (TbActorError e) {\n                    log.warn(\"[{}] Failed to send message to child actor [{}]\", parent, child);\n                }\n            });\n        }\n    }\n", "CodeBleu_score": 50.82622009322271}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (msg == null) {\n        return;\n    }\n    if (destroyed.get()) {\n        if (msg.getMsgType().equals(RULE_NODE_UPDATED_MSG)) {\n            if (initFailure) {\n                initFailure = false;\n                init(msg.getData());\n            }\n        } else {\n            msg.getCallback().onMsgProcessed(null, false);\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 54.168754954728904}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)  if (!destructionInProgress) {\n    if (highPriority) {\n      highPriorityMsgs.add(msg);\n    } else {\n      normalPriorityMsgs.add(msg);\n    }\n    processMsgs();\n  } else {\n    if (msg.getMsgType() == TbActorMsgType.RULE_NODE_UPDATED_MSG && msg.getData() == RuleNodeId.NODE_STATE_FAILED) {\n      if (initializationFailure) {\n        init();\n      } else {\n        msg.getCallback().onMsgProcessed(null);\n      }\n    } else {\n      msg.getCallback().onMsgProcessed(new TbActorError(TbActorErrorCode.ACTOR_STOPPED));\n    }\n  }\n}\n", "CodeBleu_score": 51.802734749331655}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (!destructionInProgress) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    } else if (msg.getMsgType() == RULE_NODE_UPDATED_MSG && msg.getData() instanceof TbMsgRuleNodeUpdatedMsg) {\n        TbMsgRuleNodeUpdatedMsg ruleNodeUpdatedMsg = (TbMsgRuleNodeUpdatedMsg) msg.getData();\n        if (ruleNodeUpdatedMsg.getError() != null && ruleNodeUpdatedMsg.getError().getErrorCode() == UNKNOWN_COMPONENT_ERROR_CODE) {\n            init();\n        }\n    } else {\n        msg.getCallback().onMsgProcessingFinished(null);\n    }\n}", "CodeBleu_score": 52.00951731209128}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox()    int throughput = actor.getThroughput();\n    long startTime = System.currentTimeMillis();\n    int processed = 0;\n    while (true) {\n        try {\n            if (actor.getStatus() == ActorStatus.FREE) {\n                actor.setStatus(ActorStatus.BUSY);\n                if (actor.getPriority() == ActorPriority.HIGH) {\n                    actor.process(highPriorityQueue.poll());\n                } else {\n                    actor.process(normalPriorityQueue.poll());\n                }\n                processed++;\n            } else {\n                break;\n            }\n        } catch (ActorInitializationException e) {\n            actor.setStatus(ActorStatus.STOPPED);\n            actor.setStopReason(e.getMessage());\n            actor.destroy();\n            break;\n        } catch (Exception e) {\n            actor.getProcessFailureStrategy().apply(actor, e);\n            if (actor.getStatus() == ActorStatus.STOPPED) {\n                break;\n            }\n        }\n        if (processed >= throughput || highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n            break;\n        }\n        if (System.currentTimeMillis() - startTime >= actor.getProcessingTimeout()) {\n            break;\n        }\n    }\n    actor.setStatus(ActorStatus.FREE);\n    if (!highPriorityQueue.isEmpty() || !normalPriorityQueue.isEmpty()) {\n        scheduleQueueProcessing();\n    }\n}\n", "CodeBleu_score": 35.736962634817694}, {"code": "private void processMailbox()    try {\n        int processed = 0;\n        boolean stop = false;\n        while (processed < throughput && !stop) {\n            Message message = null;\n            try {\n                message = mailbox.poll();\n                if (message != null) {\n                    processed++;\n                    if (message.getPriority() == Message.Priority.HIGH) {\n                        actor.process(message);\n                    } else {\n                        actor.process(message);\n                    }\n                } else {\n                    stop = true;\n                }\n            } catch (ActorInitializationException e) {\n                actor.setStopReason(e.getMessage());\n                actor.destroy();\n            } catch (Exception e) {\n                logger.error(\"Exception while processing message \" + message, e);\n                actor.processFailureStrategy(e);\n                if (actor.isStopped()) {\n                    stop = true;\n                }\n            }\n        }\n        if (stop) {\n            actor.setStatus(ActorStatus.FREE);\n            scheduleQueueProcessing();\n        }\n    } catch (Exception e) {\n        logger.error(\"Exception while processing mailbox\", e);\n    }\n}", "CodeBleu_score": 42.203851621740824}, {"code": "private void processMailbox()    try {\n        for (int i = 0; i < throughput; i++) {\n            if (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n                break;\n            }\n            if (!highPriorityQueue.isEmpty()) {\n                Message message = highPriorityQueue.poll();\n                try {\n                    actor.process(message);\n                } catch (ActorInitializationException e) {\n                    actor.setStopReason(e);\n                    actor.destroy();\n                    return;\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Actor \" + actor.getName() + \" failed to process message \" + message + \": \" + e.getMessage(), e);\n                    actor.processFailureStrategy(e);\n                    if (actor.isStopped()) {\n                        return;\n                    }\n                }\n            } else if (!normalPriorityQueue.isEmpty()) {\n                Message message = normalPriorityQueue.poll();\n                try {\n                    actor.process(message);\n                } catch (ActorInitializationException e) {\n                    actor.setStopReason(e);\n                    actor.destroy();\n                    return;\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Actor \" + actor.getName() + \" failed to process message \" + message + \": \" + e.getMessage(), e);\n                    actor.processFailureStrategy(e);\n                    if (actor.isStoped()) {\n                        return;\n                    }\n                }\n            }\n        }\n        actor.setStatus(ActorStatus.FREE);\n        scheduleQueueProcessing();\n    } catch (Exception e) {\n        logger.log(Level.SEVERE, \"Unexpected error while processing mailbox: \" + e.getMessage(), e);\n    }\n}", "CodeBleu_score": 35.90710678160325}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause)    if (this.stopReason.get() == null) {\n        this.stopReason.set(cause);\n    }\n    this.destroyInProgress.set(true);\n    this.dispatcher.executor().execute(this::destroyActor);\n}\n", "CodeBleu_score": 10.459538150861693}, {"code": "public void destroy(Throwable cause)    if (this.stopReason == null) {\n        this.stopReason = cause;\n    }\n    this.destroying = true;\n    this.dispatcher.schedule(this.dispatcher.getExecutor(), () -> {\n        try {\n            this.setReady(false);\n            this.destroy(this.stopReason, cause);\n            this.notifyAll(new ActorStopped(this.getRef(), this.stopReason, cause));\n        } catch (Exception e) {\n            this.dispatcher.log.warning(\"Failed to destroy actor \" + this.getRef() + \": \" + e.getMessage(), e);\n        }\n    });\n}", "CodeBleu_score": 37.140511157553924}, {"code": "public void destroy(Throwable cause)    if (stopReason == null) {\n        stopReason = new Stopped(this, cause);\n    }\n    if (isDestroyInProgress()) {\n        return;\n    }\n    setDestroyInProgress();\n    dispatcher.schedule(new Runnable() {\n        @Override\n        public void run() {\n            setReadiness(false);\n            try {\n                destroy(stopReason.cause);\n            } catch (Exception e) {\n                log.warning(\"Exception during destroy\", e);\n            }\n            notifyAllQueuedMessagesOfStop();\n        }\n    });\n}", "CodeBleu_score": 34.74369996951066}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    // Check if the tenant ID is the system tenant ID.\n    if (TenantId.SYSTEM_TENANT_ID.equals(tenantId)) {\n        return true;\n    }\n\n    // Retrieve the tenant profile.\n    TenantProfile tenantProfile = tenantProfileService.getTenantProfile(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n\n    // Fetch the rate limit configuration from the tenant profile.\n    RateLimitConfig rateLimitConfig = tenantProfile.getRateLimitConfig();\n    if (rateLimitConfig == null) {\n        return true;\n    }\n\n    // Check the rate limit.\n    boolean isRateLimitExceeded = rateLimitService.checkRateLimit(api, tenantId, level, rateLimitConfig);\n    if (isRateLimitExceeded) {\n        // Process a rate limit notification.\n        rateLimitService.processRateLimitNotification(api, tenantId, level, rateLimitConfig);\n    }\n\n    return !isRateLimitExceeded;\n}", "CodeBleu_score": 56.39044258028585}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.isSystem()) {\n        return true;\n    }\n    TenantProfile profile = tenantProfileService.getTenantProfile(tenantId);\n    if (profile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfiguration rateLimitConfiguration = profile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    boolean checkResult = rateLimitConfiguration.checkRateLimit(api, level);\n    if (!checkResult) {\n        rateLimitNotificationService.notifyAboutRateLimitExceed(tenantId, api, level);\n    }\n    return checkResult;\n}", "CodeBleu_score": 52.73991304667146}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)  if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n    return true;\n  }\n  TenantProfile profile=getTenantProfile(tenantId,ignoreTenantNotFound);\n  if (profile == null) {\n    return true;\n  }\n  RateLimitConfiguration rateLimitConfiguration=profile.getRateLimitConfiguration();\n  if (rateLimitConfiguration == null) {\n    return true;\n  }\n  boolean success=rateLimitConfiguration.getRateLimits(api).checkRateLimit(level);\n  if (!success) {\n    processRateLimitNotification(api,tenantId,rateLimitConfiguration.getRateLimits(api).getLimit(level));\n  }\n  return success;\n}", "CodeBleu_score": 39.53851920536728}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions()  long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n  for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n    if (entry.getValue().getLastActivityTime() < expirationTime) {\n      dtlsSessions.remove(entry.getKey());\n      logger.info(\"DTLS session for {} has been evicted due to inactivity\", entry.getKey());\n    }\n  }\n}", "CodeBleu_score": 51.57839566437284}, {"code": "public void evictTimeoutSessions()    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Iterator<Map.Entry<String, DTLSSession>> it = dtlsSessions.entrySet().iterator(); it.hasNext(); ) {\n        Map.Entry<String, DTLSSession> entry = it.next();\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            it.remove();\n            logger.info(\"Removed DTLS session for {}\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 49.91641838758638}, {"code": "public void evictTimeoutSessions()    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.info(\"Evicted DTLS session for client with session ID: \" + entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 50.68207945097715}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        for (JsonNode value : entry.getValue()) {\n            if (value.isArray()) {\n                for (JsonNode item : value) {\n                    result.add(new TsKvEntry(key, parseValue(item)));\n                }\n            } else {\n                result.add(new TsKvEntry(key, parseValue(value)));\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 45.08592328390131}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> result = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> value = entry.getValue();\n        for (JsonNode node : value) {\n            result.add(new TsKvEntry(key, node.asLong(), node.asDouble()));\n        }\n    }\n    return result;\n}", "CodeBleu_score": 40.90545706527974}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    List<TsKvEntry> result = new ArrayList<>();\n    if (!timeseries.isEmpty()) {\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                result.add(new TsKvEntry(key, parseValue(value)));\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 39.37423161249725}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken()    // Create a request map containing the current refresh token\n    Map<String, String> request = new HashMap<>();\n    request.put(\"refresh_token\", tokenInfo.getRefreshToken());\n\n    // Send a POST request to the authentication endpoint\n    ResponseEntity<Map<String, String>> response = restTemplate.postForEntity(\n        authEndpoint,\n        request,\n        new ParameterizedTypeReference<Map<String, String>>() {}\n    );\n\n    // Update the token information with the current timestamp and the response body\n    tokenInfo.setTimestamp(System.currentTimeMillis());\n    tokenInfo.setAccessToken(response.getBody().get(\"access_token\"));\n    tokenInfo.setRefreshToken(response.getBody().get(\"refresh_token\"));\n}", "CodeBleu_score": 45.18351316280238}, {"code": "public void refreshToken()    Map<String, String> request = new HashMap<>();\n    request.put(\"grant_type\", \"refresh_token\");\n    request.put(\"refresh_token\", tokenInfo.getRefreshToken());\n    ResponseEntity<Map> response = restTemplate.postForEntity(authEndpoint, request, Map.class);\n    updateTokenInfo(response.getBody());\n}\n", "CodeBleu_score": 48.435786419531766}, {"code": "public void refreshToken()    Map<String, String> request = new HashMap<>();\n    request.put(\"grant_type\", \"refresh_token\");\n    request.put(\"refresh_token\", tokenInfo.getRefreshToken());\n\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n    headers.setBasicAuth(clientId, clientSecret);\n\n    HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(request, headers);\n\n    ResponseEntity<String> response = restTemplate.postForEntity(authenticationUrl, requestEntity, String.class);\n\n    if (response.getStatusCode() == HttpStatus.OK) {\n        ObjectMapper mapper = new ObjectMapper();\n        Map<String, Object> responseBody = mapper.readValue(response.getBody(), new TypeReference<Map<String, Object>>() {});\n\n        tokenInfo.setAccessToken((String) responseBody.get(\"access_token\"));\n        tokenInfo.setRefreshToken((String) responseBody.get(\"refresh_token\"));\n        tokenInfo.setExpiresIn((Integer) responseBody.get(\"expires_in\"));\n        tokenInfo.setLastRefreshTime(System.currentTimeMillis());\n    }\n}\n", "CodeBleu_score": 41.3858998994622}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin()    long timestamp = System.currentTimeMillis();\n    Map<String, Object> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", \"admin\");\n    loginRequest.put(\"password\", \"admin\");\n    String url = \"http://localhost:8080/api/auth/login\";\n    ResponseEntity<Map<String, Object>> response = restTemplate.postForEntity(url, loginRequest, Map.class);\n    Map<String, Object> responseBody = response.getBody();\n    updateTokenInfo(responseBody, timestamp);\n}\n", "CodeBleu_score": 56.36778616134714}, {"code": " private void doLogin()    long timestamp = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n\n    String url = \"/api/auth/login\";\n    String response = restTemplate.postForObject(url, loginRequest, String.class);\n\n    // Update token information with the response data and the timestamp\n    updateTokenInfo(response, timestamp);\n}\n", "CodeBleu_score": 70.98457486129415}, {"code": " private void doLogin()    // Capture the current timestamp\n    long timestamp = System.currentTimeMillis();\n\n    // Create a login request map with the credentials\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n\n    // Send the login request to the authentication endpoint\n    HttpEntity<Map<String, String>> request = new HttpEntity<>(loginRequest, headers);\n    ResponseEntity<Map> response = restTemplate.postForEntity(AUTHENTICATION_ENDPOINT, request, Map.class);\n\n    // Update the token information with the response data and timestamp\n    updateTokenInfo(response.getBody(), timestamp);\n}\n", "CodeBleu_score": 67.38851956917888}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 64.95322681203042}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\"/api/device/{deviceId}\", Device.class, deviceId);\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (RestClientException e) {\n        throw e;\n    }\n}\n", "CodeBleu_score": 50.64998308826387}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n                baseUrl + \"/api/device/{deviceId}\",\n                Device.class,\n                deviceId.toString()\n        );\n        return Optional.ofNullable(response.getBody());\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (HttpStatusCodeException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 62.41140024698607}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        return Optional.of(restTemplate.postForObject(\"/api/device-with-credentials\", new DeviceWithCredentials(device, credentials), Device.class));\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    }\n}", "CodeBleu_score": 26.71821051606374}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        Request request = new Request.Builder()\n                .url(baseUrl + \"/api/device-with-credentials\")\n                .post(RequestBody.create(JSON, gson.toJson(new DeviceWithCredentials(device, credentials))))\n                .build();\n        Response response = httpClient.newCall(request).execute();\n        if (response.code() == 404) {\n            return Optional.empty();\n        }\n        return Optional.of(gson.fromJson(response.body().string(), Device.class));\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n", "CodeBleu_score": 50.81804645658843}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        return Optional.of(\n                restTemplate.postForObject(\n                        \"/api/device-with-credentials\",\n                        new DeviceWithCredentials(device, credentials),\n                        Device.class));\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    }\n}", "CodeBleu_score": 31.119087902929227}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val)  if (typeof val === 'number') {\n    // Set brightness for a specific device\n    this.devices[addr].setBrightness(Math.round(val / 100 * 15));\n  } else {\n    // Set brightness for all devices\n    for (let i = 0; i < this.devices.length; i++) {\n      this.devices[i].setBrightness(Math.round(val / 100 * 15));\n    }\n  }\n  return this;\n}", "CodeBleu_score": 46.26736718326507}, {"code": "brightness(addr, val)  if (val !== undefined) {\n    this.devices[addr] = Math.round(val / 100 * 15);\n  } else {\n    for (var i = 0; i < this.devices.length; i++) {\n      this.devices[i] = val;\n    }\n  }\n  return this;\n}", "CodeBleu_score": 39.70744972674621}, {"code": "brightness(addr, val)    if (val === undefined) {\n        this.brightness = addr;\n        this.brightness_changed = true;\n    } else {\n        this.brightness_changed = true;\n        this.brightness[addr] = Math.round(val * 15 / 100);\n    }\n    return this;\n}", "CodeBleu_score": 40.30616144881199}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr)  let obj = Object.create(LedControl.prototype);\n  Object.keys(LedControl.prototype).forEach(key => {\n    if (typeof LedControl.prototype[key] === 'function') {\n      obj[key] = LedControl.prototype[key].bind(this, addr);\n    }\n  });\n  Object.keys(this).forEach(key => {\n    if (typeof this[key] === 'function') {\n      obj[key] = this[key].bind(this, addr);\n    }\n  });\n  return obj;\n}", "CodeBleu_score": 49.219330628583}, {"code": "device(addr)    const obj = Object.create(LedControl.prototype);\n    for (const key in this) {\n        if (typeof this[key] === 'function') {\n            obj[key] = this[key].bind(this, addr);\n        } else {\n            obj[key] = this[key];\n        }\n    }\n    return obj;\n}\n", "CodeBleu_score": 40.70356256640803}, {"code": "device(addr)    const keys = Object.keys(Object.getPrototypeOf(LedControl));\n    const obj = {};\n    for (const key of keys) {\n        obj[key] = this[key].bind(this, addr);\n    }\n    return obj;\n}\n", "CodeBleu_score": 35.98913476149691}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) =>   methods.forEach(method => {\n    target[method] = function(duration, callback) {\n      if (!callback) {\n        callback = duration;\n        duration = 1000;\n      }\n      if (typeof callback !== 'function') {\n        throw new Error('Callback must be a function');\n      }\n      const promises = [];\n      this.forEach(element => {\n        const promise = element[method](duration);\n        promises.push(promise);\n      });\n      Promise.all(promises).then(callback);\n    };\n  });\n};\n", "CodeBleu_score": 48.9048675704065}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>   methods.forEach(method => {\n    target[method] = (duration, callback) => {\n      if (!callback) {\n        callback = duration;\n        duration = 1000;\n      }\n      if (typeof callback !== 'function') {\n        throw new Error(`Callback must be a function, got ${typeof callback}`);\n      }\n      const promises = this.map(element => element[method](duration));\n      Promise.all(promises).then(callback);\n    };\n  });\n};", "CodeBleu_score": 45.39861270336759}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>   methods.forEach(method => {\n    target[method] = (duration = 1000, callback) => {\n      callback = callback || function() {};\n      const promises = this.map(element => {\n        return new Promise(resolve => {\n          setTimeout(() => {\n            resolve(element[method]());\n          }, duration);\n        });\n      });\n      Promise.all(promises).then(callback);\n    };\n  });\n};", "CodeBleu_score": 34.01716252759075}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen()  let input = \"\";\n  this.serialPort.on(\"data\", (data) => {\n    input += data.toString();\n    const sentences = input.split(\"\\r\\n\");\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  });\n}", "CodeBleu_score": 54.26263068310625}, {"code": "listen()  let input = '';\n  this.serialPort.on('data', (data) => {\n    input += data.toString();\n    const sentences = input.split('\\r\\n');\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  });\n}", "CodeBleu_score": 52.66636481371382}, {"code": "listen()  let input = \"\";\n  this.serialPort.on(\"data\", (data) => {\n    input += data.toString();\n    const sentences = input.split(\"\\r\\n\");\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    input = sentences[sentences.length - 1];\n  });\n}\n", "CodeBleu_score": 54.26263068310625}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t num_samples = sequence->options->extra_samplings + 1;\n\tuint32_t needed_size = sequence->channels_count * num_samples;\n\n\tif (sequence->buffer_size < needed_size) {\n\t\tLOG_ERR(\"Provided buffer size insufficient\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 37.348559010401125}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t active_channels = 0;\n\tuint32_t needed_buffer_size;\n\tuint32_t i;\n\n\tfor (i = 0U; i < sequence->channels_count; i++) {\n\t\tif (sequence->channels[i] == config->channel_id) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = active_channels *\n\t\t\t      (sequence->resolution + config->extra_bits);\n\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= 2;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 43.35244148128628}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tuint32_t num_channels = sequence->options->extra_samplings + 1;\n\tuint32_t needed_buffer_size = num_channels * sequence->options->num_samples;\n\n\tif (sequence->options->buf_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 34.70782344941723}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)    const struct adc_ad559x_config *config = dev->config;\n    struct adc_ad559x_data *data = dev->data;\n    const struct adc_ad559x_chan_cfg *chan_cfg;\n    int err;\n\n    if (sequence->resolution != config->resolution) {\n        LOG_ERR(\"Invalid resolution\");\n        return -EINVAL;\n    }\n\n    if (sequence->channels > config->channels) {\n        LOG_ERR(\"Invalid number of channels\");\n        return -EINVAL;\n    }\n\n    if (sequence->buffer_size < (sequence->channels * config->resolution)) {\n        LOG_ERR(\"Buffer size insufficient\");\n        return -EINVAL;\n    }\n\n    data->buffer = sequence->buffer;\n    data->buf_size = sequence->buffer_size;\n\n    for (uint8_t i = 0; i < sequence->channels; i++) {\n        chan_cfg = &config->chan_cfg[i];\n        if (chan_cfg->gain != config->gain) {\n            LOG_ERR(\"Invalid gain\");\n            return -EINVAL;\n        }\n\n        if (chan_cfg->ref != config->ref) {\n            LOG_ERR(\"Invalid reference\");\n            return -EINVAL;\n        }\n\n        if (chan_cfg->acq_time != config->acq_time) {\n            LOG_ERR(\"Invalid acquisition time\");\n            return -EINVAL;\n        }\n    }\n\n    data->chan_cfg = config->chan_cfg;\n    data->channels = sequence->channels;\n\n    err = adc_ad559x_read(dev);\n    if (err) {\n        LOG_ERR(\"Failed to read ADC channels\");\n        return err;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 48.05590824022359}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)  const struct adc_ad559x_config *config = dev->config;\n  struct adc_ad559x_data *data = dev->data;\n  int ret;\n\n  if (sequence->resolution != config->resolution) {\n    LOG_ERR(\"Invalid resolution\");\n    return -EINVAL;\n  }\n\n  if (!adc_ad559x_validate_channels(config, sequence)) {\n    LOG_ERR(\"Invalid channels\");\n    return -EINVAL;\n  }\n\n  if (sequence->buffer_size < sequence->options->extra_samplings + 1) {\n    LOG_ERR(\"Buffer size too small\");\n    return -EINVAL;\n  }\n\n  data->buffer = sequence->buffer;\n  data->buf_size = sequence->buffer_size;\n  data->resolution = sequence->resolution;\n  data->num_channels = sequence->num_channels;\n\n  ret = adc_ad559x_set_channels(dev, sequence);\n  if (ret < 0) {\n    return ret;\n  }\n\n  k_mutex_lock(&data->lock, K_FOREVER);\n  ret = adc_ad559x_start_read_sync(dev);\n  k_mutex_unlock(&data->lock);\n\n  return ret;\n}\n", "CodeBleu_score": 64.75008802386179}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)    const struct adc_ad559x_config *config = dev->config;\n    struct adc_ad559x_data *data = dev->data;\n    struct adc_ad559x_chan_config *chan_config;\n    int ret;\n\n    if (sequence->resolution != config->resolution) {\n        LOG_ERR(\"ADC resolution does not match expected resolution\");\n        return -EINVAL;\n    }\n\n    for (size_t i = 0; i < sequence->num_channels; i++) {\n        chan_config = &config->chan_cfg[sequence->channels->channel_id];\n        if (chan_config->gain == AD559X_GAIN_UNKNOWN) {\n            LOG_ERR(\"ADC channel %d gain is not set\", sequence->channels[i].channel_id);\n            return -EINVAL;\n        }\n    }\n\n    if (sequence->buffer_size < sizeof(uint16_t) * sequence->num_channels) {\n        LOG_ERR(\"Buffer size is insufficient for the number of ADC channels\");\n        return -EINVAL;\n    }\n\n    data->buffer = sequence->buffer;\n\n    ret = adc_ad559x_start_read_context(dev);\n    if (ret) {\n        LOG_ERR(\"Failed to start ADC read context\");\n        return ret;\n    }\n\n    ret = adc_ad559x_wait_for_completion(dev);\n    if (ret) {\n        LOG_ERR(\"Failed to wait for ADC read completion\");\n        return ret;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 47.01081771753164}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_data *data = ctx->data;\n\tuint32_t status;\n\n\tstatus = adc_async_start_conversion(data->adc, data->adc_channels,\n\t\t\tdata->adc_channel_count, &data->adc_repeat_buf,\n\t\t\tdata->adc_channel_count);\n\tif (status != STATUS_OK) {\n\t\tprintf(\"Failed to start ADC conversion: %lu\\n\", status);\n\t}\n\n\tsem_release(&data->adc_sem);\n}\n", "CodeBleu_score": 47.22796844383208}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)    struct adc_data *data = ctx->data;\n    adc_set_channels(data->channels, data->num_channels);\n    adc_set_repeat_buffer(data->data, data->num_samples);\n    sem_release(ctx->start_sem);\n}\n", "CodeBleu_score": 41.613466863658566}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)    struct adc_data *data = ctx->data;\n    adc_set_channels(data->adc, data->channels);\n    adc_set_repeat_buffer(data->adc, data->buffer, sizeof(data->buffer));\n    adc_start_sampling(data->adc);\n    sem_release(&ctx->sem);\n}\n", "CodeBleu_score": 51.68518611080961}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    struct adc_data *data = adc_context_get_data(ctx);\n    if (repeat_sampling) {\n        data->buffer = data->repeat_buffer;\n    } else {\n        data->buffer = data->buffer_1;\n    }\n}\n", "CodeBleu_score": 54.6211239031665}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    struct adc_data_container *data_container = adc_context_get_data_container(ctx);\n    if (repeat_sampling) {\n        data_container->buffer_pointer = data_container->repeat_buffer;\n    } else {\n        data_container->buffer_pointer = data_container->buffer;\n    }\n}\n", "CodeBleu_score": 40.94497171277407}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    if (repeat_sampling) {\n        ctx->buffer_pointer = ctx->repeat_buffer;\n    } else {\n        ctx->buffer_pointer = ctx->data_container.buffer;\n    }\n}\n", "CodeBleu_score": 51.70652595248024}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)    int ret;\n    uint32_t channel_id;\n    uint32_t channel_data;\n    uint32_t channel_data_index;\n    uint32_t channel_data_count;\n    uint32_t channel_data_size;\n    uint32_t channel_data_offset;\n    uint32_t channel_data_index_offset;\n    uint32_t channel_data_index_count;\n    uint32_t channel_data_index_size;\n    uint32_t channel_data_index_offset_offset;\n    uint32_t channel_data_index_count_offset;\n    uint32_t channel_data_index_size_offset;\n    uint32_t channel_data_index_offset_offset_offset;\n    uint32_t channel_data_index_count_offset_offset;\n    uint32_t channel_data_index_size_offset_offset;\n    uint32_t channel_data_index_offset_offset_offset_offset;\n    uint32_t channel_data_index_count_offset_offset_offset;\n    uint32_t channel_data_index_size_offset_offset_offset;\n    uint32_t channel_data_index_offset_offset_offset_offset_offset;\n    uint32_t channel_data_index_count_offset_offset_offset_offset;\n    uint32_t channel_data_index_size_offset_offset_offset_offset;\n    uint32_t channel_data_index_offset_offset_offset_offset_offset_offset;\n    uint32_t channel_data_index_count_offset_offset_offset_offset_offset;\n    uint32_t channel_data_index_size_offset_offset_offset_offset_offset;\n    uint32_t channel_data_index_offset_offset_offset_offset_offset_offset_offset;\n    uint32_t channel_data_index_count_offset_offset_offset_offset_offset_offset;\n    uint32_t channel_data_index_size_offset_offset_offset", "CodeBleu_score": 6.460409904938818}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)    while (true) {\n        if (sem_wait(&data->sem_start_acquisition) != 0) {\n            LOG_ERR(\"sem_wait failed\");\n            break;\n        }\n\n        for (size_t i = 0; i < data->num_active_channels; i++) {\n            if (adc_ad559x_read_channel(data, i) != 0) {\n                LOG_ERR(\"Failed to read channel %zu\", i);\n                data->is_complete = true;\n                break;\n            }\n        }\n\n        if (sem_post(&data->sem_done_acquisition) != 0) {\n            LOG_ERR(\"sem_post failed\");\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 27.004774947493654}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)    while (true) {\n        sem_wait(&data->sem);\n        bool all_complete = true;\n        for (int i = 0; i < ADC_AD559X_CHANNEL_COUNT; i++) {\n            if (data->channel_enabled[i]) {\n                int32_t value;\n                int err = adc_ad559x_read(data->adc, i, &value);\n                if (err) {\n                    logger_error(\"adc_ad559x_read failed: %d\", err);\n                    data->channel_complete[i] = true;\n                } else {\n                    data->channel_buffer[i] = value;\n                }\n            }\n            all_complete &= data->channel_complete[i];\n        }\n        if (all_complete) {\n            sem_post(&data->sem);\n        }\n    }\n}\n", "CodeBleu_score": 28.893348420008163}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev)    const struct ads1112_config *config = dev->config;\n    uint8_t data_ready = 0;\n    int ret;\n\n    k_sleep(K_USEC(config->ready_time));\n\n    do {\n        ret = ads1112_read_register(dev, ADS1112_REG_CONFIG, &data_ready);\n        if (ret < 0) {\n            return ret;\n        }\n    } while ((data_ready & ADS1112_CONFIG_DRDY) == 0);\n\n    return 0;\n}\n", "CodeBleu_score": 40.33527782802962}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    const struct ads1112_config *config = dev->config;\n    int ret;\n\n    k_sleep(K_MSEC(config->ready_time));\n\n    do {\n        ret = ads1112_read_config(dev);\n        if (ret < 0) {\n            return ret;\n        }\n    } while (!(ret & ADS1112_CONFIG_DRDY));\n\n    return 0;\n}\n", "CodeBleu_score": 27.37154687798397}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    const struct ads1112_config *config = dev->config;\n    struct ads1112_data *data = dev->data;\n    int ret;\n\n    k_sleep(K_USEC(config->ready_time));\n\n    do {\n        ret = ads1112_read_register(dev, ADS1112_CONFIG_REG);\n        if (ret < 0) {\n            return ret;\n        }\n    } while (!(ret & ADS1112_CONFIG_DRDY));\n\n    return 0;\n}\n", "CodeBleu_score": 34.750330198471495}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)    int buffer_size = sequence->options.extra_samplings + sequence->options.oversampling + 1;\n\n    if (sequence->buffer_size < buffer_size) {\n        LOG_ERR(\"ADC buffer size is too small\");\n        return -EINVAL;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 36.19489918164482}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)    size_t buffer_size = sequence->options->extra_samplings;\n    for (size_t i = 0; i < sequence->channels->count; i++) {\n        buffer_size += sequence->channels->buf_size[i];\n    }\n    if (buffer_size > sequence->buffer->max_samples) {\n        LOG_ERR(\"Buffer size is too small\");\n        return -EINVAL;\n    }\n    return 0;\n}\n", "CodeBleu_score": 36.81176477339208}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)    int32_t buffer_size = sequence->options->buffer_size;\n    int32_t num_samplings = sequence->options->num_samplings;\n    int32_t extra_samplings = sequence->options->extra_samplings;\n\n    int32_t required_buffer_size = num_samplings + extra_samplings;\n\n    if (buffer_size < required_buffer_size) {\n        LOG_ERR(\"Buffer size is insufficient. Required buffer size: %d\", required_buffer_size);\n        return -EINVAL;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 29.8886109324464}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tint ret;\n\tuint8_t buf[2];\n\n\tret = ads1112_adc_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = ads1112_adc_set_gain(dev, sequence->gain);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tbuf[0] = ADS1112_CONFIG_REG_ADDR;\n\tbuf[1] = sequence->reference | sequence->acquisition_time | sequence->channel_id;\n\tret = i2c_write(dev->bus, buf, sizeof(buf), ADS1112_I2C_ADDRESS);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = ads1112_adc_set_resolution(dev, sequence->resolution);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tk_sleep(K_MSEC(sequence->sampling_delay));\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 49.924388738101314}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tint ret;\n\n\tret = ads1112_adc_validate_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = ads1112_adc_set_sequence(dev, sequence);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = ads1112_adc_start_read_context(dev);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_adc_wait_for_read_context(dev);\n\t\tif (ret != 0) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 44.343153154426645}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\n\t/*\n\t * Validate the ADC sequence\n\t */\n\tif (sequence->options) {\n\t\tLOG_ERR(\"ADC options not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels > ADS1112_MAX_CHANNELS) {\n\t\tLOG_ERR(\"Invalid number of channels\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\tLOG_ERR(\"Invalid buffer\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->buffer_size < (sequence->channels * sequence->resolution)) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/*\n\t * Assign the sequence buffer to the device data\n\t */\n\tstruct ads1112_data *data = dev->data;\n\tdata->sequence = sequence;\n\n\t/*\n\t * Start the ADC read context\n\t */\n\tconst struct ads1112_config *config = dev->config;\n\tdata->config.mux = ADS1112_MUX(sequence->channels);\n\tdata->config.pga = ADS1112_PGA(sequence->resolution);\n\n\tint rc = i2c_write(data->i2c, &config->i2c_cfg, ADS1112_REG_CONFIG, sizeof(data->config),\n\t\t\t   ADS1112_ADDR);\n\tif (rc != 0) {\n\t\tLOG_ERR(\"I2C write error: %d\", rc);\n\t\treturn rc;\n\t}\n\n\trc = i2c_read(data->i2c, &data->config, ADS1112_REG_CONFIG, sizeof(data->config), ADS1112_ADDR);\n\tif (rc != 0) {\n\t\tLOG_ERR(\"I2C read error: %d\", r", "CodeBleu_score": 48.23211592498418}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])    int ret;\n    struct audio_codec_cfg cfg;\n    struct audio_codec_device *codec;\n\n    if (argc < 2) {\n        shell_error(sh, \"codec device name is not specified\");\n        return -EINVAL;\n    }\n\n    codec = device_get_binding(argv[1]);\n    if (!codec) {\n        shell_error(sh, \"codec device %s not found\", argv[1]);\n        return -EINVAL;\n    }\n\n    ret = audio_codec_get_cfg(codec, &cfg);\n    if (ret < 0) {\n        shell_error(sh, \"codec device %s get cfg error %d\", argv[1], ret);\n        return ret;\n    }\n\n    if (argc >= 3) {\n        cfg.sample_rate = atoi(argv[2]);\n    }\n\n    if (argc >= 4) {\n        cfg.channel = atoi(argv[3]);\n    }\n\n    if (argc >= 5) {\n        cfg.format = atoi(argv[4]);\n    }\n\n    if (argc >= 6) {\n        cfg.bit_width = atoi(argv[5]);\n    }\n\n    if (argc >= 7) {\n        cfg.volume = atoi(argv[6]);\n    }\n\n    ret = audio_codec_set_cfg(codec, &cfg);\n    if (ret < 0) {\n        shell_error(sh, \"codec device %s set cfg error %d\", argv[1], ret);\n        return ret;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 45.16580007567607}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])    int ret;\n    struct device *dev;\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Cannot find device %s\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_properties(dev);\n    if (ret) {\n        shell_error(sh, \"Failed to apply properties: %d\", ret);\n    }\n\n    return ret;\n}\n", "CodeBleu_score": 60.217157856326985}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])    int result;\n    struct audio_codec_data *codec;\n    struct device *dev;\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"device %s not found\", argv[1]);\n        return -ENODEV;\n    }\n\n    codec = (struct audio_codec_data *)dev->data;\n\n    result = audio_codec_apply_properties(dev, codec->props);\n    if (result) {\n        shell_error(sh, \"apply properties failed %d\", result);\n        return result;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 56.30878520737086}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)    const struct mpxxdtyy_i2s_data *data = dev->data;\n    int ret = 0;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state != DMIC_STATE_CONFIGURED) {\n                LOG_ERR(\"I2S command %d not allowed in state %d\", cmd, data->state);\n                return -EINVAL;\n            }\n\n            ret = i2s_set_config(dev, I2S_CONFIG_START);\n            if (ret == 0) {\n                data->state = DMIC_STATE_ACTIVE;\n            }\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state != DMIC_STATE_ACTIVE) {\n                LOG_ERR(\"I2S command %d not allowed in state %d\", cmd, data->state);\n                return -EINVAL;\n            }\n\n            ret = i2s_set_config(dev, I2S_CONFIG_STOP);\n            if (ret == 0) {\n                data->state = DMIC_STATE_CONFIGURED;\n            }\n            break;\n\n        default:\n            LOG_ERR(\"Unsupported I2S command %d\", cmd);\n            return -EINVAL;\n    }\n\n    if (ret < 0) {\n        LOG_ERR(\"Failed to set I2S command %d\", cmd);\n        return ret;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 56.26631147618295}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)    struct mpxxdtyy_priv *priv = dev->data;\n    int ret = 0;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (priv->state != DMIC_STATE_CONFIGURED) {\n                LOG_ERR(\"DMIC device not in configured state\");\n                return -EINVAL;\n            }\n\n            ret = mpxxdtyy_i2s_cmd(priv, MPXXDTYY_I2S_CMD_START);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to send I2S start command\");\n                return ret;\n            }\n\n            priv->state = DMIC_STATE_ACTIVE;\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (priv->state != DMIC_STATE_ACTIVE) {\n                LOG_ERR(\"DMIC device not in active state\");\n                return -EINVAL;\n            }\n\n            ret = mpxxdtyy_i2s_cmd(priv, MPXXDTYY_I2S_CMD_STOP);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to send I2S stop command\");\n                return ret;\n            }\n\n            priv->state = DMIC_STATE_CONFIGURED;\n            break;\n\n        default:\n            LOG_ERR(\"Invalid DMIC trigger command\");\n            return -EINVAL;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 52.21570826467439}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)    const struct mpxxdtyy_i2s_data *data = dev->data;\n    int ret;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (data->state != DMIC_STATE_CONFIGURED) {\n                LOG_ERR(\"DMIC is not in configured state\");\n                return -ENOTSUP;\n            }\n\n            ret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_I2S_CMD_START);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to send start command\");\n                return ret;\n            }\n\n            data->state = DMIC_STATE_ACTIVE;\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (data->state != DMIC_STATE_ACTIVE) {\n                LOG_ERR(\"DMIC is not in active state\");\n                return -ENOTSUP;\n            }\n\n            ret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_I2S_CMD_STOP);\n            if (ret < 0) {\n                LOG_ERR(\"Failed to send stop command\");\n                return ret;\n            }\n\n            data->state = DMIC_STATE_CONFIGURED;\n            break;\n\n        default:\n            LOG_ERR(\"Invalid trigger command\");\n            return -EINVAL;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 54.02707713258612}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)    struct auxdisplay_hd44780_data *data = dev->data;\n    const struct auxdisplay_hd44780_config *config = dev->config;\n    uint8_t cmd = HD44780_CMD_DISPLAY_MODE;\n\n    if (enabled) {\n        cmd |= HD44780_DISPLAY_MODE_ON;\n    }\n    if (data->cursor_blink) {\n        cmd |= HD44780_DISPLAY_MODE_CURSOR_BLINK;\n    }\n    if (data->cursor_pos) {\n        cmd |= HD44780_DISPLAY_MODE_CURSOR_POS;\n    }\n\n    gpio_pin_set(config->rs_gpio_port, config->rs_pin, 0);\n    auxdisplay_hd44780_write_cmd(dev, cmd);\n}\n", "CodeBleu_score": 64.60213981593508}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)    const struct auxdisplay_hd44780_config *config = dev->config;\n    const struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t cmd = HD44780_CMD_DISPLAY_MODE;\n\n    if (data->cursor_blink) {\n        cmd |= HD44780_DISPLAY_MODE_CURSOR_BLINK;\n    }\n    if (data->cursor_pos) {\n        cmd |= HD44780_DISPLAY_MODE_CURSOR_POS;\n    }\n    if (enabled) {\n        cmd |= HD44780_DISPLAY_MODE_DISPLAY;\n    }\n\n    auxdisplay_hd44780_send_command(dev, cmd);\n}\n", "CodeBleu_score": 65.77192783652974}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)  struct auxdisplay_hd44780_data *data = dev->data;\n  uint8_t cmd = HD44780_CMD_DISPLAY_MODE;\n\n  if (enabled) {\n    cmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n  }\n\n  if (data->cursor_blink_enabled) {\n    cmd |= HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n  }\n\n  if (data->cursor_position_enabled) {\n    cmd |= HD44780_DISPLAY_MODE_CURSOR_POSITION_ON;\n  }\n\n  auxdisplay_hd44780_send_command(dev, cmd);\n}\n", "CodeBleu_score": 60.27032506869965}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev)    const struct auxdisplay_itron_config *config = dev->config;\n    if (config->busy_gpio.port == NULL) {\n        return -ENOTSUP;\n    }\n    return gpio_pin_get(config->busy_gpio.port, config->busy_gpio.pin);\n}\n", "CodeBleu_score": 72.87338480026173}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)    const struct auxdisplay_itron_config *config = dev->config;\n    int ret;\n\n    if (!config->busy_port) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get(config->busy_port, config->busy_pin);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return ret;\n}\n", "CodeBleu_score": 63.072735020032425}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)  const struct auxdisplay_itron_config *config = dev->config;\n\n  if (!config->busy_port) {\n    return -ENOTSUP;\n  }\n\n  return gpio_pin_get(config->busy_port, config->busy_pin);\n}\n", "CodeBleu_score": 38.65335364818282}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(config->i2c, buf, sizeof(buf), config->i2c_address);\n}\n", "CodeBleu_score": 57.37900806994969}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[AUXDISPLAY_SERLCD_SPECIAL_COMMAND_SIZE];\n\n\tbuf[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuf[1] = command;\n\n\treturn i2c_write(config->i2c, buf, sizeof(buf), config->i2c_addr);\n}\n", "CodeBleu_score": 57.29446293289809}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = config->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(config->i2c_master, buf, sizeof(buf), config->i2c_slave_address);\n}\n", "CodeBleu_score": 58.01553149137602}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\n  if (size > BBRAM_SIZE) {\n    return -EINVAL;\n  }\n\n  if (offset + size > BBRAM_SIZE) {\n    return -EINVAL;\n  }\n\n  if (data == NULL) {\n    return -EINVAL;\n  }\n\n  memcpy(data, bbram_emul_data + offset, size);\n\n  return 0;\n}\n", "CodeBleu_score": 52.26790863270563}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, bbram_emul_mem + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 50.608647055618135}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_dev *dev_data = dev->data;\n\n\tif ((offset + size) > dev_data->size) {\n\t\tLOG_ERR(\"Read outside of device memory\");\n\t\treturn -EFAULT;\n\t}\n\n\tmemcpy(data, &dev_data->mem[offset], size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 48.41360818082913}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tif (size != 1 && size != 2 && size != 4) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > CONFIG_BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_state != BBRAM_EMUL_VALID) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(bbram_emul_mem + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 53.151290297241005}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tARG_UNUSED(dev);\n\n\tif (size != 1) {\n\t\tLOG_ERR(\"Write size must be 1\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset >= BBRAM_EMUL_SIZE) {\n\t\tLOG_ERR(\"Write offset 0x%x out of range\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_state != BBRAM_EMUL_STATE_VALID) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EINVAL;\n\t}\n\n\tbbram_emul_mem[offset] = *data;\n\n\treturn 0;\n}\n", "CodeBleu_score": 39.11190305726708}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tuint8_t *dest;\n\tuint8_t *src;\n\tuint8_t *end;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size % 4 != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (bbram_emul_is_invalid(dev)) {\n\t\treturn -EINVAL;\n\t}\n\n\tdest = (uint8_t *)bbram_emul_get_data(dev) + offset;\n\tsrc = (uint8_t *)data;\n\tend = src + size;\n\n\twhile (src < end) {\n\t\t*dest++ = *src++;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 44.62881290921642}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device \\\"%s\\\" not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_init(*bbram_dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to initialize BBRAM device: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 73.88755671260132}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tARG_UNUSED(sh);\n\n\tif (argc < 2) {\n\t\tLOG_ERR(\"Wrong number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\n\tif (!(*bbram_dev)) {\n\t\tLOG_ERR(\"BBRAM device \\\"%s\\\" not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 60.701445100493125}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 82.72645949721637}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev)    int err;\n    size_t bytes_read = 0;\n\n    while (bytes_read < sizeof(h4_hdr)) {\n        err = uart_fifo_read(dev, &h4_hdr[bytes_read], sizeof(h4_hdr) - bytes_read);\n        if (err < 0) {\n            LOG_ERR(\"UART read error %d\", err);\n            return;\n        }\n        bytes_read += err;\n    }\n}\n", "CodeBleu_score": 30.66136095359935}, {"code": "static void h4_read_hdr(const struct device *dev)    struct h4_uart_data *uart = dev->data;\n    uint32_t hdr_len = sizeof(uart->hdr);\n    uint32_t hdr_offset = uart->hdr_offset;\n    uint32_t hdr_remaining = hdr_len - hdr_offset;\n    int ret;\n\n    /* Read remaining bytes from the UART FIFO into the header buffer */\n    ret = uart_fifo_read(dev, &uart->hdr[hdr_offset], hdr_remaining);\n    if (ret < 0) {\n        LOG_ERR(\"Error reading header from UART FIFO: %d\", ret);\n        return;\n    }\n\n    /* Update the remaining byte count based on the number of bytes successfully read */\n    hdr_remaining -= ret;\n    uart->hdr_offset = hdr_len - hdr_remaining;\n\n    /* If the header is complete, process it */\n    if (hdr_remaining == 0) {\n        h4_process_hdr(dev);\n    }\n}\n", "CodeBleu_score": 37.85383556306756}, {"code": "static void h4_read_hdr(const struct device *dev)\tuint8_t *hdr = (uint8_t *)&hdr_buf;\n\tsize_t hdr_remaining = sizeof(hdr_buf);\n\n\tsize_t hdr_already_read = sizeof(hdr_buf) - hdr_remaining;\n\n\tif (uart_poll_in(dev, hdr + hdr_already_read, hdr_remaining) != 0) {\n\t\tLOG_ERR(\"Error reading header from UART\");\n\t\treturn;\n\t}\n\n\thdr_remaining -= hdr_already_read;\n}\n", "CodeBleu_score": 35.68524990146991}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len)    uint8_t buf[33];\n    size_t rc;\n\n    rc = uart_fifo_read(uart, buf, MIN(len, sizeof(buf)));\n    if (rc < 0) {\n        LOG_ERR(\"uart_fifo_read error %d\", rc);\n        return 0;\n    }\n\n    return rc;\n}\n", "CodeBleu_score": 57.75050250997541}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)    uint8_t tmp[33];\n    size_t ret;\n\n    ret = uart_fifo_read(uart, tmp, MIN(len, sizeof(tmp)));\n    if (ret < 0) {\n        LOG_ERR(\"UART FIFO read error: %d\", ret);\n        return 0;\n    }\n\n    return ret;\n}\n", "CodeBleu_score": 52.07958054506587}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t ret;\n\n\tif (len > sizeof(buf)) {\n\t\tlen = sizeof(buf);\n\t}\n\n\tret = uart_fifo_read(uart, buf, len);\n\tif (ret < 0) {\n\t\tLOG_ERR(\"UART FIFO read error %d\", ret);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 55.967046618480964}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tuint8_t highest = 0;\n\n\tchan_lock(chan);\n\n\tlist_for_each_entry(struct zbus_observer, observer, &chan->observers, head) {\n\t\tif (observer->enabled && observer->priority < highest) {\n\t\t\thighest = observer->priority;\n\t\t}\n\t}\n\n\tchan->highest_observer_priority = highest;\n\n\tchan_unlock(chan);\n}\n", "CodeBleu_score": 15.720470416076985}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)  uint32_t hop = ZBUS_HOP_MAX;\n  struct zbus_observer *obs;\n\n  list_for_each_entry(obs, &chan->observers, chan_link) {\n    if (obs->priority < hop && obs->enabled) {\n      hop = obs->priority;\n    }\n  }\n\n  chan->hop = hop;\n}\n", "CodeBleu_score": 12.12835861519901}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    uint8_t hop = 0;\n    uint8_t prio;\n\n    zbus_lock(chan->lock);\n    for (uint8_t i = 0; i < chan->num_observers; i++) {\n        prio = chan->observers[i].priority;\n        if (prio < hop && chan->observers[i].enabled) {\n            hop = prio;\n        }\n    }\n    chan->highest_observer_priority = hop;\n    zbus_unlock(chan->lock);\n}\n", "CodeBleu_score": 22.707927479705738}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct zbus_channel *chan;\n    struct zbus_observer *obs_chan;\n\n    list_for_each_entry(chan, &zbus_channels, list) {\n        list_for_each_entry(obs_chan, &chan->observers, list) {\n            if (obs_chan == obs) {\n                update_channel_hop(chan);\n                break;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 17.01646332927352}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct zbus_channel_hop *ch;\n    struct zbus_channel_hop *tmp;\n    list_for_each_entry_safe(ch, tmp, &zbus_channels_hop, list) {\n        if (ch->obs == obs) {\n            update_channel_hop(ch);\n        }\n    }\n}\n", "CodeBleu_score": 18.077425562456742}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)  struct zbus_channel_hop *ch;\n  struct zbus_channel_hop *ch_tmp;\n  zbus_list_for_each_entry_safe(ch, ch_tmp, &channel_hop_list, node) {\n    if (ch->obs == obs) {\n      update_channel_hop(ch);\n    }\n  }\n}\n", "CodeBleu_score": 18.689751715649386}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    assert(!in_interrupt());\n    assert(obs);\n    spin_lock(&zbus_lock);\n    obs->priority = K_LOWEST_APPLICATION_THREAD_PRIO;\n    zbus_update_all_channels(obs);\n    spin_unlock(&zbus_lock);\n    return 0;\n}\n", "CodeBleu_score": 47.82600675286724}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    assert(!in_interrupt());\n    assert(obs != NULL);\n\n    spin_lock(&zbus_observer_lock);\n    obs->priority = K_LOWEST_APPLICATION_THREAD_PRIO;\n    zbus_update_observer(obs);\n    spin_unlock(&zbus_observer_lock);\n\n    return 0;\n}\n", "CodeBleu_score": 47.78600401873404}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    assert(!in_interrupt());\n    assert(obs);\n    spin_lock(&zbus_obs_lock);\n    obs->priority = THREAD_PRIORITY_MIN;\n    zbus_update_all_channels(obs);\n    spin_unlock(&zbus_obs_lock);\n    return 0;\n}\n", "CodeBleu_score": 48.16334818104503}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)  int ret;\n  k_tid_t this_tid = k_current_get();\n  k_timeout_t end_time;\n  int prio = chan->context_prio;\n  if (chan == NULL) {\n    return -EINVAL;\n  }\n  if (k_is_in_isr()) {\n    if (timeout == K_FOREVER) {\n      return -EINVAL;\n    }\n    end_time = K_TICKS(k_uptime_ticks() + timeout);\n  } else {\n    end_time = K_TICKS(k_uptime_ticks() + timeout);\n  }\n  if (prio < 0) {\n    prio = k_curr_prio();\n  }\n  k_spinlock_key_t key = k_spin_lock(&chan->lock);\n  ret = zbus_chan_notify_internal(chan, end_time, prio);\n  k_spin_unlock(&chan->lock, key);\n  return ret;\n}", "CodeBleu_score": 31.78572712280624}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)    int err = 0;\n    uint32_t end_time;\n    int context_prio;\n\n    /* Assert that the channel is not null. */\n    __ASSERT(chan != NULL, \"channel cannot be null\");\n\n    /* Adjust the timeout if in an ISR. */\n    timeout = _zbus_chan_adjust_timeout(timeout);\n\n    /* Calculate the end time based on the timeout. */\n    end_time = zbus_chan_end_time(timeout);\n\n    /* Initialize the context priority. */\n    context_prio = _zbus_chan_context_prio();\n\n    /* Lock the channel. */\n    _zbus_chan_lock(chan, context_prio);\n\n    /* Execute the notification logic. */\n    err = _zbus_chan_notify(chan, end_time, context_prio);\n\n    /* Unlock the channel. */\n    _zbus_chan_unlock(chan);\n\n    /* Return any error encountered during the process. */\n    return err;\n}\n", "CodeBleu_score": 45.13388362494103}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)    int ret;\n    k_tid_t thread_id;\n    unsigned int key;\n    k_timeout_t end_time;\n    int32_t priority;\n\n    if (chan == NULL) {\n        return -EINVAL;\n    }\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    end_time = k_uptime_get() + timeout;\n\n    priority = k_sched_priority_get(k_current_get());\n\n    key = irq_lock();\n\n    if (chan->state == ZBUS_CHAN_INIT) {\n        chan->state = ZBUS_CHAN_READY;\n    }\n\n    if (chan->state != ZBUS_CHAN_READY) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    thread_id = k_current_get();\n\n    if (chan->thread_id == NULL) {\n        chan->thread_id = thread_id;\n    }\n\n    if (chan->thread_id != thread_id) {\n        ret = -EBUSY;\n        goto exit;\n    }\n\n    if (chan->waitq == NULL) {\n        chan->waitq = k_waitq_create();\n        if (chan->waitq == NULL) {\n            ret = -ENOMEM;\n            goto exit;\n        }\n    }\n\n    if (chan->thread_id != thread_id) {\n        ret = -EBUSY;\n        goto exit;\n    }\n\n    chan->thread_id = NULL;\n\n    ret = k_waitq_put(chan->waitq, thread_id, priority, end_time);\n", "CodeBleu_score": 39.06588247963043}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)    uint32_t itmask;\n    uint32_t itmask2;\n    uint32_t itmask3;\n    uint32_t itmask4;\n    uint32_t itmask5;\n    uint32_t itmask6;\n    uint32_t itmask7;\n    uint32_t itmask8;\n    uint32_t itmask9;\n    uint32_t itmask10;\n    uint32_t itmask11;\n    uint32_t itmask12;\n    uint32_t itmask13;\n    uint32_t itmask14;\n    uint32_t itmask15;\n    uint32_t itmask16;\n    uint32_t itmask17;\n    uint32_t itmask18;\n    uint32_t itmask19;\n    uint32_t itmask20;\n    uint32_t itmask21;\n    uint32_t itmask22;\n    uint32_t itmask23;\n    uint32_t itmask24;\n    uint32_t itmask25;\n    uint32_t itmask26;\n    uint32_t itmask27;\n    uint32_t itmask28;\n    uint32_t itmask29;\n    uint32_t itmask30;\n    uint32_t itmask31;\n    uint32_t itmask32;\n    uint32_t itmask33;\n    uint32_t itmask34;\n    uint32_t itmask35;\n    uint32_t itmask36;\n    uint32_t itmask37;\n    uint32_t itmask38;\n    uint32_t itmask39;\n    uint32_t itmask40;\n    uint32_t itmask41;\n    uint32_t itmask42;\n    uint32_t itmask43;\n    uint32_t", "CodeBleu_score": 12.905652308302107}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)  uint32_t bitpos = 0;\n  uint32_t temp = 0;\n  uint32_t temp_normal = 0;\n  uint32_t temp_abnormal = 0;\n\n  if (Int == ETH_IT_TX) {\n    bitpos = ETH_IT_TX_BITPOS;\n  } else if (Int == ETH_IT_RX) {\n    bitpos = ETH_IT_RX_BITPOS;\n  } else if (Int == ETH_IT_ERR) {\n    bitpos = ETH_IT_ERR_BITPOS;\n  } else if (Int == ETH_IT_TIM) {\n    bitpos = ETH_IT_TIM_BITPOS;\n  } else if (Int == ETH_IT_BUS) {\n    bitpos = ETH_IT_BUS_BITPOS;\n  } else if (Int == ETH_IT_DMA) {\n    bitpos = ETH_IT_DMA_BITPOS;\n  } else {\n    return;\n  }\n\n  if (enable) {\n    temp = ETH->IER;\n    temp |= Int;\n    ETH->IER = temp;\n\n    if (Int == ETH_IT_ERR) {\n      temp_normal = ETH->NISR;\n      temp_abnormal = ETH->AISR;\n\n      if (temp_normal & Int) {\n        ETH->NIE |= Int;\n      } else {\n        ETH->AIE |= Int;\n      }\n    } else {\n      ETH->IE |= Int;\n    }\n  } else {\n    temp = ETH->IER;\n    temp &= ~Int;\n    ETH->IER = temp;\n\n    if (Int == ETH_IT_ERR) {\n      temp_normal = ETH->NIE;\n      temp_abnormal = ETH->AIE;\n\n      if (temp_normal & Int) {\n        temp_normal &= ~Int;\n        ETH->NIE = temp_normal;\n      } else {", "CodeBleu_score": 34.24097656956848}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)    uint32_t IntMask = 0;\n    uint32_t IntMask2 = 0;\n\n    if (Int == ETH_INT_RX_TIMER) {\n        IntMask = ETH_INT_RX_TIMER;\n    } else if (Int == ETH_INT_TX_TIMER) {\n        IntMask = ETH_INT_TX_TIMER;\n    } else if (Int == ETH_INT_TX_ERROR) {\n        IntMask = ETH_INT_TX_ERROR;\n    } else if (Int == ETH_INT_RX_ERROR) {\n        IntMask = ETH_INT_RX_ERROR;\n    } else if (Int == ETH_INT_TX_UNDERFLOW) {\n        IntMask = ETH_INT_TX_UNDERFLOW;\n    } else if (Int == ETH_INT_RX_OVERFLOW) {\n        IntMask = ETH_INT_RX_OVERFLOW;\n    } else if (Int == ETH_INT_RX_FRAME) {\n        IntMask = ETH_INT_RX_FRAME;\n    } else if (Int == ETH_INT_TX_FRAME) {\n        IntMask = ETH_INT_TX_FRAME;\n    } else if (Int == ETH_INT_TX_QUEUE_EMPTY) {\n        IntMask = ETH_INT_TX_QUEUE_EMPTY;\n    } else if (Int == ETH_INT_RX_QUEUE_OVERFLOW) {\n        IntMask = ETH_INT_RX_QUEUE_OVERFLOW;\n    } else if (Int == ETH_INT_RX_QUEUE_UNDERFLOW) {\n        IntMask = ETH_INT_RX_QUEUE_UNDERFLOW;\n    } else if (Int == ETH_INT_RX_QUEUE_FULL) {\n        IntMask = ETH_INT_RX_QUEUE_FULL;\n    } else if (Int == ETH_INT_TX_QUEUE_UNDERFLOW) {", "CodeBleu_score": 24.83821482582689}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)  ETH_TX_DESC *tx_desc = ETH->DMADSC_TX;\n  ETH_TX_DESC *start_tx_desc = tx_desc;\n\n  do {\n    if (!(tx_desc->TDSR & ETH_TDSR_OWN)) {\n      return tx_desc;\n    }\n    tx_desc = (ETH_TX_DESC *)((uint32_t)tx_desc + sizeof(ETH_TX_DESC));\n  } while (tx_desc != start_tx_desc);\n\n  return 0;\n}\n", "CodeBleu_score": 49.899650232961164}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)  ETH_TX_DESC *desc;\n  uint32_t desc_addr;\n\n  desc_addr = ETH->DMADSC_TX;\n\n  while (1) {\n    desc = (ETH_TX_DESC *)desc_addr;\n    if (desc->OWN == 1) {\n      desc_addr = desc->NXTDES;\n      if (desc_addr == ETH->DMADSC_TX) {\n        return 0;\n      }\n    } else {\n      return desc;\n    }\n  }\n}", "CodeBleu_score": 49.894143015480985}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)    ETH_TX_DESC *tx_desc = ETH_GetTxDesc();\n    ETH_TX_DESC *start_tx_desc = tx_desc;\n\n    do {\n        if (!(tx_desc->status & ETH_TX_STATUS_OWN)) {\n            return tx_desc;\n        }\n        tx_desc++;\n    } while (tx_desc != start_tx_desc);\n\n    return 0;\n}\n", "CodeBleu_score": 44.2541741886192}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    RT_ASSERT(device != RT_NULL);\n\n    Cy_CSDIDAC_OutputEnable(CY_CSDIDAC_BASE, channel, *value);\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 20.187940068635672}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    RT_ASSERT(device != RT_NULL);\n    struct cyp_adc_device *cyp_adc = (struct cyp_adc_device *)device;\n    cy_en_sd_status_t status = Cy_CSDIDAC_OutputEnable(cyp_adc->obj, channel, *value);\n    if (status != CY_CSD_SUCCESS) {\n        LOG_E(\"Failed to enable DAC output\");\n        return -RT_ERROR;\n    }\n    return RT_EOK;\n}\n", "CodeBleu_score": 52.946495690480354}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    RT_ASSERT(device != RT_NULL);\n    struct cyp_dac_device *cyp_device = (struct cyp_dac_device *)device;\n    struct cyp_dac_channel *cyp_channel = &cyp_device->channels[channel];\n\n    if (Cy_CSDIDAC_OutputEnable(cyp_device->base, cyp_channel->id, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Cy_CSDIDAC_OutputEnable failed\");\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 54.05712698399088}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)    int i;\n    if ((addr + size) > (IFX_FLASH_START_ADDR + IFX_FLASH_SIZE)) {\n        LOG_E(\"Invalid argument\");\n        return -RT_EINVAL;\n    }\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t*)(addr + i);\n    }\n    return i;\n}\n", "CodeBleu_score": 53.87184518735027}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)    if ((addr + size) > (IFX_FLASH_BASE + IFX_FLASH_SIZE)) {\n        rt_kprintf(\"[FLASH] read addr(0x%x) + size(0x%x) > IFX_FLASH_BASE(0x%x) + IFX_FLASH_SIZE(0x%x)\\n\", addr, size, IFX_FLASH_BASE, IFX_FLASH_SIZE);\n        return -RT_EINVAL;\n    }\n\n    rt_uint32_t i;\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *) (addr + i);\n    }\n\n    return i;\n}\n", "CodeBleu_score": 53.73754727969676}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)    rt_uint32_t i;\n\n    if (addr + size > IFX_FLASH_SIZE) {\n        rt_kprintf(\"flash read out of range: addr = 0x%x, size = %d\\n\", addr, size);\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n\n    return i;\n}\n", "CodeBleu_score": 54.745483010781726}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    CY_ASSERT(timer);\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(obj);\n}\n", "CodeBleu_score": 23.844803419741517}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    rt_uint32_t count;\n    cyhal_timer_t *obj;\n\n    RT_ASSERT(timer);\n    obj = (cyhal_timer_t *)timer->parent.user_data;\n    count = cyhal_timer_read(obj);\n\n    return count;\n}\n", "CodeBleu_score": 66.48149258372533}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    rt_uint32_t count;\n\n    RT_ASSERT(timer != RT_NULL);\n\n    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n\n    cyhal_timer_read(obj, &count);\n\n    return count;\n}\n", "CodeBleu_score": 62.36084999551173}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void)\twhile (xSemaphoreTake(dfs_lock_mutex, portMAX_DELAY) == pdFALSE) {\n\t\t;\n\t}\n}\n", "CodeBleu_score": 8.505638718134588}, {"code": "void dfs_lock(void)    int ret;\n    do {\n        ret = pthread_mutex_lock(&dfs_lock_mutex);\n        if (ret != 0 && ret != EBUSY) {\n            assert(0);\n        }\n    } while (ret != 0);\n}\n", "CodeBleu_score": 29.206985009850726}, {"code": "void dfs_lock(void)    int rc;\n    do {\n        rc = pthread_mutex_lock(&dfs_mutex);\n    } while (rc != 0);\n}\n", "CodeBleu_score": 11.747926330677187}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int i;\n\n    /* Search for an empty slot starting from the specified index. */\n    for (i = startfd; i < DFS_MAX_FD; i++) {\n        if (fdt->fd[i].fd_inode == NULL) {\n            return i;\n        }\n    }\n\n    /* If no empty slot is found, attempt to expand the fd table. */\n    if (dfs_fdtable_expand(fdt) == 0) {\n        return fd_slot_alloc(fdt, startfd);\n    }\n\n    /* If expansion fails, return -1. */\n    return -1;\n}\n", "CodeBleu_score": 40.196263330297704}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int fd;\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fdtab[fd] == NULL) {\n            fdt->fdtab[fd] = fdt->cloned;\n            return fd;\n        }\n    }\n\n    if (fd >= fdt->maxfd) {\n        return -1;\n    }\n\n    return fd;\n}\n", "CodeBleu_score": 42.1307133454196}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int i;\n    for (i = startfd; i < fdt->maxfd; i++) {\n        if (fdt->fd[i] == NULL) {\n            return i;\n        }\n    }\n    return -1;\n}\n", "CodeBleu_score": 29.05748391559419}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error)    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(rt_err_str) / sizeof(rt_err_str[0]); i++) {\n        if (error == rt_err_str[i].error) {\n            return rt_err_str[i].str;\n        }\n    }\n    return \"EUNKNOW\";\n}\n", "CodeBleu_score": 66.07262798314736}, {"code": "const char *rt_strerror(rt_err_t error)    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(rt_errlist) / sizeof(rt_errlist[0]); i++) {\n        if (rt_errlist[i].err == error) {\n            return rt_errlist[i].str;\n        }\n    }\n    return \"EUNKNOW\";\n}\n", "CodeBleu_score": 65.06447931737472}, {"code": "const char *rt_strerror(rt_err_t error)    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(err_str_tab) / sizeof(err_str_tab[0]); i++) {\n        if (err_str_tab[i].err == error) {\n            return err_str_tab[i].str;\n        }\n    }\n    return \"EUNKNOW\";\n}\n", "CodeBleu_score": 64.1017473614218}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_err_t result;\n\n    if (hook == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    rt_enter_critical();\n\n    if (rt_thread_idle_hook != RT_NULL) {\n        result = -RT_EFULL;\n    } else {\n        rt_thread_idle_hook = hook;\n        result = RT_EOK;\n    }\n\n    rt_exit_critical();\n\n    return result;\n}\n", "CodeBleu_score": 25.854093670989343}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_uint8_t i;\n    rt_base_t level;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    for (i = 0; i < RT_THREAD_HOOK_MAX; i++) {\n        /* find empty slot */\n        if (idle_hook[i] == RT_NULL) {\n            idle_hook[i] = hook;\n            rt_hw_interrupt_enable(level);\n            return RT_EOK;\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return -RT_EFULL;\n}\n", "CodeBleu_score": 55.011648572966784}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_err_t result = RT_EFULL;\n\n    rt_enter_critical();\n\n    for (int i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n        if (rt_thread_idle_hook[i] == RT_NULL) {\n            rt_thread_idle_hook[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    rt_exit_critical();\n\n    return result;\n}\n", "CodeBleu_score": 50.72996752577919}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    int i;\n    rt_err_t result;\n\n    /* Lock the spinlock to ensure thread safety */\n    rt_enter_critical();\n\n    /* Iterate through the idle hook list to find the specified hook */\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n        if (idle_hook[i] == hook) {\n            /* Set the corresponding entry to null */\n            idle_hook[i] = RT_NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* If the hook is not found, return an error code */\n    if (i >= RT_THREAD_IDLE_HOOK_MAX) {\n        result = -RT_ERROR;\n    }\n\n    /* Unlock the spinlock */\n    rt_exit_critical();\n\n    /* Return the result */\n    return result;\n}", "CodeBleu_score": 63.39056469149943}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_list_t *node;\n    struct rt_thread_idle_hook *idle_hook;\n    rt_err_t result = RT_EOK;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    rt_enter_critical();\n    node = rt_list_find(&idle_list, (rt_list_t *)&idle_hook, (int (*)(rt_list_t *, rt_list_t *))_idle_hook_comp);\n    if (node != RT_NULL) {\n        rt_list_remove(&idle_list, node);\n        idle_hook->hook = RT_NULL;\n    } else {\n        result = -RT_ERROR;\n    }\n    rt_exit_critical();\n\n    return result;\n}\n", "CodeBleu_score": 26.996015356358004}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_uint8_t i;\n    rt_base_t level;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_MAX; i++) {\n        if (rt_thread_idle_sethook[i] == hook) {\n            rt_thread_idle_sethook[i] = RT_NULL;\n            rt_hw_interrupt_enable(level);\n\n            return RT_EOK;\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return -RT_ERROR;\n}\n", "CodeBleu_score": 56.24160933272391}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_err_t result = RT_EOK;\n    rt_thread_t thread;\n    rt_base_t level;\n\n    /* ensure the scheduler is unlocked */\n    level = rt_hw_interrupt_disable();\n\n    /* dequeue and resume all suspended threads */\n    while ((thread = rt_list_get_first(susp_list)) != RT_NULL) {\n        rt_list_remove(susp_list, thread);\n        rt_thread_resume(thread);\n        result = rt_thread_yield();\n        if (result != RT_EOK) {\n            break;\n        }\n    }\n\n    /* restore the scheduler lock level */\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}\n", "CodeBleu_score": 32.472230201523104}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_err_t result = RT_EOK;\n\n    /* Ensure the scheduler is unlocked */\n    rt_enter_critical();\n\n    /* Dequeue and wake up each suspended thread from the list one by one */\n    while (!rt_list_isempty(susp_list)) {\n        struct rt_thread *thread = rt_list_entry(rt_list_get_first(susp_list), struct rt_thread, tlist);\n        rt_list_remove(&thread->tlist);\n        rt_thread_resume(thread);\n        rt_thread_yield();\n    }\n\n    /* Release the scheduler lock */\n    rt_exit_critical();\n\n    return result;\n}\n", "CodeBleu_score": 32.194303741738686}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_err_t result;\n    rt_thread_t thread;\n    rt_base_t level;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    level = rt_hw_interrupt_disable();\n    result = RT_EOK;\n\n    while ((thread = rt_list_first_entry(susp_list, struct rt_thread, tlist, list)) != RT_NULL) {\n        rt_list_remove(&thread->tlist);\n        thread->errno = thread_error;\n        thread->stat = RT_THREAD_READY;\n        result |= rt_thread_resume(thread);\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}\n", "CodeBleu_score": 34.263014588530936}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t old_device = rt_console;\n    rt_device_t new_device = RT_NULL;\n\n    /* Save the current console device */\n    if (old_device != RT_NULL) {\n        rt_device_ref_inc(old_device);\n    }\n\n    /* Find the new device by its name */\n    new_device = rt_device_find(name);\n\n    /* Check if the new device is valid and different from the current device */\n    if (new_device != RT_NULL && new_device != old_device) {\n        /* Close the current console device if it exists */\n        if (old_device != RT_NULL) {\n            rt_device_close(old_device);\n        }\n\n        /* Open the new console device with read/write and stream flags */\n        if (rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n            /* Set the new console device as the current console device */\n            rt_console = new_device;\n        } else {\n            /* If the new device cannot be opened, restore the old console device */\n            rt_console = old_device;\n        }\n    }\n\n    /* Decrement the reference count of the old device */\n    if (old_device != RT_NULL) {\n        rt_device_ref_dec(old_device);\n    }\n\n    /* Return the old console device */\n    return old_device;\n}\n", "CodeBleu_score": 64.66667866665195}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t old_console = rt_console;\n    if (rt_strcmp(name, RT_CONSOLE_DEVICE_NAME) == 0) {\n        /* close old console */\n        if (old_console != RT_NULL) {\n            rt_device_close(old_console);\n            old_console = RT_NULL;\n        }\n        return old_console;\n    }\n    /* close old console */\n    if (old_console != RT_NULL) {\n        rt_device_close(old_console);\n        old_console = RT_NULL;\n    }\n    /* open new console */\n    rt_console = rt_device_find(name);\n    if (rt_console != RT_NULL) {\n        rt_device_open(rt_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    }\n    return old_console;\n}\n", "CodeBleu_score": 57.78405388372757}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t old_console = rt_console;\n    if (rt_console != RT_NULL) {\n        rt_device_close(rt_console);\n    }\n    if (rt_device_find(name) != RT_NULL) {\n        rt_console = rt_device_find(name);\n        rt_device_open(rt_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    }\n    return old_console;\n}\n", "CodeBleu_score": 40.54906350646499}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type)    int count = 0;\n    struct rt_object_information *info = NULL;\n\n    switch (type) {\n    case RT_OBJECT_CLASS_THREAD:\n        info = &thread_info;\n        break;\n    case RT_OBJECT_CLASS_SEMAPHORE:\n        info = &semaphore_info;\n        break;\n    case RT_OBJECT_CLASS_MUTEX:\n        info = &mutex_info;\n        break;\n    case RT_OBJECT_CLASS_MAILBOX:\n        info = &mailbox_info;\n        break;\n    case RT_OBJECT_CLASS_MESSAGEQUEUE:\n        info = &messagequeue_info;\n        break;\n    case RT_OBJECT_CLASS_EVENT:\n        info = &event_info;\n        break;\n    case RT_OBJECT_CLASS_MEMHEAP:\n        info = &memheap_info;\n        break;\n    case RT_OBJECT_CLASS_DEVICE:\n        info = &device_info;\n        break;\n    case RT_OBJECT_CLASS_MODULE:\n        info = &module_info;\n        break;\n    case RT_OBJECT_CLASS_CONSOLE:\n        info = &console_info;\n        break;\n    case RT_OBJECT_CLASS_COMPLETION:\n        info = &completion_info;\n        break;\n    case RT_OBJECT_CLASS_FS:\n        info = &filesystem_info;\n        break;\n    case RT_OBJECT_CLASS_WORKQUEUE:\n        info = &workqueue_info;\n        break;\n    case RT_OBJECT_CLASS_NOTIFY:\n        info = &notify_info;\n        break;\n    case RT_OBJECT_CLASS_TIMER:\n        info = &timer_info;\n        break;\n    case RT_OBJECT_CLASS_NETDEVICE:\n        info = &netdevice_info;\n        break;\n    case RT_OBJECT_CLASS_SOCKET:\n        info = &socket_info;\n        break;\n    case RT_OBJECT_CLASS_NET_DBG:", "CodeBleu_score": 31.551098320438687}, {"code": "int rt_object_get_length(enum rt_object_class_type type)  int count = 0;\n  struct rt_object_information *info;\n  struct rt_object_information *tmp;\n  unsigned long flags;\n\n  info = rt_object_get_information(type);\n  spin_lock_irqsave(&info->lock, flags);\n  list_for_each_entry_safe(info, tmp, &info->list, list) {\n    count++;\n  }\n  spin_unlock_irqrestore(&info->lock, flags);\n  return count;\n}\n", "CodeBleu_score": 43.90191833323288}, {"code": "int rt_object_get_length(enum rt_object_class_type type)    int count = 0;\n    struct rt_object_information *info;\n    unsigned long flags;\n\n    info = rt_object_get_information(type);\n    if (info == NULL) {\n        return -1;\n    }\n\n    spin_lock_irqsave(&info->lock, flags);\n    count = info->count;\n    spin_unlock_irqrestore(&info->lock, flags);\n\n    return count;\n}\n", "CodeBleu_score": 36.90698022082292}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object)    struct rt_object_information *information;\n    struct rt_object *object_container;\n\n    RT_ASSERT(object != RT_NULL);\n\n    information = &object->information;\n    object_container = &object->object;\n\n    if (information->detach != RT_NULL) {\n        information->detach(object);\n    }\n\n    /* remove object from object list */\n    rt_list_remove(&object_container->list);\n\n    /* unlock */\n    rt_spin_unlock(&object_container->lock);\n\n    /* set object type */\n    object->type = RT_Object_Class_Unknown;\n}\n", "CodeBleu_score": 46.50533178625556}, {"code": "void rt_object_detach(rt_object_t object)    struct rt_object_information *information;\n    rt_list_t *list;\n\n    /* Check if the object is null */\n    if (object == RT_NULL) {\n        return;\n    }\n\n    /* Call the hook function for detachment */\n    rt_object_detach_hook(object);\n\n    /* Get the object's information structure */\n    information = object->information;\n\n    /* Lock the object's spinlock */\n    rt_spinlock_lock(&information->object_lock);\n\n    /* Remove the object from its list */\n    list = &information->object_list;\n    rt_list_remove(list, &object->list);\n\n    /* Unlock the object's spinlock */\n    rt_spinlock_unlock(&information->object_lock);\n\n    /* Set the object's type to zero */\n    object->type = 0;\n}", "CodeBleu_score": 40.36857690680039}, {"code": "void rt_object_detach(rt_object_t object)    struct rt_object_information *information;\n\n    RT_ASSERT(object != RT_NULL);\n\n    /* call object detach hook */\n    if (object->hook != RT_NULL) {\n        object->hook(object, RT_Object_Class_Detach);\n    }\n\n    information = &object->information;\n\n    /* lock */\n    rt_spin_lock(&object_lock);\n\n    /* remove from object list */\n    rt_list_remove(&information->list);\n\n    /* unlock */\n    rt_spin_unlock(&object_lock);\n\n    /* set object type */\n    information->type = 0;\n}", "CodeBleu_score": 44.903492080338495}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_custom_object_t custom_obj = (rt_custom_object_t) obj;\n\n    if (custom_obj == NULL) {\n        return RT_ERR_INVALID_OBJECT;\n    }\n\n    if (custom_obj->class != RT_CUSTOM_OBJECT_CLASS) {\n        return RT_ERR_INVALID_OBJECT_CLASS;\n    }\n\n    rt_err_t result = RT_OK;\n\n    if (custom_obj->destroy != NULL) {\n        result = custom_obj->destroy(custom_obj);\n    }\n\n    free(custom_obj);\n\n    return result;\n}\n", "CodeBleu_score": 45.89930784552986}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t ret = RT_OK;\n    rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n\n    if (custom_obj == NULL) {\n        return RT_ERR_NULL_POINTER;\n    }\n\n    if (custom_obj->class != RT_CUSTOM_OBJECT_CLASS) {\n        return RT_ERR_INVALID_CLASS;\n    }\n\n    if (custom_obj->destroy != NULL) {\n        ret = custom_obj->destroy(custom_obj);\n    }\n\n    free(custom_obj);\n\n    return ret;\n}\n", "CodeBleu_score": 48.503328616540415}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n    rt_err_t result = RT_OK;\n\n    if (custom_obj == RT_NULL) {\n        return RT_ERR_INVALID_ARG;\n    }\n\n    if (custom_obj->object.class_type != RT_CUSTOM_OBJECT_CLASS_TYPE) {\n        return RT_ERR_INVALID_ARG;\n    }\n\n    if (custom_obj->destroy != RT_NULL) {\n        result = custom_obj->destroy(custom_obj);\n    }\n\n    rt_free(custom_obj);\n\n    return result;\n}\n", "CodeBleu_score": 46.03851637246148}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void)    struct thread *curr = get_current_thread();\n    enter_critical_section();\n    close_thread(curr);\n    add_defunct_thread(curr);\n    exit_critical_section();\n    schedule();\n}\n", "CodeBleu_score": 51.41949619447534}, {"code": "static void _thread_exit(void)    struct thread_t *curr_thread = get_current_thread();\n\n    enter_critical_section();\n    curr_thread->status = THREAD_DEFUNCT;\n    add_defunct_thread(curr_thread);\n    exit_critical_section();\n\n    schedule();\n}\n", "CodeBleu_score": 53.141857373727}, {"code": "static void _thread_exit(void)    struct thread_t *curr = get_current_thread();\n\n    enter_critical_section();\n    thread_close(curr);\n    add_defunct_thread(curr);\n    exit_critical_section();\n\n    schedule();\n}\n", "CodeBleu_score": 51.64617678144816}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter)    thread_t *thread = (thread_t *)parameter;\n\n    if (!thread) {\n        return;\n    }\n\n    if (!thread->suspended) {\n        return;\n    }\n\n    thread->error = E_TIMEOUT;\n\n    scheduler_lock();\n\n    list_remove(&thread->suspend_queue);\n    list_push(&thread->ready_queue, &thread->ready_link);\n\n    scheduler_unlock();\n}\n", "CodeBleu_score": 34.61336773946204}, {"code": "static void _thread_timeout(void *parameter)    thread_t *thread = (thread_t *)parameter;\n\n    if (!thread) {\n        return;\n    }\n\n    scheduler_lock();\n\n    if (!thread_is_suspended(thread)) {\n        scheduler_unlock();\n        return;\n    }\n\n    thread_set_error(thread, ETIME);\n\n    _thread_remove_suspended(thread);\n\n    _thread_insert_ready(thread);\n\n    scheduler_unlock();\n}\n", "CodeBleu_score": 40.09481091752454}, {"code": "static void _thread_timeout(void *parameter)    thread_t *thread;\n\n    /* Get the thread parameter */\n    thread = (thread_t *)parameter;\n\n    /* Ensure the thread is valid */\n    if (thread == NULL) {\n        return;\n    }\n\n    /* Ensure the thread is suspended */\n    if (thread->state != THREAD_SUSPENDED) {\n        return;\n    }\n\n    /* Set the thread's error number to a timeout value */\n    thread->error = ETIME;\n\n    /* Lock the scheduler */\n    _scheduler_lock();\n\n    /* Remove the thread from the suspend list */\n    _thread_suspend_remove(thread);\n\n    /* Insert the thread into the ready list */\n    _thread_ready_insert(thread);\n\n    /* Unlock the scheduler */\n    _scheduler_unlock();\n}\n", "CodeBleu_score": 35.875441206757074}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread)    rt_err_t result = RT_EOK;\n    rt_uint32_t level;\n    rt_mutex_t mutex;\n\n    level = rt_hw_interrupt_disable();\n    if (thread->waiting_mutex) {\n        mutex = thread->waiting_mutex;\n        thread->waiting_mutex = RT_NULL;\n        thread->pending_mutex = RT_NULL;\n\n        if (rt_list_isempty(&mutex->owner_list)) {\n            result = rt_list_remove(&mutex->owner_list, &thread->tlist);\n            RT_ASSERT(result == RT_EOK);\n        }\n    }\n\n    _thread_release_all_mutex(thread);\n    rt_hw_spin_unlock(&thread->lock);\n    rt_hw_interrupt_enable(level);\n}\n", "CodeBleu_score": 37.03244768113641}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)    if (thread->wait_object != NULL) {\n        rt_mutex_t mutex = (rt_mutex_t)thread->wait_object;\n        if (mutex->owner == thread) {\n            mutex->owner = NULL;\n        } else {\n            rt_list_remove(&mutex->pending_threads, &thread->pending_node);\n        }\n        thread->wait_object = NULL;\n    }\n\n    rt_mutex_t mutex;\n    rt_list_for_each_entry(mutex, &thread->mutex_list, list_node) {\n        rt_mutex_unlock(mutex);\n    }\n\n    rt_spinlock_unlock(&thread->lock);\n}\n", "CodeBleu_score": 32.21887358913001}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)    rt_base_t level;\n    rt_mutex_t mutex;\n\n    level = rt_hw_interrupt_disable();\n\n    /* get the mutex the thread is waiting on */\n    mutex = thread->wait_object;\n\n    /* remove the thread from the mutex's waiting list */\n    if (mutex) {\n        rt_list_remove(&(thread->tlist));\n\n        /* clear the thread's pending object */\n        thread->wait_object = RT_NULL;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->mutex_nest > 0) {\n        mutex = thread->mutex_nest_list[--thread->mutex_nest];\n        rt_mutex_release(mutex);\n    }\n\n    rt_hw_interrupt_enable(level);\n}\n", "CodeBleu_score": 35.91311884422282}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->entry != RT_NULL);\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread name:%s (0x%p)\\n\", thread->name, thread));\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread init_priority:%d\\n\", thread->init_priority));\n\n    /* thread priority */\n    thread->current_priority = thread->init_priority;\n    thread->number_mask = 1L << thread->current_priority;\n\n    /* set thread state to suspended */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    /* trigger scheduler */\n    rt_schedule();\n\n    return RT_EOK;\n}", "CodeBleu_score": 43.94018179601653}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    RT_ASSERT(thread != RT_NULL);\n\n    /* check thread state */\n    if (thread->stat != RT_THREAD_INIT) {\n        return -RT_ERROR;\n    }\n\n    /* set thread priority */\n    thread->current_priority = thread->init_priority;\n    thread->number_mask = 1UL << thread->current_priority;\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* now the thread is in suspended state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(thread->thread_stack_size);\n\n    /* trigger scheduler */\n    rt_schedule();\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 46.96612573802844}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->entry != RT_NULL);\n\n    /* log thread */\n    rt_kprintf(\"thread %s(0x%p) startup, priority: %d\\n\",\n               thread->name, thread, thread->priority);\n\n    /* calculate priority attributes */\n    thread->ticks = thread->init_tick;\n    thread->priority = thread->init_priority;\n    thread->remaining_tick = thread->init_tick;\n\n    /* reset thread state */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    /* trigger scheduler */\n    rt_schedule();\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 41.405159095185496}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_list_t list;\n    rt_timer_t timer;\n\n    list = rt_list_first(&timer_list[0]);\n    if (list != &timer_list[0]) {\n        timer = rt_list_entry(list, struct rt_timer, list);\n        *timeout_tick = timer->timeout;\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}\n", "CodeBleu_score": 51.1716768453778}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_list_t *list;\n    struct timer_entry *entry;\n\n    list = &timer_list[TIMER_LIST_MAX_LEVEL - 1];\n    if (list->next == list) {\n        return -RT_ETIMEOUT;\n    }\n\n    entry = rt_list_entry(list->next, struct timer_entry, list);\n    *timeout_tick = entry->timeout;\n    return RT_EOK;\n}\n", "CodeBleu_score": 51.02991003402496}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_list_t *list;\n    rt_timer_t *timer;\n\n    if (timer_list[0].next != &timer_list[0]) {\n        list = timer_list[0].next;\n        timer = rt_list_entry(list, struct rt_timer, list);\n        *timeout_tick = timer->timeout;\n        return RT_EOK;\n    }\n\n    return -RT_ERROR;\n}\n", "CodeBleu_score": 44.46445035750426}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* allocate memory for the timer object */\n    rt_timer_t timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        /* initialize the timer object */\n        timer->timeout_func = timeout;\n        timer->parameter = parameter;\n        timer->init_tick = timer->timeout_tick = time;\n        timer->flag = flag;\n\n        /* set the timer name */\n        rt_strncpy(timer->name, name, RT_NAME_MAX);\n\n        /* initialize the timer list */\n        rt_list_init(&(timer->list));\n    }\n\n    /* return the timer object or null if the allocation fails */\n    return timer;\n}\n", "CodeBleu_score": 48.887367687438434}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)    /* allocate memory for the timer object */\n    rt_timer_t timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        /* initialize the timer */\n        rt_timer_init(timer, name, timeout, parameter, time, flag);\n    }\n\n    return timer;\n}\n", "CodeBleu_score": 43.55588420490143}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)    rt_timer_t timer;\n\n    /* parameter check */\n    RT_ASSERT(timeout != RT_NULL);\n\n    /* try to allocate a timer from timer pool */\n    timer = (rt_timer_t)rt_object_allocate(&timer_pool, RT_Object_Class_Timer);\n    if (timer != RT_NULL) {\n        /* initialize timer */\n        timer->timeout_func = timeout;\n        timer->parameter    = parameter;\n        timer->init_tick    = rt_tick_get();\n        timer->timeout_tick = time;\n        timer->flag         = flag;\n\n        /* insert timer into timer list */\n        rt_list_insert_after(&timer_list, &(timer->list));\n    }\n\n    return timer;\n}\n", "CodeBleu_score": 44.51179701472724}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\trec := httptest.NewRecorder()\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 73.41813574701301}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\trecorder := httptest.NewRecorder()\n\n\tfor _, handler := range a.Handlers {\n\t\thandler.ServeHTTP(recorder, req)\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.Router.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 50.82963827568702}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\trec := httptest.NewRecorder()\n\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 55.54369824508073}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tasset, err := a.Assets.Get(req.URL.Path)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch path.Ext(req.URL.Path) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\t_, err = res.Write(asset)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t}\n}", "CodeBleu_score": 50.55401358249869}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tif path == \"\" {\n\t\tpath = \"index.html\"\n\t}\n\t\n\tasset, err := a.assets.Get(path)\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\n\tswitch filepath.Ext(path) {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tdefault:\n\t\tres.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\t}\n\n\t_, err = res.Write(asset)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t}\n}\n", "CodeBleu_score": 51.29275665255978}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"index.html\"\n\t}\n\tasset, err := a.Asset(path)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\tswitch path[len(path)-2:] {\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tres.Write(asset)\n}\n", "CodeBleu_score": 47.76906383465928}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\tjson.NewEncoder(res).Encode(map[string]interface{}{\n\t\t\t\"error\": \"no robot found with name \" + robotName,\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tconnectionsJSON := make([]map[string]interface{}, len(connections))\n\tfor i, connection := range connections {\n\t\tconnectionsJSON[i] = map[string]interface{}{\n\t\t\t\"type\": connection.Type(),\n\t\t\t\"name\": connection.Name(),\n\t\t}\n\t}\n\tjson.NewEncoder(res).Encode(map[string]interface{}{\n\t\t\"connections\": connectionsJSON,\n\t})\n}\n", "CodeBleu_score": 49.46291411289934}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := getVar(req, \"robot\")\n\trobot := a.master.Robot(robotName)\n\tif robot == nil {\n\t\twriteJSON(res, map[string]interface{}{\n\t\t\t\"success\": false,\n\t\t\t\"error\":   \"No robot found with the specified name\",\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tconnectionsJSON := make([]map[string]interface{}, len(connections))\n\tfor i, connection := range connections {\n\t\tconnectionsJSON[i] = map[string]interface{}{\n\t\t\t\"name\": connection.Name(),\n\t\t\t\"type\": connection.Type(),\n\t\t}\n\t}\n\n\twriteJSON(res, map[string]interface{}{\n\t\t\"success\":     true,\n\t\t\"connections\": connectionsJSON,\n\t})\n}", "CodeBleu_score": 47.27927439065345}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\n\trobot, err := a.master.Robot(robotName)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusNotFound, jsonError{\n\t\t\tStatus:  http.StatusNotFound,\n\t\t\tMessage: \"no robot with name \" + robotName,\n\t\t})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\tconnectionsJSON := make([]jsonConnection, len(connections))\n\tfor i, connection := range connections {\n\t\tconnectionsJSON[i] = jsonConnection{\n\t\t\tName: connection.Name(),\n\t\t\tType: connection.Type(),\n\t\t}\n\t}\n\n\ta.writeJSON(res, http.StatusOK, connectionsJSON)\n}\n", "CodeBleu_score": 46.29647871880688}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || user != username || pass != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}", "CodeBleu_score": 51.61453134186381}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\tif len(pair) != 2 || !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 48.65467755537707}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, _ := base64.StdEncoding.DecodeString(auth[1])\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\n\t\tif len(pair) != 2 || !secureCompare(pair[0], username) || !secureCompare(pair[1], password) {\n\t\t\thttp.Error(w, \"authorization failed\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 49.7736751735011}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := float64(toMax-toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tscaled := int(slope*input + intercept)\n\t\tif scaled < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif scaled > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn scaled\n\t}\n}\n", "CodeBleu_score": 69.70665504989182}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 51.69589435049284}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tslope := toRange / fromRange\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}\n", "CodeBleu_score": 50.21342343512043}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogModeSupported() {\n\t\treturn 0, 0.0, errors.New(\"analog reading not supported by this connection\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastValue = float64(raw)\n\n\treturn raw, a.lastValue, nil\n}\n", "CodeBleu_score": 45.20045659893797}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tval, err := a.connection.AnalogRead(a.Pin())\n\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\ta.lastRaw = val\n\ta.lastValue = float64(val)\n\n\treturn val, a.lastValue, nil\n}\n", "CodeBleu_score": 37.20211360188811}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.AnalogModeSupported() {\n\t\treturn 0, 0, fmt.Errorf(\"analog reading not supported by connection\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastValue = a.scaleToValue(float64(raw))\n\n\treturn raw, a.lastValue, nil\n}\n", "CodeBleu_score": 53.62055347819445}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 50.2302590210742}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m * float64(fromMin)\n\n\treturn func(input int) float64 {\n\t\toutput := m * float64(input) + n\n\t\tif output > toMax {\n\t\t\treturn toMax\n\t\t} else if output < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\treturn output\n\t}\n}", "CodeBleu_score": 71.75119957462283}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}", "CodeBleu_score": 50.67270976800855}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\td := NewAnalogSensorDriver(a, pin, 1*time.Second, 10, grovePiezoVibrationSensorModel, opts...)\n\n\td.name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\td.AddEvent(Vibration)\n\n\td.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: d,\n\t}\n}", "CodeBleu_score": 72.68907288266287}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 10*time.Millisecond, 10, \"\"),\n\t}\n\td.SetName(GroveName)\n\td.AddEvent(Vibration)\n\n\tgobot.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\td.Publish(d.Event(Vibration), data)\n\t\t}\n\t})\n\n\treturn d\n}", "CodeBleu_score": 46.59578804101855}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, 1*time.Second, 10, \"GrovePiezoVibrationSensor\"),\n\t\tEventer:           gobot.NewEventer(),\n\t}\n\n\td.AddEvent(Vibration)\n\n\tgobot.On(d.Event(Data), func(data interface{}) {\n\t\tif data.(int) > 1000 {\n\t\t\tgobot.Publish(d.Event(Vibration), nil)\n\t\t}\n\t})\n\n\tif err := d.SetName(gobot.DefaultName(\"GrovePiezoVibrationSensor\")); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}\n", "CodeBleu_score": 56.4679193157456}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif d.pin == \"\" {\n\t\treturn errors.New(\"No pin attached to buzzer driver\")\n\t}\n\n\td.Stop()\n\n\tperiod := 1000000 / hz\n\ttempo := 60 / d.bpm\n\n\tsteps := int(duration/(tempo*1000)) + 1\n\n\tgo func() {\n\t\tfor i := 0; i < steps; i++ {\n\t\t\td.Toggle()\n\t\t\ttime.Sleep(time.Duration(period/2) * time.Microsecond)\n\t\t\td.Toggle()\n\t\t\ttime.Sleep(time.Duration(period/2) * time.Microsecond)\n\t\t}\n\t}()\n\n\treturn nil\n}\n", "CodeBleu_score": 39.22429701413969}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\td.tone(hz, duration)\n\treturn nil\n}\n", "CodeBleu_score": 7.403127893250828}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tperiod := uint64(1000000 / hz)\n\ttempo := uint64(60 / d.bpm * 1000)\n\n\tlog.Println(\"hz\", hz, \"period\", period, \"tempo\", tempo)\n\n\tonTime := uint64(float64(tempo) * d.toneMultiplier)\n\toffTime := tempo - onTime\n\n\tlog.Println(\"onTime\", onTime, \"offTime\", offTime)\n\n\ttotalCycles := float64(duration) / (float64(onTime)+float64(offTime)) * 1000\n\tlog.Println(\"total cycles\", totalCycles)\n\n\tnumberOfCycles := int(totalCycles)\n\tlog.Println(\"numberOfCycles\", numberOfCycles)\n\n\tfor i := 0; i < numberOfCycles; i++ {\n\t\tlog.Println(\"i\", i)\n\t\tif err := d.pin.High(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(onTime) * time.Microsecond)\n\n\t\tif err := d.pin.Low(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(offTime) * time.Microsecond)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.38670410837068}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.stop()\n\n\td.sleepPin.Low()\n\n\td.sleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 30.022590799456545}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin is not set\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 29.566609093602874}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 30.022590799456545}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins map not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpin, err := a.translateAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 48.66076227608929}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpath := a.translate(id)\n\tfi, err := os.Open(path + \"/value\")\n\tdefer fi.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = NewAnalogPin(fi)\n\treturn a.pins[id], nil\n}\n", "CodeBleu_score": 48.647710510531326}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Must initialize analog pins before use\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpin, err := sysfs.NewAnalogPin(a.pinMap()[id])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 47.74984632188152}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.digitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}\n", "CodeBleu_score": 74.96791848684103}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}\n", "CodeBleu_score": 73.41065212010278}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(int(val))\n}\n", "CodeBleu_score": 73.41065212010278}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"No pins available\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := parseID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = NewDigitalPin(chip, line, a.conn)\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, option := range opts {\n\t\toption(pin)\n\t}\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 44.23810410112365}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif len(a.pins) == 0 {\n\t\treturn nil, fmt.Errorf(\"no pins available\")\n\t}\n\n\tpin := a.pins[id]\n\tif pin == nil {\n\t\tchip, line, err := a.translateID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = NewDigitalPin(chip, line, a.connector())\n\t}\n\n\tfor _, option := range opts {\n\t\toption(pin)\n\t}\n\n\tif pin.Err() != nil {\n\t\treturn nil, pin.Err()\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 52.723678700131636}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"no pins defined\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tpinInfo, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = a.connector.DigitalPin(pinInfo.Chip, pinInfo.Line, pinInfo.Direction, opts...)\n\t\tif pin == nil {\n\t\t\treturn nil, errors.New(\"could not create digital pin\")\n\t\t}\n\n\t\ta.pins[id] = pin\n\t}\n\n\tfor _, option := range opts {\n\t\toption(pin)\n\t}\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 53.012302527118024}]}
