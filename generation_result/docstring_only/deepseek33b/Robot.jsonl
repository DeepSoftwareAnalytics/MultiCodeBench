{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> requiredFiles;\n\n    // Get the list of files in the folder\n    std::vector<std::string> files = GetFilesInFolder(folder);\n\n    // Iterate over the files\n    for (const std::string &file : files) {\n        // Check if the file is required\n        if (IsFileRequired(file)) {\n            // If the download flag is set, check if the file exists locally\n            if (download) {\n                // If the file does not exist, request it and log the download action\n                if (!FileExists(file)) {\n                    RequestFile(file);\n                    Logger::Log(Logger::LogLevel::INFO, \"Downloaded file: \" + file);\n                }\n                // If the file exists, log that it is found in the cache\n                else {\n                    Logger::Log(Logger::LogLevel::INFO, \"Found file in cache: \" + file);\n                }\n            }\n            // Add the file to the list of required files\n            requiredFiles.push_back(file);\n        }\n    }\n\n    return requiredFiles;\n}\n", "CodeBleu_score": 48.16239110839289}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> requiredFiles;\n    std::string folderPath = folder + \"/required_files.txt\";\n    std::ifstream file(folderPath);\n    if (file.is_open()) {\n        std::string line;\n        while (std::getline(file, line)) {\n            if (line.empty()) {\n                continue;\n            }\n            if (download) {\n                std::string filePath = folder + \"/\" + line;\n                if (!std::filesystem::exists(filePath)) {\n                    RequestFile(line);\n                    LogAction(\"Downloaded file: \" + line);\n                } else {\n                    LogAction(\"File found in cache: \" + line);\n                }\n            }\n            requiredFiles.push_back(line);\n        }\n        file.close();\n    } else {\n        LogAction(\"Unable to open file: \" + folderPath);\n    }\n    return requiredFiles;\n}\n", "CodeBleu_score": 43.68942232334949}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> requiredFiles;\n\n    for (const auto &entry : std::filesystem::directory_iterator(folder)) {\n        if (entry.is_regular_file()) {\n            const std::string fileName = entry.path().filename().string();\n            requiredFiles.push_back(fileName);\n\n            if (download) {\n                if (std::find(this->cachedFiles.begin(), this->cachedFiles.end(), fileName) == this->cachedFiles.end()) {\n                    // File not found in cache, request file\n                    std::cout << \"Requesting file: \" << fileName << std::endl;\n                    this->RequestFile(fileName);\n                } else {\n                    // File found in cache\n                    std::cout << \"File found in cache: \" << fileName << std::endl;\n                }\n            }\n        }\n    }\n\n    return requiredFiles;\n}\n", "CodeBleu_score": 48.43887554132091}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the transformation is ill-formed\n    if (transform.location.x == 0.0 && transform.location.y == 0.0 && transform.rotation.yaw == 0.0 && transform.rotation.pitch == 0.0 && transform.rotation.roll == 0.0) {\n      // Issue a warning if the transformation is ill-formed\n      std::cout << \"Warning: Ill-formed transformation for SpringArm or SpringArmGhost attachment type.\" << std::endl;\n    }\n  }\n\n  // Call an internal function to complete the actor spawning process\n  return _SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n}\n", "CodeBleu_score": 44.61001263475867}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  rpc::Actor actor;\n\n  // Check if the attachment type is SpringArm or SpringArmGhost\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f) {\n      // Issue a warning if the translation is only in the 'z' axis\n      std::cout << \"WARNING: Translation is only in the 'z' axis, which may lead to ill-formed transformations.\" << std::endl;\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process\n  actor = _SpawnActorWithParent(\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n\n  return actor;\n}\n", "CodeBleu_score": 47.48259183486505}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the transform is ill-formed.\n    if (transform.location.x == 0.0f &&\n        transform.location.y == 0.0f &&\n        transform.location.z != 0.0f &&\n        transform.rotation.pitch == 0.0f &&\n        transform.rotation.yaw == 0.0f &&\n        transform.rotation.roll == 0.0f) {\n      std::stringstream ss;\n      ss << \"Ill-formed transform: \" << transform;\n      utils::log_warning(ss.str());\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process.\n  return _spawn_actor_with_parent(\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}\n", "CodeBleu_score": 46.847212662676526}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\n   // Retrieve the token for the G-buffer\n   rpc::Token Token = m_StreamingClient.GetToken(ActorId, GBufferId);\n\n   // Copy the token data\n   std::vector<char> TokenData(Token.data(), Token.data() + Token.size());\n\n   // Subscribe to the streaming client using the provided callback function\n   m_StreamingClient.Subscribe(TokenData, [callback](Buffer Buffer) {\n      callback(Buffer);\n   });\n}\n", "CodeBleu_score": 46.15931105435383}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)   // Retrieve the G-buffer token\n   rpc::Token token = client.GetGBuffer(ActorId, GBufferId);\n\n   // Copy the token data\n   std::vector<uint8_t> token_data(token.size());\n   memcpy(token_data.data(), token.data(), token.size());\n\n   // Subscribe to the streaming client using the token data and callback function\n   streaming_client.Subscribe(token_data, callback);\n}\n", "CodeBleu_score": 45.024065981164085}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\n   // Retrieve the token for the G-buffer\n   auto token = GetGBufferToken(ActorId, GBufferId);\n\n   // Copy the token data\n   auto tokenData = token.GetData();\n\n   // Subscribe to the streaming client using the provided callback function\n   streamingClient.Subscribe(tokenData, [callback](Buffer buffer) {\n      callback(buffer);\n   });\n}\n", "CodeBleu_score": 40.85343599325692}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()    if (navigation_ == nullptr) {\n        navigation_ = std::make_shared<WalkerNavigation>();\n        navigation_->SetEpisode(this);\n    }\n    return navigation_;\n}\n", "CodeBleu_score": 32.5874538518217}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()    if (m_navigation == nullptr) {\n        m_navigation = std::make_shared<WalkerNavigation>();\n        if (!SetNavigation(m_navigation)) {\n            m_navigation = nullptr;\n        }\n    }\n    return m_navigation;\n}\n", "CodeBleu_score": 37.45556824495437}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()  if (!navigation_) {\n    navigation_ = std::make_shared<WalkerNavigation>(this);\n    if (!navigation_->SetWalker(walker_)) {\n      navigation_ = nullptr;\n    }\n  }\n  return navigation_;\n}\n", "CodeBleu_score": 34.71556069742389}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  const uint64_t timeout_time = std::chrono::duration_cast<std::chrono::milliseconds>(timeout).count();\n\n  while (episode.GetFrame() < frame) {\n    if (timeout_time > 0) {\n      const auto start_time = std::chrono::system_clock::now();\n      if (!episode.GetReplayer()->Tick(timeout_time)) {\n        return false;\n      }\n      const auto end_time = std::chrono::system_clock::now();\n      const auto elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();\n      timeout_time -= elapsed_time;\n    } else {\n      if (!episode.GetReplayer()->Tick(1000)) {\n        return false;\n      }\n    }\n  }\n\n  episode.GetReplayer()->Tick(0);\n\n  return true;\n}\n", "CodeBleu_score": 52.540400438671156}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  const uint64_t timeout_ticks = timeout.total_milliseconds() / 1000;\n  const uint64_t start_frame = episode.GetFrame();\n  const uint64_t end_frame = start_frame + timeout_ticks;\n\n  while (episode.GetFrame() < frame && episode.GetFrame() < end_frame) {\n    std::this_thread::yield();\n  }\n\n  if (episode.GetFrame() < frame) {\n    return false;\n  }\n\n  episode.TriggerTick();\n\n  return true;\n}\n", "CodeBleu_score": 37.7112202579364}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  // Get the current frame of the episode state.\n  const uint64_t current_frame = episode.GetCurrentFrame();\n\n  // Check if the current frame is less than the given frame.\n  if (current_frame < frame) {\n    // Calculate the time difference between the current frame and the given frame.\n    const time_duration time_diff = episode.GetTimestamp() - episode.GetCurrentTimestamp();\n    const time_duration frame_diff = std::chrono::duration_cast<time_duration>(frame - current_frame) * time_diff;\n\n    // Set the timeout duration for the synchronization.\n    const time_duration sync_timeout = std::min(frame_diff, timeout);\n\n    // Wait for the synchronization to complete.\n    if (!episode.WaitForTick(sync_timeout)) {\n      return false;\n    }\n  }\n\n  // Trigger a tick in the TrafficManager.\n  episode.TriggerTick();\n\n  return true;\n}\n", "CodeBleu_score": 39.4900012086147}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  // Get the current episode ID\n  uint64_t current_episode_id = GetCurrentEpisodeId();\n\n  // Load the new episode\n  LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the new episode to load\n  uint64_t new_episode_id = WaitForEpisodeChange(current_episode_id);\n\n  // Get the new episode object\n  EpisodeProxy episode = GetEpisode(new_episode_id);\n\n  return episode;\n}\n", "CodeBleu_score": 28.26070594086142}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)    // Set the map name and reset settings\n    rpc::EpisodeSettings settings;\n    settings.set_map_name(map_name);\n    settings.set_reset_settings(reset_settings);\n    settings.set_map_layers(map_layers);\n\n    // Load the episode with the specified settings\n    rpc::EpisodeInfo episode_info = client.LoadEpisode(settings);\n\n    // Check if the episode ID has changed\n    while (episode_info.episode_id() == -1) {\n        episode_info = client.LoadEpisode(settings);\n    }\n\n    // Return the episode object\n    return EpisodeProxy(client, episode_info);\n}\n", "CodeBleu_score": 33.74483674465625}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)    std::string episode_id = this->GetCurrentEpisodeID();\n    std::string new_episode_id = \"\";\n    uint32_t attempts = 0;\n    uint32_t max_attempts = 10;\n    uint32_t sleep_time = 100;\n    while (new_episode_id == \"\" && attempts < max_attempts) {\n        this->LoadEpisode(map_name, reset_settings, map_layers);\n        new_episode_id = this->GetCurrentEpisodeID();\n        if (new_episode_id != episode_id) {\n            break;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(sleep_time));\n        attempts++;\n    }\n    if (new_episode_id == \"\") {\n        throw std::runtime_error(\"Failed to load new episode within \" + std::to_string(max_attempts) + \" attempts.\");\n    }\n    return this->GetEpisode(new_episode_id);\n}\n", "CodeBleu_score": 39.73245196434155}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  auto walker = GetWalkerByID(controller.GetID());\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Walker with ID \" + std::to_string(controller.GetID()) + \" not found\");\n  }\n  assert(episode != nullptr);\n  if (!walker->HasNavigation()) {\n    walker->CreateNavigation();\n  }\n  walker->RegisterController(controller.GetID());\n}\n", "CodeBleu_score": 53.99944327852755}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  auto walker = GetWalkerByID(controller.GetID());\n  if (!walker) {\n    throw std::runtime_error(\"Walker with ID \" + std::to_string(controller.GetID()) + \" not found.\");\n  }\n  assert(episode);\n  if (!walker->navigation) {\n    walker->navigation = std::make_unique<Navigation>(walker->GetID());\n  }\n  walker->navigation->Register(controller.GetID());\n}\n", "CodeBleu_score": 43.69631254020585}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  auto walker = walker_map_.find(controller.GetWalkerId());\n  if (walker == walker_map_.end()) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n  assert(episode_ != nullptr);\n  if (walker->second.navigation_ == nullptr) {\n    walker->second.navigation_ = std::make_unique<Navigation>(\n        walker->second.position_, walker->second.rotation_,\n        walker->second.GetWalkerType(), episode_->GetNavigationMesh());\n  }\n  controller_map_.insert({controller.GetControllerId(), &controller});\n}\n", "CodeBleu_score": 53.82737240007969}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  auto new_actor = std::make_shared<Actor>(\n      blueprint,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n\n  RegisterActor(new_actor);\n\n  new_actor->SetGarbageCollectionPolicy(gc);\n\n  _spawned_actors.insert(new_actor);\n\n  LogSpawnActor(*new_actor);\n\n  return new_actor;\n}\n", "CodeBleu_score": 26.84586625368823}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  auto actor = std::make_shared<Actor>(\n      blueprint,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n\n  RegisterActor(actor);\n\n  actor->SetGarbageCollectionPolicy(gc);\n\n  actor->GetActorBlueprint().SetRecommendedPrimitives(actor);\n\n  actor->SetEpisode(*_Episode);\n\n  if (parent != nullptr) {\n    actor->AttachTo(*parent);\n  }\n\n  _LoggingInstance->RecordSpawnedActor(*actor);\n\n  return actor;\n}\n", "CodeBleu_score": 37.08792200299544}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  auto actor = std::make_shared<Actor>(\n      blueprint,\n      transform,\n      parent,\n      attachment_type,\n      socket_name,\n      _current_episode,\n      gc,\n      _map,\n      _random_device,\n      _traffic_manager,\n      _data_replayer,\n      _recorder);\n\n  _current_episode->RegisterActor(actor);\n\n  if (gc == GarbageCollectionPolicy::EXTERNAL) {\n    actor->SetGarbageCollectionPolicy(GarbageCollectionPolicy::EXTERNAL);\n    _garbage_collection_policy_external_actors.insert(actor->GetId());\n  }\n\n  if (parent != nullptr) {\n    debug_helper::DrawPoint(\n        transform.location,\n        0.1f,\n        cc::DebugHelper::Color::Cyan,\n        0.0f,\n        true);\n  }\n\n  _logger->LogSpawnActor(actor);\n\n  return actor;\n}\n", "CodeBleu_score": 45.778824501108396}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (episode == nullptr) {\n    throw std::runtime_error(\"The episode is not initialized, can not subscribe to sensor.\");\n  }\n\n  // Subscribe to the sensor's data stream.\n  client->SubscribeToStream(\n      sensor.GetStreamName(),\n      [callback, episode = episode](Buffer buffer) {\n        // Deserialize the data received from the sensor.\n        auto sensor_data = buffer.Deserialize<sensor::SensorData>();\n\n        // Associate the data with the current episode.\n        sensor_data->SetEpisode(episode);\n\n        // Invoke the callback with the sensor data.\n        callback(sensor_data);\n      });\n}\n", "CodeBleu_score": 45.31871256836615}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (!episode.IsValid()) {\n    throw std::runtime_error(\"No episode running\");\n  }\n\n  client->SubscribeToStream(\n      sensor.GetToken(),\n      [this, callback](Buffer data) {\n        auto sensor_data =\n            BufferToSensorData(data, episode->GetCurrentTimeStamp());\n        sensor_data->SetEpisode(episode);\n        callback(sensor_data);\n      });\n}\n", "CodeBleu_score": 41.72311003471519}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (episode == nullptr) {\n    throw std::runtime_error(\"Simulator::SubscribeToSensor: episode is not set\");\n  }\n\n  client->SubscribeToStream(\n      sensor.GetToken(),\n      [this, sensor, callback](Buffer data) {\n        SharedPtr<sensor::SensorData> sensor_data = sensor.Deserialize(data);\n        sensor_data->SetEpisodeId(episode->GetId());\n        callback(sensor_data);\n      });\n}\n", "CodeBleu_score": 42.87055664554333}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)  // Load the current walkers\n  const auto &walkers = episode->GetState()->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  // Get the current episode state\n  const auto episode_state = episode->GetState();\n\n  // Remove walkers that are no longer in the episode\n  for (auto it = _walkers.begin(); it != _walkers.end();) {\n    const auto &walker = *it;\n    if (walkers.find(walker->GetId()) == walkers.end()) {\n      RemoveWalker(walker);\n      it = _walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update the vehicles in the crowd and the crowd itself\n  UpdateVehiclesInCrowd(episode_state);\n  UpdateCrowd(episode_state);\n\n  // Apply the states of the walkers in a batch to the simulator\n  std::vector<carla::rpc::ActorState> walker_states;\n  for (const auto &walker : _walkers) {\n    const auto walker_state = episode_state->GetWalker(walker->GetId());\n    const auto transform = walker_state->GetTransform();\n    const auto velocity = walker_state->GetVelocity();\n    walker_states.emplace_back(\n        carla::geom::Transform{\n          carla::geom::Location{transform.location.x, transform.location.y, transform.location.z},\n          carla::geom::Rotation{transform.rotation.pitch, transform.rotation.yaw, transform.rotation.roll}},\n        carla::geom::Vector3D{velocity.x, velocity.y, velocity.z},\n        carla::geom::Vector3D{},\n        carla::geom::Vector3D{});\n  }\n  _simulator->ApplyBatchStateToWalkers(walker_states);\n\n  // Check if any walker has been killed\n  for (const auto &walker : _walkers) {\n    const auto walk", "CodeBleu_score": 45.5099043589367}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)  // Load current walkers\n  const auto walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  // Get current episode state\n  const auto current_state = episode->GetState();\n\n  // Remove walkers that no longer exist\n  for (auto it = _walkers.begin(); it != _walkers.end();) {\n    if (walkers.find(it->first) == walkers.end()) {\n      _vehicles.erase(it->first);\n      it = _walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update vehicles in the crowd\n  for (auto &[id, walker] : _walkers) {\n    const auto &[transform, speed] = walkers.at(id);\n    walker->UpdateVehicle(transform, speed);\n  }\n\n  // Update crowd in the navigation module\n  _navigation->UpdateCrowd(current_state);\n\n  // Get the transform and speed of each walker\n  std::vector<Transform> walker_transforms;\n  std::vector<float> walker_speeds;\n  for (auto &[id, walker] : _walkers) {\n    const auto &[transform, speed] = walkers.at(id);\n    walker_transforms.push_back(transform);\n    walker_speeds.push_back(speed);\n  }\n\n  // Apply the states in a batch to the simulator\n  _simulator->ApplyBatch([&](auto &simulator) {\n    simulator.SetTransforms(walker_transforms);\n    simulator.SetSpeeds(walker_speeds);\n  });\n\n  // Check if any walker has been killed\n  for (auto it = _walkers.begin(); it != _walkers.end();) {\n    const auto id = it->first;\n    const auto &walker = it->second;\n    if (walker->IsAlive()) {\n      ++it;\n    } else {\n      _vehicles.erase", "CodeBleu_score": 46.130222288523534}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)  const auto &walkers = episode->GetWalkers();\n  if (walkers.empty()) {\n    return;\n  }\n\n  const auto current_state = episode->GetState();\n  const auto &actors = episode->GetActors();\n\n  // Remove walkers that are no longer alive.\n  for (auto &&walker : walkers) {\n    if (actors.find(walker.first) == actors.end()) {\n      RemoveWalker(walker.first);\n    }\n  }\n\n  // Update vehicles in the crowd and the crowd itself.\n  UpdateVehiclesInCrowd(episode);\n  UpdateCrowd(episode);\n\n  // For each walker, get their transform and speed, and apply these states in a batch to the simulator.\n  std::vector<ActorState> walker_states;\n  for (auto &&walker : walkers) {\n    const auto &vehicle = walker.second;\n    const auto &vehicle_transform = vehicle->GetTransform();\n    const auto vehicle_velocity = vehicle->GetVelocity();\n    const auto vehicle_angular_velocity = vehicle->GetAngularVelocity();\n    const auto vehicle_acceleration = vehicle->GetAcceleration();\n    const auto vehicle_angular_acceleration = vehicle->GetAngularAcceleration();\n    const auto vehicle_bounding_box = vehicle->GetBoundingBox();\n    const auto vehicle_transform_matrix = vehicle_transform.GetMatrix();\n    const auto vehicle_forward_vector = vehicle_transform.GetForwardVector();\n    const auto vehicle_rotation = vehicle_transform.rotation;\n\n    ActorState walker_state = {\n      walker.first,\n      vehicle_transform_matrix,\n      vehicle_velocity,\n      vehicle_angular_velocity,\n      vehicle_acceleration,\n      vehicle_angular_acceleration,\n      vehicle_bounding_box,\n      vehicle_forward_vector,\n      vehicle_rotation\n    };\n\n    walker_states.push_back(std::move(walker_state));\n  }", "CodeBleu_score": 40.16777138800549}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const    rpc::ActorDescription desc;\n    desc.uid = uid;\n    desc.id = id;\n    desc.attributes.reserve(attributes.size());\n    for (const auto& [key, value] : attributes) {\n        desc.attributes.emplace_back(key, value);\n    }\n    return desc;\n}\n", "CodeBleu_score": 60.42767305209231}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.set_uid(m_uid);\n  description.set_id(m_id);\n  description.mutable_attributes()->Reserve(m_attributes.size());\n  for (const auto& attribute : m_attributes) {\n    description.add_attributes()->CopyFrom(attribute);\n  }\n  return description;\n}\n", "CodeBleu_score": 61.526583397691795}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const    rpc::ActorDescription description;\n    description.uid = uid;\n    description.id = id;\n    description.attributes.reserve(attributes.size());\n    for (const auto& attribute : attributes) {\n        description.attributes.emplace_back(attribute.second);\n    }\n    return description;\n}\n", "CodeBleu_score": 70.78365237325173}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  std::vector<Blueprint> result;\n  for (const auto &blueprint : blueprints_) {\n    if (blueprint.HasAttribute(name)) {\n      if (blueprint.GetAttribute(name).GetRecommendedValues().size() == 1) {\n        if (value == blueprint.GetAttribute(name).GetRecommendedValues()[0]) {\n          result.push_back(blueprint);\n        }\n      } else {\n        if (value == blueprint.GetAttribute(name).GetValue()) {\n          result.push_back(blueprint);\n        }\n      }\n    }\n  }\n  return std::make_shared<BlueprintLibrary>(result);\n}\n", "CodeBleu_score": 44.419989992616536}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  auto result = std::make_shared<BlueprintLibrary>();\n  for (auto &bp : blueprints_) {\n    if (bp->HasAttribute(name)) {\n      if (bp->GetRecommendedValues().count(name) > 0) {\n        if (bp->GetRecommendedValues().at(name) == value) {\n          result->AddBlueprint(bp);\n        }\n      } else {\n        if (bp->GetAttributes().at(name) == value) {\n          result->AddBlueprint(bp);\n        }\n      }\n    }\n  }\n  return result;\n}\n", "CodeBleu_score": 42.063274198032566}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  auto result = std::make_shared<BlueprintLibrary>();\n\n  for (auto &blueprint : *this) {\n    if (blueprint.second.GetAttributes().count(name) == 0) {\n      continue;\n    }\n\n    const auto &attribute = blueprint.second.GetAttributes().at(name);\n    if (attribute.GetRecommendedValues().count(value) > 0) {\n      result->AddBlueprint(blueprint.second);\n    }\n  }\n\n  return result;\n}\n", "CodeBleu_score": 36.4703306252735}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string full_path = base_folder + path + \"_\" + version;\n\tif (!ValidatePath(full_path)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 43.64373574567859}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string full_path = base_folder + path;\n    if (!ValidateFilePath(full_path)) {\n        return false;\n    }\n\n    std::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    file.write(reinterpret_cast<char*>(content.data()), content.size());\n    file.close();\n    return true;\n}\n", "CodeBleu_score": 46.11282620348949}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string full_path = this->base_folder + path;\n    if (!ValidateFilePath(full_path)) {\n        return false;\n    }\n    std::ofstream file(full_path, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n    file.write((char*)content.data(), content.size());\n    file.close();\n    return true;\n}\n", "CodeBleu_score": 45.508139179729945}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  const geom::BoundingBox parent_bounds = GetParent().GetBoundingBox();\n  const geom::Location parent_location = parent_bounds.location;\n  const geom::Location child_location = parent_location + transform.location;\n\n  const geom::Vector3D child_extent = parent_bounds.extent;\n  const geom::Vector3D child_extent_rotated = geom::Rotate(transform.rotation.yaw, child_extent);\n\n  const geom::Vector3D child_extent_rotated_half = child_extent_rotated * 0.5;\n  const geom::Location child_location_front_left = child_location + geom::Location(child_extent_rotated_half.x, child_extent_rotated_half.y, 0.0);\n  const geom::Location child_location_rear_left = child_location + geom::Location(child_extent_rotated_half.x, -child_extent_rotated_half.y, 0.0);\n  const geom::Location child_location_front_right = child_location + geom::Location(-child_extent_rotated_half.x, child_extent_rotated_half.y, 0.0);\n  const geom::Location child_location_rear_right = child_location + geom::Location(-child_extent_rotated_half.x, -child_extent_rotated_half.y, 0.0);\n\n  return std::make_shared<const Bounds>(\n      frame,\n      child_location_front_left,\n      child_location_rear_left,\n      child_location_front_right,\n      child_location_rear_right);\n}\n", "CodeBleu_score": 32.653484248104014}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  const auto &extents = parent_actor->GetBoundingBox().extent;\n  const auto &location = parent_actor->GetBoundingBox().location;\n  const auto &yaw = transform.rotation.yaw;\n  const auto &cos_yaw = std::cos(yaw);\n  const auto &sin_yaw = std::sin(yaw);\n  const auto &dx = extents.x * cos_yaw;\n  const auto &dy = extents.x * sin_yaw;\n  const auto &dz = extents.z * sin_yaw;\n  const auto &dy_plus_dz = dy + dz;\n  const auto &dy_minus_dz = dy - dz;\n  const auto &dx_minus_dy_minus_dz = dx - dy_minus_dz;\n  const auto &dx_minus_dy_plus_dz = dx - dy_plus_dz;\n  const auto &dx_plus_dy_minus_dz = dx + dy_minus_dz;\n  const auto &dx_plus_dy_plus_dz = dx + dy_plus_dz;\n  const auto &x = transform.location.x;\n  const auto &y = transform.location.y;\n  const auto &z = transform.location.z;\n  const auto &p0 = geom::Location(x + dx_minus_dy_minus_dz, y + dy_minus_dz, z - dz);\n  const auto &p1 = geom::Location(x + dx_minus_dy_plus_dz, y + dy_plus_dz, z + dz);\n  const auto &p2 = geom::Location(x + dx_plus_dy_minus_dz, y - dy_minus_dz, z - dz);\n  const auto &p3 = geom::Location(x + dx_plus_dy_plus_dz, y - dy_plus_dz, z + dz);\n  return std::make_shared<Bounds>(frame, p0, p1, p2, p3);\n}\n", "CodeBleu_score": 36.241366856315736}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  const auto &bb = parent_actor->GetBoundingBox();\n  const auto location = transform.location + bb.location;\n  const auto yaw = transform.rotation.yaw;\n\n  const auto extent_x = std::cos(yaw) * bb.extent.x;\n  const auto extent_y = std::sin(yaw) * bb.extent.x;\n  const auto extent_z = bb.extent.z;\n\n  const auto l_x = extent_x;\n  const auto l_y = extent_y;\n  const auto l_z = extent_z;\n  const auto r_x = -extent_x;\n  const auto r_y = -extent_y;\n  const auto r_z = extent_z;\n\n  const auto l_l_x = l_x;\n  const auto l_l_y = l_y;\n  const auto l_l_z = l_z;\n  const auto l_r_x = l_x;\n  const auto l_r_y = r_y;\n  const auto l_r_z = l_z;\n  const auto r_l_x = r_x;\n  const auto r_l_y = l_y;\n  const auto r_l_z = r_z;\n  const auto r_r_x = r_x;\n  const auto r_r_y = r_y;\n  const auto r_r_z = r_z;\n\n  const auto l_l_loc = location + geom::Location(l_l_x, l_l_y, l_l_z);\n  const auto l_r_loc = location + geom::Location(l_r_x, l_r_y, l_r_z);\n  const auto r_l_loc = location + geom::Location(r_l_x, r_l_y, r_l_z);\n  const auto r_r_loc = location + geom::Location(r_r_x, r_r_y, r_r_z);\n\n  return std::make_shared<Bounds>(frame", "CodeBleu_score": 48.00890633996017}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()    std::lock_guard<std::mutex> lock(_mutex);\n    std::vector<LightState> lightStates = _server->GetLightStates();\n\n    for (const auto& lightState : lightStates) {\n        auto it = _lights.find(lightState.GetId());\n        if (it != _lights.end()) {\n            it->second->SetState(lightState);\n        } else {\n            _lights[lightState.GetId()] = std::make_shared<Light>(lightState);\n        }\n    }\n}\n", "CodeBleu_score": 35.2417545741045}, {"code": "void LightManager::QueryLightsStateToServer()    std::lock_guard<std::mutex> lock(_mutex);\n    std::vector<std::string> light_ids;\n    std::vector<std::string> light_names;\n    std::vector<std::string> light_states;\n    std::vector<std::string> light_brightness;\n    std::vector<std::string> light_hue;\n    std::vector<std::string> light_saturation;\n    std::vector<std::string> light_color_temp;\n    std::vector<std::string> light_color_mode;\n\n    _server->QueryLightsState(light_ids, light_names, light_states, light_brightness, light_hue, light_saturation, light_color_temp, light_color_mode);\n\n    for (int i = 0; i < light_ids.size(); i++) {\n        std::string light_id = light_ids[i];\n        std::string light_name = light_names[i];\n        std::string light_state = light_states[i];\n        int brightness = std::stoi(light_brightness[i]);\n        int hue = std::stoi(light_hue[i]);\n        int saturation = std::stoi(light_saturation[i]);\n        int color_temp = std::stoi(light_color_temp[i]);\n        std::string color_mode = light_color_mode[i];\n\n        if (_lights.find(light_id) == _lights.end()) {\n            // Light does not exist in the map, create a new one\n            _lights[light_id] = std::make_shared<Light>(light_id, light_name, light_state, brightness, hue, saturation, color_temp, color_mode);\n        } else {\n            // Light already exists in the map, update its state\n            _lights[light_id]->SetState(light_state);\n            _lights[light_id]->SetBrightness(brightness);\n            _lights[light_id]->SetHue(hue);\n            _lights[light_id]->SetSaturation(", "CodeBleu_score": 35.0568868018461}, {"code": "void LightManager::QueryLightsStateToServer()    std::lock_guard<std::mutex> lock(_mutex);\n    std::vector<LightState> lightStates = _server->GetLightStates();\n    for (const auto& lightState : lightStates) {\n        if (_lights.find(lightState.id) == _lights.end()) {\n            _lights[lightState.id] = std::make_shared<Light>(lightState.id, lightState.name, lightState.state);\n        } else {\n            _lights[lightState.id]->SetState(lightState.state);\n        }\n    }\n}\n", "CodeBleu_score": 35.73354461030674}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)  std::lock_guard<std::mutex> lock(lights_mutex_);\n  if (dirty_) {\n    auto msg = std::make_shared<Message>(MessageType::kLightState);\n    for (const auto& light : lights_) {\n      if (light.second.IsDirty()) {\n        msg->AddLightState(light.second);\n      }\n    }\n    if (msg->GetLightStates().size() > 0) {\n      if (discard_client) {\n        msg->SetDiscardClient(true);\n      }\n      server_->Send(msg);\n    }\n    for (auto& light : lights_) {\n      light.second.ClearDirty();\n    }\n    dirty_ = false;\n  }\n}\n", "CodeBleu_score": 40.670327160891}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)  std::lock_guard<std::mutex> lock(light_mutex_);\n\n  if (dirty_ || discard_client) {\n    // create a message with the updated light states\n    std::string message = \"LIGHT_STATES\";\n    for (const auto& light : lights_) {\n      message += \" \" + light.first + \":\" + std::to_string(light.second.state);\n    }\n    // send the message to the server\n    server_->SendMessage(message);\n    // clear the changes and reset the dirty flag\n    changes_.clear();\n    dirty_ = false;\n  }\n}\n", "CodeBleu_score": 31.643653299897966}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)    std::lock_guard<std::mutex> lock(m_mutex);\n\n    if (m_dirty) {\n        // Create a message containing the updated light states\n        std::string message = \"{\\\"lights\\\":[\";\n        for (int i = 0; i < m_lights.size(); i++) {\n            message += \"{\\\"id\\\":\" + std::to_string(m_lights[i].id) + \",\\\"state\\\":\" + (m_lights[i].state ? \"true\" : \"false\") + \"}\";\n            if (i < m_lights.size() - 1) {\n                message += \",\";\n            }\n        }\n        message += \"]}\";\n\n        // Send the message to the server\n        if (m_client != nullptr) {\n            m_client->Send(message);\n        }\n\n        // Clear the changes and reset the dirty flag\n        m_changes.clear();\n        m_dirty = false;\n    }\n}\n", "CodeBleu_score": 37.72532982641072}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)  if (GetId() != \"sensor.other.v2x_custom\") {\n    log_warning(\"ServerSideSensor::Send: Sensor ID is not sensor.other.v2x_custom\");\n    return;\n  }\n\n  auto context = GetContext();\n  auto episode = context->GetEpisode();\n  episode->Send(message);\n}\n", "CodeBleu_score": 53.547849188956995}, {"code": "void ServerSideSensor::Send(std::string message)  if (GetId() != \"sensor.other.v2x_custom\") {\n    // LOG(WARNING) << \"Sensor ID is not sensor.other.v2x_custom\";\n    return;\n  }\n  auto episode = GetEpisode();\n  if (!episode) {\n    // LOG(WARNING) << \"Episode is not set\";\n    return;\n  }\n  episode->Send(message, GetContext());\n}\n", "CodeBleu_score": 45.046625198465364}, {"code": "void ServerSideSensor::Send(std::string message)  if (GetId() != \"sensor.other.v2x_custom\") {\n    LOG(WARNING) << \"This sensor is not sending v2x_custom messages.\";\n    return;\n  }\n\n  GetEpisode().Lock()->Send(std::move(message));\n}\n", "CodeBleu_score": 49.7008620535764}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)  if (enabled) {\n    // Register the vehicle with the traffic manager\n    traffic_manager_->RegisterVehicle(this, tm_port);\n  } else {\n    // Unregister the vehicle from the traffic manager\n    traffic_manager_->UnregisterVehicle(this, tm_port);\n  }\n}\n", "CodeBleu_score": 48.79022790894185}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)    if (enabled) {\n        if (traffic_manager_ != nullptr) {\n            traffic_manager_->RegisterVehicle(this, tm_port);\n        } else {\n            std::cout << \"Traffic manager not initialized. Cannot register vehicle.\" << std::endl;\n        }\n    } else {\n        if (traffic_manager_ != nullptr) {\n            traffic_manager_->UnregisterVehicle(this);\n        } else {\n            std::cout << \"Traffic manager not initialized. Cannot unregister vehicle.\" << std::endl;\n        }\n    }\n}\n", "CodeBleu_score": 36.209062677504235}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)    if (enabled) {\n        std::cout << \"Autopilot enabled for vehicle \" << id_ << std::endl;\n        RegisterVehicle(tm_port);\n    } else {\n        std::cout << \"Autopilot disabled for vehicle \" << id_ << std::endl;\n        UnregisterVehicle(tm_port);\n    }\n}\n", "CodeBleu_score": 41.880754762715114}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()    Super::Start();\n    Walker = Cast<AWalker>(GetPawn());\n    NavSystem->AddWalker(Walker, Walker->GetNavAgentPropertiesRef());\n    Walker->GetRootComponent()->SetMobility(EComponentMobility::Movable);\n    Walker->GetRootComponent()->SetSimulatePhysics(false);\n    Walker->GetRootComponent()->SetCollisionProfileName(\"NoCollision\");\n}\n", "CodeBleu_score": 33.57741310792246}, {"code": "void WalkerAIController::Start()    Super::Start();\n\n    // Register the AI controller with the episode\n    UWorld* world = GetWorld();\n    if (world) {\n        AEpisode* episode = Cast<AEpisode>(world->GetAuthGameMode());\n        if (episode) {\n            episode->RegisterController(this);\n        }\n    }\n\n    // Get the walker actor and add it to the navigation system\n    AActor* walker = GetPawn();\n    if (walker) {\n        FVector location = walker->GetActorLocation();\n        UNavigationSystemV1* navSystem = UNavigationSystemV1::GetCurrent(world);\n        if (navSystem) {\n            navSystem->RegisterComponentWithNavigationSystem(walker->GetRootComponent());\n            navSystem->SimpleMoveToLocation(walker->GetController(), location);\n        }\n    }\n\n    // Disable physics simulation and collisions for the walker actor\n    walker->SetActorEnableCollision(false);\n    walker->GetRootComponent()->SetSimulatePhysics(false);\n}\n", "CodeBleu_score": 35.60657332460319}, {"code": "void WalkerAIController::Start()    Super::Start();\n\n    // Get the walker actor\n    AActor* walker = GetPawn();\n\n    // Register the walker actor with the episode\n    episode.RegisterAgent(walker);\n\n    // Add the walker actor to the navigation system with its current location\n    UNavigationSystemV1* navSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n    FNavAgentProperties navAgentProperties;\n    navAgentProperties.AgentRadius = 100.0f;\n    navAgentProperties.AgentHeight = 200.0f;\n    navAgentProperties.bCanCrouch = true;\n    navSystem->RegisterNavAgentWithNavigationSystem(*walker, navAgentProperties);\n\n    // Disable the physics simulation and collisions for the walker actor\n    walker->SetActorEnableCollision(false);\n    walker->SetActorTickEnabled(false);\n}\n", "CodeBleu_score": 35.00050014628866}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  auto navigation = GetEpisode().GetNavigationSystem();\n  if (navigation == nullptr) {\n    return;\n  }\n\n  auto parent_actor = GetParent();\n  if (parent_actor == nullptr) {\n    return;\n  }\n\n  auto parent_controller = boost::static_pointer_cast<cc::Walker>(parent_actor->GetAttribute(\"controller\"));\n  if (parent_controller == nullptr) {\n    return;\n  }\n\n  if (!navigation->SetMaxSpeed(parent_controller->GetId(), max_speed)) {\n    cg::Logger::GetInstance().LogWarning(\n      \"Failed to set max speed for walker controller '\" + GetId() + \"'!\");\n  }\n}\n", "CodeBleu_score": 53.210902165367294}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  if (auto const navigation = dynamic_cast<SimpleWaypointPtr>(GetEpisode().GetNavigationPtr())) {\n    if (auto const parent_walker = boost::static_pointer_cast<Walker>(GetParent())) {\n      if (!navigation->SetMaxSpeed(parent_walker, max_speed)) {\n        cg::Logger::GetInstance().LogWarning(GetTypeName() + \" (\" + GetLogId() + \")::SetMaxSpeed: failed to set maximum speed.\");\n      }\n    } else {\n      cg::Logger::GetInstance().LogWarning(GetTypeName() + \" (\" + GetLogId() + \")::SetMaxSpeed: parent walker not found.\");\n    }\n  } else {\n    cg::Logger::GetInstance().LogWarning(GetTypeName() + \" (\" + GetLogId() + \")::SetMaxSpeed: navigation not found.\");\n  }\n}\n", "CodeBleu_score": 41.75523542140478}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  auto *navigation = GetEpisode().GetNavigationSystem();\n  if (navigation == nullptr) {\n    return;\n  }\n\n  const auto *walker = navigation->GetWalker();\n  if (walker == nullptr) {\n    return;\n  }\n\n  if (!navigation->SetWalkerMaxSpeed(max_speed)) {\n    UE_LOG(\n        LogCarla,\n        Warning,\n        TEXT(\"Failed to set max speed %f for walker\"),\n        max_speed);\n  }\n}\n", "CodeBleu_score": 50.47885595619985}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const  std::vector<SharedPtr<Waypoint>> result;\n  for (auto waypoint : parent_map_->GetPrevious(distance, this)) {\n    SharedPtr<Waypoint> new_waypoint =\n        std::make_shared<Waypoint>(waypoint);\n    result.push_back(new_waypoint);\n  }\n  return result;\n}\n", "CodeBleu_score": 52.31656324258513}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<std::weak_ptr<Waypoint>> previous = parent_map->GetPrevious(this->GetId(), distance);\n    for (auto& wp : previous) {\n        if (auto sp = wp.lock()) {\n            result.push_back(std::make_shared<Waypoint>(sp));\n        }\n    }\n    return result;\n}\n", "CodeBleu_score": 55.98282062809423}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> previousWaypoints = parentMap->GetPrevious(shared_from_this(), distance);\n\n    for (const auto& waypoint : previousWaypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n    }\n\n    return result;\n}\n", "CodeBleu_score": 55.16015485193822}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> result;\n\n  std::vector<SharedPtr<Waypoint>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\n  for (auto &signal : signals) {\n    if (signal->GetType() == road::Lane::LaneType::LaneType::Driving) {\n      continue;\n    }\n\n    bool is_repeated = false;\n    for (auto &landmark : result) {\n      if (landmark->GetWaypoint()->GetId() == signal->GetId()) {\n        is_repeated = true;\n        break;\n      }\n    }\n\n    if (is_repeated) {\n      continue;\n    }\n\n    result.push_back(std::make_shared<Landmark>(signal));\n  }\n\n  return result;\n}\n", "CodeBleu_score": 47.99694884981174}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> result;\n\n  std::vector<SharedPtr<Waypoint>> signals = GetSignalsInDistance(\n      distance, stop_at_junction);\n\n  std::vector<SharedPtr<Waypoint>> repeated_signals;\n\n  for (auto signal : signals) {\n    if (std::find(repeated_signals.begin(), repeated_signals.end(), signal) !=\n        repeated_signals.end()) {\n      continue;\n    }\n    repeated_signals.push_back(signal);\n    SharedPtr<Landmark> landmark = std::make_shared<Landmark>(signal);\n    SharedPtr<Waypoint> waypoint = std::make_shared<Waypoint>(signal);\n    result.push_back(landmark);\n  }\n\n  return result;\n}\n", "CodeBleu_score": 51.305985439108746}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> result;\n\n  std::vector<SharedPtr<Signal>> signals =\n      GetSignalsInDistance(distance, stop_at_junction);\n\n  std::vector<SharedPtr<Signal>> unique_signals;\n  for (auto signal : signals) {\n    if (std::find(unique_signals.begin(), unique_signals.end(), signal) ==\n        unique_signals.end()) {\n      unique_signals.push_back(signal);\n    }\n  }\n\n  for (auto signal : unique_signals) {\n    auto landmark = std::make_shared<Landmark>(signal);\n    auto waypoint = std::make_shared<Waypoint>(signal);\n    landmark->SetWaypoint(waypoint);\n    result.push_back(landmark);\n  }\n\n  return result;\n}\n", "CodeBleu_score": 51.778382409997405}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  // Set a local timeout based on the provided timeout or the episode's networking timeout.\n  time_duration local_timeout = timeout > time_duration::zero() ? timeout : GetNetworkingTimeout();\n\n  // If the settings include a fixed delta time, attempt to verify the accuracy of this setting over a series of ticks.\n  if (settings.has_fixed_delta_seconds()) {\n    bool fixed_delta_time_correct = false;\n    uint32_t num_attempts = 0;\n    while (!fixed_delta_time_correct && num_attempts < 3) {\n      fixed_delta_time_correct = ApplyFixedDeltaTime(settings.fixed_delta_seconds(), local_timeout);\n      ++num_attempts;\n    }\n    if (!fixed_delta_time_correct) {\n      // If the setting is not correctly applied after a number of attempts, log a warning.\n      log_warning(\n        \"fixed delta time was not correctly applied after {} attempts\",\n        num_attempts\n      );\n    }\n  }\n\n  // Return the identifier of the applied settings.\n  return settings.identifier();\n}\n", "CodeBleu_score": 33.49457050718856}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  // Set a local timeout based on the provided timeout or the episode's networking timeout.\n  time_duration local_timeout = timeout > 0s ? timeout : _episode->GetNetworkingTimeout();\n\n  // Set the fixed delta time if provided.\n  if (settings.has_fixed_delta_seconds()) {\n    SetFixedDeltaSeconds(settings.fixed_delta_seconds());\n  }\n\n  // Attempt to verify the accuracy of the fixed delta time setting over a series of ticks.\n  if (settings.has_fixed_delta_seconds()) {\n    // Set the timeout for the tick verification.\n    SetTimeout(local_timeout);\n\n    // Verify the accuracy of the fixed delta time setting.\n    bool success = VerifyFixedDeltaTime(settings.fixed_delta_seconds());\n\n    // If the setting is not correctly applied after a number of attempts, log a warning.\n    if (!success) {\n      // Log a warning that the fixed delta time setting is not correctly applied.\n      _logger->warn(\"fixed delta time setting not correctly applied\");\n    }\n  }\n\n  // Return the identifier of the applied settings.\n  return _episode->GetSettings().GetHash();\n}\n", "CodeBleu_score": 30.78783555834465}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  // If the timeout is not specified, use the episode's networking timeout.\n  if (timeout == time_duration::zero()) {\n    timeout = _episode->GetNetworkingTimeout();\n  }\n\n  // Set a local timeout based on the provided timeout.\n  auto local_timeout = boost::posix_time::microseconds(timeout.total_microseconds());\n\n  // Apply the settings to the world.\n  _client->ApplyBatchSync(\n      [&settings, &local_timeout](carla::client::detail::EpisodeProxy &episode) {\n        episode.Lock()->SetFixedDeltaSeconds(settings.fixed_delta_seconds);\n        episode.Lock()->SetSynchronousMode(settings.synchronous_mode);\n        episode.Lock()->SetNoRenderingMode(settings.no_rendering_mode);\n        episode.Lock()->SetSubstepping(settings.substepping);\n        episode.Lock()->SetMaxSubstepDeltaTime(settings.max_substep_delta_time);\n        episode.Lock()->SetMaxSubsteps(settings.max_substeps);\n        episode.Lock()->SetReplayerTime(settings.replayer_time_factor);\n        episode.Lock()->SetReplayerDistance(settings.replayer_distance_to_ego);\n      },\n      local_timeout);\n\n  // If the settings include a fixed delta time, verify its accuracy.\n  if (settings.fixed_delta_seconds > 0.0f) {\n    VerifyFixedDeltaTime(settings.fixed_delta_seconds);\n  }\n\n  // Return the identifier of the applied settings.\n  return _episode->GetCurrentSettings().id;\n}\n", "CodeBleu_score": 33.213409641213254}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint    float squaredLength = Math::LengthSquared(segment);\n    float length = std::sqrt(squaredLength);\n\n    if (length == 0.0f) {\n        return std::make_pair(0.0f, Math::Length(point - segment.start));\n    }\n\n    float t = std::clamp(Math::Dot(point - segment.start, segment.end - segment.start) / squaredLength, 0.0f, 1.0f);\n    float distanceAlongSegment = t * length;\n    float distanceToPoint = Math::Length(point - (segment.start + t * (segment.end - segment.start)));\n\n    return std::make_pair(distanceAlongSegment, distanceToPoint);\n}\n", "CodeBleu_score": 40.88525707438759}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint    const float segmentLengthSq = Math::LengthSq(segment.end - segment.start);\n    const float segmentLength = std::sqrt(segmentLengthSq);\n    if (segmentLength == 0.0f) {\n        return { 0.0f, Math::Length(point - segment.start) };\n    }\n\n    const float projection = Math::Dot(point - segment.start, segment.end - segment.start) / segmentLengthSq;\n    const float clampedProjection = std::clamp(projection, 0.0f, 1.0f);\n    const float distanceAlongSegment = clampedProjection * segmentLength;\n    const float distanceToProjection = Math::Length(point - (segment.start + (segment.end - segment.start) * clampedProjection));\n    return { distanceAlongSegment, distanceToProjection };\n}\n", "CodeBleu_score": 40.501758308480554}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint    const Vector2f& point,\n    const Vector2f& segmentStart,\n    const Vector2f& segmentEnd\n} {\n    const Vector2f segment = segmentEnd - segmentStart;\n    const float segmentLengthSquared = segment.LengthSquared();\n    if (segmentLengthSquared == 0.0f) {\n        return {0.0f, (point - segmentStart).Length()};\n    }\n\n    const float projection = segment.Dot(point - segmentStart) / segmentLengthSquared;\n    const float clampedProjection = std::clamp(projection, 0.0f, 1.0f);\n    const float distanceAlongSegment = segmentLengthSquared * clampedProjection;\n    const float distanceToPoint = (point - (segmentStart + segment * clampedProjection)).Length();\n\n    return {distanceAlongSegment, distanceToPoint};\n}\n", "CodeBleu_score": 44.83171105760286}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n\n    auto first_index = vertices_.size();\n\n    // Add all vertices to the mesh\n    for (auto &vertex : vertices) {\n        vertices_.push_back(vertex);\n    }\n\n    // Add indices to form triangles\n    for (auto i = 1; i < vertices.size() - 1; ++i) {\n        indices_.push_back(first_index);\n        indices_.push_back(first_index + i);\n        indices_.push_back(first_index + i + 1);\n    }\n}\n", "CodeBleu_score": 41.827300086781264}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n    size_t initial_index = vertices_.size();\n    vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n    for (size_t i = 1; i < vertices.size() - 1; i++) {\n        indices_.push_back(initial_index);\n        indices_.push_back(initial_index + i);\n        indices_.push_back(initial_index + i + 1);\n    }\n}\n", "CodeBleu_score": 50.059513170852334}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)     assert(vertices.size() >= 3);\n     size_t initial_index = vertices_.size();\n     vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n     for (size_t i = 1; i < vertices.size() - 1; ++i) {\n         indices_.push_back(initial_index);\n         indices_.push_back(initial_index + i);\n         indices_.push_back(initial_index + i + 1);\n     }\n }\n", "CodeBleu_score": 49.82801236502118}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  // Ensure the message is valid.\n  DEBUG_ASSERT(message->size() <= std::numeric_limits<uint32_t>::max());\n\n  // Post a lambda to the strand for execution.\n  _strand.post([\n    weak = weak_from_this(),\n    message = std::move(message)\n  ] () mutable {\n    // Obtain a shared pointer to self.\n    auto self = weak.lock();\n    if (!self) {\n      return;\n    }\n\n    // Check if the socket is open.\n    if (!self->_socket.is_open()) {\n      return;\n    }\n\n    // Set a timeout.\n    self->_socket.expires_after(std::chrono::seconds(10));\n\n    // Initiate an asynchronous write.\n    boost::asio::async_write(\n        self->_socket,\n        boost::asio::buffer(message->data(), message->size()),\n        [\n          weak,\n          message = std::move(message)\n        ] (boost::system::error_code ec, std::size_t /*length*/) {\n          // Obtain a shared pointer to self.\n          auto self = weak.lock();\n          if (!self) {\n            return;\n          }\n\n          // Handle the result.\n          self->_handle_sent(ec, message);\n        });\n  });\n}\n", "CodeBleu_score": 47.70032433640391}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (!message->Validate()) {\n    log_error(\"sending invalid message\");\n    return;\n  }\n  _strand.post([this, message]() {\n    if (!_socket.is_open()) {\n      return;\n    }\n    _socket.expires_after(boost::asio::chrono::seconds(10));\n    _socket.async_write_some(\n        boost::asio::buffer(message->Serialize()),\n        boost::asio::bind_executor(\n            _strand,\n            [this, message](boost::system::error_code ec, std::size_t /*length*/) {\n              if (ec) {\n                log_error(\"error sending message:\", ec);\n                Close();\n              }\n            }));\n  });\n}\n", "CodeBleu_score": 35.83665765380414}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (message->empty()) {\n    return;\n  }\n  _strand.post([this, message] {\n    if (!_socket.is_open()) {\n      return;\n    }\n    _socket.expires_after(std::chrono::seconds(10));\n    _socket.async_write_some(\n        asio::buffer(*message),\n        [this, message](const asio::error_code &ec, size_t) {\n          if (ec) {\n            log_error(\"error sending message:\", ec.message());\n            Close();\n          } else {\n            log_debug(\"sent message:\", *message);\n          }\n        });\n  });\n}\n", "CodeBleu_score": 31.1716759168445}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)    if (!ec) {\n        socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        socket_.close();\n    }\n    on_closed(ec);\n    LOG(INFO) << \"Session closed\";\n}\n", "CodeBleu_score": 40.42032710087327}, {"code": "void Primary::CloseNow(boost::system::error_code ec)    if (!ec) {\n        boost::system::error_code ec;\n        socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        socket_.close(ec);\n    }\n    on_closed_();\n    LOG(INFO) << \"Session closed\";\n}\n", "CodeBleu_score": 42.367153134982814}, {"code": "void Primary::CloseNow(boost::system::error_code ec)  if (ec) {\n    LOG(ERROR) << \"Error in Primary::CloseNow: \" << ec.message();\n  }\n  // Cancel the timer to prevent firing after the socket is closed.\n  timer_.cancel();\n  if (!ec && socket_.is_open()) {\n    // Shut down the socket to close it gracefully.\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    if (ec) {\n      LOG(ERROR) << \"Error shutting down socket: \" << ec.message();\n    }\n    // Close the socket.\n    socket_.close(ec);\n    if (ec) {\n      LOG(ERROR) << \"Error closing socket: \" << ec.message();\n    }\n  }\n  // Trigger the on_closed callback.\n  on_closed_(shared_from_this());\n  // Log that the session has been closed.\n  LOG(INFO) << \"Session closed\";\n}\n", "CodeBleu_score": 53.1802517363606}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()\tchar buffer[100];\n\tsprintf(buffer, \"Are you alive?\");\n\tLog::Write(Log::INFO, \"Sending: %s\", buffer);\n\tRouter::Send(Router::YOU_ALIVE, buffer);\n\tLog::Write(Log::INFO, \"Received: %s\", Router::Receive());\n}\n", "CodeBleu_score": 26.3925926026998}, {"code": "void PrimaryCommands::SendIsAlive()    const char* message = \"Are you alive?\";\n    char buffer[BUFFER_SIZE];\n    strcpy(buffer, message);\n    Logger::Log(Logger::INFO, \"Sending: \", buffer);\n    this->router->Write(buffer, YOU_ALIVE);\n    this->router->Read(buffer);\n    Logger::Log(Logger::INFO, \"Received: \", buffer);\n}\n", "CodeBleu_score": 30.13722479621116}, {"code": "void PrimaryCommands::SendIsAlive()\tchar buffer[256];\n\tsprintf(buffer, \"Are you alive?\");\n\tLogging::Log(\"Sending: %s\", buffer);\n\tRouter::Write(buffer, YOU_ALIVE);\n\n\tRouter::Read(buffer);\n\tLogging::Log(\"Received: %s\", buffer);\n}\n", "CodeBleu_score": 22.226920133825466}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if the sensor is on any server\n    if (router.IsSensorOnAnyServer(sensor_id)) {\n        // Create a buffer with the sensor ID\n        uint8_t buffer[3];\n        buffer[0] = ENABLE_ROS;\n        buffer[1] = sensor_id >> 8;\n        buffer[2] = sensor_id & 0xFF;\n\n        // Send the ENABLE_ROS command to the server\n        router.SendCommand(buffer, 3);\n\n        // Wait for the server's response\n        uint8_t response[3];\n        router.WaitForResponse(response, 3);\n\n        // Process the server's response\n        if (response[0] == ERROR) {\n            // Log an error message\n            logger.LogError(\"Error enabling ROS for sensor \" + std::to_string(sensor_id));\n        }\n    } else {\n        // Log an error message\n        logger.LogError(\"Sensor \" + std::to_string(sensor_id) + \" not found on any server\");\n    }\n}\n", "CodeBleu_score": 47.08173057712526}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if sensor is on any server\n    bool found = false;\n    for (int i = 0; i < num_servers; i++) {\n        if (servers[i].GetSensor(sensor_id)) {\n            found = true;\n            break;\n        }\n    }\n\n    if (!found) {\n        logger.Error(\"Sensor not found on any server\");\n        return;\n    }\n\n    // Create buffer with sensor ID\n    char buffer[5];\n    buffer[0] = ENABLE_ROS;\n    memcpy(&buffer[1], &sensor_id, sizeof(stream_id));\n\n    // Send command to server\n    router.Send(buffer, 5);\n\n    // Wait for response\n    char response[10];\n    int bytes_received = router.Receive(response, 10);\n\n    if (bytes_received < 0) {\n        logger.Error(\"Error receiving response from server\");\n        return;\n    }\n\n    // Process response\n    if (response[0] == SUCCESS) {\n        logger.Info(\"Sensor enabled for ROS\");\n    } else if (response[0] == FAILURE) {\n        logger.Error(\"Failed to enable sensor for ROS\");\n    } else {\n        logger.Error(\"Invalid response from server\");\n    }\n}\n", "CodeBleu_score": 41.65321206160995}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)  // Check if the sensor is found on any server\n  for (int i = 0; i < num_servers; i++) {\n    if (sensor_found_on_server[i]) {\n      // Create a buffer with the sensor ID\n      char buffer[sizeof(stream_id)];\n      memcpy(buffer, &sensor_id, sizeof(stream_id));\n\n      // Send the ENABLE_ROS command to the server using the router\n      router->SendCommand(buffer, sizeof(buffer), ENABLE_ROS, i);\n\n      // Wait for and process the server's response\n      router->WaitForResponse(i);\n      router->ProcessResponse(i);\n\n      // Exit the loop\n      break;\n    }\n  }\n\n  // If the sensor is not found on any server, log an error message\n  if (!sensor_found_on_server[num_servers]) {\n    logger->Log(\"Sensor not found on any server\");\n  }\n}\n", "CodeBleu_score": 45.8111687540039}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)    // Check if the sensor is already activated\n    if (sensor_id_to_token_.find(sensor_id) != sensor_id_to_token_.end()) {\n        // If the sensor is already activated, return the existing token\n        std::cout << \"Sensor \" << sensor_id << \" is already activated\" << std::endl;\n        return sensor_id_to_token_[sensor_id];\n    }\n\n    // Enable the sensor on a secondary server\n    std::cout << \"Enabling sensor \" << sensor_id << \" on a secondary server\" << std::endl;\n    // TODO: Implement logic to enable the sensor on a secondary server\n\n    // Retrieve a new token for the sensor\n    std::cout << \"Retrieving a new token for sensor \" << sensor_id << std::endl;\n    token_type token = GenerateToken();\n\n    // Update the maps\n    sensor_id_to_token_[sensor_id] = token;\n    token_to_sensor_id_[token] = sensor_id;\n\n    // Log the action\n    std::cout << \"Activated sensor \" << sensor_id << \" with token \" << token << std::endl;\n\n    // Return the new token\n    return token;\n}\n", "CodeBleu_score": 43.29798421996235}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)    if (IsSensorActivated(sensor_id)) {\n        return tokens[sensor_id];\n    }\n\n    auto secondary_server = GetSecondaryServer(sensor_id);\n    auto token = secondary_server->EnableSensor(sensor_id);\n    tokens[sensor_id] = token;\n    sensors[token] = sensor_id;\n    return token;\n}\n", "CodeBleu_score": 34.15798601092486}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)    // Check if sensor is already activated\n    if (sensor_id_to_token_.count(sensor_id) > 0) {\n        // If sensor is already activated, return existing token\n        return sensor_id_to_token_[sensor_id];\n    } else {\n        // If sensor is not activated, enable sensor on secondary server\n        secondary_server_->EnableSensor(sensor_id);\n\n        // Retrieve new token\n        token_type token = secondary_server_->GetToken(sensor_id);\n\n        // Update maps\n        sensor_id_to_token_[sensor_id] = token;\n        token_to_sensor_id_[token] = sensor_id;\n\n        // Log action\n        std::cout << \"Primary server: sensor \" << sensor_id << \" enabled on secondary server with token \" << token << std::endl;\n\n        // Return new token\n        return token;\n    }\n}\n", "CodeBleu_score": 41.14345008190754}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (!file) {\n        return false;\n    }\n\n    file.seekg(0, std::ios::end);\n    std::streampos fileSize = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n    std::vector<char> fileData(fileSize);\n    file.read(fileData.data(), fileSize);\n\n    file.close();\n\n    return Load(fileData);\n}\n", "CodeBleu_score": 52.12640230439298}, {"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    std::vector<char> data((std::istreambuf_iterator<char>(file)),\n                            std::istreambuf_iterator<char>());\n    file.close();\n\n    return Load(data);\n}\n", "CodeBleu_score": 55.68501460961508}, {"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    std::vector<char> data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n    file.close();\n\n    return Load(data);\n}\n", "CodeBleu_score": 57.29623879656229}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)    if (!IsReady()) {\n        return false;\n    }\n\n    std::lock_guard<std::mutex> lock(m_mutex);\n\n    auto walker = m_walkerMap.find(id);\n    if (walker != m_walkerMap.end()) {\n        m_crowd->removeAgent(walker->second);\n        m_walkerManager->RemoveAgent(id);\n        m_walkerMap.erase(walker);\n        return true;\n    }\n\n    auto vehicle = m_vehicleMap.find(id);\n    if (vehicle != m_vehicleMap.end()) {\n        m_crowd->removeAgent(vehicle->second);\n        m_vehicleManager->RemoveAgent(id);\n        m_vehicleMap.erase(vehicle);\n        return true;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 58.233325718329944}, {"code": "bool Navigation::RemoveAgent(ActorId id)    if (!IsReady()) {\n        return false;\n    }\n\n    assert(crowd != nullptr);\n\n    // Search for the agent in the walker and vehicle mappings\n    auto walkerIt = walkerMapping.find(id);\n    auto vehicleIt = vehicleMapping.find(id);\n\n    if (walkerIt != walkerMapping.end()) {\n        // Remove the agent from the crowd and update the walker manager\n        {\n            std::lock_guard<std::mutex> lock(crowdMutex);\n            crowd->removeAgent(walkerIt->second);\n        }\n        walkerManager->RemoveAgent(id);\n        walkerMapping.erase(walkerIt);\n        return true;\n    } else if (vehicleIt != vehicleMapping.end()) {\n        // Remove the agent from the crowd and update the vehicle manager\n        {\n            std::lock_guard<std::mutex> lock(crowdMutex);\n            crowd->removeAgent(vehicleIt->second);\n        }\n        vehicleManager->RemoveAgent(id);\n        vehicleMapping.erase(vehicleIt);\n        return true;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 61.48520300234094}, {"code": "bool Navigation::RemoveAgent(ActorId id)    // Check if the system is ready\n    if (!IsReady()) {\n        return false;\n    }\n\n    // Assert the crowd object is not null\n    assert(m_crowd != nullptr);\n\n    // Lock the mutex\n    std::unique_lock<std::mutex> lock(m_mutex);\n\n    // Search for the agent id in the walker and vehicle mappings\n    auto walkerIt = m_walkerMapping.find(id);\n    auto vehicleIt = m_vehicleMapping.find(id);\n\n    // If the agent is not found in either mapping, return false\n    if (walkerIt == m_walkerMapping.end() && vehicleIt == m_vehicleMapping.end()) {\n        return false;\n    }\n\n    // Enter a critical section to safely remove the agent\n    {\n        // If the agent is a walker, remove it from the walker manager\n        if (walkerIt != m_walkerMapping.end()) {\n            m_walkerManager->RemoveWalker(walkerIt->second);\n            m_walkerMapping.erase(walkerIt);\n        }\n\n        // If the agent is a vehicle, remove it from the vehicle manager\n        if (vehicleIt != m_vehicleMapping.end()) {\n            m_vehicleManager->RemoveVehicle(vehicleIt->second);\n            m_vehicleMapping.erase(vehicleIt);\n        }\n    }\n\n    // Update the crowd with the changes\n    m_crowd->update(0.0f, nullptr);\n\n    // Return true to indicate success\n    return true;\n}\n", "CodeBleu_score": 53.24909219635402}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    std::set<int> current_vehicles;\n    for (auto const& vehicle : vehicles) {\n        current_vehicles.insert(vehicle.vehicle_id);\n    }\n\n    for (auto const& vehicle : vehicles) {\n        auto vehicle_it = vehicles_.find(vehicle.vehicle_id);\n        if (vehicle_it == vehicles_.end()) {\n            vehicles_.insert({vehicle.vehicle_id, vehicle});\n        } else {\n            vehicle_it->second = vehicle;\n        }\n    }\n\n    for (auto const& vehicle : vehicles_) {\n        if (current_vehicles.find(vehicle.first) == current_vehicles.end()) {\n            vehicles_.erase(vehicle.first);\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 50.666963431292956}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\n    // Collect the IDs of currently mapped vehicles\n    std::set<int> current_vehicle_ids;\n    for (auto const& vehicle : vehicles_) {\n        current_vehicle_ids.insert(vehicle.first);\n    }\n\n    // Add or update vehicles from the provided list\n    for (auto const& vehicle : vehicles) {\n        vehicles_[vehicle.vehicle_id] = vehicle;\n        vehicles_[vehicle.vehicle_id].updated = true;\n    }\n\n    // Remove vehicles not marked as updated\n    for (auto const& vehicle_id : current_vehicle_ids) {\n        if (vehicles_[vehicle_id].updated == false) {\n            vehicles_.erase(vehicle_id);\n        } else {\n            vehicles_[vehicle_id].updated = false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 49.27217000723958}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    // Collect the IDs of currently mapped vehicles\n    std::set<int> mappedVehicleIds;\n    for (auto& [id, vehicle] : vehicles_) {\n        mappedVehicleIds.insert(id);\n    }\n\n    // Add or update vehicles from the provided list\n    for (const auto& vehicle : vehicles) {\n        int id = vehicle.vehicle_id;\n        if (vehicles_.count(id) == 0) {\n            vehicles_[id] = Vehicle(vehicle);\n        } else {\n            vehicles_[id].Update(vehicle);\n        }\n        mappedVehicleIds.erase(id);\n    }\n\n    // Remove vehicles that are not updated\n    for (int id : mappedVehicleIds) {\n        vehicles_.erase(id);\n    }\n\n    return true;\n}\n", "CodeBleu_score": 48.70283742573121}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  const auto &walkers = _actor_system->GetWalkers();\n  const auto &vehicles = _actor_system->GetVehicles();\n\n  // Search for the actor in the mapped walkers and vehicles.\n  const auto it = _actor_system->GetActors().find(id);\n  if (it == _actor_system->GetActors().end()) {\n    return false;\n  }\n\n  // Enter a critical section to prevent concurrent access to the vehicle list.\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Compute the squared distance.\n  const float squared_distance = distance * distance;\n\n  // Use the crowd system to determine if a vehicle is nearby.\n  return _crowd_system.HasVehicleNear(id, squared_distance, direction);\n}\n", "CodeBleu_score": 47.33698604625848}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  // Find the actor in the mapped walkers and vehicles\n  auto it = _walkers_and_vehicles.find(id);\n  if (it == _walkers_and_vehicles.end()) {\n    return false;\n  }\n\n  // Enter a critical section\n  std::lock_guard<std::mutex> lock(_mutex);\n\n  // Compute the squared distance\n  float squared_distance = distance * distance;\n\n  // Use the crowd system to determine if a vehicle is nearby\n  return _crowd_system.HasVehicleNear(it->second, squared_distance, direction);\n}\n", "CodeBleu_score": 50.82105640528498}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  // Search for the actor in the mapped walkers and vehicles.\n  auto walker_it = walkers_.find(id);\n  auto vehicle_it = vehicles_.find(id);\n\n  // If the actor is not found in either the walkers or vehicles, return false.\n  if (walker_it == walkers_.end() && vehicle_it == vehicles_.end()) {\n    return false;\n  }\n\n  // Enter a critical section to ensure thread safety.\n  std::lock_guard<std::mutex> lock(mutex_);\n\n  // Compute the squared distance.\n  float squared_distance = distance * distance;\n\n  // Use the crowd system to determine if a vehicle is nearby.\n  if (walker_it != walkers_.end()) {\n    return walker_it->second.crowd_system->HasVehicleNear(squared_distance, direction);\n  } else {\n    return vehicle_it->second.crowd_system->HasVehicleNear(squared_distance, direction);\n  }\n}\n", "CodeBleu_score": 53.84861658024407}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)  auto &route = info.route;\n  if (route.empty()) {\n    return EventResult::End;\n  }\n  auto &current = route.front();\n  WalkerEventVisitor visitor{info.context, *this, id, info, delta};\n  return boost::variant2::visit(visitor, current);\n}\n", "CodeBleu_score": 52.2862679796164}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)  // Get current route point.\n  const RoutePoint &point = info.route.GetCurrentRoutePoint();\n\n  // Create a WalkerEventVisitor with the current context.\n  WalkerEventVisitor visitor(info.context);\n\n  // Process the event at the current route point using boost::variant2::visit.\n  EventResult result = boost::variant2::visit(visitor, point.event);\n\n  // Return the result of the event execution.\n  return result;\n}\n", "CodeBleu_score": 45.85143537482788}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)  if (info.route.empty()) {\n    return EventResult::End;\n  }\n\n  auto current_route_point = info.route.front();\n\n  WalkerEventVisitor visitor{\n      id,\n      info,\n      delta,\n      current_route_point,\n      info.route.begin(),\n      info.route.end(),\n      _context};\n\n  return boost::variant2::visit(visitor, current_route_point);\n}\n", "CodeBleu_score": 48.05723230631539}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  pugi::xml_node opendrive_node = xml.child(\"OpenDRIVE\");\n\n  for (pugi::xml_node road_node = opendrive_node.child(\"road\");\n       road_node;\n       road_node = road_node.next_sibling(\"road\")) {\n    std::string road_id = road_node.attribute(\"id\").as_string();\n\n    for (pugi::xml_node lane_section_node = road_node.child(\"lanes\").child(\"laneSection\");\n         lane_section_node;\n         lane_section_node = lane_section_node.next_sibling(\"laneSection\")) {\n      ParseLanes(lane_section_node, map_builder, road_id, \"left\");\n      ParseLanes(lane_section_node, map_builder, road_id, \"center\");\n      ParseLanes(lane_section_node, map_builder, road_id, \"right\");\n    }\n  }\n}\n", "CodeBleu_score": 47.68303315682327}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const int road_id = std::stoi(road_node.attribute(\"id\").value());\n    for (pugi::xml_node lanes_node : road_node.children(\"lanes\")) {\n      for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n        for (pugi::xml_node left_node : lane_section_node.children(\"left\")) {\n          ParseLanes(left_node, map_builder, road_id, 0);\n        }\n        for (pugi::xml_node center_node : lane_section_node.children(\"center\")) {\n          ParseLanes(center_node, map_builder, road_id, 0);\n        }\n        for (pugi::xml_node right_node : lane_section_node.children(\"right\")) {\n          ParseLanes(right_node, map_builder, road_id, 0);\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 55.568207409284355}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const int road_id = std::stoi(road_node.attribute(\"id\").value());\n\n    for (pugi::xml_node lanes_node : road_node.children(\"lanes\")) {\n      for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n        const double s_0 = std::stod(lane_section_node.attribute(\"s\").value());\n        const auto left_lanes = lane_section_node.child(\"left\");\n        const auto center_lanes = lane_section_node.child(\"center\");\n        const auto right_lanes = lane_section_node.child(\"right\");\n\n        ParseLanes(left_lanes, s_0, road_id, map_builder);\n        ParseLanes(center_lanes, s_0, road_id, map_builder);\n        ParseLanes(right_lanes, s_0, road_id, map_builder);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 60.9409242189373}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cout << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}\n", "CodeBleu_score": 68.874825773384}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    if (info.current_count_change == 1) {\n        matched_++;\n        if (matched_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_--;\n    } else {\n        // should never happen\n        std::cerr << \"invalid count change\" << std::endl;\n    }\n}\n", "CodeBleu_score": 56.11541359320667}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    if (info.current_count_change == 1) {\n        matched_++;\n        std::cout << \"Publisher matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        std::cout << \"Publisher unmatched.\" << std::endl;\n    } else {\n        std::cout << info.current_count_change\n                  << \" is not a valid value for PublicationMatchedStatus current count change\" << std::endl;\n    }\n}\n", "CodeBleu_score": 68.874825773384}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        matched_++;\n        if (matched_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        if (matched_ == 0) {\n            delete reader;\n        }\n    } else {\n        std::cerr << \"CarlaSubscriberListenerImpl::on_subscription_matched: invalid change count\" << std::endl;\n    }\n}\n", "CodeBleu_score": 53.481624570959}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        matched_++;\n        if (matched_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        if (matched_ == 0) {\n            // destroy the subscriber\n        }\n    } else {\n        // log error message\n    }\n}\n", "CodeBleu_score": 48.28907505514963}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        matched_++;\n        if (matched_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        matched_--;\n        if (matched_ == 0) {\n            delete reader;\n        }\n    } else {\n        std::cerr << info.current_count_change\n                  << \" is not a valid value for SubscriptionMatchedStatus current count change\" << std::endl;\n    }\n}\n", "CodeBleu_score": 65.46393819584063}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if(!m_isGetKeyDefined)\n        return false;\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if(force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16)    {\n        m_md5.init();\n        m_md5.update(m_keyBuffer,\n                static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for(uint8_t i = 0;i<16;++i)        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else    {\n        for(uint8_t i = 0;i<16;++i)        {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 83.77940396103882}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);  // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer,\n                static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 96.11489378124978}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if (!m_isGetKeyDefined) {\n        return false;\n    }\n\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),\n            CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.\n    p_type->serializeKey(ser);\n    if (force_md5 || CarlaCollisionEvent::getKeyMaxCdrSerializedSize() > 16) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 96.43690246315792}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}\n", "CodeBleu_score": 95.2089897485463}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}\n", "CodeBleu_score": 95.2089897485463}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        // Serialize the object.\n        p_type->serialize(ser);\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}\n", "CodeBleu_score": 95.2089897485463}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    // exit immediately if the target has already been set\n    if (target_set) {\n        return;\n    }\n\n    // decode the message\n    switch (msg.msgid) {\n\n    // if the message is a request for mission data, set the target system ID\n    // and request position and air pressure data streams from the target\n    case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:\n        {\n            // decode\n            mavlink_mission_request_list_t packet;\n            mavlink_msg_mission_request_list_decode(&msg, &packet);\n\n            // set target's sysid\n            set_target(packet.target_system);\n\n            // request position stream\n            gcs().request_datastream_position(target_sysid);\n\n            // request air pressure stream\n            gcs().request_datastream_airpressure(target_sysid);\n        }\n        break;\n\n    // if the message is a request for waypoints, set the target system ID\n    // and request position and air pressure data streams from the target\n    case MAVLINK_MSG_ID_WAYPOINT_REQUEST_LIST:\n        {\n            // decode\n            mavlink_waypoint_request_list_t packet;\n            mavlink_msg_waypoint_request_list_decode(&msg, &packet);\n\n            // set target's sysid\n            set_target(packet.target_system);\n\n            // request position stream\n            gcs().request_datastream_position(target_sysid);\n\n            // request air pressure stream\n            gcs().request_datastream_airpressure(target_sysid);\n        }\n        break;\n\n    // if the message is a request for a parameter, set the target system ID\n    // and request position and air pressure data streams from the target\n    case MAVLINK_MSG_ID_PARAM_REQUEST_LIST:\n        {\n            // decode\n            mavlink_param_request_list_t packet;\n            mavlink_msg_param_request_list_decode(&msg, &packet);\n\n            //", "CodeBleu_score": 38.97094302655584}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    if (target_set) {\n        // already got a target\n        return;\n    }\n\n    // decode\n    switch (msg.msgid) {\n\n    case MAVLINK_MSG_ID_ATTITUDE: {\n        mavlink_attitude_t packet;\n        mavlink_msg_attitude_decode(&msg, &packet);\n        tracker.set_tracking_angle(packet.roll, packet.pitch, packet.yaw,\n                                    packet.body_frame);\n        break;\n    }\n\n    case MAVLINK_MSG_ID_LOCAL_POSITION_NED: {\n        mavlink_local_position_ned_t packet;\n        mavlink_msg_local_position_ned_decode(&msg, &packet);\n        tracker.set_tracking_position(packet.x, packet.y, -packet.z,\n                                      packet.vy, packet.vz);\n        break;\n    }\n\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT: {\n        mavlink_global_position_int_t packet;\n        mavlink_msg_global_position_int_decode(&msg, &packet);\n        tracker.set_tracking_position(packet.lat, packet.lon, packet.alt,\n                                      packet.vx, packet.vy);\n        break;\n    }\n\n    default:\n        // not something we would track\n        return;\n    }\n\n    // set target has been set\n    target_set = true;\n\n    // send data streams in case we were waiting for it\n    if (stream_requested) {\n        handle_request_data_stream(msg.sysid, msg.compid, STREAM_POSITION, 1);\n        handle_request_data_stream(msg.sysid, msg.compid, STREAM_EXTRA1, 1);\n        stream_requested = false;\n    }\n}\n", "CodeBleu_score": 41.38924839154916}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    // exit immediately if the target has already been set\n    if (target_set) {\n        return;\n    }\n\n    // decode message\n    mavlink_status_t status;\n    mavlink_message_t rmsg;\n    mavlink_msg_decode(&msg, &status, &rmsg);\n\n    // exit immediately if this is not a message that should be tracked\n    if (rmsg.msgid != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n        rmsg.msgid != MAVLINK_MSG_ID_SCALED_PRESSURE) {\n        return;\n    }\n\n    // if the target's sysid is zero, this indicates that the target\n    // should be whatever the sender is:\n    if (target_system == 0) {\n        // set target_system based on sender of the message\n        target_system = rmsg.sysid;\n        // send a request message for position and air pressure data\n        mavlink_request_data_stream_t req_msg;\n        req_msg.target_system = target_system;\n        req_msg.target_component = 0;\n        req_msg.req_stream_id = MAV_DATA_STREAM_POSITION;\n        req_msg.req_message_rate = 5;\n        req_msg.start_stop = 1;\n        mavlink_msg_request_data_stream_send(\n            mavlink_comm_0,\n            target_system, 0, &req_msg);\n        req_msg.req_stream_id = MAV_DATA_STREAM_RAW_SENSORS;\n        mavlink_msg_request_data_stream_send(\n            mavlink_comm_0,\n            target_system, 0, &req_msg);\n    }\n\n    // flag that the target has been set\n    target_set = true;\n}\n", "CodeBleu_score": 34.87214244207784}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        barometer.set_calibration_needed();\n    }\n    return result;\n}\n", "CodeBleu_score": 64.27041235267414}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        barometer.set_imu_temp_at_calibration(imu.get_temperature());\n        barometer.set_ground_pressure(barometer.get_pressure());\n        barometer.set_ground_temperature(barometer.get_temperature());\n        barometer.set_ground_altitude(g.rangefinder_landing ? rangefinder.distance_cm() : 0);\n        barometer.set_healthy(true);\n        barometer.update_calibration();\n        barometer.calibrate_ground_pressure();\n        barometer.update_calibration();\n        barometer.set_baro_cal_started(true);\n        barometer.set_calibration_time(AP_HAL::millis());\n        barometer.set_calibration_count(0);\n        barometer.set_calibration(true);\n    }\n    return result;\n}\n", "CodeBleu_score": 49.897661602154166}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT ret = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (ret == MAV_RESULT_ACCEPTED) {\n        baro_cal_needed = true;\n    }\n    return ret;\n}\n", "CodeBleu_score": 79.17062535648334}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    if (packet.param1 == 1.0f) {\n        // arm\n        if (motors->armed()) {\n            return MAV_RESULT_ACCEPTED;\n        }\n        motors->armed(true);\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    if (packet.param1 == 0.0f) {\n        // disarm\n        if (!motors->armed()) {\n            return MAV_RESULT_ACCEPTED;\n        }\n        motors->armed(false);\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    return MAV_RESULT_UNSUPPORTED;\n}\n", "CodeBleu_score": 62.4171401840329}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    if (packet.param1 == 1.0f) {\n        // arm servos\n        AP_Notify::events.user_input_test = 1;\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (packet.param1 == 0.0f) {\n        // disarm servos\n        AP_Notify::events.user_input_test = 0;\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}\n", "CodeBleu_score": 63.63334266465801}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    if (packet.param1 == 1.0f) {\n        // arm\n        servos_armed = true;\n        return MAV_RESULT_ACCEPTED;\n    }\n    if (packet.param1 == 0.0f) {\n        // disarm\n        servos_armed = false;\n        return MAV_RESULT_ACCEPTED;\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}\n", "CodeBleu_score": 65.64838220890505}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    for (uint8_t i=0; i < num_gcs(); i++) {\n        if (comm_get_txspace(i) > MAVLINK_NUM_NON_PAYLOAD_BYTES + MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN) {\n            mavlink_msg_request_data_stream_send(i, sysid, compid, MAV_DATA_STREAM_POSITION, 10);\n        }\n    }\n}\n", "CodeBleu_score": 56.64815382390693}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    // Iterate over the available GCS channels\n    for (uint8_t i = 0; i < num_gcs(); i++) {\n        // Get the channel's protocol version\n        mavlink_channel_t chan = gcs_chan(i);\n        uint8_t chan_protocol_version = mavlink_comm_get_protocol_version(chan);\n\n        // Check if the channel has available payload space\n        if (comm_get_txspace(chan) >= MAVLINK_MSG_ID_REQUEST_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n            // Send the request to start the data stream\n            mavlink_msg_request_data_stream_send(chan, sysid, compid, MAV_DATA_STREAM_POSITION, _gcs_pos_update_rate_hz[i], 1);\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 57.56725675943384}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    for (uint8_t i=0; i<num_gcs; i++) {\n        if (gcs[i] != nullptr && gcs[i]->initialised()) {\n            if (HAVE_PAYLOAD_SPACE(gcs[i]->get_chan(), POSITION)) {\n                gcs[i]->send_message(MSG_REQUEST_DATA_STREAM);\n                gcs[i]->reset_retry_timeout();\n                gcs[i]->set_datastream_period(POSITION, 1000000 / GCS_MAVLINK::get_update_rate(gcs[i]->get_chan()));\n                gcs[i]->set_datastream_enable(POSITION, true);\n                gcs[i]->send_message(MSG_SET_MESSAGE_INTERVAL);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 42.53557563658911}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    AHRS& ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch < 0.707) {\n        return false;\n    }\n    ef_pitch = radians(90 - degrees(asin(cos_pitch)));\n    ef_yaw = radians(90 - degrees(atan2(ahrs.sin_yaw() / cos_pitch, ahrs.cos_yaw() / cos_pitch)));\n    return true;\n}\n", "CodeBleu_score": 51.00900808962319}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    // Get AHRS instance\n    AP_AHRS &ahrs = AP::ahrs();\n    // Get the cosine of the AHRS pitch angle\n    float cos_pitch = ahrs.cos_pitch();\n    // Check if the cosine of the AHRS pitch angle is zero\n    if (cos_pitch == 0.0f) {\n        // If the cosine of the AHRS pitch angle is zero, return false\n        return false;\n    }\n    // Calculate the earth frame pitch angle\n    ef_pitch = RAD_TO_DEG(atan2f(ahrs.sin_pitch() / cos_pitch, ahrs.cos_pitch()));\n    // Calculate the earth frame yaw angle\n    ef_yaw = wrap_180(RAD_TO_DEG(atan2f(ahrs.sin_yaw(), ahrs.cos_yaw() * cos_pitch)));\n    // Return true\n    return true;\n}\n", "CodeBleu_score": 51.60357992979263}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    AHRS &ahrs = AP::ahrs();\n    float cos_pitch = ahrs.cos_pitch();\n    if (cos_pitch < 0.7f) {\n        return false;\n    } else {\n        ef_pitch = safe_asin(cos_pitch * safe_sin(pitch));\n        ef_yaw = wrap_PI(yaw - ahrs.yaw);\n        return true;\n    }\n}\n", "CodeBleu_score": 51.460915631354965}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)    // Calculate the yaw and pitch in centidegrees\n    float yaw = (float)navigation.target_yaw / 100.0f;\n    float pitch = (float)navigation.target_pitch / 100.0f;\n\n    // Check if the direction is reversed\n    if (reversed) {\n        yaw = -yaw;\n        pitch = -pitch;\n    }\n\n    // Compute the angle error in centidegrees\n    float angle_error = atan2f(pitch, yaw) * 180.0f / M_PI * 100.0f;\n\n    // Convert the errors from earth frame to body frame\n    float body_angle_error = angle_error - navigation.yaw;\n    float body_pitch_error = pitch * cosf(body_angle_error * M_PI / 180.0f / 100.0f);\n\n    // Check if the target distance is valid or no minimum distance is set\n    if (navigation.target_distance_valid || min_distance == 0) {\n        // Update the pitch servo\n        if (body_pitch_error > 0) {\n            pitch_servo.write(map(body_pitch_error, 0, max_pitch, 0, 180));\n        } else {\n            pitch_servo.write(map(-body_pitch_error, 0, max_pitch, 180, 0));\n        }\n\n        // Update the yaw servo\n        if (body_angle_error > 0) {\n            yaw_servo.write(map(body_angle_error, 0, max_yaw, 0, 180));\n        } else {\n            yaw_servo.write(map(-body_angle_error, 0, max_yaw, 180, 0));\n        }\n    }\n}\n", "CodeBleu_score": 37.17630373679371}, {"code": "void Mode::update_auto(void)    // Calculate yaw and pitch in centidegrees\n    int32_t yaw_cd = wrap_360_cd(nav_status.bearing * 100);\n    int32_t pitch_cd = wrap_180_cd(nav_status.bearing * 100);\n\n    // Check if the direction is reversed\n    if (reverse_yaw) {\n        yaw_cd = wrap_360_cd(180000 - yaw_cd);\n    }\n    if (reverse_pitch) {\n        pitch_cd = wrap_180_cd(180000 - pitch_cd);\n    }\n\n    // Compute angle error in centidegrees\n    int32_t angle_error_cd = wrap_180_cd(yaw_cd - ahrs.yaw_sensor);\n\n    // Convert angle error from earth frame to body frame\n    angle_error_cd = wrap_180_cd(angle_error_cd - ahrs.pitch_sensor);\n\n    // Update pitch and yaw servos if target distance is valid or no minimum distance is set\n    if (nav_status.distance_to_target >= min_distance_cm || min_distance_cm == 0) {\n        // Calculate pitch and yaw servo positions\n        int16_t pitch_servo_pos = constrain_int16(pitch_cd * (g.pitch_range / 4500), -g.pitch_range, g.pitch_range);\n        int16_t yaw_servo_pos = constrain_int16(yaw_cd * (g.yaw_range / 4500), -g.yaw_range, g.yaw_range);\n\n        // Update pitch and yaw servos\n        RC_Channel_aux::set_radio_trimmed(RC_Channel_aux::k_tracker_yaw, yaw_servo_pos);\n        RC_Channel_aux::set_radio_trimmed(RC_Channel_aux::k_tracker_pitch, pitch_", "CodeBleu_score": 36.422093401907794}, {"code": "void Mode::update_auto(void)    // Calculate the yaw and pitch in centidegrees\n    int16_t yaw = (int16_t)((float)g_params.target_yaw * 100.0);\n    int16_t pitch = (int16_t)((float)g_params.target_pitch * 100.0);\n\n    // Check if the direction is reversed\n    if (g_params.reverse_direction) {\n        yaw = -yaw;\n        pitch = -pitch;\n    }\n\n    // Compute the angle error\n    int16_t yaw_error = yaw - g_status.yaw;\n    int16_t pitch_error = pitch - g_status.pitch;\n\n    // Convert the errors from earth frame to body frame\n    int16_t yaw_error_body = yaw_error * g_params.cos_pitch + pitch_error * g_params.sin_pitch;\n    int16_t pitch_error_body = -yaw_error * g_params.sin_pitch + pitch_error * g_params.cos_pitch;\n\n    // Update the pitch and yaw servos\n    if (g_params.target_distance_valid || g_params.min_distance == 0) {\n        g_status.pitch_servo = g_params.pitch_servo_trim + g_params.pitch_servo_gain * pitch_error_body;\n        g_status.yaw_servo = g_params.yaw_servo_trim + g_params.yaw_servo_gain * yaw_error_body;\n    }\n}\n", "CodeBleu_score": 39.537092832879125}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)    gps.update();\n\n    // Check if the last message time has changed\n    if (gps.last_message_time() != last_message_time) {\n        last_message_time = gps.last_message_time();\n\n        // Check if the GPS status is at least 3D fix\n        if (gps.status() >= STATUS_3D_FIX) {\n            // Decrement the ground start countdown\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n\n            // Check if the current location is valid\n            if (gps.valid_location()) {\n                // Set the home location if the countdown reaches one\n                if (ground_start_countdown == 1) {\n                    set_home_location(gps.latitude(), gps.longitude(), gps.altitude());\n                }\n            } else {\n                // Reset the countdown if the current location is invalid\n                ground_start_countdown = GROUND_START_COUNTDOWN;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 47.83936153350506}, {"code": "void Tracker::update_GPS(void)    // Update the GPS data\n    gps.update();\n\n    // Check if the last message time has changed\n    if (last_message_time != gps.last_message_time()) {\n        // Update the last message time\n        last_message_time = gps.last_message_time();\n\n        // Check if the GPS status is at least 3D fix\n        if (gps.satellites() >= 3) {\n            // Decrement the countdown\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n\n            // Check if the countdown has reached zero\n            if (ground_start_countdown == 0) {\n                // Set the home location if the current location is valid\n                if (gps.valid()) {\n                    home_latitude = gps.latitude();\n                    home_longitude = gps.longitude();\n                    home_altitude = gps.altitude();\n                } else {\n                    // Reset the countdown\n                    ground_start_countdown = 3;\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 49.07570601905038}, {"code": "void Tracker::update_GPS(void)    // Update GPS data\n    gps.update();\n\n    // Check if the last message time has changed\n    if (last_message_time != gps.last_message_time()) {\n        last_message_time = gps.last_message_time();\n\n        // Check if the GPS status is at least 3D fix\n        if (gps.status() >= 3) {\n            // Decrement the countdown\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n            }\n\n            // Set the home location if the current location is valid\n            if (ground_start_countdown == 1) {\n                if (gps.location.isValid()) {\n                    home_latitude = gps.location.lat();\n                    home_longitude = gps.location.lng();\n                } else {\n                    // Reset the countdown if the current location is invalid\n                    ground_start_countdown = 5;\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 50.38447622142589}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    if (pitch > 0) {\n        // Set the servo to 180 degrees\n        pitch_onoff_servo.write(180);\n    } else {\n        // Set the servo to 0 degrees\n        pitch_onoff_servo.write(0);\n    }\n}\n", "CodeBleu_score": 13.451121333565894}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    if (pitch > 0) {\n        servo_pitch.writeMicroseconds(PITCH_ON_SERVO_PWM);\n    } else {\n        servo_pitch.writeMicroseconds(PITCH_OFF_SERVO_PWM);\n    }\n}\n", "CodeBleu_score": 14.010228325550377}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    // if (pitch > -10) {\n    //     pitch_onoff_servo.write(180);\n    // }\n    // else {\n    //     pitch_onoff_servo.write(0);\n    // }\n}\n", "CodeBleu_score": 4.619414675954676}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (checks_to_perform == ARMING_CHECK_ALL ||\n        checks_to_perform == ARMING_CHECK_BARO) {\n        // Check baro reference ok\n        if (barometer.all_healthy()) {\n            const AP_AHRS &ahrs = AP::ahrs();\n            // Check baro vs inav altitude\n            if (fabsf(inertial_nav.get_altitude() - barometer.get_altitude()) > BARO_MAX_ALT_DISPARITY_CM) {\n                if (display_failure) {\n                    gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Altitude disparity\");\n                }\n                return false;\n            }\n            // Check inav vs ahrs\n            if (fabsf(inertial_nav.get_altitude() - ahrs.get_altitude()) > BARO_MAX_ALT_DISPARITY_CM) {\n                if (display_failure) {\n                    gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Altitude disparity\");\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 49.87643567030021}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    // return true immediately if barometer checks are disabled\n    if (!(checks_to_perform & ARMING_CHECK_BARO)) {\n        return true;\n    }\n\n    // check baro\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // Check baro vs inav altitude check.\n    // This check is only applied if we are using the inertial nav system for altitude\n    // and the baro height source is set to inav.\n    if ((checks_to_perform & ARMING_CHECK_BARO) &&\n        (baro_checks_enabled & ARMING_CHECK_BARO) &&\n        (ahrs.get_primary_height_source() == AP_AHRS_NavEKF::HeightSource::BARO) &&\n        (ahrs.pre_arm_check_baro() == false)) {\n        const char *reason = ahrs.pre_arm_failing_check_baro();\n        if (reason == nullptr) {\n            reason = \"Unknown\";\n        }\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Baro altitude check failed (%s)\", reason);\n        }\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 46.90083892605899}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    // return true if already armed\n    if (copter.ap.armed) {\n        return true;\n    }\n\n    // perform barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // Check baro reference vs alt and ground altitude\n    if ((checks_to_perform & ARMING_CHECK_ALL) ||\n        (checks_to_perform & ARMING_CHECK_BARO)) {\n        // Check baro vs inertial nav alt and nudge z down if\n        // necessary. This is done with baro disabled to ensure\n        // that the altitude is correct based on the inertial\n        // nav. Don't use EKF alt because it won't have the right\n        // vertical position due to baro drift\n        copter.gcs().send_text(MAV_SEVERITY_INFO, \"Checking baro vs inertial nav\");\n        copter.barometer.set_baro_enabled(false);\n        copter.barometer.update_calibration();\n        copter.gcs().send_text(MAV_SEVERITY_INFO, \"Collected baro ground sample\");\n        const float inertial_nav_alt = copter.inertial_nav.get_altitude();\n        const int32_t baro_alt_above_ground = copter.barometer.get_altitude();\n        const int16_t baro_offset_cm = copter.barometer.get_baro_offset();\n        copter.barometer.update();\n        const int32_t baro_alt = copter.barometer.get_altitude();\n        const float baro_alt_abs = fabs(baro_alt);\n        copter.barometer.set_baro_enabled(true);\n        if (baro_alt_abs > 0 && inertial_nav_alt > 0) {\n            const float baro_alt_diff = fabs(baro_alt_above_ground - baro_alt);\n            if (baro_alt_diff > BARO_DISPARITY", "CodeBleu_score": 46.45055475514145}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const    // If the terrain source is from a rangefinder, then no terrain database is required\n    if (copter.terrain.get_source() == AP_Terrain::TerrainSourceType::TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n\n    // If the terrain source is from the terrain database, and the RTL altitude type is terrain, then a terrain database is required\n    if (copter.terrain.get_source() == AP_Terrain::TerrainSourceType::TERRAIN_SOURCE_TERRAINDATABASE &&\n        copter.rtl_alt_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n\n    // Otherwise, defer to the base class implementation of terrain_database_required\n    return AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 74.62372178879563}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    if (copter.g2.rtl_alt_type.get() == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 33.56058669213048}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    if (g.terrain_follow) {\n        if (g.terrain_follow == TERRAIN_FOLLOW_ENABLED_RANGEFINDER_ONLY) {\n            return false;\n        }\n        if (g.terrain_follow == TERRAIN_FOLLOW_ENABLED_TERRAIN_ONLY) {\n            return true;\n        }\n        if (g.terrain_follow == TERRAIN_FOLLOW_ENABLED_TERRAIN_AND_RANGEFINDER) {\n            return true;\n        }\n    }\n\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 61.11658881235454}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()    // set loop time for controllers\n    motors->set_loop_rate(scheduler.get_loop_rate_hz());\n    wp_nav->set_dt(scheduler.get_loop_period_s());\n\n    // run low level rate controllers that use only the rate_controller\n    attitude_control->rate_controller_run();\n}\n", "CodeBleu_score": 29.202371439274728}, {"code": "void Copter::run_rate_controller()    // set loop time for controllers\n    motors->set_loop_time_rate_controller(scheduler.get_loop_time_rate_controller());\n\n    // run low-level rate controllers that require only IMU data\n    attitude_control->rate_controller_run();\n}\n", "CodeBleu_score": 20.607992719567903}, {"code": "void Copter::run_rate_controller()    // set loop time for controllers\n    motors->set_loop_time_rate_controller(scheduler.get_loop_time_rate_controller());\n\n    // run low level rate controllers that use only the rate controller\n    attitude_control->rate_controller_run();\n}\n", "CodeBleu_score": 20.607992719567903}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    // check if we have a valid waypoint\n    if (!new_loc.valid()) {\n        return false;\n    }\n\n    // check if we have changed from no target to valid target\n    if (!old_loc.valid()) {\n        return true;\n    }\n\n    // check if we have changed altitude\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return true;\n    }\n\n    // check if we have changed lat/lon\n    if (old_loc.lat != new_loc.lat || old_loc.lng != new_loc.lng) {\n        return true;\n    }\n\n    // we have not changed location\n    return false;\n}\n", "CodeBleu_score": 49.98089019305927}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    // check if the old location matches the new location\n    if (old_loc == new_loc) {\n        return false;\n    }\n\n    // check if the altitude frames match\n    if (old_loc.get_alt_frame() != new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // set the new location as the target\n    set_target_location(new_loc);\n    return true;\n}\n", "CodeBleu_score": 57.9258287114087}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    // if we have no location yet, use the current location\n    if (old_loc.lat == 0 && old_loc.lng == 0) {\n        return false;\n    }\n\n    // if the old location is the same as the new location, don't change the target\n    if (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng && old_loc.alt == new_loc.alt) {\n        return false;\n    }\n\n    // if the old location is the same as the new location, don't change the target\n    if (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng && old_loc.alt == new_loc.alt) {\n        return false;\n    }\n\n    // if the altitude frames of the old and new locations are the same, don't change the target\n    if (old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // if the old location is the same as the new location, don't change the target\n    if (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng && old_loc.alt == new_loc.alt) {\n        return false;\n    }\n\n    // if the altitude frames of the old and new locations are the same, don't change the target\n    if (old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n        return false;\n    }\n\n    // if the old location is the same as the new location, don't change the target\n    if (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng && old_loc.alt == new_loc.alt) {\n        return false;\n    }\n\n    // if the altitude frames of the old and new locations are the same, don't change the target\n    if (old_loc.get_alt_frame() == new_loc.get_alt_frame()) {\n        return false;\n    }", "CodeBleu_score": 41.73368888896549}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        // the user wants the mode to change back to the last mode\n        copter.reset_control_switch();\n    }\n}\n", "CodeBleu_score": 60.65730786190863}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        // the mode the switch wanted has already been set - reset the\n        // channel and the user can try again\n        rc().reset_mode_switch();\n    }\n}\n", "CodeBleu_score": 69.04749221956563}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (ch_flag == AuxSwitchPos::HIGH) {\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.flightmode->mode_number() == mode) {\n        rc().reset_mode_switch();\n    }\n}\n", "CodeBleu_score": 69.04749221956563}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()    // save roll and pitch trim\n    float roll_trim = ToRad((float)channel_roll->get_control_in()/100.0f);\n    float pitch_trim = ToRad((float)channel_pitch->get_control_in()/100.0f);\n    ahrs.add_trim(roll_trim, pitch_trim);\n\n    // log event\n    Log_Write_Event(DATA_SAVEWP_MSG);\n    gcs_send_text_P(MAV_SEVERITY_INFO, PSTR(\"Trim saved\"));\n}\n", "CodeBleu_score": 77.44016784780567}, {"code": "void Copter::save_trim()    // save existing trim values\n    float roll_trim_old = ahrs.roll_trim;\n    float pitch_trim_old = ahrs.pitch_trim;\n\n    // calculate new trim values\n    ahrs.roll_trim += ToRad((float)channel_roll->get_control_in()/ROLL_TRIM_MAX);\n    ahrs.pitch_trim += ToRad((float)channel_pitch->get_control_in()/PITCH_TRIM_MAX);\n\n    // save new trim values to eeprom\n    ahrs.save_trim();\n\n    // log new values\n    Log_Write_Event(DATA_SAVEWP);\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Trimmed roll: %4.2f, pitch: %4.2f\", (double)ahrs.roll_trim*RAD_TO_DEG, (double)ahrs.pitch_trim*RAD_TO_DEG);\n\n    // send new trim values to GCS\n    gcs_send_trim_roll(ahrs.roll_trim*RAD_TO_DEG);\n    gcs_send_trim_pitch(ahrs.pitch_trim*RAD_TO_DEG);\n\n    // display new values\n    display_roll_pitch_trim(ahrs.roll_trim*RAD_TO_DEG, ahrs.pitch_trim*RAD_TO_DEG);\n\n    // log ahrs_ekf_view values\n    Log_Write_AHRS2();\n\n    // send new trim values to AHRS\n    ahrs.send_trim();\n\n    // send new trim values to flight controller\n    gcs_send_trim_roll(ahrs.roll_trim*RAD_TO_DEG);\n    gcs_send_trim_pitch(ahrs.pitch_trim*RAD_TO_DEG);\n\n    // send new trim values to rangefinder\n    rangefinder.send_trim(ahrs.roll_trim*RAD_TO_DEG, ahrs.pitch_trim*RAD_TO_", "CodeBleu_score": 41.8254191232187}, {"code": "void Copter::save_trim()    float roll_trim, pitch_trim;\n\n    // calculate roll trim\n    roll_trim = (channel_roll->get_control_in() / static_cast<float>(ROLL_PITCH_INPUT_MAX)) * radians(4500);\n\n    // calculate pitch trim\n    pitch_trim = (channel_pitch->get_control_in() / static_cast<float>(ROLL_PITCH_INPUT_MAX)) * radians(4500);\n\n    // add trim to ahrs object\n    // save to eeprom\n    ahrs.add_trim(roll_trim, pitch_trim);\n    Log_Write_Event(DATA_SAVEWP_MSG);\n    gcs_send_text_P(MAV_SEVERITY_INFO, PSTR(\"Trim saved\"));\n}\n", "CodeBleu_score": 49.93718718543537}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()    const Vector3f &velocity = copter.inertial_nav.get_velocity();\n    float speed = norm(velocity.x,velocity.y);\n    float speed_sq = sq(speed);\n\n    if (copter.position_ok() && (speed_sq > MIN_SPEED_SQ)) {\n        // use velocity to calculate scaled look ahead yaw\n        float look_ahead_yaw = atan2f(velocity.y,velocity.x);\n        return look_ahead_yaw;\n    } else {\n        return 0.0f;\n    }\n}\n", "CodeBleu_score": 58.31129258457727}, {"code": "float Mode::AutoYaw::look_ahead_yaw()    const Vector3f& vel = inertial_nav.get_velocity();\n    float speed_sq = vel.length_squared();\n    if (!inertial_nav.get_filter_status().flags.horiz_pos_abs &&\n        (speed_sq < AP_ACRO_YAW_SPEED_FILT_MIN*AP_ACRO_YAW_SPEED_FILT_MIN)) {\n        return ahrs.yaw;\n    }\n    if (speed_sq < AP_ACRO_YAW_SPEED_FILT_MIN*AP_ACRO_YAW_SPEED_FILT_MIN) {\n        return ahrs.yaw;\n    }\n    float look_ahead_yaw = atan2f(-vel.y, -vel.x);\n    return look_ahead_yaw;\n}\n", "CodeBleu_score": 50.83410792794481}, {"code": "float Mode::AutoYaw::look_ahead_yaw()    // get copter's velocity\n    Vector3f velocity = inertial_nav.get_velocity();\n\n    // calculate speed squared\n    float speed_sq = velocity.length_squared();\n\n    // if copter's position is valid and the speed exceeds a minimum threshold\n    if (rover.position_ok() && (speed_sq > MIN_AUTO_YAW_SPEED_SQ)) {\n        // update look-ahead yaw angle using arctangent of velocity components\n        look_ahead_yaw = atan2f(-velocity.y, velocity.x);\n    }\n\n    // return computed look-ahead yaw angle\n    return look_ahead_yaw;\n}\n", "CodeBleu_score": 41.711409371240784}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::Method::RUDDER) {\n        if (plane.g2.rudder_arming_dis_ch != 0) {\n            // check if throttle is zero\n            if (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) <= 0) {\n                return false;\n            }\n            // check if rudder arming/disarm disabled\n            if (plane.g2.rudder_arming_dis_ch < 0) {\n                return false;\n            }\n        }\n    }\n\n    if (hal.util->was_watchdog_armed()) {\n        // if we've already armed, return true so that arming\n        // is not stopped\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 60.99185581904144}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arming_dis_ch != nullptr && rudder_arming_dis_ch->get_control_in() < 0) {\n            // rudder arming must be disabled\n            return false;\n        }\n\n        if (throttle_zero_flag) {\n            // throttle must be zero\n            return false;\n        }\n    }\n\n    if (armed || method == AP_Arming::Method::NONE) {\n        // if we are already armed or arming checks are disabled\n        // then skip arming checks\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 56.208757514008354}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arming_dis_ch != nullptr) {\n            // check rudder arming is not disabled\n            if (rudder_arming_dis_ch->get() == RUDDER_ARMING_DISABLED) {\n                return false;\n            }\n        }\n\n        // check throttle is not zero\n        if (hal.rcin->read(channel_throttle->get_radio_min()) <= 0) {\n            return false;\n        }\n\n        // if we got this far all is ok\n        return true;\n    }\n\n    // check if arming is disabled\n    if (checks_to_perform_mask & ARMING_CHECK_NONE) {\n        return true;\n    }\n\n    // check if the watchdog was ever armed\n    if (watchdog_was_armed) {\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 63.66308226617665}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\n    // return true immediately if already armed\n    if (armed) {\n        return true;\n    }\n\n    // don't allow arming via the parameter interface\n    if (method == AP_Arming::Method::MAVLINK) {\n        return false;\n    }\n\n    // don't allow arming via the parameter interface\n    if (method == AP_Arming::Method::PARAM) {\n        return false;\n    }\n\n    // if method is set to GCS arming, do pre-arm checks. Otherwise perform the arming checks\n    if (method == AP_Arming::Method::MAVLINK_GCS_ARMING) {\n        // run pre-arm checks and display failures\n        if (!run_pre_arm_checks()) {\n            return false;\n        }\n    } else if (do_arming_checks && !run_arm_checks(true)) {\n        return false;\n    }\n\n    // update home and ahrs location\n    update_home();\n\n    // update current location\n    update_current_loc();\n\n    // update the current mode\n    Mode *old_mode = plane.control_mode;\n    plane.set_mode(plane.mode_auto, ModeReason::ARMING_COMPLETE);\n\n    // set arming flag\n    armed = true;\n\n    // log arming\n    AP::logger().Write_Event(LogEvent::ARMING_COMPLETE);\n\n    // record time we armed\n    armed_time_ms = AP_HAL::millis();\n\n    // update armed flag and log arming to dataflash\n    plane.set_armed(true, ArmingMethod::MAVLINK);\n\n    // send text of final arming status\n    if (old_mode != nullptr) {\n        old_mode->exit();\n    }\n\n    // re-read the control mode and update throttle trim\n    plane.reset_control_switch();\n\n    // flag we are now in the throttle checks\n    in_throttle_checks = true;\n\n    // return success\n    return true;\n}\n", "CodeBleu_score": 50.982551798476614}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    // don't allow arming unless home position is set\n    if (!AP::ahrs().home_is_set()) {\n        return false;\n    }\n\n    // don't allow arming until all sensors are calibrated\n    if (!AP_Arming::all_calibrations_complete()) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL,\"Can't arm yet. Waiting on sensor calibration.\");\n        return false;\n    }\n\n    // check if arming via the parameter interface is allowed\n    if (!arming_via_sensor_setup_allowed()) {\n        return false;\n    }\n\n    // check if arming via the parameter interface is allowed\n    if (!arming_via_rc_switch_allowed()) {\n        return false;\n    }\n\n    // if we are using the autopilot switches to arm/disarm but\n    // arming via mission command code is disabled, disallow arming/disarming\n    // via the rc switch\n    if (method == AP_Arming::Method::AUTOPILOT_SWITCH && !arming_via_mission_command_allowed()) {\n        return false;\n    }\n\n    // if we are disarming, and arming via mission command code is disabled, disallow arming/disarming\n    // via the rc switch\n    if (method == AP_Arming::Method::AUTOPILOT_SWITCH && !arming_via_mission_command_allowed()) {\n        return false;\n    }\n\n    // if the rotor is not spinning when we try to arm then\n    // the rotor has not initialised properly\n    if (method == AP_Arming::Method::AUTOPILOT_SWITCH && !SRV_Channels::get_output_scaled(SRV_Channel::k_sprayer_pump) && !SRV_Channels::get_output_scaled(SRV_Channel::k_sprayer_spinner)) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arm: Rotor Not Spinning\");\n        return false;\n    }\n\n    // if method is unknown, exit", "CodeBleu_score": 41.340074432977865}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    if (!_require_positive_throttle) {\n        // if we don't require positive throttle, we mark throttle as\n        // not-yet-armed. This allows for arming with a throttle below\n        // the min.\n        _flags.throttle_zero = false;\n    }\n\n    // remember method used\n    _method = method;\n\n    // return true immediately if already armed\n    if (_flags.armed) {\n        return true;\n    }\n\n    // run pre_arm_checks\n    if (!pre_arm_checks(do_arming_checks)) {\n        AP_Notify::events.arming_failed = true;\n        return false;\n    }\n\n    // check EKF origin has been set\n    Location temp_loc;\n    if (_ahrs.get_origin(temp_loc)) {\n        // if EKF origin has already been set, set home to current\n        // location, as we assume the pilot is already happy with\n        // the frame origin being here\n        set_home_persistently(temp_loc);\n    } else {\n        // EKF origin has not been set, set home to current location\n        set_home_persistently(_inav.get_position());\n    }\n\n    // update current location\n    _ahrs.set_home(home);\n\n    // arm motors\n    const bool ret = _arming.arm(method, do_arming_checks);\n\n    // return true if arming was successful\n    if (ret) {\n        // set system arm flag\n        _flags.armed = true;\n\n        // log flight mode in case it was changed while vehicle was disarmed\n        _logger.Write_Mode(control_mode->mode_number(), control_mode_reason);\n\n        // re-initialize the mission\n        mission.reset();\n        mission.init();\n\n        // flag that we are using in-air commands\n        _using_in_air_commands = true;\n\n        // log arming to dataflash\n        Log_Write_Event(DATA_ARMED);\n\n        // update notify object\n        AP_Notify::flags.armed =", "CodeBleu_score": 45.37641710677873}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    if (armed) {\n        return true;\n    }\n\n    if (!AP_Arming::pre_arm_checks(display_failure)) {\n        return false;\n    }\n\n    if (!AP_Arming::rc_calibration_checks(display_failure)) {\n        return false;\n    }\n\n    // check adsb avoidance failsafe\n    if (plane.failsafe.adsb) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"ADSB threat detected\");\n        }\n        return false;\n    }\n\n    // check throttle is not too low\n    if (plane.g.throttle_fs_enabled.get() && plane.g.throttle_fs_value != 0 && plane.channel_throttle->get_radio_in() < plane.g.throttle_fs_value) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"Check Throttle\");\n        }\n        return false;\n    }\n\n    // check if motor interlock and Emergency Stop aux switches are used\n    // at the same time.  This could cause a crash.\n    if (rc().find_channel_for_option(RC_Channel::AUX_FUNC::MOTOR_INTERLOCK) &&\n        rc().find_channel_for_option(RC_Channel::AUX_FUNC::MOTOR_ESTOP)){\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"Interlock/E-Stop Conflict\");\n        }\n        return false;\n    }\n\n    // check if motor interlock aux switch is in use\n    // if it is, switch needs to be in disabled position to arm\n    // if not it should be in enabled position\n    if (rc().find_channel_for_option(RC_Channel::AUX_FUNC::MOTOR_INTERLOCK)) {\n        if (rc().has_valid_input()) {\n            RC_Channel::A", "CodeBleu_score": 52.67140589754451}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    if (armed) {\n        return true;\n    }\n\n    if (!AP_Arming::pre_arm_checks(display_failure)) {\n        return false;\n    }\n\n    // check lean angle\n    if (aparm.angle_max < 1000 || aparm.angle_max > 8000) {\n        check_failed(display_failure, \"Check Lean Angle\");\n        return false;\n    }\n\n    // check tilt is less than roll\n    if (aparm.tilt_max > aparm.roll_max) {\n        check_failed(display_failure, \"Check Tilt\");\n        return false;\n    }\n\n    // check throttle is above failsafe throttle\n    if (plane.g.throttle_fs_value != 0 && plane.channel_throttle->get_radio_min() > plane.g.throttle_fs_value) {\n        check_failed(display_failure, \"Check Throttle\");\n        return false;\n    }\n\n    // check throttle is above failsafe throttle\n    if (plane.g.throttle_fs_enabled != 0 && plane.g.throttle_fs_value != 0) {\n        // normalise the throttle\n        float throttle = plane.receiver_rssi->get_throttle();\n        if (throttle > 0.0f && throttle < plane.g.throttle_fs_value) {\n            check_failed(display_failure, \"Check RC Throttle\");\n            return false;\n        }\n    }\n\n    // check if safety switch is set\n    if (hal.util->safety_switch_state() != AP_HAL::Util::SAFETY_DISARMED) {\n        check_failed(display_failure, \"Check Safety Switch\");\n        return false;\n    }\n\n    // if pre arm checks are disabled, return true\n    if (checks_to_perform == ARMING_CHECK_NONE) {\n        return true;", "CodeBleu_score": 53.60216146944888}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    // if already armed, return true\n    if (hal.util->get_soft_armed()) {\n        return true;\n    }\n\n    // if disarm button not configured, return failure\n    if (arming.get_disarm_level() == 0) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Disarm Button Not Configured\");\n        }\n        return false;\n    }\n\n    // return true if pre-arm checks are successful\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 63.693132743506645}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    float ne_x = cos(ahrs.get_yaw()) * x + sin(ahrs.get_yaw()) * y;\n    float ne_y = -sin(ahrs.get_yaw()) * x + cos(ahrs.get_yaw()) * y;\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 64.69745212083626}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    float ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n    float ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 61.21436179083206}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    float ne_x = x * cos(yaw) - y * sin(yaw);\n    float ne_y = x * sin(yaw) + y * cos(yaw);\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 56.006161570633026}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    // convert to absolute altitude\n    float angle_deg = packet.param1;\n    uint8_t relative_to = packet.param4;\n    float angle_rad;\n\n    // if relative_to is zero, use absolute angle\n    // if relative_to is 1, use relative angle\n    if (relative_to == 0) {\n        angle_rad = ToRad(angle_deg);\n    } else if (relative_to == 1) {\n        angle_rad = ToRad(angle_deg) + ahrs.yaw;\n    } else {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set yaw angle\n    if (is_zero(packet.param2)) {\n        condition_value = angle_rad;\n        return MAV_RESULT_ACCEPTED;\n    }\n\n    // set yaw rate\n    condition_value = angle_rad / packet.param2;\n    return MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 37.644635205587065}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    // convert the parameter values to radians\n    const float desired_yaw = radians(packet.param1);\n    const float angular_speed = radians(packet.param2);\n    const float direction = packet.param3;\n    const uint16_t relative_angle = packet.param4;\n\n    // validate yaw angle\n    if (!check_lat(desired_yaw)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // validate angular speed\n    if (!check_lat(angular_speed)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // validate direction\n    if (!check_lat(direction)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // validate relative angle\n    if (!check_lat(relative_angle)) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // set the yaw heading\n    sub.set_yaw_heading(desired_yaw, angular_speed, direction, relative_angle);\n\n    // return success\n    return MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 35.31678483414188}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    // sanity check location\n    if (!sub.control_check_barometer()) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // param1 : target angle in degrees\n    // param2 : speed during change in deg/second\n    // param3 : direction -1 ccw, +1 cw\n    // param4 : relative offset 1) Clockwise from true north, 0 means yaw angle absolute, -1 counter clockwise from true north\n    float angle_deg = packet.param1;\n    float speed_deg_s = packet.param2;\n    int8_t direction = packet.param3;\n    int8_t relative_to = packet.param4;\n\n    // check if speed is larger than zero\n    if (speed_deg_s <= 0.0f) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // check if relative to is supported\n    if (relative_to < -1 || relative_to > 1) {\n        return MAV_RESULT_DENIED;\n    }\n\n    // if the location is a mission waypoint\n    if (relative_to == 0) {\n        // get the lat, lon\n        if (!sub.set_yaw_location(angle_deg, speed_deg_s, direction, sub.GPS_lock)) {\n            return MAV_RESULT_FAILED;\n        }\n    } else {\n        // get the current lat, lon\n        Location_Class current_loc;\n        if (!sub.current_loc(current_loc)) {\n            return MAV_RESULT_FAILED;\n        }\n        // set the yaw angle\n        if (!sub.set_yaw_location(angle_deg, speed_deg_s, direction, current_loc, relative_to > 0)) {\n            return MAV_RESULT_FAILED;\n        }\n    }\n\n    return MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 32.7966639519124}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if (sub.control_mode == AUTO || sub.control_mode == GUIDED) {\n        return wrap_360_cd(sub.nav_controller->target_bearing_cd()) / 2;\n    }\n    return 0;\n}\n", "CodeBleu_score": 64.23495936802934}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if (sub.control_mode == AUTO || sub.control_mode == GUIDED) {\n        return wrap_360_cd(sub.nav_controller->target_bearing_cd()) / 200;\n    }\n    return 0;\n}\n", "CodeBleu_score": 68.63899407248758}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if (control_mode == AUTO || control_mode == GUIDED) {\n        return wrap_360_cd(wp_bearing_cd) / 200;\n    }\n    return 0;\n}\n", "CodeBleu_score": 44.18934821258125}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (LOGGING_ENABLED) {\n        // Create a log packet with the current time, log data ID, and value\n        log_t log_packet = {\n            .timestamp = AP_HAL::micros64(),\n            .id = (uint8_t)id,\n            .data = value\n        };\n\n        // Write the log packet to the logger as a critical block\n        logger.WriteBlock(&log_packet, sizeof(log_packet));\n    }\n}\n", "CodeBleu_score": 51.21036734765624}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (log_data_enabled) {\n        uint64_t time = AP_HAL::micros64();\n        struct log_Data_Int data;\n        data.time_us = time;\n        data.id = (uint8_t)id;\n        data.value = value;\n        logger.WriteCriticalBlock((const void *)&data, sizeof(data));\n    }\n}\n", "CodeBleu_score": 47.046456484146944}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)  if (!log_enabled) {\n    return;\n  }\n\n  // Create a log packet\n  log_packet_t packet = {\n    LOG_PACKET_HEADER_INIT(LOG_DATA_FMT),\n    time_keeper.get_ms(),\n    id,\n    value\n  };\n\n  // Write the packet\n  DataFlash.WriteCriticalBlock(&packet, sizeof(packet));\n}\n", "CodeBleu_score": 46.09191832080592}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()    if (home_is_set != HOME_UNSET) {\n        // already set\n        return;\n    }\n\n    // check EKF origin has been set\n    Location ekf_origin;\n    if (!ahrs.get_origin(ekf_origin)) {\n        return;\n    }\n\n    // set home to EKF origin\n    if (!set_home_to_current_location_inflight()) {\n        // EKF origin not yet set\n        return;\n    }\n\n    // we have successfully set AHRS home.  Set home_state to HOME_SET\n    set_home_state(HOME_SET);\n}\n", "CodeBleu_score": 28.018778815560946}, {"code": "void Sub::update_home_from_EKF()    // exit immediately if home is already set\n    if (ap.home_state != HOME_UNSET) {\n        return;\n    }\n\n    // if the motors are not armed, then we cannot set the home location\n    if (motors.armed()) {\n        // set home to current location\n        Location temp_loc;\n        temp_loc.lat = current_loc.lat;\n        temp_loc.lng = current_loc.lng;\n        temp_loc.alt = current_loc.alt;\n        if (!set_home(temp_loc, true)) {\n            // ignore failure\n        }\n    } else {\n        // try to set home to EKF location\n        set_home_to_current_location(true);\n    }\n}\n", "CodeBleu_score": 32.62064409655226}, {"code": "void Sub::update_home_from_EKF()    // exit immediately if home is already set\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if the motors are armed, set home to current location\n    if (motors.armed()) {\n        if (!set_home_to_current_location(false)) {\n            // ignore failure\n        }\n    } else {\n        // if the motors are not armed, set home to current ekf location\n        set_home_to_current_location(true);\n    }\n}\n", "CodeBleu_score": 54.205716032512456}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, copter.aparm.angle_max);\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());\n    target_climb_rate = constrain_float(target_climb_rate, -get_pilot_speed_dn(), g.pilot_speed_up);\n\n    // get avoidance adjusted climb rate\n    target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // run attitude controller\n    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());\n\n    // adjust climb rate using rangefinder\n    target_climb_rate = copter.surface_tracking.adjust_climb_rate(target_climb_rate);\n\n    // get avoidance adjusted climb rate\n    target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);\n\n    // call position controller\n    pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);\n    pos_control->update_z_controller();\n}\n", "CodeBleu_score": 50.11305360846903}, {"code": "void ModeAcro::run()    if (!motors->armed()) {\n        // Motors should be Stopped\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN);\n        // Reset attitude control targets\n        attitude_control->set_yaw_target_to_current_heading();\n        attitude_control->reset_rate_controller_I_terms();\n        // To-Do: reset rate controller I terms?\n        // call attitude controller\n        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0);\n        // reset z targets to current values\n        pos_control->relax_alt_hold_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    // To-Do: convert get_pilot_desired_lean_angles to return angles as floats\n    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, copter.aparm.angle_max);\n\n    // get pilot's desired yaw rate\n    target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // call attitude controller\n    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate);\n\n    // body-frame rate controller is run directly from 100hz loop\n\n    // output pilot's throttle without angle boost\n    attitude_control->set_throttle_out(get_pilot_desired_throttle(), false, copter.g.throttle_filt);\n\n    // get pilot desired climb rate\n    float target_", "CodeBleu_score": 55.03068352998983}, {"code": "void ModeAcro::run()    if (!motors->armed()) {\n        // Motors should be Stopped\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUT_DOWN);\n        // Attempting to Land\n        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    // To-Do: convert get_pilot_desired_lean_angles to return angles as floats\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, attitude_control->get_althold_lean_angle_max());\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // convert pilot input to body-frame rates\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());\n\n    // run attitude controller\n    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());\n\n    // output pilot's throttle without angle boost\n    attitude_control->set_throttle_out(target_climb_rate, false, g.throttle_filt);\n\n    // set forward and lateral outputs\n    motors->set_lateral(channel_forward->norm_input()*10", "CodeBleu_score": 59.09849765523051}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()    // initialise waypoint controller\n    wp_nav->wp_and_spline_init();\n\n    // initialise yaw\n    auto_yaw.set_mode(get_default_auto_yaw_mode(false));\n\n    // set guided_pos target to current position\n    Vector3f stopping_point;\n    wp_nav->get_wp_stopping_point(stopping_point);\n    guided_pos_target_cm = inertial_nav.get_position_xy_cm();\n\n    // constrain target position to within limits\n    guided_pos_target_cm.x = constrain_float(guided_pos_target_cm.x, -wp_nav->get_wp_radius(), wp_nav->get_wp_radius());\n    guided_pos_target_cm.y = constrain_float(guided_pos_target_cm.y, -wp_nav->get_wp_radius(), wp_nav->get_wp_radius());\n    guided_pos_target_cm.z = constrain_float(guided_pos_target_cm.z, -wp_nav->get_wp_radius(), wp_nav->get_wp_radius());\n\n    // if we are exactly at the waypoint with no spline, disable wpnav\n    // To-Do: Arducopter set is_zero to true if stopped...\n    if (wp_nav->reached_wp_destination()) {\n        // this will allow us to do a clean exit from guided mode\n        guided_pos_control_run = false;\n    }\n}\n", "CodeBleu_score": 40.050667017191245}, {"code": "void ModeGuided::guided_pos_control_start()    // initialise waypoint controller\n    wp_nav->wp_and_spline_init();\n\n    // initialise guided start time and position as reference for limit checking\n    guided_start_time_ms = AP_HAL::millis();\n    guided_start_pos = inertial_nav.get_position();\n\n    // set guided mode targets\n    guided_pos_target_cm.zero();\n    guided_vel_target_cms.zero();\n    guided_accel_target_cmss.zero();\n    update_time_ms = 0;\n\n    // pilot always controls yaw\n    auto_yaw.set_mode(AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 15.75024593581853}, {"code": "void ModeGuided::guided_pos_control_start()    // initialise waypoint controller\n    wp_nav->wp_and_spline_init();\n\n    // initialise guided start time and position as reference for limit checking\n    guided_start_time_ms = AP_HAL::millis();\n    guided_start_pos = inertial_nav.get_position();\n\n    // set guided mode targets\n    guided_pos_target_cm.zero();\n    guided_vel_target_cms.zero();\n    guided_accel_target_cmss.zero();\n    update_time_ms = AP_HAL::millis();\n\n    // pilot always controls yaw\n    auto_yaw.set_mode(AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 22.534250477344507}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()    // set vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g.pilot_speed_up, g.pilot_accel_z);\n\n    // initialise the vertical position controller\n    if (!pos_control->is_active_z()) {\n        pos_control->init_z_controller();\n    }\n\n    // initialise the lateral position controller\n    if (!pos_control->is_active_xy()) {\n        pos_control->init_xy_controller();\n    }\n\n    // set guided_mode to velocity controller\n    guided_mode = Guided_Velocity;\n\n    // set yaw to be auto controlled\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 46.87129779345584}, {"code": "void ModeGuided::guided_vel_control_start()    // set vertical speed and acceleration\n    pos_control->set_max_speed_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up());\n    pos_control->set_max_accel_z(wp_nav->get_accel_z());\n\n    // initialize vertical speeds and acceleration\n    pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise the vertical position controller\n    if (!pos_control->is_active_z()) {\n        pos_control->init_z_controller();\n    }\n\n    // set horizontal speed and acceleration\n    pos_control->set_max_speed_xy(wp_nav->get_default_speed_xy());\n    pos_control->set_max_accel_xy(wp_nav->get_accel_xy());\n\n    // initialise the horizontal position controller\n    if (!pos_control->is_active_xy()) {\n        pos_control->init_xy_controller();\n    }\n\n    // initialise yaw\n    set_auto_yaw_mode(AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 43.99768349818353}, {"code": "void ModeGuided::guided_vel_control_start()    // set vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise the vertical position controller\n    if (!pos_control->is_active_z()) {\n        pos_control->init_z_controller();\n    }\n\n    // initialise the lateral position controller\n    if (!pos_control->is_active_xy()) {\n        pos_control->init_xy_controller();\n    }\n\n    // set guided_mode to velocity controller\n    guided_mode = Guided_Velocity;\n\n    // initialise yaw\n    set_yaw_state(true, get_default_auto_yaw_rate_cds());\n}\n", "CodeBleu_score": 43.06679607981573}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()    // check if we have passed the timeout\n    if ((guided_state.time_start_us != 0) &&\n        (now - guided_state.time_start_us > guided_state.timeout_us)) {\n        return true;\n    }\n\n    // check if we have gone below min alt\n    if (guided_state.alt_above_home &&\n        current_loc.alt < guided_state.min_alt_cm) {\n        return true;\n    }\n\n    // check if we have gone above max alt\n    if (!guided_state.alt_above_home &&\n        current_loc.alt > guided_state.max_alt_cm) {\n        return true;\n    }\n\n    // check distance from origin\n    if (guided_state.target_dist_xy_cmin != 0.0f) {\n        float dist_xy_cmin = get_horizontal_distance_cm(guided_state.origin, current_loc);\n        if (dist_xy_cmin > guided_state.target_dist_xy_cmin) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be in auto flight mode\n    return false;\n}\n", "CodeBleu_score": 55.9825353444481}, {"code": "bool ModeGuided::guided_limit_check()    // check if we have passed the timeout\n    if ((millis() - guided_start_time) > guided_timeout && guided_timeout > 0) {\n        return true;\n    }\n\n    // get current location\n    const Location &loc = AP::ahrs().get_location();\n\n    // check if we have gone below min alt\n    if (!is_zero(guided_min_alt) && (loc.alt < guided_min_alt)) {\n        return true;\n    }\n\n    // check if we have gone above max alt\n    if (!is_zero(guided_max_alt) && (loc.alt > guided_max_alt)) {\n        return true;\n    }\n\n    // check distance from starting point\n    if (guided_mode != SubMode::WP && guided_mode != SubMode::PosVel && guided_mode != SubMode::TakeOff && guided_mode != SubMode::Land && guided_mode != SubMode::LoiterUnlim) {\n        if (get_distance(guided_start_loc, loc) > guided_limit_distance) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be in auto flight mode\n    return false;\n}\n", "CodeBleu_score": 47.84159597030354}, {"code": "bool ModeGuided::guided_limit_check()    // check if we have breached any limits\n    if (guided_state.timeout_ms != 0 &&\n        millis() - guided_state.start_time_ms > guided_state.timeout_ms) {\n        return true;\n    }\n\n    // check if we have gone below min alt\n    if (guided_state.alt_min > 0 && current_loc.alt < guided_state.alt_min) {\n        return true;\n    }\n\n    // check if we have gone above max alt\n    if (guided_state.alt_max > 0 && current_loc.alt > guided_state.alt_max) {\n        return true;\n    }\n\n    // check if horizontal control has breached limit\n    if (guided_state.horiz_max > 0) {\n        // get distance (in meters) moved from origin\n        const float dist_moved = get_horizontal_distance_cm() * 0.01f;\n        if (dist_moved > guided_state.horiz_max) {\n            return true;\n        }\n    }\n\n    // if we got this far we must be in keep going\n    return false;\n}\n", "CodeBleu_score": 54.068722080521134}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()    // check if motor test requests are received at least every 2 Hz\n    if (AP_HAL::millis() - last_test_req_ms > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Test Timeout\");\n        set_mode(ALT_HOLD);\n        disarm_motors();\n        failsafe_start_time = AP_HAL::millis();\n        return false;\n    }\n    return true;\n}\n", "CodeBleu_score": 41.33056707972689}, {"code": "bool Sub::verify_motor_test()    // check if motor test requests are received at least every 2 Hz\n    if (AP_HAL::millis() - last_test_req_ms > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test timeout\");\n        pass_flag = false;\n        disable_motor_test();\n        disarm_system();\n        record_failure(FAIL_MOTOR_TEST_TIMEOUT);\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 31.575148992015862}, {"code": "bool Sub::verify_motor_test()    // check if motor test requests are received at least every 2 Hz\n    if (AP_HAL::millis() - last_recv_timestamp > 500) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Motor test: timeout\");\n        pass_flag = false;\n        disable_motor_test();\n        disarm_system();\n        failure_time = AP_HAL::millis();\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 44.23717097559201}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav->get_roll();\n    forward_out = wp_nav->get_pitch();\n\n    // Constrain target forward/lateral values\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out  = (lateral_out / aparm.angle_max);\n    forward_out  = (forward_out / aparm.angle_max);\n}\n", "CodeBleu_score": 49.98693069118493}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)    // get pilot's desired yaw rate\n    float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // get pilot desired climb rate\n    float target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());\n\n    // get roll and pitch targets from waypoint controller\n    float roll_in, pitch_in;\n    translate_wpnav_rp(roll_in, pitch_in);\n\n    // constrain desired roll and pitch targets\n    roll_in = constrain_float(roll_in, -aparm.angle_max, aparm.angle_max);\n    pitch_in = constrain_float(pitch_in, -aparm.angle_max, aparm.angle_max);\n\n    // rotate roll and pitch targets from vehicle's perspective to body perspective\n    Matrix3f attitude_vehicle_to_body = ahrs.get_dcm().transposed();\n    Vector3f desired_angles_vehicle(roll_in, pitch_in, 0.0f);\n    Vector3f desired_angles_body = attitude_vehicle_to_body * desired_angles_vehicle;\n\n    // normalize roll and pitch targets\n    lateral_out = desired_angles_body.y / aparm.angle_max;\n    forward_out = desired_angles_body.x / aparm.angle_max;\n}\n", "CodeBleu_score": 46.34968172490378}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)    // get roll and pitch targets in centidegrees\n    lateral_out = wp_nav->get_roll();\n    forward_out = wp_nav->get_pitch();\n\n    // constrain target forward/lateral values\n    lateral_out = constrain_float(lateral_out, -aparm.angle_max, aparm.angle_max);\n    forward_out = constrain_float(forward_out, -aparm.angle_max, aparm.angle_max);\n\n    // Normalize\n    lateral_out  = (lateral_out / aparm.angle_max);\n    forward_out  = (forward_out / aparm.angle_max);\n}\n", "CodeBleu_score": 49.98693069118493}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()\n    // update barometer readings\n    barometer.read();\n\n    // update barometer health\n    barometer.update_health();\n\n    // if we are not calibrating, update the baro's altitude\n    if (!is_calibrating()) {\n\n        // update barometer's altitude\n        barometer.update_calibration();\n\n        // update altitude\n        barometer.update_altitude();\n\n        // if we have a depth sensor, update its health\n        if (depth_sensor.enabled()) {\n            depth_sensor.update_health(barometer.get_altitude());\n        }\n\n        // if we have a sonar, update its health\n        if (sonar.status() == RangeFinder::RangeFinder_Good) {\n            sonar.update_health(barometer.get_altitude());\n        }\n    }\n}\n", "CodeBleu_score": 49.34745606219016}, {"code": "void Sub::read_barometer()    // update barometer information\n    barometer.update();\n\n    // if we are using the rangefinder and it is healthy\n    if ((g.rangefinder_type != RANGEFINDER_TYPE_NONE) && (rangefinder.status() == RangeFinder::RangeFinder_Good)) {\n        // if the rangefinder does not have a valid altitude\n        if (!rangefinder.has_data(RangeFinder::RangeFinder_Altitude)) {\n            // calculate the local altitude\n            calc_rangefinder_alt();\n        }\n\n        // if we are not using GPS and the baro data is good\n        // and the rangefinder data is healthy\n        if ((gps.status() == AP_GPS::NO_GPS) &&\n            (barometer.all_healthy()) &&\n            (rangefinder.healthy(0))) {\n            // if the rangefinder altitude is above the baro altitude\n            if (rangefinder.get_altitude(0) > barometer.get_altitude()) {\n                // update the altitude using the rangefinder\n                // altitude\n                barometer.set_altitude(rangefinder.get_altitude(0));\n            }\n        }\n    }\n\n    // if we are not using the rangefinder and the altitude is above\n    // zero, update the barometer health using the altitude\n    if ((g.rangefinder_type == RANGEFINDER_TYPE_NONE) && (barometer.get_altitude() > 0)) {\n        barometer.update_health();\n    }\n\n    // if the barometer is healthy\n    if (barometer.all_healthy()) {\n        // calculate the climb rate in metres/s\n        float climb_rate = inertial_nav.get_velocity_z() + ahrs.get_baro_drift().z;\n\n        // update the state structure\n        state.altitude = barometer.get_altitude() * 100.0f;\n        state.healthy.alt = true;\n        state.airspeed_estimate = sqrtf(sq(state.velocity.x", "CodeBleu_score": 44.04428468760337}, {"code": "void Sub::read_barometer()    // update barometer health\n    barometer.update_health();\n\n    // return immediately during low pass filter calibration\n    if (barometer.get_state() == AP_Baro::BARO_UNHEALTHY) {\n        return;\n    }\n\n    // only update every 100ms\n    barometer_count++;\n    if ((barometer_count % 10) != 0) {\n        return;\n    }\n\n    barometer.update();\n\n    if (should_log(MASK_LOG_IMU)) {\n        DataFlash.Log_Write_Baro(barometer);\n    }\n\n    // update barometric altitude estimates\n    barometer.update_calibration();\n\n    // in-range update\n    if (sonar_enabled && (sonar.status() == RangeFinder::RangeFinder_Good)) {\n        float sonar_alt = sonar.distance_cm() * 0.01f;\n        barometer.update_sonar(sonar_alt);\n    }\n\n    // update ROS\n    if (ros_enabled) {\n        float alt = barometer.get_altitude();\n        float temp = barometer.get_temperature();\n        float press = barometer.get_pressure();\n        mavlink_msg_ros_sensor_send(\n            MAVLINK_COMM_0,\n            now(),\n            alt, // send altitude\n            temp, // send temperature\n            press // send pressure\n        );\n    }\n\n    // update rangefinder state\n    rangefinder_state.alt_healthy = sonar.pre_arm_check();\n\n    // update altitude target and resulting velocity\n    calc_throttle();\n}\n", "CodeBleu_score": 45.14036964742639}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()    // return false if ekf not yet initialised\n    if (!ahrs.healthy()) {\n        return false;\n    }\n\n    // ensure EKF position is ok\n    nav_filter_status filt_status = inertial_nav.get_filter_status();\n    return (!filt_status.flags.horiz_pos_abs && !filt_status.flags.pred_horiz_pos_abs);\n}\n", "CodeBleu_score": 54.80774963279953}, {"code": "bool Sub::ekf_position_ok()    // return false immediately if inertial nav is not available\n    if (!ahrs.healthy()) {\n        return false;\n    }\n\n    // return true immediately if we are not using inertial nav\n    if (!inertial_nav.get_filter_status()) {\n        return true;\n    }\n\n    // get EKF filter status\n    nav_filter_status filt_status = inertial_nav.get_filter_status();\n\n    // if disarmed we accept a predicted horizontal position\n    if (!motors.armed()) {\n        return (filt_status.flags.horiz_pos_abs && !filt_status.flags.pred_horiz_pos_abs);\n    }\n\n    // if position estimate is ok and never been in constant position mode\n    return (filt_status.flags.horiz_pos_abs && !filt_status.flags.pred_horiz_pos_abs && !filt_status.flags.const_pos_mode);\n}\n", "CodeBleu_score": 59.765073820345386}, {"code": "bool Sub::ekf_position_ok()    // return false immediately if ekf not yet initialised\n    if (!ahrs.healthy()) {\n        return false;\n    }\n\n    // get EKF filter status\n    nav_filter_status filt_status = inertial_nav.get_filter_status();\n\n    // if disarmed we accept a predicted position\n    if (!motors.armed()) {\n        return (filt_status.flags.horiz_pos_abs && filt_status.flags.pred_horiz_pos_abs);\n    }\n\n    // if in const_pos_mode, EKF vert position is unreliable\n    if (filt_status.flags.const_pos_mode) {\n        return false;\n    }\n\n    // if ekf failsafe, EKF vert position is unreliable\n    if (filt_status.flags.ekf_failsafe) {\n        return false;\n    }\n\n    // return true if ekf position height is ok\n    return filt_status.flags.horiz_pos_abs;\n}\n", "CodeBleu_score": 73.02933125561194}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    // check parent\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check AHRS has started\n    if (!rover.ahrs.healthy()) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"AHRS not healthy\");\n        return false;\n    }\n\n    // check EKF has started\n    if (!rover.ahrs.prearm_ekf_attitude_check()) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"EKF not healthy\");\n        return false;\n    }\n\n    // check we have a position estimate\n    if (!rover.ahrs.get_position(current_loc)) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"Need position estimate\");\n        return false;\n    }\n\n    // check home position is set\n    if (!AP::ahrs().home_is_set()) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"Need home position\");\n        return false;\n    }\n\n    // check position is valid\n    if (!rover.current_loc.lat || !rover.current_loc.lng) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"Invalid position\");\n        return false;\n    }\n\n    // check if ekf failsafe has triggered\n    if (rover.g2.failsafe_gps) {\n        check_failed(ARMING_CHECK_NONE, display_failure, \"EKF failsafe\");\n        return false;\n    }\n\n    // return true immediately if gps checks are disabled\n    if (checks_to_perform == ARMING_CHECK_NONE) {\n        return true;\n    }\n\n    // check if we are using GPS\n    if (rover.control_mode != &rover.mode_guided && rover.control_mode != &rover.mode_avoid_adsb && rover.control_mode != &", "CodeBleu_score": 57.69333806307597}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    if (!rover.control_mode->requires_position() && !rover.control_mode->requires_velocity()) {\n        return true;\n    }\n\n    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // Check EKF compass is healthy\n    if (rover.ahrs.get_compass_health() <= 0) {\n        check_failed(display_failure, \"EKF compass not healthy\");\n        return false;\n    }\n\n    // ensure position estimate is ok\n    if (!rover.ekf_position_ok() || rover.ekf_velocity_ok()) {\n        check_failed(display_failure, \"EKF not healthy\");\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 55.742073953175186}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    // call parent class checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // ensure ahrs is healthy\n    if (!rover.ahrs.healthy()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: AHRS not healthy\");\n        }\n        return false;\n    }\n\n    // check ekf has started and is ok\n    if (!rover.ahrs.get_NavEKF2().healthy()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: EKF not healthy\");\n        }\n        return false;\n    }\n\n    // check position estimate is ok\n    if ((rover.current_loc.lat == 0) && (rover.current_loc.lng == 0)) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: Need position estimate\");\n        }\n        return false;\n    }\n\n    // if we have a position estimate then ensure it is recent\n    if (rover.current_loc.age_ms() > AP_ARMING_REQUIRE_POSITION_MS) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL,\"PreArm: position estimate too old\");\n        }\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 53.21267475209426}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    if (!_rover.control_mode->do_user_takeoff_start(method == AP_Arming::Method::USER)) {\n        return false;\n    }\n\n    // check vehicle is close to ground\n    if (do_arming_checks && !_rover.g2.soaring_controller.is_soaring()) {\n        if (!_rover.is_balance_bot()) {\n            // check if we are using motor interlock and try to turn on the motor\n            if (method == AP_Arming::Method::MAVLINK && _rover.arming.is_motor_interlock_enabled()) {\n                _rover.g2.motors.set_interlock(true);\n            }\n            if (!_rover.is_balance_bot() && !_rover.control_mode->has_manual_throttle() && !_rover.failsafe.radio) {\n                // none of the conditions to arm were met\n                return false;\n            }\n        }\n    }\n\n    // check throttle is not too high\n    if (do_arming_checks &&\n        _rover.g2.motors.get_spool_state() == AP_Motors::SpoolState::THROTTLE_UNLIMITED &&\n        _rover.channel_throttle->get_servo_out() > _rover.g.throttle_max) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL,\"Arm: Collective too high\");\n        return false;\n    }\n\n    // check if safety switch has been pushed\n    if (do_arming_checks && _rover.safety_check(_arm_safety_on)) {\n        return false;\n    }\n\n    // call parent class method that actually arms motors\n    return AP_Arming::arm(method, do_arming_checks);\n}\n", "CodeBleu_score": 48.701859895801526}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    if (armed) {\n        return true;\n    }\n\n    if (method == AP_Arming::Method::AUTO) {\n        // try to arm using the current arming method\n        method = arming_method;\n    } else {\n        // store the arming method for future arming attempts\n        arming_method = method;\n    }\n\n    // perform pre-arm checks. arming is always done from the ground station\n    // or with a script.  do not allow arming via a mavlink or rc aux\n    // command\n    if (method == AP_Arming::Method::MAVLINK ||\n        method == AP_Arming::Method::RC) {\n        return false;\n    }\n\n    // don't allow arming via USB if USB lockout is enabled\n    if (rover.g.usb_lockout && rover.channel_usb.get_RC_in() <= 900) {\n        return false;\n    }\n\n    // do not allow arming if we are landed unless check is disabled\n    if (do_arming_checks && !AP::ahrs().home_is_set()) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Disallowing arming: Home location not set\");\n        return false;\n    }\n\n    // do not allow arming if we are landed unless check is disabled\n    if (do_arming_checks && rover.failsafe.radio) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Disallowing arming: radio failsafe\");\n        return false;\n    }\n\n    // do not allow arming if we are landed unless check is disabled\n    if (do_arming_checks && rover.failsafe.battery) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Disallowing arming: low battery\");\n        return false;\n    }\n\n    // do not allow arming if we are landed unless check is disabled\n    if (do_arming_checks && rover.failsafe.gcs) {\n        gcs().send_text(MA", "CodeBleu_score": 45.31226180724252}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    if (!rover.control_mode->do_user_takeoff_start(method == AP_Arming::Method::USER)) {\n        return false;\n    }\n\n    if (do_arming_checks && !rover.control_mode->do_pre_arm_checks(true)) {\n        return false;\n    }\n\n    // don't allow arming via INTERNAL methods except for when arming from the ground station\n    if (method == AP_Arming::Method::INTERNAL && !rover.failsafe.radio) {\n        return false;\n    }\n\n    // don't allow arming while still on the ground\n    if (rover.g2.sailboat.enabled() &&\n        !rover.g2.sailboat.sail_enabled() &&\n        rover.control_mode != &rover.mode_hold) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arm: Must be in HOLD with sail enabled\");\n        return false;\n    }\n\n    if (method == AP_Arming::Method::ZIGZAG) {\n        // ZigZag should have been handled as a failsafe\n        // per DO_SET_MODE\n        return false;\n    }\n\n    // if method is set to ZIGZAG but failsafe did not activate\n    // then arming failed\n    if (method == AP_Arming::Method::ZIGZAG) {\n        return false;\n    }\n\n    // set smart RTL home location\n    if (rover.g2.smart_rtl && rover.g2.smart_rtl->is_activated()) {\n        rover.g2.smart_rtl->set_home(true);\n    }\n\n    // initialise smart_rtl heading\n    rover.mode_smartrtl.init();\n\n    // record home position\n    rover.home_is_set = true;\n    rover.ahrs.set_home(rover.current_loc);\n\n    // set rtl home location\n    if (rover.g2.sailboat.enabled()) {\n        rover.g", "CodeBleu_score": 45.91060664798776}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()    if (charging_allowed) {\n        if (!charging_enabled) {\n            charging_enabled = true;\n            charging_enabled_time = millis();\n        }\n    } else {\n        if (charging_enabled) {\n            if (millis() - charging_enabled_time >= CHARGING_DISABLE_TIME) {\n                charging_enabled = false;\n                charging_enabled_time = millis();\n            }\n        } else {\n            if (millis() - charging_enabled_time >= CHARGING_RETRY_TIME) {\n                if (checkConditions()) {\n                    charging_enabled = true;\n                    charging_enabled_time = millis();\n                } else {\n                    charging_enabled_time = millis();\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 48.02308161404619}, {"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (!charging_enabled) {\n      charging_enabled = true;\n      digitalWrite(CHARGE_PIN, HIGH);\n      charging_start_time = millis();\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      digitalWrite(CHARGE_PIN, LOW);\n      charging_stop_time = millis();\n      charging_allowed = true;\n    } else {\n      if (millis() - charging_stop_time >= CHARGING_RETRY_DELAY) {\n        if (checkChargingConditions()) {\n          charging_allowed = true;\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 58.3705599079738}, {"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (!charging_enabled) {\n      charging_enabled = true;\n      digitalWrite(CHARGE_PIN, HIGH);\n      charging_start_time = millis();\n      charging_last_time = charging_start_time;\n      charging_last_voltage = getBatteryVoltage();\n    }\n  } else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      digitalWrite(CHARGE_PIN, LOW);\n      charging_stop_time = millis();\n      charging_last_time = charging_stop_time;\n      charging_last_voltage = getBatteryVoltage();\n    }\n  }\n}\n", "CodeBleu_score": 51.6346505044999}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)  if (ros_connected && size >= 4) {\n    uint8_t *msg = (uint8_t*)message;\n    uint8_t crc = 0;\n    for (size_t i = 0; i < size; i++) {\n      crc = crc8_dvb_s2(crc, msg[i]);\n    }\n    msg[size] = crc;\n    packetSerial.send(msg, size + 1);\n  }\n}\n", "CodeBleu_score": 43.370557030010325}, {"code": "void sendMessage(void *message, size_t size)    if (ros_running && size >= 4) {\n        uint16_t crc = crc16((uint8_t *)message, size);\n        uint8_t *message_with_crc = (uint8_t *)malloc(size + 2);\n        memcpy(message_with_crc, message, size);\n        message_with_crc[size] = crc >> 8;\n        message_with_crc[size + 1] = crc & 0xFF;\n        packetSerial.send(message_with_crc, size + 2);\n        free(message_with_crc);\n    }\n}\n", "CodeBleu_score": 54.253649483578506}, {"code": "void sendMessage(void *message, size_t size)    if (ros_connected) {\n        if (size < 4) {\n            return;\n        }\n\n        // Calculate the CRC\n        uint32_t crc = 0;\n        for (size_t i = 0; i < size - 4; i++) {\n            crc += ((uint8_t *)message)[i];\n        }\n\n        // Append the CRC to the message\n        ((uint8_t *)message)[size - 4] = crc >> 24;\n        ((uint8_t *)message)[size - 3] = crc >> 16;\n        ((uint8_t *)message)[size - 2] = crc >> 8;\n        ((uint8_t *)message)[size - 1] = crc;\n\n        // Send the message\n        packetSerial.send((uint8_t *)message, size);\n    }\n}\n", "CodeBleu_score": 59.2611702514227}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()  _serial->begin(9600);\n  _serial->flush();\n  clearBuffer();\n  delay(100);\n  _serial->write(0x7E);\n  _serial->write(0xFF);\n  _serial->write(0x06);\n  _serial->write(0x01);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0xEF);\n  delay(2000);\n  clearBuffer();\n  _serial->write(0x7E);\n  _serial->write(0xFF);\n  _serial->write(0x06);\n  _serial->write(0x09);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0xEF);\n  delay(1000);\n  clearBuffer();\n  _serial->write(0x7E);\n  _serial->write(0xFF);\n  _serial->write(0x06);\n  _serial->write(0x0C);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);\n  _serial->write(0x00);", "CodeBleu_score": 38.02494909655542}, {"code": "bool MP3Sound::begin()  Serial1.begin(9600);\n  clearBuffer();\n  if (!initSoundModule()) {\n    return false;\n  }\n  numFiles = getNumFiles();\n  return numFiles > 0;\n}\n", "CodeBleu_score": 26.565575613138925}, {"code": "bool MP3Sound::begin()  Serial1.begin(9600);\n  clearBuffer();\n  if (initializeModule()) {\n    if (getNumberOfSounds() > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n", "CodeBleu_score": 20.231693178745658}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()  if (activeSounds.size() == 0) {\n    return 0;\n  }\n\n  if (mp3.isPlaying()) {\n    return activeSounds.size();\n  }\n\n  String sound = activeSounds.get(activeSounds.size() - 1);\n  activeSounds.remove(activeSounds.size() - 1);\n\n  mp3.play(sound);\n\n  return activeSounds.size();\n}\n", "CodeBleu_score": 44.536554758078104}, {"code": "int MP3Sound::processSounds()    if (activeSounds.size() == 0) {\n        return 0;\n    }\n    if (mp3.isPlaying()) {\n        return activeSounds.size();\n    }\n    String sound = activeSounds.get(activeSounds.size() - 1);\n    activeSounds.remove(activeSounds.size() - 1);\n    playSound(sound);\n    return activeSounds.size();\n}\n", "CodeBleu_score": 38.304809730382}, {"code": "int MP3Sound::processSounds()  if (activeSounds.size() == 0) {\n    return 0;\n  }\n  if (isPlaying()) {\n    return activeSounds.size();\n  }\n  MP3Sound *sound = activeSounds.back();\n  activeSounds.pop_back();\n  sound->play();\n  return activeSounds.size();\n}\n", "CodeBleu_score": 41.44335884449071}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      if (camera->m_memoryMappedFile != NULL) {\n        wb_abstract_camera_cleanup_memory_mapped_file(camera);\n        camera->m_memoryMappedFile = NULL;\n      }\n      camera->m_memoryMappedFile = wb_abstract_camera_setup_memory_mapped_file(camera, r);\n      return true;\n    default:\n      return false;\n  }\n}\n", "CodeBleu_score": 35.66323520567204}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (camera->memory_mapped_file != NULL) {\n      wb_camera_cleanup_memory_mapped_file(camera);\n      camera->memory_mapped_file = NULL;\n    }\n    wb_camera_setup_memory_mapped_file(camera, r);\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 25.549892211437463}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *camera = (WbAbstractCamera *)d;\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    wb_abstract_camera_cleanup_memory_mapped_file(camera);\n    wb_abstract_camera_setup_memory_mapped_file(camera, r);\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 22.875681564034252}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)  AbstractCamera *ac = d->pdata;\n  int height = -1;\n  if (ac) {\n    pthread_mutex_lock(&ac->mutex);\n    if (ac->image)\n      height = ac->image->height;\n    pthread_mutex_unlock(&ac->mutex);\n  }\n  return height;\n}\n", "CodeBleu_score": 50.7841074843288}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  int height = -1;\n\n  if (d->data) {\n    wb_mutex_lock(d->mutex);\n    height = d->data->camera->height;\n    wb_mutex_unlock(d->mutex);\n  }\n\n  return height;\n}\n", "CodeBleu_score": 43.826204304466714}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  AbstractCamera *ac = (AbstractCamera *)d->pdata;\n  int height = -1;\n  if (ac->image) {\n    height = ac->image->height;\n    if (ac->image->depth == 1)\n      height /= ac->image->width;\n  }\n  return height;\n}\n", "CodeBleu_score": 44.52625881801914}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period;\n  WbAccelerometer *accelerometer;\n\n  accelerometer = wb_accelerometer_get_device(tag);\n  if (accelerometer == NULL) {\n    fprintf(stderr, \"Error: %s() called with an invalid device tag.\\n\", __FUNCTION__);\n    return 0;\n  }\n\n  pthread_mutex_lock(&accelerometer->mutex);\n  sampling_period = accelerometer->sampling_period;\n  pthread_mutex_unlock(&accelerometer->mutex);\n\n  return sampling_period;\n}\n", "CodeBleu_score": 54.91098828443683}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period = -1;\n\n  struct WbAccelerometer *accelerometer = wb_accelerometer_get_device(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else {\n    fprintf(stderr, \"Error: %s() called for an invalid device tag.\\n\", __FUNCTION__);\n  }\n\n  return sampling_period;\n}\n", "CodeBleu_score": 48.4268915599106}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period = 0;\n  wb_accelerometer_get_values(tag, &sampling_period);\n  return sampling_period;\n}\n", "CodeBleu_score": 21.825027241799724}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result(dms);\n    free(dms);\n    return result;\n}\n", "CodeBleu_score": 39.356925641872465}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dmsString(dms);\n  free(dms);\n  return dmsString;\n}\n", "CodeBleu_score": 40.283402089230336}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string dmsString(dms);\n  free(dms);\n  return dmsString;\n}\n", "CodeBleu_score": 40.283402089230336}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)    dVector3 p, n;\n    dReal d, *sides;\n    int i;\n\n    // Check that the geometry is a box\n    dGeomBoxGetLengths(g, &sides[0], &sides[1], &sides[2]);\n\n    // Compute the relative position of the point to the box center\n    p[0] = x - g->pos[0];\n    p[1] = y - g->pos[1];\n    p[2] = z - g->pos[2];\n\n    // Initialize the plane normal and distance\n    plane[0] = 0;\n    plane[1] = 0;\n    plane[2] = 0;\n    plane[3] = 0;\n\n    // Check each axis for proximity to the box's surface\n    for (i = 0; i < 3; i++) {\n        n[0] = n[1] = n[2] = 0;\n        n[i] = 1;\n\n        // Compute the distance from the point to the plane\n        d = dDOT(n, p) - sides[i] / 2;\n\n        // If the point is closer to the surface, update the plane\n        if (fabs(d) < fabs(plane[3]) || plane[3] == 0) {\n            plane[0] = n[0];\n            plane[1] = n[1];\n            plane[2] = n[2];\n            plane[3] = d;\n        }\n    }\n}\n", "CodeBleu_score": 34.63330616671144}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)    dVector3 n, p;\n    dReal d;\n    dGeomBoxGetLengths(g, n);\n    p[0] = x; p[1] = y; p[2] = z;\n    p[0] -= g->pos[0];\n    p[1] -= g->pos[1];\n    p[2] -= g->pos[2];\n    d = dDOT(n, p);\n    if (d <= -n[0]) {\n        plane[0] = -1; plane[1] = 0; plane[2] = 0; plane[3] = n[0];\n    } else if (d >= n[0]) {\n        plane[0] = 1; plane[1] = 0; plane[2] = 0; plane[3] = n[0];\n    } else if (p[1] <= -n[1]) {\n        plane[0] = 0; plane[1] = -1; plane[2] = 0; plane[3] = n[1];\n    } else if (p[1] >= n[1]) {\n        plane[0] = 0; plane[1] = 1; plane[2] = 0; plane[3] = n[1];\n    } else if (p[2] <= -n[2]) {\n        plane[0] = 0; plane[1] = 0; plane[2] = -1; plane[3] = n[2];\n    } else {\n        plane[0] = 0; plane[1] = 0; plane[2] = 1; plane[3] = n[2];\n    }\n}\n\n", "CodeBleu_score": 27.31309872514991}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)    dxGeom *g1;\n    dVector3 p, n;\n    dReal d, d1;\n    int i;\n\n    g1 = (dxGeom*) g;\n\n    dGeomBoxGetLengths (g, plane+3, plane+4, plane+5);\n    p[0] = x - g1->pos[0];\n    p[1] = y - g1->pos[1];\n    p[2] = z - g1->pos[2];\n    d = dInfinity;\n    for (i=0; i<3; i++) {\n        d1 = dFabs(p[i]) - plane[3+i];\n        if (d1 < d) {\n            d = d1;\n            n[0] = n[1] = n[2] = 0;\n            n[i] = p[i] >= 0 ? 1 : -1;\n        }\n    }\n    plane[0] = n[0];\n    plane[1] = n[1];\n    plane[2] = n[2];\n}\n\n", "CodeBleu_score": 32.53735228161265}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  dImmersionData data;\n  dReal point[3], normal[3];\n  int i;\n\n  assert (box->body);\n  assert (flags & (dIMMERSE_SURFACE_NORMALS | dIMMERSE_WATER_LINE));\n\n  data.immersion = immersion;\n  data.flags = flags;\n  data.fluidPlane = fluidPlane;\n  data.box = box;\n  data.depth = 0.0;\n  data.numPoints = 0;\n\n  for (i=0; i<3; i++) {\n    point[0] = box->pos[0] + box->R[0*4+i] * box->side[i];\n    point[1] = box->pos[1] + box->R[1*4+i] * box->side[i];\n    point[2] = box->pos[2] + box->R[2*4+i] * box->side[i];\n    if (dImmersePoint (point, fluidPlane, flags, &data)) return 1;\n  }\n  for (i=0; i<3; i++) {\n    point[0] = box->pos[0] + box->R[0*4+i] * box->side[i];\n    point[1] = box->pos[1] + box->R[1*4+i] * box->side[i];\n    point[2] = box->pos[2] + box->R[2*4+i] * box->side[i];\n    normal[0] = -box->R[0*4+i];\n    normal[1] = -box->R[1*4+i];\n    normal[2] = -box->R[2*4+i];\n    if (dImmerseLine (point, normal, fluidPlane, flags, &data)) return 1;\n  }\n  return 0;\n}\n\n", "CodeBleu_score": 38.900713231834494}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  dReal p[4], n[4];\n  dReal boxP[3], boxR[3];\n  dReal fluidP[3], fluidN[3];\n  dReal boxRadius;\n  dReal dist;\n  dReal nDot;\n  dReal nDot2;\n  dReal nDot3;\n  dReal nDot4;\n  dReal nDot5;\n  dReal nDot6;\n  dReal nDot7;\n  dReal nDot8;\n  dReal nDot9;\n  dReal nDot10;\n  dReal nDot11;\n  dReal nDot12;\n  dReal nDot13;\n  dReal nDot14;\n  dReal nDot15;\n  dReal nDot16;\n  dReal nDot17;\n  dReal nDot18;\n  dReal nDot19;\n  dReal nDot20;\n  dReal nDot21;\n  dReal nDot22;\n  dReal nDot23;\n  dReal nDot24;\n  dReal nDot25;\n  dReal nDot26;\n  dReal nDot27;\n  dReal nDot28;\n  dReal nDot29;\n  dReal nDot30;\n  dReal nDot31;\n  dReal nDot32;\n  dReal nDot33;\n  dReal nDot34;\n  dReal nDot35;\n  dReal nDot36;\n  dReal nDot37;\n  dReal nDot38;\n  dReal nDot39;\n  dReal nDot40;\n  dReal nDot41;\n  dReal nDot42;\n  dReal nDot43;\n  dReal nDot44;\n  dReal nDot45;\n  dReal nDot46;\n  dReal nDot47", "CodeBleu_score": 8.291993390749337}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)   dReal p[3], n[3], v[3];\n   dReal aabb[2][3];\n   int i;\n   sBoxImmersionData data;\n\n   // assert that the box has a body\n   if (!box->body) return 0;\n\n   // assert that the flags are valid\n   if (flags & ~(dIMMERSE_SURFACE_NORMALS | dIMMERSE_RETURN_VALUE)) return 0;\n\n   // initialize the immersion data\n   data.box = box;\n   data.fluidPlane = fluidPlane;\n   data.flags = flags;\n   data.immersion = immersion;\n   data.immersion->depth = 0;\n\n   // get the box's position\n   dBodyGetPosition(box->body, p);\n\n   // get the box's rotation\n   dBodyGetRotation(box->body, data.R);\n\n   // transform the fluid plane normal into the box's local coordinate system\n   dMULTIPLY0_331(n, data.R, fluidPlane);\n\n   // get the box's linear velocity\n   dBodyGetLinearVel(box->body, v);\n\n   // get the box's angular velocity\n   dBodyGetAngularVel(box->body, data.omega);\n\n   // get the box's AABB\n   dGeomGetAABB(box->geom, aabb[0], aabb[1]);\n\n   // check for immersion in each of the box's corners\n   for (i = 0; i < 8; i++) {\n      // set the corner point\n      p[0] = (i & 1) ? aabb[0][0] : aabb[1][0];\n      p[1] = (i & 2) ? aabb[0][1] : aabb[1][1];\n      p[2] = (i & 4) ? aabb[0][2] : aabb[1][2];\n\n      // check for immersion at the corner point\n      if (dImmer", "CodeBleu_score": 40.05285336757453}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    int ret = 0;\n    dReal a[3], b[3], c[3], R, r;\n    dReal p[3], q[3], depth;\n    dReal normal[3];\n    dReal *params;\n    dReal point[3], normal[3];\n    dReal depth;\n    dReal radius;\n    dReal *params;\n    int code;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;\n    int i;\n    int n;\n    int inside;\n    int ret;", "CodeBleu_score": 21.7539125645624}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    dVector3 p, a, b, c, d, e, f, g, h, v, w;\n    dReal h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11, h12, h13, h14, h15, h16, h17, h18, h19, h20, h21, h22, h23, h24, h25, h26, h27, h28, h29, h30, h31, h32, h33, h34, h35, h36, h37, h38, h39, h40, h41, h42, h43, h44, h45, h46, h47, h48, h49, h50, h51, h52, h53, h54, h55, h56, h57, h58, h59, h60, h61, h62, h63, h64, h65, h66, h67, h68, h69, h70, h71, h72, h73, h74, h75, h76, h77, h78, h79, h80, h81, h82, h83, h84, h85, h86, h87, h88, h89, h90, h91, h92, h93, h94, h95, h96, h97, h98, h99, h100, h101, h102, h103, h104, h105, h106, h107, h108, h109, h110, h111, h112, h113, h114, h115, h116, h117, h1", "CodeBleu_score": 6.69196941709041}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    dReal a[3], b[3], c[3], d[3], e[3], f[3], g[3];\n    dReal radius, length;\n    dReal p[3], q[3];\n    dReal depth;\n    int code;\n    dVector3 side;\n    dVector3 normal;\n    dVector3 point;\n    dVector3 dir;\n    dVector3 r;\n    dReal nr;\n    dReal rn;\n    dReal rd;\n    dReal rp;\n    dReal rq;\n    dReal rr;\n    dReal rs;\n    dReal rt;\n    dReal rv;\n    dReal rw;\n    dReal rx;\n    dReal ry;\n    dReal rz;\n    dReal s;\n    dReal t;\n    dReal u;\n    dReal v;\n    dReal w;\n    dReal x;\n    dReal y;\n    dReal z;\n    dReal r;\n    dReal s;\n    dReal t;\n    dReal u;\n    dReal v;\n    dReal w;\n    dReal x;\n    dReal y;\n    dReal z;\n    dReal r;\n    dReal s;\n    dReal t;\n    dReal u;\n    dReal v;\n    dReal w;\n    dReal x;\n    dReal y;\n    dReal z;\n    dReal r;\n    dReal s;\n    dReal t;\n    dReal u;\n    dReal v;\n    dReal w;\n    dReal x;\n    dReal y;\n    dReal z;\n    dReal r;\n    dReal s;\n    dReal t;\n    dReal u;\n    dReal v;\n    dReal w;\n    dReal x;\n    dReal y;\n    dReal z;\n    dReal r;\n    dReal s;\n    dReal t;\n    dReal u;\n    dReal v;\n    dReal w;\n    dReal x;\n    dReal y;\n    dReal z;\n    dReal r;", "CodeBleu_score": 31.36620374430889}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\n\t// Variable declaration\n\tdReal volume = 0.0;\n\tdReal tanTheta = 0.0;\n\tdReal sinTheta = 0.0;\n\tdReal cosTheta = 0.0;\n\tdReal tanThetaSquared = 0.0;\n\tdReal sinThetaSquared = 0.0;\n\tdReal cosThetaSquared = 0.0;\n\tdReal tanThetaCubed = 0.0;\n\tdReal sinThetaCubed = 0.0;\n\tdReal cosThetaCubed = 0.0;\n\tdReal tanThetaQuartic = 0.0;\n\tdReal sinThetaQuartic = 0.0;\n\tdReal cosThetaQuartic = 0.0;\n\tdReal tanThetaQuintic = 0.0;\n\tdReal sinThetaQuintic = 0.0;\n\tdReal cosThetaQuintic = 0.0;\n\tdReal tanThetaSextic = 0.0;\n\tdReal sinThetaSextic = 0.0;\n\tdReal cosThetaSextic = 0.0;\n\tdReal tanThetaSeptic = 0.0;\n\tdReal sinThetaSeptic = 0.0;\n\tdReal cosThetaSeptic = 0.0;\n\tdReal tanThetaOctic = 0.0;\n\tdReal sinThetaOctic = 0.0;\n\tdReal cosThetaOctic = 0.0;\n\tdReal tanThetaNonic = 0.0;\n\tdReal sinThetaNonic = 0.0;\n\tdReal cosThetaNonic = 0.0;\n\tdReal tanThetaDecic = 0.0;\n\tdReal sinThetaDecic = 0.0;\n\tdReal cosThetaDecic = 0.0;\n\tdReal tanThetaTridecic = 0.0;\n\tdReal sinThetaTridecic = 0.0;\n\tdReal cosThetaTridecic = 0.0;\n\tdReal tanThetaTetradecic = 0.0;\n\tdReal sinThetaTetradecic = 0.0;\n\tdReal cosThetaTetradecic = 0.0;\n\tdReal tan", "CodeBleu_score": 11.555835601165652}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const    // Calculate the volume of the hemisphere\n    dReal volume = normalizedImmersedHemisphereVolume(zIOverR, tanTheta0, sinTheta1, 0.0, 1.0);\n\n    // Return the normalized volume\n    return volume / (dReal) (4.0 * M_PI);\n}\n", "CodeBleu_score": 20.94557707794087}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const  // Check if the input is valid\n  if (zIOverR < -1.0 || zIOverR > 1.0 || tanTheta0 < 0.0 || sinTheta1 < 0.0) {\n    return 0.0;\n  }\n\n  // Calculate the lower limit of integration\n  dReal lowerLimit = std::max(0.0, zIOverR);\n\n  // Calculate the upper limit of integration\n  dReal upperLimit = std::sqrt(1.0 - zIOverR * zIOverR);\n\n  // Calculate the step size for Simpson's rule\n  dReal step = (upperLimit - lowerLimit) / (dReal) NUM_STEPS;\n\n  // Initialize the sum variable for Simpson's rule\n  dReal sum = 0.0;\n\n  // Perform Simpson's rule for the first half of the integration interval\n  for (int i = 0; i < NUM_STEPS / 2; i++) {\n    dReal x = lowerLimit + step * (2 * i + 1);\n    dReal y = std::sqrt(1.0 - x * x);\n    dReal z = zIOverR;\n    dReal r = std::sqrt(x * x + y * y + z * z);\n    dReal sinTheta = y / r;\n    dReal tanTheta = tanTheta0 + sinTheta * sinTheta1 / std::sqrt(1.0 - sinTheta * sinTheta);\n    dReal volume = step * (r * r * std::sqrt(1.0 + tanTheta * tanTheta) / 2.0);\n    sum += volume;\n  }\n\n  // Perform Simpson's rule for the second half of the integration interval\n  for (int i = 0; i < NUM_STEPS / 2; i++) {\n    dReal x = lowerLimit + step * (2 * i + 2);\n    dReal y = std::sqrt(1.0 - x * x);\n    dReal z = zIOverR;\n    dReal r = std::sqrt(x * x + y * y + z * z);\n    dReal sinTheta = y / r", "CodeBleu_score": 41.5293988376313}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const    // Calculate the x-coordinate of the buoyancy center using Simpson's rule\n    dReal xBuoyancyCenter = (zIOverR * tanTheta0 + sinTheta1) / 3.0;\n    // Scale the x-coordinate by the radius and adjust by the volume\n    return xBuoyancyCenter * radius * volume;\n}\n", "CodeBleu_score": 32.885476964724894}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const    dReal x = 0;\n    dReal theta = theta0;\n    while (theta < theta1) {\n        dReal sinTheta = sin(theta);\n        dReal cosTheta = cos(theta);\n        dReal dTheta = thetaStep;\n        dReal sinThetaPlus = sin(theta + dTheta);\n        dReal cosThetaPlus = cos(theta + dTheta);\n        dReal sinThetaMinus = sin(theta - dTheta);\n        dReal cosThetaMinus = cos(theta - dTheta);\n        dReal x0 = (R * zIOverR * sinTheta0 * cosTheta0 + R * zIOverR * sinTheta * cosTheta) / 3;\n        dReal x1 = (R * zIOverR * sinTheta * cosTheta + R * zIOverR * sinThetaPlus * cosThetaPlus) / 3;\n        dReal x2 = (R * zIOverR * sinThetaPlus * cosThetaPlus + R * zIOverR * sinTheta1 * cosTheta1) / 3;\n        x += volume * (x0 + 4 * x1 + x2);\n        theta += dTheta;\n    }\n    return x;\n}\n", "CodeBleu_score": 38.031463967725024}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\n    // Calculate the number of segments for Simpson's rule based on the volume\n    int n = int(volume * 1000000);\n    if (n < 10) n = 10;\n\n    // Initialize variables for Simpson's rule\n    dReal x0 = 0, x1 = 0, x2 = 0;\n    dReal y0 = 0, y1 = 0, y2 = 0;\n    dReal z0 = 0, z1 = 0, z2 = 0;\n    dReal x = 0, y = 0, z = 0;\n    dReal x1_x0 = 0, y1_y0 = 0, z1_z0 = 0;\n    dReal x2_x0 = 0, y2_y0 = 0, z2_z0 = 0;\n    dReal x2_x1 = 0, y2_y1 = 0, z2_z1 = 0;\n    dReal x_x0 = 0, y_y0 = 0, z_z0 = 0;\n    dReal x_x1 = 0, y_y1 = 0, z_z1 = 0;\n    dReal x_x2 = 0, y_y2 = 0, z_z2 = 0;\n    dReal x_x1_x0 = 0, y_y1_y0 = 0, z_z1_z0 = 0;\n    dReal x_x2_x0 = 0, y_y2_y0 = 0, z_z2_z0 = 0;\n    dReal x_x2_x1 = 0, y_y2_y1 = 0, z_z2_z1 = 0;\n    dReal x_x2_x1_x0 = 0, y_y2_y1_y0 = 0, z_z2_z1_z0 = 0;\n\n    // Calculate the coordinates of the first point on the hemisphere's surface\n    x0 = zIOverR;\n    y0 = 0;\n    z0 = -1;\n\n    // Calculate the coordinates of the second point on the hemisphere's surface\n    x1 = x", "CodeBleu_score": 36.8361898959036}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    dReal radius, length, volume;\n    dReal a, b, c;\n    dReal x, y, z;\n    dReal x0, y0, z0;\n    dReal x1, y1, z1;\n    dReal x2, y2, z2;\n    dReal x3, y3, z3;\n    dReal x4, y4, z4;\n    dReal x5, y5, z5;\n    dReal x6, y6, z6;\n    dReal x7, y7, z7;\n    dReal x8, y8, z8;\n    dReal x9, y9, z9;\n    dReal x10, y10, z10;\n    dReal x11, y11, z11;\n    dReal x12, y12, z12;\n    dReal x13, y13, z13;\n    dReal x14, y14, z14;\n    dReal x15, y15, z15;\n    dReal x16, y16, z16;\n    dReal x17, y17, z17;\n    dReal x18, y18, z18;\n    dReal x19, y19, z19;\n    dReal x20, y20, z20;\n    dReal x21, y21, z21;\n    dReal x22, y22, z22;\n    dReal x23, y23, z23;\n    dReal x24, y24, z24;\n    dReal x25, y25, z25;\n    dReal x26, y26, z26;\n    dReal x27, y27, z27;\n    dReal x28, y28, z28;\n    dReal x29, y29, z29;\n    dReal x30, y30, z30;\n    dReal x31, y31, z31;", "CodeBleu_score": 6.033436002976912}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  int i;\n  dReal *v;\n  dReal *v0;\n  dReal *v1;\n  dReal *v2;\n  dReal *v3;\n  dReal *v4;\n  dReal *v5;\n  dReal *v6;\n  dReal *v7;\n  dReal *v8;\n  dReal *v9;\n  dReal *v10;\n  dReal *v11;\n  dReal *v12;\n  dReal *v13;\n  dReal *v14;\n  dReal *v15;\n  dReal *v16;\n  dReal *v17;\n  dReal *v18;\n  dReal *v19;\n  dReal *v20;\n  dReal *v21;\n  dReal *v22;\n  dReal *v23;\n  dReal *v24;\n  dReal *v25;\n  dReal *v26;\n  dReal *v27;\n  dReal *v28;\n  dReal *v29;\n  dReal *v30;\n  dReal *v31;\n  dReal *v32;\n  dReal *v33;\n  dReal *v34;\n  dReal *v35;\n  dReal *v36;\n  dReal *v37;\n  dReal *v38;\n  dReal *v39;\n  dReal *v40;\n  dReal *v41;\n  dReal *v42;\n  dReal *v43;\n  dReal *v44;\n  dReal *v45;\n  dReal *v46;\n  dReal *v47;\n  dReal *v48;\n  dReal *v49;\n  dReal *v50;\n  dReal *v51;\n  dReal *v52;\n  dReal *v53;\n  dReal *v54;\n  dReal *v55;\n  dReal *v5", "CodeBleu_score": 8.372331669581044}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    dReal a1[4], a2[4];\n    dReal p1[3], p2[3];\n    dReal r1, r2;\n    dReal volume;\n    dReal depthRatio;\n    dReal tanTheta1;\n    dReal sinTheta2;\n    dReal buoyancyCenterX;\n    dReal buoyancyCenterY;\n    dReal buoyancyCenterZ;\n    dReal buoyancyCenter[3];\n    dReal buoyancyCenterScaled[3];\n    dReal buoyancyCenterAdjusted[3];\n    dReal buoyancyCenterAdjustedScaled[3];\n    dReal buoyancyCenterAdjustedScaledRadius[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjusted[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolume[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaled[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaledRadius[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaledRadiusScaled[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaledRadiusScaledVolume[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaledRadiusScaledVolumeScaled[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaledRadiusScaledVolumeScaledRadius[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaledRadiusScaledVolumeScaledRadiusScaled[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaledRadiusScaledVolumeScaledRadiusScaledVolume[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScaledRadiusScaledVolumeScaledRadiusScaledVolumeScaled[3];\n    dReal buoyancyCenterAdjustedScaledRadiusAdjustedVolumeScal", "CodeBleu_score": 6.89768155468103}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()  getInput(\"duration\", sleep_duration_);\n  if (sleep_duration_ <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_waiting_ = true;\n  timer_.start(std::chrono::milliseconds(static_cast<int>(sleep_duration_)));\n  timer_.setCallback([this]() {\n    timer_waiting_ = false;\n    emitWakeUpSignal();\n  });\n  return NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 52.17691386912586}, {"code": "NodeStatus SleepNode::onStart()    int64_t duration_ms;\n    if (!getInput(\"duration_ms\", duration_ms)) {\n        return NodeStatus::SUCCESS;\n    }\n    if (duration_ms <= 0) {\n        return NodeStatus::SUCCESS;\n    }\n    setStatus(NodeStatus::RUNNING);\n    timer_ = std::make_unique<rclcpp::TimerBase>(\n        getNode()->create_wall_timer(\n            std::chrono::milliseconds(duration_ms),\n            [this]() {\n                timer_waiting_ = false;\n                emitWakeUpSignal();\n            }));\n    return NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 52.89293276817364}, {"code": "NodeStatus SleepNode::onStart()  int duration_ms;\n  if (!getInput(\"duration_ms\", duration_ms)) {\n    return NodeStatus::SUCCESS;\n  }\n  if (duration_ms <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n  setStatus(NodeStatus::RUNNING);\n  timer_ = std::make_shared<rclcpp::TimerBase>(\n    getNode()->create_wall_timer(\n      std::chrono::milliseconds(duration_ms),\n      [this]() {\n        timer_waiting_ = false;\n        emitWakeUpSignal();\n      }));\n  if (!timer_) {\n    throw std::runtime_error(\"SleepNode::onStart: Failed to create timer\");\n  }\n  return NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 59.6996507344531}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()  std::shared_ptr<Entry> entry;\n  {\n    std::unique_lock<std::mutex> lock(blackboard_mutex_);\n    entry = blackboard_->getEntry(entry_name_);\n  }\n  if (entry) {\n    std::unique_lock<std::mutex> lock(entry->mutex_);\n    if (entry->sequence_number_ != sequence_number_) {\n      sequence_number_ = entry->sequence_number_;\n      return NodeStatus::SUCCESS;\n    }\n    return NodeStatus::FAILURE;\n  }\n  return NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 41.81301227065218}, {"code": "NodeStatus EntryUpdatedAction::tick()    // Get the entry from the blackboard\n    auto entry = blackboard()->get<std::string>(entry_name_);\n\n    // Lock the entry's mutex\n    std::unique_lock<std::mutex> lock(entry.mutex());\n\n    // Check if the entry has been updated\n    if (entry.seqID() != last_seq_id_) {\n        // Update the stored sequence ID\n        last_seq_id_ = entry.seqID();\n\n        // Return success\n        return NodeStatus::SUCCESS;\n    }\n\n    // Return failure\n    return NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 30.4320884703837}, {"code": "NodeStatus EntryUpdatedAction::tick()    std::string entry_name;\n    if (!getInput<std::string>(\"entry_name\", entry_name)) {\n        throw BT::RuntimeError(\"Missing entry name\");\n    }\n\n    BT::TreeNode::Ptr node = config().blackboard->get<BT::TreeNode::Ptr>(entry_name);\n    if (!node) {\n        return NodeStatus::FAILURE;\n    }\n\n    std::mutex &entry_mutex = node->entry()->mutex();\n    entry_mutex.lock();\n\n    uint64_t current_seq_id = node->entry()->sequenceID();\n    entry_mutex.unlock();\n\n    if (current_seq_id != last_seq_id_) {\n        last_seq_id_ = current_seq_id;\n        return NodeStatus::SUCCESS;\n    }\n\n    return NodeStatus::FAILURE;\n}\n\n}  // namespace behavior_tree\n}  // namespace isaac", "CodeBleu_score": 48.35539678210733}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const    if (m_successThreshold < 0) {\n        return std::max(size_t(0), size_t(-m_successThreshold * children().size()));\n    } else {\n        return m_successThreshold;\n    }\n}\n", "CodeBleu_score": 55.66495165042992}, {"code": "size_t ParallelNode::successThreshold() const    size_t threshold = (size_t)m_successThreshold;\n    if (threshold < 0) {\n        threshold = (size_t)m_children.size() + threshold + 1;\n    }\n    return threshold;\n}\n", "CodeBleu_score": 47.82704641354755}, {"code": "size_t ParallelNode::successThreshold() const    return _successThreshold < 0 ? std::max(0, int(_children.size()) + _successThreshold) : size_t(_successThreshold);\n}\n", "CodeBleu_score": 48.06148640165663}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        if (groot2_heartbeat_active) {\n            if (!groot2_heartbeat_active_last) {\n                // Heartbeat has been re-enabled\n                // Enable all breakpoints\n                for (auto &b : breakpoints) {\n                    b.second->setEnabled(true);\n                }\n            }\n        } else {\n            if (groot2_heartbeat_active_last) {\n                // Heartbeat has been disabled\n                // Disable all breakpoints\n                for (auto &b : breakpoints) {\n                    b.second->setEnabled(false);\n                }\n            }\n        }\n        groot2_heartbeat_active_last = groot2_heartbeat_active;\n    }\n}\n", "CodeBleu_score": 39.014185497673346}, {"code": "void Groot2Publisher::heartbeatLoop()  ros::Rate rate(100);\n  while (ros::ok()) {\n    rate.sleep();\n    if (heartbeat_active) {\n      if (ros::Time::now().toSec() - last_heartbeat.toSec() > 0.5) {\n        heartbeat_active = false;\n        enableAllBreakpoints(false);\n      }\n    } else {\n      if (ros::Time::now().toSec() - last_heartbeat.toSec() < 0.5) {\n        heartbeat_active = true;\n        enableAllBreakpoints(true);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 35.80555858845671}, {"code": "void Groot2Publisher::heartbeatLoop()    while (ros::ok()) {\n        if (heartbeat_status) {\n            if (ros::Time::now().toSec() - heartbeat_time.toSec() > 0.1) {\n                heartbeat_status = false;\n                disableAllBreakpoints();\n            }\n        }\n        ros::Duration(0.01).sleep();\n    }\n}\n", "CodeBleu_score": 19.487649587750465}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<std::string> bb_names;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    while (std::getline(ss, bb_name, ',')) {\n        bb_names.push_back(bb_name);\n    }\n\n    std::lock_guard<std::mutex> lock(mtx);\n    nlohmann::json j;\n\n    for (const auto& bb_name : bb_names) {\n        auto subtree = blackboard.getSubTree(bb_name);\n        if (subtree) {\n            std::lock_guard<std::mutex> subtree_lock(subtree->mtx);\n            j[bb_name] = subtree->toJSON();\n        }\n    }\n\n    return nlohmann::json::to_msgpack(j);\n}\n", "CodeBleu_score": 43.797218237446685}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)  std::vector<uint8_t> result;\n  std::vector<std::string> blackboards_list = split(bb_list, ',');\n\n  nlohmann::json j;\n  for (const auto& blackboard : blackboards_list) {\n    auto subtree = blackboard::Blackboard::getSubtree(blackboard);\n    if (subtree) {\n      std::lock_guard<std::mutex> lock(subtree->mutex);\n      std::string json_str = subtree->toJSON();\n      j[blackboard] = nlohmann::json::parse(json_str);\n    }\n  }\n\n  nlohmann::json j_pack = nlohmann::json::object();\n  j_pack[\"blackboards\"] = j;\n\n  std::vector<uint8_t> msgpack = nlohmann::json::to_msgpack(j_pack);\n  result.insert(result.end(), msgpack.begin(), msgpack.end());\n  return result;\n}\n", "CodeBleu_score": 46.94805699270533}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<std::string> blackboards_to_dump;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    while (std::getline(ss, bb_name, ',')) {\n        blackboards_to_dump.push_back(bb_name);\n    }\n\n    std::lock_guard<std::mutex> lock(mtx);\n    json j;\n    for (const auto& bb_name : blackboards_to_dump) {\n        auto subtree = blackboard.subtree(bb_name);\n        if (subtree.isValid()) {\n            j[bb_name] = subtree.toJSON();\n        }\n    }\n    return json::to_msgpack(j);\n}\n", "CodeBleu_score": 42.74523779492902}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  // Search for the node by its UID and check if it exists and is valid\n  if (nodes_.count(node_uid) == 0) {\n    return false;\n  }\n  auto node = nodes_[node_uid];\n  if (node->getStatus() != NodeStatus::RUNNING) {\n    return false;\n  }\n\n  // Retrieve the associated hook and lock its mutex\n  auto hook = node->getHook();\n  std::unique_lock<std::mutex> lock(hook->mutex);\n\n  // If the hook is in BREAKPOINT mode, set the desired status and removal flag, mark it as ready, and notify all waiting threads\n  if (hook->getStatus() == NodeStatus::BREAKPOINT) {\n    hook->setStatus(result);\n    hook->setRemove(remove);\n    hook->setReady(true);\n    hook->cv.notify_all();\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 48.78479989892453}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  auto node = findNode(pos);\n  if (!node)\n    return false;\n  if (!node->isValid())\n    return false;\n  auto hook = node->getHook();\n  std::unique_lock<std::mutex> lock(hook->mutex);\n  if (hook->status == NodeStatus::BREAKPOINT) {\n    hook->status = result;\n    hook->remove = remove;\n    hook->ready = true;\n    hook->cv.notify_all();\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 42.28889170744501}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  // Search for the node by its UID\n  auto node_it = nodes_.find(node_uid);\n\n  // Check if the node exists and is valid\n  if (node_it == nodes_.end() || node_it->second.is_valid == false) {\n    return false;\n  }\n\n  // Retrieve the associated hook and lock its mutex\n  std::unique_lock<std::mutex> hook_lock(node_it->second.hook->mutex);\n\n  // Check if the hook is in BREAKPOINT mode\n  if (node_it->second.hook->mode == HookMode::BREAKPOINT) {\n    // Set the desired status and removal flag\n    node_it->second.hook->status = result;\n    node_it->second.hook->remove = remove;\n\n    // Mark the hook as ready and notify all waiting threads\n    node_it->second.hook->ready = true;\n    node_it->second.hook->cv.notify_all();\n  }\n\n  return true;\n}\n", "CodeBleu_score": 40.227801461853}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()    if (status() == NodeStatus::IDLE) {\n        setStatus(NodeStatus::RUNNING);\n        halt_requested_.store(false);\n        auto future = std::async(std::launch::async, [this]() {\n            try {\n                tick();\n            }\n            catch (std::exception& ex) {\n                halt_requested_.store(true);\n                throw BT::RuntimeError(\"ThreadedAction::executeTick(): \",\n                                      name(), \": \", ex.what());\n            }\n        });\n        future_ = std::move(future);\n    }\n\n    if (halt_requested_) {\n        setStatus(NodeStatus::IDLE);\n        halt_requested_.store(false);\n    }\n\n    if (future_.valid() &&\n        future_.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n        try {\n            future_.get();\n        }\n        catch (std::exception& ex) {\n            setStatus(NodeStatus::FAILURE);\n            throw BT::RuntimeError(\"ThreadedAction::executeTick(): \",\n                                  name(), \": \", ex.what());\n        }\n        setStatus(NodeStatus::SUCCESS);\n    }\n\n    // check if the thread ended with an exception\n    if (has_exception_) {\n        has_exception_ = false;\n        std::rethrow_exception(stored_exception_);\n    }\n\n    return status();\n}\n", "CodeBleu_score": 47.41776857726086}, {"code": "NodeStatus BT::ThreadedAction::executeTick()    if (node_status_ == NodeStatus::IDLE) {\n        node_status_ = NodeStatus::RUNNING;\n        halt_requested_.store(false);\n        auto future = std::async(std::launch::async, [this]() {\n            try {\n                tick();\n                if (!halt_requested_) {\n                    node_status_ = NodeStatus::SUCCESS;\n                }\n            } catch (std::exception& ex) {\n                std::cerr << \"ThreadedAction exception: \" << ex.what() << std::endl;\n                node_status_ = NodeStatus::FAILURE;\n            }\n        });\n        future.wait();\n        if (exception_) {\n            std::rethrow_exception(exception_);\n        }\n    }\n    return node_status_;\n}\n", "CodeBleu_score": 45.26581074108875}, {"code": "NodeStatus BT::ThreadedAction::executeTick()  if (getStatus() == NodeStatus::IDLE) {\n    setStatus(NodeStatus::RUNNING);\n    halt_requested_ = false;\n    try {\n      std::thread thread(&BT::ThreadedAction::executeTickImpl, this);\n      thread.detach();\n    } catch (std::exception& ex) {\n      std::cerr << \"ThreadedAction::executeTick: \" << ex.what() << std::endl;\n      setStatus(NodeStatus::IDLE);\n    }\n  }\n  checkException();\n  return getStatus();\n}\n", "CodeBleu_score": 31.003463404542487}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    static const char* g_separator = \"---------------------------------------\";\n    stream << g_separator << std::endl;\n\n    auto printTree = [](const TreeNode* node, std::ostream& stream, int indent = 0) {\n        for (int i = 0; i < indent; i++) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n        if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control_node->children()) {\n                printTree(child, stream, indent + 1);\n            }\n        } else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            printTree(decorator_node->child(), stream, indent + 1);\n        }\n    };\n\n    printTree(root_node, stream);\n    stream << g_separator << std::endl;\n}\n\n}  // namespace BT\n", "CodeBleu_score": 57.08188935089861}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)  static const char* g_separator = \"----------------------------------------\";\n  stream << g_separator << std::endl;\n\n  auto printTree = [](const TreeNode* node, std::ostream& stream, int indent = 0) {\n    for (int i = 0; i < indent; i++) {\n      stream << \"  \";\n    }\n    stream << node->name() << std::endl;\n    if (const auto* control_node = dynamic_cast<const ControlNode*>(node)) {\n      for (const auto& child : control_node->children()) {\n        printTree(child, stream, indent + 1);\n      }\n    } else if (const auto* decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n      printTree(decorator_node->child(), stream, indent + 1);\n    }\n  };\n\n  printTree(root_node, stream);\n  stream << g_separator << std::endl;\n}\n", "CodeBleu_score": 55.84659939743395}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    static const std::string line_sep = \"--------------------------------\";\n    stream << line_sep << std::endl;\n\n    auto printTree = [&stream](const TreeNode* node, int indent = 0) {\n        for (int i = 0; i < indent; i++)\n            stream << \"  \";\n\n        stream << node->name() << std::endl;\n\n        if (auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control_node->children())\n                printTree(child.get(), indent + 1);\n        } else if (auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            printTree(decorator_node->child().get(), indent + 1);\n        }\n    };\n\n    printTree(root_node);\n    stream << line_sep << std::endl;\n}\n", "CodeBleu_score": 53.592832294106984}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)    if (!node) {\n        throw LogicError(\"applyRecursiveVisitor: node is null\");\n    }\n\n    visitor(node);\n\n    if (const ControlNode* control = dynamic_cast<const ControlNode*>(node)) {\n        for (const auto& child : control->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (const DecoratorNode* decorator = dynamic_cast<const DecoratorNode*>(node)) {\n        applyRecursiveVisitor(decorator->child(), visitor);\n    }\n}\n", "CodeBleu_score": 69.01276442127022}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (!node) {\n    throw std::logic_error(\"applyRecursiveVisitor: node is null\");\n  }\n  visitor(node);\n  if (const auto* control_node = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : control_node->children()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (const auto* decorator_node =\n                 dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decorator_node->child(), visitor);\n  }\n}\n", "CodeBleu_score": 62.88323102941325}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)    if (!node) {\n        throw std::logic_error(\"applyRecursiveVisitor: node is null\");\n    }\n\n    visitor(node);\n\n    if (const auto controlNode = dynamic_cast<const ControlNode*>(node)) {\n        for (const auto& child : controlNode->children()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (const auto decoratorNode = dynamic_cast<const DecoratorNode*>(node)) {\n        applyRecursiveVisitor(decoratorNode->child(), visitor);\n    }\n}\n", "CodeBleu_score": 63.415118073057045}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)  if (builders_.count(manifest.registration_ID) != 0) {\n    auto tmp = std::string(\"Mismatched Builder registration. A builder with ID [\") +\n               manifest.registration_ID + \"] already exists\";\n    throw BehaviorTreeException(tmp);\n  }\n\n  builders_.insert({manifest.registration_ID, builder});\n  manifests_.insert({manifest.registration_ID, manifest});\n}\n", "CodeBleu_score": 52.233933401049825}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)  auto it = builders_.find(manifest.registration_ID);\n  if (it != builders_.end()) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                \"] already registered\");\n  }\n\n  builders_.insert({manifest.registration_ID, builder});\n  manifests_.insert({manifest.registration_ID, manifest});\n}\n", "CodeBleu_score": 69.30044967421914}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)  if (builders_.count(manifest.registration_ID) != 0) {\n    throw BehaviorTreeException(\"ID [\", manifest.registration_ID,\n                                \"] already registered\");\n  }\n\n  builders_.insert({manifest.registration_ID, builder});\n  manifests_.insert({manifest.registration_ID, manifest});\n}\n", "CodeBleu_score": 59.49247031740706}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports)};\n  registerBuilder(manifest, std::move(builder));\n}\n", "CodeBleu_score": 68.10857024866756}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config);\n  };\n\n  TreeNodeManifest manifest = {NodeType::ACTION, ID, std::move(ports)};\n  registerBuilder(manifest, std::move(builder));\n}\n", "CodeBleu_score": 74.89958699527126}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  NodeBuilder builder = [tick_functor, ports](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, config, ports);\n  };\n  TreeNodeManifest manifest = {NodeType::SIMPLE_ACTION, ID, std::move(ports), {}};\n  registerBuilder(manifest, std::move(builder));\n}\n", "CodeBleu_score": 70.69332749439718}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(tree.GetChildren().size());\n    for (const auto& subtree : tree.GetChildren()) {\n        Blackboard::Ptr backup = std::make_shared<Blackboard>();\n        *backup = *subtree->blackboard_;\n        backups.push_back(backup);\n    }\n    return backups;\n}\n", "CodeBleu_score": 51.126399888846194}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.Subtrees().size());\n  for (const auto& subtree : tree.Subtrees()) {\n    auto subtree_bb = subtree->Blackboard();\n    auto new_bb = Blackboard::Create();\n    new_bb->CloneFrom(*subtree_bb);\n    backup.push_back(new_bb);\n  }\n  return backup;\n}\n", "CodeBleu_score": 52.9293584316173}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> backup;\n    backup.reserve(tree.Subtrees().size());\n    for (const auto& subtree : tree.Subtrees()) {\n        auto new_bb = Blackboard::Create();\n        new_bb->CloneFrom(*subtree->Blackboard());\n        backup.push_back(new_bb);\n    }\n    return backup;\n}\n", "CodeBleu_score": 54.21711914021811}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor->value()->Execute(env);\n}\n", "CodeBleu_score": 72.0018938306895}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)  auto executor = ParseScript(script);\n  if (!executor) {\n    return nonstd::make_unexpected(executor.error());\n  }\n  return executor.value()->Execute(env);\n}\n\n}  // namespace\n", "CodeBleu_score": 73.12096258745142}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    // Parse the script and get an executor\n    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n\n    // Execute the script using the environment and return the result\n    return executor.value()->Execute(env);\n}\n", "CodeBleu_score": 72.16369464665698}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)    std::lock_guard<std::mutex> lock(mutex_);\n    if (loaded_) {\n        throw RuntimeError(\"A library is already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle_) {\n        throw RuntimeError(dlerror());\n    }\n    path_ = path;\n    loaded_ = true;\n}\n", "CodeBleu_score": 51.51932523994276}, {"code": "void SharedLibrary::load(const std::string& path, int)    std::unique_lock<std::mutex> lock(mutex_);\n    if (handle_ != nullptr) {\n        throw std::runtime_error(\"Library already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        std::string error = dlerror();\n        throw std::runtime_error(\"Failed to load library: \" + error);\n    }\n    path_ = path;\n}\n", "CodeBleu_score": 57.26888330395366}, {"code": "void SharedLibrary::load(const std::string& path, int)    std::lock_guard<std::mutex> lock(m_mutex);\n    if (m_handle) {\n        throw std::runtime_error(\"Library already loaded\");\n    }\n    m_handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!m_handle) {\n        std::string error = dlerror();\n        throw std::runtime_error(\"Failed to load library: \" + error);\n    }\n    m_path = path;\n}\n", "CodeBleu_score": 59.32858396750251}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    if (str.length() < 3) {\n        return false;\n    }\n    StringView stripped = str.strip();\n    if (stripped.empty()) {\n        return false;\n    }\n    if (stripped.front() != '{' || stripped.back() != '}') {\n        return false;\n    }\n    if (stripped_pointer) {\n        *stripped_pointer = stripped.substr(1, stripped.length() - 2);\n    }\n    return true;\n}\n", "CodeBleu_score": 27.1736676124182}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    // If the string is less than 3 characters long, it cannot be a valid blackboard pointer\n    if (str.size() < 3) {\n        return false;\n    }\n\n    // Strip leading and trailing spaces\n    StringView stripped = strip(str);\n\n    // Check if the stripped string starts with '{' and ends with '}'\n    if (stripped.front() == '{' && stripped.back() == '}') {\n        // If a stripped_pointer is provided, assign the inner content to it\n        if (stripped_pointer) {\n            *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n        }\n\n        // Return true, indicating the string is a valid blackboard pointer\n        return true;\n    }\n\n    // If the string is not a valid blackboard pointer, return false\n    return false;\n}\n", "CodeBleu_score": 27.28181972121204}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)  if (str.size() < 3) {\n    return false;\n  }\n\n  StringView stripped = strip(str);\n\n  if (!stripped.starts_with(\"{\") || !stripped.ends_with(\"}\")) {\n    return false;\n  }\n\n  if (stripped_pointer) {\n    *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n  }\n\n  return true;\n}\n", "CodeBleu_score": 22.98131742235994}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const    //Bresenham Ray-Tracing\n    double line_cost = 0.0;\n    double point_cost = -1.0;\n\n    for (LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n        point_cost = pointCost(line.getX(), line.getY()); //Score based on the distance from an obstacle\n\n        if (line_cost < point_cost) {\n            line_cost = point_cost;\n        }\n    }\n\n    return line_cost;\n}\n", "CodeBleu_score": 69.80856521634908}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  //Bresenham Ray-Tracing\n  double line_cost = 0.0;\n  double point_cost = -1.0;\n\n  for(LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance())\n  {\n    point_cost = pointCost( line.getX(), line.getY() ); //Score the current point\n\n    if(point_cost < 0)\n      return point_cost;\n\n    if(line_cost < point_cost)\n      line_cost = point_cost;\n  }\n\n  return line_cost;\n}\n\n", "CodeBleu_score": 88.97310073629899}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  //Bresenham Ray-Tracing\n  int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n  int dy = abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n  int err = (dx > dy ? dx : -dy) / 2, e2;\n\n  double cost = 0.0;\n  double scale = 1.0;\n  for (int current_point = 0; current_point < scale * sqrt(dx * dx + dy * dy) + 1; current_point++) {\n    double point_cost = pointCost(x0, y0);\n    if (point_cost < 0) {\n      return point_cost;\n    }\n    if (point_cost >= INSCRIBED) {\n      cost += point_cost;\n    }\n    e2 = err;\n    if (e2 > -dx) {\n      err -= dy;\n      x0 += sx;\n    }\n    if (e2 < dy) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n  return cost;\n}\n", "CodeBleu_score": 40.99641530945996}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)     if (path.empty()) {\n        return;\n    }\n\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.poses = path;\n\n    pub.publish(gui_path);\n}\n", "CodeBleu_score": 55.382663107219564}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   if (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n  gui_path.poses = path;\n\n  pub.publish(gui_path);\n}\n", "CodeBleu_score": 54.6850725093079}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)     if (path.empty()) {\n        return;\n    }\n    nav_msgs::Path gui_path;\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n    gui_path.poses = path;\n    pub.publish(gui_path);\n}\n", "CodeBleu_score": 55.382663107219564}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}\n", "CodeBleu_score": 96.88797909273556}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}\n", "CodeBleu_score": 96.88797909273556}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  return fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity && \n      fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity;\n}\n", "CodeBleu_score": 96.91032596963424}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  if (setup_ && restore_defaults) {\n    config = default_limits_;\n  }\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n  boost::recursive_mutex::scoped_lock l(configuration_mutex_);\n  current_limits_ = LocalPlannerLimits(config);\n}\n", "CodeBleu_score": 80.08391881996138}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  if (setup_) {\n    if (restore_defaults) {\n      config = default_limits_;\n    }\n    boost::recursive_mutex::scoped_lock l(configuration_mutex_);\n    limits_ = config;\n  } else {\n    default_limits_ = config;\n    limits_ = config;\n    setup_ = true;\n  }\n}\n", "CodeBleu_score": 68.27036279944798}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  // check if we need to revert to default configuration\n  if (restore_defaults) {\n    config = default_config_;\n  }\n\n  // lock mutex\n  boost::mutex::scoped_lock l(limits_configuration_mutex_);\n\n  // check if we need to initialize default configuration\n  if (!setup_) {\n    default_config_ = config;\n    setup_ = true;\n  }\n\n  // update current configuration\n  config_ = config;\n}\n", "CodeBleu_score": 60.446069363371045}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  unsigned int cx = check_cell->cx, cy = check_cell->cy;\n  //if the cell would be an obstacle choose the maximum value\n  if (!getCost(cx, cy, costmap)) {\n    if (display_window_)\n      display->addPoint(cx, cy, 255, 0, 0);\n    check_cell->target_dist = obstacleCosts_;\n    return false;\n  }\n\n  //update new cell\n  double new_target_dist = current_cell->target_dist + distance(cx, cy, current_cell->cx,\n      current_cell->cy);\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    check_cell->src_x = current_cell->cx;\n    check_cell->src_y = current_cell->cy;\n  }\n  return true;\n}\n", "CodeBleu_score": 64.4011263069506}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  unsigned int cell_cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost >= costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_dist = obstacleCosts();\n    return false;\n  } else if (cell_cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_dist = unreachableCellCosts();\n    return false;\n  }\n  double new_target_dist = distance(current_cell->cx, current_cell->cy,\n      check_cell->cx, check_cell->cy) + current_cell->target_dist;\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    return true;\n  } else {\n    return false;\n  }\n}\n", "CodeBleu_score": 69.74848383004898}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  unsigned int cell_cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  if (cell_cost == costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_dist = obstacleCosts();\n    return false;\n  }\n  else if (cell_cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_dist = unreachableCellCosts();\n    return false;\n  }\n  else {\n    unsigned int new_target_dist = current_cell->target_dist + 1;\n    if (new_target_dist < check_cell->target_dist) {\n      check_cell->target_dist = new_target_dist;\n    }\n    return true;\n  }\n}\n", "CodeBleu_score": 74.69529396656112}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, scaling_factor_);\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint()?\");\n    return -9;\n  }\n\n  for (unsigned int i = 0; i < traj.getPointsSize(); ++i) {\n    double px = traj.getPoint(i).pose.position.x, py = traj.getPoint(i).pose.position.y, pth = tf2::getYaw(traj.getPoint(i).pose.orientation);\n\n    double f_cost = footprintCost(px, py, pth);\n\n    if (f_cost < 0) {\n      return -5;\n    }\n\n    if (sum_scores_)\n      cost += f_cost;\n    else\n      cost = std::max(cost, f_cost);\n  }\n  return cost * scale;\n}\n", "CodeBleu_score": 71.54899882365113}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, scaling_factor_);\n  double px, py, pth;\n  unsigned int i, num_points = traj.getPointsSize();\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint spec is empty, maybe missing call to setFootprint()?\");\n    return -9;\n  }\n\n  for (i = 0; i < num_points; ++i) {\n    traj.getPoint(i, px, py, pth);\n    double f_cost = footprintCost(px, py, pth);\n    if (f_cost < 0) {\n      return f_cost;\n    }\n    if (sum_scores_) {\n      cost += f_cost;\n    } else {\n      cost = std::max(cost, f_cost);\n    }\n  }\n  return cost * scale;\n}\n", "CodeBleu_score": 77.40348675350685}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0;\n  double scale = getScalingFactor(traj, scaling_speed_, scaling_factor_);\n  double px, py, pth;\n  unsigned int i;\n  for (i = 0; i < traj.getPointsSize(); ++i) {\n    traj.getPoint(i, px, py, pth);\n    double f_cost = footprintCost(px, py, pth);\n    if (f_cost < 0) {\n      return -9;\n    }\n    if (sum_scores_) {\n      cost += f_cost * scale;\n    } else {\n      cost = cost > f_cost ? cost : f_cost * scale;\n    }\n  }\n  return cost;\n}\n", "CodeBleu_score": 58.753756505935925}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n  //check if the plugin initialized\n  if(!initialized_){\n    ROS_ERROR(\"This planner has not been initialized, please call initialize() to use the planner\");\n    return -1.0;\n  }\n\n  //if the footprint is empty return, we can't work with an empty footprint...\n  if(footprint_spec.size() == 0)\n    return -6.0;\n\n  //calculate the size of the footprint\n  double footprint_cost = 0.0;\n\n  //get the angle of the robot\n  double angle = th;\n\n  //get the coordinates of the robot\n  double x_r, y_r;\n  x_r = x;\n  y_r = y;\n\n  //we need to scale the footprint\n  //compute the points of the scaled footprint\n  std::vector<geometry_msgs::Point> oriented_footprint;\n  geometry_msgs::Point new_pt;\n  for(unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    new_pt = footprint_spec[i];\n    new_pt.x = new_pt.x * scale;\n    new_pt.y = new_pt.y * scale;\n    oriented_footprint.push_back(new_pt);\n  }\n\n  //now we need to rotate the footprint\n  //compute the cos and sin of the angle\n  double cos_th = cos(angle);\n  double sin_th = sin(angle);\n  std::vector<geometry_msgs::Point> oriented_footprint_rotated;\n  for(unsigned int i = 0; i < oriented_footprint.size(); ++i) {\n    new_pt.x = x_r + (oriented_footprint[i].x * cos_th - oriented_footprint[i].y * sin_th);\n    new_pt.y = y_r + (oriented_footprint[i].x * sin_th + oriented_footprint[i].y * cos_th);\n    oriented_footprint_rotated.push_back(new_pt);\n  }\n\n  geometry_msgs::Point robot_position;\n  robot_position.x", "CodeBleu_score": 53.40399069135599}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)  //check if the plugin initialized\n  if (!initialized_) {\n    ROS_ERROR(\"The plugin %s has not been initialized...\", name_.c_str());\n    return -1.0;\n  }\n\n  unsigned int cell_x, cell_y;\n\n  //we won't allow trajectories that go off the map... shouldn't happen that often anyways\n  if (!costmap->worldToMap(x, y, cell_x, cell_y)) {\n    return -7.0;\n  }\n\n  double footprint_cost = 0.0;\n\n  //we need to rasterize each line in the footprint\n  for (unsigned int i = 0; i < footprint_spec.size() - 1; ++i) {\n    //get the cell coord of the first point\n    unsigned int cell_a_x, cell_a_y;\n    if (!costmap->worldToMap(x + scale * footprint_spec[i].x, y + scale * footprint_spec[i].y, cell_a_x, cell_a_y)) {\n      return -7.0;\n    }\n\n    //get the cell coord of the second point\n    unsigned int cell_b_x, cell_b_y;\n    if (!costmap->worldToMap(x + scale * footprint_spec[i + 1].x, y + scale * footprint_spec[i + 1].y, cell_b_x, cell_b_y)) {\n      return -7.0;\n    }\n\n    footprint_cost = std::max(lineCost(cell_a_x, cell_a_y, cell_b_x, cell_b_y, costmap, world_model), footprint_cost);\n  }\n\n  //we also need to connect the first point in the footprint to the last point\n  //get the cell coord of the last point\n  unsigned int cell_a_x, cell_a_y;\n  if (!costmap->worldToMap(x + scale * footprint_spec.back().x, y + scale * footprint_spec.back().y, cell_a_x, cell_a_y)) {\n    return -7.0;\n  }", "CodeBleu_score": 58.74425292465961}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n    // check if the plugin initialized\n    if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized, please call initialize() to use the planner\");\n        return -1.0;\n    }\n\n    // get the footprint of the robot\n    std::vector<geometry_msgs::Point> scaled_footprint = footprint_spec;\n\n    // footprint scaling with the parameter scale\n    for (unsigned int i = 0; i < scaled_footprint.size(); ++i) {\n        scaled_footprint[i].x *= scale;\n        scaled_footprint[i].y *= scale;\n    }\n\n    // get the robot's footprint on the costmap\n    costmap->convertToWorld(x, y, footprint_spec[0].x, footprint_spec[0].y);\n    footprint_spec[0].x = x;\n    footprint_spec[0].y = y;\n    transformFootprint(x, y, th, footprint_spec, scaled_footprint);\n\n    // set the cost of a legal position to be zero\n    double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec);\n    return footprint_cost;\n}\n\n", "CodeBleu_score": 52.676077872800995}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  if (odom_topic != odom_topic_) {\n    if (!odom_topic.empty()) {\n      // subscribe to the odometry topic with the callback\n      odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n      odom_topic_ = odom_topic;\n      odom_set_ = true;\n      ROS_INFO_STREAM(\"Subscribed to odom topic \\\"\" << odom_topic_ << \"\\\".\");\n    } else {\n      // shutdown the subscription\n      odom_sub_.shutdown();\n      odom_topic_ = odom_topic;\n      odom_set_ = false;\n      ROS_INFO_STREAM(\"Unsubscribed from odom topic \\\"\" << odom_topic_ << \"\\\".\");\n    }\n  }\n}\n", "CodeBleu_score": 48.43111588026385}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic != odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (odom_topic_ != \"\") {\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t\tROS_INFO_STREAM(\"Subscribing to odom topic \\\"\" << odom_topic_ << \"\\\".\");\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t\tROS_INFO_STREAM(\"Unsubscribing from odom topic \\\"\" << odom_topic_ << \"\\\".\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 47.070199401519645}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\n    // Check if the topic is changing\n    if (odom_topic != odom_topic_) {\n\n        // Shutdown the current subscription if it exists\n        if (odom_topic_ != \"\") {\n            odom_sub_.shutdown();\n        }\n\n        // Update the topic\n        odom_topic_ = odom_topic;\n\n        // Subscribe to the new topic if it is not empty\n        if (odom_topic_ != \"\") {\n            odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n        }\n    }\n}\n", "CodeBleu_score": 47.0152226377352}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)  const float x = pos.x() - prev.x();\n  const float y = pos.y() - prev.y();\n  const float squared_dist = x * x + y * y;\n\n  if (squared_dist < oscillation_reset_dist_sq_) {\n    return;\n  }\n\n  const float des_theta = std::atan2(y, x);\n  const float delta_theta = angles::shortest_angular_distance(prev.z(), des_theta);\n\n  if (std::abs(delta_theta) >= oscillation_reset_angle_) {\n    return;\n  }\n\n  resetOscillationFlags();\n}\n", "CodeBleu_score": 43.84418807545891}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)    float sq_dist = (pos - prev).squaredNorm();\n\n    if (sq_dist < MIN_DISTANCE_SQ) {\n        return;\n    }\n\n    float angle = acos(prev.dot(pos) / sq_dist);\n    if (angle >= MIN_ANGLE) {\n        x_oscillation_ = y_oscillation_ = z_oscillation_ = false;\n    }\n}\n", "CodeBleu_score": 31.477027215181042}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)    const float sq_dist = (pos - prev).squaredNorm();\n    const float sq_rot_dist = (2.0f - 2.0f * (prev.dot(pos)));\n    sq_rot_dist_threshold_ = rotation_replan_threshold_ * rotation_replan_threshold_;\n    if (sq_dist > oscillation_reset_dist_sq_ || sq_rot_dist > sq_rot_dist_threshold_) {\n        resetOscillationFlags();\n    }\n}\n", "CodeBleu_score": 41.060232930978124}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)    int x_idx = (int) ((pt.x - m_x_min) / m_cell_size);\n    int y_idx = (int) ((pt.y - m_y_min) / m_cell_size);\n    if (x_idx < 0 || x_idx >= m_num_cells_x || y_idx < 0 || y_idx >= m_num_cells_y) {\n        return;\n    }\n    int idx = x_idx + y_idx * m_num_cells_x;\n    if (m_cells[idx].empty()) {\n        m_cells[idx].push_back(pt);\n    } else {\n        const geometry_msgs::Point32& last_pt = m_cells[idx].back();\n        float dx = pt.x - last_pt.x;\n        float dy = pt.y - last_pt.y;\n        float dist = sqrt(dx * dx + dy * dy);\n        if (dist >= m_min_dist) {\n            m_cells[idx].push_back(pt);\n        }\n    }\n}\n", "CodeBleu_score": 38.45674767637567}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)  int x = (int)floor(pt.x / cell_size_);\n  int y = (int)floor(pt.y / cell_size_);\n  if (x < 0 || y < 0 || x >= width_ || y >= height_) {\n    return;\n  }\n  int index = x + y * width_;\n  if (grid_[index].size() > 0) {\n    double min_dist = std::numeric_limits<double>::max();\n    for (const auto& p : grid_[index]) {\n      double dx = p.x - pt.x;\n      double dy = p.y - pt.y;\n      double dist = dx * dx + dy * dy;\n      if (dist < min_dist) {\n        min_dist = dist;\n      }\n    }\n    if (min_dist < min_dist_) {\n      return;\n    }\n  }\n  grid_[index].push_back(pt);\n}\n", "CodeBleu_score": 39.74970069923259}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)  if (pt.x < x_min || pt.x > x_max || pt.y < y_min || pt.y > y_max)\n    return;\n\n  int x = (int)((pt.x - x_min) / resolution);\n  int y = (int)((pt.y - y_min) / resolution);\n  int idx = x + y * width;\n\n  if (grid[idx].size() > 0) {\n    double dist = std::hypot(grid[idx].back().x - pt.x, grid[idx].back().y - pt.y);\n    if (dist < resolution)\n      return;\n  }\n\n  grid[idx].push_back(pt);\n}\n", "CodeBleu_score": 39.289489105066565}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)    Eigen::Vector3f new_vel;\n    new_vel << 0, 0, 0;\n\n    for (int i = 0; i < 3; i++) {\n        if ((sample_target_vel[i] - vel[i]) > acclimits[i] * dt) {\n            new_vel[i] = vel[i] + acclimits[i] * dt;\n        } else if ((sample_target_vel[i] - vel[i]) < -acclimits[i] * dt) {\n            new_vel[i] = vel[i] - acclimits[i] * dt;\n        } else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n\n    return new_vel;\n}\n", "CodeBleu_score": 68.91595522614435}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\n    Eigen::Vector3f new_vel;\n    new_vel.setZero();\n\n    for (int i = 0; i < 3; i++) {\n        if (vel[i] < sample_target_vel[i]) {\n            new_vel[i] = std::min(double(sample_target_vel[i]), vel[i] + acclimits[i] * dt);\n        }\n        else {\n            new_vel[i] = std::max(double(sample_target_vel[i]), vel[i] - acclimits[i] * dt);\n        }\n    }\n\n    return new_vel;\n}\n", "CodeBleu_score": 89.40527254124301}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)    Eigen::Vector3f new_vel;\n    new_vel.setZero();\n    for (int i = 0; i < 3; i++) {\n        if ((sample_target_vel[i] - vel[i]) > acclimits[i] * dt) {\n            new_vel[i] = vel[i] + acclimits[i] * dt;\n        } else if ((sample_target_vel[i] - vel[i]) < -acclimits[i] * dt) {\n            new_vel[i] = vel[i] - acclimits[i] * dt;\n        } else {\n            new_vel[i] = sample_target_vel[i];\n        }\n    }\n    return new_vel;\n}\n", "CodeBleu_score": 69.45928672201539}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)    // Initialize the maximum distance to the farthest point with a clear line of sight\n    double max_dist = -1;\n\n    // Iterate through the global plan in reverse\n    for (int i = global_plan.size() - 1; i >= 0; i--) {\n        // Get the current cell in the global plan\n        Cell cell = global_plan[i];\n\n        // Check if the current cell is a valid point with a clear line of sight\n        if (cell.x != cell_x || cell.y != cell_y) {\n            // Convert the current cell coordinates to world coordinates\n            double wx, wy;\n            costmap_->mapToWorld(cell.x, cell.y, wx, wy);\n\n            // Calculate the distance between the current cell and the robot's current position\n            double dx = wx - x;\n            double dy = wy - y;\n            double dist = sqrt(dx * dx + dy * dy);\n\n            // Check if the current cell is the farthest point with a clear line of sight\n            if (dist > max_dist) {\n                max_dist = dist;\n\n                // Convert the goal cell coordinates to world coordinates\n                costmap_->mapToWorld(cell_x, cell_y, wx, wy);\n\n                // Calculate the angle between the current heading and the direction to the goal point\n                double angle = atan2(wy - y, wx - x) - heading;\n                angle = angles::normalize_angle(angle);\n\n                // Return the absolute value of the angle\n                return fabs(angle);\n            }\n        }\n    }\n\n    // If no valid point is found, return DBL_MAX\n    return DBL_MAX;\n}\n", "CodeBleu_score": 49.62652106659628}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)    int x_curr = cell_x;\n    int y_curr = cell_y;\n    double x_goal, y_goal;\n    double dx, dy;\n    double heading_goal;\n    double heading_diff;\n\n    // Iterate through the global plan in reverse to find the farthest point with a clear line of sight\n    for (int i = global_plan_.size() - 1; i >= 0; i--) {\n        x_goal = global_plan_[i].pose.position.x;\n        y_goal = global_plan_[i].pose.position.y;\n\n        // Check if the goal point is within the map bounds\n        if (x_goal < 0 || x_goal >= map_width_ || y_goal < 0 || y_goal >= map_height_) {\n            continue;\n        }\n\n        // Check if the line of sight between the robot's current cell and the goal point is clear\n        if (lineOfSight(x_curr, y_curr, x_goal, y_goal)) {\n            // Convert the goal cell coordinates to world coordinates\n            dx = x_goal - x;\n            dy = y_goal - y;\n            heading_goal = atan2(dy, dx);\n\n            // Calculate the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n            heading_diff = fabs(angles::shortest_angular_distance(heading, heading_goal));\n\n            // Return the heading difference if it is less than the maximum allowed heading difference\n            if (heading_diff <= max_heading_diff_) {\n                return heading_diff;\n            }\n        }\n    }\n\n    // If no valid point is found, return DBL_MAX\n    return DBL_MAX;\n}\n", "CodeBleu_score": 54.40632444096881}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\n    double heading_diff = DBL_MAX;\n\n    for (int i = global_plan_.size() - 1; i >= 0; --i) {\n\n        double x_goal = global_plan_[i].pose.position.x;\n        double y_goal = global_plan_[i].pose.position.y;\n\n        if (cell_x == x_goal && cell_y == y_goal) {\n            continue;\n        }\n\n        if (lineOfSight(cell_x, cell_y, x_goal, y_goal)) {\n\n            double x_diff = x_goal - x;\n            double y_diff = y_goal - y;\n            double goal_heading = atan2(y_diff, x_diff);\n\n            heading_diff = fabs(angles::shortest_angular_distance(heading, goal_heading));\n            break;\n        }\n    }\n\n    return heading_diff;\n}\n", "CodeBleu_score": 54.613366567444864}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n        ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, cost);\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 86.51121122009569}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost < 0) {\n    ROS_WARN(\"Invalid Trajectory %f, %f, %f, cost: %f\", vx_samp, vy_samp, vtheta_samp, cost);\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 86.73616379013143}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  Trajectory traj;\n  geometry_msgs::PoseStamped velocity;\n  velocity.header.stamp = ros::Time();\n  velocity.header.frame_id = frame_id_;\n  velocity.pose.position.x = x;\n  velocity.pose.position.y = y;\n  velocity.pose.position.z = 0.0;\n  velocity.pose.orientation = tf::createQuaternionMsgFromYaw(theta);\n  traj.addSamples(velocity, vx, vy, vtheta);\n\n  return checkTrajectory(traj, vx_samp, vy_samp, vtheta_samp);\n}\n", "CodeBleu_score": 40.26758342308314}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s in recovery behavior\", (affected_maps_ & GLOBAL_COSTMAP) ? \"global\" : \"local\",\n           (affected_maps_ & GLOBAL_COSTMAP && affected_maps_ & LOCAL_COSTMAP) ? \"s\" : \"\");\n\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    clear(global_costmap_);\n  }\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    clear(local_costmap_);\n  }\n\n  ROS_DEBUG(\"Clearing costmap took %0.4f seconds\",\n            (ros::WallTime::now() - start_time).toSec());\n}\n", "CodeBleu_score": 43.48419844742411}, {"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s in recovery behavior\", (affected_maps_ & GLOBAL_COSTMAP) ? \"global\" : \"local\",\n           (affected_maps_ & GLOBAL_COSTMAP && affected_maps_ & LOCAL_COSTMAP) ? \"s\" : \"\");\n\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    clear(global_costmap_);\n  }\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    clear(local_costmap_);\n  }\n}\n", "CodeBleu_score": 36.71870648679934}, {"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object cannot be NULL. Doing nothing.\");\n    return;\n  }\n\n  ROS_WARN(\"Clearing %s costmap%s in recovery behavior\", \n           (affected_maps_ & costmap_2d::LETHAL_OBSTACLE) ? \"global\" : \"\",\n           (affected_maps_ & ~costmap_2d::LETHAL_OBSTACLE) ? \" and local\" : \"\");\n  if (affected_maps_ & costmap_2d::LETHAL_OBSTACLE) {\n    clear(global_costmap_);\n  }\n  if (affected_maps_ & ~costmap_2d::LETHAL_OBSTACLE) {\n    clear(local_costmap_);\n  }\n}\n", "CodeBleu_score": 36.64114186768468}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  PolygonOutlineCells cell_gatherer(*this);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n\n  cell_gatherer.getCells(polygon_cells);\n}\n\n\n", "CodeBleu_score": 93.36073935552108}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  PolygonOutlineCells cell_gatherer(*this);\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n  }\n  if (!polygon.empty()) {\n    unsigned int last_index = polygon.size() - 1;\n    // we also need to close the polygon by going from the last point to the first\n    raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n  }\n\n  cell_gatherer.getCells(polygon_cells);\n}\n\n", "CodeBleu_score": 93.36073935552108}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)    PolygonOutlineCells cell_gatherer(*this);\n    for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n        raytraceLine(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + 1].x, polygon[i + 1].y);\n    }\n    if (!polygon.empty()) {\n        unsigned int last_index = polygon.size() - 1;\n        // we also need to close the polygon by going from the last point to the first\n        raytraceLine(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[0].x, polygon[0].y);\n    }\n\n    cell_gatherer.getCells(polygon_cells);\n}\n", "CodeBleu_score": 92.11652480954538}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  ROS_DEBUG(\"Costmap2DPublisher::onNewSubscription\");\n  prepareGrid();\n  pub.publish(grid_);\n}\n\n} // end namespace costmap_2d", "CodeBleu_score": 63.09676556918189}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  prepareGrid();\n  pub.publish(grid_);\n}\n", "CodeBleu_score": 78.18333018504747}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  ROS_DEBUG(\"Costmap2DPublisher::onNewSubscription\");\n  prepareGrid();\n  pub.publish(grid_);\n}\n", "CodeBleu_score": 65.66191994462031}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()    boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n    double resolution = costmap_->getResolution();\n\n    grid_.header.stamp = ros::Time::now();\n    grid_.header.frame_id = \"map\";\n\n    grid_.info.resolution = resolution;\n\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    double wx, wy;\n    costmap_->mapToWorld(0, 0, wx, wy);\n    grid_.info.origin.position.x = wx - resolution / 2;\n    grid_.info.origin.position.y = wy - resolution / 2;\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    unsigned char* data = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.data.size(); i++) {\n        grid_.data[i] = cost_translation_table_[data[i]];\n    }\n}\n", "CodeBleu_score": 87.03273280272607}, {"code": "void Costmap2DPublisher::prepareGrid()  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n  double resolution = costmap_->getResolution();\n\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = frame_id_;\n\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  grid_.info.origin.position.x = costmap_->getOriginX();\n  grid_.info.origin.position.y = costmap_->getOriginY();\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    if (data[i] == 0)\n      grid_.data[i] = -1;\n    else\n      grid_.data[i] = 100 * translate_char(data[i]);\n  }\n}\n", "CodeBleu_score": 70.5770100793926}, {"code": "void Costmap2DPublisher::prepareGrid()  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = \"map\";\n  grid_.info.resolution = resolution;\n\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n  grid_.info.origin.position.x = wx - resolution / 2;\n  grid_.info.origin.position.y = wy - resolution / 2;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  unsigned char* data = costmap_->getCharMap();\n  for (unsigned int i = 0; i < grid_.data.size(); i++) {\n    grid_.data[i] = cost_translation_table_[ data[ i ]];\n  }\n}\n", "CodeBleu_score": 89.59871089093112}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)    if (old_config.footprint == new_config.footprint) {\n        return;\n    }\n\n    if (new_config.footprint != \"\") {\n        std::vector<geometry_msgs::Point> new_footprint;\n        if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n            setRobotFootprint(new_footprint);\n        }\n    } else {\n        // if footprint parameter is an empty string, we'll just rely on the radius\n        setRobotFootprint(makeFootprintFromRadius(new_config.footprint_radius));\n    }\n}\n", "CodeBleu_score": 60.624436216886465}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)    if (new_config.footprint == old_config.footprint &&\n        new_config.robot_radius == old_config.robot_radius) {\n        return;\n    }\n\n    if (!new_config.footprint.empty()) {\n        std::vector<geometry_msgs::Point> new_footprint;\n        if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n            setRobotFootprint(new_footprint);\n        } else {\n            ROS_ERROR(\"Planner will always return zero cost because footprint specifided in \"\n                      \"parameter server is invalid.\");\n        }\n    } else {\n        // if no footprint is specified, make it a circle under the assumption that the\n        // robot is a circle\n        geometry_msgs::Point center;\n        center.x = center.y = center.z = 0.0;\n        std::vector<geometry_msgs::Point> footprint;\n        footprint.push_back(center);\n        setRobotFootprint(footprint, new_config.robot_radius);\n    }\n}\n", "CodeBleu_score": 66.88526949089122}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)    if (old_config.footprint == new_config.footprint &&\n        old_config.footprint_padding == new_config.footprint_padding &&\n        old_config.footprint_radius == new_config.footprint_radius) {\n        return;\n    }\n\n    if (new_config.footprint != \"\") {\n        std::vector<geometry_msgs::Point> new_footprint;\n        if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n            setFootprint(new_footprint);\n        }\n    } else if (new_config.footprint_radius > 0) {\n        setFootprint(makeFootprintFromRadius(new_config.footprint_radius));\n    }\n}\n", "CodeBleu_score": 69.85545432306488}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)    // get the current pose of the robot\n    geometry_msgs::PoseStamped new_pose;\n    if (!getRobotPose(new_pose)) {\n        ROS_WARN(\"[Costmap2DROS] Could not get robot pose, cancelling reconfiguration\");\n        return;\n    }\n\n    // determine the change in pose\n    geometry_msgs::PoseStamped old_pose = p_flist_->getOrigin();\n    double x = new_pose.pose.position.x - old_pose.pose.position.x,\n            y = new_pose.pose.position.y - old_pose.pose.position.y,\n            sq_dist = x * x + y * y;\n\n    // if we have moved further than we care about the threshold...\n    if (sq_dist >= min_x_ * min_x_ + min_y_ * min_y_) {\n        // we need to clear the footprint...\n        clearRobotFootprint();\n        // and update the local plan and its costs\n        p_flist_->setOrigin(new_pose);\n        updateMap(0, 0, width_, height_);\n    }\n}\n", "CodeBleu_score": 61.35388425717525}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  if (!tf_->canTransform(robot_base_frame_, global_frame_, ros::Time::now(), ros::Duration(0.05))) {\n    ROS_WARN(\"Transform between %s and %s was not available for more than 0.05s\", global_frame_.c_str(), robot_base_frame_.c_str());\n    return;\n  }\n\n  tf::Stamped<tf::Pose> new_pose;\n  geometry_msgs::PoseStamped new_pose_msg;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Could not get robot pose, cancelling reconfiguration\");\n    return;\n  }\n\n  tf::poseStampedTFToMsg(new_pose, new_pose_msg);\n\n  if (stop_updates_) {\n    if (!initialized_) {\n      // if we're just initializing, keep updating until we're done\n      ROS_DEBUG(\"Stopping updates during initialization\");\n      return;\n    }\n    // if we've been stopped for some amount of time, re-enable updates\n    if (stop_updates_time_.toSec() + stop_updates_duration_ < ros::Time::now().toSec()) {\n      stop_updates_ = false;\n      ROS_DEBUG(\"Re-enabling updates\");\n    } else {\n      // otherwise, ignore movement\n      ROS_DEBUG(\"Ignoring movement\");\n      return;\n    }\n  }\n\n  if (goal_x_ == new_pose_msg.pose.position.x && goal_y_ == new_pose_msg.pose.position.y) {\n    // we've reached our goal, so disable updates\n    stop_updates_ = true;\n    stop_updates_time_ = ros::Time::now();\n  }\n\n  if (run_thread_) {\n    // we have another thread currently running update\n    ROS_DEBUG(\"[Costmap2DROS] Preventing concurrent updates. Rejecting goal %.2f %.2f\", goal_x_, goal_y_);\n    return;\n  }\n\n  // the goal must be", "CodeBleu_score": 55.32080029706653}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  if (!costmap_)\n    return;\n\n  tf::Stamped<tf::Pose> new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"[Costmap2DROS] Could not get robot pose, cancelling reconfiguration\");\n    return;\n  }\n\n  // check if the pose has moved\n  if (fabs((old_pose_.getOrigin().x() - new_pose.getOrigin().x()) < resolution_ * 2.0) &&\n      fabs((old_pose_.getOrigin().y() - new_pose.getOrigin().y()) < resolution_ * 2.0) &&\n      fabs((old_pose_.getOrigin().z() - new_pose.getOrigin().z()) < resolution_ * 2.0)) {\n    return;\n  }\n\n  // update the old pose\n  old_pose_ = new_pose;\n\n  // determine the bounds of the update\n  double min_x = std::min(old_pose_.getOrigin().x(), new_pose.getOrigin().x());\n  double min_y = std::min(old_pose_.getOrigin().y(), new_pose.getOrigin().y());\n  double max_x = std::max(old_pose_.getOrigin().x(), new_pose.getOrigin().x());\n  double max_y = std::max(old_pose_.getOrigin().y(), new_pose.getOrigin().y());\n\n  // get the bounds of the costmap\n  double min_x_costmap, min_y_costmap, max_x_costmap, max_y_costmap;\n  costmap_->getBounds(&min_x_costmap, &min_y_costmap, &max_x_costmap, &max_y_costmap);\n\n  // check if the robot is within the bounds of the costmap\n  if (min_x < min_x_costmap || min_y < min_y_costmap || max_x > max_x_costmap || max_y > max_y_costmap) {\n    ROS_WARN(\"[Costmap2DROS] Robot is out of bounds", "CodeBleu_score": 55.172573525659665}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()  if (stopped_) {\n    // reactivate all the plugins\n    std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n    for (std::vector<boost::shared_ptr<Layer> >::iterator pluginp = plugins->begin(); pluginp != plugins->end(); ++pluginp) {\n      (*pluginp)->activate();\n    }\n    stopped_ = false;\n    stop_updates_ = false;\n    // start map update thread\n    map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, map_update_thread_interval_));\n  }\n  // block until the costmap is initialized.. it should be faster than the loop below\n  ROS_DEBUG(\"Waiting for move_base/global_costmap/costmap topic to be advertised\");\n  ros::WallTime start = ros::WallTime::now();\n  ros::WallDuration timeout(10.0);\n  ros::WallDuration elapsed = ros::WallTime::now() - start;\n  ros::WallDuration poll_interval(0.1);\n  while(ros::ok() && !costmap_initialized_ && elapsed < timeout)\n  {\n    poll_interval.sleep();\n    elapsed = ros::WallTime::now() - start;\n  }\n  if(!costmap_initialized_)\n  {\n    ROS_WARN(\"Failed to wait for costmap initialization. Waiting in loop.\");\n    while(ros::ok() && !costmap_initialized_)\n    {\n      ros::spinOnce();\n    }\n  }\n\n  // now that we know the costmap is initialized... we can spin\n  ros::spin();\n\n  // if we're stopped we need to re-subscribe to topics\n  stop_updates_ = true;\n  std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n  for (std::vector<boost::shared_ptr<Layer> >::iterator pluginp = plugins->begin(); plugin", "CodeBleu_score": 53.257730976815566}, {"code": "void Costmap2DROS::start()  std::vector<boost::shared_ptr<Layer> >* plugins = layered_costmap_->getPlugins();\n\n  // check if we're stopped or just not ready yet\n  if (stopped_) {\n    // we're stopped, so reactivate our plugins\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins->begin(); plugin != plugins->end();\n         ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n  }\n\n  // block until the costmap is reinitialized.. meaning one update cycle has run\n  ROS_DEBUG(\"Waiting for costmap to update\");\n  ros::Rate r(100);\n  while (ros::ok() && !initialized_)\n    r.sleep();\n  ROS_DEBUG(\"Costmap Started Up\");\n  stop_updates_ = false;\n\n  // if we're using a subscription-based costmap... we'll need to ensure that map updates are published\n  if (map_update_sub_)\n    map_update_sub_ = map_update_sub_;\n}\n", "CodeBleu_score": 77.70443872996786}, {"code": "void Costmap2DROS::start()  if (stopped_) {\n    // reactivate\n    for (std::vector<boost::shared_ptr<Layer> >::iterator plugin = plugins_.begin(); plugin != plugins_.end();\n        ++plugin) {\n      (*plugin)->activate();\n    }\n    stopped_ = false;\n    stop_updates_ = false;\n    initialized_ = true;\n    map_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this, map_update_frequency_));\n  }\n\n  // block until the costmap is initialized.. it should be faster than waiting for the\n  // map update loop to start\n  ros::Rate r(100);\n  while (ros::ok() && !initialized_)\n    r.sleep();\n}\n", "CodeBleu_score": 67.33382285292159}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()    if (observation_keep_time_ == 0) {\n        if (observations_.size() > 0) {\n            observations_.erase(observations_.begin() + 1, observations_.end());\n        }\n        return;\n    }\n\n    ros::Time now = ros::Time::now();\n    for (std::list<Observation>::iterator obs_it = observations_.begin(); obs_it != observations_.end(); ++obs_it) {\n        if (now - obs_it->header.stamp > observation_keep_time_) {\n            observations_.erase(obs_it, observations_.end());\n            return;\n        }\n    }\n}\n", "CodeBleu_score": 52.45912993560914}, {"code": "void ObservationBuffer::purgeStaleObservations()  if (observation_keep_time_ == 0) {\n    if (observations_.size() > 0) {\n      observations_.resize(1);\n    }\n    return;\n  }\n\n  ros::Time now = ros::Time::now();\n  for (size_t i = 0; i < observations_.size(); ++i) {\n    if (now - observations_[i].header.stamp > observation_keep_time_) {\n      observations_.erase(observations_.begin() + i, observations_.end());\n      break;\n    }\n  }\n}\n", "CodeBleu_score": 40.55049561848508}, {"code": "void ObservationBuffer::purgeStaleObservations()    if (observation_keep_time_ == 0) {\n        if (observation_list_.size() > 1) {\n            observation_list_.erase(observation_list_.begin(), observation_list_.end() - 1);\n        }\n    } else {\n        ros::Time current_time = ros::Time::now();\n        for (ObservationList::iterator iter = observation_list_.begin(); iter != observation_list_.end(); ++iter) {\n            if (current_time - iter->header.stamp > observation_keep_time_) {\n                observation_list_.erase(observation_list_.begin(), iter);\n                break;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 48.65481321275696}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)    double start_yaw, end_yaw, dtheta, interp_yaw;\n    int i;\n\n    start_yaw = tf::getYaw(path[start_index].pose.orientation);\n    end_yaw = tf::getYaw(path[end_index].pose.orientation);\n    dtheta = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    for (i = start_index; i < end_index; i++) {\n        interp_yaw = start_yaw + i * dtheta / (end_index - start_index);\n        path[i].pose.orientation = tf::createQuaternionMsgFromYaw(interp_yaw);\n    }\n}\n", "CodeBleu_score": 55.03027051969384}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)    double start_yaw, end_yaw, d_yaw;\n    start_yaw = tf::getYaw(path[start_index].pose.orientation);\n    end_yaw = tf::getYaw(path[end_index].pose.orientation);\n    d_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n    double increment = d_yaw / (end_index - start_index);\n    for (int i = start_index; i <= end_index; i++) {\n        double yaw = start_yaw + increment * (i - start_index);\n        path[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n    }\n}\n", "CodeBleu_score": 67.52662925415939}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)  double start_yaw, end_yaw, d_yaw, factor;\n  int index_delta = end_index - start_index;\n\n  if (index_delta < 0) {\n    ROS_ERROR(\"[interpolate] start index > end index : (%d, %d)\", start_index, end_index);\n    return;\n  } else if (index_delta == 0) {\n    change_.push_back(0);\n    return;\n  }\n\n  start_yaw = tf::getYaw(path[start_index].pose.orientation);\n  end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n  d_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  factor = (d_yaw / index_delta);\n\n  for (int i = 0; i < index_delta; i++) {\n    change_.push_back(start_yaw + factor * i);\n  }\n\n  for (int i = start_index; i < end_index; i++) {\n    tf::Quaternion q;\n    q.setRPY(0, 0, change_[i - start_index]);\n    tf::quaternionTFToMsg(q, path[i].pose.orientation);\n  }\n}\n", "CodeBleu_score": 51.31973985118062}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    std::vector<geometry_msgs::PoseStamped> plan;\n    makePlan(req.start, req.goal, plan);\n\n    // Update the response with the success status and the generated path\n    resp.success = !plan.empty();\n    resp.plan = plan;\n\n    // Return true to indicate that the service was processed\n    return true;\n}\n", "CodeBleu_score": 61.48049657936659}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)    std::vector<geometry_msgs::PoseStamped> path;\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n    bool success = makePlan(req.start, req.goal, path);\n    resp.plan_found = success;\n    if (success) {\n        resp.path = path;\n    }\n    return true;\n}\n", "CodeBleu_score": 92.39315961156409}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)    geometry_msgs::PoseStamped start;\n    geometry_msgs::PoseStamped goal;\n\n    start.header.frame_id = \"map\";\n    start.header.stamp = ros::Time::now();\n    start.pose = req.start;\n\n    goal.header.frame_id = \"map\";\n    goal.header.stamp = ros::Time::now();\n    goal.pose = req.goal;\n\n    std::vector<geometry_msgs::PoseStamped> plan;\n    bool success = makePlan(start, goal, plan);\n\n    resp.plan_found = success;\n    if (success) {\n        resp.path = plan;\n    }\n    return true;\n}\n", "CodeBleu_score": 60.61397167332739}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}\n", "CodeBleu_score": 63.695200034027856}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n    initialized_ = false;\n}\n", "CodeBleu_score": 63.17399027660575}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~\");\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}\n", "CodeBleu_score": 63.02611283673636}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)    if (wx < origin_x_ || wy < origin_y_)\n        return false;\n\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    if (mx < size_x_ && my < size_y_)\n        return true;\n\n    return false;\n}\n", "CodeBleu_score": 41.76811514288515}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)    if (wx < origin_x_ || wy < origin_y_)\n        return false;\n\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    if (mx < size_x_ && my < size_y_)\n        return true;\n\n    return false;\n}\n", "CodeBleu_score": 41.76811514288515}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)    if (wx < origin_x_ || wy < origin_y_)\n        return false;\n\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    if (mx < size_x_ && my < size_y_)\n        return true;\n\n    return false;\n}\n", "CodeBleu_score": 41.76811514288515}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)     if (!initialized_) {\n        ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    // create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    if (!path.empty()) {\n        gui_path.header.frame_id = path[0].header.frame_id;\n        gui_path.header.stamp = path[0].header.stamp;\n    }\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 88.2218418104165}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  if (!path.empty()) {\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n  }\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 92.63248349357995}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)     if (!initialized_) {\n        ROS_ERROR(\n                \"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n        return;\n    }\n\n    //create a message for the plan\n    nav_msgs::Path gui_path;\n    gui_path.poses.resize(path.size());\n\n    gui_path.header.frame_id = frame_id_;\n    gui_path.header.stamp = ros::Time::now();\n\n    // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n    for (unsigned int i = 0; i < path.size(); i++) {\n        gui_path.poses[i] = path[i];\n    }\n\n    plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 98.16804014274454}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\tROS_DEBUG(\"Received goal\");\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 66.79811137599187}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)    ROS_DEBUG(\"[MoveBase] Received goal\");\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 69.1131883235938}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)    ROS_DEBUG_STREAM(\"Received goal: \" << *goal);\n    move_base_msgs::MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 69.2410844179501}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)    // Check if the robot has moved far enough\n    if (std::pow(distance, 2) <= std::pow(distanceLimit, 2)) {\n        ROS_INFO(\"Robot has moved %f meters, stopping\", distanceLimit);\n        // Join and delete any existing remove limit thread\n        if (removeLimitThread.joinable()) {\n            removeLimitThread.join();\n        }\n        // Start a new thread to remove the speed limit\n        removeLimitThread = std::thread(&MoveSlowAndClear::removeLimit, this);\n        // Stop the distance check timer\n        distanceCheckTimer.stop();\n    }\n}\n", "CodeBleu_score": 43.740382036803794}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)    // Get the current distance\n    double currentDistance = std::pow(std::pow(currentX, 2) + std::pow(currentY, 2), 0.5);\n\n    // Check if the robot has moved far enough\n    if (currentDistance >= limitedDistance) {\n        ROS_INFO(\"MoveSlowAndClear: Robot has moved far enough, stopping the robot\");\n        // Stop the robot\n        geometry_msgs::Twist stop;\n        stop.linear.x = 0;\n        stop.linear.y = 0;\n        stop.linear.z = 0;\n        stop.angular.x = 0;\n        stop.angular.y = 0;\n        stop.angular.z = 0;\n        cmdVelPublisher.publish(stop);\n\n        // Join and delete any existing remove limit thread\n        if (removeLimitThread.joinable()) {\n            removeLimitThread.join();\n        }\n\n        // Start a new thread to remove the speed limit\n        removeLimitThread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n        // Stop the distance check timer\n        distanceCheckTimer.stop();\n    }\n}\n", "CodeBleu_score": 45.575802265387665}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)    if (squared_limited_distance <= squared_current_distance) {\n        ROS_INFO(\"Robot has moved far enough. Removing speed limit.\");\n        if (remove_limit_thread.joinable()) {\n            remove_limit_thread.join();\n        }\n        remove_limit_thread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n        distance_check_timer.stop();\n    }\n}\n", "CodeBleu_score": 42.48617738876179}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)    // Get the current pose of the robot\n    rm::PoseStamped start;\n    getRobotPose(start);\n\n    // Set the start and goal poses\n    geometry_msgs::PoseStamped start_pose, goal_pose;\n    start_pose.header.frame_id = \"map\";\n    start_pose.pose.position.x = start.x;\n    start_pose.pose.position.y = start.y;\n    start_pose.pose.orientation = tf::createQuaternionMsgFromYaw(start.theta);\n\n    goal_pose.header.frame_id = \"map\";\n    goal_pose.pose.position.x = goal->x;\n    goal_pose.pose.position.y = goal->y;\n    goal_pose.pose.orientation = tf::createQuaternionMsgFromYaw(goal->theta);\n\n    // Make the plan\n    std::vector<geometry_msgs::PoseStamped> plan;\n    makePlan(start_pose, goal_pose, plan);\n\n    // Publish the plan\n    nav_msgs::Path path;\n    path.header.frame_id = \"map\";\n    path.poses = plan;\n    plan_pub_.publish(path);\n}\n", "CodeBleu_score": 43.503003575274825}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  // Get the current global pose of the robot\n  geometry_msgs::PoseStamped start;\n  getRobotPose(start);\n\n  // Set the start pose to the current global pose\n  start.header.stamp = ros::Time::now();\n  start.header.frame_id = fixed_frame_;\n\n  // Set the goal pose to the received goal pose\n  geometry_msgs::PoseStamped goal_pose = goal->pose;\n\n  // Set the goal pose to the current global pose\n  goal_pose.header.stamp = ros::Time::now();\n  goal_pose.header.frame_id = fixed_frame_;\n\n  // Create an empty path vector\n  std::vector<geometry_msgs::PoseStamped> path;\n\n  // Generate a path from the current pose to the goal pose\n  makePlan(start, goal_pose, path);\n}\n", "CodeBleu_score": 45.278982427009176}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  // Get the current pose of the robot\n  geometry_msgs::PoseStamped start;\n  getRobotPose(start);\n\n  // Create a path vector\n  std::vector<geometry_msgs::PoseStamped> path;\n\n  // Generate a path from the current pose to the goal pose\n  if (!makePlan(start, *goal, path)) {\n    ROS_ERROR(\"Failed to find a path to the goal\");\n    return;\n  }\n\n  // Publish the path\n  nav_msgs::Path gui_path;\n  gui_path.header.frame_id = \"map\";\n  gui_path.header.stamp = ros::Time::now();\n  gui_path.poses = path;\n  plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 49.19419734933109}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)  dji_osdk_ros::GimbalParamSet gimbal_param_set;\n  gimbal_param_set.request.param_id = param_set.param_id;\n  gimbal_param_set.request.param_value = param_set.param_value;\n  param_set_client_.call(gimbal_param_set);\n}\n", "CodeBleu_score": 54.22058258786948}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)    dji_osdk_ros::GimbalParamSet gimbal_param_set;\n    gimbal_param_set.request.param_id = param_set.param_id;\n    gimbal_param_set.request.param_value = param_set.param_value;\n    param_set_client_.call(gimbal_param_set);\n}\n", "CodeBleu_score": 54.644487802012065}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)    // Create a ParamSet service request\n    dji_osdk_ros::GimbalParamSet param_set_req;\n\n    // Assign the parameter ID and value from the provided GimbalParamSet structure\n    param_set_req.param_id = param_set.param_id;\n    param_set_req.value = param_set.value;\n\n    // Call the param_set_client_ to send the request\n    param_set_client_.call(param_set_req);\n}\n", "CodeBleu_score": 49.64761937847585}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()    // Create a socket\n    int server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd < 0) {\n        std::cerr << \"Error creating socket\" << std::endl;\n        return;\n    }\n\n    // Bind the socket to a specific address and port\n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = INADDR_ANY;\n    server_address.sin_port = htons(port_);\n    if (bind(server_fd, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) {\n        std::cerr << \"Error binding socket\" << std::endl;\n        return;\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 1) < 0) {\n        std::cerr << \"Error listening for incoming connections\" << std::endl;\n        return;\n    }\n\n    // Accept incoming connections\n    while (true) {\n        int client_fd = accept(server_fd, NULL, NULL);\n        if (client_fd < 0) {\n            std::cerr << \"Error accepting incoming connection\" << std::endl;\n            continue;\n        }\n\n        // Receive data from the client\n        char buffer[1024];\n        int bytes_received = recv(client_fd, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            std::cerr << \"Error receiving data from client\" << std::endl;\n            close(client_fd);\n            continue;\n        }\n\n        // Process the received data\n        std::string received_data(buffer, bytes_received);\n        processReceivedData(received_data);\n\n        // Close the client socket\n        close(client_fd);\n    }\n\n    // Close the server socket\n    close(server_fd);\n}\n", "CodeBleu_score": 48.92132245990229}, {"code": "void CommunicationBridge::serverFun()    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    int valread;\n\n    // Create socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,\n                   &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(port);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *) &address,\n             sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *) &address,\n                                 (socklen_t *) &addrlen)) < 0) {\n            perror(\"accept\");\n            exit(EXIT_FAILURE);\n        }\n        valread = read(new_socket, buffer, 1024);\n        if (valread > 0) {\n            // decode the message\n            std::string message(buffer, valread);\n            std::string decoded_message = decodeMessage(message);\n\n            // publish the decoded message\n            publishMessage(decoded_message);\n        } else if (valread <= 0) {", "CodeBleu_score": 54.83587618904866}, {"code": "void CommunicationBridge::serverFun()    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,\n                   &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *) &address,\n             sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    if ((new_socket = accept(server_fd, (struct sockaddr *) &address,\n                             (socklen_t *) &addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n    while (true) {\n        int valread;\n        char buffer[1024] = {0};\n        valread = read(new_socket, buffer, 1024);\n        if (valread > 0) {\n            std::string msg = buffer;\n            std::stringstream ss(msg);\n            std::string token;\n            std::vector<std::string> tokens;\n            while (std::getline(ss, token, ',')) {\n                tokens.push_back(token);", "CodeBleu_score": 52.36061815858308}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)  if (simulation_mode_) {\n    for (int i = 0; i < swarm_control_simulation_->num_uavs(); i++) {\n      if (uav_cmd.id == swarm_control_simulation_->get_uav_id(i)) {\n        swarm_control_simulation_->set_uav_command(i, uav_cmd);\n      }\n    }\n  } else {\n    uav_basic_->set_uav_command(uav_cmd);\n  }\n}\n", "CodeBleu_score": 38.77703593653574}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)  if (simulation_mode_) {\n    if (uav_cmd.uav_id >= swarm_control_simulation_.size()) {\n      std::cout << \"ERROR: UAV ID \" << uav_cmd.uav_id << \" not found in simulation.\" << std::endl;\n      return;\n    }\n    swarm_control_simulation_[uav_cmd.uav_id]->recvData(uav_cmd);\n  } else {\n    uav_basic_->recvData(uav_cmd);\n  }\n}\n", "CodeBleu_score": 39.151330301848105}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)    if (simulation_mode_) {\n        if (uav_cmd.id < swarm_control_simulation_.size()) {\n            swarm_control_simulation_[uav_cmd.id]->recvData(uav_cmd);\n        }\n    } else {\n        uav_basic_->recvData(uav_cmd);\n    }\n}\n", "CodeBleu_score": 36.40171157566855}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.use_mode) {\n        createMode(mode_selection.mode);\n    } else {\n        deleteMode(mode_selection.mode);\n    }\n    if (mode_selection.mode == Mode::REBOOTNX) {\n        system(\"reboot\");\n    } else if (mode_selection.mode == Mode::EXITNX) {\n        system(\"exit\");\n    }\n}\n", "CodeBleu_score": 47.001157399854144}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.mode == REBOOTNX) {\n        // Execute system command for REBOOTNX mode\n        system(\"reboot\");\n    } else if (mode_selection.mode == EXITNX) {\n        // Execute system command for EXITNX mode\n        system(\"exit\");\n    } else {\n        if (mode_selection.use_mode) {\n            // Call createMode function for the specified mode\n            createMode(mode_selection.mode);\n        } else {\n            // Call deleteMode function for the specified mode\n            deleteMode(mode_selection.mode);\n        }\n    }\n}\n", "CodeBleu_score": 47.66860186685931}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.use_mode == REBOOTNX) {\n        system(\"sudo reboot\");\n    } else if (mode_selection.use_mode == EXITNX) {\n        system(\"sudo poweroff\");\n    } else if (mode_selection.use_mode == CREATEMODE) {\n        createMode(mode_selection.mode_name);\n    } else if (mode_selection.use_mode == DELETEMODE) {\n        deleteMode(mode_selection.mode_name);\n    }\n}\n", "CodeBleu_score": 52.97774310796919}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\n    if (heartbeat_count == heartbeat_count_prev) {\n        heartbeat_count++;\n    } else {\n        heartbeat_count_prev = heartbeat_count;\n        heartbeat_count = 0;\n    }\n\n    if (heartbeat_count == heartbeat_count_threshold) {\n        ROS_ERROR(\"Communication lost with vehicle\");\n        if (vehicle_type == \"swarm\") {\n            // TODO: Implement action for swarm\n        } else if (vehicle_type == \"UAV\") {\n            // TODO: Implement action for UAV\n        } else if (vehicle_type == \"UGV\") {\n            // TODO: Implement action for UGV\n        }\n        disconnect_flag = true;\n    }\n}\n", "CodeBleu_score": 38.29348132529628}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    if (vehicle_type == \"UAV\") {\n        if (heartbeat_count == heartbeat_threshold) {\n            ROS_ERROR(\"UAV heartbeat lost\");\n            disconnect_flag = true;\n        }\n    } else if (vehicle_type == \"UGV\") {\n        if (heartbeat_count == heartbeat_threshold) {\n            ROS_ERROR(\"UGV heartbeat lost\");\n            disconnect_flag = true;\n        }\n    } else if (vehicle_type == \"Swarm\") {\n        if (heartbeat_count == heartbeat_threshold) {\n            ROS_ERROR(\"Swarm heartbeat lost\");\n            disconnect_flag = true;\n        }\n    }\n}\n", "CodeBleu_score": 34.72615863750112}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    if (heartbeat_count_ == heartbeat_count_prev_) {\n        heartbeat_miss_count_++;\n        if (heartbeat_miss_count_ >= heartbeat_miss_count_threshold_) {\n            ROS_ERROR(\"CommunicationBridge: Heartbeat missed %d times. Disconnecting...\", heartbeat_miss_count_);\n            disconnect_flag_ = true;\n            if (vehicle_type_ == \"UAV\") {\n                // Trigger UAV-specific actions\n            } else if (vehicle_type_ == \"UGV\") {\n                // Trigger UGV-specific actions\n            } else if (vehicle_type_ == \"Swarm\") {\n                // Trigger swarm-specific actions\n            }\n        }\n    } else {\n        heartbeat_miss_count_ = 0;\n    }\n\n    heartbeat_count_prev_ = heartbeat_count_;\n}\n", "CodeBleu_score": 32.05366354622752}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)  // Extract drone ID and trajectory data from the message\n  int drone_id = msg->drone_id;\n  std::vector<prometheus_msgs::Bspline> traj = msg->trajectory;\n\n  // Initialize a MultiBsplines struct and set its attributes\n  MultiBsplines multi_traj;\n  multi_traj.drone_id = drone_id;\n  multi_traj.trajectory.resize(traj.size());\n\n  // Populate the MultiBsplines struct with trajectory data\n  for (int i = 0; i < traj.size(); i++) {\n    // Initialize a Bspline struct and set its attributes\n    Bspline bspline;\n    bspline.degree = traj[i].degree;\n    bspline.control_points.resize(traj[i].control_points.size());\n    bspline.knots.resize(traj[i].knots.size());\n    bspline.position_points.resize(traj[i].position_points.size());\n    bspline.yaw_points.resize(traj[i].yaw_points.size());\n\n    // Populate the Bspline struct with trajectory data\n    for (int j = 0; j < traj[i].control_points.size(); j++) {\n      bspline.control_points[j].x = traj[i].control_points[j].x;\n      bspline.control_points[j].y = traj[i].control_points[j].y;\n      bspline.control_points[j].z = traj[i].control_points[j].z;\n    }\n    for (int j = 0; j < traj[i].knots.size(); j++) {\n      bspline.knots[j] = traj[i].knots[j];\n    }\n    for (int j = 0; j < traj[i].position_points.size(); j++) {\n      bspline.position_points[j].x = traj[i].position_points[j", "CodeBleu_score": 54.35771011036764}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    // ROS_INFO(\"[EGOPlannerSwarm] MultiBsplines message received.\");\n    int drone_id = msg->drone_id;\n\n    // Extract trajectory data\n    vector<Bspline> traj_vec;\n    for (int i = 0; i < msg->traj_num; i++) {\n        Bspline traj;\n        traj.order = msg->traj_order[i];\n        traj.control_points_pos = msg->traj_pts[i].control_points_pos;\n        traj.knots = msg->traj_pts[i].knots;\n        traj_vec.push_back(traj);\n    }\n\n    // Encode MultiBsplines data\n    prometheus_msgs::MultiBsplines multi_bsplines_msg;\n    multi_bsplines_msg.drone_id = drone_id;\n    multi_bsplines_msg.traj_num = traj_vec.size();\n    for (int i = 0; i < traj_vec.size(); i++) {\n        prometheus_msgs::Bspline bspline_msg;\n        bspline_msg.order = traj_vec[i].order;\n        bspline_msg.control_points_pos = traj_vec[i].control_points_pos;\n        bspline_msg.knots = traj_vec[i].knots;\n        multi_bsplines_msg.traj_pts.push_back(bspline_msg);\n    }\n\n    // Send MultiBsplines data via TCP\n    communication_module_->sendTcpData(multi_bsplines_msg);\n}\n", "CodeBleu_score": 45.98240686116535}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    // Extract the drone ID from the message\n    int drone_id = msg->drone_id;\n\n    // Create a MultiBsplines struct to store the trajectory data\n    MultiBsplines multi_bsplines;\n\n    // Iterate over the trajectory data in the message\n    for (int i = 0; i < msg->traj_num; i++) {\n        // Create a Bspline struct to store the trajectory data\n        Bspline bspline;\n\n        // Set the attributes of the Bspline struct\n        bspline.order = msg->traj[i].order;\n        bspline.control_points_num = msg->traj[i].control_points_num;\n        bspline.knots_num = msg->traj[i].knots_num;\n\n        // Populate the knots, position points, and yaw points of the Bspline struct\n        for (int j = 0; j < msg->traj[i].knots_num; j++) {\n            bspline.knots.push_back(msg->traj[i].knots[j]);\n        }\n        for (int j = 0; j < msg->traj[i].control_points_num; j++) {\n            bspline.control_points.push_back(msg->traj[i].control_points[j]);\n            bspline.yaw_points.push_back(msg->traj[i].yaw_points[j]);\n        }\n\n        // Add the Bspline struct to the MultiBsplines struct\n        multi_bsplines.traj.push_back(bspline);\n    }\n\n    // Encode the MultiBsplines data\n    string encoded_data = multi_bsplines.encode();\n\n    // Send the encoded data via TCP using the communication module\n    // communication_module.send_data(encoded_data);\n}\n", "CodeBleu_score": 53.156586236314496}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(10.0f);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n    std::vector<unsigned char> compressed_data;\n    octree.serializeTree(compressed_data);\n\n    // Create a new PointCloud2 message with the compressed data\n    sensor_msgs::PointCloud2 compressed_msg;\n    compressed_msg.header = msg.header;\n    compressed_msg.height = 1;\n    compressed_msg.width = compressed_data.size();\n    compressed_msg.is_bigendian = false;\n    compressed_msg.is_dense = true;\n    compressed_msg.point_step = 1;\n    compressed_msg.row_step = compressed_data.size();\n    compressed_msg.fields.resize(1);\n    compressed_msg.fields[0].name = \"compressed_data\";\n    compressed_msg.fields[0].offset = 0;\n    compressed_msg.fields[0].datatype = sensor_msgs::PointField::UINT8;\n    compressed_msg.fields[0].count = 1;\n    compressed_msg.data = compressed_data;\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    return compressed_msg;\n}\n", "CodeBleu_score": 47.72833269266209}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.01);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n\n    std::vector<int> pointIdxVec;\n    octree.getPointIndices(pointIdxVec);\n\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n    for (size_t i = 0; i < pointIdxVec.size(); ++i) {\n        cloud_compressed->push_back(cloud->points[pointIdxVec[i]]);\n    }\n\n    sensor_msgs::PointCloud2 msg_compressed;\n    pcl::toROSMsg(*cloud_compressed, msg_compressed);\n    msg_compressed.header = msg.header;\n\n    return msg_compressed;\n}\n", "CodeBleu_score": 45.7323793087341}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    // Convert the input message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create a new PointCloud2 message\n    sensor_msgs::PointCloud2 compressed_msg;\n\n    // Compress the point cloud\n    std::vector<int> mapping;\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(128.0f);\n    octree.encodePointCloud(cloud, compressed_msg, mapping);\n\n    // Release dynamically allocated memory\n    cloud.reset();\n\n    // Return the compressed message\n    return compressed_msg;\n}\n", "CodeBleu_score": 30.73917119415342}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 63.0685877507056}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)    for (auto &uav : multi_uav_state_) {\n        if (uav.uav_id == uav_state.uav_id) {\n            uav = uav_state;\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 39.692851038779786}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n            multi_uav_state_[i] = uav_state;\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 63.0685877507056}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    swarm_control::MultiUGVState multi_ugv_state;\n    multi_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n    for (int i = 0; i < multi_ugv_state.ugv_count; i++) {\n        swarm_control::UGVState ugv_state;\n        ugv_state.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n        ugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        ugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        ugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        ugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        ugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        ugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        ugv_state.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        ugv_state.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n        ugv_state.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n        ugv_state.attitude.w = m_multi_ugv_state.ugv_state[i].attitude.w;\n        multi_ugv_state.ugv_state.push_back(ugv_state);\n    }\n    multi_ugv_state_pub.", "CodeBleu_score": 46.38019921064001}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    swarm_control::MultiUGVState multi_ugv_state_msg;\n    int ugv_count = 0;\n    for (auto &ugv_state : m_multi_ugv_state.ugv_state) {\n        swarm_control::UGVState ugv_state_msg;\n        ugv_state_msg.id = ugv_state.id;\n        ugv_state_msg.battery = ugv_state.battery;\n        ugv_state_msg.position.x = ugv_state.position.x;\n        ugv_state_msg.position.y = ugv_state.position.y;\n        ugv_state_msg.position.z = ugv_state.position.z;\n        ugv_state_msg.velocity.x = ugv_state.velocity.x;\n        ugv_state_msg.velocity.y = ugv_state.velocity.y;\n        ugv_state_msg.velocity.z = ugv_state.velocity.z;\n        ugv_state_msg.attitude.x = ugv_state.attitude.x;\n        ugv_state_msg.attitude.y = ugv_state.attitude.y;\n        ugv_state_msg.attitude.z = ugv_state.attitude.z;\n        ugv_state_msg.attitude.w = ugv_state.attitude.w;\n        multi_ugv_state_msg.ugv_state.push_back(ugv_state_msg);\n        ugv_count++;\n    }\n    multi_ugv_state_msg.ugv_count = ugv_count;\n    multi_ugv_state_pub.publish(multi_ugv_state_msg);\n}\n", "CodeBleu_score": 44.028963819567494}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    swarm_control::MultiUGVState multi_ugv_state_msg;\n    int ugv_count = 0;\n    for (auto &ugv_state : m_multi_ugv_state.ugv_states) {\n        swarm_control::UGVState ugv_state_msg;\n        ugv_state_msg.id = ugv_state.id;\n        ugv_state_msg.battery = ugv_state.battery;\n        ugv_state_msg.position.x = ugv_state.position.x;\n        ugv_state_msg.position.y = ugv_state.position.y;\n        ugv_state_msg.position.z = ugv_state.position.z;\n        ugv_state_msg.velocity.x = ugv_state.velocity.x;\n        ugv_state_msg.velocity.y = ugv_state.velocity.y;\n        ugv_state_msg.velocity.z = ugv_state.velocity.z;\n        ugv_state_msg.attitude.x = ugv_state.attitude.x;\n        ugv_state_msg.attitude.y = ugv_state.attitude.y;\n        ugv_state_msg.attitude.z = ugv_state.attitude.z;\n        ugv_state_msg.attitude.w = ugv_state.attitude.w;\n        multi_ugv_state_msg.ugv_states.push_back(ugv_state_msg);\n        ugv_count++;\n    }\n    multi_ugv_state_msg.ugv_count = ugv_count;\n    multi_ugv_state_pub.publish(multi_ugv_state_msg);\n}\n", "CodeBleu_score": 43.96474838101253}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  // Set the clearance for avoiding obstacles\n  double clearance = 0.5;\n\n  // Initialize the cost and gradient to zero\n  cost = 0.0;\n  gradient.setZero();\n\n  // Iterate through control points of the B-spline\n  for (int i = 0; i < q.rows(); i++) {\n    // Get the position of the current control point\n    Eigen::Vector3d pos = q.row(i);\n\n    // Iterate through moving objects\n    for (int j = 0; j < moving_obstacles_.size(); j++) {\n      // Get the position of the current moving object\n      Eigen::Vector3d obstacle_pos = moving_obstacles_[j].pos;\n\n      // Compute the predicted position of the moving object at the current control point\n      double t = i * dt_;\n      Eigen::Vector3d predicted_pos = obstacle_pos + obstacle_vel_[j] * t;\n\n      // Compute the distance between the current control point and the predicted position of the moving object\n      Eigen::Vector3d diff = pos - predicted_pos;\n      double dist = diff.norm();\n\n      // If the distance is less than the clearance, update the cost and gradient\n      if (dist < clearance) {\n        double dist_error = clearance - dist;\n        cost += dist_error * dist_error;\n        gradient.row(i) += 2.0 * dist_error * diff.transpose();\n      }\n    }\n  }\n}\n", "CodeBleu_score": 45.24387767083342}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  /*\n   * q: The control points of the B-spline trajectory.\n   * cost: The total cost of the trajectory.\n   * gradient: The gradient of the cost with respect to the control points.\n   */\n  cost = 0.0;\n  gradient.setZero();\n\n  int i(0);\n  for (i = 0; i < q.rows() - 1; ++i) {\n    Eigen::Vector2d pos(q.row(i));\n    Eigen::Vector2d vel((q.row(i + 1) - q.row(i)) * inv_time_interval_);\n    double t(i * time_interval_);\n    double min_dist(DBL_MAX);\n    Eigen::Vector2d min_pt;\n    for (int j(0); j < moving_obstacles_.size(); ++j) {\n      Eigen::Vector2d pt(moving_obstacles_[j].getPosition(t));\n      double dist(std::pow((pos - pt).norm() - moving_obstacles_[j].getRadius(), 2));\n      if (dist < min_dist) {\n        min_dist = dist;\n        min_pt = pt;\n      }\n    }\n    if (min_dist < clearance_) {\n      cost += weight_obstacle_ * min_dist;\n      Eigen::Vector2d g(2 * (pos - min_pt).transpose() * (pos - min_pt));\n      gradient.row(i) += g;\n      gradient.row(i + 1) -= g;\n    }\n  }\n}\n", "CodeBleu_score": 39.67140940013187}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  /*\n   * q: control points of the B-spline trajectory\n   * cost: cost of the trajectory\n   * gradient: gradient of the cost with respect to the control points\n   */\n  int q_size = q.rows();\n  int p_size = q.cols();\n  int ctrl_pts_num = q_size - p_size;\n  double distance;\n  Eigen::VectorXd q_i, q_ip1, q_ip2;\n  Eigen::VectorXd gradient_i, gradient_ip1, gradient_ip2;\n  Eigen::VectorXd gradient_tmp;\n  Eigen::Vector3d obj_pos;\n  Eigen::Vector3d obj_vel;\n  Eigen::Vector3d obj_acc;\n  Eigen::Vector3d obj_jerk;\n  Eigen::Vector3d pos, vel, acc, jerk;\n  Eigen::MatrixXd gradient_obj;\n  double cost_tmp;\n  double obj_radius;\n  double t, t_s, t_e;\n  double delta_t;\n  double t_scale = bspline_traj_.getTimeSum();\n  double obj_vel_max_limit, obj_acc_max_limit;\n  double obj_vel_max, obj_acc_max;\n  Eigen::Vector3d last_pos, last_vel;\n  bool is_static_obj;\n\n  cost = 0.0;\n  gradient.setZero();\n  gradient_obj.setZero(3, ctrl_pts_num);\n  for (int i = 0; i < ctrl_pts_num; ++i) {\n    q_i = q.row(i);\n    q_ip1 = q.row(i + 1);\n    q_ip2 = q.row(i + 2);\n    gradient_i = gradient.row(i);\n    gradient_ip1 = gradient.row(i + 1);\n    gradient_ip2 = gradient.row(i + 2);\n\n    for (int j = 0; j < moving_obstacles_.size(); ++j) {\n      obj_pos = moving_obstacles", "CodeBleu_score": 39.8152557031244}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  cost = 0.0;\n  gradient.setZero();\n  int N = q.cols();\n  int n = N - 1;\n  int m = N + 2 * p - 1;\n  Eigen::MatrixXd Q = Eigen::MatrixXd::Zero(3, m + 1);\n  for (int i = 0; i < N; i++) {\n    Q.block(0, i, 3, 1) = q.block(0, i, 3, 1);\n  }\n  for (int i = N - 1; i >= 0; i--) {\n    Q.block(0, i + p + 1, 3, 1) = q.block(0, i, 3, 1);\n  }\n  for (int i = 0; i < p; i++) {\n    Q.block(0, p - i, 3, 1) = q.block(0, 0, 3, 1);\n    Q.block(0, m - i, 3, 1) = q.block(0, n - 1, 3, 1);\n  }\n  Eigen::MatrixXd dQ = Eigen::MatrixXd::Zero(3, m);\n  for (int i = 0; i < m; i++) {\n    dQ.block(0, i, 3, 1) = Q.block(0, i + 1, 3, 1) - Q.block(0, i, 3, 1);\n  }\n  Eigen::MatrixXd ddQ = Eigen::MatrixXd::Zero(3, m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    ddQ.block(0, i, 3, 1) = dQ.block(0, i + 1, 3, 1) - dQ.block(0, i, 3, 1);\n  }\n  Eigen::MatrixXd dddQ = Eigen::MatrixXd::Zero(3, m - 2);\n  for (int i = 0; i < m - 2;", "CodeBleu_score": 30.836445946018355}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    // initialize the cost to zero\n    cost = 0.0;\n    // iterate through the control points of the trajectory\n    for (int i = 0; i < q.rows(); i++) {\n        // compute the positional error relative to reference points\n        Eigen::Vector3d pos_error = q.row(i).transpose() - ref_pts.row(i).transpose();\n        // compute the velocity vector\n        Eigen::Vector3d vel_vec = (q.row(i) - q.row(i - 1)).transpose() / dt;\n        // compute the cost function based on the squared dot product and cross product of the positional error and velocity vectors\n        double a2 = 1.0;\n        double b2 = 1.0;\n        cost += (pos_error.dot(pos_error) + a2 * vel_vec.dot(vel_vec)) / b2;\n        // compute the gradient for the control point\n        Eigen::Vector3d grad = pos_error / b2 + (2.0 * a2 * vel_vec) / b2;\n        // update the gradient for the control point\n        gradient.row(i) = grad.transpose();\n    }\n}\n", "CodeBleu_score": 31.17051051739454}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    // initialize the cost to zero\n    cost = 0;\n    // initialize the gradient to zero\n    gradient.setZero();\n    // iterate through the control points of the trajectory\n    for (int i = 0; i < q.cols(); i++) {\n        // compute the positional error relative to reference points\n        Eigen::Vector3d pos_err = q.col(i) - ref_pts_.col(i);\n        // compute the velocity vector\n        Eigen::Vector3d vel_vec = Eigen::Vector3d::Zero();\n        if (i < q.cols() - 1) {\n            vel_vec = q.col(i + 1) - q.col(i);\n        }\n        // compute the cost function\n        double a2 = pos_err.dot(pos_err);\n        double b2 = vel_vec.dot(vel_vec);\n        cost += a2 / a2 + b2 / b2;\n        // compute the gradient for this control point\n        Eigen::Vector3d grad_pos = 2 * pos_err / a2;\n        Eigen::Vector3d grad_vel = 2 * vel_vec / b2;\n        gradient.col(i) = grad_pos + grad_vel;\n    }\n}\n", "CodeBleu_score": 35.856699983046056}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()    Eigen::MatrixXd jerk_traj = UniformBspline::getDerivative().getDerivative().getDerivative();\n    UniformBspline jerk_traj_uni(jerk_traj, 3, getT());\n    double jerk = 0.0;\n    double time = jerk_traj_uni.getTimeSum();\n    vector<double> kts = jerk_traj_uni.getKnot();\n    vector<Eigen::Vector3d> cpts = jerk_traj_uni.getControlPoint();\n    for (int i = 0; i < int(time / kts[1]); i++) {\n        for (int j = 0; j < 3; j++) {\n            jerk += (cpts[i + 1](j) - cpts[i](j)) * (cpts[i + 1](j) - cpts[i](j)) * (kts[i + 1] - kts[i]) * (kts[i + 1] - kts[i]);\n        }\n    }\n    return jerk;\n}\n", "CodeBleu_score": 56.93541152939838}, {"code": "double UniformBspline::getJerk()  UniformBspline jerk_traj = getDerivative().getDerivative().getDerivative();\n  double jerk = 0.0;\n  double time_step = jerk_traj.getTimeSum();\n  vector<double> kts = jerk_traj.getKnot();\n  vector<Eigen::Vector3d> ctrl_pts = jerk_traj.getControlPoint();\n  for (int i = 0; i < int(ctrl_pts.size()) - 1; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      jerk += (ctrl_pts[i + 1][j] - ctrl_pts[i][j]) * (ctrl_pts[i + 1][j] - ctrl_pts[i][j]) *\n              (kts[i + 1] - kts[i]);\n    }\n  }\n  jerk = sqrt(jerk / time_step);\n  return jerk;\n}\n", "CodeBleu_score": 64.50591130001054}, {"code": "double UniformBspline::getJerk()  // Calculate the third derivative of the spline\n  Eigen::MatrixXd jerkCoeffs = UniformBspline::getDerivative().getDerivative().getDerivative().control_points_;\n\n  // Retrieve the knot times and control points of the jerk trajectory\n  double time = UniformBspline::getTimeSum();\n  Eigen::MatrixXd ctrl_pts = jerkCoeffs;\n\n  // Initialize the total jerk value to zero\n  double jerk = 0.0;\n\n  // Iterate through the control points and dimensions\n  for (int i = 0; i < ctrl_pts.rows(); ++i) {\n    for (int j = 0; j < ctrl_pts.cols(); ++j) {\n      // Sum the squared control point values multiplied by the differences in knot times\n      jerk += (ctrl_pts.coeffRef(i, j) * ctrl_pts.coeffRef(i, j)) * (time / ctrl_pts.rows());\n    }\n  }\n\n  // Return the total jerk value\n  return jerk;\n}\n", "CodeBleu_score": 56.999324823797906}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)     Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n    return pos;\n}\n", "CodeBleu_score": 62.86309382919195}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)     Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}\n", "CodeBleu_score": 75.88734546841431}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)     Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1;\n    return pos;\n}\n", "CodeBleu_score": 74.63261055051046}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\tstd::string drone_id = odom.child_frame_id;\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (...) {\n\t\tROS_WARN(\"DroneDetector::rcvDroneXOdomCallback: Error extracting drone ID from odometry message\");\n\t}\n}\n", "CodeBleu_score": 38.87120188122085}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\tstd::string drone_id = odom.child_frame_id;\n\t\trcvDroneOdomCallbackBase(odom, drone_id);\n\t} catch (std::exception& e) {\n\t\tstd::cout << \"DroneDetector::rcvDroneXOdomCallback: \" << e.what() << std::endl;\n\t}\n}\n", "CodeBleu_score": 53.131901325051146}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)    try {\n        std::string drone_id = odom.child_frame_id;\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error extracting drone ID from odometry message: \" << e.what() << std::endl;\n    }\n}\n", "CodeBleu_score": 51.828000553086575}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    Eigen::Vector3d true_pose;\n    true_pose << true_pixel(0), true_pixel(1), 0;\n    if (detect(drone_id, true_pose)) {\n        // Compute pose error\n        Eigen::Vector3d pose_error = true_pose - pose_estimate_;\n        pose_error(2) = wrapToPi(pose_error(2));\n        // Update debug result\n        debug_result_.drone_id = drone_id;\n        debug_result_.pose_error = pose_error;\n        debug_result_.found = true;\n        // Publish pose error\n        geometry_msgs::PointStamped pose_error_msg;\n        pose_error_msg.header.stamp = ros::Time::now();\n        pose_error_msg.header.frame_id = \"world\";\n        pose_error_msg.point.x = pose_error(0);\n        pose_error_msg.point.y = pose_error(1);\n        pose_error_msg.point.z = pose_error(2);\n        pose_error_pub_.publish(pose_error_msg);\n    } else {\n        // Update debug result\n        debug_result_.drone_id = drone_id;\n        debug_result_.found = false;\n    }\n}\n", "CodeBleu_score": 45.80672126105784}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = calculate_true_pose(true_pixel);\n\n    // Check for the presence of the drone in the camera frame\n    bool detected = check_presence(true_pose);\n\n    // Update the debug result\n    if (detected) {\n        // Compute the pose error between the camera and world coordinates\n        Eigen::Vector3d error = compute_pose_error(true_pose);\n\n        // Publish the pose error\n        publish_pose_error(error);\n    } else {\n        // Update the debug result to indicate failure\n        update_debug_result(drone_id, false);\n    }\n}\n", "CodeBleu_score": 22.04648170818695}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // Calculate the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose = camera_model_->pixelToCamera(true_pixel);\n\n    // Check for the presence of the drone\n    bool found = false;\n    Eigen::Vector3d camera_pose;\n    for (int i = 0; i < drones_.size(); i++) {\n        if (drones_[i].id == drone_id) {\n            found = true;\n            camera_pose = drones_[i].pose;\n            break;\n        }\n    }\n\n    // If found, compute the pose error between the camera and world coordinates\n    if (found) {\n        Eigen::Vector3d error = camera_pose - true_pose;\n        double error_norm = error.norm();\n        std::cout << \"Drone \" << drone_id << \" found with error: \" << error_norm << std::endl;\n\n        // Update the debug result\n        debug_result_.found = true;\n        debug_result_.error = error_norm;\n        debug_result_.drone_id = drone_id;\n        debug_result_.camera_pose = camera_pose;\n        debug_result_.true_pose = true_pose;\n    } else {\n        // Update the debug result to indicate failure\n        debug_result_.found = false;\n        debug_result_.error = -1;\n        debug_result_.drone_id = -1;\n        debug_result_.camera_pose = Eigen::Vector3d::Zero();\n        debug_result_.true_pose = Eigen::Vector3d::Zero();\n    }\n\n    // Publish the pose error\n    publishPoseError(debug_result_);\n}\n", "CodeBleu_score": 40.41166766886544}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    // iteratively follow the path\n    while (current != nullptr) {\n        path.push_back(current);\n        current = current->cameFrom;\n    }\n    // reverse the path\n    reverse(path.begin(), path.end());\n    return path;\n}\n", "CodeBleu_score": 64.91567580182164}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    // Start from the end node\n    path.push_back(current);\n    while (current->cameFrom != NULL) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    // Reverse the path\n    reverse(path.begin(), path.end());\n    return path;\n}\n", "CodeBleu_score": 89.47573048970906}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}\n", "CodeBleu_score": 90.00937038904927}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)    if (!Pos2Index(start_pt, start_idx) || !Pos2Index(end_pt, end_idx))\n        return false;\n\n    if (isOccupied(start_idx)) {\n        //ROS_WARN(\"Start point is inside occupied voxel, force set to be free.\");\n        //return false;\n        do {\n            start_pt = start_pt + (end_pt - start_pt).normalized() * resolution / 5.0;\n            Pos2Index(start_pt, start_idx);\n        } while (isOccupied(start_idx));\n    }\n\n    if (isOccupied(end_idx)) {\n        //ROS_WARN(\"End point is inside occupied voxel, force set to be free.\");\n        //return false;\n        do {\n            end_pt = end_pt + (start_pt - end_pt).normalized() * resolution / 5.0;\n            Pos2Index(end_pt, end_idx);\n        } while (isOccupied(end_idx));\n    }\n\n    return true;\n}\n", "CodeBleu_score": 60.70440940575803}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)    if (!Coord2Index(start_pt, start_idx) || !Coord2Index(end_pt, end_idx))\n        return false;\n\n    if (isObs(start_idx) || isObs(end_idx)) {\n        ROS_WARN(\"Start or end point is inside obstacle !!! Using the nearest point on grid instead.\");\n        Vector3d pt_cloest;\n        Coord2Index(start_pt, start_idx);\n        Index2Coord(start_idx, pt_cloest);\n        start_pt = pt_cloest;\n        Coord2Index(end_pt, end_idx);\n        Index2Coord(end_idx, pt_cloest);\n        end_pt = pt_cloest;\n\n        int iter_num = 0;\n        while (iter_num < 10) {\n            iter_num++;\n            if (isObs(start_idx)) {\n                start_pt = (start_pt + end_pt) / 2;\n                Coord2Index(start_pt, start_idx);\n            } else if (isObs(end_idx)) {\n                end_pt = (start_pt + end_pt) / 2;\n                Coord2Index(end_pt, end_idx);\n            } else {\n                break;\n            }\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 58.04162810587506}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)    if (!Coordinate2Index(start_pt, start_idx) || !Coordinate2Index(end_pt, end_idx))\n        return false;\n\n    if (isObs(start_idx) || isObs(end_idx)) {\n        //ROS_WARN(\"Start or end point is insde obstacle, start:%d, end:%d\", isObs(start_idx), isObs(end_idx));\n        Vector3d zero(0, 0, 0);\n        Vector3d start_zero(start_pt(0), start_pt(1), 0);\n        Vector3d end_zero(end_pt(0), end_pt(1), 0);\n        Vector3d start_pt_new, end_pt_new;\n        Vector3i start_idx_new, end_idx_new;\n        double dist_start = (start_pt - start_zero).norm();\n        double dist_end = (end_pt - end_zero).norm();\n        double dist_min = min(dist_start, dist_end);\n        double dist_max = max(dist_start, dist_end);\n        double delta = (dist_max - dist_min) / 10;\n        if (dist_max == dist_start) {\n            for (double i = dist_max; i >= dist_min; i -= delta) {\n                start_pt_new = start_zero + (start_pt - start_zero) * (i / dist_max);\n                end_pt_new = end_zero + (end_pt - end_zero) * (dist_min / dist_max);\n                if (!Coordinate2Index(start_pt_new, start_idx_new) || !Coordinate2Index(end_pt_new, end_idx_new))\n                    continue;\n                if (!isObs(start_idx_new) && !isObs(end_idx_new)) {\n                    start_pt = start_pt_new;\n                    end_pt = end_pt_new;\n                    break;\n                }\n            }\n        } else {\n            for (double i = dist_max; i >= dist_min; i -= delta)", "CodeBleu_score": 48.33749534560633}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  Eigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  max_id -= Eigen::Vector3i(1, 1, 1);\n\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) + y * grid_size_(2) + z] = 0;\n      }\n}\n", "CodeBleu_score": 70.68940360984}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  if (!buffer_initialized_) {\n    initializeBuffer();\n  }\n\n  Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  boundIndex(min_id);\n  boundIndex(max_id);\n\n  for (int x = min_id(0); x <= max_id(0); ++x)\n    for (int y = min_id(1); y <= max_id(1); ++y)\n      for (int z = min_id(2); z <= max_id(2); ++z) {\n        occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) + y * grid_size_(2) + z] = 0;\n      }\n}\n", "CodeBleu_score": 67.57694272956705}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  if (!buffer_initialized_) {\n    initializeBuffer();\n  }\n\n  Eigen::Vector3i min_id, max_id;\n  posToIndex(min_pos, min_id);\n  posToIndex(max_pos, max_id);\n\n  max_id -= Eigen::Vector3i(1, 1, 1);\n\n  Index x, y, z;\n  for (x = min_id(0); x <= max_id(0); ++x)\n    for (y = min_id(1); y <= max_id(1); ++y)\n      for (z = min_id(2); z <= max_id(2); ++z)\n        occupancy_buffer_inflate_[x * grid_size_(1) * grid_size_(2) + y * grid_size_(2) + z] = 0;\n}\n", "CodeBleu_score": 57.2063054701501}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d diff = pt - camera_pt;\n    double max_tx = (max_boundary_(0) - camera_pt(0)) / diff(0);\n    double max_ty = (max_boundary_(1) - camera_pt(1)) / diff(1);\n    double max_tz = (max_boundary_(2) - camera_pt(2)) / diff(2);\n    double min_tx = (min_boundary_(0) - camera_pt(0)) / diff(0);\n    double min_ty = (min_boundary_(1) - camera_pt(1)) / diff(1);\n    double min_tz = (min_boundary_(2) - camera_pt(2)) / diff(2);\n\n    double min_positive_t = std::max(std::max(std::min(max_tx, max_ty), std::min(max_tx, max_tz)),\n                                     std::max(std::min(min_tx, min_ty), std::min(min_tx, min_tz)));\n\n    return camera_pt + diff * min_positive_t;\n}\n", "CodeBleu_score": 37.03588450571979}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_t = (boundary_max_ - camera_pt).cwiseQuotient(diff);\n    Eigen::Vector3d min_t = (boundary_min_ - camera_pt).cwiseQuotient(diff);\n    Eigen::Vector3d max_min_t = max_t.cwiseMin(min_t);\n    double min_positive_t = std::max({0.0, max_min_t.x(), max_min_t.y(), max_min_t.z()});\n    return camera_pt + min_positive_t * diff;\n}\n", "CodeBleu_score": 33.66113525837022}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d diff = pt - camera_pt;\n    double max_x = (max_x_ - camera_pt(0)) / diff(0);\n    double max_y = (max_y_ - camera_pt(1)) / diff(1);\n    double max_z = (max_z_ - camera_pt(2)) / diff(2);\n\n    double min_x = (min_x_ - camera_pt(0)) / diff(0);\n    double min_y = (min_y_ - camera_pt(1)) / diff(1);\n    double min_z = (min_z_ - camera_pt(2)) / diff(2);\n\n    double min_positive = std::min(std::max(std::max(min_x, min_y), min_z), 1.0);\n    return camera_pt + diff * min_positive;\n}\n", "CodeBleu_score": 34.41535062709444}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)    // Update the last occupancy update time\n    last_occupancy_update_time_ = ros::Time::now();\n\n    // Check if an update is needed\n    if (!map_updated_) {\n        return;\n    }\n\n    // Project depth image into points\n    std::vector<Eigen::Vector3d> points;\n    projectDepthImage(points);\n\n    // Process the points with raycasting\n    for (const auto &point : points) {\n        updateOccupancy(point);\n    }\n\n    // Clear and inflate the local map if needed\n    if (local_map_updated_) {\n        clearLocalMap();\n        inflateLocalMap();\n        local_map_updated_ = false;\n    }\n\n    // Handle timeout errors for odometry and depth data\n    if ((ros::Time::now() - last_odom_time_).toSec() > odom_timeout_) {\n        odom_initialized_ = false;\n        ROS_WARN_THROTTLE(1.0, \"Odometry timeout\");\n    }\n\n    if ((ros::Time::now() - last_depth_time_).toSec() > depth_timeout_) {\n        depth_initialized_ = false;\n        ROS_WARN_THROTTLE(1.0, \"Depth image timeout\");\n    }\n\n    // Set flags for visualization\n    if (visualize_) {\n        if (odom_initialized_ && depth_initialized_) {\n            local_map_pub_.publish(local_map_.toImage());\n            global_map_pub_.publish(global_map_.toImage());\n        }\n    }\n}\n", "CodeBleu_score": 40.37364444480806}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  if (!has_odom_) {\n    ROS_WARN_THROTTLE(1, \"No odometry received!\");\n    return;\n  }\n\n  if (!has_depth_) {\n    ROS_WARN_THROTTLE(1, \"No depth image received!\");\n    return;\n  }\n\n  if (last_update_time_ == depth_msg_.header.stamp) {\n    ROS_WARN_THROTTLE(1, \"Depth image did not update the occupancy map!\");\n    return;\n  }\n\n  // Update the last update time\n  last_update_time_ = depth_msg_.header.stamp;\n\n  // If an update is needed\n  if (update_required_) {\n    // Project the depth image into points\n    std::vector<Eigen::Vector3d> points;\n    for (int v = 0; v < depth_msg_.height; v++) {\n      for (int u = 0; u < depth_msg_.width; u++) {\n        float z = depth_msg_.data[v * depth_msg_.width + u];\n        if (z > depth_msg_.min_dist && z < depth_msg_.max_dist) {\n          Eigen::Vector3d point =\n              (odom_T_cam_ * cam_T_lidar_).inverse().translation() +\n              (odom_T_cam_ * cam_T_lidar_).inverse().linear() *\n                  Eigen::Vector3d((u - depth_msg_.cx) * z / depth_msg_.fx,\n                                  (v - depth_msg_.cy) * z / depth_msg_.fy, z);\n          points.push_back(point);\n        }\n      }\n    }\n\n    // Process the points with raycasting\n    for (const auto &point : points) {\n      if (point.norm() < max_ray_length_) {\n        Eigen::Vector3d ray_start = odom_T_cam_.translation();\n        Eigen::Vector3d ray_end = point;\n        raycast(ray_start, ray_end);\n      }", "CodeBleu_score": 28.844572477346492}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  if (last_odom_update_time == ros::Time(0)) {\n    ROS_WARN(\"[GridMap] No odometry update received yet.\");\n    return;\n  }\n\n  if (last_depth_update_time == ros::Time(0)) {\n    ROS_WARN(\"[GridMap] No depth update received yet.\");\n    return;\n  }\n\n  if (ros::Time::now() - last_odom_update_time > odom_timeout) {\n    ROS_ERROR(\"[GridMap] Odometry update timeout.\");\n    odom_timeout_flag = true;\n    return;\n  }\n\n  if (ros::Time::now() - last_depth_update_time > depth_timeout) {\n    ROS_ERROR(\"[GridMap] Depth update timeout.\");\n    depth_timeout_flag = true;\n    return;\n  }\n\n  // Update the last occupancy update time\n  last_occupancy_update_time = ros::Time::now();\n\n  // Check if an update is needed\n  if (!need_update) {\n    return;\n  }\n\n  // Project the depth image into points\n  pcl::PointCloud<pcl::PointXYZ>::Ptr points(new pcl::PointCloud<pcl::PointXYZ>);\n  for (int u = 0; u < depth_image.cols; u++) {\n    for (int v = 0; v < depth_image.rows; v++) {\n      float depth = depth_image.at<float>(v, u);\n      if (depth > 0.01 && depth < max_depth) {\n        float x = (u - cx) * depth / fx;\n        float y = (v - cy) * depth / fy;\n        pcl::PointXYZ point(x, y, depth);\n        points->push_back(point);\n      }\n    }\n  }\n\n  // Transform the points to the world frame\n  pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_points(\n      new pcl::PointCloud<pcl::PointXYZ>);\n  pcl", "CodeBleu_score": 35.724670959934876}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)    float f_acc = 0.0f;\n    for (int i = 0; i < image_fns.size(); i++) {\n        Mat image = imread(image_fns[i], IMREAD_GRAYSCALE);\n        vector<Ellipse> gt = _load_ellipses(gt_fns[i]);\n        vector<Ellipse> dt = _load_ellipses(dt_fns[i]);\n        float f = _ellipse_evaluate_single(image, gt, dt, gt_angle_radians);\n        f_acc += f;\n    }\n    return f_acc / image_fns.size();\n}\n", "CodeBleu_score": 62.81027243239321}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)    float f_measure = 0.0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        // Load image\n        Mat img = imread(image_fns[i], IMREAD_COLOR);\n        if (img.empty()) {\n            cerr << \"Error: Failed to load image \" << image_fns[i] << endl;\n            return -1;\n        }\n\n        // Load ground truth ellipses\n        vector<Ellipse> gt_ellipses = load_ellipses(gt_fns[i]);\n\n        // Load detected ellipses\n        vector<Ellipse> dt_ellipses = load_ellipses(dt_fns[i]);\n\n        // Convert angle units if necessary\n        if (gt_angle_radians) {\n            for (auto& ellipse : gt_ellipses) {\n                ellipse.angle = ellipse.angle * 180.0 / M_PI;\n            }\n            for (auto& ellipse : dt_ellipses) {\n                ellipse.angle = ellipse.angle * 180.0 / M_PI;\n            }\n        }\n\n        // Evaluate detection performance\n        float tp = 0, fp = 0, fn = 0;\n        for (auto& gt_ellipse : gt_ellipses) {\n            bool matched = false;\n            for (auto& dt_ellipse : dt_ellipses) {\n                if (ellipse_iou(gt_ellipse, dt_ellipse) >= 0.5) {\n                    matched = true;\n                    break;\n                }\n            }\n            if (matched) {\n                tp++;\n            } else {\n                fn++;\n            }\n        }\n        fp = dt_ellipses.size() - tp;\n\n        // Calculate F-measure\n        float precision = tp / (tp + fp);\n        float recall = tp / (tp + fn);\n        float f1 = 2 * precision * recall / (precision + recall);", "CodeBleu_score": 49.54590735408293}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)    if (image_fns.size() != gt_fns.size() || image_fns.size() != dt_fns.size()) {\n        throw invalid_argument(\"The number of image filenames, ground truth filenames, and detected ellipse filenames must be the same.\");\n    }\n\n    float f1_sum = 0.0;\n    int num_images = image_fns.size();\n\n    for (int i = 0; i < num_images; i++) {\n        Mat image = imread(image_fns[i]);\n        vector<Ellipse> gt_ellipses = _ellipse_load_gt(gt_fns[i], gt_angle_radians);\n        vector<Ellipse> dt_ellipses = _ellipse_load_dt(dt_fns[i], gt_angle_radians);\n\n        float f1 = _ellipse_f1(gt_ellipses, dt_ellipses);\n        f1_sum += f1;\n    }\n\n    return f1_sum / num_images;\n}\n", "CodeBleu_score": 54.57331431080771}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)    if (foci == NULL) {\n        return 0.0;\n    }\n\n    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n    float normal_angle = angle1 - angle2;\n\n    while (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    }\n    while (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    }\n\n    return normal_angle;\n}\n", "CodeBleu_score": 52.59660854820921}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    if (foci == NULL) {\n        return 0.0f;\n    }\n\n    float angle1 = atan2f(y - foci[1], x - foci[0]);\n    float angle2 = atan2f(y - foci[3], x - foci[2]);\n    float normal_angle = angle1 - angle2;\n\n    if (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    } else if (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    }\n\n    return normal_angle;\n}\n", "CodeBleu_score": 49.55128546086044}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    if (foci == NULL) {\n        return 0.0f;\n    }\n\n    float x1 = foci[0];\n    float y1 = foci[1];\n    float x2 = foci[2];\n    float y2 = foci[3];\n\n    float angle1 = atan2f(y - y1, x - x1);\n    float angle2 = atan2f(y - y2, x - x2);\n\n    float normal_angle = angle1 - angle2;\n    normal_angle = fmodf(normal_angle + M_PI, 2 * M_PI) - M_PI;\n\n    return normal_angle;\n}\n", "CodeBleu_score": 40.301689355086204}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        if (vp1[i].x < min_x)\n            min_x = vp1[i].x;\n        if (vp1[i].x > max_x)\n            max_x = vp1[i].x;\n        if (vp1[i].y < min_y)\n            min_y = vp1[i].y;\n        if (vp1[i].y > max_y)\n            max_y = vp1[i].y;\n    }\n    double integral_above = 0;\n    double integral_below = 0;\n    for (int i = start; i <= end; i++) {\n        double x1 = vp1[i].x;\n        double y1 = vp1[i].y;\n        double x2 = vp1[(i + 1) % (end + 1)].x;\n        double y2 = vp1[(i + 1) % (end + 1)].y;\n        double dx = x2 - x1;\n        double dy = y2 - y1;\n        double m = dy / dx;\n        double b = y1 - m * x1;\n        double integral_above_i = (max_x - min_x) * (max_y - min_y) / 2;\n        double integral_below_i = (max_x - min_x) * (max_y - min_y) / 2;\n        if (m > 0) {\n            integral_above_i -= (max_x - min_x) * (max_y - min_y) / 2;\n            integral_below_i += (max_x - min_x) * (max_y - min_y) / 2;\n        } else {\n            integral_above_i += (max_x - min_x)", "CodeBleu_score": 39.173755529598665}, {"code": "bool inline concave_check(VP& vp1, int start, int end)    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start; i <= end; i++) {\n        if (vp1[i].x < min_x) min_x = vp1[i].x;\n        if (vp1[i].x > max_x) max_x = vp1[i].x;\n        if (vp1[i].y < min_y) min_y = vp1[i].y;\n        if (vp1[i].y > max_y) max_y = vp1[i].y;\n    }\n    double integral_above = 0.0;\n    double integral_below = 0.0;\n    for (int i = start; i <= end; i++) {\n        double x1 = vp1[i].x;\n        double y1 = vp1[i].y;\n        double x2 = vp1[(i + 1) % vp1.size()].x;\n        double y2 = vp1[(i + 1) % vp1.size()].y;\n        double area = (x1 * y2 - x2 * y1);\n        if (area > 0) integral_above += area;\n        else integral_below += area;\n    }\n    return (integral_above < integral_below);\n}\n", "CodeBleu_score": 44.409008113691726}, {"code": "bool inline concave_check(VP& vp1, int start, int end)    double x_min = DBL_MAX, x_max = -DBL_MAX, y_min = DBL_MAX, y_max = -DBL_MAX;\n    for (int i = start; i <= end; i++) {\n        x_min = min(x_min, vp1[i].x);\n        x_max = max(x_max, vp1[i].x);\n        y_min = min(y_min, vp1[i].y);\n        y_max = max(y_max, vp1[i].y);\n    }\n    double integral_above = 0, integral_below = 0;\n    for (int i = start; i <= end; i++) {\n        int j = (i + 1) % vp1.size();\n        double x1 = vp1[i].x, y1 = vp1[i].y, x2 = vp1[j].x, y2 = vp1[j].y;\n        if (y1 == y_max) {\n            integral_above += (x2 - x1) * (y2 - y1);\n        } else if (y1 == y_min) {\n            integral_below += (x2 - x1) * (y2 - y1);\n        } else if (y1 > y_max) {\n            integral_above += (x2 - x1) * (y_max - y1);\n        } else if (y1 < y_min) {\n            integral_below += (x2 - x1) * (y_min - y1);\n        }\n    }\n    return integral_above < integral_below;\n}\n", "CodeBleu_score": 47.02444885038331}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)    if (msg->detected_info.size() == 0) {\n        num_lost++;\n        num_regain = 0;\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n    } else {\n        for (auto &detection : msg->detected_info) {\n            if (detection.name == \"T\") {\n                num_regain++;\n                num_lost = 0;\n                if (num_regain > VISION_THRES) {\n                    is_detected = true;\n                }\n            } else {\n                num_lost++;\n                num_regain = 0;\n                if (num_lost > VISION_THRES) {\n                    is_detected = false;\n                }\n            }\n        }\n    }\n    if (is_detected) {\n        ellipse_det = *msg;\n        std::swap(ellipse_det.sight_angle.x, ellipse_det.sight_angle.y);\n    }\n}\n", "CodeBleu_score": 63.51112132090662}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)    // Iterate through each detection info\n    for (int i = 0; i < msg->num_of_objects; i++) {\n        // Update the ellipse_det variable\n        ellipse_det.is_detected = msg->detection_info[i].is_detected;\n        ellipse_det.sight_angle = msg->detection_info[i].sight_angle;\n        ellipse_det.confidence = msg->detection_info[i].confidence;\n        ellipse_det.position = msg->detection_info[i].position;\n        ellipse_det.velocity = msg->detection_info[i].velocity;\n        ellipse_det.size = msg->detection_info[i].size;\n        ellipse_det.ellipse_size = msg->detection_info[i].ellipse_size;\n        ellipse_det.ellipse_rotation = msg->detection_info[i].ellipse_rotation;\n        ellipse_det.ellipse_confidence = msg->detection_info[i].ellipse_confidence;\n        ellipse_det.ellipse_position = msg->detection_info[i].ellipse_position;\n        ellipse_det.ellipse_velocity = msg->detection_info[i].ellipse_velocity;\n        ellipse_det.ellipse_size = msg->detection_info[i].ellipse_size;\n        ellipse_det.ellipse_rotation = msg->detection_info[i].ellipse_rotation;\n        ellipse_det.ellipse_confidence = msg->detection_info[i].ellipse_confidence;\n        ellipse_det.ellipse_position = msg->detection_info[i].ellipse_position;\n        ellipse_det.ellipse_velocity = msg->detection_info[i].ellipse_velocity;\n        ellipse_det.ellipse", "CodeBleu_score": 27.400755100859055}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)    for (auto &det : msg->detection_info) {\n        if (det.id == 0) {\n            ellipse_det.num_lost = 0;\n            ellipse_det.num_regain++;\n            if (ellipse_det.num_regain > VISION_THRES) {\n                ellipse_det.is_detected = true;\n            }\n        } else {\n            ellipse_det.num_regain = 0;\n            ellipse_det.num_lost++;\n            if (ellipse_det.num_lost > VISION_THRES) {\n                ellipse_det.is_detected = false;\n            }\n        }\n    }\n    ellipse_det.sight_angle.data[0] = msg->sight_angle.data[1];\n    ellipse_det.sight_angle.data[1] = msg->sight_angle.data[0];\n}\n", "CodeBleu_score": 42.70408048405765}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  bool is_safe = true;\n  Eigen::Vector3i cur_idx;\n  Eigen::Vector3d cur_pos_int;\n\n  cur_pos_int(0) = int(cur_pos(0));\n  cur_pos_int(1) = int(cur_pos(1));\n  cur_pos_int(2) = int(cur_pos(2));\n\n  cur_idx = coord2gridIndex(cur_pos_int);\n\n  double dist = safe_distance;\n\n  Eigen::Vector3d u[2] = {Eigen::Vector3d(1, 0, 0), Eigen::Vector3d(0, 1, 0)};\n\n  for (int x = -dist; x <= dist; ++x)\n    for (int y = -dist; y <= dist; ++y) {\n      Eigen::Vector3i idx = cur_idx + Eigen::Vector3i(x, y, 0);\n      if (idx(0) < 0 || idx(0) >= GLX_SIZE || idx(1) < 0 ||\n          idx(1) >= GLY_SIZE || idx(2) < 0 || idx(2) >= GLZ_SIZE) {\n        continue;\n      }\n      if (Occupy_map_ptr->getInflateOccupancy(idx)) {\n        is_safe = false;\n        break;\n      }\n    }\n\n  return is_safe;\n}\n", "CodeBleu_score": 41.79671658173291}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)    Eigen::Vector3i cur_index = coord2gridIndex(cur_pos);\n    // std::cout << \"cur_index: \" << cur_index.transpose() << std::endl;\n    // std::cout << \"cur_pos: \" << cur_pos.transpose() << std::endl;\n    Eigen::Vector3i min_index = cur_index - Eigen::Vector3i::Constant(ceil(safe_distance));\n    Eigen::Vector3i max_index = cur_index + Eigen::Vector3i::Constant(ceil(safe_distance));\n    // std::cout << \"min_index: \" << min_index.transpose() << std::endl;\n    // std::cout << \"max_index: \" << max_index.transpose() << std::endl;\n    if (min_index(0) < 0) {\n        min_index(0) = 0;\n    }\n    if (min_index(1) < 0) {\n        min_index(1) = 0;\n    }\n    if (min_index(2) < 0) {\n        min_index(2) = 0;\n    }\n    if (max_index(0) > GLX_SIZE) {\n        max_index(0) = GLX_SIZE;\n    }\n    if (max_index(1) > GLY_SIZE) {\n        max_index(1) = GLY_SIZE;\n    }\n    if (max_index(2) > GLZ_SIZE) {\n        max_index(2) = GLZ_SIZE;\n    }\n    // std::cout << \"min_index: \" << min_index.transpose() << std::endl;\n    // std::cout << \"max_index: \" << max_index.transpose() << std::endl;\n    for (int x = min_index(0); x <= max_index(0); ++x) {\n        for (int y = min_index(1); y <= max_index(1); ++y) {\n            for (int z = min_index(2); z <= max_index(2); ++z) {", "CodeBleu_score": 37.14970744571986}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  return Occupy_map_ptr->check_safety(cur_pos, safe_distance);\n}\n", "CodeBleu_score": 44.71746154956753}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 67.0765492888134}, {"code": "void Astar::retrievePath(NodePtr end_node)  NodePtr current_node = end_node;\n  path_nodes_.push_back(current_node);\n\n  while (current_node->parent != nullptr) {\n    current_node = current_node->parent;\n    path_nodes_.push_back(current_node);\n  }\n\n  reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 70.50170070648267}, {"code": "void Astar::retrievePath(NodePtr end_node)    NodePtr cur_node = end_node;\n    path_nodes_.push_back(cur_node);\n    while (cur_node->parent != nullptr) {\n        cur_node = cur_node->parent;\n        path_nodes_.push_back(cur_node);\n    }\n    reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 88.11849219186722}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     state_nei[id].pos = odom->pose.pose.position;\n    state_nei[id].pos.z = odom->pose.pose.position.z;\n    if (sim_mode) {\n        if (get_distance(state_nei[id].pos, state_nei[id].start_pos) > 5) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    } else {\n        get_nei_state[id] = true;\n    }\n}\n", "CodeBleu_score": 51.956579682020944}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     if(simulation) {\n        if(id==0) {\n            if(sqrt(pow(odom->pose.pose.position.x, 2) + pow(odom->pose.pose.position.y, 2)) > 5) {\n                get_nei_state = false;\n            }\n            else {\n                get_nei_state = true;\n            }\n        }\n    }\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n}\n", "CodeBleu_score": 47.7489167545573}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     if (id == 0) {\n        state_nei[0] = odom->pose.pose.position.x;\n        state_nei[1] = odom->pose.pose.position.y;\n        state_nei[2] = odom->pose.pose.position.z;\n    }\n    else if (id == 1) {\n        state_nei[3] = odom->pose.pose.position.x;\n        state_nei[4] = odom->pose.pose.position.y;\n        state_nei[5] = odom->pose.pose.position.z;\n    }\n    else if (id == 2) {\n        state_nei[6] = odom->pose.pose.position.x;\n        state_nei[7] = odom->pose.pose.position.y;\n        state_nei[8] = odom->pose.pose.position.z;\n    }\n    else if (id == 3) {\n        state_nei[9] = odom->pose.pose.position.x;\n        state_nei[10] = odom->pose.pose.position.y;\n        state_nei[11] = odom->pose.pose.position.z;\n    }\n    else if (id == 4) {\n        state_nei[12] = odom->pose.pose.position.x;\n        state_nei[13] = odom->pose.pose.position.y;\n        state_nei[14] = odom->pose.pose.position.z;\n    }\n    else if (id == 5) {\n        state_nei[15] = odom->pose.pose.position.x;\n        state_nei[16] = odom->pose.pose.position.y;\n        state_nei[17] = odom->pose.pose.position.z;\n    }\n    else if (id == 6) {\n        state_nei[18] = odom->pose.pose.position.x", "CodeBleu_score": 33.83999915853082}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    update_counter++;\n    if (update_counter == 5) {\n        update_counter = 0;\n        Gpointcloud_process(msg);\n    }\n}\n", "CodeBleu_score": 55.499847984642805}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    if (!odom_ready) {\n        return;\n    }\n\n    sensor_ready = true;\n    update_counter++;\n\n    if (update_counter == 5) {\n        update_counter = 0;\n        astar_map->update_map(msg);\n    }\n}\n", "CodeBleu_score": 56.88883119625794}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    if (!odom_ready) {\n        return;\n    }\n    sensor_ready = true;\n    if (update_count == 4) {\n        update_count = 0;\n        astar_map->updateMap(msg);\n    } else {\n        update_count++;\n    }\n}\n", "CodeBleu_score": 56.76571834162555}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)  if (get_gpcl) {\n    get_gpcl = false;\n    pcl::PointCloud < pcl::PointXYZ > cloud;\n    pcl::fromROSMsg(*global_point, cloud);\n    global_map.setInputCloud(cloud.makeShared());\n    global_map.filter(global_map_inflate);\n  }\n}\n", "CodeBleu_score": 47.67560960680062}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)    if (get_gpcl) {\n        get_gpcl = false;\n        pcl::fromROSMsg(*global_point, *global_cloud);\n        // pcl::fromROSMsg(*global_point, *global_cloud);\n        inflate_pcl();\n    }\n}\n", "CodeBleu_score": 30.728262314961263}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tglobal_map.setInputCloud(global_point);\n\t\tglobal_map.filter(global_map_cloud);\n\t\tglobal_map_cloud.header.frame_id = \"map\";\n\t\tglobal_map_cloud.header.stamp = ros::Time::now();\n\t\tglobal_map_cloud.header.seq = 1;\n\t\tglobal_map_cloud.width = 1;\n\t\tglobal_map_cloud.height = global_map_cloud.points.size();\n\t\tglobal_map_cloud.is_dense = true;\n\t\tglobal_map_cloud.is_bigendian = false;\n\t\tglobal_map_cloud.fields.resize(3);\n\t\tglobal_map_cloud.fields[0].name = \"x\";\n\t\tglobal_map_cloud.fields[0].offset = 0;\n\t\tglobal_map_cloud.fields[0].datatype = 7;\n\t\tglobal_map_cloud.fields[0].count = 1;\n\t\tglobal_map_cloud.fields[1].name = \"y\";\n\t\tglobal_map_cloud.fields[1].offset = 4;\n\t\tglobal_map_cloud.fields[1].datatype = 7;\n\t\tglobal_map_cloud.fields[1].count = 1;\n\t\tglobal_map_cloud.fields[2].name = \"z\";\n\t\tglobal_map_cloud.fields[2].offset = 8;\n\t\tglobal_map_cloud.fields[2].datatype = 7;\n\t\tglobal_map_cloud.fields[2].count = 1;\n\t\tglobal_map_cloud.point_step = 12;\n\t\tglobal_map_cloud.row_step = global_map_cloud.point_step * global_map_cloud.width;\n\t\tglobal_map_cloud.data.resize(global_map_cloud.row_step * global_map_cloud.height);\n\t\tglobal_map_cloud.is_bigendian = false;\n\t\tglobal_map_cloud.is_dense = true;", "CodeBleu_score": 40.53491775710812}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\n    // If not in simulation mode, merge the local map with the provided odometry data\n    if (!simulation) {\n        map_merge_odom(odom);\n    }\n\n    // Convert the laser scan to a PointCloud2 format\n    sensor_msgs::PointCloud2 local_point2;\n    projector.projectLaser(*local_point, local_point2);\n\n    // Convert the PointCloud2 to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(local_point2, *cloud);\n\n    // Transform the point cloud to the map frame\n    pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl_ros::transformPointCloud(*cloud, *transformed_cloud, odom.pose.pose, map_frame);\n\n    // Update the occupancy map with the transformed point cloud\n    map_update_pointcloud(transformed_cloud);\n\n}\n", "CodeBleu_score": 52.55262586970021}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)    sensor_msgs::PointCloud2 cloud_2;\n    projector_.projectLaser(*local_point, cloud_2);\n    pcl::PointCloud<pcl::PointXYZ> cloud_3;\n    pcl::fromROSMsg(cloud_2, cloud_3);\n\n    if (simulation_mode_) {\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_4(new pcl::PointCloud<pcl::PointXYZ>);\n        *cloud_4 = cloud_3;\n        occupy_map_.update_map(cloud_4, odom.pose.pose);\n    } else {\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_4(new pcl::PointCloud<pcl::PointXYZ>);\n        *cloud_4 = cloud_3;\n        occupy_map_.update_map(cloud_4, odom.pose.pose, local_map_);\n    }\n}\n", "CodeBleu_score": 48.72043630697116}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)    if (simulation_mode) {\n        // Convert the laser scan message to a PointCloud2 format\n        sensor_msgs::PointCloud2 cloud_msg;\n        projector_.projectLaser(*local_point, cloud_msg);\n\n        // Convert the PointCloud2 message to a pcl::PointCloud\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(cloud_msg, cloud);\n\n        // Update the occupancy map with the laser scan data\n        map_update_laser(cloud, odom);\n    }\n    else {\n        // Convert the laser scan message to a PointCloud2 format\n        sensor_msgs::PointCloud2 cloud_msg;\n        projector_.projectLaser(*local_point, cloud_msg);\n\n        // Convert the PointCloud2 message to a pcl::PointCloud\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(cloud_msg, cloud);\n\n        // Update the occupancy map with the laser scan data\n        map_update_laser(cloud, odom);\n\n        // Merge the local map with the provided odometry data\n        map_merge(odom);\n    }\n}\n", "CodeBleu_score": 53.49200052126781}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)    // Convert the global point cloud map to a ROS message\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(*global_pcl, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n\n    // Convert and publish the inflated point cloud\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the messages\n    global_pcl_pub.publish(global_pcl_msg);\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 67.37862960634082}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(*global_pcl_, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub_.publish(global_pcl_msg);\n\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*inflate_pcl_, inflate_pcl_msg);\n  inflate_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_pub_.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 62.84043116167468}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl_, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl_msg);\n\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl_, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 59.06190781313645}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (odom_ready) {\n    sensor_ready = true;\n    // update map\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n    update_map(cloud, current_pose);\n  }\n}\n", "CodeBleu_score": 48.48862317673865}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    // Check if odometry is ready\n    if (odom_ready) {\n        sensor_ready = true;\n    }\n\n    // Update the A* algorithm's map using the new point cloud data and current UAV odometry\n    astar.updateMap(msg, odom);\n}\n", "CodeBleu_score": 52.20009998385207}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n  if (!odom_ready) {\n    ROS_WARN(\"No odometry yet\");\n    return;\n  }\n  sensor_ready = true;\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(*msg, *cloud);\n  //ROS_INFO(\"Received point cloud with %d points\", (int)cloud->points.size());\n  //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: Updating map\");\n  astar_planner->updateMap(cloud, current_odom);\n  //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb: Done updating map\");\n}\n", "CodeBleu_score": 63.44579713111524}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Update body pose\n  body_controller_.updateBodyPose();\n  // Update foot positions\n  body_controller_.updateFootPositions();\n  // Publish foot contact information\n  publishFootContacts();\n  // Update joint positions\n  updateJointPositions();\n  // Publish joint positions\n  publishJointPositions();\n}\n", "CodeBleu_score": 17.416076298864873}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)    // Calculate target foot positions based on the desired pose\n    Eigen::Vector3d desired_com_position = body_controller_->getDesiredComPosition();\n    Eigen::Vector3d desired_com_velocity = body_controller_->getDesiredComVelocity();\n    Eigen::Vector3d desired_com_jerk = body_controller_->getDesiredComJerk();\n    Eigen::Vector3d desired_com_angular_velocity = body_controller_->getDesiredComAngularVelocity();\n    Eigen::Vector3d desired_com_angular_acceleration = body_controller_->getDesiredComAngularAcceleration();\n\n    // Calculate target foot positions based on the desired pose\n    std::vector<Eigen::Vector3d> target_foot_positions = body_controller_->getTargetFootPositions();\n    std::vector<Eigen::Vector3d> target_foot_velocities = body_controller_->getTargetFootVelocities();\n    std::vector<Eigen::Vector3d> target_foot_accelerations = body_controller_->getTargetFootAccelerations();\n\n    // Calculate target foot positions based on the desired pose\n    std::vector<Eigen::Vector3d> target_foot_angular_velocities = body_controller_->getTargetFootAngularVelocities();\n    std::vector<Eigen::Vector3d> target_foot_angular_accelerations = body_controller_->getTargetFootAngularAccelerations();\n\n    // Calculate target foot positions based on the desired pose\n    std::vector<Eigen::Vector3d> target_foot_contact_forces = body_controller_->getTargetFootContactForces();\n    std::vector<Eigen::Vector3d> target_foot_contact_torques = body_controller_->getTargetFootContactTorques();\n\n    // Calculate target foot positions based on the desired pose\n    std::vector<Eigen::Vector3d> target_foot_contact_forces_derivative = body_controller_->getTargetFootContactForcesDerivative();\n    std::vector<Eigen::Vector3d> target_", "CodeBleu_score": 20.63856411086355}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)    // Calculate target foot positions based on desired pose\n    Eigen::Vector3d body_target_pos = body_controller_->getTargetPosition();\n    Eigen::Vector3d body_target_vel = body_controller_->getTargetVelocity();\n    Eigen::Vector3d body_target_acc = body_controller_->getTargetAcceleration();\n    Eigen::Vector3d body_target_euler = body_controller_->getTargetEulerAngles();\n    Eigen::Vector3d body_target_ang_vel = body_controller_->getTargetAngularVelocity();\n    Eigen::Vector3d body_target_ang_acc = body_controller_->getTargetAngularAcceleration();\n\n    // Compute velocity commands for legs\n    Eigen::Vector3d target_foot_vel;\n    Eigen::Vector3d target_foot_acc;\n    for (int i = 0; i < 4; i++) {\n        target_foot_vel = body_kinematics_->computeFootVelocity(body_target_pos, body_target_vel, body_target_acc, body_target_euler, body_target_ang_vel, body_target_ang_acc, i);\n        target_foot_acc = body_kinematics_->computeFootAcceleration(body_target_pos, body_target_vel, body_target_acc, body_target_euler, body_target_ang_vel, body_target_ang_acc, i);\n        leg_controllers_[i]->setTargetPosition(body_kinematics_->computeFootPosition(body_target_pos, i));\n        leg_controllers_[i]->setTargetVelocity(target_foot_vel);\n        leg_controllers_[i]->setTargetAcceleration(target_foot_acc);\n    }\n\n    // Perform inverse kinematics to determine target joint positions\n    for (int i = 0; i < 4; i++) {\n        leg_controllers_[i]->update(event.current_real - event.current_expected);\n    }\n\n    // Publish foot contact information\n    std_msgs::Bool", "CodeBleu_score": 41.560711170048315}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])  if (!foot_contacts_publisher_) {\n    return;\n  }\n  // Create message\n  std_msgs::Bool foot_contacts_msg;\n  // Populate message\n  foot_contacts_msg.data = foot_contacts[0];\n  // Publish message\n  foot_contacts_publisher_.publish(foot_contacts_msg);\n}\n", "CodeBleu_score": 24.952171694595318}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])    if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n        ContactsStamped msg;\n        msg.header.stamp = ros::Time::now();\n        msg.contacts[0] = foot_contacts[0];\n        msg.contacts[1] = foot_contacts[1];\n        msg.contacts[2] = foot_contacts[2];\n        msg.contacts[3] = foot_contacts[3];\n        foot_contacts_publisher_.publish(msg);\n    }\n}\n", "CodeBleu_score": 45.24436429513015}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])    if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n        // Create a ContactsStamped message\n        quadruped_msgs::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n        // Populate the message with the current gait phase of each leg\n        for (int i = 0; i < 4; i++) {\n            contacts_msg.contacts.push_back(foot_contacts[i]);\n        }\n        // Publish the message\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}\n", "CodeBleu_score": 54.19837056932412}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = JointState()\n    joints_msg.name = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    joints_msg.position = joints.position[:12]\n\n    # Publish the joints message\n    self.joints_pub.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    joint_trajectory = JointTrajectory()\n    joint_trajectory.header.stamp = rospy.Time.now()\n    joint_trajectory.joint_names = [\"joint_1\", \"joint_2\", \"joint_3\", \"joint_4\", \"joint_5\", \"joint_6\", \"joint_7\", \"joint_8\", \"joint_9\", \"joint_10\", \"joint_11\", \"joint_12\"]\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = rospy.Duration(1.0)\n    joint_trajectory.points.append(point)\n\n    # Publish the joint trajectory message\n    self.joint_trajectory_pub.publish(joint_trajectory)\n", "CodeBleu_score": 44.579262258687216}, {"code": "def joints_cmd_callback(self, joints)    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = JointState()\n    joints_msg.header.stamp = self.get_clock().now().to_msg()\n    joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joints_msg.position = joints.position[:12]\n\n    # Publish the joints message\n    self.joints_publisher.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    joint_trajectory_msg = JointTrajectory()\n    joint_trajectory_msg.header.stamp = self.get_clock().now().to_msg()\n    joint_trajectory_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = Duration(sec=1.0).to_msg()\n    joint_trajectory_msg.points.append(point)\n\n    # Publish the joint trajectory message\n    self.joint_trajectory_publisher.publish(joint_trajectory_msg)\n", "CodeBleu_score": 42.53555179759495}, {"code": "def joints_cmd_callback(self, joints)    # Create a minimal joints message with the first 12 joint positions\n    joints_msg = JointState()\n    joints_msg.header.stamp = rospy.Time.now()\n    joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    joints_msg.position = joints.position[:12]\n\n    # Publish the joints message\n    self.joints_pub.publish(joints_msg)\n\n    # Construct a joint trajectory message with the same positions and a specified duration\n    trajectory_msg = JointTrajectory()\n    trajectory_msg.header.stamp = rospy.Time.now()\n    trajectory_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n    point = JointTrajectoryPoint()\n    point.positions = joints.position[:12]\n    point.time_from_start = rospy.Duration(1.0)\n    trajectory_msg.points.append(point)\n\n    # Publish the trajectory message\n    self.trajectory_pub.publish(trajectory_msg)\n", "CodeBleu_score": 47.027322763790934}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Initialize foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contact_states[i] = false;\n  }\n\n  // Iterate over all contacts in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Get the name of the first collision in the contact\n    std::string collision_name = _msg->contact(i).collision1();\n\n    // Split the collision name to get the link name\n    std::string link_name = collision_name.substr(0, collision_name.find(\"::\"));\n\n    // Check if the link name matches one of the foot links\n    if (link_name == \"foot_fl\") {\n      foot_contact_states[0] = true;\n    } else if (link_name == \"foot_fr\") {\n      foot_contact_states[1] = true;\n    } else if (link_name == \"foot_rl\") {\n      foot_contact_states[2] = true;\n    } else if (link_name == \"foot_rr\") {\n      foot_contact_states[3] = true;\n    }\n  }\n}\n\n", "CodeBleu_score": 51.677326763537536}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\n    // Initialize foot contact states to false\n    for (int i = 0; i < 4; i++) {\n        footContactStates_[i] = false;\n    }\n\n    // Process each contact in the message\n    for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n        std::string col1 = _msg->contact(i).collision1();\n        std::string col2 = _msg->contact(i).collision2();\n\n        // Split the collision string to identify the contact link\n        std::string link1 = col1.substr(0, col1.find(\"::\"));\n        std::string link2 = col2.substr(0, col2.find(\"::\"));\n\n        // Check if the contact matches one of the foot links\n        for (int j = 0; j < 4; j++) {\n            if (link1 == footLinks_[j] || link2 == footLinks_[j]) {\n                footContactStates_[j] = true;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 61.145170340186304}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Initialize foot contact states to false\n  for (int i = 0; i < NUM_FEET; i++) {\n    foot_contact_state_[i] = false;\n  }\n\n  // Process each contact in the message\n  for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n    // Get the contact\n    const gazebo::msgs::Contact &contact = _msg->contact(i);\n\n    // Split the collision string to identify the contact link\n    std::string collision_string = contact.collision1();\n    std::string contact_link = collision_string.substr(0, collision_string.find(\"::\"));\n\n    // Check if the contact link matches one of the foot links\n    for (int i = 0; i < NUM_FEET; i++) {\n      if (contact_link == foot_link_names_[i]) {\n        // Set the corresponding foot contact state to true\n        foot_contact_state_[i] = true;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 53.81058704493722}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  if (!active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}\n", "CodeBleu_score": 82.96017040947656}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(initialized_params_);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  // Return 0 velocities on all rotors, until the first command is received.\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->rows());\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::Vector4d angular_acceleration_thrust;\n  angular_acceleration_thrust.block<3, 1>(0, 0) = angular_acceleration;\n  angular_acceleration_thrust(3) = thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}\n", "CodeBleu_score": 93.74783430455594}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(initialized_);\n\n  rotor_velocities->resize(rotor_count_);\n  if (!active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d acceleration;\n  ComputeDesiredAcceleration(&acceleration);\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(acceleration, &angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * acceleration.dot(odometry_.orientation.toRotationMatrix().col(2));\n\n  Eigen::VectorXd angular_acceleration_thrust;\n  angular_acceleration_thrust.resize(3);\n  angular_acceleration_thrust << angular_acceleration, thrust;\n\n  *rotor_velocities = angular_acc_to_rotor_velocities_ * angular_acceleration_thrust;\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}\n", "CodeBleu_score": 80.6024979387674}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  // Get the desired position and velocity from the command trajectory\n  const mav_msgs::EigenTrajectoryPoint desired_state =\n      command_trajectory_.at(current_reference_index_);\n\n  Eigen::Vector3d position_error =\n      desired_state.position_W - odometry_.position_W;\n\n  // Transform the velocity to the world frame\n  const Eigen::Vector3d velocity_W = odometry_.orientation_W_B.conjugate() *\n                                       odometry_.velocity_B;\n\n  Eigen::Vector3d velocity_error = desired_state.velocity_W - velocity_W;\n\n  Eigen::Vector3d desired_acceleration =\n      position_gain_ * position_error +\n      velocity_gain_ * velocity_error +\n      desired_state.acceleration_W +\n      odometry_.orientation_W_B.conjugate() * Eigen::Vector3d::UnitZ() *\n          mass_ * graivty_;\n\n  *acceleration = desired_acceleration;\n}\n", "CodeBleu_score": 42.8081409549262}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  CHECK_NOTNULL(acceleration);\n\n  // Get the current desired position and velocity from the trajectory\n  // and the current odometry.\n  Eigen::Vector3d position, velocity;\n  trajectory_msg_.Sample(time_now_, &position, &velocity);\n  Eigen::Vector3d position_error = position - odometry_.position;\n  Eigen::Vector3d velocity_error = velocity - odometry_.velocity;\n\n  // Transform the velocity to the world frame.\n  const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n  Eigen::Vector3d velocity_W = R_W_I * velocity;\n  Eigen::Vector3d velocity_error_W = R_W_I * velocity_error;\n\n  // Compute the desired acceleration.\n  Eigen::Vector3d total_acceleration_desired;\n  total_acceleration_desired = position_gain_.cwiseProduct(position_error) +\n                                velocity_gain_.cwiseProduct(velocity_error_W) +\n                                acceleration_gain_.cwiseProduct(acceleration_command_) +\n                                gravity_vector_ + mass_ * Eigen::Vector3d::UnitZ();\n\n  // Transform the desired acceleration back to the vehicle frame.\n  *acceleration = R_W_I.transpose() * total_acceleration_desired;\n}\n", "CodeBleu_score": 58.29825415093776}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const    Eigen::Vector3d position_error;\n    Eigen::Vector3d velocity_error;\n    Eigen::Vector3d commanded_world_acceleration;\n\n    // Compute the position error.\n    position_error = odometry_.position - command_trajectory_.position_W;\n\n    // Compute the velocity error.\n    velocity_error = odometry_.velocity - command_trajectory_.velocity_W;\n\n    // Transform the velocity to the world frame.\n    const Eigen::Matrix3d R_W_I = odometry_.orientation.toRotationMatrix();\n    Eigen::Vector3d velocity_I = R_W_I * odometry_.velocity;\n\n    // Compute the commanded acceleration in the world frame.\n    commanded_world_acceleration = command_trajectory_.acceleration_W + Eigen::Vector3d(0, 0, 9.81);\n\n    // Compute the desired acceleration.\n    *acceleration = position_error.cwiseProduct(position_gain_) + velocity_error.cwiseProduct(velocity_gain_) + commanded_world_acceleration;\n}\n", "CodeBleu_score": 60.18448266577809}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(initialized_);\n\n  rotor_velocities->resize(rotor_count_);\n  // Return 0 velocities on ground. Hover.\n  if (is_flying_ == false) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAngularAcc(angular_acceleration);\n\n  Eigen::VectorXd thrust_plus_rpydotdot(rotor_count_ + 3);\n  thrust_plus_rpydotdot << commanded_thrust_, angular_acceleration;\n\n  *rotor_velocities = (vehicle_parameters_.rotor_configuration_matrix_.inverse()*thrust_plus_rpydotdot);\n  *rotor_velocities = rotor_velocities->cwiseMax(Eigen::VectorXd::Zero(rotor_velocities->rows()));\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}\n\n", "CodeBleu_score": 59.96574116564103}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(initialized_);\n\n  rotor_velocities->resize(rotor_count_);\n  // Return the angular acceleration and thrust reference\n  Eigen::Vector3d angular_acceleration;\n  ComputeDesiredAcceleration(&angular_acceleration);\n\n  Eigen::VectorXd reference_thrust_squared;\n  ComputeDesiredThrust(&reference_thrust_squared);\n\n  // Calculate the rotor velocities\n  Eigen::VectorXd sqrt_reference_thrust_squared = reference_thrust_squared.cwiseSqrt();\n  Eigen::VectorXd sqrt_rotor_thrust_coeff = sqrt_reference_thrust_squared.cwiseProduct(rotor_thrust_coeff_.cwiseSqrt());\n  *rotor_velocities = (angular_acceleration.cwiseProduct(inertia_)).cwiseQuotient(sqrt_rotor_thrust_coeff) + sqrt_rotor_thrust_coeff;\n  *rotor_velocities = sqrt_rotor_thrust_coeff.cwiseInverse().cwiseProduct((angular_acceleration.cwiseProduct(inertia_)).cwiseQuotient(sqrt_rotor_thrust_coeff) + sqrt_rotor_thrust_coeff);\n  *rotor_velocities = angular_acceleration.cwiseProduct(inertia_).cwiseQuotient(sqrt_rotor_thrust_coeff) + sqrt_rotor_thrust_coeff;\n  *rotor_velocities = sqrt_rotor_thrust_coeff.cwiseInverse().cwiseProduct(angular_acceleration.cwiseProduct(inertia_).cwiseQuotient(sqrt_rotor_thrust_coeff) + sqrt_rotor_thrust_coeff);\n  *rotor_velocities = angular_acceleration.cwiseProduct(inertia_).cwiseQuotient(sqrt_rotor_thrust_", "CodeBleu_score": 47.529134669557585}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(initialized_params_);\n  assert(initialized_attitude_controller_);\n\n  rotor_velocities->resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  Eigen::VectorXd angular_acceleration;\n  ComputeDesiredAngularAcc(angular_acceleration);\n\n  // Project thrust onto body z axis.\n  double thrust = -vehicle_parameters_.mass_ * vehicle_parameters_.gravity_ / vehicle_parameters_.rotor_configuration_.rotors.size();\n\n  Eigen::VectorXd tau_red;\n  tau_red.resize(6);\n  tau_red.setZero();\n  tau_red(2) = -thrust;\n\n  Eigen::VectorXd tau;\n  tau.resize(6);\n  tau.setZero();\n  tau(2) = -thrust;\n\n  Eigen::VectorXd rotor_velocities_sq;\n  rotor_velocities_sq.resize(vehicle_parameters_.rotor_configuration_.rotors.size());\n  rotor_velocities_sq.setZero();\n  rotor_velocities_sq = angular_acc_to_rotor_velocities_matrix_.transpose() * tau_red;\n  *rotor_velocities = rotor_velocities_sq.cwiseSqrt();\n}\n", "CodeBleu_score": 43.46039007325457}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    # Find the indices for the start and end times\n    start_index = self.time.index(start_time)\n    end_index = self.time.index(end_time)\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    sliced_object.time = sliced_object.time[start_index:end_index+1]\n    sliced_object.latitude = sliced_object.latitude[start_index:end_index+1]\n    sliced_object.longitude = sliced_object.longitude[start_index:end_index+1]\n    sliced_object.altitude = sliced_object.altitude[start_index:end_index+1]\n    sliced_object.temperature = sliced_object.temperature[start_index:end_index+1]\n    sliced_object.pressure = sliced_object.pressure[start_index:end_index+1]\n    sliced_object.density = sliced_object.density[start_index:end_index+1]\n    sliced_object.dynamic_pressure = sliced_object.dynamic_pressure[start_index:end_index+1]\n    sliced_object.velocity = sliced_object.velocity[start_index:end_index+1]\n    sliced_object.true_airspeed = sliced_object.true_airspeed[start_index:end_index+1]\n    sliced_object.equivalent_airspeed = sliced_object.equivalent_airspeed[start_index:end_index+1]\n    sliced_object.mach = sliced_object.mach[start_index:end_index+1]\n    sliced_object.angle_of_attack = sliced_object.angle_of_attack[start_index:end_index+1]\n    sliced_object.angle_of_sideslip = sliced_object.angle_of_sideslip[start_index:end_index+1]", "CodeBleu_score": 13.305277334772828}, {"code": "def slice(self, start_time, end_time)\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    if start_index == -1 or end_index == -1:\n        raise ValueError(\"Invalid start or end time.\")\n\n    sliced_object = copy.deepcopy(self)\n\n    for attribute in vars(sliced_object):\n        if isinstance(getattr(sliced_object, attribute), np.ndarray):\n            setattr(sliced_object, attribute, getattr(sliced_object, attribute)[start_index:end_index + 1])\n\n    return sliced_object", "CodeBleu_score": 47.18557805064688}, {"code": "def slice(self, start_time, end_time)\n    # Find the indices for the start and end times\n    start_index = np.where(self.time == start_time)[0][0]\n    end_index = np.where(self.time == end_time)[0][0]\n\n    # Create a copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    sliced_object.time = sliced_object.time[start_index:end_index+1]\n    sliced_object.x = sliced_object.x[start_index:end_index+1]\n    sliced_object.y = sliced_object.y[start_index:end_index+1]\n    sliced_object.z = sliced_object.z[start_index:end_index+1]\n    sliced_object.lat = sliced_object.lat[start_index:end_index+1]\n    sliced_object.lon = sliced_object.lon[start_index:end_index+1]\n    sliced_object.alt = sliced_object.alt[start_index:end_index+1]\n    sliced_object.roll = sliced_object.roll[start_index:end_index+1]\n    sliced_object.pitch = sliced_object.pitch[start_index:end_index+1]\n    sliced_object.yaw = sliced_object.yaw[start_index:end_index+1]\n    sliced_object.vx = sliced_object.vx[start_index:end_index+1]\n    sliced_object.vy = sliced_object.vy[start_index:end_index+1]\n    sliced_object.vz = sliced_object.vz[start_index:end_index+1]\n    sliced_object.ax = sliced_object.ax[start_index:end_index+1]\n    sliced_object.ay = sliced_object.ay[start_index:end_index+1]\n    sliced_object.az = sliced_object.az[", "CodeBleu_score": 13.307982073899389}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    euler = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    yaw = euler[2]\n    point = Point(position.x, position.y, position.z)\n    if not self.waypoints or point != self.waypoints[-1] or yaw != self.yaws[-1]:\n        self.waypoints.append(point)\n        self.yaws.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n", "CodeBleu_score": 26.808227072169977}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    pos = waypoint_msg.pose.pose.position\n    rot = waypoint_msg.pose.pose.orientation\n    _, _, yaw = self.euler_from_quaternion(rot.x, rot.y, rot.z, rot.w)\n    point = Point(pos.x, pos.y, pos.z)\n    if (\n        len(self.waypoint_positions) == 0\n        or not (\n            self.waypoint_positions[-1] == point\n            and self.waypoint_yaws[-1] == yaw\n        )\n    ):\n        self.waypoint_positions.append(point)\n        self.waypoint_yaws.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.waypoint_bag_times.append(bag_time)\n\n", "CodeBleu_score": 25.88410813935359}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    _, _, yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    point = Point(position.x, position.y, position.z)\n\n    if not self.waypoints or point != self.waypoints[-1] or yaw != self.yaws[-1]:\n        self.waypoints.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n", "CodeBleu_score": 25.453386051327353}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_linear_acceleration_x.append(msg.linear_acceleration.x)\n        self.imu_linear_acceleration_y.append(msg.linear_acceleration.y)\n        self.imu_linear_acceleration_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 32.391981024943945}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_time_bag.append(bag_time)\n        self.imu_ax.append(msg.linear_acceleration.x)\n        self.imu_ay.append(msg.linear_acceleration.y)\n        self.imu_az.append(msg.linear_acceleration.z)\n", "CodeBleu_score": 31.05023442836023}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_time_bag.append(bag_time)\n        self.imu_acc_x.append(msg.linear_acceleration.x)\n        self.imu_acc_y.append(msg.linear_acceleration.y)\n        self.imu_acc_z.append(msg.linear_acceleration.z)\n\n", "CodeBleu_score": 31.413218394293}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n    import matplotlib.pyplot as plt\n\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = \"\"\n        filename = self.plot_prefix + \"_accelerations\" + plot_suffix + \".png\"\n\n    fig = plt.figure()\n    fig.suptitle(\"Accelerations\")\n    ax = fig.add_subplot(1, 1, 1)\n\n    for i, accel_data in enumerate(self.accelerations):\n        ax.plot(\n            accel_data[\"time\"],\n            accel_data[\"x\"],\n            color=\"r\",\n            label=\"Acceleration x\" if i == 0 else None,\n        )\n        ax.plot(\n            accel_data[\"time\"],\n            accel_data[\"y\"],\n            color=\"g\",\n            label=\"Acceleration y\" if i == 0 else None,\n        )\n        ax.plot(\n            accel_data[\"time\"],\n            accel_data[\"z\"],\n            color=\"b\",\n            label=\"Acceleration z\" if i == 0 else None,\n        )\n\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    ax.legend()\n\n    if self.save_plots:\n        plt.savefig(filename)\n        plt.close(fig)\n    else:\n        plt.show()", "CodeBleu_score": 32.673903454752704}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    plt.figure()\n    plt.suptitle(\"Accelerations\")\n    plt.subplot(1, 1, 1)\n    for i, accel in enumerate(self.accelerations):\n        plt.plot(accel[:, 0], label=\"x\" + str(i))\n        plt.plot(accel[:, 1], label=\"y\" + str(i))\n        plt.plot(accel[:, 2], label=\"z\" + str(i))\n    plt.xlabel(\"Time\")\n    plt.ylabel(\"Acceleration\")\n    plt.legend()\n    if self.save_plots:\n        plt.savefig(self.prefix + \"_accelerations\" + plot_suffix + \".png\")\n\n", "CodeBleu_score": 28.920695432032783}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import os\n\n    if plot_suffix is None:\n        plot_suffix = \"\"\n\n    if not os.path.exists(\"plots\"):\n        os.makedirs(\"plots\")\n\n    # Create a figure with a title\n    fig = plt.figure(figsize=(10, 6))\n    fig.suptitle(\"Accelerations\")\n\n    # Create a subplot for accelerations\n    ax = fig.add_subplot(111)\n\n    # Plot the x, y, and z components of each acceleration dataset with different colors and labels\n    for i, accel_data in enumerate(self.accel_data):\n        time = np.arange(0, len(accel_data)) / self.sampling_rate\n        ax.plot(time, accel_data[:, 0], label=f\"X Accel {i}\")\n        ax.plot(time, accel_data[:, 1], label=f\"Y Accel {i}\")\n        ax.plot(time, accel_data[:, 2], label=f\"Z Accel {i}\")\n\n    # Add labels for the x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Add a legend\n    ax.legend()\n\n    # Save the plot as a PNG file\n    if self.save_plots:\n        filename = f\"plots/{self.prefix}_accelerations{plot_suffix}.png\"\n        plt.savefig(filename)\n\n    # Show the plot\n    plt.show()", "CodeBleu_score": 38.651900207964744}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"At least two pose indeces are required for comparison.\")\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 44.891678952023284}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        raise ValueError(\"At least two pose indeces are required for comparison.\")\n\n    for i in range(len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 38.864742691400345}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"Please provide at least two pose indices to compare.\")\n        return\n\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 41.825852979905754}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 34.06315477308111}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench.keys():\n        if (start_time is None or time >= start_time) and (end_time is None or time <= end_time):\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 41.252935168922136}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n        if start_time is None or time >= start_time:\n            if end_time is None or time <= end_time:\n                collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 38.766509270398835}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 30.087936187511037}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    # Calculate the absolute settling time\n    absolute_settling_time = start_time + settling_time\n    # Call analyze_bag.plot_angular_velocities with the specified parameters\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n", "CodeBleu_score": 32.10207328495848}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    absolute_settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n", "CodeBleu_score": 32.10207328495848}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate the multiplier based on camera parameters\n  float multiplier =\n      (float)width / (float)this->camera_width_ *\n      (float)height / (float)this->camera_height_;\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Compute the RMS noise\n  float rms_noise = this->rms_noise_ * multiplier;\n\n  // Compute the noise values\n  std::normal_distribution<float> noise_distribution(0.0, rms_noise);\n  std::uniform_real_distribution<float> uniform_distribution(0.0, 1.0);\n\n  // Apply noise to each pixel\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vec[i] >= this->min_depth_ && data_vec[i] <= this->max_depth_) {\n      float noise = noise_distribution(this->random_generator_);\n      float random_value = uniform_distribution(this->random_generator_);\n      if (random_value <= this->noise_probability_) {\n        data_vec[i] += noise;\n      }\n    } else {\n      data_vec[i] = this->bad_point_;\n    }\n  }\n}\n", "CodeBleu_score": 54.513421745574675}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (!data) {\n    return;\n  }\n\n  // Compute the multiplier based on camera parameters\n  float multiplier =\n      (width * height) / (m_camera_params.fx * m_camera_params.fy);\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Compute the RMS noise\n  float rms_noise =\n      m_camera_params.k1 * multiplier + m_camera_params.k2 * multiplier * multiplier;\n\n  // Compute the noise values\n  float noise_1 = m_camera_params.k1 * multiplier;\n  float noise_2 = m_camera_params.k2 * multiplier * multiplier;\n\n  // Add noise to the data\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data[i] >= m_camera_params.min_depth &&\n        data[i] <= m_camera_params.max_depth) {\n      data[i] += noise_1 + noise_2 * data[i];\n    } else {\n      data[i] = m_camera_params.bad_point;\n    }\n  }\n}\n", "CodeBleu_score": 44.56613569737845}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n  const float multiplier =\n      (k1_ * k1_ + k2_ * k2_ + k3_ * k3_) / (k1_ + k2_ + k3_);\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n  const float rms_noise =\n      multiplier * std::sqrt(std::pow(std::abs(mean_ - 1), 2) +\n                             std::pow(std::abs(std::sqrt(var_) - 1), 2));\n  const float noise_1 = std::sqrt(var_) * rms_noise;\n  const float noise_2 = mean_ * rms_noise;\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vec[i] > 0 && data_vec[i] < kMaxDepth_) {\n      data_vec[i] += noise_1 * data_vec[i] + noise_2;\n    } else {\n      data_vec[i] = kBadPoint;\n    }\n  }\n}\n", "CodeBleu_score": 50.781185207449056}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get the current simulation time\n  common::Time current_time = world_->GetSimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + waypoint_topic_, ros_time, *trajectpoint_msg);\n}\n", "CodeBleu_score": 44.11434538957898}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get the current simulation time\n  gazebo::common::Time current_time = this->model->GetWorld()->GetSimTime();\n\n  // Convert the current simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n\n  // Write the trajectory message to the bag file\n  bag.write(namespace_ + waypoint_topic_, ros_time, *trajectory_msg);\n}\n", "CodeBleu_score": 47.77215014304518}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get the current simulation time\n  gazebo::common::Time current_time = this->model_->GetWorld()->SimTime();\n  // Convert the current simulation time to ROS time\n  ros::Time ros_time;\n  ros_time.sec = current_time.sec;\n  ros_time.nsec = current_time.nsec;\n  // Write the trajectory message to the bag file\n  bag_.write(namespace_ + waypoint_topic_, ros_time, *trajectory_msg);\n}\n", "CodeBleu_score": 47.98422296217095}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)  // Convert simulation time to ROS time\n  ros::Time ros_now = ros::Time::now();\n  ros::Time ros_now_fixed = ros::Time(now.sec, now.nsec);\n\n  // Prepare message for actuator velocities\n  gazebo_msgs::msgs::JointCmd joint_cmd;\n  joint_cmd.set_name(std::vector<std::string>());\n  joint_cmd.set_position(std::vector<double>());\n  joint_cmd.set_velocity(std::vector<double>());\n  joint_cmd.set_force(std::vector<double>());\n\n  // Iterate through motor joints\n  for (unsigned int i = 0; i < joint_names_.size(); i++) {\n    // Get joint pointer\n    gazebo::physics::JointPtr joint = model_->GetJoint(joint_names_[i]);\n\n    // Calculate slowed-down rotational velocity\n    double slowed_down_velocity = joint->GetVelocity(0) * velocity_slow_down_;\n\n    // Assign slowed-down velocity to message\n    joint_cmd.set_name(i, joint_names_[i]);\n    joint_cmd.set_velocity(i, slowed_down_velocity);\n  }\n\n  // Set message timestamp\n  joint_cmd.set_stamp(now.sec * 1e9 + now.nsec);\n\n  // Write message to bag file\n  bag_.write(motor_topic_, ros_now_fixed, joint_cmd);\n}\n", "CodeBleu_score": 48.934214724838064}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)    ros::Time time = ros::Time::now();\n    gazebo_msgs::ActuatorVelocities msg;\n    for (int i = 0; i < this->motor_joints.size(); i++) {\n        double slowed_down_velocity = this->motor_joints[i]->GetVelocity(0) * this->slow_down_factor;\n        msg.velocity.push_back(slowed_down_velocity);\n    }\n    msg.header.stamp = ros::Time::now();\n    this->bag.write(this->motor_topic, time, msg);\n}\n", "CodeBleu_score": 35.622789289725965}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)    // Convert simulation time to ROS time\n    ros::Time ros_now = ros::Time::now();\n\n    // Prepare a message for actuator velocities\n    gazebo_msgs::ActuatorVelocities msg;\n\n    // Iterate through the motor joints\n    for (unsigned int i = 0; i < this->motor_joints.size(); i++) {\n        // Get the current joint velocity\n        double joint_vel = this->motor_joints[i]->GetVelocity(0);\n\n        // Calculate the slowed-down rotational velocity\n        double slowed_down_vel = joint_vel * this->slow_down_factor;\n\n        // Assign the slowed-down rotational velocity to the message\n        msg.velocities.push_back(slowed_down_vel);\n    }\n\n    // Set the message timestamp\n    msg.header.stamp = ros_now;\n\n    // Write the data to a bag file\n    this->bag.write(this->motor_topic, ros_now, msg);\n}\n", "CodeBleu_score": 38.88273749653373}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert normalized input values to control surface angles\n  double aileron_left = roll_pitch_yawrate_thrust_msg->roll() * max_aileron_angle_;\n  double aileron_right = -roll_pitch_yawrate_thrust_msg->roll() * max_aileron_angle_;\n  double elevator = -roll_pitch_yawrate_thrust_msg->pitch() * max_elevator_angle_;\n  double rudder = -roll_pitch_yawrate_thrust_msg->yaw_rate() * max_rudder_angle_;\n\n  // Set control surface angles\n  joints_[\"left_aileron_joint\"]->SetForce(0, aileron_left);\n  joints_[\"right_aileron_joint\"]->SetForce(0, aileron_right);\n  joints_[\"elevator_joint\"]->SetForce(0, elevator);\n  joints_[\"rudder_joint\"]->SetForce(0, rudder);\n\n  // Set throttle\n  joints_[\"left_engine_propeller_joint\"]->SetForce(0, roll_pitch_yawrate_thrust_msg->thrust());\n  joints_[\"right_engine_propeller_joint\"]->SetForce(0, roll_pitch_yawrate_thrust_msg->thrust());\n}\n", "CodeBleu_score": 52.210363839273896}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  // TODO: Make sure the control surface angles are within the valid range.\n  double ailerons = (roll_pitch_yawrate_thrust_msg->roll() - 0.5) * 70.0;\n  double elevator = (roll_pitch_yawrate_thrust_msg->pitch() - 0.5) * 70.0;\n  double rudder = (roll_pitch_yawrate_thrust_msg->yaw_rate() - 0.5) * 60.0;\n\n  // Set the throttle value from the thrust message.\n  // TODO: Make sure the throttle value is within the valid range.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // TODO: Set the control surface angles and throttle values in the model.\n  // model_->SetControlSurfaceAngles(ailerons, elevator, rudder);\n  // model_->SetThrottle(throttle);\n}\n", "CodeBleu_score": 39.486225530230826}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_) {\n    gzdbg << __FUNCTION__ << \"() called.\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to\n  // control surface angles for ailerons, elevator, and rudder respectively.\n  double left_aileron_angle = roll_pitch_yawrate_thrust_msg->roll() * M_PI_2;\n  double right_aileron_angle = -left_aileron_angle;\n  double elevator_angle = -roll_pitch_yawrate_thrust_msg->pitch() * M_PI_2;\n  double rudder_angle = -roll_pitch_yawrate_thrust_msg->yaw_rate() * M_PI_2;\n\n  // Set the throttle value from the thrust message.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust();\n\n  // Set the control surface angles and throttle values in the model.\n  model_->SetJointPosition(left_aileron_joint_, left_aileron_angle);\n  model_->SetJointPosition(right_aileron_joint_, right_aileron_angle);\n  model_->SetJointPosition(elevator_joint_, elevator_angle);\n  model_->SetJointPosition(rudder_joint_, rudder_angle);\n  model_->SetJointPosition(left_engine_prop_joint_, throttle);\n  model_->SetJointPosition(right_engine_prop_joint_, throttle);\n}\n", "CodeBleu_score": 53.15056065833142}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // poll for MAVLink messages\n  if (readMessages) {\n    // wait until timeout before giving up\n    timeval timeout;\n    timeout.tv_sec = _timeoutMs / 1000;\n    timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(fd, &readfds);\n\n    int ret = select(fd + 1, &readfds, nullptr, nullptr, &timeout);\n\n    if (ret < 0) {\n      // this happens when the mavlink socket is closed\n      // perror(\"GazeboMavlinkInterface::pollForMAVLinkMessages: select error\");\n      return;\n    }\n\n    if (ret == 0) {\n      // timeout\n      return;\n    }\n\n    if (FD_ISSET(fd, &readfds)) {\n      // MAVLink message received\n      uint8_t buf[2048];\n      int bytesReceived = ::recv(fd, buf, sizeof(buf), 0);\n\n      if (bytesReceived < 0) {\n        // this happens when the mavlink socket is closed\n        // perror(\"GazeboMavlinkInterface::pollForMAVLinkMessages: recv error\");\n        return;\n      }\n\n      mavlink_message_t msg;\n      mavlink_status_t status;\n\n      for (int i = 0; i < bytesReceived; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_1, buf[i], &msg, &status)) {\n          // forward message via serial port\n          if (serialEnabled) {\n            serialSend(buf[i]);\n          }\n\n          // handle message\n          handleMessage(&msg);\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 56.788173202712976}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // poll for MAVLink messages\n  if (readMessages) {\n    // get the file descriptor of the serial port\n    int fd = serial_port_fd;\n\n    // check if there is data to read\n    if (serialDataAvailable(fd)) {\n      // get the current time\n      struct timeval timeout = timevalFromNanoseconds(_timeoutMs * 1000000);\n\n      // wait for data to be available for reading\n      fd_set readfds;\n      FD_ZERO(&readfds);\n      FD_SET(fd, &readfds);\n      int ret = select(fd + 1, &readfds, NULL, NULL, &timeout);\n\n      // if there is data available, read it\n      if (ret > 0 && FD_ISSET(fd, &readfds)) {\n        // get the number of bytes available to read\n        int bytes_available;\n        ioctl(fd, FIONREAD, (char *)&bytes_available);\n\n        // read the data\n        uint8_t buffer[bytes_available];\n        int bytes_read = ::read(fd, buffer, bytes_available);\n\n        // parse the MAVLink messages\n        mavlink_message_t message;\n        mavlink_status_t status;\n        for (int i = 0; i < bytes_read; i++) {\n          // try to get a new message\n          if (mavlink_parse_char(MAVLINK_COMM_1, buffer[i], &message, &status)) {\n            // handle the message\n            handleMessage(&message);\n\n            // check if the message is a command\n            if (message.msgid == MAVLINK_MSG_ID_COMMAND_LONG) {\n              // decode the command\n              mavlink_command_long_t command;\n              mavlink_msg_command_long_decode(&message, &command);\n\n              // handle the command\n              handleCommand(&command);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 43.65795026930662}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // poll for MAVLink messages\n  if (_timeoutMs == 0) {\n    _timeoutMs = _dt * 1000;\n  }\n  struct timeval timeout;\n  timeout.tv_sec = 0;\n  timeout.tv_usec = _timeoutMs * 1000;\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(fd_, &readfds);\n  int select_ret = select(fd_ + 1, &readfds, nullptr, nullptr, &timeout);\n  if (select_ret < 0) {\n    std::cerr << \"Error: select failed in GazeboMavlinkInterface::pollForMAVLinkMessages\\n\";\n    return;\n  }\n  if (select_ret == 0) {\n    // no data available\n    return;\n  }\n  if (FD_ISSET(fd_, &readfds)) {\n    // data available\n    uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n    int buf_len = read(fd_, buf, MAVLINK_MAX_PACKET_LEN);\n    if (buf_len > 0) {\n      mavlink_message_t msg;\n      mavlink_status_t status;\n      for (int i = 0; i < buf_len; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_1, buf[i], &msg, &status)) {\n          // forward message to serial\n          if (serial_enabled_) {\n            serial_port_->write(buf + i, 1);\n          }\n          // handle message\n          handleMessage(&msg);\n          i += msg.len;\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 51.84780617408189}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close()     std::lock_guard<std::mutex> lock(mutex);\n    if (is_open()) {\n        io_service.stop();\n        serial_dev->close();\n        if (io_thread.joinable()) {\n            io_thread.join();\n        }\n    }\n}\n", "CodeBleu_score": 57.88638867597518}, {"code": "void GazeboMavlinkInterface::close()   boost::mutex::scoped_lock lock(mutex);\n  if (serial_dev->is_open()) {\n    io_service.stop();\n    serial_dev->close();\n    if (io_thread.joinable())\n      io_thread.join();\n  }\n}\n", "CodeBleu_score": 59.66447309543316}, {"code": "void GazeboMavlinkInterface::close()     // Lock the mutex to ensure thread safety\n    std::lock_guard<std::recursive_mutex> lock(mutex);\n    // Check if the interface is open\n    if (is_open()) {\n        // Stop the I/O service\n        io_service.stop();\n        // Close the serial device\n        port->close();\n        // Check if the I/O thread is joinable\n        if (io_thread.joinable()) {\n            // Join the thread to clean up resources\n            io_thread.join();\n        }\n    }\n}\n", "CodeBleu_score": 54.183558127047874}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    ignition::math::Vector3d point1, point2;\n    double value1, value2;\n    double interpolatedValue;\n    ignition::math::Vector3d interpolatedPoint;\n\n    // Calculate the interpolated value\n    interpolatedValue = (value1 * (point2.Y() - point.Y()) + value2 * (point.Y() - point1.Y())) / (point2.Y() - point1.Y());\n\n    // Calculate the interpolated point\n    interpolatedPoint.X() = point.X();\n    interpolatedPoint.Y() = point.Y();\n    interpolatedPoint.Z() = interpolatedValue;\n\n    return interpolatedPoint;\n}\n", "CodeBleu_score": 33.124476759431445}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    ignition::math::Vector3d p0;\n    ignition::math::Vector3d p1;\n    double t;\n\n    ignition::math::Vector3d result;\n\n    result.X() = p0.X() + (p1.X() - p0.X()) * t;\n    result.Y() = p0.Y() + (p1.Y() - p0.Y()) * t;\n    result.Z() = p0.Z() + (p1.Z() - p0.Z()) * t;\n\n    return result;\n}\n", "CodeBleu_score": 38.30136076121281}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation  ignition::math::Vector3d pos;\n  ignition::math::Vector3d pos1;\n  ignition::math::Vector3d pos2;\n  ignition::math::Vector3d value1;\n  ignition::math::Vector3d value2;\n\n  double distance = pos1.Distance(pos2);\n  double distance1 = pos.Distance(pos1);\n  double distance2 = pos.Distance(pos2);\n\n  if (distance1 >= distance || distance2 >= distance) {\n    return ignition::math::Vector3d(0, 0, 0);\n  }\n\n  return (value1 * (distance - distance1) + value2 * (distance - distance2)) / distance;\n}\n", "CodeBleu_score": 34.79568945202277}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)    // If the new time differs from the current time, update the time position.\n    if (_time != time) {\n        // If looping is enabled, wrap the time within the animation length.\n        if (looping) {\n            time = fmod(_time, length);\n            if (time < 0) {\n                time += length;\n            }\n        // If looping is disabled, clamp the time between 0 and the animation length.\n        } else {\n            if (_time > length) {\n                time = length;\n            } else if (_time < 0) {\n                time = 0;\n            } else {\n                time = _time;\n            }\n        }\n\n        // Update the animation pose.\n        UpdatePose();\n    }\n}\n", "CodeBleu_score": 41.371071018409154}, {"code": "void Animation::SetTime(double _time)    if (m_time != _time) {\n        m_time = _time;\n\n        if (m_loop) {\n            m_time = std::fmod(m_time, m_length);\n            if (m_time < 0.0) {\n                m_time += m_length;\n            }\n        }\n        else {\n            if (m_time < 0.0) {\n                m_time = 0.0;\n            }\n            else if (m_time > m_length) {\n                m_time = m_length;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 42.98220847806512}, {"code": "void Animation::SetTime(double _time)    if (time != _time) {\n        time = _time;\n\n        if (looping) {\n            time = fmod(time, length);\n\n            if (time < 0.0) {\n                time += length;\n            }\n        } else {\n            if (time < 0.0) {\n                time = 0.0;\n            } else if (time > length) {\n                time = length;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 43.4028340951806}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    target_motion = self.get_motion()\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.flight_mode)\n    return target_motion\n\n", "CodeBleu_score": 23.567408828349183}, {"code": "def hover(self)\n    self.set_coord_frame(1)\n    self.set_motion_type(0)\n    target_motion = self.get_target_motion()\n    print(f\"{self.vehicle_type} {self.vehicle_id} is hovering at {target_motion}\")\n", "CodeBleu_score": 12.940929836175727}, {"code": "def hover(self)\n    self.set_coordinate_frame(1)\n    self.set_motion_type(0)\n    target_motion = self.get_target_motion()\n    print(f\"hovering at {target_motion}\")\n    print(f\"vehicle type: {self.vehicle_type}, id: {self.vehicle_id}, flight mode: {self.flight_mode}\")\n\n", "CodeBleu_score": 23.55996265751591}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover()\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(\"Mode switch success\")\n            return True\n        except:\n            print(\"Mode switch failed\")\n            return False\n\n", "CodeBleu_score": 48.66259695149171}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover()\n    else:\n        try:\n            self.flight_mode_service(self.flight_mode)\n            print(\"Flight mode switched to\", self.flight_mode)\n            return True\n        except:\n            print(\"Failed to switch flight mode\")\n            return False\n\n", "CodeBleu_score": 54.61121629626538}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print(\"Mode switched to \", self.flight_mode)\n            return True\n        except:\n            print(\"Failed to switch mode to \", self.flight_mode)\n            return False", "CodeBleu_score": 55.44564179317454}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if not (self.hover_flag or self.hold_flag):\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.angular.z]", "CodeBleu_score": 48.02516825069921}, {"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not (self.hover_flag or self.hold_flag):\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z]\n\n", "CodeBleu_score": 55.8657897725517}, {"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z]\n", "CodeBleu_score": 48.89892543127967}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n    if self.hover_flag == 0:\n        self.flight_mode = \"OFFBOARD\"\n        self.hover_flag = 1\n        self.hover_action()\n\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = \"OFFBOARD\"\n", "CodeBleu_score": 66.81556113640752}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_flight_mode(\"OFFBOARD\")\n    if (self.flight_mode != \"HOVER\" and self.hover_flag == 1):\n        self.hover_flag = 1\n        self.set_flight_mode(\"HOVER\")\n        self.hover_action()\n", "CodeBleu_score": 53.93583022161077}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.flight_mode != \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        else:\n            self.hover_flag = 1\n            self.flight_mode = \"HOVER\"\n            self.hover_action()\n\n    elif self.flight_mode == \"HOVER\":\n        if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = \"OFFBOARD\"\n        else:\n            self.hover_flag = 1\n            self.hover_action()", "CodeBleu_score": 64.41108010943445}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return math.atan2(2.0 * (q.w * q.z + q.x * q.y), 1.0 - 2.0 * (q.y * q.y + q.z * q.z))\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        return math.atan2(2.0 * (q.w * q.z + q.x * q.y), 1.0 - 2.0 * (q.y * q.y + q.z * q.z))\n\n", "CodeBleu_score": 36.811596296569974}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        q = q\n    else:\n        q = Quaternion(q)\n    return math.atan2(2 * (q.w * q.z + q.x * q.y), 1 - 2 * (q.y ** 2 + q.z ** 2))", "CodeBleu_score": 28.324525033628884}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        q = q.w, q.x, q.y, q.z\n    else:\n        q = Quaternion(*q)\n    return math.atan2(2 * (q.w * q.z + q.x * q.y), 1 - 2 * (q.y**2 + q.z**2))", "CodeBleu_score": 36.404340490541074}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    self.frame = MAV_FRAME_BODY_NED\n    self.type_mask = VEHICLE_TYPE_MASK\n    self.target_system = self.target_system\n    self.target_component = self.target_component\n    self.location.x = 0\n    self.location.y = 0\n    self.location.z = -self.ground_clearance\n    self.location.yaw = self.yaw\n    self.body = self.location\n    self.type_mask = VEHICLE_TYPE_MASK\n    print(\n        f\"{self.vehicle_type} {self.vehicle_id} is in {self.flight_mode} mode\"\n    )\n\n", "CodeBleu_score": 27.452389278167356}, {"code": "def hover(self)\n    self.set_attitude_target_to_current_attitude()\n    self.set_attitude_target(0, 0, 0, 0.65, 0)\n    self.set_attitude_target_thrust(0.55)\n    self.set_attitude_target_type_mask_bitmask(6)\n    self.set_attitude_target_type_mask(\n        Vehicle.ATTITUDE_TARGET_TYPEMASK_THROTTLE_IGNORE)\n    self.set_attitude_target_type_mask(\n        Vehicle.ATTITUDE_TARGET_TYPEMASK_ATTITUDE_IGNORE)\n    self.update_attitude_target_course_yaw_rate_hz()\n    self.update_attitude_target_type_mask_bitmask()\n    self.update_attitude_target_thrust()\n    self.update_attitude_target_type_mask()\n    self.update_attitude_target()\n    self.update_mode()\n    self.update_frame()\n    self.update_type()\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.mode)", "CodeBleu_score": 15.926048587154604}, {"code": "def hover(self)\n    self.vehicle.set_mode(\"HOVER\")\n    self.vehicle.set_frame(\"BODY_OFFSET_NED\")\n    self.vehicle.set_mavlink_motion_type(\"HOVER\")\n    self.target_motion = self.vehicle.mavlink_connection.mavlink_set_position_target_local_ned_encode(\n        self.vehicle.mavlink_connection.target_system,\n        self.vehicle.mavlink_connection.target_component,\n        mavutil.mavlink.MAV_FRAME_BODY_OFFSET_NED,\n        int(0b110111111000),\n        self.vehicle.location.local_frame.north,\n        self.vehicle.location.local_frame.east,\n        -self.vehicle.location.local_frame.down,\n        0.0, 0.0, 0.0,\n        self.vehicle.attitude.yaw,\n        0.0, 0.0, 0.0, 0.0)\n    print(f\"{self.vehicle_type} {self.vehicle_id} is flying in hover mode.\")\n", "CodeBleu_score": 35.20353748992285}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(self.flight_mode)\n            print('Flight mode switched to', self.flight_mode)\n            return True\n        except Exception as e:\n            print('Failed to switch flight mode:', e)\n            return False\n\n", "CodeBleu_score": 51.27989278032358}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = True\n        self.hover()\n    else:\n        try:\n            self.flightModeService(\n                custom_mode=self.flight_mode\n            )  # Set new flight mode\n            print(f\"Flight mode set to {self.flight_mode}\")\n            return True\n        except Exception as e:\n            print(f\"Failed to set flight mode: {e}\")\n            return False\n\n", "CodeBleu_score": 32.60616505529989}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(self.flight_mode)\n            print(\"Flight mode set to: \", self.flight_mode)\n            return True\n        except:\n            print(\"Failed to set flight mode\")\n            return False\n", "CodeBleu_score": 47.57189230355851}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.local_pose.header.stamp = rospy.Time.now()\n        self.local_pose.header.frame_id = 'map'\n        self.local_pose.pose.position.z = self.local_pose.pose.position.z + self.bias_pose_z\n        self.global_pose = self.local_pose\n        if self.gcs_command == 'takeoff':\n            self.takeoff_target_pose = self.local_pose\n            self.takeoff_target_pose.pose.position.z = self.takeoff_target_pose.pose.position.z + self.takeoff_height\n            self.hover_target_pose = self.takeoff_target_pose\n        elif self.gcs_command == 'land':\n            self.takeoff_target_pose = self.local_pose\n            self.takeoff_target_pose.pose.position.z = self.takeoff_target_pose.pose.position.z + self.takeoff_height\n            self.hover_target_pose = self.takeoff_target_pose\n        elif self.gcs_command == 'hover':\n            self.takeoff_target_pose = self.local_pose\n            self.takeoff_target_pose.pose.position.z = self.takeoff_target_pose.pose.position.z + self.takeoff_height\n            self.hover_target_pose = self.takeoff_target_pose\n        elif self.gcs_command == 'move':\n            self.takeoff_target_pose = self.local_pose\n            self.takeoff_target_pose.pose.position.z = self.takeoff_target_pose.pose.position.z + self.takeoff_height\n            self.hover_target_pose = self.takeoff_target_pose\n        elif self.gcs_command == 'waypoint':\n            self.takeoff_target_pose = self.local_pose\n            self.takeoff_target_pose.pose.position.z = self.takeoff_target_pose.pose.position.z + self.take", "CodeBleu_score": 18.538481405091943}, {"code": "def local_pose_callback(self, msg, i)\n    if i == self.uav_id:\n        self.local_pose.pose = msg.pose\n        self.global_pose.pose.position.x = msg.pose.position.x + self.bias_x\n        self.global_pose.pose.position.y = msg.pose.position.y + self.bias_y\n        self.global_pose.pose.position.z = msg.pose.position.z + self.bias_z\n\n        if self.takeoff_flag:\n            self.takeoff_target_pose.pose.position.z = self.takeoff_target_pose.pose.position.z + self.bias_z\n            self.takeoff_target_pose.pose.position.x = self.takeoff_target_pose.pose.position.x + self.bias_x\n            self.takeoff_target_pose.pose.position.y = self.takeoff_target_pose.pose.position.y + self.bias_y\n\n        if self.hover_flag:\n            self.hover_target_pose.pose.position.z = self.hover_target_pose.pose.position.z + self.bias_z\n            self.hover_target_pose.pose.position.x = self.hover_target_pose.pose.position.x + self.bias_x\n            self.hover_target_pose.pose.position.y = self.hover_target_pose.pose.position.y + self.bias_y\n\n        if self.land_flag:\n            self.land_target_pose.pose.position.z = self.land_target_pose.pose.position.z + self.bias_z\n            self.land_target_pose.pose.position.x = self.land_target_pose.pose.position.x + self.bias_x\n            self.land_target_pose.pose.position.y = self.land_target_pose.pose.position.y + self.bias_y\n\n        if self.return_flag:\n            self.return_target_pose.pose.position.z = self.return_target_pose.pose.position.z + self.", "CodeBleu_score": 18.51553193103902}, {"code": "def local_pose_callback(self, msg, i)\n    if i == self.uav_id:\n        self.local_pose = msg\n        self.global_pose = msg\n        self.global_pose.pose.position.x += self.bias_x\n        self.global_pose.pose.position.y += self.bias_y\n        self.global_pose.pose.position.z += self.bias_z\n        self.global_pose.header.stamp = rospy.Time.now()\n\n        if self.takeoff_command:\n            self.takeoff_target_pose.pose.position.x = self.global_pose.pose.position.x\n            self.takeoff_target_pose.pose.position.y = self.global_pose.pose.position.y\n            self.takeoff_target_pose.pose.position.z = self.takeoff_height\n            self.takeoff_target_pose.pose.orientation = self.global_pose.pose.orientation\n            self.takeoff_target_pose.header.stamp = rospy.Time.now()\n\n        if self.hover_command:\n            self.hover_target_pose.pose.position.x = self.global_pose.pose.position.x\n            self.hover_target_pose.pose.position.y = self.global_pose.pose.position.y\n            self.hover_target_pose.pose.position.z = self.hover_height\n            self.hover_target_pose.pose.orientation = self.global_pose.pose.orientation\n            self.hover_target_pose.header.stamp = rospy.Time.now()\n\n        if self.land_command:\n            self.land_target_pose.pose.position.x = self.global_pose.pose.position.x\n            self.land_target_pose.pose.position.y = self.global_pose.pose.position.y\n            self.land_target_pose.pose.position.z = 0\n            self.land_target_pose.pose.orientation = self.global_pose.pose.orientation\n            self.land_target_pose.header.stamp = rospy.Time.now", "CodeBleu_score": 18.274395871945945}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    if self.state.armed and self.state.local_position.z > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 60.40512724867122}, {"code": "def takeoff_detection(self)\n    if self.state.armed and self.state.local_position.z > 0.2:\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 60.40512724867122}, {"code": "def takeoff_detection(self)\n    if self.state.armed and self.state.mode == \"GUIDED\" and self.state.altitude > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 58.997434928278494}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    dist_matrix = np.zeros((len(orig_formation), len(orig_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            dist_matrix[i][j] = int(50 - np.linalg.norm(orig_formation[i] - orig_formation[j]))\n    return dist_matrix\n", "CodeBleu_score": 25.945764531493044}, {"code": "def build_graph(self, orig_formation, change_formation)\n    distances = np.zeros((len(orig_formation), len(orig_formation)))\n    for i, uav1 in enumerate(orig_formation):\n        for j, uav2 in enumerate(orig_formation):\n            distances[i, j] = int(50 - np.linalg.norm(uav1 - uav2))\n    return distances\n\n", "CodeBleu_score": 19.542671748373017}, {"code": "def build_graph(self, orig_formation, change_formation)\n    distances = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            distances[i, j] = int(50 - np.linalg.norm(orig_formation[i] - change_formation[j]))\n    return distances\n\n", "CodeBleu_score": 26.45947284453935}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    for j in self.G[i]:\n        if self.visited[j] == 1:\n            continue\n        self.visited[j] = 1\n        gap = self.lx[i] + self.ly[j] - self.w[i][j]\n        if gap == 0:\n            self.visited[j] = 1\n            if self.match[j] == -1 or self.find_path(self.match[j]):\n                self.match[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 42.86916875194272}, {"code": "def find_path(self, i)\n    self.visited_left[i] = True\n    for j in self.adj_right[i]:\n        if self.visited_right[j]:\n            continue\n        gap = self.label_left[i] + self.label_right[j] - self.graph[i][j]\n        if gap == 0:\n            self.visited_right[j] = True\n            if self.match_right[j] == -1 or self.find_path(self.match_right[j]):\n                self.match_left[i] = j\n                self.match_right[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 38.26460683910603}, {"code": "def find_path(self, i)\n    self.visited[i] = True\n    for j in range(self.m):\n        if self.visited[self.m + j]:\n            continue\n        gap = self.left_labels[i] + self.right_labels[j] - self.graph[i][j]\n        if gap == 0:\n            self.visited[self.m + j] = True\n            if self.match[j] == -1 or self.find_path(self.match[j]):\n                self.match[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 48.81111838976962}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n    # Iterate over UAVs\n    for uav in self.uavs:\n        # Initialize slack variables and reset visit arrays\n        uav.slack = [float('inf')] * len(self.targets)\n        uav.visited = [False] * len(self.targets)\n        uav.match = -1\n\n    # Iterate over UAVs\n    for uav in self.uavs:\n        # Reset visit arrays\n        uav.visited = [False] * len(self.targets)\n\n        # Call the DFS function to find a path\n        self.DFS(uav)\n\n    # Return the match results for the right side of the bipartite graph\n    return [target.match for target in self.targets]\n\n", "CodeBleu_score": 13.660247554289093}, {"code": "def KM(self)\n    for uav in self.UAVs:\n        uav.slack = [float('inf')] * len(self.targets)\n        uav.visited = [False] * len(self.targets)\n\n    while True:\n        path = self.find_path()\n        if path is None:\n            break\n        for uav, target in path:\n            uav.match(target)\n\n    return [uav.matching for uav in self.UAVs]\n\n", "CodeBleu_score": 15.63003647063153}, {"code": "def KM(self)\n    # Iterate over UAVs\n    for uav in self.UAVs:\n        # Initialize slack variables and reset visit arrays\n        slack = [float('inf')] * len(self.targets)\n        uav.visited = [False] * len(self.targets)\n        # Iterate over targets\n        while True:\n            # Reset visit arrays\n            for target in self.targets:\n                target.visited = False\n            # Find a path using DFS\n            if self.DFS(uav, slack):\n                break\n            # Adjust labels based on minimum slack value\n            d = float('inf')\n            for target in self.targets:\n                if not target.visited:\n                    d = min(d, slack[target.index])\n            for uav in self.UAVs:\n                if uav.visited:\n                    for target in self.targets:\n                        if not target.visited:\n                            slack[target.index] += d\n                            uav.match[target.index] -= d\n            for target in self.targets:\n                if target.visited:\n                    uav.match[target.index] += d\n    # Return the match results for the right side of the bipartite graph\n    return [uav.match for uav in self.UAVs]\n\n", "CodeBleu_score": 27.715265292380398}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n", "CodeBleu_score": 30.535780286037383}, {"code": "def yellow_dectection(image)\n    import cv2\n    import numpy as np\n\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n\n", "CodeBleu_score": 63.710682088072865}, {"code": "def yellow_dectection(image)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 30.535780286037383}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription    auto it = standalone_tag_descriptions_.find(id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (print_warning) {\n            ROS_WARN_STREAM(\"Standalone tag description with ID \" << id << \" not found.\");\n        }\n        return false;\n    }\n    descriptionContainer = it->second;\n    return true;\n}\n", "CodeBleu_score": 39.41848838649257}, {"code": "bool TagDetector::findStandaloneTagDescription    if (standalone_tag_descriptions_.count(id) == 0) {\n        if (printWarning) {\n            ROS_WARN_STREAM(\"Could not find standalone tag description with id \" << id << \". Is the description file up-to-date?\");\n        }\n        return false;\n    }\n    descriptionContainer = standalone_tag_descriptions_[id];\n    return true;\n}\n", "CodeBleu_score": 30.466643612593952}, {"code": "bool TagDetector::findStandaloneTagDescription    std::map<int, StandaloneTagDescription>::iterator it;\n    it = standalone_tag_descriptions_.find(id);\n    if (it == standalone_tag_descriptions_.end()) {\n        if (print_warning) {\n            ROS_WARN(\"findStandaloneTagDescription: Cannot find any template with id %d\", id);\n        }\n        return false;\n    }\n    descriptionContainer = &(it->second);\n    return true;\n}\n\n", "CodeBleu_score": 46.68313661353191}]}
