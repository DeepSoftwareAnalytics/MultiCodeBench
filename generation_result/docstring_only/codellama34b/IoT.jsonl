{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\twhile (desc->bDescriptorType != USB_DESC_TYPE_INTERFACE_STOP) {\n\t\tif (desc->bDescriptorType == desc_id)\n\t\t\treturn desc;\n\t\tdesc = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) desc + desc->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 33.718178968859405}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc = desc;\n\twhile (next_desc->bDescriptorType != USB_DESC_TYPE_ENDPOINT) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t *) next_desc + next_desc->bLength);\n\t\tif (next_desc->bDescriptorType == USB_DESC_TYPE_INTERFACE) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 35.85973509128523}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t *ptr = (uint8_t *) desc;\n\twhile (ptr[1] != desc_id) {\n\t\tptr += ptr[0];\n\t\tif (ptr[0] == 0)\n\t\t\treturn NULL;\n\t}\n\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) ptr;\n}\n", "CodeBleu_score": 16.284263353050903}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (!usb_config_descriptor)\n\t\treturn false;\n\tif (iface_num >= usb_config_descriptor->bNumInterfaces)\n\t\treturn false;\n\n\tuint8_t *ptr = (uint8_t *)usb_config_descriptor;\n\tptr += usb_config_descriptor->bLength;\n\twhile (ptr < (uint8_t *)usb_config_descriptor + usb_config_descriptor->wTotalLength) {\n\t\tif (ptr[1] == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *iface_desc = (struct usb_interface_descriptor *)ptr;\n\t\t\tif (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tptr += ptr[0];\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 35.19737064554212}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (g_usb_cfg_descriptor == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= g_usb_cfg_descriptor->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t *p = (uint8_t *)g_usb_cfg_descriptor;\n\tuint8_t *end = (uint8_t *)g_usb_cfg_descriptor + g_usb_cfg_descriptor->wTotalLength;\n\twhile (p < end) {\n\t\tif (p[1] == USB_DT_INTERFACE) {\n\t\t\tif ((p[2] == iface_num) && (p[3] == setting_num)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tp += p[0];\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 35.99239090938984}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)    uint8_t *iface_desc = NULL;\n    uint8_t *desc = NULL;\n    uint8_t iface_desc_num = 0;\n    uint8_t iface_desc_setting_num = 0;\n    uint8_t desc_len = 0;\n\n    /* Check for valid configuration */\n    if (usb_d_get_cfg() == NULL) {\n        return false;\n    }\n\n    /* Check for interface number in bounds */\n    if (iface_num >= usb_d_get_cfg()->desc.bNumInterfaces) {\n        return false;\n    }\n\n    /* Iterate through the descriptors */\n    desc = (uint8_t *)usb_d_get_cfg();\n    desc_len = ((usb_conf_desc_t *)desc)->wTotalLength;\n    desc += desc_len;\n    while (desc_len) {\n        /* Check for interface descriptor */\n        if ((desc[1] == USB_DT_INTERFACE) && (desc_len >= USB_DT_INTERFACE_SIZE)) {\n            iface_desc = desc;\n            iface_desc_num = desc[2];\n            iface_desc_setting_num = desc[3];\n        }\n        /* Check for end of configuration descriptor */\n        if (desc[0] == USB_DT_CONFIG) {\n            break;\n        }\n        /* Check for end of descriptor list */\n        if (desc_len < 2) {\n            break;\n        }\n        /* Get the next descriptor */\n        desc_len = desc[0];\n        desc += desc_len;\n    }\n\n    /* Check for matching interface descriptor */\n    if ((iface_desc != NULL) && (iface_desc_num == iface_num) && (iface_desc_setting_num == setting_num)) {\n        return true;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 40.714415694246696}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void)    if (req.wLength != 2) {\n        return false;\n    }\n    uint8_t ep_num = req.wIndex & 0x7f;\n    uint8_t ep_status = 0;\n    if (udd_ep_is_halted(ep_num)) {\n        ep_status = 1;\n    }\n    udd_g_ctrlreq.payload[0] = ep_status;\n    udd_g_ctrlreq.payload[1] = 0;\n    udd_g_ctrlreq.req.wLength = 2;\n    return true;\n}\n", "CodeBleu_score": 44.74072651661958}, {"code": "static bool udc_req_std_ep_get_status(void)\tuint8_t ep_num;\n\tuint8_t status;\n\n\tif (udd_g_ctrlreq.req.wLength != 2) {\n\t\treturn false;\n\t}\n\n\tep_num = udd_g_ctrlreq.req.wIndex & 0x0F;\n\tif (ep_num == 0) {\n\t\tstatus = 0;\n\t} else {\n\t\tif (Is_udd_endpoint_stall_requested(ep_num)) {\n\t\t\tstatus = 1;\n\t\t} else {\n\t\t\tstatus = 0;\n\t\t}\n\t}\n\tudd_g_ctrlreq.payload[0] = status;\n\tudd_g_ctrlreq.payload[1] = 0;\n\tudd_g_ctrlreq.payload_size = 2;\n\treturn true;\n}\n", "CodeBleu_score": 36.478783720890924}, {"code": "static bool udc_req_std_ep_get_status(void)\tif (udd_g_ctrlreq.req.wLength != 2) {\n\t\treturn false;\n\t}\n\tuint8_t ep_num = udd_g_ctrlreq.req.wIndex & 0x7F;\n\tuint8_t ep_status = 0;\n\tif (ep_num != 0) {\n\t\tif (Is_udd_endpoint_stall_requested(ep_num)) {\n\t\t\tep_status = 1;\n\t\t}\n\t}\n\tudd_g_ctrlreq.payload[0] = ep_status;\n\tudd_g_ctrlreq.payload[1] = 0;\n\tudd_g_ctrlreq.payload_size = 2;\n\treturn true;\n}\n", "CodeBleu_score": 37.67953602476599}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void)\tuint8_t bmRequestType;\n\tuint8_t bRequest;\n\tuint8_t bDescriptorType;\n\tuint8_t bInterface;\n\tuint8_t bAlternate;\n\tuint8_t bNumInterfaces;\n\tuint8_t bNumEndpoints;\n\tuint8_t bLength;\n\tuint16_t wTotalLength;\n\tuint16_t wTotalLengthCurr;\n\tuint16_t wLength;\n\tuint16_t wValue;\n\tuint16_t wIndex;\n\tconst uint8_t *p_desc;\n\tuint8_t *p_buf;\n\tbool is_highspeed;\n\tudd_ep_id_t ep_control;\n\tudd_g_ctrlreq_t g_ctrlreq;\n\n\tbmRequestType = udd_g_ctrlreq.req.bmRequestType;\n\tbRequest = udd_g_ctrlreq.req.bRequest;\n\twValue = udd_g_ctrlreq.req.wValue;\n\twIndex = udd_g_ctrlreq.req.wIndex;\n\twLength = udd_g_ctrlreq.req.wLength;\n\n\t// Check if the requested interface is valid\n\tbNumInterfaces = udc_get_nb_interface();\n\tif (wIndex >= bNumInterfaces) {\n\t\treturn false; // No such interface\n\t}\n\n\t// Get current interface\n\tudc_interface_t *ptr_interface = udc_get_interface(wIndex);\n\n\t// Get current alternate setting\n\tudc_alt_setting_t *ptr_alt_setting = ptr_interface->alternate;\n\n\t// Get current endpoint\n\tudd_ep_id_t ep_num = ptr_alt_setting->endpoints[0];\n\tudd_ep_id_t ep_int_num = ptr_alt_setting->endpoints[1];\n\n\t// Fill control request fields\n\tg_ctrlreq.req.bmRequestType = bmRequestType;\n\tg_ctrlreq.req.bRequest = bRequest;\n\tg_ctrlreq.req", "CodeBleu_score": 41.40430785551115}, {"code": "static bool udc_req_iface(void)\tusb_iface_desc_t *iface_desc;\n\tuint8_t iface_num;\n\tuint8_t alt_setting;\n\tudd_ep_id_t ep;\n\tudd_ep_id_t ep_int;\n\tudd_g_ctrlreq_t *ctrlreq = &udd_g_ctrlreq;\n\tudd_ctrl_setup_payload_t *payload = ctrlreq->payload;\n\tudd_callback_set_interface_t callback_set_intf;\n\tudd_callback_set_interface_t callback_set_alt_intf;\n\tudd_callback_set_interface_t callback_set_def_alt_intf;\n\tbool callback_set_intf_done = false;\n\tbool callback_set_alt_intf_done = false;\n\tbool callback_set_def_alt_intf_done = false;\n\tbool b_callback_set_intf_error = false;\n\tbool b_callback_set_alt_intf_error = false;\n\tbool b_callback_set_def_alt_intf_error = false;\n\tbool b_error;\n\tbool b_req_supported;\n\tuint8_t i;\n\tuint8_t nb_ep;\n\n\tif (ctrlreq->req.wValue != 0) {\n\t\treturn false; // Already supported by udc_req_std_set_configuration()\n\t}\n\tiface_num = ctrlreq->req.wIndex & 0xFF;\n\talt_setting = ctrlreq->req.wValue & 0xFF;\n\tif (iface_num >= udc_nb_iface) {\n\t\treturn false;\n\t}\n\tiface_desc = udc_descriptor_iface[iface_num];\n\tif (iface_desc->bAlternateSetting != 0) {\n\t\t// Alternate setting already set\n\t\treturn false;\n\t}\n\t// Check if requested interface supported\n\tif (udc_nb_iface_supported == 0) {\n\t\t// All interfaces are supported", "CodeBleu_score": 35.89360653265044}, {"code": "static bool udc_req_iface(void)\tuint8_t iface_num;\n\tuint8_t iface_alt;\n\tuint8_t iface_pro;\n\tbool b_valid_request;\n\n\t// Check request\n\tif (g_scsi_ep_ms_in.iface != g_scsi_ep_ms_out.iface) {\n\t\treturn false;\n\t}\n\tiface_num = g_scsi_ep_ms_in.iface;\n\tiface_alt = g_scsi_ep_ms_in.alt;\n\tiface_pro = g_scsi_ep_ms_in.pro;\n\tb_valid_request = udc_validate_iface(iface_num);\n\tif (!b_valid_request) {\n\t\treturn false;\n\t}\n\tif (Is_udd_setup_clear_feature() && (USB_REQ_RECIPIENT_INTERFACE == udd_g_ctrlreq.req.bmRequestType)) {\n\t\tif (USB_REQ_FEATURE_DEVICE_REMOTE_WAKEUP == udd_g_ctrlreq.req.wValue) {\n\t\t\tudd_disable_remote_wake_up();\n\t\t\treturn true;\n\t\t}\n\t}\n\t// Update interface descriptor\n\tudc_update_iface_desc(iface_num, iface_alt, iface_pro);\n\t// Forward request to interface handler\n\treturn udc_ctrl_request_iface(iface_num);\n}\n", "CodeBleu_score": 45.19657394600355}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void)\tudi_msc_b_cbw_valid = false;\n\tudi_msc_b_sense_key = UDI_MSC_SENSE_KEY_NO_SENSE;\n\tudi_msc_b_sense_code = UDI_MSC_SC_OK;\n\tudi_msc_b_sense_qualif = UDI_MSC_ASC_NO_ADDITIONAL_SENSE;\n\tudi_msc_b_lun_state_sense = UDI_MSC_SENSE_KEY_NO_SENSE;\n\tudi_msc_b_lun_state_sense_asc = UDI_MSC_ASC_NO_ADDITIONAL_SENSE;\n\tudi_msc_b_lun_state_sense_ascq = UDI_MSC_ASCQ_NO_ADDITIONAL_SENSE;\n\tudi_msc_b_lun_state_ready = false;\n\tudi_msc_b_lun_state_protected = false;\n\tudi_msc_b_lun_state_persistent_prevent = false;\n\tudi_msc_b_lun_state_prevent = false;\n\tudi_msc_b_lun_state_eject = false;\n\tudi_msc_b_lun_state_media_changed = false;\n\tudi_msc_b_lun_state_media_present = false;\n\tudi_msc_b_lun_state_media_lock = false;\n\tudi_msc_b_lun_state_media_size = 0;\n\tudi_msc_b_lun_state_media_removable = false;\n\tudi_msc_b_lun_state_read_only = false;\n\tudi_msc_b_lun_state_write_protected = false;\n\tudi_msc_b_lun_state_removable = false;\n\tudi_msc_b_lun_state_trans_state = UDI_MSC_TRANS_IDLE;\n\tudi_msc_b_l", "CodeBleu_score": 34.2902844386333}, {"code": "bool udi_msc_enable(void)\tudi_msc_b_cbw_invalid_field = false;\n\tudi_msc_b_sense_key = SBC_SENSE_KEY_NO_SENSE;\n\tudi_msc_b_sense_code = SBC_SENSE_CODE_NONE;\n\tudi_msc_b_sense_qualifier = SBC_SENSE_CODE_NONE;\n\tudi_msc_b_unit_attention = false;\n\tudi_msc_b_lun_state_sense = false;\n\tudi_msc_b_lun_state_test_unit_ready = false;\n\tudi_msc_b_lun_state_request_sense = false;\n\tudi_msc_b_lun_state_prevent_removal = false;\n\tudi_msc_b_lun_state_read_capacity = false;\n\tudi_msc_b_lun_state_inquiry = false;\n\tudi_msc_b_lun_state_start_stop_unit = false;\n\tudi_msc_b_lun_state_mode_sense = false;\n\tudi_msc_b_lun_state_mode_sense_10 = false;\n\tudi_msc_b_lun_state_request_sense = false;\n\tudi_msc_b_lun_state_prevent_removal = false;\n\tudi_msc_b_lun_state_read_capacity = false;\n\tudi_msc_b_lun_state_inquiry = false;\n\tudi_msc_b_lun_state_start_stop_unit = false;\n\tudi_msc_b_lun_state_mode_sense = false;\n\tudi_msc_b_lun_state_mode_sense_10 = false;\n\tudi_msc_b_lun_state_read_10 = false;\n\tudi_msc_b_lun_state_write_10 = false;\n\tudi_msc_b_lun_state_", "CodeBleu_score": 30.205000609754272}, {"code": "bool udi_msc_enable(void)\t// Initialize internal values\n\tudi_msc_b_msc_enable = false;\n\tudi_msc_b_msc_addr_enabled = false;\n\tudi_msc_b_cbw_valid = false;\n\tudi_msc_b_sense_key = SBC_SENSE_KEY_NO_SENSE;\n\tudi_msc_b_sense_code = SBC_SENSE_CODE_NONE;\n\tudi_msc_b_sense_qualif = SBC_SENSE_QUALIFIER_NONE;\n\tudi_msc_b_unit_attention = false;\n\tudi_msc_b_state = UDI_MSC_IDLE;\n\tudi_msc_b_lun = 0;\n\tudi_msc_b_data_trans_direction = TRAFFIC_IDLE;\n\tudi_msc_b_trans_req_pending = false;\n\tudi_msc_b_trans_req_pending_more = false;\n\tudi_msc_b_trans_req_pending_direction = TRAFFIC_IDLE;\n\tudi_msc_b_stall_requested = false;\n\tudi_msc_b_stall_requested_more = false;\n\tudi_msc_b_stall_requested_direction = TRAFFIC_IDLE;\n\tudi_msc_b_cbw_status = UDI_MSC_CBW_STATUS_NONE;\n\tudi_msc_b_sbc_req_enable = false;\n\tudi_msc_b_sbc_state = UDI_MSC_SBC_STATE_IDLE;\n\tudi_msc_b_sbc_data_trans_direction = TRAFFIC_IDLE;\n\tudi_msc_b_sbc_trans_req_pending = false;\n\tudi_msc_b_sbc_trans_req_pending_more = false;\n\tudi_msc_b_sbc_trans_req_pending_direction = TRAFFIC_IDLE", "CodeBleu_score": 31.86641865488511}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)  UNUSED(nb_sent);\n  UNUSED(ep);\n  if (UDD_EP_TRANSFER_OK != status) {\n    // Abort on data error\n    udi_msc_cbw_invalid();\n    return;\n  }\n  // Update CSW\n  udi_msc_csw.dCSWDataResidue -= udi_msc_cbw.dCBWDataTransferLength;\n  udi_msc_csw.bCSWStatus = CSW_STATUS_PASSED;\n  udi_msc_process_csw();\n}\n", "CodeBleu_score": 57.992610820003435}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)    UNUSED(nb_sent);\n    UNUSED(ep);\n\n    if (UDD_EP_TRANSFER_OK != status) {\n        udi_msc_reset_all();\n        return;\n    }\n    // Transfer done\n    udi_msc_update_sense_data(MSC_SENSE_NO_SENSE);\n    udi_msc_cbw_process();\n}\n", "CodeBleu_score": 46.569259729975585}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tudi_msc_cbw_t *cbw;\n\tudi_msc_csw_t *csw;\n\tudi_msc_scsi_sense_t *sense;\n\tuint32_t request_length;\n\tuint32_t data_length;\n\tuint32_t length;\n\tuint8_t *ptr;\n\n\tif (UDD_EP_TRANSFER_OK != status) {\n\t\tudi_msc_reset_all();\n\t\treturn;\n\t}\n\t// Get sense data\n\tsense = udi_msc_sense_get();\n\t// Get cbw\n\tcbw = &udi_msc_cbw;\n\t// Get csw\n\tcsw = &udi_msc_csw;\n\t// Get data\n\tdata_length = udi_msc_data_trans_size;\n\trequest_length = udi_msc_data_request_size;\n\tptr = udi_msc_data_ptr;\n\t// Update sense data\n\tudi_msc_sense_update(sense, cbw->bCBWLUN,\n\t\t\tUDI_MSC_SCSI_SENSE_KEY_NO_SENSE,\n\t\t\tUDI_MSC_SCSI_ASC_NO_ADDITIONAL_SENSE_INFORMATION);\n\t// Update CSW\n\tcsw->dCSWDataResidue -= nb_sent;\n\tudi_msc_csw_process(csw, sense);\n\t// Update data pointer and data length\n\tlength = request_length - data_length;\n\tudi_msc_data_ptr += length;\n\tudi_msc_data_trans_size -= length;\n\tudi_msc_data_request_size -= length;\n}\n", "CodeBleu_score": 53.808248153207636}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void)\tudi_msc_cbw_t *cbw;\n\tudi_msc_csw_t *csw;\n\tiram_size_t residue;\n\tuint8_t status;\n\n\t// Get pointer on CBW\n\tcbw = &udi_msc_cbw;\n\t// Get pointer on CSW\n\tcsw = &udi_msc_csw;\n\n\t// Check if there is a data residue\n\tresidue = cbw->dDataLength;\n\tif (residue) {\n\t\t// Stall the next request on the appropriate endpoint\n\t\tif (cbw->bmFlags.dir) {\n\t\t\tudi_msc_stall_in();\n\t\t} else {\n\t\t\tudi_msc_stall_out();\n\t\t}\n\t}\n\n\t// Fill CSW\n\tcsw->dSignature = UDI_MSC_CSW_SIGNATURE;\n\tcsw->dTag = cbw->dTag;\n\tcsw->dDataResidue = cpu_to_le32(residue);\n\tstatus = udi_msc_scsi_status;\n\tif (udi_msc_b_read_enable) {\n\t\tudi_msc_b_read_enable = false;\n\t\tudi_msc_stall_in();\n\t}\n\tif (udi_msc_b_write_enable) {\n\t\tudi_msc_b_write_enable = false;\n\t\tudi_msc_stall_out();\n\t}\n\tif (udi_msc_b_cbw_invalid) {\n\t\tudi_msc_b_cbw_invalid = false;\n\t\tstatus = UDI_MSC_CSW_STATUS_PHASE_ERROR;\n\t}\n\tcsw->bStatus = status;\n\n\t// Send CSW\n\tudi_msc_csw_send();\n}\n", "CodeBleu_score": 39.66397785543377}, {"code": "static void udi_msc_csw_process(void)\t// Check if there is a data residue\n\tif (udi_msc_cbw.dDataLength) {\n\t\t// Stall the next request on the appropriate endpoint\n\t\tif (udi_msc_cbw.bmFlags.dir) {\n\t\t\t// Stall the IN endpoint\n\t\t\tudi_msc_stall_in();\n\t\t} else {\n\t\t\t// Stall the OUT endpoint\n\t\t\tudi_msc_stall_out();\n\t\t}\n\t}\n\t// Prepare the CSW\n\tudi_msc_csw.dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\tudi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;\n\tudi_msc_csw.bCSWStatus = udi_msc_cbw.bCBWLUN;\n\tudi_msc_csw.bCSWStatus |= udi_msc_csw_status;\n\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dDataLength;\n\tudi_msc_csw.bCSWStatus = cpu_to_le32(udi_msc_csw.bCSWStatus);\n\tudi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);\n\t// Send the CSW\n\tudi_msc_csw_send();\n}\n", "CodeBleu_score": 49.511043403073245}, {"code": "static void udi_msc_csw_process(void)\t// Check if the host wants to receive the CSW\n\tif (udi_msc_cbw_process.dCBWDataTransferLength == 0) {\n\t\t// Send the CSW\n\t\tudi_msc_csw_send();\n\t} else {\n\t\t// Stall the appropriate endpoint\n\t\tif (udi_msc_cbw_process.bmCBWFlags & USB_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_stall_in();\n\t\t} else {\n\t\t\tudi_msc_stall_out();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.809056671786095}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tuint8_t u8_i;\n\tuint8_t u8_nb_open_ports;\n\tbool b_1200_dtr_rate;\n\tbool b_all_ports_open;\n\n\t// Check that the DTR rate is 1200\n\tb_1200_dtr_rate = true;\n\tfor (u8_i = 0; u8_i < USB_DEVICE_MAX; u8_i++) {\n\t\tif (usb_device_get_dtr_rate(u8_i) != 1200) {\n\t\t\tb_1200_dtr_rate = false;\n\t\t}\n\t}\n\n\t// Check that all ports are open\n\tu8_nb_open_ports = 0;\n\tb_all_ports_open = true;\n\tfor (u8_i = 0; u8_i < USB_DEVICE_MAX; u8_i++) {\n\t\tif (usb_device_get_state(u8_i) == DEVICE_STATE_CONFIGURED) {\n\t\t\tu8_nb_open_ports++;\n\t\t}\n\t}\n\tif (u8_nb_open_ports != USB_DEVICE_MAX) {\n\t\tb_all_ports_open = false;\n\t}\n\n\t// Manage DTR\n\tif (b_1200_dtr_rate && b_all_ports_open && !b_enable) {\n\t\t// DTR rate is 1200 and all ports are open\n\t\t// DTR is disabled\n\t\t// Schedule a delayed reset\n\t\tinitiate_reset(RESET_MODE_RESET, 2000);\n\t} else {\n\t\t// Cancel any scheduled reset\n\t\tcancel_reset();\n\t}\n\n\t// Update DTR status\n\tusb_device_cdc_set_dtr(port, b_enable);\n}\n", "CodeBleu_score": 37.85438703625116}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\t// Update the DTR status\n\tusb_cdc_dtr_enabled[port] = b_enable;\n\n\t// Check if the DTR rate is 1200\n\tif (usb_cdc_dtr_rate[port] == 1200) {\n\t\t// If the DTR signal is disabled, schedule a delayed system reset\n\t\tif (!b_enable) {\n\t\t\t// Schedule a delayed system reset\n\t\t\tinitiateReset();\n\t\t}\n\t\t// If the DTR signal is enabled, cancel any scheduled reset\n\t\telse {\n\t\t\tcancelReset();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 25.898996785476257}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)  uint8_t i;\n  uint8_t cnt_dtr_on = 0;\n  uint8_t cnt_dtr_off = 0;\n  uint16_t cnt_loop = 0;\n  bool b_dtr_prev;\n  bool b_dtr_changed;\n\n  /* Set DTR */\n  udi_cdc_set_dtr(port, b_enable);\n\n  /* Scan port to check how many time the DTR state has changed */\n  b_dtr_prev = b_enable;\n  for (i = 0; i < USB_DEVICE_MAX_EP; i++) {\n    if (udi_cdc_is_dtr_enable(i)) {\n      cnt_dtr_on++;\n    } else {\n      cnt_dtr_off++;\n    }\n    if (udi_cdc_is_dtr_enable(i) != b_dtr_prev) {\n      cnt_loop++;\n      b_dtr_prev = udi_cdc_is_dtr_enable(i);\n    }\n  }\n  b_dtr_changed = (cnt_loop != (USB_DEVICE_MAX_EP - 1));\n\n  /* If cnt_dtr_on==1 and cnt_dtr_off==(USB_DEVICE_MAX_EP-1)\n   * and DTR has changed its state,\n   * then it means that we have enabled DTR on only one port\n   * and we disable it on all others ports.\n   * This is the signal to reset the device.\n   */\n  if (cnt_dtr_on == 1 && cnt_dtr_off == (USB_DEVICE_MAX_EP - 1)\n      && b_dtr_changed) {\n    /* Reset device */\n    rstc_start_software_reset(RSTC);\n    while (1);\n  }\n}\n", "CodeBleu_score": 29.98482199426702}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)    bool ret_val = false;\n\n    // Handle Microsoft-compatible ID requests\n    if ((g_usb_req.bmRequestType & USB_REQ_TYPE_TYPE_MASK) == USB_REQ_TYPE_VENDOR) {\n        switch (g_usb_req.bRequest) {\n            case 0x04:\n                // Return Microsoft-compatible ID descriptor\n                g_usb_req.pData = (uint8_t *) &usb_microsoft_compatible_id_descriptor;\n                g_usb_req.data_size = sizeof(usb_microsoft_compatible_id_descriptor);\n                ret_val = true;\n                break;\n            case 0x05:\n                // Return Microsoft-compatible extended properties descriptor\n                g_usb_req.pData = (uint8_t *) &usb_microsoft_extended_properties_descriptor;\n                g_usb_req.data_size = sizeof(usb_microsoft_extended_properties_descriptor);\n                ret_val = true;\n                break;\n            default:\n                break;\n        }\n    }\n\n    return ret_val;\n}", "CodeBleu_score": 31.03251914174224}, {"code": "bool usb_task_other_requests(void)    bool ret = false;\n    if (usb_setup.bmRequestType == 0xC0) {\n        if (usb_setup.wIndex == 0x04) {\n            usb_ep0_tx_data(usb_msft_compat_id_descriptor, sizeof(usb_msft_compat_id_descriptor), 0);\n            ret = true;\n        } else if (usb_setup.wIndex == 0x05) {\n            usb_ep0_tx_data(usb_ext_properties_descriptor, sizeof(usb_ext_properties_descriptor), 0);\n            ret = true;\n        }\n    }\n    return ret;\n}\n", "CodeBleu_score": 14.450402347584548}, {"code": "bool usb_task_other_requests(void)    bool ret_val = false;\n\n    if (USB_SetupRequest.bmRequestType.Type == USB_SETUP_REQUEST_TYPE_VENDOR) {\n        switch (USB_SetupRequest.bRequest) {\n            case USB_REQUEST_MS_GET_EXTENDED_PROPERTIES_OS:\n                if (USB_SetupRequest.wValue.W == 5) {\n                    USB_ControlRequest.Header.Size = sizeof(USB_Descriptor_Header_t) + USB_Descriptor_String_Size(USB_MS_OS_ExtendedProperties_Device_t);\n                    USB_ControlRequest.Header.Type  = DTYPE_String;\n                    USB_ControlRequest.Data          = (void*)&USB_MS_OS_ExtendedProperties_Device;\n\n                    ret_val = true;\n                }\n\n                break;\n            case USB_REQUEST_MS_GET_EXTENDED_PROPERTIES_DESCRIPTOR:\n                if (USB_SetupRequest.wValue.W == 6) {\n                    USB_ControlRequest.Header.Size = USB_Descriptor_String_Size(USB_MS_OS_ExtendedCompatibleID_Device_t);\n                    USB_ControlRequest.Header.Type  = DTYPE_String;\n                    USB_ControlRequest.Data          = (void*)&USB_MS_OS_ExtendedCompatibleID_Device;\n\n                    ret_val = true;\n                }\n\n                break;\n        }\n    }\n\n    return ret_val;\n}", "CodeBleu_score": 35.526746726535485}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tuint8_t i;\n\tif (nbyte == 0) return;\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tbuf[i] = spiRec();\n\t}\n\tbuf[i] = spiRecLast();\n}\n", "CodeBleu_score": 39.80776870601953}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)  if (nbyte == 0) return;\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    buf[i] = spiRec();\n  }\n  buf[nbyte - 1] = spiRecLast();\n}\n", "CodeBleu_score": 47.343850092894456}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tuint8_t i;\n\n\tif (nbyte == 0)\n\t\treturn;\n\n\tfor (i = 0; i < nbyte - 1; i++)\n\t\tbuf[i] = spiRec(0xFF);\n\n\tbuf[nbyte - 1] = spiRec(0x00);\n}\n", "CodeBleu_score": 43.52428558365877}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    pfnISR_Handler oldHandler;\n    uint32_t *vectorTable = (uint32_t *)SCB->VTOR;\n\n    // Disable global interrupts\n    __disable_irq();\n\n    // Get the current handler\n    oldHandler = (pfnISR_Handler)vectorTable[irq + 16];\n\n    // Set the new handler\n    vectorTable[irq + 16] = (uint32_t)newHandler;\n\n    // Enable global interrupts\n    __enable_irq();\n\n    // Return the old handler\n    return oldHandler;\n}\n", "CodeBleu_score": 57.26207882215388}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tpfnISR_Handler oldHandler;\n\tuint32_t *vectors = (uint32_t *)SCB->VTOR;\n\t\n\toldHandler = (pfnISR_Handler)vectors[irq + 16];\n\t\n\t__disable_irq();\n\tvectors[irq + 16] = (uint32_t)newHandler;\n\t__enable_irq();\n\t\n\treturn oldHandler;\n}\n", "CodeBleu_score": 57.36573515421003}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    pfnISR_Handler oldHandler = NULL;\n    uint32_t *pVector = (uint32_t *)SCB->VTOR;\n\n    /* Disable interrupts */\n    __disable_irq();\n\n    /* Get the address of the old handler */\n    oldHandler = (pfnISR_Handler)pVector[irq + 16];\n\n    /* Set the new handler */\n    pVector[irq + 16] = (uint32_t)newHandler;\n\n    /* Enable interrupts */\n    __enable_irq();\n\n    /* Return the old handler */\n    return oldHandler;\n}\n", "CodeBleu_score": 57.90150302833729}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek()  if (cdc_rx_buffer_head == cdc_rx_buffer_tail) return -1;\n  return cdc_rx_buffer[cdc_rx_buffer_tail];\n}\n", "CodeBleu_score": 15.454678958640567}, {"code": "int MarlinSerialUSB::peek()  if (cdc_rx_buffer_head != cdc_rx_buffer_tail) {\n    return cdc_rx_buffer[cdc_rx_buffer_tail];\n  }\n  return -1;\n}\n", "CodeBleu_score": 15.968071877836021}, {"code": "int MarlinSerialUSB::peek()  if (cdc_rx_buffer_head == cdc_rx_buffer_tail) return -1;\n  return cdc_rx_buffer[cdc_rx_buffer_tail];\n}\n", "CodeBleu_score": 15.454678958640567}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read()  int c;\n  if (pending()) {\n    c = _pending_char;\n    _pending_char = -1;\n  }\n  else {\n    if (!usb_configuration) return -1;\n    if (!cdc_rx_buffer_head) return -1;\n    c = cdc_rx_buffer[cdc_rx_buffer_tail];\n    cdc_rx_buffer_tail = (cdc_rx_buffer_tail + 1) % CDC_RX_BUFFER_SIZE;\n    if (cdc_rx_buffer_head == cdc_rx_buffer_tail) {\n      cdc_rx_buffer_head = 0;\n      cdc_rx_buffer_tail = 0;\n    }\n  }\n  return c;\n}\n", "CodeBleu_score": 44.90049903715072}, {"code": "int MarlinSerialUSB::read()  uint8_t c;\n\n  // If we have a character waiting in the buffer, then return it without checking for any others.\n  if (buffer_index >= 0) {\n    c = buffer[buffer_index];\n    buffer_index--;\n    return c;\n  }\n\n  // If we don't have a character waiting, then check if the interface is configured.\n  if (!usb_configuration) return -1;\n\n  // If we are still here, then we don't have a character waiting. In order to get into the while loop below, we have to\n  // have a character available.\n  while (!usb_serial_available()) { /* intentionally left empty */ }\n\n  // If we are still here, then a character is available.\n  c = usb_serial_getchar();\n\n  #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(c);\n  #endif\n\n  return c;\n}\n", "CodeBleu_score": 39.49672696650466}, {"code": "int MarlinSerialUSB::read()  uint8_t c;\n\n  // If we don't have a character waiting then wait\n  if (!_written) {\n    // If we have an active connection, wait for a character\n    if (cdc_rx_buffer_head != cdc_rx_buffer_tail) {\n      c = cdc_rx_buffer[cdc_rx_buffer_tail];\n      cdc_rx_buffer_tail = (cdc_rx_buffer_tail + 1) % CDC_RX_BUFFER_SIZE;\n      _written = true;\n    }\n    else {\n      // No active connection, return -1\n      return -1;\n    }\n  }\n  else {\n    // We have a character waiting, return it\n    c = _rx_buffer[_tail];\n    _tail = (_tail + 1) % RX_BUFFER_SIZE;\n    _written = false;\n  }\n\n  // If emergency_parser is enabled then compare for an emergency command\n  if (emergency_parser.enabled) emergency_parser.update(c);\n\n  return c;\n}\n", "CodeBleu_score": 40.756149426063324}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available()  if (pending_rx_length) return pending_rx_length;\n  return usb_cdc_available();\n}\n", "CodeBleu_score": 33.74732516999067}, {"code": "int MarlinSerialUSB::available()  uint32_t cnt;\n\n  if (pending_rx_count) return pending_rx_count;\n\n  if (!usb_configuration) return 0;\n\n  cnt = usb_cdc_rx_length();\n  if (cnt) {\n    pending_rx_count = cnt;\n    return cnt;\n  }\n  return 0;\n}\n", "CodeBleu_score": 42.347547780056594}, {"code": "int MarlinSerialUSB::available()  if (rx_buffer_head_ == rx_buffer_tail_) {\n    if (cdc_rx_ready()) return 0;\n    else return -1;\n  }\n  return (SERIAL_RX_BUFFER_SIZE + rx_buffer_head_ - rx_buffer_tail_) % SERIAL_RX_BUFFER_SIZE;\n}\n", "CodeBleu_score": 30.892868600161027}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)    uint8_t b;\n\n    while (size--) {\n        if (read_byte(pos, b)) return true;\n        if (writing) *value++ = b;\n        if (crc) *crc = crc16_byte(*crc, b);\n        pos++;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 51.76328742335903}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)    if (size == 0) {\n        return false;\n    }\n\n    uint8_t data;\n\n    for (size_t i = 0; i < size; i++) {\n        if (read_byte(pos, data)) {\n            if (writing) {\n                value[i] = data;\n            }\n            if (crc) {\n                *crc = _crc16_update(*crc, data);\n            }\n            pos++;\n        }\n        else {\n            return false;\n        }\n    }\n\n    return false;\n}\n", "CodeBleu_score": 44.35093898577846}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)    if (size == 0)\n        return false;\n\n    if (pos < 0 || pos >= _size)\n        return false;\n\n    if (size + pos > _size)\n        size = _size - pos;\n\n    if (writing) {\n        for (size_t i = 0; i < size; i++) {\n            value[i] = _buffer[pos + i];\n            *crc = crc16_update(*crc, value[i]);\n        }\n    } else {\n        for (size_t i = 0; i < size; i++) {\n            *crc = crc16_update(*crc, _buffer[pos + i]);\n        }\n    }\n\n    pos += size;\n    return false;\n}\n", "CodeBleu_score": 43.5614616627776}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  if (pin == 255) {\n    return;\n  }\n  if (freq == 0) {\n    freq = PWM_FREQUENCY;\n  }\n  if (res == 0) {\n    res = 8;\n  }\n\n  // Use hardware PWM if possible\n  if (ledcWrite(pin, value, res, freq)) {\n    return;\n  }\n\n  // Use software PWM if possible\n  if (pwm_alloc(pin, value, freq, res)) {\n    return;\n  }\n\n  // No PWM available for this pin\n  return;\n}\n", "CodeBleu_score": 21.627652479962567}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  //Serial.printf(\"analogWrite pin %d, value %d, freq %d, res %d\\n\", pin, value, freq, res);\n  if(pin < 0) return;\n  if(pin >= NUM_DIGITAL_PINS) return;\n  if(res > 16) res = 16;\n  if(res < 1) res = 1;\n  if(freq < 1) freq = 1;\n\n  // If pin is not already in use, allocate a new slot\n  if(pwm_slots[pin] == 0xFF) {\n    // Find a free slot\n    uint8_t slot = 0;\n    while(slot < PWM_SLOTS && pwm_slots[slot] != 0xFF) slot++;\n    if(slot == PWM_SLOTS) {\n      // No free slots\n      //Serial.printf(\"No free PWM slots\\n\");\n      return;\n    }\n    pwm_slots[pin] = slot;\n    //Serial.printf(\"Allocated slot %d for pin %d\\n\", slot, pin);\n    // Start timer if not already running\n    if(!pwm_running) {\n      pwm_running = true;\n      pwm_start();\n    }\n    // Increment used PWM count\n    pwm_used++;\n  }\n\n  // Set PWM value\n  uint8_t slot = pwm_slots[pin];\n  //Serial.printf(\"Setting slot %d for pin %d to %d\\n\", slot, pin, value);\n  pwm_values[slot] = value;\n  pwm_freqs[slot] = freq;\n  pwm_res[slot] = res;\n}\n", "CodeBleu_score": 40.899867192969836}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  if (pin == 255) return;\n  if (freq == 0) freq = PWM_FREQUENCY;\n  if (res == 0) res = 8;\n  if (res > 16) res = 16;\n  if (res < 1) res = 1;\n  if (freq > 500000) freq = 500000;\n  if (freq < 1) freq = 1;\n\n  if (pin == 255) return;\n  if (freq == 0) freq = PWM_FREQUENCY;\n  if (res == 0) res = 8;\n  if (res > 16) res = 16;\n  if (res < 1) res = 1;\n  if (freq > 500000) freq = 500000;\n  if (freq < 1) freq = 1;\n\n  if (pin == 255) return;\n  if (freq == 0) freq = PWM_FREQUENCY;\n  if (res == 0) res = 8;\n  if (res > 16) res = 16;\n  if (res < 1) res = 1;\n  if (freq > 500000) freq = 500000;\n  if (freq < 1) freq = 1;\n\n  if (pin == 255) return;\n  if (freq == 0) freq = PWM_FREQUENCY;\n  if (res == 0) res = 8;\n  if (res > 16) res = 16;\n  if (res < 1) res = 1;\n  if (freq > 500000) freq = 500000;\n  if (freq < 1) freq = 1;\n\n  if (pin == 255) return;\n  if (freq ==", "CodeBleu_score": 22.684810087902495}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value)  static_assert(sizeof(servo_delays) / sizeof(servo_delays[0]) == NUM_SERVOS, \"The length of the servo delay array must be equal to the number of servos.\");\n\n  if (attach(value)) {\n    write(value);\n    delay(servo_delays[servo_channel]);\n\n    #ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n      detach();\n    #endif\n  }\n}", "CodeBleu_score": 54.04848028705508}, {"code": "void Servo::move(const int value)    static_assert(sizeof(servoDelay) / sizeof(servoDelay[0]) == SERVO_CHANNELS, \"Servo delay array length does not match the number of servo channels\");\n\n    if (attach(SERVO_PIN)) {\n        write(value);\n\n        delay(servoDelay[channel]);\n\n        #ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n        detach();\n        #endif\n    }\n}\n", "CodeBleu_score": 52.58183247721261}, {"code": "void Servo::move(const int value)  static_assert(sizeof(servoDelay) / sizeof(servoDelay[0]) == SERVO_COUNT, \"The servoDelay array length must be equal to the SERVO_COUNT constant.\");\n\n  if (attach(0)) {\n    write(value);\n    delay(servoDelay[channel]);\n", "CodeBleu_score": 50.63632934949727}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample()  static uint32_t i2s_buffer[I2S_BUFFER_LENGTH];\n  static uint32_t i2s_buffer_pos;\n  static uint32_t i2s_buffer_len;\n  static uint32_t i2s_buffer_half;\n  static uint32_t i2s_buffer_quarter;\n  static uint32_t i2s_buffer_3quarter;\n\n  static uint32_t i2s_buffer_pin_counter;\n  static uint32_t i2s_buffer_pin_counter_max;\n\n  static uint32_t i2s_buffer_pin_mask;\n\n  static uint32_t i2s_buffer_pin_data;\n  static uint32_t i2s_buffer_pin_data_old;\n  static uint32_t i2s_buffer_pin_data_new;\n\n  static uint32_t i2s_buffer_pin_duty_cycle;\n  static uint32_t i2s_buffer_pin_duty_cycle_old;\n  static uint32_t i2s_buffer_pin_duty_cycle_new;\n\n  static uint32_t i2s_buffer_pin_duty_cycle_count;\n  static uint32_t i2s_buffer_pin_duty_cycle_count_old;\n  static uint32_t i2s_buffer_pin_duty_cycle_count_new;\n\n  static uint32_t i2s_buffer_pin_duty_cycle_count_max;\n\n  static uint32_t i2s_buffer_pin_duty_cycle_count_invert;\n\n  static uint32_t i2s_buffer_pin_duty_cycle_count_invert_old;\n  static uint32_t i2s_buffer_pin_duty_cycle_count_invert_new;\n\n  static uint32_t i2s_buffer_pin_duty_cycle_count_invert_", "CodeBleu_score": 3.998952480729998}, {"code": "void i2s_push_sample()    static uint32_t i2s_buffer_pos = 0;\n    static uint32_t i2s_buffer_pos_half = 0;\n    static uint32_t i2s_buffer_pos_quarter = 0;\n\n    static uint32_t i2s_buffer_pos_sample = 0;\n    static uint32_t i2s_buffer_pos_sample_half = 0;\n    static uint32_t i2s_buffer_pos_sample_quarter = 0;\n\n    static uint32_t i2s_buffer_pos_sample_eighth = 0;\n    static uint32_t i2s_buffer_pos_sample_sixteenth = 0;\n    static uint32_t i2s_buffer_pos_sample_thirtysecond = 0;\n\n    static uint32_t i2s_buffer_pos_sample_sixtyfourth = 0;\n    static uint32_t i2s_buffer_pos_sample_onetwentyeighth = 0;\n    static uint32_t i2s_buffer_pos_sample_twofiftysixth = 0;\n\n    static uint32_t i2s_buffer_pos_sample_fivetwelfth = 0;\n    static uint32_t i2s_buffer_pos_sample_seventytwo = 0;\n    static uint32_t i2s_buffer_pos_sample_onehundredfortyeighth = 0;\n\n    static uint32_t i2s_buffer_pos_sample_twohundredfiftysix = 0;\n    static uint32_t i2s_buffer_pos_sample_threehundredsixty = 0;\n    static uint32_t i2s_buffer_pos_sample_fourhundredeighty = 0;\n\n    static uint32_t i2s_buffer_pos_sample_fivehundredtwelve = 0;\n    static uint32_t i2s_buffer_pos_sample_sixhundredfourty = 0;", "CodeBleu_score": 3.9855182629988577}, {"code": "void i2s_push_sample()  static uint32_t i2s_buffer_pos = 0;\n  static uint32_t i2s_buffer_pos_half = 0;\n  static uint32_t i2s_buffer_pos_quarter = 0;\n  static uint32_t i2s_buffer_pos_eighth = 0;\n\n  uint32_t i2s_buffer_pos_temp;\n\n  for (uint8_t i = 0; i < 8; i++) {\n    if (pwm_active[i]) {\n      if (pwm_tick_count[i] == 0) {\n        if (pwm_pin_state[i]) {\n          pwm_pin_state[i] = 0;\n          pwm_tick_count[i] = pwm_off_count[i];\n          if (i < 4) {\n            i2s_buffer[i2s_buffer_pos] = i2s_buffer[i2s_buffer_pos] & ~(1 << i);\n          } else if (i < 6) {\n            i2s_buffer[i2s_buffer_pos] = i2s_buffer[i2s_buffer_pos] & ~(1 << (i - 4));\n          } else {\n            i2s_buffer[i2s_buffer_pos] = i2s_buffer[i2s_buffer_pos] & ~(1 << (i - 6));\n          }\n        } else {\n          pwm_pin_state[i] = 1;\n          pwm_tick_count[i] = pwm_on_count[i];\n          if (i < 4) {\n            i2s_buffer[i2s_buffer_pos] = i2s_buffer[i2s_buffer_pos] | (1 << i);\n          } else if (i < 6) {\n            i2s_buffer[i2s_buffer_pos] = i2s_buffer[i2s_buffer_pos] | (1 << (i - 4));\n          } else {", "CodeBleu_score": 36.17503953097997}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)    if (timer_num == 0) {\n        return TIMER0->TCNT;\n    } else if (timer_num == 1) {\n        return TIMER1->TCNT;\n    } else if (timer_num == 2) {\n        return TIMER2->TCNT;\n    } else if (timer_num == 3) {\n        return TIMER3->TCNT;\n    } else {\n        return 0;\n    }\n}\n", "CodeBleu_score": 19.864068225071772}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)    hal_timer_t count;\n\n    switch(timer_num) {\n        case 0:\n            count = TIMER0->TCNT;\n            break;\n        case 1:\n            count = TIMER1->TCNT;\n            break;\n        case 2:\n            count = TIMER2->TCNT;\n            break;\n        default:\n            count = 0;\n            break;\n    }\n\n    return count;\n}\n", "CodeBleu_score": 30.59891368995387}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)    hal_timer_t timer_count = 0;\n\n    if (timer_num < HAL_TIMER_NUM) {\n        timer_count = timer_config[timer_num].timer_count;\n    }\n\n    return timer_count;\n}\n", "CodeBleu_score": 38.45006384843701}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  for (uint16_t cnt = 0; cnt < size; cnt++) {\n    uint8_t c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *value = c;\n    crc16(c, crc);\n    value++;\n    pos++;\n  }\n  return false;\n}\n", "CodeBleu_score": 52.31453340553279}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  for (uint8_t c = 0; c < size; c++) {\n    uint8_t v = eeprom_read_byte((uint8_t*)pos);\n    pos++;\n    if (writing) *value = v;\n    value++;\n    if (crc) *crc = _PST_UPDATE_CRC(*crc, v);\n  }\n  return false;\n}\n", "CodeBleu_score": 49.72139995148142}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  if (pos < 0 || size <= 0) return false;\n  for (size_t i = 0; i < size; i++) {\n    uint8_t c = eeprom_read_byte((unsigned char*)pos);\n    if (writing) *value = c;\n    crc16(c, crc);\n    pos++;\n    value++;\n  }\n  return false;\n}\n", "CodeBleu_score": 60.89258792716809}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    if (sdioHandle == NULL || src == NULL) {\n        return false;\n    }\n\n    bool success = false;\n    for (int i = 0; i < WRITE_RETRIES; i++) {\n        if (HAL_SD_WriteBlocks(&sdioHandle, (uint8_t *)src, block, 1, 100) == HAL_OK) {\n            success = true;\n            break;\n        }\n    }\n\n    if (!success) {\n        printf(\"Error: SDIO_WriteBlock failed!\\n\");\n    }\n\n    return success;\n}\n", "CodeBleu_score": 38.58621060596848}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    if (sdioHandle == NULL || src == NULL) {\n        return false;\n    }\n\n    bool success = false;\n    for (int i = 0; i < SDIO_WRITE_RETRIES; i++) {\n        if (HAL_SD_WriteBlocks(&sdioHandle, (uint8_t *)src, block, 1, SDIO_TIMEOUT) == SD_OK) {\n            success = true;\n            break;\n        }\n    }\n\n    if (!success) {\n        printf(\"SDIO_WriteBlock: Failed to write block %lu\\n\", block);\n    }\n\n    return success;\n}\n", "CodeBleu_score": 39.90789003725044}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)\tif (!sdioHandle || !src) {\n\t\treturn false;\n\t}\n\n\tuint32_t retry = 0;\n\tbool success = false;\n\twhile (!success && retry < SD_MAX_RETRY) {\n\t\tsuccess = SD_WriteBlock(sdioHandle, block, (uint8_t *) src, SD_BLOCK_SIZE) == SD_OK;\n\t\tretry++;\n\t}\n\tif (!success) {\n\t\tprintf(\"SDIO_WriteBlock: Failed to write block %lu\\n\", block);\n\t}\n\treturn success;\n}\n", "CodeBleu_score": 33.724123522821564}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)  if (timer_num == TEMP_TIMER_NUM) {\n    #if ENABLED(HAL_STEP_TIMER)\n      TEMP_TIMER_ISR_INIT();\n    #else\n      TEMP_TIMER_ISR_INIT();\n    #endif\n  }\n  #if ENABLED(HAL_STEP_TIMER)\n    else if (timer_num == STEP_TIMER_NUM) {\n      STEP_TIMER_ISR_INIT();\n    }\n  #endif\n  else {\n    ASSERT_CHANNEL(timer_num);\n  }\n}\n", "CodeBleu_score": 38.011983032669015}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)  switch (timer_num) {\n    case TIMER_TEMP:\n      TIMER_SET_PRESCALE(TEMP_TIMER_NUM, TEMP_TIMER_PRESCALE);\n      TIMER_SET_FREQ(TEMP_TIMER_NUM, frequency);\n      TIMER_ENABLE_PWM(TEMP_TIMER_NUM);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 0);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 1);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 2);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 3);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 4);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 5);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 6);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 7);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 8);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 9);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 10);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 11);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 12);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_TIMER_NUM, 13);\n      TIMER_SET_PWM_CMP_VALUE(TEMP_T", "CodeBleu_score": 25.44624800266998}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)  switch (timer_num) {\n    case STEP_TIMER_NUM:\n      step_timer.start(frequency);\n      break;\n    case TEMP_TIMER_NUM:\n      temp_timer.start(frequency);\n      break;\n    default:\n      ASSERT(false);\n  }\n}\n", "CodeBleu_score": 16.907695389494982}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start()  if (file.open(filename, O_RDWR)) {\n    // File exists, read it\n    size_t bytes_read = file.read(buffer, buffer_size);\n    if (bytes_read < buffer_size) {\n      memset(buffer + bytes_read, EEPROM_DEFAULT_ERASE_VALUE, buffer_size - bytes_read);\n    }\n    file.close();\n    return true;\n  }\n  else {\n    // File does not exist, create it\n    file.create(filename, buffer_size);\n    file.close();\n    return false;\n  }\n}\n", "CodeBleu_score": 29.52983970621418}, {"code": "bool PersistentStore::access_start()  // open the file for reading and writing\n  file = fopen(filename, \"r+b\");\n  if (file == NULL) {\n    // the file could not be opened\n    return false;\n  }\n\n  // initialize the buffer\n  memset(buffer, EEPROM_DEFAULT_VALUE, EEPROM_SIZE);\n\n  // get the file size\n  fseek(file, 0, SEEK_END);\n  long file_size = ftell(file);\n  rewind(file);\n\n  // if the file is smaller than the expected EEPROM size,\n  // fill the remainder of the buffer with the default erase value\n  if (file_size < EEPROM_SIZE) {\n    // fill the end of the buffer with the default erase value\n    memset(buffer + file_size, EEPROM_DEFAULT_VALUE, EEPROM_SIZE - file_size);\n  } else {\n    // the file is the expected EEPROM size, so read its contents into the buffer\n    fread(buffer, 1, EEPROM_SIZE, file);\n  }\n\n  // close the file and return\n  fclose(file);\n  return true;\n}\n", "CodeBleu_score": 49.68077574775076}, {"code": "bool PersistentStore::access_start()  if (!access_file_open()) {\n    return false;\n  }\n  if (file_size < (int32_t)sizeof(store_data)) {\n    memset(&store_data, 0xFF, sizeof(store_data));\n  }\n  else {\n    file.seek(0);\n    file.read((uint8_t*)&store_data, sizeof(store_data));\n  }\n  file.close();\n  return true;\n}\n", "CodeBleu_score": 17.853089862718317}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t r = 0;\n\n    for (uint8_t i = 0; i < 8; i++) {\n        HAL_SPI_STM32_SpiWrite(b & 0x80);\n        r <<= 1;\n        r |= HAL_SPI_STM32_SpiRead();\n        b <<= 1;\n    }\n\n    HAL_SPI_STM32_DelayUs(5);\n\n    return r;\n}\n", "CodeBleu_score": 36.48176024082399}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)\tuint8_t r = 0;\n\tfor (int i = 0; i < 8; i++) {\n\t\tHAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(GPIOA, GPIO_PIN_7, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);\n\t\tif (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_6) == GPIO_PIN_SET) {\n\t\t\tr |= (1 << (7 - i));\n\t\t}\n\t\tb <<= 1;\n\t}\n\tHAL_Delay(1);\n\treturn r;\n}\n", "CodeBleu_score": 38.503827526303084}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t r = 0;\n    for (int i = 0; i < 8; i++) {\n        digitalWrite(SPI_CLK, LOW);\n        digitalWrite(SPI_MOSI, b & 0x80);\n        b <<= 1;\n        digitalWrite(SPI_CLK, HIGH);\n        if (digitalRead(SPI_MISO)) {\n            b |= 1;\n        }\n        r <<= 1;\n        r |= digitalRead(SPI_MISO);\n    }\n    digitalWrite(SPI_CLK, LOW);\n    delayMicroseconds(10);\n    return r;\n}\n", "CodeBleu_score": 52.00397140804487}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)    uint32_t tmpreg = 0x00;\n\n    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    /* Get the AHB peripheral clock enable register value */\n    tmpreg = RCC->AHBENR;\n\n    /* Enable or disable the AHB peripheral clock */\n    if (NewState != DISABLE) {\n        tmpreg |= RCC_AHBPeriph;\n    } else {\n        tmpreg &= ~RCC_AHBPeriph;\n    }\n\n    /* Store the new value */\n    RCC->AHBENR = tmpreg;\n}\n", "CodeBleu_score": 67.84243723251593}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)    uint32_t tmpregister = 0x00;\n    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n    /* Get the AHB peripheral clock enable register value */\n    tmpregister = RCC->AHBENR;\n    /* Enable or disable the AHB peripheral clock */\n    if (NewState != DISABLE) {\n        tmpregister |= RCC_AHBPeriph;\n    } else {\n        tmpregister &= ~RCC_AHBPeriph;\n    }\n    /* Store the new value */\n    RCC->AHBENR = tmpregister;\n}\n", "CodeBleu_score": 66.57494866971707}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\t/* Check the parameters */\n\tassert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n\tassert_param(IS_FUNCTIONAL_STATE(NewState));\n\tif (NewState != DISABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 80.59593798820907}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  // Read byte\n  uint8_t b = obj->uart->DR;\n\n  // If RX buffer full, set the overflow flag and return\n  unsigned char i = (unsigned int)(obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n  if (i != obj->rx_tail) {\n    obj->rx_buffer[obj->rx_head] = b;\n    obj->rx_head = i;\n  }\n  else {\n    obj->rx_overflow = true;\n  }\n}\n", "CodeBleu_score": 58.22375137829848}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  if (obj->rx_buff.buffer == NULL) return;\n  if (obj->rx_buff.pos == obj->rx_buff.length) return;\n  if (obj->rx_buff.pos >= (obj->rx_buff.length - 1)) return;\n\n  uint8_t c;\n  c = obj->serial.read();\n\n  if (obj->serial.parityError()) {\n    obj->serial.clearParityError();\n    return;\n  }\n\n  obj->rx_buff.buffer[obj->rx_buff.pos] = c;\n  obj->rx_buff.pos++;\n\n  if (obj->rx_buff.pos == obj->rx_buff.length) {\n    obj->rx_buff.pos = 0;\n  }\n}\n", "CodeBleu_score": 32.0762466958807}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  // No Parity error, read byte and store it in the ring buffer if there is space\n  unsigned char c;\n  if (obj->uart == UART_1)\n    c = LL_USART_ReceiveData8(UART_1);\n  else\n    c = LL_USART_ReceiveData8(UART_2);\n\n  if (ring_buffer_is_full(&rx_buffer)) {\n    // When the software buffer is full, we have no choice but to drop bytes\n    // TODO: We could implement a means to signal the host program that bytes are being dropped.\n    rx_buffer_overrun = true;\n  }\n  else {\n    ring_buffer_queue(&rx_buffer, c);\n  }\n\n  // Update the next pointer\n  rx_buffer.tail = (rx_buffer.tail + 1) % SERIAL_RX_BUFFER_SIZE;\n\n  // If the emergency parser is enabled, update its state\n  if (emergency_parser.enabled)\n    emergency_parser.update(c);\n}\n", "CodeBleu_score": 38.699751195730514}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)  switch (timer_num) {\n    case MF_TIMER_STEP:\n      if (step_timer_is_init && !step_timer_is_interrupt_attached) {\n        step_timer_is_interrupt_attached = true;\n        attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, RISING);\n      }\n      break;\n    case MF_TIMER_TEMP:\n      if (temp_timer_is_init && !temp_timer_is_interrupt_attached) {\n        temp_timer_is_interrupt_attached = true;\n        attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, RISING);\n      }\n      break;\n  }\n}\n", "CodeBleu_score": 38.48111384028397}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)  if (timer_num == MF_TIMER_STEP) {\n    if (step_timer.is_initialized && step_timer.has_interrupt == false) {\n      step_timer.has_interrupt = true;\n      HAL_timer_attach_interrupt(timer_num, &Step_Handler);\n    }\n  }\n  else if (timer_num == MF_TIMER_TEMP) {\n    if (temp_timer.is_initialized && temp_timer.has_interrupt == false) {\n      temp_timer.has_interrupt = true;\n      HAL_timer_attach_interrupt(timer_num, &Temp_Handler);\n    }\n  }\n}\n", "CodeBleu_score": 39.334398932049794}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)  if (timer_num == MF_TIMER_STEP) {\n    if (step_timer_is_init && !step_timer_has_interrupt) {\n      step_timer_has_interrupt = true;\n      attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, RISING);\n    }\n  } else if (timer_num == MF_TIMER_TEMP) {\n    if (temp_timer_is_init && !temp_timer_has_interrupt) {\n      temp_timer_has_interrupt = true;\n      attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, RISING);\n    }\n  }\n}\n", "CodeBleu_score": 32.857776344790835}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\tsepLen := len(sep)\n\tsepHash := hash(sep)\n\tsHash := hash(s[len(s)-sepLen:])\n\tif sHash == sepHash && bytes.Equal(s[len(s)-sepLen:], sep) {\n\t\treturn len(s) - sepLen\n\t}\n\tfor i := len(s) - sepLen - 1; i >= 0; i-- {\n\t\tsHash = (sHash*256 + uint64(s[i])) - (uint64(s[i+sepLen]) * pow256[sepLen-1])\n\t\tif sHash == sepHash && bytes.Equal(s[i:i+sepLen], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 44.076087353810465}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tsepLen := len(sep)\n\tif sepLen == 0 {\n\t\treturn 0\n\t}\n\tsepHash := hash(sep)\n\n\tsLen := len(s)\n\tsHash := hash(s[sLen-sepLen:])\n\n\tif sepHash == sHash && s[sLen-sepLen:] == sep {\n\t\treturn sLen - sepLen\n\t}\n\n\tfor i := 0; i < sLen-sepLen; i++ {\n\t\tsHash = (sHash*primeRK + s[i]) % modulusRK\n\t\tsHash -= hash(s[i:i+sepLen-1]) * primeRK\n\t\tsHash *= primeRK\n\t\tsHash += s[i+sepLen]\n\t\tif sHash == sepHash && s[i:i+sepLen] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}", "CodeBleu_score": 38.21375056507782}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tif len(sep) == 0 {\n\t\treturn 0\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\t// Rabin-Karp search\n\thashsep, pow := hashStr(sep)\n\tn := len(s)\n\tvar h uint32\n\tfor i := 0; i < len(sep); i++ {\n\t\th = h*primeRK + uint32(s[n-1-i])\n\t}\n\tif h == hashsep && Equal(s[n-len(sep):], sep) {\n\t\treturn n - len(sep)\n\t}\n\tfor i := n - len(sep) - 1; i >= 0; i-- {\n\t\th *= primeRK\n\t\th += uint32(s[i])\n\t\th -= pow * uint32(s[i+len(sep)])\n\t\tif h == hashsep && Equal(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 52.27020843843633}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush()\t// Disable interrupts\n\toldValue := DisableInterrupts()\n\t// Check if there is data in the transmit buffer\n\tif usbcdc.txHead != usbcdc.txTail {\n\t\t// Send the data to the USB endpoint\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\t// No data available, set \"waitTxc\" to false\n\t\tusbcdc.waitTxc = false\n\t}\n\t// Restore the interrupt mask\n\tEnableInterrupts(oldValue)\n}\n", "CodeBleu_score": 40.55184715165984}, {"code": "func (usbcdc *USBCDC) Flush()\tif !usbcdc.waitTxc {\n\t\treturn\n\t}\n\t// disable interrupts\n\tatomic.Store(usbcdc.txc, 0)\n\tif usbcdc.tx.Len() > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\t// restore interrupts\n\tatomic.Store(usbcdc.txc, 1)\n}\n", "CodeBleu_score": 53.49861753008349}, {"code": "func (usbcdc *USBCDC) Flush()\tatomic.DisableIRQ()\n\tif len(usbcdc.txBuf) > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tatomic.EnableIRQ()\n}\n", "CodeBleu_score": 31.73224239688536}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.CTRL.Set(0)\n\ti2c.CTRL.SetBits(I2C_CTRL_EN)\n\ti2c.CTRL.SetBits(I2C_CTRL_START)\n\tfor !i2c.CTRL.HasBits(I2C_CTRL_IF) {\n\t}\n\ti2c.CTRL.SetBits(I2C_CTRL_CLR_FIFO)\n\tif write {\n\t\ti2c.TXDATA.Set(address << 1)\n\t} else {\n\t\ti2c.TXDATA.Set((address << 1) | 1)\n\t}\n\ti2c.CTRL.SetBits(I2C_CTRL_READ)\n\tfor !i2c.CTRL.HasBits(I2C_CTRL_IF) {\n\t}\n\ti2c.CTRL.SetBits(I2C_CTRL_CLR_FIFO)\n}\n", "CodeBleu_score": 33.567500783424016}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.Bus.Control.Set(I2C_CTRL_SEND_START)\n\tfor !i2c.Bus.Control.HasBits(I2C_CTRL_IF) {\n\t}\n\ti2c.Bus.Control.Set(I2C_CTRL_IF)\n\ti2c.Bus.Address.Set(address << 1)\n\tif !write {\n\t\ti2c.Bus.Address.SetBits(I2C_ADDR_READ)\n\t}\n\ti2c.Bus.Control.Set(I2C_CTRL_SEND_ADR_RW)\n\tfor !i2c.Bus.Control.HasBits(I2C_CTRL_IF) {\n\t}\n\ti2c.Bus.Control.Set(I2C_CTRL_IF)\n}\n", "CodeBleu_score": 33.13354131742819}, {"code": "func (i2c *I2C) start(address uint8, write bool)\t// Clear interrupt flag\n\ti2c.CTRL.Set(I2C_CTRL_IF)\n\n\t// Set start condition\n\ti2c.CTRL.Set(I2C_CTRL_START)\n\n\t// Enable I2C module\n\ti2c.CTRL.Set(I2C_CTRL_EN)\n\n\t// Wait for start condition to be transmitted\n\tfor !i2c.CTRL.HasBits(I2C_CTRL_IF) {\n\t}\n\n\t// Clear interrupt flag\n\ti2c.CTRL.Set(I2C_CTRL_IF)\n\n\t// Write address\n\ti2c.TXDATA.Set(address << 1)\n\n\t// Wait for address to be transmitted\n\tfor !i2c.CTRL.HasBits(I2C_CTRL_IF) {\n\t}\n\n\t// Clear interrupt flag\n\ti2c.CTRL.Set(I2C_CTRL_IF)\n\n\t// Set read flag if needed\n\tif !write {\n\t\ti2c.CTRL.Set(I2C_CTRL_READ)\n\t}\n}\n", "CodeBleu_score": 31.705538308057967}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\t// Check that the block number and length are valid.\n\tif start < 0 || len < 1 {\n\t\treturn ErrInvalidArgument\n\t}\n\n\t// Calculate the start address.\n\taddr := start * int64(f.blockSize)\n\n\t// Check that the start address is valid.\n\tif addr >= f.size {\n\t\treturn ErrInvalidArgument\n\t}\n\n\t// Check that the end address is valid.\n\tif addr+int64(len*f.blockSize) > f.size {\n\t\treturn ErrInvalidArgument\n\t}\n\n\t// Wait for any ongoing flash operations to complete.\n\tf.Wait()\n\n\t// Configure the flash for erasing.\n\tf.flash.CR.SetBits(stm32.FLASH_CR_PER)\n\n\t// Loop over the blocks to erase.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Calculate the address of the block to erase.\n\t\taddr = start*int64(f.blockSize) + i*int64(f.blockSize)\n\n\t\t// Erase the block.\n\t\tf.flash.CR.SetBits(stm32.FLASH_CR_STRT)\n\n\t\t// Wait for the flash to complete.\n\t\tf.Wait()\n\t}\n\n\t// Set the flash back to read mode.\n\tf.flash.CR.ClearBits(stm32.FLASH_CR_PER)\n\n\treturn nil\n}\n", "CodeBleu_score": 37.35506731242765}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tif start+len > f.numBlocks {\n\t\treturn errors.New(\"flash: erase out of range\")\n\t}\n\n\t// Calculate start address based on block number and block size\n\tstartAddr := uint32(start * f.blockSize)\n\tendAddr := uint32((start + len) * f.blockSize)\n\n\t// Wait for any ongoing flash operations to complete\n\tfor flash.SR.HasBits(flash.SR_BSY) {\n\t}\n\n\t// Enable flash erase\n\tflash.CR.SetBits(flash.CR_SERASE)\n\n\t// Loop through all blocks to be erased\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\t// Set address to erase\n\t\tflash.AR.Set(addr)\n\n\t\t// Start erase operation\n\t\tflash.CR.Set(flash.CR_STRT)\n\n\t\t// Wait for erase to complete\n\t\tfor flash.SR.HasBits(flash.SR_BSY) {\n\t\t}\n\t}\n\n\t// Disable flash erase\n\tflash.CR.ClearBits(flash.CR_SERASE)\n\n\t// Return to read mode\n\tflash.CR.ClearBits(flash.CR_PG)\n\n\treturn nil\n}", "CodeBleu_score": 33.649553476703495}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tif start < 0 || start >= f.BlockCount {\n\t\treturn flash.ErrInvalidAddr\n\t}\n\tif len < 0 || len > f.BlockCount-start {\n\t\treturn flash.ErrInvalidAddr\n\t}\n\tstartAddr := f.BaseAddr + uint32(start)*f.BlockSize\n\tendAddr := startAddr + uint32(len)*f.BlockSize\n\tif endAddr > f.BaseAddr+f.Size {\n\t\treturn flash.ErrInvalidAddr\n\t}\n\t// wait for any ongoing operations to complete\n\tf.WaitReady()\n\t// set the flash to erase mode\n\tf.SetEraseMode()\n\t// loop through the blocks\n\tfor addr := startAddr; addr < endAddr; addr += f.BlockSize {\n\t\t// erase the block\n\t\tf.Erase(addr)\n\t\t// wait for the erase to complete\n\t\tf.WaitReady()\n\t}\n\t// set the flash back to read mode\n\tf.SetReadMode()\n\treturn nil\n}", "CodeBleu_score": 38.00685589982514}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\t// Check if the write operation exceeds the flash memory bounds.\n\tif off > f.size {\n\t\treturn 0, fmt.Errorf(\"write out of bounds: offset=%d, size=%d\", off, f.size)\n\t}\n\n\t// Calculate the start address for writing.\n\taddr := f.base + uintptr(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tpadded := make([]byte, len(p))\n\tcopy(padded, p)\n\tfor i := len(p); i < len(padded); i++ {\n\t\tpadded[i] = 0xFF\n\t}\n\n\t// Enable write mode on the flash memory controller.\n\tf.flash.CR.SetBits(stm32.FLASH_CR_PG)\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(padded); i += f.blockSize {\n\t\t// Write the block.\n\t\terr = f.flash.Program(uintptr(unsafe.Pointer(addr+uintptr(i))), padded[i:i+f.blockSize])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\t// Wait for the flash memory to be ready.\n\t\terr = f.flash.Wait()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 34.61880371347955}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 || len(p) < 0 || int(off)+len(p) > f.Size() {\n\t\treturn 0, errors.New(\"flash: write operation out of bounds\")\n\t}\n\n\t// Calculate start address for writing\n\taddr := f.start + uint32(off)\n\n\t// Pad the data to fit the write block size\n\tpaddedData := make([]byte, len(p))\n\tcopy(paddedData, p)\n\tpaddedData = padData(paddedData, f.writeBlockSize)\n\n\t// Enable write mode\n\tf.flash.EnableWrite()\n\n\t// Write data in blocks\n\tfor i := 0; i < len(paddedData); i += f.writeBlockSize {\n\t\tif err := f.flash.Write(addr+uint32(i), paddedData[i:i+f.writeBlockSize]); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif err := f.flash.WaitForCompletion(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\treturn len(p), nil\n}", "CodeBleu_score": 31.684260391633668}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off > f.size {\n\t\treturn 0, errors.New(\"flash: write offset exceeds flash memory bounds\")\n\t}\n\tif off+int64(len(p)) > f.size {\n\t\treturn 0, errors.New(\"flash: write exceeds flash memory bounds\")\n\t}\n\tstartAddr := uint32(f.addr + off)\n\tif len(p)%f.blockSize != 0 {\n\t\tp = append(p, make([]byte, f.blockSize-len(p)%f.blockSize)...)\n\t}\n\tf.flash.EnableWrite()\n\tfor i := 0; i < len(p); i += f.blockSize {\n\t\tf.flash.WriteBlock(startAddr+uint32(i), p[i:i+f.blockSize])\n\t\tf.flash.WaitReady()\n\t}\n\tf.flash.DisableWrite()\n\treturn len(p), nil\n}", "CodeBleu_score": 32.72699136511979}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"Failed to duplicate file descriptor\", err\n\t}\n\n\t// Attempt to open the directory.\n\tfor {\n\t\tdirPtr, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dirPtr), \"\", nil\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"Failed to open directory\", err\n\t\t}\n\t}\n}", "CodeBleu_score": 56.281076925336784}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tvar err error\n\tvar dirPtr uintptr\n\tvar errno syscall.Errno\n\tvar dir *syscall.Dirent\n\n\t// Duplicate the file descriptor\n\tfd, err = dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\t// Open the directory\n\tfor {\n\t\tdirPtr, errno = syscall.Fdopendir(int(fd))\n\t\tif errno == 0 {\n\t\t\tbreak\n\t\t} else if errno != syscall.EINTR {\n\t\t\terr = errno\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the file descriptor\n\tif err != nil {\n\t\tif errno = syscall.Close(int(fd)); errno != 0 {\n\t\t\treturn 0, \"\", errno\n\t\t}\n\t}\n\n\treturn dirPtr, \"\", err\n}\n", "CodeBleu_score": 46.59815441929346}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor\n\tnewFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"Could not duplicate file descriptor\", err\n\t}\n\n\t// Attempt to open the directory file descriptor\n\tvar dirPtr uintptr\n\tfor {\n\t\tdirPtr, err = syscall.Fdopendir(newFd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If there was an error, close the duplicated file descriptor and return the error\n\tif err != nil {\n\t\tsyscall.Close(newFd)\n\t\treturn 0, \"Could not open directory file descriptor\", err\n\t}\n\n\treturn dirPtr, \"\", nil\n}\n", "CodeBleu_score": 71.46346715147511}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response)  uint32_t size = 0;\n  const esp_partition_t *running = esp_ota_get_running_partition();\n  esp_image_metadata_t data;\n  esp_err_t err = esp_image_verify(running, ESP_IMAGE_VERIFY, &data);\n  if (err != ESP_OK) {\n    ESP_LOGE(TAG, \"Failed to get image metadata (%s)\", esp_err_to_name(err));\n    return 0;\n  }\n  if (response == sketchSize) {\n    size = data.image_len;\n  } else {\n    size = running->size - data.image_len;\n  }\n  return size;\n}\n", "CodeBleu_score": 52.8146970278906}, {"code": "static uint32_t sketchSize(sketchSize_t response)\n    const esp_partition_t *running = esp_ota_get_running_partition();\n    esp_image_header_t header;\n    esp_image_metadata_t data;\n    const esp_partition_pos_t partition = {\n        .offset = running->address,\n        .size = running->size,\n    };\n\n    if (esp_image_load_header(running, true, &header) != ESP_OK) {\n        return 0;\n    }\n\n    if (esp_image_verify(ESP_IMAGE_VERIFY, &partition, &header) != ESP_OK) {\n        return 0;\n    }\n\n    if (esp_image_get_metadata(running, &data) != ESP_OK) {\n        return 0;\n    }\n\n    return response == sketchSize_t::free ? data.image_len : running->size;\n}\n", "CodeBleu_score": 61.68260998972039}, {"code": "static uint32_t sketchSize(sketchSize_t response)  const esp_partition_t* partition = esp_ota_get_running_partition();\n  esp_image_header_t header;\n  esp_image_metadata_t data;\n  const esp_partition_pos_t partition_pos = {\n    .offset = partition->address,\n    .size = partition->size,\n  };\n  esp_err_t err = esp_image_verify(ESP_IMAGE_VERIFY, &partition_pos, &header, &data);\n  if (err != ESP_OK) {\n    return 0;\n  }\n  return response == SKETCH_SIZE ? data.image_len : data.image_len - data.image_len;\n}\n", "CodeBleu_score": 55.28657124969912}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)    uint32_t total_sectors;\n    uint32_t sectors_per_cluster;\n    uint32_t reserved_sectors;\n    uint32_t fat_sectors;\n    uint32_t root_directory_sectors;\n    uint32_t total_data_sectors;\n    uint32_t total_clusters;\n    uint32_t sectors_per_fat;\n    uint32_t sectors_per_track;\n    uint32_t heads;\n    uint32_t hidden_sectors;\n    uint32_t fat_type;\n    uint32_t fat_size;\n    uint32_t root_dir_sectors;\n    uint32_t root_entries;\n    uint32_t data_sectors;\n    uint32_t total_fat_sectors;\n    uint32_t sectors_per_fat_32;\n    uint32_t fat_offset;\n    uint32_t total_fat_size;\n    uint32_t root_dir_offset;\n    uint32_t data_offset;\n    uint32_t total_disk_size;\n    uint32_t i;\n    uint8_t *p_buffer;\n    uint8_t *p_sector;\n    uint8_t *p_fat;\n    uint8_t *p_fat_end;\n    uint8_t *p_root_dir;\n    uint8_t *p_root_dir_end;\n    uint8_t *p_data;\n    uint8_t *p_data_end;\n    uint8_t *p_file_name;\n    uint8_t *p_file_extension;\n    uint8_t *p_file_name_end;\n    uint8_t *p_file_extension_end;\n    uint8_t *p_file_data;\n    uint8_t *p_file_data_end;\n    uint8_t *p_file_data_ptr;\n    uint8_t *p_", "CodeBleu_score": 9.418513164437762}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)    uint32_t i;\n    uint8_t *disk_ptr;\n    uint32_t disk_sectors;\n    uint32_t fat_sectors;\n    uint32_t root_sectors;\n    uint32_t data_sectors;\n    uint32_t total_sectors;\n    uint32_t bytes_per_sector;\n    uint32_t bytes_per_cluster;\n    uint32_t reserved_sectors;\n    uint32_t root_dir_sectors;\n    uint32_t fat_type;\n    uint32_t sectors_per_fat;\n    uint32_t sectors_per_track;\n    uint32_t heads;\n    uint32_t hidden_sectors;\n    uint32_t total_sectors_l;\n    uint32_t total_sectors_h;\n    uint32_t signature;\n    uint32_t file_size;\n    uint32_t file_first_cluster;\n    uint32_t fat_offset;\n    uint32_t root_offset;\n    uint32_t data_offset;\n    uint32_t data_offset_cluster;\n    uint32_t root_entry_offset;\n    uint32_t fat_entry_offset;\n    uint32_t fat_entry_value;\n    uint8_t *fat_ptr;\n    uint8_t *root_ptr;\n    uint8_t *data_ptr;\n    uint8_t *file_ptr;\n    uint8_t *ptr;\n    uint8_t *ptr_end;\n    uint8_t *ptr_data;\n    uint8_t *ptr_data_end;\n    uint8_t *ptr_file;\n    uint8_t *ptr_file_end;\n    uint8_t *ptr_file_data;\n    uint8_t *ptr_file_data_end;\n    uint8_t *ptr_file_name;\n    uint8_t *ptr_file_ext;\n    uint8_t", "CodeBleu_score": 9.068876846181213}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)    uint32_t num_sectors = 0;\n    uint8_t *disk_ptr = NULL;\n    uint32_t i = 0;\n    uint32_t j = 0;\n    uint32_t k = 0;\n    uint32_t l = 0;\n    uint32_t m = 0;\n    uint32_t n = 0;\n    uint32_t o = 0;\n    uint32_t p = 0;\n    uint32_t q = 0;\n    uint32_t r = 0;\n    uint32_t s = 0;\n    uint32_t t = 0;\n    uint32_t u = 0;\n    uint32_t v = 0;\n    uint32_t w = 0;\n    uint32_t x = 0;\n    uint32_t y = 0;\n    uint32_t z = 0;\n    uint32_t aa = 0;\n    uint32_t ab = 0;\n    uint32_t ac = 0;\n    uint32_t ad = 0;\n    uint32_t ae = 0;\n    uint32_t af = 0;\n    uint32_t ag = 0;\n    uint32_t ah = 0;\n    uint32_t ai = 0;\n    uint32_t aj = 0;\n    uint32_t ak = 0;\n    uint32_t al = 0;\n    uint32_t am = 0;\n    uint32_t an = 0;\n    uint32_t ao = 0;\n    uint32_t ap = 0;\n    uint32_t aq = 0;\n    uint32_t ar = 0;\n    uint32_t as = 0;\n    uint32_t at = 0;\n    uint32_t au = 0;\n    uint32_t av = 0;\n    uint", "CodeBleu_score": 6.160281980918769}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    if (offset % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Offset must be aligned with SPI_FLASH_SEC_SIZE (0x%x)\", SPI_FLASH_SEC_SIZE);\n        return ESP_FAIL;\n    }\n\n    if (size % SPI_FLASH_SEC_SIZE != 0) {\n        ESP_LOGE(TAG, \"Size must be aligned with SPI_FLASH_SEC_SIZE (0x%x)\", SPI_FLASH_SEC_SIZE);\n        return ESP_FAIL;\n    }\n\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"Data exceeds the partition size (0x%x)\", partition->size);\n        return ESP_FAIL;\n    }\n\n    if (esp_partition_erase_range(partition, offset, size) != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase partition\");\n        return ESP_FAIL;\n    }\n\n    return esp_partition_write(partition, offset, data, size);\n}\n", "CodeBleu_score": 49.821742351177235}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    if (offset % partition->sector_size != 0) {\n        ESP_LOGE(TAG, \"Offset is not aligned with the flash sector size\");\n        return ESP_FAIL;\n    }\n    if (size % partition->sector_size != 0) {\n        ESP_LOGE(TAG, \"Size is not aligned with the flash sector size\");\n        return ESP_FAIL;\n    }\n    if (offset + size > partition->size) {\n        ESP_LOGE(TAG, \"Data is too large for the selected partition\");\n        return ESP_FAIL;\n    }\n    if (esp_partition_erase_range(partition, offset, size) != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase partition\");\n        return ESP_FAIL;\n    }\n    if (esp_partition_write(partition, offset, data, size) != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data\");\n        return ESP_FAIL;\n    }\n    return ESP_OK;\n}\n", "CodeBleu_score": 44.98761920543167}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    if (offset % 4096 == 0) {\n        if (esp_partition_erase_range(partition, offset, size) != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase partition\");\n            return ESP_FAIL;\n        }\n    }\n    return esp_partition_write(partition, offset, data, size);\n}\n", "CodeBleu_score": 44.01071119875583}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t n = 0;\n    unsigned char c;\n    while (*in) {\n        c = *in++;\n        if (c >= '0' && c <= '9')\n            c -= '0';\n        else if (c >= 'a' && c <= 'f')\n            c -= 'a' - 10;\n        else if (c >= 'A' && c <= 'F')\n            c -= 'A' - 10;\n        else\n            continue;\n\n        if (*in) {\n            *out = c << 4;\n            c = *in++;\n            if (c >= '0' && c <= '9')\n                c -= '0';\n            else if (c >= 'a' && c <= 'f')\n                c -= 'a' - 10;\n            else if (c >= 'A' && c <= 'F')\n                c -= 'A' - 10;\n            else\n                break;\n            *out++ |= c;\n            n++;\n        }\n        else\n            break;\n\n        if (n >= maxlen)\n            break;\n    }\n    return n;\n}\n", "CodeBleu_score": 38.279367701523334}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t len = 0;\n\tint i = 0;\n\tchar c = 0;\n\twhile (in[i] != '\\0' && len < maxlen) {\n\t\tc = in[i++];\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tout[len] = (c - '0');\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tout[len] = (c - 'A' + 10);\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tout[len] = (c - 'a' + 10);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\t++len;\n\t\tif (i < strlen(in) && (in[i] >= '0' && in[i] <= '9') || (in[i] >= 'A' && in[i] <= 'F') || (in[i] >= 'a' && in[i] <= 'f')) {\n\t\t\tout[len] = out[len - 1] * 16;\n\t\t\t++len;\n\t\t}\n\t}\n\treturn len;\n}\n", "CodeBleu_score": 44.907665235997285}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t len = 0;\n    unsigned char c;\n    unsigned char c2;\n\n    if (in == NULL) {\n        return 0;\n    }\n\n    while (*in != '\\0' && len < maxlen) {\n        c = *in++;\n        if (c >= '0' && c <= '9') {\n            c -= '0';\n        } else if (c >= 'a' && c <= 'f') {\n            c -= 'a' - 10;\n        } else if (c >= 'A' && c <= 'F') {\n            c -= 'A' - 10;\n        } else {\n            continue;\n        }\n        c2 = *in++;\n        if (c2 >= '0' && c2 <= '9') {\n            c2 -= '0';\n        } else if (c2 >= 'a' && c2 <= 'f') {\n            c2 -= 'a' - 10;\n        } else if (c2 >= 'A' && c2 <= 'F') {\n            c2 -= 'A' - 10;\n        } else {\n            in--;\n            continue;\n        }\n        out[len++] = (c << 4) + c2;\n    }\n    return len;\n}\n", "CodeBleu_score": 39.855847227380146}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void)\tif (tx_buffer_ptr == NULL) {\n\t\treturn 0;\n\t}\n\tif (xSemaphoreTake(tx_mutex, 10) == pdTRUE) {\n\t\tint ret = tx_buffer_ptr->availableForStore();\n\t\txSemaphoreGive(tx_mutex);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 52.41064502790002}, {"code": "int HWCDC::availableForWrite(void)    if (!_tx_buffer_ptr) {\n        return 0;\n    }\n\n    if (osSemaphoreWait(_tx_sem, _timeout) == osOK) {\n        int free_size = _tx_buffer_ptr->free();\n        osSemaphoreRelease(_tx_sem);\n        return free_size;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 48.635441050435844}, {"code": "int HWCDC::availableForWrite(void)\tint32_t freeSize;\n\n\tif (!_txRingBuffer.isInitialized() || !_txRingBufferLock.isInitialized()) {\n\t\treturn 0;\n\t}\n\n\tif (!_txRingBufferLock.take(TX_RING_BUFFER_LOCK_TIMEOUT)) {\n\t\treturn 0;\n\t}\n\n\tfreeSize = _txRingBuffer.getFreeSize();\n\t_txRingBufferLock.release();\n\treturn freeSize;\n}\n", "CodeBleu_score": 42.72526721784536}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    _lock.lock();\n    _onReceiveCB = function;\n    _onlyOnTimeout = onlyOnTimeout;\n    if (function) {\n        if (_rxTimeout) {\n            _rxTimeout->setCallback(&_rxTimeoutCB);\n        } else {\n            _rxTimeout = new Timeout(_rxTimeoutCB, 0, false);\n        }\n        if (!_rxTask) {\n            _rxTask = new EventTask(this, &HardwareSerial::_rxTaskCB);\n        }\n        _rxTask->setCallback(function);\n        _rxTask->setCallbackArg(_rxTask);\n        _rxTask->setTriggered(false);\n        _rxTask->setTimeout(0);\n        _rxTask->setRxFifo(_rxFifo);\n        _rxTask->setRxTimeout(_rxTimeout);\n        _rxTask->setRxOnlyOnTimeout(_onlyOnTimeout);\n        _rxTask->setRxBaud(_baud);\n        _rxTask->setRxBitTime(_bitTime);\n        _rxTask->setRxIrqHandler(&_uartIRQ);\n        _rxTask->setRxIrqN(_rxIrqN);\n        _rxTask->setRxPin(_rxPin);\n        _rxTask->setRxPinMask(_rxPinMask);\n        _rxTask->setRxPinAcknowledgeAddress(&_rxPinAcknowledgeAddress);\n        _rxTask->setRxPinAcknowledgeMask(_rxPinAcknowledgeMask);\n        _rxTask->setRxPinFunction(_rxPinFunction);\n        _rxTask->setRxPinAltFunction(_rxPinAltFunction);\n        _rxTask->setRxPinPull(_rxPinPull);\n        _rxTask->setRxPinPullConfig(_rxPinPullConfig);\n        _rxTask->setRxPinPullDirection(_rxPinPullDirection);\n        _rxTask->setRxPinResistor(_rxPinResistor);\n        _rxTask->setRxPinSlewRate(_rxPinSlewRate);", "CodeBleu_score": 35.6852272060591}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    _lockMutex();\n    _onReceiveCB = function;\n    _rxTimeout = onlyOnTimeout;\n    if (_onReceiveCB) {\n        _setRxThreshold();\n        if (!_rxTask) {\n            _rxTask = new Task(SerialRxTask, this, false, NULL);\n        }\n    }\n    _unlockMutex();\n}\n", "CodeBleu_score": 38.86554524709948}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    _lockMutex();\n    _onReceiveCB = function;\n    _onlyOnTimeout = onlyOnTimeout;\n    if (_onReceiveCB) {\n        _setRxTimeout(true);\n        if (!_rxTask) {\n            _rxTask = new ReceiveTask(this);\n            _rxTask->start();\n        }\n    }\n    _unlockMutex();\n}\n", "CodeBleu_score": 38.822410538337145}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)    if (length < 1) {\n        return 0;\n    }\n\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) {\n            break;\n        }\n        *buffer++ = (char)c;\n        index++;\n    }\n    *buffer = '\\0';\n    return index;\n}\n", "CodeBleu_score": 94.49587704737506}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)    if (length < 1) {\n        return 0;\n    }\n\n    size_t index = 0;\n    while (index < length) {\n        int c = timedRead();\n        if (c < 0 || c == terminator) {\n            break;\n        }\n        *buffer++ = (char) c;\n        index++;\n    }\n    *buffer = '\\0';\n    return index;\n}\n", "CodeBleu_score": 92.96845407863205}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)\tif (length < 1) {\n\t\treturn 0;\n\t}\n\tsize_t index = 0;\n\twhile (index < length) {\n\t\tint c = timedRead();\n\t\tif (c < 0 || c == terminator) {\n\t\t\tbreak;\n\t\t}\n\t\t*buffer++ = (char)c;\n\t\tindex++;\n\t}\n\t*buffer = '\\0';\n\treturn index;\n}\n", "CodeBleu_score": 85.09529371001436}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  Serial.println(\"tone\");\n  Serial.print(\"Pin: \");\n  Serial.println(pin);\n  Serial.print(\"Frequency: \");\n  Serial.println(frequency);\n  Serial.print(\"Duration: \");\n  Serial.println(duration);\n\n  if (pin >= 0 && pin < 14) {\n    if (pins[pin] == 0) {\n      pins[pin] = 1;\n      toneQueue.push({pin, frequency, duration});\n      Serial.println(\"Tone started\");\n    } else {\n      Serial.println(\"Error: Pin already in use\");\n    }\n  } else {\n    Serial.println(\"Error: Invalid pin\");\n  }\n}\n", "CodeBleu_score": 35.59727182026447}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  Serial.println(\"tone\");\n  Serial.print(\"Pin: \");\n  Serial.println(pin);\n  Serial.print(\"Frequency: \");\n  Serial.println(frequency);\n  Serial.print(\"Duration: \");\n  Serial.println(duration);\n\n  if (pins[pin].toneState == TONE_AVAILABLE) {\n    pins[pin].toneState = TONE_START;\n    pins[pin].toneFrequency = frequency;\n    pins[pin].toneDuration = duration;\n    pins[pin].toneStartTime = millis();\n\n    Serial.print(\"Sending tone start command to queue: \");\n    Serial.print(pin);\n    Serial.print(\", \");\n    Serial.print(frequency);\n    Serial.print(\", \");\n    Serial.println(duration);\n\n    xQueueSend(toneQueue, &pins[pin], 0);\n  } else {\n    Serial.print(\"Error: Pin \");\n    Serial.print(pin);\n    Serial.println(\" is not available. Stop the current tone first.\");\n  }\n}\n", "CodeBleu_score": 35.759526591331294}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  Serial.println(\"Tone: pin \" + String(pin) + \", frequency \" + String(frequency) + \", duration \" + String(duration));\n\n  if (pin == 1) {\n    Serial.println(\"Tone: Pin 1 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 2) {\n    Serial.println(\"Tone: Pin 2 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 3) {\n    Serial.println(\"Tone: Pin 3 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 4) {\n    Serial.println(\"Tone: Pin 4 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 5) {\n    Serial.println(\"Tone: Pin 5 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 6) {\n    Serial.println(\"Tone: Pin 6 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 7) {\n    Serial.println(\"Tone: Pin 7 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 8) {\n    Serial.println(\"Tone: Pin 8 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 9) {\n    Serial.println(\"Tone: Pin 9 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 10) {\n    Serial.println(\"Tone: Pin 10 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 11) {\n    Serial.println(\"Tone: Pin 11 is reserved for RF communication. Please use another pin.\");\n    return;\n  }\n\n  if (pin == 12) {", "CodeBleu_score": 30.20197418759021}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled)  if (!_usb_started) {\n    _webusb_enabled = enabled;\n    if (enabled) {\n      _usb_version = 0x0210;\n    }\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 45.81776992973469}, {"code": "bool ESPUSB::webUSB(bool enabled)    if (enabled) {\n        if (usb_version < 0x0210) {\n            usb_version = 0x0210;\n        }\n        webusb_enabled = true;\n    } else {\n        webusb_enabled = false;\n    }\n    return !usb_started;\n}\n", "CodeBleu_score": 60.29079352998904}, {"code": "bool ESPUSB::webUSB(bool enabled)  if (enabled) {\n    if (!_webUSB) {\n      if (_usbVersion < 0x0210) {\n        _usbVersion = 0x0210;\n      }\n    }\n    _webUSB = enabled;\n    return true;\n  }\n  _webUSB = enabled;\n  return false;\n}\n", "CodeBleu_score": 59.9430438804885}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX()    // Read the data into the buffer\n    int len = USBDevice::readEP(CDC_EP_OUT, _rx_buffer, CDC_RX_BUFFER_SIZE);\n\n    // If there is data, post a receive event\n    if (len > 0) {\n        // Post a receive event\n        Event evt(this, EventType::Receive);\n        evt.data = len;\n        postEvent(evt);\n    }\n}\n", "CodeBleu_score": 8.582087340778118}, {"code": "void USBCDC::_onRX()    uint8_t buffer[64];\n    uint32_t length;\n    uint32_t dropped = 0;\n\n    if (usb_cdc_rx_busy) {\n        return;\n    }\n    usb_cdc_rx_busy = true;\n\n    while (true) {\n        length = usb_ep_read_packet(usb_cdc_rx_ep, buffer, sizeof(buffer));\n        if (length == 0) {\n            break;\n        }\n\n        for (uint32_t i = 0; i < length; i++) {\n            if (!usb_cdc_rx_queue.full()) {\n                usb_cdc_rx_queue.put(buffer[i]);\n            } else {\n                dropped++;\n            }\n        }\n    }\n\n    if (dropped) {\n        usb_cdc_rx_queue.put(USBCDC_QUEUE_ERROR);\n        usb_cdc_rx_queue.put(dropped);\n        debug_if(dbg, \"USBCDC::_onRX: dropped %d bytes\\n\", dropped);\n    }\n\n    if (length) {\n        usb_cdc_rx_queue.put(USBCDC_QUEUE_RX);\n        usb_cdc_rx_queue.put(length);\n    }\n\n    usb_cdc_rx_busy = false;\n}\n", "CodeBleu_score": 32.94101284540347}, {"code": "void USBCDC::_onRX()\tuint8_t buf[64];\n\tuint32_t len = 0;\n\tuint32_t read;\n\tuint32_t overflow = 0;\n\tuint32_t i;\n\n\t// read data into buffer\n\tread = USBDevice.readEP(rxEP, buf, sizeof(buf));\n\n\t// post receive event\n\tif (read) {\n\t\tif (rxQueue) {\n\t\t\t// try to write data to the receive queue\n\t\t\tfor (i = 0; i < read; i++) {\n\t\t\t\tif (!rxQueue->write(&buf[i], 1)) {\n\t\t\t\t\t// if the queue is full, count the number of dropped bytes\n\t\t\t\t\toverflow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if any bytes were dropped, post an overflow event\n\t\t\tif (overflow) {\n\t\t\t\tpostEvent(USBCDC_EVENT_OVERFLOW, overflow);\n\t\t\t}\n\t\t}\n\t\tpostEvent(USBCDC_EVENT_RX, read);\n\t}\n}\n", "CodeBleu_score": 26.742267763590654}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Parse robot name from URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Get robot from database\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\ta.respondWithError(res, err)\n\t\treturn\n\t}\n\n\t// Get devices from database\n\tdevices, err := a.db.GetDevices(robotName)\n\tif err != nil {\n\t\ta.respondWithError(res, err)\n\t\treturn\n\t}\n\n\t// Create response JSON\n\tresponse := struct {\n\t\tRobot   *model.Robot `json:\"robot\"`\n\t\tDevices []*model.Device `json:\"devices\"`\n\t}{\n\t\trobot,\n\t\tdevices,\n\t}\n\n\t// Write response JSON to response writer\n\ta.respondWithJSON(res, http.StatusOK, response)\n}", "CodeBleu_score": 33.09482712562563}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Parse robot name from request\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Check if robot exists\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif robot == nil {\n\t\thttp.Error(res, \"No robot with name '\"+robotName+\"' exists.\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get robot devices\n\tdevices, err := a.db.GetDevicesForRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Convert devices to JSON\n\tjson, err := json.Marshal(devices)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write JSON to HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(json)\n}", "CodeBleu_score": 36.08604263612083}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\trobotName := mux.Vars(req)[\"robotName\"]\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err != nil {\n\t\thttp.Error(res, \"No robot was found with the specified name.\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevices, err := a.db.GetDevicesByRobot(robot.ID)\n\tif err != nil {\n\t\thttp.Error(res, \"Failed to get devices for robot.\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tjson.NewEncoder(res).Encode(devices)\n}\n", "CodeBleu_score": 30.857355195124914}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Check if the robot exists\n\trobot, ok := a.Robots[robotName]\n\tif !ok {\n\t\t// If the robot does not exist, write an error message to the HTTP response\n\t\thttp.Error(res, fmt.Sprintf(\"No robot with the name '%s' was found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Create a JSON array to hold the robot's connections\n\tconnectionsJSON := make([]jsonConnection, 0)\n\n\t// Iterate through the robot's connections\n\tfor _, connection := range robot.Connections {\n\t\t// Convert the connection to JSON format\n\t\tconnectionJSON := jsonConnection{\n\t\t\tName: connection.Name,\n\t\t\tType: connection.Type,\n\t\t\tFrom: connection.From,\n\t\t\tTo:   connection.To,\n\t\t}\n\n\t\t// Add the connection to the JSON array\n\t\tconnectionsJSON = append(connectionsJSON, connectionJSON)\n\t}\n\n\t// Write the JSON array to the HTTP response\n\tjson.NewEncoder(res).Encode(connectionsJSON)\n}", "CodeBleu_score": 41.68767981766489}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\n\trobot, err := a.getRobot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\n\tjson, err := json.Marshal(connections)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write(json)\n}", "CodeBleu_score": 32.16173034049261}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL.\n\trobotName := mux.Vars(req)[\"robot\"]\n\t// Check if the robot exists.\n\trobot, ok := a.Robots[robotName]\n\tif !ok {\n\t\t// If the robot is not found, write an error message to the HTTP response.\n\t\thttp.Error(res, fmt.Sprintf(\"No robot with name %s found.\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\t// Create a slice to hold the robot's connections.\n\tconnections := []Connection{}\n\t// Iterate through the robot's connections.\n\tfor _, conn := range robot.Connections {\n\t\t// Convert the connection to JSON format.\n\t\tconnection := Connection{\n\t\t\tName:     conn.Name,\n\t\t\tType:     conn.Type,\n\t\t\tHost:     conn.Host,\n\t\t\tPort:     conn.Port,\n\t\t\tUsername: conn.Username,\n\t\t\tPassword: conn.Password,\n\t\t}\n\t\t// Append the connection to the slice.\n\t\tconnections = append(connections, connection)\n\t}\n\t// Convert the slice to JSON format.\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\t// Write the JSON formatted connections to the HTTP response.\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 42.159212824742866}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\tvar err error\n\tvar command string\n\tvar commandResult interface{}\n\n\t// Retrieve the robot name from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robotName\")\n\t// Retrieve the device name from the URL query parameters.\n\tdeviceName := req.URL.Query().Get(\"deviceName\")\n\t// Retrieve the command name from the URL query parameters.\n\tcommand = req.URL.Query().Get(\"command\")\n\n\t// Check if the robot exists.\n\tif _, ok := a.Robots[robotName]; !ok {\n\t\t// If the robot does not exist, write an error message as a JSON response.\n\t\thttp.Error(res, fmt.Sprintf(\"Robot \\\"%s\\\" not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tif _, ok := a.Robots[robotName].Devices[deviceName]; !ok {\n\t\t// If the device does not exist, write an error message as a JSON response.\n\t\thttp.Error(res, fmt.Sprintf(\"Device \\\"%s\\\" not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the specified command on the device.\n\tswitch command {\n\tcase \"Start\":\n\t\tcommandResult, err = a.Robots[robotName].Devices[deviceName].Start()\n\tcase \"Halt\":\n\t\tcommandResult, err = a.Robots[robotName].Devices[deviceName].Halt()\n\tdefault:\n\t\t// If the command is not supported, write an error message as a JSON response.\n\t\thttp.Error(res, fmt.Sprintf(\"Command \\\"%s\\\" not supported\", command), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check if an error occurred while executing the command.\n\tif err != nil {\n\t\t// If an error occurred, write the error message as a JSON response.\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the command result as a JSON response.\n\tjson", "CodeBleu_score": 37.617402980524794}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Parse the robot and device names from the URL query parameters\n\tquery := req.URL.Query()\n\trobotName := query.Get(\"robot\")\n\tdeviceName := query.Get(\"device\")\n\tcommand := query.Get(\"command\")\n\n\t// Get the robot from the robot map\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\t// If the robot is not found, write an error message as a JSON response\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the device from the robot\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\t// If the device is not found, write an error message as a JSON response\n\t\thttp.Error(res, fmt.Sprintf(\"Device %s not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\tdevice.Execute(command)\n\n\t// Write an empty JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tfmt.Fprint(res, \"{}\")\n}", "CodeBleu_score": 44.654976764483166}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\"robotName\")\n\tdeviceName := req.URL.Query().Get(\"deviceName\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\trobot, ok := a.RobotMap[robotName]\n\tif !ok {\n\t\thttp.Error(res, fmt.Sprintf(\"Robot %s not found\", robotName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdevice, ok := robot.Devices[deviceName]\n\tif !ok {\n\t\thttp.Error(res, fmt.Sprintf(\"Device %s not found\", deviceName), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tswitch command {\n\tcase \"on\":\n\t\tdevice.On()\n\tcase \"off\":\n\t\tdevice.Off()\n\tdefault:\n\t\thttp.Error(res, fmt.Sprintf(\"Command %s not found\", command), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n}", "CodeBleu_score": 43.475043273390824}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.06124909846933}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 51.450947436460694}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized.\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// continue\n\t}\n}", "CodeBleu_score": 52.35961621281909}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.Lock()\n\tdefer a.Unlock()\n\n\tif a.connection.SupportsAnalogRead() {\n\t\trawValue, err := a.connection.AnalogRead(a.Pin)\n\t\tif err != nil {\n\t\t\treturn 0, 0, err\n\t\t}\n\n\t\tscaledValue := a.scaleValue(rawValue)\n\t\ta.lastAnalogRead = scaledValue\n\t\ta.lastAnalogReadRaw = rawValue\n\t\treturn rawValue, scaledValue, nil\n\t}\n\n\treturn 0, 0, fmt.Errorf(\"Connection does not support analog read\")\n}\n", "CodeBleu_score": 49.943562682095326}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.Lock()\n\tdefer a.Unlock()\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\trawValue, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue := a.scaleValue(rawValue)\n\ta.lastAnalogValue = scaledValue\n\ta.lastAnalogRawValue = rawValue\n\treturn rawValue, scaledValue, nil\n}\n", "CodeBleu_score": 49.860250893065974}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"connection %s does not support analog reading\", a.connection.Name())\n\t}\n\trawValue, err := a.connection.AnalogRead(a.Pin())\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue := a.scaleValue(rawValue)\n\ta.lastAnalogValue = scaledValue\n\ta.lastAnalogRawValue = rawValue\n\treturn rawValue, scaledValue, nil\n}\n", "CodeBleu_score": 51.96065545335389}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\td := new(GroveSoundSensorDriver)\n\td.Pin = pin\n\td.Name = gobot.DefaultName(\"GroveSoundSensor\")\n\td.AnalogSensorDriver = NewAnalogSensorDriver(a, pin, d.Work, opts...)\n\treturn d\n}\n", "CodeBleu_score": 43.53000129576298}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tdriver := new(GroveSoundSensorDriver)\n\tinit := []interface{}{pin}\n\tdriver.AnalogSensorDriver = NewAnalogSensorDriver(a, \"GroveSoundSensor\", append(init, opts...)...)\n\treturn driver\n}\n", "CodeBleu_score": 37.34372836415014}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tdriver := new(GroveSoundSensorDriver)\n\tinit := []interface{}{pin}\n\tdriver.AnalogSensorDriver = NewAnalogSensorDriver(a, init...)\n\tdriver.Pin = pin\n\tdriver.Name = fmt.Sprintf(\"GroveSoundSensor_%s\", pin)\n\tif len(opts) > 0 {\n\t\tdriver.Name = opts[0].(string)\n\t}\n\treturn driver\n}\n", "CodeBleu_score": 31.42088353418974}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error\td.writeRegister(CommandReg, SoftReset)\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tif d.readRegister(CommandReg)&SoftReset != 0 {\n\t\treturn fmt.Errorf(\"Timeout during soft reset\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 26.82006166334058}, {"code": "func (d *MFRC522Common) softReset() error\t// Issue the reset command.\n\td.WriteRegister(CommandReg, PCD_SoftReset)\n\t// Wait the appropriate time for command to complete.\n\ttime.Sleep(100 * time.Millisecond)\n\t// Check that power down bit is cleared.\n\tif d.ReadRegister(CommandReg)&(1<<PCD_POWER_DOWN) != 0 {\n\t\treturn errors.New(\"Soft reset did not complete\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 26.875814635053775}, {"code": "func (d *MFRC522Common) softReset() error\t// Write the soft reset command to the command register\n\tif err := d.writeRegister(CommandReg, PCD_SoftReset); err != nil {\n\t\treturn err\n\t}\n\t// Wait the required 100ms + 20% safety margin\n\ttime.Sleep(120 * time.Millisecond)\n\t// Check that the power-down bit is no longer set\n\tcmd, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif cmd&PCD_SoftReset != 0 {\n\t\treturn errors.New(\"Timeout during soft reset\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 67.77001051080302}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tvar err error\n\tvar length uint8\n\tvar controlReg uint8\n\n\t// Get the number of bytes stored in the FIFO\n\tlength, err = d.ReadRegister(d.FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes is not equal to the length of the byte slice, return an error\n\tif length != uint8(len(backData)) {\n\t\treturn 0, errors.New(\"Length of byte slice does not match number of bytes in FIFO\")\n\t}\n\n\t// Read each byte from the FIFO buffer\n\tfor i := uint8(0); i < length; i++ {\n\t\tbackData[i], err = d.ReadRegister(d.FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tcontrolReg, err = d.ReadRegister(d.ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn controlReg, nil\n}\n", "CodeBleu_score": 42.7971062609147}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tvar err error\n\tvar length uint8\n\tvar lastBits uint8\n\tvar n uint8\n\n\t// Get the number of bytes stored in the FIFO\n\tlength, err = d.dev.ReadReg(d.reg.FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes is more than the size of the byte slice, return an error\n\tif length > uint8(len(backData)) {\n\t\treturn 0, errors.New(\"Length of backData is less than the number of bytes in FIFO\")\n\t}\n\n\t// Read the data from FIFO buffer\n\tfor n = 0; n < length; n++ {\n\t\tbackData[n], err = d.dev.ReadReg(d.reg.FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read control register\n\tlastBits, err = d.dev.ReadReg(d.reg.ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Return the number of valid bits\n\treturn (lastBits & 0x07), nil\n}\n", "CodeBleu_score": 44.823416287832195}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Read the number of bytes stored in the FIFO\n\tn, err := d.ReadFifoLevel()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// If the number of bytes is more than the size of the byte slice, return an error\n\tif n > uint8(len(backData)) {\n\t\treturn 0, errors.New(\"readFifo: the number of bytes in the FIFO is more than the size of the byte slice\")\n\t}\n\n\t// Read the bytes from the FIFO into the byte slice\n\tfor i := uint8(0); i < n; i++ {\n\t\tbackData[i], err = d.ReadFifoData()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tlastBits, err := d.ReadControlRegister(ControlRegisterReceiveBits)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn lastBits, nil\n}\n", "CodeBleu_score": 52.820137283310146}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error\t// Log message\n\td.logger.Printf(\"Halting PICC\")\n\t// Halt command is 0x50 0x00\n\thaltCommand := []byte{0x50, 0x00}\n\t// Calculate CRC\n\thaltCommand = append(haltCommand, d.calculateCRC(haltCommand)...)\n\t// Send command to the PICC\n\terr := d.sendCommand(haltCommand)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Check the response\n\tbuffer, err := d.readResponse()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif buffer[0] != 0x00 {\n\t\treturn errors.New(\"PICC did not halt\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 42.998528054142085}, {"code": "func (d *MFRC522Common) piccHalt() error\td.logger.Debug(\"Halting PICC\")\n\t// Halt command\n\tbuffer := []byte{d.CommandHalt, 0}\n\t// Calculate CRC\n\tbuffer = append(buffer, d.crc(buffer)...)\n\t// Send command to the PICC\n\tif _, err := d.dev.Write(buffer); err != nil {\n\t\treturn err\n\t}\n\t// Wait for response\n\tif _, err := d.dev.Read(buffer); err != nil {\n\t\treturn err\n\t}\n\t// Check if the response is valid\n\tif err := d.checkValid(buffer, d.CommandHalt, 0); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 38.996761631492504}, {"code": "func (d *MFRC522Common) piccHalt() error\t// Log message\n\td.logger.Debugf(\"PICC Halt\\n\")\n\n\t// Create halt command\n\thaltCmd := []byte{d.CommandHalt, 0}\n\n\t// Calculate CRC for the halt command\n\thaltCmd = append(haltCmd, d.crc(haltCmd)...)\n\n\t// Send the halt command to the PICC\n\tif err := d.dev.Tx(haltCmd, nil); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the PICC responded with the expected error message (i.e. if the PICC halted)\n\tif err := d.dev.Rx(0, nil, nil); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 34.86457687287597}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tbuffer := []byte{0x30, 0x00}\n\tbuffer[1] = block\n\tbuffer[2] = 0x70\n\tbuffer[3] = 0x00\n\tbuffer[4] = 0x00\n\tbuffer[5] = 0x00\n\tbuffer[6] = 0x00\n\tbuffer[7] = 0x00\n\tbuffer[8] = 0x00\n\tbuffer[9] = 0x00\n\tbuffer[10] = 0x00\n\tbuffer[11] = 0x00\n\tbuffer[12] = 0x00\n\tbuffer[13] = 0x00\n\tbuffer[14] = 0x00\n\tbuffer[15] = 0x00\n\tcrc := d.calculateCRC(buffer[0:6])\n\tbuffer[6] = crc[0]\n\tbuffer[7] = crc[1]\n\tresponse, err := d.cardWrite(buffer, 16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif response[0] != 0x30 {\n\t\treturn nil, fmt.Errorf(\"error reading from card: %x\", response[0])\n\t}\n\tif response[1] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"error reading from card: %x\", response[1])\n\t}\n\treturn response[0:16], nil\n}\n", "CodeBleu_score": 30.539685928065218}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tvar err error\n\tvar data []byte\n\tvar n uint8\n\tvar buff []byte\n\n\t// Initiate the read operation using a MIFARE Standard READ command.\n\tbuff, err = d.PCD_MIFARE_CMD(MIFARE_CMD_READ, block)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The read operation was successful.\n\tif len(buff) > 0 {\n\t\t// Read all 16 bytes of the data block.\n\t\tfor n = 0; n < 16; n++ {\n\t\t\tdata = append(data, buff[n])\n\t\t}\n\t}\n\n\treturn data, nil\n}\n", "CodeBleu_score": 28.40567266582684}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tvar data []byte\n\tvar err error\n\tvar buffer []byte\n\tvar size uint8\n\n\t// Initiate MFRC522\n\tif err := d.PcdReset(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Reset baud rates\n\tif err := d.PcdAntennaOn(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Build command buffer\n\tbuffer = []byte{d.PiccCmdRead, block}\n\n\t// Calculate CRC for the command buffer and append it\n\tbuffer = append(buffer, d.PcdCalculateCrc(buffer)...)\n\n\t// Clear the internal buffer and transfer the command buffer to the FIFO\n\td.PcdClearRegisterBitMask(d.CommandReg, 0x80)\n\tif err := d.PcdWrite(d.CommandReg, buffer); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Turn on the bit that sends data to the FIFO\n\td.PcdSetRegisterBitMask(d.CommandReg, 0x80)\n\n\t// Wait for the command to complete\n\tif err := d.PcdWaitForReceive(d.CommandReg); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check for errors in the response\n\tif d.PcdReadRegister(d.ErrorReg) != 0x00 {\n\t\treturn nil, fmt.Errorf(\"error in response\")\n\t}\n\n\t// Check if the response is valid\n\tif d.PcdReadRegister(d.FIFOLevelReg) != 0x02 {\n\t\treturn nil, fmt.Errorf(\"response invalid\")\n\t}\n\n\t// Read the data from the FIFO\n\tsize = d.PcdReadRegister(d.FIFOLevelReg)\n\tdata = make([]byte, size)\n\tif err := d.PcdRead(d.FIFODataReg, data); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Return the data\n\treturn data, nil\n}", "CodeBleu_score": 44.30052519856189}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer must be at least 2 bytes\")\n\t}\n\n\td.clearRegisterBitmask(Status2Reg, 0x08) // Clear the CRCIRq bit\n\n\td.writeRegister(ComIEnReg, 0x78)         // Enable the CRCIRq interrupt\n\td.writeRegister(CommIrqReg, 0x78)        // Enable the CRCIRq interrupt\n\td.writeRegister(FIFOLevelReg, 0x88)      // FlushBuffer = 1, FIFO initialization\n\td.writeRegister(CommandReg, PCD_IDLE)    // Stop any active command\n\n\td.writeRegister(BitFramingReg, 0x07) // TxLastBits = BitFramingReg[2..0]\n\n\td.writeRegister(CommandReg, PCD_TRANSCEIVE)\n\td.writeRegister(TransceiveReg, reqMode)\n\td.writeRegister(FIFODataReg, 0x26)\n\n\td.writeRegister(BitFramingReg, 0x80) // StartSend = 1, transmission of data starts\n\n\tfor i := byte(2000); i > 0; i-- {\n\t\tn, err := d.readRegister(ComIrqReg)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif n&0x01 > 0 && n&0x04 > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\td.writeRegister(BitFramingReg, 0x00) // StartSend = 0\n\n\tif err := d.readRegisterInto(FIFOLevelReg, answer); err != nil {\n\t\treturn err\n\t}\n\n\tif answer[0]&0x0F != 0x0A {\n\t\treturn fmt.Errorf(\"PICC did not answer with an ACK\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 51.81166649238056}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// Check if we're in the correct state\n\tif d.CommunicationMode != CommunicationModeIdle {\n\t\treturn errors.New(\"MFRC522 communication mode is not idle\")\n\t}\n\n\t// Check if the answer buffer has at least 2 bytes of space\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer is too small\")\n\t}\n\n\t// Clear the collision register\n\td.ClearRegisterBitMask(CollReg, 0x80)\n\n\t// Set the transmission to use only 7 bits of the last byte\n\tif reqMode == PICC_CMD_REQA || reqMode == PICC_CMD_WUPA {\n\t\td.WriteRegister(BitFramingReg, 0x07)\n\t} else {\n\t\td.WriteRegister(BitFramingReg, 0x00)\n\t}\n\n\t// Transceive the request command\n\terr := d.TransceiveData(reqMode, nil, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the response is valid\n\tif len(answer) != 2 || answer[0] != d.PICC_ANTICOLL || answer[1] != 0x00 {\n\t\treturn errors.New(\"invalid response\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 52.95263272085804}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn ErrNoRoom\n\t}\n\n\t// Clear the collision register\n\td.dev.ClearRegisterBitMask(CollReg, 0x80)\n\n\t// Set the transmission to use 7 bits\n\tif reqMode == ReqID4 {\n\t\td.dev.WriteRegister(BitFramingReg, 0x07)\n\t} else {\n\t\td.dev.WriteRegister(BitFramingReg, 0x00)\n\t}\n\n\t// Send the request command\n\terr := d.dev.Transceive([]byte{reqMode}, answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif answer[0]&0x04 != 0 {\n\t\treturn ErrCRC\n\t}\n\n\tif answer[0]&0x02 != 0 {\n\t\treturn ErrParity\n\t}\n\n\tif answer[0]&0x01 != 0 {\n\t\treturn ErrProtocol\n\t}\n\n\tif answer[0]&0x08 != 0 {\n\t\treturn ErrCollision\n\t}\n\n\tif answer[0]&0x10 != 0 {\n\t\treturn ErrBufferOverflow\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 47.805428757371224}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\terr := d.stepPin.Out(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.stepDelay)\n\terr = d.stepPin.Out(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == Clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 63.44308534712641}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low\n\terr := d.stepPin.Out(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the delay\n\ttime.Sleep(d.delay)\n\n\t// Set the step pin high\n\terr = d.stepPin.Out(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number\n\tif d.direction == clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 63.272511273911924}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.direction == Clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\terr := d.stepPin.Out(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.stepPin.Out(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 51.98731808035434}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.monitoring {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.stop = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stop:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdist, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(err)\n\t\t\t\t}\n\t\t\t\td.mutex.Lock()\n\t\t\t\td.distance = dist\n\t\t\t\td.mutex.Unlock()\n\t\t\t\ttime.Sleep(d.interval)\n\t\t\t}\n\t\t}\n\t}()\n\td.monitoring = true\n\treturn nil\n}\n", "CodeBleu_score": 46.428554943371275}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\tif d.monitoring {\n\t\treturn errors.New(\"Distance monitor already running\")\n\t}\n\td.monitoring = true\n\td.stopMonitor = make(chan bool)\n\td.wg.Add(1)\n\tgo d.monitorDistance()\n\treturn nil\n}\n", "CodeBleu_score": 22.417792233722945}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.monitoring {\n\t\treturn errors.New(\"already monitoring\")\n\t}\n\n\td.stop = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\td.wg.Add(1)\n\n\tgo func() {\n\t\tdefer d.wg.Done()\n\n\t\tticker := time.NewTicker(d.measurementInterval)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stop:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\td.logger.Error(err)\n\t\t\t\t} else {\n\t\t\t\t\td.logger.Debugf(\"measured distance: %f cm\", distance)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\td.monitoring = true\n\n\treturn nil\n}\n", "CodeBleu_score": 45.70957171416289}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar startTime time.Time\n\treturn func(pin int, value time.Duration, edge string, count uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Since(startTime)\n\t\t\td.Echo <- duration.Seconds() * 34000 / 2\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.09394409238727}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tstart := time.Now()\n\treturn func(pin int, value time.Duration, edge string, tick uint32, count uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstart = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Now().Sub(start)\n\t\t\td.Distance <- duration.Seconds() * 34000 / 2\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.45630880338082}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar startTime time.Time\n\treturn func(pin int, duration time.Duration, edge string, count uint32, value uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := time.Since(startTime)\n\t\t\td.DistanceChannel <- duration\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.42166004462984}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\td.triggerPin.Out(gpio.High)\n\ttime.Sleep(10 * time.Microsecond)\n\td.triggerPin.Out(gpio.Low)\n\n\tfor d.echoPin.Read() == gpio.Low && d.timeout < 1000000 {\n\t\td.timeout++\n\t}\n\n\tif d.timeout >= 1000000 {\n\t\treturn errors.New(\"timeout\")\n\t}\n\n\tstartTime := time.Now()\n\tfor d.echoPin.Read() == gpio.High && d.timeout < 1000000 {\n\t\td.timeout++\n\t}\n\n\tif d.timeout >= 1000000 {\n\t\treturn errors.New(\"timeout\")\n\t}\n\n\td.measuredTime = time.Since(startTime).Nanoseconds() / 1000\n\treturn nil\n}", "CodeBleu_score": 48.09754729198263}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\tif err := d.triggerSensor(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := d.waitForMeasurement(); err != nil {\n\t\treturn err\n\t}\n\n\td.measuredTime = d.getMeasuredTime()\n\n\treturn nil\n}\n", "CodeBleu_score": 49.65258763635249}, {"code": "func (d *HCSR04Driver) measureDistance() error\t// Lock the measurement mutex to ensure exclusive access\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor\n\td.triggerPin.High()\n\ttime.Sleep(time.Microsecond)\n\td.triggerPin.Low()\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\td.echoPin.WaitForEdge(time.Microsecond*5000)\n\n\t// If the measurement timed out, return an error\n\tif !d.echoPin.Read() {\n\t\treturn errors.New(\"measurement timed out\")\n\t}\n\n\t// Store the measured time in microseconds\n\td.measuredTime = d.echoPin.ReadDurationLastChange()\n\n\treturn nil\n}\n", "CodeBleu_score": 41.16424479682201}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n    # Check if the token is available in the environment variables\n    token = self.get_token_from_environment()\n    if token:\n        return token\n    # Check if the token is available in the local state\n    token = self.get_token_from_local_state()\n    if token:\n        return token\n    # Check if the refresh token is available in the local state\n    refresh_token = self.get_refresh_token_from_local_state()\n    if refresh_token:\n        # Attempt to fetch a new access token using the refresh token\n        token = self.fetch_new_access_token_using_refresh_token(refresh_token)\n        if token:\n            return token\n    raise AccountNotAuthorized(\n        \"You are not authorized to access this resource. Please run 'python3 -m venmo_api_python authorize' to authorize your account.\"\n    )\n\n", "CodeBleu_score": 12.963267143128837}, {"code": "def fetch_authentication_token(self)\n    try:\n        if self.authentication_token is not None:\n            return self.authentication_token\n        else:\n            if self.authentication_data is None:\n                raise AccountNotAuthorized\n            else:\n                if self.authentication_data[\"expires_at\"] < datetime.now().timestamp():\n                    if self.authentication_data[\"refresh_token\"] is not None:\n                        self.authentication_data = self.refresh_authentication_token(self.authentication_data[\"refresh_token\"])\n                        self.update_local_state()\n                        return self.authentication_token\n                    else:\n                        raise AccountNotAuthorized\n                else:\n                    return self.authentication_data[\"access_token\"]\n    except AccountNotAuthorized:\n        raise AccountNotAuthorized\n\n", "CodeBleu_score": 31.513470581156987}, {"code": "def fetch_authentication_token(self)\n    from os import environ\n    from datetime import datetime\n    from .exceptions import AccountNotAuthorized\n    from .utils import get_local_state\n    from .utils import set_local_state\n    from .utils import refresh_authentication_token\n    from .utils import get_authentication_token\n\n    # Check for access token in environment variables\n    if \"SPOTIPY_ACCESS_TOKEN\" in environ:\n        access_token = environ[\"SPOTIPY_ACCESS_TOKEN\"]\n        return access_token\n\n    # Check for access token in local state\n    local_state = get_local_state()\n    if local_state is not None:\n        if \"access_token\" in local_state:\n            access_token = local_state[\"access_token\"]\n            if \"expires_at\" in local_state:\n                expires_at = local_state[\"expires_at\"]\n                if expires_at is not None:\n                    now = datetime.now()\n                    if now < expires_at:\n                        return access_token\n                    else:\n                        if \"refresh_token\" in local_state:\n                            refresh_token = local_state[\"refresh_token\"]\n                            new_access_token = refresh_authentication_token(refresh_token)\n                            if new_access_token is not None:\n                                new_local_state = get_local_state()\n                                set_local_state(new_local_state)\n                                return new_access_token\n                            else:\n                                raise AccountNotAuthorized(\"Failed to refresh access token\")\n                        else:\n                            raise AccountNotAuthorized(\"Access token is expired and no refresh token is available\")\n                else:\n                    raise AccountNotAuthorized(\"Expiration time not found in local state\")\n            else:\n                raise AccountNotAuthorized(\"Access token not found in local state\")\n        else:\n            raise AccountNotAuthorized(\"Access token not found in local state\")\n    else:\n        raise AccountNotAuthorized(\"Local state not found\")\n\n", "CodeBleu_score": 30.82416224030988}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n    refresh_token = self.refresh_token\n    self.delete_session()\n    try:\n        self.post(endpoint=\"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 42.90434342344259}, {"code": "def logout(self)\n    if self.is_logged_in():\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        try:\n            self.post(\"/v1/logout\", {\"refresh_token\": refresh_token})\n        except AccountError:\n            pass\n        return True\n    return False", "CodeBleu_score": 75.00912496909635}, {"code": "def logout(self)\n\n    # Retrieve the refresh token\n    refresh_token = self.get_refresh_token()\n\n    # Delete the local session\n    self.delete_local_session()\n\n    # Attempt to send a POST request to the \"/v1/logout\" endpoint with the refresh token\n    try:\n        self.post(\"/v1/logout\", {\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n\n    return True", "CodeBleu_score": 47.10750149746179}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_info = {\n            \"name\": package.name,\n            \"version\": package.version,\n        }\n        if package.external:\n            package_info[\"source\"] = package.source\n        packages.append(package_info)\n    return packages", "CodeBleu_score": 28.356186853558636}, {"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        packages.append(\n            {\n                \"name\": package.name,\n                \"version\": package.version,\n                \"source\": package.source,\n            }\n        )\n    return packages\n\n", "CodeBleu_score": 21.90686619643904}, {"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_name = package.name\n        package_version = package.version\n        package_url = package.source_url\n        packages.append((package_name, package_version, package_url))\n    return packages\n", "CodeBleu_score": 20.397253391459984}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if not env in cls.platforms:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(cls.platforms[env], autoinstall)\n    instance.project_env = env\n    instance.configure_project_packages(targets)\n    return instance\n\n", "CodeBleu_score": 33.55646208570409}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\n    # Retrieve the platform specification for the environment\n    spec = cls.get_platform_spec(env)\n    if not spec:\n        raise UndefinedEnvPlatformError(env)\n\n    # Create the instance\n    instance = cls(spec, autoinstall)\n\n    # Set the project environment\n    instance.set_project_environment(env)\n\n    # Configure the project packages for the given environment and targets\n    instance.configure_project_packages(env, targets)\n\n    return instance", "CodeBleu_score": 31.072578596883314}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n\n    if env not in cls.config.env_platforms:\n        raise UndefinedEnvPlatformError(env)\n\n    env_platform = cls.config.env_platforms[env]\n    instance = cls(env_platform, autoinstall)\n    instance.project_env = env\n    instance.configure(targets)\n    return instance\n\n", "CodeBleu_score": 37.08065312604944}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}\n", "CodeBleu_score": 69.08222267670335}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}\n", "CodeBleu_score": 69.08222267670335}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}\n", "CodeBleu_score": 69.08222267670335}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us)  if (time_in_us > 0) {\n    SetSleep();\n    TimerWakeUp(time_in_us);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_TIMER_CONTROL_REG,\n               Read8bit(AXP192_TIMER_CONTROL_REG) | 0x03);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_IRQ1_REG, Read8bit(AXP192_IRQ1_REG) | 0x08);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_IRQ3_REG, Read8bit(AXP192_IRQ3_REG) | 0x08);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_IRQ4_REG, Read8bit(AXP192_IRQ4_REG) | 0x08);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_IRQ5_REG, Read8bit(AXP192_IRQ5_REG) | 0x08);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_IRQ6_REG, Read8bit(AXP192_IRQ6_REG) | 0x08);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_IRQ7_REG, Read8bit(AXP192_IRQ7_REG) | 0x08);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_IRQ8_REG, Read8bit(AXP192_IRQ8_REG) | 0x08);\n    // Enable the timer wakeup source\n    Write1Byte(AXP192_IRQ9_REG, Read8bit(AXP192_IRQ9_REG) | 0x08);", "CodeBleu_score": 40.53357731513852}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)    SetSleep();\n    if (time_in_us == 0) {\n        // Disable timer wakeup source\n        Write1Byte(AXP192_INTEN3, 0x00);\n        Write1Byte(AXP192_INTEN4, 0x00);\n    } else {\n        // Enable timer wakeup source\n        Write1Byte(AXP192_INTEN3, 0x80);\n        Write1Byte(AXP192_INTEN4, 0x00);\n\n        // Calculate time in seconds\n        uint8_t t = (time_in_us / 1000000);\n\n        // Set timer wakeup time\n        Write1Byte(AXP192_TIMER_CTL, 0x80);\n        Write1Byte(AXP192_TIMER_CTL, t);\n    }\n\n    // Initiate deep sleep\n    Write1Byte(AXP192_PWRCTL, 0x04);\n}\n", "CodeBleu_score": 36.316328981946036}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)  SetSleep();\n  if (time_in_us > 0) {\n    timer.EnableTimerWakeUp(time_in_us);\n  } else {\n    timer.DisableTimerWakeUp();\n  }\n  System.DeepSleep();\n}\n", "CodeBleu_score": 38.83856954550129}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)  int y = this->start_y;\n  this->start_y += this->font_height;\n  if (this->start_y >= this->height - this->bottom_fixed_area) {\n    this->start_y = this->top_fixed_area;\n  }\n  this->fill_rect(0, y, this->width, this->font_height, color);\n  this->update_scroll_address(this->start_y);\n  return y;\n}\n", "CodeBleu_score": 7.702979191154719}, {"code": "int Display::scroll_line(uint32_t color)  int y = _start_y;\n  fill_rect(0, y, _width, _line_height, color);\n  _start_y += _line_height;\n  if (_start_y > _height - _line_height - _bottom_fixed_area) {\n    _start_y = _top_fixed_area;\n  }\n  update_scroll_address();\n  return y;\n}\n", "CodeBleu_score": 16.22386353940112}, {"code": "int Display::scroll_line(uint32_t color)  uint32_t y = _y;\n  fill_rect(0, y, _width, _height, color);\n  _y += _font_height;\n  if (_y >= _height - _bottom_fixed_area) {\n    _y = _top_fixed_area;\n  }\n  set_scroll_address();\n  return y;\n}\n", "CodeBleu_score": 16.203635312125012}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  bool success = true;\n\n  success = success && setAccessPoints(access_points);\n  success = success && setHTMLContent(ssids);\n\n  if (success) {\n    start();\n  }\n\n  return success;\n}\n", "CodeBleu_score": 47.58259170077642}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\tif (!setAccessPoints(access_points)) {\n\t\treturn false;\n\t}\n\n\tif (!setHTMLContent(ssids)) {\n\t\treturn false;\n\t}\n\n\tstart();\n\treturn true;\n}\n", "CodeBleu_score": 56.16228443253206}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if (!setSSIDs(ssids)) return false;\n  if (!setHTML(access_points)) return false;\n  return start();\n}\n", "CodeBleu_score": 53.84493535835364}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue()  if (queue_enabled_flag) {\n    if (queue_flag) {\n      queue_flag = false;\n    }\n    if (queue.size() > 0) {\n      queue.clear();\n    }\n    if (text.size() > 0) {\n      text.clear();\n    }\n    if (text_in.size() > 0) {\n      text_in.clear();\n    }\n  } else {\n    queue_enabled_flag = true;\n  }\n}\n", "CodeBleu_score": 15.443927637312285}, {"code": "void GpsInterface::enable_queue()  if (queue_enabled_flag) {\n    // If the queue is already enabled, ensure that the queue, text, and text_in are initialized.\n    if (queue == NULL) {\n      queue = new QueueHandle_t;\n      *queue = xQueueCreate(1, sizeof(char));\n    }\n    if (text == NULL) {\n      text = new char*;\n      *text = (char*)malloc(sizeof(char) * GPS_BUFFER_SIZE);\n    }\n    if (text_in == NULL) {\n      text_in = new char*;\n      *text_in = (char*)malloc(sizeof(char) * GPS_BUFFER_SIZE);\n    }\n  } else {\n    // If the queue is not enabled, flush the existing queue and set the queue_enabled_flag to true.\n    if (queue != NULL) {\n      vQueueDelete(*queue);\n      delete queue;\n      queue = NULL;\n    }\n    if (text != NULL) {\n      free(*text);\n      delete text;\n      text = NULL;\n    }\n    if (text_in != NULL) {\n      free(*text_in);\n      delete text_in;\n      text_in = NULL;\n    }\n    queue_enabled_flag = true;\n  }\n}\n", "CodeBleu_score": 9.018214869744714}, {"code": "void GpsInterface::enable_queue()  if (queue_enabled_flag) {\n    if (queue_text_flag) {\n      if (queue.size() > 0) {\n        queue.clear();\n        queue_text_flag = false;\n      }\n    }\n    else {\n      queue_text_flag = true;\n    }\n  }\n  else {\n    queue_enabled_flag = true;\n    queue_text_flag = true;\n  }\n}\n", "CodeBleu_score": 15.180192728694921}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea()    if (this->nmea_queue != NULL) {\n        this->nmea_queue->clear();\n        delete this->nmea_queue;\n        this->nmea_queue = new std::queue<std::string>();\n    } else {\n        this->nmea_queue = new std::queue<std::string>();\n    }\n}\n", "CodeBleu_score": 21.534878852379233}, {"code": "void GpsInterface::flush_queue_nmea()    if (queue_nmea != NULL) {\n        delete queue_nmea;\n        queue_nmea = new std::queue<std::string>();\n    } else {\n        queue_nmea = new std::queue<std::string>();\n    }\n}\n", "CodeBleu_score": 41.32078954608458}, {"code": "void GpsInterface::flush_queue_nmea()\tif (queue_nmea != NULL) {\n\t\twhile (!queue_nmea->empty()) {\n\t\t\tqueue_nmea->pop();\n\t\t}\n\t\tdelete queue_nmea;\n\t\tqueue_nmea = new std::queue<std::string>();\n\t} else {\n\t\tqueue_nmea = new std::queue<std::string>();\n\t}\n}\n", "CodeBleu_score": 36.36064724851021}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    uint32_t size = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n    uint8_t *buf = (uint8_t *)malloc(size * sizeof(uint8_t));\n    if (buf == NULL) {\n      Serial.println(\"malloc failed\");\n      while (1);\n    }\n    for (int i = 0; i < size; i++) {\n      buf[i] = (uint8_t)((color_p->full & 0xFF00) >> 8);\n      color_p++;\n    }\n    tft.startWrite();\n    tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    tft.pushColors(buf, size, true);\n    tft.endWrite();\n    free(buf);\n    lv_disp_flush_ready(disp);\n  }\n", "CodeBleu_score": 58.04431602667}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    // Set the address window to the specified area\n    tft.startWrite();\n    tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1));\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n      for (int x = area->x1; x <= area->x2; x++) {\n        // Write the corresponding color from the provided color buffer\n        tft.writePixel(color_p->full);\n        // Increment the color buffer\n        color_p++;\n      }\n    }\n    // End the write transaction\n    tft.endWrite();\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }\n\n  /*\n   * The function \"my_touch_read\" reads the touchpad values and stores them in the specified variable.\n   */\n  void my_touch_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data) {\n    uint16_t touchX, touchY;\n    // Read the touchpad values\n    bool touched = tft.getTouch(&touchX, &touchY, 600);\n    // If the touchpad is touched, update the touchpad data\n    if (touched) {\n      data->state = LV_INDEV_STATE_PR;\n      data->point.x = touchX;\n      data->point.y = touchY;\n    } else {\n      data->state = LV_INDEV_STATE_REL;\n    }\n  }", "CodeBleu_score": 71.11464274251627}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    //lv_coord_t h_res = disp->rotated == 0 ? disp->hor_res : disp->ver_res;\n    //lv_coord_t v_res = disp->rotated == 0 ? disp->ver_res : disp->hor_res;\n    //lv_coord_t h_res = disp->hor_res;\n    //lv_coord_t v_res = disp->ver_res;\n    //lv_coord_t x = area->x1;\n    //lv_coord_t y = area->y1;\n    //lv_coord_t w = lv_area_get_width(area);\n    //lv_coord_t h = lv_area_get_height(area);\n    //lv_color_t color;\n    //lv_coord_t x_end = x + w - 1;\n    //lv_coord_t y_end = y + h - 1;\n    //lv_coord_t x_index_max = disp->rotated == 0 ? x_end : y_end;\n    //lv_coord_t y_index_max = disp->rotated == 0 ? y_end : x_end;\n    //lv_coord_t x_index_min = disp->rotated == 0 ? x : y;\n    //lv_coord_t y_index_min = disp->rotated == 0 ? y : x;\n    //lv_coord_t x_index_t;\n    //lv_coord_t y_index_t;\n    //lv_coord_t x_t;\n    //lv_coord_t y_t;\n    //lv_coord_t x_r;\n    //lv_coord_t y_r;\n    //lv_coord_t x_r_start = 0;\n    //lv_coord_t y_r_start = 0;\n    //lv_coord_t x_r_end = 0;\n    //lv_coord_t y_r_end = 0;\n    //lv_coord_t x_r_", "CodeBleu_score": 3.3979555216869204}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    if (menu == NULL) {\n        return;\n    }\n\n    for (int i = 0; i < menu->getNumberOfNodes(); i++) {\n        MenuNode * node = menu->getNode(i);\n        if (node != NULL) {\n            for (int j = 0; j < layer; j++) {\n                Serial.print(\"--\");\n            }\n            Serial.println(node->getName());\n            showMenuList(node->getSubMenu(), layer + 1);\n        }\n    }\n    Serial.println();\n}\n", "CodeBleu_score": 53.38464709422796}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    for (int i = 0; i < menu->getMenuNodesCount(); i++) {\n        MenuNode * node = menu->getMenuNode(i);\n        for (int j = 0; j < layer; j++) {\n            Serial.print(\"    \");\n        }\n        Serial.println(node->getName());\n        if (node->getMenu() != NULL) {\n            showMenuList(node->getMenu(), layer + 1);\n        }\n    }\n    Serial.println();\n}\n", "CodeBleu_score": 54.770343424246434}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    for (int i = 0; i < menu->getLength(); i++) {\n        if (menu->getChild(i)->getType() == MENU_TYPE) {\n            for (int j = 0; j < layer; j++) {\n                Serial.print(\"  \");\n            }\n            Serial.println(menu->getChild(i)->getName());\n            showMenuList(menu->getChild(i), layer + 1);\n        }\n        else {\n            for (int j = 0; j < layer; j++) {\n                Serial.print(\"  \");\n            }\n            Serial.println(menu->getChild(i)->getName());\n        }\n    }\n    Serial.println();\n}\n", "CodeBleu_score": 53.85356199956358}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count)  for (int i = 0; i < count; i++) {\n    String ssid = generateRandomSSID();\n    ssids.add(ssid);\n    Serial.println(ssid);\n  }\n  return ssids.size();\n}\n", "CodeBleu_score": 23.52179481400198}, {"code": "int WiFiScan::generateSSIDs(int count)  for (int i = 0; i < count; i++) {\n    char ssid[7];\n    randomSSID(ssid);\n    Serial.println(ssid);\n    ssids.push_back(ssid);\n  }\n  return count;\n}\n", "CodeBleu_score": 20.774966807305294}, {"code": "int WiFiScan::generateSSIDs(int count)  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += (char)random(48, 122);\n    }\n    ssidList.add(new SSID(ssid, random(1, 15), randomMAC()));\n    Serial.println(ssidList.get(i).toString());\n  }\n  return count;\n}\n", "CodeBleu_score": 37.532664146263265}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n    # [START pubsub_quickstart_create_topic]\n    # TODO(developer)\n    # project_id = \"Your Google Cloud Project ID\"\n    # topic_name = \"Your Pub/Sub topic name\"\n\n    from google.cloud import pubsub_v1\n\n    # Initialize a Publisher client.\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the full topic path.\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic.\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Created topic: {topic}\")\n    # [END pubsub_quickstart_create_topic]\n    return topic\n\n", "CodeBleu_score": 67.95197765022509}, {"code": "def create_topic(project_id, topic_name)\n    # [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    # TODO(developer)\n    # project_id = \"your-project-id\"\n    # topic_name = \"your-topic-name\"\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(\"Topic created: {}\".format(topic))\n    # [END pubsub_create_topic]\n    return topic\n\n", "CodeBleu_score": 75.91364902390401}, {"code": "def create_topic(project_id, topic_name)\n    import os\n    from google.cloud import pubsub_v1\n\n    # TODO(developer)\n    # project_id = \"your-project-id\"\n    # topic_name = \"your-topic-name\"\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Topic created: {topic}\")\n    return topic\n\n", "CodeBleu_score": 76.33710865516453}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    import time\n    import jwt\n    import json\n\n    # Read the private key from the file.\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Set issued at time to current UTC time and expiration time to one hour later.\n    iat = time.time()\n    exp = iat + 3600\n\n    # Create the JWT.\n    token = jwt.encode(\n        {\n            \"iat\": iat,\n            \"exp\": exp,\n            \"aud\": project_id,\n        },\n        private_key,\n        algorithm=algorithm,\n    )\n\n    return token\n\n", "CodeBleu_score": 44.79190420711415}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n    import datetime\n    import json\n    import jwt\n\n    # The current time in UTC\n    now = datetime.datetime.utcnow()\n\n    # The expiration time in UTC\n    exp = now + datetime.timedelta(hours=1)\n\n    # The payload of the JWT\n    payload = {\n        'iat': now,\n        'exp': exp,\n        'aud': project_id\n    }\n\n    # The encoded JWT\n    encoded_jwt = jwt.encode(payload, open(private_key_file, 'r').read(), algorithm=algorithm)\n\n    return encoded_jwt\n\n", "CodeBleu_score": 41.05720990776498}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    import time\n    import jwt\n\n    # Set issued time (iat) to current UTC time\n    iat = time.time()\n\n    # Set expiration time (exp) to one hour later\n    exp = iat + 3600\n\n    # Set audience (aud) to the provided GCP project ID\n    aud = project_id\n\n    # Read private key from the specified file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create JWT\n    jwt_token = jwt.encode(\n        {\n            'iat': iat,\n            'exp': exp,\n            'aud': aud\n        },\n        private_key,\n        algorithm=algorithm\n    )\n\n    return jwt_token\n\n", "CodeBleu_score": 48.89691530618618}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n    payload = message.payload.decode(\"utf-8\")\n    topic = message.topic\n    qos = message.qos\n\n    print(\"Received message: {}\".format(payload))\n    print(\"Topic: {}\".format(topic))\n    print(\"QoS: {}\".format(qos))\n\n    if payload == \"on\":\n        print(\"Capturing preview image...\")\n        import cv2\n        import time\n        import datetime\n        import os\n        import sys\n        import json\n        import requests\n        from google.cloud import storage\n        from google.oauth2 import service_account\n\n        # Get the current working directory\n        cwd = os.getcwd()\n\n        # Set the current working directory to the location of this file\n        os.chdir(os.path.dirname(os.path.abspath(__file__)))\n\n        # Load the configuration file\n        with open(\"config.json\", \"r\") as f:\n            config = json.load(f)\n\n        # Set the current working directory back to its original location\n        os.chdir(cwd)\n\n        # Set the current date and time\n        now = datetime.datetime.now()\n\n        # Set the current date and time in the format YYYY-MM-DD-HH-MM-SS\n        now_str = now.strftime(\"%Y-%m-%d-%H-%M-%S\")\n\n        # Set the name of the file\n        file_name = \"preview.jpg\"\n\n        # Set the path to the file\n        file_path = os.path.join(cwd, file_name)\n\n        # Set the path to the file\n        file_path = os.path.join(cwd, file_name)\n\n        # Set the path to the file\n        file_path = os.path.join(cwd, file_name)\n\n        # Set the path to the file\n        file_path = os.path.join(cwd, file_name)\n\n        # Set the path to the file\n        file_path = os.path.join(cwd, file_name)\n\n        # Set the path to the file\n        file_path = os.path.join", "CodeBleu_score": 35.80957113083525}, {"code": "def on_message(unused_client, unused_userdata, message)\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Received message: \\\"{}\\\" on topic: \\\"{}\\\" with Qos: {}\".format(\n        payload, message.topic, str(message.qos)))\n    if payload == \"on\":\n        import os\n        import time\n        import picamera\n        from google.cloud import storage\n        from google.cloud.storage.blob import Blob\n        from google.oauth2 import service_account\n        from google.cloud import pubsub_v1\n\n        # Set the GCP project ID\n        project_id = \"pi-iot-demo-1\"\n\n        # Set the name of the bucket that will store the images\n        bucket_name = \"pi-iot-demo-1-bucket\"\n\n        # Set the name of the topic that will be published to\n        topic_name = \"pi-iot-demo-1-topic\"\n\n        # Set the name of the service account credentials file\n        credentials_file = \"pi-iot-demo-1-07557347a267.json\"\n\n        # Set the name of the file to be uploaded\n        file_name = \"preview.jpg\"\n\n        # Set the path to the file to be uploaded\n        file_path = os.path.join(os.path.dirname(__file__), file_name)\n\n        # Set the path to the camera\n        camera_path = \"/dev/video0\"\n\n        # Set the camera resolution\n        camera_resolution = (640, 480)\n\n        # Set the camera framerate\n        camera_framerate = 24\n\n        # Set the camera rotation\n        camera_rotation = 0\n\n        # Set the camera ISO\n        camera_iso = 0\n\n        # Set the camera shutterspeed\n        camera_shutterspeed = 0\n\n        # Set the camera contrast\n        camera_contrast = 0\n\n        # Set the camera brightness\n        camera_brightness = 50\n\n        # Set the camera saturation\n        camera_saturation = 0\n\n        # Set the number of camera warmup frames\n        camera_", "CodeBleu_score": 37.44779545358204}, {"code": "def on_message(unused_client, unused_userdata, message)\n    payload = message.payload.decode(\"utf-8\")\n    print(\"Message received: {}\".format(payload))\n    print(\"Topic: {}\".format(message.topic))\n    print(\"QoS: {}\".format(message.qos))\n    if payload == \"on\":\n        import cv2\n        import os\n        import time\n        import paho.mqtt.client as mqtt\n        from google.cloud import storage\n\n        # Set the GCP project name\n        project_name = \"YOUR_GCP_PROJECT_NAME\"\n\n        # Set the bucket name\n        bucket_name = \"YOUR_BUCKET_NAME\"\n\n        # Set the MQTT topic name\n        mqtt_topic_name = \"YOUR_MQTT_TOPIC_NAME\"\n\n        # Set the MQTT event topic name\n        mqtt_event_topic_name = \"YOUR_MQTT_EVENT_TOPIC_NAME\"\n\n        # Set the MQTT server name\n        mqtt_server_name = \"YOUR_MQTT_SERVER_NAME\"\n\n        # Set the MQTT server port\n        mqtt_server_port = \"YOUR_MQTT_SERVER_PORT\"\n\n        # Set the MQTT client ID\n        mqtt_client_id = \"YOUR_MQTT_CLIENT_ID\"\n\n        # Set the MQTT username\n        mqtt_username = \"YOUR_MQTT_USERNAME\"\n\n        # Set the MQTT password\n        mqtt_password = \"YOUR_MQTT_PASSWORD\"\n\n        # Set the MQTT keepalive\n        mqtt_keepalive = \"YOUR_MQTT_KEEPALIVE\"\n\n        # Set the MQTT tls version\n        mqtt_tls_version = \"YOUR_MQTT_TLS_VERSION\"\n\n        # Set the MQTT client cert file\n        mqtt_client_cert_file = \"YOUR_MQTT_CLIENT_CERT_FILE\"\n\n        # Set the MQTT client key file\n        mqtt_client_key_file", "CodeBleu_score": 27.684118969252978}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n\n    import argparse\n    import os\n\n    parser = argparse.ArgumentParser(description='Google Cloud IoT Core MQTT example.')\n    parser.add_argument('--project_id', default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n                        help='GCP cloud project name')\n    parser.add_argument('--registry_id', required=True, help='Cloud IoT Core registry id')\n    parser.add_argument('--device_id', required=True, help='Cloud IoT Core device id')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), default='RS256', help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--ca_certs', default='roots.pem', help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument('--mqtt_bridge_hostname', default='mqtt.googleapis.com', help='MQTT bridge hostname.')\n    parser.add_argument('--mqtt_bridge_port', choices=(8883, 443), default=8883, type=int, help='MQTT bridge port.')\n    parser.add_argument('--jwt_expires_minutes', default=20, type=int, help='Expiration time, in minutes, for JWT tokens.')\n\n    return parser.parse_args()\n", "CodeBleu_score": 55.327258570105286}, {"code": "def parse_command_line_args()\n    import argparse\n    import os\n\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT device connection example.\")\n    parser.add_argument(\"--project_id\", default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"), help=\"GCP cloud project name\")\n    parser.add_argument(\"--registry_id\", required=True, help=\"Cloud IoT Core registry id\")\n    parser.add_argument(\"--device_id\", required=True, help=\"Cloud IoT Core device id\")\n    parser.add_argument(\"--private_key_file\", required=True, help=\"Path to private key file.\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), default=\"RS256\", help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\"--ca_certs\", default=\"roots.pem\", help=\"CA root from https://pki.google.com/roots.pem\")\n    parser.add_argument(\"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", choices=(8883, 443), default=8883, type=int, help=\"MQTT bridge port.\")\n    parser.add_argument(\"--jwt_expires_minutes\", default=20, type=int, help=\"Expiration time, in minutes, for JWT tokens.\")\n\n    return parser.parse_args()", "CodeBleu_score": 53.84767161128151}, {"code": "def parse_command_line_args()\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT Core MQTT example.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\n        \"--registry_id\", required=True, help=\"Cloud IoT Core registry id\"\n    )\n    parser.add_argument(\n        \"--device_id\", required=True, help=\"Cloud IoT Core device id\"\n    )\n    parser.add_argument(\n        \"--private_key_file\", required=True, help=\"Path to private key file.\"\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        default=\"RS256\",\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n    )\n    parser.add_argument(\n        \"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        default=\"roots.pem\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n    )\n    parser.add_argument(\n        \"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\"\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        default=\"event\",\n        help=\"Indicates whether the message to be published is a telemetry event or a device state message.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        default=\"mqtt.googleapis.com\",\n        help=\"MQTT bridge hostname.\",\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\", default=8883, help=\"MQTT bridge port.\"\n    )\n    return parser.parse_args()\n", "CodeBleu_score": 39.0983684646366}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n    # Import the Google API Python client library\n    from googleapiclient import discovery\n    # Import the Google OAuth2 client library\n    from oauth2client.service_account import ServiceAccountCredentials\n\n    # Define the API scopes\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Define the discovery URL\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials\n    credentials = ServiceAccountCredentials.from_json_keyfile_name(service_account_json, scopes)\n\n    # Build the client\n    service = discovery.build(\n        'cloudiot',\n        'v1',\n        discoveryServiceUrl=discovery_url,\n        credentials=credentials,\n        cache_discovery=False)\n\n    return service\n\n", "CodeBleu_score": 49.716305058152756}, {"code": "def get_client(service_account_json)\n    from googleapiclient.discovery import build\n    from google.oauth2 import service_account\n\n    scopes = [\n        \"https://www.googleapis.com/auth/cloud-platform\",\n        \"https://www.googleapis.com/auth/cloudiot\",\n    ]\n    discovery_url = \"https://cloudiot.googleapis.com/$discovery/rest\"\n\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes\n    )\n\n    return build(\"cloudiot\", \"v1\", credentials=credentials, discoveryServiceUrl=discovery_url)\n\n", "CodeBleu_score": 35.76428377385053}, {"code": "def get_client(service_account_json)\n\n    from googleapiclient import discovery\n    from oauth2client.service_account import ServiceAccountCredentials\n\n    # Define the necessary API scopes\n    scopes = [\n        'https://www.googleapis.com/auth/cloud-platform',\n        'https://www.googleapis.com/auth/cloudiot'\n    ]\n\n    # Define the version of the API\n    version = 'v1'\n\n    # Define the discovery URL\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials\n    credentials = ServiceAccountCredentials.from_json_keyfile_name(service_account_json, scopes=scopes)\n\n    # Build and return the client for the Cloud IoT Core service\n    return discovery.build(\n        'cloudiot',\n        version,\n        discoveryServiceUrl=discovery_url,\n        credentials=credentials,\n        cache_discovery=False\n    )\n\n", "CodeBleu_score": 40.31205254434036}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n\n    # Importing required modules to the function\n    import hashlib\n    import asn1tools\n    from cryptography.hazmat.primitives.asymmetric import padding\n    from cryptography.hazmat.primitives import hashes\n    from cryptography.hazmat.primitives.asymmetric import utils\n    from cryptography.hazmat.primitives import serialization\n    from cryptography.hazmat.backends import default_backend\n    from cryptography.hazmat.primitives.asymmetric import rsa\n\n    # Defining the ASN1 code for the hash method\n    hash_method_asn1 = {\n        \"sha256\": \"3031300d060960864801650304020105000420\",\n        \"sha384\": \"3041300d060960864801650304020205000430\",\n        \"sha512\": \"3051300d060960864801650304020305000440\"\n    }\n\n    # Checking if the hash method is valid\n    if hash_method not in hash_method_asn1:\n        raise ValueError(\"Invalid hash method\")\n\n    # Retrieving the ASN1 code for the hash method\n    hash_method_asn1 = hash_method_asn1[hash_method]\n\n    # Encoding the hash value as a byte block\n    hash_value = hash_value.encode()\n\n    # Concatenating the ASN1 code with the hash value\n    hash_value = hash_method_asn1 + hash_value.hex()\n\n    # Decoding the concatenated hash value from a hex string to a byte block\n    hash_value = bytes.fromhex(hash_value)\n\n    # Encoding the private key as a byte block\n    priv_key = priv_key.encode()\n\n    # Loading the private key from the byte block", "CodeBleu_score": 34.19690651845767}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    from Crypto.Hash import SHA256, SHA512, MD5\n    from Crypto.PublicKey import RSA\n    from Crypto.Signature import PKCS1_v1_5\n    from Crypto.Util import asn1\n    import binascii\n\n    if hash_method == \"SHA256\":\n        asn1_code = asn1.DerSequence([asn1.DerObjectId(\"1.3.14.3.2.26\"), asn1.DerNull()])\n        hash_object = SHA256.new(hash_value)\n    elif hash_method == \"SHA512\":\n        asn1_code = asn1.DerSequence([asn1.DerObjectId(\"2.16.840.1.101.3.4.2.3\"), asn1.DerNull()])\n        hash_object = SHA512.new(hash_value)\n    elif hash_method == \"MD5\":\n        asn1_code = asn1.DerSequence([asn1.DerObjectId(\"1.2.840.113549.2.5\"), asn1.DerNull()])\n        hash_object = MD5.new(hash_value)\n    else:\n        raise ValueError(\"Invalid hash method\")\n\n    asn1_code_bytes = asn1_code.encode()\n    hash_value_bytes = hash_object.digest()\n\n    hash_value_bytes_padded = PKCS1_v1_5.pad(asn1_code_bytes + hash_value_bytes, RSA.size(priv_key))\n    signature_bytes = priv_key._decrypt(hash_value_bytes_padded)\n\n    return signature_bytes\n\n", "CodeBleu_score": 33.596569931436306}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    import hashlib\n    import asn1tools\n    import rsa\n\n    if hash_method == \"SHA-1\":\n        asn1_code = asn1tools.compile_string(\n            \"\"\"\n        DigestInfo ::= SEQUENCE {\n            digestAlgorithm AlgorithmIdentifier,\n            digest OCTET STRING\n        }\n\n        AlgorithmIdentifier ::= SEQUENCE {\n            algorithm OBJECT IDENTIFIER,\n            parameters ANY DEFINED BY algorithm OPTIONAL\n        }\n        \"\"\"\n        ).get(\"DigestInfo\")\n        asn1_code_hash = asn1_code.encode(\n            {\n                \"digestAlgorithm\": {\n                    \"algorithm\": \"1.3.14.3.2.26\",\n                    \"parameters\": None,\n                },\n                \"digest\": hash_value,\n            }\n        )\n    elif hash_method == \"SHA-256\":\n        asn1_code = asn1tools.compile_string(\n            \"\"\"\n        DigestInfo ::= SEQUENCE {\n            digestAlgorithm AlgorithmIdentifier,\n            digest OCTET STRING\n        }\n\n        AlgorithmIdentifier ::= SEQUENCE {\n            algorithm OBJECT IDENTIFIER,\n            parameters ANY DEFINED BY algorithm OPTIONAL\n        }\n        \"\"\"\n        ).get(\"DigestInfo\")\n        asn1_code_hash = asn1_code.encode(\n            {\n                \"digestAlgorithm\": {\n                    \"algorithm\": \"2.16.840.1.101.3.4.2.1\",\n                    \"parameters\": None,\n                },\n                \"digest\": hash_value,\n            }\n        )\n    elif hash_method == \"SHA-384\":\n        asn1_code = asn1tools.compile_string(\n            \"\"\"\n        DigestInfo ::= SEQUENCE {\n            digestAlgorithm AlgorithmIdentifier,\n            digest OCTET STRING\n        }\n\n        AlgorithmIdentifier ::= SEQUENCE {\n            algorithm OBJECT IDENTIFI", "CodeBleu_score": 20.164756728044793}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n    # Convert signature to integer\n    sig = int.from_bytes(signature, byteorder='big')\n    # Decrypt signature\n    clear_sig = decrypt(sig, pub_key)\n    # Determine hash method used\n    hash_method = determine_hash_method(clear_sig)\n    # Compute hash of message\n    hash_message = hash_method(message)\n    # Reconstruct padded hash\n    padded_hash = pad_hash(hash_message, hash_method)\n    # Check if clear signature matches padded hash\n    if clear_sig == padded_hash:\n        return hash_method.__name__\n    else:\n        raise VerificationError('Signature does not match message')", "CodeBleu_score": 14.554708223884477}, {"code": "def verify(message, signature, pub_key)\n    # Convert signature to integer\n    signature = int(signature, 16)\n    # Decrypt signature\n    clear_signature = pow(signature, pub_key.e, pub_key.n)\n    # Determine the hash method used\n    hash_method = get_hash_method(clear_signature)\n    # Compute the hash of the message\n    message_hash = hash_method(message).hexdigest()\n    # Reconstruct the expected padded hash\n    padded_hash = pad_hash(message_hash, hash_method)\n    # Verify the signature\n    if padded_hash != clear_signature:\n        raise VerificationError(\"Signature verification failed\")\n    return hash_method.__name__\n\n", "CodeBleu_score": 21.102736010264106}, {"code": "def verify(message, signature, pub_key)\n    # Convert the signature to an integer\n    signature = int(signature, 16)\n    # Decrypt the signature to obtain the clear signature\n    clear_signature = pow(signature, pub_key.e, pub_key.n)\n    # Determine the hash method used\n    if clear_signature < pub_key.n - 256:\n        hash_method = 'sha256'\n    elif clear_signature < pub_key.n - 256 ** 2:\n        hash_method = 'sha512'\n    else:\n        raise ValueError('Invalid signature.')\n    # Compute the hash of the message\n    hash_message = hashlib.new(hash_method, message.encode()).hexdigest()\n    # Reconstruct the expected padded hash\n    padded_hash = '{}{}'.format(\n        '0' * (len(hash_method) + 2),\n        hash_message\n    )\n    # Convert the padded hash to an integer\n    padded_hash = int(padded_hash, 16)\n    # If the expected padded hash does not match the clear signature, raise a verification error\n    if padded_hash != clear_signature:\n        raise ValueError('Invalid signature.')\n    # If the verification is successful, return the hash method name\n    return hash_method", "CodeBleu_score": 31.37409391849455}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT()  time_t now = time(NULL);\n  if (now > 0) {\n    Serial.printf(\"now: %d\\n\", now);\n    jwt = createJWT(now + JWT_EXPIRATION_SECONDS);\n    Serial.printf(\"jwt: %s\\n\", jwt.c_str());\n  }\n  connectMQTTClient();\n  mqttSubscribe = true;\n  Serial.printf(\"Connecting to MQTT server %s:%d\\n\", MQTT_SERVER, MQTT_PORT);\n}\n", "CodeBleu_score": 49.98015493954647}, {"code": "static void connectMQTT()  time_t now = time(NULL);\n  if (now > 0) {\n    Serial.printf(\"Current time: %d\\n\", now);\n    getJWT(now);\n  }\n  connectMQTTClient();\n  mqttConnect = true;\n  Serial.println(\"Connecting to MQTT...\");\n}\n", "CodeBleu_score": 50.15738908609284}, {"code": "static void connectMQTT()  time_t now = time(nullptr);\n  if (now > 0) {\n    Serial.println(\"MQTT: Updating JWT with current UNIX time\");\n    updateJWT(now);\n  }\n  Serial.println(\"MQTT: Connecting...\");\n  client.connect();\n  mqttConnected = true;\n}\n", "CodeBleu_score": 49.236176166142336}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    *num = 0;\n    for (int i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        *num = *num * 10 + (str[i] - '0');\n    }\n    return str + width;\n}\n", "CodeBleu_score": 20.779671883105237}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t n = 0;\n\tfor (int i = 0; i < width; i++) {\n\t\tif (str[i] >= '0' && str[i] <= '9') {\n\t\t\tn = n * 10 + str[i] - '0';\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n\t*num = n;\n\treturn str + width;\n}\n", "CodeBleu_score": 19.92273908037174}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t val = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (str[i] >= '0' && str[i] <= '9') {\n            val = val * 10 + str[i] - '0';\n        } else {\n            return str;\n        }\n    }\n    *num = val;\n    return str + width;\n}\n", "CodeBleu_score": 20.43229314057361}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)  int ret = 0;\n\n  if (build_state == NULL) {\n    return ATCACERT_E_BAD_PARAMS;\n  }\n\n  // Calculate the total size of the certificate\n  build_state->cert_size = build_state->cert_loc.end_pos;\n\n  return ret;\n}\n", "CodeBleu_score": 31.349507238027453}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    int ret = 0;\n\n    if (build_state == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    if (build_state->cert_def->cert_elements == NULL || build_state->cert_elements == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Finish up the cert\n    if (build_state->cert_def->cert_elements[build_state->cert_elements_count].id == CERT_ELEM_SIGNATURE) {\n        // Signature\n        ret = atcacert_get_device_locs(build_state->cert_def, &build_state->cert_elements[build_state->cert_elements_count].device_locs);\n        if (ret != ATCACERT_E_SUCCESS) {\n            return ret;\n        }\n        build_state->cert_elements[build_state->cert_elements_count].device_locs.count = 1;\n        build_state->cert_elements[build_state->cert_elements_count].device_locs.locs[0].zone = DEVZONE_DATA;\n        build_state->cert_elements[build_state->cert_elements_count].device_locs.locs[0].slot = 0;\n        build_state->cert_elements[build_state->cert_elements_count].device_locs.locs[0].is_genkey = 0;\n        build_state->cert_elements[build_state->cert_elements_count].device_locs.locs[0].offset = 0;\n        build_state->cert_elements[build_state->cert_elements_count].device_locs.locs[0].count = 64;\n        build_state->cert_elements[build_state->cert_elements_count].device_locs.locs[0].block = 0;\n\n        build_state->cert_elements[build_state->cert_elements_count].offset = build_state->cert_elements_count == 0 ? 0 : build_state->cert_elements", "CodeBleu_score": 53.000045431757314}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)  int ret = 0;\n  uint8_t is_device_loc_set = 0;\n  uint8_t is_device_sn_set = 0;\n  uint8_t is_signer_loc_set = 0;\n  uint8_t is_signer_sn_set = 0;\n  uint8_t is_cert_sn_set = 0;\n  uint8_t is_public_key_set = 0;\n  uint8_t is_comp_cert_set = 0;\n  uint8_t is_std_cert_set = 0;\n  uint8_t is_signer_id_set = 0;\n  uint8_t is_cert_element_set = 0;\n  uint8_t is_cert_sn_src_set = 0;\n  uint8_t is_issue_date_set = 0;\n  uint8_t is_expire_date_set = 0;\n  uint8_t is_signer_id_src_set = 0;\n  uint8_t is_tbs_hash_set = 0;\n  uint8_t is_sig_set = 0;\n  uint8_t is_cert_set = 0;\n  uint8_t is_cert_template_set = 0;\n  uint8_t is_device_loc_format_set = 0;\n  uint8_t is_signer_loc_format_set = 0;\n  uint8_t is_device_sn_format_set = 0;\n  uint8_t is_signer_sn_format_set = 0;\n  uint8_t is_cert_sn_format_set = 0;\n  uint8_t is_cert_sn_len_set = 0;\n  uint8_t is_cert_template_id_set = 0;\n  uint8_t is_cert_sn_digest_set = 0;\n  uint8_t is_cert_sn_source_flag_set = 0;\n  uint8_t is_cert_sn_min_set =", "CodeBleu_score": 8.953623961373195}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int                 ret = 0;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    atcacert_device_t   device;\n    atcacert_device_loc_t ca_public_key_loc;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_device_locs(cert_def, &ca_public_key_loc, NULL);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_read_device_loc(&ca_public_key_loc, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_device(&device);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_verify_cert_hw_p256(tbs_digest, signature, ca_public_key);\n\n    return ret;\n}\n", "CodeBleu_score": 71.00780058068166}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int                 ret = 0;\n    uint8_t             tbs_digest[32];\n    uint8_t             signature[64];\n    atcacert_verify_ctx ctx;\n\n    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_verify_start(&ctx, ca_public_key, tbs_digest, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_verify_is_verified(&ctx);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}\n", "CodeBleu_score": 75.4361521147692}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int                      ret = 0;\n    size_t                   tbs_digest_size = 32;\n    size_t                   signature_size = 64;\n    uint8_t                  tbs_digest[32];\n    uint8_t                  signature[64];\n    atcacert_device_loc_t    cert_sn_dev_loc;\n    uint8_t                  cert_sn[9];\n    uint8_t                  cert_sn_full[32];\n    uint8_t                  cert_sn_is_device_sn;\n    uint8_t                  cert_sn_is_device_sn_full;\n    atcacert_device_loc_t    ca_public_key_dev_loc;\n    uint8_t                  ca_public_key_slot;\n    uint8_t                  ca_public_key_slot_full;\n    uint8_t                  ca_public_key_slot_is_genkey;\n    uint8_t                  ca_public_key_slot_is_genkey_full;\n    uint8_t                  ca_public_key_block;\n    uint8_t                  ca_public_key_block_full;\n    uint8_t                  ca_public_key_offset;\n    uint8_t                  ca_public_key_offset_full;\n    uint8_t                  ca_public_key_full[72];\n    uint8_t                  ca_public_key_full_size = sizeof(ca_public_key_full);\n    atcacert_device_loc_t    ca_public_key_dev_loc_full;\n    uint8_t                  ca_public_key_slot_full;\n    uint8_t                  ca_public_key_block_full;\n    uint8_t                  ca_public_key_offset_full;\n    uint8_t                  ca_public_key_full_size_full;\n    atcacert_device_loc_t    ca_public_key_dev_loc_full_full;", "CodeBleu_score": 13.761999675591413}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\ttimerStruct_t *current = *list;\n\ttimerStruct_t *previous = NULL;\n\twhile (current != NULL) {\n\t\tif (current == timer) {\n\t\t\tif (previous == NULL) {\n\t\t\t\t*list = current->next;\n\t\t\t} else {\n\t\t\t\tprevious->next = current->next;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\treturn false;\n}\n}\n", "CodeBleu_score": 32.42359259089261}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\ttimerStruct_t *curr = *list;\n\ttimerStruct_t *prev = NULL;\n\twhile (curr) {\n\t\tif (curr == timer) {\n\t\t\tif (prev == NULL) {\n\t\t\t\t*list = curr->next;\n\t\t\t} else {\n\t\t\t\tprev->next = curr->next;\n\t\t\t}\n\t\t\tfree(curr);\n\t\t\treturn true;\n\t\t}\n\t\tprev = curr;\n\t\tcurr = curr->next;\n\t}\n\treturn false;\n}\n}\n", "CodeBleu_score": 33.79561125506913}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{    timerStruct_t *temp = *list;\n    if (timer == *list) {\n        *list = timer->next;\n        return true;\n    }\n    while (temp != NULL) {\n        if (temp->next == timer) {\n            temp->next = timer->next;\n            return true;\n        }\n        temp = temp->next;\n    }\n    return false;\n}\n}\n", "CodeBleu_score": 30.732366453208048}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket)\tstruct socket *sock;\n\tint ret;\n\t\n\tsock = get_socket(socket);\n\tif (sock == NULL) {\n\t\terrno = EBADF;\n\t\treturn BSD_ERROR;\n\t}\n\t\n\tsock->state = NOT_A_SOCKET;\n\t\n\tret = close(sock->fd);\n\tif (ret == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\tsock->state = SOCKET_OPEN;\n\t\t\t\terrno = EBADF;\n\t\t\t\treturn BSD_ERROR;\n\t\t\tdefault:\n\t\t\t\tsock->state = SOCKET_OPEN;\n\t\t\t\treturn BSD_ERROR;\n\t\t}\n\t}\n\t\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 42.04211173505329}, {"code": "int BSD_close(int socket)\tstruct socket *sock;\n\tint ret;\n\n\tif (!(sock = get_socket(socket))) {\n\t\treturn BSD_ERROR;\n\t}\n\n\tsock->state = NOT_A_SOCKET;\n\n\tif ((ret = close(sock->fd)) < 0) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\terrno = ENOTSOCK;\n\t\t\t\tbreak;\n\t\t\tcase EINTR:\n\t\t\tcase EIO:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = BSD_ERROR;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 37.53248706422934}, {"code": "int BSD_close(int socket)    struct socket *sock;\n    int err;\n\n    sock = get_socket_by_fd(socket);\n    if (sock == NULL) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n\n    sock->state = NOT_A_SOCKET;\n\n    err = close(sock->fd);\n    if (err < 0) {\n        errno = err;\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 35.29007213284863}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog)\tif (listen(socket, backlog) == -1) {\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 16.880247065934935}, {"code": "int BSD_listen(int socket, int backlog)\tint response = listen(socket, backlog);\n\tif (response == -1) {\n\t\terrno = BSD_GetLastError();\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 11.612247462510483}, {"code": "int BSD_listen(int socket, int backlog)\tint response;\n\t\n\t/*\n\t * The \"listen\" function sets the socket to listen for incoming connections with a specified backlog.\n\t */\n\tresponse = listen(socket, backlog);\n\tif (response < 0) {\n\t\t/*\n\t\t * If the \"listen\" function returns a negative number, the function sets the appropriate error number and returns \"BSD_ERROR\".\n\t\t */\n\t\tswitch (errno) {\n\t\t\tcase EACCES:\n\t\t\t\terrno = E_BSD_SOCKET_ACCESS_DENIED;\n\t\t\t\tbreak;\n\t\t\tcase EADDRINUSE:\n\t\t\t\terrno = E_BSD_SOCKET_ADDRESS_IN_USE;\n\t\t\t\tbreak;\n\t\t\tcase EBADF:\n\t\t\t\terrno = E_BSD_SOCKET_BAD_FILE_DESCRIPTOR;\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\terrno = E_BSD_SOCKET_INVALID_ARGUMENT;\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\terrno = E_BSD_SOCKET_NOT_A_SOCKET;\n\t\t\t\tbreak;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\terrno = E_BSD_SOCKET_OPERATION_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terrno = E_BSD_SOCKET_UNKNOWN_ERROR;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\t\n\t/*\n\t * If no error occurs, the function returns \"BSD_SUCCESS\".\n\t */\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 39.59666908074643}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)    struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n    struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *) addr;\n    struct sockaddr_un *addr_un = (struct sockaddr_un *) addr;\n    int ret;\n    int err;\n    socklen_t len;\n\n    // Check the address family\n    switch (addr->sa_family) {\n        case AF_INET:\n            len = sizeof(struct sockaddr_in);\n            ret = accept(socket, (struct sockaddr *) addr_in, &len);\n            break;\n        case AF_INET6:\n            len = sizeof(struct sockaddr_in6);\n            ret = accept(socket, (struct sockaddr *) addr_in6, &len);\n            break;\n        case AF_UNIX:\n            len = sizeof(struct sockaddr_un);\n            ret = accept(socket, (struct sockaddr *) addr_un, &len);\n            break;\n        default:\n            errno = EAFNOSUPPORT;\n            return -1;\n    }\n\n    if (ret < 0) {\n        err = errno;\n        switch (err) {\n            case EBADF:\n                errno = ENOTSOCK;\n                break;\n            case ECONNABORTED:\n                errno = ECONNABORTED;\n                break;\n            case EINTR:\n                errno = EINTR;\n                break;\n            case EINVAL:\n                errno = EINVAL;\n                break;\n            case EMFILE:\n                errno = EMFILE;\n                break;\n            case ENFILE:\n                errno = ENFILE;\n                break;\n            case ENOBUFS:\n                errno = ENOBUFS;\n                break;\n            case ENOMEM:\n                errno = ENOMEM;\n                break;\n            case ENOTSOCK:\n                errno = ENOTSOCK;\n                break;\n            case EOPNOTSUPP:\n                errno = EOPNOTSUPP;", "CodeBleu_score": 36.48902556068641}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret = 0;\n\tstruct sockaddr_in *addr_in = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;\n\n\tif (addr->sa_family == AF_INET) {\n\t\tret = accept(socket, (struct sockaddr *)addr_in, addrlen);\n\t} else if (addr->sa_family == AF_INET6) {\n\t\tret = accept(socket, (struct sockaddr *)addr_in6, addrlen);\n\t} else {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\n\tif (ret < 0) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = ENOTSOCK;\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 30.477332608440065}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint retval;\n\tstruct sockaddr_in * sockaddr_in_ptr;\n\tstruct sockaddr_in6 * sockaddr_in6_ptr;\n\tstruct sockaddr_un * sockaddr_un_ptr;\n\tstruct sockaddr * sockaddr_ptr;\n\tstruct sockaddr_in sockaddr_in;\n\tstruct sockaddr_in6 sockaddr_in6;\n\tstruct sockaddr_un sockaddr_un;\n\tstruct sockaddr sockaddr;\n\n\t/* Check if the socket is created. */\n\tif (socket >= MAX_SOCKETS || socket_table[socket].state == STATE_CLOSED) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\t/* Check if the socket is listening. */\n\tif (socket_table[socket].state != STATE_LISTEN) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* Check if the address is valid. */\n\tif (addr == NULL) {\n\t\terrno = EFAULT;\n\t\treturn -1;\n\t}\n\n\t/* Check if the address length is valid. */\n\tif (addrlen == NULL) {\n\t\terrno = EFAULT;\n\t\treturn -1;\n\t}\n\n\t/* Check if the address length is valid. */\n\tif (*addrlen < 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* Check if the address is valid. */\n\tif (*addrlen < sizeof(struct bsd_sockaddr)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* Convert the socket address to a supported format. */\n\tswitch (addr->sa_family) {\n\t\tcase AF_INET:\n\t\t\t/* Check if the address length is valid. */\n\t\t\tif (*addrlen < sizeof(struct bsd_sockaddr_in)) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;", "CodeBleu_score": 35.57631033353103}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT()  if (timeStatus() != timeNotSet) {\n    long now = now();\n    long jwt_offset = (now - jwt_exp) / 1000;\n    jwt_exp = now / 1000 + 3600;\n    jwt = createJWT(jwt_exp, jwt_offset);\n    mqtt.setWill(topic, 0, true, \"offline\");\n    mqtt.connect(clientID, mqtt_user, jwt);\n    debug(\"Connecting to MQTT broker...\");\n  }\n  mqtt_connect = true;\n}\n", "CodeBleu_score": 44.494989043273506}, {"code": "static void connectMQTT()  Serial.println(\"Connecting to MQTT broker\");\n  time_t now = time(nullptr);\n  if (now < 100000) {\n    Serial.println(\"Time is not set yet. Connecting to NTP server and synchronizing time.\");\n    configTime(0, 0, \"0.pool.ntp.org\", \"time.nist.gov\");\n    delay(5000);\n    now = time(nullptr);\n    while (now < 100000) {\n      delay(500);\n      Serial.print(\".\");\n      now = time(nullptr);\n    }\n    Serial.println(\"\");\n    struct tm timeinfo;\n    gmtime_r(&now, &timeinfo);\n    Serial.print(\"Current time: \");\n    Serial.print(asctime(&timeinfo));\n  }\n  char jwt[128];\n  int jwt_length = createJWT(jwt, sizeof(jwt));\n  if (jwt_length > 0) {\n    Serial.println(\"JWT created\");\n    mqttClient.setId(MQTT_CLIENT_ID);\n    mqttClient.setUsernamePassword(MQTT_USER, jwt);\n    mqttClient.setWill(MQTT_TOPIC_STATUS, 0, true, \"offline\");\n    mqttClient.setKeepAlive(MQTT_KEEP_ALIVE);\n    mqttClient.setCleanSession(true);\n    if (mqttClient.connect(MQTT_BROKER, MQTT_PORT)) {\n      Serial.println(\"Connected to MQTT broker\");\n      mqttClient.publish(MQTT_TOPIC_STATUS, \"online\");\n      mqttClient.subscribe(MQTT_TOPIC_COMMAND);\n    }\n  } else {\n    Serial.println(\"JWT creation failed\");\n  }\n}\n", "CodeBleu_score": 39.26572755012104}, {"code": "static void connectMQTT()  if (timeStatus() == timeNotSet) {\n    Serial.println(\"Time is not set yet. Connecting to WiFi and getting time over NTP.\");\n    connectWiFi();\n    updateTime();\n  }\n  if (timeStatus() != timeNotSet) {\n    long timeOffset = now() - epochTime;\n    if (timeOffset < 0) {\n      timeOffset = 0;\n    }\n    Serial.println(\"Time is set. Updating JWT with time offset.\");\n    jwt.setTimeOffset(timeOffset);\n    Serial.println(\"Connecting to MQTT.\");\n    mqtt.connect();\n    mqttConnected = true;\n  }\n}\n", "CodeBleu_score": 42.29350004936299}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void)    if (CLOUD_getConnectionState() == CONNECTED) {\n        char *clientId = CLOUD_getClientId();\n        char *host = CLOUD_getHost();\n        int port = CLOUD_getPort();\n\n        MQTT_disconnect(clientId, host, port);\n\n        free(clientId);\n        free(host);\n    }\n\n    CLOUD_setConnectionState(DISCONNECTED);\n    CLOUD_setClientId(NULL);\n    CLOUD_setHost(NULL);\n    CLOUD_setPort(0);\n\n    debug_log(DEBUG_LOG_SEVERITY_INFO, DEBUG_LOG_SYSTEM_CLOUD, \"Disconnected from cloud\");\n}\n", "CodeBleu_score": 43.72330699279067}, {"code": "void CLOUD_disconnect(void)    if (CLOUD_isConnected()) {\n        CLOUD_log(CLOUD_LOG_LEVEL_DEBUG, \"Disconnecting from the cloud\");\n        CLOUD_disconnectMQTT();\n    }\n}\n", "CodeBleu_score": 22.760768748459746}, {"code": "void CLOUD_disconnect(void)\tif (CLOUD_getConnectionState() == CONNECTED) {\n\t\tCLOUD_log(CLOUD_LOG_LEVEL_DEBUG, \"Disconnecting from cloud service...\");\n\t\tCLOUD_setConnectionState(DISCONNECTED);\n\t\tCLOUD_disconnectMQTT();\n\t}\n}\n", "CodeBleu_score": 48.035269816039815}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)\tif (passed_wifi_creds == 1) {\n\t\t// Connect to the Wi-Fi network using the specified credentials\n\t\tSerial.println(\"Connecting to specified network...\");\n\t\tWiFi.begin(wifi_ssid, wifi_password);\n\t}\n\telse {\n\t\t// Connect to the Wi-Fi network using the default credentials\n\t\tSerial.println(\"Connecting to default network...\");\n\t\tWiFi.begin();\n\t}\n\n\t// Wait for a connection\n\tSerial.print(\"Connecting\");\n\twhile (WiFi.status() != WL_CONNECTED) {\n\t\tdelay(500);\n\t\tSerial.print(\".\");\n\t}\n\tSerial.println();\n\n\t// Print the IP address\n\tSerial.println(\"WiFi connected\");\n\tSerial.print(\"IP address: \");\n\tSerial.println(WiFi.localIP());\n\n\t// Return true if connected, false otherwise\n\treturn (WiFi.status() == WL_CONNECTED);\n}\n", "CodeBleu_score": 34.38337032467903}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  // Connect to Wi-Fi network\n  if (passed_wifi_creds) {\n    Serial.println(\"Attempting to connect to Wi-Fi network with new credentials...\");\n    WiFi.begin(ssid, password);\n  } else {\n    Serial.println(\"Attempting to connect to Wi-Fi network using default credentials...\");\n    WiFi.begin();\n  }\n\n  // Wait for connection\n  Serial.print(\"Connecting\");\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println();\n\n  // Connection failed\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"Failed to connect to Wi-Fi network.\");\n    networking_error = true;\n    return false;\n  }\n\n  // Connection succeeded\n  Serial.println(\"Successfully connected to Wi-Fi network.\");\n  networking_error = false;\n  return true;\n}\n", "CodeBleu_score": 36.60660175411438}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  if (passed_wifi_creds) {\n    // Connect to the Wi-Fi access point using the credentials provided\n    Serial.println();\n    Serial.print(\"Connecting to \\\"\");\n    Serial.print(wifi_ssid);\n    Serial.print(\"\\\"\");\n\n    if (wifi_auth_type == WIFI_AUTH_OPEN) {\n      // Connect to an open access point\n      WiFi.begin(wifi_ssid);\n    } else {\n      // Connect to a password-protected access point\n      WiFi.begin(wifi_ssid, wifi_password);\n    }\n\n    // Wait for a connection\n    uint8_t timeout_counter = 0;\n    while (WiFi.status() != WL_CONNECTED && timeout_counter < 10) {\n      delay(500);\n      Serial.print(\".\");\n      timeout_counter++;\n    }\n    Serial.println();\n\n    // If the connection was successful\n    if (WiFi.status() == WL_CONNECTED) {\n      // Print the local IP address\n      Serial.print(\"Connected! IP address: \");\n      Serial.println(WiFi.localIP());\n\n      // Set the networking error status\n      networking_err = ERR_NONE;\n\n      // Return true\n      return true;\n    } else {\n      // Log an error message\n      Serial.println(\"Connection failed.\");\n\n      // Set the networking error status\n      networking_err = ERR_WIFI_CONNECT;\n\n      // Return false\n      return false;\n    }\n  } else {\n    // Connect to the Wi-Fi access point using the default credentials\n    Serial.println();\n    Serial.print(\"Connecting to \\\"\");\n    Serial.print(DEFAULT_WIFI_SSID);\n    Serial.print(\"\\\"\");\n\n    // Connect to an open access point\n    WiFi.begin(DEFAULT_WIFI_SSID);\n\n    // Wait for a connection\n    uint8_t timeout_counter = 0;\n    while (WiFi.status() != WL_CONNECTED && timeout_counter < 10) {", "CodeBleu_score": 38.35262336135633}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map)    // Create a new client\n    const client = new GraphQLClient(\"https://api.sensorup.com/graphql\", {\n        headers: {\n            \"x-api-key\": \"e1640257-1566-421f-8562-191822352298\"\n        }\n    });\n\n    // Query for sensors\n    const query = gql`\n        query {\n            sensors {\n                id\n                name\n                description\n                geo {\n                    coordinates\n                }\n                measurements {\n                    parameter\n                    unit\n                    value\n                    timestamp\n                }\n            }\n        }\n    `;\n\n    // Send query to SensorUp API\n    const data = await client.request(query);\n\n    // Log API response\n    console.log(data);\n\n    // If data is retrieved\n    if (data) {\n        // Log retrieval of sensors\n        console.log(\"Sensors retrieved\");\n\n        // Iterate through each sensor\n        data.sensors.forEach(sensor => {\n            // Log sensor name\n            console.log(sensor.name);\n\n            // Create a marker\n            let marker = new mapboxgl.Marker({\n                color: \"#000000\"\n            }).setLngLat(sensor.geo.coordinates);\n\n            // Add marker to map\n            marker.addTo(map);\n        });\n    }\n}\n", "CodeBleu_score": 35.83719765101398}, {"code": "async function DisplaySensors(map)  const client = new GraphQLClient(\"https://api.smartcitizen.me/v0/graphql\");\n  const query = gql`\n    query {\n      sensors {\n        id\n        name\n        latitude\n        longitude\n        sensordatavalues {\n          value\n          createdAt\n          sensor {\n            id\n            name\n          }\n        }\n      }\n    }\n  `;\n\n  const response = await client.request(query);\n  console.log(response);\n\n  if (response.sensors) {\n    console.log(\"Retrieved sensors:\", response.sensors);\n    response.sensors.forEach((sensor) => {\n      const marker = L.marker([sensor.latitude, sensor.longitude]).addTo(map);\n      marker.bindPopup(\n        `<b>${sensor.name}</b><br/><i>${sensor.sensordatavalues[0].sensor.name}</i><br/>${sensor.sensordatavalues[0].value} ${sensor.sensordatavalues[0].sensor.name.split(\" \")[0]}<br/>${new Date(\n          sensor.sensordatavalues[0].createdAt\n        ).toLocaleString()}`\n      );\n    });\n  }\n}\n", "CodeBleu_score": 39.751284150585185}, {"code": "async function DisplaySensors(map)    // Generate a client\n    const client = new GraphQLClient(\"https://api.smartcitizen.me/v0/graphql\");\n\n    // Send a GraphQL query to fetch sensor data\n    const query = `\n        query {\n            sensors {\n                id\n                location {\n                    latitude\n                    longitude\n                }\n                device {\n                    id\n                    name\n                }\n            }\n        }\n    `;\n    const data = await client.request(query);\n\n    // Log the API response\n    console.log(data);\n\n    // If the response contains data, log the retrieval of sensors\n    if (data.sensors) {\n        console.log(\"Sensors retrieved:\");\n\n        // Iterate through each sensor to create a marker\n        data.sensors.forEach((sensor) => {\n            // Log the sensor\n            console.log(sensor);\n\n            // Create a marker\n            const marker = new google.maps.Marker({\n                position: {\n                    lat: sensor.location.latitude,\n                    lng: sensor.location.longitude\n                },\n                map: map,\n                title: sensor.device.name\n            });\n\n            // Add the marker to the map\n            marker.setMap(map);\n        });\n    }\n}\n", "CodeBleu_score": 37.71210308933177}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.classList.add(\"sensor\");\n  marker.style.backgroundColor = sensor.color;\n  marker.style.border = `1px solid ${sensor.color}`;\n  return marker;\n};\n", "CodeBleu_score": 31.30985127254922}, {"code": "const CreateSensorMarker = (sensor) =>  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.classList.add('sensor-marker');\n  marker.style.backgroundColor = 'rgb(255, 255, 255)';\n  marker.style.border = '1px solid rgb(0, 0, 0)';\n  return marker;\n};\n", "CodeBleu_score": 30.52275397712714}, {"code": "const CreateSensorMarker = (sensor) =>  // Create a marker for the sensor\n  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = 'white';\n  marker.style.border = '1px solid black';\n\n  return marker;\n};\n", "CodeBleu_score": 34.26943261118506}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"homeassistant.components.{module_name}.mfa_module\"\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError:\n        _LOGGER.error(f\"Unable to load MFA module {module_name} from {module_path}\")\n        raise\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await async_process_deps_reqs(hass, module_name, module.REQUIREMENTS)\n    if not hasattr(module, \"setup_flow\"):\n        _LOGGER.error(f\"MFA module {module_name} does not have a setup_flow() function\")\n        raise ImportError(f\"MFA module {module_name} does not have a setup_flow() function\")\n    if not hasattr(module, \"setup_flow_handler\"):\n        _LOGGER.error(f\"MFA module {module_name} does not have a setup_flow_handler() function\")\n        raise ImportError(f\"MFA module {module_name} does not have a setup_flow_handler() function\")\n    return module\n", "CodeBleu_score": 37.42929612943953}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = \"homeassistant.components.auth.mfa_modules.{}\".format(module_name)\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError:\n        _LOGGER.error(\"Unable to load MFA module %s\", module_name)\n        raise\n\n    if hasattr(module, \"REQUIREMENTS\") and not hass.config.skip_pip:\n        await async_process_deps_reqs(hass, module.REQUIREMENTS)\n\n    if hasattr(module, \"REQUIREMENTS_ONLY_ON_CORE\"):\n        core_config = await hass.async_add_executor_job(\n            config_util.async_hass_config_yaml, hass\n        )\n        core_config = core_config[DOMAIN]\n        if core_config[CONF_TYPE] == CONF_CORE:\n            await async_process_deps_reqs(hass, module.REQUIREMENTS_ONLY_ON_CORE)\n\n    if hasattr(module, \"REQUIREMENTS_SETUP\"):\n        await async_process_deps_reqs(hass, module.REQUIREMENTS_SETUP)\n\n    if hasattr(module, \"REQUIREMENTS_SETUP_ONLY_ON_CORE\"):\n        core_config = await hass.async_add_executor_job(\n            config_util.async_hass_config_yaml, hass\n        )\n        core_config = core_config[DOMAIN]\n        if core_config[CONF_TYPE] == CONF_CORE:\n            await async_process_deps_reqs(hass, module.REQUIREMENTS_SETUP_ONLY_ON_CORE)\n\n    return module\n\n", "CodeBleu_score": 37.553247844697346}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = \"custom_components.multi_factor_auth.mfa_modules.{}\".format(module_name)\n    try:\n        module = await hass.async_add_executor_job(importlib.import_module, module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load MFA module %s: %s\", module_name, err)\n        raise\n    else:\n        if hasattr(module, \"REQUIREMENTS\") and not hass.data[DATA_SKIP_PIP]:\n            await async_process_requirements(hass, module.REQUIREMENTS)\n        if module_name not in hass.data[DATA_PROCESSED_REQS]:\n            hass.data[DATA_PROCESSED_REQS].append(module_name)\n        return module\n\n", "CodeBleu_score": 41.91375098513011}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data[\"pin\"]\n    for entry in self.data:\n        if entry[\"user_id\"] == user_id:\n            entry[\"pin\"] = pin\n            return self.async_write_ha_state()\n    self.data.append({\"user_id\": user_id, \"pin\": pin})\n    return self.async_write_ha_state()\n\n", "CodeBleu_score": 53.05786560648749}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data.get(\"pin\")\n    if pin is None:\n        raise ValueError(\"PIN is required\")\n\n    user_entry = self.user_data.get(user_id)\n    if user_entry is None:\n        self.user_data[user_id] = {\"pin\": pin}\n    else:\n        user_entry[\"pin\"] = pin\n\n    self.async_write_user_data()\n\n    return {\"success\": True}", "CodeBleu_score": 39.23427755303342}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data[\"pin\"]\n    if self.user_id in self.data:\n        self.data[self.user_id][\"pin\"] = pin\n    else:\n        self.data[self.user_id] = {\"pin\": pin}\n    return self.data[self.user_id]\n\n", "CodeBleu_score": 41.131453759317985}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._initialized:\n            return\n        self._initialized = True\n        data = await self._user_store.read_all()\n        if not data:\n            data = {}\n        self._user_settings = {\n            user_id: NotifySetting(user_id, data.get(user_id, {}))\n            for user_id in data\n        }\n\n", "CodeBleu_score": 40.155470259054944}, {"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._is_loaded:\n            return\n\n        data = await self._user_store.get_user_data(self._user_id)\n        if data is None:\n            self._user_settings = {}\n        else:\n            self._user_settings = {\n                user: NotifySetting(**setting)\n                for user, setting in data.items()\n            }\n\n        self._is_loaded = True\n\n", "CodeBleu_score": 40.340310773116336}, {"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._loaded:\n            return\n\n        data = await self._store.read()\n\n        if not data:\n            self._data = {}\n        else:\n            self._data = {\n                int(key): NotifySetting(value[\"notify\"])\n                for key, value in data.items()\n            }\n\n        self._loaded = True\n\n", "CodeBleu_score": 37.484055459325106}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self.async_ensure_user_settings_loaded(user_id)\n    notification_settings = self.get_notification_settings(user_id)\n    if notification_settings is None:\n        return False\n    return await self.async_hass.async_add_executor_job(\n        self.validate, user_input, notification_settings\n    )\n\n", "CodeBleu_score": 47.96887536784803}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self._async_ensure_user_settings_loaded(user_id)\n    settings = self._async_get_user_settings(user_id)\n    if settings is None:\n        return False\n\n    code = user_input.get(self.code_input)\n    if code is None:\n        return False\n\n    return await self._async_hass.async_add_executor_job(\n        self._validate_code, code, settings\n    )", "CodeBleu_score": 52.101902574644285}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    await self.async_load_user_settings(user_id)\n    user_settings = self.get_user_settings(user_id)\n    if user_settings is None:\n        return False\n    return await self.async_hass.async_add_executor_job(\n        self.validate_otp, user_settings, user_input\n    )\n\n", "CodeBleu_score": 46.91872143586006}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.entities.get(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.devices.get(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 64.42890356638978}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if not entity_entry:\n        return None\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if not device_entry:\n        return None\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 52.70688386442347}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.hass.states.get(entity_id)\n    if entity is None:\n        return None\n    device = perm_lookup.hass.states.get(f\"{entity.domain}.{entity.attributes.get('device_id')}\")\n    if device is None:\n        return None\n    area_id = device.attributes.get(\"area_id\")\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 57.07004653499236}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category in policy:\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {}\n                for policy in policies:\n                    merged_policy[category].update(policy[category])\n    return PolicyType(merged_policy)\n\n", "CodeBleu_score": 45.54572732201105}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    new_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, value in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                new_policy[category] = value\n    return PolicyType(new_policy)", "CodeBleu_score": 47.38482898971299}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen: set[str] = set()\n\n    for policy in policies:\n        for category, values in policy.items():\n            if category not in seen:\n                seen.add(category)\n                merged_policy[category] = values\n\n    return PolicyType(merged_policy)", "CodeBleu_score": 47.94686424745649}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = await hass.async_add_executor_job(\n            importlib.import_module, f\"homeassistant.auth.{provider}\"\n        )\n    except ImportError as err:\n        _LOGGER.error(\"Unable to load auth provider %s: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Unable to load auth provider {provider}: {err}\"\n        ) from err\n    return module\n\n", "CodeBleu_score": 35.63987231660531}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    module = await hass.async_add_executor_job(\n        importlib.import_module, f\"homeassistant.auth.{provider}\"\n    )\n    return module\n\n", "CodeBleu_score": 10.988835712706575}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    module = await hass.async_add_executor_job(\n        importlib.import_module, f\"homeassistant.auth.{provider}\"\n    )\n    requirements = getattr(module, \"REQUIREMENTS\", [])\n    if requirements:\n        await async_process_requirements(hass, provider, requirements)\n    return module\n\n", "CodeBleu_score": 18.793652687674527}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n    try:\n        self._data = await self._store.load()\n    except FileNotFoundError:\n        self._data = {}\n    if not self._data:\n        self._data = {\"users\": []}\n    self._check_normalization()\n\n", "CodeBleu_score": 37.28105711776731}, {"code": "async def async_load(self) -> None\n    if not self.store:\n      self.users = []\n      return\n    self.users = await self.store.load()\n    if self.normalize_usernames:\n      for user in self.users:\n        if not self.is_normalized(user[\"username\"]):\n          user[\"username\"] = self.normalize(user[\"username\"])\n          await self.store.save(self.users)\n\n", "CodeBleu_score": 25.085985094445352}, {"code": "async def async_load(self) -> None\n    data = await self.store.async_load()\n    if data is None:\n        data = {}\n    self.data = data\n    self.async_schedule_save(self.data)\n\n    if not self.data:\n        self.data = {}\n        self.async_schedule_save(self.data)\n\n    if self.data:\n        for username in self.data:\n            if not self.data[username][\"username\"].islower():\n                self.data[self.data[username][\"username\"].lower()] = self.data[username]\n                del self.data[username]\n                self.async_schedule_save(self.data)\n\n", "CodeBleu_score": 25.308009817771342}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n    # Normalize the username\n    username = username.lower()\n    # Initialize a dummy hash\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    # Iterate through all users\n    for user in self.users:\n        # Check if the username matches\n        if user[\"username\"] == username:\n            # Decode the stored password hash\n            password_hash = base64.b64decode(user[\"password_hash\"])\n            # Use bcrypt's timing-safe check to compare the provided password with the stored hash\n            if bcrypt.checkpw(password.encode(\"utf-8\"), password_hash):\n                # The passwords match, so the login is valid\n                return\n            else:\n                # The passwords do not match, so the login is invalid\n                raise InvalidAuth()\n    # No matching user was found, so the login is invalid\n    raise InvalidAuth()", "CodeBleu_score": 40.15798533830397}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"password\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            stored_hash = base64.b64decode(user.password_hash)\n            if bcrypt.checkpw(password.encode(), stored_hash):\n                return\n            else:\n                raise InvalidAuth\n    if bcrypt.checkpw(b\"password\", dummy_hash):\n        raise InvalidAuth\n\n", "CodeBleu_score": 41.08123672215824}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user[\"username\"] == username:\n            password_hash = base64.b64decode(user[\"password_hash\"])\n            if bcrypt.checkpw(password.encode(), password_hash):\n                return\n            raise InvalidAuth\n    if bcrypt.checkpw(b\"\", dummy_hash):\n        raise InvalidAuth\n\n", "CodeBleu_score": 44.15389860976504}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n    username = self.normalize_username(username)\n    user = self.get_user(username)\n    self.users.remove(user)\n\n", "CodeBleu_score": 13.58634642996856}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = self._normalize_username(username)\n    if username not in self._users:\n        raise InvalidUser(\"user_not_found\")\n    del self._users[username]\n\n", "CodeBleu_score": 20.36917730890555}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = username.lower()\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(message=\"user_not_found\")", "CodeBleu_score": 28.726852926042966}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.data:\n        await self.async_load()\n    try:\n        self.data.pop(credentials.username)\n        await self.async_save()\n    except KeyError:\n        pass", "CodeBleu_score": 44.084246790742895}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    try:\n        if not self.data.initialized:\n            await self.async_initialize_data()\n        self.data.data.pop(credentials.data[\"username\"])\n        await self.async_save_data()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 48.68774170346145}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self._data.get(DOMAIN):\n        await self.async_load()\n    try:\n        self._data[DOMAIN].pop(credentials.username)\n        await self.async_save(self._data)\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 45.24221691730622}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\n    # Get the current time\n    current_time = time.time()\n\n    # Create a set of joined threads\n    joined_threads: set[Thread] = set()\n\n    # Iterate through each thread\n    for thread in threads:\n        # If the thread is not alive or has no identifier\n        if not thread.is_alive() or not hasattr(thread, \"ident\"):\n            # Add the thread to the joined set\n            joined_threads.add(thread)\n        else:\n            # Calculate the timeout for the thread\n            thread_timeout = current_time + timeout - time.time()\n\n            # If the thread is still alive\n            if thread.is_alive():\n                # If the timeout is greater than zero\n                if thread_timeout > 0:\n                    # Attempt to join the thread\n                    thread.join(thread_timeout)\n\n                # If the thread is still alive\n                if thread.is_alive():\n                    # If logging is enabled\n                    if log:\n                        # Log the thread\n                        logger.warning(\n                            f\"Thread {thread.ident} ({thread.name}) is still running\"\n                        )\n\n                    # Attempt to raise a SystemExit exception in the thread\n                    thread_raise_exception(thread, SystemExit)\n\n            # Add the thread to the joined set\n            joined_threads.add(thread)\n\n    # Return the joined threads\n    return joined_threads\n\n", "CodeBleu_score": 42.18868794808506}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined.add(thread)\n            continue\n        thread_timeout = timeout - (time.time() - thread.start_time)\n        if thread_timeout > 0:\n            thread.join(thread_timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n        else:\n            if log:\n                logger.warning(\n                    f\"Thread {thread.name} ({thread.ident}) is still running.\"\n                )\n    for thread in threads:\n        if thread not in joined:\n            try:\n                thread.raise_exception(SystemExit)\n            except Exception:\n                pass\n    return joined\n\n", "CodeBleu_score": 47.54921546293861}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n\n    # Calculate the timeout for each thread\n    thread_timeouts = {\n        thread: timeout / len(threads) for thread in threads if thread.is_alive()\n    }\n\n    # Join threads within their timeout\n    joined = set()\n    for thread, timeout in thread_timeouts.items():\n        thread.join(timeout)\n        if not thread.is_alive():\n            joined.add(thread)\n        else:\n            if log:\n                print(\n                    f\"Thread {thread.name} with identifier {thread.ident} is still running.\"\n                )\n\n    # Attempt to raise a SystemExit exception in any remaining threads\n    for thread in thread_timeouts:\n        if thread.is_alive():\n            try:\n                thread._tstate_lock.release()\n            except Exception:\n                pass\n\n    return joined", "CodeBleu_score": 45.439770747016006}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import logging\n    import time\n\n    # Calculate timeout\n    timeout = 10\n    threads = threading.enumerate()\n    non_daemon_threads = [t for t in threads if not t.daemon]\n    non_daemon_threads = [t for t in non_daemon_threads if t is not threading.current_thread()]\n    non_daemon_threads = [t for t in non_daemon_threads if t.is_alive()]\n    if len(non_daemon_threads) > 0:\n        timeout = timeout / len(non_daemon_threads)\n\n    # Join threads\n    for t in non_daemon_threads:\n        t.join(timeout)\n        if t.is_alive():\n            logging.warning(f\"Failed to join thread {t.name} during shutdown\")\n\n", "CodeBleu_score": 36.3234898690863}, {"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import logging\n    import time\n\n    shutdown_timeout = 10\n    threads = threading.enumerate()\n    threads_to_join = [thread for thread in threads if thread is not threading.main_thread() and not thread.daemon]\n    timeout_per_thread = shutdown_timeout / len(threads_to_join)\n    for thread in threads_to_join:\n        try:\n            thread.join(timeout_per_thread)\n        except Exception as e:\n            logging.warning(f\"Error while shutting down {thread.name}: {e}\")\n        if thread.is_alive():\n            logging.warning(f\"{thread.name} did not shut down within {timeout_per_thread} seconds\")", "CodeBleu_score": 45.53651058109149}, {"code": "def deadlock_safe_shutdown() -> None\n\n    import threading\n    import time\n    import logging\n\n    def get_all_threads() -> list:\n        \"\"\"The function \"get_all_threads\" returns a list of all threads that are alive.\"\"\"\n        return [thread for thread in threading.enumerate() if thread.is_alive()]\n\n    def get_non_main_threads() -> list:\n        \"\"\"The function \"get_non_main_threads\" returns a list of all threads that are alive and are not the main thread.\"\"\"\n        return [thread for thread in get_all_threads() if thread != threading.main_thread()]\n\n    def get_non_daemon_threads() -> list:\n        \"\"\"The function \"get_non_daemon_threads\" returns a list of all threads that are alive, are not the main thread, and are not daemon threads.\"\"\"\n        return [thread for thread in get_non_main_threads() if not thread.daemon]\n\n    def get_thread_timeout(timeout: float, number_of_threads: int) -> float:\n        \"\"\"The function \"get_thread_timeout\" returns a timeout for a thread based on the total shutdown timeout divided by the number of remaining threads.\"\"\"\n        return timeout / number_of_threads\n\n    def join_thread(thread: threading.Thread, timeout: float) -> None:\n        \"\"\"The function \"join_thread\" attempts to join the specified thread within the specified timeout. If joining the thread fails, a warning is logged.\"\"\"\n        try:\n            thread.join(timeout)\n        except:\n            logging.warning(f\"Failed to join thread {thread.name} during shutdown.\")\n\n    def join_all_threads(threads: list, timeout: float) -> None:\n        \"\"\"The function \"join_all_threads\" attempts to join all threads in the specified list within the specified timeout. If joining any thread fails, a warning is logged.\"\"\"\n        for thread in threads:\n            join_thread(thread, timeout)\n\n    def get_remaining_threads() -> list:\n        \"\"\"The function \"get_remaining_threads\" returns a list of all threads that are alive, are not the main thread, are not daemon threads, and have not been joined", "CodeBleu_score": 36.76259504903824}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None    if len(remaining_with_setup_started) > 0 or self._previous_remaining_with_setup_started:\n      self._dispatcher_signal.emit(remaining_with_setup_started)\n      self._previous_remaining_with_setup_started = len(remaining_with_setup_started) > 0\n    else:\n      self._dispatcher_signal.emit({})\n      self._previous_remaining_with_setup_started = False", "CodeBleu_score": 46.921377618569856}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None    if remaining_with_setup_started:\n      self.dispatcher.dispatch(\n        \"remaining_setups\",\n        remaining_with_setup_started\n      )\n      self.has_remaining_setups = True\n    elif self.has_remaining_setups:\n      self.dispatcher.dispatch(\"remaining_setups\", {})\n      self.has_remaining_setups = False", "CodeBleu_score": 32.10538884196484}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None    if self._remaining_with_setup_started or remaining_with_setup_started:\n      self._remaining_with_setup_started = remaining_with_setup_started\n      self._dispatcher.send(signal=self._signal, sender=self, remaining_with_setup_started=self._remaining_with_setup_started)\n    else:\n      self._remaining_with_setup_started = None", "CodeBleu_score": 37.17846147352813}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\n    bluetooth_file = config.cache_dir / \"bluetooth.py\"\n    if not bluetooth_file.exists():\n        return\n\n    bluetooth_content = bluetooth_file.read_text()\n    generated_content = generate_bluetooth_content(integrations)\n    if bluetooth_content != generated_content:\n        config.add_error(\n            \"bluetooth\",\n            \"The bluetooth.py file is out of date. Run script to fix.\",\n            fixable=True,\n            fix=lambda: bluetooth_file.write_text(generated_content),\n        )\n\n", "CodeBleu_score": 44.39819790735514}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\n    # Generate the bluetooth.py content\n    bluetooth_content = generate(integrations, config)\n\n    # If the specific integrations are being validated, compare the generated content with the cached content\n    if config.specific_integrations:\n        # If the generated content differs from the cached content, add an error to the configuration\n        if bluetooth_content != config.cache.bluetooth_content:\n            config.add_error(\n                \"bluetooth\",\n                f\"The bluetooth.py file is not up to date. Run `{config.env} -m homeassistant --script check_config --script-args bluetooth` to update it.\",\n                fixable=True,\n            )\n\n    # If all integrations are being validated, compare the generated content with the current content\n    else:\n        # Read the current content of bluetooth.py\n        with open(config.cache.hass_config_path / \"bluetooth.py\", \"r\") as file:\n            current_bluetooth_content = file.read()\n\n        # If the generated content differs from the current content, add an error to the configuration\n        if bluetooth_content != current_bluetooth_content:\n            config.add_error(\n                \"bluetooth\",\n                f\"The bluetooth.py file is not up to date. Run `{config.env} -m homeassistant --script check_config --script-args bluetooth` to update it.\",\n                fixable=True,\n            )\n\n    # Store the generated content in the configuration cache\n    config.cache.bluetooth_content = bluetooth_content\n\n", "CodeBleu_score": 36.95082560897407}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n\n    if not config.cache_dir.exists():\n        config.cache_dir.mkdir(parents=True)\n\n    bluetooth_file = config.cache_dir / \"bluetooth.py\"\n\n    if not bluetooth_file.exists():\n        bluetooth_file.touch()\n\n    generated_content = generate(integrations)\n    current_content = bluetooth_file.read_text()\n\n    if generated_content != current_content:\n        config.add_error(\n            \"bluetooth\",\n            \"Bluetooth integration is not up to date. Please run 'script/bluetooth.py' to fix.\",\n            fixable=True,\n        )\n\n    bluetooth_file.write_text(generated_content)", "CodeBleu_score": 48.22150609049527}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error\t// Create the POST request for the Dropbox OAuth2 token endpoint.\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\",\n\t\tstrings.NewReader(\"grant_type=refresh_token&refresh_token=\"+d.refreshToken))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the request headers for the POST request.\n\treq.Header.Set(\"Authorization\", \"Basic \"+basicAuth(d.appKey, d.appSecret))\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the POST request.\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Decode the JSON response.\n\tvar data interface{}\n\terr = json.NewDecoder(resp.Body).Decode(&data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Log the response.\n\tlog.Println(data)\n\n\t// Check if the POST request was successful.\n\tif resp.StatusCode == 200 {\n\t\t// Update the access token.\n\t\td.accessToken = data.(map[string]interface{})[\"access_token\"].(string)\n\t} else {\n\t\t// Return an error if the POST request was unsuccessful.\n\t\treturn errors.New(\"Dropbox OAuth2 token endpoint returned status code \" + strconv.Itoa(resp.StatusCode))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 48.62514345560835}, {"code": "func (d *Dropbox) refreshToken() error\t// Create the request body for the POST request\n\t// The request body contains the refresh token, app key, and app secret\n\tbody := \"grant_type=refresh_token&refresh_token=\" + d.RefreshToken + \"&client_id=\" + d.AppKey + \"&client_secret=\" + d.AppSecret\n\t// Create the POST request\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(body))\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Set the request header\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t// Send the POST request\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\t// Check the response status code\n\tif resp.StatusCode != 200 {\n\t\t// Read the response body\n\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Log the response body\n\t\tlog.Println(string(body))\n\t\treturn errors.New(\"Failed to refresh token\")\n\t}\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Unmarshal the response body into the AccessToken struct\n\tvar accessToken AccessToken\n\terr = json.Unmarshal(body, &accessToken)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Update the access token\n\td.AccessToken = accessToken.AccessToken\n\treturn nil\n}", "CodeBleu_score": 49.152394620210146}, {"code": "func (d *Dropbox) refreshToken() error\t// Build the request body\n\tbody := \"grant_type=refresh_token&refresh_token=\" + d.refreshToken + \"&client_id=\" + d.appKey + \"&client_secret=\" + d.appSecret\n\n\t// Build the request\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(body))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set the headers\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\t// Send the request\n\tresp, err := d.client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Decode the response\n\tvar data map[string]interface{}\n\tif err := json.NewDecoder(resp.Body).Decode(&data); err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the request was successful\n\tif resp.StatusCode != 200 {\n\t\t// Log the response\n\t\tlog.Println(\"Response:\", resp)\n\t\tlog.Println(\"Response Body:\", data)\n\t\treturn errors.New(resp.Status)\n\t}\n\n\t// Update the access token\n\td.accessToken = data[\"access_token\"].(string)\n\n\treturn nil\n}", "CodeBleu_score": 49.74671886719666}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\tvar body []byte\n\tvar err error\n\tvar req *http.Request\n\tvar res *http.Response\n\n\tfor i := 0; i < 2; i++ {\n\t\tif i > 0 {\n\t\t\tif err = d.refreshToken(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif req, err = http.NewRequest(method, url, nil); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.accessToken)\n\t\treq.Header.Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\t\treq.Header.Set(\"Accept\", \"application/json\")\n\t\treq.Header.Set(\"X-Goog-Api-Client\", \"gdrivesync-\"+version)\n\n\t\tif callback != nil {\n\t\t\tif err = callback(req); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif res, err = d.client.Do(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif res.StatusCode == 401 {\n\t\t\tcontinue\n\t\t}\n\n\t\tdefer res.Body.Close()\n\t\tbody, err = ioutil.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif res.StatusCode < 200 || res.StatusCode > 299 {\n\t\t\treturn nil, fmt.Errorf(\"Google Drive API error: %s (%d)\", string(body), res.StatusCode)\n\t\t}\n\n\t\tif resp != nil {\n\t\t\tif err = json.Unmarshal(body, resp); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tbreak\n\t}\n\n\treturn body, nil\n}\n", "CodeBleu_score": 45.559398468737676}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.accessToken)\n\treq.Header.Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\treq.Header.Set(\"X-Upload-Content-Type\", \"application/octet-stream\")\n\treq.Header.Set(\"X-Upload-Content-Length\", \"0\")\n\treq.Header.Set(\"Accept\", \"application/json; charset=UTF-8\")\n\treq.Header.Set(\"X-Goog-Upload-Protocol\", \"raw\")\n\treq.Header.Set(\"X-Goog-Upload-Command\", \"start\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tvar respBody []byte\n\terr = base.Retry(3, 5*time.Second, func() error {\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\trespBody, err = ioutil.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode == 401 {\n\t\t\tif err := d.refreshToken(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn base.ErrRetry\n\t\t}\n\t\tif resp.StatusCode != 200 {\n\t\t\treturn fmt.Errorf(\"Google Drive API error: %s\", respBody)\n\t\t}\n\t\tif resp != nil {\n\t\t\tif err := json.Unmarshal(respBody, resp); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\treturn respBody, err\n}\n", "CodeBleu_score": 53.06764195518689}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\t// Set the authorization header with the access token.\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.accessToken)\n\n\t// Include parameters for supporting all drives.\n\tq := req.URL.Query()\n\tq.Add(\"supportsAllDrives\", \"true\")\n\treq.URL.RawQuery = q.Encode()\n\n\t// If a callback is provided, customize the request.\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\t// Send the request.\n\tclient := &http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\t// If a response structure is provided, set the request result.\n\tif resp != nil {\n\t\tif err := json.NewDecoder(res.Body).Decode(resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If the request was successful, return the response body.\n\tif res.StatusCode == 200 {\n\t\treturn ioutil.ReadAll(res.Body)\n\t}\n\n\t// If the request failed, return an error.\n\treturn nil, fmt.Errorf(\"request failed with status code %d\", res.StatusCode)\n}\n", "CodeBleu_score": 55.9091087140523}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate the chunk size\n\tchunkSize := int(d.chunkSize)\n\tif chunkSize == 0 {\n\t\tchunkSize = 10485760 // 10MB\n\t}\n\n\t// Create a buffer to read the file\n\tbuffer := make([]byte, chunkSize)\n\tvar offset int64\n\tvar bytesRead int\n\tvar err error\n\n\t// Read the file in chunks\n\tfor {\n\t\t// Check if context was cancelled\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// Read the next chunk\n\t\tbytesRead, err = stream.Read(buffer)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the chunk is empty, break the loop\n\t\tif bytesRead == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Create a request to upload the chunk\n\t\treq, err := http.NewRequest(http.MethodPut, url, bytes.NewReader(buffer[:bytesRead]))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Add the headers\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+int64(bytesRead)-1, stream.Size()))\n\t\treq.Header.Set(\"Content-Length\", strconv.Itoa(bytesRead))\n\t\treq.Header.Set(\"Content-Type\", \"application/json; charset=UTF-8\")\n\n\t\t// Send the request\n\t\tres, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer res.Body.Close()\n\n\t\t// If the response is not 200, return an error\n\t\tif res.StatusCode != 200 {\n\t\t\treturn fmt.Errorf(\"received status code %d\", res.StatusCode)\n\t\t}\n\n\t\t// Increment the offset\n\t\toffset += int6", "CodeBleu_score": 43.79311706171032}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate the chunk size\n\tchunkSize := int64(d.chunkSize)\n\tif chunkSize == 0 {\n\t\tchunkSize = 104857600 // 100 MB\n\t}\n\t// Check if the file size is smaller than the chunk size\n\tif stream.Size() < chunkSize {\n\t\t// If it is, upload the file in a single request\n\t\treturn d.singleUpload(ctx, stream, url)\n\t}\n\t// Create a buffer for reading the file\n\tbuf := make([]byte, chunkSize)\n\t// Create a buffer for uploading the file\n\tuploadBuf := bytes.NewBuffer(buf)\n\t// Read the file in chunks\n\tfor {\n\t\t// Read the chunk\n\t\tn, err := stream.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t\t// Check if the context has been cancelled\n\t\tif err := ctx.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create the request body\n\t\tuploadBuf.Reset()\n\t\tuploadBuf.Write(buf[:n])\n\t\t// Create the request\n\t\treq, err := http.NewRequestWithContext(ctx, \"PUT\", url, uploadBuf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set the content range\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", stream.BytesRead(), stream.BytesRead()+int64(n)-1, stream.Size()))\n\t\t// Send the request\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Check if the context has been cancelled\n\t\tif err := ctx.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Check if the response is valid\n\t\tif resp.StatusCode != 308 {\n\t\t\treturn fmt.Errorf(\"invalid response status: %s\", resp.Status)", "CodeBleu_score": 44.83128947049484}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate the chunk size.\n\tchunkSize := int64(d.ChunkSize)\n\tif chunkSize < minChunkSize {\n\t\tchunkSize = minChunkSize\n\t}\n\tif chunkSize > maxChunkSize {\n\t\tchunkSize = maxChunkSize\n\t}\n\n\t// Create the buffer.\n\tbuf := make([]byte, chunkSize)\n\t// Create the reader.\n\treader := bufio.NewReader(stream)\n\n\t// Create the first chunk.\n\tchunk := &Chunk{\n\t\tstart:       0,\n\t\tend:         chunkSize - 1,\n\t\tisLastChunk: false,\n\t}\n\n\t// Create the uploader.\n\tuploader := &ChunkUploader{\n\t\tctx:       ctx,\n\t\tdrive:     d,\n\t\turl:       url,\n\t\tchunkSize: chunkSize,\n\t\tbuf:       buf,\n\t\treader:    reader,\n\t\tchunk:     chunk,\n\t}\n\n\t// Upload the chunks.\n\tfor {\n\t\t// Upload the chunk.\n\t\terr := uploader.uploadChunk()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Check if the chunk is the last one.\n\t\tif chunk.isLastChunk {\n\t\t\tbreak\n\t\t}\n\n\t\t// Update the chunk.\n\t\tchunk.start = chunk.end + 1\n\t\tchunk.end = chunk.start + chunkSize - 1\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 48.21439483078277}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error\tmountPoint := ctx.Get(\"mount_point\").(string)\n\tif mountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"mount_point is required\")\n\t}\n\n\terr := storage.Umount(mountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusServiceUnavailable, err.Error())\n\t}\n\n\terr = storage.DeleteConfig(mountPoint)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusServiceUnavailable, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}", "CodeBleu_score": 33.80227285554105}, {"code": "func UmountStorage(ctx echo.Context) error\tvar mount_point string\n\tvar config_name string\n\tvar config_path string\n\tvar config_data []byte\n\tvar config_file *os.File\n\n\t// Bind mount_point from request context\n\tif err := ctx.Bind(&mount_point); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Check if mount_point is empty\n\tif mount_point == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"mount_point is empty\")\n\t}\n\n\t// Get config_name from mount_point\n\tconfig_name = strings.Replace(mount_point, \"/\", \"_\", -1)\n\n\t// Get config_path from config_name\n\tconfig_path = filepath.Join(config.AppConfig.StorageConfigPath, config_name)\n\n\t// Check if config_path exists\n\tif _, err := os.Stat(config_path); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, \"storage not found\")\n\t}\n\n\t// Read config_data from config_path\n\tif config_data, err = ioutil.ReadFile(config_path); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Unmarshal config_data into config_file\n\tif err := json.Unmarshal(config_data, &config_file); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Check if config_file is empty\n\tif config_file == nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"config_file is empty\")\n\t}\n\n\t// Check if config_file is already mounted\n\tif config_file.Mounted == true {\n\t\t// Unmount config_file\n\t\tif err := syscall.Unmount(config_file.MountPoint, 0); err != nil {\n\t\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t\t}\n\n\t\t// Set config_file.Mount", "CodeBleu_score": 37.44760387145095}, {"code": "func UmountStorage(ctx echo.Context) error\t// Bind the request context to a new \"UmountStorageRequest\" instance\n\tvar request UmountStorageRequest\n\tif err := ctx.Bind(&request); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Check if the mount point is empty\n\tif request.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"mount point cannot be empty\")\n\t}\n\n\t// Check if the mount point is a valid path\n\tif _, err := os.Stat(request.MountPoint); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"invalid mount point\")\n\t}\n\n\t// Unmount the storage\n\tif err := syscall.Unmount(request.MountPoint, 0); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the configuration\n\tif err := deleteConfiguration(request.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}\n", "CodeBleu_score": 37.47774284881223}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error\t// Get the path from the query parameters\n\tpath := ctx.QueryParam(\"path\")\n\n\t// Check if the path is provided\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"missing path query parameter\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"file not found\",\n\t\t})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(path)\n}", "CodeBleu_score": 41.490898636273556}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"file path is required\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// Return a JSON response with an error message\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"file not found\",\n\t\t})\n\t}\n\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 36.87053925841947}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Extract the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an appropriate error message\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"Please provide a file path\"})\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// Return a JSON response with an appropriate error message\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File not found\"})\n\t}\n\t// Return the file to the client\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 36.08055357561187}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tmessage := new(Message)\n\tif err := ctx.Bind(message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tif err := Notify(name, message.Message); err != nil {\n\t\treturn err\n\t}\n\treturn ctx.NoContent(http.StatusOK)\n}\n", "CodeBleu_score": 40.28306692953918}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\tif err := notify.Send(name, message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\treturn ctx.String(http.StatusOK, \"OK\")\n}", "CodeBleu_score": 47.41916303907323}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tmessage := make(map[string]string)\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\tif err := notify.Notify(name, message[\"message\"]); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.String(http.StatusOK, \"OK\")\n}\n", "CodeBleu_score": 47.92612903966161}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error\t// upgrade the HTTP GET request to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// add the WebSocket connection to the list of connections\n\tconnections[ws] = true\n\n\t// ensure that the message sending service is running\n\tif !sending {\n\t\tsending = true\n\t\tgo sendMessages()\n\t}\n\n\t// enter a loop to continuously read messages from the WebSocket connection\n\tfor {\n\t\t// read a message from the WebSocket connection\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\t// print the error\n\t\t\tlog.Println(err)\n\n\t\t\t// remove the WebSocket connection from the list of connections\n\t\t\tdelete(connections, ws)\n\n\t\t\t// stop the message sending service if no more connections are open\n\t\t\tif len(connections) == 0 {\n\t\t\t\tsending = false\n\t\t\t}\n\n\t\t\t// exit the loop\n\t\t\tbreak\n\t\t}\n\n\t\t// print the message type and message\n\t\tlog.Printf(\"%s: %s\\n\", msgType(msg[0]), msg[1:])\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 44.674357561014354}, {"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the WebSocket connection to the list of connections.\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it is not running.\n\tif !sending {\n\t\tsending = true\n\t\tgo sendMessages()\n\t}\n\n\t// Read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Message type: %d, Message: %s\\n\", msgType, string(msg))\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tfor i, v := range connections {\n\t\tif v == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 47.93830733014206}, {"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP request to a WebSocket connection.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list of connections.\n\tconnections[ws] = true\n\n\t// Start the message sending service if it is not running.\n\tif !sending {\n\t\tsending = true\n\t\tgo sendMessages()\n\t}\n\n\t// Read messages from the WebSocket connection and print them.\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Message type: %d, Message: %s\\n\", msgType, string(msg))\n\t}\n\n\t// Remove the WebSocket connection from the list of connections.\n\tdelete(connections, ws)\n\n\treturn nil\n}\n", "CodeBleu_score": 45.82163447817342}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tvar hardwareInfo HardwareInfo\n\tvar err error\n\n\thardwareInfo.DriveModel, err = getDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\thardwareInfo.Architecture, err = getArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\thardwareInfo.CPU, err = getCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, hardwareInfo)\n}\n", "CodeBleu_score": 16.106202301934808}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tvar (\n\t\tdriveModel string\n\t\terr        error\n\t)\n\n\t// Get the drive model\n\tif driveModel, err = GetDriveModel(); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\t// Get the architecture\n\tarchitecture := GetArchitecture()\n\n\t// Get the CPU information\n\tcpuInfo, err := GetCPUInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\t// Return the system hardware information\n\treturn ctx.JSON(http.StatusOK, echo.Map{\n\t\t\"driveModel\":  driveModel,\n\t\t\"architecture\": architecture,\n\t\t\"cpuInfo\":     cpuInfo,\n\t})\n}", "CodeBleu_score": 22.664447623768204}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get system hardware information\n\tsystemHardwareInfo, err := getSystemHardwareInfo()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err)\n\t}\n\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}\n", "CodeBleu_score": 12.978198739836166}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error)\tserviceList, err := s.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar runningServices []string\n\tvar notRunningServices []string\n\tfor _, service := range serviceList {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}\n", "CodeBleu_score": 65.62421624464334}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunningServices := []string{}\n\tnotRunningServices := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{true: &runningServices, false: &notRunningServices}, nil\n}", "CodeBleu_score": 66.14911243146888}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tvar (\n\t\terr      error\n\t\tservices []string\n\t)\n\n\t// Get a list of services\n\tservices, err = s.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a map to hold the results\n\tserviceMap := make(map[bool]*[]string)\n\n\t// Create a list for each status\n\tvar running, notRunning []string\n\n\t// Iterate over the list of services\n\tfor _, service := range services {\n\t\t// Check the status of the service\n\t\tstatus, err := s.Status(service)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// If the service is running, add it to the running list\n\t\tif status == \"running\" {\n\t\t\trunning = append(running, service)\n\t\t} else {\n\t\t\t// Otherwise, add it to the not running list\n\t\t\tnotRunning = append(notRunning, service)\n\t\t}\n\t}\n\n\t// Add the lists to the map\n\tserviceMap[true] = &running\n\tserviceMap[false] = &notRunning\n\n\t// Return the map\n\treturn serviceMap, nil\n}", "CodeBleu_score": 52.94290206746651}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tif i.Notify == nil {\n\t\treturn\n\t}\n\tvar err error\n\tvar buf []byte\n\tif buf, err = json.Marshal(message); err != nil {\n\t\ti.Notify.Errorf(\"failed to serialize message: %s\", err)\n\t\treturn\n\t}\n\tvar res *http.Response\n\tif res, err = i.Notify.Send(name, buf); err != nil {\n\t\ti.Notify.Errorf(\"failed to publish message: %s\", err)\n\t\treturn\n\t}\n\tif res.StatusCode != http.StatusOK {\n\t\ti.Notify.Errorf(\"failed to publish message: %s\", res.Status)\n\t\treturn\n\t}\n}", "CodeBleu_score": 36.32829754148449}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\t// Create a new message\n\tmsg := &notify.Message{\n\t\tName: name,\n\t\tData: message,\n\t}\n\n\t// Publish the message to the message bus\n\tif err := i.bus.Publish(msg); err != nil {\n\t\ti.logger.Error(\"failed to publish message\",\n\t\t\tzap.String(\"name\", name),\n\t\t\tzap.Any(\"message\", message),\n\t\t\tzap.Error(err),\n\t\t)\n\t}\n}", "CodeBleu_score": 26.03991634344841}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tif len(message) == 0 {\n\t\tmessage = make(map[string]interface{})\n\t}\n\tmessage[\"name\"] = name\n\tmessageJSON, _ := json.Marshal(message)\n\tif err := i.publisher.Publish(string(messageJSON)); err != nil {\n\t\ti.logger.Error(\"Failed to publish notification\", zap.Error(err))\n\t}\n}", "CodeBleu_score": 29.08539235963399}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(c.runtime.MessageBus())\n\treturn client\n}\n", "CodeBleu_score": 10.817471942762277}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(c.runtime.MessageBus())\n\treturn client\n}\n", "CodeBleu_score": 10.817471942762277}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(c.address)\n\treturn client\n}\n", "CodeBleu_score": 9.708836872896125}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string\t// Check the \"x-forwarded-for\" header first.\n\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\t// If the header is not available, use the remote address.\n\t\tip = request.RemoteAddr\n\t}\n\t// Convert the loopback addresses \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\".\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.Contains(ip, \"::ffff:127.0.0.1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 47.36953243243804}, {"code": "func GetIP(request *http.Request) string\tif xff := request.Header.Get(\"x-forwarded-for\"); xff != \"\" {\n\t\tips := strings.Split(xff, \", \")\n\t\tif len(ips) > 0 {\n\t\t\treturn ips[0]\n\t\t}\n\t}\n\tip, _, err := net.SplitHostPort(request.RemoteAddr)\n\tif err != nil {\n\t\treturn request.RemoteAddr\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 35.42332773909767}, {"code": "func GetIP(request *http.Request) string\tif ip := request.Header.Get(\"x-forwarded-for\"); ip != \"\" {\n\t\tips := strings.Split(ip, \",\")\n\t\tif len(ips) > 0 {\n\t\t\treturn strings.TrimSpace(ips[0])\n\t\t}\n\t}\n\tip, _, err := net.SplitHostPort(strings.TrimSpace(request.RemoteAddr))\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tif ip == \"::1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\treturn strings.TrimPrefix(ip, \"::ffff:\")\n\t}\n\treturn ip\n}", "CodeBleu_score": 37.72297416211883}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\tvar entry []byte\n\tvar err error\n\tvar moduleEntry []byte\n\tvar modules []string\n\tvar modulePath string\n\tvar moduleEntryFile string\n\tvar moduleEntryFilePath string\n\n\t// Define the path to the modules directory and the path to the entry file\n\tmodules = c.config.Modules\n\tmodulePath = c.config.ModulesDir\n\tentryFilePath := c.config.EntryFile\n\n\t// Create a new entry file if it does not exist\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t_, err = os.Create(entryFilePath)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n\n\t// Read the entry file\n\tentry, err = ioutil.ReadFile(entryFilePath)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\t// Read each module directory for entry.json files\n\tfor _, module := range modules {\n\t\tmoduleEntryFilePath = modulePath + \"/\" + module + \"/entry.json\"\n\t\tmoduleEntryFile, err := os.Open(moduleEntryFilePath)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t\tdefer moduleEntryFile.Close()\n\n\t\tmoduleEntry, err = ioutil.ReadAll(moduleEntryFile)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\t// Append the module entry to the entry file\n\t\tentry = append(entry, moduleEntry...)\n\t}\n\n\t// Write the entry file\n\terr = ioutil.WriteFile(entryFilePath, entry, 0644)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}", "CodeBleu_score": 25.348831153083257}, {"code": "func (c *systemService) GenreateSystemEntry()\tvar (\n\t\tmoduleDirPath  string\n\t\tentryFilePath  string\n\t\tentryFile      *os.File\n\t\terr            error\n\t\tmoduleDirs     []string\n\t\tmoduleDir      string\n\t\tentryFilePaths []string\n\t)\n\n\tmoduleDirPath = c.config.ModulesDir\n\tentryFilePath = c.config.EntryFile\n\n\t// ensure the entry file exists\n\tif _, err = os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\tif entryFile, err = os.Create(entryFilePath); err != nil {\n\t\t\tc.logger.Log(err)\n\t\t}\n\t}\n\n\t// get the module directories\n\tif moduleDirs, err = ioutil.ReadDir(moduleDirPath); err != nil {\n\t\tc.logger.Log(err)\n\t}\n\n\t// for each module directory\n\tfor _, moduleDir = range moduleDirs {\n\t\t// get the module entry file path\n\t\tentryFilePaths = append(entryFilePaths, moduleDirPath+\"/\"+moduleDir.Name()+\"/entry.json\")\n\t}\n\n\t// for each module entry file path\n\tfor _, entryFilePath = range entryFilePaths {\n\t\t// read the entry file\n\t\tif _, err = ioutil.ReadFile(entryFilePath); err != nil {\n\t\t\tc.logger.Log(err)\n\t\t}\n\t}\n\n\t// write the entry file\n\tif err = ioutil.WriteFile(entryFilePath, []byte(\"\"), 0644); err != nil {\n\t\tc.logger.Log(err)\n\t}\n}", "CodeBleu_score": 23.439283474587466}, {"code": "func (c *systemService) GenreateSystemEntry()\tif c.systemEntryFile == \"\" {\n\t\tc.systemEntryFile = filepath.Join(c.systemEntryDir, \"entry.json\")\n\t}\n\n\tif _, err := os.Stat(c.systemEntryDir); os.IsNotExist(err) {\n\t\tif err := os.Mkdir(c.systemEntryDir, 0755); err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif _, err := os.Stat(c.systemEntryFile); os.IsNotExist(err) {\n\t\tif _, err := os.Create(c.systemEntryFile); err != nil {\n\t\t\tlog.Println(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar entry []byte\n\tvar modules []string\n\tvar moduleEntries []byte\n\tvar err error\n\n\tif modules, err = filepath.Glob(filepath.Join(c.modulesDir, \"*\")); err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tfor _, module := range modules {\n\t\tif moduleEntries, err = ioutil.ReadFile(filepath.Join(module, \"entry.json\")); err != nil {\n\t\t\tlog.Println(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(moduleEntries) > 0 {\n\t\t\tentry = append(entry, moduleEntries...)\n\t\t\tentry = append(entry, []byte(\",\")...)\n\t\t}\n\t}\n\n\tif len(entry) > 0 {\n\t\tentry = entry[:len(entry)-1]\n\t\tentry = append([]byte(\"[\"), entry...)\n\t\tentry = append(entry, []byte(\"]\")...)\n\n\t\tif err := ioutil.WriteFile(c.systemEntryFile, entry, 0755); err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t}\n}", "CodeBleu_score": 39.973256452416244}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) \tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tnames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, iface := range ifaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}", "CodeBleu_score": 63.33944169856587}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, networkName := range networkNames {\n\t\tfor _, i := range interfaces {\n\t\t\tif i.Name == networkName {\n\t\t\t\treturn i.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"no matching interface found\")\n}", "CodeBleu_score": 64.6706138125824}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range ifaces {\n\t\tfor _, name := range names {\n\t\t\tif iface.Name == name {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"No matching interface found\")\n}\n", "CodeBleu_score": 63.33944169856587}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t ret = 0;\n\tSAppObj *pAppObj = NULL;\n\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Add the request to the TSC object's list of requests.\n\t */\n\tpRequest->pNext = pTscObj->pRequests;\n\tpTscObj->pRequests = pRequest;\n\n\t/*\n\t * Increment the request count for the associated TSC object.\n\t */\n\tpTscObj->requestCount++;\n\n\t/*\n\t * If the TSC object has application information, update the application's request summary, including total and current request counts.\n\t */\n\tif (pTscObj->pAppObj != NULL) {\n\t\tpAppObj = pTscObj->pAppObj;\n\t\tpAppObj->requestCount++;\n\t\tpAppObj->currentRequestCount++;\n\t}\n\n\t/*\n\t * Log debug information about the new request.\n\t */\n\tif (debug) {\n\t\tprintf(\"[DEBUG] [%s] [%s:%s:%d] [requestCount=%d]\\n\", __FUNCTION__, __FILE__, __FUNCTION__, __LINE__, pTscObj->requestCount);\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 38.93611944340526}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t ret = 0;\n\tSTscReqSummary *pReqSummary = NULL;\n\tif (pRequest == NULL || pTscObj == NULL) {\n\t\tret = EINVAL;\n\t\tgoto bail;\n\t}\n\tpRequest->pTscObj = pTscObj;\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpReqSummary = &pTscObj->pAppInfo->reqSummary;\n\t\tpReqSummary->totalRequests++;\n\t\tpReqSummary->currentRequests++;\n\t}\n\tpTscObj->requestCount++;\n\tif (pTscObj->requestCount > pTscObj->maxRequestCount) {\n\t\tpTscObj->maxRequestCount = pTscObj->requestCount;\n\t}\n\tif (pTscObj->requestCount == 1) {\n\t\tpTscObj->firstRequestTime = time(NULL);\n\t}\n\tpTscObj->lastRequestTime = time(NULL);\n\tpTscObj->lastRequestId = pRequest->requestId;\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo->lastRequestTime = pTscObj->lastRequestTime;\n\t}\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo->lastRequestId = pTscObj->lastRequestId;\n\t}\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo->lastRequestObj = pRequest;\n\t}\n\tpTscObj->lastRequestObj = pRequest;\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo->lastRequestObj = pRequest;\n\t}\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo->lastRequestTime = pTscObj->lastRequestTime;\n\t}\n\tif (pTscObj->pAppInfo != NULL) {\n\t\tpTscObj->pAppInfo", "CodeBleu_score": 35.40318650584193}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t rc = EDB_OK;\n\tSAppObj *pAppObj = NULL;\n\tSAppSummary *pAppSummary = NULL;\n\tSAppSummary *pAppSummaryTmp = NULL;\n\tSAppSummary *pAppSummaryTmp2 = NULL;\n\tuint32_t appId = 0;\n\tuint32_t appIdTmp = 0;\n\tuint32_t appIdTmp2 = 0;\n\tuint32_t appIdTmp3 = 0;\n\tuint32_t appIdTmp4 = 0;\n\tuint32_t appIdTmp5 = 0;\n\tuint32_t appIdTmp6 = 0;\n\tuint32_t appIdTmp7 = 0;\n\tuint32_t appIdTmp8 = 0;\n\tuint32_t appIdTmp9 = 0;\n\tuint32_t appIdTmp10 = 0;\n\tuint32_t appIdTmp11 = 0;\n\tuint32_t appIdTmp12 = 0;\n\tuint32_t appIdTmp13 = 0;\n\tuint32_t appIdTmp14 = 0;\n\tuint32_t appIdTmp15 = 0;\n\tuint32_t appIdTmp16 = 0;\n\tuint32_t appIdTmp17 = 0;\n\tuint32_t appIdTmp18 = 0;\n\tuint32_t appIdTmp19 = 0;\n\tuint32_t appIdTmp20 = 0;\n\tuint32_t appIdTmp21 = 0;\n\tuint32_t appIdTmp22 = 0;\n\tuint32_t appIdTmp23 = 0;\n\tuint32_t appIdTmp24 = 0;\n\tuint32_t appIdTmp25 = 0;\n\tuint32_t appIdTmp26 = 0;", "CodeBleu_score": 6.328365279728178}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tif (pRequest == NULL) {\n\t\treturn true;\n\t}\n\tif (strcmp(pRequest->pPrimaryDb, exceptDb) != 0) {\n\t\tint i;\n\t\tfor (i = 0; i < pRequest->dbCount; i++) {\n\t\t\tchar* db = pRequest->ppDb[i];\n\t\t\tchar* dot = strchr(db, '.');\n\t\t\tif (dot != NULL) {\n\t\t\t\t*dot = '\\0';\n\t\t\t}\n\t\t\tif (strcmp(db, exceptDb) == 0) {\n\t\t\t\tif (dot != NULL) {\n\t\t\t\t\t*dot = '.';\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (dot != NULL) {\n\t\t\t\t*dot = '.';\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 59.72439638921403}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tchar* p = NULL;\n\tchar* pDb = NULL;\n\tchar* pTmp = NULL;\n\tchar* pTmp2 = NULL;\n\tchar* pTmp3 = NULL;\n\tchar* pTmp4 = NULL;\n\tchar* pTmp5 = NULL;\n\tchar* pTmp6 = NULL;\n\tchar* pTmp7 = NULL;\n\tchar* pTmp8 = NULL;\n\tchar* pTmp9 = NULL;\n\tchar* pTmp10 = NULL;\n\tchar* pTmp11 = NULL;\n\tchar* pTmp12 = NULL;\n\tchar* pTmp13 = NULL;\n\tchar* pTmp14 = NULL;\n\tchar* pTmp15 = NULL;\n\tchar* pTmp16 = NULL;\n\tchar* pTmp17 = NULL;\n\tchar* pTmp18 = NULL;\n\tchar* pTmp19 = NULL;\n\tchar* pTmp20 = NULL;\n\tchar* pTmp21 = NULL;\n\tchar* pTmp22 = NULL;\n\tchar* pTmp23 = NULL;\n\tchar* pTmp24 = NULL;\n\tchar* pTmp25 = NULL;\n\tchar* pTmp26 = NULL;\n\tchar* pTmp27 = NULL;\n\tchar* pTmp28 = NULL;\n\tchar* pTmp29 = NULL;\n\tchar* pTmp30 = NULL;\n\tchar* pTmp31 = NULL;\n\tchar* pTmp32 = NULL;\n\tchar* pTmp33 = NULL;\n\tchar* pTmp34 = NULL;\n\tchar* pTmp35 = NULL;\n\tchar* pTmp36 = NULL;\n\tchar* pTmp37 = NULL;\n\tchar* pTmp38 = NULL;\n\tchar* pTmp39 = NULL;\n\tchar* pTmp40 = NULL;\n\tchar* pTmp41 = NULL;\n\tchar* pTmp42 = NULL;", "CodeBleu_score": 5.322237697108181}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)\tif (pRequest->pRequestMsg->database != NULL) {\n\t\tif (strcmp(pRequest->pRequestMsg->database, exceptDb) != 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (pRequest->pRequestMsg->numOfDatabases > 0) {\n\t\tint i;\n\t\tfor (i = 0; i < pRequest->pRequestMsg->numOfDatabases; i++) {\n\t\t\tif (strcmp(pRequest->pRequestMsg->databases[i], exceptDb) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 44.782280453619165}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tbool rval = false;\n\tswitch (code) {\n\tcase RPC_ERR_NO_ERROR:\n\tcase RPC_ERR_NO_SUCH_METHOD:\n\tcase RPC_ERR_INVALID_PARAMS:\n\tcase RPC_ERR_INTERNAL_ERROR:\n\tcase RPC_ERR_INVALID_REQUEST:\n\tcase RPC_ERR_METHOD_NOT_FOUND:\n\tcase RPC_ERR_INVALID_PARAMETER:\n\tcase RPC_ERR_PARSE_ERROR:\n\tcase RPC_ERR_REQUEST_CANCELED:\n\tcase RPC_ERR_CONNECTION_CLOSED:\n\tcase RPC_ERR_SERVER_SHUTDOWN:\n\tcase RPC_ERR_UNKNOWN_ERROR:\n\tcase RPC_ERR_UNKNOWN_PROTOCOL_VERSION:\n\tcase RPC_ERR_UNSUPPORTED_PROTOCOL:\n\tcase RPC_ERR_UNSUPPORTED_TRANSPORT:\n\tcase RPC_ERR_UNSUPPORTED_ENCODING:\n\tcase RPC_ERR_UNSUPPORTED_TYPE:\n\tcase RPC_ERR_UNSUPPORTED_OPERATION:\n\tcase RPC_ERR_INVALID_HEADER:\n\tcase RPC_ERR_INVALID_STREAM:\n\tcase RPC_ERR_INVALID_STATE:\n\tcase RPC_ERR_INVALID_FORMAT:\n\tcase RPC_ERR_INVALID_ARGUMENT:\n\tcase RPC_ERR_INVALID_CONFIG:\n\tcase RPC_ERR_INVALID_CONTEXT:\n\tcase RPC_ERR_INVALID_DESERIALIZER:\n\tcase RPC_ERR_INVALID_CONTENT_TYPE:\n\tcase RPC_ERR_INVALID_TRANSPORT:\n\tcase RPC_ERR_INVALID_ENCODING:\n\tcase RPC_ERR_INVALID_CLIENT:\n\tcase RPC_ERR_INVALID_SERVER:\n\tcase RPC_ERR_INVALID_RESPONSE:\n\tcase RPC_ERR", "CodeBleu_score": 21.081744239921203}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    bool rval = false;\n\n    if (code == RPC_ERR_CODE_REDIRECT) {\n        switch (msgType) {\n            case TMSG_RPC_REQ:\n            case TMSG_RPC_REQ_CONT:\n            case TMSG_RPC_REQ_END:\n            case TMSG_RPC_REQ_RETURN:\n            case TMSG_RPC_REQ_RETURN_CONT:\n            case TMSG_RPC_REQ_RETURN_END:\n            case TMSG_RPC_REQ_RETURN_ERR:\n                rval = true;\n                break;\n            default:\n                rval = false;\n                break;\n        }\n    }\n\n    return rval;\n}\n", "CodeBleu_score": 31.703609548453304}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\tif (code == EBADF || code == ENOTCONN || code == EPIPE) {\n\t\tif (msgType == tmsg_RpcRequest || msgType == tmsg_RpcResponse || msgType == tmsg_RpcError || msgType == tmsg_RpcCancel) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 40.19314281340016}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests)\tif (pRequests == NULL) {\n\t\treturn;\n\t}\n\n\tSHashLock(pRequests);\n\n\tSHashIterator iter;\n\tSHashIteratorInit(&iter, pRequests);\n\tSHashKeyValue kv;\n\n\twhile (SHashIteratorNext(&iter, &kv)) {\n\t\tRequestObj *pRequest = kv.value;\n\t\tif (pRequest != NULL) {\n\t\t\tif (pRequest->query != NULL) {\n\t\t\t\tQueryStop(pRequest->query);\n\t\t\t}\n\t\t}\n\t}\n\n\tSHashUnlock(pRequests);\n}\n", "CodeBleu_score": 41.34511266641493}, {"code": "void stopAllRequests(SHashObj *pRequests)    SHashIterator it;\n    SHashObj *pRequest;\n\n    // Iterate through the hash table\n    for (pRequest = SHashFirst(pRequests, &it); pRequest != NULL; pRequest = SHashNext(&it)) {\n        // Acquire the request\n        if (pRequest->pRequest != NULL) {\n            // Stop the query associated with the request if it is valid\n            if (pRequest->pRequest->pQuery != NULL) {\n                StopQuery(pRequest->pRequest->pQuery);\n            }\n\n            // Release the request\n            ReleaseRequest(pRequest->pRequest);\n        }\n    }\n}\n", "CodeBleu_score": 45.086861120180814}, {"code": "void stopAllRequests(SHashObj *pRequests)\tSHashObj *pRequest;\n\tint i;\n\t\n\tfor (i = 0; i < pRequests->max_entries; i++) {\n\t\tpRequest = pRequests->table[i];\n\t\twhile (pRequest != NULL) {\n\t\t\tif (pRequest->value != NULL) {\n\t\t\t\tstopQuery((QueryDesc *)pRequest->value);\n\t\t\t}\n\t\t\tpRequest = pRequest->next;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.76281576518489}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport()    if (!tscIsCrashReportEnabled()) {\n        return;\n    }\n    if (atomic_compare_exchange_strong(&clientStop, 0, 1)) {\n        while (clientStop) {\n            sleep(1);\n        }\n    } else {\n        TSCLog(@\"The crash report thread is already stopped.\");\n    }\n}\n", "CodeBleu_score": 58.14753262635968}, {"code": "void tscStopCrashReport()    if (!TSC_CRASH_REPORT_ENABLED) {\n        return;\n    }\n    if (atomic_compare_exchange_strong(&clientStop, 0, 1)) {\n        while (clientStop) {\n            usleep(100000);\n        }\n    } else {\n        TSC_LOG(\"tscStopCrashReport\", \"Crash report thread is already stopped.\");\n    }\n}\n", "CodeBleu_score": 49.0795331157255}, {"code": "void tscStopCrashReport()    if (!tscCrashReportEnabled) {\n        return;\n    }\n\n    if (atomic_compare_exchange_strong(&tscClientStop, &tscClientStop, 1)) {\n        while (tscClientStop) {\n            sleep(1);\n        }\n    } else {\n        tscLog(\"tscStopCrashReport: Crash report thread is already stopped.\\n\");\n    }\n}\n", "CodeBleu_score": 53.03179913876397}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t numViews = 0;\n\tint32_t numCols = 0;\n\tint32_t numColsInView = 0;\n\tint32_t numColsInCatalog = 0;\n\tint32_t numColsToRemove = 0;\n\tint32_t numColsToAdd = 0;\n\tint32_t numColsToUpdate = 0;\n\tint32_t numColsToKeep = 0;\n\tint32_t viewId = 0;\n\tint32_t colId = 0;\n\tint32_t colIdInView = 0;\n\tint32_t colIdInCatalog = 0;\n\tint32_t colIdToRemove = 0;\n\tint32_t colIdToAdd = 0;\n\tint32_t colIdToUpdate = 0;\n\tint32_t colIdToKeep = 0;\n\tint32_t viewNameLen = 0;\n\tint32_t colNameLen = 0;\n\tint32_t colType = 0;\n\tint32_t colTypeInView = 0;\n\tint32_t colTypeInCatalog = 0;\n\tint32_t colTypeToRemove = 0;\n\tint32_t colTypeToAdd = 0;\n\tint32_t colTypeToUpdate = 0;\n\tint32_t colTypeToKeep = 0;\n\tint32_t colSize = 0;\n\tint32_t colSizeInView = 0;\n\tint32_t colSizeInCatalog = 0;\n\tint32_t colSizeToRemove = 0;\n\tint32_t colSizeToAdd = 0;\n\tint32_t colSizeToUpdate = 0", "CodeBleu_score": 8.5336895430092}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t ret = 0;\n\tuint32_t i = 0;\n\tuint32_t viewCount = 0;\n\tuint32_t *pViewCount = NULL;\n\tstruct SViewInfo **pViewInfo = NULL;\n\n\t/*\n\t * Deserialize the view information\n\t */\n\tret = deserializeViewInfo(value, valueLen, &viewCount, &pViewInfo);\n\n\tif (ret != FUNC_RET_OK) {\n\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\"failed to deserialize view information, \" \\\n\t\t\t\"error code: %d.\", __LINE__, ret);\n\n\t\treturn ret;\n\t}\n\n\tpViewCount = &viewCount;\n\tfor (i=0; i<*pViewCount; i++) {\n\t\tif (pViewInfo[i]->column_count > 0) {\n\t\t\t/*\n\t\t\t * Update view metadata\n\t\t\t */\n\t\t\tret = hbUpdateViewMeta(pCatalog, pViewInfo[i]);\n\t\t\tif (ret != FUNC_RET_OK) {\n\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\t\"failed to update view metadata, \" \\\n\t\t\t\t\t\"error code: %d.\", __LINE__, ret);\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Remove view metadata\n\t\t\t */\n\t\t\tret = hbRemoveViewMeta(pCatalog, pViewInfo[i]);\n\t\t\tif (ret != FUNC_RET_OK) {\n\t\t\t\tlogError(\"file: \"__FILE__\", line: %d, \" \\\n\t\t\t\t\t\"failed to remove view metadata, \" \\\n\t\t\t\t\t\"error code: %d.\", __LINE__, ret);\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Destroy the response array\n\t */", "CodeBleu_score": 34.70757764874174}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)\tint32_t rc = 0;\n\tint32_t i = 0;\n\tint32_t j = 0;\n\tint32_t k = 0;\n\tint32_t viewCount = 0;\n\tint32_t columnCount = 0;\n\tint32_t viewId = 0;\n\tint32_t columnId = 0;\n\tint32_t columnType = 0;\n\tint32_t columnSize = 0;\n\tchar *viewName = NULL;\n\tchar *columnName = NULL;\n\tchar *columnTypeName = NULL;\n\tstruct SViewInfo *pViewInfo = NULL;\n\tstruct SViewInfo *pViewInfoTmp = NULL;\n\tstruct SViewInfo *pViewInfoNew = NULL;\n\tstruct SViewColumnInfo *pColumnInfo = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp2 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew2 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp3 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew3 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp4 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew4 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp5 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew5 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp6 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew6 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp7 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew7 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp8 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew8 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoTmp9 = NULL;\n\tstruct SViewColumnInfo *pColumnInfoNew9 = NULL;\n\tstruct SViewColumnInfo", "CodeBleu_score": 6.870995013510892}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3_put_object_callback_data *data = (S3_put_object_callback_data *) callbackData;\n\n    // The content length is used to determine how much data was received.\n    // The content length is the same as the object size.\n    // If the content length is zero, then we'll treat the object as a directory.\n    data->contentLength = properties->contentLength;\n\n    return S3StatusOK;\n}\n\n", "CodeBleu_score": 51.668461506280664}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    struct callback_data *data = (struct callback_data *) callbackData;\n\n    (void)properties;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    }\n    else {\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}\n\n", "CodeBleu_score": 73.20494913350959}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    callback_data *data = (callback_data *) callbackData;\n\n    int64_t contentLength = 0;\n\n    if (properties) {\n        contentLength = properties->contentLength;\n    }\n\n    // Only update the content length if it is greater than zero\n    if (contentLength > 0) {\n        data->contentLength = contentLength;\n    }\n    else {\n        // Make sure the content length is not negative\n        if (contentLength < 0) {\n            data->contentLength = 0;\n        }\n    }\n\n    return S3StatusOK;\n}\n\n", "CodeBleu_score": 56.741055112159614}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync()    if (mkdir(checkpointDir, 0777) == -1) {\n        perror(\"mkdir\");\n    }\n    removeEmptyDirs();\n    if (generateRsyncConfig()) {\n        char command[100];\n        sprintf(command, \"rsync --daemon --config=%s --port=%d\", rsyncConfigFile, rsyncPort);\n        system(command);\n        if (checkRsync()) {\n            printf(\"Rsync started successfully\\n\");\n        } else {\n            printf(\"Rsync failed to start\\n\");\n        }\n    } else {\n        printf(\"Rsync failed to start\\n\");\n    }\n}\n", "CodeBleu_score": 19.74202621383798}, {"code": "void startRsync()  /*\n   * Attempt to create the checkpoint backup directory.\n   */\n  if (!createDir(checkpointBackupDir)) {\n    /*\n     * If the creation failed, log an error.\n     */\n    logger(\"ERROR: Could not create the checkpoint backup directory.\", \"red\");\n  }\n  /*\n   * Remove empty directories from the checkpoint backup directory.\n   */\n  removeEmptyDirs(checkpointBackupDir);\n  /*\n   * Generate the Rsync configuration file.\n   */\n  if (!generateRsyncConf()) {\n    /*\n     * If the configuration file generation failed, log an error.\n     */\n    logger(\"ERROR: Could not generate the Rsync configuration file.\", \"red\");\n  }\n  /*\n   * Construct the command to start the Rsync daemon.\n   */\n  String startRsyncCommand = \"rsync --daemon --config=\" + checkpointBackupDir + \"/rsync.conf --port=\" + checkpointBackupPort;\n  /*\n   * Execute the command to start the Rsync daemon.\n   */\n  Process startRsyncProcess = startProcess(startRsyncCommand);\n  /*\n   * Wait for the Rsync daemon to start.\n   */\n  startRsyncProcess.waitFor();\n  /*\n   * Read the output of the command to start the Rsync daemon.\n   */\n  String startRsyncOutput = startRsyncProcess.getInputStream().readAll().toString();\n  /*\n   * If the output contains \"rsync: [sender] version\", log that the Rsync server started successfully.\n   */\n  if (startRsyncOutput.contains(\"rsync: [sender] version\")) {\n    logger(\"Rsync server started successfully.\", \"green\");\n  }\n  /*\n   * If the output does not contain \"rsync: [sender] version\", log that the Rsync server failed to start.\n   */\n  else {\n    logger(\"ERROR: Could not start the Rsync server.\", \"red\");\n  }\n}\n", "CodeBleu_score": 24.253601926273493}, {"code": "void startRsync()  if (mkdir(CHECKPOINT_BACKUP_DIR, 0777) != 0) {\n    logEvent(\"Error\", \"Could not create checkpoint backup directory\");\n  }\n  removeEmptyDirectories(CHECKPOINT_BACKUP_DIR);\n  if (generateRsyncConfig()) {\n    char rsyncCommand[500];\n    sprintf(rsyncCommand, \"rsync --daemon --config=%s --port=%d\", RSYNC_CONFIG_FILE, RSYNC_PORT);\n    system(rsyncCommand);\n    logEvent(\"Info\", \"Rsync server started\");\n  }\n  else {\n    logEvent(\"Error\", \"Could not generate Rsync configuration file\");\n  }\n}\n", "CodeBleu_score": 18.946074641063813}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" not found\");\n    }\n    dispatcher.getExecutor().shutdownNow();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 68.29142065980757}, {"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id \" + dispatcherId + \" is not registered\");\n    }\n    dispatcher.shutdown();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 66.36692245246459}, {"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with id '\" + dispatcherId + \"' not found\");\n    }\n    dispatcher.shutdown();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 65.15674936935231}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    TbActorRef parentRef = ctx.getActor(parent);\n    if (parentRef == null) {\n      log.warn(\"[{}] Parent actor is not registered!\", parent);\n      return;\n    }\n    List<TbActorId> children = actorChildren.get(parent);\n    if (children != null) {\n      children.stream().filter(childFilter).forEach(child -> {\n        TbActorRef childRef = ctx.getActor(child);\n        if (childRef == null) {\n          log.warn(\"[{}] Child actor is not registered!\", child);\n        } else {\n          if (highPriority) {\n            childRef.tellWithHighPriority(msg);\n          } else {\n            childRef.tell(msg);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n   */\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg) {\n    broadcastToChildren(parent, childFilter, msg, false);\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n   */\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority, long delay) {\n    TbActorRef parentRef = ctx.getActor(parent);\n    if (parentRef == null) {\n      log.warn(\"[{}] Parent actor", "CodeBleu_score": 48.317702024506524}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    Set<TbActorId> children = parentChildrenMap.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(childId -> {\n            try {\n                if (highPriority) {\n                    actorContext.tellWithHighPriority(childId, msg);\n                } else {\n                    actorContext.tell(childId, msg);\n                }\n            } catch (TbActorNotRegisteredException e) {\n                log.warn(\"[{}] Failed to broadcast message to child actor\", childId, e);\n            }\n        });\n    }\n}", "CodeBleu_score": 59.35474380184167}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    Set<TbActorId> children = childrenMap.get(parent);\n    if (children != null) {\n        children.stream().filter(childFilter).forEach(child -> {\n            try {\n                if (highPriority) {\n                    actorContext.tellWithHighPriority(child, msg);\n                } else {\n                    actorContext.tell(child, msg);\n                }\n            } catch (TbActorNotRegisteredException e) {\n                log.warn(\"[{}] Failed to broadcast message: {}\", child, msg, e);\n            }\n        });\n    }\n}", "CodeBleu_score": 62.41001742211021}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (destroyInProgress) {\n        if (highPriority && msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (initState == ComponentLifecycleState.INITIALIZED) {\n                initState = ComponentLifecycleState.INITIALIZING;\n                logger.info(\"[{}] Processing RULE_NODE_UPDATED_MSG message during destroy process.\", entityId);\n                onMsg(msg);\n            } else {\n                logger.info(\"[{}] Ignoring RULE_NODE_UPDATED_MSG message during destroy process.\", entityId);\n            }\n        } else {\n            msg.getCallback().onSuccess();\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 59.61958451185586}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (destroyInProgress) {\n        if (msg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG) {\n            if (initFailed) {\n                initFailed = false;\n                init(context);\n            }\n        } else {\n            msg.getCallback().onFailure(new RuntimeException(\"Actor is stopped!\"));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}\n", "CodeBleu_score": 48.56564157178351}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (!destroyInProgress) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    } else {\n        if (msg.getMsgType() == TbActorMsg.MsgType.RULE_NODE_UPDATED_MSG) {\n            TbActorMsg tbActorMsg = msg;\n            if (tbActorMsg.getMsgType() == TbActorMsg.MsgType.RULE_NODE_UPDATED_MSG) {\n                RuleNodeUpdatedMsg ruleNodeUpdatedMsg = (RuleNodeUpdatedMsg) tbActorMsg;\n                if (ruleNodeUpdatedMsg.getRuleNode().getType().equals(RuleNodeType.ROOT)) {\n                    init(ruleNodeUpdatedMsg.getRuleNode());\n                }\n            }\n        } else {\n            msg.getTbActorCtx().tellFailure(msg.getMsgType(), msg.getMsg());\n        }\n    }\n}", "CodeBleu_score": 57.88085226427939}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox()  int processed = 0;\n  int throughput = getThroughput();\n  while (processed < throughput) {\n    if (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n      setStatus(ActorStatus.FREE);\n      scheduleQueueProcessing();\n      return;\n    }\n    if (!highPriorityQueue.isEmpty()) {\n      Message message = highPriorityQueue.poll();\n      if (message != null) {\n        try {\n          process(message);\n          processed++;\n        } catch (InitializationFailureException e) {\n          setStopReason(e);\n          destroy();\n          return;\n        } catch (Exception e) {\n          logger.error(\"An exception occurred while processing a message.\", e);\n          applyProcessFailureStrategy(e);\n          if (getStatus() == ActorStatus.STOPPED) {\n            return;\n          }\n        }\n      }\n    }\n    if (!normalPriorityQueue.isEmpty()) {\n      Message message = normalPriorityQueue.poll();\n      if (message != null) {\n        try {\n          process(message);\n          processed++;\n        } catch (InitializationFailureException e) {\n          setStopReason(e);\n          destroy();\n          return;\n        } catch (Exception e) {\n          logger.error(\"An exception occurred while processing a message.\", e);\n          applyProcessFailureStrategy(e);\n          if (getStatus() == ActorStatus.STOPPED) {\n            return;\n          }\n        }\n      }\n    }\n  }\n  scheduleQueueProcessing();\n}", "CodeBleu_score": 34.363249140773156}, {"code": "private void processMailbox()    while (true) {\n        if (mailbox.isEmpty()) {\n            if (isActive()) {\n                status = Status.FREE;\n                scheduleQueueProcessing();\n            }\n            return;\n        }\n        Message message = mailbox.remove();\n        try {\n            process(message);\n        } catch (InitializationFailureException e) {\n            stopReason = e.getStopReason();\n            destroy();\n            return;\n        } catch (Exception e) {\n            logger.error(\"Failed to process message \" + message, e);\n            if (processFailureStrategy.shouldStop(e)) {\n                stopReason = processFailureStrategy.getStopReason(e);\n                destroy();\n                return;\n            }\n        }\n    }\n}", "CodeBleu_score": 26.741337610372025}, {"code": "private void processMailbox()    try {\n        // Process messages from the high priority queue\n        int processed = 0;\n        while (processed < throughputLimit) {\n            Message message = highPriorityQueue.poll();\n            if (message == null) {\n                break;\n            }\n            process(message);\n            processed++;\n        }\n        // Process messages from the normal priority queue\n        while (processed < throughputLimit) {\n            Message message = normalPriorityQueue.poll();\n            if (message == null) {\n                break;\n            }\n            process(message);\n            processed++;\n        }\n        // If there are no more messages, set the actor's status to free and schedule a queue processing attempt\n        if (highPriorityQueue.isEmpty() && normalPriorityQueue.isEmpty()) {\n            status = ActorStatus.FREE;\n            scheduleProcessMailbox();\n        }\n    } catch (InitializationFailureException e) {\n        stopReason = e;\n        destroy();\n    } catch (Exception e) {\n        logger.error(\"Failed to process message\", e);\n        processFailureStrategy.apply(this, e);\n        if (stopReason != null) {\n            destroy();\n        }\n    }\n}", "CodeBleu_score": 30.1963246026144}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause)    if (stopReason == null) {\n        stopReason = new StopReason(cause);\n    }\n    if (destroyInProgress.compareAndSet(false, true)) {\n        dispatcher.executor.execute(() -> {\n            try {\n                if (isRunning()) {\n                    setReadiness(false);\n                    actor.destroy(stopReason);\n                }\n                stop();\n            } catch (Throwable t) {\n                LOG.warn(\"Exception during actor destruction\", t);\n            }\n        });\n    }\n}", "CodeBleu_score": 38.54100430800004}, {"code": "public void destroy(Throwable cause)    if (cause == null)\n        throw new IllegalArgumentException(\"cause must not be null\");\n\n    if (stopReason == null)\n        stopReason = cause;\n\n    if (destroying)\n        return;\n\n    destroying = true;\n    dispatcher.executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                setReady(false);\n                invoke(new OnDestroy(context, cause));\n                notifyStopped();\n            } catch (Exception e) {\n                log.warning(\"{} while destroying {}\", e.getClass().getName(), context);\n            }\n        }\n    });\n}", "CodeBleu_score": 29.04382177345782}, {"code": "public void destroy(Throwable cause)    if (stopReason == null) {\n        stopReason = cause;\n    }\n    if (destroyInProgress) {\n        return;\n    }\n    destroyInProgress = true;\n    dispatcher.executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                setReady(false);\n                actor.postStop();\n            } catch (Exception e) {\n                logger.warn(\"Error while stopping actor {}\", actor, e);\n            }\n            try {\n                mailbox.stop();\n            } catch (Exception e) {\n                logger.warn(\"Error while stopping mailbox for actor {}\", actor, e);\n            }\n            try {\n                dispatcher.unregister(actor);\n            } catch (Exception e) {\n                logger.warn(\"Error while unregistering actor {}\", actor, e);\n            }\n            try {\n                if (context != null) {\n                    context.stop(actor);\n                }\n            } catch (Exception e) {\n                logger.warn(\"Error while stopping actor context {}\", actor, e);\n            }\n            try {\n                for (Message message : mailbox.stopping()) {\n                    message.handle(actor, context, self);\n                }\n            } catch (Exception e) {\n                logger.warn(\"Error while handling stopping messages for actor {}\", actor, e);\n            }\n        }\n    });\n}", "CodeBleu_score": 42.604156013106866}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n\n    RateLimitPolicy rateLimitPolicy = rateLimitConfiguration.getPolicy(api, level);\n    if (rateLimitPolicy == null) {\n        return true;\n    }\n\n    RateLimitContext rateLimitContext = new RateLimitContext(api, tenantId, level, rateLimitPolicy);\n    RateLimitResult rateLimitResult = rateLimitService.checkRateLimit(rateLimitContext);\n    if (rateLimitResult.isFailed()) {\n        rateLimitService.processRateLimitNotification(rateLimitContext, rateLimitResult);\n    }\n    return !rateLimitResult.isFailed();\n}", "CodeBleu_score": 56.094891296176506}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    // If the tenant ID corresponds to the system tenant, it always returns true.\n    if (tenantId.equals(TenantId.SYSTEM_TENANT_ID)) {\n        return true;\n    }\n    // It retrieves the tenant's profile; if not found and ignoring missing tenants is allowed, it returns true, otherwise, it throws a TenantProfileNotFoundException.\n    TenantProfile tenantProfile = getTenantProfile(tenantId, ignoreTenantNotFound);\n    if (tenantProfile == null) {\n        return true;\n    }\n    // It fetches the rate limit configuration from the tenant profile and checks the rate limit.\n    RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n    if (rateLimitConfiguration == null) {\n        return true;\n    }\n    RateLimitConfiguration.RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    boolean result = checkRateLimit(api, tenantId, rateLimit, level);\n    // If the rate limit is exceeded, it processes a rate limit notification.\n    if (!result) {\n        processRateLimitNotification(api, tenantId, rateLimit, level);\n    }\n    // Finally, it returns whether the rate limit check was successful.\n    return result;\n}", "CodeBleu_score": 48.120481827370924}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    TenantProfileData tenantProfileData = tenantProfile.getProfileData();\n    RateLimitConfiguration configuration = tenantProfileData.getRateLimitConfiguration();\n    if (configuration == null) {\n        return true;\n    }\n    RateLimitPolicy rateLimitPolicy = configuration.getPolicy(api);\n    if (rateLimitPolicy == null) {\n        return true;\n    }\n    RateLimitPolicyLevel rateLimitPolicyLevel = rateLimitPolicy.getLevel(level);\n    if (rateLimitPolicyLevel == null) {\n        return true;\n    }\n    RateLimitPolicyLevelConfiguration rateLimitPolicyLevelConfiguration = rateLimitPolicyLevel.getConfiguration();\n    if (rateLimitPolicyLevelConfiguration == null) {\n        return true;\n    }\n    RateLimitPolicyLevelThrottlingConfiguration throttlingConfiguration = rateLimitPolicyLevelConfiguration.getThrottling();\n    if (throttlingConfiguration == null) {\n        return true;\n    }\n    long limit = throttlingConfiguration.getLimit();\n    long interval = throttlingConfiguration.getIntervalSec();\n    if (limit == 0 || interval == 0) {\n        return true;\n    }\n    long tsBucket = System.currentTimeMillis() / (interval * 1000);\n    RateLimitContext rateLimitContext = new RateLimitContext(api, tenantId, level, tsBucket);\n    RateLimitResult rateLimitResult = rateLimitService.checkRateLimit(rateLimitContext, limit);\n    if (rateLimitResult.isThrottling()) {\n        RateLimitNotification notification = new RateLimitNotification(api, tenantId, level, tsBucket, limit, interval);\n        notification.setConfiguration(rateLimitPolicyLevelConfiguration);\n        notification", "CodeBleu_score": 49.613665787832225}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions()    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n        DtlsSession dtlsSession = entry.getValue();\n        if (dtlsSession.getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.info(\"Removed DTLS session with ID \" + entry.getKey() + \" due to inactivity timeout.\");\n        }\n    }\n}", "CodeBleu_score": 49.11643123522471}, {"code": "public void evictTimeoutSessions()    long expirationTime = System.currentTimeMillis() - sessionInactivityTimeout;\n    for (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n        DtlsSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.info(\"Removed DTLS session with id {} due to inactivity timeout.\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 51.74856559488747}, {"code": "public void evictTimeoutSessions()    // Get the current time\n    long currentTime = System.currentTimeMillis();\n    // Calculate the expiration time\n    long expirationTime = currentTime - inactivityTimeout;\n    // Iterate over the entries in the DTLS sessions map\n    for (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n        // Get the DTLS session\n        DtlsSession dtlsSession = entry.getValue();\n        // Get the last activity time\n        long lastActivityTime = dtlsSession.getLastActivityTime();\n        // Check if the last activity time is older than the expiration time\n        if (lastActivityTime < expirationTime) {\n            // Remove the DTLS session from the map\n            dtlsSessions.remove(entry.getKey());\n            // Log the removal\n            log.info(\"Removed session with id \" + entry.getKey() + \" due to inactivity timeout\");\n        }\n    }\n}", "CodeBleu_score": 35.2530404110152}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    List<TsKvEntry> result = new ArrayList<>();\n    if (!timeseries.isEmpty()) {\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            for (JsonNode node : entry.getValue()) {\n                if (node.has(\"ts\") && node.has(\"value\")) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, node.get(\"value\").asText())));\n                }\n            }\n        }\n    }\n    return result;\n}\n", "CodeBleu_score": 42.01338479779949}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (!timeseries.isEmpty()) {\n        List<TsKvEntry> result = new ArrayList<>();\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.asText())));\n            }\n        }\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}", "CodeBleu_score": 49.649150341876066}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    List<TsKvEntry> result = new ArrayList<>();\n    if (!timeseries.isEmpty()) {\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            for (JsonNode value : entry.getValue()) {\n                if (value.isBoolean()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new BooleanDataEntry(key, value.asBoolean())));\n                } else if (value.isDouble()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new DoubleDataEntry(key, value.asDouble())));\n                } else if (value.isTextual()) {\n                    result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.asText())));\n                } else {\n                    throw new RuntimeException(\"Unsupported data type: \" + value.getNodeType());\n                }\n            }\n        }\n    }\n    return result;\n}", "CodeBleu_score": 37.216098986264235}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken()    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", this.refreshToken);\n\n    Response response = given()\n        .contentType(\"application/json\")\n        .body(requestMap)\n        .when()\n        .post(this.authEndpoint);\n\n    this.token = response.jsonPath().getString(\"token\");\n    this.refreshToken = response.jsonPath().getString(\"refresh_token\");\n    this.expiresAt = System.currentTimeMillis() + response.jsonPath().getInt(\"expires_in\") * 1000;\n}", "CodeBleu_score": 44.69029472804432}, {"code": "public void refreshToken()    // Create a request map containing the current refresh token\n    Map<String, String> request = new HashMap<String, String>();\n    request.put(\"refresh_token\", this.refreshToken);\n    request.put(\"grant_type\", \"refresh_token\");\n    request.put(\"client_id\", this.clientId);\n    request.put(\"client_secret\", this.clientSecret);\n\n    // Send a POST request to the authentication endpoint\n    try {\n        URL url = new URL(this.authUrl);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setDoOutput(true);\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"charset\", \"utf-8\");\n        con.setRequestProperty(\"Content-Length\", Integer.toString(request.toString().getBytes().length));\n        con.setUseCaches(false);\n\n        // Send request\n        DataOutputStream wr = new DataOutputStream(con.getOutputStream());\n        wr.writeBytes(this.getQuery(request));\n        wr.flush();\n        wr.close();\n\n        int responseCode = con.getResponseCode();\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String inputLine;\n        StringBuffer response = new StringBuffer();\n\n        while ((inputLine = in.readLine()) != null) {\n            response.append(inputLine);\n        }\n        in.close();\n\n        // Parse the response and update the token information\n        JSONObject jsonObject = new JSONObject(response.toString());\n        this.accessToken = jsonObject.getString(\"access_token\");\n        this.refreshToken = jsonObject.getString(\"refresh_token\");\n        this.tokenTimestamp = System.currentTimeMillis();\n    } catch (Exception e) {\n        System.out.println(e);\n    }\n}\n", "CodeBleu_score": 32.46852289371876}, {"code": "public void refreshToken()    try {\n        Map<String, String> request = new HashMap<>();\n        request.put(\"refresh_token\", refreshToken);\n        Response response = Unirest.post(authEndpoint).headers(headers).body(request).asString();\n        if (response.getStatus() == 200) {\n            Map<String, Object> responseBody = response.getBody().getObject();\n            accessToken = responseBody.get(\"access_token\").toString();\n            refreshToken = responseBody.get(\"refresh_token\").toString();\n            tokenExpires = System.currentTimeMillis() + (Integer.parseInt(responseBody.get(\"expires_in\").toString()) * 1000);\n        } else {\n            throw new RuntimeException(\"Error: \" + response.getBody().toString());\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Error: \" + e.getMessage());\n    }\n}", "CodeBleu_score": 44.383534053034715}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin()    try {\n        // get the current timestamp\n        long currentTimestamp = System.currentTimeMillis();\n\n        // create the login request map\n        Map<String, String> loginRequestMap = new HashMap<>();\n        loginRequestMap.put(\"username\", username);\n        loginRequestMap.put(\"password\", password);\n\n        // send the request to the authentication endpoint\n        Response response = Unirest.post(AUTHENTICATION_ENDPOINT)\n                .header(\"Content-Type\", \"application/json\")\n                .body(loginRequestMap)\n                .asJson();\n\n        // update the token information with the response data and the timestamp\n        tokenInformation.setToken(response.getBody().getObject().getString(\"token\"));\n        tokenInformation.setExpirationTime(response.getBody().getObject().getLong(\"expirationTime\"));\n        tokenInformation.setTimestamp(currentTimestamp);\n\n        // show the login success dialog\n        JOptionPane.showMessageDialog(null, \"Login Successful!\", \"Success\", JOptionPane.INFORMATION_MESSAGE);\n    } catch (UnirestException e) {\n        e.printStackTrace();\n    }\n}", "CodeBleu_score": 52.10603013677553}, {"code": " private void doLogin()    final String username = \"admin\";\n    final String password = \"admin\";\n    final String timestamp = String.valueOf(System.currentTimeMillis());\n\n    final Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    loginRequest.put(\"timestamp\", timestamp);\n\n    final String loginURL = \"https://\" + HOST + \"/api/auth/login\";\n    final ResponseEntity<Map<String, Object>> response = restTemplate.postForEntity(loginURL, loginRequest, Map.class);\n    final Map<String, Object> loginResponse = response.getBody();\n\n    token = (String) loginResponse.get(\"token\");\n    tokenTimestamp = (String) loginResponse.get(\"timestamp\");\n}", "CodeBleu_score": 51.30749472926717}, {"code": " private void doLogin()    final String url = \"https://\" + this.getHost() + \"/api/auth/login\";\n    final String currentTime = String.valueOf(System.currentTimeMillis());\n    final Map<String, Object> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", this.getUsername());\n    loginRequest.put(\"password\", this.getPassword());\n    final String requestData = new JSONObject(loginRequest).toString();\n    try {\n        final Response response = Request.Post(url).bodyString(requestData, ContentType.APPLICATION_JSON).execute();\n        final JSONObject jsonObject = new JSONObject(response.returnContent().toString());\n        this.setToken(jsonObject.getString(\"token\"));\n        this.setTokenExpiration(jsonObject.getLong(\"tokenExpiration\"));\n        this.setLoginTimestamp(currentTime);\n    } catch (final IOException e) {\n        e.printStackTrace();\n    }\n}", "CodeBleu_score": 37.85772092812887}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        HttpResponse<Device> response = Unirest.get(this.url + \"/api/device/{deviceId}\")\n                .header(\"accept\", \"application/json\")\n                .asObject(Device.class);\n        return Optional.of(response.getBody());\n    } catch (UnirestException e) {\n        if (e.getCause() instanceof HttpClientErrorException.NotFound) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 58.93601796220498}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        return Optional.of(deviceApi.getDevice(deviceId));\n    } catch (ApiException e) {\n        if (e.getCode() == 404) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 33.042070603270076}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        ResponseEntity<Device> response = restTemplate.getForEntity(\n            \"http://localhost:8080/api/device/{deviceId}\",\n            Device.class,\n            deviceId\n        );\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 62.33934137668549}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    Request request = new Request();\n    request.setDevice(device);\n    request.setCredentials(credentials);\n    try {\n        Response response = client.post(\"/api/device-with-credentials\", request);\n        if (response.getStatus() == 404) {\n            return Optional.empty();\n        }\n        return Optional.of(response.getDevice());\n    } catch (Exception e) {\n        throw e;\n    }\n}", "CodeBleu_score": 42.99495302642765}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(baseUrl + \"/api/device-with-credentials\"))\n            .header(\"Content-Type\", \"application/json\")\n            .POST(HttpRequest.BodyPublishers.ofString(createDeviceWithCredentialsRequest(device, credentials)))\n            .build();\n\n    try {\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n        if (response.statusCode() == 404) {\n            return Optional.empty();\n        }\n        return Optional.of(mapper.readValue(response.body(), Device.class));\n    } catch (IOException | InterruptedException e) {\n        throw new CompletionException(e);\n    }\n}\n", "CodeBleu_score": 47.33368196637428}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    Request request = new Request();\n    request.setDevice(device);\n    request.setCredentials(credentials);\n\n    try {\n        return Optional.of(sendPost(\"/api/device-with-credentials\", request, Device.class));\n    } catch (HttpException e) {\n        if (e.getStatusCode() == 404) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 40.71056813525092}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val)\tif (arguments.length === 1) {\n\t\tthis.devices.forEach(device => {\n\t\t\tdevice.brightness = this.map(arguments[0], 0, 100, 0, 15);\n\t\t});\n\t} else if (arguments.length === 2) {\n\t\tthis.devices[addr].brightness = this.map(arguments[1], 0, 100, 0, 15);\n\t}\n\treturn this;\n}\n", "CodeBleu_score": 45.76706280625801}, {"code": "brightness(addr, val)    if (typeof addr === 'number') {\n        if (typeof val === 'number') {\n            this.map[addr].brightness = val;\n        } else {\n            throw new TypeError('Invalid value type');\n        }\n    } else if (typeof addr === 'undefined') {\n        for (let key in this.map) {\n            this.map[key].brightness = val;\n        }\n    } else {\n        throw new TypeError('Invalid arguments');\n    }\n    return this;\n}\n", "CodeBleu_score": 42.668166366034356}, {"code": "brightness(addr, val)    if (arguments.length == 1) {\n        for (let i = 0; i < this._devices.length; i++) {\n            this._devices[i].brightness(arguments[0]);\n        }\n    } else if (arguments.length == 2) {\n        this._devices[addr].brightness(arguments[1]);\n    } else {\n        throw new Error(\"Invalid number of arguments\");\n    }\n    return this;\n}\n", "CodeBleu_score": 41.134303997233104}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr)  var d = {};\n  var proto = Object.getPrototypeOf(this);\n  var keys = Object.keys(proto);\n  keys.push.apply(keys, Object.keys(this));\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (typeof proto[key] === 'function') {\n      d[key] = proto[key].bind(this, addr);\n    }\n  }\n  return d;\n}\n", "CodeBleu_score": 35.629916278850175}, {"code": "device(addr)    var dev = {};\n    for (var key in LedControl.prototype) {\n        dev[key] = LedControl.prototype[key].bind(this, addr);\n    }\n    for (var key in this) {\n        dev[key] = this[key];\n    }\n    return dev;\n}\n", "CodeBleu_score": 38.450145084454796}, {"code": "device(addr)  var obj = {};\n  var proto = Object.getPrototypeOf(this);\n  var keys = Object.getOwnPropertyNames(proto);\n  keys = keys.concat(Object.keys(this));\n  keys.forEach(function(key) {\n    if (typeof proto[key] === 'function') {\n      obj[key] = proto[key].bind(this, addr);\n    }\n  });\n  return obj;\n}\n", "CodeBleu_score": 38.87253546235927}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) =>     methods.forEach(method => {\n        target[`${method}Callback`] = function(duration, callback) {\n            if (typeof callback !== 'function') {\n                callback = function() {};\n            }\n            const promises = [];\n            this.forEach(element => {\n                promises.push(element[method]());\n            });\n            Promise.all(promises).then(() => {\n                setTimeout(callback, duration);\n            });\n        };\n    });\n};", "CodeBleu_score": 33.753127053105544}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>   methods.forEach(method => {\n    target[`${method}Callback`] = function(duration, callback) {\n      if (!isFunction(callback)) {\n        callback = function() {};\n      }\n\n      let promises = [];\n\n      this.forEach(element => {\n        promises.push(element[method](duration));\n      });\n\n      Promise.all(promises).then(callback);\n    };\n  });\n};", "CodeBleu_score": 25.349143856611832}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>   methods.forEach(method => {\n    target[method] = function(duration, callback) {\n      if (typeof callback !== 'function') {\n        callback = () => {};\n      }\n      let promises = [];\n      this.forEach(element => {\n        promises.push(element[method](duration));\n      });\n      Promise.all(promises).then(() => callback());\n    };\n  });\n};", "CodeBleu_score": 32.83763376502927}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen()  var input = \"\";\n  Serial.begin(9600);\n  while (true) {\n    while (Serial.available()) {\n      input += Serial.readString();\n      var nl = input.indexOf(\"\\r\\n\");\n      if (nl > -1) {\n        var sentence = input.substring(0, nl);\n        input = input.substring(nl + 2);\n        parseNmeaSentence(sentence);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 30.111716807255064}, {"code": "listen()  String input = \"\";\n  while (true) {\n    while (Serial.available() > 0) {\n      char c = Serial.read();\n      input += c;\n      if (c == '\\n') {\n        String sentence = input.substring(0, input.length() - 1);\n        parseNmeaSentence(sentence);\n        input = \"\";\n      }\n    }\n  }\n}\n", "CodeBleu_score": 17.760712502407312}, {"code": "listen()  this.input = \"\";\n  this.serial.readLine(this.serial.delimiter(), (data) => {\n    this.input += data;\n    let sentences = this.input.split(this.serial.delimiter());\n    for (let i = 0; i < sentences.length - 1; i++) {\n      this.parseNmeaSentence(sentences[i]);\n    }\n    this.input = sentences[sentences.length - 1];\n  });\n}\n", "CodeBleu_score": 46.630263651425864}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t active_channels = 0;\n\tsize_t needed_buffer_size;\n\n\tfor (int i = 0; i < config->channel_count; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = active_channels * sizeof(uint16_t);\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= 2;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 45.802696306734134}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config_info;\n\tuint32_t active_channels = 0;\n\tuint32_t needed_buffer_size;\n\tuint32_t buffer_size = sequence->options ?\n\t\t\t       sequence->options->extra_samplings *\n\t\t\t       sequence->buffer_size :\n\t\t\t       sequence->buffer_size;\n\n\tfor (int i = 0; i < config->channel_count; i++) {\n\t\tif (sequence->channels & BIT(i)) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tneeded_buffer_size = active_channels *\n\t\t\t     adc_ad559x_get_data_size(sequence->resolution);\n\n\tif (buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%u/%u)\", buffer_size,\n\t\t\tneeded_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 38.001168764891375}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tuint8_t channels = 0;\n\tsize_t needed_buffer_size;\n\n\tfor (int i = 0; i < sequence->channels; i++) {\n\t\tuint8_t channel_id = sequence->channels[i];\n\n\t\tif (channel_id >= config->channel_count) {\n\t\t\tLOG_ERR(\"Channel %d is not valid\", channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!(config->active_channels & BIT(channel_id))) {\n\t\t\tLOG_ERR(\"Channel %d is not active\", channel_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchannels |= BIT(channel_id);\n\t}\n\n\tneeded_buffer_size = adc_ad559x_get_buffer_size(sequence->resolution,\n\t\t\t\t\t\t\tchannels);\n\tif (sequence->options) {\n\t\tneeded_buffer_size *= 2;\n\t}\n\n\tif (sequence->buffer_size < needed_buffer_size) {\n\t\tLOG_ERR(\"Provided buffer is too small (%zu/%zu)\",\n\t\t\tsequence->buffer_size, needed_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 39.021336759255576}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)    const struct ad559x_config *config = dev->config;\n    struct ad559x_data *data = dev->data;\n    int err;\n    uint8_t i;\n\n    if (sequence->resolution != config->resolution) {\n        LOG_ERR(\"AD559x: unsupported resolution\");\n        return -ENOTSUP;\n    }\n\n    for (i = 0U; i < sequence->channels; i++) {\n        uint8_t input = sequence->buffer[i];\n\n        if (input >= config->channels) {\n            LOG_ERR(\"AD559x: unsupported channel %d\", input);\n            return -ENOTSUP;\n        }\n    }\n\n    if (sequence->options) {\n        LOG_ERR(\"AD559x: unsupported options\");\n        return -ENOTSUP;\n    }\n\n    size_t expected_buffer_size = sequence->channels * sizeof(uint16_t);\n\n    if (sequence->buffer_size < expected_buffer_size) {\n        LOG_ERR(\"AD559x: insufficient buffer size\");\n        return -ENOMEM;\n    }\n\n    data->buffer = sequence->buffer;\n    data->sequence.options = sequence->options;\n\n    err = ad559x_start_read(dev, sequence);\n    if (err) {\n        return err;\n    }\n\n    err = ad559x_wait_for_completion(dev);\n    if (err) {\n        return err;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 47.65860689013898}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)    struct adc_ad559x_data *data = dev->data;\n    struct adc_ad559x_config *config = dev->config;\n    uint8_t buf[2];\n    int err;\n    int i;\n    int j;\n    uint16_t *buffer = sequence->buffer;\n    uint16_t *buffer_end = buffer + sequence->buffer_size;\n    uint16_t *buffer_ptr = buffer;\n    uint16_t *buffer_ptr_end = buffer_end;\n    uint16_t buf_val;\n    uint16_t buf_val_end;\n    uint16_t buf_val_start;\n    uint16_t buf_val_end_start;\n    uint16_t buf_val_start_end;\n    uint16_t buf_val_end_end;\n    uint16_t buf_val_start_start;\n    uint16_t buf_val_end_start_start;\n    uint16_t buf_val_start_end_start;\n    uint16_t buf_val_end_end_start;\n    uint16_t buf_val_start_start_start;\n    uint16_t buf_val_end_start_start_start;\n    uint16_t buf_val_start_end_start_start;\n    uint16_t buf_val_end_end_start_start;\n    uint16_t buf_val_start_start_start_start;\n    uint16_t buf_val_end_start_start_start_start;\n    uint16_t buf_val_start_end_start_start_start;\n    uint16_t buf_val_end_end_start_start_start;\n    uint16_t buf_val_start_start_start_start_start;\n    uint16_t buf_val_end_start_start_start_start_start;\n    uint16_t buf_val_start_end_start_start_start_start;\n    uint16_t buf_val_", "CodeBleu_score": 14.354164850616751}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tconst struct adc_ad559x_config *config = dev->config;\n\tstruct adc_ad559x_data *data = dev->data;\n\tuint8_t resolution = config->resolution;\n\tuint8_t channels = config->channels;\n\tuint8_t *buffer = sequence->buffer;\n\tuint32_t buffer_size = sequence->buffer_size;\n\tuint32_t buffer_len = sequence->buffer_size / sizeof(uint16_t);\n\tuint8_t channel_id = sequence->channels;\n\tuint8_t i;\n\tuint16_t result;\n\n\tif (resolution != sequence->resolution) {\n\t\tLOG_ERR(\"ADC resolution mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (channels != sequence->channels) {\n\t\tLOG_ERR(\"ADC channels mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (buffer_len < 1) {\n\t\tLOG_ERR(\"ADC buffer size too small\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Unexpected sequence options\");\n\t\treturn -ENOTSUP;\n\t}\n\n\t/* Setup the ADC context structure */\n\tdata->ctx.sequence = sequence;\n\tdata->ctx.read_pos = 0;\n\tdata->ctx.read_total = buffer_len;\n\tdata->ctx.repeat_buffer = sequence->buffer;\n\tdata->ctx.repeat_size = 0;\n\tdata->ctx.options = sequence->options;\n\n\t/* Start the ADC read operation */\n\tfor (i = 0; i < channels; i++) {\n\t\tif (channel_id & BIT(i)) {\n\t\t\t/* Read the ADC value */\n\t\t\tadc_ad559x_read(dev, i, &result);\n\t\t\tbuffer[data->ctx.read_pos++] = result;\n\t\t}\n\t}\n\n\t/* Indicate the completion of the read operation */\n\tadc_context", "CodeBleu_score": 45.31110974813855}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_itf_drv *itf_drv = ctx->itf_drv;\n\tstruct adc_itf_config *itf_config = ctx->itf_config;\n\tstruct adc_itf_ctrl *itf_ctrl = ctx->itf_ctrl;\n\tstruct adc_itf_data *itf_data = ctx->itf_data;\n\n\t/* Set channels */\n\titf_ctrl->channels = ctx->channels;\n\titf_ctrl->repeat_buffer = ctx->buffer;\n\titf_ctrl->buffer_size = ctx->buffer_size;\n\titf_ctrl->repeat_size = ctx->repeat_size;\n\titf_ctrl->oversampling = ctx->oversampling;\n\titf_ctrl->oversampling_shift = ctx->oversampling_shift;\n\titf_ctrl->calibration_offset = ctx->calibration_offset;\n\n\t/* Release semaphore */\n\tsem_post(&itf_ctrl->sem_sync);\n}\n", "CodeBleu_score": 45.33307615093305}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_itf_data *data = ctx->data;\n\tstruct adc_itf_ctrl *ctrl = ctx->ctrl;\n\n\t/* set channels */\n\tctrl->channel = data->channel;\n\n\t/* set repeat buffer */\n\tctrl->repeat_buffer = data->buffer;\n\tctrl->repeat_size = data->size;\n\n\t/* start sampling */\n\tctrl->repeat_count = data->repeat;\n\tctrl->repeat_trigger = 0;\n\n\t/* start sampling */\n\tctrl->repeat_trigger = 1;\n}\n", "CodeBleu_score": 47.88400719911413}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_sampling_device *dev = ctx->dev;\n\tstruct adc_sampling_channel *ch;\n\tstruct adc_sampling_buffer *buf;\n\tuint8_t channel_count = 0;\n\tuint8_t i;\n\n\t/* Set channels to be sampled */\n\tfor (i = 0; i < dev->channel_count; i++) {\n\t\tch = &dev->channel[i];\n\t\tif (ch->ctx == ctx) {\n\t\t\tch->channel->CHANNEL.reg = ADC_CHANNEL_SINGLE_MODE | ADC_CHANNEL_INPUTMODE_DIFFERENTIAL_gc;\n\t\t\tch->channel->CHANNEL.reg |= (ch->pin_p << ADC_CH_MUXPOS_gp) | (ch->pin_n << ADC_CH_MUXNEG_gp);\n\t\t\tchannel_count++;\n\t\t}\n\t}\n\n\t/* Initialize repeat buffer with data buffer */\n\tbuf = &ctx->buffer;\n\tbuf->repeat_buffer.reg = (uint16_t)buf->data_buffer;\n\tbuf->repeat_buffer.reg |= ADC_REP_REP_bf | ADC_REP_REPNUM_gm;\n\tbuf->repeat_buffer.reg |= (buf->size << ADC_REP_REPNUM_gp);\n\n\t/* Start sampling */\n\tdev->adc->CTRLB.reg |= ADC_CH_START_bm;\n}\n", "CodeBleu_score": 23.769638198087833}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->buffer;\n\t}\n}\n", "CodeBleu_score": 49.88243588448712}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->buffer_pointer = ctx->repeat_buffer;\n\t} else {\n\t\tctx->buffer_pointer = ctx->single_buffer;\n\t}\n}\n", "CodeBleu_score": 50.05338307014884}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    if (repeat_sampling) {\n        ctx->buffer = ctx->repeat_buffer;\n    }\n}\n", "CodeBleu_score": 47.93607017048976}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\twhile (1) {\n\t\tk_sem_take(&data->acq_sem, K_FOREVER);\n\n\t\tfor (int i = 0; i < ADC_AD559X_CHANNELS; i++) {\n\t\t\tif (data->active_channels & BIT(i)) {\n\t\t\t\tint rc = adc_ad559x_read_channel(data, i);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d\", i);\n\t\t\t\t\tdata->completed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tk_sem_give(&data->sem);\n\t}\n}\n", "CodeBleu_score": 25.887846132899195}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tint ret;\n\tint i;\n\n\twhile (1) {\n\t\tk_sem_take(&data->sem, K_FOREVER);\n\n\t\tfor (i = 0; i < ADC_AD559X_CHANNEL_COUNT; i++) {\n\t\t\tif (data->active_channels & BIT(i)) {\n\t\t\t\tret = adc_ad559x_read_channel(data, i);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tLOG_ERR(\"Failed to read channel %d\", i);\n\t\t\t\t\tdata->complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tk_sem_give(&data->sem_acquisition_finished);\n\t}\n}\n", "CodeBleu_score": 37.64482310867259}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)    const struct adc_ad559x_config *config = data->config;\n    struct adc_ad559x_sequence *sequence = data->sequence;\n    struct adc_sequence *public_sequence = &sequence->public;\n    struct adc_ad559x_channel_config *channel_config;\n    int channel_id;\n    int ret;\n\n    while (1) {\n        k_sem_take(&data->sem_acquisition, K_FOREVER);\n\n        if (public_sequence->channels == 0) {\n            LOG_DBG(\"No channels in sequence\");\n            data->complete = true;\n            k_sem_give(&data->sem_acquisition);\n            continue;\n        }\n\n        for (channel_id = 0; channel_id < public_sequence->channels; channel_id++) {\n            channel_config = &sequence->channels[channel_id];\n\n            if (channel_config->differential) {\n                ret = adc_ad559x_read_differential(config, channel_config->input_positive,\n                                                    channel_config->input_negative,\n                                                    &sequence->buffer[channel_id]);\n            } else {\n                ret = adc_ad559x_read_single_ended(config, channel_config->input_positive,\n                                                    &sequence->buffer[channel_id]);\n            }\n\n            if (ret < 0) {\n                LOG_ERR(\"Failed to read channel %d (%d)\", channel_id, ret);\n                data->complete = true;\n                k_sem_give(&data->sem_acquisition);\n                return;\n            }\n        }\n\n        data->complete = true;\n        k_sem_give(&data->sem_acquisition);\n    }\n}\n", "CodeBleu_score": 41.1526109129878}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev)\tint err;\n\tuint8_t config_reg_val;\n\tuint8_t config_reg_val_new;\n\tuint8_t config_reg_val_old;\n\tuint8_t config_reg_val_old_old;\n\tuint8_t config_reg_val_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\tuint8_t config_reg_val_old_old_old_", "CodeBleu_score": 5.013093331658085}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    int ret;\n    uint16_t config;\n    uint16_t ready_time;\n    uint8_t ready_time_unit;\n\n    /* Read the config register to get the ready time */\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n    if (ret) {\n        LOG_ERR(\"ads1112: failed to read config register\");\n        return ret;\n    }\n\n    /* Calculate the ready time */\n    ready_time_unit = (config & ADS1112_CONFIG_DR_MASK) >> ADS1112_CONFIG_DR_SHIFT;\n    if (ready_time_unit == 0) {\n        ready_time = 1;\n    } else if (ready_time_unit == 1) {\n        ready_time = 8;\n    } else {\n        ready_time = 16;\n    }\n\n    /* Sleep for the ready time */\n    k_sleep(K_MSEC(ready_time));\n\n    /* Check the status */\n    while (1) {\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n        if (ret) {\n            LOG_ERR(\"ads1112: failed to read config register\");\n            return ret;\n        }\n\n        if (config & ADS1112_CONFIG_RDY) {\n            break;\n        }\n\n        k_sleep(K_MSEC(100));\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 47.608111229888884}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    int ret;\n    uint16_t config;\n    struct ads1112_data *data = dev->data;\n    const struct ads1112_config *cfg = dev->config;\n\n    k_msleep(cfg->ready_time);\n\n    while (1) {\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &config);\n        if (ret) {\n            return ret;\n        }\n\n        if (!(config & ADS1112_CONFIG_OS_MASK)) {\n            return 0;\n        }\n\n        k_usleep(100);\n    }\n}\n", "CodeBleu_score": 45.363525657088275}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tint buffer_size_required = 0;\n\tint buffer_size_specified = 0;\n\n\tbuffer_size_required = sequence->channels * sequence->oversampling;\n\tbuffer_size_specified = sequence->buffer_size;\n\n\tif (buffer_size_required > buffer_size_specified) {\n\t\tLOG_ERR(\"ADC: buffer size too small. required:%d specified:%d\",\n\t\t\tbuffer_size_required, buffer_size_specified);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 44.56302914192787}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)\tsize_t required_buffer_size = 0;\n\tsize_t buffer_size = sequence->buffer_size;\n\n\t/* Calculate required buffer size */\n\trequired_buffer_size = ads1112_get_required_buffer_size(sequence);\n\n\t/* Check if the buffer size is sufficient */\n\tif (buffer_size < required_buffer_size) {\n\t\tLOG_ERR(\"ADC: Buffer size %u is less than required size %u\", buffer_size, required_buffer_size);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 37.83035490178699}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)    int required_buffer_size = ads1112_get_required_buffer_size(sequence);\n    if (required_buffer_size < 0) {\n        return required_buffer_size;\n    }\n    if (sequence->buffer_size < required_buffer_size) {\n        return -EINVAL;\n    }\n    return 0;\n}\n", "CodeBleu_score": 40.17335158966823}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\tif (!sequence->channels) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels->channel_id >= ADS1112_NUM_CHANNELS) {\n\t\treturn -EINVAL;\n\t}\n\n\tdata->current_sequence = sequence;\n\n\terr = ads1112_adc_start_read_async(dev, sequence);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (wait) {\n\t\terr = ads1112_adc_wait_read_async(dev, sequence);\n\t}\n\n\treturn err;\n}\n", "CodeBleu_score": 48.109413960401106}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)  struct ads1112_data *data = dev->data;\n  int err;\n  const struct ads1112_dev_config *config = dev->config;\n  const struct adc_channel_config *channel_config = sequence->channels;\n  uint8_t buf[3];\n  uint8_t buf_len = 0;\n  uint8_t i;\n  uint8_t chan_count = 0;\n  uint8_t chan_id = 0;\n  uint8_t chan_mask = 0;\n  uint8_t chan_valid = 0;\n  uint8_t chan_invalid = 0;\n  uint8_t chan_duplicate = 0;\n  uint8_t chan_single_shot = 0;\n  uint8_t chan_differential = 0;\n  uint8_t chan_gain_valid = 0;\n  uint8_t chan_gain_invalid = 0;\n  uint8_t chan_gain_single_shot = 0;\n  uint8_t chan_gain_differential = 0;\n  uint8_t chan_gain_mask = 0;\n  uint8_t chan_gain_mask_valid = 0;\n  uint8_t chan_gain_mask_invalid = 0;\n  uint8_t chan_gain_mask_single_shot = 0;\n  uint8_t chan_gain_mask_differential = 0;\n  uint8_t chan_gain_mask_mask = 0;\n  uint8_t chan_gain_mask_mask_valid = 0;\n  uint8_t chan_gain_mask_mask_invalid = 0;\n  uint8_t chan_gain_mask_mask_single_shot = 0;\n  uint8_t chan_gain_mask_mask_differential = 0;\n  uint8_t chan_gain_mask_mask_mask = 0;\n  uint8", "CodeBleu_score": 20.604433841619585}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tint err;\n\n\tif (sequence->channels == 0) {\n\t\tLOG_ERR(\"No channels in sequence.\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for valid sequence */\n\tif (sequence->channels > ADS1112_MAX_CHANNELS) {\n\t\tLOG_ERR(\"Too many channels in sequence.\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for valid buffer size */\n\tif (sequence->options) {\n\t\tif (sequence->options->extra_samplings == 0) {\n\t\t\tLOG_ERR(\"Sequence expects no extra samples.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Check for valid buffer size */\n\tif (sequence->buffer == NULL) {\n\t\tLOG_ERR(\"Sequence buffer pointer is NULL.\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check for valid buffer size */\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Sequence buffer size too small.\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Assign the sequence buffer */\n\tdata->buffer = sequence->buffer;\n\n\t/* Start the ADC read context */\n\terr = ads1112_adc_start_read_ctx(dev, sequence, wait);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 44.948365480728114}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tstruct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Failed to get device binding\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = audio_codec_apply_properties(dev, &codec_properties);\n\tif (ret < 0) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t\treturn -EINVAL;\n\t}\n\n\tshell_print(sh, \"Properties applied\");\n\n\treturn 0;\n}\n", "CodeBleu_score": 55.94173783998052}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret = 0;\n\tconst struct device *dev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Failed to get device binding\");\n\t\treturn -EINVAL;\n\t}\n\t/* The function \"audio_codec_configure\" is used to configure the audio codec properties. */\n\tret = audio_codec_configure(dev, AUDIO_CODEC_PROPERTY, &codec_prop);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to configure the audio codec properties\");\n\t} else {\n\t\tshell_print(sh, \"Audio codec properties configured successfully\");\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 54.945303718918794}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tstruct device *dev;\n\tint ret;\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Could not get audio codec device binding\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = audio_codec_apply_properties(dev, &audio_properties);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply audio codec properties (%d)\", ret);\n\t} else {\n\t\tshell_print(sh, \"Applied audio codec properties\");\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 55.6991873521508}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_send_cmd(dev, CMD_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is not configured\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_send_cmd(dev, CMD_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Device is not active\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tLOG_ERR(\"Unsupported command\");\n\t\tret = -ENOTSUP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 53.38027046073479}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_data *drv_data = dev->data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\tif (drv_data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = mpxxdtyy_i2s_send_cmd(dev, MPXXDTYY_CMD_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdrv_data->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EPERM;\n\t\t}\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\tif (drv_data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = mpxxdtyy_i2s_send_cmd(dev, MPXXDTYY_CMD_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdrv_data->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 48.62616344562702}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_data *data = dev->data;\n\tint ret = 0;\n\n\tif (cmd == DMIC_TRIGGER_START) {\n\t\tif (data->state == MPXXDTYY_STATE_CONFIGURED) {\n\t\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_START);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_ACTIVE;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (cmd == DMIC_TRIGGER_STOP) {\n\t\tif (data->state == MPXXDTYY_STATE_ACTIVE) {\n\t\t\tret = i2s_trigger(data->i2s_dev, I2S_DIR_RX, I2S_TRIGGER_STOP);\n\t\t\tif (ret == 0) {\n\t\t\t\tdata->state = MPXXDTYY_STATE_CONFIGURED;\n\t\t\t}\n\t\t} else {\n\t\t\tLOG_ERR(\"Invalid state\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tLOG_ERR(\"Unsupported command\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 39.88716723162897}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tconst struct auxdisplay_hd44780_config *config = dev->config;\n\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = config->display_mode_cmd;\n\n\tif (enabled) {\n\t\tcmd |= HD44780_DISPLAY_ON;\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tcmd |= HD44780_CURSOR_ON;\n\t}\n\n\tif (data->blink_enabled) {\n\t\tcmd |= HD44780_BLINK_ON;\n\t}\n\n\tif (data->cursor_position) {\n\t\tcmd |= HD44780_CURSOR_POS;\n\t}\n\n\tauxdisplay_hd44780_send_cmd(dev, cmd);\n}\n", "CodeBleu_score": 70.89825195028646}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command;\n\n\tcommand = AUXDISPLAY_HD44780_CMD_DISPLAY_CONTROL;\n\tif (enabled) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_CONTROL_D;\n\t}\n\tif (data->cursor_on) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_CONTROL_C;\n\t}\n\tif (data->cursor_blink) {\n\t\tcommand |= AUXDISPLAY_HD44780_DISPLAY_CONTROL_B;\n\t}\n\n\tauxdisplay_hd44780_send_command(dev, command);\n}\n", "CodeBleu_score": 56.219014896510934}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)    struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t command = 0;\n\n    if (enabled) {\n        command = AUXDISPLAY_HD44780_DISPLAY_ON;\n    }\n\n    if (data->cursor_enabled) {\n        command |= AUXDISPLAY_HD44780_CURSOR_ON;\n    }\n\n    if (data->blink_enabled) {\n        command |= AUXDISPLAY_HD44780_CURSOR_BLINK_ON;\n    }\n\n    data->display_enabled = enabled;\n\n    auxdisplay_hd44780_send_command(dev, command);\n}\n", "CodeBleu_score": 58.30764545663729}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tstruct auxdisplay_itron_config *config = dev->config;\n\tstruct gpio_pin_config pin_config;\n\tint rc;\n\n\tif (config->busy_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tpin_config.pin = config->busy_pin;\n\tpin_config.flags = GPIO_INPUT;\n\trc = gpio_pin_configure(config->busy_port, config->busy_pin, &pin_config);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\n\treturn gpio_pin_get(config->busy_port, config->busy_pin);\n}\n", "CodeBleu_score": 61.05199135559173}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tconst struct auxdisplay_itron_config *config = dev->config;\n\tstruct auxdisplay_itron_data *data = dev->data;\n\tint ret;\n\n\tif (!config->busy_port) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(data->busy_dev, config->busy_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn !ret;\n}\n", "CodeBleu_score": 60.75394643091645}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tstruct auxdisplay_itron_data *data = dev->data;\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint busy_gpio = config->busy_gpio;\n\tint busy_gpio_pin = config->busy_gpio_pin;\n\tint busy_gpio_flags = config->busy_gpio_flags;\n\tint busy_gpio_port = config->busy_gpio_port;\n\tint ret = 0;\n\n\tif (busy_gpio == -1) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_configure(data->busy_gpio_dev, busy_gpio_pin,\n\t\t\t\t busy_gpio_flags);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = gpio_pin_get(data->busy_gpio_dev, busy_gpio_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn (ret == busy_gpio_port);\n}\n", "CodeBleu_score": 55.47452061468417}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint err;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\terr = i2c_write(config->i2c_dev, buffer, sizeof(buffer), config->i2c_addr);\n\tif (err < 0) {\n\t\treturn err;\n\t}\n\n\tk_busy_wait(config->command_delay);\n\n\treturn 0;\n}\n", "CodeBleu_score": 59.95990683078889}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\tret = i2c_write(config->i2c_dev, buffer, sizeof(buffer), config->i2c_addr);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tk_busy_wait(config->special_command_delay);\n\n\treturn ret;\n}\n", "CodeBleu_score": 60.4004222544281}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tstruct auxdisplay_serlcd_config *config = dev->config;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = (uint8_t)command;\n\n\tret = i2c_write(data->i2c, buffer, sizeof(buffer), config->i2c_addr);\n\n\tif (ret == 0) {\n\t\tk_busy_wait(config->command_delay);\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 57.44744627355711}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tconst struct bbram_emul_cfg *cfg = dev->config;\n\tuint8_t *mem = cfg->mem;\n\tint err;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\terr = bbram_emul_check_access(dev, offset, size);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tmemcpy(data, &mem[offset], size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 48.904808694854694}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tstruct bbram_emul_data *data_ = dev->data;\n\tuint8_t *mem = data_->mem;\n\tint ret;\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (mem == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tret = emul_read_buf(dev, offset, mem, size);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tmemcpy(data, mem, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 46.95579393350193}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tstruct bbram_emul_data *dev_data = dev->data;\n\tuint8_t *mem = dev_data->mem;\n\tuint8_t *p;\n\n\tif (offset + size > dev_data->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tp = mem + offset;\n\tmemcpy(data, p, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 50.11268637335816}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *dev_data = dev->data;\n\tuint8_t *bbram_data = dev_data->bbram_data;\n\n\tif (size > BBRAM_DATA_SIZE) {\n\t\tLOG_ERR(\"Cannot write more than %u bytes\", BBRAM_DATA_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > BBRAM_DATA_SIZE) {\n\t\tLOG_ERR(\"Cannot write past end of BBRAM\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev_data->invalid) {\n\t\tLOG_ERR(\"BBRAM is in an invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(&bbram_data[offset], data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 54.81731270842428}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *dev_data = dev->data;\n\tuint8_t *bbram_mem = dev_data->bbram_mem;\n\tsize_t bbram_size = dev_data->bbram_size;\n\tsize_t bbram_offset = offset;\n\n\tif (dev_data->invalid) {\n\t\treturn -EIO;\n\t}\n\n\tif (size > bbram_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif ((bbram_offset + size) > bbram_size) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&bbram_mem[bbram_offset], data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 56.76906129832143}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *data_ = dev->data;\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset + size > data_->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_->state == BBRAM_STATE_INVALID) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data_->data + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 58.009640988724534}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tif (argc < 2) {\n\t\tshell_error(sh, \"Please specify a device\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 80.09847531956812}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tif (argc != 2) {\n\t\tshell_error(sh, \"Missing argument for %s\", argv[0]);\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (!*bbram_dev) {\n\t\tshell_error(sh, \"Could not find device %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 72.89514110278157}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing argument\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}\n", "CodeBleu_score": 65.5160613346979}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev)\tuint8_t *hdr = (uint8_t *)&hci_h4_rx.hdr;\n\tuint8_t hdr_len = HCI_H4_HDR_SIZE;\n\tint err;\n\n\twhile (hdr_len) {\n\t\tuint8_t read;\n\n\t\tread = hdr_len;\n\t\terr = uart_fifo_read(dev, hdr, read);\n\t\tif (err < 0) {\n\t\t\tBT_ERR(\"Unable to read from UART (%d)\", err);\n\t\t\treturn;\n\t\t}\n\n\t\thdr_len -= err;\n\t\thdr += err;\n\t}\n\n\tBT_DBG(\"H:4 <--- %02x %02x %02x %02x\", hdr[0], hdr[1], hdr[2],\n\t       hdr[3]);\n}\n", "CodeBleu_score": 32.252047996658476}, {"code": "static void h4_read_hdr(const struct device *dev)    struct bt_hci_h4_dev *h4 = DEV_DATA(dev);\n    int read;\n    uint8_t buf[4];\n\n    /* Calculate the number of bytes already read */\n    read = h4->rx_len - h4->rx_buf.len;\n\n    /* Attempt to read the remaining bytes from the UART FIFO into the header buffer */\n    if (uart_fifo_read(h4->uart, buf, read) != read) {\n        LOG_ERR(\"Failed to read from UART\");\n        return;\n    }\n\n    /* Update the remaining byte count based on the number of bytes successfully read */\n    h4->rx_len -= read;\n\n    /* Append the bytes read to the header buffer */\n    net_buf_add_mem(&h4->rx_buf, buf, read);\n}\n", "CodeBleu_score": 48.894815340040495}, {"code": "static void h4_read_hdr(const struct device *dev)\tstruct bt_hci_h4_dev_data_t *hci_dev = DEV_DATA(dev);\n\tuint8_t *hdr = hci_dev->rx_buf;\n\tint to_read = hci_dev->rx_len - hci_dev->rx_off;\n\tint read;\n\n\tif (hci_dev->rx_off) {\n\t\tmemcpy(hdr, hci_dev->rx_pkt, hci_dev->rx_off);\n\t}\n\n\tread = uart_fifo_read(hci_dev->uart, hdr + hci_dev->rx_off, to_read);\n\tif (read < 0) {\n\t\tBT_ERR(\"Unable to read from UART\");\n\t\thci_dev->rx_len = 0U;\n\t\thci_dev->rx_off = 0U;\n\t\treturn;\n\t}\n\n\thci_dev->rx_off += read;\n}\n", "CodeBleu_score": 41.879124509144475}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t read;\n\tint err;\n\n\twhile (len) {\n\t\tread = MIN(len, sizeof(buf));\n\t\terr = uart_fifo_read(uart, buf, read);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Failed to read from UART (err %d)\", err);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= read;\n\t}\n\n\treturn read;\n}\n", "CodeBleu_score": 52.92430794713135}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)    uint8_t buf[33];\n    size_t read = 0;\n\n    while (len) {\n        size_t rx_len = MIN(len, sizeof(buf));\n        size_t rx_read = 0;\n\n        if (uart_fifo_read(uart, buf, rx_len) != 0) {\n            LOG_ERR(\"Failed to read from UART device\");\n            return 0;\n        }\n\n        rx_read = rx_len;\n        len -= rx_len;\n        read += rx_len;\n    }\n\n    return read;\n}\n", "CodeBleu_score": 36.1466682315411}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t read;\n\tint err;\n\n\twhile (len) {\n\t\tread = MIN(len, sizeof(buf));\n\t\terr = uart_fifo_read(uart, buf, read);\n\t\tif (err) {\n\t\t\tLOG_ERR(\"Unable to discard %d bytes (%d)\", read, err);\n\t\t\treturn 0;\n\t\t}\n\n\t\tlen -= read;\n\t}\n\n\treturn read;\n}\n", "CodeBleu_score": 43.73842664706694}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    uint8_t hop = 255;\n    for (uint8_t i = 0; i < chan->num_observers; i++) {\n        if (chan->observers[i].enabled && chan->observers[i].priority < hop) {\n            hop = chan->observers[i].priority;\n        }\n    }\n    chan->highest_observer_priority = hop;\n}\n", "CodeBleu_score": 18.89119137559561}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    uint8_t hop = 0xff;\n    for (uint8_t i = 0; i < ZBUS_CHANNEL_MAX_OBSERVERS; i++) {\n        if (chan->observers[i].priority < hop && chan->observers[i].enabled) {\n            hop = chan->observers[i].priority;\n        }\n    }\n    chan->highest_observer_priority = hop;\n}\n", "CodeBleu_score": 19.297823560670622}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    unsigned int hop = 0;\n\n    for (unsigned int i = 0; i < chan->num_observers; i++) {\n        if (chan->observers[i].priority < hop && chan->observers[i].enabled) {\n            hop = chan->observers[i].priority;\n        }\n    }\n\n    chan->highest_observer_priority = hop;\n}\n", "CodeBleu_score": 18.071450748034597}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tstruct zbus_channel_observer *ch_obs;\n\tstruct zbus_channel *ch;\n\n\tlist_for_each_entry(ch_obs, &zbus_channel_observers, list) {\n\t\tch = ch_obs->channel;\n\t\tif (ch->observer == obs) {\n\t\t\tzbus_channel_hop(ch);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 17.65205421703182}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct zbus_channel_observer *ch_obs;\n    struct zbus_channel *ch;\n\n    list_for_each_entry(ch_obs, &zbus_ch_obs_list, list) {\n        ch = ch_obs->channel;\n        if (ch->obs == obs)\n            update_channel_hop(ch);\n    }\n}\n", "CodeBleu_score": 18.044990576871566}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct zbus_channel_observer *co;\n    list_for_each_entry(co, &obs->channels, list) {\n        update_channel_hop(co);\n    }\n}\n", "CodeBleu_score": 18.440188462217034}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    int ret = 0;\n    if (obs == NULL) {\n        ret = -1;\n        goto out;\n    }\n    if (in_isr()) {\n        ret = -1;\n        goto out;\n    }\n    spin_lock(&obs->lock);\n    obs->priority = 0;\n    for (int i = 0; i < obs->num_channels; i++) {\n        struct zbus_channel *chan = obs->channels[i];\n        chan->num_observers++;\n        if (chan->num_observers == 1) {\n            chan->num_observers_enabled++;\n        }\n    }\n    spin_unlock(&obs->lock);", "CodeBleu_score": 37.117083950076854}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    assert(!is_in_isr());\n    assert(obs != NULL);\n\n    spinlock_acquire(&obs->lock);\n    obs->priority = PRIORITY_MIN;\n    zbus_obs_update_channels(obs);\n    spinlock_release(&obs->lock);\n    return 0;\n}\n", "CodeBleu_score": 46.77027558827444}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tassert(!is_in_isr());\n\tassert(obs != NULL);\n\tspin_lock(&obs->lock);\n\tobs->priority = min_thread_priority;\n\tfor (int i = 0; i < ZBUS_MAX_CHANNELS; i++) {\n\t\tif (obs->channels[i].channel != NULL) {\n\t\t\tobs->channels[i].channel->observers[obs->channels[i].priority] = NULL;\n\t\t\tobs->channels[i].channel->observers[obs->priority] = obs;\n\t\t}\n\t}\n\tspin_unlock(&obs->lock);\n\treturn 0;\n}\n", "CodeBleu_score": 40.101907724215366}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)    if (!chan) {\n        return -EINVAL;\n    }\n\n    if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n        return -EINVAL;\n    }\n\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;\n    }\n\n    struct zbus_chan_notify_ctx ctx = {\n        .chan = chan,\n        .timeout = timeout,\n        .end_time = k_uptime_get() + timeout,\n        .prio = k_thread_priority_get(k_current_get()),\n    };\n\n    int err = zbus_chan_lock(chan);\n    if (err) {\n        return err;\n    }\n\n    err = zbus_chan_notify_locked(&ctx);\n\n    zbus_chan_unlock(chan);\n\n    return err;\n}\n", "CodeBleu_score": 48.541908928153276}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)    Z_ASSERT_MSG(chan != NULL, \"Channel is NULL\");\n    timeout = z_timeout_adjust(timeout);\n    int err = 0;\n    k_spinlock_key_t key = k_spin_lock(&chan->lock);\n    if (chan->state == ZBUS_CHAN_STATE_OPEN) {\n        if (timeout == K_NO_WAIT) {\n            err = zbus_chan_notify_locked(chan, K_NO_WAIT);\n        } else {\n            k_spinlock_key_t key = k_spin_lock(&chan->lock);\n            if (chan->state == ZBUS_CHAN_STATE_OPEN) {\n                chan->state = ZBUS_CHAN_STATE_WAITING;\n                chan->end_time = k_uptime_get() + timeout;\n                k_sched_lock();\n                chan->waiting_thread = _current;\n                _current->base.swap_data = (void *) chan;\n                k_spin_unlock(&chan->lock, key);\n                err = z_pend_curr(&chan->lock, key, &chan->wait_q, timeout);\n                chan->waiting_thread = NULL;\n                k_sched_unlock();\n            } else {\n                k_spin_unlock(&chan->lock, key);\n            }\n        }\n    } else {\n        k_spin_unlock(&chan->lock, key);\n    }\n    return err;\n}\n", "CodeBleu_score": 38.61734700210654}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tassert(chan != NULL);\n\n\tif (k_is_in_isr()) {\n\t\ttimeout = K_NO_WAIT;\n\t}\n\n\tk_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n\tint err = 0;\n\tstruct zbus_chan_ctx *ctx = &chan->ctx;\n\tctx->timeout = timeout;\n\tctx->end = k_uptime_get() + ctx->timeout;\n\tctx->prio = k_thread_priority_get(k_current_get());\n\n\terr = zbus_chan_notify_locked(chan);\n\n\tk_spin_unlock(&chan->lock, key);\n\n\treturn err;\n}\n", "CodeBleu_score": 42.1310549592555}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)    uint32_t mask = 0;\n    uint32_t regindex = 0;\n    uint32_t bitindex = 0;\n    uint32_t value = 0;\n    uint32_t tmpreg = 0;\n\n    /* Check the parameters */\n    assert_param(IS_ETH_IT(Int));\n\n    /* Get the interrupt position */\n    Int &= 0x0000FFFF;\n    regindex = (uint32_t)(Int >> 0x05);\n    bitindex = Int & 0x1F;\n    /* Get the interrupt mask */\n    mask = (uint32_t)0x01 << bitindex;\n\n    if (enable) {\n        /* Enable the interrupt */\n        if (regindex == 0x00) {\n            /* Enable the selected ETHERNET interrupts */\n            tmpreg = ETH->DMA_IER;\n            tmpreg |= mask;\n            ETH->DMA_IER = tmpreg;\n        } else if (regindex == 0x01) {\n            /* Enable the selected ETHERNET interrupts */\n            tmpreg = ETH->MAC_IER;\n            tmpreg |= mask;\n            ETH->MAC_IER = tmpreg;\n        }\n    } else {\n        /* Disable the interrupt */\n        if (regindex == 0x00) {\n            /* Disable the selected ETHERNET interrupts */\n            tmpreg = ETH->DMA_IER;\n            tmpreg &= ~mask;\n            ETH->DMA_IER = tmpreg;\n        } else if (regindex == 0x01) {\n            /* Disable the selected ETHERNET interrupts */\n            tmpreg = ETH->MAC_IER;\n            tmpreg &= ~mask;\n            ETH->MAC_IER = tmpreg;\n        }\n    }\n}\n", "CodeBleu_score": 44.84978023440624}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tuint32_t reg;\n\t/* Check the parameters */\n\tassert_param(IS_ETH_IT(Int));\n\t/* Check if the interrupt is normal or abnormal */\n\tif (Int & 0x00000001) {\n\t\t/* Normal interrupt */\n\t\treg = ETH->DMA_INT_EN;\n\t\t/* Enable the selected normal interrupt */\n\t\tif (enable) {\n\t\t\treg |= Int;\n\t\t}\n\t\t/* Disable the selected normal interrupt */\n\t\telse {\n\t\t\treg &= ~Int;\n\t\t}\n\t\t/* Update the normal interrupt enable register */\n\t\tETH->DMA_INT_EN = reg;\n\t}\n\telse {\n\t\t/* Abnormal interrupt */\n\t\treg = ETH->DMA_INT_EN;\n\t\t/* Enable the selected abnormal interrupt */\n\t\tif (enable) {\n\t\t\treg |= Int;\n\t\t}\n\t\t/* Disable the selected abnormal interrupt */\n\t\telse {\n\t\t\treg &= ~Int;\n\t\t}\n\t\t/* Update the abnormal interrupt enable register */\n\t\tETH->DMA_INT_EN = reg;\n\t}\n}\n", "CodeBleu_score": 31.99298807883825}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)    uint32_t temp = 0;\n    uint32_t temp1 = 0;\n    uint32_t temp2 = 0;\n\n    /* Check the parameters */\n    assert_param(IS_ETH_IT(Int));\n\n    /* Check if the interrupt is normal or abnormal */\n    if (Int & ETH_NORMAL_IT) {\n        temp = Int & ETH_NORMAL_IT_MASK;\n        temp1 = ETH->DMAIER & ETH_NORMAL_IT_MASK;\n        temp2 = ETH->DMAIER & ETH_ABNORMAL_IT_MASK;\n    } else {\n        temp = Int & ETH_ABNORMAL_IT_MASK;\n        temp1 = ETH->DMAIER & ETH_NORMAL_IT_MASK;\n        temp2 = ETH->DMAIER & ETH_ABNORMAL_IT_MASK;\n    }\n\n    /* Enable or disable the selected interrupt */\n    if (enable) {\n        temp1 |= temp;\n        temp2 |= temp;\n    } else {\n        temp1 &= ~temp;\n        temp2 &= ~temp;\n    }\n\n    /* Update the DMAIER register */\n    ETH->DMAIER = temp1 | temp2;\n}\n", "CodeBleu_score": 45.23858164650083}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)    ETH_TX_DESC *pTxDesc;\n    uint32_t i = 0;\n\n    pTxDesc = (ETH_TX_DESC *)(ETH_BASE_ADDRESS + 0x1000);\n\n    while (i < NUM_TX_FRAG) {\n        if (pTxDesc->Status & ETH_TX_DESC_OWN) {\n            pTxDesc++;\n            i++;\n        } else {\n            return pTxDesc;\n        }\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 35.08120714244036}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pTxDesc;\n\tETH_TX_DESC *pTxDescStart;\n\tuint32_t reg;\n\tpTxDescStart = pTxDesc = (ETH_TX_DESC *)ETH->TXDESCRIPTOR;\n\twhile (1) {\n\t\treg = pTxDesc->status;\n\t\tif ((reg & ETH_TX_DESC_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tif (pTxDesc == pTxDescStart) {\n\t\t\treturn 0;\n\t\t}\n\t\tpTxDesc = (ETH_TX_DESC *)(pTxDesc->buf);\n\t}\n}\n", "CodeBleu_score": 46.78471972093987}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)    ETH_TX_DESC *pTxDesc;\n    uint32_t i;\n\n    /*\n     * Get the current Tx descriptor address\n     */\n    pTxDesc = (ETH_TX_DESC *) (ETH->DMATXDESCADDR);\n\n    /*\n     * Search for a free descriptor\n     */\n    for (i = 0; i < ETH_TX_DESC_CNT; i++) {\n        if ((pTxDesc->Status & ETH_DMATXDESC_OWN) == 0) {\n            return (pTxDesc);\n        }\n        /*\n         * Get the next descriptor in the list\n         */\n        pTxDesc = (ETH_TX_DESC *) (pTxDesc->Buffer1Addr);\n    }\n\n    /*\n     * No free descriptor found\n     */\n    return (0);\n}\n", "CodeBleu_score": 47.85200167623549}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    RT_ASSERT(device != RT_NULL);\n    struct cyp_dac *dac = (struct cyp_dac *)device->parent.user_data;\n    RT_ASSERT(dac != RT_NULL);\n    Cy_CSDIDAC_OutputEnable(dac->base, channel, *value);\n    return RT_EOK;\n}\n", "CodeBleu_score": 44.078747341804906}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    rt_err_t result = RT_EOK;\n    struct rt_adc_device *adc_dev = (struct rt_adc_device *)device;\n    struct cyp_adc_device *cyp_adc = (struct cyp_adc_device *)adc_dev->parent.user_data;\n    uint32_t result_u32;\n    uint32_t chan_num = channel;\n    if (chan_num >= cyp_adc->max_channel) {\n        LOG_E(\"invalid channel number %d, max channel is %d\", chan_num, cyp_adc->max_channel);\n        return -RT_EINVAL;\n    }\n\n    result_u32 = Cy_CSD_ReadConvertedResult(cyp_adc->csd_base, chan_num);\n    *value = result_u32;\n    return result;\n}\n", "CodeBleu_score": 44.9632300686637}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    struct cyp_dac_device *dac_device;\n    CY_ASSERT(device != NULL);\n    dac_device = (struct cyp_dac_device *)device;\n    CY_ASSERT(dac_device->dac_channel != NULL);\n    if (Cy_CSDIDAC_OutputEnable(dac_device->dac_channel, value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"CSDIDAC output enable failed\");\n        return RT_ERROR;\n    }\n    return RT_EOK;\n}\n", "CodeBleu_score": 46.08704659130669}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\tif (addr + size > IFX_FLASH_END_ADDR) {\n\t\tLOG_E(\"Reading out of flash memory range. Read addr: 0x%08X, size: 0x%08X, flash end addr: 0x%08X\", addr, size, IFX_FLASH_END_ADDR);\n\t\treturn -RT_EINVAL;\n\t}\n\tfor (rt_uint32_t i = 0; i < size; i++) {\n\t\tbuf[i] = *(rt_uint8_t *) (addr + i);\n\t}\n\treturn size;\n}\n", "CodeBleu_score": 49.84646796468027}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\trt_uint32_t i;\n\trt_uint32_t *buf32 = (rt_uint32_t *)buf;\n\n\tif (addr + size > IFX_FLASH_32K_END_ADDR) {\n\t\tLOG_E(\"ERROR: ifx_flash_read_32k: addr + size exceeds flash memory end address\");\n\t\treturn IFX_FLASH_ERROR_INVALID_ARGUMENT;\n\t}\n\n\tfor (i = 0; i < size; i += 4) {\n\t\tbuf32[i / 4] = *(rt_uint32_t *)(IFX_FLASH_32K_BASE_ADDR + addr + i);\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 39.13260773250266}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)    rt_uint32_t end_addr = addr + size;\n    rt_uint32_t i;\n\n    if (end_addr > IFX_FLASH_32K_END_ADDR) {\n        LOG_E(\"read out of bounds\");\n        return -RT_EINVAL;\n    }\n\n    for (i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n\n    return size;\n}\n", "CodeBleu_score": 49.72315052452689}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    RT_ASSERT(hal_timer != NULL);\n    return cyhal_timer_read(hal_timer);\n}\n", "CodeBleu_score": 26.532310365104127}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(hal_timer);\n}\n", "CodeBleu_score": 30.615368973180512}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    rt_uint32_t count;\n    RT_ASSERT(timer != RT_NULL);\n    cyhal_timer_t *hal_timer = (cyhal_timer_t *)timer->parent.user_data;\n    count = cyhal_timer_read(hal_timer);\n    return count;\n}\n", "CodeBleu_score": 70.18568960732952}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void)    int r;\n\n    while (true) {\n        r = pthread_mutex_lock(&dfs_mutex);\n        if (r == 0)\n            break;\n        assert(r == EBUSY);\n        sleep(1);\n    }\n}\n", "CodeBleu_score": 22.66395073320675}, {"code": "void dfs_lock(void)\tint ret;\n\n\tdo {\n\t\tret = pthread_mutex_lock(&dfs_mutex);\n\t\tif (ret == EBUSY) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != 0) {\n\t\t\tassert(0);\n\t\t}\n\t} while (ret != 0);\n}\n", "CodeBleu_score": 22.33274606766684}, {"code": "void dfs_lock(void)\tint ret;\n\n\twhile (1) {\n\t\tret = pthread_mutex_lock(&dfs_mutex);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tassert(ret == 0);\n\t}\n}\n", "CodeBleu_score": 21.37024752020892}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (!fdt->fds[fd])\n            return fd;\n    }\n\n    if (fd == fdt->maxfd) {\n        int old_maxfd = fdt->maxfd;\n\n        if (fdt->maxfd == DFS_FD_MAX)\n            return -1;\n\n        fdt->maxfd = fdt->maxfd * 2;\n        if (fdt->maxfd > DFS_FD_MAX)\n            fdt->maxfd = DFS_FD_MAX;\n\n        fdt->fds = (struct dfs_fd **) realloc(fdt->fds, fdt->maxfd * sizeof(struct dfs_fd *));\n        if (!fdt->fds) {\n            fdt->maxfd = old_maxfd;\n            return -1;\n        }\n\n        for (; fd < fdt->maxfd; fd++)\n            fdt->fds[fd] = NULL;\n    }\n\n    return fd;\n}\n", "CodeBleu_score": 38.31176175696264}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint fd;\n\tstruct files_struct *files = current->files;\n\n\tif (startfd < 0)\n\t\treturn -1;\n\n\tfd = startfd;\n\tspin_lock(&files->file_lock);\n\tfor (; fd < files->max_fds; fd++) {\n\t\tif (fdt->fd[fd] == NULL) {\n\t\t\tif (fd >= files->next_fd)\n\t\t\t\tfiles->next_fd = fd + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&files->file_lock);\n\n\tif (fd >= files->max_fds && expand_files(files, fd) < 0)\n\t\treturn -1;\n\n\treturn fd;\n}\n", "CodeBleu_score": 38.72023312906773}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int fd;\n\n    for (fd = startfd; fd < fdt->maxfd; fd++) {\n        if (fdt->fds[fd] == NULL) {\n            return fd;\n        }\n    }\n\n    /* No empty fd found, expand the fd table */\n    return fd_expand_table(fdt, startfd);\n}\n", "CodeBleu_score": 32.76980608696011}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error)    static const char *errstr[] = {\n        \"EOK\",\n        \"EPERM\",\n        \"ENOENT\",\n        \"EIO\",\n        \"ENXIO\",\n        \"E2BIG\",\n        \"ENOEXEC\",\n        \"EBADF\",\n        \"ECHILD\",\n        \"EAGAIN\",\n        \"ENOMEM\",\n        \"EACCES\",\n        \"EFAULT\",\n        \"ENOTBLK\",\n        \"EBUSY\",\n        \"EEXIST\",\n        \"EXDEV\",\n        \"ENODEV\",\n        \"ENOTDIR\",\n        \"EISDIR\",\n        \"EINVAL\",\n        \"ENFILE\",\n        \"EMFILE\",\n        \"ENOTTY\",\n        \"ETXTBSY\",\n        \"EFBIG\",\n        \"ENOSPC\",\n        \"ESPIPE\",\n        \"EROFS\",\n        \"EMLINK\",\n        \"EPIPE\",\n        \"EDOM\",\n        \"ERANGE\",\n        \"EDEADLK\",\n        \"ENAMETOOLONG\",\n        \"ENOLCK\",\n        \"ENOSYS\",\n        \"ENOTEMPTY\",\n        \"ELOOP\",\n        \"EWOULDBLOCK\",\n        \"ENOMSG\",\n        \"EIDRM\",\n        \"ECHRNG\",\n        \"EL2NSYNC\",\n        \"EL3HLT\",\n        \"EL3RST\",\n        \"ELNRNG\",\n        \"EUNATCH\",\n        \"ENOCSI\",\n        \"EL2HLT\",\n        \"EBADE\",\n        \"EBADR\",\n        \"EXFULL\",\n        \"ENOANO\",\n        \"EBADRQC\",\n        \"EBADSLT\",\n        \"EDEADLOCK\",\n        \"EBFONT\",\n        \"ENOSTR\",\n        \"ENODATA\",\n        \"ETIME\",\n        \"ENOSR\",\n        \"ENONET\",\n        \"ENOPKG\",\n        \"EREMOTE\",\n        \"ENOLINK\",\n        \"EADV\",\n        \"ESRM", "CodeBleu_score": 8.01136681756676}, {"code": "const char *rt_strerror(rt_err_t error)    static const char *rt_error_str[] = {\n        \"EOK\",\n        \"EPERM\",\n        \"ENOENT\",\n        \"EIO\",\n        \"ENXIO\",\n        \"EINTR\",\n        \"EINVAL\",\n        \"ENOEXEC\",\n        \"EBADF\",\n        \"ECHILD\",\n        \"EAGAIN\",\n        \"ENOMEM\",\n        \"EACCES\",\n        \"EFAULT\",\n        \"EBUSY\",\n        \"EEXIST\",\n        \"EXDEV\",\n        \"ENODEV\",\n        \"ENOTDIR\",\n        \"EISDIR\",\n        \"EINVAL\",\n        \"ENFILE\",\n        \"EMFILE\",\n        \"ENOTTY\",\n        \"EFBIG\",\n        \"ENOSPC\",\n        \"ESPIPE\",\n        \"EROFS\",\n        \"EMLINK\",\n        \"EPIPE\",\n        \"EDOM\",\n        \"ERANGE\",\n        \"EDEADLK\",\n        \"ENAMETOOLONG\",\n        \"ENOLCK\",\n        \"ENOSYS\",\n        \"ENOTEMPTY\",\n        \"ELOOP\",\n        \"EWOULDBLOCK\",\n        \"ENOMSG\",\n        \"EIDRM\",\n        \"ECHRNG\",\n        \"EL2NSYNC\",\n        \"EL3HLT\",\n        \"EL3RST\",\n        \"ELNRNG\",\n        \"EUNATCH\",\n        \"ENOCSI\",\n        \"EL2HLT\",\n        \"EBADE\",\n        \"EBADR\",\n        \"EXFULL\",\n        \"ENOANO\",\n        \"EBADRQC\",\n        \"EBADSLT\",\n        \"EDEADLOCK\",\n        \"EBFONT\",\n        \"ENOSTR\",\n        \"ENODATA\",\n        \"ETIME\",\n        \"ENOSR\",\n        \"ENONET\",\n        \"ENOPKG\",\n        \"EREMOTE\",\n        \"ENOLINK\",\n        \"EADV\",\n        \"ESRMNT\",\n        \"ECO", "CodeBleu_score": 8.130766373634517}, {"code": "const char *rt_strerror(rt_err_t error)    static const char *error_strings[] = {\n        \"EOK\",\n        \"EPERM\",\n        \"ENOENT\",\n        \"EIO\",\n        \"ENXIO\",\n        \"EINTR\",\n        \"EINVAL\",\n        \"ENOEXEC\",\n        \"EBADF\",\n        \"ECHILD\",\n        \"EAGAIN\",\n        \"ENOMEM\",\n        \"EACCES\",\n        \"EFAULT\",\n        \"EBUSY\",\n        \"EEXIST\",\n        \"EXDEV\",\n        \"ENODEV\",\n        \"ENOTDIR\",\n        \"EISDIR\",\n        \"EINVAL\",\n        \"ENFILE\",\n        \"EMFILE\",\n        \"ENOTTY\",\n        \"EFBIG\",\n        \"ENOSPC\",\n        \"ESPIPE\",\n        \"EROFS\",\n        \"EMLINK\",\n        \"EPIPE\",\n        \"EDOM\",\n        \"ERANGE\",\n        \"EDEADLK\",\n        \"ENAMETOOLONG\",\n        \"ENOLCK\",\n        \"ENOSYS\",\n        \"ENOTEMPTY\",\n        \"ELOOP\",\n        \"EWOULDBLOCK\",\n        \"ENOMSG\",\n        \"EIDRM\",\n        \"ECHRNG\",\n        \"EL2NSYNC\",\n        \"EL3HLT\",\n        \"EL3RST\",\n        \"ELNRNG\",\n        \"EUNATCH\",\n        \"ENOCSI\",\n        \"EL2HLT\",\n        \"EBADE\",\n        \"EBADR\",\n        \"EXFULL\",\n        \"ENOANO\",\n        \"EBADRQC\",\n        \"EBADSLT\",\n        \"EDEADLOCK\",\n        \"EBFONT\",\n        \"ENOSTR\",\n        \"ENODATA\",\n        \"ETIME\",\n        \"ENOSR\",\n        \"ENONET\",\n        \"ENOPKG\",\n        \"EREMOTE\",\n        \"ENOLINK\",\n        \"EADV\",\n        \"ESRMNT\",\n        \"ECOMM\",", "CodeBleu_score": 8.07943845525314}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_err_t ret;\n    rt_base_t level;\n    rt_thread_t tid;\n    rt_list_t *list;\n    struct rt_idle_hook *idle_hook;\n\n    tid = rt_thread_self();\n    if (tid != rt_thread_find(\"tidle\")) {\n        return -RT_ERROR;\n    }\n\n    idle_hook = (struct rt_idle_hook *)rt_malloc(sizeof(struct rt_idle_hook));\n    if (idle_hook == RT_NULL) {\n        return -RT_ENOMEM;\n    }\n\n    idle_hook->hook = hook;\n\n    level = rt_hw_interrupt_disable();\n    list = &(rt_thread_self()->idle_hook_list);\n    ret = rt_list_insert_before(list, &(idle_hook->list));\n    rt_hw_interrupt_enable(level);\n\n    return ret;\n}\n", "CodeBleu_score": 23.988321144438096}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_err_t ret = RT_EOK;\n    rt_base_t level;\n    rt_thread_t tid;\n    struct rt_object *object;\n    struct rt_list_node *node;\n\n    tid = rt_thread_self();\n    if (tid == RT_NULL) {\n        return -RT_EINVAL;\n    }\n\n    level = rt_hw_interrupt_disable();\n    /* find idle thread */\n    object = rt_object_find(RT_IDLE_THREAD_NAME, RT_Object_Class_Thread);\n    if (object == RT_NULL) {\n        /* no idle thread, just return */\n        rt_hw_interrupt_enable(level);\n        return -RT_ERROR;\n    }\n\n    /* lock scheduler */\n    rt_enter_critical();\n    /* find an empty hook */\n    rt_list_for_each(node, &((rt_thread_t)object)->idle_hook_list) {\n        if (rt_list_entry(node, struct idle_hook_list, list) == RT_NULL) {\n            rt_list_entry(node, struct idle_hook_list, list) = hook;\n            goto __exit;\n        }\n    }\n\n    /* no hook entry found */\n    ret = -RT_EFULL;\n", "CodeBleu_score": 27.417885935871393}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_err_t result;\n    rt_base_t level;\n    rt_thread_t thread;\n    rt_object_t object;\n    struct rt_object_information *information;\n    struct rt_list_node *node;\n    struct rt_list_node *list;\n    int i;\n\n    /* get current context */\n    thread = rt_thread_self();\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* get object information */\n    information = rt_object_get_information(RT_Object_Class_Thread);\n    RT_ASSERT(information != RT_NULL);\n    list = &(information->object_list);\n\n    /* try to find an empty hook */\n    for (i = 0; i < information->object_size; i++) {\n        /* get object */\n        object = rt_list_entry(list, struct rt_object, list);\n        if (object != RT_NULL && object->type == RT_Object_Class_Thread) {\n            struct rt_thread *thread = (struct rt_thread *)object;\n            if (thread == thread)\n                continue;\n\n            for (node = thread->idle_hook_list.next; node != &(thread->idle_hook_list); node = node->next) {\n                if (rt_list_entry(node, struct idle_hook_list, list) == RT_NULL)\n                    break;\n            }\n\n            /* empty hook */\n            if (node != &(thread->idle_hook_list)) {\n                struct idle_hook_list *hook_list;\n\n                /* disable interrupt */\n                level = rt_hw_interrupt_disable();\n\n                /* try to find an empty hook */\n                for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n                    if (thread->idle_hook_list[i] == RT_NULL)\n                        break;\n                }\n\n                /* no more hooks */\n                if (i >= RT_IDLE_HO", "CodeBleu_score": 41.84126753958907}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_err_t result;\n    struct rt_thread *thread;\n    struct rt_object *object;\n    rt_base_t level;\n    rt_list_t *l;\n    struct rt_idle_hook *idle_hook;\n\n    object = &rt_thread_idle_obj;\n    thread = rt_object_allocate(object, RT_Object_Class_Thread, \"idle\");\n    if (thread == RT_NULL) {\n        return -RT_ERROR;\n    }\n\n    level = rt_hw_interrupt_disable();\n    rt_list_for_each(l, &(thread->idle_hook_list)) {\n        idle_hook = rt_list_entry(l, struct rt_idle_hook, list);\n        if (idle_hook->hook == hook) {\n            rt_list_remove(&(idle_hook->list));\n            result = RT_EOK;\n            break;\n        }\n    }\n    rt_hw_interrupt_enable(level);\n\n    if (l == &(thread->idle_hook_list)) {\n        result = -RT_ERROR;\n    }\n\n    rt_object_delete(object);\n    return result;\n}\n", "CodeBleu_score": 39.33523215986477}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_err_t result;\n    struct rt_thread *thread;\n    struct rt_object_information *information;\n    rt_base_t level;\n    rt_list_t *node;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* get current thread */\n    thread = rt_thread_self();\n    /* get idle hook list */\n    information = rt_object_get_information(RT_Object_Class_Thread);\n    RT_ASSERT(information != RT_NULL);\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* iterate over the idle hook list */\n    for (node = information->object_list.next; node != &(information->object_list); node = node->next) {\n        /* get thread */\n        thread = rt_list_entry(node, struct rt_thread, list);\n        /* check thread type */\n        if (thread->type != RT_Object_Class_Thread)\n            continue;\n        /* check whether hook is in idle hook list */\n        if (thread->idle_hook == hook) {\n            /* remove idle hook */\n            thread->idle_hook = RT_NULL;\n            /* unlock scheduler */\n            rt_exit_critical();\n            /* enable interrupt */\n            rt_hw_interrupt_enable(level);\n            /* return successfully */\n            return RT_EOK;\n        }\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n    /* return error */\n    return -RT_ERROR;\n}\n", "CodeBleu_score": 35.36211237371099}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_err_t ret = RT_EOK;\n    struct rt_idle_hook *idle_hook;\n\n    /* disable interrupt */\n    rt_spin_lock(&idle_hook_spin);\n\n    /* find idle hook */\n    idle_hook = idle_hook_list;\n    while (idle_hook != RT_NULL) {\n        if (idle_hook->hook == hook) {\n            /* remove idle hook */\n            idle_hook->hook = RT_NULL;\n            goto out;\n        }\n\n        idle_hook = idle_hook->next;\n    }\n\n    /* not found */\n    ret = -RT_ERROR;\n", "CodeBleu_score": 38.29336294477703}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_ubase_t level;\n    rt_thread_t thread;\n    rt_list_t *node;\n\n    /* disable interrupt */\n    level = rt_hw_interrupt_disable();\n\n    /* resume all suspended threads */\n    while (!rt_list_isempty(susp_list)) {\n        /* get next suspended thread */\n        node = susp_list->next;\n        rt_list_remove(node);\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n        /* set error number */\n        thread->error = thread_error;\n\n        /*\n         * insert to defferred thread list,\n         * it will be waked up when scheduler is up\n         */\n        rt_list_insert_before(&(rt_thread_defunct->tlist), node);\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 29.58790677241474}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_thread_t thread;\n    rt_list_t *node;\n\n    rt_enter_critical();\n    while (!rt_list_isempty(susp_list)) {\n        node = susp_list->next;\n        rt_list_remove(node);\n        rt_exit_critical();\n\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n        thread->error = thread_error;\n        rt_thread_resume(thread);\n\n        rt_enter_critical();\n    }\n    rt_exit_critical();\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 31.72133661853812}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    struct rt_thread *thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (\"thread %.*s resume all threads in list\\n\", RT_NAME_MAX, rt_thread_self()->name));\n\n    /* disable interrupt */\n    rt_enter_critical();\n\n    /* resume all threads in list */\n    while (!rt_list_isempty(susp_list)) {\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        rt_thread_resume(thread);\n\n        /* set error number */\n        thread->error = thread_error;\n    }\n\n    /* enable interrupt */\n    rt_exit_critical();\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 33.37894718084685}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t new_dev;\n    rt_device_t old_dev;\n\n    old_dev = rt_console_get_device();\n\n    if ((new_dev = rt_device_find(name)) != RT_NULL) {\n        if (new_dev != old_dev) {\n            /* close old console */\n            if (old_dev != RT_NULL) {\n                rt_device_close(old_dev);\n            }\n            /* open new console */\n            rt_device_open(new_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n            /* set new console device */\n            rt_console_set_device(new_dev);\n        }\n    }\n\n    return old_dev;\n}\n", "CodeBleu_score": 51.96410635901228}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t new_dev;\n    rt_device_t old_dev;\n\n    old_dev = rt_console_get_device();\n    if (old_dev != RT_NULL && rt_strcmp(old_dev->parent.name, name) == 0) {\n        return old_dev;\n    }\n\n    new_dev = rt_device_find(name);\n    if (new_dev != RT_NULL) {\n        if (old_dev != RT_NULL) {\n            rt_device_close(old_dev);\n        }\n        if (rt_device_open(new_dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n            rt_console_set_device(new_dev);\n            return old_dev;\n        }\n    }\n\n    return RT_NULL;\n}\n", "CodeBleu_score": 57.82372018732118}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t new_device, old_device;\n    /* save current device */\n    old_device = rt_console_get_device();\n    /* find new console device, and set it up */\n    new_device = rt_device_find(name);\n    if (new_device != old_device) {\n        if (old_device != RT_NULL) {\n            rt_device_close(old_device);\n        }\n        if (new_device != RT_NULL && rt_device_open(new_device, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n            rt_console_set_device(new_device);\n        } else {\n            rt_kprintf(\"error: the new console device was not found.\\n\");\n        }\n    }\n    return old_device;\n}\n", "CodeBleu_score": 61.756018001604716}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type)\tint i;\n\tstruct rt_object *object;\n\tstruct rt_list_node *node;\n\tstruct rt_object_information *information;\n\tint length = 0;\n\n\tinformation = &rt_object_container[type];\n\trt_enter_critical();\n\trt_list_for_each(node, &(information->object_list)) {\n\t\tobject = rt_list_entry(node, struct rt_object, list);\n\t\tlength++;\n\t}\n\trt_exit_critical();\n\treturn length;\n}\n", "CodeBleu_score": 45.27588466073833}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tint i;\n\tstruct rt_object *object;\n\tint length = 0;\n\trt_object_list_lock(type);\n\tfor (i = 0; i < MAX_RT_OBJECTS; i++) {\n\t\tobject = rt_object_list[type][i];\n\t\tif (object != NULL) {\n\t\t\tlength++;\n\t\t}\n\t}\n\trt_object_list_unlock(type);\n\treturn length;\n}\n", "CodeBleu_score": 31.6284032550788}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tint length = 0;\n\tstruct rt_object *object;\n\trt_object_information[type].lock.lock();\n\tobject = rt_object_information[type].object_list;\n\twhile (object != NULL) {\n\t\tlength++;\n\t\tobject = object->next;\n\t}\n\trt_object_information[type].lock.unlock();\n\treturn length;\n}\n", "CodeBleu_score": 32.07462508197805}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object)    if (object == RT_NULL) {\n        return;\n    }\n\n    /* invoke object hook */\n    if (object->type != RT_Object_Class_Null) {\n        rt_object_delete_hook(object);\n    }\n\n    /* unlock object */\n    rt_object_unlock(object);\n\n    /* set object type to RT_Object_Class_Null */\n    object->type = RT_Object_Class_Null;\n}\n", "CodeBleu_score": 37.197908792784155}, {"code": "void rt_object_detach(rt_object_t object)    rt_list_t *list;\n    struct rt_object_information *information;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n    RT_ASSERT(rt_object_get_type(object) != RT_Object_Class_Unknown);\n\n    /* which list */\n    information = rt_object_get_information(object->type);\n    RT_ASSERT(information != RT_NULL);\n\n    list = &(information->object_list);\n\n    rt_enter_critical();\n    /* remove from old list */\n    rt_list_remove(list, object);\n    rt_exit_critical();\n\n    /* invoke object hook */\n    if (information->detach_func != RT_NULL)\n        information->detach_func(object);\n\n    /* set object type to unknown */\n    object->type = RT_Object_Class_Unknown;\n}\n", "CodeBleu_score": 54.663550913664935}, {"code": "void rt_object_detach(rt_object_t object)    register rt_base_t temp;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n    RT_ASSERT(rt_object_get_type(object) != RT_Object_Class_Null);\n\n    /* disable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* invoke object hook */\n    if (object->type != RT_Object_Class_Null && rt_object_is_systemobject(object) == RT_FALSE)\n        object->cleanup(object);\n\n    /* detach object */\n    rt_object_detach_internal(object);\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(temp);\n}\n", "CodeBleu_score": 25.980478798972495}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_custom_object_t custom_obj;\n\trt_err_t result;\n\n\tif (obj == NULL) {\n\t\treturn RT_ERR_NULL_POINTER;\n\t}\n\n\tif (rt_object_get_class_id(obj) != RT_CLASS_CUSTOM_OBJECT) {\n\t\treturn RT_ERR_INVALID_TYPE;\n\t}\n\n\tcustom_obj = (rt_custom_object_t) obj;\n\n\tif (custom_obj->destroy != NULL) {\n\t\tresult = custom_obj->destroy(custom_obj);\n\t} else {\n\t\tresult = RT_OK;\n\t}\n\n\trt_object_delete(obj);\n\n\treturn result;\n}\n", "CodeBleu_score": 42.50626553819396}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t result = RT_OK;\n    rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n\n    /* Check if object is valid */\n    if (custom_obj == RT_NULL) {\n        return RT_ERR_OBJ_INVALID;\n    }\n\n    /* Check if object is of the custom object class type */\n    if (custom_obj->parent.type != RT_Object_Class_Custom) {\n        return RT_ERR_OBJ_INVALID;\n    }\n\n    /* Call custom destroy method */\n    if (custom_obj->destroy != RT_NULL) {\n        result = custom_obj->destroy(custom_obj);\n    }\n\n    /* Delete object */\n    rt_free(custom_obj);\n\n    return result;\n}\n", "CodeBleu_score": 47.03544329170715}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t result = RT_OK;\n    if (obj == NULL) {\n        return RT_ERR_NULL_POINTER;\n    }\n    if (obj->type != RT_Object_Class_Custom) {\n        return RT_ERR_TYPE_INVALID;\n    }\n    if (obj->destroy != NULL) {\n        result = obj->destroy(obj);\n    }\n    rt_object_delete(obj);\n    return result;\n}\n", "CodeBleu_score": 49.75665897884042}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void)\tk_tid_t tid = k_current_get();\n\n\t/*\n\t * Check if the current thread is the idle thread.\n\t * If so, this is an error.\n\t */\n\tif (tid == &_k_idle_thread) {\n\t\tk_panic();\n\t}\n\n\t/*\n\t * Enter a critical section.\n\t * This ensures that the current thread is not preempted\n\t * and that scheduler is locked.\n\t */\n\t_sched_lock();\n\n\t/*\n\t * Close the thread.\n\t */\n\t_thread_monitor_exit(tid);\n\t_k_object_unref(tid);\n\t_abort_thread_timeout(tid);\n\n\t/*\n\t * Add the thread to the defunct thread list.\n\t */\n\t_mark_thread_as_defunct(tid);\n\n\t/*\n\t * Exit the critical section.\n\t */\n\t_sched_unlock();\n\n\t/*\n\t * Trigger a context switch to the next task.\n\t */\n\t_Swap(irq_lock());\n\tCODE_UNREACHABLE;\n}\n", "CodeBleu_score": 47.98371999294988}, {"code": "static void _thread_exit(void)\tstruct _thread_ *t;\n\tt = _thread_current_get();\n\t_irq_disable();\n\t_sched_critical_section_start();\n\tt->state = _THREAD_STATE_DEFUNCT;\n\t_sched_critical_section_end();\n\t_sched_switch();\n}\n", "CodeBleu_score": 43.90439861092052}, {"code": "static void _thread_exit(void)\tkthread_t* current_thread;\n\tkthread_t* next_thread;\n\tcurrent_thread = _current_thread;\n\tcurrent_thread->state = THREAD_STATE_DEFUNCT;\n\tnext_thread = _scheduler();\n\t_switch_context(current_thread, next_thread);\n}\n", "CodeBleu_score": 44.28106132379324}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter)\tkthread_t *thread = (kthread_t *)parameter;\n\tint error = ETIMEDOUT;\n\t\n\tksched_lock();\n\t\n\tif( !thread_is_suspended(thread) ) {\n\t\tkpanic();\n\t}\n\t\n\tthread->error = error;\n\t\n\tthread_unsuspend(thread);\n\t\n\tksched_unlock();\n}\n", "CodeBleu_score": 29.532862022281535}, {"code": "static void _thread_timeout(void *parameter)\tkthread_t *thread = (kthread_t *)parameter;\n\n\t/* Check to make sure the thread is suspended. */\n\tif (thread->state != THREAD_SUSPENDED)\n\t\treturn;\n\n\t/* Lock the scheduler. */\n\t_scheduler_lock();\n\n\t/* Set the thread's error number. */\n\tthread->errno = ETIMEDOUT;\n\n\t/* Remove the thread from the suspend list. */\n\tlist_remove((list_t *)thread->suspend_node.list);\n\n\t/* Insert the thread into the ready list. */\n\t_thread_ready(thread);\n\n\t/* Unlock the scheduler. */\n\t_scheduler_unlock();\n}\n", "CodeBleu_score": 30.47028941810884}, {"code": "static void _thread_timeout(void *parameter)\tkthread_t *thread = (kthread_t *)parameter;\n\n\t/* Verify the thread is suspended. */\n\tif ( thread->state != THREAD_SUSPENDED ) {\n\t\t/* The thread is not suspended, so we can't timeout. */\n\t\treturn;\n\t}\n\n\t/* Lock the scheduler. */\n\tsched_lock();\n\n\t/* Verify the thread is still suspended. */\n\tif ( thread->state != THREAD_SUSPENDED ) {\n\t\t/* The thread is no longer suspended, so we can't timeout. */\n\t\tsched_unlock();\n\t\treturn;\n\t}\n\n\t/* Set the thread's error number. */\n\tthread->error = ETIMEDOUT;\n\n\t/* Remove the thread from the suspend list. */\n\tlist_remove( &thread->suspend );\n\n\t/* Insert the thread into the ready list. */\n\tlist_insert( &thread->ready, &ready_list );\n\n\t/* Unlock the scheduler. */\n\tsched_unlock();\n}\n", "CodeBleu_score": 33.002031440380165}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_mutex_t mutex;\n\trt_bool_t state;\n\n\t/* Lock thread's spinlock. */\n\tstate = _thread_spin_lock(&thread->spinlock);\n\n\t/* Check if thread is waiting on a mutex. */\n\tif (thread->pending_object != NULL) {\n\t\t/* Get mutex. */\n\t\tmutex = (rt_mutex_t)thread->pending_object;\n\n\t\t/* Remove thread from mutex's waiting list. */\n\t\t_thread_list_remove(&mutex->waiting_list, thread);\n\n\t\t/* Clear thread's pending object. */\n\t\tthread->pending_object = NULL;\n\t}\n\n\t/* Restore spinlock state. */\n\t_thread_spin_unlock(&thread->spinlock, state);\n\n\t/* Release all mutexes the thread has taken. */\n\t_thread_release_all_mutexes(thread);\n}\n", "CodeBleu_score": 18.952049987766678}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)    rt_mutex_t mutex;\n    rt_mutex_t *mutex_list;\n    rt_uint8_t mutex_count;\n\n    /* get thread's mutex list */\n    mutex_list = thread->mutex_list;\n    mutex_count = thread->mutex_count;\n\n    /* remove thread from mutex wait list */\n    while (mutex_count) {\n        mutex = mutex_list[mutex_count - 1];\n        rt_list_remove(&(thread->tlist));\n        mutex->owner = RT_NULL;\n        mutex->hold = 0;\n        mutex_count --;\n    }\n\n    /* clean mutex list */\n    thread->mutex_count = 0;\n}\n", "CodeBleu_score": 31.055339223098144}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)    rt_mutex_t mutex;\n    rt_list_t *list;\n\n    rt_spin_lock(&(thread->spinlock));\n\n    mutex = thread->pending_object;\n    if (mutex) {\n        /* remove from mutex waiting list */\n        list = &(mutex->waiting_list);\n        rt_list_remove(list, &(thread->tlist));\n        /* wake up suspended threads */\n        if (!rt_list_isempty(list)) {\n            rt_schedule();\n        }\n\n        thread->pending_object = RT_NULL;\n        thread->error = -RT_ETIMEOUT;\n    }\n\n    /* release all mutexes the thread has taken */\n    while (thread->hold_mutex_list != RT_NULL) {\n        _mutex_release(thread->hold_mutex_list, thread);\n    }\n\n    rt_spin_unlock(&(thread->spinlock));\n}\n", "CodeBleu_score": 38.669214805132626}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    /* Check for null thread */\n    if (thread == RT_NULL) {\n        return -RT_ERROR;\n    }\n    /* Check for thread in initialization state */\n    if (thread->stat != RT_THREAD_INIT) {\n        return -RT_ERROR;\n    }\n    /* Check for thread type */\n    if (thread->type != RT_Thread) {\n        return -RT_ERROR;\n    }\n    /* Log thread name and priority */\n    LOG_I(\"thread startup: %.*s (priority: %d)\", RT_NAME_MAX, thread->name, thread->current_priority);\n    /* Calculate thread priority attributes */\n    rt_schedule_calculate_init(thread);\n    /* Reset thread state to suspended */\n    thread->stat = RT_THREAD_SUSPEND;\n    /* Resume thread */\n    rt_schedule_resume_thread(thread);\n    /* Trigger scheduler if available */\n    rt_schedule();\n    return RT_EOK;\n}\n", "CodeBleu_score": 46.50756501390375}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    /* Check for null thread */\n    if (thread == RT_NULL) {\n        return RT_ERROR;\n    }\n    /* Check if thread is in the initialization state */\n    if (thread->stat != RT_THREAD_INIT) {\n        return RT_ERROR;\n    }\n    /* Check if thread is of the correct type */\n    if (thread->type != RT_Thread) {\n        return RT_ERROR;\n    }\n    /* Log the thread's name and priority */\n    LOG_D(\"thread:%s start\", thread->name);\n    LOG_D(\"thread:%s priority:%d\", thread->name, thread->init_priority);\n    /* Calculate the thread's priority attributes */\n    rt_thread_priority_recalculate(thread);\n    /* Reset the thread's state to suspended */\n    thread->stat = RT_THREAD_SUSPEND;\n    /* Resume the thread */\n    rt_thread_resume(thread);\n    /* Trigger the scheduler */\n    rt_schedule();\n    return RT_EOK;\n}\n", "CodeBleu_score": 46.77590630150448}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    rt_ubase_t temp;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(rt_object_get_type(&thread->parent.parent) == RT_Object_Class_Thread);\n    RT_ASSERT(rt_object_is_systemobject(&thread->parent.parent));\n\n    RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread startup: %s\\n\", thread->name));\n\n    /* initialize thread timer */\n    rt_timer_init(&(thread->thread_timer),\n                  thread->name,\n                  rt_thread_timeout,\n                  thread,\n                  0,\n                  RT_TIMER_FLAG_ONE_SHOT);\n\n    /* thread state check (RUNNING) */\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    /* set thread to suspend state */\n    temp = rt_hw_interrupt_disable();\n    thread->stat = RT_THREAD_SUSPEND;\n    rt_hw_interrupt_enable(temp);\n\n    /* set thread priority */\n    rt_thread_control(thread,\n                      RT_THREAD_CTRL_CHANGE_PRIORITY,\n                      &(thread->init_priority));\n\n    /* set thread preempt (enable) */\n    temp = rt_hw_interrupt_disable();\n    thread->scheduler_lock_nest = 0;\n    rt_hw_interrupt_enable(temp);\n\n    /* add to object list */\n    rt_object_take(&(thread->parent.parent), RT_WAITING_FOREVER);\n\n    /* resume thread */\n    rt_thread_resume(thread);\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 44.583065721340304}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    struct rt_timer *timer;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ETIMEOUT;\n    }\n\n    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n\n    *timeout_tick = timer->timeout_tick;\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 76.79691347402652}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_timer_t timer;\n    rt_tick_t tick;\n    rt_uint8_t index;\n\n    /* get the first timer */\n    timer = rt_list_entry(timer_list[0].next, struct rt_timer, row[0]);\n\n    /* get timeout tick */\n    tick = timer->timeout_tick;\n\n    /* get timer index */\n    index = timer->index;\n\n    /* set next timeout tick */\n    *timeout_tick = tick;\n\n    /* remove timer from timer list */\n    rt_list_remove(&timer->row[index]);\n\n    /* recalculate timeout tick of the timer list */\n    _timer_list_recalculate_next_timeout(timer_list, index);\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 43.16930695837215}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_err_t ret;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        /* no timer exist */\n        ret = -RT_ETIMEOUT;\n    } else {\n        /* get next timeout tick */\n        struct rt_timer *timer;\n\n        timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,\n                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n        *timeout_tick = timer->timeout_tick;\n        ret = RT_EOK;\n    }\n\n    return ret;\n}\n", "CodeBleu_score": 74.13583555195339}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)  rt_timer_t timer;\n\n  /* check parameters */\n  RT_ASSERT(timeout != RT_NULL);\n  RT_ASSERT(time >= 0);\n\n  timer = rt_object_allocate(RT_Object_Class_Timer, name);\n  if (timer != RT_NULL) {\n    /* set flag */\n    timer->parent.flag = flag;\n\n    /* set deactivated */\n    timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;\n\n    timer->timeout_func = timeout;\n    timer->parameter    = parameter;\n    timer->timeout_tick = time;\n\n    rt_object_init(&(timer->parent), RT_Object_Class_Timer, name);\n  }\n\n  return timer;\n}", "CodeBleu_score": 51.223788954185444}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)  rt_timer_t timer;\n\n  RT_ASSERT(timeout != RT_NULL);\n\n  /* allocate a timer */\n  timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n  if (timer == RT_NULL) {\n    return RT_NULL;\n  }\n\n  /* initialize timer */\n  rt_memset(timer, 0, sizeof(struct rt_timer));\n\n  rt_strncpy(timer->parent.name, name, RT_NAME_MAX);\n\n  timer->timeout_func = timeout;\n  timer->parameter    = parameter;\n\n  timer->timeout_tick = time;\n  timer->init_tick    = time;\n\n  timer->parent.flag  = flag;\n\n  return timer;\n}\n", "CodeBleu_score": 54.8389500359717}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)  rt_timer_t timer;\n\n  /* parameter check */\n  RT_ASSERT(timeout != RT_NULL);\n\n  /* allocate object */\n  timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n  if (timer != RT_NULL) {\n    /* set flag */\n    timer->parent.flag = flag;\n\n    /* initialize timer */\n    rt_timer_init(timer, name, timeout, parameter, time, flag);\n  }\n\n  return timer;\n}\n", "CodeBleu_score": 50.58017099857555}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\tvar rr *httptest.ResponseRecorder\n\tfor _, h := range a.handlers {\n\t\trr = httptest.NewRecorder()\n\t\th.ServeHTTP(rr, req)\n\t\tfor k, v := range rr.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t\tres.WriteHeader(rr.Code)\n\t\tif rr.Code == http.StatusUnauthorized {\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 53.78589613774708}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Create a new context for the request.\n\tctx := req.Context()\n\n\t// Create a new recorder for the response.\n\trec := httptest.NewRecorder()\n\n\t// Pass the request through the handlers.\n\tfor _, handler := range a.handlers {\n\t\thandler.ServeHTTP(rec, req)\n\t\t// Copy the headers to the response.\n\t\tfor key, values := range rec.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\t\t// Check for unauthorized status.\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\t// Send an unauthorized error response.\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Forward the request to the router.\n\ta.router.ServeHTTP(res, req.WithContext(ctx))\n}", "CodeBleu_score": 61.0836434206464}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\tvar (\n\t\tctx     = req.Context()\n\t\thandler = a.handler\n\t\tstatus  int\n\t\terr     error\n\t)\n\tfor _, h := range a.handlers {\n\t\thandler = h(handler)\n\t}\n\tif status, err = handler(ctx, res, req); err != nil {\n\t\ta.logger.Error(err)\n\t\thttp.Error(res, http.StatusText(status), status)\n\t\treturn\n\t}\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 38.589907988809664}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\n\tdata, err := a.assets.ReadFile(\"static\" + path)\n\tif err != nil {\n\t\tres.WriteHeader(404)\n\t\treturn\n\t}\n\n\tswitch {\n\tcase strings.HasSuffix(path, \".js\"):\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase strings.HasSuffix(path, \".css\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase strings.HasSuffix(path, \".html\"):\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(data)\n}", "CodeBleu_score": 44.38936610779723}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path[1:]\n\tif path == \"\" {\n\t\tpath = \"index.html\"\n\t}\n\tif path == \"favicon.ico\" {\n\t\tpath = \"favicon.png\"\n\t}\n\tdata, err := a.assets.ReadFile(path)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\tres.Header().Set(\"Content-Type\", mime.TypeByExtension(filepath.Ext(path)))\n\tres.Write(data)\n}", "CodeBleu_score": 15.340032433905948}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path[1:]\n\tif path == \"\" {\n\t\tpath = \"index.html\"\n\t}\n\tdata, err := Asset(path)\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tvar contentType string\n\tswitch {\n\tcase strings.HasSuffix(path, \".css\"):\n\t\tcontentType = \"text/css\"\n\tcase strings.HasSuffix(path, \".js\"):\n\t\tcontentType = \"application/javascript\"\n\tdefault:\n\t\tcontentType = \"text/html\"\n\t}\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Write(data)\n}", "CodeBleu_score": 28.73850448286023}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Find the robot with the specified name\n\trobot := a.master.FindRobot(robotName)\n\n\t// If the robot was found\n\tif robot != nil {\n\t\t// Get the robot's connections\n\t\tconnections := robot.GetConnections()\n\n\t\t// Convert the connections to JSON format\n\t\tconnectionsJSON, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\n\t\t// Write the JSON response containing the robot's connections\n\t\tres.Write(connectionsJSON)\n\t} else {\n\t\t// If the robot was not found, write a JSON error message indicating that no robot was found with the specified name\n\t\terrMsg := \"No robot found with the specified name\"\n\t\terrMsgJSON, err := json.Marshal(errMsg)\n\t\tif err != nil {\n\t\t\tlog.Println(err)\n\t\t}\n\t\tres.Write(errMsgJSON)\n\t}\n}\n", "CodeBleu_score": 33.36463410276443}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL.\n\trobotName := req.URL.Query().Get(\"name\")\n\t// Find the robot with the specified name.\n\trobot := a.master.FindRobot(robotName)\n\t// If the robot was found, convert its connections to JSON format.\n\tif robot != nil {\n\t\tconnections := robot.Connections()\n\t\t// Convert the connections to JSON format.\n\t\tconnectionsJSON, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\t// Write the JSON response.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(connectionsJSON)\n\t\treturn\n\t}\n\t// If the robot was not found, write a JSON error message.\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.Write([]byte(`{\"error\":\"No robot was found with the specified name.\"}`))\n}\n", "CodeBleu_score": 36.576412939981914}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\t// Find the robot with the specified name\n\trobot, err := a.master.FindRobot(robotName)\n\tif err != nil {\n\t\t// If the robot is not found, write a JSON error message indicating that no robot was found with the specified name\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Gather the robot's connections\n\tconnections := robot.Connections()\n\n\t// Convert the connections to JSON format\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\t// If the connections cannot be converted to JSON format, write a JSON error message indicating that an error occurred\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Write the JSON response containing the connections\n\tfmt.Fprint(res, string(connectionsJSON))\n}", "CodeBleu_score": 32.3712568564926}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || user != username || pass != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 52.77829973463957}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=Restricted\")\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 51.92613047549658}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || user != username || pass != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(w, \"Authorized\", http.StatusOK)\n\t}\n}", "CodeBleu_score": 52.470725071238064}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t}\n\t\tif value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 55.06830572362054}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Round(slope*input + intercept))\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}", "CodeBleu_score": 56.73097750075544}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := (toMax - toMin) / (fromMax - fromMin)\n\tintercept := toMin - slope*fromMin\n\treturn func(input float64) int {\n\t\tvalue := int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}", "CodeBleu_score": 56.770576738440205}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil {\n\t\treturn 0, 0, fmt.Errorf(\"Not connected to a sensor\")\n\t}\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, fmt.Errorf(\"Connection does not support analog read\")\n\t}\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.scaleValue(rawValue)\n\treturn rawValue, a.lastScaledValue, nil\n}\n", "CodeBleu_score": 57.07312535770963}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(connection.ErrConnectionClosed.Error())\n\t}\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(fmt.Sprintf(support.ErrFeatureNotSupported, \"AnalogRead\"))\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = a.scale(rawValue)\n\n\treturn a.lastRawValue, a.lastScaledValue, nil\n}\n", "CodeBleu_score": 57.40390757858185}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil {\n\t\treturn 0, 0, errors.New(\"Not Connected\")\n\t}\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"Connection Does Not Support Analog Read\")\n\t}\n\n\tvalue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRawValue = value\n\ta.lastScaledValue = a.scaleRawValue(value)\n\treturn value, a.lastScaledValue, nil\n}\n", "CodeBleu_score": 54.54798526390056}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMax - (m * fromMax)\n\treturn func(val int) float64 {\n\t\tif val < fromMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif val > fromMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn (m * float64(val)) + n\n\t}\n}", "CodeBleu_score": 66.90235310999752}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(x int) float64 {\n\t\tif x < fromMin {\n\t\t\tx = fromMin\n\t\t} else if x > fromMax {\n\t\t\tx = fromMax\n\t\t}\n\t\treturn m*float64(x) + n\n\t}\n}", "CodeBleu_score": 55.79858815946408}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / (fromMax - fromMin)\n\tn := toMin - m*fromMin\n\treturn func(input int) float64 {\n\t\toutput := m*float64(input) + n\n\t\tif output < toMin {\n\t\t\treturn toMin\n\t\t}\n\t\tif output > toMax {\n\t\t\treturn toMax\n\t\t}\n\t\treturn output\n\t}\n}\n", "CodeBleu_score": 68.27667479694826}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\tdriver := &GrovePiezoVibrationSensorDriver{\n\t\tname:     gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tpin:      pin,\n\t\tinterval: 10 * time.Millisecond,\n\t\thalt:     make(chan bool, 0),\n\t}\n\n\tdriver.AnalogSensorDriver = NewAnalogSensorDriver(a, pin, driver.PublishEvent, opts...)\n\n\tdriver.AddEvent(Vibration)\n\n\tif err := driver.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn driver\n}\n", "CodeBleu_score": 46.1963203087363}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\tdriver := &GrovePiezoVibrationSensorDriver{\n\t\tname:     gopi.DRIVER_GROVEPIEZOVIBRATION,\n\t\treporter: AnalogSensorDriverReporter(a, pin, opts...),\n\t}\n\n\t// Set up event listener for data events\n\tif err := driver.reporter.EventBus().Listen(driver.Event(), func(event gopi.Event) {\n\t\tif data, ok := event.(*gopi.AnalogSensorDataEvent); ok {\n\t\t\tif data.Value() > 1000 {\n\t\t\t\tdriver.Publish(gopi.NewSensorEvent(driver.Event(), gopi.SENSOR_EVENT_VIBRATION, data.Value()))\n\t\t\t}\n\t\t}\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn driver\n}\n", "CodeBleu_score": 45.86962052042347}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\tdriver := new(GrovePiezoVibrationSensorDriver)\n\tdriver.Name = gobot.DefaultName(\"GrovePiezoVibrationSensor\")\n\tdriver.Pin = pin\n\tdriver.Vibration = 0\n\tdriver.Units = \"vibration\"\n\tdriver.Commands = []string{}\n\tdriver.Events = []string{\n\t\t\"vibration\",\n\t}\n\n\tdriver.AnalogSensorDriver = NewAnalogSensorDriver(a, pin, opts...)\n\n\tdriver.AddEvent(Vibration)\n\n\tdriver.Work = func() {\n\t\tvibration := driver.Read()\n\t\tif vibration > 1000 {\n\t\t\tdriver.Publish(driver.Event(Vibration), vibration)\n\t\t}\n\t}\n\n\treturn driver\n}\n", "CodeBleu_score": 35.462560090753364}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif d.state != \"ready\" {\n\t\treturn errors.New(\"device not ready\")\n\t}\n\n\td.state = \"busy\"\n\tdefer func() { d.state = \"ready\" }()\n\n\ttonePeriod := 1.0 / hz\n\ttoneDuration := duration\n\ttempo := 60.0 / d.bpm\n\n\tfor toneDuration > 0 {\n\t\tif toneDuration < tempo {\n\t\t\ttempo = toneDuration\n\t\t}\n\n\t\ttoneDuration -= tempo\n\n\t\tif err := d.buzzer.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(time.Duration(tonePeriod * float64(time.Second)))\n\n\t\tif err := d.buzzer.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttime.Sleep(time.Duration((tempo - tonePeriod) * float64(time.Second)))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 36.555185296666274}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif !d.IsBuzzerEnabled() {\n\t\treturn errors.New(\"buzzer is not enabled\")\n\t}\n\n\tif hz < 0 {\n\t\treturn errors.New(\"frequency must be positive\")\n\t}\n\n\tif duration < 0 {\n\t\treturn errors.New(\"duration must be positive\")\n\t}\n\n\tperiod := 1 / hz\n\ttempo := 60 / d.GetBPM()\n\n\tfor i := 0; i < int(duration/period); i++ {\n\t\tif err := d.buzzer.On(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period*tempo) * time.Second)\n\n\t\tif err := d.buzzer.Off(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period*tempo) * time.Second)\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 49.895151297910374}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif hz < 0 {\n\t\treturn errors.New(\"frequency must be positive\")\n\t}\n\tif duration < 0 {\n\t\treturn errors.New(\"duration must be positive\")\n\t}\n\tif d.bpm <= 0 {\n\t\treturn errors.New(\"bpm must be positive\")\n\t}\n\n\tperiod := 1 / hz\n\ttempo := 60 / d.bpm\n\ttoneOnTime := period / 2\n\ttoneOffTime := period - toneOnTime\n\ttoneDuration := duration\n\n\tfor toneDuration > 0 {\n\t\terr := d.BuzzerOn()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(toneOnTime*1000) * time.Millisecond)\n\t\terr = d.BuzzerOff()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(toneOffTime*1000) * time.Millisecond)\n\t\ttoneDuration -= period\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 43.984253414881955}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"Sleep pin not configured\")\n\t}\n\td.stop()\n\td.sleepPin.Out(gpio.Low)\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 29.403304559111014}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif !d.sleepPin.Get() {\n\t\treturn errors.New(\"sleep pin is not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 26.99479772252949}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif !d.sleepPin.Get() {\n\t\treturn errors.New(\"easydriver: sleep pin is not set\")\n\t}\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 27.899548982683303}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins map is not initialized\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif ok {\n\t\treturn pin, nil\n\t}\n\n\tpinPath, err := a.translatePin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin, err = sysfs.NewAnalogPin(pinPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 52.5652104557094}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin.(gobot.AnalogPinner), nil\n\t}\n\n\tpin, err := a.newAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin.(gobot.AnalogPinner), nil\n}\n", "CodeBleu_score": 46.02548939137564}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"pins not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpin, err := a.NewAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 45.90328771572248}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.DigitalPin(id, sysfs.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.Write(val)\n}\n", "CodeBleu_score": 65.16497138043418}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tpin, err := a.DigitalPin(id, gobot.DigitalWrite)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.Write(val)\n}\n", "CodeBleu_score": 65.38018080680281}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.GetDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\n\treturn nil\n}", "CodeBleu_score": 63.05072167256442}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif !a.connected {\n\t\treturn nil, errors.New(\"not connected\")\n\t}\n\n\tvar pin gobot.DigitalPinner\n\n\tif p, ok := a.pins[id]; ok {\n\t\tpin = p\n\t} else {\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin = gpio.NewDirectPinDriver(a.gpio, chip, line)\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin.(gobot.DigitalPinOptioner))\n\t}\n\n\tif _, ok := a.pins[id]; !ok {\n\t\ta.pins[id] = pin\n\t}\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 49.676300065089876}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif a.Pins == nil {\n\t\treturn nil, errors.New(\"Adaptor not connected\")\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(a.Pins)\n\t}\n\n\tpin, err := a.Pins.Get(id)\n\tif err != nil {\n\t\tpin, err = a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = a.Pins.Add(pin)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 46.3910156604732}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif len(a.digitalPins) == 0 {\n\t\treturn nil, errors.New(\"Cannot get digital pin, no digital pins available\")\n\t}\n\n\tvar pin gobot.DigitalPinner\n\n\tif p, ok := a.digitalPins[id]; ok {\n\t\tpin = p\n\t} else {\n\t\tchip, line, err := gpio.PinToChipAndLine(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = gpio.NewDirectPin(chip, line)\n\t\ta.digitalPins[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(pin)\n\t}\n\n\treturn pin, nil\n}", "CodeBleu_score": 45.13518911466379}]}
