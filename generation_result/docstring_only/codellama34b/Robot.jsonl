{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> files;\n    std::vector<std::string> file_list;\n    std::string file_path;\n    std::string file_name;\n\n    // Get the list of files from the specified folder\n    file_list = GetFileList(folder);\n\n    // Check if the file exists locally\n    for (int i = 0; i < file_list.size(); i++) {\n        file_name = file_list[i];\n        file_path = folder + \"/\" + file_name;\n        if (FileExists(file_path)) {\n            std::cout << \"File found in cache: \" << file_path << std::endl;\n        } else {\n            std::cout << \"File not found in cache: \" << file_path << std::endl;\n            if (download) {\n                std::cout << \"Downloading file: \" << file_path << std::endl;\n                DownloadFile(file_path);\n            }\n        }\n        files.push_back(file_path);\n    }\n\n    return files;\n}\n", "CodeBleu_score": 45.740347932427724}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> files;\n\tstd::vector<std::string> lines;\n\tstd::string file = folder + \"/required.txt\";\n\tif (File::Exists(file)) {\n\t\tlines = File::ReadLines(file);\n\t\tfor (size_t i = 0; i < lines.size(); i++) {\n\t\t\tstd::string line = lines[i];\n\t\t\tif (line.empty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (line.find(\"#\") != std::string::npos) {\n\t\t\t\tline = line.substr(0, line.find(\"#\"));\n\t\t\t}\n\t\t\tif (line.empty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (download) {\n\t\t\t\tif (!File::Exists(folder + \"/\" + line)) {\n\t\t\t\t\tif (this->DownloadFile(folder, line)) {\n\t\t\t\t\t\tLog::Out << \"Downloaded \" << line << \" from \" << this->GetURL() << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tLog::Error << \"Could not download \" << line << \" from \" << this->GetURL() << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLog::Out << line << \" found in cache\" << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiles.push_back(line);\n\t\t}\n\t}\n\treturn files;\n}\n", "CodeBleu_score": 42.67682736709338}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> files;\n\tstd::vector<std::string> file_paths;\n\tstd::string file_path;\n\tstd::string file;\n\tstd::string file_name;\n\tstd::string file_extension;\n\tstd::string file_directory;\n\tstd::string file_directory_name;\n\tstd::string file_directory_path;\n\tstd::string file_directory_extension;\n\tstd::string file_directory_directory;\n\tstd::string file_directory_directory_name;\n\tstd::string file_directory_directory_path;\n\tstd::string file_directory_directory_extension;\n\tstd::string file_directory_directory_directory;\n\tstd::string file_directory_directory_directory_name;\n\tstd::string file_directory_directory_directory_path;\n\tstd::string file_directory_directory_directory_extension;\n\tstd::string file_directory_directory_directory_directory;\n\tstd::string file_directory_directory_directory_directory_name;\n\tstd::string file_directory_directory_directory_directory_path;\n\tstd::string file_directory_directory_directory_directory_extension;\n\tstd::string file_directory_directory_directory_directory_directory;\n\tstd::string file_directory_directory_directory_directory_directory_name;\n\tstd::string file_directory_directory_directory_directory_directory_path;\n\tstd::string file_directory_directory_directory_directory_directory_extension;\n\tstd::string file_directory_directory_directory_directory_directory_directory;\n\tstd::string file_directory_directory_directory_directory_directory_directory_name;\n\tstd::string file_directory_directory_directory_directory_directory_directory_path;\n\tstd::string file_directory_directory_directory_directory_directory_directory_extension;\n\tstd::string file_directory_directory_directory_directory_directory_directory_directory;\n\tstd::string file_directory_directory_directory_directory_directory_directory_directory_name;\n\tstd::string file_directory_directory_directory_directory_directory_directory_directory_path;\n\tstd::string file_directory_directory_directory_directory", "CodeBleu_score": 13.506000372996779}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f) {\n      log_warning(\n          \"SpringArm or SpringArmGhost attachment type used with a transform that has no x,y translation. \"\n          \"This will result in a malformed actor being spawned.\");\n    }\n  }\n  return _client.SpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 41.18883292113889}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x == 0.0f && transform.location.y == 0.0f &&\n        transform.rotation.pitch == 0.0f &&\n        transform.rotation.yaw == 0.0f &&\n        transform.rotation.roll == 0.0f) {\n      log_warning(\"Spawning an actor with SpringArm or SpringArmGhost \"\n                  \"attachment type with only z translation.\");\n    }\n  }\n\n  return SpawnActor(description, transform, parent, attachment_type, socket_name);\n}\n", "CodeBleu_score": 43.16370984599545}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  return SpawnActorWithParent_Internal(\n      description,\n      transform,\n      parent,\n      attachment_type,\n      socket_name);\n}\n", "CodeBleu_score": 22.225716870431295}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\n  // Retrieve the token for the G-buffer.\n  auto token = GetTokenForGBuffer(ActorId, GBufferId);\n\n  // Copy the token data.\n  auto token_data = token.GetData();\n\n  // Subscribe to the streaming client using the callback function.\n  SubscribeToStream(token_data, callback);\n}\n", "CodeBleu_score": 34.64559564185849}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\n  auto token = GetGBufferToken(ActorId, GBufferId);\n\n  // Copy the token data.\n  Buffer buffer = token.GetData();\n\n  // Subscribe to the streaming client.\n  SubscribeToStream(buffer, callback);\n}\n", "CodeBleu_score": 32.765857888923634}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\n  // Retrieve the GBufferToken from the server.\n  auto GBufferToken = GetGBufferToken(ActorId, GBufferId);\n\n  // Copy the GBufferToken data.\n  auto GBufferTokenData = GBufferToken.Get();\n\n  // Subscribe to the streaming client using the provided callback function.\n  StreamingClient->Subscribe(GBufferTokenData, callback);\n}\n", "CodeBleu_score": 34.672907904746886}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()  std::shared_ptr<WalkerNavigation> nav = GetNavigation();\n  if (nav == nullptr) {\n    nav = std::make_shared<WalkerNavigation>(SharedPtr<Episode>::Get());\n    SetNavigation(nav);\n  }\n  return nav;\n}\n", "CodeBleu_score": 42.45996467945754}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()  auto *walker = GetActorRegistry().Find(GetPlayerPawn());\n  if (walker == nullptr) {\n    return nullptr;\n  }\n  if (walker->GetNavigation() != nullptr) {\n    return walker->GetNavigation();\n  }\n  auto *world = GetWorld();\n  if (world == nullptr) {\n    return nullptr;\n  }\n  auto *blueprint_library = world->GetBlueprintLibrary();\n  if (blueprint_library == nullptr) {\n    return nullptr;\n  }\n  auto *walker_navigation_bp = blueprint_library->FindBlueprint<UBlueprint>(\"/Game/Carla/Blueprints/WalkerNavigation.WalkerNavigation\");\n  if (walker_navigation_bp == nullptr) {\n    return nullptr;\n  }\n  auto *walker_navigation = world->SpawnActor<AWalkerNavigation>(walker_navigation_bp->GeneratedClass);\n  if (walker_navigation == nullptr) {\n    return nullptr;\n  }\n  walker->SetNavigation(walker_navigation);\n  return walker->GetNavigation();\n}\n", "CodeBleu_score": 43.897275435497804}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()  std::shared_ptr<WalkerNavigation> walker_nav = GetWalkerNavigation();\n  if (walker_nav == nullptr) {\n    walker_nav = std::make_shared<WalkerNavigation>(GetActor());\n    if (!SetWalkerNavigation(walker_nav)) {\n      walker_nav = nullptr;\n    }\n  }\n  return walker_nav;\n}\n", "CodeBleu_score": 44.76915999357518}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  time_point start_time = time_now();\n  time_duration time_since_start;\n  while (episode.GetState()->GetFrame() < frame) {\n    time_since_start = time_now() - start_time;\n    if (time_since_start > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetManager()->Tick();\n  return true;\n}\n", "CodeBleu_score": 36.286336908878006}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  time_point start_time = clock::now();\n  time_point end_time = start_time + timeout;\n  while (episode.GetState()->GetCurrentFrame() < frame) {\n    if (clock::now() > end_time) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.GetManager()->NextStep();\n  return true;\n}\n", "CodeBleu_score": 35.713420417433085}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  time_point start_time = time_now();\n  time_duration elapsed_time = seconds(0);\n  while (episode.GetEpisodeFrameNumber() < frame) {\n    if (elapsed_time > timeout) {\n      return false;\n    }\n    this_thread::yield();\n    elapsed_time = time_now() - start_time;\n  }\n  episode.Tick();\n  return true;\n}\n", "CodeBleu_score": 33.10822122652857}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  return LoadEpisode(map_name, reset_settings, map_layers, 10, 100);\n}\n", "CodeBleu_score": 11.861787297710688}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  rpc::client client(_host, _port);\n  auto request = rpc::RequestEpisode();\n  request.set_map_name(map_name);\n  request.set_reset_settings(reset_settings);\n  request.set_map_layers(map_layers);\n  auto response = client.LoadEpisode(request);\n  if (!response.has_error()) {\n    return EpisodeProxy(response.episode_id(), _host, _port);\n  } else {\n    throw_exception(response.error());\n  }\n}\n", "CodeBleu_score": 35.293194658622106}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)    return LoadEpisode(map_name, reset_settings, map_layers, 0);\n}\n", "CodeBleu_score": 11.858264513274307}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)    // Retrieve the walker associated with the controller\n    auto walker = GetWalker(controller.GetWalkerID());\n\n    // Throw an exception if the walker is not found\n    if (walker == nullptr) {\n        throw std::invalid_argument(\"Walker with ID \" + std::to_string(controller.GetWalkerID()) + \" does not exist\");\n    }\n\n    // Assert that the episode is not null\n    assert(episode != nullptr);\n\n    // Create navigation if it is missing\n    if (navigation == nullptr) {\n        CreateNavigation();\n    }\n\n    // Register the walker with the controller's ID\n    walker->RegisterController(controller.GetID());\n}\n", "CodeBleu_score": 49.861313876235144}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)    // Retrieve the walker associated with the controller.\n    auto walker = GetWalker(controller.GetWalkerID());\n\n    // Throw an exception if the walker is not found.\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Walker not found.\");\n    }\n\n    // Assert that the episode is not null.\n    assert(episode != nullptr);\n\n    // Create navigation if it is missing.\n    if (navigation == nullptr) {\n        navigation = std::make_unique<Navigation>(episode);\n    }\n\n    // Register the walker with the controller's ID.\n    navigation->RegisterWalker(controller.GetWalkerID(), walker);\n}\n", "CodeBleu_score": 56.81151827228375}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)    auto walker = GetWalker(controller.GetWalkerID());\n    if (walker == nullptr) {\n        throw std::runtime_error(\"Walker not found\");\n    }\n    if (controller.GetEpisode() == nullptr) {\n        throw std::runtime_error(\"Episode is null\");\n    }\n    if (controller.GetNavigation() == nullptr) {\n        controller.SetNavigation(controller.GetEpisode()->GetNavigation());\n    }\n    controller.RegisterWalker(walker);\n}\n", "CodeBleu_score": 52.743508385602034}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  RELEASE_ASSERT(Episode != nullptr);\n  RELEASE_ASSERT(blueprint != nullptr);\n  RELEASE_ASSERT(gc != GarbageCollectionPolicy::Inherit);\n\n  if (parent == nullptr) {\n    RELEASE_ASSERT(attachment_type == rpc::AttachmentType::Rigid);\n  } else {\n    RELEASE_ASSERT(attachment_type != rpc::AttachmentType::Rigid);\n  }\n\n  auto *actor = Episode->SpawnActor(blueprint, transform, parent, attachment_type, socket_name);\n  actor->SetGarbageCollectionPolicy(gc);\n  actor->SetSemanticTags(blueprint->GetSemanticTags());\n  actor->SetId(NextActorId++);\n  ActorRegistry.emplace(actor->GetId(), actor);\n  return SharedPtr<Actor>(actor);\n}\n", "CodeBleu_score": 51.742909448517196}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  RELEASE_ASSERT(Episode != nullptr);\n  auto *actor = new ActorDynamic(Episode, blueprint, transform, parent, attachment_type, socket_name);\n  actor->SetGarbageCollectionPolicy(gc);\n  Episode->RegisterActor(actor);\n  return SharedPtr<Actor>(actor);\n}\n", "CodeBleu_score": 30.106220281272112}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  REQUIRE_CARLA_EPISODE();\n  auto *w = Episode->GetWorld();\n  REQUIRE_TRUE(w != nullptr);\n  auto *cw = Cast<ICarlaWorld>(w);\n  REQUIRE_TRUE(cw != nullptr);\n  auto *aw = cw->GetActors();\n  REQUIRE_TRUE(aw != nullptr);\n  auto *ac = aw->GetActorRegistry();\n  REQUIRE_TRUE(ac != nullptr);\n  auto *wb = Cast<World>(w);\n  REQUIRE_TRUE(wb != nullptr);\n  auto *s = wb->SpawnActor(blueprint.MakeActorDescription(), transform, parent, attachment_type, socket_name);\n  REQUIRE_TRUE(s != nullptr);\n  SharedPtr<Actor> actor = ac->RegisterActor(s, gc);\n  REQUIRE_TRUE(actor != nullptr);\n  return actor;\n}\n", "CodeBleu_score": 45.31650289144212}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (!Episode) {\n    throw_exception(std::runtime_error(\"Invalid episode\"));\n  }\n\n  auto streaming_sensor = boost::dynamic_pointer_cast<sensor::Sensor>(sensor);\n  if (!streaming_sensor) {\n    throw_exception(std::runtime_error(\"Sensor is not of type Sensor\"));\n  }\n\n  auto sensor_stream = streaming_sensor->GetStream();\n  if (sensor_stream == nullptr) {\n    throw_exception(std::runtime_error(\"Sensor has no stream\"));\n  }\n\n  auto sensor_datatype = streaming_sensor->GetDataType();\n  if (sensor_datatype == nullptr) {\n    throw_exception(std::runtime_error(\"Sensor has no datatype\"));\n  }\n\n  auto sensor_datatype_id = sensor_datatype->GetId();\n  if (sensor_datatype_id == 0) {\n    throw_exception(std::runtime_error(\"Sensor has no datatype id\"));\n  }\n\n  auto sensor_callback = [callback, sensor_datatype_id, this](SharedPtr<Stream> stream, const Buffer &buffer) {\n    auto data = sensor_datatype_id == 1 ?\n                std::make_shared<sensor::ImageData>(stream->GetToken(), buffer) :\n                std::make_shared<sensor::SensorData>(stream->GetToken(), buffer);\n    data->SetEpisode(Episode);\n    callback(data);\n  };\n\n  Client->SubscribeToStream(sensor_stream, sensor_callback);\n}\n", "CodeBleu_score": 46.980206550479174}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (_episode == nullptr) {\n    throw_exception(std::runtime_error(\"Invalid episode\"));\n  }\n  _client.SubscribeToStream(\n      sensor.GetActorDescription().GetStreamToken(),\n      [=](SharedPtr<client::Client> client, const sensor::SensorData &message) {\n        auto data = sensor.ParseMessage(message);\n        data->SetEpisode(_episode);\n        callback(data);\n      });\n}\n", "CodeBleu_score": 50.15304664553825}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)    if (GetCurrentEpisode() == nullptr) {\n        throw_exception(std::runtime_error(\"cannot subscribe to a sensor while an episode is not available\"));\n    }\n    GetClient().SubscribeToStream(\n        sensor.GetStreamToken(),\n        [this, sensor, callback](auto client, auto data) {\n            auto episode = GetCurrentEpisode();\n            if (episode == nullptr) {\n                return;\n            }\n            auto sensor_data = sensor.Deserialize(data);\n            sensor_data->SetEpisode(episode);\n            callback(std::move(sensor_data));\n        });\n}\n", "CodeBleu_score": 46.26776462154229}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    // Get the list of walkers in the episode.\n    const std::vector<Actor> &actors = episode->GetActors();\n    // If the list is empty, return.\n    if (actors.empty()) {\n        return;\n    }\n    // Get the current state of the episode.\n    const World &world = episode->GetWorld();\n    // Remove any walkers that no longer exist.\n    RemoveDestroyedWalkers(actors, world);\n    // Update the vehicles in the crowd and the crowd itself in the navigation module.\n    crowd->Update(world.GetTime());\n    // For each walker, get their transform and speed, then apply these states in a batch to the simulator.\n    for (auto &walker : _walkers) {\n        const Actor &actor = walker.first;\n        const ActorId actor_id = actor.GetId();\n        const ActorState &actor_state = world.GetState(actor_id);\n        const cg::Transform actor_transform = actor_state.GetTransform();\n        const cg::Vector3D actor_velocity = actor_state.GetVelocity();\n        crowd->SetWalkerPosition(walker.second, actor_transform.location);\n        crowd->SetWalkerVelocity(walker.second, actor_velocity);\n    }\n    // Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.\n    for (auto it = _walkers.begin(); it != _walkers.end();) {\n        const Actor &actor = it->first;\n        const ActorId actor_id = actor.GetId();\n        const ActorState &actor_state = world.GetState(actor_id);\n        if (actor_state.IsDead()) {\n            crowd->RemoveWalker(it->second);\n            it = _walkers.erase(it);\n        } else {\n            ++it;\n        }\n    }\n}", "CodeBleu_score": 43.61449224385008}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\n  // Get the list of walkers.\n  auto walkers = episode->GetWalkers();\n  if (walkers.size() == 0) {\n    return;\n  }\n\n  // Remove any walkers that no longer exist.\n  for (auto it = _walkers.begin(); it != _walkers.end();) {\n    if (walkers.find(it->first) == walkers.end()) {\n      _walkers.erase(it++);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update the crowd.\n  _crowd->update(episode->GetElapsedTime());\n\n  // Update the vehicles in the crowd.\n  for (auto &&vehicle : _crowd->getVehicles()) {\n    auto walker = walkers.at(vehicle->getId());\n    auto controller = _walkers.at(vehicle->getId());\n    auto transform = walker->GetTransform();\n    auto speed = walker->GetVelocity();\n    controller->SetWalkerSpeed(speed);\n    controller->SetWalkerTransform(transform);\n  }\n\n  // Check if any walker has been killed.\n  for (auto &&vehicle : _crowd->getVehicles()) {\n    auto walker = walkers.at(vehicle->getId());\n    if (walker->IsAlive()) {\n      continue;\n    }\n    _crowd->removeVehicle(*vehicle);\n    _walkers.erase(vehicle->getId());\n  }\n}", "CodeBleu_score": 45.10026418115258}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\n  // Get the list of walkers.\n  auto walkers = episode->GetWalkers();\n\n  // Return if the list is empty.\n  if (walkers.size() == 0) {\n    return;\n  }\n\n  // Get the current state of the episode.\n  auto state = episode->GetState();\n\n  // Remove any walkers that no longer exist.\n  for (auto it = walkers.begin(); it != walkers.end();) {\n    if (state.walkers.find((*it)->GetId()) == state.walkers.end()) {\n      it = walkers.erase(it);\n    } else {\n      ++it;\n    }\n  }\n\n  // Update the vehicles in the crowd and the crowd itself in the navigation module.\n  crowd->Update(state.GetElapsedTime());\n\n  // For each walker, get their transform and speed, then apply these states in a batch to the simulator.\n  for (auto walker : walkers) {\n\n    // Get the walker's transform and speed.\n    auto transform = walker->GetTransform();\n    auto speed = walker->GetSpeed();\n\n    // Apply these states in a batch to the simulator.\n    crowd->ApplyVehicleState(walker->GetId(), transform, speed);\n  }\n\n  // Check if any walker has been killed, handling their removal from the crowd and destroying their controller if they are dead.\n  for (auto walker : walkers) {\n    if (walker->IsDead()) {\n      crowd->RemoveVehicle(walker->GetId());\n      walker->Destroy();\n    }\n  }\n}\n", "CodeBleu_score": 37.88613818896134}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(attributes.size());\n  for (auto &&attribute : attributes) {\n    description.attributes.emplace_back(attribute.first, attribute.second);\n  }\n  return description;\n}\n", "CodeBleu_score": 70.81241552915313}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.set_id(id);\n  description.set_uid(uid);\n  description.mutable_attributes()->Reserve(attributes.size());\n  for (auto &&attribute : attributes) {\n    description.add_attributes()->CopyFrom(attribute);\n  }\n  return description;\n}\n", "CodeBleu_score": 61.73695683042476}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.uid = uid;\n  description.id = id;\n  description.attributes.reserve(attributes.size());\n  for (auto &&attribute : attributes) {\n    description.attributes.push_back(attribute->MakeDescription());\n  }\n  return description;\n}\n", "CodeBleu_score": 71.77930128909391}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const    return SharedPtr<BlueprintLibrary>(new BlueprintLibrary(\n        _blueprint_library->FilterByAttribute(TCHAR_TO_UTF8(*name), TCHAR_TO_UTF8(*value))));\n}\n", "CodeBleu_score": 18.278816441720753}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  return SharedPtr<BlueprintLibrary>(new BlueprintLibrary(\n        _blueprint_library->FilterByAttribute(TCHAR_TO_UTF8(*name), TCHAR_TO_UTF8(*value))));\n}\n", "CodeBleu_score": 18.245030254332328}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  std::vector<SharedPtr<Blueprint>> filtered_blueprints;\n  for (auto &blueprint : blueprints_) {\n    auto attr = blueprint->GetAttributes();\n    if (attr.find(name) != attr.end()) {\n      if (attr[name].compare(value) == 0) {\n        filtered_blueprints.push_back(blueprint);\n      }\n    }\n  }\n  return MakeShared<BlueprintLibrary>(filtered_blueprints);\n}\n", "CodeBleu_score": 35.37844673740024}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string fullPath = GetFullPath(path);\n    if (!ValidatePath(fullPath))\n        return false;\n    std::ofstream outFile(fullPath, std::ios::binary | std::ios::trunc);\n    if (!outFile.is_open())\n        return false;\n    outFile.write(reinterpret_cast<char*>(content.data()), content.size());\n    outFile.close();\n    return true;\n}\n", "CodeBleu_score": 45.72546494648174}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string fullPath = GetFullPath(path);\n    if (!ValidatePath(fullPath)) {\n        return false;\n    }\n    std::ofstream file(fullPath, std::ios::binary);\n    if (!file) {\n        return false;\n    }\n    file.write((char*)content.data(), content.size());\n    file.close();\n    return true;\n}\n", "CodeBleu_score": 38.65426114319588}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string fullPath = baseFolder + path;\n    std::string versionPath = baseFolder + versionFolder + path;\n    std::string versionPathTemp = baseFolder + versionFolder + path + \".tmp\";\n    std::string versionPathTemp2 = baseFolder + versionFolder + path + \".tmp2\";\n\n    // Check if the file exists\n    if (!std::filesystem::exists(fullPath)) {\n        return false;\n    }\n\n    // Check if the version folder exists\n    if (!std::filesystem::exists(versionPath)) {\n        std::filesystem::create_directory(versionPath);\n    }\n\n    // Open the file\n    std::ofstream file(versionPathTemp, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    // Write the content\n    file.write((char*)content.data(), content.size());\n    file.close();\n\n    // Rename the file\n    std::filesystem::rename(versionPathTemp, versionPathTemp2);\n    std::filesystem::rename(fullPath, versionPathTemp);\n    std::filesystem::rename(versionPathTemp2, fullPath);\n\n    return true;\n}", "CodeBleu_score": 45.643974052526254}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\n  // Calculate the location of the bounding box.\n  geom::Location location = transform.location;\n  location.x += parent_bounds_->corners[0].x;\n  location.y += parent_bounds_->corners[0].y;\n\n  // Calculate the four corners of the bounding box.\n  std::vector<geom::Location> corners;\n  corners.reserve(4);\n  const auto &extents = parent_bounds_->extents;\n  const auto c = cos(transform.rotation.yaw);\n  const auto s = sin(transform.rotation.yaw);\n  const auto x_factor = extents.x * c;\n  const auto y_factor = extents.x * s;\n  const auto z_factor = extents.y * s;\n  corners.emplace_back(location.x + x_factor, location.y + y_factor, location.z + z_factor);\n  corners.emplace_back(location.x + x_factor, location.y - y_factor, location.z - z_factor);\n  corners.emplace_back(location.x - x_factor, location.y - y_factor, location.z + z_factor);\n  corners.emplace_back(location.x - x_factor, location.y + y_factor, location.z - z_factor);\n\n  // Return the bounding box.\n  return std::make_shared<const Bounds>(frame, corners, extents);\n}\n", "CodeBleu_score": 42.82140886679704}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\n  const geom::Vector3D &location = transform.location;\n  const geom::Vector3D &extent = _bounds_extents;\n  const float yaw = transform.rotation.yaw;\n\n  const float c = std::cos(yaw);\n  const float s = std::sin(yaw);\n\n  const float x_tl = c * extent.x + s * extent.y;\n  const float y_tl = -s * extent.x + c * extent.y;\n\n  const float x_tr = c * extent.x - s * extent.y;\n  const float y_tr = s * extent.x + c * extent.y;\n\n  const float x_bl = -c * extent.x + s * extent.y;\n  const float y_bl = s * extent.x + c * extent.y;\n\n  const float x_br = -c * extent.x - s * extent.y;\n  const float y_br = -s * extent.x + c * extent.y;\n\n  const geom::Vector3D &parent_location = transform.GetForwardVector();\n\n  const geom::Location corner_tl = {\n      location.x + parent_location.x + x_tl,\n      location.y + parent_location.y + y_tl,\n      location.z + parent_location.z};\n\n  const geom::Location corner_tr = {\n      location.x + parent_location.x + x_tr,\n      location.y + parent_location.y + y_tr,\n      location.z + parent_location.z};\n\n  const geom::Location corner_bl = {\n      location.x + parent_location.x + x_bl,\n      location.y + parent_location.y + y_bl,\n      location.z + parent_location.z};\n\n  const geom::Location corner_br = {\n      location.x + parent_location.x + x_br,\n      location.y + parent_location.y + y_br,\n      location.z + parent_location.z};\n\n  return std::make_shared<const Bounds>(frame, corner_tl, corner_tr,", "CodeBleu_score": 43.15687960605983}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  const geom::Vector3D &location = transform.location;\n  const geom::Vector3D &extent = transform.extent;\n  const geom::Vector3D &forward_vector = transform.GetForwardVector();\n  const geom::Vector3D &right_vector = transform.GetRightVector();\n  const geom::Vector3D &up_vector = transform.GetUpVector();\n\n  const geom::Vector3D &parent_location = _parent_transform.location;\n  const geom::Vector3D &parent_forward_vector = _parent_transform.GetForwardVector();\n  const geom::Vector3D &parent_right_vector = _parent_transform.GetRightVector();\n  const geom::Vector3D &parent_up_vector = _parent_transform.GetUpVector();\n\n  const geom::Vector3D &location_in_parent = parent_location + parent_right_vector * location.x + parent_forward_vector * location.y + parent_up_vector * location.z;\n\n  const geom::Vector3D &forward_vector_in_parent = parent_forward_vector * forward_vector.x + parent_right_vector * forward_vector.y + parent_up_vector * forward_vector.z;\n  const geom::Vector3D &right_vector_in_parent = parent_forward_vector * right_vector.x + parent_right_vector * right_vector.y + parent_up_vector * right_vector.z;\n  const geom::Vector3D &up_vector_in_parent = parent_forward_vector * up_vector.x + parent_right_vector * up_vector.y + parent_up_vector * up_vector.z;\n\n  const geom::Vector3D &extent_in_parent = parent_right_vector * extent.x + parent_forward_vector * extent.y + parent_up_vector * extent.z;\n\n  const geom::Vector3D &lower_left = location_in_parent - right_vector_in_parent * extent_in_parent.x - forward_vector_in_parent * extent_in_parent.y - up_vector_in_parent * extent_in_parent.z;\n  const geom", "CodeBleu_score": 30.089626336884756}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()    //Lock mutex\n    _lightsMutex.lock();\n\n    //Get light states from server\n    std::vector<Light> lights = _lightsInterface->GetLights();\n\n    //Update local light states\n    for (int i = 0; i < lights.size(); i++) {\n        if (_lights.find(lights[i].id) != _lights.end()) {\n            _lights[lights[i].id] = lights[i];\n        } else {\n            _lights[lights[i].id] = lights[i];\n            _lights[lights[i].id].lightObject = new LightObject(lights[i]);\n        }\n    }\n\n    //Unlock mutex\n    _lightsMutex.unlock();\n}\n", "CodeBleu_score": 26.142239919272026}, {"code": "void LightManager::QueryLightsStateToServer()    _lightsLock.lock();\n    std::vector<std::string> lightIDs = _lights.keys();\n    std::vector<std::string> lightStates = _lights.values();\n    _lightsLock.unlock();\n\n    std::vector<std::string> newLightIDs = _serverConnection->GetLightIDs();\n    std::vector<std::string> newLightStates = _serverConnection->GetLightStates();\n\n    for (int i = 0; i < newLightIDs.size(); i++) {\n        bool found = false;\n        for (int j = 0; j < lightIDs.size(); j++) {\n            if (newLightIDs[i] == lightIDs[j]) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            _lightsLock.lock();\n            _lights.insert(newLightIDs[i], newLightStates[i]);\n            _lightsLock.unlock();\n\n            Light light;\n            light.SetID(newLightIDs[i]);\n            light.SetState(newLightStates[i]);\n            _lightsMapLock.lock();\n            _lightsMap.insert(newLightIDs[i], light);\n            _lightsMapLock.unlock();\n        }\n    }\n}", "CodeBleu_score": 33.8048154811432}, {"code": "void LightManager::QueryLightsStateToServer()    // Lock the mutex\n    _lightMutex.lock();\n\n    // Get the light states from the server\n    std::vector<LightState> lightStates = _server.GetLightStates();\n\n    // Update the local light states\n    for (auto lightState : lightStates) {\n        // Check if the light exists in the map\n        if (_lights.find(lightState.id) == _lights.end()) {\n            // Create a new light\n            Light light(lightState);\n            _lights.insert(std::make_pair(lightState.id, light));\n        } else {\n            // Update the light\n            _lights.at(lightState.id).UpdateState(lightState);\n        }\n    }\n\n    // Unlock the mutex\n    _lightMutex.unlock();\n}\n", "CodeBleu_score": 32.28076988382389}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)\t//Lock the mutex\n\tlock_guard<mutex> lock(light_manager_mutex);\n\t\n\t//Check if there are changes\n\tif (dirty) {\n\t\t//Create a message to send to the server\n\t\tMessage message;\n\t\tmessage.type = MessageType::LIGHT_STATE;\n\t\t\n\t\t//Create a data stream to write to\n\t\tDataStreamWriter writer;\n\t\t\n\t\t//Write the number of lights to the message\n\t\twriter.Write<uint32_t>(lights.size());\n\t\t\n\t\t//Write the light states to the message\n\t\tfor (uint32_t i = 0; i < lights.size(); i++) {\n\t\t\twriter.Write<uint32_t>(lights[i].id);\n\t\t\twriter.Write<uint32_t>(lights[i].state);\n\t\t\twriter.Write<uint32_t>(lights[i].brightness);\n\t\t\twriter.Write<uint32_t>(lights[i].color);\n\t\t\twriter.Write<uint32_t>(lights[i].flash_length);\n\t\t\twriter.Write<uint32_t>(lights[i].flash_interval);\n\t\t}\n\t\t\n\t\t//Write the data to the message\n\t\tmessage.data = writer.GetData();\n\t\t\n\t\t//Send the message to the server\n\t\tSendMessage(message);\n\t\t\n\t\t//Clear the changes\n\t\tif (!discard_client) {\n\t\t\tfor (uint32_t i = 0; i < lights.size(); i++) {\n\t\t\t\tlights[i].changes = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Reset the dirty flag\n\t\tdirty = false;\n\t}\n}\n", "CodeBleu_score": 37.396175944041666}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)  if (m_lights_changed) {\n    m_lights_changed = false;\n    m_lights_dirty = false;\n\n    //Create a message to send to the server\n    Message msg;\n    msg.header.type = Message::MessageType::LIGHT_UPDATE;\n    msg.header.size = sizeof(msg.data.light_update);\n    msg.data.light_update.discard_client = discard_client;\n    msg.data.light_update.light_count = m_lights.size();\n\n    //Copy the light states into the message\n    for (int i = 0; i < m_lights.size(); i++) {\n      msg.data.light_update.lights[i].id = m_lights[i].id;\n      msg.data.light_update.lights[i].state = m_lights[i].state;\n    }\n\n    //Send the message to the server\n    SendMessage(msg);\n  }\n}\n", "CodeBleu_score": 29.351650421618654}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tif (discard_client) {\n\t\t// Discard any changes made by the client\n\t\tfor (auto &light : lights) {\n\t\t\tlight.second.discard_changes = true;\n\t\t}\n\t}\n\t\n\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(mutex);\n\t\n\t// Check if there are any changes\n\tbool changes = false;\n\tfor (auto &light : lights) {\n\t\tif (light.second.dirty) {\n\t\t\tchanges = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (changes) {\n\t\t// Create a message containing the updated light states\n\t\tMessage msg;\n\t\tmsg.type = MessageType::LIGHT_STATE_UPDATE;\n\t\tmsg.light_state_update_msg.lights.reserve(lights.size());\n\t\tfor (auto &light : lights) {\n\t\t\tif (light.second.dirty || light.second.discard_changes) {\n\t\t\t\tmsg.light_state_update_msg.lights.push_back(light.second.state);\n\t\t\t\tlight.second.discard_changes = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Send the message to the server\n\t\tSendMessage(msg);\n\t\t\n\t\t// Clear the changes and reset the dirty flag\n\t\tfor (auto &light : lights) {\n\t\t\tlight.second.dirty = false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.88190998972032}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)  std::string sensor_id = GetId();\n  std::string sensor_name = GetName();\n  std::string sensor_type = GetType();\n  std::string sensor_parent = GetParent();\n  std::string sensor_context = GetContext();\n\n  // Log a debug message\n  log_debug(\"Sensor ID: \" + sensor_id);\n  log_debug(\"Sensor name: \" + sensor_name);\n  log_debug(\"Sensor type: \" + sensor_type);\n  log_debug(\"Sensor parent: \" + sensor_parent);\n  log_debug(\"Sensor context: \" + sensor_context);\n\n  // Check if the sensor ID matches \"sensor.other.v2x_custom\"\n  if (sensor_id != \"sensor.other.v2x_custom\") {\n    // Log a warning\n    log_warning(\"Sensor ID does not match 'sensor.other.v2x_custom'\");\n    return;\n  }\n\n  // Send a message to the episode using the sensor's context\n  std::string msg = \"Message from sensor \" + sensor_id;\n  SendEpisodeMessage(sensor_context, msg);\n}\n", "CodeBleu_score": 46.73513321489599}, {"code": "void ServerSideSensor::Send(std::string message)  std::string id = this->GetId();\n  if (id != \"sensor.other.v2x_custom\") {\n    std::cout << \"Warning: Sensor ID is not \\\"sensor.other.v2x_custom\\\"\" << std::endl;\n    return;\n  }\n  std::cout << \"Sending message: \" << message << std::endl;\n  this->GetContext()->Send(message);\n}", "CodeBleu_score": 47.66076299669001}, {"code": "void ServerSideSensor::Send(std::string message)  // Log a debug message\n  log_debug(\"ServerSideSensor::Send called\");\n\n  // Check if the sensor's ID is \"sensor.other.v2x_custom\"\n  if (GetId() != \"sensor.other.v2x_custom\") {\n    // Log a warning\n    log_warning(\"Sensor ID is not 'sensor.other.v2x_custom'\");\n    // Return\n    return;\n  }\n\n  // Send a message to the episode using the sensor's context\n  GetEpisode().Lock()->Send(message);\n}\n", "CodeBleu_score": 57.07845017089739}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)  if (enabled) {\n    if (m_autopilotEnabled) {\n      return;\n    }\n\n    m_autopilotEnabled = true;\n    m_autopilotPort = tm_port;\n    m_autopilotTM = new TrafficManager(m_autopilotPort);\n    m_autopilotTM->RegisterVehicle(this);\n  } else {\n    if (!m_autopilotEnabled) {\n      return;\n    }\n\n    m_autopilotEnabled = false;\n    m_autopilotTM->UnregisterVehicle(this);\n    delete m_autopilotTM;\n    m_autopilotTM = nullptr;\n  }\n}\n", "CodeBleu_score": 37.0382940461346}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)  if (enabled) {\n    if (tm_port != 0) {\n      if (tm_port != m_tm_port) {\n        if (m_tm_port != 0) {\n          UnregisterFromTrafficManager();\n        }\n        m_tm_port = tm_port;\n        RegisterWithTrafficManager();\n      }\n    }\n  } else {\n    if (m_tm_port != 0) {\n      UnregisterFromTrafficManager();\n    }\n  }\n}\n", "CodeBleu_score": 42.70186306879326}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)  if (enabled) {\n    // Register the vehicle with the traffic manager.\n    if (tm_port != 0) {\n      tm_vehicle_port = tm_port;\n      tm_vehicle = std::make_shared<tm_vehicle_t>(\n          GetId(),\n          GetVehicleTM().GetId(),\n          GetVehicleController().GetId(),\n          GetVehicleController().GetServerPort(),\n          GetVehicleController().GetClientPort(),\n          GetVehicleController().GetForwardedClientPort(),\n          GetBoundingBox().location,\n          GetBoundingBox().extent);\n      GetVehicleTM().RegisterVehicle(tm_vehicle);\n    }\n  } else {\n    // Unregister the vehicle from the traffic manager.\n    if (tm_vehicle_port != 0) {\n      GetVehicleTM().UnregisterVehicle(tm_vehicle);\n      tm_vehicle_port = 0;\n    }\n  }\n}\n", "CodeBleu_score": 40.31064490204334}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()\tSuper::Start();\n\t\n\tWalker = Cast<AWalker>(GetPawn());\n\tif (Walker) {\n\t\tWalker->GetMovementComponent()->StopMovementImmediately();\n\t\tWalker->GetMovementComponent()->DisableMovement();\n\t\tWalker->GetMovementComponent()->Deactivate();\n\t\tWalker->GetMovementComponent()->SetComponentTickEnabled(false);\n\t\tWalker->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToAllChannels(ECR_Ignore);\n\t\tWalker->GetCapsuleComponent()->SetSimulatePhysics(false);\n\t\tWalker->GetCapsuleComponent()->SetEnableGravity(false);\n\t\tWalker->GetCharacterMovement()->SetMovementMode(MOVE_None);\n\t\tWalker->GetCharacterMovement()->StopMovementImmediately();\n\t\tWalker->GetCharacterMovement()->DisableMovement();\n\t\tWalker->GetCharacterMovement()->Deactivate();\n\t\tWalker->GetCharacterMovement()->SetComponentTickEnabled(false);\n\t\t\n\t\tWalker->SetActorHiddenInGame(true);\n\t\tWalker->SetActorEnableCollision(false);\n\t\tWalker->SetActorTickEnabled(false);\n\t\tWalker->SetActorLocation(GetActorLocation());\n\t\tWalker->SetActorRotation(FRotator::ZeroRotator);\n\t\tWalker->SetActorScale3D(FVector::OneVector);\n\t\tWalker->SetActorRelativeScale3D(FVector::OneVector);\n\t\tWalker->SetActorHiddenInGame(false);\n\t\tWalker->SetActorEnableCollision(true);\n\t\tWalker->SetActorTickEnabled(true);\n\t\t\n\t\tWalker->AddActorLocalOffset(FVector(0.f, 0.", "CodeBleu_score": 30.832036194737388}, {"code": "void WalkerAIController::Start()\tSuper::Start();\n\n\t// Find the walker\n\tWalker = Cast<AWalker>(GetPawn());\n\tif (Walker) {\n\t\t// Add the walker to the navigation system\n\t\tWalker->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t\tWalker->GetCharacterMovement()->DisableMovement();\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_WorldDynamic, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_PhysicsBody, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_Vehicle, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_Destructible, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECollisionChannel::ECC_EngineTraceChannel1, ECollisionResponse::ECR_Block);\n\t\tWalker->GetCapsuleComponent", "CodeBleu_score": 31.687642480888755}, {"code": "void WalkerAIController::Start()    Super::Start();\n\n    // Get the walker actor from the level.\n    walker = Cast<AWalker>(GetPawn());\n\n    // Add the walker to the navigation system.\n    walker->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n    walker->GetCapsuleComponent()->SetCollisionResponseToAllChannels(ECR_Ignore);\n    walker->GetCapsuleComponent()->SetSimulatePhysics(false);\n    walker->GetCapsuleComponent()->SetEnableGravity(false);\n    walker->GetCapsuleComponent()->SetLinearDamping(0.0f);\n    walker->GetCapsuleComponent()->SetAngularDamping(0.0f);\n    walker->GetCapsuleComponent()->BodyInstance.SetEnableAutoWeld(true);\n    walker->GetCapsuleComponent()->BodyInstance.bAutoWeld = true;\n    walker->GetCapsuleComponent()->SetGenerateOverlapEvents(false);\n    walker->GetCapsuleComponent()->SetCollisionObjectType(ECC_Pawn);\n    walker->GetCapsuleComponent()->SetCanEverAffectNavigation(true);\n    walker->GetCapsuleComponent()->SetNavigationChannels(FNavigationChannel::Walking | FNavigationChannel::Flying);\n    walker->GetCapsuleComponent()->SetNavigationRelevancy(0.0f);\n    walker->GetCapsuleComponent()->SetNavigationInteraction(ECanBeCharacterBase::ECB_No);\n    walker->GetCapsuleComponent()->SetNavigationPenalty(0.0f);\n    walker->GetCapsuleComponent()->SetNavigationAreaType(EAREA_NavWalking);\n    walker->GetCapsuleComponent()->SetNavigationVolume(0.0f);\n    walker->GetCapsuleComponent()->SetNavigationAgentType(FNavigationAgentProperties::DefaultAgent);\n    walker->GetCapsuleComponent()->SetNavigationGeometry(EAIGeometryType::NavWalking);\n    walker->GetCapsuleComponent()->SetNavigationWeight(0.0f);\n    walker->Get", "CodeBleu_score": 27.16412628630134}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)    UAIPerceptionComponent* perception = GetPerceptionComponent();\n    if (!perception) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed - Perception component not found for controller %s\"), *GetName());\n        return;\n    }\n\n    UAINavigationInstance* navigation = perception->GetNavigationSystem();\n    if (!navigation) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed - Navigation system not found for controller %s\"), *GetName());\n        return;\n    }\n\n    AWalker* walker = Cast<AWalker>(GetPawn());\n    if (!walker) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed - Walker not found for controller %s\"), *GetName());\n        return;\n    }\n\n    if (!navigation->SetWalkerMaxSpeed(walker, max_speed)) {\n        UE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::SetMaxSpeed - Failed to set walker %s maximum speed to %f\"), *walker->GetName(), max_speed);\n    }\n}", "CodeBleu_score": 41.80971426365375}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\t// Get the navigation instance\n\tauto nav = GetWorld()->GetNavigationSystem();\n\n\t// If the navigation instance is valid\n\tif (nav) {\n\t\t// Get the parent walker\n\t\tauto walker = Cast<AWalker>(GetPawn());\n\n\t\t// If the walker is valid\n\t\tif (walker) {\n\t\t\t// Attempt to set the walker's maximum speed\n\t\t\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\t\t\t// Log a warning message\n\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to set walker's maximum speed.\"));\n\t\t\t}\n\t\t}\n\t\t// If the walker is not valid\n\t\telse {\n\t\t\t// Log a warning message\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to set walker's maximum speed. The walker is not valid.\"));\n\t\t}\n\t}\n\t// If the navigation instance is not valid\n\telse {\n\t\t// Log a warning message\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Failed to set walker's maximum speed. The navigation system is not valid.\"));\n\t}\n}", "CodeBleu_score": 51.44743872884763}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\t// Retrieve the navigation instance from the current episode\n\tconst auto nav = GetNavigationSystem();\n\tif (!nav) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"[%s] Could not retrieve the navigation instance from the current episode.\"), *GetName());\n\t\treturn;\n\t}\n\n\t// Retrieve the parent walker\n\tconst auto walker = Cast<AWalker>(GetPawn());\n\tif (!walker) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"[%s] Could not retrieve the parent walker.\"), *GetName());\n\t\treturn;\n\t}\n\n\t// Attempt to set the maximum speed\n\tif (!nav->SetWalkerMaxSpeed(walker, max_speed)) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"[%s] Could not set the maximum speed for the parent walker.\"), *GetName());\n\t\treturn;\n\t}\n}\n", "CodeBleu_score": 45.73590123441696}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const  std::vector<SharedPtr<Waypoint>> result;\n  std::vector<SharedPtr<Waypoint>> waypoints = GetMap()->GetPrevious(this->GetTransform(), distance);\n  for (auto &waypoint : waypoints) {\n    result.push_back(MakeShared<Waypoint>(waypoint->GetTransform()));\n  }\n  return result;\n}\n", "CodeBleu_score": 61.213989407595335}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> waypoints = _map->GetPrevious(_transform->GetLocation(), distance);\n\n    for (auto &waypoint : waypoints) {\n        result.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint->GetTransform(), _map)));\n    }\n\n    return result;\n}\n", "CodeBleu_score": 64.85739403751415}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> waypoints = GetMap()->GetPrevious(this->GetTransform(), distance);\n    for (auto &waypoint : waypoints) {\n        result.push_back(MakeShared<Waypoint>(waypoint->GetTransform()));\n    }\n    return result;\n}\n", "CodeBleu_score": 61.28691150198337}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  // Get all signals within the specified distance\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::vector<SharedPtr<Landmark>> landmarks;\n\n  for (auto &signal : signals) {\n    // Check if the signal is already in the list\n    bool found = false;\n    for (auto &landmark : landmarks) {\n      if (landmark->GetSignalId() == signal->GetId()) {\n        found = true;\n        break;\n      }\n    }\n\n    // If not, create a new landmark and add it to the list\n    if (!found) {\n      auto waypoint = GetWorld()->GetMap().GetWaypoint(signal->GetTransform());\n      landmarks.push_back(SharedPtr<Landmark>(new Landmark(waypoint, signal->GetId())));\n    }\n  }\n\n  return landmarks;\n}\n", "CodeBleu_score": 43.87472876005227}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  // Get all signals within distance\n  auto signals = GetSignalsInDistance(distance, stop_at_junction);\n\n  // Create a vector of landmarks\n  std::vector<SharedPtr<Landmark>> landmarks;\n\n  // For each signal\n  for (auto& signal : signals) {\n    // Create a landmark\n    auto landmark = std::make_shared<Landmark>(\n        signal->GetLocation(), signal->GetSignalId(), signal->GetType());\n\n    // Check if the landmark is already in the vector\n    auto it = std::find_if(landmarks.begin(), landmarks.end(),\n        [&landmark](SharedPtr<Landmark> lm) {\n          return lm->GetSignalId() == landmark->GetSignalId();\n        });\n\n    // If not, add it to the vector\n    if (it == landmarks.end()) {\n      landmarks.push_back(landmark);\n    }\n  }\n\n  return landmarks;\n}\n", "CodeBleu_score": 45.56618982756386}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> landmarks;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::vector<SharedPtr<Signal>>::iterator it = signals.begin();\n  while (it != signals.end()) {\n    SharedPtr<Signal> signal = *it;\n    if (signal->GetType() == \"100\") {\n      SharedPtr<Waypoint> waypoint = GetWorld()->GetMap()->GetWaypoint(signal->GetLocation());\n      SharedPtr<Landmark> landmark = GetWorld()->GetMap()->GetLandmark(signal->GetSignalId());\n      if (landmark == nullptr) {\n        landmark = MakeShared<Landmark>(signal->GetSignalId(), waypoint);\n        GetWorld()->GetMap()->AddLandmark(landmark);\n      }\n      landmarks.push_back(landmark);\n    }\n    ++it;\n  }\n  return landmarks;\n}\n", "CodeBleu_score": 44.95626088730913}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  uint64_t settings_id = _episode->ApplySettings(settings);\n  _episode->RegisterActor(_spectator, settings_id);\n  _episode->RegisterActor(_player, settings_id);\n  _episode->RegisterActor(_traffic_manager->GetTrafficManager(), settings_id);\n  _episode->RegisterActor(_recorder, settings_id);\n  _episode->RegisterActor(_traffic_light_manager, settings_id);\n  _episode->RegisterActor(_map, settings_id);\n  _episode->RegisterActor(_weather, settings_id);\n  _episode->RegisterActor(_debug_helper, settings_id);\n  _episode->RegisterActor(_gnss_sensor, settings_id);\n  _episode->RegisterActor(_imu_sensor, settings_id);\n  _episode->RegisterActor(_collision_sensor, settings_id);\n  _episode->RegisterActor(_lane_invasion_sensor, settings_id);\n  _episode->RegisterActor(_gnss_sensor->GetSensor(), settings_id);\n  _episode->RegisterActor(_imu_sensor->GetSensor(), settings_id);\n  _episode->RegisterActor(_collision_sensor->GetSensor(), settings_id);\n  _episode->RegisterActor(_lane_invasion_sensor->GetSensor(), settings_id);\n  _episode->SetTimeout(settings.fixed_delta_seconds > 0.0 ?\n      time_duration::zero() :\n      settings.synchronous_mode ? timeout : time_duration::max());\n  if (settings.fixed_delta_seconds > 0.0) {\n    _episode->SetTickClock(_fixed_delta_seconds_clock, settings.fixed_delta_seconds);\n  }\n  return settings_id;\n}\n", "CodeBleu_score": 34.00906082819458}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  REQUIRE_CARLA_EPISODE();\n  using namespace std::chrono;\n  using namespace std::string_literals;\n\n  auto &episode = GetCurrentEpisode();\n\n  // Set the episode's timeout.\n  if (timeout == time_duration::zero()) {\n    timeout = settings.fixed_delta_seconds > 0.0f ?\n        seconds(1u) + duration_cast<seconds>(duration<float>(settings.fixed_delta_seconds)) :\n        episode.GetNetworkingTimeout();\n  }\n\n  // Apply the settings.\n  const auto id = episode.ApplySettings(settings);\n\n  // Wait until the settings are correctly applied.\n  const auto end = steady_clock::now() + timeout;\n  while (steady_clock::now() < end) {\n    if (episode.GetSettings().frame_number > 0u) {\n      return id;\n    }\n    std::this_thread::yield();\n  }\n\n  // The settings were not applied correctly.\n  if (settings.fixed_delta_seconds > 0.0f) {\n    log_warning(\n        \"failed to apply episode settings after\",\n        duration_cast<duration<float>>(timeout).count(),\n        \"seconds, the server may be too busy,\",\n        \"try increasing the CARLA_SERVER_TIMEOUT_TICKS value in Unreal's Global.ini\");\n  } else {\n    log_warning(\n        \"failed to apply episode settings after\",\n        duration_cast<duration<float>>(timeout).count(),\n        \"seconds, the server may be too busy,\",\n        \"try increasing the CARLA_SERVER_TIMEOUT_TICKS value in Unreal's Global.ini,\",\n        \"or try using a fixed delta seconds in the episode settings\");\n  }\n\n  return id;\n}\n", "CodeBleu_score": 47.6401898499021}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  uint64_t id = _episode_settings_id++;\n  _episode_settings[id] = settings;\n  _episode_settings[id].fixed_delta_seconds = settings.fixed_delta_seconds;\n  _episode_settings[id].substepping = settings.substepping;\n  _episode_settings[id].max_substep_delta_time = settings.max_substep_delta_time;\n  _episode_settings[id].max_substeps = settings.max_substeps;\n  _episode_settings[id].synchronous_mode = settings.synchronous_mode;\n  _episode_settings[id].no_rendering_mode = settings.no_rendering_mode;\n\n  _episode_settings[id].synchronous_mode = true;\n  _episode_settings[id].no_rendering_mode = true;\n\n  _episode_settings[id].tick_time_out = timeout;\n\n  if (settings.fixed_delta_seconds > 0.0) {\n    time_duration delta = seconds(settings.fixed_delta_seconds);\n    time_point start = time_now();\n    time_point end = start + delta;\n    time_duration error = seconds(0.0);\n    for (int i = 0; i < 10; ++i) {\n      time_point now = time_now();\n      if (now < end) {\n        std::this_thread::sleep_for(end - now);\n      }\n      now = time_now();\n      error += now - end;\n      end = start + delta * (i + 1);\n    }\n    error /= 10;\n    if (error.total_milliseconds() > 10.0) {\n      log_warning(\"delta time of\", settings.fixed_delta_seconds, \"seconds is not accurate\");\n    }\n  }\n\n  return id;\n}\n", "CodeBleu_score": 47.79682236484177}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tfloat LengthSquared = (Point2D End - Point2D Start).LengthSquared();\n\tfloat Length = sqrtf(LengthSquared);\n\tif (Length == 0.0f)\n\t\treturn std::pair<float, float>(0.0f, (Point2D Start - Point2D).Length());\n\n\tfloat t = Math::Clamp(((Point2D - Point2D Start).Dot(Point2D End - Point2D Start)) / LengthSquared, 0.0f, 1.0f);\n\tPoint2D Projection = Point2D Start + t * (Point2D End - Point2D Start);\n\treturn std::pair<float, float>(t * Length, (Projection - Point2D).Length());\n}\n", "CodeBleu_score": 34.80464026265389}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tfloat segmentLength = (p2 - p1).Length();\n\tif (segmentLength == 0) {\n\t\tfloat distance1 = (point - p1).Length();\n\t\tfloat distance2 = (point - p2).Length();\n\t\tif (distance1 < distance2)\n\t\t\treturn std::pair<float, float>(0, distance1);\n\t\telse\n\t\t\treturn std::pair<float, float>(1, distance2);\n\t}\n\tfloat t = Math::Clamp((point - p1).Dot(p2 - p1) / (segmentLength * segmentLength), 0.0f, 1.0f);\n\tVector2 projection = p1 + t * (p2 - p1);\n\treturn std::pair<float, float>(t, (projection - point).Length());\n}\n", "CodeBleu_score": 39.916063808573554}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tconst float segmentLength = (segmentEnd - segmentStart).Length();\n\tif (segmentLength == 0.f)\n\t\treturn std::make_pair(0.f, (point - segmentStart).Length());\n\n\tconst float t = Math::Clamp((point - segmentStart).Dot(segmentEnd - segmentStart) / segmentLength, 0.f, 1.f);\n\tconst Vector2 projection = segmentStart + t * (segmentEnd - segmentStart);\n\n\treturn std::make_pair(t * segmentLength, (point - projection).Length());\n}", "CodeBleu_score": 37.76280117339992}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tint initial_index = m_vertices.size();\n\tfor (const auto &vertex : vertices) {\n\t\tm_vertices.push_back(vertex);\n\t}\n\tfor (int i = 1; i < vertices.size() - 1; ++i) {\n\t\tm_indices.push_back(initial_index);\n\t\tm_indices.push_back(initial_index + i);\n\t\tm_indices.push_back(initial_index + i + 1);\n\t}\n}", "CodeBleu_score": 42.22844994550287}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n    const auto initial_index = vertices_.size();\n    for (const auto &vertex : vertices) {\n        vertices_.push_back(vertex);\n    }\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n        indices_.push_back(initial_index);\n        indices_.push_back(initial_index + i);\n        indices_.push_back(initial_index + i + 1);\n    }\n}\n", "CodeBleu_score": 43.574060150394395}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)     assert(vertices.size() >= 3);\n     const size_t initial_index = m_vertices.size();\n     for (const auto &vertex : vertices) {\n         m_vertices.push_back(vertex);\n     }\n     for (size_t i = 1; i < vertices.size() - 1; ++i) {\n         m_indices.push_back(initial_index);\n         m_indices.push_back(initial_index + i);\n         m_indices.push_back(initial_index + i + 1);\n     }\n }", "CodeBleu_score": 47.30355124667852}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG_ASSERT_EQ(message->size(), message->size());\n  DEBUG", "CodeBleu_score": 17.368992386203708}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\n  if (message->size() > 16 * 1024 * 1024) {\n    throw std::runtime_error(\"message too large\");\n  }\n\n  auto self = shared_from_this();\n\n  _strand.post([self, message]() {\n    if (!self->_socket.is_open()) {\n      return;\n    }\n    self->_socket.expires_after(std::chrono::seconds(10));\n    auto handle_sent = [self](error_code ec, size_t) {\n      if (ec) {\n        self->Stop();\n      }\n    };\n    boost::asio::async_write(\n        self->_socket,\n        boost::asio::buffer(message->data(), message->size()),\n        self->_strand.wrap(handle_sent));\n  });\n}\n", "CodeBleu_score": 39.41439945508966}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  DEBUG_ASSERT(message != nullptr);\n  DEBUG_ASSERT(message->size() > 0u);\n  io_service.post([=]() {\n    if (!socket.is_open()) {\n      return;\n    }\n    auto self = shared_from_this();\n    auto timeout = std::make_shared<asio::steady_timer>(io_service);\n    timeout->expires_from_now(std::chrono::seconds(10));\n    timeout->async_wait([=](const error_code &ec) {\n      if (!ec) {\n        socket.close();\n      }\n    });\n    asio::async_write(\n        socket,\n        asio::buffer(message->data(), message->size()),\n        [=](const error_code &ec, size_t) {\n          timeout->cancel();\n          if (ec) {\n            log_error(ec);\n            socket.close();\n          }\n        });\n  });\n}\n", "CodeBleu_score": 44.762836650443624}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)    if (ec) {\n        Log::GetLogger()->error(\"({}) Error closing socket: {}\", m_SessionID, ec.message());\n    }\n    if (m_Socket.is_open()) {\n        boost::system::error_code ignored_ec;\n        m_Socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n        m_Socket.close();\n    }\n\n    m_DeadlineTimer.cancel();\n    if (m_OnClosed) {\n        m_OnClosed();\n    }\n    Log::GetLogger()->info(\"({}) Session closed\", m_SessionID);\n}\n", "CodeBleu_score": 49.73549837784167}, {"code": "void Primary::CloseNow(boost::system::error_code ec)    if (ec == boost::asio::error::operation_aborted)\n        return;\n    if (ec) {\n        std::cerr << \"error: \" << ec.message() << \"\\n\";\n    }\n    if (!socket_.is_open())\n        return;\n    boost::system::error_code ignored_ec;\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    socket_.close(ignored_ec);\n    on_closed();\n    std::cerr << \"session closed\\n\";\n}\n", "CodeBleu_score": 48.01836305945819}, {"code": "void Primary::CloseNow(boost::system::error_code ec)    if (deadline_timer_ != nullptr) {\n        deadline_timer_->cancel();\n    }\n\n    if (!ec && socket_.is_open()) {\n        boost::system::error_code ignored_ec;\n        socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n        socket_.close(ignored_ec);\n    }\n\n    on_closed(ec);\n    LOG_INFO(\"Session closed\");\n}\n", "CodeBleu_score": 52.45086353453896}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()\t// Create the buffer from the message\n\tchar buffer[200];\n\tsprintf(buffer, \"%s\", \"Are you alive?\");\n\t// Log the sending action\n\tLog::WriteMessage(buffer, LOG_INFO);\n\t// Write the buffer to the next router with the command YOU_ALIVE\n\tWrite(buffer, strlen(buffer), YOU_ALIVE);\n\t// Wait for and log the response from the system\n\tint size;\n\tchar response[200];\n\tRead(response, &size, YOU_ALIVE);\n\tLog::WriteMessage(response, LOG_INFO);\n}\n", "CodeBleu_score": 38.07969717868541}, {"code": "void PrimaryCommands::SendIsAlive()  char message[100];\n  sprintf(message, \"Are you alive?\");\n  Log::LogSend(message);\n  char buffer[100];\n  sprintf(buffer, \"%s\", message);\n  WriteToNextRouter(buffer, YOU_ALIVE);\n  char response[100];\n  ReadFromNextRouter(response);\n  Log::LogReceive(response);\n}\n", "CodeBleu_score": 35.07888382755754}, {"code": "void PrimaryCommands::SendIsAlive()  // create a buffer from the message\n  std::vector<uint8_t> buffer = CreateBuffer(\"Are you alive?\");\n  // log the sending action\n  LogSending(buffer);\n  // write the buffer to the next router with the command YOU_ALIVE\n  WriteBuffer(buffer, YOU_ALIVE);\n  // wait for and log the response from the system\n  LogResponse(YOU_ALIVE);\n}\n", "CodeBleu_score": 23.82729234790209}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if sensor is on a secondary server\n    if (sensor_id.secondary_server_id == 0) {\n        // Sensor is on the primary server\n        return;\n    }\n\n    // Create buffer\n    unsigned char buffer[1];\n    buffer[0] = sensor_id.sensor_id;\n\n    // Send command\n    if (router->Send(sensor_id.secondary_server_id, ENABLE_ROS, buffer, 1)) {\n        // Wait for response\n        router->WaitForResponse(sensor_id.secondary_server_id, ENABLE_ROS);\n    }\n    else {\n        // Log error\n        Logging::LogMessage(LogLevels::ERROR, \"Unable to send ENABLE_ROS command to secondary server \" + to_string(sensor_id.secondary_server_id) + \".\");\n    }\n}\n", "CodeBleu_score": 34.993808332463146}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Check if sensor is already enabled.\n\tif (enabled_sensors.find(sensor_id) != enabled_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being enabled.\n\tif (enabling_sensors.find(sensor_id) != enabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}\n\n\t// Check if sensor is already being disabled.\n\tif (disabling_sensors.find(sensor_id) != disabling_sensors.end()) {\n\t\treturn;\n\t}", "CodeBleu_score": 27.54678900443983}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if the sensor has been activated on any secondary server\n    bool found = false;\n    for (int i = 0; i < num_secondaries; i++) {\n        if (secondary_servers[i]->IsSensorActive(sensor_id)) {\n            found = true;\n            break;\n        }\n    }\n\n    // If the sensor is found on any secondary server, send an ENABLE_ROS command to the server\n    if (found) {\n        // Create a buffer with the sensor ID\n        char buffer[sizeof(stream_id)];\n        memcpy(buffer, &sensor_id, sizeof(stream_id));\n\n        // Send an ENABLE_ROS command to the server using the router\n        router->SendCommand(ENABLE_ROS, buffer, sizeof(stream_id));\n\n        // Wait for and process the server's response\n        ProcessEnableForROSResponse();\n    }\n\n    // If the sensor is not found on any secondary server, log an error message\n    else {\n        std::cout << \"Sensor \" << sensor_id << \" is not active on any secondary server\" << std::endl;\n    }\n}\n", "CodeBleu_score": 41.24806877660145}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\ttoken_type token;\n\n\t// Check if sensor is already activated\n\tif (sensor_activated.find(sensor_id) != sensor_activated.end()) {\n\t\ttoken = sensor_activated[sensor_id];\n\t\tLOG_INFO(\"Sensor \" << sensor_id << \" already activated, returning token \" << token);\n\t\treturn token;\n\t}\n\n\t// Sensor is not activated, so activate it\n\ttoken = activate_sensor(sensor_id);\n\n\t// Update sensor maps\n\tsensor_activated[sensor_id] = token;\n\ttoken_sensor[token] = sensor_id;\n\n\tLOG_INFO(\"Sensor \" << sensor_id << \" activated, returning token \" << token);\n\treturn token;\n}\n", "CodeBleu_score": 42.927939327951904}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)  /*\n   * Check if sensor is already activated.\n   */\n  if (sensor_to_token.find(sensor_id) != sensor_to_token.end()) {\n    std::cout << \"Sensor \" << sensor_id << \" is already activated.\" << std::endl;\n    return sensor_to_token[sensor_id];\n  }\n\n  /*\n   * Sensor is not activated, so activate it on a secondary server.\n   */\n  std::cout << \"Sensor \" << sensor_id << \" is not activated.\" << std::endl;\n  std::cout << \"Activating sensor \" << sensor_id << \" on a secondary server.\" << std::endl;\n  token_type new_token = SecondaryCommands::EnableSensor(sensor_id);\n  sensor_to_token[sensor_id] = new_token;\n  token_to_sensor[new_token] = sensor_id;\n  std::cout << \"Sensor \" << sensor_id << \" has been activated.\" << std::endl;\n  return new_token;\n}\n", "CodeBleu_score": 42.450857243959575}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)    if (sensor_map.find(sensor_id) != sensor_map.end()) {\n        // Sensor already activated.\n        token_type token = sensor_map[sensor_id];\n        LOG(INFO) << \"Sensor \" << sensor_id << \" already activated. Returning token \" << token;\n        return token;\n    } else {\n        // Sensor not activated.\n        LOG(INFO) << \"Sensor \" << sensor_id << \" not activated. Enabling sensor on secondary server.\";\n        // Get token from secondary server.\n        token_type token = secondary_server->EnableSensor(sensor_id);\n        // Update maps.\n        sensor_map[sensor_id] = token;\n        token_map[token] = sensor_id;\n        // Log action.\n        LOG(INFO) << \"Sensor \" << sensor_id << \" enabled. Returning token \" << token;\n        return token;\n    }\n}\n", "CodeBleu_score": 46.91900301345014}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open())\n\t\treturn false;\n\n\tfile.seekg(0, std::ios::end);\n\tstd::vector<char> buffer(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read(buffer.data(), buffer.size());\n\tfile.close();\n\n\treturn Load(buffer);\n}\n", "CodeBleu_score": 48.93058183030875}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open())\n\t\treturn false;\n\tfile.seekg(0, std::ios::end);\n\tstd::vector<char> buffer(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read(&buffer[0], buffer.size());\n\tfile.close();\n\treturn Load(buffer);\n}\n", "CodeBleu_score": 48.92250766829376}, {"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (!file)\n        return false;\n    file.seekg(0, std::ios::end);\n    std::size_t size = file.tellg();\n    file.seekg(0, std::ios::beg);\n    std::vector<char> buffer(size);\n    file.read(buffer.data(), size);\n    file.close();\n    return Load(buffer);\n}\n", "CodeBleu_score": 48.88790896176249}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\tbool result = false;\n\n\t{\n\t\tstd::lock_guard<std::mutex> lock(criticalSection);\n\n\t\tauto walker = walkers.find(id);\n\t\tif (walker != walkers.end()) {\n\t\t\tcrowd->removeAgent(walker->second);\n\t\t\twalkers.erase(walker);\n\t\t\tresult = true;\n\t\t}\n\t\telse {\n\t\t\tauto vehicle = vehicles.find(id);\n\t\t\tif (vehicle != vehicles.end()) {\n\t\t\t\tcrowd->removeAgent(vehicle->second);\n\t\t\t\tvehicles.erase(vehicle);\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 51.53041289097388}, {"code": "bool Navigation::RemoveAgent(ActorId id)    if (!this->IsReady()) {\n        return false;\n    }\n    if (this->crowd == nullptr) {\n        return false;\n    }\n    bool result = false;\n    this->criticalSection.Enter();\n    if (this->walkers.Contains(id)) {\n        result = this->RemoveWalker(id);\n    } else if (this->vehicles.Contains(id)) {\n        result = this->RemoveVehicle(id);\n    }\n    this->criticalSection.Leave();\n    return result;\n}\n", "CodeBleu_score": 20.264402895403542}, {"code": "bool Navigation::RemoveAgent(ActorId id)    if (!ready) {\n        return false;\n    }\n\n    if (crowd == nullptr) {\n        return false;\n    }\n\n    // Enter critical section.\n    {\n        std::lock_guard<std::mutex> lock(critical_section);\n\n        // Find agent id in walker map.\n        auto walker_it = walker_map.find(id);\n        if (walker_it != walker_map.end()) {\n            // Remove walker from crowd.\n            crowd->removeAgent(walker_it->second);\n\n            // Remove walker from walker manager.\n            walker_manager.RemoveAgent(walker_it->second);\n\n            // Remove walker from walker map.\n            walker_map.erase(walker_it);\n\n            return true;\n        }\n\n        // Find agent id in vehicle map.\n        auto vehicle_it = vehicle_map.find(id);\n        if (vehicle_it != vehicle_map.end()) {\n            // Remove vehicle from crowd.\n            crowd->removeAgent(vehicle_it->second);\n\n            // Remove vehicle from vehicle manager.\n            vehicle_manager.RemoveAgent(vehicle_it->second);\n\n            // Remove vehicle from vehicle map.\n            vehicle_map.erase(vehicle_it);\n\n            return true;\n        }\n    }\n\n    return false;\n}\n", "CodeBleu_score": 58.59905353497024}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    // Collect vehicle IDs\n    std::set<int> vehicle_ids;\n    for (auto& vehicle : vehicles) {\n        vehicle_ids.insert(vehicle.id);\n    }\n\n    // Add or update vehicles\n    for (auto& vehicle : vehicles) {\n        if (vehicle.id != -1) {\n            if (vehicles_.find(vehicle.id) == vehicles_.end()) {\n                vehicles_.insert(std::pair<int, Vehicle>(vehicle.id, Vehicle(vehicle)));\n            } else {\n                vehicles_[vehicle.id].Update(vehicle);\n            }\n            vehicles_[vehicle.id].updated_ = true;\n        }\n    }\n\n    // Remove unupdated vehicles\n    for (auto& vehicle : vehicles_) {\n        if (!vehicle.second.updated_) {\n            vehicles_.erase(vehicle.first);\n        } else {\n            vehicle.second.updated_ = false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 47.85706857272576}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    std::set<int> vehicleIDs;\n    for (auto& vehicle : vehicles) {\n        vehicleIDs.insert(vehicle.id);\n        if (vehicles_.find(vehicle.id) == vehicles_.end()) {\n            vehicles_.insert({vehicle.id, vehicle});\n        } else {\n            vehicles_[vehicle.id] = vehicle;\n            vehicles_[vehicle.id].updated = true;\n        }\n    }\n    for (auto it = vehicles_.begin(); it != vehicles_.end();) {\n        if (vehicleIDs.find(it->first) == vehicleIDs.end()) {\n            it = vehicles_.erase(it);\n        } else {\n            ++it;\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 50.100640618063586}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    // Collect current vehicle IDs\n    std::set<int> currentVehicleIDs;\n    for (auto& vehicle : vehicles_) {\n        currentVehicleIDs.insert(vehicle.first);\n    }\n\n    // Add/update vehicles\n    for (auto& vehicle : vehicles) {\n        // Update vehicle\n        vehicles_[vehicle.id] = vehicle;\n\n        // Remove vehicle from current vehicle IDs\n        currentVehicleIDs.erase(vehicle.id);\n    }\n\n    // Remove vehicles that are no longer in the scene\n    for (auto& vehicleID : currentVehicleIDs) {\n        vehicles_.erase(vehicleID);\n    }\n\n    return true;\n}\n", "CodeBleu_score": 52.36608063847703}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  std::lock_guard<std::mutex> lock(_mutex);\n  auto it = _walkers.find(id);\n  if (it != _walkers.end()) {\n    const Actor &actor = it->second;\n    const float squared_distance = distance * distance;\n    const auto &vehicles = GetVehicles();\n    for (auto &&vehicle : vehicles) {\n      if (vehicle->GetLocation().DistanceSquared(actor.GetLocation()) < squared_distance) {\n        return _crowd_system->IsVehicleNear(actor.GetId(), vehicle->GetId());\n      }\n    }\n  }\n  return false;\n}\n", "CodeBleu_score": 52.31088855097664}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)    // Search for the actor in the mapped walkers and vehicles.\n    auto it = _walkers.find(id);\n    if (it == _walkers.end()) {\n        it = _vehicles.find(id);\n        if (it == _vehicles.end()) {\n            return false;\n        }\n    }\n\n    // Enter a critical section.\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Compute the squared distance.\n    const float squared_distance = distance * distance;\n\n    // Get the actor.\n    Actor actor = it->second;\n\n    // Get the actor's location.\n    carla::geom::Location location = actor->GetLocation();\n\n    // Get the actor's forward vector.\n    carla::geom::Vector3D forward_vector = actor->GetTransform().GetForwardVector();\n\n    // Compute the dot product between the forward vector and the given direction.\n    const float dot_product = carla::geom::Math::Dot(forward_vector, direction);\n\n    // Compute the cosine of the angle between the forward vector and the given direction.\n    const float cosine = dot_product / (forward_vector.Length() * direction.Length());\n\n    // Compute the angle between the forward vector and the given direction.\n    const float angle = std::acos(cosine);\n\n    // Check if the angle is less than the given angle threshold.\n    if (angle < 0.523599f) {\n        // Check if the actor has a vehicle.\n        if (actor->HasParent()) {\n            // Get the actor's vehicle.\n            Actor vehicle = actor->GetParent();\n\n            // Check if the vehicle is a vehicle.\n            if (vehicle->IsVehicle()) {\n                // Get the vehicle's location.\n                location = vehicle->GetLocation();\n            }\n        }\n\n        // Get the location of the actor.\n        carla::geom::Location actor_location = actor->GetLocation();\n\n        // Compute the squared distance between the actor and the vehicle.\n        const float squared_distance_actor", "CodeBleu_score": 54.36600541630325}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)    std::lock_guard<std::mutex> lock(_mutex);\n    Actor actor = GetActorById(id);\n    if (actor == nullptr) {\n        return false;\n    }\n    float squared_distance = distance * distance;\n    if (actor->IsWalker()) {\n        for (auto& vehicle : _vehicles) {\n            if (vehicle->IsInCrowd()) {\n                continue;\n            }\n            float dx = vehicle->GetLocation().x - actor->GetLocation().x;\n            float dy = vehicle->GetLocation().y - actor->GetLocation().y;\n            float dz = vehicle->GetLocation().z - actor->GetLocation().z;\n            float squared_length = dx * dx + dy * dy + dz * dz;\n            if (squared_length < squared_distance) {\n                return true;\n            }\n        }\n    } else if (actor->IsVehicle()) {\n        for (auto& walker : _walkers) {\n            if (walker->IsInCrowd()) {\n                continue;\n            }\n            float dx = walker->GetLocation().x - actor->GetLocation().x;\n            float dy = walker->GetLocation().y - actor->GetLocation().y;\n            float dz = walker->GetLocation().z - actor->GetLocation().z;\n            float squared_length = dx * dx + dy * dy + dz * dz;\n            if (squared_length < squared_distance) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 43.712205074731074}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)    // Retrieve the current route point for the walker.\n    RoutePoint rp = info.route.GetCurrent();\n\n    // Create a WalkerEventVisitor with the current context.\n    WalkerEventVisitor visitor(id, info, delta);\n\n    // Process the event at the current route point.\n    return boost::apply_visitor(visitor, rp.event);\n}\n", "CodeBleu_score": 42.35713103610193}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)    // Retrieve the current route point\n    RoutePoint routePoint = info.GetRoutePoint();\n\n    // Create a visitor with the current context\n    WalkerEventVisitor visitor(id, info, routePoint, delta);\n\n    // Process the event at the current route point\n    return boost::apply_visitor(visitor, routePoint.event);\n}", "CodeBleu_score": 40.54573124996659}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)    auto &route = info.route;\n    auto &current = route.GetCurrent();\n    auto &visitor = info.visitor;\n\n    // Set the current context.\n    visitor.SetContext(current, delta);\n\n    // Execute the event.\n    auto result = boost::apply_visitor(visitor, current.event);\n\n    // Update the walker state.\n    switch (result) {\n        case EventResult::SUCCESS:\n            // Advance to the next route point.\n            route.Advance();\n            break;\n        case EventResult::FAILURE:\n            // Stop the walker.\n            info.state = WalkerState::STOPPED;\n            break;\n        case EventResult::RETRY:\n            // Do nothing.\n            break;\n    }\n\n    return result;\n}", "CodeBleu_score": 41.45442526438574}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  for (pugi::xml_node road : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    const std::string road_id = road.attribute(\"id\").value();\n    for (pugi::xml_node lanes : road.children(\"lanes\")) {\n      ParseLanes(lanes, road_id, map_builder);\n    }\n  }\n}\n", "CodeBleu_score": 25.663991468904378}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  // Iterate through each road node.\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    // Get the road ID.\n    std::string road_id = road_node.attribute(\"id\").value();\n\n    // Iterate through each lanes node.\n    for (pugi::xml_node lanes_node : road_node.children(\"lanes\")) {\n      // Iterate through each lane section.\n      for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n        // Get the lane section s.\n        double s = lane_section_node.attribute(\"s\").as_double();\n\n        // Iterate through each left lane.\n        for (pugi::xml_node lane_node : lane_section_node.children(\"left\")) {\n          // Parse the left lane.\n          ParseLane(lane_node, carla::road::Lane::LaneType::Driving,\n                    carla::road::Lane::LaneType::Driving, road_id, s,\n                    map_builder);\n        }\n\n        // Iterate through each center lane.\n        for (pugi::xml_node lane_node : lane_section_node.children(\"center\")) {\n          // Parse the center lane.\n          ParseLane(lane_node, carla::road::Lane::LaneType::Driving,\n                    carla::road::Lane::LaneType::Driving, road_id, s,\n                    map_builder);\n        }\n\n        // Iterate through each right lane.\n        for (pugi::xml_node lane_node : lane_section_node.children(\"right\")) {\n          // Parse the right lane.\n          ParseLane(lane_node, carla::road::Lane::LaneType::Driving,\n                    carla::road::Lane::LaneType::Driving, road_id, s,\n                    map_builder);\n        }\n      }\n    }\n  }", "CodeBleu_score": 60.52762054728681}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n  // Iterate through each road node.\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n\n    // Retrieve the road ID.\n    std::string road_id = road_node.attribute(\"id\").value();\n\n    // Iterate through each lanes node.\n    for (pugi::xml_node lanes_node : road_node.children(\"lanes\")) {\n\n      // Iterate through each lane section.\n      for (pugi::xml_node lane_section_node : lanes_node.children(\"laneSection\")) {\n\n        // Retrieve the lane section s value.\n        double s = std::stod(lane_section_node.attribute(\"s\").value());\n\n        // Iterate through each left, center, and right lane node.\n        for (pugi::xml_node lane_node : lane_section_node.children(\"left\")) {\n          ParseLanes(map_builder, road_id, s, lane_node, \"left\");\n        }\n        for (pugi::xml_node lane_node : lane_section_node.children(\"center\")) {\n          ParseLanes(map_builder, road_id, s, lane_node, \"center\");\n        }\n        for (pugi::xml_node lane_node : lane_section_node.children(\"right\")) {\n          ParseLanes(map_builder, road_id, s, lane_node, \"right\");\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 61.48666909618208}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    std::lock_guard<std::mutex> lock(m_mutex);\n    if (info.current_count_change == 1) {\n        if (m_matched_count == 0) {\n            m_first_connected = true;\n        }\n        m_matched_count++;\n        if (m_matched_count > m_max_matched) {\n            m_max_matched = m_matched_count;\n        }\n    } else if (info.current_count_change == -1) {\n        m_matched_count--;\n    } else {\n        std::cerr << \"Invalid matched count change\" << std::endl;\n    }\n}\n", "CodeBleu_score": 54.80596239554914}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    if (info.current_count_change == 1) {\n        publication_matched_ = true;\n        publication_matched_count_ = info.total_count;\n        first_publication_matched_ = info.last_subscription_handle;\n    } else if (info.current_count_change == -1) {\n        publication_matched_count_--;\n    } else {\n        std::cerr << \"Unexpected publication matched count received: \" << info.current_count_change << std::endl;\n    }\n}\n", "CodeBleu_score": 68.62413197109095}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    if (info.current_count_change == 1) {\n        matched_ = info.total_count;\n        first_connected_ = true;\n        // TODO: Log\n        // spdlog::debug(\"DataWriter matched\");\n    } else if (info.current_count_change == -1) {\n        matched_ = info.total_count;\n        // TODO: Log\n        // spdlog::debug(\"DataWriter unmatched\");\n    } else {\n        // TODO: Log\n        // spdlog::error(\"DataWriter illegal match change\");\n    }\n}\n", "CodeBleu_score": 60.798903501852934}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        if (info.total_count == 1) {\n            first_connected = true;\n        }\n        ++matched_count;\n    } else if (info.current_count_change == -1) {\n        --matched_count;\n        if (matched_count == 0) {\n            delete subscriber;\n            subscriber = nullptr;\n        }\n    } else {\n        logError(get_class_name(), \"on_subscription_matched\", \"Invalid change count.\");\n    }\n}\n", "CodeBleu_score": 52.20237238031052}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        ++matched_count;\n        if (matched_count == 1) {\n            first_connected = true;\n        }\n    } else if (info.current_count_change == -1) {\n        --matched_count;\n        if (matched_count == 0) {\n            delete subscriber;\n        }\n    } else {\n        std::cerr << \"Invalid matched count received: \" << info.current_count_change << std::endl;\n    }\n}\n", "CodeBleu_score": 61.27263704564054}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        if (info.current_count == 1) {\n            first_connected = true;\n        }\n        matched_count++;\n    } else if (info.current_count_change == -1) {\n        if (info.current_count == 0) {\n            if (matched_count == 0) {\n                std::cerr << \"Internal error: matched_count == 0 in on_subscription_matched\" << std::endl;\n            } else {\n                matched_count--;\n            }\n            if (matched_count == 0) {\n                // The last subscriber has unsubscribed. Destroy the subscriber.\n                delete subscriber;\n                subscriber = nullptr;\n            }\n        }\n    } else {\n        std::cerr << \"Internal error: unexpected change_count in on_subscription_matched\" << std::endl;\n    }\n}\n", "CodeBleu_score": 56.77934507780628}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if(!m_key_pool) {\n        return false;\n    }\n    // Serialization.\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    m_cdr_ser.serialize(p_type->collision_location_);\n    m_cdr_ser.serialize(p_type->collision_impulse_);\n    m_cdr_ser.serialize(p_type->collision_normal_);\n    m_cdr_ser.serialize(p_type->collision_actor_id_);\n    m_cdr_ser.serialize(p_type->collision_other_actor_id_);\n\n    if(force_md5 || CarlaCollisionEventPubSubType::md5 != NULL) {\n        // Get MD5.\n        m_md5_helper.init();\n        unsigned char* data = m_cdr_ser.getBuffer();\n        unsigned int size = m_cdr_ser.getSerializedDataLength();\n        m_md5_helper.update(data, size);\n        m_md5_helper.finalize();\n        m_md5_helper.digest(md5);\n        memcpy(handle->value, md5, 16);\n    } else {\n        // Direct copy.\n        for(uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_cdr_ser.getBuffer()[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 57.72776146128663}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if(!m_isGetKeyDefined)\n        return false;\n    CarlaCollisionEvent* p_type = static_cast<CarlaCollisionEvent*>(data);\n    // Serialization.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),CarlaCollisionEvent::getKeyMaxCdrSerializedSize());     //object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);     //object that serializes the data.\n    p_type->serializeKey(ser);\n    m_isKeyDefined = true;\n    if(force_md5 || CarlaCollisionEvent::isKeyDefined())\n    {\n        // Get MD5.\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for(uint8_t i = 0;i<16;++i)\n        {\n            handle->value[i] = m_md5.digest[i];\n        }\n    }\n    else\n    {\n        for(uint8_t i = 0;i<16;++i)\n        {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 77.38653502385031}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if(!this->m_key_pool) {\n        return false;\n    }\n    CarlaCollisionEvent* type = static_cast<CarlaCollisionEvent*>(data);\n    // Serialization.\n    CarlaCollisionEventPubSubType::serializeKey(type, m_key_pool);\n    if(force_md5 || CarlaCollisionEventPubSubType::getKeyMaxCdrSerializedSize() > 16) {\n        // Hash the serialized data.\n        m_md5.init();\n        m_md5.update(m_key_pool, static_cast<unsigned int>(CarlaCollisionEventPubSubType::getKeyMaxCdrSerializedSize()));\n        m_md5.finalize();\n        for(uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for(uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_key_pool[i];\n        }\n    }\n    return true;\n}", "CodeBleu_score": 68.79436645947243}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    // Object that manages a buffer that can be dynamically resized.\n    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        CarlaEgoVehicleControl &carla_ego_vehicle_control = *(CarlaEgoVehicleControl*)data;\n        ser << carla_ego_vehicle_control.throttle;\n        ser << carla_ego_vehicle_control.steer;\n        ser << carla_ego_vehicle_control.brake;\n        ser << carla_ego_vehicle_control.hand_brake;\n        ser << carla_ego_vehicle_control.reverse;\n        ser << carla_ego_vehicle_control.manual_gear_shift;\n        ser << carla_ego_vehicle_control.gear;\n        ser << carla_ego_vehicle_control.manual_first_gear;\n        ser << carla_ego_vehicle_control.manual_second_gear;\n        ser << carla_ego_vehicle_control.manual_third_gear;\n        ser << carla_ego_vehicle_control.manual_fourth_gear;\n        ser << carla_ego_vehicle_control.manual_fifth_gear;\n        ser << carla_ego_vehicle_control.manual_sixth_gear;\n        ser << carla_ego_vehicle_control.manual_seventh_gear;", "CodeBleu_score": 50.18603492346683}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try\n    {\n        p_type->serialize(ser); // Serialize the object:\n    }\n    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n    {\n        return false;\n    }\n\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length\n    return true;\n}\n", "CodeBleu_score": 90.9250449010683}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    // Object that manages a buffer to store serialized data.\n    FastBuffer buffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    Cdr cdr(buffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR);\n\n    // Object we want to serialize.\n    CarlaEgoVehicleControl object;\n    // Convert the data to the object.\n    object.steer = *(reinterpret_cast<float*>(data));\n    object.throttle = *(reinterpret_cast<float*>(data) + 1);\n    object.brake = *(reinterpret_cast<float*>(data) + 2);\n    object.hand_brake = *(reinterpret_cast<bool*>(data) + 3);\n    object.reverse = *(reinterpret_cast<bool*>(data) + 4);\n    object.manual_gear_shift = *(reinterpret_cast<bool*>(data) + 5);\n    object.gear = *(reinterpret_cast<int32_t*>(data) + 6);\n    object.manual_steering = *(reinterpret_cast<bool*>(data) + 7);\n    object.manual_throttle = *(reinterpret_cast<bool*>(data) + 8);\n    object.manual_brake = *(reinterpret_cast<bool*>(data) + 9);\n\n    // Serialize the object into the buffer.\n    cdr << object;\n    // Get the serialized length.\n    payload->length = static_cast<uint32_t>(cdr.getSerializedDataLength());\n\n    return true;\n}\n", "CodeBleu_score": 46.7438995909576}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    if (target_set) {\n        return;\n    }\n\n    switch (msg.msgid) {\n    case MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n        if (target_sysid != msg.sysid) {\n            target_sysid = msg.sysid;\n            request_stream_local_position_ned();\n            request_stream_air_pressure();\n        }\n        target_set = true;\n        break;\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n        if (target_sysid != msg.sysid) {\n            target_sysid = msg.sysid;\n            request_stream_global_position_int();\n            request_stream_air_pressure();\n        }\n        target_set = true;\n        break;\n    default:\n        break;\n    }\n}\n", "CodeBleu_score": 38.34642684943713}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\n\t// if the target is already set, exit immediately\n\tif (mavlink_target_system_id != 0) {\n\t\treturn;\n\t}\n\n\t// decode the MAVLink message\n\tmavlink_msg_command_long_decode(&msg, &mavlink_command_long);\n\n\t// check if the message type is one that should be tracked\n\tif (mavlink_command_long.command != MAV_CMD_DO_SET_RELAY &&\n\t\tmavlink_command_long.command != MAV_CMD_DO_DIGICAM_CONTROL &&\n\t\tmavlink_command_long.command != MAV_CMD_DO_MOUNT_CONTROL &&\n\t\tmavlink_command_long.command != MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW &&\n\t\tmavlink_command_long.command != MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE) {\n\t\treturn;\n\t}\n\n\t// if the target system ID is not set, set the sysid to the target and request position and air pressure data streams from the target\n\tif (mavlink_target_system_id == 0) {\n\t\tmavlink_target_system_id = msg.sysid;\n\t\tmavlink_stream_request_list(msg.sysid);\n\t}\n\n\t// flag that the target has been set\n\tmavlink_target_set = true;\n}\n", "CodeBleu_score": 40.601667776648405}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)  // exit immediately if target already set\n  if (target_system_id != 0) {\n    return;\n  }\n\n  // decode message\n  switch (msg.msgid) {\n    case MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n      mavlink_local_position_ned_t local_position_ned;\n      mavlink_msg_local_position_ned_decode(&msg, &local_position_ned);\n      target_system_id = msg.sysid;\n      break;\n    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n      mavlink_global_position_int_t global_position_int;\n      mavlink_msg_global_position_int_decode(&msg, &global_position_int);\n      target_system_id = msg.sysid;\n      break;\n    case MAVLINK_MSG_ID_GPS_RAW_INT:\n      mavlink_gps_raw_int_t gps_raw_int;\n      mavlink_msg_gps_raw_int_decode(&msg, &gps_raw_int);\n      target_system_id = msg.sysid;\n      break;\n    case MAVLINK_MSG_ID_GPS2_RAW:\n      mavlink_gps2_raw_t gps2_raw;\n      mavlink_msg_gps2_raw_decode(&msg, &gps2_raw);\n      target_system_id = msg.sysid;\n      break;\n    case MAVLINK_MSG_ID_HIL_GPS:\n      mavlink_hil_gps_t hil_gps;\n      mavlink_msg_hil_gps_decode(&msg, &hil_gps);\n      target_system_id = msg.sysid;\n      break;\n    case MAVLINK_MSG_ID_HIL_SENSOR:\n      mavlink_hil_sensor_t hil_sensor;\n      mavlink_msg_hil_sensor_", "CodeBleu_score": 37.87953443276765}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = _handle_command_preflight_calibration(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _calibration_needed = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 49.88335842622002}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\tMAV_RESULT result = _handle_command_preflight_calibration(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_param_calibration_baro = true;\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 46.9270262163936}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = _handle_command_preflight_calibration(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _state->baro_calibration_needed = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 51.87105241143778}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\n\t/*\n\t * If the command parameter is 1.0, it arms the servos and returns MAV_RESULT_ACCEPTED.\n\t */\n\tif (packet.param1 == 1.0) {\n\n\t\t/*\n\t\t * If the servos are armed, return MAV_RESULT_ACCEPTED.\n\t\t */\n\t\tif (servos_armed) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\n\t\t/*\n\t\t * If the servos are not armed, arm the servos and return MAV_RESULT_ACCEPTED.\n\t\t */\n\t\telse {\n\t\t\tservos_armed = true;\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t}\n\n\t/*\n\t * If the command parameter is 0, it disarms the servos and returns MAV_RESULT_ACCEPTED.\n\t */\n\telse if (packet.param1 == 0) {\n\n\t\t/*\n\t\t * If the servos are not armed, return MAV_RESULT_ACCEPTED.\n\t\t */\n\t\tif (!servos_armed) {\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\n\t\t/*\n\t\t * If the servos are armed, disarm the servos and return MAV_RESULT_ACCEPTED.\n\t\t */\n\t\telse {\n\t\t\tservos_armed = false;\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t}\n\t}\n\n\t/*\n\t * For any other parameter value, it returns MAV_RESULT_UNSUPPORTED.\n\t */\n\telse {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 48.79688490429319}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    if (packet.param1 == 1.0) {\n        if (arm_servos()) {\n            return MAV_RESULT_ACCEPTED;\n        } else {\n            return MAV_RESULT_FAILED;\n        }\n    } else if (packet.param1 == 0.0) {\n        if (disarm_servos()) {\n            return MAV_RESULT_ACCEPTED;\n        } else {\n            return MAV_RESULT_FAILED;\n        }\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}\n", "CodeBleu_score": 53.874693631013756}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    if (packet.param1 == 1.0) {\n        if (arm_servos()) {\n            return MAV_RESULT_ACCEPTED;\n        }\n    } else if (packet.param1 == 0) {\n        if (disarm_servos()) {\n            return MAV_RESULT_ACCEPTED;\n        }\n    }\n    return MAV_RESULT_UNSUPPORTED;\n}\n", "CodeBleu_score": 56.36320332401675}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    // iterate over all GCS channels\n    for (uint8_t i=0; i < gcs_channel_count; i++) {\n        // check if the channel is available\n        if (gcs_channels[i].available == true) {\n            // check if the channel has enough payload space\n            if (gcs_channels[i].payload_space >= sizeof(mavlink_global_position_int_t)) {\n                // send a request to start the data stream on the channel\n                gcs_channels[i].available = false;\n                gcs_channels[i].sysid = sysid;\n                gcs_channels[i].compid = compid;\n                gcs_channels[i].msgid = MAVLINK_MSG_ID_GLOBAL_POSITION_INT;\n                gcs_channels[i].update_rate = 10;\n                gcs_channels[i].payload_space = gcs_channels[i].payload_space - sizeof(mavlink_global_position_int_t);\n                gcs_channels[i].payload_counter = 0;\n                gcs_channels[i].payload_array[gcs_channels[i].payload_counter] = MAVLINK_MSG_ID_GLOBAL_POSITION_INT;\n                gcs_channels[i].payload_counter++;\n                gcs_channels[i].payload_array[gcs_channels[i].payload_counter] = 10;\n                gcs_channels[i].payload_counter++;\n                gcs_channels[i].payload_array[gcs_channels[i].payload_counter] = sysid;\n                gcs_channels[i].payload_counter++;\n                gcs_channels[i].payload_array[gcs_channels[i].payload_counter] = compid;\n                gcs_channels[i].payload_counter++;\n                gcs_channels[i].payload_array[gcs_channels[i].payload_counter] = MAV_COMP_ID_AUTOPILOT1;\n                gcs_channels[i].payload", "CodeBleu_score": 44.15503255672421}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\n    // Iterate over GCS channels\n    for (uint8_t i = 0; i < gcs_channel_count; i++) {\n\n        // If the channel is available, request the data stream\n        if (gcs_channels[i].available == true) {\n\n            // Create a request message\n            mavlink_message_t msg;\n            mavlink_msg_request_data_stream_pack_chan(sysid, compid, gcs_channels[i].mavlink_channel, &msg, gcs_channels[i].mavlink_channel, MAV_DATA_STREAM_POSITION, 10);\n\n            // Send the message\n            gcs_channels[i].available = false;\n            gcs_channels[i].sysid = sysid;\n            gcs_channels[i].compid = compid;\n            gcs_channels[i].msgid = msg.msgid;\n            gcs_channels[i].position_streaming = true;\n            gcs_channels[i].position_update_rate = 10;\n            gcs_channels[i].position_update_interval = 1000 / gcs_channels[i].position_update_rate;\n            gcs_channels[i].position_last_update = millis();\n            gcs_channels[i].position_last_sent = millis();\n            gcs_channels[i].position_last_sent_interval = 0;\n            gcs_channels[i].position_data_received = false;\n            gcs_channels[i].position_data_sent = false;\n            gcs_channels[i].position_data_sent_count = 0;\n            gcs_channels[i].position_data_received_count = 0;\n            gcs_channels[i].position_data_sent_lost_count = 0;\n            gcs_channels[i].position_data_received_lost_count = 0;\n            gcs_channels[i].position_data_sent_lost_total = 0;\n            gcs", "CodeBleu_score": 43.41658562691096}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)  // iterate over all GCS channels\n  for (uint8_t i = 0; i < num_gcs; i++) {\n    // check if this channel has enough space for the request\n    if (gcs_channels[i].available_payload_space() >= 13) {\n      // send request to start position data stream\n      gcs_channels[i].send_request_start_datastream(sysid, compid, MAV_DATA_STREAM_POSITION, 100);\n    }\n  }\n}\n", "CodeBleu_score": 44.41862307464156}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)  if (ahrs) {\n    float pitch_cos = cos(ahrs->get_pitch());\n    if (pitch_cos != 0.0) {\n      ef_pitch = atan2(sin(pitch) * pitch_cos, cos(pitch));\n      ef_yaw = yaw + ahrs->get_yaw();\n      return true;\n    }\n  }\n  return false;\n}\n", "CodeBleu_score": 45.27383808718074}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)  AHRS* ahrs = ahrs_instance();\n  if (ahrs == NULL) {\n    return false;\n  }\n  float cos_pitch = ahrs->getPitch();\n  if (cos_pitch == 0) {\n    return false;\n  }\n  ef_pitch = atan2(pitch, cos_pitch);\n  ef_yaw = yaw;\n  return true;\n}\n", "CodeBleu_score": 47.054922245567795}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)  // get AHRS instance\n  AHRS* ahrs = AHRS::getInstance();\n\n  // get pitch cosine\n  float pitch_cos = ahrs->getPitchCos();\n\n  // check for zero pitch cosine\n  if (pitch_cos == 0) {\n    return false;\n  }\n\n  // calculate earth frame pitch and yaw\n  ef_pitch = atan2(sin(pitch), pitch_cos);\n  ef_yaw = yaw + ahrs->getYaw();\n\n  return true;\n}\n", "CodeBleu_score": 46.56689863797755}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)  // Calculate the yaw and pitch in centidegrees\n  // Calculate the angle error\n  // Check if the direction is reversed\n  // Convert the errors from earth frame to body frame\n  // Update the pitch and yaw servos\n}", "CodeBleu_score": 1.4375659340075755}, {"code": "void Mode::update_auto(void)  // Calculate the yaw and pitch in centidegrees\n  yaw_target = (int)(((float)nav.heading * 100) / 360);\n  pitch_target = (int)(((float)nav.pitch * 100) / 360);\n\n  // Check if the direction is reversed\n  if (nav.heading > 180) {\n    yaw_target = 36000 - yaw_target;\n  }\n\n  // Calculate the angle error\n  yaw_error = yaw_target - yaw_actual;\n  pitch_error = pitch_target - pitch_actual;\n\n  // Convert the errors from earth frame to body frame\n  yaw_error = yaw_error + pitch_error;\n  pitch_error = -pitch_error;\n\n  // If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n  if (nav.distance_cm > 0 || min_distance_cm == 0) {\n    update_pitch(pitch_error);\n    update_yaw(yaw_error);\n  }\n}\n", "CodeBleu_score": 28.923427985211937}, {"code": "void Mode::update_auto(void)\n  // Set yaw and pitch to center\n  yaw_auto = 0;\n  pitch_auto = 0;\n\n  // Set target yaw and pitch\n  if (nav.status == 1) {\n    yaw_auto = nav.yaw_to_target;\n    pitch_auto = nav.pitch_to_target;\n  }\n  else if (nav.status == 2) {\n    yaw_auto = nav.yaw_to_home;\n    pitch_auto = nav.pitch_to_home;\n  }\n\n  // Check if direction is reversed\n  if (nav.status == 1 && nav.reverse == 1) {\n    yaw_auto = yaw_auto + 18000;\n    if (yaw_auto > 18000) {\n      yaw_auto = yaw_auto - 36000;\n    }\n  }\n  else if (nav.status == 2 && nav.reverse == 1) {\n    yaw_auto = yaw_auto - 18000;\n    if (yaw_auto < -18000) {\n      yaw_auto = yaw_auto + 36000;\n    }\n  }\n\n  // Compute angle errors\n  yaw_error = yaw_auto - yaw;\n  pitch_error = pitch_auto - pitch;\n\n  // Convert errors to body frame\n  yaw_error_bf = yaw_error * cos(pitch / 10000.0 / 180.0 * M_PI) - pitch_error * sin(yaw / 10000.0 / 180.0 * M_PI);\n  pitch_error_bf = pitch_error * cos(yaw / 10000.0 / 180.0 * M_PI) + yaw_error * sin(pitch / 10000.0 / 180.0 * M_PI);\n\n  // Update pitch and yaw servos\n  if (nav.status == 1 && nav.target_distance >", "CodeBleu_score": 37.335712130876125}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)  // GPS update\n  if (GPS.newNMEAreceived()) {\n    if (!GPS.parse(GPS.lastNMEA())) {\n      return;\n    }\n  }\n\n  // Check if the GPS status is at least 3D fix\n  if (GPS.fix) {\n    // Check if the last message time has changed\n    if (GPS.lastFix() != last_fix_time) {\n      last_fix_time = GPS.lastFix();\n\n      // Check if the current location is valid\n      if (GPS.location.isValid()) {\n        // Update the current location\n        current_location.latitude = GPS.location.lat();\n        current_location.longitude = GPS.location.lng();\n        current_location.altitude = GPS.altitude.meters();\n\n        // Update the current location in the telemetry\n        telemetry.current_location.latitude = current_location.latitude;\n        telemetry.current_location.longitude = current_location.longitude;\n        telemetry.current_location.altitude = current_location.altitude;\n\n        // If the home location has not been set, set it\n        if (!home_location_set) {\n          // Set the home location\n          home_location.latitude = current_location.latitude;\n          home_location.longitude = current_location.longitude;\n          home_location.altitude = current_location.altitude;\n\n          // Set the home location in the telemetry\n          telemetry.home_location.latitude = home_location.latitude;\n          telemetry.home_location.longitude = home_location.longitude;\n          telemetry.home_location.altitude = home_location.altitude;\n\n          // Set the home location as set\n          home_location_set = true;\n        }\n      }\n    }\n  }\n\n  // If the ground start countdown is enabled, decrement the countdown\n  if (ground_start_countdown_enabled) {\n    if (ground_start_countdown > 0) {\n      ground_", "CodeBleu_score": 45.10377347664806}, {"code": "void Tracker::update_GPS(void)  static uint32_t last_msg_time = 0;\n  static uint32_t gps_countdown = 0;\n\n  // If the GPS message has changed, update the GPS data\n  if (gps_data.time_last_msg != last_msg_time) {\n    last_msg_time = gps_data.time_last_msg;\n\n    // Check if the GPS has a 3D fix\n    if (gps_data.fix_type >= 3) {\n      // If the GPS has a 3D fix, start the countdown\n      if (gps_countdown == 0) {\n        gps_countdown = GPS_COUNTDOWN;\n      }\n    }\n    else {\n      // If the GPS does not have a 3D fix, reset the countdown\n      gps_countdown = 0;\n    }\n  }\n\n  // If the GPS countdown is greater than one, decrement it\n  if (gps_countdown > 1) {\n    gps_countdown--;\n  }\n\n  // If the GPS countdown is one, set the home location\n  if (gps_countdown == 1) {\n    // Set the home location\n    set_home_location();\n\n    // Reset the GPS countdown\n    gps_countdown = 0;\n  }\n}\n", "CodeBleu_score": 38.58915728199007}, {"code": "void Tracker::update_GPS(void)  if (gps.last_message_time() != last_message_time) {\n    last_message_time = gps.last_message_time();\n    if (gps.fix_quality() >= 3) {\n      gps_fix_countdown--;\n      if (gps_fix_countdown == 0) {\n        gps_fix_countdown = -1;\n        if (gps.location().is_valid()) {\n          home_location = gps.location();\n          home_location.alt = 0;\n          Serial.println(\"GPS Fix\");\n        }\n        else {\n          gps_fix_countdown = GPS_FIX_COUNTDOWN_TIME;\n        }\n      }\n    }\n    else {\n      gps_fix_countdown = GPS_FIX_COUNTDOWN_TIME;\n    }\n  }\n}\n", "CodeBleu_score": 48.188326906511094}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const  // set pitch servo to 90 degrees\n  if (pitch > 0) {\n    pitch_onoff_servo.write(90);\n  }\n  // set pitch servo to 180 degrees\n  else if (pitch < 0) {\n    pitch_onoff_servo.write(180);\n  }\n  // set pitch servo to 90 degrees\n  else {\n    pitch_onoff_servo.write(90);\n  }\n}", "CodeBleu_score": 17.375117566391555}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const  static float last_pitch = 0;\n  static uint32_t last_pitch_time = 0;\n  static uint32_t last_pitch_time_change = 0;\n  static uint32_t pitch_change_count = 0;\n  static uint32_t pitch_change_count_threshold = 1000;\n\n  // If the pitch has changed, reset the countdown\n  if (pitch != last_pitch) {\n    pitch_change_count = 0;\n    last_pitch_time_change = millis();\n  }\n  // If the pitch has not changed, increment the countdown\n  else {\n    pitch_change_count += millis() - last_pitch_time;\n  }\n\n  // If the pitch has been the same for a while, set the home location\n  if (pitch_change_count > pitch_change_count_threshold) {\n    if (pitch < 0) {\n      pitch_servo.write(0);\n    }\n    else if (pitch > 0) {\n      pitch_servo.write(180);\n    }\n  }\n\n  last_pitch = pitch;\n  last_pitch_time = millis();\n}", "CodeBleu_score": 42.078015184230274}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const  if (pitch > 180) {\n    pitch = 180;\n  } else if (pitch < 0) {\n    pitch = 0;\n  }\n\n  int servo_pitch = map(pitch, 0, 180, 1000, 2000);\n  servo_pitch_onoff.writeMicroseconds(servo_pitch);\n}\n", "CodeBleu_score": 16.525277277744564}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (arming_checks_enabled(ARMING_CHECK_BARO)) {\n        if (barometer.get_altitude() > inertial_nav.get_altitude() + 100) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro error\"));\n            }\n            return false;\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 32.07799652856704}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (!arming_checks_complete) {\n        // we've already failed\n        return false;\n    }\n\n    if (arming_checks_complete && !_baro_healthy) {\n        // we've already failed\n        return false;\n    }\n\n    if (arming_checks_complete && _baro_healthy && _baro_ref_altitude_cm == 0) {\n        // we've already failed\n        return false;\n    }\n\n    if (!_baro_healthy) {\n        // we've already failed\n        return false;\n    }\n\n    if (_baro_ref_altitude_cm == 0) {\n        // we've already failed\n        return false;\n    }\n\n    if (!_baro_ref_set) {\n        // we've already failed\n        return false;\n    }\n\n    // check baro altitude\n    if (abs(ahrs.get_altitude_above_sea_level() - _baro_ref_altitude_cm) > _baro_alt_max_delta) {\n        if (display_failure) {\n            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_WARNING, \"Baro Alt Fail\");\n        }\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 43.69087933885534}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    // call base class barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check baro altitude\n    if (arming_checks_all_or_none() || (arming_checks & ARMING_CHECK_BARO)) {\n        // get baro altitude\n        float baro_alt = barometer.get_altitude();\n\n        // get inertial altitude\n        float inertial_alt = inertial_nav.get_altitude();\n\n        // check altitude difference\n        if (labs(baro_alt - inertial_alt) > BARO_ALT_MAX_DISPARITY) {\n            if (display_failure) {\n                gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Baro alt differs too much\"));\n            }\n            return false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 41.42217172184683}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const    if (_terrain_source == TerrainSourceRangefinder) {\n        return false;\n    }\n    if (_terrain_source == TerrainSourceTerrainDB && _rtl_alt_type == RTL_AltitudeTerrain) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 53.441341121899335}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    if (_rtl_alt_type == AP_Rally::RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 29.520679626442035}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    if (aparm.rtl_alt_type == AP_RTL::RTL_ALT_TERRAIN) {\n        if (aparm.terrain_source == AP_TERRAIN_SOURCE_RANGEFINDER) {\n            return false;\n        }\n        return true;\n    }\n    return AP_Arming_Plane::terrain_database_required();\n}\n", "CodeBleu_score": 49.72280473413306}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()\n    // get the time since the last call to this function\n    uint32_t loop_time = scheduler.time_since_last_loop();\n\n    // set the loop time in the attitude controller\n    attitude_control.set_loop_dt(loop_time);\n\n    // run the attitude controller\n    attitude_control.rate_controller_run();\n}\n", "CodeBleu_score": 43.35886317689444}, {"code": "void Copter::run_rate_controller()\n    // get scheduler loop time\n    uint32_t loop_time_us = scheduler.interval_us_last(AP_TIMER_RATE_CONTROL);\n\n    // run rate controller\n    attitude_control.rate_controller_run(loop_time_us);\n\n    // run position controller\n    position_control.update_position(loop_time_us);\n\n    // run motor controllers\n    motors.output();\n}\n", "CodeBleu_score": 41.28569058000274}, {"code": "void Copter::run_rate_controller()    // set loop time\n    attitude_control.set_dt(scheduler.interval_100());\n\n    // run attitude controller\n    attitude_control.rate_controller_run();\n}\n", "CodeBleu_score": 23.675927519688383}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc == new_loc) {\n\t\t// we've reached the target, set the target to the next waypoint\n\t\tset_target_location_to_next_waypoint();\n\t\treturn true;\n\t}\n\n\t// check if the altitude frame has changed\n\tif (old_loc.alt != new_loc.alt) {\n\t\t// we've changed altitude frame, set the target to the next waypoint\n\t\tset_target_location_to_next_waypoint();\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 45.85444967933822}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\n\t// if we have a new target location\n\tif (new_loc.is_valid()) {\n\n\t\t// if the new target location is different to the old target location\n\t\tif (old_loc != new_loc) {\n\n\t\t\t// if the old target location is valid\n\t\t\tif (old_loc.is_valid()) {\n\n\t\t\t\t// if the altitude frames of the old and new locations are different\n\t\t\t\tif (old_loc.alt != new_loc.alt) {\n\n\t\t\t\t\t// if the old target location is above the new target location\n\t\t\t\t\tif (old_loc.alt > new_loc.alt) {\n\n\t\t\t\t\t\t// set altitude to new target location\n\t\t\t\t\t\t_target_alt = new_loc.alt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set target location to new location\n\t\t\t_target_loc = new_loc;\n\n\t\t\t// return true\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// return false\n\treturn false;\n}\n", "CodeBleu_score": 40.468563185001784}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\n\t// if the old location and the current target location are the same, we don't need to do anything\n\tif (old_loc.lat == _mission_item.lat && old_loc.lng == _mission_item.lng) {\n\t\treturn false;\n\t}\n\n\t// if the new location and the current target location are the same, we don't need to do anything\n\tif (new_loc.lat == _mission_item.lat && new_loc.lng == _mission_item.lng) {\n\t\treturn false;\n\t}\n\n\t// if the old and new location are the same, we don't need to do anything\n\tif (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng) {\n\t\treturn false;\n\t}\n\n\t// if the altitude frame has changed, we need to do a VTOL transition or a landing\n\tif (new_loc.alt_is_amsl != old_loc.alt_is_amsl) {\n\n\t\t// if we're already in a VTOL mode, we're probably doing a transition\n\t\tif (_vtol_status.vtol_in_rw_mode) {\n\n\t\t\t// if we're in fixed-wing mode, we need to do a transition\n\t\t\tif (_vtol_status.vtol_in_fw_mode) {\n\n\t\t\t\t// if we're already in transition, don't do anything\n\t\t\t\tif (_vtol_status.vtol_transition_failsafe) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// set transition to fixed-wing\n\t\t\t\t_vtol_status.vtol_transition_failsafe = true;\n\n\t\t\t// if we're in multi-copter mode, we need to do a landing\n\t\t\t} else {\n\n\t\t\t\t// if we're already in transition, don't do anything\n\t\t\t\tif (_vtol_status.vtol_transition_failsafe) {\n\t\t\t\t\treturn false;", "CodeBleu_score": 44.27970958852513}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (aux_switch_pos(ch_flag) == AUX_SWITCH_POS_HIGH) {\n        copter.set_mode(mode);\n    } else if (copter.mode == mode) {\n        rc.reset_mode_switch();\n    }\n}\n", "CodeBleu_score": 47.546659677703765}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)  if (rc_channel_aux_switch_mapped(ch_flag)) {\n    if (rc_channel_aux_switch_high(ch_flag)) {\n      copter.set_mode(mode);\n    } else {\n      if (copter.mode == mode) {\n        copter.rc.reset_mode_switch();\n      }\n    }\n  }\n}\n", "CodeBleu_score": 52.65856167215367}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (rc().get_aux_switch_pos(ch_flag) == AUX_SWITCH_HIGH) {\n        copter.set_mode(mode);\n    } else if (copter.get_mode() == mode) {\n        rc().reset_mode_switch();\n    }\n}\n", "CodeBleu_score": 56.60919184371813}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()    // save trim\n    float roll_trim = 0.0f;\n    float pitch_trim = 0.0f;\n    if (channel_roll->control_in > 0) {\n        roll_trim = channel_roll->control_in * ToRad(4500);\n    } else {\n        roll_trim = channel_roll->control_in * ToRad(-4500);\n    }\n    if (channel_pitch->control_in > 0) {\n        pitch_trim = channel_pitch->control_in * ToRad(4500);\n    } else {\n        pitch_trim = channel_pitch->control_in * ToRad(-4500);\n    }\n    ahrs.set_trim(Vector3f(roll_trim, pitch_trim, 0));\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    gcs_send_text_P(SEVERITY_INFO,PSTR(\"TRIM SAVED\"));\n}\n", "CodeBleu_score": 42.359481600510534}, {"code": "void Copter::save_trim()    // save trim\n    Vector3f trim_roll_pitch;\n    trim_roll_pitch.x = ahrs.roll_sensor;\n    trim_roll_pitch.y = ahrs.pitch_sensor;\n    trim_roll_pitch.z = 0.0f;\n    Vector3f trim_roll_pitch_rad = trim_roll_pitch.radians();\n    g.trim_roll = trim_roll_pitch_rad.x;\n    g.trim_pitch = trim_roll_pitch_rad.y;\n    g.save();\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    mavlink_and_console_log_info(chan, \"Trim Saved\");\n}\n", "CodeBleu_score": 40.35741983637223}, {"code": "void Copter::save_trim()    float roll_trim = 0.0f;\n    float pitch_trim = 0.0f;\n    if (channel_roll->control_in > 0) {\n        roll_trim = channel_roll->control_in * 0.01f;\n    } else {\n        roll_trim = channel_roll->control_in * 0.01f;\n    }\n    if (channel_pitch->control_in > 0) {\n        pitch_trim = channel_pitch->control_in * 0.01f;\n    } else {\n        pitch_trim = channel_pitch->control_in * 0.01f;\n    }\n    ahrs.set_trim(ToRad(roll_trim), ToRad(pitch_trim));\n    Log_Write_Event(DATA_SAVE_TRIM);\n    gcs_send_text_P(SEVERITY_INFO,PSTR(\"Trim Saved\"));\n}\n", "CodeBleu_score": 42.931635644343544}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()  float speed_sq = 0;\n  float speed_xy = 0;\n  float speed_z = 0;\n  float look_ahead_yaw = 0;\n\n  /*\n   * Retrieve the copter's velocity.\n   */\n  speed_xy = sqrt(copter.velocity.x*copter.velocity.x + copter.velocity.y*copter.velocity.y);\n  speed_z = copter.velocity.z;\n  speed_sq = speed_xy*speed_xy + speed_z*speed_z;\n\n  /*\n   * If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle.\n   */\n  if(copter.position.is_valid && speed_sq > MIN_SPEED_SQ) {\n    look_ahead_yaw = atan2(copter.velocity.y, copter.velocity.x);\n  }\n\n  return look_ahead_yaw;\n}\n", "CodeBleu_score": 43.655841411096766}, {"code": "float Mode::AutoYaw::look_ahead_yaw()    float speed_squared = 0.0;\n    float look_ahead_yaw = 0.0;\n    float look_ahead_yaw_rate = 0.0;\n\n    /*\n     * Retrieve the copter's velocity.\n     */\n    Vector3f velocity = _ahrs.get_velocity();\n\n    /*\n     * Calculate the speed squared.\n     */\n    speed_squared = velocity.length_squared();\n\n    /*\n     * If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle using the arctangent of the velocity components.\n     */\n    if (speed_squared > _look_ahead_speed_threshold_squared) {\n        look_ahead_yaw = atan2f(velocity.y, velocity.x);\n        look_ahead_yaw_rate = _look_ahead_gain * (look_ahead_yaw - _ahrs.yaw);\n    }\n\n    /*\n     * Return the computed look-ahead yaw angle.\n     */\n    return look_ahead_yaw_rate;\n}\n", "CodeBleu_score": 45.52380314264168}, {"code": "float Mode::AutoYaw::look_ahead_yaw()  float speed_sq = 0;\n  float speed_xy = 0;\n  float speed_xy_inv = 0;\n  float look_ahead_yaw = 0;\n\n  // Retrieve the copter's velocity\n  float vel_x = copter.vel_x;\n  float vel_y = copter.vel_y;\n\n  // Calculate the speed squared\n  speed_sq = (vel_x * vel_x) + (vel_y * vel_y);\n\n  // If the copter's position is valid and the speed exceeds a minimum threshold\n  if (copter.position_is_valid && speed_sq > 0.01) {\n    // Calculate the speed along the xy-plane\n    speed_xy = sqrt(speed_sq);\n\n    // Calculate the inverse speed along the xy-plane\n    speed_xy_inv = 1 / speed_xy;\n\n    // Update the look-ahead yaw angle\n    look_ahead_yaw = atan2(vel_y * speed_xy_inv, vel_x * speed_xy_inv);\n  }\n\n  // Return the computed look-ahead yaw angle\n  return look_ahead_yaw;\n}", "CodeBleu_score": 43.70218315095005}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::RUDDER) {\n        if (rudder_arming_disabled || throttle_zero) {\n            return false;\n        }\n    }\n    if (arming_checks_disabled || watchdog_armed) {\n        return true;\n    }\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 36.12469281140418}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::RUDDER) {\n        if (rudder_arming_disabled || throttle_zero) {\n            return false;\n        }\n    }\n\n    if (arming_checks_disabled || watchdog_armed) {\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 36.12469281140418}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::RUDDER) {\n        if (arming_disabled || rudder_disabled || throttle_zero) {\n            return false;\n        }\n    }\n\n    if (watchdog_armed) {\n        return true;\n    }\n\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 35.45737630646858}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    // exit immediately if already armed\n    if (armed()) {\n        return true;\n    }\n\n    // perform arming checks if requested\n    if (do_arming_checks) {\n        if (!arming_checks()) {\n            return false;\n        }\n    }\n\n    // perform method specific checks\n    if (!arm_method_specific_checks(method)) {\n        return false;\n    }\n\n    // record home location\n    if (should_set_home_on_arming(method)) {\n        set_home_to_current_location();\n    }\n\n    // update ahrs home\n    ahrs.set_home(ahrs.get_position());\n\n    // update current location\n    update_current_location();\n\n    // change arm state\n    change_arming_state(true, method);\n\n    // set delay arming flag\n    delay_arming(true);\n\n    // send status text\n    send_armed_msg();\n\n    // return success\n    return true;\n}\n", "CodeBleu_score": 45.83914895995973}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\n    // exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // check if we are in a calibration mode\n    if (ap.g.cal_mode != CALIBRATION_MODE_NONE) {\n        return false;\n    }\n\n    // check if we are in a flight mode that disallows arming\n    if (!ap.allow_arming()) {\n        return false;\n    }\n\n    // perform arming checks\n    if (do_arming_checks) {\n        if (!ap.barometer.all_healthy()) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Arming denied: barometer unhealthy\"));\n            return false;\n        }\n        if (!ap.compass.healthy(0)) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Arming denied: compass #0 unhealthy\"));\n            return false;\n        }\n        if (!ap.compass.healthy(1)) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Arming denied: compass #1 unhealthy\"));\n            return false;\n        }\n        if (!ap.compass.healthy(2)) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Arming denied: compass #2 unhealthy\"));\n            return false;\n        }\n        if (!ap.gps.status() && ap.gps.get_last_gps_time_ms() > 5000) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"Arming denied: GPS unhealthy\"));\n            return false;\n        }\n    }\n\n    // update home location\n    update_home();\n\n    // set home in AHRS\n    ahrs.set_home(ahrs.get_position());\n\n    // update current location\n    update_current_location();", "CodeBleu_score": 50.70489212064383}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    // perform arming checks\n    if (do_arming_checks) {\n        if (!arming_checks()) {\n            return false;\n        }\n    }\n\n    // set arming method\n    set_method(method);\n\n    // update home\n    if (should_set_home_on_arming()) {\n        set_home_to_current_location();\n    }\n\n    // update current location\n    update_current_location();\n\n    // change arm state\n    change_arming(true);\n\n    // set delay arming flag\n    delay_arming(true);\n\n    // send status text\n    set_arming_state_msg(AP_ARMING_STATE_TEXT_ARMED);\n\n    // return success\n    return true;\n}\n", "CodeBleu_score": 34.30805544946439}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    // if already armed, allow arming\n    if (armed) {\n        return true;\n    }\n\n    // if disarm button is configured, disarm\n    if (disarm_button != -1) {\n        return AP_Arming::pre_arm_checks(display_failure);\n    }\n\n    // display message if requested\n    if (display_failure) {\n        gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"No DISARM button\"));\n    }\n\n    // return failure\n    return false;\n}\n", "CodeBleu_score": 62.42276214428193}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    // if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // check if vehicle has a disarm button\n    if (disarm_button == -1) {\n        // display message if requested\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"No disarm button\"));\n        }\n        return false;\n    }\n\n    // standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 65.6665394559852}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    // if already armed, return true\n    if (armed) {\n        return true;\n    }\n\n    // if no disarm button is configured, display failure message\n    if (!disarm_button_pressed()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"No Disarm Button\"));\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 68.51559254879854}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    float ne_x, ne_y;\n    ne_x = x * cos(ahrs.yaw) - y * sin(ahrs.yaw);\n    ne_y = x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 58.66672485736424}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)  float ne_x = x * cos(ahrs.yaw) + y * sin(ahrs.yaw);\n  float ne_y = -x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n\n  x = ne_x;\n  y = ne_y;\n}\n", "CodeBleu_score": 59.31375314283132}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    float ne_x = x * cos(ahrs.yaw) + y * sin(ahrs.yaw);\n    float ne_y = -x * sin(ahrs.yaw) + y * cos(ahrs.yaw);\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 60.50731305808223}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    MAV_RESULT res = MAV_RESULT_DENIED;\n\n    if (is_zero(packet.param1)) {\n        // absolute angle\n        if (packet.param2 < 0) {\n            // this is a hack to allow ground station to send an absolute yaw angle\n            // in a single packet.  A MAV_CMD_CONDITION_YAW with param2 == 0 means\n            // use the current heading as a reference.  param4 is the target angle.\n            // param3 is the direction to rotate.\n            float target_heading = wrap_180(ToDeg(packet.param4));\n            if (is_zero(packet.param3)) {\n                // rotate to the target angle\n                set_auto_yaw_mode(AUTO_YAW_HOLD, target_heading);\n            }else{\n                // rotate by the given angle\n                set_auto_yaw_mode(AUTO_YAW_RELATIVE, target_heading);\n            }\n            res = MAV_RESULT_ACCEPTED;\n        }\n    }else if (is_zero(packet.param2)) {\n        // relative angle\n        float relative_angle = ToRad(packet.param1);\n        if (relative_angle > 0) {\n            set_auto_yaw_mode(AUTO_YAW_RELATIVE, relative_angle);\n            res = MAV_RESULT_ACCEPTED;\n        }\n    }\n\n    return res;\n}\n", "CodeBleu_score": 41.99587019608676}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\tfloat yaw = packet.param1;\n\tfloat yaw_rate = packet.param2;\n\tfloat direction = packet.param3;\n\tfloat relative_offset = packet.param4;\n\n\t// Check if the yaw angle is within the acceptable range\n\tif (yaw < 0.0f || yaw > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the yaw rate is within the acceptable range\n\tif (yaw_rate < 0.0f || yaw_rate > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the direction is within the acceptable range\n\tif (direction < 0.0f || direction > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Check if the relative offset is within the acceptable range\n\tif (relative_offset < 0.0f || relative_offset > 360.0f) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t// Set the yaw heading\n\tset_yaw_heading(yaw, yaw_rate, direction, relative_offset);\n\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 33.59117984336824}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)  float yaw_angle_deg = packet.param1;\n  float yaw_rate_deg_s = packet.param2;\n  uint8_t direction = packet.param3;\n  float yaw_absolute_angle_deg = packet.param4;\n\n  if (yaw_angle_deg < -180.0 || yaw_angle_deg > 180.0) {\n    return MAV_RESULT_DENIED;\n  }\n  if (yaw_rate_deg_s < 0.0 || yaw_rate_deg_s > 180.0) {\n    return MAV_RESULT_DENIED;\n  }\n  if (direction != 0 && direction != 1) {\n    return MAV_RESULT_DENIED;\n  }\n  if (yaw_absolute_angle_deg < -180.0 || yaw_absolute_angle_deg > 180.0) {\n    return MAV_RESULT_DENIED;\n  }\n\n  // Set yaw heading\n  float yaw_heading_deg = yaw_angle_deg;\n  if (direction == 1) {\n    yaw_heading_deg = yaw_absolute_angle_deg;\n  }\n  else {\n    yaw_heading_deg = yaw_heading_deg + yaw_absolute_angle_deg;\n  }\n  set_yaw_heading(yaw_heading_deg);\n\n  return MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 32.22111029154916}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const  if (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED_ARMED) {\n    return (uint8_t)(((((uint16_t)waypoint_heading + 18000) % 36000) / 200));\n  } else {\n    return 0;\n  }\n}\n", "CodeBleu_score": 37.19219504023159}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if (control_mode == MAV_MODE_GUIDED_ARMED || control_mode == MAV_MODE_AUTO_ARMED) {\n        return (uint8_t)((waypoint_heading/2) % 360);\n    } else {\n        return 0;\n    }\n}\n", "CodeBleu_score": 37.71521381437163}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const  if (control_mode == MAV_MODE_AUTO || control_mode == MAV_MODE_GUIDED_ARMED) {\n    return (uint8_t)(((int16_t)waypoint_heading + 18000) / 2);\n  }\n  else {\n    return 0;\n  }\n}\n", "CodeBleu_score": 36.89910905302145}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (log_enabled) {\n        LogPacket packet = {\n            .timestamp = millis(),\n            .id = id,\n            .value = value\n        };\n        noInterrupts();\n        xQueueSendToBack(log_queue, &packet, portMAX_DELAY);\n        interrupts();\n    }\n}\n", "CodeBleu_score": 39.79391022524978}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (Logging_Enabled) {\n        LogPacket packet;\n        packet.time = millis();\n        packet.id = id;\n        packet.value = value;\n        Log_Write_Packet(packet);\n    }\n}\n", "CodeBleu_score": 40.12228067075955}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (log_enabled) {\n\t\tLogPacket packet;\n\t\tpacket.timestamp = millis();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tlog_queue.push(packet);\n\t}\n}\n", "CodeBleu_score": 34.58053390532578}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()  if (home_is_set) {\n    return;\n  }\n  if (motors_armed) {\n    set_home_to_current_location();\n    return;\n  }\n  set_home_to_EKF_origin();\n}\n", "CodeBleu_score": 24.030691964553796}, {"code": "void Sub::update_home_from_EKF()  if (home_is_set) {\n    return;\n  }\n  if (motor_armed) {\n    home_latitude = latitude;\n    home_longitude = longitude;\n    home_altitude = altitude;\n    home_is_set = true;\n  } else {\n    home_latitude = ekf_latitude;\n    home_longitude = ekf_longitude;\n    home_altitude = ekf_altitude;\n    home_is_set = true;\n  }\n}\n", "CodeBleu_score": 18.633242206086127}, {"code": "void Sub::update_home_from_EKF()  if (gps.is_home_set()) {\n    return;\n  }\n  if (motors.armed()) {\n    gps.set_home_to_current_location();\n  } else {\n    gps.set_home_to_EKF_origin();\n  }\n}\n", "CodeBleu_score": 33.818202705251}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()  // If not armed, set throttle to zero and exit\n  if (!motors.armed()) {\n    pilot_throttle = 0;\n    motors.set_rates(0, 0, 0, 0);\n    return;\n  }\n\n  // Set spool state to unlimited throttle\n  spool.unlimited_throttle();\n\n  // Convert pilot inputs to desired body frame rates\n  float roll_rate = pilot_roll * PILOT_MAX_ROLL_RATE;\n  float pitch_rate = pilot_pitch * PILOT_MAX_PITCH_RATE;\n  float yaw_rate = pilot_yaw * PILOT_MAX_YAW_RATE;\n\n  // Run attitude controller\n  attitude_control.run(roll_rate, pitch_rate, yaw_rate);\n\n  // Set motor outputs\n  motors.set_rates(pilot_throttle, pilot_roll, pilot_pitch, pilot_yaw);\n}", "CodeBleu_score": 38.43958439898564}, {"code": "void ModeAcro::run()  // if not armed, set throttle to zero and relax control\n  if (!motors.armed()) {\n    pilot_throttle = 0;\n    control_yaw.relax_control();\n    control_pitch.relax_control();\n    control_roll.relax_control();\n  }\n  // if armed, convert pilot inputs to desired body frame rates, run attitude controller, and set motor inputs\n  else {\n    // set spool state to unlimited throttle\n    spool.state = Spool::UNLIMITED;\n\n    // convert pilot inputs to desired body frame rates\n    control_yaw.set_desired_rate(pilot_yaw * MAX_YAW_RATE);\n    control_pitch.set_desired_rate(pilot_throttle * MAX_PITCH_RATE - pilot_pitch * MAX_PITCH_RATE);\n    control_roll.set_desired_rate(pilot_throttle * MAX_ROLL_RATE - pilot_roll * MAX_ROLL_RATE);\n\n    // run attitude controller\n    control_yaw.run();\n    control_pitch.run();\n    control_roll.run();\n\n    // set motor inputs\n    motors.front = pilot_throttle;\n    motors.left = pilot_throttle - control_roll.output;\n    motors.right = pilot_throttle + control_roll.output;\n    motors.rear = pilot_throttle - control_pitch.output;\n  }\n}", "CodeBleu_score": 48.31789960524101}, {"code": "void ModeAcro::run()  if (motors.get_armed()) {\n    // Set the spool state to unlimited throttle\n    spool.set_spool_state(SPOOL_UNLIMITED);\n\n    // Convert pilot inputs to desired body frame rates\n    float roll_rate = pilot_1.get_demanded_rate(ROLL);\n    float pitch_rate = pilot_1.get_demanded_rate(PITCH);\n    float yaw_rate = pilot_1.get_demanded_rate(YAW);\n\n    // Run the attitude controller with the desired rates\n    attitude_control.run(roll_rate, pitch_rate, yaw_rate);\n\n    // Set the motor outputs\n    motors.set_motor_outputs(attitude_control.get_motor_outputs());\n  }\n  else {\n    // Set the throttle to zero\n    motors.set_throttle(0);\n\n    // Set the spool state to idle\n    spool.set_spool_state(SPOOL_IDLE);\n\n    // Relax the attitude controllers\n    attitude_control.relax_controllers();\n  }\n\n  // Output the pilot's throttle input without angle boost\n  pilot_1.set_throttle_out(motors.get_throttle_in());\n\n  // Set the forward and lateral motor inputs based on pilot controls\n  motors.set_forward_motor_inputs(pilot_1.get_demanded_rate(ROLL));\n  motors.set_lateral_motor_inputs(pilot_1.get_demanded_rate(PITCH));\n}", "CodeBleu_score": 46.29416460039496}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()    // set guided position control mode\n    set_mode_guided();\n\n    // initialize waypoint controller\n    waypoint_controller.init();\n\n    // set the waypoint to the stopping point\n    waypoint_controller.set_destination(current_loc.lat, current_loc.lon, current_loc.alt);\n\n    // set the yaw using the default auto yaw mode\n    waypoint_controller.set_auto_yaw_mode(AUTO_YAW_MODE_DEFAULT);\n}\n", "CodeBleu_score": 36.83941430795905}, {"code": "void ModeGuided::guided_pos_control_start()\t// set guided mode flag\n\tguided_mode_flag = true;\n\n\t// set guided mode\n\tset_mode(GUIDED);\n\n\t// set guided mode flag in the waypoint controller\n\twaypoint_nav.set_guided_mode(true);\n\n\t// set the destination of the waypoint controller to the stopping point\n\twaypoint_nav.set_destination(stopping_point);\n\n\t// initialize the yaw using the default auto yaw mode\n\twaypoint_nav.set_yaw_mode(auto_yaw_mode);\n}\n", "CodeBleu_score": 27.67519860057431}, {"code": "void ModeGuided::guided_pos_control_start()  // set guided mode to position control\n  set_mode_position_control();\n\n  // initialize waypoint controller\n  wp_controller_.init();\n\n  // set the waypoint destination\n  wp_controller_.set_destination(guided_pos_control_destination_);\n\n  // set the yaw\n  set_auto_yaw_mode();\n}\n", "CodeBleu_score": 21.20247769698675}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()  // Set the yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw.\n  // This is the default value.\n  set_yaw_control_mode(YAW_CONTROL_MODE_AUTO_YAW_HOLD);\n\n  // Initialize the vertical and horizontal velocity controllers.\n  // Initialize the vertical velocity controller.\n  _vel_control.init(\n    _accel_z_max,\n    _vel_z_max,\n    _accel_z_max,\n    _vel_z_max,\n    _accel_z_max,\n    _vel_z_max,\n    _accel_z_max,\n    _vel_z_max);\n\n  // Initialize the horizontal velocity controller.\n  _vel_control.init(\n    _accel_xy_max,\n    _vel_xy_max,\n    _accel_xy_max,\n    _vel_xy_max,\n    _accel_xy_max,\n    _vel_xy_max,\n    _accel_xy_max,\n    _vel_xy_max);\n\n  // Set the guided mode to velocity controller.\n  set_guided_mode(GUIDED_MODE_VELOCITY_CONTROL);\n}\n", "CodeBleu_score": 41.28704353738517}, {"code": "void ModeGuided::guided_vel_control_start()  /*\n   * Initialize vertical speed and acceleration limits\n   */\n  _vel_params.max_vel_z_up = _params.max_vel_z_up;\n  _vel_params.max_vel_z_dn = _params.max_vel_z_dn;\n  _vel_params.cruise_speed = _params.cruise_speed;\n  _vel_params.max_acc_z = _params.max_acc_z;\n  _vel_params.slow_land_alt1 = _params.slow_land_alt1;\n  _vel_params.slow_land_alt2 = _params.slow_land_alt2;\n  _vel_params.max_vel_xy = _params.max_vel_xy;\n  _vel_params.max_acc_xy = _params.max_acc_xy;\n  _vel_params.max_jerk = _params.max_jerk;\n  _vel_params.thr_min = _params.thr_min;\n  _vel_params.thr_max = _params.thr_max;\n  _vel_params.thr_hover = _params.thr_hover;\n  _vel_params.vel_xy_p = _params.vel_xy_p;\n  _vel_params.vel_xy_i = _params.vel_xy_i;\n  _vel_params.vel_xy_d = _params.vel_xy_d;\n  _vel_params.vel_z_p = _params.vel_z_p;\n  _vel_params.vel_z_i = _params.vel_z_i;\n  _vel_params.vel_z_d = _params.vel_z_d;\n\n  /*\n   * Initialize horizontal and vertical velocity controllers\n   */\n  _vel_control.init_vel_controller(_vel_params);\n\n  /*\n   * Initialize yaw control mode\n   */\n  _yaw_control.set_yaw_control_mode(YAW_CONTROL_MODE_AUTO_YAW_HOLD);\n\n  /*\n   * Initialize position controller\n   */", "CodeBleu_score": 30.346468400147902}, {"code": "void ModeGuided::guided_vel_control_start()    // Set up vertical speeds and accelerations\n    float z_accel_max = 0.0f;\n    float z_vel_max_up = 0.0f;\n    float z_vel_max_down = 0.0f;\n    float z_vel_cruise = 0.0f;\n\n    // Set up horizontal speeds and accelerations\n    float xy_accel_max = 0.0f;\n    float xy_vel_max = 0.0f;\n\n    // Set up vertical controller\n    float z_p = 0.0f;\n    float z_i = 0.0f;\n    float z_d = 0.0f;\n    float z_imax = 0.0f;\n\n    // Set up horizontal controller\n    float xy_p = 0.0f;\n    float xy_i = 0.0f;\n    float xy_d = 0.0f;\n    float xy_imax = 0.0f;\n\n    // Set up yaw controller\n    float yaw_p = 0.0f;\n    float yaw_i = 0.0f;\n    float yaw_d = 0.0f;\n    float yaw_imax = 0.0f;\n\n    // Set up the velocity controller\n    set_accel_z_max(z_accel_max);\n    set_vel_z_cruise(z_vel_cruise);\n    set_vel_z_max(z_vel_max_up, z_vel_max_down);\n    set_accel_xy_max(xy_accel_max);\n    set_vel_xy_max(xy_vel_max);\n    set_pos_z_target_from_distance(0.0f);\n\n    // Set up the velocity controller\n    set_accel_z_max(z_accel_max);\n    set_vel_z_cruise(z_vel_cruise);\n    set_vel_z_max(z_vel_max_up, z_vel_max_down", "CodeBleu_score": 29.336233443781413}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()\t// check if guided mode is timed out\n\tif (guided_mode_timeout_enabled && (millis() - guided_mode_timeout_start_ms > guided_mode_timeout_ms)) {\n\t\treturn true;\n\t}\n\n\t// check if altitude is within limits\n\tif (guided_mode_alt_limit_enabled) {\n\t\tif (current_loc.alt < guided_mode_alt_min || current_loc.alt > guided_mode_alt_max) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// check if horizontal distance moved exceeds limit\n\tif (guided_mode_horiz_dist_limit_enabled) {\n\t\tif (get_distance_to_next_waypoint(current_loc, next_wp) > guided_mode_horiz_dist_max) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 29.24870557224458}, {"code": "bool ModeGuided::guided_limit_check()    if (guided_mode_timeout_enabled && (current_time - guided_mode_start_time > guided_mode_timeout_limit)) {\n        // we've exceeded the guided mode timeout\n        return true;\n    }\n\n    if (guided_mode_min_alt_enabled && (current_loc.alt < guided_mode_min_alt)) {\n        // we've fallen below the minimum altitude\n        return true;\n    }\n\n    if (guided_mode_max_alt_enabled && (current_loc.alt > guided_mode_max_alt)) {\n        // we've risen above the maximum altitude\n        return true;\n    }\n\n    if (guided_mode_horizontal_distance_max_enabled && (get_distance_xy_cm(guided_mode_start_location,current_loc) > guided_mode_horizontal_distance_max)) {\n        // we've moved more than the maximum horizontal distance\n        return true;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 32.83664790684638}, {"code": "bool ModeGuided::guided_limit_check()\tif (guided_limit_check_timeout()) {\n\t\treturn true;\n\t}\n\n\tif (guided_limit_check_alt_max()) {\n\t\treturn true;\n\t}\n\n\tif (guided_limit_check_alt_min()) {\n\t\treturn true;\n\t}\n\n\tif (guided_limit_check_dist()) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 13.612924546067177}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()  if (millis() - motor_test_timer >= 500) {\n    if (motor_test_timer != 0) {\n      if (motor_test_timer_count > 1) {\n        motor_test_timer_count = 0;\n        motor_test_timer = millis();\n      } else {\n        if (motor_test_timer_count == 0) {\n          motor_test_timer_count = 1;\n          motor_test_timer = millis();\n        } else {\n          motor_test_timer_count = 0;\n          motor_test_timer = millis();\n          if (pass) {\n            pass = false;\n            motor_test = false;\n            Serial.println(\"Motor test timeout\");\n            Serial.println(\"Motor test failed\");\n            Serial.println(\"Motor test disabled\");\n            Serial.println(\"System disarmed\");\n            Serial.println(\"Motor test failure time: \" + String(millis()));\n            return false;\n          }\n        }\n      }\n    } else {\n      motor_test_timer = millis();\n    }\n  }\n  return true;\n}", "CodeBleu_score": 44.68680403957897}, {"code": "bool Sub::verify_motor_test()  if (motor_test_start_time != 0) {\n    if (micros() - motor_test_start_time > 200000) {\n      motor_test_start_time = 0;\n      if (pass) {\n        pass = false;\n        motor_test_pass = false;\n        motor_test_timeout = true;\n        motor_test_timeout_time = micros();\n        disable_motor_test();\n        disable_motor_test_flag = true;\n        disarm();\n        record_failure_time();\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "CodeBleu_score": 49.91031845751886}, {"code": "bool Sub::verify_motor_test()\n  // Check if motor test requests are received at least every 2 Hz\n  if (millis() - last_motor_test_time > 500) {\n\n    // If not, send a timeout message\n    Serial.println(\"Motor test timeout\");\n\n    // Set the pass flag to false\n    pass = false;\n\n    // Disable the motor test\n    motor_test_enabled = false;\n\n    // Disarm the system\n    motor_test_enabled = false;\n\n    // Record the failure time\n    motor_test_failed_time = millis();\n\n    // Return false\n    return false;\n  }\n  else {\n\n    // Return true\n    return true;\n  }\n}", "CodeBleu_score": 41.40245836232149}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)  //Get the current waypoint navigation targets\n  lateral_out = wp_nav.get_lateral_target();\n  forward_out = wp_nav.get_forward_target();\n\n  //Constrain the targets within a specified maximum angle range\n  constrain_targets(lateral_out, forward_out);\n\n  //Normalize the targets\n  normalize_targets(lateral_out, forward_out);\n}\n", "CodeBleu_score": 25.937755607334246}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)  // Retrieve the roll and pitch targets from wp_nav in centidegrees\n  float roll_target = wp_nav.get_roll_cd();\n  float pitch_target = wp_nav.get_pitch_cd();\n\n  // Constrain the targets within a specified maximum angle range\n  roll_target = constrain(roll_target, -wp_nav_max_angle_cd, wp_nav_max_angle_cd);\n  pitch_target = constrain(pitch_target, -wp_nav_max_angle_cd, wp_nav_max_angle_cd);\n\n  // Normalize the targets\n  roll_target = map(roll_target, -wp_nav_max_angle_cd, wp_nav_max_angle_cd, -100, 100);\n  pitch_target = map(pitch_target, -wp_nav_max_angle_cd, wp_nav_max_angle_cd, -100, 100);\n\n  // Assign the normalized values to the lateral and forward outputs\n  lateral_out = roll_target;\n  forward_out = pitch_target;\n}\n", "CodeBleu_score": 45.24745446082841}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)  /*\n   * Retrieve roll and pitch targets from wp_nav in centidegrees.\n   */\n  lateral_out = wp_nav.get_roll_cd();\n  forward_out = wp_nav.get_pitch_cd();\n\n  /*\n   * Constrain targets within a specified maximum angle range.\n   */\n  if (lateral_out > MAX_LATERAL_ANGLE_CD) {\n    lateral_out = MAX_LATERAL_ANGLE_CD;\n  }\n  else if (lateral_out < -MAX_LATERAL_ANGLE_CD) {\n    lateral_out = -MAX_LATERAL_ANGLE_CD;\n  }\n\n  if (forward_out > MAX_FORWARD_ANGLE_CD) {\n    forward_out = MAX_FORWARD_ANGLE_CD;\n  }\n  else if (forward_out < -MAX_FORWARD_ANGLE_CD) {\n    forward_out = -MAX_FORWARD_ANGLE_CD;\n  }\n\n  /*\n   * Normalize targets.\n   */\n  lateral_out = lateral_out / MAX_LATERAL_ANGLE_CD;\n  forward_out = forward_out / MAX_FORWARD_ANGLE_CD;\n}\n", "CodeBleu_score": 31.118080799690095}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()  // Read barometer\n  float baro_pressure = baro.getPressure();\n  float baro_altitude = baro.getAltitude();\n  float baro_temperature = baro.getTemperature();\n\n  // Update barometer calibration\n  if (baro_altitude > 0) {\n    baro.calibratePressure();\n  }\n\n  // Update sensor health\n  if (baro_altitude < 0) {\n    sensor_health.baro = false;\n  } else {\n    sensor_health.baro = true;\n  }\n\n  // Update sensor data\n  sensor_data.baro_pressure = baro_pressure;\n  sensor_data.baro_altitude = baro_altitude;\n  sensor_data.baro_temperature = baro_temperature;\n}", "CodeBleu_score": 41.82122382233936}, {"code": "void Sub::read_barometer()  // Read the raw values from the barometer.\n  baro_raw_pressure = baro.getPressure();\n  baro_raw_altitude = baro.getAltitude();\n  baro_raw_temperature = baro.getTemperature();\n\n  // Convert the raw values to useful units.\n  baro_pressure = baro_raw_pressure / 100.0;\n  baro_altitude = baro_raw_altitude / 100.0;\n  baro_temperature = baro_raw_temperature / 100.0;\n\n  // If the altitude is above zero, update the barometer calibration.\n  if (baro_altitude > 0.0) {\n    baro_calibration_factor = (101325.0 / baro_raw_pressure) * pow(1 - (0.0065 * altitude) / (273.15 + baro_raw_temperature), -5.255);\n  }\n\n  // If a depth sensor is present, update the sensor health status based on the barometer's health.\n  if (depth_sensor_present) {\n    if (baro_altitude < 0.0) {\n      depth_sensor_healthy = false;\n    }\n    else {\n      depth_sensor_healthy = true;\n    }\n  }\n}", "CodeBleu_score": 36.85878153961926}, {"code": "void Sub::read_barometer()  // read the barometer\n  float baro_pressure = baro.getPressure();\n  float baro_temperature = baro.getTemperature();\n\n  // calculate the altitude\n  float altitude = baro.getAltitude(baro_pressure);\n\n  // update the barometer calibration\n  if (altitude > 0.0) {\n    baro.calibrateAltitude(altitude);\n  }\n\n  // update the sensor health status\n  if (altitude < 0.0) {\n    sensor_health.baro_health = 1;\n  } else {\n    sensor_health.baro_health = 0;\n  }\n\n  // update the altitude\n  sensor_data.altitude = altitude;\n\n  // update the barometer pressure\n  sensor_data.baro_pressure = baro_pressure;\n\n  // update the barometer temperature\n  sensor_data.baro_temperature = baro_temperature;\n}\n", "CodeBleu_score": 45.770106110836444}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()    // Check if inertial nav is available\n    if (!ekf_inertial_nav_complete()) {\n        return false;\n    }\n\n    // Check if the motors are disarmed\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // Check if the EKF is not in constant position mode\n    if (ekf_status.flags.ev_pos) {\n        return false;\n    }\n\n    // Check if the EKF has a good horizontal position\n    if (!ekf_status.flags.ev_hpos) {\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 42.968713494629476}, {"code": "bool Sub::ekf_position_ok()    if (!ekf_status.inertial_nav_mode) {\n        return false;\n    }\n    if (!motors.armed()) {\n        return true;\n    }\n    if (!ekf_status.pos_horiz_abs_valid) {\n        return false;\n    }\n    if (ekf_status.constant_pos_mode) {\n        return false;\n    }\n    return true;\n}\n", "CodeBleu_score": 45.57785060805883}, {"code": "bool Sub::ekf_position_ok()    bool ekf_position_ok = false;\n    bool ekf_predicting = false;\n    bool ekf_inertial_nav = false;\n    bool ekf_const_pos_mode = false;\n    bool ekf_horiz_pos_good = false;\n    bool ekf_vert_pos_good = false;\n    bool ekf_vel_horiz_good = false;\n    bool ekf_vel_vert_good = false;\n    bool ekf_pos_horiz_rel_good = false;\n    bool ekf_pos_vert_rel_good = false;\n    bool ekf_vel_horiz_rel_good = false;\n    bool ekf_vel_vert_rel_good = false;\n    bool ekf_pos_horiz_rel_stable = false;\n    bool ekf_pos_vert_rel_stable = false;\n    bool ekf_vel_horiz_rel_stable = false;\n    bool ekf_vel_vert_rel_stable = false;\n    bool ekf_horiz_vel_good = false;\n    bool ekf_vert_vel_good = false;\n    bool ekf_horiz_vel_rel_good = false;\n    bool ekf_vert_vel_rel_good = false;\n    bool ekf_horiz_vel_rel_stable = false;\n    bool ekf_vert_vel_rel_stable = false;\n    bool ekf_horiz_pos_rel_good = false;\n    bool ekf_vert_pos_rel_good = false;\n    bool ekf_horiz_pos_rel_stable = false;\n    bool ekf_vert_pos_rel_stable = false;\n    bool ekf_vel_horiz_rel_stable = false;\n    bool ekf_vel_vert_rel_stable = false;\n    bool ekf_horiz_pos_rel_good = false;\n    bool ekf_vert_pos_rel_good = false;\n    bool ekf_horiz_pos_rel_stable = false;\n    bool ekf_vert_pos_rel_stable = false;\n    bool ekf_vel_horiz_rel", "CodeBleu_score": 15.30831084530826}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    if (!control_mode->require_GPS()) {\n        return true;\n    }\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n    if (!ahrs.get_gps().status() || ahrs.get_gps().status()->status < AP_GPS::GPS_OK_FIX_3D) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS not fixed\"));\n        }\n        return false;\n    }\n    if (ahrs.get_gps().status()->status == AP_GPS::GPS_OK_FIX_3D && ahrs.get_gps().status()->hdop > 500) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS HDOP too high\"));\n        }\n        return false;\n    }\n    if (ahrs.get_gps().status()->status == AP_GPS::GPS_OK_FIX_3D && ahrs.get_gps().status()->vdop > 1000) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS VDOP too high\"));\n        }\n        return false;\n    }\n    if (!ahrs.get_gps().status()->have_vertical_velocity) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS not supplying vertical velocity\"));\n        }\n        return false;\n    }\n    if (!ahrs.get_gps().status()->have_horizontal_velocity) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS not supplying horizontal velocity\"));\n        }\n        return false;\n    }\n    if (ahrs.get_", "CodeBleu_score": 51.890231788036445}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    // if we are not in a mode that requires GPS, return true\n    if (!ap.gps.gps_enabled(ap.ahrs.get_gps_mode())) {\n        return true;\n    }\n\n    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // if EKF failsafe is active, return false\n    if (ap.gps.get_EKF_status().failsafe) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"EKF failsafe active\"));\n        }\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ap.ahrs.get_ahrs_health_all_ok()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"AHRS not healthy\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ap.gps.position_ok()) {\n        if (display_failure) {\n            gcs_send_text_P(MAV_SEVERITY_WARNING,PSTR(\"GPS position not valid\"));\n        }\n        return false;\n    }\n\n    // if we get this far, all checks have passed\n    return true;\n}\n", "CodeBleu_score": 58.24218335778886}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    // if we don't need position or velocity then we don't need GPS\n    if (!ap.gps.get_position().is_valid() && !ap.gps.get_velocity().is_valid()) {\n        return true;\n    }\n\n    // call parent's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if AHRS system is ready\n    if (!ahrs.initialised()) {\n        if (display_failure) {\n            gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: Compass not initialised\"));\n        }\n        return false;\n    }\n\n    // check if EKF failsafe is active\n    if (ahrs.get_ekf_status() == AP_AHRS::EKF_STATUS_ESTIMATING) {\n        if (display_failure) {\n            gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: EKF not ready\"));\n        }\n        return false;\n    }\n\n    // check if position estimate is valid\n    if (!ap.gps.get_position().is_valid()) {\n        if (display_failure) {\n            gcs().send_text_P(MAV_SEVERITY_WARNING,PSTR(\"PreArm: GPS position not valid\"));\n        }\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}\n", "CodeBleu_score": 55.08684676075353}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    // exit immediately if already armed\n    if (_armed) {\n        return true;\n    }\n\n    // exit immediately if we are not armed and the method is not safe\n    if (method != AP_Arming::SAFE) {\n        return false;\n    }\n\n    // perform arming checks if required\n    if (do_arming_checks && !_pre_arm_checks.pre_arm_check(true)) {\n        return false;\n    }\n\n    // set home location\n    _ahrs.set_home();\n\n    // initialise simple mode heading\n    _simple_mode_init_heading = _ahrs.yaw_sensor;\n\n    // record home heading for sail vehicles\n    if (_sail_control != NULL) {\n        _sail_control->set_home_heading(_ahrs.yaw_sensor);\n    }\n\n    // update soft armed status\n    _armed = true;\n\n    // send arm/disarm status text\n    _mavlink_fd->send_statustext_all(MAV_SEVERITY_WARNING, ARMING_MESSAGE);\n\n    // log arming event\n    Log_Write_Event(DATA_ARM_E);\n\n    return true;\n}\n", "CodeBleu_score": 45.332340639498526}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }\n\n    // if we are already armed we can't arm\n    if (is_armed()) {\n        return false;\n    }", "CodeBleu_score": 18.71010931078182}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    // if we are already armed we cannot arm again\n    if (armed()) {\n        return false;\n    }\n\n    // if we are already in the process of arming we cannot arm again\n    if (arming_in_progress()) {\n        return false;\n    }\n\n    // if we are in a failsafe event we cannot arm again\n    if (failsafe_event_count() > 0) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we cannot arm again\n    if (pre_arm_checks_failed()) {\n        return false;\n    }\n\n    // if we are in a pre-arm event we", "CodeBleu_score": 19.24098628531722}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()  // Check if charging is allowed\n  if (charging_allowed) {\n    // If it is, check if charging is currently disabled\n    if (!charging_enabled) {\n      // If it is, enable charging and record the time\n      charging_enabled = true;\n      charging_disabled_time = millis();\n    }\n  } else {\n    // If charging is not allowed, check if charging is currently enabled\n    if (charging_enabled) {\n      // If it is, disable charging\n      charging_enabled = false;\n    } else {\n      // If it is not, check if the delay has elapsed\n      if (millis() - charging_disabled_time >= CHARGING_DISABLED_DELAY) {\n        // If it has, re-enable charging\n        charging_enabled = true;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 42.40678700477493}, {"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (!charging_enabled) {\n      charging_enabled = true;\n      digitalWrite(CHARGING_ENABLE_PIN, HIGH);\n      charging_enabled_time = millis();\n    }\n  }\n  else {\n    if (charging_enabled) {\n      charging_enabled = false;\n      digitalWrite(CHARGING_ENABLE_PIN, LOW);\n    }\n    if (millis() - charging_disabled_time > CHARGING_DISABLE_DELAY) {\n      charging_disabled_time = millis();\n    }\n  }\n}\n", "CodeBleu_score": 53.218805414511515}, {"code": "void updateChargingEnabled()  if (charging_allowed && !charging_enabled) {\n    enableCharging();\n  } else if (!charging_allowed && charging_enabled) {\n    disableCharging();\n  }\n}\n", "CodeBleu_score": 10.831865860231039}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)  if (rosRunning && size >= 4) {\n    uint32_t crc = calculateCRC(message, size);\n    packetSerial.send(message, size);\n    packetSerial.send(&crc, 4);\n  }\n}\n", "CodeBleu_score": 29.41875575336686}, {"code": "void sendMessage(void *message, size_t size)  if (rosRunning) {\n    if (size >= 4) {\n      uint16_t crc = 0;\n      uint8_t *messageBytes = (uint8_t *)message;\n      for (size_t i = 0; i < size; i++) {\n        crc = _crc_ccitt_update(crc, messageBytes[i]);\n      }\n      messageBytes[size] = (uint8_t)(crc & 0xFF);\n      messageBytes[size + 1] = (uint8_t)(crc >> 8);\n      packetSerial.send(messageBytes, size + 2);\n    }\n  }\n}", "CodeBleu_score": 52.568060736851805}, {"code": "void sendMessage(void *message, size_t size)  if (rosRunning && size >= 4) {\n    uint16_t crc = crc16((uint8_t *)message, size);\n    uint8_t *crcBytes = (uint8_t *)&crc;\n    packetSerial.send(message, size);\n    packetSerial.send(crcBytes, 2);\n  }\n}\n", "CodeBleu_score": 38.95956035923503}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()  Serial.begin(9600);\n  Serial.setTimeout(1000);\n  while (Serial.available()) {\n    Serial.read();\n  }\n  Serial.write(0x7E);\n  Serial.write(0xFF);\n  Serial.write(0x06);\n  Serial.write(0x0F);\n  Serial.write(0x01);\n  Serial.write(0x00);\n  Serial.write(0x01);\n  Serial.write(0xEF);\n  if (Serial.read() == 0x7E && Serial.read() == 0xFF && Serial.read() == 0x06) {\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();\n    Serial.read();", "CodeBleu_score": 34.42164917064501}, {"code": "bool MP3Sound::begin()  Serial.begin(9600);\n  while (Serial.available()) {\n    Serial.read();\n  }\n  Serial.println(\"AT+RESET\");\n  delay(100);\n  Serial.println(\"AT+STATUS\");\n  delay(100);\n  Serial.println(\"AT+VOLUME=30\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PAUSE\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println(\"AT+PLAY\");\n  delay(100);\n  Serial.println", "CodeBleu_score": 39.51784317337351}, {"code": "bool MP3Sound::begin()  // Initialize the serial communication\n  Serial1.begin(9600);\n  // Clear the serial buffer\n  while (Serial1.available()) {\n    Serial1.read();\n  }\n  // Initialize the sound module\n  Serial1.write(0x7E);\n  Serial1.write(0xFF);\n  Serial1.write(0x06);\n  Serial1.write(0x0F);\n  Serial1.write(0x01);\n  Serial1.write(0x00);\n  Serial1.write(0x01);\n  Serial1.write(0x00);\n  Serial1.write(0xEF);\n  // Wait for a response\n  while (Serial1.available() < 9) {\n    delay(100);\n  }\n  // Check the response\n  if (Serial1.read() == 0x7E && Serial1.read() == 0xFF && Serial1.read() == 0x06 && Serial1.read() == 0x00) {\n    // Clear the serial buffer\n    while (Serial1.available()) {\n      Serial1.read();\n    }\n    // Initialize the sound module\n    Serial1.write(0x7E);\n    Serial1.write(0xFF);\n    Serial1.write(0x06);\n    Serial1.write(0x09);\n    Serial1.write(0x01);\n    Serial1.write(0x00);\n    Serial1.write(0x01);\n    Serial1.write(0x00);\n    Serial1.write(0xEF);\n    // Wait for a response\n    while (Serial1.available() < 9) {\n      delay(100);\n    }\n    // Check the response\n    if (Serial1.read() == 0x7E && Serial1.read() == 0xFF && Serial1.read() == 0x06 && Serial1.read() == 0x00) {\n      // Clear the serial buffer\n      while (Serial1.available()) {\n        Serial1.read();\n      }\n      // Initialize the sound module", "CodeBleu_score": 40.528742596895505}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()    if (activeSounds.empty() || mp3.isPlaying()) return activeSounds.size();\n    Sound* sound = activeSounds.back();\n    sound->play();\n    activeSounds.pop_back();\n    return activeSounds.size();\n}\n", "CodeBleu_score": 39.5022246337487}, {"code": "int MP3Sound::processSounds()\tint numActiveSounds = getNumActiveSounds();\n\tif (numActiveSounds <= 0 || isPlaying())\n\t\treturn numActiveSounds;\n\t\n\tSound *sound = getLastActiveSound();\n\tif (sound == NULL)\n\t\treturn numActiveSounds;\n\t\n\tplaySound(sound);\n\tremoveActiveSound(sound);\n\t\n\treturn getNumActiveSounds();\n}\n", "CodeBleu_score": 30.10965534315665}, {"code": "int MP3Sound::processSounds()\tif (activeSounds.size() == 0) {\n\t\treturn activeSounds.size();\n\t}\n\tif (mp3Playing) {\n\t\treturn activeSounds.size();\n\t}\n\tSound* sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tsound->play();\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 38.34149786418774}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *ac = (WbAbstractCamera *)d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      wb_abstract_camera_memory_mapped_file_cleanup(ac);\n      ac->memory_mapped_file = wb_request_read_string(r);\n      ac->memory_mapped_file_size = wb_request_read_uint32(r);\n      ac->memory_mapped_file_offset = wb_request_read_uint32(r);\n      ac->memory_mapped_file_opened = false;\n      break;\n    default:\n      return false;\n  }\n  return true;\n}\n", "CodeBleu_score": 49.12882850207458}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  AbstractCamera *ac = (AbstractCamera *)d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (ac->memory_mapped_file)\n        wb_abstract_camera_cleanup_memory_mapped_file(ac);\n\n      ac->memory_mapped_file = true;\n      ac->memory_mapped_file_request = r;\n      ac->memory_mapped_file_request_size = ac->requested_width * ac->requested_height * 3;\n      ac->memory_mapped_file_request_size =\n        (ac->memory_mapped_file_request_size + 3) & ~3;  // align to 4 bytes\n      ac->memory_mapped_file_request_size *= ac->requested_number_of_views;\n      ac->memory_mapped_file_request_size += sizeof(WbCameraImage);\n\n      ac->memory_mapped_file_request_data = wb_request_write_data(ac->memory_mapped_file_request, ac->memory_mapped_file_request_size);\n      ac->memory_mapped_file_request_data_position = 0;\n      ac->memory_mapped_file_request_data_size = ac->memory_mapped_file_request_size;\n      ac->memory_mapped_file_request_data_updated = false;\n      ac->memory_mapped_file_request_data_updated_size = 0;\n      ac->memory_mapped_file_request_data_updated_position = 0;\n      ac->memory_mapped_file_request_data_updated_size_position = 0;\n\n      ac->memory_mapped_file_request_data_updated_size =\n        wb_request_write_uchar(ac->memory_mapped_file_request, ac->memory_mapped_file_request_data_updated_size);\n      ac->memory_mapped_file_request_data_updated_position =\n        wb_request_write_uchar(ac->memory_", "CodeBleu_score": 38.70046237324791}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *ac = (WbAbstractCamera *)d->pdata;\n  bool command_handled = true;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE:\n      ac->memory_mapped_file_request = r;\n      wb_abstract_camera_memory_mapped_file_cleanup(ac);\n      wb_abstract_camera_memory_mapped_file_setup(ac);\n      break;\n    default:\n      command_handled = false;\n      break;\n  }\n  return command_handled;\n}\n", "CodeBleu_score": 66.94344436056474}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)  if (d->abstract_camera_data) {\n    int result = d->abstract_camera_data->height;\n    return result;\n  }\n  return -1;\n}\n", "CodeBleu_score": 45.44572036258644}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  WbAbstractCamera *ac = d->pdata;\n  if (ac->has_get_height)\n    return ac->get_height(d);\n  return -1;\n}\n", "CodeBleu_score": 16.712584920057267}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  int result = -1;\n  robot_mutex_lock_step();\n  WbAbstractCamera *ac = wb_abstract_camera_get_struct(d);\n  if (ac)\n    result = ac->height;\n  robot_mutex_unlock_step();\n  return result;\n}", "CodeBleu_score": 66.3549028792524}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period = 0;\n  struct Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n  } else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\\n\", __FUNCTION__);\n  return sampling_period;\n}", "CodeBleu_score": 57.14602554012267}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period = 0;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    fprintf(stderr, \"Error: %s(): invalid device tag.\\n\", __FUNCTION__);\n  robot_mutex_unlock_step();\n  return sampling_period;\n}", "CodeBleu_score": 63.57889240240735}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period;\n  struct wb_accelerometer *accelerometer = wb_accelerometer_get_struct(tag);\n  if (accelerometer == NULL) {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\\n\", __FUNCTION__);\n    return -1;\n  }\n  wb_accelerometer_mutex_lock();\n  sampling_period = accelerometer->sampling_period;\n  wb_accelerometer_mutex_unlock();\n  return sampling_period;\n}\n", "CodeBleu_score": 66.29718696784003}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString(dms);\n    free(dms);\n    return dmsString;\n}\n", "CodeBleu_score": 40.74865130796342}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)  char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n  string result(dms);\n  free(dms);\n  return result;\n}", "CodeBleu_score": 39.129695571856914}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString = dms;\n    free(dms);\n    return dmsString;\n}\n", "CodeBleu_score": 44.48218558457228}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)  dUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n  dGeomBoxGetTangentPlaneFunc (g, x, y, z, plane);\n}\n", "CodeBleu_score": 7.973694668733819}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdUASSERT(g && g->type == dBoxClass, \"The argument is not a box geometry\");\n\tdUASSERT(plane, \"The plane pointer is invalid\");\n\n\t// Ensure the geometry is a box\n\tdGeomBoxGetLengths(g, plane);\n\tdGeomBoxGetLengths(g, plane + 1);\n\tdGeomBoxGetLengths(g, plane + 2);\n\tdGeomBoxGetLengths(g, plane + 3);\n\n\t// Compute the relative position of the point to the box center\n\tdVector3 point;\n\tpoint[0] = x - g->aabb[0];\n\tpoint[1] = y - g->aabb[1];\n\tpoint[2] = z - g->aabb[2];\n\n\t// Check each axis for proximity to the box's surface\n\tdReal distance = 0.0;\n\tdReal abs_point = 0.0;\n\tint normal_index = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tabs_point = fabs(point[i]);\n\t\tif (abs_point > plane[i]) {\n\t\t\tdistance = plane[i];\n\t\t\tnormal_index = i;\n\t\t}\n\t\telse if (abs_point > distance) {\n\t\t\tdistance = abs_point;\n\t\t\tnormal_index = i;\n\t\t}\n\t}\n\n\t// Set the plane's normal and distance\n\tplane[0] = 0.0;\n\tplane[1] = 0.0;\n\tplane[2] = 0.0;\n\tplane[normal_index] = (normal_index == 0) ? 1.0 : -1.0;\n\tplane[3] = distance;\n}\n", "CodeBleu_score": 37.95507124302008}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)    dUASSERT(g && g->type == dBoxClass, \"argument not a box\");\n    dUASSERT(plane, \"argument not a plane\");\n    dGeomBoxGetTangentPlaneFunc(g, x, y, z, plane);\n}\n", "CodeBleu_score": 9.372627204676013}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  dAASSERT (box);\n  dUASSERT (box->body, \"The box must have a body\");\n  dUASSERT (immersion, \"The immersion structure must not be null\");\n\n  // Check if the flags are valid\n  if (flags & ~(dImmerseBox_1D | dImmerseBox_2D)) {\n    dDebug (0, \"The flags must be 0 or dImmerseBox_1D or dImmerseBox_2D\");\n    return 0;\n  }\n\n  // Initialize the immersion data structure\n  immersion->g1.box = box;\n  immersion->g2.plane = fluidPlane;\n  immersion->flags = flags;\n\n  // Perform the immersion checking\n  return dImmerseBoxBox (immersion);\n}\n", "CodeBleu_score": 49.99966716212246}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  // check if the object is a box\n  dUASSERT (box && box->type == dBoxClass, \"argument not a box\");\n  // check if the box has a body\n  dUASSERT (box->body, \"box has no body\");\n  // check if the immersion pointer is valid\n  dUASSERT (immersion, \"immersion pointer is invalid\");\n  // check if the flags are valid\n  dUASSERT ((flags & NUMI_MASK) != 0, \"no immersion type set\");\n  // check if the flags are valid\n  dUASSERT (flags <= (NUMI_MASK | TRIMESH_ENABLED), \"invalid flags\");\n\n  // initialize the immersion object\n  immersion->g1 = box;\n  immersion->g2 = NULL;\n  immersion->normal = fluidPlane;\n  immersion->depth = 0;\n  immersion->contact = NULL;\n  immersion->contactSize = 0;\n  immersion->contactMax = 0;\n\n  // perform the immersion check\n  return dImmerseBoxBox (box, fluidPlane, flags, immersion);\n}\n", "CodeBleu_score": 47.07226040656855}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  dUASSERT(box, \"The box must be valid\");\n  dUASSERT(box->body, \"The box must have a body\");\n  dUASSERT(immersion, \"The immersion structure must be valid\");\n  dUASSERT(fluidPlane, \"The fluid plane must be valid\");\n  dUASSERT(dGeomGetClass(box) == dBoxClass, \"The object must be a box\");\n  dUASSERT(flags & NUMI_MASK, \"At least one numeric function must be active\");\n  dUASSERT(flags & ANGLE_MASK, \"At least one angle function must be active\");\n\n  dImmersionBoxData data;\n  data.box = box;\n  data.fluidPlane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n\n  return dImmerseBox_Box(&data);\n}\n", "CodeBleu_score": 44.45040976300681}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\n  // check arguments\n  dUASSERT (o1 && o2 && immersion, \"argument not a geom\");\n  dUASSERT (o1->type == dBoxClass, \"argument not a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"argument not a capsule\");\n\n  // check if the box is a box\n  dUASSERT (o1->gflags & GEOM_PLACEABLE, \"box argument not placeable\");\n\n  // check if the capsule is a capsule\n  dUASSERT (o2->gflags & GEOM_PLACEABLE, \"capsule argument not placeable\");\n\n  // get the box\n  dxBox *box = (dxBox*) o1;\n\n  // get the capsule\n  dxCapsule *capsule = (dxCapsule*) o2;\n\n  // check if the box is a box\n  dUASSERT (box->gflags & GEOM_PLACEABLE, \"box argument not placeable\");\n\n  // check if the capsule is a capsule\n  dUASSERT (capsule->gflags & GEOM_PLACEABLE, \"capsule argument not placeable\");\n\n  // get the box rotation, position, side length and half side length\n  const dReal *R = box->final_posr->R;\n  const dReal *pos = box->final_posr->pos;\n  dVector3 sides = { box->side[0], box->side[1], box->side[2] };\n  dVector3 half_sides = { box->side[0]*REAL(0.5), box->side[1]*REAL(0.5), box->side[2]*REAL(0.5) };\n\n  // get the capsule rotation, position, radius, length and half length\n  const dReal *cR = capsule->final_posr->R;\n  const dReal *cpos = capsule->final_posr->pos;\n  dReal radius = capsule->radius;\n  dReal length = capsule->lz;\n  dReal half_length = length*REAL(0.5);", "CodeBleu_score": 40.663704415736774}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\n  // check arguments\n  dUASSERT(o1 && o2 && immersion, \"The arguments are not valid\");\n\n  // check types\n  dUASSERT(o1->type == dBoxClass, \"The first argument is not a box\");\n  dUASSERT(o2->type == dCapsuleClass, \"The second argument is not a capsule\");\n\n  // check if the box is immersed in the fluid\n  if (!dGeomIsEnabled(o1)) {\n    immersion->type = 0;\n    return 0;\n  }\n\n  // check if the capsule is immersed in the fluid\n  if (!dGeomIsEnabled(o2)) {\n    immersion->type = 0;\n    return 0;\n  }\n\n  // get the box and the capsule\n  dxBox *box = (dxBox *) o1;\n  dxCapsule *capsule = (dxCapsule *) o2;\n\n  // get the rotation matrices\n  dReal rot1[12];\n  dRSetIdentity(rot1);\n  dReal rot2[12];\n  dRFromAxisAndAngle(rot2, capsule->axis[0], capsule->axis[1], capsule->axis[2], capsule->rad);\n\n  // get the center of the capsule\n  dVector3 center;\n  dGeomBoxGetCentre(o1, center);\n\n  // get the center of the box\n  dVector3 box_center;\n  dGeomBoxGetCentre(o2, box_center);\n\n  // get the half sizes of the box\n  dVector3 box_half_size;\n  dGeomBoxGetLengths(o2, box_half_size);\n\n  // get the half size of the capsule\n  dReal half_size = capsule->lz * REAL(0.5);\n\n  // get the position of the center of the capsule relative to the center of the box\n  dVector3 delta;\n  delta[0] = center[0] - box_center[0];\n  delta[1] = center[1] - box_center[1];", "CodeBleu_score": 47.08750286701502}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dVector3 p1, p2, v, normal;\n  dxBox *b1 = (dxBox *) o1;\n  dxCapsule *b2 = (dxCapsule *) o2;\n  dReal lz, lx, ly, lz2, lx2, ly2, radius, radius2, length, length2;\n  dReal dist, depth, cos1, sin1, cos2, sin2, A, B, C, D, E, F, s, t;\n  dReal x, y, z, x2, y2, z2;\n  int i, j;\n\n  // get box information\n  lx = b1->side[0];\n  ly = b1->side[1];\n  lz = b1->side[2];\n\n  // get capsule information\n  lx2 = b2->lz;\n  ly2 = b2->lz;\n  lz2 = b2->lz;\n  radius = b2->radius;\n  radius2 = radius * radius;\n  length = b2->lz;\n  length2 = length * length;\n\n  // check for separation in the x direction\n  x = dCalcVectorDot3_14 (b1->final_posr->pos, b1->final_posr->R, b2->final_posr->pos);\n  x2 = dCalcVectorDot3_14 (b2->final_posr->pos, b2->final_posr->R, b1->final_posr->pos);\n  if (x > lx + lx2 || x2 > lx + lx2) return 0;\n\n  // check for separation in the y direction\n  y = dCalcVectorDot3_14 (b1->final_posr->pos, b1->final_posr->R, b2->final_posr->pos);\n  y2 = dCalcVectorDot3_14 (b2->final_posr->pos, b2->final_posr->R, b1->final_posr->pos);\n  if (y > ly + ly2 || y2 > ly +", "CodeBleu_score": 35.675606989253914}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const    dReal tanTheta1 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.5;\n    dReal tanTheta2 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.75;\n    dReal tanTheta3 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.875;\n    dReal tanTheta4 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.9375;\n    dReal tanTheta5 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.96875;\n    dReal tanTheta6 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.984375;\n    dReal tanTheta7 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.9921875;\n    dReal tanTheta8 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.99609375;\n    dReal tanTheta9 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.998046875;\n    dReal tanTheta10 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.9990234375;\n    dReal tanTheta11 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.99951171875;\n    dReal tanTheta12 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.999755859375;\n    dReal tanTheta13 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.9998779296875;\n    dReal tanTheta14 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.99993896484375;\n    dReal tanTheta15 = tanTheta0 + (sinTheta1 - tanTheta0) * 0.9999694824218", "CodeBleu_score": 14.10984670738851}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const    dReal volume = 0;\n\n    // Use Simpson's rule to integrate the hemisphere\n    // We divide the integration into two parts to handle potential singularities\n    // The first part is from the center of the hemisphere to the point where the hemisphere intersects the immersion surface\n    // The second part is from the intersection point to the edge of the hemisphere\n    // The second part is only necessary if the hemisphere intersects the surface\n    // If the hemisphere does not intersect the surface then the first part is the entire hemisphere\n\n    // Calculate the first part of the integration\n    dReal theta0 = dAtan(tanTheta0);\n    volume = (dReal)0.5 * (sinTheta1 - dSin(theta0)) * (zIOverR * zIOverR);\n\n    // If the hemisphere intersects the surface then calculate the second part of the integration\n    if (theta0 < dReal(0.0)) {\n        // Calculate the point of intersection\n        dReal tanTheta1 = dSqrt(dReal(1.0) - (zIOverR * zIOverR));\n        dReal theta1 = dAtan(tanTheta1);\n\n        // Calculate the second part of the integration\n        volume += (dReal)0.5 * (dSin(theta1) - dSin(theta0)) * (zIOverR * zIOverR);\n    }\n\n    // Return the normalized volume\n    return volume;\n}\n", "CodeBleu_score": 41.519950704948684}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const    // Calculate the volume of the immersed hemisphere using Simpson's rule\n    // The integration is divided into two parts to handle potential singularities\n    // The first part is from zIOverR to tanTheta0\n    // The second part is from tanTheta0 to sinTheta1\n    // The sum of the two parts is the total volume\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson's rule\n    // The integration is done using Simpson''s rule\n    // The integration is done using Simpson's rule\n    //", "CodeBleu_score": 7.076934726344632}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const    // Simpson's rule for numerical integration over the hemisphere's surface\n    const dReal step = (sinTheta1 - tanTheta0) / (dReal) NUM_INTEGRATION_STEPS;\n    dReal sum = 0;\n    for (int i = 1; i < NUM_INTEGRATION_STEPS; i += 2) {\n        dReal theta = tanTheta0 + (dReal) i * step;\n        dReal thetaPlusStep = tanTheta0 + (dReal) (i + 1) * step;\n        dReal term = (dReal) 4.0 * (zIOverR - std::sqrt(1.0 - theta * theta)) * (zIOverR - std::sqrt(1.0 - thetaPlusStep * thetaPlusStep));\n        sum += (thetaPlusStep - theta) * term;\n    }\n    sum *= step / (dReal) 3.0;\n\n    // Add the term for theta = 0\n    sum += (dReal) 0.5 * (zIOverR - std::sqrt(1.0 - tanTheta0 * tanTheta0)) * (zIOverR - std::sqrt(1.0 - sinTheta1 * sinTheta1));\n\n    // Scale by the radius and adjust by the volume\n    sum *= (dReal) 0.5 * m_radius * m_radius * m_radius;\n    sum -= volume;\n\n    return sum;\n}\n", "CodeBleu_score": 38.217442208166176}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const  dReal xB = 0;\n  dReal xB1 = 0;\n  dReal xB2 = 0;\n  dReal xB3 = 0;\n  dReal xB4 = 0;\n  dReal xB5 = 0;\n  dReal xB6 = 0;\n  dReal xB7 = 0;\n  dReal xB8 = 0;\n  dReal xB9 = 0;\n  dReal xB10 = 0;\n  dReal xB11 = 0;\n  dReal xB12 = 0;\n  dReal xB13 = 0;\n  dReal xB14 = 0;\n  dReal xB15 = 0;\n  dReal xB16 = 0;\n  dReal xB17 = 0;\n  dReal xB18 = 0;\n  dReal xB19 = 0;\n  dReal xB20 = 0;\n  dReal xB21 = 0;\n  dReal xB22 = 0;\n  dReal xB23 = 0;\n  dReal xB24 = 0;\n  dReal xB25 = 0;\n  dReal xB26 = 0;\n  dReal xB27 = 0;\n  dReal xB28 = 0;\n  dReal xB29 = 0;\n  dReal xB30 = 0;\n  dReal xB31 = 0;\n  dReal xB32 = 0;\n  dReal xB33 = 0;\n  dReal xB34 = 0;\n  dReal xB35 = 0;\n  dReal xB36 = 0;\n  dReal xB37 = 0;\n  dReal xB38 = 0;\n  dReal xB39 = 0;\n  dReal xB40 = 0;\n  dReal xB41 = 0;\n  dReal xB42 = 0;\n  dReal xB43", "CodeBleu_score": 10.04797588649986}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const    dReal xBc = 0;\n    dReal dz = 2 * zIOverR / (nBuoyancyPoints - 1);\n    dReal z = zIOverR - zIOverR;\n    dReal dz2 = dz + dz;\n    dReal z2 = z + z;\n    dReal z4 = z2 + z2;\n    for (int i = 0; i < nBuoyancyPoints; i++, z += dz2, z2 += dz2, z4 += dz2) {\n        dReal cosTheta = sqrt(fabs(1 - z2));\n        dReal sinTheta = sqrt(fabs(1 - z4));\n        dReal theta = asin(sinTheta);\n        dReal theta0 = asin(sinTheta0);\n        dReal theta1 = asin(sinTheta1);\n        dReal theta2 = asin(sinTheta * sinTheta0 / sinTheta1);\n        dReal theta3 = asin(sinTheta * sinTheta1 / sinTheta0);\n        dReal theta4 = asin(sinTheta0 * sinTheta1 / sinTheta);\n        dReal theta5 = asin(sinTheta1 * sinTheta0 / sinTheta);\n        dReal theta6 = asin(sinTheta * sinTheta0 / sinTheta);\n        dReal theta7 = asin(sinTheta * sinTheta1 / sinTheta);\n        dReal theta8 = asin(sinTheta0 * sinTheta1 / sinTheta);\n        dReal theta9 = asin(sinTheta1 * sinTheta0 / sinTheta);\n        dReal theta10 = asin(sinTheta0 * sinTheta1 / sinTheta);\n        dReal theta11 = asin(sinTheta * sinTheta0 / sinTheta1);\n        dReal theta12 = asin(sinTheta * sinTheta1 / sinTheta0);\n        dReal theta13 = asin(sinTheta0 * sinTheta1 / sinTheta);\n        dReal theta14 = asin(sinTheta1 * sinTheta0 / sinTheta);\n        dReal theta15 = asin(sinTheta0 * sinTheta1 / sin", "CodeBleu_score": 36.51752129575432}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dxCapsule *capsule = (dxCapsule*) CLASSDATA(o1);\n  dxTriMesh *mesh = (dxTriMesh*) CLASSDATA(o2);\n\n  int i;\n  dReal k;\n  dReal depth;\n  dReal volume;\n  dReal area;\n  dReal radius = REAL(0.5) * capsule->radius;\n  dReal length = capsule->lz - radius;\n  dReal cos_angle = cos (capsule->angle);\n  dReal sin_angle = sin (capsule->angle);\n\n  // get capsule's immersion depth\n  k = dImmerseCapsuleTriangle (o1, o2, 0, &depth);\n\n  // if depth is negative, the capsule is completely out of the mesh\n  if (k < 0) return 0;\n\n  // get capsule's immersion volume\n  volume = dImmerseCapsuleTriangle (o1, o2, 1, &depth);\n\n  // if depth is negative, the capsule is completely out of the mesh\n  if (k < 0) return 0;\n\n  // get capsule's immersion area\n  area = dImmerseCapsuleTriangle (o1, o2, 2, &depth);\n\n  // if depth is negative, the capsule is completely out of the mesh\n  if (k < 0) return 0;\n\n  // calculate the buoyancy center\n  immersion->buoyancy_center[0] = REAL(0.0);\n  immersion->buoyancy_center[1] = REAL(0.0);\n  immersion->buoyancy_center[2] = REAL(0.0);\n\n  // calculate the x-coordinate of the buoyancy center\n  immersion->buoyancy_center[0] = sCapsule", "CodeBleu_score": 45.85517200920521}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dIASSERT ((flags & NUMI_MASK) >= 1);\n  int maxc = flags & NUMI_MASK;\n  if (maxc == 1) {\n    return 1;\n  }\n  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n  dxCapsule *c = (dxCapsule*) CLASSDATA(o1);\n  dxTriMesh *m = (dxTriMesh*) CLASSDATA(o2);\n  const dReal *R = c->final_posr->R;\n  const dReal *pos = c->final_posr->pos;\n  const dReal *p1 = c->final_posr->pos;\n  const dReal *p2 = c->final_posr->pos + 3;\n  dReal radius = c->radius;\n  dReal length = c->lz;\n  dReal halfLength = length / 2;\n  dReal cylinderVolume = M_PI * radius * radius * length;\n  dReal halfSpaceVolume = M_PI * radius * radius * halfLength;\n  dReal hemisphereVolume = 2.0 / 3.0 * M_PI * radius * radius * radius;\n  dReal totalVolume = cylinderVolume - halfSpaceVolume + hemisphereVolume;\n  dReal hemisphereMass = totalVolume * c->mass / (cylinderVolume - halfSpaceVolume);\n  dReal hemisphereDensity = hemisphereMass / hemisphereVolume;\n  dReal hemisphereRadius = dSqrt (3.0 / (4.0 * M_PI) * hemisphereVolume / (halfLength * halfLength));\n  dReal hemisphereRadius2 = hemisphereRadius * hemisphereRadius;\n  dReal hemisphereRadius3 = hemisphereRadius2 * hemisphereRadius;\n  dReal hemisphereRadius4 = hemisphereRadius3 * hemisphereRadius;\n  dReal hemisphereRadius5 = hemisphereRadius4 * hemisphereRadius;\n  dReal hemisphereRadius6 = hemisphereRadius", "CodeBleu_score": 37.09661533610175}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dIASSERT ((flags & NUMI_MASK) >= 1);\n  int maxc = (flags & NUMI_MASK) + 1;\n  dVector3 p, q, n, v, nn;\n  dReal k, nx, ny, nz, m[4], A[4], B[4], C[4], D[4], E[4], F[4], G[4], H[4];\n  dReal x, y, z, R, r, h, V, V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, V13, V14, V15, V16, V17, V18, V19, V20, V21, V22, V23, V24, V25, V26, V27, V28, V29, V30, V31, V32, V33, V34, V35, V36, V37, V38, V39, V40, V41, V42, V43, V44, V45, V46, V47, V48, V49, V50, V51, V52, V53, V54, V55, V56, V57, V58, V59, V60, V61, V62, V63, V64, V65, V66, V67, V68, V69, V70, V71, V72, V73, V74, V75, V76, V77, V78, V79, V80, V81, V82, V83, V84, V85, V86, V87, V88, V89, V90, V91, V92, V93, V94, V95, V96, V97, V98, V99, V100", "CodeBleu_score": 16.99160052054602}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()    NodeStatus status;\n\n    if (!getInput<double>(\"duration\", duration_)) {\n        return status;\n    }\n\n    if (duration_ <= 0.0) {\n        return status;\n    }\n\n    setStatus(NodeStatus::RUNNING);\n\n    timer_waiting_ = true;\n    timer_.start(duration_);\n    timer_.setCallback(std::bind(&SleepNode::emitWakeUp, this));\n\n    return status;\n}\n", "CodeBleu_score": 37.86884384446269}, {"code": "NodeStatus SleepNode::onStart()    NodeStatus ret = NodeStatus::SUCCESS;\n    if (isInputConnected(0)) {\n        double sleep_duration = getInput<double>(0);\n        if (sleep_duration > 0) {\n            setStatus(NodeStatus::RUNNING);\n            timer_waiting_ = true;\n            auto cb = [this]() {\n                timer_waiting_ = false;\n                emit(0, true);\n                setStatus(NodeStatus::SUCCESS);\n            };\n            timer_.start(sleep_duration, cb);\n        }\n    }\n    return ret;\n}\n", "CodeBleu_score": 40.37610274353709}, {"code": "NodeStatus SleepNode::onStart()  NodeStatus ret = NodeStatus::SUCCESS;\n  if (input_->isConnected()) {\n    int64_t duration = input_->getData<int64_t>();\n    if (duration > 0) {\n      setStatus(NodeStatus::RUNNING);\n      timer_waiting_ = true;\n      ret = timer_.start(duration, [this]() {\n        timer_waiting_ = false;\n        emit(wake_up_);\n      });\n      if (ret != NodeStatus::SUCCESS) {\n        timer_waiting_ = false;\n      }\n    }\n  }\n  return ret;\n}\n", "CodeBleu_score": 45.74593869011814}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(mutex);\n\n\t// Retrieve the entry\n\tauto entry = blackboardClient.getBlackboardEntry(entryName);\n\n\t// Check if the entry exists\n\tif (entry) {\n\t\t// Check if the entry has been updated\n\t\tif (entry->getSequenceID() != sequenceID) {\n\t\t\t// Update the sequence ID\n\t\t\tsequenceID = entry->getSequenceID();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\t}\n\n\t// Return failure\n\treturn NodeStatus::FAILURE;\n}", "CodeBleu_score": 28.91218738575228}, {"code": "NodeStatus EntryUpdatedAction::tick()\tstd::string entry_name;\n\tgetInput(\"entry_name\", entry_name);\n\n\tstd::string entry_value;\n\tgetInput(\"entry_value\", entry_value);\n\n\t// Check if the entry exists\n\tif (!blackboard->exists(entry_name)) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the mutex\n\tstd::unique_lock<std::mutex> lock(blackboard->mtx);\n\n\t// Get the entry\n\tEntry* entry = blackboard->getEntry(entry_name);\n\n\t// Check if the entry has been updated\n\tif (entry->sequence_id != entry_value) {\n\t\tentry->sequence_id = entry_value;\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\treturn NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 44.79307673809749}, {"code": "NodeStatus EntryUpdatedAction::tick()\tNodeStatus status = NodeStatus::FAILURE;\n\tstd::string entry_name = getInput<std::string>(\"entry_name\");\n\tstd::string entry_value = getInput<std::string>(\"entry_value\");\n\tbool entry_found = false;\n\tstd::string entry_type = getInput<std::string>(\"entry_type\");\n\tstd::string entry_type_real = entry_type;\n\n\tif (entry_type == \"string\") {\n\t\tentry_type_real = \"std::string\";\n\t}\n\n\tif (entry_type == \"int\") {\n\t\tentry_type_real = \"int\";\n\t}\n\n\tif (entry_type == \"double\") {\n\t\tentry_type_real = \"double\";\n\t}\n\n\tif (entry_type == \"bool\") {\n\t\tentry_type_real = \"bool\";\n\t}\n\n\tif (entry_type == \"vector<string>\") {\n\t\tentry_type_real = \"std::vector<std::string>\";\n\t}\n\n\tif (entry_type == \"vector<int>\") {\n\t\tentry_type_real = \"std::vector<int>\";\n\t}\n\n\tif (entry_type == \"vector<double>\") {\n\t\tentry_type_real = \"std::vector<double>\";\n\t}\n\n\tif (entry_type == \"vector<bool>\") {\n\t\tentry_type_real = \"std::vector<bool>\";\n\t}\n\n\tif (entry_type == \"vector<vector<string>>\") {\n\t\tentry_type_real = \"std::vector<std::vector<std::string>>\";\n\t}\n\n\tif (entry_type == \"vector<vector<int>>\") {\n\t\tentry_type_real = \"std::vector<std::vector<int>>\";\n\t}\n\n\tif (entry_type == \"vector<vector<double>>\") {\n\t\tentry_type_real = \"std::vector<std::vector<double>>\";\n\t}\n\n\tif (entry_type == \"vector<vector<bool>>\") {\n\t\tentry_type_real = \"std", "CodeBleu_score": 29.664721653014432}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const\tif (this->successThreshold_ < 0) {\n\t\treturn this->children.size() + this->successThreshold_;\n\t}\n\treturn static_cast<size_t>(this->successThreshold_);\n}\n", "CodeBleu_score": 20.669053949551895}, {"code": "size_t ParallelNode::successThreshold() const\tif (this->successThreshold_ < 0) {\n\t\treturn (size_t)((this->children_.size() * -this->successThreshold_) + 0.5);\n\t}\n\treturn (size_t)this->successThreshold_;\n}\n", "CodeBleu_score": 21.489951836806824}, {"code": "size_t ParallelNode::successThreshold() const\tint threshold = this->threshold;\n\tif (threshold < 0) {\n\t\tthreshold += this->children.size();\n\t\tif (threshold < 0) {\n\t\t\tthreshold = 0;\n\t\t}\n\t}\n\treturn threshold;\n}\n", "CodeBleu_score": 41.73982589375251}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()    while(true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::chrono::steady_clock::time_point currentTime = std::chrono::steady_clock::now();\n        std::chrono::duration<double> timeSinceLastHeartbeat = currentTime - lastHeartbeat;\n        if(timeSinceLastHeartbeat.count() > heartbeatTimeout) {\n            if(heartbeatStatus) {\n                // heartbeat has timed out\n                heartbeatStatus = false;\n                std::cout << \"Groot2Publisher: Heartbeat timed out. Disabling breakpoints.\" << std::endl;\n                for(auto it = breakpoints.begin(); it != breakpoints.end(); it++) {\n                    it->second.enabled = false;\n                }\n            }\n        } else {\n            if(!heartbeatStatus) {\n                // heartbeat has resumed\n                heartbeatStatus = true;\n                std::cout << \"Groot2Publisher: Heartbeat resumed. Enabling breakpoints.\" << std::endl;\n                for(auto it = breakpoints.begin(); it != breakpoints.end(); it++) {\n                    it->second.enabled = true;\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 36.60224647958876}, {"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        if (getHeartbeatStatus()) {\n            if (!heartbeatStatus) {\n                heartbeatStatus = true;\n                enableAllBreakpoints();\n            }\n        } else {\n            if (heartbeatStatus) {\n                heartbeatStatus = false;\n                disableAllBreakpoints();\n            }\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n", "CodeBleu_score": 27.301552005995184}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\t// If the server is down, disable all breakpoints\n\t\tif (serverDown()) {\n\t\t\tdisableAllBreakpoints();\n\t\t}\n\t\t// If the server is up, enable all breakpoints\n\t\telse {\n\t\t\tenableAllBreakpoints();\n\t\t}\n\t\t// Sleep for 10 milliseconds\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t}\n}\n", "CodeBleu_score": 11.753679383285732}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)  std::vector<uint8_t> result;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n  std::vector<std::string> bb_names;\n\n  while (std::getline(ss, bb_name, ',')) {\n    bb_names.push_back(bb_name);\n  }\n\n  std::vector<std::string> bb_names_to_publish;\n  for (const std::string& bb_name : bb_names) {\n    if (bb_name == \"all\") {\n      for (const std::string& bb_name : blackboard_names_) {\n        bb_names_to_publish.push_back(bb_name);\n      }\n    } else {\n      bb_names_to_publish.push_back(bb_name);\n    }\n  }\n\n  nlohmann::json j;\n  for (const std::string& bb_name : bb_names_to_publish) {\n    std::lock_guard<std::mutex> lock(blackboard_mutex_);\n    auto it = blackboards_.find(bb_name);\n    if (it != blackboards_.end()) {\n      if (it->second.isValid()) {\n        j[bb_name] = it->second.toJSON();\n      }\n    }\n  }\n\n  result = nlohmann::json::to_msgpack(j);\n  return result;\n}\n", "CodeBleu_score": 46.19075830947914}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<uint8_t> result;\n    std::stringstream ss(bb_list);\n    std::string bb_name;\n    while (std::getline(ss, bb_name, ',')) {\n        std::lock_guard<std::mutex> lock(this->blackboard_mutex);\n        auto it = this->blackboards.find(bb_name);\n        if (it != this->blackboards.end()) {\n            auto bb = it->second;\n            if (bb->isValid()) {\n                nlohmann::json j = nlohmann::json::object();\n                j[bb_name] = bb->toJSON();\n                result.insert(result.end(), j.dump().begin(), j.dump().end());\n            }\n        }\n    }\n    return result;\n}\n", "CodeBleu_score": 45.50646703401401}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<uint8_t> bb_dump;\n    std::vector<std::string> bb_names;\n    std::stringstream ss(bb_list);\n    std::string item;\n    while (std::getline(ss, item, ',')) {\n        bb_names.push_back(item);\n    }\n    rapidjson::Document bb_json;\n    bb_json.SetObject();\n    for (std::string bb_name : bb_names) {\n        if (bb_name.empty()) {\n            continue;\n        }\n        std::shared_ptr<Blackboard> bb_ptr = getBlackboard(bb_name);\n        if (bb_ptr != nullptr) {\n            std::string bb_json_str = bb_ptr->toJSON();\n            rapidjson::Document bb_json_doc;\n            bb_json_doc.Parse(bb_json_str.c_str());\n            bb_json.AddMember(bb_name, bb_json_doc, bb_json.GetAllocator());\n        }\n    }\n    rapidjson::StringBuffer buffer;\n    rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);\n    bb_json.Accept(writer);\n    bb_dump.assign(buffer.GetString(), buffer.GetString() + buffer.GetSize());\n    return bb_dump;\n}\n", "CodeBleu_score": 40.00933536655143}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  // Check if the node exists\n  if (nodes.find(node_uid) == nodes.end()) {\n    ROS_ERROR(\"Groot2Publisher::unlockBreakpoint: Node %d does not exist\", node_uid);\n    return false;\n  }\n\n  // Check if the node is valid\n  if (nodes[node_uid].status != NodeStatus::VALID) {\n    ROS_ERROR(\"Groot2Publisher::unlockBreakpoint: Node %d is not valid\", node_uid);\n    return false;\n  }\n\n  // Lock the hook mutex\n  std::lock_guard<std::mutex> lock(nodes[node_uid].hook->mutex);\n\n  // Check if the hook is in BREAKPOINT mode\n  if (nodes[node_uid].hook->mode != HookMode::BREAKPOINT) {\n    ROS_ERROR(\"Groot2Publisher::unlockBreakpoint: Node %d is not in BREAKPOINT mode\", node_uid);\n    return false;\n  }\n\n  // Set the desired status and removal flag\n  nodes[node_uid].hook->desired_status = result;\n  nodes[node_uid].hook->remove = remove;\n\n  // Mark the hook as ready\n  nodes[node_uid].hook->ready = true;\n\n  // Notify all waiting threads\n  nodes[node_uid].hook->cv.notify_all();\n\n  return true;\n}\n", "CodeBleu_score": 34.50268473016618}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  if (node_uid == 0) {\n    return false;\n  }\n  std::lock_guard<std::mutex> lock(m_mutex);\n  auto it = std::find_if(m_nodes.begin(), m_nodes.end(),\n                         [&](const auto &node) { return node->uid() == node_uid; });\n  if (it == m_nodes.end()) {\n    return false;\n  }\n  auto hook = (*it)->hook();\n  if (hook == nullptr) {\n    return false;\n  }\n  std::lock_guard<std::mutex> lock_hook(hook->m_mutex);\n  if (hook->m_mode != BREAKPOINT) {\n    return false;\n  }\n  hook->m_status = result;\n  hook->m_remove = remove;\n  hook->m_ready = true;\n  hook->m_cond.notify_all();\n  return true;\n}\n", "CodeBleu_score": 54.138454675776956}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  std::lock_guard<std::mutex> lock(m_mutex);\n\n  // Check if the node exists\n  if (m_nodes.count(node_uid) == 0) {\n    return false;\n  }\n\n  // Check if the node is valid\n  if (!m_nodes[node_uid].valid) {\n    return false;\n  }\n\n  // Lock the hook's mutex\n  std::lock_guard<std::mutex> hook_lock(m_nodes[node_uid].hook->m_mutex);\n\n  // Check if the hook is in BREAKPOINT mode\n  if (m_nodes[node_uid].hook->m_mode == HookMode::BREAKPOINT) {\n    // Set the desired status and removal flag\n    m_nodes[node_uid].hook->m_status = result;\n    m_nodes[node_uid].hook->m_remove = remove;\n    // Mark the hook as ready\n    m_nodes[node_uid].hook->m_ready = true;\n    // Notify all waiting threads\n    m_nodes[node_uid].hook->m_cond.notify_all();\n    return true;\n  }\n\n  return false;\n}\n", "CodeBleu_score": 36.59511272345706}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()    std::lock_guard<std::mutex> lock(state_mutex_);\n    if (status_ == NodeStatus::IDLE) {\n        status_ = NodeStatus::RUNNING;\n        halt_requested_ = false;\n        tick_thread_ = std::thread([this] {\n            try {\n                tick();\n                if (!halt_requested_) {\n                    status_ = NodeStatus::SUCCESS;\n                }\n            }\n            catch (std::exception &error) {\n                std::cout << \"[ERROR] \" << error.what() << std::endl;\n                status_ = NodeStatus::IDLE;\n            }\n        });\n    }\n    if (stored_exception_) {\n        std::rethrow_exception(stored_exception_);\n    }\n    return status_;\n}\n", "CodeBleu_score": 42.013275152187255}, {"code": "NodeStatus BT::ThreadedAction::executeTick()  // If the node is not idle, then it is already running.\n  if (status() != NodeStatus::IDLE) {\n    return status();\n  }\n\n  // Set the status to running and reset halt_requested_\n  setStatus(NodeStatus::RUNNING);\n  halt_requested_ = false;\n\n  // Start a new thread to run the tick function\n  std::thread tick_thread(&BT::ThreadedAction::tickThread, this);\n\n  // Detach the thread so it can run independently\n  tick_thread.detach();\n\n  return status();\n}\n", "CodeBleu_score": 18.896591690694887}, {"code": "NodeStatus BT::ThreadedAction::executeTick()  // If the node is not IDLE, return the current status\n  if (getStatus() != NodeStatus::IDLE) {\n    return getStatus();\n  }\n\n  // If the node is IDLE, set the status to RUNNING and reset halt_requested_\n  setStatus(NodeStatus::RUNNING);\n  halt_requested_ = false;\n\n  // Start the tick function in a new thread\n  std::thread tick_thread([this]() {\n    try {\n      // Run the tick function\n      tick();\n\n      // If halt_requested_ is false, update the status\n      if (!halt_requested_) {\n        setStatus(NodeStatus::SUCCESS);\n      }\n    } catch (std::exception &ex) {\n      // If an exception occurs, log an error, set the status to IDLE, and rethrow the exception\n      RCLCPP_ERROR(node_->get_logger(), ex.what());\n      setStatus(NodeStatus::IDLE);\n      throw;\n    }\n  });\n\n  // Detach the thread to allow it to run asynchronously\n  tick_thread.detach();\n\n  // If any exceptions have been stored, rethrow them\n  if (!stored_exceptions_.empty()) {\n    std::rethrow_exception(stored_exceptions_.top());\n  }\n\n  // Return the current status of the node\n  return getStatus();\n}\n", "CodeBleu_score": 44.18847808443068}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)  stream << \"--------------------------------------------------------------------------------\" << std::endl;\n  stream << \"Tree Structure\" << std::endl;\n  stream << \"--------------------------------------------------------------------------------\" << std::endl;\n  auto print_node = [&stream](const TreeNode* node, int depth) {\n    for (int i = 0; i < depth; ++i) {\n      stream << \"  \";\n    }\n    stream << node->get_name() << std::endl;\n    if (node->get_type() == TreeNode::CONTROL) {\n      for (auto child : node->get_children()) {\n        print_node(child, depth + 1);\n      }\n    }\n    else if (node->get_type() == TreeNode::DECORATOR) {\n      print_node(node->get_child(), depth + 1);\n    }\n  };\n  print_node(root_node, 0);\n  stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}\n", "CodeBleu_score": 47.79804801180194}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    auto print_node = [&](const TreeNode* node, int depth) {\n        stream << std::string(depth, '\\t') << node->getName() << std::endl;\n        if (node->getType() == NodeType::CONTROL) {\n            for (auto child : node->getChildren()) {\n                print_node(child, depth + 1);\n            }\n        }\n        else if (node->getType() == NodeType::DECORATOR) {\n            print_node(node->getChild(), depth + 1);\n        }\n    };\n    stream << \"--------------------------------------------------------\" << std::endl;\n    print_node(root_node, 0);\n    stream << \"--------------------------------------------------------\" << std::endl;\n}\n", "CodeBleu_score": 36.95126243553318}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    // lambda function for printing\n    auto print_tree = [&](const TreeNode* node, int depth) {\n        // indent based on depth\n        for (int i = 0; i < depth; i++) {\n            stream << \"    \";\n        }\n        // print the node's name\n        stream << node->getNodeName() << std::endl;\n        // recursively print the children\n        if (node->getType() == TreeNode::Type::CONTROL) {\n            for (const auto& child : node->getChildren()) {\n                print_tree(child.get(), depth + 1);\n            }\n        } else if (node->getType() == TreeNode::Type::DECORATOR) {\n            print_tree(node->getChild(), depth + 1);\n        }\n    };\n    // begin with a separator line\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n    // print the tree recursively\n    print_tree(root_node, 0);\n    // end with a separator line\n    stream << \"--------------------------------------------------------------------------------\" << std::endl;\n}", "CodeBleu_score": 46.35205123044893}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)    if (node == nullptr) {\n        throw LogicError(\"applyRecursiveVisitor: node is null\");\n    }\n    visitor(node);\n    if (node->getType() == ControlNode::Type::CONTROL) {\n        const auto* controlNode = static_cast<const ControlNode*>(node);\n        for (const auto& child : controlNode->getChildren()) {\n            applyRecursiveVisitor(child.get(), visitor);\n        }\n    } else if (node->getType() == DecoratorNode::Type::DECORATOR) {\n        const auto* decoratorNode = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decoratorNode->getChild(), visitor);\n    }\n}\n", "CodeBleu_score": 58.64359111017665}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr)\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n\n  visitor(node);\n\n  if (node->getType() == ControlNode::SEQUENCE) {\n    const auto* sequenceNode = static_cast<const SequenceNode*>(node);\n    for (const auto& child : sequenceNode->getChildren())\n      applyRecursiveVisitor(child.get(), visitor);\n  } else if (node->getType() == ControlNode::SELECTOR) {\n    const auto* selectorNode = static_cast<const SelectorNode*>(node);\n    for (const auto& child : selectorNode->getChildren())\n      applyRecursiveVisitor(child.get(), visitor);\n  } else if (node->getType() == ControlNode::PARALLEL) {\n    const auto* parallelNode = static_cast<const ParallelNode*>(node);\n    for (const auto& child : parallelNode->getChildren())\n      applyRecursiveVisitor(child.get(), visitor);\n  } else if (node->getType() == ControlNode::DECORATOR) {\n    const auto* decoratorNode = static_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decoratorNode->getChild(), visitor);\n  }\n}\n", "CodeBleu_score": 51.63987488489585}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr) {\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n  }\n  visitor(node);\n  if (node->getType() == ControlNode::Type::kSequence ||\n      node->getType() == ControlNode::Type::kSelector) {\n    const auto* controlNode = static_cast<const ControlNode*>(node);\n    for (const auto& child : controlNode->children()) {\n      applyRecursiveVisitor(child.get(), visitor);\n    }\n  } else if (node->getType() == ControlNode::Type::kDecorator) {\n    const auto* decoratorNode = static_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decoratorNode->getChild().get(), visitor);\n  }\n}\n", "CodeBleu_score": 58.28298769455582}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    if (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"Builder with registration ID \" +\n                                    manifest.registrationID + \" already exists.\");\n    }\n    builders[manifest.registrationID] = builder;\n    manifests[manifest.registrationID] = manifest;\n}\n", "CodeBleu_score": 45.92867609691284}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    std::string registrationID = manifest.getRegistrationID();\n\n    if (builders.find(registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"Cannot register builder with ID \" + registrationID + \" because it already exists.\");\n    }\n\n    builders[registrationID] = builder;\n    manifests[registrationID] = manifest;\n}\n", "CodeBleu_score": 43.75608988784686}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    if (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"The registration ID \\\"\" + manifest.registrationID + \"\\\" is already registered.\");\n    }\n    builders[manifest.registrationID] = builder;\n    manifests[manifest.registrationID] = manifest;\n}\n", "CodeBleu_score": 45.486430967735046}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  NodeBuilder builder = [tick_functor](const std::string& name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n\n  TreeNodeManifest manifest(ID, ActionNode, std::move(ports));\n  registerBuilder(manifest, builder);\n}\n", "CodeBleu_score": 58.434974537149756}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  NodeBuilder builder = [tick_functor](const std::string& name,\n                                       const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n  TreeNodeManifest manifest(ActionNode::TYPE, ID, std::move(ports));\n  this->registerBuilder(manifest, builder);\n}\n", "CodeBleu_score": 60.39958297642627}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  NodeBuilder builder = [tick_functor](const std::string& name,\n                                       const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, config, tick_functor);\n  };\n  TreeNodeManifest manifest(ID, ActionNode, std::move(ports));\n  registerBuilder(manifest, builder);\n}\n", "CodeBleu_score": 61.718445545745304}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)  std::vector<Blackboard::Ptr> blackboard_backups;\n  blackboard_backups.reserve(tree.NumSubtrees());\n  for (size_t i = 0; i < tree.NumSubtrees(); ++i) {\n    Blackboard::Ptr blackboard_backup = Blackboard::Create();\n    blackboard_backup->Clone(*tree.Subtree(i)->blackboard());\n    blackboard_backups.push_back(blackboard_backup);\n  }\n  return blackboard_backups;\n}\n", "CodeBleu_score": 48.70434267717798}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)  std::vector<Blackboard::Ptr> blackboard_backups;\n  blackboard_backups.reserve(tree.size());\n  for (const auto& subtree : tree) {\n    auto blackboard_backup = Blackboard::Create();\n    blackboard_backup->Clone(*subtree.blackboard());\n    blackboard_backups.push_back(blackboard_backup);\n  }\n  return blackboard_backups;\n}\n", "CodeBleu_score": 52.629393614831976}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)  std::vector<Blackboard::Ptr> blackboard_backups;\n  blackboard_backups.reserve(tree.size());\n  for (auto subtree : tree) {\n    Blackboard::Ptr blackboard_backup = Blackboard::Create();\n    blackboard_backup->Clone(*subtree->blackboard());\n    blackboard_backups.push_back(blackboard_backup);\n  }\n  return blackboard_backups;\n}\n", "CodeBleu_score": 51.81585048699442}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if(!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor.value()(env);\n}\n", "CodeBleu_score": 74.87297416666183}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (executor) {\n\t\treturn executor.value()(env);\n\t}\n\telse {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n}\n", "CodeBleu_score": 83.79059398950157}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return (*executor)(env);\n}", "CodeBleu_score": 70.90981686204361}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)    // Check if the library is already loaded\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded.\");\n    }\n\n    // Lock the mutex\n    std::unique_lock<std::mutex> lock(mutex);\n\n    // Attempt to load the library\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    // Check if the load was successful\n    if (handle == NULL) {\n        // Throw a RuntimeError with the error message\n        throw RuntimeError(dlerror());\n    }\n\n    // Store the path\n    this->path = path;\n\n    // Set the loaded flag to true\n    loaded = true;\n}\n", "CodeBleu_score": 49.87705393360156}, {"code": "void SharedLibrary::load(const std::string& path, int)    //Acquire a unique lock on the mutex\n    std::unique_lock<std::mutex> lock(mutex);\n    //Check if a library is already loaded\n    if (loaded) {\n        throw RuntimeError(\"A library has already been loaded\");\n    }\n    //Attempt to load the library\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    //If the load fails, retrieve the error message and throw a RuntimeError\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    //If the load was successful, store the path of the loaded library\n    this->path = path;\n    loaded = true;\n}\n", "CodeBleu_score": 53.91540420247295}, {"code": "void SharedLibrary::load(const std::string& path, int)    std::lock_guard<std::mutex> lock(mutex_);\n    if (handle_ != nullptr) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n    handle_ = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle_ == nullptr) {\n        throw RuntimeError(dlerror());\n    }\n    path_ = path;\n}\n", "CodeBleu_score": 49.76923004995973}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    // Check if the string is at least 3 characters long\n    if (str.size() < 3) {\n        return false;\n    }\n\n    // Strip leading and trailing spaces\n    StringView stripped = str.trim();\n\n    // Check if the string starts with '{' and ends with '}'\n    if (stripped.front() != '{' || stripped.back() != '}') {\n        return false;\n    }\n\n    // Assign the inner content to stripped_pointer if it is not nullptr\n    if (stripped_pointer != nullptr) {\n        *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n\n    return true;\n}\n", "CodeBleu_score": 26.35266723436845}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    // Check if the string is at least 3 characters long\n    if (str.length() < 3) {\n        return false;\n    }\n\n    // Strip leading and trailing spaces\n    StringView stripped = str;\n    stripped.trim();\n\n    // Check if the string starts with '{' and ends with '}'\n    if (stripped.at(0) != '{' || stripped.at(stripped.length() - 1) != '}') {\n        return false;\n    }\n\n    // If valid and a stripped_pointer is provided, assign the inner content to stripped_pointer\n    if (stripped_pointer != nullptr) {\n        *stripped_pointer = stripped.substr(1, stripped.length() - 2);\n    }\n\n    return true;\n}\n", "CodeBleu_score": 27.99056753440685}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped_str = str;\n\tstripped_str.trim();\n\tif (stripped_str.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped_str[0] != '{' || stripped_str[stripped_str.size() - 1] != '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped_str.substr(1, stripped_str.size() - 2);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 27.31310325310494}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const    double cost = 0.0;\n    LineIterator line(x0, x1, y0, y1);\n\n    for (; !line.done(); line.advance()) {\n        double point_cost = pointCost(line.x(), line.y());\n\n        if (point_cost < 0.0) {\n            return point_cost;\n        } else if (point_cost > cost) {\n            cost = point_cost;\n        }\n    }\n\n    return cost;\n}\n", "CodeBleu_score": 63.796276832339636}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const    double lineCost = 0.0;\n    LineIterator line(x0, y0, x1, y1);\n    for (; !line.done(); line.advance()) {\n        double pointCost = pointCost(line.x(), line.y());\n        if (pointCost < 0.0) {\n            return pointCost;\n        }\n        if (pointCost > lineCost) {\n            lineCost = pointCost;\n        }\n    }\n    return lineCost;\n}\n", "CodeBleu_score": 62.39889459258923}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  double line_cost = 0.0;\n  LineIterator line(x0, y0, x1, y1);\n  for(; !line.done(); line.advance()) {\n    double point_cost = pointCost(line.x(), line.y());\n    if(point_cost < 0.0) {\n      return point_cost;\n    } else if(point_cost > line_cost) {\n      line_cost = point_cost;\n    }\n  }\n  return line_cost;\n}\n", "CodeBleu_score": 68.52715360059811}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   if (path.empty()) {\n    return;\n  }\n  nav_msgs::Path path_msg;\n  path_msg.header.frame_id = path[0].header.frame_id;\n  path_msg.header.stamp = path[0].header.stamp;\n  path_msg.poses.resize(path.size());\n  for (std::size_t i = 0; i < path.size(); ++i) {\n    path_msg.poses[i] = path[i];\n  }\n  pub.publish(path_msg);\n}\n", "CodeBleu_score": 69.03742456400236}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   if (path.empty()) {\n    return;\n  }\n\n  nav_msgs::Path path_msg;\n  path_msg.header.frame_id = path[0].header.frame_id;\n  path_msg.header.stamp = path[0].header.stamp;\n  path_msg.poses = path;\n  pub.publish(path_msg);\n}\n", "CodeBleu_score": 47.13909583534721}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   // If the path is empty, don't do anything\n  if (path.empty())\n    return;\n\n  // Create a Path message and copy the path into it\n  nav_msgs::Path msg;\n  msg.header.frame_id = path[0].header.frame_id;\n  msg.header.stamp = path[0].header.stamp;\n  msg.poses = path;\n\n  // Publish the path\n  pub.publish(msg);\n}\n", "CodeBleu_score": 46.88222750092782}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)    // Check if the robot is stopped\n    bool is_stopped = false;\n\n    // Check if the robot is rotating\n    if (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n        // Check if the robot is translating\n        if (abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n            // The robot is not rotating and it is not translating\n            is_stopped = true;\n        }\n    }\n\n    return is_stopped;\n}\n", "CodeBleu_score": 56.14564138499826}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)    // Check if the angular and linear velocities are below or equal to their respective thresholds\n    if (base_odom.twist.twist.angular.z <= rot_stopped_velocity && base_odom.twist.twist.linear.x <= trans_stopped_velocity) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "CodeBleu_score": 43.80799048622885}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\n    // Check if the robot is rotating\n    if (abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n        // Check if the robot is translating\n        if (abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity) {\n            return true;\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 57.25335837547376}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  if (setup_ && restore_defaults) {\n    ROS_INFO(\"[LocalPlannerUtil]: Resetting to default configuration.\");\n    config.max_vel_x = default_config_.max_vel_x;\n    config.min_vel_x = default_config_.min_vel_x;\n    config.max_vel_y = default_config_.max_vel_y;\n    config.min_vel_y = default_config_.min_vel_y;\n    config.max_vel_theta = default_config_.max_vel_theta;\n    config.min_vel_theta = default_config_.min_vel_theta;\n    config.acc_lim_x = default_config_.acc_lim_x;\n    config.acc_lim_y = default_config_.acc_lim_y;\n    config.acc_lim_theta = default_config_.acc_lim_theta;\n    config.min_turning_radius = default_config_.min_turning_radius;\n    config.yaw_rate_lim = default_config_.yaw_rate_lim;\n    config.w_max = default_config_.w_max;\n    config.w_min = default_config_.w_min;\n    config.v_x_lim = default_config_.v_x_lim;\n    config.v_y_lim = default_config_.v_y_lim;\n    config.v_theta_lim = default_config_.v_theta_lim;\n    config.global_plan_lookahead_dist = default_config_.global_plan_lookahead_dist;\n    config.d_ref_setpoint = default_config_.d_ref_setpoint;\n    config.d_ref_min = default_config_.d_ref_min;\n    config.d_ref_max = default_config_.d_ref_max;\n    config.delta_d_lim = default_config_.delta_d_lim;\n    config.delta_d_margin = default_config_.delta_d_margin;\n    config.local_plan_lookahead_dist = default_config_.local_plan_lookahead_dist;\n    config.local_", "CodeBleu_score": 28.771985056989337}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  if (setup_ && restore_defaults) {\n    ROS_INFO(\"[LocalPlanner] Resetting to default limits.\");\n    config = default_config_;\n  }\n  if (!setup_) {\n    default_config_ = config;\n    setup_ = true;\n  }\n  boost::mutex::scoped_lock l(configuration_mutex_);\n  current_config_ = config;\n}\n", "CodeBleu_score": 65.91827149472437}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  if (setup_ && restore_defaults) {\n    ROS_INFO(\"[LocalPlannerUtil]: Restoring default limits.\");\n    config.max_planning_velocity = default_limits_.max_planning_velocity;\n    config.min_planning_velocity = default_limits_.min_planning_velocity;\n    config.max_planning_velocity_yaw = default_limits_.max_planning_velocity_yaw;\n    config.min_planning_velocity_yaw = default_limits_.min_planning_velocity_yaw;\n    config.max_planning_acceleration = default_limits_.max_planning_acceleration;\n    config.min_planning_acceleration = default_limits_.min_planning_acceleration;\n    config.max_planning_acceleration_yaw = default_limits_.max_planning_acceleration_yaw;\n    config.min_planning_acceleration_yaw = default_limits_.min_planning_acceleration_yaw;\n    config.max_planning_jerk = default_limits_.max_planning_jerk;\n    config.min_planning_jerk = default_limits_.min_planning_jerk;\n    config.max_planning_jerk_yaw = default_limits_.max_planning_jerk_yaw;\n    config.min_planning_jerk_yaw = default_limits_.min_planning_jerk_yaw;\n    config.max_planning_duration = default_limits_.max_planning_duration;\n    config.min_planning_duration = default_limits_.min_planning_duration;\n    config.max_planning_distance = default_limits_.max_planning_distance;\n    config.min_planning_distance = default_limits_.min_planning_distance;\n    config.max_planning_lookahead_distance = default_limits_.max_planning_lookahead_distance;\n    config.min_planning_lookahead_distance = default_limits_.min_planning_", "CodeBleu_score": 28.82388951975158}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  // First, check if the cell is an obstacle or has no information\n  if (check_cell->is_obstacle || check_cell->distance == costmap.NO_INFORMATION) {\n    check_cell->target_distance = costmap.INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  // Calculate the new target distance\n  int new_distance = current_cell->target_distance + 1;\n\n  // Update the target distance if the new distance is shorter\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 46.517760950783725}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  // check if the cell is an obstacle\n  if(costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::LETHAL_OBSTACLE) {\n    // if it is, set the target distance to the maximum cost\n    check_cell->target_dist = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n  // if it is not, calculate the new target distance\n  double new_dist = current_cell->target_dist + hypot(current_cell->x - check_cell->x, current_cell->y - check_cell->y);\n  // check if the new distance is less than the current target distance\n  if(new_dist < check_cell->target_dist) {\n    // if it is, update the cell's target distance\n    check_cell->target_dist = new_dist;\n    return true;\n  }\n  // if it isn't, return false\n  return false;\n}\n", "CodeBleu_score": 55.67683932586051}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  // if the cell is an obstacle, return false\n  if (check_cell->is_obstacle) {\n    current_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n    return false;\n  }\n\n  // if the cell has no information, return false\n  if (check_cell->is_unknown) {\n    current_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n    return false;\n  }\n\n  // calculate the new target distance\n  double new_target_distance = current_cell->target_distance +\n                               calculateDistance(check_cell->x, check_cell->y,\n                                                 current_cell->x, current_cell->y);\n\n  // if the new target distance is shorter, update the cell's target distance\n  if (new_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_target_distance;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 50.12954864643031}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)    double cost = 0.0;\n    double scaling_factor = 1.0;\n    initializeCostMaps();\n    // if the footprint is empty, log an error and return -9\n    if (footprint_spec_.empty()) {\n        ROS_ERROR_STREAM(\"Footprint spec is empty\");\n        return -9;\n    }\n    // for each point in the trajectory, calculate the footprint cost\n    for (int i = 0; i < traj.getPointsSize(); i++) {\n        // calculate the footprint cost\n        double footprint_cost = calculateFootprintCost(traj.getPoint(i), traj.getVelocity(i));\n        // if the footprint cost is negative, return the cost immediately\n        if (footprint_cost < 0) {\n            return footprint_cost;\n        }\n        // otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag\n        if (sum_scores_) {\n            cost += footprint_cost;\n        } else {\n            cost = std::max(cost, footprint_cost);\n        }\n        // calculate the scaling factor\n        scaling_factor = std::max(scaling_factor, calculateScalingFactor(traj.getVelocity(i)));\n    }\n    // return the total cost\n    return cost * scaling_factor;\n}\n", "CodeBleu_score": 51.38720774539928}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0.0;\n  double scaling_factor = 0.0;\n  initializeCost(traj, cost, scaling_factor);\n  if (footprint_spec_.empty()) {\n    ROS_ERROR(\"Footprint spec is empty\");\n    return -9;\n  }\n  for (size_t i = 0; i < traj.getPointsSize(); ++i) {\n    double footprint_cost = scoreFootprint(traj.getPoint(i));\n    if (footprint_cost < 0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += scaling_factor * footprint_cost;\n    } else {\n      cost = std::max(cost, scaling_factor * footprint_cost);\n    }\n  }\n  return cost;\n}\n", "CodeBleu_score": 49.124735484029074}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double scaling_factor_penalty = 1.0;\n  double cost_penalty = 0.0;\n  double scaling_factor_penalty_speed = 1.0;\n  double cost_penalty_speed = 0.0;\n  double scaling_factor_penalty_accel = 1.0;\n  double cost_penalty_accel = 0.0;\n  double scaling_factor_penalty_jerk = 1.0;\n  double cost_penalty_jerk = 0.0;\n  double scaling_factor_penalty_snap = 1.0;\n  double cost_penalty_snap = 0.0;\n  double scaling_factor_penalty_yaw = 1.0;\n  double cost_penalty_yaw = 0.0;\n  double scaling_factor_penalty_obstacle = 1.0;\n  double cost_penalty_obstacle = 0.0;\n  double scaling_factor_penalty_total = 1.0;\n  double cost_penalty_total = 0.0;\n  double scaling_factor_penalty_total_speed = 1.0;\n  double cost_penalty_total_speed = 0.0;\n  double scaling_factor_penalty_total_accel = 1.0;\n  double cost_penalty_total_accel = 0.0;\n  double scaling_factor_penalty_total_jerk = 1.0;\n  double cost_penalty_total_jerk = 0.0;\n  double scaling_factor_penalty_total_snap = 1.0;\n  double cost_penalty_total_snap = 0.0;\n  double scaling_factor_penalty_total_yaw = 1.0;\n  double cost_penalty_total_yaw = 0.0;\n  double scaling_factor_penalty_total_obstacle = 1.0;\n  double cost_penalty_total_obstacle = 0.0", "CodeBleu_score": 8.418916122594664}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n  // Get the footprint of the robot in world coords\n  std::vector<geometry_msgs::Point> oriented_footprint;\n  if (!world_model->getOrientedFootprint(x, y, th, footprint_spec, oriented_footprint))\n    return -7.0;\n\n  // Scale the footprint\n  for (unsigned int i = 0; i < oriented_footprint.size(); ++i) {\n    oriented_footprint[i].x *= scale;\n    oriented_footprint[i].y *= scale;\n  }\n\n  // If the footprint is outside the bounds of the costmap, we need to return a cost of 100\n  if (!costmap->worldToMap(x, y, costmap_cell_.x, costmap_cell_.y))\n    return -7.0;\n\n  // Get the cost of the footprint\n  double footprint_cost = world_model->footprintCost(oriented_footprint, costmap);\n\n  // Get the cost of the cell that the robot is in\n  unsigned char cost = costmap->getCost(costmap_cell_.x, costmap_cell_.y);\n\n  // Return the maximum of the two costs\n  return std::max(footprint_cost, cost);\n}\n", "CodeBleu_score": 54.564358359380414}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n    double footprint_cost = 0.0;\n    double cost = 0.0;\n    double min_cost = 0.0;\n    double final_cost = 0.0;\n\n    // Scale the footprint points\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        footprint_spec[i].x *= scale;\n        footprint_spec[i].y *= scale;\n    }\n\n    // Rotate the footprint points\n    std::vector<geometry_msgs::Point> oriented_footprint;\n    for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n        geometry_msgs::Point pt;\n        pt.x = x + (footprint_spec[i].x * cos(th) - footprint_spec[i].y * sin(th));\n        pt.y = y + (footprint_spec[i].x * sin(th) + footprint_spec[i].y * cos(th));\n        oriented_footprint.push_back(pt);\n    }\n\n    // Calculate the footprint cost\n    if (world_model->footprintCost(oriented_footprint, costmap->getSizeInCellsX(), costmap->getSizeInCellsY(), costmap->getResolution(), costmap->getOriginX(), costmap->getOriginY(), footprint_cost)) {\n        // If the footprint cost is negative, return -6.0\n        if (footprint_cost < 0.0) {\n            return -6.0;\n        }\n\n        // Calculate the cell cost\n        if (costmap->getCost(x, y, cost)) {\n            // If the position is off the map, return -7.0\n            return -7.0;\n        }\n\n        // Return the maximum cost between the footprint cost and the cell cost\n        final_cost = std::max(footprint_cost, cost);\n    }\n\n    return final_cost;\n}\n", "CodeBleu_score": 60.143704140249184}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)  // check if the footprint is legal\n  if (!world_model->footprintCost(x, y, th, footprint_spec, costmap))\n    return -6.0;\n\n  // check if the footprint is outside the costmap bounds\n  if (!costmap->worldToMap(x, y, cell_x, cell_y))\n    return -7.0;\n\n  // get the cost of the footprint\n  double footprint_cost = 0.0;\n  for (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n    unsigned int point_x, point_y;\n    if (!costmap->worldToMap(x + footprint_spec[i].x * scale, y + footprint_spec[i].y * scale, point_x, point_y))\n      return -7.0;\n    footprint_cost = std::max(footprint_cost, costmap->getCost(point_x, point_y));\n  }\n\n  // get the cost of the center point of the footprint\n  unsigned char cost = costmap->getCost(cell_x, cell_y);\n\n  // return the cost\n  return std::max(cost, footprint_cost);\n}\n", "CodeBleu_score": 62.43109533177878}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}\n", "CodeBleu_score": 50.74625094985174}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n    else {\n      odom_sub_.shutdown();\n    }\n  }\n}\n", "CodeBleu_score": 49.24296029785495}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (!odom_topic_.empty()) {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}\n", "CodeBleu_score": 48.71856464192537}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)    // Calculate the squared distance between the current and previous positions\n    double squared_distance = (pos - prev).squaredNorm();\n\n    // Calculate the angular difference between the current and previous orientations\n    Eigen::Vector3f orientation_diff = pos - prev;\n    double angular_difference = atan2(orientation_diff[1], orientation_diff[0]);\n\n    // Reset the oscillation flags if the squared distance exceeds a threshold or the angular difference is greater than a set angle\n    if (squared_distance > 0.05 || angular_difference > 0.05) {\n        // Reset the oscillation flags\n        oscillation_flags_[0] = false;\n        oscillation_flags_[1] = false;\n    }\n}\n", "CodeBleu_score": 41.47663113183832}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\t// Calculate the squared distance\n\tEigen::Vector3f diff = pos - prev;\n\tfloat squaredDistance = diff.dot(diff);\n\n\t// Calculate the angular difference\n\tEigen::Vector3f posUnit = pos.normalized();\n\tEigen::Vector3f prevUnit = prev.normalized();\n\tfloat angularDifference = acos(posUnit.dot(prevUnit));\n\n\t// Reset the flags if the squared distance exceeds the threshold or the angular difference is greater than a set angle\n\tif(squaredDistance > squaredDistanceThreshold || angularDifference > angularDifferenceThreshold) {\n\t\t// Reset the flags\n\t\tresetOscillationFlags();\n\t}\n}", "CodeBleu_score": 39.55367183217188}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)  // Calculate the squared distance between the current and previous positions.\n  const float dist_sq = (pos - prev).squaredNorm();\n  // Calculate the angular difference between the current and previous yaw angles.\n  const float angle_diff = std::abs(std::atan2(pos[1], pos[0]) - std::atan2(prev[1], prev[0]));\n  // If the squared distance exceeds the threshold or the angular difference is greater than the set angle, reset the oscillation flags.\n  if (dist_sq > oscillation_dist_threshold_ || angle_diff > oscillation_angle_threshold_) {\n    oscillation_flags_ = OscillationFlags::NONE;\n  }\n}\n", "CodeBleu_score": 41.8100932633569}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)    // Check if point is within the grid bounds\n    if (pt.x < min_x_ || pt.x > max_x_ || pt.y < min_y_ || pt.y > max_y_ || pt.z < min_z_ || pt.z > max_z_) {\n        ROS_DEBUG_STREAM(\"Point out of bounds: \" << pt);\n        return;\n    }\n\n    // Calculate grid coordinates\n    float x = (pt.x - min_x_) / cell_size_;\n    float y = (pt.y - min_y_) / cell_size_;\n    float z = (pt.z - min_z_) / cell_size_;\n\n    // Check if the point is too close to its nearest neighbor\n    if (x - (int) x < min_distance_ || y - (int) y < min_distance_ || z - (int) z < min_distance_) {\n        ROS_DEBUG_STREAM(\"Point too close to its nearest neighbor: \" << pt);\n        return;\n    }\n\n    // Calculate grid index\n    int i = (int) x;\n    int j = (int) y;\n    int k = (int) z;\n\n    // Insert point into grid\n    grid_[i][j][k].push_back(pt);\n}\n", "CodeBleu_score": 34.659862929570494}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)  // calculate grid coordinates\n  int x = (int)floor((pt.x - origin_.x) / cell_size_);\n  int y = (int)floor((pt.y - origin_.y) / cell_size_);\n  int z = (int)floor((pt.z - origin_.z) / cell_size_);\n\n  // check if point is outside grid bounds\n  if (x < 0 || x >= x_cell_count_ || y < 0 || y >= y_cell_count_ || z < 0 || z >= z_cell_count_)\n    return;\n\n  // check if point is too close to its nearest neighbor\n  if (isNearNeighbor(pt, x, y, z))\n    return;\n\n  // calculate grid index\n  int index = x + (y * x_cell_count_) + (z * x_cell_count_ * y_cell_count_);\n\n  // insert point into grid\n  cells_[index].push_back(pt);\n}\n", "CodeBleu_score": 43.12368779758746}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)    /*\n     * @param pt The point to insert.\n     */\n    /*\n     * If the point is outside the grid bounds, return without inserting it.\n     */\n    if (pt.x < min_x_ || pt.y < min_y_ || pt.x > max_x_ || pt.y > max_y_) {\n        return;\n    }\n    /*\n     * Find the grid coordinates of the point.\n     */\n    int i = (int)floor((pt.x - min_x_) / cell_size_);\n    int j = (int)floor((pt.y - min_y_) / cell_size_);\n    /*\n     * If the point is too close to its nearest neighbor, return without inserting it.\n     */\n    if (i >= width_ - 1 || j >= height_ - 1) {\n        return;\n    }\n    /*\n     * Calculate the grid index.\n     */\n    int index = j * width_ + i;\n    /*\n     * Insert the point into the cell.\n     */\n    cells_[index].push_back(pt);\n}", "CodeBleu_score": 39.22989130872024}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        if (sample_target_vel(i) > vel(i)) {\n            new_vel(i) = std::min(sample_target_vel(i), vel(i) + acclimits(i) * dt);\n        } else {\n            new_vel(i) = std::max(sample_target_vel(i), vel(i) - acclimits(i) * dt);\n        }\n    }\n    return new_vel;\n}\n", "CodeBleu_score": 66.3070311584533}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\n    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n\n    for (int i = 0; i < 3; ++i) {\n        if (sample_target_vel(i) > vel(i)) {\n            new_vel(i) = std::min(vel(i) + acclimits(i) * dt, sample_target_vel(i));\n        } else if (sample_target_vel(i) < vel(i)) {\n            new_vel(i) = std::max(vel(i) - acclimits(i) * dt, sample_target_vel(i));\n        } else {\n            new_vel(i) = vel(i);\n        }\n    }\n\n    return new_vel;\n}\n", "CodeBleu_score": 62.15288117042478}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; ++i) {\n    if (sample_target_vel(i) > vel(i)) {\n      new_vel(i) = std::min(sample_target_vel(i), vel(i) + acclimits(i) * dt);\n    } else if (sample_target_vel(i) < vel(i)) {\n      new_vel(i) = std::max(sample_target_vel(i), vel(i) - acclimits(i) * dt);\n    } else {\n      new_vel(i) = vel(i);\n    }\n  }\n  return new_vel;\n}\n", "CodeBleu_score": 65.81374489432778}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)    // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n    int i = global_plan.size() - 1;\n    while (i >= 0) {\n        // Get the coordinates of the current cell in the global plan\n        double cell_x_goal = global_plan[i].x;\n        double cell_y_goal = global_plan[i].y;\n\n        // Convert the goal cell coordinates to world coordinates\n        double x_goal = cell_x_goal * cell_size_ + map_origin_x_;\n        double y_goal = cell_y_goal * cell_size_ + map_origin_y_;\n\n        // If the goal point is not in the same cell as the robot, it's a valid point\n        if (cell_x_goal != cell_x || cell_y_goal != cell_y) {\n            // Calculate the shortest angular distance between the current heading and the direction to the goal point\n            double heading_diff = fabs(atan2(y_goal - y, x_goal - x) - heading);\n\n            // If the angle is greater than pi, then it's shorter to go the other way\n            if (heading_diff > M_PI) {\n                heading_diff = 2 * M_PI - heading_diff;\n            }\n\n            // Return the heading difference\n            return heading_diff;\n        }\n\n        // If the goal point is in the same cell as the robot, move on to the next cell in the global plan\n        i--;\n    }\n\n    // If no valid point is found, return DBL_MAX\n    return DBL_MAX;\n}\n", "CodeBleu_score": 46.76798493616735}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\n  // find the closest point in the global plan that is visible from the current cell\n  int closest_index = -1;\n  double closest_distance = DBL_MAX;\n  for (int i = global_plan.size() - 1; i >= 0; i--) {\n    if (global_plan[i].x == cell_x && global_plan[i].y == cell_y) {\n      closest_index = i;\n      break;\n    }\n    double distance = hypot(global_plan[i].x - x, global_plan[i].y - y);\n    if (distance < closest_distance) {\n      closest_distance = distance;\n      closest_index = i;\n    }\n  }\n\n  // if no point is visible, return the maximum heading difference\n  if (closest_index == -1) {\n    return DBL_MAX;\n  }\n\n  // convert the goal point to world coordinates\n  double goal_x = global_plan[closest_index].x * resolution + origin_x;\n  double goal_y = global_plan[closest_index].y * resolution + origin_y;\n\n  // calculate the heading to the goal point\n  double goal_heading = atan2(goal_y - y, goal_x - x);\n\n  // return the absolute value of the shortest angular difference between the current heading and the goal heading\n  double heading_diff = fabs(shortestAngularDistance(heading, goal_heading));\n  return heading_diff;\n}\n", "CodeBleu_score": 47.393320625587805}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble heading_diff = DBL_MAX;\n\tdouble goal_x = 0;\n\tdouble goal_y = 0;\n\tint goal_cell_x = 0;\n\tint goal_cell_y = 0;\n\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n\tfor (int i = global_plan_.size() - 1; i >= 0; i--) {\n\t\t// Convert the global plan point to cell coordinates\n\t\tgoal_x = global_plan_[i].x;\n\t\tgoal_y = global_plan_[i].y;\n\t\tgoal_cell_x = (int)((goal_x - origin_x_) / resolution_);\n\t\tgoal_cell_y = (int)((goal_y - origin_y_) / resolution_);\n\n\t\t// Check if the goal cell is within the map bounds\n\t\tif (goal_cell_x >= 0 && goal_cell_x < width_ && goal_cell_y >= 0 && goal_cell_y < height_) {\n\t\t\t// Check if the goal cell is within the robot's FOV\n\t\t\tif (fov_check(cell_x, cell_y, goal_cell_x, goal_cell_y)) {\n\t\t\t\t// Calculate the heading to the goal cell\n\t\t\t\tdouble goal_heading = atan2(goal_y - y, goal_x - x);\n\n\t\t\t\t// Calculate the difference between the robot's current heading and the heading to the goal cell\n\t\t\t\theading_diff = fabs(angles::shortest_angular_distance(heading, goal_heading));\n\n\t\t\t\t// Break out of the loop\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn heading_diff;\n}\n", "CodeBleu_score": 55.164438943271385}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  if (cost < 0) {\n    ROS_WARN(\"Trajectory is invalid. Cost: %f\", cost);\n    ROS_WARN(\"x: %f, y: %f, theta: %f, vx: %f, vy: %f, vtheta: %f\", x, y, theta, vx, vy, vtheta);\n    ROS_WARN(\"vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 68.7792933623472}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0) {\n    return true;\n  }\n  ROS_WARN_STREAM(\"Trajectory rejected: \" << cost << \" \" << vx_samp << \" \" << vy_samp << \" \" << vtheta_samp);\n  return false;\n}\n", "CodeBleu_score": 76.06661111606502}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n    if (cost >= 0) {\n        return true;\n    } else {\n        ROS_WARN(\"Trajectory rejected with cost: %f, vx_samp: %f, vy_samp: %f, vtheta_samp: %f\", cost, vx_samp, vy_samp, vtheta_samp);\n        return false;\n    }\n}\n", "CodeBleu_score": 77.32086177845154}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmap pointer is NULL. Make sure you set it up in the planner's initializer\");\n    return;\n  }\n\n  if (invert_area_to_clear_)\n    ROS_WARN(\"Clearing inside the area of the specified footprint\");\n  else\n    ROS_WARN(\"Clearing outside the area of the specified footprint\");\n\n  ros::WallTime start = ros::WallTime::now();\n  if (affected_maps_ & static_map)\n    global_costmap_->clearMap();\n  if (affected_maps_ & dynamic_map)\n    local_costmap_->clearMap();\n  if (force_update_) {\n    if (affected_maps_ & static_map)\n      global_costmap_->updateMap();\n    if (affected_maps_ & dynamic_map)\n      local_costmap_->updateMap();\n  }\n  ros::WallTime end = ros::WallTime::now();\n  ROS_INFO(\"Clearing costmaps took %.3f ms\", (end - start).toSec() * 1000.0);\n}", "CodeBleu_score": 47.58344898269692}, {"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but is being used, please call initialize() before use\");\n    return;\n  }\n\n  if (costmap_ == NULL) {\n    ROS_ERROR(\"The costmap pointer is NULL. Make sure that the planner has been initialized and that the costmap is valid.\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global costmap pointer is NULL. Make sure that the planner has been initialized and that the global costmap is valid.\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"The invert_area_to_clear_ flag is set. This behavior will clear the costmap outside the specified area.\");\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n  if (affected_maps_ & costmap_2d::FREE_SPACE) {\n    if (invert_area_to_clear_) {\n      costmap_->clearNonRollingWindow(x_, y_, width_, height_);\n    } else {\n      costmap_->clearRollingWindow(x_, y_, width_, height_);\n    }\n  }\n\n  if (affected_maps_ & costmap_2d::INFLATED_OBSTACLES) {\n    if (invert_area_to_clear_) {\n      global_costmap_->clearNonRollingWindow(x_, y_, width_, height_);\n    } else {\n      global_costmap_->clearRollingWindow(x_, y_, width_, height_);\n    }\n  }\n\n  ros::WallTime end = ros::WallTime::now();\n  ros::WallDuration elapsed = end - start;\n  ROS_DEBUG(\"It took %f seconds to clear the costmap\", elapsed.toSec());\n}\n", "CodeBleu_score": 47.34745702662312}, {"code": "void ClearCostmapRecovery::runBehavior()  // Check if the object is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before use\");\n    return;\n  }\n\n  // Check that the costmaps are not NULL\n  if (!global_costmap_ || !local_costmap_) {\n    ROS_ERROR(\"The costmaps passed to the object cannot be NULL\");\n    return;\n  }\n\n  // Check if the area to clear is inside or outside the area to clear\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"The area to clear is inside the area to clear\");\n  } else {\n    ROS_WARN(\"The area to clear is outside the area to clear\");\n  }\n\n  // Clear the global and/or local costmaps\n  if (affected_maps_ == AFFECTED_MAPS_GLOBAL || affected_maps_ == AFFECTED_MAPS_BOTH) {\n    // Start the timer for the global costmap\n    ros::WallTime start = ros::WallTime::now();\n\n    // Clear the global costmap\n    global_costmap_->clearNonLethal(invert_area_to_clear_);\n\n    // Update the global costmap if requested\n    if (update_global_costmap_) {\n      global_costmap_->updateMap(0, 0, global_costmap_->getSizeInCellsX(), global_costmap_->getSizeInCellsY(), true);\n    }\n\n    // End the timer for the global costmap\n    ros::WallTime end = ros::WallTime::now();\n\n    // Log the time taken to clear the global costmap\n    ROS_INFO_STREAM(\"It took \" << (end - start).toSec() << \" seconds to clear the global costmap\");\n  }\n  if (affected_maps_ == AFFECTED_MAPS_LOCAL || affected_maps_ == AFFECTED_MAPS_BOTH) {\n    // Start the timer for the local costmap\n    ros::WallTime start = ros::WallTime::now();\n\n    // Clear the local costmap\n    local_cost", "CodeBleu_score": 48.30150571980699}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  polygon_cells.clear();\n  PolygonOutlineCells cells(polygon_cells);\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    unsigned int j = (i + 1) % polygon.size();\n    raytraceLine(polygon[i], polygon[j], cells);\n  }\n  if (!polygon.empty()) {\n    raytraceLine(polygon.back(), polygon.front(), cells);\n  }\n}\n", "CodeBleu_score": 52.96022959746913}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  PolygonOutlineCells polygon_cells_accumulator;\n  polygon_cells_accumulator.cells = &polygon_cells;\n\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    unsigned int j = (i + 1) % polygon.size();\n    raytraceLine(polygon[i], polygon[j], polygon_cells_accumulator);\n  }\n\n  if (polygon.size() > 2) {\n    raytraceLine(polygon.back(), polygon.front(), polygon_cells_accumulator);\n  }\n}\n", "CodeBleu_score": 53.373824421373904}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  PolygonOutlineCells polygon_cells_object(polygon_cells);\n  polygon_cells.clear();\n  if (polygon.size() <= 1)\n    return;\n  for (unsigned int i = 0; i < polygon.size() - 1; ++i) {\n    raytraceLine(polygon[i], polygon[i + 1], polygon_cells_object);\n  }\n  if (polygon.size() > 2) {\n    raytraceLine(polygon[polygon.size() - 1], polygon[0], polygon_cells_object);\n  }\n}\n", "CodeBleu_score": 57.622750764747245}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  //we'll call the base class to fill the costmap\n  Costmap2D::publishCostmap();\n\n  //we'll grab the current time to be used for the header's stamp field\n  ros::Time now = ros::Time::now();\n\n  //we'll populate the message with the static data that doesn't change\n  nav_msgs::OccupancyGridPtr msg(new nav_msgs::OccupancyGrid);\n  msg->header.frame_id = global_frame_;\n  msg->header.stamp = now;\n  msg->info.resolution = getResolution();\n  msg->info.width = getSizeInCellsX();\n  msg->info.height = getSizeInCellsY();\n  msg->info.origin.position.x = getOriginX();\n  msg->info.origin.position.y = getOriginY();\n  msg->info.origin.position.z = 0.0;\n  msg->info.origin.orientation.x = 0.0;\n  msg->info.origin.orientation.y = 0.0;\n  msg->info.origin.orientation.z = 0.0;\n  msg->info.origin.orientation.w = 1.0;\n\n  //we'll copy the data into the message\n  msg->data.resize(size_x_ * size_y_);\n  memcpy(&msg->data[0], costmap_, size_x_ * size_y_);\n\n  //we'll publish the message\n  pub.publish(msg);\n}\n", "CodeBleu_score": 46.8975443248873}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  //prepare the grid for publishing\n  prepareGrid();\n\n  //publish the grid\n  pub.publish(grid_);\n}\n", "CodeBleu_score": 68.24095687598614}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  //we need to make sure to clear the costmap and reset the timestamp\n  //to match the current time\n  Costmap2D* costmap = layered_costmap_->getCostmap();\n  costmap->clearMap();\n  costmap->getCostmap()->resetTimestamp();\n  prepareGrid(costmap);\n  pub.publish(grid_);\n}\n", "CodeBleu_score": 50.78007956409218}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.info.map_load_time = ros::Time::now();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  //we need to convert the map coordinates to world coordinates for the origin\n  double origin_x = costmap_->getOriginX(), origin_y = costmap_->getOriginY();\n  double origin_yaw = tf::getYaw(costmap_->getTransform());\n  grid_.info.origin.position.x = origin_x;\n  grid_.info.origin.position.y = origin_y;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.x = 0.0;\n  grid_.info.origin.orientation.y = 0.0;\n  grid_.info.origin.orientation.z = sin(origin_yaw * 0.5);\n  grid_.info.origin.orientation.w = cos(origin_yaw * 0.5);\n\n  //we'll save the origin coordinates for later use\n  origin_x_ = origin_x;\n  origin_y_ = origin_y;\n  origin_yaw_ = origin_yaw;\n\n  //we'll resize the grid data according to the size of the costmap\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  //we'll populate the grid data from the costmap's character map using a translation table\n  unsigned char* grid_data = &grid_.data[0];\n  unsigned int span = grid_.info.width;\n  for (unsigned int i = 0; i < costmap_->getSizeInCellsY(); ++i) {\n    unsigned int it = i * span;\n    for (unsigned int j = 0; j < costmap_->getSizeInCellsX(); ++j) {", "CodeBleu_score": 65.04497958889789}, {"code": "void Costmap2DPublisher::prepareGrid()  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  double resolution = costmap_->getResolution();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  geometry_msgs::Pose origin;\n  origin.position.x = costmap_->getOriginX();\n  origin.position.y = costmap_->getOriginY();\n  origin.position.z = 0.0;\n  origin.orientation.x = 0.0;\n  origin.orientation.y = 0.0;\n  origin.orientation.z = 0.0;\n  origin.orientation.w = 1.0;\n  grid_.info.origin = origin;\n\n  origin_x_ = origin.position.x;\n  origin_y_ = origin.position.y;\n\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n}\n", "CodeBleu_score": 47.85137177300387}, {"code": "void Costmap2DPublisher::prepareGrid()  //lock the costmap mutex\n  boost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n  //get the map resolution\n  double resolution = costmap_->getResolution();\n\n  //set the header information of the grid\n  nav_msgs::MapMetaData grid_info;\n  grid_info.map_load_time = ros::Time::now();\n  grid_info.resolution = resolution;\n  grid_info.width = costmap_->getSizeInCellsX();\n  grid_info.height = costmap_->getSizeInCellsY();\n  grid_info.origin.position.x = costmap_->getOriginX();\n  grid_info.origin.position.y = costmap_->getOriginY();\n  grid_info.origin.position.z = 0.0;\n  grid_info.origin.orientation.x = 0.0;\n  grid_info.origin.orientation.y = 0.0;\n  grid_info.origin.orientation.z = 0.0;\n  grid_info.origin.orientation.w = 1.0;\n\n  //save the origin coordinates\n  origin_x_ = grid_info.origin.position.x;\n  origin_y_ = grid_info.origin.position.y;\n\n  //resize the grid\n  grid_.data.resize(grid_info.width * grid_info.height);\n\n  //populate the costmap with data\n  unsigned char* grid_ptr = &grid_.data[0];\n  for (unsigned int i = 0; i < grid_info.height; ++i) {\n    for (unsigned int j = 0; j < grid_info.width; ++j) {\n      unsigned char cost = costmap_->getCost(j, i);\n      *grid_ptr = cost;\n      ++grid_ptr;\n    }\n  }\n}\n", "CodeBleu_score": 56.7955422280509}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    try {\n      points = parseFootprint(new_config.footprint);\n    } catch (std::runtime_error &ex) {\n      ROS_ERROR(\"The footprint specified in the costmap configuration is not a polygon. Exception: %s\", ex.what());\n      return;\n    }\n\n    if (points.size() < 3) {\n      ROS_ERROR(\"The footprint specified in the costmap configuration needs to be composed of at least 3 points\");\n      return;\n    }\n\n    footprint_ = points;\n  } else {\n    footprint_ = makeFootprint(new_config.robot_radius);\n  }\n}\n", "CodeBleu_score": 62.19505609990118}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  std::vector<geometry_msgs::Point> new_polygon;\n  try {\n    new_polygon = parseFootprint(new_config.footprint);\n  } catch (std::invalid_argument &e) {\n    ROS_ERROR_STREAM(\"Invalid footprint string: \" << new_config.footprint << \"\\n\" << e.what());\n  }\n\n  if (!new_polygon.empty()) {\n    footprint_ = new_polygon;\n    ROS_INFO_STREAM(\"Setting footprint to: \" << new_config.footprint);\n  } else {\n    std::vector<geometry_msgs::Point> default_polygon;\n    default_polygon.push_back(toPoint(new_config.robot_radius, new_config.robot_radius));\n    default_polygon.push_back(toPoint(new_config.robot_radius, -new_config.robot_radius));\n    default_polygon.push_back(toPoint(-new_config.robot_radius, -new_config.robot_radius));\n    default_polygon.push_back(toPoint(-new_config.robot_radius, new_config.robot_radius));\n    footprint_ = default_polygon;\n    ROS_INFO_STREAM(\"Setting footprint to default: \" << new_config.robot_radius);\n  }\n}\n", "CodeBleu_score": 54.834770421076165}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  // if the footprint and radius are the same, we can skip this\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius)\n    return;\n\n  // if we have a valid footprint, we'll use that\n  if (new_config.footprint != old_config.footprint && !new_config.footprint.empty()) {\n    if (!costmap_->setFootprint(new_config.footprint)) {\n      ROS_ERROR(\"The footprint specified in the costmap parameters [%s] is not a valid polygon\",\n                new_config.footprint.c_str());\n    }\n  } else {\n    // otherwise, we'll make a footprint based on the robot radius\n    std::vector<geometry_msgs::Point> footprint;\n    double radius = new_config.robot_radius;\n    unsigned int num_points = 10;\n    double angle = 0.0;\n    double delta = 2 * M_PI / num_points;\n    for (unsigned int i = 0; i < num_points; ++i) {\n      geometry_msgs::Point point;\n      point.x = radius * cos(angle);\n      point.y = radius * sin(angle);\n      footprint.push_back(point);\n      angle += delta;\n    }\n    costmap_->setFootprint(footprint);\n  }\n}\n", "CodeBleu_score": 56.4664724841287}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  geometry_msgs::PoseStamped pose;\n  if (!getRobotPose(pose)) {\n    ROS_WARN(\"Unable to get robot pose, canceling reconfiguration\");\n    reconfigure_thread_->cancel();\n    return;\n  }\n  new_pose_ = pose;\n}\n", "CodeBleu_score": 58.89730483509502}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  std::string global_frame = layered_costmap_->getGlobalFrameID();\n  std::string robot_base_frame = layered_costmap_->getBaseFrameID();\n\n  geometry_msgs::PoseStamped new_pose;\n  new_pose.header.frame_id = robot_base_frame;\n  new_pose.header.stamp = ros::Time::now();\n\n  try {\n    tf_.transformPose(global_frame, new_pose, new_pose);\n  } catch (tf::LookupException &ex) {\n    ROS_ERROR(\"No Transform available Error sending goal: %s\\n\", ex.what());\n    return;\n  } catch (tf::ConnectivityException &ex) {\n    ROS_ERROR(\"Connectivity Error sending goal: %s\\n\", ex.what());\n    return;\n  } catch (tf::ExtrapolationException &ex) {\n    ROS_ERROR(\"Extrapolation Error sending goal: %s\\n\", ex.what());\n    return;\n  }\n\n  std::vector<geometry_msgs::Point> footprint_spec;\n  costmap_2d::calculateMinAndMaxDistances(new_pose, *layered_costmap_->getFootprint(),\n                                          min_clearing_distance_, max_clearing_distance_,\n                                          &min_x_, &min_y_, &max_x_, &max_y_);\n\n  if (rolling_window_) {\n    if (new_pose.pose.position.x < old_pose_.pose.position.x) {\n      x_min_ = x_max_;\n      x_max_ = new_pose.pose.position.x;\n    } else {\n      x_max_ = x_min_;\n      x_min_ = new_pose.pose.position.x;\n    }\n\n    if (new_pose.pose.position.y < old_pose_.pose.position.y) {\n      y_min_ = y_max_;\n      y_max_ = new_pose.pose.position.y;\n    } else {\n      y_max_ = y_min_;", "CodeBleu_score": 38.133057900422976}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  if (frozen_map_)\n    return;\n\n  tf::Stamped<tf::Pose> new_pose;\n  try {\n    tf_->transformPose(global_frame_, *tf_pose_, new_pose);\n  } catch (tf::LookupException& ex) {\n    ROS_ERROR(\"No Transform available Error: %s\\n\", ex.what());\n    return;\n  } catch (tf::ConnectivityException& ex) {\n    ROS_ERROR(\"Connectivity Error: %s\\n\", ex.what());\n    return;\n  } catch (tf::ExtrapolationException& ex) {\n    ROS_ERROR(\"Extrapolation Error: %s\\n\", ex.what());\n    return;\n  }\n\n  geometry_msgs::PoseStamped pose;\n  tf::poseStampedTFToMsg(new_pose, pose);\n  robot_pose_ = pose;\n\n  //update the map with the new pose\n  updateMap(pose.pose.position.x, pose.pose.position.y, pose.pose.orientation.z);\n}\n", "CodeBleu_score": 39.73084682327166}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()  boost::mutex::scoped_lock lock(lock_);\n  // If the costmap is stopped, we need to re-subscribe to topics\n  if (stopped_) {\n    ROS_DEBUG(\"Re-subscribing to topics.\");\n    std::vector<boost::shared_ptr<Layer> >::iterator plugin_iter = plugins_.begin();\n    std::vector<boost::shared_ptr<Layer> >::iterator plugin_end = plugins_.end();\n    for (; plugin_iter != plugin_end; ++plugin_iter) {\n      if ((*plugin_iter)->is_enabled()) {\n        (*plugin_iter)->activate();\n      }\n    }\n    stopped_ = false;\n  }\n  stop_updates_ = false;\n  lock.unlock();\n\n  // Wait until we're ready to start\n  while (!is_running_ && ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n}\n", "CodeBleu_score": 61.17084819749849}, {"code": "void Costmap2DROS::start()  //re-subscribe to topics\n  for (unsigned int i = 0; i < plugins_.size(); ++i) {\n    if (plugins_[i]->isStopped()) {\n      plugins_[i]->activate();\n      plugins_[i]->setStopped(false);\n    }\n  }\n\n  stop_updates_ = false;\n  while (!is_running_ && ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  while (!is_initialized_ && ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  while (!map_update_thread_->isRunning() && ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n}\n", "CodeBleu_score": 46.596118680367105}, {"code": "void Costmap2DROS::start()  if (stopped_) {\n    ROS_DEBUG_NAMED(\"costmap\", \"Reactivating plugins\");\n    for (unsigned int i = 0; i < plugins_.size(); ++i) {\n      plugins_[i]->activate();\n    }\n    stopped_ = false;\n  }\n\n  stop_updates_ = false;\n\n  //wait for the costmap to be fully initialized\n  while (!costmap_initialized_ && ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n\n  //wait for the map update thread to start\n  while (!map_update_thread_ && ros::ok()) {\n    ros::Duration(0.01).sleep();\n  }\n}\n", "CodeBleu_score": 50.49153343900106}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()  if (observation_keep_time_ == ros::Duration(0)) {\n    // keep most recent observation\n    while (observations_.size() > 1) {\n      observations_.pop_front();\n    }\n    return;\n  }\n\n  // remove observations that are older than the specified keep time\n  std::list<Observation>::iterator it = observations_.begin();\n  std::list<Observation>::iterator next = it;\n  next++;\n  while (next != observations_.end()) {\n    if (it->time_stamp_ + observation_keep_time_ < next->time_stamp_) {\n      it = observations_.erase(it);\n    } else {\n      ++it;\n    }\n    ++next;\n  }\n}\n", "CodeBleu_score": 42.52197836056884}, {"code": "void ObservationBuffer::purgeStaleObservations()  if (observation_keep_time_ == ros::Duration(0)) {\n    if (observations_.size() > 1) {\n      observations_.erase(observations_.begin(), observations_.end() - 1);\n    }\n    return;\n  }\n  ros::Time latest_time = ros::Time::now() - observation_keep_time_;\n  for (ObservationList::iterator it = observations_.begin(); it != observations_.end(); it++) {\n    if (it->header.stamp > latest_time) {\n      break;\n    }\n  }\n  observations_.erase(observations_.begin(), it);\n}\n", "CodeBleu_score": 45.23479400481429}, {"code": "void ObservationBuffer::purgeStaleObservations()  if (observation_keep_time_ == ros::Duration(0.0)) {\n    // keep most recent observation\n    if (observations_.size() > 1) {\n      observations_.erase(observations_.begin(), observations_.end() - 1);\n    }\n  } else {\n    // remove observations that are older than the specified keep time\n    ros::Time keep_time = ros::Time::now() - observation_keep_time_;\n    for (ObservationList::iterator it = observations_.begin(); it != observations_.end(); it++) {\n      if (it->header.stamp > keep_time) {\n        break;\n      }\n    }\n    observations_.erase(observations_.begin(), it);\n  }\n}\n", "CodeBleu_score": 47.32046732294582}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)    // Get the yaw angles of the start and end poses\n    double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n    // Determine the shortest angular distance between the start and end yaw angles\n    double delta_yaw = end_yaw - start_yaw;\n    if (delta_yaw > M_PI) {\n        delta_yaw = delta_yaw - 2 * M_PI;\n    } else if (delta_yaw < -M_PI) {\n        delta_yaw = delta_yaw + 2 * M_PI;\n    }\n\n    // Compute the incremental change in angle for each pose\n    double delta_yaw_increment = delta_yaw / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i < end_index; i++) {\n        double yaw = start_yaw + (i - start_index) * delta_yaw_increment;\n        path[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n    }\n}\n", "CodeBleu_score": 53.872082728159235}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)  double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n  double yaw_diff = end_yaw - start_yaw;\n  yaw_diff = atan2(sin(yaw_diff), cos(yaw_diff));\n  double incremental_change = yaw_diff / (end_index - start_index);\n  for (int i = start_index; i < end_index; i++) {\n    double new_yaw = start_yaw + incremental_change * (i - start_index);\n    new_yaw = atan2(sin(new_yaw), cos(new_yaw));\n    path[i].pose.orientation = tf::createQuaternionMsgFromYaw(new_yaw);\n  }\n}\n", "CodeBleu_score": 55.84340463445552}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)  // Calculate the yaw angles at the start and end indices\n  double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n  // Determine the shortest angular distance between the start and end indices\n  double delta_yaw = end_yaw - start_yaw;\n  delta_yaw = atan2(sin(delta_yaw), cos(delta_yaw));\n  // Compute the incremental change in angle for each pose\n  double delta_theta = delta_yaw / (end_index - start_index);\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    double theta = delta_theta * (i - start_index);\n    double yaw = start_yaw + theta;\n    yaw = atan2(sin(yaw), cos(yaw));\n    path[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n  }\n}\n", "CodeBleu_score": 53.79556056745837}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)    ROS_INFO(\"makePlanService: start_x: %f, start_y: %f, start_a: %f, goal_x: %f, goal_y: %f, goal_a: %f\", req.start.x, req.start.y, req.start.theta, req.goal.x, req.goal.y, req.goal.theta);\n\n    tf::Stamped<tf::Pose> start, goal;\n    start.setIdentity();\n    goal.setIdentity();\n\n    start.frame_id_ = \"map\";\n    goal.frame_id_ = \"map\";\n\n    start.stamp_ = ros::Time();\n    goal.stamp_ = ros::Time();\n\n    start.setOrigin(tf::Vector3(req.start.x, req.start.y, 0.0));\n    start.setRotation(tf::createQuaternionFromYaw(req.start.theta));\n\n    goal.setOrigin(tf::Vector3(req.goal.x, req.goal.y, 0.0));\n    goal.setRotation(tf::createQuaternionFromYaw(req.goal.theta));\n\n    std::vector<geometry_msgs::PoseStamped> path;\n    bool success = makePlan(start, goal, path);\n    resp.plan_found = success;\n    resp.path = path;\n    ROS_INFO(\"makePlanService: success: %s\", success ? \"true\" : \"false\");\n    return true;\n}\n", "CodeBleu_score": 47.5980157037252}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)  ROS_INFO(\"Received a request to make a plan from (%f, %f) to (%f, %f)\", req.start.pose.position.x, req.start.pose.position.y, req.goal.pose.position.x, req.goal.pose.position.y);\n  geometry_msgs::PoseStamped start, goal;\n  start.header.frame_id = \"map\";\n  start.pose = req.start.pose;\n  goal.header.frame_id = \"map\";\n  goal.pose = req.goal.pose;\n  std::vector<geometry_msgs::PoseStamped> path;\n  bool success = makePlan(start, goal, path);\n  resp.plan_found = success;\n  resp.path = path;\n  return true;\n}\n", "CodeBleu_score": 56.647023882497535}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)  //set the frame id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  //make the plan\n  bool success = makePlan(req.start, req.goal, resp.plan.poses);\n\n  //update the response with the success status and the generated path if a plan is found\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.header.stamp = ros::Time::now();\n  resp.success = success;\n\n  return true;\n}\n", "CodeBleu_score": 63.34877279901475}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\",\n                                                 &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}\n", "CodeBleu_score": 57.551378737994796}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}\n", "CodeBleu_score": 58.23063668057915}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    ros::NodeHandle n;\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub_ = n.subscribe(\"move_base_simple/goal\", 1, &PlannerWithCostmap::goalCallback, this);\n    current_goal_ = NULL;\n    last_plan_ = NULL;\n    last_valid_plan_ = NULL;\n    plan_pub_ = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n    plan_cost_pub_ = private_nh.advertise<std_msgs::Float64>(\"plan_cost\", 1);\n    plan_valid_pub_ = private_nh.advertise<std_msgs::Bool>(\"plan_valid\", 1);\n    plan_valid_ = false;\n    last_valid_cost_ = 0.0;\n    last_valid_plan_cost_ = 0.0;\n}\n", "CodeBleu_score": 50.17549179736234}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)  double originX = costmap_->getOriginX(), originY = costmap_->getOriginY();\n  double resolution = costmap_->getResolution();\n\n  mx = (wx - originX) / resolution;\n  my = (wy - originY) / resolution;\n\n  unsigned int sizeX = costmap_->getSizeInCellsX(), sizeY = costmap_->getSizeInCellsY();\n\n  if(mx < sizeX && mx >= 0 && my < sizeY && my >= 0)\n    return true;\n\n  return false;\n}\n", "CodeBleu_score": 62.98898327313592}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)  // check if the world coordinate is within the costmap bounds\n  if(wx < world_model_->getOriginX() || wy < world_model_->getOriginY()){\n    ROS_ERROR(\"ERROR: cannot convert world coords to map coords because world coords are outside of costmap bounds\");\n    return false;\n  }\n\n  // convert world coordinates to map coordinates\n  mx = (wx - world_model_->getOriginX()) / costmap_->getResolution();\n  my = (wy - world_model_->getOriginY()) / costmap_->getResolution();\n\n  // check if map coordinates are within the costmap's size limits\n  if(mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()){\n    return true;\n  }\n  else{\n    return false;\n  }\n}\n", "CodeBleu_score": 50.208409894108485}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)  if(wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    ROS_WARN(\"Computing map coords for a point that is too far from the global frame (%f, %f).\", wx, wy);\n  }\n\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  if(mx < costmap_->getSizeInCellsX() && my < costmap_->getSizeInCellsY()) {\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 48.21667003439609}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path plan;\n  plan.poses.resize(path.size());\n  plan.header.stamp = ros::Time::now();\n  plan.header.frame_id = frame_id_;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    plan.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(plan);\n}\n", "CodeBleu_score": 84.1735613398002}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message for the plan\n  nav_msgs::Path plan;\n  plan.poses.resize(path.size());\n  plan.header.stamp = ros::Time::now();\n  plan.header.frame_id = frame_id_;\n\n  // copy the plan\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    plan.poses[i] = path[i];\n  }\n\n  // publish the plan\n  plan_pub_.publish(plan);\n}\n", "CodeBleu_score": 83.0433481717623}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message for the plan\n  nav_msgs::Path plan;\n  plan.poses.resize(path.size());\n  plan.header.stamp = ros::Time::now();\n  plan.header.frame_id = frame_id_;\n\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    plan.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(plan);\n}\n", "CodeBleu_score": 84.1735613398002}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)  ROS_DEBUG_NAMED(\"move_base\", \"Got a new goal: frame_id = %s, x = %.2f, y = %.2f, z = %.2f, qx = %.2f, qy = %.2f, qz = %.2f, qw = %.2f\",\n                  goal->header.frame_id.c_str(), goal->pose.position.x, goal->pose.position.y, goal->pose.position.z,\n                  goal->pose.orientation.x, goal->pose.orientation.y, goal->pose.orientation.z, goal->pose.orientation.w);\n\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n  action_goal.target_pose.header.stamp = ros::Time::now();\n  action_goal_pub_.publish(action_goal);\n}", "CodeBleu_score": 53.75977895050718}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)  ROS_DEBUG_NAMED(\"move_base\", \"Received new goal in the form of a PoseStamped message.\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 76.16959363845815}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)  ROS_DEBUG_NAMED(\"move_base\", \"Received goal in PoseStamped format\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 74.47554055134007}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  double limitedDistance = sqrt(pow(limitedX - initialX, 2) + pow(limitedY - initialY, 2));\n  double currentDistance = sqrt(pow(currentX - initialX, 2) + pow(currentY - initialY, 2));\n  if (limitedDistance < currentDistance) {\n    ROS_INFO(\"Moved far enough, removing speed limit.\");\n    if (removeLimitThread.joinable()) {\n      removeLimitThread.join();\n    }\n    removeLimitThread = thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    distanceCheckTimer.stop();\n  }\n}\n", "CodeBleu_score": 51.21130135654801}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  ROS_INFO(\"Checking distance\");\n  if (sqrt(pow(limitedDistance, 2)) >= sqrt(pow(currentDistance, 2))) {\n    ROS_INFO(\"Distance check passed\");\n    distanceCheckTimer.stop();\n    if (distanceCheckThread) {\n      distanceCheckThread->join();\n      delete distanceCheckThread;\n    }\n    distanceCheckThread = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n  }\n}\n", "CodeBleu_score": 54.65474208071709}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)    if (sqrt(pow(limitedDistance, 2)) >= sqrt(pow(currentDistance, 2))) {\n        ROS_INFO(\"Distance Check: Robot has moved far enough, clearing speed limit.\");\n        if (removeLimitThread.joinable()) {\n            removeLimitThread.join();\n        }\n        removeLimitThread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n        distanceCheckTimer.stop();\n    }\n}\n", "CodeBleu_score": 48.15207000415134}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  /*\n   * Get the current robot pose.\n   */\n  geometry_msgs::PoseStamped global_pose;\n  bool success = getRobotPose(global_pose);\n\n  /*\n   * If we have a valid robot pose, make a plan.\n   */\n  if (success) {\n    makePlan(global_pose, *goal, plan_);\n  }\n}\n", "CodeBleu_score": 55.96663881071071}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  // get the global pose of the robot\n  rm::PoseStamped global_pose;\n  if (!getRobotPose(global_pose)) {\n    ROS_ERROR(\"Failed to get robot pose, not making plan\");\n    return;\n  }\n\n  // make a plan from the current robot pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> path;\n  if (!makePlan(global_pose, *goal, path)) {\n    ROS_ERROR(\"Failed to make plan\");\n    return;\n  }\n\n  // publish the path for visualization purposes\n  path_pub_.publish(path);\n}\n", "CodeBleu_score": 52.20168052590828}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  /*\n   * Get the global pose of the robot.\n   */\n  try {\n    /*\n     * Get the global pose of the robot.\n     */\n    tf::Stamped<tf::Pose> global_pose;\n    tf_listener_.transformPose(costmap_ros_->getGlobalFrameID(), *goal, global_pose);\n    /*\n     * Get the x and y coordinates of the robot from the pose.\n     */\n    double robot_x = global_pose.getOrigin().x();\n    double robot_y = global_pose.getOrigin().y();\n    /*\n     * Get the orientation of the robot from the pose.\n     */\n    double robot_yaw = tf::getYaw(global_pose.getRotation());\n    /*\n     * Create a geometry_msgs::PoseStamped message to hold the robot's pose.\n     */\n    geometry_msgs::PoseStamped robot_pose;\n    /*\n     * Set the header of the robot_pose message to the frame of the costmap.\n     */\n    robot_pose.header.frame_id = costmap_ros_->getGlobalFrameID();\n    /*\n     * Set the x and y coordinates of the robot in the robot_pose message.\n     */\n    robot_pose.pose.position.x = robot_x;\n    robot_pose.pose.position.y = robot_y;\n    /*\n     * Set the orientation of the robot in the robot_pose message.\n     */\n    robot_pose.pose.orientation.w = cos(robot_yaw / 2.0);\n    robot_pose.pose.orientation.z = sin(robot_yaw / 2.0);\n    /*\n     * Create a geometry_msgs::PoseStamped message to hold the goal pose.\n     */\n    geometry_msgs::PoseStamped goal_pose;\n    /*\n     * Set the header of the goal_pose message to the frame of the costmap.\n     */\n    goal_pose.header.frame_id = costmap_ros_->getGlobalFrameID();\n    /*\n     * Set the x and y coordinates of the goal in the goal", "CodeBleu_score": 41.133305963829905}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)  // Create the request\n  ros::ServiceClient param_set_client = nh_.serviceClient<mavros_msgs::ParamSet>(\"mavros/param/set\");\n  mavros_msgs::ParamSet param_set_srv;\n  param_set_srv.request.param_id = param_set.param_id;\n  param_set_srv.request.value = param_set.value;\n\n  // Call the service\n  if (param_set_client.call(param_set_srv)) {\n    ROS_INFO(\"Parameter %s set to %f\", param_set_srv.request.param_id.c_str(), param_set_srv.request.value.real);\n  } else {\n    ROS_ERROR(\"Failed to call service mavros/param/set\");\n  }\n}\n", "CodeBleu_score": 42.630311156505705}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)  // Create service request\n  mav_services::ParamSet param_set_srv;\n\n  // Assign parameters to service request\n  param_set_srv.request.param_id = param_set.param_id;\n  param_set_srv.request.value = param_set.value;\n\n  // Call service\n  if (!param_set_client_.call(param_set_srv)) {\n    ROS_ERROR(\"Failed to call service param_set\");\n  }\n}\n", "CodeBleu_score": 53.62431371593587}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)  // create a request\n  ros::ServiceClient param_set_client_ = nh_.serviceClient<mavros_msgs::ParamSet>(\"mavros/param/set\");\n  mavros_msgs::ParamSet srv;\n  srv.request.param_id = param_set.param_id;\n  srv.request.value.real = param_set.value;\n  // send the request\n  if (param_set_client_.call(srv)) {\n    ROS_INFO(\"Parameter %s set to %f\", param_set.param_id.c_str(), param_set.value);\n  } else {\n    ROS_ERROR(\"Failed to call service mavros/param/set\");\n  }\n}\n", "CodeBleu_score": 59.928571106705974}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()    // Set up the socket\n    int sockfd, newsockfd, portno, clilen;\n    struct sockaddr_in serv_addr, cli_addr;\n\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        ROS_ERROR(\"ERROR opening socket\");\n        exit(1);\n    }\n    bzero((char *) &serv_addr, sizeof(serv_addr));\n    portno = atoi(port.c_str());\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = INADDR_ANY;\n    serv_addr.sin_port = htons(portno);\n    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n        ROS_ERROR(\"ERROR on binding\");\n        exit(1);\n    }\n    listen(sockfd, 5);\n    clilen = sizeof(cli_addr);\n    while (true) {\n        newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);\n        if (newsockfd < 0) {\n            ROS_ERROR(\"ERROR on accept\");\n            exit(1);\n        }\n        // Receive data\n        char buffer[256];\n        bzero(buffer, 256);\n        int n = read(newsockfd, buffer, 255);\n        if (n < 0) {\n            ROS_ERROR(\"ERROR reading from socket\");\n            exit(1);\n        }\n        // Decode data\n        if (n > 0) {\n            std::string msg(buffer);\n            std::vector<std::string> msg_parts = split(msg, ',');\n            if (msg_parts.size() > 0) {\n                if (msg_parts[0] == \"1\") {\n                    std::vector<std::string> msg_parts_2 = split(msg_parts[1], ':');\n                    if (msg_parts_2.size() > 0) {", "CodeBleu_score": 47.39634214072858}, {"code": "void CommunicationBridge::serverFun()  int socket_desc, client_sock, c, read_size;\n  struct sockaddr_in server, client;\n  char client_message[2000];\n\n  //Create socket\n  socket_desc = socket(AF_INET, SOCK_STREAM, 0);\n  if (socket_desc == -1) {\n    ROS_ERROR(\"Could not create socket\");\n    exit(1);\n  }\n  puts(\"Socket created\");\n\n  //Prepare the sockaddr_in structure\n  server.sin_family = AF_INET;\n  server.sin_addr.s_addr = INADDR_ANY;\n  server.sin_port = htons(port);\n\n  //Bind\n  if (bind(socket_desc, (struct sockaddr *) &server, sizeof(server)) < 0) {\n    ROS_ERROR(\"bind failed. Error\");\n    exit(1);\n  }\n  puts(\"bind done\");\n\n  //Listen\n  listen(socket_desc, 3);\n\n  //Accept and incoming connection\n  puts(\"Waiting for incoming connections...\");\n  c = sizeof(struct sockaddr_in);\n\n  //Accept and incoming connection\n  puts(\"Waiting for incoming connections...\");\n  c = sizeof(struct sockaddr_in);\n\n  while (1) {\n    client_sock = accept(socket_desc, (struct sockaddr *) &client, (socklen_t *) &c);\n    if (client_sock < 0) {\n      ROS_ERROR(\"accept failed\");\n      exit(1);\n    }\n    puts(\"Connection accepted\");\n\n    //Receive a message from client\n    while (1) {\n      if ((read_size = recv(client_sock, client_message, 2000, 0)) > 0) {\n        //Send the message back to client\n        if (read_size > 0) {\n          client_message[read_size] = '\\0';\n          ROS_INFO(\"Message received: %s\", client_message);\n          processMessage(client_message);\n        } else {\n          ROS_ERROR(\"Error reading message\");", "CodeBleu_score": 46.51100174782074}, {"code": "void CommunicationBridge::serverFun()    int newSocket, valread;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    char message[1024] = {0};\n\n    // Creating socket file descriptor\n    if ((serverFd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(serverFd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(port);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(serverFd, (struct sockaddr *) &address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(serverFd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    if ((newSocket = accept(serverFd, (struct sockaddr *) &address, (socklen_t *) &addrlen)) < 0) {\n        perror(\"accept\");\n        exit(EXIT_FAILURE);\n    }\n\n    while (true) {\n        valread = read(newSocket, buffer, 1024);\n        if (valread <= 0) {\n            perror(\"read\");\n            exit(EXIT_FAILURE);\n        }\n        if (valread <= 0) {\n            printf(\"\\nConnection Closed\\n\");\n            break;\n        }\n        buffer[valread] = '\\", "CodeBleu_score": 50.707728556615415}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)  if (!simulation_mode_) {\n    uav_basic_.publish(uav_cmd);\n  } else {\n    for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n      if (swarm_control_simulation_[i].id == uav_cmd.id) {\n        swarm_control_simulation_[i].publish(uav_cmd);\n        break;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 38.481974871375}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (simulation_mode_) {\n\t\t// Find the corresponding UAV and send the command\n\t\tfor (int i = 0; i < swarm_control_simulation_.uav_list.size(); i++) {\n\t\t\tif (swarm_control_simulation_.uav_list[i].id == uav_cmd.id) {\n\t\t\t\tswarm_control_simulation_.uav_list[i].uav_basic_.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Publish the command to the UAV\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 36.95065709382958}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)  // Check if simulation mode is active\n  if (simulation_mode_) {\n    // If simulation mode is active, find the UAV with the same ID as the received command\n    for (int i = 0; i < swarm_control_simulation_.uavs.size(); i++) {\n      // If the UAV ID matches, publish the command to the UAV\n      if (swarm_control_simulation_.uavs[i].id == uav_cmd.uav_id) {\n        swarm_control_simulation_.uavs[i].uav_basic_.publish(uav_cmd);\n        break;\n      }\n    }\n  } else {\n    // If simulation mode is not active, publish the command to the UAV\n    uav_basic_.publish(uav_cmd);\n  }\n}\n", "CodeBleu_score": 41.73598973059115}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)  if (mode_selection.use_mode) {\n    createMode(mode_selection);\n  } else {\n    deleteMode(mode_selection);\n  }\n}\n", "CodeBleu_score": 30.599649345240888}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == 1) {\n\t\tcreateMode(mode_selection.mode_name, mode_selection.mode_path);\n\t} else if (mode_selection.use_mode == 2) {\n\t\tdeleteMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == 3) {\n\t\texecuteSystemCommand(mode_selection.mode_path);\n\t} else if (mode_selection.use_mode == 4) {\n\t\texecuteSystemCommand(mode_selection.mode_path);\n\t\texit(0);\n\t} else if (mode_selection.use_mode == 5) {\n\t\texecuteSystemCommand(mode_selection.mode_path);\n\t\texit(0);\n\t} else if (mode_selection.use_mode == 6) {\n\t\texecuteSystemCommand(mode_selection.mode_path);\n\t\texit(0);\n\t}\n}\n", "CodeBleu_score": 47.14899119669447}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == 1) {\n\t\tcreateMode(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == 2) {\n\t\tdeleteMode(mode_selection);\n\t}\n\telse if (mode_selection.use_mode == 3) {\n\t\tsystem(\"REBOOTNX\");\n\t}\n\telse if (mode_selection.use_mode == 4) {\n\t\tsystem(\"EXITNX\");\n\t}\n}\n", "CodeBleu_score": 57.94662438063444}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)  // Check heartbeat status\n  if (heartbeat_counter == 0) {\n    ROS_INFO(\"Heartbeat received.\");\n  } else if (heartbeat_counter > 0) {\n    ROS_INFO(\"Heartbeat missed: %d\", heartbeat_counter);\n    if (heartbeat_counter >= max_heartbeat_misses) {\n      ROS_ERROR(\"Heartbeat missed: %d\", heartbeat_counter);\n      if (vehicle_type == \"swarm\") {\n        ROS_INFO(\"Swarm heartbeat missed. Disconnecting.\");\n        disconnect_flag = true;\n      } else if (vehicle_type == \"uav\") {\n        ROS_INFO(\"UAV heartbeat missed. Disconnecting.\");\n        disconnect_flag = true;\n      } else if (vehicle_type == \"ugv\") {\n        ROS_INFO(\"UGV heartbeat missed. Disconnecting.\");\n        disconnect_flag = true;\n      } else {\n        ROS_ERROR(\"Invalid vehicle type. Disconnecting.\");\n        disconnect_flag = true;\n      }\n    }\n  }\n  heartbeat_counter++;\n}\n", "CodeBleu_score": 39.0013578326565}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    if (this->heartbeat_counter < this->heartbeat_max_count) {\n        this->heartbeat_counter++;\n    }\n    else {\n        if (this->heartbeat_counter == this->heartbeat_max_count) {\n            if (this->vehicle_type == \"swarm\") {\n                ROS_ERROR(\"Lost connectivity with swarm.\");\n                this->disconnect_flag = true;\n            }\n            else if (this->vehicle_type == \"UAV\") {\n                ROS_ERROR(\"Lost connectivity with UAV.\");\n                this->disconnect_flag = true;\n            }\n            else if (this->vehicle_type == \"UGV\") {\n                ROS_ERROR(\"Lost connectivity with UGV.\");\n                this->disconnect_flag = true;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 25.332400648187246}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)  if (heartbeat_count == heartbeat_counter) {\n    if (heartbeat_counter < heartbeat_threshold) {\n      heartbeat_counter++;\n    } else {\n      ROS_ERROR(\"Heartbeat timeout. Disconnecting.\");\n      disconnect_flag = true;\n      heartbeat_counter = 0;\n    }\n  } else {\n    heartbeat_counter = 0;\n  }\n  heartbeat_count = 0;\n}\n", "CodeBleu_score": 18.86517129784063}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    // Get drone ID\n    int drone_id = msg->drone_id;\n\n    // Initialize Bspline struct\n    Bspline bspline;\n\n    // Set Bspline attributes\n    bspline.set_d(msg->d);\n    bspline.set_order(msg->order);\n    bspline.set_dim(msg->dim);\n    bspline.set_n_control_points(msg->n_control_points);\n    bspline.set_n_knots(msg->n_knots);\n    bspline.set_n_points(msg->n_points);\n    bspline.set_start_time(msg->start_time);\n    bspline.set_duration(msg->duration);\n    bspline.set_start_pos(msg->start_pos);\n    bspline.set_end_pos(msg->end_pos);\n\n    // Populate Bspline knots\n    for (int i = 0; i < msg->n_knots; i++) {\n        bspline.knots.push_back(msg->knots[i]);\n    }\n\n    // Populate Bspline position points\n    for (int i = 0; i < msg->n_points; i++) {\n        bspline.position_points.push_back(msg->position_points[i]);\n    }\n\n    // Populate Bspline yaw points\n    for (int i = 0; i < msg->n_points; i++) {\n        bspline.yaw_points.push_back(msg->yaw_points[i]);\n    }\n\n    // Encode Bspline data\n    std::string encoded_msg = bspline.encode();\n\n    // Send Bspline data via TCP\n    tcp_client.send(encoded_msg);\n}", "CodeBleu_score": 44.764352161845736}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    int id = msg->drone_id;\n    int num_traj = msg->num_traj;\n\n    // \u5c06\u63a5\u6536\u5230\u7684\u8f68\u8ff9\u8fdb\u884c\u7f16\u7801\n    // \u5c06\u7f16\u7801\u540e\u7684\u8f68\u8ff9\u53d1\u9001\u7ed9\u5bf9\u5e94\u7684\u65e0\u4eba\u673a\n    prometheus_msgs::MultiBsplines multi_bsplines_msg;\n    multi_bsplines_msg.drone_id = id;\n    multi_bsplines_msg.num_traj = num_traj;\n\n    for (int i = 0; i < num_traj; i++) {\n        prometheus_msgs::Bsplines bsplines;\n        bsplines.drone_id = id;\n        bsplines.traj_id = i;\n        bsplines.start_time = msg->traj[i].start_time;\n        bsplines.duration = msg->traj[i].duration;\n        bsplines.knot_num = msg->traj[i].knot_num;\n        bsplines.knot_vector = msg->traj[i].knot_vector;\n        bsplines.order = msg->traj[i].order;\n        bsplines.dimension = msg->traj[i].dimension;\n        bsplines.control_points = msg->traj[i].control_points;\n        bsplines.control_points_yaw = msg->traj[i].control_points_yaw;\n        bsplines.control_points_yaw_dot = msg->traj[i].control_points_yaw_dot;\n        bsplines.control_points_yaw_ddot = msg->traj[i].control_points_yaw_ddot;\n\n        // \u5c06\u8f68\u8ff9\u7f16\u7801\u4e3a\u4e8c\u8fdb\u5236\u683c\u5f0f\n        string encode_msg = bspline_encode(bsplines);\n        // \u5c06\u7f16\u7801\u540e\u7684\u8f68\u8ff9\u53d1\u9001\u7ed9\u5bf9\u5e94\u7684\u65e0\u4eba\u673a\n        tcp_client_ptr->send_msg(encode_msg);\n    }\n}\n", "CodeBleu_score": 48.75343565901644}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\n    // Extract drone ID\n    int drone_id = msg->drone_id;\n\n    // Initialize Bspline struct\n    Bspline bspline;\n\n    // Set Bspline attributes\n    bspline.drone_id = drone_id;\n    bspline.order = msg->order;\n    bspline.dim = msg->dim;\n    bspline.n_knots = msg->n_knots;\n    bspline.n_points = msg->n_points;\n\n    // Populate Bspline knots\n    for (int i = 0; i < bspline.n_knots; i++) {\n        bspline.knots.push_back(msg->knots[i]);\n    }\n\n    // Populate Bspline position points\n    for (int i = 0; i < bspline.n_points; i++) {\n        bspline.points.push_back(msg->points[i]);\n    }\n\n    // Populate Bspline yaw points\n    for (int i = 0; i < bspline.n_points; i++) {\n        bspline.yaws.push_back(msg->yaws[i]);\n    }\n\n    // Encode Bspline data\n    std::string bspline_encoded = bspline.encode();\n\n    // Send Bspline data via TCP\n    comm.tcp_send(bspline_encoded);\n}\n", "CodeBleu_score": 38.547366132730446}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    // Convert the PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create the octree\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZI> *octree = new pcl::octree::OctreePointCloudCompression<pcl::PointXYZI>(0.01);\n\n    // Compress the point cloud\n    octree->setInputCloud(cloud);\n    octree->addPointsFromInputCloud();\n\n    // Store the compressed data\n    std::vector<uint8_t> compressed_data;\n    octree->serializeTree(compressed_data);\n\n    // Create the output PointCloud2 message\n    sensor_msgs::PointCloud2 output;\n    output.header.stamp = msg.header.stamp;\n    output.header.frame_id = msg.header.frame_id;\n    output.height = 1;\n    output.width = compressed_data.size();\n    output.fields.resize(1);\n    output.fields[0].name = \"data\";\n    output.fields[0].offset = 0;\n    output.fields[0].datatype = sensor_msgs::PointField::UINT8;\n    output.fields[0].count = 1;\n    output.is_bigendian = false;\n    output.point_step = 1;\n    output.row_step = compressed_data.size();\n    output.is_dense = true;\n    output.data.resize(compressed_data.size());\n    memcpy(&output.data[0], &compressed_data[0], compressed_data.size());\n\n    // Release dynamically allocated memory\n    delete octree;\n\n    return output;\n}\n", "CodeBleu_score": 43.11783049400427}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n    sensor_msgs::PointCloud2 msg_filtered;\n    pcl::PCLPointCloud2 pcl_pc2;\n    pcl_conversions::toPCL(msg, pcl_pc2);\n    pcl::fromPCLPointCloud2(pcl_pc2, *cloud);\n\n    pcl::VoxelGrid<pcl::PointXYZ> sor;\n    sor.setInputCloud(cloud);\n    sor.setLeafSize(0.01f, 0.01f, 0.01f);\n    sor.filter(*cloud_filtered);\n\n    pcl::toPCLPointCloud2(*cloud_filtered, pcl_pc2);\n    pcl_conversions::fromPCL(pcl_pc2, msg_filtered);\n\n    return msg_filtered;\n}\n", "CodeBleu_score": 33.474053790230954}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    // Create a PointCloud object to store the input message.\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // Convert the input message to a pcl::PointCloud.\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Create a PointCloud object to store the compressed point cloud.\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n\n    // Compress the point cloud.\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.01);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n    octree.decompress(cloud_compressed);\n\n    // Create a PointCloud2 message to store the compressed point cloud.\n    sensor_msgs::PointCloud2 compressed_msg;\n\n    // Convert the compressed point cloud to a PointCloud2 message.\n    pcl::toROSMsg(*cloud_compressed, compressed_msg);\n\n    // Release dynamically allocated memory.\n    cloud.reset();\n    cloud_compressed.reset();\n\n    // Return the compressed point cloud.\n    return compressed_msg;\n}\n", "CodeBleu_score": 36.71825891381067}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)  for (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n      multi_uav_state_[i] = uav_state;\n    }\n  }\n}\n", "CodeBleu_score": 54.66880153663588}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)  int i;\n  for (i = 0; i < multi_uav_state_.uav_state_list_size(); i++) {\n    if (multi_uav_state_.uav_state_list(i).uav_id() == uav_state.uav_id()) {\n      multi_uav_state_.mutable_uav_state_list()->DeleteSubrange(i, 1);\n      multi_uav_state_.add_uav_state_list()->CopyFrom(uav_state);\n      break;\n    }\n  }\n}\n", "CodeBleu_score": 53.57347653715372}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)  for (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].id == uav_state.id) {\n      multi_uav_state_[i] = uav_state;\n      break;\n    }\n  }\n}\n", "CodeBleu_score": 58.12078729510155}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)  // Initialize MultiUGVState message\n  multi_ugv_state_msg.header.stamp = ros::Time::now();\n  multi_ugv_state_msg.header.frame_id = \"world\";\n  multi_ugv_state_msg.ugv_count = 0;\n\n  // Iterate through each UGV state\n  for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n    // Populate UGVState message\n    ugv_state_msg.header.stamp = ros::Time::now();\n    ugv_state_msg.header.frame_id = \"world\";\n    ugv_state_msg.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n    ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n    ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n    ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n    ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n    ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n    ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n    ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n    ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n    ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;", "CodeBleu_score": 43.31066202311825}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)  // Initialize MultiUGVState message\n  cav_msgs::MultiUGVState m_msg;\n\n  // Iterate through each UGV state\n  for (int i = 0; i < m_multi_ugv_state.ugv_state_count; i++) {\n    // Populate UGVState message\n    cav_msgs::UGVState ugv_state;\n    ugv_state.ugv_id = m_multi_ugv_state.ugv_state[i].ugv_id;\n    ugv_state.battery_voltage = m_multi_ugv_state.ugv_state[i].battery_voltage;\n    ugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n    ugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n    ugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n    ugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n    ugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n    ugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n    ugv_state.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n    ugv_state.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n    ugv_state.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n    ugv_state.attitude.w = m_multi_ugv_state.ugv_state[i].attitude.w;\n\n    // Add UGVState to MultiUGVState message", "CodeBleu_score": 40.21131267820388}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)  /*\n   * Initialize the MultiUGVState message.\n   */\n  ugv_msgs::MultiUGVState multi_ugv_state;\n\n  /*\n   * Iterate through each UGV state in the provided MultiUGVState structure.\n   */\n  for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n    /*\n     * Populate the UGVState message with ID, battery, position, velocity, and attitude data.\n     */\n    ugv_msgs::UGVState ugv_state;\n    ugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n    ugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n    ugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n    ugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n    ugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n    ugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n    ugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n    ugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n    ugv_state.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n    ugv_state.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n    ugv_state.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n    ugv_state.attitude.w = m", "CodeBleu_score": 40.487831471665245}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  for (int i = 0; i < q.cols(); i++) {\n    Eigen::Vector3d cp = q.block<3, 1>(0, i);\n    Eigen::Vector3d cp_gradient = Eigen::Vector3d::Zero();\n\n    for (int j = 0; j < moving_objects_.size(); j++) {\n      Eigen::Vector3d obj_pos = moving_objects_[j]->getPosition();\n      Eigen::Vector3d obj_gradient = Eigen::Vector3d::Zero();\n      double obj_radius = moving_objects_[j]->getRadius();\n\n      double dist = (cp - obj_pos).norm();\n      double dist_gradient = 0.0;\n\n      if (dist < obj_radius) {\n        double dist_cost = pow(dist - obj_radius, 2);\n        cost += dist_cost;\n\n        dist_gradient = 2 * (dist - obj_radius);\n        cp_gradient += dist_gradient * (cp - obj_pos).normalized();\n        obj_gradient = -dist_gradient * (cp - obj_pos).normalized();\n      }\n\n      moving_objects_[j]->setGradient(obj_gradient);\n    }\n\n    gradient.block<3, 1>(0, i) = cp_gradient;\n  }\n}\n", "CodeBleu_score": 46.560974932893295}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  cost = 0.0;\n  gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n  for (int i = 0; i < q.cols(); i++) {\n    Eigen::Vector3d p = q.block<3, 1>(0, i);\n    double yaw = q(3, i);\n    Eigen::Vector3d p_w;\n    p_w = calcOffsetPose(p, yaw, p_w);\n    double c_p, c_y;\n    Eigen::Vector3d g_p, g_y;\n    calcCostAndGradient(p_w, c_p, g_p, c_y, g_y);\n    cost += c_p;\n    gradient.block<3, 1>(0, i) += g_p;\n  }\n}\n", "CodeBleu_score": 29.14247697534843}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n    // Iterate through control points\n    for (int i = 0; i < q.rows(); ++i) {\n\n        // Get the predicted position of the moving objects\n        std::vector<Eigen::Vector3d> predicted_pos;\n        for (int j = 0; j < moving_objects_.size(); ++j) {\n            predicted_pos.push_back(moving_objects_[j]->getPredictedPos(q(i, 0)));\n        }\n\n        // Iterate through moving objects\n        for (int j = 0; j < moving_objects_.size(); ++j) {\n\n            // Calculate the distance between the control point and the object\n            double distance = (q.row(i).head(3) - predicted_pos[j]).norm();\n\n            // If the distance is less than the clearance, update the cost and gradient\n            if (distance < moving_objects_[j]->getClearance()) {\n                double cost_increment = moving_objects_[j]->getWeight() * exp(-distance / moving_objects_[j]->getClearance());\n                cost += cost_increment;\n                gradient.row(i) += 2 * moving_objects_[j]->getWeight() * exp(-distance / moving_objects_[j]->getClearance()) * (q.row(i).head(3) - predicted_pos[j]) / moving_objects_[j]->getClearance();\n            }\n        }\n    }\n}\n", "CodeBleu_score": 35.331925833721165}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n    // Initialize cost to zero\n    cost = 0;\n\n    // Initialize gradient to zero\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    // Iterate through the control points of the trajectory\n    for (int i = 0; i < q.cols(); i++) {\n\n        // Compute the positional error relative to reference points and a velocity vector\n        Eigen::Vector3d error, vel;\n        error = q.col(i) - ref_points.col(i);\n        vel = q.col(i + 1) - q.col(i);\n\n        // The cost function is based on the squared dot product and cross product of these vectors, normalized by constants a2 and b2\n        cost += a2 * error.dot(error) + b2 * vel.dot(vel);\n\n        // The gradient is updated for each control point using the computed derivatives\n        gradient.col(i) = 2 * a2 * error;\n        gradient.col(i + 1) = 2 * b2 * vel;\n    }\n}\n", "CodeBleu_score": 27.09619870829709}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  cost = 0.0;\n  gradient.setZero(m_nCoefficients, m_nControlPoints);\n\n  // Iterate through all the control points\n  for (int i = 0; i < m_nControlPoints; i++) {\n    // Compute the positional error\n    Eigen::Vector3d posError = q.col(i) - m_qRef.col(i);\n\n    // Compute the velocity vector\n    Eigen::Vector3d vel;\n    if (i == 0) {\n      vel = (q.col(i + 1) - q.col(i)) / m_dt;\n    } else if (i == m_nControlPoints - 1) {\n      vel = (q.col(i) - q.col(i - 1)) / m_dt;\n    } else {\n      vel = (q.col(i + 1) - q.col(i - 1)) / (2 * m_dt);\n    }\n\n    // Compute the fitness cost\n    cost += posError.dot(posError) / a2 + vel.dot(vel) / b2;\n\n    // Compute the gradient\n    Eigen::Vector3d posErrorGradient = 2 * posError / a2;\n    Eigen::Vector3d velGradient = 2 * vel / b2;\n\n    gradient.col(i) = posErrorGradient + velGradient;\n  }\n}\n", "CodeBleu_score": 35.229873467211064}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    cost = 0;\n    gradient.setZero(m_nControlPoints, 3);\n    Eigen::MatrixXd A = Eigen::MatrixXd::Zero(3, 3);\n    Eigen::Vector3d b = Eigen::Vector3d::Zero();\n    Eigen::Vector3d c = Eigen::Vector3d::Zero();\n    Eigen::Vector3d d = Eigen::Vector3d::Zero();\n    Eigen::Vector3d e = Eigen::Vector3d::Zero();\n    Eigen::Vector3d f = Eigen::Vector3d::Zero();\n    Eigen::Vector3d g = Eigen::Vector3d::Zero();\n    Eigen::Vector3d h = Eigen::Vector3d::Zero();\n    Eigen::Vector3d k = Eigen::Vector3d::Zero();\n    Eigen::Vector3d l = Eigen::Vector3d::Zero();\n    Eigen::Vector3d m = Eigen::Vector3d::Zero();\n    Eigen::Vector3d n = Eigen::Vector3d::Zero();\n    Eigen::Vector3d o = Eigen::Vector3d::Zero();\n    Eigen::Vector3d p = Eigen::Vector3d::Zero();\n    Eigen::Vector3d qq = Eigen::Vector3d::Zero();\n    Eigen::Vector3d r = Eigen::Vector3d::Zero();\n    Eigen::Vector3d s = Eigen::Vector3d::Zero();\n    Eigen::Vector3d t = Eigen::Vector3d::Zero();\n    Eigen::Vector3d u = Eigen::Vector3d::Zero();\n    Eigen::Vector3d v = Eigen::Vector3d::Zero();\n    Eigen::Vector3d w = Eigen::Vector3d::Zero();\n    Eigen::Vector3d x = Eigen::Vector3d::Zero();\n    Eigen::Vector3d y = Eigen::Vector3d::Zero();\n    Eigen::Vector3d z = Eigen::Vector3d::Zero();\n    Eigen::Vector3d aa = Eigen::Vector3d::Zero();\n    Eigen::Vector3d b", "CodeBleu_score": 14.176587607201796}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()    // Get the jerk trajectory\n    UniformBspline jerkTraj = getJerkTrajectory();\n\n    // Get the knot times of the jerk trajectory\n    std::vector<double> knotTimes = jerkTraj.getKnotTimes();\n\n    // Get the control points of the jerk trajectory\n    std::vector<std::vector<double>> controlPoints = jerkTraj.getControlPoints();\n\n    // Calculate the jerk value\n    double jerk = 0;\n    for (int i = 0; i < controlPoints.size(); i++) {\n        for (int j = 0; j < controlPoints[i].size(); j++) {\n            jerk += pow(controlPoints[i][j], 2) * (knotTimes[i + 1] - knotTimes[i]);\n        }\n    }\n\n    return jerk;\n}\n", "CodeBleu_score": 46.89585024114687}, {"code": "double UniformBspline::getJerk()\t// Calculate the third derivative of the spline\n\tUniformBspline jerk = this->getDerivative(3);\n\n\t// Get the knot times and control points of the jerk trajectory\n\tstd::vector<double> jerk_knots = jerk.getKnotTimes();\n\tstd::vector<std::vector<double>> jerk_control_points = jerk.getControlPoints();\n\n\t// Initialize the jerk value\n\tdouble jerk_value = 0;\n\n\t// Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tfor (int i = 0; i < jerk_control_points.size(); i++) {\n\t\tfor (int j = 0; j < jerk_control_points[i].size(); j++) {\n\t\t\tjerk_value += pow(jerk_control_points[i][j], 2) * (jerk_knots[i + 1] - jerk_knots[i]);\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn jerk_value;\n}", "CodeBleu_score": 43.139730064141055}, {"code": "double UniformBspline::getJerk()\t// Get the third derivative of the spline\n\tUniformBspline jerk_spline = getDerivative(3);\n\n\t// Get the knot times of the jerk spline\n\tstd::vector<double> jerk_knot_times = jerk_spline.getKnotTimes();\n\n\t// Get the control points of the jerk spline\n\tstd::vector<double> jerk_control_points = jerk_spline.getControlPoints();\n\n\t// Initialize the jerk value\n\tdouble jerk = 0.0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < jerk_control_points.size(); i++) {\n\t\t// Sum the squared control point values multiplied by the differences in knot times\n\t\tjerk += pow(jerk_control_points[i], 2) * (jerk_knot_times[i + 1] - jerk_knot_times[i]);\n\t}\n\n\t// Return the total jerk value\n\treturn jerk;\n}\n", "CodeBleu_score": 41.15219378288176}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)   Eigen::Vector4d pos;\n  pos(0) = (u - cx_) * depth / fx_;\n  pos(1) = (v - cy_) * depth / fy_;\n  pos(2) = depth;\n  pos(3) = 1.0;\n  return pos;\n}\n", "CodeBleu_score": 75.53417429134528}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tEigen::Vector4d pos;\n\tpos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1;\n\treturn pos;\n}\n", "CodeBleu_score": 47.26051706637474}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)     // Calculate the 3D position of the pixel in camera coordinates\n    double x = (u - cx_) * depth / fx_;\n    double y = (v - cy_) * depth / fy_;\n    double z = depth;\n    return Eigen::Vector4d(x, y, z, 1);\n}\n", "CodeBleu_score": 52.582225444353604}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)  try {\n    rcvDroneOdomCallbackBase(odom, odom.child_frame_id);\n  } catch (std::exception& e) {\n    ROS_ERROR(\"Error in DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n  }\n}\n", "CodeBleu_score": 38.18734281049662}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)  try {\n    std::string drone_id = odom.child_frame_id.substr(odom.child_frame_id.find_last_of('/') + 1);\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (std::exception& e) {\n    ROS_ERROR(\"Exception thrown while processing drone odometry: %s\", e.what());\n  }\n}\n", "CodeBleu_score": 49.723751681134345}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)    try {\n        rcvDroneOdomCallbackBase(odom, odom.child_frame_id);\n    } catch (const std::exception& e) {\n        ROS_ERROR_STREAM(e.what());\n    }\n}\n", "CodeBleu_score": 38.233083551862165}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\n  // Set the drone ID\n  this->drone_id = drone_id;\n\n  // Set the true pixel position\n  this->true_pixel = true_pixel;\n\n  // Set the drone pose in the world frame\n  this->drone_pose_world = this->drone_poses[this->drone_id];\n\n  // Compute the drone pose in the camera frame\n  this->drone_pose_camera = this->cam_pose_world.inverse() * this->drone_pose_world;\n\n  // Set the drone position in the camera frame\n  this->drone_position_camera = this->drone_pose_camera.translation();\n\n  // Set the drone orientation in the camera frame\n  this->drone_orientation_camera = this->drone_pose_camera.rotation();\n\n  // Set the drone position in the world frame\n  this->drone_position_world = this->drone_pose_world.translation();\n\n  // Set the drone orientation in the world frame\n  this->drone_orientation_world = this->drone_pose_world.rotation();\n\n  // Set the drone position in the camera frame\n  this->drone_position_camera = this->drone_pose_camera.translation();\n\n  // Set the drone orientation in the camera frame\n  this->drone_orientation_camera = this->drone_pose_camera.rotation();\n\n  // Set the drone position in the world frame\n  this->drone_position_world = this->drone_pose_world.translation();\n\n  // Set the drone orientation in the world frame\n  this->drone_orientation_world = this->drone_pose_world.rotation();\n\n  // Set the drone position in the camera frame\n  this->drone_position_camera = this->drone_pose_camera.translation();\n\n  // Set the drone orientation in the camera frame\n  this->drone_orientation_camera = this->drone_pose_camera.rotation();\n\n  // Set the drone position in the world frame\n  this->drone_position_world", "CodeBleu_score": 15.018406691627915}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)  // Compute the true pose of the drone in the camera frame\n  Eigen::Vector3d true_position_camera = Eigen::Vector3d(true_pixel(0), true_pixel(1), 0);\n  Eigen::Matrix3d true_rotation_camera = Eigen::Matrix3d::Identity();\n  Eigen::Vector3d true_position_world = true_rotation_camera * true_position_camera + true_position_camera;\n\n  // Check for the drone's presence\n  bool is_present = false;\n  for (int i = 0; i < drone_ids_.size(); i++) {\n    if (drone_ids_[i] == drone_id) {\n      is_present = true;\n      break;\n    }\n  }\n\n  // Compute the pose error\n  Eigen::Vector3d position_error = true_position_world - drone_positions_[drone_id];\n  Eigen::Matrix3d rotation_error = true_rotation_camera - drone_rotations_[drone_id];\n\n  // Update the debug result\n  if (is_present) {\n    drone_detector_debug_.drone_ids.push_back(drone_id);\n    drone_detector_debug_.drone_positions.push_back(true_position_world);\n    drone_detector_debug_.drone_rotations.push_back(true_rotation_camera);\n    drone_detector_debug_.position_errors.push_back(position_error);\n    drone_detector_debug_.rotation_errors.push_back(rotation_error);\n  } else {\n    drone_detector_debug_.drone_ids.push_back(drone_id);\n    drone_detector_debug_.drone_positions.push_back(Eigen::Vector3d(0, 0, 0));\n    drone_detector_debug_.drone_rotations.push_back(Eigen::Matrix3d::Identity());\n    drone_detector_debug_.position_errors.push_back(E", "CodeBleu_score": 40.61021906277944}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\n  // Set the drone ID\n  this->drone_id = drone_id;\n\n  // Set the true pixel position\n  this->true_pixel = true_pixel;\n\n  // Get the drone's pose in the world frame\n  Eigen::Vector3d drone_world_pos;\n  bool drone_found = this->getDronePose(drone_world_pos);\n\n  // If the drone is found\n  if (drone_found) {\n\n    // Get the drone's pose in the camera frame\n    Eigen::Vector3d drone_camera_pos;\n    this->getDronePoseCameraFrame(drone_world_pos, drone_camera_pos);\n\n    // Get the drone's pixel position in the camera frame\n    Eigen::Vector2i drone_pixel;\n    this->getDronePixel(drone_camera_pos, drone_pixel);\n\n    // Compute the error between the true pixel and the detected pixel\n    Eigen::Vector2i error = this->getError(drone_pixel, true_pixel);\n\n    // Update the debug result\n    this->updateDebugResult(true, error);\n\n    // Publish the error\n    this->publishError(error);\n\n  } else {\n\n    // Update the debug result\n    this->updateDebugResult(false, Eigen::Vector2i(0, 0));\n\n  }\n\n}\n", "CodeBleu_score": 32.067203573024294}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != NULL) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 88.89055639970091}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom != nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 84.13385546767653}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 90.00937038904927}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)  bool start_pt_inside_obstacle = false;\n  bool end_pt_inside_obstacle = false;\n\n  start_idx = ConvertToGridIndex(start_pt);\n  end_idx = ConvertToGridIndex(end_pt);\n\n  // Check if the start or end point is inside an obstacle.\n  if (IsOutsideMap(start_idx)) {\n    start_pt_inside_obstacle = true;\n  }\n  if (IsOutsideMap(end_idx)) {\n    end_pt_inside_obstacle = true;\n  }\n\n  // If either start or end point is inside an obstacle, iterate through the points between the start and end point and find the closest point that is not inside an obstacle.\n  if (start_pt_inside_obstacle || end_pt_inside_obstacle) {\n    Vector3d start_pt_adjusted = start_pt;\n    Vector3d end_pt_adjusted = end_pt;\n    Vector3i start_idx_adjusted = start_idx;\n    Vector3i end_idx_adjusted = end_idx;\n    Vector3d direction_vec = end_pt - start_pt;\n    double direction_vec_norm = direction_vec.norm();\n    double direction_vec_x = direction_vec(0) / direction_vec_norm;\n    double direction_vec_y = direction_vec(1) / direction_vec_norm;\n    double direction_vec_z = direction_vec(2) / direction_vec_norm;\n    double distance_traveled = 0;\n    double distance_traveled_threshold = 0.01;\n\n    while (distance_traveled < direction_vec_norm) {\n      if (start_pt_inside_obstacle) {\n        start_pt_adjusted = start_pt + distance_traveled * direction_vec;\n        start_idx_adjusted = ConvertToGridIndex(start_pt_adjusted);\n        if (IsOutsideMap(start_idx_adjusted)) {\n          distance_traveled += distance_traveled_th", "CodeBleu_score": 33.873961216837756}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)  // Convert the start and end points to grid indices.\n  if (!ConvertToIndex(start_pt, start_idx) || !ConvertToIndex(end_pt, end_idx)) {\n    return false;\n  }\n\n  // Check if the start or end point is inside an obstacle.\n  if (IsInsideObstacle(start_idx)) {\n    // Iteratively adjust the start point until it is no longer inside an obstacle.\n    while (IsInsideObstacle(start_idx)) {\n      // Move the start point away from the end point.\n      if (start_idx(0) > end_idx(0)) {\n        start_idx(0)--;\n      }\n      else if (start_idx(0) < end_idx(0)) {\n        start_idx(0)++;\n      }\n      else if (start_idx(1) > end_idx(1)) {\n        start_idx(1)--;\n      }\n      else if (start_idx(1) < end_idx(1)) {\n        start_idx(1)++;\n      }\n      else if (start_idx(2) > end_idx(2)) {\n        start_idx(2)--;\n      }\n      else if (start_idx(2) < end_idx(2)) {\n        start_idx(2)++;\n      }\n      else {\n        // The start and end points are at the same grid index.\n        return false;\n      }\n    }\n  }\n  else if (IsInsideObstacle(end_idx)) {\n    // Iteratively adjust the end point until it is no longer inside an obstacle.\n    while (IsInsideObstacle(end_idx)) {\n      // Move the end point away from the start point.\n      if (end_idx(0) > start_idx(0)) {\n        end_idx(0)--;\n      }\n      else if (end_idx(0) < start_idx(0)) {\n        end_idx(0)++;\n      }\n      else if (end_idx(1) > start_idx(1)) {\n        end_idx(1)--;\n      }\n      else if (", "CodeBleu_score": 35.21527453303509}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)    // Convert the start and end points to grid indices\n    if (!ConvertToIndex(start_pt, start_idx)) {\n        return false;\n    }\n    if (!ConvertToIndex(end_pt, end_idx)) {\n        return false;\n    }\n\n    // If the start point is inside an obstacle, move it away from the end point until it is no longer inside an obstacle\n    if (IsInsideObstacle(start_idx)) {\n        Vector3d temp_start_pt = ConvertFromIndex(start_idx);\n        Vector3d temp_end_pt = ConvertFromIndex(end_idx);\n        Vector3d dir_to_end_pt = temp_end_pt - temp_start_pt;\n        dir_to_end_pt.normalize();\n        Vector3d temp_start_pt_new = temp_start_pt + dir_to_end_pt * grid_size_;\n        while (IsInsideObstacle(temp_start_pt_new)) {\n            temp_start_pt_new += dir_to_end_pt * grid_size_;\n        }\n        if (!ConvertToIndex(temp_start_pt_new, start_idx)) {\n            return false;\n        }\n    }\n\n    // If the end point is inside an obstacle, move it away from the start point until it is no longer inside an obstacle\n    if (IsInsideObstacle(end_idx)) {\n        Vector3d temp_end_pt = ConvertFromIndex(end_idx);\n        Vector3d temp_start_pt = ConvertFromIndex(start_idx);\n        Vector3d dir_to_start_pt = temp_start_pt - temp_end_pt;\n        dir_to_start_pt.normalize();\n        Vector3d temp_end_pt_new = temp_end_pt + dir_to_start_pt * grid_size_;\n        while (IsInsideObstacle(temp_end_pt_new)) {\n            temp_end_pt_new += dir_to_start_pt * grid_size_;\n        }\n        if (!ConvertToIndex(temp_end_pt_new, end_idx)) {", "CodeBleu_score": 41.6399776804155}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  Index start_idx, end_idx;\n  if (!getIndex(min_pos, start_idx)) {\n    ROS_WARN(\"[GridMap::resetBuffer]: Minimum position is out of map bounds, doing nothing.\");\n    return;\n  }\n  if (!getIndex(max_pos, end_idx)) {\n    ROS_WARN(\"[GridMap::resetBuffer]: Maximum position is out of map bounds, doing nothing.\");\n    return;\n  }\n\n  // Iterate over the cells that should be reseted.\n  for (Eigen::Array3i::Index x = start_idx(0); x <= end_idx(0); ++x) {\n    for (Eigen::Array3i::Index y = start_idx(1); y <= end_idx(1); ++y) {\n      for (Eigen::Array3i::Index z = start_idx(2); z <= end_idx(2); ++z) {\n        Eigen::Array3i index(x, y, z);\n        // Set the corresponding element in the occupancy_buffer_inflate_ to zero.\n        occupancy_buffer_inflate_(x, y, z) = 0.0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 41.80107144397851}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  // Iterate over all grid cells within the specified bounds.\n  for (Eigen::Array3i i = min_pos.array().floor().max(Eigen::Array3i::Zero());\n      i <= max_pos.array().floor().min(bufferSize_ - Eigen::Array3i::Ones());\n      ++i) {\n    // Set the corresponding cell to zero.\n    occupancy_buffer_inflate_(i.x(), i.y(), i.z()) = 0;\n  }\n}", "CodeBleu_score": 27.332633631379494}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  // Iterate over all cells in the grid\n  for (Eigen::Array3i i = min_pos.array().floor().matrix().cast<int>();\n       i(2) <= max_pos(2); ++i(2)) {\n    for (i(1) = min_pos(1); i(1) <= max_pos(1); ++i(1)) {\n      for (i(0) = min_pos(0); i(0) <= max_pos(0); ++i(0)) {\n        Index index = getIndex(i);\n        occupancy_buffer_inflate_(index) = 0;\n        distance_buffer_inflate_(index) = 0;\n      }\n    }\n  }\n}", "CodeBleu_score": 38.499325965983736}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d max_translation = diff.cwiseQuotient(diff.cwiseAbs());\n    Eigen::Vector3d min_translation = -max_translation;\n\n    for (int i = 0; i < 3; i++) {\n        if (diff(i) < 0) {\n            if (max_translation(i) < 0) {\n                max_translation(i) = 0;\n            }\n        } else if (diff(i) > 0) {\n            if (min_translation(i) > 0) {\n                min_translation(i) = 0;\n            }\n        } else {\n            max_translation(i) = 0;\n            min_translation(i) = 0;\n        }\n    }\n\n    Eigen::Vector3d max_translated_pt = camera_pt + max_translation * diff.cwiseAbs();\n    Eigen::Vector3d min_translated_pt = camera_pt + min_translation * diff.cwiseAbs();\n\n    if (max_translated_pt.cwiseAbs().maxCoeff() > min_translated_pt.cwiseAbs().maxCoeff()) {\n        return max_translated_pt;\n    } else {\n        return min_translated_pt;\n    }\n}\n", "CodeBleu_score": 38.59484001770474}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)  Eigen::Vector3d diff = pt - camera_pt;\n  double max_x = std::max(diff[0], -diff[0]);\n  double max_y = std::max(diff[1], -diff[1]);\n  double max_z = std::max(diff[2], -diff[2]);\n\n  double min_x = std::min(diff[0], -diff[0]);\n  double min_y = std::min(diff[1], -diff[1]);\n  double min_z = std::min(diff[2], -diff[2]);\n\n  double x_scale = 1;\n  double y_scale = 1;\n  double z_scale = 1;\n\n  if (max_x > max_y && max_x > max_z) {\n    x_scale = (max_x / diff[0]) * (diff[0] > 0 ? 1 : -1);\n    if (max_y > max_z) {\n      y_scale = (max_y / diff[1]) * (diff[1] > 0 ? 1 : -1);\n      z_scale = (max_z / diff[2]) * (diff[2] > 0 ? 1 : -1);\n    } else {\n      z_scale = (max_z / diff[2]) * (diff[2] > 0 ? 1 : -1);\n      y_scale = (max_y / diff[1]) * (diff[1] > 0 ? 1 : -1);\n    }\n  } else if (max_y > max_z) {\n    y_scale = (max_y / diff[1]) * (diff[1] > 0 ? 1 : -1);\n    if (max_x > max_z) {\n      x_scale = (max_x / diff[0]) * (diff[0] > 0 ? 1 : -1);\n      z_scale = (max_z / diff[2]) * (diff[2] > 0 ? 1 : -1);\n    } else {\n      z_scale = (max_z / diff[2]) * (diff[2]", "CodeBleu_score": 35.76784881426467}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\n  // Difference vector between the point and the camera position\n  Eigen::Vector3d diff = pt - camera_pt;\n\n  // Maximum and minimum translation coefficients along each axis\n  double max_x = std::max(diff[0], 0.0);\n  double min_x = std::min(diff[0], 0.0);\n  double max_y = std::max(diff[1], 0.0);\n  double min_y = std::min(diff[1], 0.0);\n  double max_z = std::max(diff[2], 0.0);\n  double min_z = std::min(diff[2], 0.0);\n\n  // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n  double scale_x = 1.0;\n  double scale_y = 1.0;\n  double scale_z = 1.0;\n\n  if (max_x > 0.0) {\n    scale_x = std::min(max_x / diff[0], scale_x);\n  }\n  if (min_x < 0.0) {\n    scale_x = std::min(-min_x / diff[0], scale_x);\n  }\n  if (max_y > 0.0) {\n    scale_y = std::min(max_y / diff[1], scale_y);\n  }\n  if (min_y < 0.0) {\n    scale_y = std::min(-min_y / diff[1], scale_y);\n  }\n  if (max_z > 0.0) {\n    scale_z = std::min(max_z / diff[2], scale_z);\n  }\n  if (min_z < 0.0) {\n    scale_z = std::min(-min_z / diff[2], scale_z);\n  }\n\n  // Return the adjusted point near the boundary\n  return camera_pt + scale_x * diff;\n}\n", "CodeBleu_score": 39.53475022418866}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  if (m_paused) {\n    return;\n  }\n  // Update the last occupancy update time.\n  m_lastOccupancyUpdate = ros::Time::now();\n\n  // If an update is needed, project the depth image into points and process them with raycasting.\n  if (m_occupancyUpdate) {\n    // Update the occupancy map with the latest depth image.\n    updateOccupancy();\n\n    // Clear the local map.\n    clearLocalMap();\n\n    // Inflate the local map.\n    inflateLocalMap();\n\n    // Reset the flag.\n    m_occupancyUpdate = false;\n  }\n\n  // Handle timeout errors for odometry or depth data.\n  if (m_lastDepthImage.header.stamp.isZero() || m_lastOdometry.header.stamp.isZero()) {\n    ROS_WARN(\"Timed out waiting for odometry or depth image data.\");\n    m_hasOdometry = false;\n    m_hasDepthImage = false;\n  }\n}\n", "CodeBleu_score": 26.05868470066438}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  // Update last occupancy update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // Check if an update is needed\n  if (!update_occupancy_) {\n    return;\n  }\n\n  // Reset update flag\n  update_occupancy_ = false;\n\n  // Check if the map has been initialized\n  if (!initialized_) {\n    ROS_ERROR(\"Occupancy update requested before map was initialized.\");\n    return;\n  }\n\n  // Check if the map has been cleared\n  if (!map_cleared_) {\n    clearMap();\n  }\n\n  // Check if the map has been inflated\n  if (!map_inflated_) {\n    inflateMap();\n  }\n\n  // Check if the map has been updated\n  if (!map_updated_) {\n    updateMap();\n  }\n\n  // Check if the map has been published\n  if (!map_published_) {\n    publishMap();\n  }\n}\n", "CodeBleu_score": 23.078436840278194}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  if (occupancy_update_timer_.isValid()) {\n    occupancy_update_timer_.stop();\n  }\n  occupancy_update_timer_.start();\n\n  // Update the last occupancy update time.\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // If an update is needed, update the occupancy map.\n  if (update_occupancy_) {\n    updateOccupancy();\n  }\n\n  // If the local map has been updated, clear and inflate the local map.\n  if (update_local_map_) {\n    updateLocalMap();\n  }\n\n  // Handle timeout errors for odometry or depth data.\n  if ((ros::Time::now() - last_odom_update_time_).toSec() > timeout_secs_) {\n    ROS_WARN(\"Odometry data timeout. Stopping robot.\");\n    publishStop();\n    odom_timeout_ = true;\n  }\n  if ((ros::Time::now() - last_depth_update_time_).toSec() > timeout_secs_) {\n    ROS_WARN(\"Depth data timeout. Stopping robot.\");\n    publishStop();\n    depth_timeout_ = true;\n  }\n}\n", "CodeBleu_score": 40.56472798391852}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat sum = 0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\t// Load the image\n\t\tMat image = imread(image_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\t\tif (image.empty()) {\n\t\t\tcerr << \"Failed to load image \" << image_fns[i] << endl;\n\t\t\treturn -1;\n\t\t}\n\t\t// Load the ground truth ellipses\n\t\tvector<RotatedRect> gt_ellipses = _ellipse_load(gt_fns[i], gt_angle_radians);\n\t\t// Load the detected ellipses\n\t\tvector<RotatedRect> dt_ellipses = _ellipse_load(dt_fns[i], false);\n\t\t// Evaluate the detection performance\n\t\tfloat f = _ellipse_fmeasure(image, gt_ellipses, dt_ellipses);\n\t\t// Accumulate the F-measure\n\t\tsum += f;\n\t}\n\t// Return the average F-measure\n\treturn sum / image_fns.size();\n}", "CodeBleu_score": 57.2852417501054}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\n    // Create a variable to accumulate the F-measure\n    float F = 0.0;\n\n    // Iterate through the filenames\n    for (int i = 0; i < image_fns.size(); i++) {\n\n        // Load the image\n        Mat image = imread(image_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n\n        // Load the ground truth ellipses\n        vector<Ellipse> gt_ellipses = load_ellipses(gt_fns[i], gt_angle_radians);\n\n        // Load the detected ellipses\n        vector<Ellipse> dt_ellipses = load_ellipses(dt_fns[i], false);\n\n        // Evaluate the detection performance\n        float F_i = evaluate_detection(image, gt_ellipses, dt_ellipses);\n\n        // Accumulate the F-measure\n        F += F_i;\n\n    }\n\n    // Return the average F-measure\n    return F / image_fns.size();\n\n}\n", "CodeBleu_score": 62.213719879714255}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\tfloat avg_fmeasure = 0.0;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tstring image_fn = image_fns[i];\n\t\tstring gt_fn = gt_fns[i];\n\t\tstring dt_fn = dt_fns[i];\n\n\t\t// load the image\n\t\tMat image = imread(image_fn, CV_LOAD_IMAGE_COLOR);\n\n\t\t// load the ground truth ellipses\n\t\tvector<Ellipse> gt_ellipses = load_ellipses(gt_fn, gt_angle_radians);\n\n\t\t// load the detected ellipses\n\t\tvector<Ellipse> dt_ellipses = load_ellipses(dt_fn, false);\n\n\t\t// evaluate the detection performance\n\t\tfloat fmeasure = evaluate_detection(image, gt_ellipses, dt_ellipses);\n\n\t\t// accumulate the average F-measure\n\t\tavg_fmeasure += fmeasure;\n\t}\n\n\t// calculate the average F-measure\n\tavg_fmeasure /= image_fns.size();\n\n\treturn avg_fmeasure;\n}\n", "CodeBleu_score": 60.114270149272464}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float angle_to_focus_a, angle_to_focus_b, normal_angle;\n\n    if (foci == NULL) {\n        return 0;\n    }\n\n    angle_to_focus_a = atan2(foci[1] - y, foci[0] - x);\n    angle_to_focus_b = atan2(foci[3] - y, foci[2] - x);\n\n    normal_angle = angle_to_focus_a - angle_to_focus_b;\n    if (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    } else if (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    }\n\n    return normal_angle;\n}\n", "CodeBleu_score": 40.17629258032676}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float a = foci[0];\n    float b = foci[1];\n    float angle_a = atan2(y - b, x - a);\n    float angle_b = atan2(y - a, x - b);\n    float angle = angle_a - angle_b;\n    if (angle < -M_PI) {\n        angle += 2 * M_PI;\n    } else if (angle > M_PI) {\n        angle -= 2 * M_PI;\n    }\n    return angle;\n}\n", "CodeBleu_score": 37.505653596125974}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float angle = 0.0;\n\n    if (foci != NULL) {\n        float angle_to_focus_1 = atan2(foci[1] - y, foci[0] - x);\n        float angle_to_focus_2 = atan2(foci[3] - y, foci[2] - x);\n        angle = angle_to_focus_1 - angle_to_focus_2;\n    }\n\n    return fmod(angle + PI, TWO_PI) - PI;\n}\n", "CodeBleu_score": 33.58824417522695}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        if (vp1[i].x < min_x) min_x = vp1[i].x;\n        if (vp1[i].x > max_x) max_x = vp1[i].x;\n        if (vp1[i].y < min_y) min_y = vp1[i].y;\n        if (vp1[i].y > max_y) max_y = vp1[i].y;\n    }\n    double area_above = 0;\n    double area_below = 0;\n    for (double x = min_x; x <= max_x; x += 0.01) {\n        double y_above = 0;\n        double y_below = 0;\n        for (int i = start; i <= end; i++) {\n            if (vp1[i].x == x) {\n                y_above = vp1[i].y;\n                y_below = vp1[i].y;\n                break;\n            }\n            if (vp1[i].x < x && vp1[i + 1].x > x) {\n                y_above = vp1[i].y + (x - vp1[i].x) * (vp1[i + 1].y - vp1[i].y) / (vp1[i + 1].x - vp1[i].x);\n                y_below = vp1[i].y + (x - vp1[i].x) * (vp1[i + 1].y - vp1[i].y) / (vp1[i + 1].x - vp1[i].x);\n                break;\n            }\n        }\n        if (y_above > y_below) {", "CodeBleu_score": 37.64366538890669}, {"code": "bool inline concave_check(VP& vp1, int start, int end)    float xmin, xmax, ymin, ymax;\n    float area_above = 0, area_below = 0;\n    float x1, y1, x2, y2;\n    int i;\n    xmin = xmax = vp1[0].x;\n    ymin = ymax = vp1[0].y;\n    for (i = start; i <= end; i++) {\n        if (vp1[i].x < xmin) xmin = vp1[i].x;\n        if (vp1[i].x > xmax) xmax = vp1[i].x;\n        if (vp1[i].y < ymin) ymin = vp1[i].y;\n        if (vp1[i].y > ymax) ymax = vp1[i].y;\n    }\n    for (x1 = xmin; x1 <= xmax; x1++) {\n        for (i = start; i <= end; i++) {\n            if (vp1[i].x == x1) break;\n        }\n        if (i > end) continue;\n        x2 = vp1[(i + 1) % (end - start + 1) + start].x;\n        y1 = vp1[i].y;\n        y2 = vp1[(i + 1) % (end - start + 1) + start].y;\n        if (y1 < y2) {\n            area_above += (x2 - x1) * (y2 - y1);\n        } else {\n            area_below += (x2 - x1) * (y2 - y1);\n        }\n    }\n    if (area_above < area_below) {\n        return false;\n    } else {\n        return true;\n    }\n}\n", "CodeBleu_score": 43.898019429062316}, {"code": "bool inline concave_check(VP& vp1, int start, int end)    //Calculate the minimum and maximum x and y coordinates\n    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start + 1; i <= end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        }\n        else if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        }\n        else if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n    }\n    //Calculate the integral above and below the polygon section\n    double integral_above = 0.0;\n    double integral_below = 0.0;\n    for (double x = min_x; x <= max_x; x += 0.01) {\n        double y_above = max_y;\n        double y_below = min_y;\n        for (int i = start; i <= end; i++) {\n            if (vp1[i].x < x) {\n                double slope = (vp1[i].y - vp1[i + 1].y) / (vp1[i].x - vp1[i + 1].x);\n                double y_intercept = vp1[i].y - (slope * vp1[i].x);\n                double y = slope * x + y_intercept;\n                if (y > y_above) {\n                    y_above = y;\n                }\n                if (y < y_below) {\n                    y_below = y;\n                }\n            }\n        }\n        integral_above += y_above * 0.01;\n        integral_below += y", "CodeBleu_score": 41.00663641558189}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)    // ROS_INFO(\"ellipse_det_cb\");\n    for (int i = 0; i < msg->detected_infos.size(); i++) {\n        if (msg->detected_infos[i].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_regain = 0;\n            num_lost++;\n        }\n    }\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n    swap(ellipse_det.sight_angle, msg->detected_infos[0].sight_angle);\n}\n", "CodeBleu_score": 63.968680253015634}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)    // Iterate through each detection info\n    for (int i = 0; i < msg->detected_infos.size(); i++) {\n        // If an object named \"T\" is detected, increment num_regain\n        if (msg->detected_infos[i].detected_objects[0].name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n            is_detected = true;\n            // Otherwise, increment num_lost\n        } else {\n            num_regain = 0;\n            num_lost++;\n            is_detected = false;\n        }\n        // If num_lost exceeds VISION_THRES, set is_detected to false\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n        // If num_regain exceeds VISION_THRES, set is_detected to true\n        if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n        // Swap sight_angle values\n        ellipse_det.sight_angle[0] = msg->detected_infos[i].detected_objects[0].sight_angle[0];\n        ellipse_det.sight_angle[1] = msg->detected_infos[i].detected_objects[0].sight_angle[1];\n    }\n}\n", "CodeBleu_score": 67.6082381467125}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)  ellipse_det.is_detected = false;\n  ellipse_det.num_lost = 0;\n  ellipse_det.num_regain = 0;\n  for (int i = 0; i < msg->detected_info.size(); i++) {\n    if (msg->detected_info[i].detected_objects[0].name == \"T\") {\n      ellipse_det.num_regain++;\n      ellipse_det.num_lost = 0;\n      ellipse_det.is_detected = true;\n    } else {\n      ellipse_det.num_lost++;\n      ellipse_det.num_regain = 0;\n      ellipse_det.is_detected = false;\n    }\n  }\n  if (ellipse_det.num_lost > VISION_THRES) {\n    ellipse_det.is_detected = false;\n  }\n  if (ellipse_det.num_regain > VISION_THRES) {\n    ellipse_det.is_detected = true;\n  }\n  float temp = ellipse_det.sight_angle;\n  ellipse_det.sight_angle = ellipse_det.sight_angle_alt;\n  ellipse_det.sight_angle_alt = temp;\n}", "CodeBleu_score": 40.90885906792154}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  Eigen::Vector3d cur_pos_fcu = cur_pos;\n  Eigen::Vector3d cur_pos_enu = pos_fcu2enu(cur_pos_fcu);\n\n  /* ---------- check safety in the map ---------- */\n  Eigen::Vector3d pos_to_check_enu;\n  Eigen::Vector3d pos_to_check_fcu;\n\n  /* ---------- check safety in x direction ---------- */\n  pos_to_check_enu = cur_pos_enu;\n  pos_to_check_enu(0) = cur_pos_enu(0) + safe_distance;\n  pos_to_check_fcu = pos_enu2fcu(pos_to_check_enu);\n  if (occupy_map_ptr->check_safety(pos_to_check_fcu, safe_distance)) {\n    return false;\n  }\n\n  pos_to_check_enu = cur_pos_enu;\n  pos_to_check_enu(0) = cur_pos_enu(0) - safe_distance;\n  pos_to_check_fcu = pos_enu2fcu(pos_to_check_enu);\n  if (occupy_map_ptr->check_safety(pos_to_check_fcu, safe_distance)) {\n    return false;\n  }\n\n  /* ---------- check safety in y direction ---------- */\n  pos_to_check_enu = cur_pos_enu;\n  pos_to_check_enu(1) = cur_pos_enu(1) + safe_distance;\n  pos_to_check_fcu = pos_enu2fcu(pos_to_check_enu);\n  if (occupy_map_ptr->check_safety(pos_to_check_fcu, safe_distance)) {\n    return false;\n  }\n\n  pos_to_check_enu = cur_pos_enu;\n  pos_to_check_enu(1) = cur_pos_enu(1) - safe_distance;\n  pos_to_check_fcu = pos_enu2fcu(pos_", "CodeBleu_score": 39.7646832883997}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  // check if the current position is safe\n  if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n", "CodeBleu_score": 43.382953539697766}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  if (cur_pos[0] < min_x + safe_distance || cur_pos[0] > max_x - safe_distance || cur_pos[1] < min_y + safe_distance || cur_pos[1] > max_y - safe_distance || cur_pos[2] < min_z + safe_distance || cur_pos[2] > max_z - safe_distance)\n    return false;\n  else\n    return true;\n}\n", "CodeBleu_score": 26.72932875861135}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)\tNodePtr current_node = end_node;\n\twhile (current_node != nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->getParent();\n\t}\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 50.93966415022512}, {"code": "void Astar::retrievePath(NodePtr end_node)    NodePtr current_node = end_node;\n    path_nodes_.push_back(current_node);\n    while (current_node->parent != nullptr) {\n        current_node = current_node->parent;\n        path_nodes_.push_back(current_node);\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 67.0765492888134}, {"code": "void Astar::retrievePath(NodePtr end_node)    // Construct path by following parent pointers from end node to start node\n    NodePtr current_node = end_node;\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->getParent();\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 56.976518922070554}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     // ROS_INFO(\"Inside nei_odom_cb\");\n    if (id == 0) {\n        state_nei[0] = odom->pose.pose.position.x;\n        state_nei[1] = odom->pose.pose.position.y;\n        state_nei[2] = odom->pose.pose.position.z;\n    }\n    else if (id == 1) {\n        state_nei[3] = odom->pose.pose.position.x;\n        state_nei[4] = odom->pose.pose.position.y;\n        state_nei[5] = odom->pose.pose.position.z;\n    }\n    else if (id == 2) {\n        state_nei[6] = odom->pose.pose.position.x;\n        state_nei[7] = odom->pose.pose.position.y;\n        state_nei[8] = odom->pose.pose.position.z;\n    }\n    else if (id == 3) {\n        state_nei[9] = odom->pose.pose.position.x;\n        state_nei[10] = odom->pose.pose.position.y;\n        state_nei[11] = odom->pose.pose.position.z;\n    }\n    else if (id == 4) {\n        state_nei[12] = odom->pose.pose.position.x;\n        state_nei[13] = odom->pose.pose.position.y;\n        state_nei[14] = odom->pose.pose.position.z;\n    }\n    else if (id == 5) {\n        state_nei[15] = odom->pose.pose.position.x;\n        state_nei[16] = odom->pose.pose.position.y;\n        state_nei[17] = odom->pose.pose.position.z;\n    }\n    else if (id == 6) {\n        state_nei[18] = odom->pose.", "CodeBleu_score": 33.83996014018797}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)   //ROS_INFO(\"nei_odom_cb\");\n  if (id == 1) {\n    state_nei[0] = odom->pose.pose.position.x;\n    state_nei[1] = odom->pose.pose.position.y;\n    state_nei[2] = odom->pose.pose.position.z;\n  }\n  if (id == 2) {\n    state_nei[3] = odom->pose.pose.position.x;\n    state_nei[4] = odom->pose.pose.position.y;\n    state_nei[5] = odom->pose.pose.position.z;\n  }\n  if (id == 3) {\n    state_nei[6] = odom->pose.pose.position.x;\n    state_nei[7] = odom->pose.pose.position.y;\n    state_nei[8] = odom->pose.pose.position.z;\n  }\n  if (id == 4) {\n    state_nei[9] = odom->pose.pose.position.x;\n    state_nei[10] = odom->pose.pose.position.y;\n    state_nei[11] = odom->pose.pose.position.z;\n  }\n  if (id == 5) {\n    state_nei[12] = odom->pose.pose.position.x;\n    state_nei[13] = odom->pose.pose.position.y;\n    state_nei[14] = odom->pose.pose.position.z;\n  }\n  if (id == 6) {\n    state_nei[15] = odom->pose.pose.position.x;\n    state_nei[16] = odom->pose.pose.position.y;\n    state_nei[17] = odom->pose.pose.position.z;\n  }\n  if (id == 7) {\n    state_nei[18] = odom->pose.pose.position.x;", "CodeBleu_score": 32.737220746852564}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     ROS_INFO_STREAM(\"NEI ODOM CB\");\n    // ROS_INFO_STREAM(\"NEI ODOM CB\");\n    // if(id != 1) return;\n    // if(id == 1) {\n    //     ROS_INFO_STREAM(\"NEI ODOM CB\");\n    // }\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n    state_nei[id][3] = tf::getYaw(odom->pose.pose.orientation);\n    state_nei[id][4] = odom->twist.twist.linear.x;\n    state_nei[id][5] = odom->twist.twist.linear.y;\n    state_nei[id][6] = odom->twist.twist.linear.z;\n    state_nei[id][7] = odom->twist.twist.angular.x;\n    state_nei[id][8] = odom->twist.twist.angular.y;\n    state_nei[id][9] = odom->twist.twist.angular.z;\n    if(simulation_mode) {\n        double dist = sqrt(pow(state_nei[id][0] - state_start[0], 2) + pow(state_nei[id][1] - state_start[1], 2));\n        if(dist > 5) {\n            get_nei_state = false;\n        }\n        else {\n            get_nei_state = true;\n        }\n    }\n}\n", "CodeBleu_score": 48.62366877658404}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\n    // If odometry is not ready, return\n    if (!odom_ready) {\n        return;\n    }\n\n    // Set the sensor_ready flag to true\n    sensor_ready = true;\n\n    // Increment the update counter\n    update_counter++;\n\n    // Every fifth update, update the Astar map with the new point cloud data and reset the update counter\n    if (update_counter == 5) {\n        update_counter = 0;\n\n        // Update the Astar map with the new point cloud data\n        update_map(msg);\n    }\n}\n", "CodeBleu_score": 55.522421530435665}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\n  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  update_count++;\n  if (update_count < 5) {\n    return;\n  }\n  update_count = 0;\n\n  //  ROS_INFO(\"Gpointcloud_cb\");\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>(cloud));\n\n  //  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  //  pcl::fromROSMsg(*msg, *cloud_ptr);\n\n  //  ROS_INFO(\"Gpointcloud_cb: cloud_ptr->size() = %d\", cloud_ptr->size());\n\n  //  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  //  pcl::fromROSMsg(*msg, *cloud_ptr);\n\n  //  ROS_INFO(\"Gpointcloud_cb: cloud_ptr->size() = %d\", cloud_ptr->size());\n\n  //  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  //  pcl::fromROSMsg(*msg, *cloud_ptr);\n\n  //  ROS_INFO(\"Gpointcloud_cb: cloud_ptr->size() = %d\", cloud_ptr->size());\n\n  //  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  //  pcl::fromROSMsg(*msg, *cloud_ptr);\n\n  //  ROS_INFO(\"Gpointcloud_cb: cloud_ptr->size() = %d\", cloud_ptr->size());\n\n  //  pcl::PointCloud<pcl::", "CodeBleu_score": 54.607743724626715}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  if (update_count < 5) {\n    update_count++;\n    return;\n  }\n  update_count = 0;\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n  pcl::PointXYZ pt;\n  for (size_t i = 0; i < cloud.points.size(); i++) {\n    pt = cloud.points[i];\n    Astar.setObs(pt.x, pt.y, pt.z);\n  }\n  Astar.updateMap();\n}\n", "CodeBleu_score": 57.047787212747316}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)    if (!get_gpcl) {\n        get_gpcl = true;\n        sensor_msgs::PointCloud2 map_temp;\n        pcl::PointCloud<pcl::PointXYZ> latest_global_cloud;\n        pcl::fromROSMsg(*global_point, latest_global_cloud);\n        pcl::PointCloud<pcl::PointXYZ> global_cloud_temp;\n        pcl::fromROSMsg(map_gpcl, global_cloud_temp);\n        global_cloud_temp += latest_global_cloud;\n        pcl::toROSMsg(global_cloud_temp, map_temp);\n        map_temp.header.frame_id = \"map\";\n        map_gpcl = map_temp;\n        has_gpcl = true;\n        inflate_point_cloud(map_gpcl, map_inflated);\n    }\n}\n", "CodeBleu_score": 50.33769420811369}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\n  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::PointCloud<pcl::PointXYZ> latest_global_pcl_;\n    pcl::fromROSMsg(*global_point, latest_global_pcl_);\n    global_pcl_.clear();\n    global_pcl_ = latest_global_pcl_;\n    has_global_point = true;\n    inflate_point_cloud();\n  }\n}", "CodeBleu_score": 59.353338590045325}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\n    // if the global map has not been updated yet\n    if (!get_gpcl) {\n        // set the flag\n        get_gpcl = true;\n        // convert the sensor message to a point cloud\n        pcl::fromROSMsg(*global_point, *globalmap);\n        // store the point cloud\n        globalmap_p = globalmap;\n        // inflate the point cloud\n        pcl::PointCloud<pcl::PointXYZ>::Ptr globalmap_inf(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::VoxelGrid<pcl::PointXYZ> vg;\n        vg.setLeafSize(inflation_r, inflation_r, inflation_r);\n        vg.setInputCloud(globalmap);\n        vg.filter(*globalmap_inf);\n        globalmap = globalmap_inf;\n    }\n}\n", "CodeBleu_score": 53.992218217712896}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)    // 1. Convert laser scan to point cloud\n    sensor_msgs::PointCloud2 cloud;\n    projector_.projectLaser(*local_point, cloud);\n    pcl::PointCloud<pcl::PointXYZ> laser_cloud;\n    pcl::fromROSMsg(cloud, laser_cloud);\n\n    // 2. Update map using odometry\n    if (!simulation_mode_) {\n        // 2.1. Update local map\n        pcl::PointCloud<pcl::PointXYZ> laser_cloud_world;\n        pcl::PointXYZ point;\n        for (int i = 0; i < laser_cloud.points.size(); i++) {\n            point.x = laser_cloud.points[i].x + odom.pose.pose.position.x;\n            point.y = laser_cloud.points[i].y + odom.pose.pose.position.y;\n            point.z = laser_cloud.points[i].z + odom.pose.pose.position.z;\n            laser_cloud_world.points.push_back(point);\n        }\n        pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_world_ptr(new pcl::PointCloud<pcl::PointXYZ>(laser_cloud_world));\n        local_map_ += *laser_cloud_world_ptr;\n\n        // 2.2. Update global map\n        pcl::PointCloud<pcl::PointXYZ> laser_cloud_global;\n        pcl::PointXYZ point_global;\n        for (int i = 0; i < laser_cloud.points.size(); i++) {\n            point_global.x = laser_cloud.points[i].x + odom.pose.pose.position.x + map_size_x_/2;\n            point_global.y = laser_cloud.points[i].y + odom.pose.pose.position.y + map_size_y_/2;\n            point_global.z = laser_cloud.points[i].z + odom.pose.pose.position.z;", "CodeBleu_score": 46.684205445735515}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\n    // Update map using laser scan\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::PointXYZ pt;\n\n    // Set the origin of the laser scan to the odometry data\n    tf::Point pt_tf;\n    pt_tf.setX(odom.pose.pose.position.x);\n    pt_tf.setY(odom.pose.pose.position.y);\n    pt_tf.setZ(odom.pose.pose.position.z);\n\n    // Set the orientation of the laser scan to the odometry data\n    tf::Quaternion qt;\n    qt.setX(odom.pose.pose.orientation.x);\n    qt.setY(odom.pose.pose.orientation.y);\n    qt.setZ(odom.pose.pose.orientation.z);\n    qt.setW(odom.pose.pose.orientation.w);\n    tf::Matrix3x3 m(qt);\n    double roll, pitch, yaw;\n    m.getRPY(roll, pitch, yaw);\n\n    // Loop through the laser scan and add points to the point cloud\n    for (int i = 0; i < (int)local_point->ranges.size(); i++) {\n        if (local_point->ranges[i] < 10.0 && local_point->ranges[i] > 0.0) {\n            double theta = local_point->angle_min + (double)i * local_point->angle_increment;\n            pt.x = local_point->ranges[i] * cos(theta);\n            pt.y = local_point->ranges[i] * sin(theta);\n            pt.z = 0.0;\n            cloud.points.push_back(pt);\n        }\n    }\n\n    // Transform the point cloud from the laser scan to the odometry frame\n    pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl_ros::transformPointCloud(cloud, *transformed_cloud, od", "CodeBleu_score": 44.01788299848434}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\n    // This function, Occupy_map::map_update_laser, updates the occupancy map using laser scan data and odometry information.\\nIt projects the laser scan into a PointCloud2 format and converts it to a pcl::PointCloud.\\nIf not in simulation mode, it merges the local map with the provided odometry data.\n\n    // This function, Occupy_map::map_update_laser, updates the occupancy map using laser scan data and odometry information.\\nIt projects the laser scan into a PointCloud2 format and converts it to a pcl::PointCloud.\\nIf not in simulation mode, it merges the local map with the provided odometry data.\n\n    // This function, Occupy_map::map_update_laser, updates the occupancy map using laser scan data and odometry information.\\nIt projects the laser scan into a PointCloud2 format and converts it to a pcl::PointCloud.\\nIf not in simulation mode, it merges the local map with the provided odometry data.\n\n    // This function, Occupy_map::map_update_laser, updates the occupancy map using laser scan data and odometry information.\\nIt projects the laser scan into a PointCloud2 format and converts it to a pcl::PointCloud.\\nIf not in simulation mode, it merges the local map with the provided odometry data.\n\n    // This function, Occupy_map::map_update_laser, updates the occupancy map using laser scan data and odometry information.\\nIt projects the laser scan into a PointCloud2 format and converts it to a pcl::PointCloud.\\nIf not in simulation mode, it merges the local map with the provided odometry data.\n\n    // This function, Occupy_map::map_update_laser, updates the occupancy map using laser scan data and odometry information.\\nIt projects the laser scan into a PointCloud2 format and converts it to a pcl::PointCloud.\\nIf not in simulation mode, it merges the local map with the provided odometry data.\n\n    // This function, Occupy_map::map_update_laser, updates the occupancy map using laser scan data and odometry information.\\nIt projects the", "CodeBleu_score": 13.461492463296832}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)  sensor_msgs::PointCloud2 map_pcl, inflate_pcl;\n  pcl::toROSMsg(*global_pcl_, map_pcl);\n  pcl::toROSMsg(*inflate_pcl_, inflate_pcl);\n  map_pcl.header.frame_id = \"world\";\n  inflate_pcl.header.frame_id = \"world\";\n  global_pcl_pub_.publish(map_pcl);\n  inflate_pcl_pub_.publish(inflate_pcl);\n}\n", "CodeBleu_score": 53.43747383548649}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)  sensor_msgs::PointCloud2 pcl_msg;\n  sensor_msgs::PointCloud2 inflate_pcl_msg;\n  pcl::toROSMsg(*global_pcl_, pcl_msg);\n  pcl::toROSMsg(*inflate_pcl_, inflate_pcl_msg);\n  pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub_.publish(pcl_msg);\n  inflate_pcl_pub_.publish(inflate_pcl_msg);\n}", "CodeBleu_score": 56.319026825662256}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)  sensor_msgs::PointCloud2 global_pcl_msg, inflate_pcl_msg;\n  pcl::toROSMsg(*global_pcl_ptr, global_pcl_msg);\n  pcl::toROSMsg(*inflate_pcl_ptr, inflate_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n  inflate_pcl_msg.header.frame_id = \"world\";\n  global_pcl_pub.publish(global_pcl_msg);\n  inflate_pcl_pub.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 55.233296381716215}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (!odom_ready) {\n    ROS_WARN(\"Odometry not ready, not processing point cloud data\");\n    return;\n  }\n\n  sensor_ready = true;\n\n  // Convert the sensor_msgs/PointCloud2 data to pcl/PointCloud\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n\n  // Transform the point cloud into the odometry frame\n  pcl::PointCloud<pcl::PointXYZ> cloud_transformed;\n  pcl_ros::transformPointCloud(cloud, cloud_transformed, odom_to_map);\n\n  // Update the A* map\n  astar.setPointCloud(cloud_transformed);\n}\n", "CodeBleu_score": 56.964165569177794}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (!odom_ready) {\n    ROS_WARN(\"Odometry not ready yet\");\n    return;\n  }\n  sensor_ready = true;\n  ROS_INFO(\"Pointcloud received\");\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  pcl::fromROSMsg(*msg, cloud);\n  for (int i = 0; i < cloud.points.size(); i++) {\n    float x = cloud.points[i].x;\n    float y = cloud.points[i].y;\n    float z = cloud.points[i].z;\n    if (x < 0.1 && y < 0.1 && z < 0.1)\n      continue;\n    if (x > 20 || y > 20 || z > 20)\n      continue;\n    if (x < -20 || y < -20 || z < -20)\n      continue;\n    if (x > 100 || y > 100 || z > 100)\n      continue;\n    if (x < -100 || y < -100 || z < -100)\n      continue;\n    if (x > 200 || y > 200 || z > 200)\n      continue;\n    if (x < -200 || y < -200 || z < -200)\n      continue;\n    if (x > 300 || y > 300 || z > 300)\n      continue;\n    if (x < -300 || y < -300 || z < -300)\n      continue;\n    if (x > 400 || y > 400 || z > 400)\n      continue;\n    if (x < -400 || y < -400 || z < -400)\n      continue;\n    if (x > 500 || y > 500 || z > 500)\n      continue;\n    if (x < -500 || y < -500 || z < -500)\n      continue;", "CodeBleu_score": 55.472659231188736}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb\");\n    if (!odometry_ready) {\n        return;\n    }\n    sensor_ready = true;\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready\");\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->header.stamp.sec %d\", msg->header.stamp.sec);\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->header.stamp.nsec %d\", msg->header.stamp.nsec);\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->header.frame_id %s\", msg->header.frame_id.c_str());\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->height %d\", msg->height);\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->width %d\", msg->width);\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->fields %d\", msg->fields.size());\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->fields[0].name %s\", msg->fields[0].name.c_str());\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->fields[0].offset %d\", msg->fields[0].offset);\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->fields[0].datatype %d\", msg->fields[0].datatype);\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->fields[0].count %d\", msg->fields[0].count);\n    //ROS_INFO(\"GlobalPlanner::Lpointcloud_cb - sensor_ready - msg->fields[1].name %s\", msg->fields[1].name.c_str());\n    //ROS_INFO(\"GlobalPl", "CodeBleu_score": 39.71381480193054}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Update the state estimate\n  updateStateEstimate_();\n\n  // Get the current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get the current pose\n  Eigen::Matrix<double, 3, 1> current_position = state_estimate_.position;\n  Eigen::Matrix<double, 3, 1> current_velocity = state_estimate_.velocity;\n  Eigen::Matrix<double, 3, 3> current_rotation = state_estimate_.rotation;\n  Eigen::Matrix<double, 3, 1> current_angular_velocity = state_estimate_.angular_velocity;\n\n  // Get the current joint positions\n  Eigen::Matrix<double, 12, 1> current_joint_positions = state_estimate_.joint_positions;\n\n  // Get the current contact state\n  Eigen::Matrix<int, 4, 1> current_contact_state = state_estimate_.contact_state;\n\n  // Get the current desired pose\n  Eigen::Matrix<double, 3, 1> desired_position = desired_state_.position;\n  Eigen::Matrix<double, 3, 1> desired_velocity = desired_state_.velocity;\n  Eigen::Matrix<double, 3, 3> desired_rotation = desired_state_.rotation;\n  Eigen::Matrix<double, 3, 1> desired_angular_velocity = desired_state_.angular_velocity;\n\n  // Get the current desired joint positions\n  Eigen::Matrix<double, 12, 1> desired_joint_positions = desired_state_.joint_positions;\n\n  // Get the current desired contact state\n  Eigen::Matrix<int, 4, 1> desired_contact_state = desired_state_.contact_state;\n\n  // Get the current desired mode\n  int desired_mode = desired_state_.mode;\n\n  // Get the current desired gait\n  int desired_gait = desired_state_.gait;\n\n  // Get the current desired stance\n  int desired_stance = desired_state_.stance;", "CodeBleu_score": 33.32942370148214}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)    // Check if the robot is ready to walk\n    if (!isReadyToWalk()) {\n        // If not, return\n        return;\n    }\n\n    // Update the robot state\n    updateRobotState();\n\n    // Update the body controller\n    updateBodyController();\n\n    // Update the leg controllers\n    updateLegControllers();\n\n    // Update the robot state\n    updateRobotState();\n\n    // Publish the robot state\n    publishRobotState();\n}\n", "CodeBleu_score": 15.383481335047511}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Get the current time.\n  ros::Time current_time = ros::Time::now();\n\n  // Compute the time elapsed since the last iteration.\n  double dt = (current_time - previous_loop_time_).toSec();\n\n  // Get the current state of the robot.\n  quadruped_->getState(current_state_);\n\n  // Compute the desired state of the robot.\n  quadruped_->getCommand(current_state_, desired_state_);\n\n  // Get the current state of the robot.\n  quadruped_->getState(current_state_);\n\n  // Compute the desired state of the robot.\n  quadruped_->getCommand(current_state_, desired_state_);\n\n  // Compute the target foot positions for the desired state.\n  quadruped_->computeTargetFootPositions(desired_state_, target_foot_positions_);\n\n  // Compute the desired joint positions for the desired state.\n  quadruped_->computeDesiredJointPositions(desired_state_, target_joint_positions_);\n\n  // Compute the desired joint velocities for the desired state.\n  quadruped_->computeDesiredJointVelocities(desired_state_, target_joint_velocities_);\n\n  // Compute the desired joint torques for the desired state.\n  quadruped_->computeDesiredJointTorques(desired_state_, target_joint_torques_);\n\n  // Compute the desired joint accelerations for the desired state.\n  quadruped_->computeDesiredJointAccelerations(desired_state_, target_joint_accelerations_);\n\n  // Compute the desired joint positions for the desired state.\n  quadruped_->computeDesiredJointPositions(desired_state_, target_joint_positions_);\n\n  // Compute the desired joint velocities for the desired state.\n  quadruped_->computeDesiredJointVelocities(desired_state_, target_joint_velocities_);\n\n  // Compute the desired joint torques for the desired state.\n  quadruped_->compute", "CodeBleu_score": 42.95730684175282}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\n    // Create a ContactsStamped message\n    quad_msgs::ContactsStamped contacts_msg;\n\n    // Populate the message with the current gait phase of each leg\n    for (int i = 0; i < 4; i++) {\n        quad_msgs::Contact contact;\n        contact.contact = foot_contacts[i];\n        contacts_msg.contacts.push_back(contact);\n    }\n\n    // Publish the message\n    foot_contacts_publisher_.publish(contacts_msg);\n\n}", "CodeBleu_score": 45.644174144563024}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])  // Create a ContactsStamped message\n  quad_msgs::ContactsStamped contacts_msg;\n\n  // Populate the message with the current gait phase of each leg\n  contacts_msg.header.stamp = ros::Time::now();\n  contacts_msg.contacts.resize(4);\n  for (int i = 0; i < 4; ++i) {\n    contacts_msg.contacts[i].contact = foot_contacts[i];\n    contacts_msg.contacts[i].leg_index = i;\n  }\n\n  // Publish the message\n  foot_contacts_publisher_.publish(contacts_msg);\n}\n", "CodeBleu_score": 63.27987630004974}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])  if (foot_contact_publisher_ != NULL && !in_gazebo_) {\n    sensor_msgs::ContactsStamped contacts;\n    contacts.header.stamp = ros::Time::now();\n    contacts.header.frame_id = base_link_frame_id_;\n    for (int i = 0; i < 4; i++) {\n      contacts.states.push_back(foot_contacts[i]);\n    }\n    foot_contact_publisher_->publish(contacts);\n  }\n}\n", "CodeBleu_score": 50.63270481399734}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)\t// Create a minimal joints message\n\tstd_msgs__msg__Float64MultiArray joints_msg = new std_msgs__msg__Float64MultiArray();\n\tjoints_msg.setData(joints.getPosition());\n\t// Publish the joints message\n\tself.getNode().createPublisher(Float64MultiArray.class, \"joints\").publish(joints_msg);\n\t// Create a joint trajectory message\n\ttrajectory_msgs__msg__JointTrajectory trajectory_msg = new trajectory_msgs__msg__JointTrajectory();\n\ttrajectory_msg.setJointNames(joints.getNames());\n\ttrajectory_msgs__msg__JointTrajectoryPoint trajectory_point = new trajectory_msgs__msg__JointTrajectoryPoint();\n\ttrajectory_point.setPositions(joints.getPosition());\n\ttrajectory_point.setTimeFromStart(Duration.newDuration(1, 0));\n\ttrajectory_msg.setPoints(new trajectory_msgs__msg__JointTrajectoryPoint[]{trajectory_point});\n\t// Publish the trajectory message\n\tself.getNode().createPublisher(JointTrajectory.class, \"joint_trajectory\").publish(trajectory_msg);\n}", "CodeBleu_score": 34.28648716218896}, {"code": "def joints_cmd_callback(self, joints)    self.joints_msg.position = joints.position\n    self.joints_msg.header.stamp = self.get_clock().now().to_msg()\n    self.joints_pub.publish(self.joints_msg)\n\n    self.traj_msg.points.clear()\n    self.traj_msg.points.append(self.traj_point_msg)\n    self.traj_msg.joint_names = self.joints_msg.name\n    self.traj_msg.header.stamp = self.get_clock().now().to_msg()\n    self.traj_pub.publish(self.traj_msg)\n}\n", "CodeBleu_score": 28.266251280131595}, {"code": "def joints_cmd_callback(self, joints)  # Minimal joint message\n  self.joints_msg = JointState()\n  self.joints_msg.header = Header(stamp=rospy.Time.now())\n  self.joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n  self.joints_msg.position = joints.data\n  self.joints_pub.publish(self.joints_msg)\n\n  # Trajectory message\n  self.traj_msg = JointTrajectory()\n  self.traj_msg.header = Header(stamp=rospy.Time.now())\n  self.traj_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n  self.traj_msg.points = [JointTrajectoryPoint(positions=joints.data, time_from_start=Duration(self.traj_duration))]\n  self.traj_pub.publish(self.traj_msg)\n}\n", "CodeBleu_score": 36.987449284281084}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Initialize all foot contact states to false\n  for (int i = 0; i < 4; i++) {\n    foot_contact_states_[i] = false;\n  }\n\n  // For each contact in the message, split the collision string to identify the contact link\n  // If a contact matches one of the foot links, set the corresponding foot contact state to true\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    std::string link1 = _msg->contact(i).collision1().split('/').back();\n    std::string link2 = _msg->contact(i).collision2().split('/').back();\n    if (link1 == \"l_foot_link\" || link2 == \"l_foot_link\") {\n      foot_contact_states_[0] = true;\n    } else if (link1 == \"r_foot_link\" || link2 == \"r_foot_link\") {\n      foot_contact_states_[1] = true;\n    } else if (link1 == \"l_back_foot_link\" || link2 == \"l_back_foot_link\") {\n      foot_contact_states_[2] = true;\n    } else if (link1 == \"r_back_foot_link\" || link2 == \"r_back_foot_link\") {\n      foot_contact_states_[3] = true;\n    }\n  }\n}\n", "CodeBleu_score": 49.17826204678876}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Initialize foot contact states to false\n  left_contact = false;\n  right_contact = false;\n\n  // Check each contact\n  for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n    // Get collision names\n    std::string collision1 = _msg->contact(i).collision1().substr(0, _msg->contact(i).collision1().find(\"::\"));\n    std::string collision2 = _msg->contact(i).collision2().substr(0, _msg->contact(i).collision2().find(\"::\"));\n\n    // Check if any of the feet are in contact\n    if (collision1.find(left_foot_collision) != std::string::npos || collision2.find(left_foot_collision) != std::string::npos) {\n      left_contact = true;\n    }\n    if (collision1.find(right_foot_collision) != std::string::npos || collision2.find(right_foot_collision) != std::string::npos) {\n      right_contact = true;\n    }\n  }\n}\n", "CodeBleu_score": 36.723956840751526}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)  for (unsigned int i = 0; i < _msg->contact_size(); ++i) {\n    std::string link_name = _msg->contact(i).collision2(0).split('/')[1];\n    if (link_name == \"l_foot\") {\n      l_contact_ = true;\n    } else if (link_name == \"r_foot\") {\n      r_contact_ = true;\n    }\n  }\n}\n", "CodeBleu_score": 30.734550309444252}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(rotor_velocities->size() == kNumMotors);\n  assert(std::isfinite(command_.thrust) && command_.thrust >= 0.0);\n  assert(std::isfinite(command_.bodyrates(0)) && std::isfinite(command_.bodyrates(1)) && std::isfinite(command_.bodyrates(2)));\n  assert(std::isfinite(command_.collective_thrust));\n\n  if (!controller_.GetStatus().enabled) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  double rotor_velocity_squared = 0.0;\n  double rotor_acceleration = 0.0;\n  double rotor_acceleration_squared = 0.0;\n\n  double body_z_acceleration = 0.0;\n  double body_x_acceleration = 0.0;\n  double body_y_acceleration = 0.0;\n\n  double body_z_thrust = 0.0;\n  double body_x_thrust = 0.0;\n  double body_y_thrust = 0.0;\n\n  double body_z_angular_acceleration = 0.0;\n  double body_x_angular_acceleration = 0.0;\n  double body_y_angular_acceleration = 0.0;\n\n  double rotor_thrust = 0.0;\n  double rotor_angular_acceleration = 0.0;\n\n  double body_z_acceleration_squared = 0.0;\n  double body_x_acceleration_squared = 0.0;\n  double body_y_acceleration_squared = 0.0;\n\n  double body_z_thrust_squared = 0.0;\n  double body_x_thrust_squared = 0.0;\n  double body_y_thrust_squared = 0.0;", "CodeBleu_score": 28.63214896338071}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(rotor_velocities->size() == kRotorQuantity);\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(kRotorQuantity);\n    return;\n  }\n\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n  CalculateDesiredAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n  Eigen::Vector3d thrust_vector =\n      desired_acceleration + Eigen::Vector3d(0.0, 0.0, 9.81) +\n      Eigen::Vector3d(0.0, 0.0, kGravityZ * mass_);\n\n  Eigen::Vector3d moment_vector =\n      desired_angular_acceleration +\n      Eigen::Vector3d(0.0, 0.0, kGravityZ * moment_arm_ * mass_);\n\n  Eigen::Vector3d rotor_forces = thrust_vector + moment_vector;\n\n  Eigen::VectorXd rotor_forces_matrix(kRotorQuantity);\n  for (int i = 0; i < kRotorQuantity; i++) {\n    rotor_forces_matrix(i) = rotor_forces(i);\n  }\n\n  *rotor_velocities = rotor_forces_matrix.cwiseQuotient(rotor_forces_matrix.norm() * rotor_forces_matrix.norm() *\n                                                        rotor_forces_matrix.norm() * rotor_thrust_coefficients_);\n\n  for (int i = 0; i < kRotorQuantity; i++) {\n    if (rotor_velocities->coeff(i) < 0.0) {\n      rotor_velocities->coeffRef(i) = 0.0;\n    }\n  }\n\n  *rotor_velocities = rotor", "CodeBleu_score": 46.89942352694819}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(rotor_velocities->size() == kRotorQuantity);\n  assert(std::isfinite(acc_desired_norm_));\n  assert(std::isfinite(ang_acc_desired_norm_));\n  assert(std::isfinite(thrust_cmd_));\n\n  if (!controller_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(kRotorQuantity);\n    return;\n  }\n\n  // Calculate desired acceleration and angular acceleration.\n  Eigen::Vector3d acc_desired = acc_desired_ * acc_desired_norm_;\n  Eigen::Vector3d ang_acc_desired = ang_acc_desired_ * ang_acc_desired_norm_;\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust_projected_onto_body_z_axis =\n      thrust_cmd_ * thrust_cmd_norm_ * rotor_configuration_.rotor_direction;\n\n  // Combine thrust and angular acceleration.\n  Eigen::Vector3d acc_desired_thrust = acc_desired + thrust_projected_onto_body_z_axis;\n\n  // Rotate the desired acceleration and angular acceleration into a world frame.\n  Eigen::Matrix3d rot_W_B = GetRotationMatrixWToB(attitude_);\n  Eigen::Vector3d acc_desired_thrust_W = rot_W_B * acc_desired_thrust;\n  Eigen::Vector3d ang_acc_desired_W = rot_W_B * ang_acc_desired;\n\n  // Calculate the desired rotor velocities.\n  Eigen::VectorXd rotor_velocities_W =\n      rotor_configuration_.inertia *\n      (rotor_configuration_.rotor_direction.transpose() *\n       (acc_desired_thrust_W + ang_acc_desired_W));\n\n  // Project onto the rotor plane.\n  rotor_velocities_W = rotor_configuration_.rot", "CodeBleu_score": 42.76008675947909}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  // Position error.\n  Eigen::Vector3d position_error =\n      current_trajectory_->get_position() - current_odometry_.get_position();\n\n  // Velocity error.\n  Eigen::Vector3d velocity_error =\n      current_trajectory_->get_velocity() - current_odometry_.get_velocity();\n\n  // Compute acceleration.\n  *acceleration =\n      position_error * position_gain_ + velocity_error * velocity_gain_ +\n      current_trajectory_->get_acceleration() -\n      current_odometry_.get_velocity().cross(current_odometry_.get_velocity()) *\n          mass_ / 2.0 -\n      Eigen::Vector3d(0.0, 0.0, 9.81);\n}\n", "CodeBleu_score": 34.04595606516552}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  // Transform the vehicle's velocity to the world frame.\n  Eigen::Vector3d vehicle_velocity_world_frame;\n  geometry_msgs::TransformStamped transform;\n  try {\n    transform = tf_buffer_.lookupTransform(world_frame_id_, vehicle_frame_id_, ros::Time(0));\n  } catch (tf2::TransformException& ex) {\n    ROS_ERROR(\"%s\", ex.what());\n  }\n  geometry_msgs::Vector3 vehicle_velocity_local_frame = vehicle_state_.twist.twist.linear;\n  vehicle_velocity_world_frame.x() = transform.transform.translation.x +\n    (cos(transform.transform.rotation.w) * vehicle_velocity_local_frame.x -\n      sin(transform.transform.rotation.w) * vehicle_velocity_local_frame.y);\n  vehicle_velocity_world_frame.y() = transform.transform.translation.y +\n    (sin(transform.transform.rotation.w) * vehicle_velocity_local_frame.x +\n      cos(transform.transform.rotation.w) * vehicle_velocity_local_frame.y);\n  vehicle_velocity_world_frame.z() = vehicle_velocity_local_frame.z;\n\n  // Calculate the position and velocity errors.\n  Eigen::Vector3d position_error = command_trajectory_.position - vehicle_state_.pose.pose.position;\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity - vehicle_velocity_world_frame;\n\n  // Calculate the desired acceleration.\n  *acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error +\n    command_trajectory_.acceleration - gravity_ * mass_ / 2;\n}\n", "CodeBleu_score": 43.48356846607718}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  // Compute position and velocity errors\n  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n  ComputeDesiredVelocity(&velocity_error);\n  ComputeDesiredPosition(&position_error);\n\n  // Transform vehicle's velocity to the world frame\n  Eigen::Vector3d current_velocity_world;\n  current_velocity_world = transform_broadcaster_->transform.translation;\n\n  // Compute velocity error\n  velocity_error = velocity_error - current_velocity_world;\n\n  // Compute desired acceleration\n  *acceleration = position_error * position_gain_ + velocity_error * velocity_gain_ +\n                  transform_broadcaster_->transform.translation * acceleration_gain_ -\n                  Eigen::Vector3d(0, 0, 9.81) * mass_ + transform_broadcaster_->transform.translation * acceleration_gain_;\n}\n", "CodeBleu_score": 39.361910244414275}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(rotor_velocities->size() == input_.rotor_velocities.size());\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(input_.rotor_velocities.size());\n\n  // Ensure the inputs and parameters are valid.\n  if (!(input_.attitude.allFinite() && input_.angular_rates.allFinite() &&\n        input_.attitude_reference.allFinite() &&\n        input_.angular_rates_reference.allFinite())) {\n    ROS_ERROR(\"An input is either NaN, or +/- Inf\");\n\n    // Set the rotor velocities to zero and return.\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_velocities->size());\n    return;\n  }\n\n  // Compute the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration;\n  angular_acceleration =\n      AttitudeControllerSamy::CalculateDesiredAngularAcceleration();\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::Vector3d desired_acceleration;\n  desired_acceleration = angular_acceleration + input_.thrust_reference;\n\n  // Compute the rotor velocities.\n  *rotor_velocities =\n      AttitudeControllerSamy::CalculateRotorVelocities(desired_acceleration);\n}\n", "CodeBleu_score": 41.87911417760708}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(rotor_velocities->size() == rotor_count_);\n\n  // Resize rotor_velocities.\n  rotor_velocities->resize(rotor_count_);\n\n  // Check that the inputs are valid.\n  assert(AreInputsSane(input_));\n  assert(AreStatesSane(state_));\n\n  // Compute the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration =\n      input_.collective_thrust / input_.mass * input_.body_rates.cross(state_.attitude);\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::VectorXd desired_acceleration(rotor_count_);\n  desired_acceleration << desired_angular_acceleration, input_.thrust_reference;\n\n  // Compute the rotor velocities.\n  *rotor_velocities = rotor_matrix_ * desired_acceleration;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < rotor_count_; i++) {\n    if ((*rotor_velocities)(i) < 1.0) {\n      (*rotor_velocities)(i) = 1.0;\n    }\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->array().sqrt();\n}", "CodeBleu_score": 53.599582399841154}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(attitude_);\n  assert(angular_acceleration_);\n  assert(thrust_);\n  assert(rotor_velocities->size() == rotor_configuration_.num_rotors_);\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(rotor_configuration_.num_rotors_);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration =\n      attitude_->GetBodyToReferenceAngularAcceleration(attitude_estimate_);\n\n  // Combine the desired angular acceleration and thrust into a single vector.\n  Eigen::VectorXd torque(rotor_configuration_.num_rotors_);\n  torque = torque_mixing_matrix_ * (angular_acceleration + thrust_);\n\n  // Calculate the rotor velocities.\n  for (int i = 0; i < rotor_configuration_.num_rotors_; i++) {\n    (*rotor_velocities)(i) = sqrt(torque(i) / rotor_configuration_.rotor_drag_coefficients_(i));\n    (*rotor_velocities)(i) = (*rotor_velocities)(i) < 1.0 ? 1.0 : (*rotor_velocities)(i);\n  }\n}", "CodeBleu_score": 45.530124151201846}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    from copy import deepcopy\n    from numpy import array\n    from numpy import searchsorted\n    from numpy import s_\n\n    if start_time >= end_time:\n        raise ValueError(\"start_time must be less than end_time\")\n\n    # Find the indices corresponding to the start and end times\n    i_start = searchsorted(self.time, start_time)\n    i_end = searchsorted(self.time, end_time)\n\n    # Create a deep copy of the object\n    obj_slice = deepcopy(self)\n\n    # Update the attributes of the copied object to contain only the sliced data\n    obj_slice.time = self.time[i_start:i_end]\n    obj_slice.data = self.data[:, i_start:i_end]\n    obj_slice.it = array(self.it[i_start:i_end])\n    obj_slice.it_points = array(self.it_points[i_start:i_end])\n    obj_slice.it_interp = self.it_interp[i_start:i_end]\n\n    return obj_slice", "CodeBleu_score": 31.207818917904056}, {"code": "def slice(self, start_time, end_time)\n    from copy import deepcopy\n    import numpy as np\n\n    # Find the indices corresponding to the start and end times\n    start_index = np.where(self.time >= start_time)[0][0]\n    end_index = np.where(self.time <= end_time)[0][-1]\n\n    # Make a deep copy of the object\n    sliced_object = deepcopy(self)\n\n    # Update the attributes of the copied object to contain only the sliced data\n    sliced_object.time = self.time[start_index:end_index + 1]\n    sliced_object.current = self.current[start_index:end_index + 1]\n    sliced_object.voltage = self.voltage[start_index:end_index + 1]\n    sliced_object.charge = self.charge[start_index:end_index + 1]\n\n    return sliced_object", "CodeBleu_score": 32.76852320324281}, {"code": "def slice(self, start_time, end_time)\n    # Find the indices corresponding to the start and end times\n    start_idx = self.time_vector.index(start_time)\n    end_idx = self.time_vector.index(end_time)\n\n    # Make a deep copy of the object\n    copied_object = self.copy()\n\n    # Update the attributes to contain only the sliced data\n    copied_object.time_vector = self.time_vector[start_idx:end_idx + 1]\n    copied_object.current_vector = self.current_vector[start_idx:end_idx + 1]\n    copied_object.voltage_vector = self.voltage_vector[start_idx:end_idx + 1]\n    copied_object.voltage_vector_filtered = self.voltage_vector_filtered[start_idx:end_idx + 1]\n    copied_object.current_vector_filtered = self.current_vector_filtered[start_idx:end_idx + 1]\n    copied_object.voltage_rms = self.voltage_rms[start_idx:end_idx + 1]\n    copied_object.current_rms = self.current_rms[start_idx:end_idx + 1]\n    copied_object.voltage_peak = self.voltage_peak[start_idx:end_idx + 1]\n    copied_object.current_peak = self.current_peak[start_idx:end_idx + 1]\n    copied_object.voltage_crest_factor = self.voltage_crest_factor[start_idx:end_idx + 1]\n    copied_object.current_crest_factor = self.current_crest_factor[start_idx:end_idx + 1]\n    copied_object.voltage_mean = self.voltage_mean[start_idx:end_idx + 1]\n    copied_object.current_mean = self.current_mean[start_idx:end_idx + 1]\n    copied_object.voltage_variance = self.voltage_var", "CodeBleu_score": 13.411210402868043}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract the position and rotation from the waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert the rotation to Euler angles\n    (roll, pitch, yaw) = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the waypoint is different from the last one\n    if self.last_waypoint is not None and self.last_waypoint.position == point and self.last_waypoint.yaw == yaw:\n        # If the waypoint is the same, do not append it\n        return\n    else:\n        # If the waypoint is different, append it\n        self.waypoints.append(point)\n        self.yaw.append(yaw)\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n        self.last_waypoint = waypoint_msg\n", "CodeBleu_score": 25.86876404532717}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n\n    # Extract the position and rotation from the message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert the rotation to Euler angles\n    yaw = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])[2]\n\n    # Create a Point object\n    point = Point()\n    point.x = position.x\n    point.y = position.y\n    point.z = position.z\n\n    # Check if the current waypoint is different from the last one\n    if self.waypoints_array and self.waypoints_array[-1] != point:\n        # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints_array.append(point)\n        self.waypoints_yaw_array.append(yaw)\n        self.waypoints_time_array.append(msg_time)\n        self.waypoints_bag_time_array.append(bag_time)\n\n        # Increment the number of waypoints\n        self.num_waypoints += 1\n\n        # Print the waypoint\n        print(self.num_waypoints, point, yaw)\n\n        # Print the waypoint time\n        print(self.num_waypoints, msg_time)\n\n        # Print the waypoint bag time\n        print(self.num_waypoints, bag_time)\n\n        # Print a blank line\n        print(\"\")\n\n        # Return True\n        return True\n\n    # If the waypoint is the same as the last one, return False\n    return False\n", "CodeBleu_score": 30.98543368024232}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    self.waypoint_pos = waypoint_msg.pose.pose.position\n    self.waypoint_rot = waypoint_msg.pose.pose.orientation\n    self.waypoint_euler = tf.transformations.euler_from_quaternion(\n        [self.waypoint_rot.x, self.waypoint_rot.y, self.waypoint_rot.z, self.waypoint_rot.w])\n    self.waypoint_point = Point(self.waypoint_pos.x, self.waypoint_pos.y, self.waypoint_pos.z)\n\n    # Check if the waypoint is different from the last one\n    if (self.waypoint_pos.x != self.last_waypoint_pos.x) or (self.waypoint_pos.y != self.last_waypoint_pos.y) or (self.waypoint_pos.z != self.last_waypoint_pos.z) or (self.waypoint_euler[2] != self.last_waypoint_euler[2]):\n        self.waypoint_time.append(bag_time)\n        self.waypoint_msg_time.append(msg_time)\n        self.waypoint_positions.append(self.waypoint_point)\n        self.waypoint_yaws.append(self.waypoint_euler[2])\n        self.last_waypoint_pos = self.waypoint_pos\n        self.last_waypoint_euler = self.waypoint_euler\n", "CodeBleu_score": 22.256924459322185}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == '/imu_raw':\n        self.imu_raw_x.append(msg.linear_acceleration.x)\n        self.imu_raw_y.append(msg.linear_acceleration.y)\n        self.imu_raw_z.append(msg.linear_acceleration.z)\n        self.imu_raw_time.append(msg.header.stamp.to_sec())\n        self.imu_raw_bag_time.append(bag_time)\n\n    elif topic == '/imu_filtered':\n        self.imu_filtered_x.append(msg.linear_acceleration.x)\n        self.imu_filtered_y.append(msg.linear_acceleration.y)\n        self.imu_filtered_z.append(msg.linear_acceleration.z)\n        self.imu_filtered_time.append(msg.header.stamp.to_sec())\n        self.imu_filtered_bag_time.append(bag_time)\n\n    elif topic == '/imu_data':\n        self.imu_data_x.append(msg.linear_acceleration.x)\n        self.imu_data_y.append(msg.linear_acceleration.y)\n        self.imu_data_z.append(msg.linear_acceleration.z)\n        self.imu_data_time.append(msg.header.stamp.to_sec())\n        self.imu_data_bag_time.append(bag_time)\n\n    elif topic == '/imu_data_raw':\n        self.imu_data_raw_x.append(msg.linear_acceleration.x)\n        self.imu_data_raw_y.append(msg.linear_acceleration.y)\n        self.imu_data_raw_z.append(msg.linear_acceleration.z)\n        self.imu_data_raw_time.append(msg.header.stamp.to_sec())\n        self.imu_data", "CodeBleu_score": 24.33494547843068}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\n    if topic == \"/imu/data\":\n        self.imu_data_x.append(msg.linear_acceleration.x)\n        self.imu_data_y.append(msg.linear_acceleration.y)\n        self.imu_data_z.append(msg.linear_acceleration.z)\n        self.imu_data_time.append(msg.header.stamp.to_sec())\n        self.imu_data_bagtime.append(bag_time)\n    elif topic == \"/imu_1/data\":\n        self.imu_1_data_x.append(msg.linear_acceleration.x)\n        self.imu_1_data_y.append(msg.linear_acceleration.y)\n        self.imu_1_data_z.append(msg.linear_acceleration.z)\n        self.imu_1_data_time.append(msg.header.stamp.to_sec())\n        self.imu_1_data_bagtime.append(bag_time)\n    elif topic == \"/imu_2/data\":\n        self.imu_2_data_x.append(msg.linear_acceleration.x)\n        self.imu_2_data_y.append(msg.linear_acceleration.y)\n        self.imu_2_data_z.append(msg.linear_acceleration.z)\n        self.imu_2_data_time.append(msg.header.stamp.to_sec())\n        self.imu_2_data_bagtime.append(bag_time)\n    elif topic == \"/imu_3/data\":\n        self.imu_3_data_x.append(msg.linear_acceleration.x)\n        self.imu_3_data_y.append(msg.linear_acceleration.y)\n        self.imu_3_data_z.append(msg.linear_acceleration.z)\n        self.imu_3_data_time.append(msg.header.stamp", "CodeBleu_score": 24.50442210278333}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu_left\":\n        self.imu_left_x.append(msg.linear_acceleration.x)\n        self.imu_left_y.append(msg.linear_acceleration.y)\n        self.imu_left_z.append(msg.linear_acceleration.z)\n        self.imu_left_time.append(msg.header.stamp.to_sec())\n        self.imu_left_bag_time.append(bag_time)\n    elif topic == \"/imu_right\":\n        self.imu_right_x.append(msg.linear_acceleration.x)\n        self.imu_right_y.append(msg.linear_acceleration.y)\n        self.imu_right_z.append(msg.linear_acceleration.z)\n        self.imu_right_time.append(msg.header.stamp.to_sec())\n        self.imu_right_bag_time.append(bag_time)\n    elif topic == \"/imu_left_raw\":\n        self.imu_left_raw_x.append(msg.linear_acceleration.x)\n        self.imu_left_raw_y.append(msg.linear_acceleration.y)\n        self.imu_left_raw_z.append(msg.linear_acceleration.z)\n        self.imu_left_raw_time.append(msg.header.stamp.to_sec())\n        self.imu_left_raw_bag_time.append(bag_time)\n    elif topic == \"/imu_right_raw\":\n        self.imu_right_raw_x.append(msg.linear_acceleration.x)\n        self.imu_right_raw_y.append(msg.linear_acceleration.y)\n        self.imu_right_raw_z.append(msg.linear_acceleration.z)\n        self.imu_right_raw_time.append(msg.header.stamp.to_sec())\n        self.im", "CodeBleu_score": 24.262930504375284}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n    if plot_suffix is None:\n        plot_suffix = \"\"\n    else:\n        plot_suffix = \"_\" + plot_suffix\n    fig, ax = plt.subplots(1, 1, figsize=(16, 9))\n    fig.suptitle(\"Accelerations\" + plot_suffix, fontsize=20)\n    ax.set_title(\"Accelerations\" + plot_suffix, fontsize=16)\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    for i, accel_data in enumerate(self.accelerations):\n        ax.plot(accel_data.time, accel_data.x, label=\"x\", color=self.colors[i])\n        ax.plot(accel_data.time, accel_data.y, label=\"y\", color=self.colors[i])\n        ax.plot(accel_data.time, accel_data.z, label=\"z\", color=self.colors[i])\n    ax.legend()\n    if self.save_plots:\n        fig.savefig(self.plot_path + \"/accelerations\" + plot_suffix + \".png\")\n\n", "CodeBleu_score": 36.97525158699956}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    import matplotlib.pyplot as plt\n    from os.path import join\n    from os import mkdir\n\n    # Create a figure and subplot for accelerations\n    fig, ax = plt.subplots()\n\n    # Create a list of colors to use for the different accelerations\n    colors = [\"red\", \"blue\", \"green\", \"yellow\", \"purple\", \"cyan\", \"orange\", \"magenta\"]\n\n    # Plot the x, y, and z components of each acceleration dataset\n    for i, accel in enumerate(self.accelerations):\n        ax.plot(accel[\"t\"], accel[\"x\"], color=colors[i], label=\"x\")\n        ax.plot(accel[\"t\"], accel[\"y\"], color=colors[i], label=\"y\")\n        ax.plot(accel[\"t\"], accel[\"z\"], color=colors[i], label=\"z\")\n\n    # Add labels for the x and y axes\n    ax.set_xlabel(\"Time (s)\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n\n    # Add a legend\n    ax.legend()\n\n    # If saving plots is enabled, create a filename and save the plot\n    if self.save_plots:\n        # Create the directory for the plots if it doesn't exist\n        if not os.path.exists(self.plot_dir):\n            os.mkdir(self.plot_dir)\n\n        # Create a filename for the plot\n        if plot_suffix is None:\n            filename = self.plot_prefix + \"accelerations.png\"\n        else:\n            filename = self.plot_prefix + plot_suffix + \"_accelerations.png\"\n\n        # Save the plot\n        fig.savefig(join(self.plot_dir, filename))\n\n    # Show the plot\n    plt.show()", "CodeBleu_score": 38.541881140550096}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    # Create a figure and set the title.\n    fig = plt.figure(figsize=(16, 9))\n    fig.suptitle(self.title)\n    # Create a subplot for the accelerations.\n    ax = fig.add_subplot(1, 1, 1)\n    # Plot the x, y, and z components of the accelerations.\n    ax.plot(self.time, self.accelerations_x, label='x', color='blue')\n    ax.plot(self.time, self.accelerations_y, label='y', color='green')\n    ax.plot(self.time, self.accelerations_z, label='z', color='red')\n    # Add labels for the x and y axes.\n    ax.set_xlabel('time (s)')\n    ax.set_ylabel('acceleration (m/s^2)')\n    # Add a legend.\n    ax.legend()\n    # If saving plots is enabled, construct a filename and save the plot.\n    if self.save_plots:\n        filename = self.filename_prefix + '_accelerations'\n        if plot_suffix:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        fig.savefig(filename)\n    # Show the plot.\n    plt.show()\n\n", "CodeBleu_score": 36.65083537013756}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    # This function, compare_positions, compares the positions of multiple poses based on their indices.\n    # It requires at least two pose indices to perform comparisons.\n    # For each pose index, it compares the position with all subsequent pose indices using the compare_two_xyz function.\n    #\n    # Input:\n    #   pose_indeces: list of pose indices to compare\n    #\n    # Output:\n    #   pose_distances: list of distances between the pose indices\n    #\n    # Example:\n    # compare_positions([1, 2, 3])\n    #\n    #\n\n    pose_distances = []\n    for i in range(len(pose_indeces)-1):\n        for j in range(i+1, len(pose_indeces)):\n            pose_distances.append(self.compare_two_xyz(pose_indeces[i], pose_indeces[j]))\n    return pose_distances\n\n", "CodeBleu_score": 24.763975743680035}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"Error: At least two pose indices are required to perform comparisons.\")\n        return\n\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 39.09642756924825}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"ERROR: compare_positions requires at least two pose indices to compare.\")\n        return\n    for i in range(len(pose_indeces)-1):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 36.66080255566141}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for collision in self.wrench:\n        if start_time < collision.time < end_time:\n            collision_times.append(collision.time)\n    return collision_times", "CodeBleu_score": 38.53764229396123}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\n    collision_times = []\n\n    for collision_time in self.wrench.keys():\n        if start_time <= collision_time <= end_time:\n            collision_times.append(collision_time)\n\n    return collision_times", "CodeBleu_score": 38.75549238535944}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n\n    # Initialize empty list\n    collision_times = []\n\n    # Iterate through each collision's time in self.wrench\n    for collision in self.wrench:\n        # If the time is within the start_time and end_time range, append the time to the collision_times list\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n\n    # Return the list of collision times\n    return collision_times", "CodeBleu_score": 38.827983576462124}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 29.32422071502378}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    # Calculate the absolute settling time.\n    abs_settling_time = start_time + settling_time\n    # Call the analyze_bag.plot_angular_velocities function with the specified start time, end time, settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5].\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 28.605689571937422}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\n    # Calculate the absolute settling time\n    abs_settling_time = start_time + settling_time\n\n    # Plot the angular velocities\n    analyze_bag.plot_angular_velocities(start_time, end_time, abs_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n", "CodeBleu_score": 28.605689571937422}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n\n  const float multiplier = 1.0f / (256.0f * 256.0f);\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> data_map(data, height, width);\n\n  const float rms_noise = CalculateRMSNoise(width, height);\n  const float noise_values = CalculateNoiseValues(width, height);\n\n  for (uint32_t i = 0; i < data_map.rows(); i++) {\n    for (uint32_t j = 0; j < data_map.cols(); j++) {\n      const float value = data_map(i, j);\n      if (value > 0.0f) {\n        data_map(i, j) = value + multiplier * rms_noise * value * value +\n                         multiplier * noise_values;\n      } else {\n        data_map(i, j) = 0.0f;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 47.73133124386789}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n  const float multiplier =\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f / 1000.0f) *\n      (1.0f / 1000.0f) * (1.0f / 1000.0f) * (1.0f", "CodeBleu_score": 13.778443897377354}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  // Check if data is null\n  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier\n  float multiplier = 1.0f / (1000.0f / 2.0f);\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Calculate RMS noise and noise values\n  float rms_noise = multiplier * sqrt(noise_sigma_ * noise_sigma_ * 1000.0f);\n  float noise_vals[width * height];\n  for (uint32_t i = 0; i < width * height; i++) {\n    noise_vals[i] = rms_noise * rand_gauss();\n  }\n\n  // Add noise to data\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vec(i) > 0.0f && data_vec(i) < 10.0f) {\n      data_vec(i) += noise_vals[i];\n    } else {\n      data_vec(i) = 0.0f;\n    }\n  }\n}\n", "CodeBleu_score": 56.784945849233004}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  ros::Time ros_time = ros::Time::now();\n  // Convert Gazebo time to ROS time\n  ros_time.sec = this->world->GetSimTime().sec;\n  ros_time.nsec = this->world->GetSimTime().nsec;\n  // Write trajectory to bag file\n  this->bag.write(this->waypoint_topic, ros_time, *trajectory_msg);\n}\n", "CodeBleu_score": 41.94693703290094}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get the current simulation time\n  gazebo::common::Time sim_time = this->world_->GetSimTime();\n\n  // Convert simulation time to ROS time\n  ros::Time ros_time = gazebo::msgs::Convert(sim_time);\n\n  // Write trajectory message to bag file\n  this->bag_.write(this->waypoint_topic_, ros_time, trajectory_msg);\n}\n", "CodeBleu_score": 42.607531300144686}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get the current simulation time\n  gazebo::common::Time sim_time = this->world_->GetSimTime();\n\n  // Convert to ROS time\n  ros::Time ros_time = ros::Time(sim_time.sec, sim_time.nsec);\n\n  // Write to bag file\n  this->bag_.write(this->waypoint_topic_, ros_time, *trajectory_msg);\n}\n", "CodeBleu_score": 52.72317379358422}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)  if (now - last_motor_vel_time_ > motor_vel_update_period_) {\n    last_motor_vel_time_ = now;\n\n    // Convert simulation time to ROS time\n    ros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n    // Prepare a message for motor velocities\n    mav_msgs::Actuators actuators_msg;\n    actuators_msg.header.stamp = ros_time;\n    actuators_msg.header.frame_id = namespace_;\n\n    // Iterate through the motor joints, calculate the slowed-down rotational velocities, and assign them to the message\n    for (int i = 0; i < motor_joints_.size(); i++) {\n      physics::JointPtr joint = motor_joints_[i];\n      double joint_vel = joint->GetVelocity(0);\n      double slowed_joint_vel = joint_vel / motor_velocity_slowdown_;\n      actuators_msg.angular_velocities.push_back(slowed_joint_vel);\n    }\n\n    // Publish the message\n    actuators_pub_.publish(actuators_msg);\n\n    // Write the message to a bag file\n    if (bag_open_) {\n      bag_.write(motor_vel_topic_, ros_time, actuators_msg);\n    }\n  }\n}\n", "CodeBleu_score": 50.38850672074877}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)  // Convert simulation time to ROS time\n  ros::Time time_now = ros::Time::now();\n\n  // Prepare message\n  mav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n\n  // Set timestamp\n  actuator_msg->header.stamp = time_now;\n\n  // Iterate through joints\n  for (int i = 0; i < this->joint_names_.size(); i++) {\n    // Get joint name\n    std::string joint_name = this->joint_names_[i];\n\n    // Get joint\n    physics::JointPtr joint = this->model_->GetJoint(joint_name);\n\n    // Get joint velocity\n    double joint_velocity = joint->GetVelocity(0);\n\n    // Get joint lower limit\n    double joint_lower = joint->LowerLimit(0);\n\n    // Get joint upper limit\n    double joint_upper = joint->UpperLimit(0);\n\n    // Get joint effort\n    double joint_effort = joint->GetForce(0);\n\n    // Get joint position\n    double joint_position = joint->Position(0);\n\n    // Calculate slowed-down rotational velocity\n    double rotational_velocity = joint_velocity / this->rotor_velocity_slowdown_sim_;\n\n    // Assign slowed-down rotational velocity to message\n    actuator_msg->angular_velocities.push_back(rotational_velocity);\n\n    // Assign joint effort to message\n    actuator_msg->joint_efforts.push_back(joint_effort);\n\n    // Assign joint lower limit to message\n    actuator_msg->joint_lower_limits.push_back(joint_lower);\n\n    // Assign joint upper limit to message\n    actuator_msg->joint_upper_limits.push_back(joint_upper);\n\n    // Assign joint position to message\n    actuator_msg->joint_positions.push_back(joint_position);\n  }\n\n  // Write data to bag file\n  this->motor_pub_.publish(actuator_msg);\n}", "CodeBleu_score": 37.186368368859924}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)  if (now < this->next_actuator_vel_update_time_) {\n    return;\n  }\n  this->next_actuator_vel_update_time_ = now + this->actuator_vel_update_interval_;\n\n  // Get the simulation time and convert it to ROS time.\n  ros::Time sim_time = ros::Time().fromSec(now.Double());\n\n  // Prepare the message.\n  mav_msgs::ActuatorsPtr actuator_msg(new mav_msgs::Actuators);\n  actuator_msg->header.stamp = sim_time;\n  actuator_msg->header.frame_id = this->namespace_;\n  actuator_msg->angular_velocities.clear();\n\n  // Iterate through the motors and get their velocities.\n  for (int i = 0; i < this->rotor_velocities_.size(); i++) {\n    // Calculate the slowed-down rotational velocities.\n    double vel = this->rotor_velocities_[i] * this->rotor_velocity_slowdown_sim_;\n    actuator_msg->angular_velocities.push_back(vel);\n  }\n\n  // Write the message to the bag file.\n  this->actuator_vel_bag_.write(this->actuator_vel_topic_, sim_time, *actuator_msg);\n}\n", "CodeBleu_score": 42.49665210573653}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  // Log that this function was called.\n  if (debug_print_) {\n    std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback()\"\n              << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to control\n  // surface angles for ailerons, elevator, and rudder respectively.\n  double roll = roll_pitch_yawrate_thrust_msg->roll();\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n  double roll_angle = roll * (max_aileron_angle_ - min_aileron_angle_) / 2.0\n      + (max_aileron_angle_ - min_aileron_angle_) / 2.0;\n  double pitch_angle = pitch * (max_elevator_angle_ - min_elevator_angle_) / 2.0\n      + (max_elevator_angle_ - min_elevator_angle_) / 2.0;\n  double yaw_rate_angle = yaw_rate * (max_rudder_angle_ - min_rudder_angle_) / 2.0\n      + (max_rudder_angle_ - min_rudder_angle_) / 2.0;\n\n  // Set the throttle value from the thrust message.\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n  double throttle = thrust * (max_throttle_ - min_throttle_) / 2.0\n      + (max_throttle_ - min_throttle_) / 2.0;\n\n  // Set the control surface angles.\n  aileron_control_surface_->SetAngle(0, roll_angle);\n  elevator_control_surface_->SetAngle(0, pitch_angle);\n  rudder_control_surface_->SetAngle(0, yaw_rate_angle);", "CodeBleu_score": 41.785743808726586}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  // Log that this function was called.\n  if (debug_print_) {\n    ROS_INFO_NAMED(\"GazeboFwDynamicsPlugin\", \"RollPitchYawrateThrustCallback() called.\");\n  }\n\n  // Convert normalized input values for roll, pitch, and yaw rate to control surface angles for ailerons, elevator, and rudder respectively.\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll * (max_aileron_angle_ - min_aileron_angle_) + min_aileron_angle_;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch * (max_elevator_angle_ - min_elevator_angle_) + min_elevator_angle_;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate * (max_rudder_angle_ - min_rudder_angle_) + min_rudder_angle_;\n\n  // Set the throttle value from the thrust message.\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Set the control surface angles and throttle.\n  SetAilerons(roll_angle);\n  SetElevator(pitch_angle);\n  SetRudder(yaw_rate);\n  SetThrottle(throttle);\n}\n", "CodeBleu_score": 36.731264930692554}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  // Log that this callback was called\n  if (debug_print_) {\n    std::cout << \"\\n\\n##### \" << model_->GetName() << \"::RollPitchYawrateThrustCallback() @ \" <<\n        world_->GetSimTime().Double() << \" #####\\n\";\n    std::cout << \"roll_pitch_yawrate_thrust_msg->roll: \" <<\n        roll_pitch_yawrate_thrust_msg->roll << \"\\n\";\n    std::cout << \"roll_pitch_yawrate_thrust_msg->pitch: \" <<\n        roll_pitch_yawrate_thrust_msg->pitch << \"\\n\";\n    std::cout << \"roll_pitch_yawrate_thrust_msg->yaw_rate: \" <<\n        roll_pitch_yawrate_thrust_msg->yaw_rate << \"\\n\";\n    std::cout << \"roll_pitch_yawrate_thrust_msg->thrust: \" <<\n        roll_pitch_yawrate_thrust_msg->thrust << \"\\n\";\n  }\n\n  // Convert roll, pitch, and yaw rate to control surface angles\n  double aileron_cmd = roll_pitch_yawrate_thrust_msg->roll * aileron_cmd_max_;\n  double elevator_cmd = roll_pitch_yawrate_thrust_msg->pitch * elevator_cmd_max_;\n  double rudder_cmd = roll_pitch_yawrate_thrust_msg->yaw_rate * rudder_cmd_max_;\n\n  // Set the throttle value\n  double throttle_cmd = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Set the control surface commands\n  this->SetAileronCmd(aileron_cmd);\n  this->SetElevatorCmd(elevator_cmd);\n  this->SetRudderCmd(rudder_cmd);\n  this->SetThrottleCmd(throttle_cmd);\n}\n", "CodeBleu_score": 42.66458087401376}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  struct timeval receiveTimeout;\n  fd_set fds;\n  int ret;\n\n  receiveTimeout.tv_sec = _timeoutMs / 1000;\n  receiveTimeout.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  FD_ZERO(&fds);\n  FD_SET(this->hil_fd, &fds);\n\n  ret = select(this->hil_fd + 1, &fds, NULL, NULL, &receiveTimeout);\n\n  if (ret == -1) {\n    gzerr << \"Failed to select on HIL fd\\n\";\n    return;\n  } else if (ret) {\n    struct sockaddr_in remoteAddr;\n    socklen_t remoteAddrLen = sizeof(remoteAddr);\n\n    // Receive data from UDP socket\n    int len = recvfrom(this->hil_fd, recv_buf, sizeof(recv_buf), 0,\n                       (struct sockaddr *)&remoteAddr, &remoteAddrLen);\n\n    if (len > 0) {\n      mavlink_message_t msg;\n      mavlink_status_t status;\n\n      // Search for MAVLink messages in the received buffer\n      for (unsigned i = 0; i < len; ++i) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, recv_buf[i], &msg, &status)) {\n          // Handle message\n          this->handle_mavlink_message(&msg);\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 63.21593163922814}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // poll from Gazebo\n  struct timeval receiveTimeout;\n  fd_set fds;\n  int ret;\n\n  // set the time out\n  receiveTimeout.tv_sec = _timeoutMs / 1000;\n  receiveTimeout.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n  // add data socket to set\n  FD_ZERO(&fds);\n  FD_SET(this->socketFd, &fds);\n\n  // poll socket\n  ret = select(this->socketFd + 1, &fds, NULL, NULL, &receiveTimeout);\n\n  if (ret == -1) {\n    std::cerr << \"aborting on select error\" << std::endl;\n    abort();\n  }\n  else if (ret) {\n    // handle data\n    if (FD_ISSET(this->socketFd, &fds)) {\n      // read data into buffer\n      int len = recv(this->socketFd, this->buf, sizeof(this->buf), 0);\n      if (len <= 0) {\n        //abort on error\n        std::cerr << \"aborting on read error\" << std::endl;\n        abort();\n      }\n\n      // handle message\n      this->handle_message();\n    }\n  }\n}\n", "CodeBleu_score": 47.08031107832679}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // poll for messages\n  struct timeval received_time;\n  int ret = 0;\n  bool received_msg = false;\n  do {\n    // setup timeval\n    received_time.tv_sec = _timeoutMs / 1000;\n    received_time.tv_usec = (_timeoutMs % 1000) * 1000UL;\n\n    // setup fd's\n    struct pollfd fds[1];\n    fds[0].fd = this->hil_fd;\n    fds[0].events = POLLIN;\n\n    // poll\n    ret = poll(fds, 1, _timeoutMs);\n    if (ret < 0) {\n      std::cerr << \"poll error: \" << strerror(errno) << \"\\n\";\n    } else if (ret > 0) {\n      // handle data\n      if (fds[0].revents & POLLIN) {\n        // receive data\n        int len = recv(this->hil_fd, recv_buf + message_len,\n                       sizeof(recv_buf) - message_len, 0);\n        if (len < 0) {\n          std::cerr << \"recv error: \" << strerror(errno) << \"\\n\";\n        } else {\n          message_len += len;\n          received_msg = true;\n        }\n      }\n    }\n  } while (ret > 0);\n\n  // parse mavlink messages\n  if (received_msg) {\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (unsigned i = 0; i < message_len; ++i) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, recv_buf[i], &msg, &status)) {\n        handle_mavlink_message(&msg);\n      }\n    }\n  }\n\n  // reset message length\n  message_len = 0;\n}\n", "CodeBleu_score": 61.967150435371764}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close()   // Lock the mutex to ensure thread safety.\n  boost::mutex::scoped_lock scoped_lock(mutex);\n\n  // If the serial device is open, stop the I/O service and close the serial device.\n  if (serial_dev.isOpen()) {\n    io_service.stop();\n    serial_dev.close();\n  }\n\n  // If the I/O thread is joinable, join the thread to clean up resources.\n  if (io_thread.joinable()) {\n    io_thread.join();\n  }\n}\n", "CodeBleu_score": 54.651738670055884}, {"code": "void GazeboMavlinkInterface::close()   std::lock_guard<std::mutex> lock(mutex);\n  if (!is_open_) {\n    return;\n  }\n  //stop the io_service from polling the serial device\n  io_service_.stop();\n  //close the serial device\n  serial_dev_.close();\n  //wait for the io_service to stop\n  try {\n    io_service_.reset();\n  }\n  catch(const std::exception& e) {\n    std::cerr << e.what() << '\\n';\n  }\n  //if the io_service_thread joinable, join it to clean up resources\n  if (io_service_thread_.joinable()) {\n    io_service_thread_.join();\n  }\n  is_open_ = false;\n}\n", "CodeBleu_score": 54.05589466881908}, {"code": "void GazeboMavlinkInterface::close()   boost::mutex::scoped_lock scoped_lock(mutex);\n\n  if (this->is_open) {\n    this->is_open = false;\n    this->io_service.stop();\n    this->serial_dev.close();\n    if (this->io_thread.joinable()) {\n      this->io_thread.join();\n    }\n  }\n}\n", "CodeBleu_score": 32.15245893939291}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation  const ignition::math::Vector3d &position,\n  const ignition::math::Vector3d &p0,\n  const ignition::math::Vector3d &p1,\n  const ignition::math::Vector3d &v0,\n  const ignition::math::Vector3d &v1} {\n  // Calculate the interpolated value between two points using their corresponding values\n  const ignition::math::Vector3d interpolated =\n    (position - p0) * (v1 - v0) / (p1 - p0) + v0;\n\n  // Return the resulting vector\n  return interpolated;\n}\n", "CodeBleu_score": 39.956168394776725}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation  ignition::math::Vector3d position,\n  ignition::math::Vector3d firstPoint,\n  ignition::math::Vector3d secondPoint,\n  ignition::math::Vector3d firstValue,\n  ignition::math::Vector3d secondValue\n} {\n  // Calculate the distance between the two points\n  double distance = firstPoint.Distance(secondPoint);\n\n  // Calculate the ratio between the distance and the position\n  double ratio = position.Distance(firstPoint) / distance;\n\n  // Calculate the interpolated value\n  ignition::math::Vector3d interpolatedValue = firstValue + ratio * (secondValue - firstValue);\n\n  // Return the interpolated value\n  return interpolatedValue;\n}\n", "CodeBleu_score": 34.170304639460106}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    const ignition::math::Vector3d &pos,\n    const ignition::math::Vector3d &val1,\n    const ignition::math::Vector3d &val2,\n    const ignition::math::Vector3d &pos1,\n    const ignition::math::Vector3d &pos2\n}", "CodeBleu_score": 34.41989683981728}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)\tif (looping) {\n\t\ttime = fmod(_time, length);\n\t}\n\telse {\n\t\ttime = glm::clamp(_time, 0.0, length);\n\t}\n}\n", "CodeBleu_score": 28.618757005226335}, {"code": "void Animation::SetTime(double _time)\tif (time != _time) {\n\t\tif (loop) {\n\t\t\ttime = fmod(_time, length);\n\t\t\tif (time < 0)\n\t\t\t\ttime += length;\n\t\t}\n\t\telse {\n\t\t\ttime = std::max(0.0, std::min(_time, length));\n\t\t}\n\t\tUpdate();\n\t}\n}\n", "CodeBleu_score": 31.884686820667724}, {"code": "void Animation::SetTime(double _time)    if (loop) {\n        time = fmod(_time, length);\n    } else {\n        time = glm::clamp(_time, 0.0, length);\n    }\n}\n", "CodeBleu_score": 29.58820999717785}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n\n    # Set the vehicle's coordinate frame to 1 (NED)\n    self.vehicle.set_coordinate_frame(mavutil.mavlink.MAV_FRAME_LOCAL_NED)\n\n    # Set the vehicle's motion type to 0 (hold)\n    self.vehicle.set_motion_type(mavutil.mavlink.MAV_MOUNT_MOTION_NONE)\n\n    # Construct a target_motion message with the current position and yaw\n    target_motion = self.vehicle.message_factory.mount_configure_encode(\n        0, 1,    # target system, target component\n        mavutil.mavlink.MAV_MOUNT_MODE_MAVLINK_TARGETING,  # mount_mode\n        1,  # stabilize roll\n        1,  # stabilize pitch\n        1,  # stabilize yaw\n    )\n    # Send target_motion message to vehicle\n    self.vehicle.send_mavlink(target_motion)\n\n    # Construct a target_location message with the current position and yaw\n    target_location = self.vehicle.message_factory.mount_control_encode(\n        0, 1,    # target system, target component\n        0b0000111111000111,  # input_a\n        0,  # input_b\n        0,  # input_c\n        0,  # save position\n    )\n    # Send target_location message to vehicle\n    self.vehicle.send_mavlink(target_location)\n\n    # Print vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: %s\" % self.vehicle.type)\n    print(\"Vehicle ID: %s\" % self.vehicle.id)\n    print(\"Flight mode: %s\" % self.vehicle.mode.name)", "CodeBleu_score": 22.110974540471563}, {"code": "def hover(self)\n    self.set_vehicle_coordinate_frame(1)\n    self.set_motion_type(0)\n    target = self.get_target_motion()\n    target.position.x = self.get_current_position().x\n    target.position.y = self.get_current_position().y\n    target.position.z = self.get_current_position().z\n    target.yaw = self.get_current_yaw()\n    self.set_target_motion(target)\n    print(\"Vehicle Type:\", self.get_vehicle_type())\n    print(\"Vehicle ID:\", self.get_vehicle_id())\n    print(\"Flight Mode:\", self.get_flight_mode())", "CodeBleu_score": 22.10870473369433}, {"code": "def hover(self)\n    # Set the vehicle's coordinate frame to 1 (body frame)\n    self.set_attitude_target_local_ned(0, 0, 0, 0, 0, 0, 0, 0, 1)\n    # Set the vehicle's motion type to 0 (hover)\n    self.set_motion_type_target(0)\n    # Construct a target using the current position and yaw\n    target = self.get_local_position()\n    target.x = 0\n    target.y = 0\n    target.z = 0\n    # Send the target to the vehicle\n    self.set_position_target_local_ned(target.x, target.y, target.z, 0)\n    # Print the vehicle's type, ID, and flight mode\n    print(self.get_type())\n    print(self.get_id())\n    print(self.get_mode())\n\n", "CodeBleu_score": 24.58073249581284}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print('Flight mode switched to ' + self.flight_mode)\n            return True\n        except:\n            print('Flight mode switch failed')\n            return False\n\n", "CodeBleu_score": 62.48265597192454}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print('Successfully switched to ' + self.flight_mode + ' mode!')\n            return True\n        except:\n            print('Failed to switch to ' + self.flight_mode + ' mode!')\n            return False\n", "CodeBleu_score": 47.7938721252255}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print('Mode switch successful!')\n            return True\n        except rospy.ServiceException as e:\n            print('Mode switch failed!')\n            return False\n", "CodeBleu_score": 61.33126627270102}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_flag = False\n    self.hold_flag = False\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = [0, 0, 0, 0, 0, 0]\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if self.hover_flag == False:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if self.hover_flag == False and self.hold_flag == False:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z]\n", "CodeBleu_score": 54.2716798943143}, {"code": "def cmd_vel_enu_callback(self, msg)\n    # print(\"cmd_vel_enu_callback\")\n    self.hover_flag = self.hover_state_transition(msg.linear.x, msg.linear.y, msg.angular.z)\n    if self.hover_flag == 0:\n        self.hold_flag = self.hold_state_transition(msg.linear.x, msg.linear.y, msg.angular.z, 'enu')\n        if self.hold_flag == 0:\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            self.target_motion = np.array([msg.linear.x, msg.linear.y, msg.angular.z])\n", "CodeBleu_score": 53.0971901926853}, {"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_flag = False\n    self.hold_flag = False\n    self.coordinate_frame = 1\n    self.motion_type = 1\n    self.target_motion = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\n    if self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z):\n        return\n    if self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu'):\n        return\n\n    self.target_motion[0] = msg.linear.x\n    self.target_motion[1] = msg.linear.y\n    self.target_motion[2] = msg.linear.z\n    self.target_motion[3] = msg.angular.x\n    self.target_motion[4] = msg.angular.y\n    self.target_motion[5] = msg.angular.z\n", "CodeBleu_score": 45.20525239449261}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n    if (x > 0.02 or x < -0.02 or y > 0.02 or y < -0.02 or z > 0.02 or z < -0.02 or w > 0.005 or w < -0.005) and self.hover_flag == 1:\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n        print(\"OFFBOARD\")\n    elif (x < 0.02 and x > -0.02 and y < 0.02 and y > -0.02 and z < 0.02 and z > -0.02 and w < 0.005 and w > -0.005) and self.hover_flag == 0:\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        print(\"HOVER\")\n", "CodeBleu_score": 33.10586144169153}, {"code": "def hover_state_transition(self, x, y, z, w)\n    # If any of the x, y, z values exceed 0.02 or w exceeds 0.005, it sets hover_flag to 0 and changes the flight mode to 'OFFBOARD'\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005) and self.hover_flag == 1:\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    # If the flight mode is not \"HOVER\" and the conditions are met, it sets hover_flag to 1, changes the flight mode to 'HOVER', and initiates the hover action\n    elif self.hover_flag == 0 and self.flight_mode != \"HOVER\":\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover()\n", "CodeBleu_score": 51.018305767324094}, {"code": "def hover_state_transition(self, x, y, z, w)\n\n    if (x > 0.02 or x < -0.02 or y > 0.02 or y < -0.02 or z > 0.02 or z < -0.02 or w > 0.005 or w < -0.005):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    elif (self.hover_flag == 1):\n        self.set_mode(\"HOVER\")\n        self.hover_flag = 0\n    elif (self.hover_flag == 0):\n        self.set_mode(\"HOVER\")\n        self.hover_flag = 1", "CodeBleu_score": 34.674109545392106}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 27.52863807726429}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        return q.yaw\n\n", "CodeBleu_score": 35.6773847240096}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q[0], q[1], q[2], q[3])\n        yaw = q.yaw\n    return yaw\n\n", "CodeBleu_score": 38.689044969360964}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    # Update coordinate frame\n    self.update_frame()\n    # Update motion type\n    self.update_motion_type()\n    # Construct target\n    target = self.construct_target()\n    # Set vehicle to hover mode\n    self.vehicle.simple_takeoff(target.z)\n    # Print vehicle type, vehicle ID, and flight mode\n    print(self.vehicle_type, self.vehicle_id, \"hover\")", "CodeBleu_score": 10.603156918320348}, {"code": "def hover(self)\n    # Set the coordinate frame to be NED\n    self.vehicle.set_coordinate_frame(mavutil.mavlink.MAV_FRAME_LOCAL_NED)\n    # Set the vehicle motion type to be hover\n    self.vehicle.mode = VehicleMode(\"HOVER\")\n    # Construct a target position in NED frame\n    target_ned = location_helpers.global_to_local(self.vehicle.location.global_frame, self.vehicle.home_location, self.vehicle.attitude.yaw)\n    # Construct a target motion in NED frame\n    target_motion = Motion(type=\"velocity\", velocity=target_ned, yaw=self.vehicle.attitude.yaw)\n    # Set the target motion\n    self.vehicle.channels.overrides['4'] = 1700\n    self.vehicle.channels.overrides['5'] = 1700\n    self.vehicle.channels.overrides['6'] = 1700\n    self.vehicle.channels.overrides['7'] = 1700\n    self.vehicle.channels.overrides['8'] = 1700\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: %s\" % self.vehicle.type)\n    print(\"Vehicle ID: %s\" % self.vehicle.id)\n    print(\"Flight mode: %s\" % self.vehicle.mode.name)\n    return target_motion\n\n", "CodeBleu_score": 33.619928887525816}, {"code": "def hover(self)\n\n    # Set the coordinate frame to NED\n    self.vehicle.set_coordinate_frame(mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT)\n\n    # Set the flight mode to hover\n    self.vehicle.mode = VehicleMode(\"HOVER\")\n\n    # Construct a target with the current position and yaw\n    target = LocationGlobalRelative(self.vehicle.location.global_frame.lat,\n                                    self.vehicle.location.global_frame.lon,\n                                    self.vehicle.location.global_frame.alt,\n                                    self.vehicle.attitude.yaw)\n\n    # Set the target\n    self.vehicle.simple_goto(target)\n\n    # Print the vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type: %s\" % self.vehicle.type)\n    print(\"Vehicle ID: %s\" % self.vehicle.id)\n    print(\"Flight mode: %s\" % self.vehicle.mode.name)", "CodeBleu_score": 31.604292187593796}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(custom_mode=self.flight_mode)\n            print('Flight mode switched to ' + self.flight_mode)\n            return True\n        except rospy.ServiceException, e:\n            print('Service call failed: %s'%e)\n            return False\n", "CodeBleu_score": 51.673481316822546}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flightModeService(custom_mode=self.flight_mode)\n            print('Flight mode changed to ' + self.flight_mode)\n            return True\n        except:\n            print('Flight mode change failed')\n            return False\n", "CodeBleu_score": 54.36344202292388}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service(self.flight_mode)\n            print('Flight mode set to: ' + self.flight_mode)\n            return True\n        except rospy.ServiceException:\n            print('Flight mode change failed.')\n            return False\n", "CodeBleu_score": 50.373879688878034}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n", "CodeBleu_score": 56.05767870702787}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n\n", "CodeBleu_score": 55.65560951111508}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.get_total_reward()\n    if self.visualize:\n        self.visualize()\n\n", "CodeBleu_score": 56.05767870702787}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n\n    # Check if the message index matches the UAV ID\n    if msg.index == i:\n        self.local_pose[i] = msg\n\n        # If the GCS command is takeoff, update the takeoff_target_pose\n        if self.gcs_command[i] == \"takeoff\":\n            self.takeoff_target_pose[i] = msg\n\n        # If the GCS command is hover, update the hover_target_pose\n        if self.gcs_command[i] == \"hover\":\n            self.hover_target_pose[i] = msg\n\n        # Update the global_pose for the UAV, applying a bias to the position coordinates\n        self.global_pose[i].pose.position.x = msg.pose.position.x + self.bias_x[i]\n        self.global_pose[i].pose.position.y = msg.pose.position.y + self.bias_y[i]\n        self.global_pose[i].pose.position.z = msg.pose.position.z\n        self.global_pose[i].pose.orientation.x = msg.pose.orientation.x\n        self.global_pose[i].pose.orientation.y = msg.pose.orientation.y\n        self.global_pose[i].pose.orientation.z = msg.pose.orientation.z\n        self.global_pose[i].pose.orientation.w = msg.pose.orientation.w", "CodeBleu_score": 27.65434742964576}, {"code": "def local_pose_callback(self, msg, i)\n    if msg.index == i:\n        self.local_pose[i] = msg\n        if self.ground_control_station[i] == 1:\n            self.takeoff_target_pose[i] = msg\n        elif self.ground_control_station[i] == 2:\n            self.hover_target_pose[i] = msg\n    self.global_pose[i].pose.position.x = msg.pose.position.x + self.global_offset[0]\n    self.global_pose[i].pose.position.y = msg.pose.position.y + self.global_offset[1]\n    self.global_pose[i].pose.position.z = msg.pose.position.z + self.global_offset[2]\n    self.global_pose[i].pose.orientation.x = msg.pose.orientation.x\n    self.global_pose[i].pose.orientation.y = msg.pose.orientation.y\n    self.global_pose[i].pose.orientation.z = msg.pose.orientation.z\n    self.global_pose[i].pose.orientation.w = msg.pose.orientation.w\n    self.global_pose[i].header.stamp = msg.header.stamp\n    self.global_pose[i].header.seq = msg.header.seq\n    self.global_pose[i].header.frame_id = msg.header.frame_id\n\n", "CodeBleu_score": 24.193470254123937}, {"code": "def local_pose_callback(self, msg, i)\n    # Update local pose\n    if msg.index == i:\n        self.local_pose[i] = msg\n\n    # Update takeoff target pose\n    if msg.index == self.takeoff_target_id:\n        self.takeoff_target_pose = msg\n\n    # Update hover target pose\n    if msg.index == self.hover_target_id:\n        self.hover_target_pose = msg\n\n    # Update global pose\n    self.global_pose[i].pose.position.x = msg.pose.position.x + self.global_pose_bias[i][0]\n    self.global_pose[i].pose.position.y = msg.pose.position.y + self.global_pose_bias[i][1]\n    self.global_pose[i].pose.position.z = msg.pose.position.z + self.global_pose_bias[i][2]\n    self.global_pose[i].pose.orientation.x = msg.pose.orientation.x\n    self.global_pose[i].pose.orientation.y = msg.pose.orientation.y\n    self.global_pose[i].pose.orientation.z = msg.pose.orientation.z\n    self.global_pose[i].pose.orientation.w = msg.pose.orientation.w\n\n", "CodeBleu_score": 27.198456009865257}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == \"ARMED\":\n        return True\n    else:\n        return False\n", "CodeBleu_score": 62.705636058786936}, {"code": "def takeoff_detection(self)\n\n    if (self.altitude > 0.2) and (self.arm_state == \"active\"):\n        return True\n    else:\n        return False\n", "CodeBleu_score": 56.996477608692665}, {"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n", "CodeBleu_score": 62.862379601652705}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    # Initialize distance matrix\n    dist_mat = np.zeros((len(orig_formation), len(change_formation)))\n    # Iterate over each pair of UAVs\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            # Calculate distance between UAVs\n            dist = np.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust distance\n            dist = int(50 - dist)\n            # Add adjusted distance to distance matrix\n            dist_mat[i, j] = dist\n    return dist_mat\n\n", "CodeBleu_score": 26.766098800882965}, {"code": "def build_graph(self, orig_formation, change_formation)\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    orig_formation = orig_formation.reshape(orig_formation.shape[0], 1, 2)\n    change_formation = change_formation.reshape(1, change_formation.shape[0], 2)\n    distance_matrix = np.linalg.norm(orig_formation - change_formation, axis=2)\n    distance_matrix = np.subtract(50, distance_matrix)\n    distance_matrix = np.rint(distance_matrix)\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n\n", "CodeBleu_score": 12.984608168850201}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # construct distance matrix\n    dist_mat = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_mat[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n    # adjust distances and convert to integers\n    dist_mat = 50 - dist_mat\n    dist_mat = dist_mat.astype(int)\n    return dist_mat\n\n", "CodeBleu_score": 26.92724564200521}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    # Mark the left vertex as visited\n    self.left[i].visited = True\n    # Iterate through adjacent right vertices\n    for j in self.left[i].adj:\n        # If the right vertex is already visited, continue\n        if self.right[j].visited:\n            continue\n        # Calculate the gap between labels and match weight\n        gap = self.right[j].label - self.left[i].label - self.right[j].match\n        # If the gap is zero, mark the right vertex as visited and check if it can either find a path or update the match\n        if gap == 0:\n            self.right[j].visited = True\n            if self.find_path(self.right[j].match) or self.right[j].match == -1:\n                self.right[j].match = i\n                return True\n        # If the gap is not zero, update the slack value for the right vertex\n        elif self.right[j].slack > gap:\n            self.right[j].slack = gap\n    return False", "CodeBleu_score": 41.46159600111062}, {"code": "def find_path(self, i)\n    self.left_visited[i] = True\n    for j in range(self.n_right):\n        if self.right_visited[j]:\n            continue\n        gap = self.right_labels[j] - self.left_labels[i]\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.right_match[j] == -1 or self.find_path(self.right_match[j]):\n                self.right_match[j] = i\n                return True\n        elif self.slack[j] > gap:\n            self.slack[j] = gap\n    return False\n", "CodeBleu_score": 45.435096481997924}, {"code": "def find_path(self, i)\n    self.left[i] = True\n    for j in range(self.n):\n        if self.right[j] == False and self.G[i][j] > 0:\n            self.right[j] = True\n            if self.match[j] == -1 or self.find_path(self.match[j]):\n                self.match[j] = i\n                return True\n            else:\n                self.right[j] = False\n    return False\n\n", "CodeBleu_score": 35.459733725911455}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n\n    # Initialize slack variables and visit arrays\n    slack = [0] * self.n\n    slack_u = [0] * self.n\n    slack_v = [0] * self.m\n    visit_u = [0] * self.n\n    visit_v = [0] * self.m\n\n    # Initialize path arrays\n    path_u = [0] * self.n\n    path_v = [0] * self.m\n\n    # Initialize path pointers\n    path_u[0] = 0\n    path_v[0] = 0\n\n    # Initialize path count\n    count = 0\n\n    # Iterate over UAVs\n    for u in range(self.n):\n        # Initialize slack variables and visit arrays\n        for v in range(self.m):\n            slack[v] = self.cost[u][v] - self.u_label[u] - self.v_label[v]\n            slack_u[v] = self.cost[u][v] - self.u_label[u] - self.v_label[v]\n            slack_v[v] = self.cost[u][v] - self.u_label[u] - self.v_label[v]\n            visit_u[v] = 0\n            visit_v[v] = 0\n\n        # Initialize path pointers\n        path_u[0] = u\n        path_v[0] = 0\n\n        # Initialize path count\n        count = 0\n\n        # Initialize slack variable\n        slack_min = sys.maxsize\n\n        # Initialize starred zero\n        starred_zero = -1\n\n        # Initialize primed zero\n        primed_zero = -1\n\n        # Initialize done\n        done = False\n\n        # Iterate until done\n        while not done:\n            # Find minimum slack value\n            slack_min = sys.maxsize\n            for v in range(self.m):\n                if slack[v] < slack_min and not visit_v[v]:\n                    slack_min = slack[v]\n\n            # Iterate over", "CodeBleu_score": 27.449266908077334}, {"code": "def KM(self)\n\n    # Initialize slack variables\n    slack = {}\n    for i in self.graph.keys():\n        for j in self.graph[i]:\n            slack[j] = 0\n\n    # Initialize visit arrays\n    visitedU = [0] * self.numUAVs\n    visitedV = [0] * self.numVehicles\n\n    # Iterate over UAVs\n    for u in range(self.numUAVs):\n        # Reset visit arrays\n        for i in range(self.numUAVs):\n            visitedU[i] = 0\n        for j in range(self.numVehicles):\n            visitedV[j] = 0\n\n        # Find path\n        path = self.find_path(u, visitedU, visitedV, slack)\n        if path:\n            for i in range(0, len(path), 2):\n                self.matchU[path[i]] = path[i+1]\n                self.matchV[path[i+1]] = path[i]\n\n    # Return match results\n    return self.matchV\n", "CodeBleu_score": 23.419376951382176}, {"code": "def KM(self)\n\n    # Initialize slack variables\n    self.slack = [0 for i in range(self.n)]\n\n    # Initialize arrays for keeping track of visited vertices\n    self.visited_left = [0 for i in range(self.n)]\n    self.visited_right = [0 for i in range(self.n)]\n\n    # Initialize arrays for keeping track of the path\n    self.path_left = [0 for i in range(self.n)]\n    self.path_right = [0 for i in range(self.n)]\n\n    # Initialize the matching\n    self.matching = [0 for i in range(self.n)]\n\n    # Initialize the matching\n    for i in range(self.n):\n        self.matching[i] = -1\n\n    # Initialize the matching\n    for i in range(self.n):\n        for j in range(self.n):\n            self.slack[j] = self.cost[i][j]\n\n    # Iterate over UAVs\n    for i in range(self.n):\n        # Reset visited arrays\n        self.visited_left = [0 for i in range(self.n)]\n        self.visited_right = [0 for i in range(self.n)]\n\n        # Reset path arrays\n        self.path_left = [0 for i in range(self.n)]\n        self.path_right = [0 for i in range(self.n)]\n\n        # Find path\n        self.path(i)\n\n    # Return the matching\n    return self.matching\n\n", "CodeBleu_score": 26.047860339916255}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the Yellow color range and create a mask\n    lower = np.array([20, 100, 100])\n    upper = np.array([40, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 33.5902581422402}, {"code": "def yellow_dectection(image)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.array([20, 100, 100])\n    upper = np.array([40, 255, 255])\n    mask = cv2.inRange(hsv, lower, upper)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 37.41750194400123}, {"code": "def yellow_dectection(image)\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the Yellow color range and create a mask\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([50, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n    return res\n\n", "CodeBleu_score": 29.537592895953964}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription\t// Check if the tag description exists\n\tauto it = standalone_tag_descriptions_.find(tag_id);\n\tif (it != standalone_tag_descriptions_.end()) {\n\t\tdescriptionContainer = it->second;\n\t\treturn true;\n\t} else {\n\t\tif (printWarning) {\n\t\t\tROS_WARN(\"Tag description for tag ID %d was not found. Please add the tag to the list of standalone tag descriptions.\", tag_id);\n\t\t}\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 39.30536165552232}, {"code": "bool TagDetector::findStandaloneTagDescription  // Check if the tag is in the standalone_tag_descriptions_ map\n  std::map<int, TagDescription>::iterator it = standalone_tag_descriptions_.find(tag_id);\n\n  // If the tag is not in the map, print a warning\n  if (it == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN(\"Tag %d is not in the standalone_tag_descriptions_ map.\", tag_id);\n    }\n    return false;\n  }\n\n  // If the tag is in the map, set the descriptionContainer to the tag's description and return true\n  descriptionContainer = it->second;\n  return true;\n}\n", "CodeBleu_score": 44.70212713698953}, {"code": "bool TagDetector::findStandaloneTagDescription  // Check if the standalone tag description is in the map\n  auto it = standalone_tag_descriptions_.find(id);\n  if (it == standalone_tag_descriptions_.end()) {\n    if (printWarning) {\n      ROS_WARN(\"[%s] Standalone tag description with ID %d not found.\", ros::this_node::getName().c_str(), id);\n    }\n    return false;\n  }\n\n  // Set the description container to the tag's description\n  descriptionContainer = it->second;\n  return true;\n}\n", "CodeBleu_score": 42.44979092080714}]}
