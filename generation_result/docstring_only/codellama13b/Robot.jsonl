{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> files;\n    std::string path = folder + \"/required_files.txt\";\n    std::ifstream file(path);\n    if (!file.is_open()) {\n        std::cout << \"Could not open required_files.txt\" << std::endl;\n        return files;\n    }\n    std::string line;\n    while (std::getline(file, line)) {\n        if (download) {\n            if (CheckFile(folder, line)) {\n                std::cout << \"File found in cache: \" << line << std::endl;\n            } else {\n                std::cout << \"File not found in cache: \" << line << std::endl;\n                std::cout << \"Downloading file: \" << line << std::endl;\n                DownloadFile(folder, line);\n            }\n        }\n        files.push_back(line);\n    }\n    return files;\n}\n", "CodeBleu_score": 43.73118460178013}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> files;\n\n    // Get a list of all files in the folder\n    std::vector<std::string> fileList = GetFileList(folder);\n\n    // Iterate through each file\n    for (const auto &file : fileList) {\n        std::string filePath = folder + file;\n\n        // If the file is a directory, skip it\n        if (IsDirectory(filePath)) {\n            continue;\n        }\n\n        // If the file is not found, request it\n        if (download && !IsFile(filePath)) {\n            RequestFile(filePath);\n            Log(filePath + \" not found, downloading...\");\n        }\n        // If the file is found, log that it is in the cache\n        else if (!download) {\n            Log(filePath + \" found in cache.\");\n        }\n\n        // Add the file to the list\n        files.push_back(filePath);\n    }\n\n    return files;\n}\n", "CodeBleu_score": 44.61102241208487}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const  std::vector<std::string> required_files;\n  std::vector<std::string> files;\n  std::vector<std::string> file_names;\n  std::string file_name;\n\n  // Get the list of files in the specified folder.\n  files = GetFiles(folder);\n\n  // Get the list of file names in the specified folder.\n  for (auto file : files) {\n    file_name = file.substr(file.find_last_of(\"/\\\\\") + 1);\n    file_names.push_back(file_name);\n  }\n\n  // Check if each file exists locally.\n  for (auto file_name : file_names) {\n    if (download) {\n      if (std::filesystem::exists(file_name)) {\n        Log(std::string(\"File found in cache: \") + file_name, Logger::Level::INFO);\n      } else {\n        Log(std::string(\"File not found in cache: \") + file_name, Logger::Level::INFO);\n        required_files.push_back(file_name);\n      }\n    } else {\n      required_files.push_back(file_name);\n    }\n  }\n\n  return required_files;\n}\n", "CodeBleu_score": 46.23986205544517}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  // Check if the parent actor is valid.\n  if (parent != rpc::ActorId()) {\n    if (GetActorById(parent) == nullptr) {\n      throw std::runtime_error(\n          \"Cannot spawn actor with parent that does not exist\");\n    }\n  }\n\n  // Check if the provided attachment type is valid.\n  if (attachment_type != rpc::AttachmentType::Rigid &&\n      attachment_type != rpc::AttachmentType::SpringArm &&\n      attachment_type != rpc::AttachmentType::SpringArmGhost) {\n    throw std::runtime_error(\"Invalid attachment type\");\n  }\n\n  // Check if the provided transform is valid for the given attachment type.\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.location.x != 0.0f || transform.location.y != 0.0f ||\n        transform.location.z == 0.0f) {\n      log_warning(\n          \"SpringArm attachment type requires a transform with only translation \"\n          \"in the z-axis. The provided transform will be ignored.\");\n    }\n  }\n\n  // Spawn the actor.\n  rpc::Actor actor = _client.SpawnActor(description, transform);\n  if (parent != rpc::ActorId()) {\n    AttachActors(actor.id(), parent, attachment_type, socket_name);\n  }\n\n  return actor;\n}\n", "CodeBleu_score": 51.04031028094068}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)    // check if the parent exists\n    if (!DoesActorExist(parent)) {\n        throw std::runtime_error(\n            \"Attempted to spawn actor with a non-existing parent\");\n    }\n\n    // check if the parent is a vehicle\n    if (GetActorType(parent) == rpc::ActorType::Vehicle) {\n        throw std::runtime_error(\n            \"Attempted to spawn actor as child of a vehicle\");\n    }\n\n    // check if the parent is a walker\n    if (GetActorType(parent) == rpc::ActorType::Walker) {\n        throw std::runtime_error(\n            \"Attempted to spawn actor as child of a walker\");\n    }\n\n    // check if the parent is a traffic sign\n    if (GetActorType(parent) == rpc::ActorType::TrafficSign) {\n        throw std::runtime_error(\n            \"Attempted to spawn actor as child of a traffic sign\");\n    }\n\n    // check if the parent is a traffic light\n    if (GetActorType(parent) == rpc::ActorType::TrafficLight) {\n        throw std::runtime_error(\n            \"Attempted to spawn actor as child of a traffic light\");\n    }\n\n    // check if the parent is a vehicle\n    if (GetActorType(parent) == rpc::ActorType::Vehicle) {\n        throw std::runtime_error(\n            \"Attempted to spawn actor as child of a vehicle\");\n    }\n\n    // check if the parent is a walker\n    if (GetActorType(parent) == rpc::ActorType::Walker) {\n        throw std::runtime_error(\n            \"Attempted to spawn actor as child of a walker\");\n    }\n\n    // check if the parent is a traffic sign\n    if (GetActorType(parent) == rpc::ActorType::TrafficSign) {\n        throw std::runtime_error(\n            \"Attempted to spawn actor as child of a traffic sign\");\n    }\n\n    // check if the parent is a traffic light\n    if (GetActor", "CodeBleu_score": 29.96220356155509}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)    // Check if the parent is valid.\n    if (parent != 0u && !DoesActorExist(parent)) {\n        throw std::runtime_error(\n            \"SpawnActorWithParent: parent actor id does not exist\");\n    }\n\n    // Check if the attachment type is valid.\n    if (attachment_type != rpc::AttachmentType::Rigid &&\n        attachment_type != rpc::AttachmentType::SpringArm &&\n        attachment_type != rpc::AttachmentType::SpringArmGhost) {\n        throw std::runtime_error(\n            \"SpawnActorWithParent: attachment type is not valid\");\n    }\n\n    // Check if the attachment type is SpringArm or SpringArmGhost.\n    if (attachment_type == rpc::AttachmentType::SpringArm ||\n        attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        // Check if the translation is only in the 'z' axis.\n        if (transform.location.x != 0.0f ||\n            transform.location.y != 0.0f ||\n            transform.location.z == 0.0f) {\n            LOG_WARNING(\n                \"SpawnActorWithParent: the translation of the provided \"\n                \"transformation is only in the 'z' axis, which is not \"\n                \"allowed for attachment type SpringArm or SpringArmGhost. \"\n                \"The actor will be spawned but its transformation will be \"\n                \"ill-formed.\");\n        }\n    }\n\n    // Call the internal function to spawn the actor.\n    return SpawnActorInternal(\n        description, transform, parent, attachment_type, socket_name);\n}\n", "CodeBleu_score": 48.64004768602593}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)  // Get a token for the G-buffer.\n  auto token = GetToken(ActorId, GBufferId);\n\n  // Copy the token data.\n  Buffer token_data;\n  token_data.data.resize(token.size());\n  memcpy(token_data.data.data(), token.data(), token.size());\n\n  // Subscribe to the streaming client using the provided callback function.\n  SubscribeToStream(token_data, callback);\n}\n", "CodeBleu_score": 42.85393954045505}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)  // Get the token for the G-buffer.\n  auto token = GetGBufferToken(ActorId, GBufferId);\n\n  // Copy the token data.\n  Buffer buffer;\n  buffer.Data = token.Data;\n  buffer.Size = token.Size;\n\n  // Subscribe to the streaming client using the provided callback function.\n  SubscribeToStreamingClient(buffer, callback);\n}\n", "CodeBleu_score": 36.08100584482781}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)    if (ActorId.IsEmpty() || GBufferId == 0) {\n        callback(Buffer());\n        return;\n    }\n\n    // Retrieve the token for the G-buffer.\n    std::string token;\n    if (!GetToken(ActorId, GBufferId, token)) {\n        callback(Buffer());\n        return;\n    }\n\n    // Copy the token data.\n    Buffer token_data(token.begin(), token.end());\n\n    // Subscribe to the streaming client using the provided callback function.\n    SubscribeToStreamingClient(ActorId, GBufferId, token_data, callback);\n}\n", "CodeBleu_score": 44.08298965096697}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()    if (!navigation) {\n        navigation = WalkerNavigation::Create(this);\n    }\n    return navigation;\n}\n", "CodeBleu_score": 18.558572147308073}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()    // If the navigation object is null, create it\n    if (Navigation == nullptr) {\n        Navigation = std::make_shared<WalkerNavigation>();\n    }\n\n    // Return the navigation object\n    return Navigation;\n}\n", "CodeBleu_score": 28.35295686400509}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()    if (this->Navigation == nullptr) {\n        this->Navigation = std::make_shared<WalkerNavigation>(this);\n    }\n    return this->Navigation;\n}\n", "CodeBleu_score": 17.018997922494677}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)    using namespace std::chrono;\n    auto start_time = steady_clock::now();\n    while (episode.GetCurrentFrame() < frame) {\n        if (steady_clock::now() - start_time > timeout) {\n            return false;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n    episode.Lock()->GetTrafficManager()->Tick();\n    return true;\n}\n", "CodeBleu_score": 40.35547632288091}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  const auto start_time = std::chrono::system_clock::now();\n  const auto end_time = start_time + timeout;\n  while (episode.GetCurrentFrame() < frame) {\n    if (std::chrono::system_clock::now() > end_time) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  episode.Lock()->GetTrafficManager()->Tick();\n  return true;\n}\n", "CodeBleu_score": 44.24808706413117}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  using std::chrono::duration_cast;\n  using std::chrono::milliseconds;\n  using std::chrono::steady_clock;\n\n  const auto start_time = steady_clock::now();\n\n  while (episode.GetCurrentFrame() < frame) {\n    if (duration_cast<milliseconds>(steady_clock::now() - start_time) > timeout) {\n      return false;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  }\n\n  episode.Lock()->GetTrafficManager()->SetSynchronousMode(true);\n  return true;\n}\n", "CodeBleu_score": 48.384755018028805}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  rpc::LoadEpisodeRequest request;\n  request.set_map_name(map_name);\n  request.set_reset_settings(reset_settings);\n  request.set_map_layers(map_layers);\n  rpc::LoadEpisodeResponse response;\n  client.call(\"simulator_load_episode\", request, response);\n  return EpisodeProxy(client, response.episode_id());\n}\n", "CodeBleu_score": 26.905102796928617}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)    rpc::LoadEpisodeRequest request;\n    request.set_map_name(map_name);\n    request.set_reset_settings(reset_settings);\n    request.set_map_layers(map_layers);\n\n    rpc::LoadEpisodeResponse response;\n    client.call(\"Simulator.LoadEpisode\", request, response);\n\n    if (response.status() != rpc::LoadEpisodeResponse::Success) {\n        throw std::runtime_error(\"Simulator::LoadEpisode: \" + response.error_message());\n    }\n\n    return EpisodeProxy(response.episode_id());\n}\n", "CodeBleu_score": 29.980591635679115}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map is already loaded\n  // TODO: Check if the map", "CodeBleu_score": 3.4021653290208267}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  // Retrieve the walker associated with the controller\n  auto walker = GetWalker(controller.GetId());\n  if (!walker) {\n    throw std::runtime_error(\"Walker not found for AI controller: \" + controller.GetId());\n  }\n\n  // Assert that the episode is not null\n  if (!episode_) {\n    throw std::runtime_error(\"Episode is null\");\n  }\n\n  // Create navigation if it is missing\n  if (!episode_->GetNavigation()) {\n    episode_->SetNavigation(std::make_unique<carla::client::detail::NavigationImpl>(episode_->GetCurrentMap()));\n  }\n\n  // Register the walker with the controller's ID\n  episode_->RegisterWalker(walker, controller.GetId());\n}\n", "CodeBleu_score": 49.776971452555365}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  Walker *walker = GetWalker(controller.GetWalkerId());\n  if (!walker) {\n    throw std::invalid_argument(\n        \"Simulator::RegisterAIController: walker not found\");\n  }\n  if (!episode_) {\n    throw std::invalid_argument(\n        \"Simulator::RegisterAIController: episode is null\");\n  }\n  if (!walker->GetNavigation()) {\n    walker->SetNavigation(new Navigation());\n  }\n  walker->GetNavigation()->RegisterController(controller.GetId());\n}\n", "CodeBleu_score": 40.70511459200259}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  Walker *walker = GetWalker(controller.GetWalkerId());\n  if (!walker) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n\n  assert(episode_ != nullptr);\n  if (!episode_->navigation) {\n    episode_->navigation = new Navigation();\n  }\n  episode_->navigation->controllers.push_back(controller);\n}\n", "CodeBleu_score": 44.6267401449397}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  ActorId id = _episode->RegisterActor(\n      _episode->SpawnActor(blueprint, transform, parent, attachment_type, socket_name));\n  _episode->SetGarbageCollectionPolicy(id, gc);\n  return _episode->GetActorById(id);\n}\n", "CodeBleu_score": 26.677791929956822}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)    // Check if the blueprint is valid\n    if (!blueprint.IsValid()) {\n        throw std::invalid_argument(\"The actor blueprint is not valid\");\n    }\n\n    // Check if the transform is valid\n    if (!transform.is_valid()) {\n        throw std::invalid_argument(\"The actor transform is not valid\");\n    }\n\n    // Check if the parent is valid\n    if (parent != nullptr) {\n        if (parent->GetEpisode() != this->GetCurrentEpisode()) {\n            throw std::invalid_argument(\"The parent actor is not valid\");\n        }\n    }\n\n    // Check if the attachment type is valid\n    if (attachment_type != rpc::AttachmentType::Rigid &&\n        attachment_type != rpc::AttachmentType::SpringArm) {\n        throw std::invalid_argument(\"The attachment type is not valid\");\n    }\n\n    // Check if the garbage collection policy is valid\n    if (gc != GarbageCollectionPolicy::Inherit &&\n        gc != GarbageCollectionPolicy::Enabled &&\n        gc != GarbageCollectionPolicy::Disabled) {\n        throw std::invalid_argument(\"The garbage collection policy is not valid\");\n    }\n\n    // Create the request object\n    rpc::SpawnActorRequest request;\n    request.set_actor_type(blueprint.GetType());\n    request.set_blueprint_id(blueprint.GetId());\n    request.mutable_transform()->CopyFrom(transform.to_proto());\n    if (parent != nullptr) {\n        request.set_parent_id(parent->GetId());\n        request.set_attachment_type(attachment_type);\n        request.set_attachment_socket_name(socket_name);\n    }\n    request.set_auto_attach_parent(blueprint.GetAutoAttachParent());\n    request.set_auto_attach_children(blueprint.GetAutoAttachChildren());\n    request.set_enable_gcs(gc == GarbageCollectionPolicy::Enabled);\n\n    // Send the request\n    rpc::SpawnActorResponse response;\n    if (!this->_client.call(\"spawn_actor\", request, response", "CodeBleu_score": 41.20891512081906}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)\n  // Create the actor\n  auto actor = GetCurrentEpisode().SpawnActor(blueprint, transform);\n\n  // Register the actor in the current episode\n  GetCurrentEpisode().RegisterActor(actor);\n\n  // Apply the appropriate garbage collection policy\n  ApplyGarbageCollectionPolicy(actor, gc);\n\n  // Log the actor creation\n  LogActorCreation(actor, blueprint, parent, attachment_type, socket_name);\n\n  return actor;\n}\n", "CodeBleu_score": 30.867080051182693}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (!Episode->IsValid()) {\n    throw std::runtime_error(\n        \"Trying to subscribe to sensor in invalid episode\");\n  }\n  auto stream = sensor.GetCurrentEpisode().Lock()->SubscribeToStream(\n      sensor.GetStream());\n  if (stream == nullptr) {\n    throw std::runtime_error(\"Trying to subscribe to invalid sensor\");\n  }\n  stream->Listen([this, callback](SharedPtr<sensor::SensorData> data) {\n    // Associate the sensor data with the current episode\n    data->SetEpisode(Episode);\n    // Invoke the callback\n    callback(data);\n  });\n}\n", "CodeBleu_score": 44.22646283139574}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)    if (sensor.GetEpisode().Lock() != _episode.Lock()) {\n        throw std::invalid_argument(\n                \"the sensor is not part of this episode\");\n    }\n    _client.SubscribeToStream(\n            sensor.GetDataStreamName(),\n            [this, callback](SharedPtr<sensor::SensorData> data) {\n                SharedPtr<Episode> episode = _episode.Lock();\n                if (episode != nullptr) {\n                    data->SetEpisode(episode);\n                    callback(data);\n                }\n            });\n}\n", "CodeBleu_score": 40.19473643899804}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)    if (sensor.GetEpisode().lock() != episode_) {\n        throw std::invalid_argument(\"Sensor is not part of this episode\");\n    }\n    if (sensor.GetEpisode().lock()->GetSimulator().lock() != shared_from_this()) {\n        throw std::invalid_argument(\"Sensor is not part of this episode\");\n    }\n    if (!sensor.IsListening()) {\n        sensor.Listen(true);\n    }\n    sensor_data_callbacks_.insert(std::make_pair(sensor.GetSensorHandle(), callback));\n}\n", "CodeBleu_score": 31.506115652673262}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    // Get current walkers\n    const auto walkers = episode->GetPopulation();\n    if (walkers.size() == 0) {\n        return;\n    }\n\n    // Remove any walkers that no longer exist\n    RemoveDeadWalkers(episode);\n\n    // Update vehicles in crowd and crowd itself\n    UpdateVehicles(episode);\n\n    // Update states in simulator\n    UpdateWalkers(episode);\n\n    // Remove dead walkers\n    RemoveDeadWalkers(episode);\n}\n", "CodeBleu_score": 15.622758145342466}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    // Load the current walkers\n    std::vector<ActorId> walker_ids = episode->GetActorsByFilter(\n        [](const auto &x) { return x.second->GetActorType() == ActorType::Vehicle && x.second->GetActorId() != 0; });\n\n    // Return if no walkers\n    if (walker_ids.empty()) {\n        return;\n    }\n\n    // Get the current state of the episode\n    const auto episode_state = episode->GetState();\n\n    // Remove any walkers that no longer exist\n    for (auto it = walker_states.begin(); it != walker_states.end();) {\n        if (std::find(walker_ids.begin(), walker_ids.end(), it->first) == walker_ids.end()) {\n            it = walker_states.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    // Update the vehicles in the crowd and the crowd itself in the navigation module\n    navigation_module->Update(episode_state);\n\n    // Get the transform and speed for each walker\n    std::vector<std::pair<carla::geom::Transform, float>> walker_transforms_speed;\n    for (auto &walker_id : walker_ids) {\n        auto walker = episode_state.GetActorById(walker_id);\n        walker_transforms_speed.push_back(std::make_pair(walker->GetTransform(), walker->GetVelocity().Length()));\n    }\n\n    // Apply these states in a batch to the simulator\n    client->ApplyBatch(\n        [&](auto &client) {\n            for (auto &walker_id : walker_ids) {\n                auto walker = episode_state.GetActorById(walker_id);\n                auto walker_state = walker_states.find(walker_id);\n\n                // If the walker is not in the map, add it\n                if (walker_state == walker_states.end()) {\n                    walker_state = walker_states.", "CodeBleu_score": 43.34893678882826}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    // get current walkers\n    std::vector<std::shared_ptr<Walker>> walkers = episode->GetWalkers();\n    // check if the list is empty\n    if (walkers.size() == 0) {\n        return;\n    }\n    // get current state of episode\n    std::vector<std::shared_ptr<carla::rpc::Actor>> actors = episode->GetActors();\n    // remove any walkers that no longer exist\n    for (auto it = walkers.begin(); it != walkers.end();) {\n        auto walker = *it;\n        bool found = false;\n        for (auto actor : actors) {\n            if (actor->GetId() == walker->GetId()) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            it = walkers.erase(it);\n        } else {\n            ++it;\n        }\n    }\n    // update vehicles in crowd\n    for (auto walker : walkers) {\n        // get transform\n        carla::geom::Transform transform = walker->GetTransform();\n        // get speed\n        float speed = walker->GetSpeed();\n        // apply to crowd\n        _crowd->updateVehicle(walker->GetId(), transform.location, transform.rotation.yaw, speed);\n    }\n    // update crowd\n    _crowd->update(0.016f, _crowd_max_speed);\n    // for each walker\n    for (auto walker : walkers) {\n        // get transform\n        carla::geom::Transform transform = walker->GetTransform();\n        // get speed\n        float speed = walker->GetSpeed();\n        // apply to simulator\n        episode->SetWalkerTransform(walker, transform);\n        episode->SetWalkerSpeed(walker, speed);\n    }\n    // check if any walker has been killed\n    for (auto it = walkers.begin(); it != walkers.end();) {\n        auto walker = *it;\n        bool found = false;\n        for (auto actor : actors) {\n            if (", "CodeBleu_score": 44.53164236803391}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription actor_description;\n  actor_description.set_uid(uid);\n  actor_description.set_id(id);\n  actor_description.mutable_attributes()->Reserve(attributes.size());\n  for (auto &attribute : attributes) {\n    actor_description.add_attributes()->CopyFrom(attribute);\n  }\n  return actor_description;\n}\n", "CodeBleu_score": 55.99837143524839}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription actor_description;\n  actor_description.set_uid(GetActorId());\n  actor_description.set_id(GetActorClass().GetId());\n  for (const auto& attribute : GetAttributes()) {\n    actor_description.mutable_attributes()->insert(\n        {attribute.first, attribute.second});\n  }\n  return actor_description;\n}\n", "CodeBleu_score": 49.41562105081576}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription actor_description;\n  actor_description.set_uid(GetActorUID());\n  actor_description.set_id(GetActorId());\n\n  // Reserve space for the attributes.\n  actor_description.mutable_attributes()->Reserve(GetNumAttributes());\n\n  // Copy the attributes.\n  for (auto it = Attributes.begin(); it != Attributes.end(); ++it) {\n    actor_description.mutable_attributes()->Add(it->second);\n  }\n\n  return actor_description;\n}\n", "CodeBleu_score": 50.54853338273659}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const    SharedPtr<BlueprintLibrary> result = make_shared<BlueprintLibrary>();\n\n    for (auto it = blueprints.begin(); it != blueprints.end(); it++) {\n        auto blueprint = *it;\n\n        auto attributes = blueprint->GetAttributes();\n        auto attribute = attributes.find(name);\n        if (attribute != attributes.end()) {\n            if (attribute->second.value == value) {\n                result->blueprints.push_back(blueprint);\n            }\n            else {\n                for (auto it = attribute->second.recommendedValues.begin(); it != attribute->second.recommendedValues.end(); it++) {\n                    if (*it == value) {\n                        result->blueprints.push_back(blueprint);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}\n", "CodeBleu_score": 56.44617041399742}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  SharedPtr<BlueprintLibrary> result = make_shared<BlueprintLibrary>();\n  for (auto &blueprint : blueprints_) {\n    if (blueprint->HasAttribute(name)) {\n      if (blueprint->GetAttribute(name)->HasValue(value)) {\n        result->AddBlueprint(blueprint);\n      }\n    }\n  }\n  return result;\n}\n", "CodeBleu_score": 31.411299191291903}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const    SharedPtr<BlueprintLibrary> result(new BlueprintLibrary());\n    for (auto it = blueprints.begin(); it != blueprints.end(); it++) {\n        SharedPtr<Blueprint> blueprint = *it;\n        if (blueprint->HasAttribute(name)) {\n            std::vector<std::string> values = blueprint->GetAttribute(name);\n            if (std::find(values.begin(), values.end(), value) != values.end()) {\n                result->blueprints.push_back(blueprint);\n            }\n        }\n    }\n    return result;\n}\n", "CodeBleu_score": 48.61064749126452}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string fullPath = path;\n    if (!ValidateFilePath(fullPath)) {\n        return false;\n    }\n\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    file.write((char *)&content[0], content.size());\n    file.close();\n\n    return true;\n}\n", "CodeBleu_score": 45.947583388496504}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullPath = GetFullPath(path);\n\tstd::ofstream file(fullPath, std::ios::out | std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.write((char*)content.data(), content.size());\n\tfile.close();\n\treturn true;\n}\n", "CodeBleu_score": 38.377235485138506}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string fullPath = path;\n    if (!ValidatePath(fullPath)) {\n        return false;\n    }\n\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (!file.is_open()) {\n        return false;\n    }\n\n    file.write(reinterpret_cast<const char*>(content.data()), content.size());\n    file.close();\n\n    return true;\n}\n", "CodeBleu_score": 46.17341322581241}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const    // Get the parent bounding box\n    const auto parent_bounds = GetParentBounds(frame);\n\n    // Get the location of the parent bounding box\n    const auto parent_location = parent_bounds->GetLocation();\n\n    // Get the transform of the parent bounding box\n    const auto parent_transform = parent_bounds->GetTransform();\n\n    // Get the transform of the child bounding box\n    const auto child_transform = transform;\n\n    // Calculate the location of the child bounding box\n    const auto child_location = parent_location + parent_transform.GetLocation() + child_transform.GetLocation();\n\n    // Create a vector of the child's extents\n    const auto child_extents = geom::Vector3D(child_transform.GetExtents().x, child_transform.GetExtents().y, 0.0);\n\n    // Create a vector of the child's extents rotated by the yaw angle\n    const auto rotated_child_extents = geom::Rotate2D(child_extents, child_transform.GetRotation().GetYaw());\n\n    // Calculate the location of the child's corners\n    const auto child_corners = geom::Vector3DArray{\n      child_location + rotated_child_extents,\n      child_location - rotated_child_extents,\n      child_location + rotated_child_extents.Rotate(geom::Vector2D(0.0, M_PI)),\n      child_location - rotated_child_extents.Rotate(geom::Vector2D(0.0, M_PI))\n    };\n\n    // Create a shared pointer to a Bounds object containing the frame number and the calculated corners\n    const auto bounds = std::make_shared<const Bounds>(frame, child_corners);\n\n    return bounds;\n  }\n\n  /*\n   * This function, LaneInvasionCallback::GetParentBounds, returns a shared pointer to a Bounds object containing the parent's frame number and the location of the parent's bounding box corners.\n   */\n  std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::GetParentBounds(", "CodeBleu_score": 30.061354391200034}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  // Get the parent's bounding box.\n  const auto parent_bounds = GetParentBounds(frame);\n  // Create a new Bounds object.\n  auto bounds = std::make_shared<const Bounds>();\n  // Set the frame number.\n  bounds->frame = frame;\n  // Get the parent's bounding box location.\n  const auto &location = parent_bounds->location;\n  // Get the transform's location.\n  const auto &transform_location = transform.location;\n  // Add the parent's bounding box location to the transform's location.\n  const auto location_x = location.x + transform_location.x;\n  const auto location_y = location.y + transform_location.y;\n  const auto location_z = location.z + transform_location.z;\n  // Set the Bounds' location.\n  bounds->location = geom::Location{location_x, location_y, location_z};\n  // Get the parent's bounding box extents.\n  const auto &extents = parent_bounds->extents;\n  // Get the transform's rotation.\n  const auto &rotation = transform.rotation;\n  // Get the yaw angle.\n  const auto yaw = rotation.yaw;\n  // Calculate the length of the diagonal of the parent's bounding box.\n  const auto diagonal = std::sqrt(std::pow(extents.x, 2.0) + std::pow(extents.y, 2.0));\n  // Calculate the length of the diagonal of the bounding box after rotation.\n  const auto diagonal_rotated = std::abs(diagonal * std::cos(yaw));\n  // Calculate the length of the side of the bounding box after rotation.\n  const auto side_rotated = diagonal * std::sin(yaw);\n  // Calculate the length of the side of the bounding box before rotation.\n  const auto side = std::abs(extents.y);\n  // Calculate the length of the diagonal of the bounding box before rotation.\n  const auto diagonal_before_rotation = std::sqrt(std::pow(extents.x, 2.0) + std::", "CodeBleu_score": 37.46848816078002}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const    // Get the parent's bounding box\n    const auto parent_bounds = parent_->GetBounds(frame);\n    // Get the transform's location\n    const auto location = transform.location;\n    // Get the transform's yaw angle\n    const auto yaw = transform.rotation.yaw;\n    // Get the parent's bounding box extents\n    const auto extents = parent_bounds->extents;\n    // Create a new bounding box with the same frame number as the parent\n    Bounds bounds{parent_bounds->frame, {}};\n    // Get the first corner of the parent's bounding box\n    const auto &p1 = parent_bounds->corners[0];\n    // Get the second corner of the parent's bounding box\n    const auto &p2 = parent_bounds->corners[1];\n    // Get the third corner of the parent's bounding box\n    const auto &p3 = parent_bounds->corners[2];\n    // Get the fourth corner of the parent's bounding box\n    const auto &p4 = parent_bounds->corners[3];\n    // Get the first corner of the child's bounding box\n    const auto c1 = geom::Rotate2D(p1, location, yaw);\n    // Get the second corner of the child's bounding box\n    const auto c2 = geom::Rotate2D(p2, location, yaw);\n    // Get the third corner of the child's bounding box\n    const auto c3 = geom::Rotate2D(p3, location, yaw);\n    // Get the fourth corner of the child's bounding box\n    const auto c4 = geom::Rotate2D(p4, location, yaw);\n    // Add the child's bounding box corners to the child's bounding box\n    bounds.corners.push_back(c1);\n    bounds.corners.push_back(c2);\n    bounds.corners.push_back(c3);\n    bounds.corners.push_back(c4);\n    // Return the child's bounding box\n    return std::make_shared<const B", "CodeBleu_score": 46.849557744292284}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()\t// Lock the mutex\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Get the light states from the server\n\tstd::vector<LightState> lightStates = _lightsServer->GetLightsState();\n\n\t// Iterate through the light states\n\tfor (LightState lightState : lightStates) {\n\t\t// Get the light id\n\t\tint lightId = lightState.GetLightId();\n\n\t\t// Get the light object from the map\n\t\tLight* light = _lights[lightId];\n\n\t\t// If the light does not exist, create a new light\n\t\tif (light == nullptr) {\n\t\t\t// Create a new light object\n\t\t\tlight = new Light(lightId);\n\n\t\t\t// Add the light object to the map\n\t\t\t_lights[lightId] = light;\n\t\t}\n\n\t\t// Update the light object\n\t\tlight->Update(lightState);\n\t}\n}\n", "CodeBleu_score": 31.48761588288852}, {"code": "void LightManager::QueryLightsStateToServer()\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\tstd::vector<Light> lights = _client.GetLightsState();\n\n\tfor (int i = 0; i < lights.size(); i++) {\n\t\tif (_lights.find(lights[i].GetId()) != _lights.end()) {\n\t\t\t_lights[lights[i].GetId()]->SetLightState(lights[i]);\n\t\t}\n\t\telse {\n\t\t\t_lights[lights[i].GetId()] = std::make_shared<Light>(lights[i]);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 26.658844140259795}, {"code": "void LightManager::QueryLightsStateToServer()    // Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex> lock(_lights_mutex);\n\n    // Create the JSON request\n    json request = {\n        {\"type\", \"query_lights\"},\n        {\"id\", _id}\n    };\n\n    // Send the request to the server\n    std::string response = _server.SendMessage(request.dump());\n\n    // Parse the JSON response\n    json parsed_response = json::parse(response);\n\n    // Check if the request was successful\n    if (parsed_response[\"success\"] != true) {\n        // Print the error message\n        std::cout << \"Failed to query lights state from server: \" << parsed_response[\"error\"] << std::endl;\n\n        // Exit the function\n        return;\n    }\n\n    // Get the lights from the response\n    json lights = parsed_response[\"lights\"];\n\n    // Iterate over the lights\n    for (json::iterator it = lights.begin(); it != lights.end(); ++it) {\n        // Get the light id\n        std::string light_id = it.key();\n\n        // Check if the light already exists in the _lights map\n        if (_lights.find(light_id) != _lights.end()) {\n            // Get the light from the map\n            Light *light = _lights[light_id];\n\n            // Update the light\n            light->Update(it.value());\n        } else {\n            // Create a new light\n            Light *light = new Light(it.value());\n\n            // Add the light to the _lights map\n            _lights[light_id] = light;\n        }\n    }\n}\n", "CodeBleu_score": 40.13325110356815}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)    if (dirty) {\n        std::lock_guard<std::mutex> lock(mutex);\n        if (dirty) {\n            // Create message\n            std::string message = \"LightsState:\";\n            for (auto& light : lights) {\n                message += light.GetName() + \":\" + std::to_string(light.GetState()) + \",\";\n            }\n            message = message.substr(0, message.size() - 1); // Remove last comma\n\n            // Send message\n            if (discard_client) {\n                server->SendMessage(message, true);\n            } else {\n                server->SendMessage(message);\n            }\n\n            // Clear changes\n            for (auto& light : lights) {\n                light.SetDirty(false);\n            }\n            dirty = false;\n        }\n    }\n}\n", "CodeBleu_score": 40.58148604803164}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)    // Lock the mutex\n    std::lock_guard<std::mutex> lock(m_lights_mutex);\n\n    // If there are no changes, return\n    if (!m_lights_dirty)\n        return;\n\n    // Create the message\n    std::string message = \"{\\\"type\\\":\\\"lights\\\",\\\"data\\\":{\\\"lights\\\":{\";\n\n    // Loop through the lights\n    for (auto it = m_lights.begin(); it != m_lights.end(); it++) {\n        // If it's the first light, don't add a comma\n        if (it == m_lights.begin())\n            message += \"\\\"\" + it->first + \"\\\":\";\n        else\n            message += \",\\\"\" + it->first + \"\\\":\";\n\n        // Add the light's data to the message\n        message += it->second->GetData();\n    }\n\n    // Finish the message\n    message += \"}}\";\n\n    // Send the message to the server\n    if (!discard_client)\n        m_server->SendMessage(message);\n\n    // Clear the changes and reset the dirty flag\n    m_lights_dirty = false;\n}\n", "CodeBleu_score": 40.569325945611375}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)    std::lock_guard<std::mutex> lock(m_mutex);\n    if (m_lights_changed) {\n        if (discard_client) {\n            m_lights_changed = false;\n        }\n        std::vector<Light> lights = GetLights();\n        std::string msg = \"update_lights\";\n        for (auto &light : lights) {\n            msg += \" \" + std::to_string(light.id) + \" \" + std::to_string(light.is_on) + \" \" +\n                   std::to_string(light.brightness) + \" \" + std::to_string(light.red) + \" \" +\n                   std::to_string(light.green) + \" \" + std::to_string(light.blue);\n        }\n        m_client.SendMessage(msg);\n    }\n}\n", "CodeBleu_score": 42.80656984539607}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)    if (GetId() != \"sensor.other.v2x_custom\") {\n        UE_LOG(LogTemp, Warning, TEXT(\"The sensor's ID is not sensor.other.v2x_custom\"));\n        return;\n    }\n    auto episode = GetEpisode();\n    if (episode == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"The sensor's episode is nullptr\"));\n        return;\n    }\n    auto episode_impl = static_cast<CarlaServerEpisode*>(episode);\n    episode_impl->SendMessage(message);\n}\n", "CodeBleu_score": 48.14723696319923}, {"code": "void ServerSideSensor::Send(std::string message)    if (this->id != \"sensor.other.v2x_custom\") {\n        UE_LOG(LogTemp, Warning, TEXT(\"ServerSideSensor::Send: Sensor ID does not match.\"));\n        return;\n    }\n    this->context->Episode->Lock()->SendMessage(this->id, message);\n}\n", "CodeBleu_score": 34.483563286491474}, {"code": "void ServerSideSensor::Send(std::string message)  if (GetSensorId() != \"sensor.other.v2x_custom\") {\n    UE_LOG(LogTemp, Warning, TEXT(\"Sensor ID does not match\"));\n    return;\n  }\n  UE_LOG(LogTemp, Warning, TEXT(\"Sending message to episode\"));\n  GetContext()->Episode->GetCarlaEpisode()->SendSensorData(GetId(), message);\n}\n", "CodeBleu_score": 52.63844602873154}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)    if (enabled) {\n        if (tm_port != 0) {\n            SetTrafficManager(tm_port);\n        }\n        SetActorFlag(7, true);\n    } else {\n        SetActorFlag(7, false);\n        ResetTrafficManager();\n    }\n}\n", "CodeBleu_score": 44.17453364570844}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)  if (enabled) {\n    SetTrafficManager(tm_port);\n  } else {\n    SetTrafficManager(0);\n  }\n}\n", "CodeBleu_score": 36.39087293800494}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)    if (enabled) {\n        this->tm_port = tm_port;\n        this->is_autopilot_enabled = true;\n        this->tm_vehicle = std::make_shared<carla::client::detail::Actor>(\n            this->GetActor(),\n            this->GetClient(),\n            this->GetEpisode());\n        this->tm_vehicle->SetAutopilot(true, tm_port);\n    } else {\n        this->tm_vehicle->SetAutopilot(false, tm_port);\n        this->tm_vehicle->Destroy();\n        this->tm_vehicle = nullptr;\n        this->is_autopilot_enabled = false;\n        this->tm_port = 0;\n    }\n}\n", "CodeBleu_score": 35.54770401395418}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()    Super::Start();\n\n    // Get the Pawn and its mesh component\n    AWalkerPawn* WalkerPawn = Cast<AWalkerPawn>(GetPawn());\n    if (WalkerPawn == nullptr) {\n        UE_LOG(LogTemp, Error, TEXT(\"%s() No Pawn found!\"), *FString(__FUNCTION__));\n        return;\n    }\n\n    // Get the mesh component\n    UMeshComponent* MeshComponent = WalkerPawn->GetMesh();\n    if (MeshComponent == nullptr) {\n        UE_LOG(LogTemp, Error, TEXT(\"%s() No MeshComponent found!\"), *FString(__FUNCTION__));\n        return;\n    }\n\n    // Get the navigation system\n    ANavigationSystem* NavSystem = Cast<ANavigationSystem>(GetWorld()->GetNavigationSystem());\n    if (NavSystem == nullptr) {\n        UE_LOG(LogTemp, Error, TEXT(\"%s() No NavigationSystem found!\"), *FString(__FUNCTION__));\n        return;\n    }\n\n    // Register the walker actor with the navigation system\n    FNavLocation NavLocation;\n    NavLocation.Location = MeshComponent->GetComponentLocation();\n    NavSystem->AddActorToNavigation(WalkerPawn, &NavLocation);\n\n    // Disable the walker actor's physics simulation and collisions\n    WalkerPawn->SetActorEnableCollision(false);\n    WalkerPawn->SetSimulatePhysics(false);\n\n    // Set the walker's target\n    SetWalkerTarget(WalkerPawn);\n}\n", "CodeBleu_score": 39.72910335381711}, {"code": "void WalkerAIController::Start()\tSuper::Start();\n\n\t// Get the Pawn to control\n\tWalker = Cast<AWalker>(GetPawn());\n\tif (!Walker) {\n\t\tUE_LOG(LogTemp, Error, TEXT(\"AIController pawn is not a Walker\"));\n\t\treturn;\n\t}\n\n\t// Get the episode and register the AI controller with it\n\tif (Walker->Episode) {\n\t\tWalker->Episode->RegisterAIController(this);\n\t}\n\n\t// Register the walker with the navigation system\n\tUNavigationSystem::GetCurrent(GetWorld())->AddActorToNavigation(Walker);\n\n\t// Disable physics simulation and collisions for the walker\n\tWalker->SetActorEnableCollision(false);\n\tWalker->SetSimulatePhysics(false);\n}\n", "CodeBleu_score": 34.722654928218674}, {"code": "void WalkerAIController::Start()    Super::Start();\n\n    // Retrieve the walker actor\n    FActorDescription *actorDescription = GetDescription();\n    check(actorDescription != nullptr);\n\n    // Retrieve the walker actor\n    walker = Cast<AWalker>(GetWorld()->SpawnActor(actorDescription->GetClass(), actorDescription->GetLocation(), actorDescription->GetRotation()));\n    check(walker != nullptr);\n\n    // Add the walker to the navigation system\n    UNavigationSystem::GetCurrent(GetWorld())->AddActorToNavigation(walker);\n\n    // Disable the physics simulation and collisions for the walker actor\n    walker->SetActorEnableCollision(false);\n    walker->SetActorTickEnabled(false);\n    walker->SetSimulatePhysics(false);\n}\n", "CodeBleu_score": 40.16663594559298}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)    // Get the current episode\n    FString episode_name = GetWorld()->GetMapName();\n    ACarlaEpisode* episode = UCarlaStatics::GetCurrentEpisode(episode_name);\n    if (episode == nullptr) {\n        UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Episode %s not found!\"), *episode_name);\n        return;\n    }\n\n    // Get the navigation instance\n    ANavigationSystem* navigation = episode->GetNavigationSystem();\n    if (navigation == nullptr) {\n        UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Navigation instance not found!\"));\n        return;\n    }\n\n    // Get the parent walker\n    AWalkerAIController* walker = Cast<AWalkerAIController>(GetPawnOwner());\n    if (walker == nullptr) {\n        UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Parent walker not found!\"));\n        return;\n    }\n\n    // Set the maximum speed\n    if (!navigation->SetWalkerSpeed(walker, max_speed)) {\n        UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController::SetMaxSpeed: Failed to set maximum speed!\"));\n    }\n}\n", "CodeBleu_score": 45.863204464614846}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  if (this->episode_->GetNavigation() == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController: Navigation instance not available\"));\n    return;\n  }\n  auto walker = Cast<ACharacter>(GetPawn());\n  if (walker == nullptr) {\n    UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController: Pawn is not a character\"));\n    return;\n  }\n  if (!this->episode_->GetNavigation()->SetWalkerSpeed(walker, max_speed)) {\n    UE_LOG(LogCarla, Warning, TEXT(\"WalkerAIController: Failed to set walker speed\"));\n  }\n}\n", "CodeBleu_score": 49.20000271778001}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  if (episode_->GetNavigation()) {\n    auto walker = Cast<Walker>(GetOwner());\n    if (walker) {\n      if (!episode_->GetNavigation()->SetWalkerSpeed(walker, max_speed)) {\n        UE_LOG(LogCarla, Warning, TEXT(\"Failed to set max speed for walker %s\"),\n          *walker->GetName());\n      }\n    } else {\n      UE_LOG(LogCarla, Warning, TEXT(\"Walker %s not found\"), *GetOwner()->GetName());\n    }\n  } else {\n    UE_LOG(LogCarla, Warning, TEXT(\"Navigation not found\"));\n  }\n}\n", "CodeBleu_score": 51.72287970844776}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const  std::vector<SharedPtr<Waypoint>> result;\n  std::vector<std::vector<double>> waypoints = parent_map_->GetPreviousWaypoints(id_, distance);\n  for (auto waypoint : waypoints) {\n    result.push_back(std::make_shared<Waypoint>(waypoint, parent_map_));\n  }\n  return result;\n}\n", "CodeBleu_score": 52.76092952063631}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<carla::geom::Location> waypoints = parent_map->GetPreviousWaypoints(*this, distance);\n    for (const carla::geom::Location& loc : waypoints) {\n        result.push_back(MakeWaypoint(loc));\n    }\n    return result;\n}\n", "CodeBleu_score": 45.909445401719964}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const  std::vector<SharedPtr<Waypoint>> result;\n  std::vector<Waypoint> waypoints = map_->GetPreviousWaypoints(id_, distance);\n  for (auto& waypoint : waypoints) {\n    result.push_back(std::make_shared<Waypoint>(waypoint));\n  }\n  return result;\n}\n", "CodeBleu_score": 49.085537213659826}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  std::set<SharedPtr<Signal>> unique_signals;\n  for (auto signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      SharedPtr<Landmark> landmark = Landmark::MakeShared(signal);\n      result.push_back(landmark);\n    }\n  }\n  return result;\n}\n", "CodeBleu_score": 43.66821723977458}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  // TODO: implement\n  return {};\n}\n", "CodeBleu_score": 7.357840350844504}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\n  // Get the signals within the distance\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\n  // Create a set to store the unique signals\n  std::set<SharedPtr<Signal>> unique_signals;\n\n  // Loop through the signals and check for duplicates\n  for (auto const& signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n    }\n  }\n\n  // Create a vector to store the landmarks\n  std::vector<SharedPtr<Landmark>> landmarks;\n\n  // Loop through the unique signals and create a new waypoint and landmark\n  for (auto const& signal : unique_signals) {\n    // Create a new waypoint\n    SharedPtr<Waypoint> waypoint =\n        std::make_shared<Waypoint>(signal->GetLocation(), signal->GetHeading(),\n                                   signal->GetLaneId(), signal->GetSignalId());\n\n    // Create a new landmark\n    SharedPtr<Landmark> landmark =\n        std::make_shared<Landmark>(signal->GetId(), waypoint);\n\n    // Add the landmark to the vector\n    landmarks.push_back(landmark);\n  }\n\n  // Return the vector of landmarks\n  return landmarks;\n}\n", "CodeBleu_score": 45.76405783621825}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  const auto start_time = Clock::now();\n  const auto timeout_time = start_time + timeout;\n  const auto fixed_delta_seconds = settings.GetFixedDeltaSeconds();\n\n  // If the user provided a fixed delta time, we will attempt to verify the\n  // accuracy of this setting over a series of ticks.\n  if (fixed_delta_seconds.has_value()) {\n    const auto fixed_delta_time =\n        std::chrono::duration_cast<time_duration>(std::chrono::duration<double>(*fixed_delta_seconds));\n    const auto max_delta_time = fixed_delta_time * 1.05;\n    const auto min_delta_time = fixed_delta_time * 0.95;\n    const auto num_ticks = 10u;\n    const auto delta_time = (timeout_time - start_time) / num_ticks;\n\n    // If the timeout is too short to run the verification, we will log a\n    // warning and skip the verification.\n    if (delta_time < min_delta_time) {\n      UE_LOG(LogCarla, Warning, TEXT(\"Timeout too short to verify fixed delta time\"));\n    } else {\n      auto last_time = start_time;\n      for (auto i = 0u; i < num_ticks; ++i) {\n        if (Clock::now() > timeout_time) {\n          break;\n        }\n        std::this_thread::sleep_for(delta_time);\n        const auto current_time = Clock::now();\n        const auto delta = current_time - last_time;\n        last_time = current_time;\n        if (delta < min_delta_time || delta > max_delta_time) {\n          UE_LOG(LogCarla, Warning, TEXT(\"Fixed delta time not properly applied\"));\n          break;\n        }\n      }\n    }\n  }\n\n  // If the timeout is too short to run the verification, we will log a warning\n  // and skip the verification.\n  if (timeout_time - Clock::now() < 1s) {\n    UE_LOG(LogCarla", "CodeBleu_score": 46.12826457465186}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  using namespace std::chrono;\n  using namespace std::chrono_literals;\n\n  // Set the timeout.\n  auto start_time = clock::now();\n  auto end_time = start_time + timeout;\n\n  // Apply the settings.\n  uint64_t settings_id = 0u;\n  if (settings.HasField(\"fixed_delta_seconds\")) {\n    const auto fixed_delta_seconds = settings.GetFloat(\"fixed_delta_seconds\");\n    if (fixed_delta_seconds <= 0.0f) {\n      throw std::invalid_argument(\"fixed_delta_seconds must be positive\");\n    }\n    settings_id = ApplySettings(fixed_delta_seconds);\n  } else {\n    settings_id = ApplySettings();\n  }\n\n  // Verify the settings.\n  if (settings.HasField(\"fixed_delta_seconds\")) {\n    const auto fixed_delta_seconds = settings.GetFloat(\"fixed_delta_seconds\");\n    const auto max_tolerance = 0.01f;\n    const auto max_attempts = 5u;\n    for (auto i = 0u; i < max_attempts; ++i) {\n      if (clock::now() > end_time) {\n        break;\n      }\n\n      // Get the current settings.\n      const auto current_settings = GetSettings();\n      const auto current_fixed_delta_seconds = current_settings.GetFloat(\"fixed_delta_seconds\");\n\n      // Check if the settings are correct.\n      if (std::abs(fixed_delta_seconds - current_fixed_delta_seconds) < max_tolerance) {\n        return settings_id;\n      }\n\n      // Sleep for a short period of time.\n      std::this_thread::sleep_for(100ms);\n    }\n\n    // Log a warning.\n    UE_LOG(LogCarla, Warning, TEXT(\"Timeout while waiting for settings to be applied\"));\n  }\n\n  return settings_id;\n}\n", "CodeBleu_score": 49.68214815404451}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  // Set the timeout\n  if (settings.has_fixed_delta_seconds()) {\n    timeout = std::chrono::duration_cast<time_duration>(std::chrono::duration<double>(settings.fixed_delta_seconds()));\n  } else if (settings.has_networking_timeout()) {\n    timeout = std::chrono::duration_cast<time_duration>(std::chrono::duration<double>(settings.networking_timeout()));\n  }\n\n  // Create the settings\n  std::unique_ptr<EpisodeSettings> episode_settings = std::make_unique<EpisodeSettings>(settings);\n\n  // Set the settings\n  uint64_t id = 0u;\n  if (episode_settings->synchronous_mode) {\n    id = ApplySynchronousSettings(std::move(episode_settings), timeout);\n  } else {\n    id = ApplyAsynchronousSettings(std::move(episode_settings), timeout);\n  }\n  return id;\n}\n", "CodeBleu_score": 36.3254312668197}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tfloat x0, float y0, float x1, float y1, float px, float py\n}\n", "CodeBleu_score": 6.591884464374997}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint    float x1, float y1, float x2, float y2, float px, float py\n}\n", "CodeBleu_score": 6.606179590980715}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint    /*\n     * This function, Math::DistanceSegmentToPoint, calculates the shortest distance from a point to a line segment in 2D space.\\nIt first computes the squared length of the segment and its length.\\nIf the segment length is zero, it returns zero and the distance from the point to one endpoint.\\nOtherwise, it projects the point onto the segment, clamps the projection, and returns the distance along the segment and the distance from the projection to the point.\n     */\n    float distance_squared,\n    float distance,\n    float segment_length_squared,\n    float segment_length,\n    float dot,\n    float projection,\n    float clamped_projection,\n    float distance_along_segment,\n    float distance_from_projection;\n\n    // Compute the squared length of the segment\n    segment_length_squared = (segment.end - segment.start).LengthSquared();\n\n    // If the segment length is zero, return zero and the distance from the point to one endpoint\n    if (segment_length_squared == 0) {\n        distance_squared = (point - segment.start).LengthSquared();\n        distance = sqrt(distance_squared);\n        return std::make_pair(distance, distance);\n    }\n\n    // Compute the length of the segment\n    segment_length = sqrt(segment_length_squared);\n\n    // Project the point onto the segment\n    dot = ((point - segment.start) / segment_length).Dot(segment.end - segment.start);\n    projection = dot * segment_length;\n\n    // Clamp the projection to [0, segment_length]\n    clamped_projection = std::min(segment_length, std::max(0.0f, projection));\n\n    // Compute the distance along the segment\n    distance_along_segment = clamped_projection / segment_length;\n\n    // Compute the distance from the projection to the point\n    distance_from_projection = (point - (segment.start + (segment.end - segment.start) * distance_along_segment)).Length();\n\n    // Return the distance along the segment and the distance from", "CodeBleu_score": 33.08148774405398}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n    std::vector<GLuint> indices;\n    indices.reserve(vertices.size() - 2);\n    for (size_t i = 0; i < vertices.size() - 2; ++i) {\n        indices.push_back(m_vertices.size());\n        m_vertices.push_back(vertices[0]);\n        m_vertices.push_back(vertices[i + 1]);\n        m_vertices.push_back(vertices[i + 2]);\n    }\n    m_indices.insert(m_indices.end(), indices.begin(), indices.end());\n}\n", "CodeBleu_score": 41.59621237469922}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n    size_t initial_index = m_vertices.size();\n    for (size_t i = 0; i < vertices.size(); ++i) {\n        m_vertices.push_back(vertices[i]);\n    }\n    for (size_t i = 0; i < vertices.size() - 2; ++i) {\n        m_indices.push_back(initial_index);\n        m_indices.push_back(initial_index + i + 1);\n        m_indices.push_back(initial_index + i + 2);\n    }\n}\n", "CodeBleu_score": 47.728706385284084}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n    unsigned int initial_index = m_vertices.size();\n    for (auto &vertex : vertices) {\n        AddVertex(vertex);\n    }\n    for (unsigned int i = 0; i < vertices.size() - 2; i++) {\n        AddIndex(initial_index);\n        AddIndex(initial_index + i + 1);\n        AddIndex(initial_index + i + 2);\n    }\n}\n", "CodeBleu_score": 52.625579912698086}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (!message) {\n    return;\n  }\n\n  // Check if the message is valid\n  if (!message->IsValid()) {\n    LOG_ERROR(\"Primary::Write: invalid message\");\n    return;\n  }\n\n  // Check if the socket is open\n  if (!IsOpen()) {\n    LOG_ERROR(\"Primary::Write: socket is closed\");\n    return;\n  }\n\n  // Post a lambda to the strand\n  _strand.post([this, message]() {\n    // Check if the socket is open\n    if (!IsOpen()) {\n      LOG_ERROR(\"Primary::Write: socket is closed\");\n      return;\n    }\n\n    // Set a timeout\n    _socket.expires_after(std::chrono::seconds(1));\n\n    // Initiate an asynchronous write\n    _socket.async_write_some(\n      boost::asio::buffer(message->GetBuffer(), message->GetSize()),\n      [this, message](const boost::system::error_code& ec, std::size_t length) {\n        // Handle the result\n        HandleSent(message, ec, length);\n      });\n  });\n}\n", "CodeBleu_score": 37.004270526200614}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (message == nullptr) {\n    throw std::invalid_argument(\"message cannot be nullptr\");\n  }\n  if (message->GetData().size() > carla::streaming::detail::tcp::MAX_MESSAGE_SIZE) {\n    throw std::invalid_argument(\"message too big\");\n  }\n  io_service_.post([this, message]() {\n    if (!socket_.is_open()) {\n      return;\n    }\n    auto self = shared_from_this();\n    auto handle_sent = [this, self](const boost::system::error_code &ec, std::size_t bytes) {\n      if (ec) {\n        if (ec == boost::asio::error::operation_aborted) {\n          return;\n        }\n        LOG_ERROR(\"failed to send message: \", ec.message());\n        Close();\n        return;\n      }\n      if (bytes != message->GetData().size()) {\n        LOG_ERROR(\"failed to send message: \", bytes, \" bytes instead of \", message->GetData().size(), \" bytes\");\n        Close();\n      }\n    };\n    socket_.async_write_some(boost::asio::buffer(message->GetData()), [this, self, handle_sent](const boost::system::error_code &ec, std::size_t bytes) {\n      if (ec) {\n        if (ec == boost::asio::error::operation_aborted) {\n          return;\n        }\n        LOG_ERROR(\"failed to send message: \", ec.message());\n        Close();\n        return;\n      }\n      if (bytes != message->GetData().size()) {\n        LOG_ERROR(\"failed to send message: \", bytes, \" bytes instead of \", message->GetData().size(), \" bytes\");\n        Close();\n      }\n      socket_.async_write(boost::asio::buffer(message->GetData()), handle_sent);\n    });\n  });\n}\n", "CodeBleu_score": 42.413696674821225}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (message == nullptr) {\n    return;\n  }\n  if (message->size() > 0u) {\n    _strand.post([this, message]() {\n      if (_socket.is_open()) {\n        _socket.async_write_some(boost::asio::buffer(message->data(), message->size()),\n                                 [this, message](const boost::system::error_code &ec, std::size_t size) {\n                                   if (ec) {\n                                     _logger.debug(\"Primary::Write: {}\", ec.message());\n                                     Close();\n                                   } else {\n                                     _logger.debug(\"Primary::Write: {} bytes\", size);\n                                   }\n                                 });\n      }\n    });\n  }\n}\n", "CodeBleu_score": 36.73026463384894}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)  if (ec) {\n    // Rationale: Pass the error code to the user-provided on_closed callback.\n    // The user can decide what to do with the error code. If the user does not\n    // want to handle the error, he or she does not have to.\n    on_closed(ec);\n  } else {\n    // Rationale: If the user does not want to handle the error, he or she does\n    // not have to.\n    // Rationale: Shut down the socket so that the remote peer knows that no\n    // more data will be sent.\n    // Rationale: Close the socket.\n    // Rationale: Pass the error code to the user-provided on_closed callback.\n    // The user can decide what to do with the error code. If the user does not\n    // want to handle the error, he or she does not have to.\n    boost::system::error_code ignored_ec;\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    socket_.close(ignored_ec);\n    on_closed(ignored_ec);\n  }\n  LogSessionEnd();\n}\n", "CodeBleu_score": 47.15404479744808}, {"code": "void Primary::CloseNow(boost::system::error_code ec)  if (ec) {\n    return;\n  }\n  if (socket_.is_open()) {\n    boost::system::error_code ec;\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    socket_.close(ec);\n  }\n  if (on_closed_) {\n    on_closed_();\n  }\n  logger_.Log(LogLevel::DEBUG, \"Session closed\");\n}\n", "CodeBleu_score": 56.929983967147756}, {"code": "void Primary::CloseNow(boost::system::error_code ec)    // Cancel the deadline timer.\n    deadline_.cancel();\n    // If the socket is open and no error code is provided, attempt to shut down and close the socket.\n    if (!ec && socket_.is_open()) {\n        // Shut down the socket.\n        boost::system::error_code ec;\n        socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n        // Close the socket.\n        socket_.close(ec);\n    }\n    // Trigger the on_closed callback.\n    if (on_closed_) {\n        on_closed_();\n    }\n    // Log that the session has been closed.\n    std::cout << \"session closed\" << std::endl;\n}\n", "CodeBleu_score": 56.565399109313105}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()    // Create a buffer from the message\n    char* buffer = new char[1024];\n    sprintf(buffer, \"Are you alive?\");\n\n    // Log the sending action\n    log_message(\"Sending IsAlive message to next router\");\n\n    // Write the buffer to the next router with the command YOU_ALIVE\n    WriteToNextRouter(buffer, YOU_ALIVE);\n\n    // Wait for and log the response from the system\n    char* response = ReadFromNextRouter(YOU_ALIVE);\n    log_message(response);\n\n    // Delete the buffer\n    delete[] buffer;\n}\n", "CodeBleu_score": 37.618082890565084}, {"code": "void PrimaryCommands::SendIsAlive()    char buffer[BUFFER_SIZE];\n    int bytes_written;\n    int bytes_read;\n    int bytes_to_read;\n    int router_id;\n    int message_type;\n    char message[MESSAGE_SIZE];\n\n    // create buffer\n    bytes_written = CreateBuffer(YOU_ALIVE, buffer);\n    // log sending action\n    LogSend(YOU_ALIVE);\n    // write buffer to next router\n    WriteToNextRouter(buffer, bytes_written);\n    // wait for response\n    bytes_to_read = ReadFromNextRouter(buffer, bytes_read);\n    // log receiving action\n    LogReceive(YOU_ALIVE, buffer, bytes_to_read);\n    // parse response\n    ParseBuffer(buffer, bytes_to_read, router_id, message_type, message);\n    // check if response is valid\n    if (message_type != YOU_ALIVE) {\n        throw std::runtime_error(\"Invalid response type\");\n    }\n    if (strcmp(message, \"I'm alive!\") != 0) {\n        throw std::runtime_error(\"Invalid response message\");\n    }\n}\n", "CodeBleu_score": 36.17239776062131}, {"code": "void PrimaryCommands::SendIsAlive()    char buffer[100];\n    strcpy(buffer, \"Are you alive?\");\n    Log(buffer, SEND);\n    WriteToNext(buffer, YOU_ALIVE);\n    Log(buffer, RECEIVE);\n}\n", "CodeBleu_score": 20.091225816507112}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)  // Check if the sensor is activated on any secondary server.\n  bool sensor_found = false;\n  for (auto &server : secondary_servers) {\n    if (server.second.sensor_id == sensor_id) {\n      sensor_found = true;\n      break;\n    }\n  }\n  if (!sensor_found) {\n    LOG(ERROR) << \"Sensor ID \" << sensor_id << \" not found on any secondary server.\";\n    return;\n  }\n\n  // Create a buffer with the sensor ID.\n  auto buffer = std::make_shared<Buffer>();\n  buffer->add_data(sensor_id);\n\n  // Send an ENABLE_ROS command to the server using the router.\n  router->SendCommandToSecondaryServer(buffer, Command::ENABLE_ROS);\n\n  // Wait for and process the server's response.\n  auto response = router->WaitForResponse();\n  if (response->command == Command::ENABLE_ROS_ACK) {\n    LOG(INFO) << \"Sensor ID \" << sensor_id << \" enabled for ROS.\";\n  } else {\n    LOG(ERROR) << \"Sensor ID \" << sensor_id << \" failed to enable for ROS.\";\n  }\n}\n", "CodeBleu_score": 48.37277519092328}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)  // Create a buffer to send the sensor ID\n  char *buffer = new char[sizeof(stream_id)];\n  memcpy(buffer, &sensor_id, sizeof(stream_id));\n\n  // Send the command to the router\n  router->SendCommand(ENABLE_ROS, buffer, sizeof(stream_id));\n\n  // Wait for the response\n  char *response = router->WaitForResponse(ENABLE_ROS);\n\n  // Check the response\n  if (response == NULL) {\n    // If the response is NULL, the sensor was not found on any server\n    // Log an error message\n    LogError(\"No server has the sensor \" + std::to_string(sensor_id) + \" active.\");\n  } else {\n    // If the response is not NULL, the sensor was found on a server\n    // Check the response\n    if (response[0] == 0) {\n      // If the response is 0, the sensor was successfully enabled\n      // Log a message\n      LogInfo(\"Sensor \" + std::to_string(sensor_id) + \" enabled for ROS.\");\n    } else {\n      // If the response is not 0, the sensor was not successfully enabled\n      // Log an error message\n      LogError(\"Failed to enable sensor \" + std::to_string(sensor_id) + \" for ROS.\");\n    }\n  }\n\n  // Delete the buffer\n  delete[] buffer;\n}\n", "CodeBleu_score": 44.10235651820763}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if sensor is active on any secondary server\n    bool found = false;\n    for (int i = 0; i < SecondaryServers::GetSecondaryServerCount(); i++) {\n        if (SecondaryServers::GetSecondaryServer(i)->IsSensorActive(sensor_id)) {\n            found = true;\n            break;\n        }\n    }\n\n    // If sensor is active on a server, send ENABLE_ROS command\n    if (found) {\n        // Create buffer\n        char buffer[sizeof(sensor_id)];\n        memcpy(buffer, &sensor_id, sizeof(sensor_id));\n\n        // Send command to router\n        if (Router::SendCommand(Command::ENABLE_ROS, buffer, sizeof(sensor_id)) == -1) {\n            Log(LOG_LEVEL_ERROR, \"Error sending ENABLE_ROS command to router\\n\");\n        }\n\n        // Wait for response from router\n        char response[sizeof(bool)];\n        if (Router::ReceiveCommandResponse(response, sizeof(bool)) == -1) {\n            Log(LOG_LEVEL_ERROR, \"Error receiving response from router\\n\");\n        }\n\n        // Process response\n        bool success = *(bool*)response;\n        if (!success) {\n            Log(LOG_LEVEL_ERROR, \"Error enabling sensor for ROS\\n\");\n        }\n    }\n    else {\n        Log(LOG_LEVEL_ERROR, \"Sensor ID %d not active on any secondary server\\n\", sensor_id);\n    }\n}\n", "CodeBleu_score": 39.60305734433249}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)  // Check if sensor is already activated\n  if (this->sensor_map.count(sensor_id) > 0) {\n    // Sensor is already activated, return existing token\n    token_type token = this->sensor_map[sensor_id];\n    this->logger->log(\"Sensor \" + std::to_string(sensor_id) + \" already activated, returning existing token \" + std::to_string(token) + \".\");\n    return token;\n  }\n  // Sensor is not activated, activate it\n  this->logger->log(\"Sensor \" + std::to_string(sensor_id) + \" not activated, activating...\");\n  // Retrieve new token\n  token_type token = this->secondary_server->ActivateSensor(sensor_id);\n  // Update maps\n  this->sensor_map[sensor_id] = token;\n  this->token_map[token] = sensor_id;\n  // Log action\n  this->logger->log(\"Sensor \" + std::to_string(sensor_id) + \" activated, new token \" + std::to_string(token) + \".\");\n  // Return token\n  return token;\n}\n", "CodeBleu_score": 30.669289487841823}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)    // Check if sensor is already activated\n    auto it = m_sensor_to_token.find(sensor_id);\n    if (it != m_sensor_to_token.end()) {\n        // Sensor is already activated\n        LOG_INFO(\"Sensor \" << sensor_id << \" already activated\");\n        return it->second;\n    }\n    // Sensor is not activated\n    // Enable sensor on secondary server\n    auto secondary_server = m_sensor_to_secondary_server.find(sensor_id);\n    if (secondary_server == m_sensor_to_secondary_server.end()) {\n        // No secondary server for sensor\n        LOG_ERROR(\"No secondary server for sensor \" << sensor_id);\n        return 0;\n    }\n    // Get new token\n    token_type new_token = m_secondary_server_to_token.at(secondary_server->second);\n    // Update maps\n    m_sensor_to_token.insert(std::make_pair(sensor_id, new_token));\n    m_token_to_sensor.insert(std::make_pair(new_token, sensor_id));\n    // Log action\n    LOG_INFO(\"Activated sensor \" << sensor_id << \" with token \" << new_token);\n    // Return token\n    return new_token;\n}\n", "CodeBleu_score": 44.65662189633443}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)    if (this->active_sensors.find(sensor_id) != this->active_sensors.end()) {\n        token_type token = this->active_sensors[sensor_id];\n        this->logger->log(\"GetToken\", \"Sensor already activated, returning existing token\", sensor_id);\n        return token;\n    }\n    this->logger->log(\"GetToken\", \"Sensor not activated, activating and returning new token\", sensor_id);\n    this->active_sensors[sensor_id] = this->secondary_server->EnableSensor(sensor_id);\n    this->active_sensors_ids.push_back(sensor_id);\n    this->active_sensors_tokens[sensor_id] = this->active_sensors[sensor_id];\n    return this->active_sensors[sensor_id];\n}\n", "CodeBleu_score": 30.295586439188465}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)  std::ifstream file(filename, std::ios::binary);\n  if (!file.is_open()) {\n    return false;\n  }\n  std::vector<uint8_t> data;\n  file.seekg(0, std::ios::end);\n  data.resize(file.tellg());\n  file.seekg(0, std::ios::beg);\n  file.read(reinterpret_cast<char *>(data.data()), data.size());\n  file.close();\n  return Load(data);\n}\n", "CodeBleu_score": 56.456868428448104}, {"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (!file) {\n        return false;\n    }\n    std::vector<unsigned char> data;\n    file.seekg(0, std::ios::end);\n    data.resize(file.tellg());\n    file.seekg(0, std::ios::beg);\n    file.read((char *)&data[0], data.size());\n    file.close();\n    return Load(data);\n}\n", "CodeBleu_score": 47.995976758716104}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> data;\n\tfile.seekg(0, std::ios::end);\n\tdata.resize(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile.read(data.data(), data.size());\n\tfile.close();\n\treturn Load(data);\n}\n", "CodeBleu_score": 52.95884418590262}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)    if (!IsReady()) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Navigation system is not ready\"));\n        return false;\n    }\n    if (m_crowd == nullptr) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Crowd is null\"));\n        return false;\n    }\n\n    // Search for the agent in the walker and vehicle mappings\n    auto walker = m_walkerManager->FindWalker(id);\n    auto vehicle = m_vehicleManager->FindVehicle(id);\n\n    // If found, enter a critical section to safely remove the agent from the crowd\n    if (walker != nullptr) {\n        std::lock_guard<std::mutex> lock(m_mutex);\n        if (m_crowd->removeAgent(walker->GetAgentId())) {\n            // Update the walker manager and remove the id from the walker mapping\n            m_walkerManager->RemoveWalker(id);\n            m_walkerIdMap.erase(id);\n            return true;\n        }\n    } else if (vehicle != nullptr) {\n        std::lock_guard<std::mutex> lock(m_mutex);\n        if (m_crowd->removeAgent(vehicle->GetAgentId())) {\n            // Update the vehicle manager and remove the id from the vehicle mapping\n            m_vehicleManager->RemoveVehicle(id);\n            m_vehicleIdMap.erase(id);\n            return true;\n        }\n    }\n\n    // If the agent is not found, return false\n    return false;\n}\n", "CodeBleu_score": 47.59305229442208}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tbool result = false;\n\n\tif (IsReady() && m_crowd) {\n\t\t// Find the agent id in the walker and vehicle mappings\n\t\tauto it = m_walkerMap.find(id);\n\t\tif (it != m_walkerMap.end()) {\n\t\t\t// Enter a critical section to safely remove the agent from the crowd\n\t\t\tCriticalSectionLock<Navigation> lock(this);\n\n\t\t\t// Remove the agent from the crowd\n\t\t\tdtCrowdAgent* agent = m_crowd->getAgent(it->second);\n\t\t\tm_crowd->removeAgent(it->second);\n\n\t\t\t// Remove the agent id from the walker mapping\n\t\t\tm_walkerMap.erase(it);\n\n\t\t\t// Remove the agent from the walker manager\n\t\t\tm_walkerManager.RemoveWalker(id);\n\n\t\t\tresult = true;\n\t\t}\n\n\t\tit = m_vehicleMap.find(id);\n\t\tif (it != m_vehicleMap.end()) {\n\t\t\t// Enter a critical section to safely remove the agent from the crowd\n\t\t\tCriticalSectionLock<Navigation> lock(this);\n\n\t\t\t// Remove the agent from the crowd\n\t\t\tdtCrowdAgent* agent = m_crowd->getAgent(it->second);\n\t\t\tm_crowd->removeAgent(it->second);\n\n\t\t\t// Remove the agent id from the vehicle mapping\n\t\t\tm_vehicleMap.erase(it);\n\n\t\t\t// Remove the agent from the vehicle manager\n\t\t\tm_vehicleManager.RemoveVehicle(id);\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 49.21548101481906}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!IsReady()) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Navigation system is not ready!\"));\n\t\treturn false;\n\t}\n\tif (!crowd) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: crowd object is null!\"));\n\t\treturn false;\n\t}\n\n\t// Find the agent in the walker or vehicle manager\n\tint agentIndex = -1;\n\tif (walkerManager) {\n\t\tagentIndex = walkerManager->FindAgent(id);\n\t}\n\tif (agentIndex == -1 && vehicleManager) {\n\t\tagentIndex = vehicleManager->FindAgent(id);\n\t}\n\tif (agentIndex == -1) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Navigation::RemoveAgent: Agent not found!\"));\n\t\treturn false;\n\t}\n\n\t// Critical section\n\tFPlatformMutex* mutex = crowd->GetMutex();\n\tmutex->Lock();\n\n\t// Remove the agent from the crowd\n\tdtCrowdAgent* agent = crowd->getAgent(agentIndex);\n\tif (agent) {\n\t\tcrowd->removeAgent(agentIndex);\n\t}\n\n\t// Update the walker or vehicle manager\n\tif (walkerManager) {\n\t\twalkerManager->RemoveAgent(id);\n\t}\n\tif (vehicleManager) {\n\t\tvehicleManager->RemoveAgent(id);\n\t}\n\n\t// Remove the id from the mappings\n\twalkerMap.Remove(id);\n\tvehicleMap.Remove(id);\n\n\tmutex->Unlock();\n\n\treturn true;\n}\n", "CodeBleu_score": 37.52365955096408}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    // Collect the IDs of currently mapped vehicles into a set\n    std::set<int> current_vehicle_ids;\n    for (auto it = vehicle_map_.begin(); it != vehicle_map_.end(); ++it) {\n        current_vehicle_ids.insert(it->first);\n    }\n\n    // Add or update vehicles from the provided list, marking them as updated\n    for (auto it = vehicles.begin(); it != vehicles.end(); ++it) {\n        int id = it->id;\n        if (vehicle_map_.count(id) == 0) {\n            // New vehicle, add it to the map\n            vehicle_map_[id] = Vehicle(id, it->x, it->y, it->yaw, it->speed, it->lane, it->width);\n        } else {\n            // Existing vehicle, update it\n            vehicle_map_[id].Update(it->x, it->y, it->yaw, it->speed, it->lane, it->width);\n        }\n        current_vehicle_ids.erase(id);\n    }\n\n    // Vehicles not marked as updated are removed, indicating they do not exist in the current frame\n    for (auto it = current_vehicle_ids.begin(); it != current_vehicle_ids.end(); ++it) {\n        vehicle_map_.erase(*it);\n    }\n\n    return true;\n}\n", "CodeBleu_score": 48.39671008242294}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    std::set<int> currentVehicleIDs;\n    for (auto it = this->vehicles.begin(); it != this->vehicles.end(); it++) {\n        currentVehicleIDs.insert(it->first);\n    }\n    for (auto it = vehicles.begin(); it != vehicles.end(); it++) {\n        auto it2 = this->vehicles.find(it->id);\n        if (it2 != this->vehicles.end()) {\n            it2->second.Update(*it);\n        } else {\n            this->vehicles.insert(std::make_pair(it->id, Vehicle(it->id, *it)));\n        }\n    }\n    for (auto it = currentVehicleIDs.begin(); it != currentVehicleIDs.end(); it++) {\n        if (!this->vehicles.at(*it).updated) {\n            this->vehicles.erase(*it);\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 48.04980988738275}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> currentVehicleIDs;\n\n\tfor (auto& vehicle : m_vehicles) {\n\t\tcurrentVehicleIDs.insert(vehicle.first);\n\t}\n\n\tfor (auto& vehicle : vehicles) {\n\t\tif (m_vehicles.find(vehicle.id) != m_vehicles.end()) {\n\t\t\tm_vehicles[vehicle.id] = vehicle;\n\t\t}\n\t\telse {\n\t\t\tm_vehicles[vehicle.id] = vehicle;\n\t\t}\n\n\t\tcurrentVehicleIDs.erase(vehicle.id);\n\t}\n\n\tfor (auto& vehicleID : currentVehicleIDs) {\n\t\tm_vehicles.erase(vehicleID);\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 51.38570980271485}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\t// Check if the actor is in the list of walkers\n\tauto walker = GetWalker(id);\n\tif (walker != nullptr) {\n\t\t// Enter critical section\n\t\tstd::lock_guard<std::mutex> guard(walkers_mutex);\n\n\t\t// Compute squared distance\n\t\tfloat sqr_distance = direction.DistanceSquared(walker->GetLocation());\n\n\t\t// Check if a vehicle is nearby\n\t\tif (sqr_distance < distance * distance) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Check if the actor is in the list of vehicles\n\tauto vehicle = GetVehicle(id);\n\tif (vehicle != nullptr) {\n\t\t// Enter critical section\n\t\tstd::lock_guard<std::mutex> guard(vehicles_mutex);\n\n\t\t// Compute squared distance\n\t\tfloat sqr_distance = direction.DistanceSquared(vehicle->GetLocation());\n\n\t\t// Check if a vehicle is nearby\n\t\tif (sqr_distance < distance * distance) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Return false if no vehicle is nearby\n\treturn false;\n}\n", "CodeBleu_score": 43.132350888219115}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)    // First, check if the actor is a walker or a vehicle\n    auto actor = GetActorById(id);\n    if (actor == nullptr) {\n        return false;\n    }\n\n    // If it is a vehicle, check if it is close to the given actor\n    if (actor->GetActorType() == ActorType::Vehicle) {\n        auto vehicle = boost::static_pointer_cast<cc::Vehicle>(actor);\n        auto loc = vehicle->GetLocation();\n        auto diff = carla::geom::Location(loc.x - direction.x, loc.y - direction.y, loc.z - direction.z);\n        auto squared_distance = diff.x * diff.x + diff.y * diff.y + diff.z * diff.z;\n        if (squared_distance < distance * distance) {\n            return true;\n        }\n    }\n\n    // If it is a walker, check if it is close to the given actor\n    if (actor->GetActorType() == ActorType::Walker) {\n        auto walker = boost::static_pointer_cast<cc::Walker>(actor);\n        auto loc = walker->GetLocation();\n        auto diff = carla::geom::Location(loc.x - direction.x, loc.y - direction.y, loc.z - direction.z);\n        auto squared_distance = diff.x * diff.x + diff.y * diff.y + diff.z * diff.z;\n        if (squared_distance < distance * distance) {\n            return true;\n        }\n    }\n\n    // If it is not a vehicle or walker, return false\n    return false;\n}\n", "CodeBleu_score": 43.97674917211921}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  // Check if the actor is a vehicle\n  if (id.type != ActorTypes::Vehicle) {\n    UE_LOG(LogTemp, Warning, TEXT(\"Navigation::HasVehicleNear: The actor is not a vehicle.\"));\n    return false;\n  }\n\n  // Check if the actor is in the list of walkers and vehicles\n  if (id.id >= walkers_and_vehicles.Num()) {\n    UE_LOG(LogTemp, Warning, TEXT(\"Navigation::HasVehicleNear: The actor is not in the list of walkers and vehicles.\"));\n    return false;\n  }\n\n  // Check if the distance is positive\n  if (distance <= 0.0f) {\n    UE_LOG(LogTemp, Warning, TEXT(\"Navigation::HasVehicleNear: The distance must be positive.\"));\n    return false;\n  }\n\n  // Check if the direction is normalized\n  if (direction.SquaredLength() != 1.0f) {\n    UE_LOG(LogTemp, Warning, TEXT(\"Navigation::HasVehicleNear: The direction must be normalized.\"));\n    return false;\n  }\n\n  // Get the vehicle\n  ACarlaWheeledVehicle* vehicle = Cast<ACarlaWheeledVehicle>(walkers_and_vehicles[id.id]);\n\n  // Check if the vehicle is valid\n  if (vehicle == nullptr) {\n    UE_LOG(LogTemp, Warning, TEXT(\"Navigation::HasVehicleNear: The vehicle is not valid.\"));\n    return false;\n  }\n\n  // Get the vehicle's location\n  FVector location = vehicle->GetActorLocation();\n\n  // Get the vehicle's forward vector\n  FVector forward = vehicle->GetActorForwardVector();\n\n  // Check if the vehicle is in the crowd\n  bool result = false;\n  if (crowd_manager->IsAgentInCrowd(vehicle)) {\n    // Get the vehicle's position in the crowd\n    const float* position = crowd_manager->GetAgentPosition(vehicle);\n\n    // Check if", "CodeBleu_score": 37.91509890052737}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)    auto &route = info.route;\n    auto &current = route.current;\n\n    WalkerEventVisitor visitor(id, info, delta);\n\n    EventResult result = boost::variant2::visit(visitor, current);\n\n    if (result == EventResult::ER_FINISHED) {\n        route.current = route.next;\n        route.next = RoutePoint();\n    }\n\n    return result;\n}\n", "CodeBleu_score": 48.306959410522374}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tauto routePoint = info.routePoints.at(info.currentRoutePointIndex);\n\tauto event = routePoint.event;\n\tauto visitor = WalkerEventVisitor(id, info, delta);\n\tauto result = boost::variant2::visit(visitor, event);\n\treturn result;\n}\n", "CodeBleu_score": 51.823451720094816}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tconst RoutePoint &rp = info.route.GetCurrentRoutePoint();\n\tWalkerEventVisitor visitor(this, id, info, delta);\n\treturn boost::variant2::visit(visitor, rp.event);\n}\n", "CodeBleu_score": 69.71611910968927}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n  // Get the road node\n  auto road_node = xml.child(\"OpenDRIVE\").child(\"road\");\n\n  // Get the lanes node\n  auto lanes_node = road_node.child(\"lanes\");\n\n  // Get the road ID\n  std::string road_id = road_node.attribute(\"id\").as_string();\n\n  // Iterate through each lane section\n  for (pugi::xml_node lane_section_node = lanes_node.child(\"laneSection\");\n       lane_section_node;\n       lane_section_node = lane_section_node.next_sibling(\"laneSection\")) {\n\n    // Get the s value for the lane section\n    double s = lane_section_node.attribute(\"s\").as_double();\n\n    // Get the left, center, and right lane nodes\n    auto left_lane_node = lane_section_node.child(\"left\");\n    auto center_lane_node = lane_section_node.child(\"center\");\n    auto right_lane_node = lane_section_node.child(\"right\");\n\n    // Parse the lane section\n    ParseLanes(left_lane_node, center_lane_node, right_lane_node, s, road_id,\n               map_builder);\n  }\n}\n", "CodeBleu_score": 48.80543549253284}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").child(\"road\")) {\n    // Get the road ID\n    std::string road_id = road_node.attribute(\"id\").as_string();\n\n    // Iterate through each lane section node\n    for (pugi::xml_node lane_section_node : road_node.child(\"lanes\")) {\n      // Get the left, center, and right lane nodes\n      pugi::xml_node left_lane_node = lane_section_node.child(\"laneOffset\");\n      pugi::xml_node center_lane_node = lane_section_node.child(\"lane\");\n      pugi::xml_node right_lane_node = lane_section_node.child(\"lane\");\n\n      // Parse the left, center, and right lane nodes\n      ParseLanes(road_id, left_lane_node, center_lane_node, right_lane_node, map_builder);\n    }\n  }\n}\n", "CodeBleu_score": 44.66031251466245}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  using namespace carla::road;\n\n  auto road_nodes = xml.child(\"OpenDRIVE\").child(\"road\");\n  for (auto road_node : road_nodes) {\n    auto road_id = road_node.attribute(\"id\").as_string();\n    auto lanes_node = road_node.child(\"lanes\");\n    for (auto lane_section_node : lanes_node.children(\"laneSection\")) {\n      auto left_nodes = lane_section_node.children(\"left\");\n      auto center_nodes = lane_section_node.children(\"center\");\n      auto right_nodes = lane_section_node.children(\"right\");\n      auto left_lanes = ParseLanes(left_nodes);\n      auto center_lanes = ParseLanes(center_nodes);\n      auto right_lanes = ParseLanes(right_nodes);\n      map_builder.AddRoad(road_id, left_lanes, center_lanes, right_lanes);\n    }\n  }\n}\n", "CodeBleu_score": 51.12252445975837}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)  if (info.current_count_change == 1) {\n    // New match has been discovered\n    std::cout << \"New publisher matched.\" << std::endl;\n    std::cout << \"  total: \" << info.total_count << std::endl;\n    std::cout << \"  current: \" << info.current_count << std::endl;\n    std::cout << \"  total_count_change: \" << info.total_count_change << std::endl;\n    std::cout << \"  current_count_change: \" << info.current_count_change << std::endl;\n    std::cout << \"  last_subscription_handle: \" << info.last_subscription_handle << std::endl;\n    std::cout << \"  last_publication_handle: \" << info.last_publication_handle << std::endl;\n    std::cout << \"  current_count_change: \" << info.current_count_change << std::endl;\n    std::cout << \"  total_count_change: \" << info.total_count_change << std::endl;\n    std::cout << \"  alive_count_change: \" << info.alive_count_change << std::endl;\n    std::cout << \"  not_alive_count_change: \" << info.not_alive_count_change << std::endl;\n    std::cout << \"  alive_count: \" << info.alive_count << std::endl;\n    std::cout << \"  not_alive_count: \" << info.not_alive_count << std::endl;\n    std::cout << \"  last_publication_handle: \" << info.last_publication_handle << std::endl;\n    std::cout << \"  total_count: \" << info.total_count << std::endl;\n    std::cout << \"  current_count: \" << info.current_count << std::endl;\n    std::cout << \"  total_count_change: \" << info.total_count_change << std::endl;\n    std::cout << \"  current_count_change: \" << info.current_count_change << std::endl;\n    std::", "CodeBleu_score": 45.1898723089174}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    if (info.current_count_change == 1) {\n        // New match\n        std::cout << \"New match made to writer \" << writer->get_guid() << std::endl;\n        matched_count_++;\n        if (matched_count_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        // Match lost\n        std::cout << \"Match lost for writer \" << writer->get_guid() << std::endl;\n        matched_count_--;\n    } else {\n        // Should never happen\n        std::cout << \"Error, invalid count change (\" << info.current_count_change << \") for writer \" << writer->get_guid() << std::endl;\n    }\n}\n", "CodeBleu_score": 54.595095584520934}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    (void)writer;\n    if (info.current_count_change == 1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched() - \"\n                  << \"Publisher matched.\" << std::endl;\n        std::cout << \"  total: \" << info.total_count << std::endl;\n        std::cout << \"  total_count_change: \" << info.total_count_change << std::endl;\n        std::cout << \"  current: \" << info.current_count << std::endl;\n        std::cout << \"  current_count_change: \" << info.current_count_change << std::endl;\n        std::cout << \"  last_subscription_handle: \" << info.last_subscription_handle << std::endl;\n        std::cout << \"  last_publication_handle: \" << info.last_publication_handle << std::endl;\n        std::cout << \"  status: \" << info.status << std::endl;\n        std::cout << \"  instance_handle: \" << info.instance_handle << std::endl;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"CarlaListenerImpl::on_publication_matched() - \"\n                  << \"Publisher unmatched.\" << std::endl;\n        std::cout << \"  total: \" << info.total_count << std::endl;\n        std::cout << \"  total_count_change: \" << info.total_count_change << std::endl;\n        std::cout << \"  current: \" << info.current_count << std::endl;\n        std::cout << \"  current_count_change: \" << info.current_count_change << std::endl;\n        std::cout << \"  last_subscription_handle: \" << info.last_subscription_handle << std::endl;\n        std::cout << \"  last_publication_handle: \" << info.last_publication_handle << std::endl;\n        std::cout << \"  status: \" << info.status << std::endl;\n        std::cout << \"  instance_handle:", "CodeBleu_score": 36.652998879356765}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\" << std::endl;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n    } else {\n        std::cout << \"Subscriber matched error.\" << std::endl;\n    }\n}\n", "CodeBleu_score": 45.745434596819315}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        std::cout << \"Subscriber matched.\" << std::endl;\n        this->matched_count++;\n        this->first_connected = true;\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscriber unmatched.\" << std::endl;\n        this->matched_count--;\n        if (this->matched_count == 0) {\n            this->subscriber->delete_datareader(reader);\n        }\n    } else {\n        std::cout << \"Subscriber matched error.\" << std::endl;\n    }\n}\n", "CodeBleu_score": 49.12072620483065}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    if (info.current_count_change == 1) {\n        std::cout << \"New subscription matched for topic \" << reader->get_topicdescription()->get_name() << std::endl;\n        ++matched_count_;\n        if (matched_count_ == 1) {\n            first_connected_ = true;\n        }\n    } else if (info.current_count_change == -1) {\n        std::cout << \"Subscription unmatched for topic \" << reader->get_topicdescription()->get_name() << std::endl;\n        --matched_count_;\n        if (matched_count_ == 0) {\n            first_connected_ = false;\n        }\n    } else {\n        std::cout << \"Invalid value for current count change: \" << info.current_count_change << std::endl;\n    }\n}\n", "CodeBleu_score": 53.19685135058755}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    eprosima::fastcdr::FastBuffer fastbuffer(m_keyBuffer, m_keyBufferLen);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);\n    p_type->serializeKey(ser);\n    if (force_md5 || ser.endianness() != eprosima::fastcdr::Cdr::DEFAULT_ENDIAN || ser.endianness() != publisher_->cdr_encapsulation()) {\n        m_md5.init();\n        m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));\n        m_md5.finalize();\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_md5.digest[i];\n        }\n    } else {\n        for (uint8_t i = 0; i < 16; ++i) {\n            handle->value[i] = m_keyBuffer[i];\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 75.37549311509862}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if ( !isKeyDefined() ) {\n        return false;\n    }\n    CarlaCollisionEvent* p_type = (CarlaCollisionEvent*)data;\n    if (force_md5 || p_type->isKeyComputed()) {\n        p_type->computeKey();\n    }\n    *handle = p_type->getKey();\n    return true;\n}\n", "CodeBleu_score": 20.757219733465806}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\")) {\n        return false;\n    }\n    if (0 == strcmp(type_name, \"CarlaCollisionEvent\"))", "CodeBleu_score": 14.35191693236295}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}\n", "CodeBleu_score": 97.96914124278699}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}\n", "CodeBleu_score": 97.96914124278699}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}\n", "CodeBleu_score": 97.96914124278699}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n        case MAVLINK_MSG_ID_SCALED_PRESSURE:\n        case MAVLINK_MSG_ID_ATTITUDE:\n        case MAVLINK_MSG_ID_VFR_HUD:\n        case MAVLINK_MSG_ID_GPS_RAW_INT:\n        case MAVLINK_MSG_ID_SYS_STATUS:\n        case MAVLINK_MSG_ID_SYSTEM_TIME:\n        case MAVLINK_MSG_ID_MISSION_CURRENT:\n        case MAVLINK_MSG_ID_MISSION_REQUEST_INT:\n        case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:\n        case MAVLINK_MSG_ID_MISSION_ITEM_INT:\n        case MAVLINK_MSG_ID_MISSION_COUNT:\n        case MAVLINK_MSG_ID_MISSION_CLEAR_ALL:\n        case MAVLINK_MSG_ID_MISSION_ITEM_REACHED:\n        case MAVLINK_MSG_ID_MISSION_ACK:\n        case MAVLINK_MSG_ID_MISSION_SET_CURRENT:\n        case MAVLINK_MSG_ID_MISSION_REQUEST:\n        case MAVLINK_MSG_ID_MISSION_COUNT_REPLY:\n        case MAVLINK_MSG_ID_MISSION_REQUEST_LIST_REPLY:\n        case MAVLINK_MSG_ID_MISSION_ITEM:\n        case MAVLINK_MSG_ID_MISSION_ITEM_REPLY:\n        case MAVLINK_MSG_ID_MISSION_ACK_REPLY:\n        case MAVLINK_MSG_ID_MISSION_SET_CURRENT_REPLY:\n        case MAVLINK_MSG_ID_MISSION_REQUEST_REPLY:\n        case MAVLIN", "CodeBleu_score": 13.160812852911008}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)  if (m_target_set) {\n    return;\n  }\n\n  mavlink_message_t mavlink_msg;\n  mavlink_msg.msgid = msg.msgid;\n  mavlink_msg.sysid = msg.sysid;\n  mavlink_msg.compid = msg.compid;\n  mavlink_msg.payload64[0] = msg.payload64[0];\n  mavlink_msg.payload64[1] = msg.payload64[1];\n  mavlink_msg.payload64[2] = msg.payload64[2];\n  mavlink_msg.payload64[3] = msg.payload64[3];\n  mavlink_msg.payload64[4] = msg.payload64[4];\n  mavlink_msg.payload64[5] = msg.payload64[5];\n  mavlink_msg.payload64[6] = msg.payload64[6];\n  mavlink_msg.payload64[7] = msg.payload64[7];\n  mavlink_msg.len = msg.len;\n  mavlink_msg.checksum = msg.checksum;\n  mavlink_msg.seq = msg.seq;\n\n  mavlink_heartbeat_t heartbeat;\n  mavlink_msg_heartbeat_decode(&mavlink_msg, &heartbeat);\n\n  if (heartbeat.type != MAV_TYPE_GCS) {\n    return;\n  }\n\n  if (m_target_sysid == 0) {\n    m_target_sysid = heartbeat.system_id;\n    mavlink_request_data_stream(m_target_sysid, m_target_compid, MAVLINK_DATA_STREAM_POSITION, 1, 10);\n    mavlink_request_data_stream(m_target_sysid, m_target_compid, MAVLINK_DATA_STREAM_AIR_PRESSURE, 1, 10);\n  }\n", "CodeBleu_score": 45.09241715926461}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\n\tif (target_set) {\n\t\treturn;\n\t}\n\n\tmavlink_msg_id id = (mavlink_msg_id)msg.msgid;\n\n\tif (id != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n\t    id != MAVLINK_MSG_ID_ATTITUDE &&\n\t    id != MAVLINK_MSG_ID_ATTITUDE_QUATERNION &&\n\t    id != MAVLINK_MSG_ID_GPS_RAW_INT &&\n\t    id != MAVLINK_MSG_ID_SYS_STATUS &&\n\t    id != MAVLINK_MSG_ID_VFR_HUD &&\n\t    id != MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n\t    id != MAVLINK_MSG_ID_GPS_RAW_INT &&\n\t    id != MAVLINK_MSG_ID_EXTENDED_SYS_STATE &&\n\t    id != MAVLINK_MSG_ID_HIGHRES_IMU &&\n\t    id != MAVLINK_MSG_ID_SCALED_PRESSURE &&\n\t    id != MAVLINK_MSG_ID_DISTANCE_SENSOR) {\n\t\treturn;\n\t}\n\n\tif (target_system_id == 0) {\n\t\ttarget_system_id = msg.sysid;\n\t\tmavlink_request_data_stream(mavlink_fd, target_system_id, target_component_id,\n\t\t\t\t\t    MAVLINK_DATA_STREAM_POSITION, 1);\n\t\tmavlink_request_data_stream(mavlink_fd, target_system_id, target_component_id,\n\t\t\t\t\t    MAVLINK_DATA_STREAM_EXTRA1, 1);\n\t\tmavlink_request_data_stream(mavlink_fd, target_system_id, target_component_id,\n\t\t\t\t\t    MAV", "CodeBleu_score": 31.610854178913723}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = _handle_command_preflight_calibration(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _calibration_baro_pending = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 50.26486412160261}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_altitude_calibration = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 56.8217366181951}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n\n    /* call base class handler first */\n    result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _need_alt_calibration = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 62.988470824356945}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (packet.param1 == 1.0) {\n        result = MAV_RESULT_ACCEPTED;\n        _servos.arm();\n    } else if (packet.param1 == 0) {\n        result = MAV_RESULT_ACCEPTED;\n        _servos.disarm();\n    }\n    return result;\n}\n", "CodeBleu_score": 58.88818499624895}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    MAV_RESULT result = MAV_RESULT_UNSUPPORTED;\n    if (packet.param1 == 1.0) {\n        result = MAV_RESULT_ACCEPTED;\n        servos_armed = true;\n    } else if (packet.param1 == 0.0) {\n        result = MAV_RESULT_ACCEPTED;\n        servos_armed = false;\n    }\n    return result;\n}\n", "CodeBleu_score": 52.70035098829804}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    if (packet.param1 == 1.0) {\n        // arm\n        set_arm_state(true);\n        return MAV_RESULT_ACCEPTED;\n    } else if (packet.param1 == 0.0) {\n        // disarm\n        set_arm_state(false);\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}\n", "CodeBleu_score": 57.451901243274165}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    // Iterate over all GCS channels\n    for (uint8_t i = 0; i < GCS_CHANNELS; i++) {\n        // If channel is available\n        if (gcs_channels[i].available()) {\n            // If channel has enough space\n            if (gcs_channels[i].space_available()) {\n                // Send request to start data stream\n                gcs_channels[i].send_message(GCS_Message::DATASTREAM_REQUEST, sysid, compid, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ", "CodeBleu_score": 42.28743396330261}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    // iterate over all available channels\n    for (uint8_t i = 0; i < GCS_MAX_CHANNELS; i++) {\n        if (gcs_channels[i].status == GCS_CHANNEL_STATUS_AVAILABLE) {\n            // check if we have enough space to send a request\n            if (gcs_channels[i].payload_length >= MAVLINK_MSG_ID_DATA_STREAM_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n                // send request\n                mavlink_msg_data_stream_pack(GCS_SYSTEM_ID, GCS_COMPONENT_ID, &gcs_channels[i].msgbuf, i, sysid, compid, MAV_DATA_STREAM_POSITION, 10);\n                gcs_channels[i].status = GCS_CHANNEL_STATUS_BUSY;\n                gcs_channels[i].payload_length = 0;\n                return;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 48.29154469552428}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    // check for space on each channel\n    for (uint8_t i = 0; i < _num_channels; i++) {\n        // check if channel is available\n        if (!_channels[i].is_available()) {\n            continue;\n        }\n        // check if channel is already streaming\n        if (_channels[i].is_streaming_position(sysid, compid)) {\n            continue;\n        }\n        // check if channel has space for a new stream\n        if (_channels[i].get_available_payload() < MAVLINK_MSG_ID_GLOBAL_POSITION_INT_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES) {\n            continue;\n        }\n        // send request to start streaming\n        mavlink_message_t msg;\n        mavlink_msg_gcs_send_message_pack(GCS_SYSTEM_ID, GCS_COMPONENT_ID, &msg, GCS_MESSAGE_START_DATA_STREAM,\n                                          sysid, compid, MAV_DATA_STREAM_POSITION);\n        _channels[i].send_message(&msg);\n        // add stream to channel\n        _channels[i].add_stream_position(sysid, compid);\n    }\n}\n", "CodeBleu_score": 47.137161151363735}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    if (ahrs.get_pitch_cos() != 0) {\n        ef_pitch = atan2(ahrs.get_pitch_sin(), ahrs.get_pitch_cos()) + pitch;\n        ef_yaw = yaw - ahrs.get_yaw();\n        return true;\n    } else {\n        return false;\n    }\n}\n", "CodeBleu_score": 45.74196895825284}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)  // Retrieve the AHRS instance\n  AHRS* ahrs = AHRS::GetInstance();\n\n  // Check for a zero pitch cosine to avoid division by zero\n  if (ahrs->GetPitchCosine() != 0) {\n    // Calculate the earth frame pitch and yaw using trigonometric conversions\n    ef_pitch = atan2(ahrs->GetPitchSine(), ahrs->GetPitchCosine());\n    ef_yaw = atan2(ahrs->GetRollSine(), ahrs->GetRollCosine());\n\n    // Return true\n    return true;\n  }\n\n  // Return false\n  return false;\n}\n", "CodeBleu_score": 39.165050127318835}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    AHRS* ahrs = AHRS::getInstance();\n    float pitch_cos = cos(pitch);\n    if (pitch_cos != 0) {\n        ef_pitch = atan2(ahrs->getWorldLinearAccelY(), ahrs->getWorldLinearAccelX());\n        ef_yaw = atan2(ahrs->getWorldLinearAccelX() * sin(pitch), ahrs->getWorldLinearAccelY() * sin(pitch) + ahrs->getWorldLinearAccelZ() * cos(pitch));\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 41.916391053380394}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)  // Calculate the target yaw and pitch in centidegrees\n  float target_yaw = (float)nav.get_bearing() * 100.0;\n  float target_pitch = (float)nav.get_pitch() * 100.0;\n\n  // Check if the direction is reversed\n  if (nav.get_direction() == 1) {\n    target_yaw = -target_yaw;\n    target_pitch = -target_pitch;\n  }\n\n  // Calculate the angle error\n  float yaw_error = target_yaw - (float)servo_yaw * 100.0;\n  float pitch_error = target_pitch - (float)servo_pitch * 100.0;\n\n  // Convert the errors from earth frame to body frame\n  float yaw_error_body = yaw_error;\n  float pitch_error_body = pitch_error;\n  if (nav.get_direction() == 1) {\n    yaw_error_body = -yaw_error;\n    pitch_error_body = -pitch_error;\n  }\n\n  // Update the pitch and yaw servos\n  if (nav.get_distance() > nav.get_min_distance() || nav.get_min_distance() == 0) {\n    servo_yaw = nav.get_bearing();\n    servo_pitch = nav.get_pitch();\n    if (nav.get_direction() == 1) {\n      servo_yaw = -servo_yaw;\n      servo_pitch = -servo_pitch;\n    }\n    servo_yaw = constrain(servo_yaw, -180, 180);\n    servo_pitch = constrain(servo_pitch, -90, 90);\n    servo_yaw = map(servo_yaw, -180, 180, SERVO_YAW_MIN, SERVO_YAW_MAX);\n    servo_pitch = map(servo_pitch, -", "CodeBleu_score": 37.29626725778278}, {"code": "void Mode::update_auto(void)\n  // Get the current navigation status\n  nav_status_t nav_status = nav_status_get();\n\n  // Get the current navigation parameters\n  nav_params_t nav_params = nav_params_get();\n\n  // Calculate the target yaw and pitch in centidegrees\n  int16_t target_yaw = nav_params.yaw_target * 100;\n  int16_t target_pitch = nav_params.pitch_target * 100;\n\n  // Check if the direction is reversed\n  bool reversed = false;\n  if (nav_params.reverse_direction) {\n    reversed = true;\n  }\n\n  // Calculate the angle error\n  int16_t yaw_error = target_yaw - nav_status.yaw_angle;\n  int16_t pitch_error = target_pitch - nav_status.pitch_angle;\n\n  // Convert the errors from earth frame to body frame\n  int16_t yaw_error_body = yaw_error;\n  int16_t pitch_error_body = pitch_error;\n  if (reversed) {\n    yaw_error_body = -yaw_error;\n    pitch_error_body = -pitch_error;\n  }\n\n  // If the target distance is valid or no minimum distance is set, update the pitch and yaw servos\n  if (nav_status.target_distance_valid || nav_params.min_distance == 0) {\n    // Update the yaw servo\n    int16_t yaw_servo_target = yaw_error_body;\n    if (nav_params.yaw_servo_reverse) {\n      yaw_servo_target = -yaw_servo_target;\n    }\n    yaw_servo_target = constrain(yaw_servo_target, nav_params.yaw_servo_min, nav_params.yaw_servo_max);\n    yaw_servo_target = map(yaw_servo_target, nav_params.yaw_servo_min, nav_", "CodeBleu_score": 35.69333262418171}, {"code": "void Mode::update_auto(void)  // Calculate the target yaw and pitch in centidegrees\n  // Calculate the yaw error\n  int16_t yaw_error = target_yaw - nav_yaw;\n  // Calculate the pitch error\n  int16_t pitch_error = target_pitch - nav_pitch;\n  // Check if the direction is reversed\n  if (yaw_error > 180) {\n    yaw_error -= 360;\n  } else if (yaw_error < -180) {\n    yaw_error += 360;\n  }\n  // Check if the direction is reversed\n  if (pitch_error > 180) {\n    pitch_error -= 360;\n  } else if (pitch_error < -180) {\n    pitch_error += 360;\n  }\n  // Convert the errors from earth frame to body frame\n  int16_t yaw_error_body = yaw_error + nav_roll;\n  int16_t pitch_error_body = pitch_error + nav_pitch;\n  // Check if the target distance is valid or no minimum distance is set\n  if (target_distance_valid || target_distance_min == 0) {\n    // Calculate the yaw servo target\n    yaw_servo_target = yaw_error_body * K_YAW_P;\n    // Calculate the pitch servo target\n    pitch_servo_target = pitch_error_body * K_PITCH_P;\n  }\n}\n", "CodeBleu_score": 23.708703825866433}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)    // Update the GPS\n    GPS_Update();\n    // Check if the last message time has changed\n    if (GPS_last_message_time != GPS_last_message_time_prev) {\n        // If the GPS status is at least 3D fix\n        if (GPS_status >= 3) {\n            // If the countdown is not zero\n            if (countdown != 0) {\n                // Reset the countdown\n                countdown = 0;\n            }\n            // If the current location is valid\n            if (GPS_is_valid_location()) {\n                // If the home location is not set\n                if (!home_set) {\n                    // Set the home location\n                    set_home_location();\n                }\n            }\n        }\n    }\n    // Update the previous last message time\n    GPS_last_message_time_prev = GPS_last_message_time;\n}\n", "CodeBleu_score": 27.380589001705797}, {"code": "void Tracker::update_GPS(void)\t// Update the GPS data\n\tgps.update();\n\n\t// Check if the last message time has changed and if the GPS status is at least 3D fix\n\tif ((gps.last_message_time != last_message_time) && (gps.status >= 3)) {\n\t\t// If the location is valid, set the home location\n\t\tif (gps.location.isValid()) {\n\t\t\thome_location = gps.location;\n\t\t\thome_location_set = true;\n\t\t}\n\t\t// If the location is invalid, reset the countdown\n\t\telse {\n\t\t\thome_location_set = false;\n\t\t\thome_location_countdown = HOME_LOCATION_COUNTDOWN_MAX;\n\t\t}\n\t\t// Set the last message time to the current time\n\t\tlast_message_time = gps.last_message_time;\n\t}\n\n\t// Manage a countdown for ground start\n\tif (home_location_countdown > 0) {\n\t\thome_location_countdown--;\n\t}\n\t// If the countdown reaches one, set the home location if the current location is valid\n\tif (home_location_countdown == 1) {\n\t\tif (gps.location.isValid()) {\n\t\t\thome_location = gps.location;\n\t\t\thome_location_set = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 40.331102620471384}, {"code": "void Tracker::update_GPS(void)    static unsigned long last_message_time = 0;\n    static unsigned long ground_start_countdown = 0;\n\n    if (gps.time.value() != last_message_time) {\n        last_message_time = gps.time.value();\n\n        if (gps.status >= 3) {\n            if (ground_start_countdown > 0) {\n                ground_start_countdown--;\n                if (ground_start_countdown == 0) {\n                    set_home_location();\n                }\n            }\n        } else {\n            ground_start_countdown = 1000;\n        }\n    }\n}\n", "CodeBleu_score": 40.232573703903725}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch > 0) {\n\t\t//pitch on\n\t\tif (pitch > 180) {\n\t\t\tpitch = 180;\n\t\t}\n\t\tpitch = pitch / 180.0;\n\t\tpitch = pitch * 255;\n\t\tpitch = 255 - pitch;\n\t\tpitch = pitch + 128;\n\t\tpitch = pitch * 2;\n\t\tpitch = pitch + 100;\n\t\tpitch = constrain(pitch, 100, 200);\n\t\tanalogWrite(PITCH_ONOFF_SERVO_PIN, pitch);\n\t} else {\n\t\t//pitch off\n\t\tanalogWrite(PITCH_ONOFF_SERVO_PIN, 100);\n\t}\n}\n", "CodeBleu_score": 18.451595449983838}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    if (pitch > 0.0f) {\n        pitch_onoff_servo.write(180);\n    } else {\n        pitch_onoff_servo.write(0);\n    }\n}\n", "CodeBleu_score": 13.430007715687974}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    if (pitch > 0.0f) {\n        //pitch_onoff_servo.write(pitch_onoff_servo_max_angle);\n        pitch_onoff_servo.write(pitch_onoff_servo_min_angle);\n    } else {\n        //pitch_onoff_servo.write(pitch_onoff_servo_min_angle);\n        pitch_onoff_servo.write(pitch_onoff_servo_max_angle);\n    }\n}\n", "CodeBleu_score": 14.449091757121476}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    // call parent class barometer_checks\n    if (!AP_Arming_Plane::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check barometer reference\n    if (g.arming_check_baro) {\n        // check barometer reference\n        if (!barometer.healthy()) {\n            if (display_failure) {\n                gcs_send_text_fmt(PSTR(\"Baro reference check failed\"));\n            }\n            return false;\n        }\n\n        // check barometer altitude\n        float baro_alt = barometer.get_altitude();\n        float inertial_alt = inertial_nav.get_altitude();\n        float baro_alt_err = abs(baro_alt - inertial_alt);\n        if (baro_alt_err > g.arming_baro_threshold) {\n            if (display_failure) {\n                gcs_send_text_fmt(PSTR(\"Baro altitude check failed (%dm)\"), (int)baro_alt_err);\n            }\n            return false;\n        }\n    }\n\n    // return success\n    return true;\n}\n", "CodeBleu_score": 45.85916469211517}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    if (!AP_Arming_Copter_Base::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    if (arming.check_baro_ref) {\n        // check barometer reference\n        if (barometer.get_reference_pressure() == 0) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Barometer reference not set\");\n            }\n            return false;\n        }\n    }\n\n    // check barometer altitude\n    if (arming.check_baro_alt) {\n        if (abs(barometer.get_altitude() - inertial_nav.get_altitude()) > arming.baro_alt_threshold) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Barometer altitude error: %dm\", (int)abs(barometer.get_altitude() - inertial_nav.get_altitude()));\n            }\n            return false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 48.135269846085194}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    bool ret = AP_Arming_Base::barometer_checks(display_failure);\n    if (ret && _arming_check_baro) {\n        // check barometer reference\n        if (!_barometer.healthy()) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Baro reference failed\\n\"));\n            }\n            ret = false;\n        } else {\n            // check barometer altitude\n            float baro_alt = _barometer.get_altitude();\n            float inertial_alt = _inertial_nav.get_altitude();\n            float alt_diff = fabsf(baro_alt - inertial_alt);\n            if (alt_diff > _baro_alt_max_diff) {\n                if (display_failure) {\n                    hal.console->printf_P(PSTR(\"Baro altitude %f too far from inertial altitude %f\\n\"),\n                                          (double)baro_alt, (double)inertial_alt);\n                }\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}\n", "CodeBleu_score": 50.07196355087133}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const    if (get_terrain_source() == terrain_source_t::RANGEFINDER) {\n        return false;\n    } else if (get_terrain_source() == terrain_source_t::TERRAIN_DATABASE &&\n               get_rtl_alt_type() == rtl_alt_type_t::TERRAIN) {\n        return true;\n    }\n    return AP_Arming_Copter_Base::terrain_database_required();\n}\n", "CodeBleu_score": 54.3594881352466}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    if (rtl_alt_type() == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming_Copter_Base::terrain_database_required();\n}\n", "CodeBleu_score": 27.400787194653702}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    return (get_terrain_source() == TERRAIN_SOURCE_TERRAIN_DATABASE &&\n            _rtl_alt_type == RTL_ALT_TYPE_TERRAIN);\n}\n", "CodeBleu_score": 9.806799691473236}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()    // get the time of this loop\n    uint32_t now = micros();\n\n    // calculate the time since the last loop\n    uint32_t delta_time = now - last_loop_time;\n\n    // set the loop time for the attitude controller\n    attitude_control.set_loop_time_us(delta_time);\n\n    // set the loop time for the position controller\n    position_control.set_loop_time_us(delta_time);\n\n    // set the loop time for the motor controller\n    motor_control.set_loop_time_us(delta_time);\n\n    // run the rate controller\n    rate_controller_run();\n\n    // remember the last time we ran the rate controller\n    last_loop_time = now;\n}\n", "CodeBleu_score": 48.743841504473494}, {"code": "void Copter::run_rate_controller()    // run the rate controllers\n    // --------------------------------------------------------------------------------------------------------------\n    // get the time from the scheduler\n    uint32_t now = scheduler.micros();\n\n    // calculate the delta time in seconds\n    float dt = (float)(now - last_run) / 1000000.0f;\n\n    // set the last run time to now\n    last_run = now;\n\n    // run the rate controllers\n    attitude_control.rate_controller_run(dt);\n    position_control.rate_controller_run(dt);\n    motor_control.rate_controller_run(dt);\n}\n", "CodeBleu_score": 47.59698439142801}, {"code": "void Copter::run_rate_controller()    // get loop time\n    uint32_t now = get_time();\n    uint32_t dt = now - last_loop_time;\n    last_loop_time = now;\n\n    // set loop time for controllers that require it\n    attitude_control.set_dt(dt);\n    position_control.set_dt(dt);\n    motor_control.set_dt(dt);\n\n    // run attitude controller\n    attitude_control.rate_controller_run();\n\n    // run position controller\n    position_control.rate_controller_run();\n\n    // run motor controller\n    motor_control.rate_controller_run();\n}\n", "CodeBleu_score": 48.96492429908725}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    // if the old location matches the new location and the altitude frames are the same, then we don't need to update the target location\n    if (old_loc.equals(new_loc) && old_loc.alt_relative() == new_loc.alt_relative()) {\n        return false;\n    }\n    // set the new location as the target\n    set_target_location(new_loc);\n    return true;\n}\n", "CodeBleu_score": 50.76428489363624}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    if (old_loc.alt == new_loc.alt) {\n        if (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng) {\n            return false;\n        }\n    }\n    target_location = new_loc;\n    return true;\n}\n", "CodeBleu_score": 44.6267320951504}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    // check if we have a new waypoint\n    if (waypoint_manager.get_next_waypoint_id() != current_waypoint_id) {\n        // check if the waypoint is the same as the old location\n        if (waypoint_manager.get_next_waypoint_location() == old_loc.location) {\n            // check if the altitude frames are the same\n            if (waypoint_manager.get_next_waypoint_alt_frame() == old_loc.alt_frame) {\n                // set the new waypoint as the target\n                target_location = waypoint_manager.get_next_waypoint_location();\n                return true;\n            }\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 40.583435206981264}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (aux_function_active(ch_flag)) {\n        // if the switch is in the HIGH position, set the mode\n        if (aux_function_on(ch_flag)) {\n            if (mode != get_mode()) {\n                set_mode(mode);\n            }\n        } else {\n            // if the switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n            if (mode == get_mode()) {\n                rc().reset_mode_switch();\n            }\n        }\n    }\n}\n", "CodeBleu_score": 55.25659446175148}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)  // check if the switch is in the HIGH position\n  if (aux_function_on(ch_flag)) {\n    // set the mode\n    copter.set_mode(mode);\n  } else {\n    // check if the current flight mode matches the given mode\n    if (copter.control_mode() == mode) {\n      // reset the mode switch\n      rc().reset_mode_switch();\n    }\n  }\n}\n", "CodeBleu_score": 61.0058227766753}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (aux_function == AUX_FUNCTION_MODE_CHANGE) {\n        if (aux_switch_pos == ch_flag) {\n            if (aux_switch_pos == AUX_SWITCH_POS_HIGH) {\n                // set_mode will return true if the mode was changed\n                if (set_mode(mode)) {\n                    // reset the mode switch\n                    rc().reset_mode_switch();\n                }\n            } else {\n                // if the switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n                if (get_mode() == mode) {\n                    rc().reset_mode_switch();\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 55.84572667750179}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()    // get the roll and pitch control input values\n    float roll_input = get_pilot_desired_roll();\n    float pitch_input = get_pilot_desired_pitch();\n\n    // calculate the trim values from the control inputs\n    float roll_trim = roll_input * 0.01745329251994329576923690768489f;\n    float pitch_trim = pitch_input * 0.01745329251994329576923690768489f;\n\n    // add the trim values to the AHRS\n    ahrs.set_trim(roll_trim, pitch_trim);\n\n    // log the event\n    Log_Write_Event(DATA_TRIM_SAVED);\n\n    // send a confirmation message\n    mavlink_log_info(&mavlink_log_pub, \"Trim values saved\");\n}\n", "CodeBleu_score": 45.50216947413016}, {"code": "void Copter::save_trim()    // calculate the trim values from the control inputs of the roll and pitch channels\n    int16_t roll_input = get_radio_in(RC_ROLL);\n    int16_t pitch_input = get_radio_in(RC_PITCH);\n\n    // convert to radians\n    float roll_trim = roll_input * 0.01745329252f;\n    float pitch_trim = pitch_input * 0.01745329252f;\n\n    // add the trim values to the AHRS trim\n    ahrs.set_trim(roll_trim, pitch_trim);\n\n    // log the event\n    Log_Write_Event(DATA_TRIM_SAVED);\n\n    // send confirmation message\n    mavlink_log_info(&mavlink_log_pub, \"Trim values saved\");\n}\n", "CodeBleu_score": 44.77054697862346}, {"code": "void Copter::save_trim()    // calculate the trim values from the control inputs of the roll and pitch channels\n    int16_t roll_trim = 0;\n    int16_t pitch_trim = 0;\n    if (channel_roll->control_in > 0) {\n        roll_trim = channel_roll->control_in;\n    } else {\n        roll_trim = -channel_roll->control_in;\n    }\n    if (channel_pitch->control_in > 0) {\n        pitch_trim = channel_pitch->control_in;\n    } else {\n        pitch_trim = -channel_pitch->control_in;\n    }\n    // convert to radians\n    roll_trim = (int16_t)((float)roll_trim * 0.01745329252f);\n    pitch_trim = (int16_t)((float)pitch_trim * 0.01745329252f);\n    // add to AHRS trim\n    ahrs.add_trim(roll_trim, pitch_trim);\n    // log event\n    Log_Write_Event(DATA_TRIM_SAVED);\n    // send confirmation message\n    mavlink_log_info(&mavlink_log_pub, \"trim saved\");\n}\n", "CodeBleu_score": 41.28727089267486}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()    // get the copter's velocity\n    float x_vel = copter.get_velocity().x;\n    float y_vel = copter.get_velocity().y;\n    float z_vel = copter.get_velocity().z;\n\n    // calculate the speed squared\n    float speed_squared = x_vel*x_vel + y_vel*y_vel + z_vel*z_vel;\n\n    // if the copter's position is valid and the speed exceeds a minimum threshold\n    if (copter.get_position_valid() && speed_squared > MIN_SPEED_SQUARED) {\n        // update the look-ahead yaw angle using the arctangent of the velocity components\n        look_ahead_yaw_angle = atan2(y_vel, x_vel);\n    }\n\n    // return the computed look-ahead yaw angle\n    return look_ahead_yaw_angle;\n}\n", "CodeBleu_score": 45.98090707853254}, {"code": "float Mode::AutoYaw::look_ahead_yaw()    // Get velocity vector\n    const Vector3f& velocity = _vehicle->get_velocity();\n    // Calculate speed squared\n    float speed_sq = velocity.lengthSq();\n    // Check if copter's position is valid and speed exceeds minimum threshold\n    if (_vehicle->get_position().is_valid() && speed_sq > _min_speed_sq) {\n        // Calculate look-ahead yaw angle using arctangent of velocity components\n        _look_ahead_yaw = atan2f(velocity.y, velocity.x);\n    }\n    // Return look-ahead yaw angle\n    return _look_ahead_yaw;\n}\n", "CodeBleu_score": 53.41172722518033}, {"code": "float Mode::AutoYaw::look_ahead_yaw()    // get the velocity vector\n    Vector3f velocity = _vehicle->getVelocity();\n\n    // get the velocity squared\n    float speed_squared = velocity.lengthSq();\n\n    // if the velocity is valid and the speed exceeds the minimum threshold\n    if (_vehicle->isValid() && speed_squared > _min_speed_squared) {\n        // calculate the look-ahead yaw angle using the arctangent of the velocity components\n        _look_ahead_yaw = atan2(velocity.y, velocity.x);\n    }\n\n    // return the look-ahead yaw angle\n    return _look_ahead_yaw;\n}\n", "CodeBleu_score": 47.29750077176848}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    // rudder arming check\n    if (method == AP_Arming::RUDDER) {\n        // rudder arming disabled or throttle not zero\n        if (_rudder_arming_disabled || _rudder_arming_throttle_zero) {\n            return false;\n        }\n    }\n    // watchdog armed or arming checks disabled\n    if (_watchdog_armed || _arming_checks_disabled) {\n        return true;\n    }\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 38.31962661348802}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    // rudder arming check\n    if (method == AP_Arming::RUDDER) {\n        if (!_rudder_arming_enabled || _throttle_zero == false) {\n            return false;\n        }\n    }\n\n    // bypass arming checks if watchdog armed or disabled\n    if (!_arming_checks_enabled || _watchdog_armed) {\n        return true;\n    }\n\n    // call parent class arm_checks\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 38.12986689047222}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (method == AP_Arming::RUDDER) {\n        if (disable_rudder_checks || _throttle_zero == false) {\n            return false;\n        }\n    }\n    return AP_Arming_Base::arm_checks(method);\n}\n", "CodeBleu_score": 28.708910015556576}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    // do we need to do arming checks?\n    if (do_arming_checks) {\n        // do we need to do a pre-arm check?\n        if (method == AP_Arming::PreArm) {\n            // do the pre-arm checks\n            if (!pre_arm_check()) {\n                return false;\n            }\n        }\n\n        // do we need to do a safety check?\n        if (method == AP_Arming::Safety || method == AP_Arming::Safety_Always) {\n            // do the safety checks\n            if (!safety_check()) {\n                return false;\n            }\n        }\n\n        // do we need to do a pre-arm check?\n        if (method == AP_Arming::PreArm_Always) {\n            // do the pre-arm checks\n            if (!pre_arm_check()) {\n                return false;\n            }\n        }\n\n        // do we need to do a safety check?\n        if (method == AP_Arming::Safety_Always) {\n            // do the safety checks\n            if (!safety_check()) {\n                return false;\n            }\n        }\n    }\n\n    // set home location if not already set\n    if (!_home_is_set) {\n        if (!set_home()) {\n            return false;\n        }\n    }\n\n    // set current location\n    set_current_location();\n\n    // set arm state\n    set_arm_state(true);\n\n    // set delay arming flag\n    _delay_arming_flag = true;\n\n    // send status text\n    send_status_text(AP_Arming::Armed);\n\n    // return true if successful\n    return true;\n}\n", "CodeBleu_score": 42.416273250222055}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    if (do_arming_checks) {\n        if (!check_throttle_arming()) {\n            return false;\n        }\n        if (!check_battery_arming()) {\n            return false;\n        }\n        if (!check_pilot_inputs_arming()) {\n            return false;\n        }\n        if (!check_failsafe_arming()) {\n            return false;\n        }\n        if (!check_radio_arming()) {\n            return false;\n        }\n        if (!check_geofence_arming()) {\n            return false;\n        }\n        if (!check_gps_arming()) {\n            return false;\n        }\n        if (!check_compass_arming()) {\n            return false;\n        }\n        if (!check_airspeed_arming()) {\n            return false;\n        }\n        if (!check_esc_arming()) {\n            return false;\n        }\n        if (!check_avionics_arming()) {\n            return false;\n        }\n        if (!check_motors_arming()) {\n            return false;\n        }\n        if (!check_servos_arming()) {\n            return false;\n        }\n        if (!check_capability_arming()) {\n            return false;\n        }\n    }\n\n    // set home location\n    if (method == AP_Arming::ARMING_METHOD_STABILIZE) {\n        if (!_home_is_set) {\n            set_home_to_current_location();\n        }\n    }\n\n    // set current location\n    set_current_location();\n\n    // set arming state\n    _arming_state = AP_Arming::ARMING_STATE_ARMED;\n\n    // set delay arming flag\n    _delay_armed = true;\n\n    // send status text\n    if (method == AP_Arming::ARMING_METHOD_STABILIZE) {\n        hal.console->printf_P(PSTR(\"Throttle armed\\n\"));\n    } else if (method == AP_Arming::AR", "CodeBleu_score": 32.2933957824396}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    // if we are already armed, do nothing\n    if (armed) {\n        return true;\n    }\n\n    // if we are not in a position to arm, do nothing\n    if (!can_arm()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n    // if we are in a position to arm, but we are not allowed to arm, do nothing\n    if (!allow_arming()) {\n        return false;\n    }\n\n", "CodeBleu_score": 25.365167003322803}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    if (arming.is_armed()) {\n        return true;\n    }\n\n    // check for disarm button\n    if (disarm_button == NULL) {\n        if (display_failure) {\n            gcs_send_text_fmt(MAV_SEVERITY_WARNING, \"Disarm button not configured\");\n        }\n        return false;\n    }\n\n    // run standard pre-arm checks\n    return arming.pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 62.82118307214296}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\n    if (_vehicle->is_armed()) {\n        return true;\n    }\n\n    if (!_vehicle->get_disarm_button_configured()) {\n        if (display_failure) {\n            _vehicle->scheduler.notify_printf(PSTR(\"Arming failed: Disarm button not configured.\"));\n        }\n        return false;\n    }\n\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 62.86106075146578}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    if (armed()) {\n        return true;\n    }\n\n    // check if disarm button is configured\n    if (disarm_button.get_button() == 0) {\n        // disarm button not configured\n        if (display_failure) {\n            hal.console->printf_P(PSTR(\"Disarm button not configured\\n\"));\n        }\n        return false;\n    }\n\n    // proceed with standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 64.08000661908105}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    // Rotation matrix\n    float rotation_matrix[2][2] = {\n        {cos(yaw), -sin(yaw)},\n        {sin(yaw), cos(yaw)}\n    };\n\n    // Rotate the coordinates\n    float ne_x = x * rotation_matrix[0][0] + y * rotation_matrix[0][1];\n    float ne_y = x * rotation_matrix[1][0] + y * rotation_matrix[1][1];\n\n    // Update the coordinates\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 47.90134656892719}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)  float ne_x;\n  float ne_y;\n\n  // Rotation matrix\n  float R[2][2] = {\n    {cos(ahrs.yaw), -sin(ahrs.yaw)},\n    {sin(ahrs.yaw), cos(ahrs.yaw)}\n  };\n\n  // Apply the rotation matrix\n  ne_x = x * R[0][0] + y * R[0][1];\n  ne_y = x * R[1][0] + y * R[1][1];\n\n  // Update x and y with the new coordinates\n  x = ne_x;\n  y = ne_y;\n}\n", "CodeBleu_score": 54.15118172698848}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\n\t// Rotation matrix to rotate from body frame to North-East frame\n\tfloat R_body_to_NE[2][2];\n\tR_body_to_NE[0][0] = cos(ahrs.yaw);\n\tR_body_to_NE[0][1] = -sin(ahrs.yaw);\n\tR_body_to_NE[1][0] = sin(ahrs.yaw);\n\tR_body_to_NE[1][1] = cos(ahrs.yaw);\n\n\t// Rotate the coordinates x and y from the body frame to the North-East frame\n\tfloat ne_x = R_body_to_NE[0][0]*x + R_body_to_NE[0][1]*y;\n\tfloat ne_y = R_body_to_NE[1][0]*x + R_body_to_NE[1][1]*y;\n\n\t// Update x and y with the new values\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 49.10725921744837}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    MAV_RESULT result = MAV_RESULT_DENIED;\n    if (packet.param4 < 0.0f || packet.param4 > 360.0f) {\n        return result;\n    }\n    if (packet.param1 < 0.0f || packet.param1 > 360.0f) {\n        return result;\n    }\n    if (packet.param2 < 0.0f || packet.param2 > 180.0f) {\n        return result;\n    }\n    if (packet.param3 < 0.0f || packet.param3 > 1.0f) {\n        return result;\n    }\n    result = MAV_RESULT_ACCEPTED;\n    return result;\n}\n", "CodeBleu_score": 50.73257134568745}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    // Check if the yaw angle and param4 values are within acceptable ranges\n    if (packet.param1 >= 0.0f && packet.param1 <= 360.0f && packet.param4 >= 0.0f && packet.param4 <= 1.0f) {\n        // Set the yaw heading using the provided parameters\n        _vehicle->set_yaw_heading(packet.param1, packet.param4);\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_DENIED;\n    }\n}\n", "CodeBleu_score": 49.49959100193681}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    MAV_RESULT result = MAV_RESULT_ACCEPTED;\n    if (packet.param4 >= 0 && packet.param4 <= 360) {\n        yaw_condition_ = packet.param4;\n        yaw_condition_set_ = true;\n    } else {\n        result = MAV_RESULT_DENIED;\n    }\n    return result;\n}\n", "CodeBleu_score": 32.80088235238098}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\tuint8_t ret = 0;\n\tif (control_mode == AUTO || control_mode == GUIDED) {\n\t\tif (waypoint_bearing >= 0) {\n\t\t\tret = (waypoint_bearing / 100) / 2;\n\t\t} else {\n\t\t\tret = (36000 + waypoint_bearing) / 100 / 2;\n\t\t}\n\t}\n\treturn ret;\n}\n", "CodeBleu_score": 40.68941344009806}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if (control_mode == MAV_MODE_AUTO_ARMED || control_mode == MAV_MODE_GUIDED_ARMED) {\n        return (waypoint_bearing + 18000) / 2;\n    } else {\n        return 0;\n    }\n}\n", "CodeBleu_score": 38.19839413552395}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    return _high_latency_tgt_heading;\n}\n", "CodeBleu_score": 5.8809906132134815}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (log_enabled) {\n        Log_Packet packet = {\n            .time = (uint32_t)time(NULL),\n            .id = id,\n            .value = value\n        };\n        Log_Write_Packet(&packet);\n    }\n}\n", "CodeBleu_score": 37.43384166315923}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (m_log_enabled) {\n\t\t// Create the packet\n\t\tLogPacket packet;\n\t\tpacket.time = m_log_time;\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\n\t\t// Write the packet as a critical block\n\t\tm_log_file.WriteCriticalBlock(packet);\n\t}\n}\n", "CodeBleu_score": 35.24587125856529}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (log_enabled) {\n        LogPacket packet;\n        packet.time = Get_Time();\n        packet.id = id;\n        packet.value = value;\n        Log_Write_Packet(packet);\n    }\n}\n", "CodeBleu_score": 40.017353510663206}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()  if (home_is_set()) {\n    return;\n  }\n\n  if (motors_armed()) {\n    set_home_to_current_location();\n    return;\n  }\n\n  // Attempt to set the home location to the current EKF location.\n  // If this fails, ignore the failure and return.\n  set_home_to_current_EKF_location();\n}\n", "CodeBleu_score": 26.71969037897081}, {"code": "void Sub::update_home_from_EKF()\tif (home_is_set()) {\n\t\treturn;\n\t}\n\n\tif (armed()) {\n\t\tset_home_to_current_location();\n\t} else {\n\t\tset_home_to_EKF_location();\n\t}\n}\n", "CodeBleu_score": 24.452295523711726}, {"code": "void Sub::update_home_from_EKF()  if (home_is_set()) {\n    return;\n  }\n\n  // If the motors are armed, we set the home position to the current location.\n  // This is important for the EKF to be able to use GPS data to constrain its\n  // position estimate.\n  if (armed()) {\n    set_home_to_current_location();\n    return;\n  }\n\n  // If the motors are not armed, we attempt to set the home position to the\n  // current EKF position.\n  //\n  // We ignore any failure in this attempt.\n  //\n  // This is because it is possible that the EKF has not converged and so the\n  // current position is not a good representation of the home position.\n  //\n  // However, we still want to set the home position so that the EKF can\n  // constrain its position estimate to be within a reasonable distance of the\n  // home position.\n  //\n  // We don't want to set the home position to the current GPS location because\n  // we don't want the EKF to be constrained to the accuracy of the GPS\n  // position.\n  //\n  // We don't want to set the home position to the current barometer altitude\n  // because we don't want the EKF to be constrained to the accuracy of the\n  // barometer.\n  //\n  // We don't want to set the home position to the current accelerometer\n  // altitude because we don't want the EKF to be constrained to the accuracy\n  // of the accelerometer.\n  //\n  // We don't want to set the home position to the current GPS altitude because\n  // we don't want the EKF to be constrained to the accuracy of the GPS\n  // altitude.\n  //\n  // We don't want to set the home position to the current GPS velocity because\n  // we don't want the EKF to be constrained to the accuracy of the GPS\n  // velocity.\n  //\n  // We don't want to set the home position to the current GPS heading because\n  // we don't want the E", "CodeBleu_score": 20.568383156849734}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()    // Check if motors are armed\n    if (!motorsAreArmed()) {\n        // If not armed, set throttle to zero, set spool state to unlimited throttle, relax attitude controllers, and exit\n        setThrottle(0);\n        setSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n        relaxAttitudeController();\n        return;\n    }\n\n    // If armed, set spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run attitude controller with these rates\n    setSpoolState(SPOOL_STATE_UNLIMITED_THROTTLE);\n    float rollRate = convertPilotInputToDesiredBodyFrameRate(rollPilotInput);\n    float pitchRate = convertPilotInputToDesiredBodyFrameRate(pitchPilotInput);\n    float yawRate = convertPilotInputToDesiredBodyFrameRate(yawPilotInput);\n    runAttitudeController(rollRate, pitchRate, yawRate);\n\n    // Output pilot's throttle input without angle boost and set forward and lateral motor inputs based on pilot controls\n    setThrottle(throttlePilotInput);\n    setForwardMotorInput(rollPilotInput);\n    setLateralMotorInput(pitchPilotInput);\n}\n", "CodeBleu_score": 30.238195947638445}, {"code": "void ModeAcro::run()    if (!motors.armed()) {\n        motors.writeOutputs();\n        motors.relax();\n        return;\n    }\n\n    // Set spool state to unlimited throttle\n    motors.setSpoolState(Motors::SPOOL_STATE_UNLIMITED);\n\n    // Convert pilot inputs to desired body frame rates\n    float rollRate = pilot.roll.getRate() * config.get().roll_p;\n    float pitchRate = pilot.pitch.getRate() * config.get().pitch_p;\n    float yawRate = pilot.yaw.getRate() * config.get().yaw_p;\n\n    // Run attitude controller\n    attitude.run(rollRate, pitchRate, yawRate);\n\n    // Output pilot's throttle input without angle boost\n    motors.setThrottle(pilot.throttle.get());\n\n    // Set forward and lateral motor inputs based on pilot controls\n    motors.setMotor(Motors::MOTOR_FL, pilot.roll.get() + pilot.pitch.get() + pilot.throttle.get());\n    motors.setMotor(Motors::MOTOR_FR, pilot.roll.get() - pilot.pitch.get() - pilot.throttle.get());\n    motors.setMotor(Motors::MOTOR_BL, pilot.roll.get() - pilot.pitch.get() + pilot.throttle.get());\n    motors.setMotor(Motors::MOTOR_BR, pilot.roll.get() + pilot.pitch.get() - pilot.throttle.get());\n\n    // Write outputs\n    motors.writeOutputs();\n}\n", "CodeBleu_score": 47.87059405893568}, {"code": "void ModeAcro::run()  // if not armed, set throttle to zero, adjust spool state, relax attitude controller, and exit\n  if (!motors.armed()) {\n    // set throttle to zero\n    attitude_control.relax();\n    attitude_control.set_throttle_out(0);\n\n    // set spool state to unlimited\n    motors.set_unlimited();\n\n    // exit immediately\n    return;\n  }\n\n  // set spool state to unlimited\n  motors.set_unlimited();\n\n  // convert pilot inputs to body frame rates\n  attitude_control.set_roll(channel_roll->get_control_in());\n  attitude_control.set_pitch(channel_pitch->get_control_in());\n  attitude_control.set_yaw(channel_yaw->get_control_in());\n\n  // run attitude controller\n  attitude_control.angle_ef_roll_pitch_rate_ef_yaw_rate();\n\n  // get pilot's desired throttle\n  float throttle = channel_throttle->get_control_in();\n\n  // run motor control\n  motors.set_throttle_out(throttle);\n\n  // set forward and lateral motor inputs\n  motors.set_forward_out(attitude_control.get_forward_out());\n  motors.set_roll_out(attitude_control.get_roll_out());\n\n  // set pilot's desired throttle\n  attitude_control.set_throttle_out(throttle);\n}\n", "CodeBleu_score": 43.044024892475704}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()    // set position control mode\n    _control_mode.flag_control_manual_enabled = false;\n    _control_mode.flag_control_auto_enabled = false;\n    _control_mode.flag_control_position_enabled = true;\n    _control_mode.flag_control_velocity_enabled = false;\n    _control_mode.flag_control_acceleration_enabled = false;\n    _control_mode.flag_control_attitude_enabled = false;\n    _control_mode.flag_control_rates_enabled = false;\n    _control_mode.flag_control_altitude_enabled = false;\n    _control_mode.flag_control_climb_rate_enabled = false;\n    _control_mode.flag_control_termination_enabled = false;\n\n    // set waypoint controller\n    _waypoint_controller.init();\n\n    // set default auto yaw mode\n    _auto_yaw_mode = AutoYawMode::YAW_TO_WAYPOINT;\n\n    // set waypoint destination\n    _waypoint_controller.set_destination(_destination);\n\n    // set yaw\n    _waypoint_controller.set_yaw(_destination.yaw);\n}\n", "CodeBleu_score": 35.26844102791895}, {"code": "void ModeGuided::guided_pos_control_start()  // Set position control mode\n  control_mode_.flag_control_position_enabled = true;\n  control_mode_.flag_control_velocity_enabled = false;\n  control_mode_.flag_control_acceleration_enabled = false;\n  control_mode_.flag_control_attitude_enabled = false;\n  control_mode_.flag_control_rates_enabled = false;\n  control_mode_.flag_control_manual_enabled = false;\n  control_mode_.flag_control_altitude_enabled = false;\n  control_mode_.flag_control_climb_rate_enabled = false;\n  control_mode_.flag_control_force_enabled = false;\n  control_mode_.flag_control_torque_enabled = false;\n  control_mode_.flag_control_yawrate_enabled = false;\n  control_mode_.flag_control_acceleration_enabled = false;\n  control_mode_.flag_control_velocity_enabled = false;\n  control_mode_.flag_control_position_enabled = true;\n  control_mode_.flag_control_auto_enabled = false;\n  control_mode_.flag_control_offboard_enabled = false;\n  control_mode_.flag_control_rattitude_enabled = false;\n  control_mode_.flag_control_position_velocity_enabled = false;\n  control_mode_.flag_control_velocity_enabled = false;\n  control_mode_.flag_control_acceleration_enabled = false;\n  control_mode_.flag_control_attitude_enabled = false;\n  control_mode_.flag_control_rates_enabled = false;\n  control_mode_.flag_control_manual_enabled = false;\n  control_mode_.flag_control_altitude_enabled = false;\n  control_mode_.flag_control_climb_rate_enabled = false;\n  control_mode_.flag_control_force_enabled = false;\n  control_mode_.flag_control_torque_enabled = false;\n  control_mode_.flag_control_yawrate_enabled = false;\n  control_mode_.flag_control_acceleration_enabled = false;\n  control", "CodeBleu_score": 20.926911576246965}, {"code": "void ModeGuided::guided_pos_control_start()  // TODO: set position control mode\n  // TODO: initialize the waypoint controller\n  // TODO: retrieve the stopping point\n  // TODO: set it as the waypoint destination\n  // TODO: initialize the yaw using the default auto yaw mode\n  _navigator->set_mode_auto();\n  _navigator->set_can_loiter_at_sp(false);\n  _navigator->set_position_setpoint_only_z_controller_enabled(false);\n  _navigator->set_yaw_setpoint(NAN);\n  _navigator->set_yaw_sp_move_rate(0.0f);\n  _navigator->set_yaw_acceptance(math::radians(1.0f));\n  _navigator->set_yaw_setpoint_type(WAYPOINT);\n  _navigator->set_auto_yaw_mode(AUTO_YAW_LOOK_AT_GOAL);\n  _navigator->set_auto_yaw_max_rotation_dps(math::radians(180.0f));\n  _navigator->set_auto_yaw_timeout(1.0f);\n  _navigator->set_auto_yaw_look_ahead(0.0f);\n  _navigator->set_auto_yaw_landing(false);\n  _navigator->set_auto_yaw_error_max(math::radians(1.0f));\n  _navigator->set_auto_yaw_error_min(0.0f);\n  _navigator->set_auto_yaw_error_time_max(0.0f);\n  _navigator->set_auto_yaw_error_time_min(0.0f);\n  _navigator->set_auto_yaw_start_delay(0.0f);\n  _navigator->set_auto_yaw_stop_delay(0.0f);\n  _navigator->set_auto_yaw_inhibit_turning_at_waypoint(false);\n  _navigator->set_auto_yaw_inhibit_turning_at_landing(false);", "CodeBleu_score": 34.980310847128884}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()    // Initialize vertical velocity control\n    _vel_max_up_air = _param_mpc_z_vel_max_up.get();\n    _vel_max_down_air = _param_mpc_z_vel_max_dn.get();\n    _accel_z_max_up = _param_mpc_acc_up_max.get();\n    _accel_z_max_down = _param_mpc_acc_down_max.get();\n\n    // Initialize horizontal velocity control\n    _vel_max_xy = _param_mpc_xy_vel_max.get();\n    _accel_xy_max = _param_mpc_xy_acc_max.get();\n\n    // Initialize yaw control mode\n    _yaw_mode = YawMode();\n\n    // Initialize velocity controllers\n    _vel_x_controller.set_max_velocity(_vel_max_xy);\n    _vel_x_controller.set_max_acceleration(_accel_xy_max);\n    _vel_y_controller.set_max_velocity(_vel_max_xy);\n    _vel_y_controller.set_max_acceleration(_accel_xy_max);\n    _vel_z_controller.set_max_velocity(_vel_max_up_air);\n    _vel_z_controller.set_max_acceleration(_accel_z_max_up);\n\n    // Set yaw control mode\n    _yaw_mode = YawMode(YawMode::YawModeType::YAW_MODE_AUTO_HOLD);\n}\n", "CodeBleu_score": 35.4540205822431}, {"code": "void ModeGuided::guided_vel_control_start()    // initialize vertical maximum speeds and acceleration\n    _vel_max_up = _param_mpc_z_vel_max_up.get();\n    _vel_max_down = _param_mpc_z_vel_max_dn.get();\n    _accel_z = _param_mpc_acc_up_max.get();\n\n    // initialize vertical and horizontal velocity controllers\n    _vel_sp_z_prev = 0.0f;\n    _vel_sp_xy_prev.zero();\n    _vel_err_xy_prev.zero();\n    _vel_err_z_prev = 0.0f;\n\n    // set yaw control mode to AUTO_YAW_HOLD\n    _yaw_mode = YawMode::AUTO_YAW_HOLD;\n}\n", "CodeBleu_score": 20.77017317927296}, {"code": "void ModeGuided::guided_vel_control_start()    // initialize vertical maximum speeds and acceleration using pilot-defined parameters\n    _v_cruise_accel = _param_mpc_acc_up_max.get();\n    _v_cruise_max = _param_mpc_acc_up_max.get() * _param_mpc_acc_up_max.get() / _param_mpc_z_vel_max_up.get();\n    _v_cruise_min = _param_mpc_acc_down_max.get() * _param_mpc_acc_down_max.get() / _param_mpc_z_vel_max_down.get();\n\n    // initialize vertical and horizontal velocity controllers\n    _vel_x_controller.reset();\n    _vel_y_controller.reset();\n\n    // set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n    _control_mode.flag_control_yaw_override_enabled = true;\n}\n", "CodeBleu_score": 31.97874534495737}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()  // Check if timeout has been reached\n  if (_time_first_inside_safe_area > 0 &&\n      (hrt_absolute_time() - _time_first_inside_safe_area > GUIDED_LIMIT_TIMEOUT)) {\n    return true;\n  }\n\n  // Check if minimum altitude is reached\n  if (_param_gnd_min_alt.get() > 0 &&\n      _Navigator->get_global_position()->alt < _param_gnd_min_alt.get()) {\n    return true;\n  }\n\n  // Check if maximum altitude is reached\n  if (_param_gnd_max_alt.get() > 0 &&\n      _Navigator->get_global_position()->alt > _param_gnd_max_alt.get()) {\n    return true;\n  }\n\n  // Check if horizontal distance moved exceeds limit\n  if (_param_gnd_max_hor_dist.get() > 0 &&\n      _distance_to_target > _param_gnd_max_hor_dist.get()) {\n    return true;\n  }\n\n  return false;\n}\n", "CodeBleu_score": 38.3278571044362}, {"code": "bool ModeGuided::guided_limit_check()  // check if the timeout has been exceeded\n  if (hrt_elapsed_time(&_time_first_inside_orbit) > GUIDED_LIMIT_TIMEOUT) {\n    return true;\n  }\n\n  // check if the altitude is too low\n  if (_alt_above_target < GUIDED_LIMIT_ALT) {\n    return true;\n  }\n\n  // check if the altitude is too high\n  if (_alt_above_target > GUIDED_LIMIT_ALT_MAX) {\n    return true;\n  }\n\n  // check if the horizontal distance moved is too large\n  if (_distance_to_target < GUIDED_LIMIT_DIST) {\n    return true;\n  }\n\n  // if none of the above conditions are true, then return false\n  return false;\n}\n", "CodeBleu_score": 19.65348435245633}, {"code": "bool ModeGuided::guided_limit_check()  // Check timeout\n  if (_time_wp_reached > 0 && hrt_elapsed_time(&_time_wp_reached) > GUIDED_TIMEOUT) {\n    return true;\n  }\n\n  // Check altitude\n  if (_param_agl_setpoint_max.get() > FLT_EPSILON) {\n    if (_param_agl_setpoint_max.get() < -_global_pos.agl) {\n      return true;\n    }\n  }\n\n  if (_param_agl_setpoint_min.get() > FLT_EPSILON) {\n    if (_param_agl_setpoint_min.get() > -_global_pos.agl) {\n      return true;\n    }\n  }\n\n  // Check horizontal distance\n  if (_param_dist_setpoint_max.get() > FLT_EPSILON) {\n    if (_param_dist_setpoint_max.get() < _distance_to_wp) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "CodeBleu_score": 37.971971403147045}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()  static bool pass = true;\n  static bool first_run = true;\n  static bool timeout = false;\n  static uint32_t start_time = 0;\n  static uint32_t timeout_time = 0;\n  static uint32_t current_time = 0;\n  static uint32_t last_time = 0;\n  static uint32_t last_motor_test_request_time = 0;\n  static uint32_t last_motor_test_response_time = 0;\n  static uint32_t motor_test_request_time = 0;\n  static uint32_t motor_test_response_time = 0;\n  static uint32_t motor_test_request_count = 0;\n  static uint32_t motor_test_response_count = 0;\n  static uint32_t motor_test_timeout_count = 0;\n  static uint32_t motor_test_response_timeout_count = 0;\n  static uint32_t motor_test_request_timeout_count = 0;\n\n  if (first_run) {\n    start_time = HAL_GetTick();\n    timeout_time = start_time + 10000;\n    first_run = false;\n  }\n  current_time = HAL_GetTick();\n  if (current_time > timeout_time) {\n    timeout = true;\n  }\n  if (timeout) {\n    pass = false;\n    timeout_time = current_time + 10000;\n    timeout = false;\n    motor_test_timeout_count++;\n    if (motor_test_timeout_count > 1) {\n      motor_test_response_timeout_count++;\n    }\n    if (motor_test_response_timeout_count > 1) {\n      motor_test_request_timeout_count++;\n    }\n    if (motor_test_request_timeout_count > 1) {\n      motor_test_request_timeout_count = 0;\n      motor_test_response_timeout_count = 0", "CodeBleu_score": 35.11197704915342}, {"code": "bool Sub::verify_motor_test()  bool passed = true;\n  if (millis() - motor_test_start_time > MOTOR_TEST_TIMEOUT) {\n    passed = false;\n    motor_test_passed = false;\n    motor_test_start_time = millis();\n    Serial.println(\"Motor test timed out.\");\n    Serial.println(\"Disarming.\");\n    disarm();\n    Serial.println(\"Disarmed.\");\n    Serial.println(\"Setting motor test pass flag to false.\");\n    Serial.println(\"Returning false.\");\n  }\n  if (millis() - motor_test_last_request_time > MOTOR_TEST_REQUEST_TIMEOUT) {\n    passed = false;\n    motor_test_passed = false;\n    motor_test_start_time = millis();\n    Serial.println(\"Motor test request timed out.\");\n    Serial.println(\"Disarming.\");\n    disarm();\n    Serial.println(\"Disarmed.\");\n    Serial.println(\"Setting motor test pass flag to false.\");\n    Serial.println(\"Returning false.\");\n  }\n  return passed;\n}\n", "CodeBleu_score": 42.27277783586544}, {"code": "bool Sub::verify_motor_test()\n    if (motor_test_pass) {\n        if (millis() - motor_test_start_time > MOTOR_TEST_TIMEOUT) {\n            motor_test_pass = false;\n            motor_test_failure_time = millis();\n            motor_test_timeout = true;\n            motor_test_enabled = false;\n            disarm();\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return false;\n    }\n}\n", "CodeBleu_score": 43.55801724941648}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)  // Get roll and pitch targets from wp_nav in centidegrees\n  float roll_target = wp_nav.roll_cd*100;\n  float pitch_target = wp_nav.pitch_cd*100;\n\n  // Constrain roll and pitch targets within a specified maximum angle range\n  roll_target = constrain_float(roll_target, -wp_nav.max_roll_cd*100, wp_nav.max_roll_cd*100);\n  pitch_target = constrain_float(pitch_target, -wp_nav.max_pitch_cd*100, wp_nav.max_pitch_cd*100);\n\n  // Normalize roll and pitch targets\n  float roll_norm = normalize_float(roll_target, -100, 100);\n  float pitch_norm = normalize_float(pitch_target, -100, 100);\n\n  // Assign normalized roll and pitch targets to lateral_out and forward_out\n  lateral_out = roll_norm;\n  forward_out = pitch_norm;\n}\n", "CodeBleu_score": 38.10845926409466}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\n\t// Get roll and pitch targets from wp_nav\n\tfloat roll_target = wp_nav.get_roll_target();\n\tfloat pitch_target = wp_nav.get_pitch_target();\n\n\t// Constrain roll and pitch targets to within specified maximum angle range\n\tif (roll_target > roll_max) {\n\t\troll_target = roll_max;\n\t}\n\tif (roll_target < roll_max * -1) {\n\t\troll_target = roll_max * -1;\n\t}\n\tif (pitch_target > pitch_max) {\n\t\tpitch_target = pitch_max;\n\t}\n\tif (pitch_target < pitch_max * -1) {\n\t\tpitch_target = pitch_max * -1;\n\t}\n\n\t// Normalize roll and pitch targets\n\tfloat roll_target_norm = roll_target / roll_max;\n\tfloat pitch_target_norm = pitch_target / pitch_max;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target_norm;\n\tforward_out = pitch_target_norm;\n\n}\n", "CodeBleu_score": 40.919760509493855}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)  float roll_target = wp_nav.roll_cd;\n  float pitch_target = wp_nav.pitch_cd;\n\n  if (fabs(roll_target) > wp_nav.roll_max_cd) {\n    roll_target = wp_nav.roll_max_cd * (roll_target / fabs(roll_target));\n  }\n\n  if (fabs(pitch_target) > wp_nav.pitch_max_cd) {\n    pitch_target = wp_nav.pitch_max_cd * (pitch_target / fabs(pitch_target));\n  }\n\n  float roll_norm = roll_target / wp_nav.roll_max_cd;\n  float pitch_norm = pitch_target / wp_nav.pitch_max_cd;\n\n  // If roll or pitch is too small, normalize to 0.\n  if (fabs(roll_norm) < wp_nav.roll_norm_deadband) {\n    roll_norm = 0;\n  }\n\n  if (fabs(pitch_norm) < wp_nav.pitch_norm_deadband) {\n    pitch_norm = 0;\n  }\n\n  lateral_out = roll_norm;\n  forward_out = pitch_norm;\n}\n", "CodeBleu_score": 36.29335817778333}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()  // Update the barometer data\n  barometer.update();\n\n  // If the altitude is above zero, update the barometer calibration\n  if (barometer.getAltitude() > 0) {\n    barometer.calibrate(barometer.getPressure(), barometer.getTemperature());\n  }\n\n  // If a depth sensor is present, update the sensor health status based on the barometer's health\n  if (depth_sensor_present) {\n    if (barometer.getHealth() == 0) {\n      depth_sensor_health = 1;\n    } else {\n      depth_sensor_health = 0;\n    }\n  }\n}\n", "CodeBleu_score": 55.518559696222646}, {"code": "void Sub::read_barometer()    // Read the barometer data.\n    barometer.read();\n\n    // If the altitude is above zero, update the barometer calibration.\n    if (barometer.getAltitude() > 0) {\n        // Set the calibration value to the current altitude.\n        barometer.setCalibration(barometer.getAltitude());\n    }\n\n    // If a depth sensor is present, update the sensor health status based on the barometer's health.\n    if (depth_sensor_present) {\n        // If the barometer is not healthy, set the depth sensor health status to false.\n        if (!barometer.isHealthy()) {\n            depth_sensor_healthy = false;\n        }\n    }\n}\n", "CodeBleu_score": 56.33206566508908}, {"code": "void Sub::read_barometer()    // Read the barometer data\n    barometer.read();\n\n    // Update the barometer calibration if the altitude is above zero\n    if (barometer.getAltitude() > 0) {\n        barometer.calibrate(barometer.getPressure(), barometer.getTemperature());\n    }\n\n    // Update the depth sensor health status based on the barometer's health\n    if (depth_sensor_health == DEPTH_SENSOR_HEALTH_UNKNOWN) {\n        if (barometer.health() == BAROMETER_HEALTH_GOOD) {\n            depth_sensor_health = DEPTH_SENSOR_HEALTH_GOOD;\n        } else if (barometer.health() == BAROMETER_HEALTH_BAD) {\n            depth_sensor_health = DEPTH_SENSOR_HEALTH_BAD;\n        }\n    }\n}\n", "CodeBleu_score": 50.01248058353291}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()  return (ekf_position_ok_impl(this));\n}\n", "CodeBleu_score": 2.057379130424868}, {"code": "bool Sub::ekf_position_ok()    // check if inertial navigation is available\n    if (!ekf.inertial_nav_valid()) {\n        return false;\n    }\n\n    // check if the motors are disarmed\n    if (!motors.armed()) {\n        return true;\n    }\n\n    // check if the EKF is in constant position mode\n    if (ekf.control_status_flags().in_air && !ekf.control_status_flags().in_fixed_wing_operation) {\n        return false;\n    }\n\n    // check if the EKF is in constant position mode\n    if (ekf.control_status_flags().in_fixed_wing_operation && ekf.control_status_flags().in_air) {\n        return false;\n    }\n\n    // check if the EKF is in constant position mode\n    if (ekf.control_status_flags().in_fixed_wing_operation && !ekf.control_status_flags().in_air) {\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 52.708540574960615}, {"code": "bool Sub::ekf_position_ok()  if (!inertial_nav_available()) {\n    return false;\n  }\n\n  if (!motors_armed()) {\n    return true;\n  }\n\n  if (ekf_predicted_position_good()) {\n    return true;\n  }\n\n  if (ekf_in_const_pos_mode()) {\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 16.8445941068419}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    if (control_mode_requires_gps()) {\n        if (!AP_Arming_Base::gps_checks(display_failure)) {\n            return false;\n        }\n        if (!ahrs.healthy()) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"AHRS not healthy\\n\"));\n            }\n            return false;\n        }\n        if (ahrs.ekf_failsafe()) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"EKF failsafe active\\n\"));\n            }\n            return false;\n        }\n        if (!ahrs.position_ok()) {\n            if (display_failure) {\n                hal.console->printf_P(PSTR(\"Invalid position estimate\\n\"));\n            }\n            return false;\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 50.10327753522661}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    if (control_mode_requires_gps_position() || control_mode_requires_gps_velocity()) {\n        if (!AP_Arming_Base::gps_checks(display_failure)) {\n            return false;\n        }\n\n        if (!ahrs.healthy()) {\n            if (display_failure) {\n                gcs_send_text_fmt(PSTR(\"GPS: AHRS not ready\"));\n            }\n            return false;\n        }\n\n        if (ins.get_ekf_flags().ekf_failsafe) {\n            if (display_failure) {\n                gcs_send_text_fmt(PSTR(\"GPS: EKF failsafe\"));\n            }\n            return false;\n        }\n\n        if (!ins.get_position_valid()) {\n            if (display_failure) {\n                gcs_send_text_fmt(PSTR(\"GPS: No position estimate\"));\n            }\n            return false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 48.66819053345465}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    if (control_mode_requires_gps() || control_mode_requires_velocity()) {\n        if (!AP_Arming_Plane::gps_checks(display_failure)) {\n            return false;\n        }\n        if (!ahrs.healthy()) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Arming failed: AHRS not ready\");\n            }\n            return false;\n        }\n        if (ahrs.get_ekf_flags().ev_failsafe) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Arming failed: EKF failsafe\");\n            }\n            return false;\n        }\n        if (!ahrs.get_ekf_flags().fuse_pos) {\n            if (display_failure) {\n                gcs_send_text_fmt(MAV_SEVERITY_CRITICAL, \"Arming failed: position estimate not valid\");\n            }\n            return false;\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 50.6959729776934}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    // set the home location\n    if (do_arming_checks) {\n        set_home_location();\n    }\n\n    // set the initial heading\n    if (do_arming_checks) {\n        set_initial_heading();\n    }\n\n    // record the home heading for sail vehicles\n    if (do_arming_checks) {\n        record_home_heading();\n    }\n\n    // update the soft armed status\n    if (do_arming_checks) {\n        update_soft_armed_status();\n    }\n\n    // send an arm/disarm status text\n    if (do_arming_checks) {\n        send_arming_status_text();\n    }\n\n    // return true if we successfully armed\n    return true;\n}\n", "CodeBleu_score": 28.119391064020014}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\n    // record the arming method\n    arming_method = method;\n\n    // if we are not in the disarmed state, we can't arm\n    if (armed_state != AP_Arming::Disarmed) {\n        return false;\n    }\n\n    // if we are not in the ready state, we can't arm\n    if (armed_state != AP_Arming::Ready) {\n        return false;\n    }\n\n    // if we are not in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in the standby state, we can't arm\n    if (armed_state != AP_Arming::Standby) {\n        return false;\n    }\n\n    // if we are in", "CodeBleu_score": 28.70068314805399}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    if (do_arming_checks) {\n        if (!_check_arming_allowed()) {\n            return false;\n        }\n    }\n\n    // set the home location\n    _set_home_location();\n\n    // set the simple mode heading\n    _set_simple_mode_heading();\n\n    // record the home heading for sail vehicles\n    _record_home_heading();\n\n    // set the soft armed status\n    _set_soft_armed(true);\n\n    // send an arm/disarm status text\n    _send_arm_disarm_status_text(true);\n\n    return true;\n}\n", "CodeBleu_score": 26.558535147320118}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()  // If charging is allowed but should not continue, it disables charging and records the time.\n  if (charging_allowed == false && charging_enabled == true) {\n    charging_enabled = false;\n    charging_disabled_time = millis();\n  }\n\n  // If charging is not allowed, it retries enabling charging after a specified delay, checking the conditions again to decide whether to enable or continue disabling charging.\n  if (charging_enabled == false) {\n    if (millis() - charging_disabled_time > 60000) {\n      if (charging_allowed == true) {\n        charging_enabled = true;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 39.63800440023313}, {"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (charging_enabled) {\n      // Charging is enabled and should be, so do nothing\n    } else {\n      // Charging is not enabled and should be, so enable it\n      charging_enabled = true;\n      Serial.println(\"Enabling charging\");\n      digitalWrite(CHARGING_ENABLE_PIN, HIGH);\n    }\n  } else {\n    // Charging is not allowed, so disable it if it is enabled\n    if (charging_enabled) {\n      charging_enabled = false;\n      Serial.println(\"Disabling charging\");\n      digitalWrite(CHARGING_ENABLE_PIN, LOW);\n    }\n    // If charging is not allowed and should not continue, record the time\n    if (!charging_should_continue) {\n      charging_time = millis();\n    } else {\n      // If charging is not allowed but should continue, retry enabling charging after a delay\n      if (millis() - charging_time > 10000) {\n        charging_time = millis();\n        updateChargingEnabled();\n      }\n    }\n  }\n}\n", "CodeBleu_score": 59.07068547573895}, {"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (charging_enabled) {\n      // Do nothing\n    } else {\n      // Enable charging\n      digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n      charging_enabled = true;\n      charging_enabled_time = millis();\n      charging_enabled_count++;\n    }\n  } else {\n    // Disable charging\n    if (charging_enabled) {\n      digitalWrite(CHARGE_ENABLE_PIN, LOW);\n      charging_enabled = false;\n      charging_disabled_time = millis();\n      charging_disabled_count++;\n    } else {\n      // Check if charging has been disabled for too long\n      if ((millis() - charging_disabled_time) > DISABLE_CHARGING_TIMEOUT) {\n        // Enable charging\n        digitalWrite(CHARGE_ENABLE_PIN, HIGH);\n        charging_enabled = true;\n        charging_enabled_time = millis();\n        charging_enabled_count++;\n      } else {\n        // Retry enabling charging after a delay\n        if ((millis() - charging_disabled_time) > DISABLE_CHARGING_RETRY_DELAY) {\n          updateChargingEnabled();\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 58.89699428731714}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)  if (size < 4) {\n    return;\n  }\n  if (ros::ok()) {\n    uint32_t crc = crc32::crc32((uint8_t *)message, size);\n    memcpy((uint8_t *)message + size, &crc, 4);\n    packetSerial.send(message, size + 4);\n  }\n}\n", "CodeBleu_score": 44.69017221404796}, {"code": "void sendMessage(void *message, size_t size)  if (ros::isStarted() && size >= 4) {\n    uint32_t crc = crc32((uint8_t *)message, size);\n    memcpy((uint8_t *)message + size, &crc, 4);\n    packetSerial.write(message, size + 4);\n  }\n}\n", "CodeBleu_score": 36.51980352513315}, {"code": "void sendMessage(void *message, size_t size)  if (size < 4) {\n    return;\n  }\n  uint8_t *msg = (uint8_t *)message;\n  uint32_t crc = crc32(0, msg, size);\n  msg[size] = (crc >> 24) & 0xff;\n  msg[size + 1] = (crc >> 16) & 0xff;\n  msg[size + 2] = (crc >> 8) & 0xff;\n  msg[size + 3] = crc & 0xff;\n  size += 4;\n  packetSerial.send(msg, size);\n}\n", "CodeBleu_score": 61.31950638438979}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()  Serial1.begin(9600);\n  delay(100);\n  Serial1.write(0x7E);\n  delay(100);\n  Serial1.write(0xFF);\n  delay(100);\n  Serial1.write(0x06);\n  delay(100);\n  Serial1.write(0x03);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n ", "CodeBleu_score": 33.93002291452632}, {"code": "bool MP3Sound::begin()  // initialize serial communication with the sound module\n  if (!mp3Serial.begin(9600)) {\n    return false;\n  }\n  // clear any existing data in the buffer\n  mp3Serial.clear();\n  // initialize the sound module\n  mp3Serial.write(0x7E);\n  mp3Serial.write(0xFF);\n  mp3Serial.write(0x06);\n  mp3Serial.write(0x01);\n  mp3Serial.write(0x56);\n  mp3Serial.write(0xAE);\n  mp3Serial.write(0xC9);\n  mp3Serial.write(0xAB);\n  mp3Serial.write(0x8C);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n  mp3Serial.write(0x00);\n ", "CodeBleu_score": 34.29140901572274}, {"code": "bool MP3Sound::begin()  // initialize serial communication with sound module\n  Serial1.begin(9600);\n  delay(100);\n  Serial1.write(0x7E);\n  delay(100);\n  Serial1.write(0xFF);\n  delay(100);\n  Serial1.write(0x06);\n  delay(100);\n  Serial1.write(0x03);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.write(0x00);\n  delay(100);\n  Serial1.", "CodeBleu_score": 34.47283964812318}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()  if (activeSounds.size() == 0) {\n    return 0;\n  }\n  if (isPlaying()) {\n    return activeSounds.size();\n  }\n  MP3Sound* sound = activeSounds.back();\n  activeSounds.pop_back();\n  sound->play();\n  return activeSounds.size();\n}\n", "CodeBleu_score": 41.44335884449071}, {"code": "int MP3Sound::processSounds()\tint numSounds = activeSounds.size();\n\tif (numSounds == 0) return numSounds;\n\tif (isPlaying()) return numSounds;\n\n\tint sound = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplay(sound);\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 52.24891646240768}, {"code": "int MP3Sound::processSounds()  if (activeSounds.size() == 0) {\n    return 0;\n  }\n  if (mp3.isPlaying()) {\n    return activeSounds.size();\n  }\n  mp3.play(activeSounds.back());\n  activeSounds.pop_back();\n  return activeSounds.size();\n}\n", "CodeBleu_score": 41.46339219557741}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *ac = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      int size;\n      const char *filename = wb_request_read_string(r);\n      int width = wb_request_read_int32(r);\n      int height = wb_request_read_int32(r);\n      int bpp = wb_request_read_int32(r);\n      if (wb_request_read_uchar(r) != 0)  // not used\n        wb_request_read_uchar(r);  // not used\n      int depth = wb_request_read_int32(r);\n      int channels = wb_request_read_int32(r);\n      int refresh_rate = wb_request_read_int32(r);\n      bool is_grey = wb_request_read_uchar(r);\n      bool is_rgb = wb_request_read_uchar(r);\n      bool is_rgba = wb_request_read_uchar(r);\n      bool is_yuv = wb_request_read_uchar(r);\n      bool is_yuv422 = wb_request_read_uchar(r);\n      bool is_yuv444 = wb_request_read_uchar(r);\n      bool is_depth = wb_request_read_uchar(r);\n      bool is_disparity = wb_request_read_uchar(r);\n      bool is_indexed = wb_request_read_uchar(r);\n      bool is_luma = wb_request_read_uchar(r);\n      bool is_alpha = wb_request_read_uchar(r);\n      bool is_label = wb_request_read_uchar(r);\n      bool is_confidence = wb_request_read_uchar(r);\n      bool is_object_id = wb_request_read_uchar(r);\n      bool is_object_type = wb_request_read_uchar(r);\n      bool is_instance", "CodeBleu_score": 29.31177831098059}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *ac = d->pdata;\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (ac->memory_mapped_file) {\n        munmap(ac->memory_mapped_file, ac->memory_mapped_file_size);\n        ac->memory_mapped_file = NULL;\n      }\n      if (ac->memory_mapped_file_size) {\n        ac->memory_mapped_file = mmap(NULL, ac->memory_mapped_file_size, PROT_READ, MAP_SHARED, r->fds[0], 0);\n        if (ac->memory_mapped_file == MAP_FAILED)\n          fprintf(stderr, \"Error: %s(): %s\\n\", __FUNCTION__, strerror(errno));\n      }\n      break;\n    }\n    default:\n      return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 47.98883852112703}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  WbAbstractCamera *camera = d->pdata;\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      int width, height, format;\n      const char *filename;\n      if (wb_request_read_memory_mapped_file(r, &width, &height, &filename, &format)) {\n        wb_abstract_camera_set_image_buffer_size(camera, width, height, format);\n        if (camera->memory_mapped_file)\n          wb_abstract_camera_close_memory_mapped_file(camera);\n        camera->memory_mapped_file = wb_abstract_camera_open_memory_mapped_file(camera, filename);\n        if (camera->memory_mapped_file) {\n          wb_abstract_camera_set_image_buffer(camera, camera->memory_mapped_file->data, camera->memory_mapped_file->size);\n          wb_abstract_camera_set_image_buffer_size(camera, camera->memory_mapped_file->width, camera->memory_mapped_file->height,\n                                                   camera->memory_mapped_file->format);\n        }\n        wb_request_write_uchar(r, camera->memory_mapped_file ? 1 : 0);\n        return true;\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  return false;\n}\n", "CodeBleu_score": 45.0270328323506}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)  int result = -1;\n  WbData *data = wb_abstract_camera_get_data(d);\n  if (data) {\n    wb_abstract_camera_lock(d);\n    result = wb_abstract_camera_get_height_internal(data);\n    wb_abstract_camera_unlock(d);\n  }\n  return result;\n}\n", "CodeBleu_score": 45.03260460357025}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  WbAbstractCamera *camera = d->pdata;\n  int height;\n  wb_abstract_camera_lock(camera);\n  height = camera->height;\n  wb_abstract_camera_unlock(camera);\n  return height;\n}\n", "CodeBleu_score": 44.33060518330156}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  WbAbstractCamera *camera = d->pdata;\n  int height = -1;\n  wb_abstract_camera_lock(camera);\n  if (camera->data)\n    height = camera->data->height;\n  wb_abstract_camera_unlock(camera);\n  return height;\n}\n", "CodeBleu_score": 44.36251467486848}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer)\n    sampling_period = accelerometer->sampling_period;\n  else\n    sampling_period = 0;\n  robot_mutex_unlock_step();\n  return sampling_period;\n}\n", "CodeBleu_score": 46.967598975566915}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period;\n  robot_mutex_lock_step();\n  Accelerometer *accelerometer = accelerometer_get_struct(tag);\n  if (accelerometer) {\n    sampling_period = accelerometer->sampling_period;\n    robot_mutex_unlock_step();\n    return sampling_period;\n  }\n  robot_mutex_unlock_step();\n  fprintf(stderr, \"Error: %s(): invalid device tag.\\n\", __FUNCTION__);\n  return 0;\n}\n", "CodeBleu_score": 68.85612290733229}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  int sampling_period;\n  WbDevice *d = wb_accelerometer_get_device(tag);\n  if (d) {\n    wb_robot_mutex_lock();\n    sampling_period = d->pdata->sampling_period;\n    wb_robot_mutex_unlock();\n  } else {\n    fprintf(stderr, \"Error: %s(): invalid device tag.\\n\", __FUNCTION__);\n    sampling_period = 0;\n  }\n  return sampling_period;\n}\n", "CodeBleu_score": 55.494795427777746}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    // Convert the decimal degree value to degrees, minutes, and seconds.\n    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\n    // Copy the result to a std::string, free the allocated memory, and return the string.\n    string result = string(dms);\n    free(dms);\n    return result;\n}\n", "CodeBleu_score": 46.74194499186772}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString(dms);\n    free(dms);\n    return dmsString;\n}\n", "CodeBleu_score": 40.74865130796342}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsStr(dms);\n    free(dms);\n    return dmsStr;\n}\n", "CodeBleu_score": 39.85344343163211}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)    dAASSERT (g && g->type == dBoxClass);\n    dUASSERT (plane, \"argument is NULL\");\n\n    dxBox *b = (dxBox *) g;\n\n    // get the box's center\n    dReal c[3];\n    dGeomBoxGetCenter (g, c);\n\n    // compute the relative position of the point to the box center\n    dReal rel_x = x - c[0];\n    dReal rel_y = y - c[1];\n    dReal rel_z = z - c[2];\n\n    // check each axis for proximity to the box's surface\n    dReal proj = dFabs (rel_x) - b->side[0];\n    if (proj < 0) {\n        plane[0] = 0;\n        plane[1] = 0;\n        plane[2] = rel_x > 0 ? -1 : 1;\n        plane[3] = -c[2];\n    }\n    else {\n        proj = dFabs (rel_y) - b->side[1];\n        if (proj < 0) {\n            plane[0] = 0;\n            plane[1] = rel_y > 0 ? -1 : 1;\n            plane[2] = 0;\n            plane[3] = -c[2];\n        }\n        else {\n            proj = dFabs (rel_z) - b->side[2];\n            if (proj < 0) {\n                plane[0] = rel_z > 0 ? -1 : 1;\n                plane[1] = 0;\n                plane[2] = 0;\n                plane[3] = -c[2];\n            }\n            else {\n                // the point is inside the box\n                dReal dist = dSqrt (rel_x * rel_x + rel_y * rel_y + rel_z * rel_z);\n                plane[0] = rel_x / dist;\n                plane[1] = rel_y / dist;\n                plane[2] = rel_z / dist;\n                plane[3] = -c[2];", "CodeBleu_score": 37.30072228998007}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)    dAASSERT (g && g->type == dBoxClass);\n    dUASSERT (plane, \"argument is null\");\n\n    dxBox *b = (dxBox *) g;\n\n    // calculate the relative position of the point to the box center\n    dReal px = x - b->final_posr->pos[0];\n    dReal py = y - b->final_posr->pos[1];\n    dReal pz = z - b->final_posr->pos[2];\n\n    // check each axis for proximity to the box's surface\n    dReal dist = dFabs (px) - b->side[0];\n    if (dist < 0) {\n        plane[0] = px > 0 ? 1 : -1;\n        plane[1] = 0;\n        plane[2] = 0;\n        plane[3] = -b->side[0];\n    }\n    else {\n        dist = dFabs (py) - b->side[1];\n        if (dist < 0) {\n            plane[0] = 0;\n            plane[1] = py > 0 ? 1 : -1;\n            plane[2] = 0;\n            plane[3] = -b->side[1];\n        }\n        else {\n            dist = dFabs (pz) - b->side[2];\n            if (dist < 0) {\n                plane[0] = 0;\n                plane[1] = 0;\n                plane[2] = pz > 0 ? 1 : -1;\n                plane[3] = -b->side[2];\n            }\n            else {\n                // the point is inside the box\n                dReal qx = px / b->side[0];\n                dReal qy = py / b->side[1];\n                dReal qz = pz / b->side[2];\n                dReal q = dSqrt (qx * qx + qy * qy + qz * qz);\n                plane[0] = qx / q;\n                plane[1] = qy / q;\n                plane[2]", "CodeBleu_score": 38.32190756530655}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)    dUASSERT(g && g->type == dBoxClass,\"argument not a box\");\n    dxBox *b = (dxBox*) g;\n    dVector3 relpos;\n    dReal side = 0;\n    dReal pdist = 0;\n    dVector3 axes[3];\n    axes[0][0] = 1;\n    axes[0][1] = 0;\n    axes[0][2] = 0;\n    axes[1][0] = 0;\n    axes[1][1] = 1;\n    axes[1][2] = 0;\n    axes[2][0] = 0;\n    axes[2][1] = 0;\n    axes[2][2] = 1;\n\n    relpos[0] = x - b->final_posr->pos[0];\n    relpos[1] = y - b->final_posr->pos[1];\n    relpos[2] = z - b->final_posr->pos[2];\n\n    dMultiply1_331 (relpos,b->final_posr->R,relpos);\n\n    for (int i=0; i<3; i++) {\n        dReal proj = dFabs (dDOT14(relpos,axes[i]));\n        if (proj > side) {\n            side = proj;\n            pdist = dDOT14(axes[i],relpos);\n            dCopyVector3(plane,axes[i]);\n        }\n    }\n    plane[3] = -pdist;\n}\n", "CodeBleu_score": 39.64055710156542}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  dAASSERT (box && fluidPlane && immersion);\n  dUASSERT (box->body,\"The box must be attached to a body\");\n  dUASSERT (flags & (dIMMERSE_BOX_PARTIAL | dIMMERSE_BOX_TOTAL),\n      \"The flags must be valid\");\n\n  immersion->box = box;\n  immersion->plane = fluidPlane;\n  immersion->flags = flags;\n\n  return dImmerseBoxImmersion (immersion);\n}\n", "CodeBleu_score": 49.18855791046295}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\n  dAASSERT (box);\n  dAASSERT (box->body);\n  dAASSERT (fluidPlane);\n  dAASSERT (immersion);\n\n  sBoxImmersionData data;\n  data.box = box;\n  data.plane = fluidPlane;\n  data.flags = flags;\n  data.immersion = immersion;\n\n  return dImmerseBoxData (&data);\n}\n\n\n", "CodeBleu_score": 50.09460771602835}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\n  dAASSERT (box);\n  dAASSERT (fluidPlane);\n  dAASSERT (immersion);\n  dAASSERT (box->body);\n\n  // initialize the sBoxImmersionData object\n  sBoxImmersionData b;\n  b.box = box;\n  b.fluidPlane = fluidPlane;\n  b.flags = flags;\n  b.immersion = immersion;\n\n  // check the immersion\n  return dImmerseBoxData (&b);\n}\n\n\n\n", "CodeBleu_score": 49.38938002479999}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dAASSERT (immersion);\n  dUASSERT (o1 && o1->type == dBoxClass, \"argument 1 must be a box\");\n  dUASSERT (o2 && o2->type == dCapsuleClass, \"argument 2 must be a capsule\");\n  dUASSERT (immersion->normal && immersion->depth && immersion->pos, \"immersion structure must be valid\");\n\n  dVector3 normal;\n  dReal depth;\n  dVector3 pos;\n  int code = dCollideBoxCapsule (o1, o2, flags, normal, &depth, pos, 0);\n  if (code) {\n    immersion->normal[0] = normal[0];\n    immersion->normal[1] = normal[1];\n    immersion->normal[2] = normal[2];\n    immersion->depth = depth;\n    immersion->pos[0] = pos[0];\n    immersion->pos[1] = pos[1];\n    immersion->pos[2] = pos[2];\n    return code;\n  }\n  return 0;\n}\n\n\n", "CodeBleu_score": 40.95711442823324}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dAASSERT (o1);\n  dAASSERT (o2);\n  dAASSERT (immersion);\n  dUASSERT (o1->type == dBoxClass, \"argument 1 must be a box\");\n  dUASSERT (o2->type == dCapsuleClass, \"argument 2 must be a capsule\");\n  dUASSERT (flags >= 0 && flags <= 1, \"argument 3 must be 0 or 1\");\n\n  dxBox *b = (dxBox *) o1;\n  dxCapsule *c = (dxCapsule *) o2;\n\n  // check if the capsule is in the box\n  if (dFabs(c->final_posr->pos[0] - b->final_posr->pos[0]) >\n      (b->side[0] + c->radius + c->lz) ||\n      dFabs(c->final_posr->pos[1] - b->final_posr->pos[1]) >\n      (b->side[1] + c->radius + c->lz) ||\n      dFabs(c->final_posr->pos[2] - b->final_posr->pos[2]) >\n      (b->side[2] + c->radius + c->lz)) {\n    return 0;\n  }\n\n  // compute the capsule center in the box frame\n  dVector3 center;\n  dMultiply1_331 (center, b->final_posr->R, c->final_posr->pos);\n  center[0] += b->final_posr->pos[0];\n  center[1] += b->final_posr->pos[1];\n  center[2] += b->final_posr->pos[2];\n\n  // compute the capsule axis in the box frame\n  dVector3 axis;\n  dMultiply0_331 (axis, b->final_posr->R, c->final_posr->R + 2);\n\n  // compute the capsule endpoints in the box frame\n  dVector3 end1, end2;\n  dReal radius = c->", "CodeBleu_score": 39.07849700992501}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dAASSERT (immersion);\n  dUASSERT (o1 && o1->type == dBoxClass, \"argument 1 must be a box\");\n  dUASSERT (o2 && o2->type == dCapsuleClass, \"argument 2 must be a capsule\");\n\n  // get the data for the capsule\n  dVector3 l,r;\n  dReal radius,length;\n  dGeomCapsuleGetParams (o2,&radius,&length);\n  dGeomGetPosition (o2,l);\n  dGeomGetRotation (o2,r);\n\n  // get the data for the box\n  dVector3 sides,center;\n  dGeomBoxGetLengths (o1,sides);\n  dGeomGetPosition (o1,center);\n\n  // compute the capsule's AABB\n  dVector3 aabb[2];\n  dReal radius2 = radius*radius;\n  dReal lz = l[2] + length*REAL(0.5);\n  dReal rz = l[2] - length*REAL(0.5);\n  if (lz > rz) {\n    aabb[0][0] = l[0] - sides[0];\n    aabb[0][1] = l[1] - sides[1];\n    aabb[0][2] = rz;\n    aabb[1][0] = l[0] + sides[0];\n    aabb[1][1] = l[1] + sides[1];\n    aabb[1][2] = lz;\n  }\n  else {\n    aabb[0][0] = l[0] - sides[0];\n    aabb[0][1] = l[1] - sides[1];\n    aabb[0][2] = lz;\n    aabb[1][0] = l[0] + sides[0];\n    aabb[1][1] = l[1] + sides[1];\n    aabb[1][2] = rz;\n  }\n  dReal *aabb_p = (dReal *) aabb;\n  for", "CodeBleu_score": 40.02848576597533}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63, x64, x65, x66, x67, x68, x69, x70, x71, x72, x73, x74, x75, x76, x77, x78, x79, x80, x81, x82, x83, x84, x85, x86, x87, x88, x89, x90, x91, x92, x93, x94, x95, x96, x97, x98, x99, x100, x101, x102, x103, x104, x105, x106, x107, x108, x109, x110, x111, x112, x113, x114, x115, x116, x117, x118, x119, x120, x121, x122, x123", "CodeBleu_score": 7.640771804908547}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const    // constants\n    const dReal pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679;\n    const dReal two_pi = 2.0 * pi;\n    const dReal half_pi = 0.5 * pi;\n\n    // variables\n    dReal zIOverR2 = zIOverR * zIOverR;\n    dReal zIOverR3 = zIOverR2 * zIOverR;\n    dReal zIOverR4 = zIOverR3 * zIOverR;\n    dReal tanTheta02 = tanTheta0 * tanTheta0;\n    dReal tanTheta04 = tanTheta02 * tanTheta02;\n    dReal tanTheta06 = tanTheta04 * tanTheta02;\n    dReal tanTheta08 = tanTheta06 * tanTheta02;\n    dReal tanTheta10 = tanTheta08 * tanTheta02;\n    dReal tanTheta12 = tanTheta10 * tanTheta02;\n    dReal tanTheta14 = tanTheta12 * tanTheta02;\n    dReal tanTheta16 = tanTheta14 * tanTheta02;\n    dReal tanTheta18 = tanTheta16 * tanTheta02;\n    dReal tanTheta20 = tanTheta18 * tanTheta02;\n    dReal tanTheta22 = tanTheta20 * tanTheta02;\n    dReal tanTheta24 = tanTheta22 * tanTheta02;\n    dReal tanTheta26 = tanTheta24 * tanTheta02;\n    dReal tanTheta28 = tanTheta26 * tanTheta02;\n    dReal tanTheta30 = tanTheta28 * tanTheta02;\n    dReal tanTheta32 = tanTheta30 * tanTheta", "CodeBleu_score": 34.432991595690474}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const    const dReal z = zIOverR * m_radius;\n    const dReal tanTheta0Sq = tanTheta0 * tanTheta0;\n    const dReal sinTheta1Sq = sinTheta1 * sinTheta1;\n    const dReal tanTheta0SqMinus1 = tanTheta0Sq - 1;\n    const dReal sinTheta1SqMinus1 = sinTheta1Sq - 1;\n    const dReal tanTheta0SqMinus1Over2 = tanTheta0SqMinus1 / 2;\n    const dReal sinTheta1SqMinus1Over2 = sinTheta1SqMinus1 / 2;\n    const dReal tanTheta0SqMinus1Over2Sq = tanTheta0SqMinus1Over2 * tanTheta0SqMinus1Over2;\n    const dReal sinTheta1SqMinus1Over2Sq = sinTheta1SqMinus1Over2 * sinTheta1SqMinus1Over2;\n\n    dReal sum = 0;\n    dReal x = 0;\n    dReal y = 0;\n    for (int i = 0; i < m_simpsonIntegrationSteps; i++) {\n        const dReal theta = (i + 1) * dReal(2) / m_simpsonIntegrationSteps - 1;\n        const dReal tanTheta = tanTheta0 * theta + tanTheta0SqMinus1Over2;\n        const dReal sinTheta = sinTheta1 * theta + sinTheta1SqMinus1Over2;\n        const dReal tanThetaSq = tanTheta * tanTheta;\n        const dReal sinThetaSq = sinTheta * sinTheta;\n        const dReal tanThetaSqMinus1 = tanThetaSq - 1;\n        const dReal sinThetaSqMinus1 = sinThetaSq - 1;\n        const dReal tanThetaSqMinus1Over2 = tanThetaSqMinus1 / 2;\n        const dReal sinThetaSqMinus1Over2 = sinThetaSqMinus1 / 2;\n        const dReal tanThetaSqMinus1Over2", "CodeBleu_score": 36.01546272212401}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal x0 = 0.0;\n\tdReal x1 = 0.0;\n\tdReal x2 = 0.0;\n\tdReal x3 = 0.0;\n\tdReal x4 = 0.0;\n\tdReal x5 = 0.0;\n\tdReal x6 = 0.0;\n\tdReal x7 = 0.0;\n\tdReal x8 = 0.0;\n\tdReal x9 = 0.0;\n\tdReal x10 = 0.0;\n\tdReal x11 = 0.0;\n\tdReal x12 = 0.0;\n\tdReal x13 = 0.0;\n\tdReal x14 = 0.0;\n\tdReal x15 = 0.0;\n\tdReal x16 = 0.0;\n\tdReal x17 = 0.0;\n\tdReal x18 = 0.0;\n\tdReal x19 = 0.0;\n\tdReal x20 = 0.0;\n\tdReal x21 = 0.0;\n\tdReal x22 = 0.0;\n\tdReal x23 = 0.0;\n\tdReal x24 = 0.0;\n\tdReal x25 = 0.0;\n\tdReal x26 = 0.0;\n\tdReal x27 = 0.0;\n\tdReal x28 = 0.0;\n\tdReal x29 = 0.0;\n\tdReal x30 = 0.0;\n\tdReal x31 = 0.0;\n\tdReal x32 = 0.0;\n\tdReal x33 = 0.0;\n\tdReal x34 = 0.0;\n\tdReal x35 = 0.0;\n\tdReal x36 = 0.0;\n\tdReal x37 = 0.0;\n\tdReal x38 = 0.0;\n\tdReal x39 = 0.0;\n\td", "CodeBleu_score": 9.8199744272259}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tconst dReal pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679;\n\tconst dReal piOver2 = 1.5707963267948966192313216916397514420985846996875529104874722961546473979536132812572028298584763415;\n\tconst dReal piOver4 = 0.78539816339744830961566084581987572104929234984377645524377472306963180337988793823424198454956358636;\n\tconst dReal oneOverSqrt3 = 0.57735026918962576450914878050195745564760175127012676034859107675652544561895404369976679502367111282;\n\tconst dReal oneOverSqrt2 = 0.7071067811865475244008443621048490392848359", "CodeBleu_score": 10.49896725223955}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal xBuoyancyCenter = 0;\n\tdReal x = 0;\n\tdReal y = 0;\n\tdReal z = 0;\n\tdReal rSq = 0;\n\tdReal zSq = 0;\n\tdReal xSq = 0;\n\tdReal xSqPlusYSq = 0;\n\tdReal xSqPlusYSqPlusZSq = 0;\n\tdReal xSqPlusYSqMinusZSq = 0;\n\tdReal xSqPlusYSqPlusZSqMinusR = 0;\n\tdReal xSqPlusYSqMinusZSqMinusR = 0;\n\tdReal xSqPlusYSqPlusZSqMinusRSq = 0;\n\tdReal xSqPlusYSqMinusZSqMinusRSq = 0;\n\tdReal xSqPlusYSqPlusZSqMinusRPlusZ = 0;\n\tdReal xSqPlusYSqMinusZSqMinusRPlusZ = 0;\n\tdReal xSqPlusYSqPlusZSqMinusRMinusZ = 0;\n\tdReal xSqPlusYSqMinusZSqMinusRMinusZ = 0;\n\tdReal xSqPlusYSqPlusZSqMinusRPlusZSq = 0;\n\tdReal xSqPlusYSqMinusZSqMinusRPlusZSq = 0;\n\tdReal xSqPlusYSqPlusZSqMinusRMinusZSq = 0;\n\tdReal xSqPlusYSqMinusZSqMinusRMinusZSq = 0;\n\tdReal xSqPlusYSqPlusZSqMinusRPlusZSqMinusR = 0;\n\tdReal xSqPlusYSqMinusZSqMinusRPlusZSqMinusR = 0;\n\tdReal xSqPlusYSqPlusZSqMinusRMinusZSqMinusR = 0;\n\tdReal xSqPlusYSqMinusZSq", "CodeBleu_score": 13.475431171276792}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dIASSERT (immersion);\n  dIASSERT ((flags & NUMC_MASK) >= 1);\n  dIASSERT ((flags & NUMC_MASK) <= 8);\n  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n  dIASSERT (o1->body && o2->body);\n\n  dxCapsule *capsule = (dxCapsule*) o1;\n  dxTriMesh *mesh = (dxTriMesh*) o2;\n  dBody *body1 = o1->body;\n  dBody *body2 = o2->body;\n  dReal radius = capsule->radius;\n  dReal depth = radius * immersion->depth_ratio;\n  dReal *pos1 = immersion->pos1;\n  dReal *pos2 = immersion->pos2;\n  dReal *normal = immersion->normal;\n  dReal *pos = immersion->pos;\n  dReal *R1 = immersion->R1;\n  dReal *R2 = immersion->R2;\n  dReal *R1inv = immersion->R1inv;\n  dReal *R2inv = immersion->R2inv;\n  dReal *normal_R1 = immersion->normal_R1;\n  dReal *normal_R2 = immersion->normal_R2;\n  dReal *pos_R1 = immersion->pos_R1;\n  dReal *pos_R2 = immersion->pos_R2;\n  dReal *pos_R12 = immersion->pos_R12;\n  dReal *normal_R12 = immersion->normal_R12;\n  dReal *pos_R12inv = immersion->pos_R12inv;\n  dReal *normal_R12inv = immersion->normal_R12inv;\n  dReal *pos_R12inv_R1 = immersion->pos_R12inv_R1;\n  dReal *normal_R12inv_R1 = immersion->normal_R12", "CodeBleu_score": 40.48439585839323}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dIASSERT (o1->type == dCapsuleClass);\n  dIASSERT (o2->type == dTriMeshClass);\n  dIASSERT ((flags & NUMI_MASK) >= 1);\n\n  dxCapsule *capsule = (dxCapsule*) o1;\n  dxTriMesh *tm = (dxTriMesh*) o2;\n\n  // get capsule parameters\n  dReal r = capsule->radius;\n  dReal l = capsule->lz;\n  dVector3 p;\n  dVector3 q;\n  dGeomGetCapsuleEndpoints (o1, p, q);\n\n  // get the center of the capsule\n  dReal px = (p[0] + q[0]) * REAL(0.5);\n  dReal py = (p[1] + q[1]) * REAL(0.5);\n  dReal pz = (p[2] + q[2]) * REAL(0.5);\n\n  // get the normal of the capsule\n  dVector3 n;\n  n[0] = q[0] - p[0];\n  n[1] = q[1] - p[1];\n  n[2] = q[2] - p[2];\n  dNormalize3 (n);\n\n  // get the orientation of the capsule\n  dMatrix3 R;\n  dRFromZ (R, n);\n\n  // get the radius of the hemisphere\n  dReal R2 = r * r;\n\n  // get the height of the hemisphere\n  dReal h = dSqrt (R2 - l * l);\n\n  // get the volume of the hemisphere\n  dReal V = REAL(0.5) * M_PI * R2 * h;\n\n  // get the initial angle of the hemisphere\n  dReal theta1 = dAsin (l / r);\n\n  // get the final angle of the hemisphere\n  dReal theta2 = dAcos (l / h);\n\n  // get the immersion depth ratio\n  dReal rho = (l +", "CodeBleu_score": 40.49974070784217}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\n    dIASSERT (immersion != NULL);\n    dIASSERT (immersion->immersionType == dImmersionCapsuleTrimesh);\n    dIASSERT (immersion->immersionData != NULL);\n\n    dImmerseCapsuleTrimeshData *immersionData = (dImmerseCapsuleTrimeshData *)immersion->immersionData;\n\n    // get the capsule\n    dReal radius = REAL(0.5) * (o1->capsule.radius + o2->capsule.radius);\n    dReal length = o1->capsule.lz;\n    dVector3 pos;\n    dVector3 axis;\n    dGeomGetCapsulePosition (o1, pos, axis);\n    dVector3 axis2;\n    dGeomGetCapsuleAxis (o2, axis2);\n\n    // get the trimesh\n    dReal *vertices = (dReal *)immersionData->vertices;\n    dReal *normals = (dReal *)immersionData->normals;\n    int *indices = (int *)immersionData->indices;\n    int n = immersionData->n;\n    int m = immersionData->m;\n\n    // calculate the center of the sphere's surface in the capsule's frame\n    dVector3 center;\n    dCROSS (center, =, axis2, axis);\n    dMULTIPLY1_331 (center, o2->posr.R, center);\n    dAddVectors3 (center, center, o2->posr.pos);\n    dSubtractVectors3 (center, center, pos);\n\n    // calculate the radius of the sphere\n    dReal radius2 = dCalcVectorLengthSquared3 (center);\n    if (radius2 > radius * radius) {\n        // the sphere is completely outside the capsule\n        return 0;\n    }\n\n    // calculate the height of the hemisphere\n    dReal height = dSqrt (radius * radius - radius2);\n\n    // calculate the depth of the hemisphere\n    dReal depth = height - radius2;\n\n", "CodeBleu_score": 38.54267318600873}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()    // Retrieve the sleep duration from the input\n    double duration = getInput<double>(\"duration\");\n    if (duration <= 0.0) {\n        return SUCCESS;\n    }\n    // Set the node status to RUNNING\n    setStatus(RUNNING);\n    // Start a timer\n    timer_ = nh_.createTimer(ros::Duration(duration), &SleepNode::timerCallback, this);\n    // Set a callback to emit a wake-up signal when the timer expires\n    timer_.setWallDuration(ros::WallDuration(duration));\n    timer_.start();\n    // Set the timer_waiting_ flag\n    timer_waiting_ = true;\n    return RUNNING;\n}\n", "CodeBleu_score": 37.3310567355333}, {"code": "NodeStatus SleepNode::onStart()  // Retrieve the sleep duration from the input.\n  auto sleep_duration = getInput<int>(\"sleep_duration\");\n\n  // If the duration is missing or non-positive, return SUCCESS.\n  if (!sleep_duration || *sleep_duration <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING.\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer.\n  timer_ = std::make_unique<rclcpp::TimerBase::SharedPtr>(\n    std::make_shared<rclcpp::TimerBase>(\n      getNodeBaseInterface().get_node_base_interface()));\n\n  // Set a callback to emit a wake-up signal when the timer expires.\n  timer_->reset(\n    std::bind(&SleepNode::onTimerExpire, this),\n    std::chrono::milliseconds(*sleep_duration));\n\n  // Set the timer_waiting_ flag to true.\n  timer_waiting_ = true;\n\n  return NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 47.26135596447059}, {"code": "NodeStatus SleepNode::onStart()  // Retrieve the sleep duration in milliseconds from the input\n  std::string sleep_duration_str;\n  if (!getInput<std::string>(\"sleep_duration\", sleep_duration_str)) {\n    return NodeStatus::FAILURE;\n  }\n\n  // Parse the sleep duration\n  double sleep_duration_ms;\n  try {\n    sleep_duration_ms = std::stod(sleep_duration_str);\n  } catch (const std::invalid_argument& e) {\n    RCLCPP_ERROR(getLogger(), \"Invalid sleep duration: %s\", e.what());\n    return NodeStatus::FAILURE;\n  } catch (const std::out_of_range& e) {\n    RCLCPP_ERROR(getLogger(), \"Invalid sleep duration: %s\", e.what());\n    return NodeStatus::FAILURE;\n  }\n\n  // Check the sleep duration\n  if (sleep_duration_ms <= 0) {\n    RCLCPP_WARN(getLogger(), \"Sleep duration is non-positive: %f ms\", sleep_duration_ms);\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start the timer\n  timer_ = createWallTimer(\n    std::chrono::milliseconds(static_cast<int>(sleep_duration_ms)),\n    [this]() {\n      // Set the node status to SUCCESS\n      setStatus(NodeStatus::SUCCESS);\n\n      // Reset the timer_waiting_ flag\n      timer_waiting_ = false;\n\n      // Emit the wake-up signal\n      emitEvent();\n    });\n\n  // Set the timer_waiting_ flag\n  timer_waiting_ = true;\n\n  return NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 43.94590739157004}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()    if (getBlackboard().getEntry(entry_name_).isValid()) {\n        getBlackboard().getEntry(entry_name_).lock();\n        if (getBlackboard().getEntry(entry_name_).getSequence() != sequence_id_) {\n            sequence_id_ = getBlackboard().getEntry(entry_name_).getSequence();\n            getBlackboard().getEntry(entry_name_).unlock();\n            return NodeStatus::SUCCESS;\n        }\n        getBlackboard().getEntry(entry_name_).unlock();\n        return NodeStatus::FAILURE;\n    }\n    return NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 37.95089190201442}, {"code": "NodeStatus EntryUpdatedAction::tick()    // Get the entry from the blackboard\n    std::shared_ptr<Entry> entry = blackboard->getEntry(key);\n    if (!entry) {\n        // Entry not found\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the entry mutex\n    std::lock_guard<std::mutex> lock(entry->mutex);\n\n    // Compare the current sequence ID with the previously stored sequence ID\n    if (entry->sequence_id == sequence_id) {\n        // Sequence ID has not changed\n        return NodeStatus::FAILURE;\n    }\n\n    // Update the stored sequence ID\n    sequence_id = entry->sequence_id;\n\n    // Sequence ID has changed\n    return NodeStatus::SUCCESS;\n}\n", "CodeBleu_score": 40.979434732917376}, {"code": "NodeStatus EntryUpdatedAction::tick()    // Retrieve the entry from the blackboard\n    std::shared_ptr<BlackboardEntry> entry = blackboard->getEntry(entryName);\n\n    // Check if the entry is valid\n    if (entry == nullptr) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the mutex of the entry\n    std::unique_lock<std::mutex> lock(entry->mutex);\n\n    // Check if the sequence ID of the entry has been updated\n    if (entry->sequenceID != sequenceID) {\n        sequenceID = entry->sequenceID;\n        return NodeStatus::SUCCESS;\n    }\n\n    return NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 39.528938763091595}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const  if (successThreshold_ < 0) {\n    return std::max(static_cast<size_t>(-successThreshold_), children_.size());\n  }\n  return static_cast<size_t>(successThreshold_);\n}\n", "CodeBleu_score": 54.2874544167955}, {"code": "size_t ParallelNode::successThreshold() const    if (successThreshold_ < 0) {\n        return -successThreshold_ * children_.size();\n    }\n    return successThreshold_;\n}\n", "CodeBleu_score": 49.844289431698094}, {"code": "size_t ParallelNode::successThreshold() const    size_t successThreshold = m_successThreshold;\n    if (successThreshold < 0) {\n        successThreshold = -successThreshold;\n        if (successThreshold == 0) {\n            successThreshold = 1;\n        }\n        successThreshold *= childCount();\n    }\n    return successThreshold;\n}\n", "CodeBleu_score": 41.75534997864784}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        std::lock_guard<std::mutex> lock(heartbeatMutex);\n\n        // check if the heartbeat has been disabled\n        if (heartbeatDisabled) {\n            // if so, enable all breakpoints\n            for (auto &breakpoint : breakpoints) {\n                breakpoint.second->enable();\n            }\n\n            // reset the heartbeatDisabled flag\n            heartbeatDisabled = false;\n        }\n\n        // check if the heartbeat has expired\n        if (heartbeatExpired) {\n            // if so, disable all breakpoints\n            for (auto &breakpoint : breakpoints) {\n                breakpoint.second->disable();\n            }\n\n            // reset the heartbeatExpired flag\n            heartbeatExpired = false;\n        }\n\n        // sleep for 10 milliseconds\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n", "CodeBleu_score": 37.165459597155404}, {"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        std::lock_guard<std::mutex> lock(mutex);\n        if (heartbeat.empty()) {\n            continue;\n        }\n\n        // Check if heartbeat is still active\n        auto now = std::chrono::system_clock::now();\n        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(now - heartbeat.back().second).count();\n        if (duration > 1000) {\n            // Disable breakpoints\n            for (auto &breakpoint : breakpoints) {\n                breakpoint.second.enabled = false;\n            }\n            heartbeat.clear();\n            continue;\n        }\n\n        // Enable breakpoints\n        for (auto &breakpoint : breakpoints) {\n            breakpoint.second.enabled = true;\n        }\n    }\n}\n", "CodeBleu_score": 43.1839268901539}, {"code": "void Groot2Publisher::heartbeatLoop()  while (true) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    std::lock_guard<std::mutex> lock(m_mutex);\n    if (m_heartbeat_status == HeartbeatStatus::INACTIVE) {\n      // disable all breakpoints\n      for (auto it = m_breakpoints.begin(); it != m_breakpoints.end(); it++) {\n        it->second->disable();\n      }\n    } else if (m_heartbeat_status == HeartbeatStatus::ACTIVE) {\n      // enable all breakpoints\n      for (auto it = m_breakpoints.begin(); it != m_breakpoints.end(); it++) {\n        it->second->enable();\n      }\n    }\n  }\n}\n", "CodeBleu_score": 36.4619775836935}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<uint8_t> result;\n    std::vector<std::string> bb_names;\n    std::stringstream ss(bb_list);\n    std::string item;\n    while (std::getline(ss, item, ',')) {\n        bb_names.push_back(item);\n    }\n\n    for (auto& bb_name : bb_names) {\n        auto subtree = m_groot->getSubtree(bb_name);\n        if (subtree) {\n            std::string json_string;\n            subtree->exportJSON(json_string);\n            json json_obj = json::parse(json_string);\n            result.insert(result.end(), json_obj.dump().begin(), json_obj.dump().end());\n        }\n    }\n    return result;\n}\n", "CodeBleu_score": 45.018897554262246}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)  std::vector<uint8_t> result;\n  std::stringstream ss(bb_list);\n  std::string bb_name;\n  while (std::getline(ss, bb_name, ',')) {\n    auto bb = bt_->getBlackboard();\n    auto subtree = bb->getSubTree(bb_name);\n    if (subtree) {\n      std::string json_str;\n      subtree->toJson(json_str);\n      auto json_obj = nlohmann::json::parse(json_str);\n      result.insert(result.end(), json_obj.begin(), json_obj.end());\n    }\n  }\n  return result;\n}\n", "CodeBleu_score": 46.75354839455238}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<uint8_t> msgpack_data;\n\n    std::vector<std::string> blackboard_names;\n    boost::split(blackboard_names, bb_list, boost::is_any_of(\",\"));\n\n    // Create a JSON object\n    json json_bb_list;\n\n    for (const auto& bb_name : blackboard_names) {\n        // Find the corresponding subtree\n        auto subtree = std::find_if(m_subtrees.begin(), m_subtrees.end(), [&bb_name](const auto& subtree) {\n            return subtree->getBlackboardName() == bb_name;\n        });\n\n        if (subtree != m_subtrees.end()) {\n            // Lock the subtree\n            (*subtree)->lock();\n\n            // Export the blackboard to JSON\n            json json_bb = (*subtree)->exportBlackboardToJSON();\n\n            // Unlock the subtree\n            (*subtree)->unlock();\n\n            // Add the blackboard to the JSON object\n            json_bb_list[bb_name] = json_bb;\n        }\n    }\n\n    // Convert the JSON object to MessagePack format\n    msgpack_data = nlohmann::json::to_msgpack(json_bb_list);\n\n    return msgpack_data;\n}\n", "CodeBleu_score": 45.62982534140551}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  // Check if the node exists\n  if (pos.node_uid == node_uid) {\n    // Lock the mutex\n    std::lock_guard<std::mutex> lock(pos.hook->mutex);\n    // Check if the node is valid\n    if (pos.hook->status == NodeStatus::BREAKPOINT) {\n      // Set the status\n      pos.hook->status = result;\n      // Set the removal flag\n      pos.hook->remove = remove;\n      // Mark the hook as ready\n      pos.hook->ready = true;\n      // Notify all waiting threads\n      pos.hook->cond.notify_all();\n      // Return true\n      return true;\n    }\n  }\n  // Return false\n  return false;\n}\n", "CodeBleu_score": 30.89245024819183}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)    bool success = false;\n    std::unique_lock<std::mutex> lock(m_mutex);\n    auto it = m_nodes.find(node_uid);\n    if (it != m_nodes.end()) {\n        auto &node = it->second;\n        if (node.isValid()) {\n            auto &hook = node.getHook(pos);\n            std::unique_lock<std::mutex> hook_lock(hook.m_mutex);\n            if (hook.m_status == NodeStatus::BREAKPOINT) {\n                hook.m_status = result;\n                hook.m_remove = remove;\n                hook.m_ready = true;\n                hook.m_cv.notify_all();\n                success = true;\n            }\n        }\n    }\n    return success;\n}\n", "CodeBleu_score": 49.12922763664332}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  // Check if the node exists\n  if (pos.nodes.find(node_uid) == pos.nodes.end()) {\n    ROS_ERROR_STREAM(\"Groot2Publisher::unlockBreakpoint: Node \" << node_uid << \" does not exist\");\n    return false;\n  }\n\n  // Check if the node is valid\n  if (!pos.nodes[node_uid]->isValid()) {\n    ROS_ERROR_STREAM(\"Groot2Publisher::unlockBreakpoint: Node \" << node_uid << \" is invalid\");\n    return false;\n  }\n\n  // Lock the mutex\n  std::unique_lock<std::mutex> lock(pos.nodes[node_uid]->hook_mutex);\n\n  // Check if the node is in breakpoint mode\n  if (pos.nodes[node_uid]->hook->getMode() != HookMode::BREAKPOINT) {\n    ROS_ERROR_STREAM(\"Groot2Publisher::unlockBreakpoint: Node \" << node_uid << \" is not in breakpoint mode\");\n    return false;\n  }\n\n  // Set the desired status\n  pos.nodes[node_uid]->hook->setStatus(result);\n\n  // Set the removal flag\n  pos.nodes[node_uid]->hook->setRemovalFlag(remove);\n\n  // Mark the hook as ready\n  pos.nodes[node_uid]->hook->setReady();\n\n  // Notify all waiting threads\n  pos.nodes[node_uid]->hook->notify_all();\n\n  return true;\n}\n", "CodeBleu_score": 35.72626560590605}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()    // Check if the action is already running\n    if (status == RUNNING) {\n        // The action is already running, return RUNNING\n        return RUNNING;\n    }\n\n    // Check if the action has been halted\n    if (halt_requested_) {\n        // The action has been halted, return IDLE\n        return IDLE;\n    }\n\n    // Set the status to RUNNING\n    status = RUNNING;\n\n    // Start a new thread to run the action\n    thread_ = std::thread(&ThreadedAction::run, this);\n\n    // Return RUNNING\n    return RUNNING;\n}\n", "CodeBleu_score": 11.89474584686281}, {"code": "NodeStatus BT::ThreadedAction::executeTick()    // Check if the thread is already running\n    if(thread_running_) {\n        // If so, check if a halt has been requested\n        if(halt_requested_) {\n            // If so, set the node status to HALTED and halt the thread\n            setStatus(HALTED);\n            thread_.interrupt();\n            thread_.join();\n            thread_running_ = false;\n        }\n        // Return the current status of the node\n        return status();\n    }\n    // If the thread is not already running, set the node status to RUNNING\n    setStatus(RUNNING);\n    // Reset the halt request\n    halt_requested_ = false;\n    // Start the thread\n    thread_running_ = true;\n    // Run the tick function in a separate thread\n    thread_ = boost::thread(boost::bind(&ThreadedAction::tick, this));\n    // Return the current status of the node\n    return status();\n}\n", "CodeBleu_score": 30.38052489574543}, {"code": "NodeStatus BT::ThreadedAction::executeTick()    // Check if the node has been halted\n    if (halt_requested_) {\n        // Halt the node\n        setStatus(BT::HALTED);\n        halt_requested_ = false;\n        return status_;\n    }\n\n    // Check if the node is already running\n    if (status_ == BT::RUNNING) {\n        // The node is already running, return the status\n        return status_;\n    }\n\n    // Set the status to RUNNING\n    setStatus(BT::RUNNING);\n\n    // Reset the halt_requested flag\n    halt_requested_ = false;\n\n    // Start a new thread to run the tick function\n    std::thread tick_thread([&]() {\n        try {\n            // Run the tick function\n            tick();\n            // If the tick function completed without a halt request, set the status to SUCCESS\n            if (!halt_requested_) {\n                setStatus(BT::SUCCESS);\n            }\n        } catch (const BT::Exception& ex) {\n            // Catch the exception and log an error\n            setStatus(BT::ERROR);\n            throw ex;\n        } catch (const std::exception& ex) {\n            // Catch the exception and log an error\n            setStatus(BT::ERROR);\n            throw BT::RuntimeError(\"Exception caught in ThreadedAction::executeTick: \", ex.what());\n        } catch (...) {\n            // Catch the exception and log an error\n            setStatus(BT::ERROR);\n            throw BT::RuntimeError(\"Unknown exception caught in ThreadedAction::executeTick\");\n        }\n    });\n    tick_thread.detach();\n\n    // Return the current status of the node\n    return status_;\n}\n", "CodeBleu_score": 49.517922598075245}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    const std::string indent = \"  \";\n\n    // recursive lambda function to print the tree\n    auto print_tree = [&](const TreeNode* node, int depth) {\n        stream << std::string(depth * 2, ' ') << node->name << std::endl;\n        if (const auto* control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control_node->children) {\n                print_tree(child.get(), depth + 1);\n            }\n        } else if (const auto* decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            print_tree(decorator_node->child.get(), depth + 1);\n        }\n    };\n\n    // print the tree\n    stream << std::string(2, '-') << \" Tree \" << std::string(2, '-') << std::endl;\n    print_tree(root_node, 0);\n    stream << std::string(2, '-') << \" End \" << std::string(2, '-') << std::endl;\n}\n", "CodeBleu_score": 45.983054082016324}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    if (root_node == nullptr) {\n        return;\n    }\n\n    stream << \"\\n\";\n\n    auto print_tree = [&](const TreeNode* node, int depth) {\n        for (int i = 0; i < depth; ++i) {\n            stream << \"    \";\n        }\n        stream << node->name() << std::endl;\n\n        if (const auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control_node->children()) {\n                print_tree(child, depth + 1);\n            }\n        } else if (const auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            print_tree(decorator_node->child(), depth + 1);\n        }\n    };\n\n    print_tree(root_node, 0);\n\n    stream << \"\\n\";\n}\n", "CodeBleu_score": 49.99927781631283}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)  // Define a recursive lambda function to handle the printing\n  auto printTreeRecursivelyLambda = [&](const TreeNode* node, int depth) {\n    stream << std::string(2 * depth, ' ') << node->name() << std::endl;\n    if (const auto control_node = dynamic_cast<const ControlNode*>(node)) {\n      for (const auto& child : control_node->children()) {\n        printTreeRecursivelyLambda(child, depth + 1);\n      }\n    } else if (const auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n      printTreeRecursivelyLambda(decorator_node->child(), depth + 1);\n    }\n  };\n\n  // Begin and end with separator lines\n  stream << \"------------------------------------\" << std::endl;\n  printTreeRecursivelyLambda(root_node, 0);\n  stream << \"------------------------------------\" << std::endl;\n}\n", "CodeBleu_score": 46.57702766508011}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr) {\n    throw std::logic_error(\"Node is null\");\n  }\n  visitor(node);\n  if (node->getNodeType() == NodeType::Control) {\n    const ControlNode* controlNode = dynamic_cast<const ControlNode*>(node);\n    for (const TreeNode* child : controlNode->getChildren()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->getNodeType() == NodeType::Decorator) {\n    const DecoratorNode* decoratorNode = dynamic_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decoratorNode->getChild(), visitor);\n  }\n}\n", "CodeBleu_score": 57.99871501155096}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr) {\n    throw std::logic_error(\"Cannot apply visitor to nullptr\");\n  }\n  visitor(node);\n  if (node->getNodeType() == NodeType::Control) {\n    const auto& controlNode = dynamic_cast<const ControlNode*>(node);\n    for (const auto& child : controlNode->getChildren()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->getNodeType() == NodeType::Decorator) {\n    const auto& decoratorNode = dynamic_cast<const DecoratorNode*>(node);\n    applyRecursiveVisitor(decoratorNode->getChild(), visitor);\n  }\n}\n", "CodeBleu_score": 59.710182352201315}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr) {\n    throw std::logic_error(\"Cannot apply visitor to null node.\");\n  }\n  visitor(node);\n  if (node->getNodeType() == NodeType::Control) {\n    for (const auto& child : node->getChildren()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (node->getNodeType() == NodeType::Decorator) {\n    applyRecursiveVisitor(node->getChild(), visitor);\n  }\n}\n", "CodeBleu_score": 46.97974931117872}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    if (m_builders.find(manifest.getRegistrationID()) != m_builders.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder: \"\n                                    \"registration ID already exists\");\n    }\n    m_builders[manifest.getRegistrationID()] = builder;\n    m_manifests[manifest.getRegistrationID()] = manifest;\n}\n", "CodeBleu_score": 41.5208302340233}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    if (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder: \"\n                                    \"Registration ID already exists: \" +\n                                    manifest.registrationID);\n    }\n    builders.insert(std::make_pair(manifest.registrationID, builder));\n    manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}\n", "CodeBleu_score": 46.74535838871966}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    if (m_builders.find(manifest.getRegistrationID()) != m_builders.end()) {\n        throw BehaviorTreeException(\"Registration ID already exists\");\n    }\n\n    m_manifests.insert(std::make_pair(manifest.getRegistrationID(), manifest));\n    m_builders.insert(std::make_pair(manifest.getRegistrationID(), builder));\n}\n", "CodeBleu_score": 47.175357969800956}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  registerBuilder(ID, [=](const std::string& node_name, const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(node_name, tick_functor, config);\n  }, ports);\n}\n", "CodeBleu_score": 42.77768710473042}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)    auto builder = [=](const std::string& node_name, const NodeConfiguration& config) {\n        return std::make_unique<SimpleActionNode>(node_name, tick_functor, config);\n    };\n    auto manifest = TreeNodeManifest(\n        {ID},\n        {PortsList::create_ports(ports)},\n        {NodeType::ACTION});\n    registerBuilder(manifest, builder);\n}\n", "CodeBleu_score": 63.13498290528406}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  auto builder = [tick_functor](const std::string& node_name,\n                               const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(node_name, tick_functor, config);\n  };\n  auto manifest =\n      TreeNodeManifest{ActionNodeType, ID, std::move(ports), builder};\n  registerBuilder(manifest);\n}\n", "CodeBleu_score": 64.18848585054471}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)  std::vector<Blackboard::Ptr> backup;\n  backup.reserve(tree.rootNode()->GetNumChildren());\n\n  for (auto& child : tree.rootNode()->children) {\n    auto backupBlackboard = std::make_shared<Blackboard>();\n    backupBlackboard->SetFrom(child->GetBlackboard());\n    backup.push_back(backupBlackboard);\n  }\n\n  return backup;\n}\n", "CodeBleu_score": 49.296650499847075}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> blackboardBackups;\n    blackboardBackups.reserve(tree.GetSubtreeCount());\n\n    for (const auto& subtree : tree.GetSubtrees()) {\n        auto newBlackboard = std::make_shared<Blackboard>();\n        newBlackboard->Clone(subtree->GetBlackboard());\n        blackboardBackups.push_back(newBlackboard);\n    }\n\n    return blackboardBackups;\n}\n", "CodeBleu_score": 49.09056756768854}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> blackboardBackups;\n    blackboardBackups.reserve(tree.GetChildren().size());\n    for (const auto& child : tree.GetChildren()) {\n        blackboardBackups.push_back(std::make_shared<Blackboard>(*child.GetBlackboard()));\n    }\n    return blackboardBackups;\n}\n", "CodeBleu_score": 51.67061392490064}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor->Execute(env);\n}\n", "CodeBleu_score": 71.20951309976552}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(script);\n\tif (!executor) {\n\t\treturn nonstd::make_unexpected(executor.error());\n\t}\n\treturn Execute(env, *executor);\n}\n", "CodeBleu_score": 66.7273556321342}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if (executor) {\n        return executor->Execute(env);\n    }\n    return executor.error();\n}\n", "CodeBleu_score": 61.565006259106994}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)    // Acquire the lock\n    std::lock_guard<std::mutex> lock(mutex);\n\n    // Check if the library is already loaded\n    if (loaded) {\n        throw RuntimeError(\"Library already loaded\");\n    }\n\n    // Attempt to load the library\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n\n    // Store the path\n    libraryPath = path;\n\n    // Set the loaded flag\n    loaded = true;\n}\n", "CodeBleu_score": 53.58077196096151}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (handle)\n\t\tthrow RuntimeError(\"Library already loaded\");\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle)\n\t\tthrow RuntimeError(dlerror());\n\tthis->path = path;\n}\n", "CodeBleu_score": 47.356246061718366}, {"code": "void SharedLibrary::load(const std::string& path, int)    if (isLoaded())\n        throw RuntimeError(\"Library already loaded.\");\n\n    std::lock_guard<std::mutex> lock(mutex);\n\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (handle == nullptr)\n        throw RuntimeError(dlerror());\n\n    this->path = path;\n}\n", "CodeBleu_score": 47.07103389631635}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    if (str.length() < 3) {\n        return false;\n    }\n\n    StringView stripped = str.trim();\n\n    if (stripped.length() < 3) {\n        return false;\n    }\n\n    if (stripped.front() != '{' || stripped.back() != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = stripped.substr(1, stripped.length() - 2);\n    }\n\n    return true;\n}\n", "CodeBleu_score": 27.219811380685556}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    if (str.size() < 3) {\n        return false;\n    }\n\n    StringView stripped = str.trim();\n\n    if (stripped.size() < 3) {\n        return false;\n    }\n\n    if (stripped.front() != '{' || stripped.back() != '}') {\n        return false;\n    }\n\n    if (stripped_pointer) {\n        *stripped_pointer = stripped.substr(1, stripped.size() - 2);\n    }\n\n    return true;\n}\n", "CodeBleu_score": 27.60846743604977}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.length() < 3) return false;\n\tStringView s = str;\n\ts.trim();\n\tif (s.length() < 3) return false;\n\tif (s[0] != '{' || s[s.length() - 1] != '}') return false;\n\tif (stripped_pointer) *stripped_pointer = s.substr(1, s.length() - 2);\n\treturn true;\n}\n", "CodeBleu_score": 21.321055991259403}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  double lineCost = 0.0;\n  double pointCost = 0.0;\n  double maxCost = 0.0;\n  double minCost = 0.0;\n  double deltaX = x1 - x0;\n  double deltaY = y1 - y0;\n  double deltaXSign = (deltaX < 0) ? -1.0 : 1.0;\n  double deltaYSign = (deltaY < 0) ? -1.0 : 1.0;\n  double deltaXAbs = fabs(deltaX);\n  double deltaYAbs = fabs(deltaY);\n  double error = deltaXAbs + deltaYAbs;\n  double error2;\n\n  if (deltaXAbs >= deltaYAbs) {\n    error2 = deltaYAbs << 1;\n    while (x0 != x1) {\n      pointCost = pointCostAt(x0, y0);\n      if (pointCost < 0) {\n        return pointCost;\n      }\n      maxCost = std::max(maxCost, pointCost);\n      minCost = std::min(minCost, pointCost);\n      if (error > deltaXAbs) {\n        error -= deltaXAbs;\n        y0 += deltaYSign;\n        error2 -= deltaXAbs;\n      } else {\n        error += error2;\n        x0 += deltaXSign;\n      }\n      lineCost += pointCost;\n    }\n  } else {\n    error2 = deltaXAbs << 1;\n    while (y0 != y1) {\n      pointCost = pointCostAt(x0, y0);\n      if (pointCost < 0) {\n        return pointCost;\n      }\n      maxCost = std::max(maxCost, pointCost);\n      minCost = std::min(minCost, pointCost);\n      if (error > deltaYAbs) {\n        error -= deltaYAbs;\n        x0 += deltaXSign;\n        error2 -= deltaYAbs;\n      } else {\n        error += error2;\n        y0 += deltaYSign;\n      }\n      lineCost += pointCost;", "CodeBleu_score": 36.89092693959161}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  double lineCost = 0.0;\n  double pointCost = 0.0;\n  double slope = (double)(y1 - y0) / (double)(x1 - x0);\n  double intercept = y0 - slope * x0;\n\n  for (LineIterator it(x0, x1, y0, y1, *this); !it.isDone(); it.advance()) {\n    pointCost = pointCost(it.getX(), it.getY(), slope, intercept);\n    if (pointCost < 0.0)\n      return pointCost;\n    lineCost = std::max(lineCost, pointCost);\n  }\n  return lineCost;\n}\n", "CodeBleu_score": 48.145644097898646}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  double cost = 0.0;\n  double line_cost = 0.0;\n  double point_cost = 0.0;\n  double max_cost = 0.0;\n  double min_cost = 0.0;\n  double scale = 1.0;\n  double inv_scale = 1.0;\n  double inv_scale_sq = 1.0;\n  double dx = 0.0;\n  double dy = 0.0;\n  double d = 0.0;\n  double d_sq = 0.0;\n  double d_inv = 0.0;\n  double d_inv_sq = 0.0;\n  double d_inv_3 = 0.0;\n  double d_inv_5 = 0.0;\n  double d_inv_7 = 0.0;\n  double d_inv_9 = 0.0;\n  double d_inv_11 = 0.0;\n  double d_inv_13 = 0.0;\n  double d_inv_15 = 0.0;\n  double d_inv_17 = 0.0;\n  double d_inv_19 = 0.0;\n  double d_inv_21 = 0.0;\n  double d_inv_23 = 0.0;\n  double d_inv_25 = 0.0;\n  double d_inv_27 = 0.0;\n  double d_inv_29 = 0.0;\n  double d_inv_31 = 0.0;\n  double d_inv_33 = 0.0;\n  double d_inv_35 = 0.0;\n  double d_inv_37 = 0.0;\n  double d_inv_39 = 0.0;\n  double d_inv_41 = 0.0;\n  double d_inv_43 = 0.0;\n  double d_inv_45 = 0.0;\n  double d_inv_47 = 0.0;\n  double d_inv_49 =", "CodeBleu_score": 13.04324285137759}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   if (path.size() == 0) {\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}\n", "CodeBleu_score": 85.34787746054684}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   if (path.empty()) {\n    return;\n  }\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header = path[0].header;\n  gui_path.header.frame_id = \"map\";\n  gui_path.header.stamp = ros::Time::now();\n\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}\n\n\n", "CodeBleu_score": 74.36716159359639}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   // If the path is empty, do nothing\n  if (path.empty()) {\n    return;\n  }\n\n  // Create a nav_msgs::Path message and populate its header\n  nav_msgs::Path plan_msg;\n  plan_msg.header.frame_id = path[0].header.frame_id;\n  plan_msg.header.stamp = path[0].header.stamp;\n\n  // Copy each pose from the path to the plan_msg\n  plan_msg.poses.resize(path.size());\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    plan_msg.poses[i] = path[i].pose;\n  }\n\n  // Publish the plan_msg message\n  pub.publish(plan_msg);\n}\n\n", "CodeBleu_score": 65.72587341964137}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  // Check if the robot has stopped\n  if (fabs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity &&\n      fabs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 74.40713523586669}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  // Check if the robot has stopped.\n  if (base_odom.twist.twist.angular.z <= rot_stopped_velocity && \n      base_odom.twist.twist.linear.x <= trans_stopped_velocity && \n      base_odom.twist.twist.linear.y <= trans_stopped_velocity) {\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 54.70638144081339}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  if(base_odom.twist.twist.angular.z <= rot_stopped_velocity &&\n     base_odom.twist.twist.linear.x <= trans_stopped_velocity &&\n     base_odom.twist.twist.linear.y <= trans_stopped_velocity &&\n     base_odom.twist.twist.linear.z <= trans_stopped_velocity) {\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 53.28799615311721}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)    if (setup_done_) {\n        if (restore_defaults) {\n            // reset to default values\n            LocalPlannerLimits default_config;\n            default_config.min_vel_x = config.min_vel_x;\n            default_config.max_vel_x = config.max_vel_x;\n            default_config.min_vel_x_backwards = config.min_vel_x_backwards;\n            default_config.max_vel_x_backwards = config.max_vel_x_backwards;\n            default_config.min_vel_y = config.min_vel_y;\n            default_config.max_vel_y = config.max_vel_y;\n            default_config.min_vel_theta = config.min_vel_theta;\n            default_config.max_vel_theta = config.max_vel_theta;\n            default_config.max_vel_x_in_goal_region = config.max_vel_x_in_goal_region;\n            default_config.max_vel_y_in_goal_region = config.max_vel_y_in_goal_region;\n            default_config.max_vel_theta_in_goal_region = config.max_vel_theta_in_goal_region;\n            default_config.max_acc_x = config.max_acc_x;\n            default_config.max_acc_y = config.max_acc_y;\n            default_config.max_acc_theta = config.max_acc_theta;\n            default_config.max_acc_x_in_goal_region = config.max_acc_x_in_goal_region;\n            default_config.max_acc_y_in_goal_region = config.max_acc_y_in_goal_region;\n            default_config.max_acc_theta_in_goal_region = config.max_acc_theta_in_goal_region;\n            default_config.max_jerk_x = config.max_jerk_x;\n            default_config.max_jerk_y = config.max_jerk_y;\n            default_config.", "CodeBleu_score": 29.083113886631445}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)    if (restore_defaults) {\n        if (setup) {\n            config.max_vel_x = default_config.max_vel_x;\n            config.max_vel_x_backwards = default_config.max_vel_x_backwards;\n            config.max_vel_y = default_config.max_vel_y;\n            config.max_vel_theta = default_config.max_vel_theta;\n            config.max_vel_x_in_obstacle = default_config.max_vel_x_in_obstacle;\n            config.max_vel_y_in_obstacle = default_config.max_vel_y_in_obstacle;\n            config.max_vel_theta_in_obstacle = default_config.max_vel_theta_in_obstacle;\n            config.min_in_place_vel_x = default_config.min_in_place_vel_x;\n            config.min_in_place_vel_theta = default_config.min_in_place_vel_theta;\n            config.max_trans_acc = default_config.max_trans_acc;\n            config.max_rot_acc = default_config.max_rot_acc;\n            config.max_trans_jerk = default_config.max_trans_jerk;\n            config.max_rot_jerk = default_config.max_rot_jerk;\n            config.trans_gain = default_config.trans_gain;\n            config.rot_gain = default_config.rot_gain;\n            config.trans_gain_in_obstacle = default_config.trans_gain_in_obstacle;\n            config.rot_gain_in_obstacle = default_config.rot_gain_in_obstacle;\n            config.rot_stopped_vel = default_config.rot_stopped_vel;\n            config.min_in_place_rot_vel = default_config.min_in_place_rot_vel;\n            config.min_stop_distance_before_obstacle = default_config.min_stop_distance_before", "CodeBleu_score": 22.020644325522625}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  if (setup_done_) {\n    if (restore_defaults) {\n      // Restore default configuration\n      config.min_vel_x = default_config_.min_vel_x;\n      config.max_vel_x = default_config_.max_vel_x;\n      config.min_vel_x_backwards = default_config_.min_vel_x_backwards;\n      config.max_vel_x_backwards = default_config_.max_vel_x_backwards;\n      config.min_vel_y = default_config_.min_vel_y;\n      config.max_vel_y = default_config_.max_vel_y;\n      config.min_vel_theta = default_config_.min_vel_theta;\n      config.max_vel_theta = default_config_.max_vel_theta;\n      config.max_vel_x_in_goal_region = default_config_.max_vel_x_in_goal_region;\n      config.min_in_place_vel_x = default_config_.min_in_place_vel_x;\n      config.max_in_place_vel_x = default_config_.max_in_place_vel_x;\n      config.min_in_place_vel_theta = default_config_.min_in_place_vel_theta;\n      config.max_in_place_vel_theta = default_config_.max_in_place_vel_theta;\n      config.min_trans_vel_when_stopped = default_config_.min_trans_vel_when_stopped;\n      config.min_rot_in_place_vel = default_config_.min_rot_in_place_vel;\n      config.max_rot_in_place_vel = default_config_.max_rot_in_place_vel;\n      config.min_goal_dist = default_config_.min_goal_dist;\n      config.max_goal_dist = default_config_.max_goal_dist;\n      config.yaw_goal_tolerance = default_config_.yaw_goal_tolerance;\n      config.xy_goal_tolerance = default_config_.xy_", "CodeBleu_score": 29.019851953477588}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  unsigned int mx, my;\n  double x, y;\n  double distance;\n  double new_distance;\n  double new_distance_squared;\n  double target_distance;\n  double target_distance_squared;\n  unsigned int cost;\n\n  // Get the index of the cell to check\n  mx = check_cell->getX();\n  my = check_cell->getY();\n\n  // Check if the cell has been updated already\n  if (check_cell->getTargetDistance() != -1) {\n    return false;\n  }\n\n  // Get the cost of the cell\n  cost = costmap.getCost(mx, my);\n\n  // Check if the cell is an obstacle\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->setTargetDistance(max_obstacle_cost_);\n    return false;\n  }\n\n  // Get the distance from the current cell to the cell to check\n  x = (double)mx - (double)current_cell->getX();\n  y = (double)my - (double)current_cell->getY();\n  distance = sqrt(x * x + y * y);\n\n  // Get the current target distance of the cell to check\n  target_distance = check_cell->getTargetDistance();\n\n  // Calculate the new target distance\n  new_distance = distance + current_cell->getTargetDistance();\n  new_distance_squared = new_distance * new_distance;\n  target_distance_squared = target_distance * target_distance;\n\n  // Check if the new target distance is shorter\n  if (new_distance_squared < target_distance_squared) {\n    check_cell->setTargetDistance(new_distance);\n    return true;\n  }\n\n  return false;\n}\n", "CodeBleu_score": 51.65174247894937}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  unsigned char cost = costmap.getCost(check_cell->x, check_cell->y);\n  if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = max_obstacle_cost_;\n    return false;\n  }\n  double distance = sqrt(pow(current_cell->x - check_cell->x, 2) + pow(current_cell->y - check_cell->y, 2));\n  if (distance < check_cell->target_distance) {\n    check_cell->target_distance = distance;\n  }\n  return true;\n}\n", "CodeBleu_score": 64.87338857406353}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  unsigned char cost = costmap.getCost(check_cell->x_, check_cell->y_);\n  if (cost == costmap_2d::LETHAL_OBSTACLE) {\n    check_cell->target_distance_ = std::numeric_limits<double>::max();\n    return false;\n  }\n  if (cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance_ = std::numeric_limits<double>::max();\n    return false;\n  }\n  double new_distance = current_cell->target_distance_ +\n      sqrt(pow(current_cell->x_ - check_cell->x_, 2) +\n      pow(current_cell->y_ - check_cell->y_, 2));\n  if (new_distance < check_cell->target_distance_) {\n    check_cell->target_distance_ = new_distance;\n  }\n  return true;\n}\n", "CodeBleu_score": 60.33451850674511}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)    double cost = 0;\n    double scale = 0;\n    double footprint_cost = 0;\n    double min_footprint_cost = 0;\n    double max_footprint_cost = 0;\n\n    if (footprint_spec_.empty()) {\n        ROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: footprint specification is empty\");\n        return -9;\n    }\n\n    for (unsigned int i = 0; i < traj.size(); i++) {\n        footprint_cost = scoreFootprint(traj[i], traj.getSpeed(i));\n        if (footprint_cost < 0) {\n            return footprint_cost;\n        }\n\n        if (sum_scores_) {\n            cost += footprint_cost;\n            scale += 1;\n        } else {\n            if (footprint_cost > max_footprint_cost) {\n                max_footprint_cost = footprint_cost;\n            }\n            if (footprint_cost < min_footprint_cost) {\n                min_footprint_cost = footprint_cost;\n            }\n        }\n    }\n\n    if (sum_scores_) {\n        cost /= scale;\n    } else {\n        cost = max_footprint_cost - min_footprint_cost;\n    }\n\n    return cost;\n}\n", "CodeBleu_score": 52.331209739961395}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double footprint_cost = 0.0;\n\n  if (footprint_spec_.footprint.empty()) {\n    ROS_ERROR(\"Footprint is empty. Cannot score trajectory.\");\n    return -9;\n  }\n\n  // Calculate the scaling factor\n  scaling_factor = traj.getLength() / (double)max_trajectory_length_;\n\n  // Calculate the cost of each point in the trajectory\n  for (unsigned int i = 0; i < traj.getSize(); ++i) {\n\n    footprint_cost = scoreFootprint(traj, i);\n\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n\n    if (sum_scores_) {\n      cost += footprint_cost * scaling_factor;\n    } else {\n      cost = std::max(cost, footprint_cost * scaling_factor);\n    }\n  }\n\n  return cost;\n}\n", "CodeBleu_score": 49.910123644808166}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\n  // Initialize cost and scaling factor\n  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double cost_scale = 1.0;\n\n  // Check if footprint is empty\n  if (footprint_spec_.footprint.empty()) {\n    ROS_ERROR(\"Obstacle cost function: Footprint is empty\");\n    return -9;\n  }\n\n  // For each point in the trajectory\n  for (int i = 0; i < traj.size(); i++) {\n\n    // Calculate footprint cost\n    double footprint_cost = footprintCost(traj.poses[i], traj.speeds[i]);\n\n    // If footprint cost is negative, return cost immediately\n    if (footprint_cost < 0)\n      return footprint_cost;\n\n    // Otherwise, either sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_)\n      cost += footprint_cost * scaling_factor;\n    else\n      cost = std::max(cost, footprint_cost * scaling_factor);\n\n    // Update scaling factor\n    scaling_factor *= scaling_factor_decay_;\n  }\n\n  // Scale cost\n  cost *= cost_scale;\n\n  // Return cost\n  return cost;\n}\n", "CodeBleu_score": 48.68129280395584}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)  // Scale the footprint points\n  std::vector<geometry_msgs::Point> scaled_footprint_spec;\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point scaled_point;\n    scaled_point.x = footprint_spec[i].x * scale;\n    scaled_point.y = footprint_spec[i].y * scale;\n    scaled_point.z = footprint_spec[i].z;\n    scaled_footprint_spec.push_back(scaled_point);\n  }\n\n  // Get the footprint cost\n  double footprint_cost = world_model->footprintCost(scaled_footprint_spec, x, y, th, costmap);\n\n  // Get the cell cost\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    return -7.0;\n  }\n  unsigned int cost = costmap->getCost(mx, my);\n  if (cost == costmap_2d::LETHAL_OBSTACLE) {\n    return -6.0;\n  }\n\n  // Return the maximum cost\n  if (footprint_cost > cost) {\n    return footprint_cost;\n  } else {\n    return cost;\n  }\n}\n", "CodeBleu_score": 66.05316367501337}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)  std::vector<geometry_msgs::Point> scaled_footprint;\n  scaled_footprint.resize(footprint_spec.size());\n  for (unsigned int i = 0; i < footprint_spec.size(); i++) {\n    scaled_footprint[i].x = x + scale * footprint_spec[i].x * cos(th) - scale * footprint_spec[i].y * sin(th);\n    scaled_footprint[i].y = y + scale * footprint_spec[i].x * sin(th) + scale * footprint_spec[i].y * cos(th);\n  }\n\n  double cost = 0.0;\n  for (unsigned int i = 0; i < scaled_footprint.size(); i++) {\n    unsigned int mx, my;\n    if (!costmap->worldToMap(scaled_footprint[i].x, scaled_footprint[i].y, mx, my)) {\n      return -7.0;\n    }\n    cost = std::max(cost, world_model->footprintCost(mx, my));\n  }\n  return cost;\n}\n", "CodeBleu_score": 59.7018742814395}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)  // Scale the footprint points by the given scale factor\n  std::vector<geometry_msgs::Point> scaled_footprint;\n  for (int i = 0; i < footprint_spec.size(); i++) {\n    geometry_msgs::Point scaled_pt;\n    scaled_pt.x = scale * footprint_spec[i].x;\n    scaled_pt.y = scale * footprint_spec[i].y;\n    scaled_footprint.push_back(scaled_pt);\n  }\n\n  // Calculate the footprint cost using a world model\n  double footprint_cost = world_model->footprintCost(scaled_footprint, x, y, th, costmap);\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  // Get the cell cost at the given position\n  unsigned int mx, my;\n  costmap->worldToMap(x, y, mx, my);\n  if (!costmap->isInside(mx, my)) {\n    return -7.0;\n  }\n  double cell_cost = costmap->getCost(mx, my);\n\n  // Return the maximum cost between the footprint cost and the cell cost\n  return std::max(footprint_cost, cell_cost);\n}\n", "CodeBleu_score": 73.92954074631895}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  // if the new topic differs from the current one\n  if (odom_topic != odom_topic_) {\n    // if the new topic is not empty\n    if (!odom_topic.empty()) {\n      // update the topic\n      odom_topic_ = odom_topic;\n      // subscribe to the new odometry topic with a callback to odomCallback\n      odom_subscriber_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    }\n    // if the new topic is empty\n    else {\n      // shut down the existing subscription\n      odom_subscriber_.shutdown();\n    }\n  }\n}\n", "CodeBleu_score": 44.83816871036679}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  // If the odometry topic is the same, do nothing\n  if (odom_topic == odom_topic_)\n    return;\n\n  // If the odometry topic is not empty, subscribe to it\n  if (odom_topic != \"\") {\n    odom_sub_ = nh_.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n  }\n  // If the odometry topic is empty, shut down the existing subscription\n  else {\n    odom_sub_.shutdown();\n  }\n\n  // Update the odometry topic\n  odom_topic_ = odom_topic;\n}\n", "CodeBleu_score": 45.306344868572445}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)    if (odom_topic == odom_topic_)\n        return;\n\n    odom_topic_ = odom_topic;\n\n    if (odom_topic_.empty()) {\n        odom_subscriber_.shutdown();\n        return;\n    }\n\n    odom_subscriber_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n}\n", "CodeBleu_score": 41.87638090567176}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)    // Calculate the squared distance between the current and previous positions\n    float squaredDistance = (pos - prev).squaredNorm();\n    // Calculate the angular difference between the current and previous positions\n    float angularDifference = std::abs(std::atan2(pos[1] - prev[1], pos[0] - prev[0]) - std::atan2(pos[2] - prev[2], pos[0] - prev[0]));\n    // If the squared distance exceeds the threshold or the angular difference is greater than the set angle, reset the oscillation flags\n    if (squaredDistance > _oscillationDistanceThreshold || angularDifference > _oscillationAngleThreshold) {\n        _oscillationFlags[0] = false;\n        _oscillationFlags[1] = false;\n        _oscillationFlags[2] = false;\n    }\n}\n", "CodeBleu_score": 43.474265943593146}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tfloat dist = (pos - prev).norm();\n\tfloat angle = (pos - prev).dot(Eigen::Vector3f::UnitX());\n\tif (dist > maxDistance || angle > maxAngle) {\n\t\tresetOscillationFlags();\n\t}\n}\n", "CodeBleu_score": 27.842828071348997}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tfloat dist = (pos - prev).norm();\n\tif (dist > sqr_distance_threshold_) {\n\t\tresetOscillationFlags();\n\t}\n\telse {\n\t\tfloat angle = (pos - prev).norm();\n\t\tif (angle > angle_threshold_) {\n\t\t\tresetOscillationFlags();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.26677483460965}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)    int x, y, z;\n    if (getGridCoordinates(pt, x, y, z)) {\n        if (x < 0 || y < 0 || z < 0 || x >= grid_width || y >= grid_height || z >= grid_depth) {\n            return;\n        }\n        int index = x + y * grid_width + z * grid_width * grid_height;\n        if (index >= grid_size) {\n            return;\n        }\n        if (cells[index].size() > 0) {\n            double min_dist = std::numeric_limits<double>::max();\n            for (unsigned int i = 0; i < cells[index].size(); i++) {\n                double dist = (pt.x - cells[index][i].x) * (pt.x - cells[index][i].x) + (pt.y - cells[index][i].y) * (pt.y - cells[index][i].y) + (pt.z - cells[index][i].z) * (pt.z - cells[index][i].z);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                }\n            }\n            if (min_dist < sqr(min_distance)) {\n                return;\n            }\n        }\n        cells[index].push_back(pt);\n    }\n}\n", "CodeBleu_score": 42.58810826460529}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)  // get the grid coordinates of the point\n  int x, y, z;\n  getGridCoordinates(pt, x, y, z);\n\n  // check if the point is too close to its nearest neighbor\n  if (x < 0 || x >= width || y < 0 || y >= height || z < 0 || z >= depth) {\n    return;\n  }\n\n  // calculate the grid index\n  int index = x + y * width + z * width * height;\n\n  // insert the point into the grid cell\n  cells[index].push_back(pt);\n}\n", "CodeBleu_score": 43.75871765917411}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)  // Get grid coordinates\n  int x, y, z;\n  if (!getGridCoordinates(pt, x, y, z)) {\n    return;\n  }\n\n  // Get grid index\n  int index = getGridIndex(x, y, z);\n\n  // Check if index is out of bounds\n  if (index < 0 || index >= (int)grid_.size()) {\n    return;\n  }\n\n  // Insert point into grid cell\n  grid_[index].push_back(pt);\n}\n", "CodeBleu_score": 48.262778196895084}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)    Eigen::Vector3f new_vel;\n    new_vel.setZero();\n    for (int i = 0; i < 3; i++) {\n        if (vel(i) < sample_target_vel(i)) {\n            if (vel(i) + acclimits(i) * dt > sample_target_vel(i)) {\n                new_vel(i) = sample_target_vel(i);\n            } else {\n                new_vel(i) = vel(i) + acclimits(i) * dt;\n            }\n        } else if (vel(i) > sample_target_vel(i)) {\n            if (vel(i) - acclimits(i) * dt < sample_target_vel(i)) {\n                new_vel(i) = sample_target_vel(i);\n            } else {\n                new_vel(i) = vel(i) - acclimits(i) * dt;\n            }\n        } else {\n            new_vel(i) = vel(i);\n        }\n    }\n    return new_vel;\n}\n", "CodeBleu_score": 49.872839028613846}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)  Eigen::Vector3f vel_new = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    float vel_diff = sample_target_vel(i) - vel(i);\n    float vel_diff_abs = std::abs(vel_diff);\n    if (vel_diff_abs < acclimits(i) * dt) {\n      vel_new(i) = sample_target_vel(i);\n    } else {\n      if (vel_diff < 0) {\n        vel_new(i) = vel(i) - acclimits(i) * dt;\n      } else {\n        vel_new(i) = vel(i) + acclimits(i) * dt;\n      }\n    }\n  }\n  return vel_new;\n}\n", "CodeBleu_score": 54.46356079483836}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)  Eigen::Vector3f new_vel;\n  new_vel.setZero();\n\n  for (int i = 0; i < 3; i++) {\n    if (vel(i) < sample_target_vel(i)) {\n      new_vel(i) = vel(i) + acclimits(i) * dt;\n      if (new_vel(i) > sample_target_vel(i)) {\n        new_vel(i) = sample_target_vel(i);\n      }\n    } else if (vel(i) > sample_target_vel(i)) {\n      new_vel(i) = vel(i) - acclimits(i) * dt;\n      if (new_vel(i) < sample_target_vel(i)) {\n        new_vel(i) = sample_target_vel(i);\n      }\n    } else {\n      new_vel(i) = sample_target_vel(i);\n    }\n  }\n\n  return new_vel;\n}\n", "CodeBleu_score": 52.3264229231996}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\t// If the goal point is in the same cell as the robot, return the absolute difference between the current heading and the direction to the goal point.\n\tif (cell_x == (int)x && cell_y == (int)y) {\n\t\treturn fabs(angleDiff(heading, atan2(y - (double)cell_y, x - (double)cell_x)));\n\t}\n\n\t// Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell.\n\tfor (int i = (int)global_plan.size() - 1; i >= 0; i--) {\n\t\t// If the current point is in the same cell as the goal point, return the absolute difference between the current heading and the direction to the goal point.\n\t\tif (global_plan[i].x == (int)x && global_plan[i].y == (int)y) {\n\t\t\treturn fabs(angleDiff(heading, atan2(y - (double)cell_y, x - (double)cell_x)));\n\t\t}\n\n\t\t// If the current point is in the same cell as the robot's current cell, return the absolute difference between the current heading and the direction to the goal point.\n\t\tif (global_plan[i].x == (int)cell_x && global_plan[i].y == (int)cell_y) {\n\t\t\treturn fabs(angleDiff(heading, atan2(y - (double)cell_y, x - (double)cell_x)));\n\t\t}\n\n\t\t// If the current point is in the same cell as the goal point, return the absolute difference between the current heading and the direction to the goal point.\n\t\tif (global_plan[i].x == (int)x && global_plan[i].y == (int)y) {\n\t\t\treturn fabs(angleDiff(heading, atan2(y - (double)cell_y, x - (double)cell_x)));\n\t\t}\n\n\t\t// If the current point is in the same cell as the robot's current cell, return the absolute difference between the current heading and", "CodeBleu_score": 38.22343116534319}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)  double heading_diff = DBL_MAX;\n\n  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell.\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    // If the cell is in the global plan and is clear of obstacles, calculate the heading difference.\n    if (cellInGlobalPlan(cell_x, cell_y, i) && !cellInObstacle(cell_x, cell_y)) {\n      double goal_x = global_plan_[i].x;\n      double goal_y = global_plan_[i].y;\n      double goal_heading = atan2(goal_y - y, goal_x - x);\n      double diff = fabs(angles::shortest_angular_distance(heading, goal_heading));\n      if (diff < heading_diff) {\n        heading_diff = diff;\n      }\n    }\n  }\n  return heading_diff;\n}\n", "CodeBleu_score": 56.54632638050157}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)  double goal_x, goal_y, goal_heading, diff;\n  int i;\n  bool found = false;\n\n  for (i = (int)global_plan_.size() - 1; i >= 0; i--) {\n    if (global_plan_[i].x == cell_x && global_plan_[i].y == cell_y) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    ROS_WARN(\"TrajectoryPlanner::headingDiff: Couldn't find current cell in global plan!\");\n    return DBL_MAX;\n  }\n\n  goal_x = global_plan_[i].x;\n  goal_y = global_plan_[i].y;\n  goal_heading = atan2(goal_y - y, goal_x - x);\n  diff = angles::shortest_angular_distance(heading, goal_heading);\n\n  return fabs(diff);\n}\n", "CodeBleu_score": 48.684413681932135}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n        ROS_WARN(\"Trajectory rejected: vx_samp=%f, vy_samp=%f, vtheta_samp=%f, cost=%f\",\n            vx_samp, vy_samp, vtheta_samp, cost);\n        return false;\n    }\n    return true;\n}\n", "CodeBleu_score": 77.17884391375193}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  // Compute the cost of the trajectory\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  // If the cost is negative, log a warning and return false\n  if (cost < 0) {\n    ROS_WARN(\"Trajectory rejected: cost=%f, vx=%f, vy=%f, vtheta=%f\", cost, vx, vy, vtheta);\n    return false;\n  }\n\n  // Otherwise, return true\n  return true;\n}\n", "CodeBleu_score": 70.42187097506407}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n    if (cost < 0) {\n        ROS_WARN(\"Invalid trajectory with sample velocities (%f, %f, %f) and cost %f\",\n            vx_samp, vy_samp, vtheta_samp, cost);\n        return false;\n    }\n    return true;\n}\n", "CodeBleu_score": 78.63657315066604}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, please call initialize() before using this behavior\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global costmap is NULL\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"The local costmap is NULL\");\n    return;\n  }\n\n  bool clear_global = (affected_maps_ & GLOBAL_COSTMAP) > 0;\n  bool clear_local = (affected_maps_ & LOCAL_COSTMAP) > 0;\n\n  if (clear_global && clear_local) {\n    ROS_WARN(\"Clearing both the global and local costmaps\");\n  } else if (clear_global) {\n    ROS_WARN(\"Clearing the global costmap\");\n  } else if (clear_local) {\n    ROS_WARN(\"Clearing the local costmap\");\n  } else {\n    ROS_ERROR(\"No costmaps were specified to be cleared\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing the area outside of the specified clearing area\");\n  } else {\n    ROS_WARN(\"Clearing the area inside of the specified clearing area\");\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n\n  if (clear_global) {\n    global_costmap_->setCostmapToDefaultValue(invert_area_to_clear_);\n    if (force_costmap_update_) {\n      global_costmap_->updateMap();\n    }\n  }\n\n  if (clear_local) {\n    local_costmap_->setCostmapToDefaultValue(invert_area_to_clear_);\n    if (force_costmap_update_) {\n      local_costmap_->updateMap();\n    }\n  }\n\n  ros::WallTime end = ros::WallTime::now();\n\n  ROS_INFO(\"Clearing the costmaps", "CodeBleu_score": 47.160849809566116}, {"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, please call initialize() before using this plugin\");\n    return;\n  }\n\n  if (global_costmap_ == NULL) {\n    ROS_ERROR(\"The global costmap is NULL, please provide a valid global costmap before using this plugin\");\n    return;\n  }\n\n  if (local_costmap_ == NULL) {\n    ROS_ERROR(\"The local costmap is NULL, please provide a valid local costmap before using this plugin\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the specified area\");\n  } else {\n    ROS_WARN(\"Clearing outside the specified area\");\n  }\n\n  ros::WallTime start_time = ros::WallTime::now();\n\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    global_costmap_->setCostmapToDefaultValue(invert_area_to_clear_);\n    if (force_clearing_) {\n      global_costmap_->updateMap();\n    }\n  }\n\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    local_costmap_->setCostmapToDefaultValue(invert_area_to_clear_);\n    if (force_clearing_) {\n      local_costmap_->updateMap();\n    }\n  }\n\n  ros::WallTime end_time = ros::WallTime::now();\n\n  ROS_INFO(\"Clearing the costmaps took %.2f seconds\", (end_time - start_time).toSec());\n}\n", "CodeBleu_score": 46.77291786179445}, {"code": "void ClearCostmapRecovery::runBehavior()  if (!initialized_) {\n    ROS_ERROR(\"The behavior has not been initialized, please call initialize() before using this behavior\");\n    return;\n  }\n\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmap pointer(s) are NULL, please call initialize() before using this behavior\");\n    return;\n  }\n\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside the specified area\");\n  } else {\n    ROS_WARN(\"Clearing outside the specified area\");\n  }\n\n  ros::WallTime start = ros::WallTime::now();\n  if (affected_maps_ & GLOBAL_COSTMAP) {\n    global_costmap_->setCostmapToUnknown();\n    if (force_updates_) {\n      global_costmap_->updateMap();\n    }\n  }\n  ros::WallTime global_end = ros::WallTime::now();\n  if (affected_maps_ & LOCAL_COSTMAP) {\n    local_costmap_->setCostmapToUnknown();\n    if (force_updates_) {\n      local_costmap_->updateMap();\n    }\n  }\n  ros::WallTime local_end = ros::WallTime::now();\n\n  ROS_INFO(\"Clearing the costmaps took %f seconds (global: %f, local: %f)\",\n           (local_end - start).toSec(), (global_end - start).toSec(), (local_end - global_end).toSec());\n}\n", "CodeBleu_score": 48.88659939945243}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tpolygon_cells.clear();\n\tif (polygon.empty())\n\t\treturn;\n\n\tMapLocation p1, p2;\n\tp1 = polygon[0];\n\tfor (unsigned int i = 1; i < polygon.size(); ++i) {\n\t\tp2 = polygon[i];\n\t\traytraceLine(p1, p2, polygon_cells);\n\t\tp1 = p2;\n\t}\n\n\tif (polygon.size() > 2) {\n\t\tp2 = polygon[0];\n\t\traytraceLine(p1, p2, polygon_cells);\n\t}\n}\n", "CodeBleu_score": 46.37844337787426}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)    polygon_cells.clear();\n    if (polygon.size() < 2) {\n        return;\n    }\n    for (unsigned int i = 0; i < polygon.size() - 1; i++) {\n        std::vector<MapLocation> cells;\n        raytraceLine(polygon[i], polygon[i + 1], cells);\n        polygon_cells.insert(polygon_cells.end(), cells.begin(), cells.end());\n    }\n    std::vector<MapLocation> cells;\n    raytraceLine(polygon[polygon.size() - 1], polygon[0], cells);\n    polygon_cells.insert(polygon_cells.end(), cells.begin(), cells.end());\n}\n", "CodeBleu_score": 54.29464179144341}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tpolygon_cells.clear();\n\tif (polygon.empty()) {\n\t\treturn;\n\t}\n\tPolygonOutlineCells outline_cells(polygon);\n\tfor (unsigned int i = 0; i < polygon.size(); i++) {\n\t\tMapLocation& p1 = polygon[i];\n\t\tMapLocation& p2 = polygon[(i + 1) % polygon.size()];\n\t\traytraceLine(p1, p2, outline_cells);\n\t}\n\toutline_cells.closePolygon();\n\tpolygon_cells = outline_cells.getCells();\n}\n", "CodeBleu_score": 45.71953943454178}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  // get the connection state of the subscriber\n  const ros::ConnectionState& state = pub.getSubscriber().getTopic()->getNumPublishers();\n\n  // if we have a new subscriber, we need to prepare the grid data\n  if (state == ros::ConnectionState::CONNECTED) {\n    prepareGrid();\n  }\n}\n", "CodeBleu_score": 47.707608246514866}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  if (pub.getSubscriberName() == \"map\") {\n    ROS_DEBUG(\"Map subscriber connected. Publishing map data.\");\n    publishMap();\n  } else {\n    ROS_DEBUG(\"Subscriber connected. Publishing grid data.\");\n    publishGrid();\n  }\n}\n", "CodeBleu_score": 46.386450838414504}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  // Check if we have a new subscriber and if we have a new map\n  if (pub.getSubscriber().getTopic() == topic_name_) {\n    if (map_ == NULL) {\n      ROS_WARN(\"New subscriber to %s but no map has been received yet.  Waiting for a map to be received.\", topic_name_.c_str());\n      return;\n    }\n\n    // We have a new subscriber and a map so we can publish the data\n    prepareGrid();\n    publishGrid(pub);\n  }\n}\n", "CodeBleu_score": 47.55388362272105}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()  boost::mutex::scoped_lock lock(costmap_mutex_);\n  // Retrieve the resolution\n  double resolution = costmap_->getResolution();\n  // Set the header, resolution, width, and height\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n  grid_.info.resolution = resolution;\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n  // Convert the map coordinates to world coordinates for the origin and set the origin's position and orientation\n  geometry_msgs::Pose origin;\n  costmap_->mapToWorld(0, 0, origin.position.x, origin.position.y);\n  tf::Quaternion q = tf::createQuaternionFromYaw(costmap_->getOriginYaw());\n  origin.orientation.x = q.x();\n  origin.orientation.y = q.y();\n  origin.orientation.z = q.z();\n  origin.orientation.w = q.w();\n  // Save the origin coordinates and resize the grid data vector\n  grid_.info.origin = origin;\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = character_to_value_[costmap_->getCost(i)];\n  }\n}\n", "CodeBleu_score": 56.47806550597616}, {"code": "void Costmap2DPublisher::prepareGrid()\t// lock the mutex\n\tboost::mutex::scoped_lock lock(costmap_mutex_);\n\t// retrieve the resolution\n\tdouble resolution = costmap_->getResolution();\n\t// set the grid's header\n\tgrid_.header.frame_id = costmap_->getGlobalFrameID();\n\t// set the grid's resolution\n\tgrid_.info.resolution = resolution;\n\t// set the grid's width\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\t// set the grid's height\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\t// convert the map coordinates to world coordinates for the origin\n\ttf::Point origin = costmap_->getOriginPointInWorldFrame();\n\t// set the origin's position\n\tgrid_.info.origin.position.x = origin.x();\n\tgrid_.info.origin.position.y = origin.y();\n\t// set the origin's orientation\n\tgrid_.info.origin.orientation.w = 1.0;\n\t// save the origin coordinates\n\torigin_x_ = origin.x();\n\torigin_y_ = origin.y();\n\t// resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\t// populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < costmap_->getSizeInCellsX(); i++) {\n\t\tfor (unsigned int j = 0; j < costmap_->getSizeInCellsY(); j++) {\n\t\t\tunsigned int index = i + j * grid_.info.width;\n\t\t\tgrid_.data[index] = translation_table_[costmap_->getCost(i, j)];\n\t\t}\n\t}\n}\n", "CodeBleu_score": 61.31169959668379}, {"code": "void Costmap2DPublisher::prepareGrid()  // Lock the costmap mutex\n  boost::mutex::scoped_lock lock(costmap_->getMutex());\n\n  // Retrieve the resolution\n  double res = costmap_->getResolution();\n\n  // Set the grid's header\n  grid_.header.stamp = ros::Time::now();\n  grid_.header.frame_id = costmap_->getGlobalFrameID();\n\n  // Set the grid's resolution\n  grid_.info.resolution = res;\n\n  // Set the grid's width and height\n  grid_.info.width = costmap_->getSizeInCellsX();\n  grid_.info.height = costmap_->getSizeInCellsY();\n\n  // Convert the map coordinates to world coordinates for the origin\n  double wx, wy;\n  costmap_->mapToWorld(0, 0, wx, wy);\n\n  // Set the origin's position and orientation\n  grid_.info.origin.position.x = wx;\n  grid_.info.origin.position.y = wy;\n  grid_.info.origin.position.z = 0.0;\n  grid_.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x_ = wx;\n  origin_y_ = wy;\n\n  // Resize the grid data vector\n  grid_.data.resize(grid_.info.width * grid_.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n    grid_.data[i] = translation_table_[costmap_->getCost(i % grid_.info.width, i / grid_.info.width)];\n  }\n}\n", "CodeBleu_score": 68.1155900194322}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  // check if the footprint or robot radius has changed\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // check if a valid footprint string has been provided\n  if (!new_config.footprint.empty()) {\n    // try to parse the string to a polygon\n    std::vector<geometry_msgs::Point> points;\n    std::stringstream ss(new_config.footprint);\n    double x, y;\n    while (ss >> x >> y) {\n      geometry_msgs::Point point;\n      point.x = x;\n      point.y = y;\n      points.push_back(point);\n    }\n\n    // check if the polygon is valid\n    if (points.size() < 3) {\n      ROS_ERROR(\"The footprint string must contain at least 3 points\");\n    } else {\n      // set the footprint\n      footprint_spec_ = footprint_tools::convexFromPoints(points);\n      return;\n    }\n  }\n\n  // if no valid footprint string has been provided, set the footprint based on the robot radius\n  ROS_INFO(\"Setting the footprint based on the robot radius\");\n  footprint_spec_.clear();\n  footprint_spec_.push_back(geometry_msgs::Point32(new_config.robot_radius, 0, 0));\n  footprint_spec_.push_back(geometry_msgs::Point32(new_config.robot_radius, new_config.robot_radius, 0));\n  footprint_spec_.push_back(geometry_msgs::Point32(0, new_config.robot_radius, 0));\n  footprint_spec_.push_back(geometry_msgs::Point32(0, 0, 0));\n}\n", "CodeBleu_score": 59.778063212754795}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  if (new_config.robot_radius == old_config.robot_radius &&\n      new_config.footprint == old_config.footprint)\n    return;\n\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> points;\n    if (!costmap_2d::toFootprint(new_config.robot_radius, new_config.footprint, points)) {\n      ROS_ERROR(\"Costmap2DROS::readFootprintFromConfig() Invalid footprint string: %s\",\n                new_config.footprint.c_str());\n      return;\n    }\n    setFootprint(points);\n  } else {\n    setFootprintRadius(new_config.robot_radius);\n  }\n}\n", "CodeBleu_score": 55.63730300926555}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  // check if the footprint or robot radius changed\n  if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n    return;\n  }\n\n  // if a valid footprint string is provided, use it\n  if (new_config.footprint != \"\") {\n    std::vector<geometry_msgs::Point> footprint_spec;\n    std::vector<double> inscribed_radius;\n    std::vector<double> circumscribed_radius;\n    if (!costmap_2d::polygonFromString(new_config.footprint, new_config.robot_radius, footprint_spec,\n                                       inscribed_radius, circumscribed_radius)) {\n      ROS_ERROR(\"Invalid footprint string provided.  Using default.\");\n    } else {\n      setFootprint(footprint_spec);\n      return;\n    }\n  }\n\n  // if no valid footprint string is provided, set the footprint based on the robot radius\n  std::vector<geometry_msgs::Point> default_footprint_spec(4);\n  double radius = new_config.robot_radius;\n  double left = -radius;\n  double right = radius;\n  double top = radius;\n  double bottom = -radius;\n  default_footprint_spec[0].x = left;\n  default_footprint_spec[0].y = bottom;\n  default_footprint_spec[1].x = right;\n  default_footprint_spec[1].y = bottom;\n  default_footprint_spec[2].x = right;\n  default_footprint_spec[2].y = top;\n  default_footprint_spec[3].x = left;\n  default_footprint_spec[3].y = top;\n  setFootprint(default_footprint_spec);\n}\n", "CodeBleu_score": 62.03907988210737}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  if (!tf_listener_.waitForTransform(global_frame_, robot_base_frame_, ros::Time(0), ros::Duration(0.1), ros::Duration(0.01), &tf_warn_)) {\n    ROS_WARN_THROTTLE(1.0, \"Could not transform robot pose into %s frame. Continuing to wait...\", global_frame_.c_str());\n    return;\n  }\n  geometry_msgs::PoseStamped new_pose;\n  new_pose.header.stamp = ros::Time::now();\n  new_pose.header.frame_id = global_frame_;\n  new_pose.pose.position.x = 0.0;\n  new_pose.pose.position.y = 0.0;\n  new_pose.pose.position.z = 0.0;\n  new_pose.pose.orientation.x = 0.0;\n  new_pose.pose.orientation.y = 0.0;\n  new_pose.pose.orientation.z = 0.0;\n  new_pose.pose.orientation.w = 1.0;\n  tf_listener_.transformPose(global_frame_, new_pose, new_pose);\n  geometry_msgs::PoseStamped old_pose = current_robot_pose_;\n  current_robot_pose_ = new_pose;\n  if (old_pose.header.stamp != ros::Time(0) &&\n      (fabs(old_pose.pose.position.x - new_pose.pose.position.x) > 0.001 ||\n       fabs(old_pose.pose.position.y - new_pose.pose.position.y) > 0.001 ||\n       fabs(old_pose.pose.orientation.z - new_pose.pose.orientation.z) > 0.001 ||\n       fabs(old_pose.pose.orientation.w - new_pose.pose.orientation.w) > 0.001)) {\n    ROS_DEBUG(\"Robot pose has changed, reconfiguring the costmap\");\n    reconfigure();\n  }\n}", "CodeBleu_score": 45.27479175184762}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  // get the robot's current pose\n  tf::Stamped<tf::Pose> new_pose;\n  try {\n    tf_->transformPose(fixed_frame_, ros::Time(0), new_pose);\n  } catch (tf::TransformException &ex) {\n    ROS_WARN_THROTTLE(1.0, \"Costmap2DROS: Failed to get the robot's pose for reconfiguration: %s\",\n                     ex.what());\n    return;\n  }\n\n  // store the robot's current pose\n  new_pose.stamp_ = ros::Time::now();\n  new_pose_ = new_pose;\n\n  // reconfigure the costmap\n  configureCostmap();\n}\n", "CodeBleu_score": 42.90253959864761}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  if (!tf_listener_->waitForTransform(global_frame_, robot_base_frame_, ros::Time(0), ros::Duration(0.1))) {\n    ROS_WARN(\"Could not transform robot pose into global frame. Not updating the costmap.\");\n    return;\n  }\n\n  tf::Stamped<tf::Pose> robot_pose;\n  tf::poseStampedMsgToTF(tf_buffer_->lookupTransform(global_frame_, robot_base_frame_, ros::Time(0), ros::Duration(0.1)), robot_pose);\n  tf::Stamped<tf::Pose> global_pose;\n  tf::poseStampedMsgToTF(tf_buffer_->lookupTransform(global_frame_, global_frame_, ros::Time(0), ros::Duration(0.1)), global_pose);\n\n  if (robot_pose.frame_id_ != global_pose.frame_id_) {\n    ROS_WARN(\"The robot pose and the global pose do not have the same frame. Not updating the costmap.\");\n    return;\n  }\n\n  if (!isPoseValid(robot_pose, global_pose)) {\n    ROS_WARN(\"The robot pose is invalid. Not updating the costmap.\");\n    return;\n  }\n\n  new_pose_ = robot_pose;\n  new_pose_.setData(robot_pose.getOrigin(), robot_pose.getRotation());\n  new_pose_.frame_id_ = global_frame_;\n\n  reconfigure_mutex_.lock();\n  reconfigure_ = true;\n  reconfigure_mutex_.unlock();\n}\n", "CodeBleu_score": 38.50365407927928}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()  if (!is_running_) {\n    if (stopped_) {\n      for (Costmap2D::LayerMap::iterator it = layers_.begin(); it != layers_.end(); ++it) {\n        it->second->activate();\n      }\n      stopped_ = false;\n    }\n    is_running_ = true;\n    stop_updates_ = false;\n    while (!ros::ok() || !initialized_ || !map_update_thread_.joinable()) {\n      ros::Duration(0.01).sleep();\n    }\n    map_update_thread_ = std::thread(&Costmap2DROS::mapUpdateThread, this);\n  }\n}\n", "CodeBleu_score": 52.27675622608753}, {"code": "void Costmap2DROS::start()    if (isStopped()) {\n        ROS_INFO_STREAM(\"Starting costmap\");\n        // re-subscribe to topics by activating each plugin and set the stopped flag to false\n        for (auto &plugin : plugins_) {\n            plugin->start();\n        }\n        setStopped(false);\n        stop_updates_ = false;\n    }\n\n    // wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n    while (!ros::ok() || !isInitialized() || !isActive()) {\n        ros::Duration(0.1).sleep();\n    }\n}\n", "CodeBleu_score": 29.611385088822427}, {"code": "void Costmap2DROS::start()  if (is_running_) {\n    return;\n  }\n  // Check if the costmap was stopped\n  if (stopped_) {\n    // Re-subscribe to topics by activating each plugin and set the stopped flag to false\n    for (auto &plugin : plugins_) {\n      plugin->start();\n    }\n    stopped_ = false;\n  }\n  // Set stop_updates_ to false\n  stop_updates_ = false;\n\n  // Wait in a loop until ROS is running, the costmap is initialized, and the map update thread is active\n  while (!ros::ok() || !initialized_ || !map_update_thread_.joinable()) {\n    // Sleep for 100 ms\n    ros::Duration(0.1).sleep();\n  }\n}\n", "CodeBleu_score": 40.81904088043197}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()    if (observation_keep_time_ == 0) {\n        // If the keep time is zero, we only keep the most recent observation.\n        if (observations_.size() > 0) {\n            // If there are observations, remove all but the last one.\n            observations_.erase(observations_.begin(), observations_.end() - 1);\n        }\n    } else {\n        // If the keep time is non-zero, we keep the most recent observation and all observations that are younger than the specified keep time.\n        // We iterate through the observations, removing all observations that are older than the keep time, stopping when we find a valid observation.\n        while (observations_.size() > 0 && observations_[0].timestamp + observation_keep_time_ < ros::Time::now()) {\n            observations_.erase(observations_.begin());\n        }\n    }\n}\n", "CodeBleu_score": 32.56825069168192}, {"code": "void ObservationBuffer::purgeStaleObservations()    if (observation_keep_time_ == 0) {\n        // If observation_keep_time_ is zero, keep only the most recent observation.\n        if (observations_.size() > 0) {\n            observations_.erase(observations_.begin(), observations_.end()-1);\n        }\n    } else {\n        // If observation_keep_time_ is non-zero, keep only the most recent observation that is not older than the specified keep time.\n        ros::Time now = ros::Time::now();\n        while (observations_.size() > 0) {\n            if ((now - observations_.front().time) < observation_keep_time_) {\n                // The first observation in the list is not older than the specified keep time.\n                break;\n            } else {\n                // The first observation in the list is older than the specified keep time.\n                // Remove it from the list.\n                observations_.erase(observations_.begin());\n            }\n        }\n    }\n}\n", "CodeBleu_score": 38.91372348009512}, {"code": "void ObservationBuffer::purgeStaleObservations()    if (observation_keep_time_ == ros::Duration(0)) {\n        while (!observation_list_.empty()) {\n            if (observation_list_.front().getStamp() == ros::Time(0)) {\n                observation_list_.pop_front();\n            } else {\n                break;\n            }\n        }\n    } else {\n        ros::Time current_time = ros::Time::now();\n        while (!observation_list_.empty()) {\n            if (current_time - observation_list_.front().getStamp() > observation_keep_time_) {\n                observation_list_.pop_front();\n            } else {\n                break;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 43.18795449205278}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)  if (start_index < 0 || start_index >= path.size()) {\n    ROS_ERROR(\"OrientationFilter::interpolate: start index out of bounds\");\n    return;\n  }\n  if (end_index < 0 || end_index >= path.size()) {\n    ROS_ERROR(\"OrientationFilter::interpolate: end index out of bounds\");\n    return;\n  }\n  if (start_index >= end_index) {\n    ROS_ERROR(\"OrientationFilter::interpolate: start index must be less than end index\");\n    return;\n  }\n\n  // get yaw angles at start and end indices\n  double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n  // determine the shortest angular distance between the yaw angles\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // determine the incremental change in angle for each pose\n  double delta_yaw_increment = delta_yaw / (end_index - start_index);\n\n  // update the orientation of each pose in the specified range\n  for (int i = start_index; i <= end_index; i++) {\n    double new_yaw = start_yaw + (i - start_index) * delta_yaw_increment;\n    tf::Quaternion q;\n    q.setRPY(0, 0, new_yaw);\n    path[i].pose.orientation = tf::createQuaternionMsgFromYaw(new_yaw);\n  }\n}\n", "CodeBleu_score": 54.64266527800552}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)    if (start_index < 0 || start_index >= path.size() || end_index < 0 || end_index >= path.size()) {\n        ROS_WARN(\"OrientationFilter::interpolate: Index out of range\");\n        return;\n    }\n\n    // Calculate the yaw angles at the start and end indices\n    double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n    // Calculate the shortest angular distance between them\n    double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n    // Calculate the incremental change in angle for each pose\n    double delta_angle = delta_yaw / (end_index - start_index);\n\n    // Update the orientation of each pose in the specified range\n    for (int i = start_index; i < end_index; i++) {\n        double yaw = start_yaw + i * delta_angle;\n        tf::Quaternion q;\n        q.setRPY(0, 0, yaw);\n        path[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n    }\n}\n", "CodeBleu_score": 61.91063736596838}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)  if (start_index < 0 || start_index >= path.size()) {\n    ROS_ERROR(\"OrientationFilter::interpolate: start index out of bounds\");\n    return;\n  }\n  if (end_index < 0 || end_index >= path.size()) {\n    ROS_ERROR(\"OrientationFilter::interpolate: end index out of bounds\");\n    return;\n  }\n  if (start_index >= end_index) {\n    ROS_ERROR(\"OrientationFilter::interpolate: start index must be less than end index\");\n    return;\n  }\n\n  // get the start and end yaw angles\n  double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n  // calculate the shortest angular distance between them\n  double delta_yaw = angles::shortest_angular_distance(start_yaw, end_yaw);\n\n  // compute the incremental change in angle for each pose\n  double delta_yaw_inc = delta_yaw / (end_index - start_index);\n\n  // update the orientation of each pose in the specified range\n  for (int i = start_index; i < end_index; i++) {\n    double yaw = start_yaw + (i - start_index) * delta_yaw_inc;\n    tf::Quaternion q;\n    q.setRotation(tf::Vector3(0, 0, 1), yaw);\n    path[i].pose.orientation = tf::createQuaternionMsgFromQuaternion(q);\n  }\n}\n", "CodeBleu_score": 54.40682225231939}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)  // set the frame id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n  // call makePlan to generate a path\n  bool success = makePlan(req.start, req.goal, resp.plan);\n  // update the response with the success status and the generated path if a plan is found\n  resp.success = success;\n  if(success) {\n    resp.plan.header.frame_id = \"map\";\n  }\n  // return true to indicate that the service was processed\n  return true;\n}\n", "CodeBleu_score": 68.73379606172163}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)  // Set the start and goal frames to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan\n  bool success = makePlan(req.start, req.goal, resp.plan);\n\n  // Set the success status\n  resp.success = success;\n\n  // Return true to indicate that the service was processed\n  return true;\n}\n", "CodeBleu_score": 64.26636214292542}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)  if (req.start.header.frame_id.empty()) {\n    req.start.header.frame_id = \"map\";\n  }\n  if (req.goal.header.frame_id.empty()) {\n    req.goal.header.frame_id = \"map\";\n  }\n  bool success = makePlan(req.start, req.goal, resp.plan);\n  resp.success = success;\n  return true;\n}\n", "CodeBleu_score": 60.667871300732465}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    goal_pub = private_nh.advertise<geometry_msgs::PoseStamped>(\"goal\", 1, true);\n    make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n    costmap_ = cmap;\n}\n", "CodeBleu_score": 63.91265664582366}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    costmap_ros_ = cmap;\n    costmap_ = costmap_ros_->getCostmap();\n    initializePubSub(private_nh);\n}\n", "CodeBleu_score": 33.07614859328088}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    private_nh.param(\"planning_thread_frequency\", planning_thread_frequency_, 10.0);\n    private_nh.param(\"planning_patience\", planning_patience_, 0.01);\n    private_nh.param(\"max_planning_thread_freq\", max_planning_thread_freq_, 5.0);\n    private_nh.param(\"static_map_ros_topic\", static_map_ros_topic_, string(\"/static_map\"));\n    private_nh.param(\"global_plan_pub_topic\", global_plan_pub_topic_, string(\"global_plan\"));\n    private_nh.param(\"global_plan_topic\", global_plan_topic_, string(\"move_base_msgs/GlobalPlan\"));\n    private_nh.param(\"initial_plan_topic\", initial_plan_topic_, string(\"move_base_msgs/InitialPlan\"));\n    private_nh.param(\"goal_topic\", goal_topic_, string(\"move_base_msgs/MoveBaseGoal\"));\n    private_nh.param(\"goal_cost_param\", goal_cost_param_, 0.0);\n    private_nh.param(\"oscillation_reset_distance\", oscillation_reset_distance_, 0.5);\n    private_nh.param(\"oscillation_reset_duration\", oscillation_reset_duration_, 0.0);\n    private_nh.param(\"planning_mode\", planning_mode_, string(\"simple\"));\n    private_nh.param(\"planning_mode_cmd\", planning_mode_cmd_, string(\"simple\"));\n    private_nh.param(\"planning_mode_topic\", planning_mode_topic_, string(\"planning_mode\"));\n    private_nh.param(\"planning_mode_cmd_topic\", planning_mode_cmd_topic_, string(\"planning_mode_cmd\"));\n    private_nh.param(\"planner_frequency\", planner_frequency_, 10.0);\n    private_nh.param(\"planner_patience\", planner_patience_, 0.0", "CodeBleu_score": 39.30730658493725}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n\t\t\twx > costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n\t\t\twy > costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n\t\treturn false;\n\t}\n\tmx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n\tmy = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\treturn true;\n}\n", "CodeBleu_score": 41.09519863709473}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)  if (wx < origin_x_ || wx > origin_x_ + costmap_->getSizeInMetersX() ||\n      wy < origin_y_ || wy > origin_y_ + costmap_->getSizeInMetersY()) {\n    ROS_DEBUG(\"Coordinates (%.2f, %.2f) are out of bounds\", wx, wy);\n    return false;\n  }\n\n  mx = (wx - origin_x_) * costmap_->getResolution();\n  my = (wy - origin_y_) * costmap_->getResolution();\n\n  return true;\n}\n", "CodeBleu_score": 51.13322098868929}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY() ||\n      wx >= costmap_->getOriginX() + costmap_->getSizeInMetersX() ||\n      wy >= costmap_->getOriginY() + costmap_->getSizeInMetersY()) {\n    return false;\n  }\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n  return true;\n}\n", "CodeBleu_score": 42.557286256712224}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 89.73555267017348}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message to store the plan\n  nav_msgs::Path gui_path;\n\n  // set the frame ID and timestamp\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  // copy each pose in the path\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses.push_back(path[i]);\n  }\n\n  // publish the plan\n  plan_pub_.publish(gui_path);\n}\n\n\n", "CodeBleu_score": 76.45510006069975}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // create a message to store the plan\n  nav_msgs::Path gui_path;\n\n  // set the frame ID and timestamp\n  gui_path.header.frame_id = costmap_ros_->getGlobalFrameID();\n  gui_path.header.stamp = ros::Time::now();\n\n  // copy each pose in the path\n  for (unsigned int i = 0; i < path.size(); ++i) {\n    gui_path.poses.push_back(path[i]);\n  }\n\n  // publish\n  plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 76.41044953090703}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)    ROS_DEBUG(\"Wrapping goal in an action message\");\n    MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 67.87800501409875}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)  ROS_DEBUG(\"Got a goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 67.91707978636644}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)  ROS_DEBUG(\"Got a goal\");\n  move_base_msgs::MoveBaseActionGoal action_goal;\n  action_goal.header.stamp = ros::Time::now();\n  action_goal.goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 67.91707978636644}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  double squared_limited_distance = pow(limited_distance_, 2);\n  double squared_current_distance = pow(current_distance_, 2);\n  if (squared_limited_distance <= squared_current_distance) {\n    ROS_INFO(\"Distance check passed. Moving on.\");\n    // Stop the timer\n    distance_check_timer_.stop();\n    // Join and delete the remove limit thread\n    if (remove_limit_thread_->joinable()) {\n      remove_limit_thread_->join();\n      delete remove_limit_thread_;\n    }\n    // Create and start a new thread to remove the speed limit\n    remove_limit_thread_ = new boost::thread(boost::bind(&MoveSlowAndClear::removeSpeedLimit, this));\n    // Stop the distance check\n    move_slow_and_clear_server_.setPreempted();\n  }\n}\n", "CodeBleu_score": 61.054658458940025}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  // Check if the robot has moved far enough\n  double distance = sqrt(pow(x_current, 2) + pow(y_current, 2));\n  if (distance > sqrt(pow(distance_limit, 2))) {\n    // Log a message\n    ROS_INFO(\"Distance check passed. Moving on.\");\n    // Join and delete any existing remove limit thread\n    if (remove_limit_thread.joinable()) {\n      remove_limit_thread.join();\n    }\n    // Start a new thread to remove the speed limit\n    remove_limit_thread = std::thread(&MoveSlowAndClear::removeLimit, this);\n    // Stop the distance check timer\n    distance_check_timer.stop();\n  }\n}\n", "CodeBleu_score": 47.31437890440613}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  // If the robot has moved far enough, it logs a message, joins and deletes any existing remove limit thread, starts a new thread to remove the speed limit, and stops the distance check timer.\n  if (std::pow(limited_distance, 2) <= std::pow(current_distance, 2)) {\n    ROS_INFO(\"Distance Check: Distance reached\");\n    if (remove_limit_thread.joinable()) {\n      remove_limit_thread.join();\n      remove_limit_thread.~thread();\n    }\n    remove_limit_thread = std::thread(&MoveSlowAndClear::removeLimit, this);\n    distance_check_timer.stop();\n  }\n}\n", "CodeBleu_score": 52.4143719085305}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  // Retrieve the current global pose of the robot\n  // Note: This is the pose of the robot base frame in the global frame\n  // Note: The current global pose is stored in the member variable current_pose_\n  // Note: The current global pose is updated every time a new message is received\n  // Note: The current global pose is used to generate a path\n  current_pose_ = tf_->getRobotPose();\n\n  // Generate a path from the current pose to the goal pose\n  // Note: The generated path is stored in the member variable plan_\n  // Note: The generated path is used to send the path to the controller\n  // Note: The plan is cleared every time a new message is received\n  makePlan(current_pose_, goal->pose, plan_);\n\n  // Send the path to the controller\n  // Note: The path is sent to the controller using the publisher path_pub_\n  // Note: The path is sent to the controller as a nav_msgs/Path message\n  // Note: The path is sent to the controller every time a new message is received\n  path_pub_.publish(plan_);\n}\n", "CodeBleu_score": 43.69766549884759}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  // Get the current global pose of the robot\n  tf::Stamped<tf::Pose> robot_pose;\n  try {\n    tf_listener_.waitForTransform(global_frame_, base_frame_, ros::Time(0), ros::Duration(1.0));\n    tf_listener_.lookupTransform(global_frame_, base_frame_, ros::Time(0), robot_pose);\n  } catch (tf::TransformException ex) {\n    ROS_ERROR(\"%s\", ex.what());\n    return;\n  }\n\n  // Create a new plan\n  std::vector<geometry_msgs::PoseStamped> path;\n  if (makePlan(robot_pose, *goal, path)) {\n    // Publish the plan\n    plan_pub_.publish(path);\n  } else {\n    ROS_ERROR(\"Failed to make a plan\");\n  }\n}\n", "CodeBleu_score": 47.14629886173019}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)  // Retrieve the current global pose of the robot\n  tf::Stamped<tf::Pose> robot_pose;\n  if (!getRobotPose(robot_pose)) {\n    ROS_WARN(\"NavfnWithCostmap::poseCallback: Could not get robot pose\");\n    return;\n  }\n\n  // Generate a path from the current pose to the goal pose\n  std::vector<geometry_msgs::PoseStamped> path;\n  makePlan(robot_pose, *goal, path);\n\n  // Publish the path\n  path_pub_.publish(path);\n}\n", "CodeBleu_score": 52.23203178520941}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)    // Create a service request\n    mavros_msgs::ParamSetRequest set_request;\n    // Assign the parameter ID and value to the service request\n    set_request.param_id = param_set.param_id;\n    set_request.value.set<float>(param_set.param_value);\n    // Call the service\n    param_set_client_.call(set_request);\n}\n", "CodeBleu_score": 52.0971023322315}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)  // Create a service request\n  ros::ServiceClient param_set_client_ = nh_.serviceClient<mavros_msgs::ParamSet>(\"mavros/param/set\");\n  mavros_msgs::ParamSet param_set_srv;\n  // Assign the parameter ID and value from the provided GimbalParamSet structure to the service request\n  param_set_srv.request.param_id = param_set.param_id;\n  param_set_srv.request.value.int_value = param_set.value;\n  // Call the param_set_client_ to send the request\n  param_set_client_.call(param_set_srv);\n}\n", "CodeBleu_score": 48.09060406411092}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)    // Create the service request\n    std_srvs::SetBool::Request req;\n    std_srvs::SetBool::Response res;\n\n    // Assign the parameter ID and value to the service request\n    req.data = param_set.value;\n\n    // Call the param_set_client_ to send the request\n    param_set_client_.call(req, res);\n}\n", "CodeBleu_score": 39.08748785973659}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()  int new_fd;\n  int n;\n  char buf[MAXDATASIZE];\n  struct sockaddr_in their_addr;\n  socklen_t sin_size;\n  int rc;\n\n  // wait for a connection\n  sin_size = sizeof(their_addr);\n  new_fd = accept(sockfd, (struct sockaddr *)&their_addr, &sin_size);\n  if (new_fd == -1) {\n    perror(\"accept\");\n    exit(1);\n  }\n\n  // loop to handle multiple connections\n  while (1) {\n    // receive data\n    n = recv(new_fd, buf, MAXDATASIZE, 0);\n\n    // if data received successfully, decode and publish\n    if (n > 0) {\n      rc = decode(buf, n);\n      if (rc == 0) {\n        // publish message\n        publish();\n      } else {\n        // if the message is not a valid message, log an error\n        ROS_ERROR(\"CommunicationBridge::serverFun: received invalid message\");\n      }\n    } else if (n == 0) {\n      // if the message length is zero, log an error\n      ROS_ERROR(\"CommunicationBridge::serverFun: received zero length message\");\n    } else {\n      // if an error occurred, log an error\n      ROS_ERROR(\"CommunicationBridge::serverFun: error receiving message\");\n    }\n\n    // close the socket if an error occurred\n    if (n < 0) {\n      close(new_fd);\n      break;\n    }\n  }\n}\n", "CodeBleu_score": 48.4636377653279}, {"code": "void CommunicationBridge::serverFun()\n    int new_fd;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    while(true) {\n\n        // Wait for incoming connections\n        new_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);\n        if (new_fd == -1) {\n            ROS_ERROR(\"Error accepting new connection\");\n            continue;\n        }\n\n        // Read data from the socket\n        char recv_buf[BUF_SIZE];\n        int num_bytes = recv(new_fd, recv_buf, BUF_SIZE, 0);\n\n        // If data is received successfully, process it\n        if (num_bytes > 0) {\n            // Parse the message\n            std_msgs::String msg;\n            msg.data = std::string(recv_buf, num_bytes);\n\n            // Publish the message\n            if (msg.data.length() > 0) {\n                ROS_INFO(\"Received message: %s\", msg.data.c_str());\n                publisher.publish(msg);\n            }\n        }\n\n        // If no data is received, log an error and close the socket\n        else if (num_bytes == 0) {\n            ROS_ERROR(\"Received no data\");\n            close(new_fd);\n        }\n\n        // If an error occurs, log it and close the socket\n        else {\n            ROS_ERROR(\"Error receiving data\");\n            close(new_fd);\n        }\n    }\n}\n", "CodeBleu_score": 54.66834193193709}, {"code": "void CommunicationBridge::serverFun()\tint new_fd;\n\tstruct sockaddr_in their_addr;\n\tsocklen_t sin_size;\n\tchar buf[BUFLEN];\n\tint numbytes;\n\tint i;\n\tchar ip_addr[16];\n\n\t// Create a new socket\n\tif ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n\t\tperror(\"socket\");\n\t\texit(1);\n\t}\n\n\t// Set up the socket address structure\n\tmemset(&serv_addr, 0, sizeof(serv_addr));\n\tserv_addr.sin_family = AF_INET;\n\tserv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tserv_addr.sin_port = htons(port);\n\n\t// Bind the socket to the address\n\tif (bind(server_fd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {\n\t\tperror(\"bind\");\n\t\texit(1);\n\t}\n\n\t// Listen for connections\n\tif (listen(server_fd, 10) < 0) {\n\t\tperror(\"listen\");\n\t\texit(1);\n\t}\n\n\t// Loop to accept connections and handle them\n\twhile (1) {\n\t\tsin_size = sizeof(struct sockaddr_in);\n\t\tif ((new_fd = accept(server_fd, (struct sockaddr *) &their_addr, &sin_size)) == -1) {\n\t\t\tperror(\"accept\");\n\t\t\texit(1);\n\t\t}\n\n\t\t// Get the IP address of the client\n\t\tinet_ntop(their_addr.sin_family, &their_addr.sin_addr, ip_addr, sizeof(ip_addr));\n\t\tROS_INFO(\"Received connection from %s\", ip_addr);\n\n\t\t// Loop to receive data\n\t\twhile (1) {\n\t\t\tif ((numbytes = recv(new_fd, buf, BUFLEN, 0)) <= 0) {\n", "CodeBleu_score": 41.2288078776834}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\n  // If not in simulation mode, publish the command to the single UAV\n  if (!simulation_mode_) {\n    uav_cmd.header.stamp = ros::Time::now();\n    uav_basic_.publish(uav_cmd);\n  }\n\n  // If in simulation mode, publish the command to the correct UAV\n  else {\n    // Find the corresponding UAV by ID from swarm_control_simulation_\n    for (int i = 0; i < swarm_control_simulation_.swarm_control.uav_commands.size(); i++) {\n      if (swarm_control_simulation_.swarm_control.uav_commands[i].id == uav_cmd.id) {\n        swarm_control_simulation_.swarm_control.uav_commands[i] = uav_cmd;\n      }\n    }\n    swarm_control_simulation_.header.stamp = ros::Time::now();\n    swarm_control_simulation_.header.frame_id = \"swarm_control_simulation\";\n    swarm_control_simulation_.header.seq++;\n    swarm_control_simulation_.swarm_control.header.stamp = ros::Time::now();\n    swarm_control_simulation_.swarm_control.header.frame_id = \"swarm_control_simulation\";\n    swarm_control_simulation_.swarm_control.header.seq++;\n    swarm_control_simulation_.swarm_control.uav_commands[0].header.stamp = ros::Time::now();\n    swarm_control_simulation_.swarm_control.uav_commands[0].header.frame_id = \"swarm_control_simulation\";\n    swarm_control_simulation_.swarm_control.uav_commands[0].header.seq++;\n    swarm_control_simulation_.swarm_control.uav_commands[0].id = uav_cmd.id;\n    swarm_control_simulation_.swarm_control.uav_commands[0].mode = uav_cmd.mode;\n    swarm_control_simulation_.swarm_control", "CodeBleu_score": 35.38822779247536}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)  // Check if in simulation mode\n  if (simulation_mode_) {\n    // Find the corresponding UAV\n    for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n      if (swarm_control_simulation_[i]->getId() == uav_cmd.id) {\n        // Publish the command to the UAV\n        swarm_control_simulation_[i]->publishCommand(uav_cmd);\n      }\n    }\n  } else {\n    // Publish the command to the UAV\n    uav_basic_.publishCommand(uav_cmd);\n  }\n}\n", "CodeBleu_score": 40.315592520338036}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)  if (!simulation_mode_) {\n    uav_basic_.publish(uav_cmd);\n  } else {\n    for (int i = 0; i < swarm_control_simulation_.size(); i++) {\n      if (swarm_control_simulation_[i].id == uav_cmd.id) {\n        swarm_control_simulation_[i].uav_command_pub.publish(uav_cmd);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 38.25437797107437}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)  if (mode_selection.use_mode == MODE_REBOOT) {\n    system(\"reboot\");\n  } else if (mode_selection.use_mode == MODE_EXIT) {\n    system(\"exit\");\n  } else if (mode_selection.use_mode == MODE_CREATE) {\n    createMode(mode_selection.mode_name);\n  } else if (mode_selection.use_mode == MODE_DELETE) {\n    deleteMode(mode_selection.mode_name);\n  }\n}\n", "CodeBleu_score": 51.13039195413294}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.use_mode == 0) {\n        if (mode_selection.mode == 1) {\n            system(\"reboot\");\n        }\n        else if (mode_selection.mode == 2) {\n            system(\"poweroff\");\n        }\n        else if (mode_selection.mode == 3) {\n            system(\"exit\");\n        }\n    }\n    else if (mode_selection.use_mode == 1) {\n        if (mode_selection.mode == 1) {\n            createMode(0);\n        }\n        else if (mode_selection.mode == 2) {\n            createMode(1);\n        }\n        else if (mode_selection.mode == 3) {\n            createMode(2);\n        }\n    }\n    else if (mode_selection.use_mode == 2) {\n        if (mode_selection.mode == 1) {\n            deleteMode(0);\n        }\n        else if (mode_selection.mode == 2) {\n            deleteMode(1);\n        }\n        else if (mode_selection.mode == 3) {\n            deleteMode(2);\n        }\n    }\n}\n", "CodeBleu_score": 50.37740622317276}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.use_mode == 0) {\n        // Delete mode\n        deleteMode(mode_selection.mode_id);\n    }\n    else if (mode_selection.use_mode == 1) {\n        // Create mode\n        createMode(mode_selection.mode_id, mode_selection.mode_name);\n    }\n    else if (mode_selection.use_mode == 2) {\n        // Reboot\n        system(\"reboot\");\n    }\n    else if (mode_selection.use_mode == 3) {\n        // Exit\n        system(\"exit\");\n    }\n}\n", "CodeBleu_score": 52.94809066066834}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    if (heartbeat_count == 0) {\n        ROS_ERROR(\"Lost connection to heartbeat node. Check connection and restart the node.\");\n        if (vehicle_type == \"swarm\") {\n            ROS_ERROR(\"Swarm mode is currently not supported. Please restart the node.\");\n            disconnect_flag = true;\n        }\n        else if (vehicle_type == \"uav\") {\n            ROS_ERROR(\"UAV mode is currently not supported. Please restart the node.\");\n            disconnect_flag = true;\n        }\n        else if (vehicle_type == \"ugv\") {\n            ROS_ERROR(\"UGV mode is currently not supported. Please restart the node.\");\n            disconnect_flag = true;\n        }\n        else {\n            ROS_ERROR(\"Unknown vehicle type. Please restart the node.\");\n            disconnect_flag = true;\n        }\n    }\n    else if (heartbeat_count > 0) {\n        heartbeat_count--;\n    }\n}\n", "CodeBleu_score": 38.99863526492119}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\n    // If the heartbeat counter has not changed, increment the counter\n    if (heartbeat_counter == heartbeat_counter_prev) {\n        heartbeat_counter++;\n    }\n    // If the heartbeat counter has changed, reset the counter\n    else {\n        heartbeat_counter = 0;\n    }\n\n    // If the heartbeat counter exceeds the threshold, print an error message and take appropriate actions\n    if (heartbeat_counter >= heartbeat_counter_threshold) {\n        ROS_ERROR(\"Heartbeat counter exceeded threshold, disconnecting...\");\n\n        // If the vehicle is a swarm, trigger a disconnect event\n        if (vehicle_type == \"swarm\") {\n            disconnect_flag = true;\n        }\n        // If the vehicle is a UAV, trigger a disconnect event\n        else if (vehicle_type == \"UAV\") {\n            disconnect_flag = true;\n        }\n        // If the vehicle is a UGV, trigger a disconnect event\n        else if (vehicle_type == \"UGV\") {\n            disconnect_flag = true;\n        }\n    }\n\n    // Update the heartbeat counter\n    heartbeat_counter_prev = heartbeat_counter;\n}\n", "CodeBleu_score": 40.13635790028168}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    if (heartbeat_status == 0) {\n        heartbeat_count++;\n        if (heartbeat_count >= heartbeat_attempts) {\n            if (vehicle_type == \"swarm\") {\n                ROS_ERROR(\"Swarm heartbeat not received. Shutting down.\");\n                ROS_ERROR(\"Please restart the swarm.\");\n                ros::shutdown();\n            } else if (vehicle_type == \"uav\") {\n                ROS_ERROR(\"UAV heartbeat not received. Shutting down.\");\n                ROS_ERROR(\"Please restart the UAV.\");\n                ros::shutdown();\n            } else if (vehicle_type == \"ugv\") {\n                ROS_ERROR(\"UGV heartbeat not received. Shutting down.\");\n                ROS_ERROR(\"Please restart the UGV.\");\n                ros::shutdown();\n            }\n        }\n    } else {\n        heartbeat_count = 0;\n    }\n}\n", "CodeBleu_score": 38.18800338511465}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    // Get the drone ID\n    int id = msg->id;\n\n    // Create a MultiBsplines message\n    prometheus_msgs::MultiBsplines multi_bsplines_msg;\n\n    // Set the drone ID\n    multi_bsplines_msg.id = id;\n\n    // Create a Bspline message\n    prometheus_msgs::Bspline bspline_msg;\n\n    // Set the number of segments\n    bspline_msg.seg_num = msg->seg_num;\n\n    // Set the number of knots\n    bspline_msg.knot_num = msg->knot_num;\n\n    // Set the number of control points\n    bspline_msg.ctrl_num = msg->ctrl_num;\n\n    // Set the number of points\n    bspline_msg.pt_num = msg->pt_num;\n\n    // Set the number of yaw points\n    bspline_msg.yaw_num = msg->yaw_num;\n\n    // Set the duration\n    bspline_msg.duration = msg->duration;\n\n    // Set the start time\n    bspline_msg.start_time = msg->start_time;\n\n    // Set the start position\n    bspline_msg.start_pos.x = msg->start_pos.x;\n    bspline_msg.start_pos.y = msg->start_pos.y;\n    bspline_msg.start_pos.z = msg->start_pos.z;\n\n    // Set the start yaw\n    bspline_msg.start_yaw = msg->start_yaw;\n\n    // Set the start velocity\n    bspline_msg.start_vel.x = msg->start_vel.x;\n    bspline_msg.start_vel.y = msg->start_vel.y;\n    bspline_msg.start_vel.z = msg->start_vel.z;\n\n    // Set the start acceleration\n    bspline_msg.start_acc.x = msg->start_acc.x;\n    bspline_msg.start_acc.y = msg->", "CodeBleu_score": 27.400761735400014}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)  std::stringstream ss;\n  prometheus_msgs::MultiBsplines multi_bsplines_out;\n  multi_bsplines_out.header = msg->header;\n  multi_bsplines_out.id = msg->id;\n  multi_bsplines_out.time_from_start = msg->time_from_start;\n  multi_bsplines_out.duration = msg->duration;\n  multi_bsplines_out.dimension = msg->dimension;\n  multi_bsplines_out.n_segments = msg->n_segments;\n  multi_bsplines_out.n_points = msg->n_points;\n  multi_bsplines_out.n_polynomials = msg->n_polynomials;\n  multi_bsplines_out.n_segments_x = msg->n_segments_x;\n  multi_bsplines_out.n_segments_y = msg->n_segments_y;\n  multi_bsplines_out.n_segments_z = msg->n_segments_z;\n  multi_bsplines_out.n_segments_yaw = msg->n_segments_yaw;\n  multi_bsplines_out.n_polynomials_x = msg->n_polynomials_x;\n  multi_bsplines_out.n_polynomials_y = msg->n_polynomials_y;\n  multi_bsplines_out.n_polynomials_z = msg->n_polynomials_z;\n  multi_bsplines_out.n_polynomials_yaw = msg->n_polynomials_yaw;\n  multi_bsplines_out.n_polynomials_total = msg->n_polynomials_total;\n  multi_bsplines_out.n_polynomials_total_x = msg->n_polynomials_total_x;\n  multi_bsplines_out.n_polynomials_total_y = msg->n_polynomials_total_y;\n  multi_bsplines_out.n_polynomials_", "CodeBleu_score": 21.096501694639574}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    // std::cout << \"EGOPlannerSwarm::multitrajSubTcpCb\" << std::endl;\n    prometheus_msgs::MultiBsplines msg_out;\n    msg_out.header = msg->header;\n    msg_out.type = msg->type;\n    msg_out.swarm_id = msg->swarm_id;\n    msg_out.num_traj = msg->num_traj;\n    msg_out.traj_id = msg->traj_id;\n    msg_out.start_time = msg->start_time;\n    msg_out.end_time = msg->end_time;\n    msg_out.traj_size = msg->traj_size;\n    msg_out.traj_type = msg->traj_type;\n    msg_out.traj_name = msg->traj_name;\n    msg_out.traj_id = msg->traj_id;\n    msg_out.traj_points = msg->traj_points;\n    msg_out.traj_points_size = msg->traj_points_size;\n    msg_out.traj_points_time = msg->traj_points_time;\n    msg_out.traj_points_pos = msg->traj_points_pos;\n    msg_out.traj_points_vel = msg->traj_points_vel;\n    msg_out.traj_points_acc = msg->traj_points_acc;\n    msg_out.traj_points_jerk = msg->traj_points_jerk;\n    msg_out.traj_points_yaw = msg->traj_points_yaw;\n    msg_out.traj_points_dyaw = msg->traj_points_dyaw;\n    msg_out.traj_points_d2yaw = msg->traj_points_d2yaw;\n    msg_out.traj_points_ddyaw = msg->traj_points_ddyaw;\n    msg_out.traj_points_dd2yaw = msg->traj_points_dd2yaw;\n    msg", "CodeBleu_score": 23.89486331288654}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = msg.height;\n  compressed_msg.width = msg.width;\n  compressed_msg.fields = msg.fields;\n  compressed_msg.is_bigendian = msg.is_bigendian;\n  compressed_msg.point_step = msg.point_step;\n  compressed_msg.row_step = msg.row_step;\n  compressed_msg.is_dense = msg.is_dense;\n  compressed_msg.data.resize(msg.data.size());\n  compressed_msg.data = msg.data;\n  return compressed_msg;\n}\n", "CodeBleu_score": 17.718781773936453}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)  // Create a new PointCloud2 message\n  sensor_msgs::PointCloud2 compressed_msg;\n  // Create a pcl::PointCloud object\n  pcl::PointCloud<pcl::PointXYZ> cloud;\n  // Convert the input message to a pcl::PointCloud object\n  pcl::fromROSMsg(msg, cloud);\n  // Create an octree object\n  pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree(resolution_);\n  // Set the octree resolution\n  octree.setResolution(resolution_);\n  // Build the octree\n  octree.setInputCloud(cloud.makeShared());\n  // Compress the point cloud\n  octree.addPointsFromInputCloud();\n  // Convert the compressed point cloud to a PointCloud2 message\n  pcl::toROSMsg(octree.getInputCloud(), compressed_msg);\n  // Set the header information\n  compressed_msg.header = msg.header;\n  // Return the compressed message\n  return compressed_msg;\n}\n", "CodeBleu_score": 27.568578879622418}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)  sensor_msgs::PointCloud2 compressed_msg;\n  compressed_msg.header = msg.header;\n  compressed_msg.height = msg.height;\n  compressed_msg.width = msg.width;\n  compressed_msg.is_bigendian = msg.is_bigendian;\n  compressed_msg.is_dense = msg.is_dense;\n  compressed_msg.point_step = msg.point_step;\n  compressed_msg.row_step = msg.row_step;\n  compressed_msg.fields = msg.fields;\n  compressed_msg.data = msg.data;\n  compressed_msg.is_dense = msg.is_dense;\n\n  // Convert the PointCloud2 message to a pcl::PointCloud\n  pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n  pcl::fromROSMsg(msg, *cloud);\n\n  // Compress the point cloud\n  pcl::PointCloud<pcl::PointXYZRGB>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);\n  octree.setInputCloud(cloud);\n  octree.addPointsFromInputCloud();\n  octree.getVoxelCentroids(*compressed_cloud);\n\n  // Convert the compressed point cloud to a PointCloud2 message\n  pcl::toROSMsg(*compressed_cloud, compressed_msg);\n\n  // Release dynamically allocated memory\n  cloud.reset();\n  compressed_cloud.reset();\n\n  return compressed_msg;\n}\n", "CodeBleu_score": 39.85366693330783}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\n    for (auto it = multi_uav_state_.begin(); it != multi_uav_state_.end(); ++it) {\n        if (it->id == uav_state.id) {\n            it->id = uav_state.id;\n            it->x = uav_state.x;\n            it->y = uav_state.y;\n            it->z = uav_state.z;\n            it->vx = uav_state.vx;\n            it->vy = uav_state.vy;\n            it->vz = uav_state.vz;\n            it->yaw = uav_state.yaw;\n            it->yaw_rate = uav_state.yaw_rate;\n            it->timestamp = uav_state.timestamp;\n            it->state = uav_state.state;\n        }\n    }\n}\n", "CodeBleu_score": 41.600883582878204}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].UAV_ID == uav_state.UAV_ID) {\n            multi_uav_state_[i] = uav_state;\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 61.01334993384696}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)    for (int i = 0; i < multi_uav_state_.size(); i++) {\n        if (multi_uav_state_[i].id == uav_state.id) {\n            multi_uav_state_[i] = uav_state;\n            break;\n        }\n    }\n}\n", "CodeBleu_score": 60.95257322243705}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    // Create a MultiUGVState message\n    m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n    m_multi_ugv_state_msg.header.frame_id = \"world\";\n    m_multi_ugv_state_msg.UGV_count = 0;\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.UGV_count; i++) {\n        // Create a UGVState message\n        m_ugv_state_msg.ID = m_multi_ugv_state.ugv_state[i].ID;\n        m_ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n        m_ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        m_ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        m_ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        m_ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        m_ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        m_ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        m_ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        m_ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n        m_ugv_state_msg.attitude.z = m_multi_ugv_", "CodeBleu_score": 44.38905366048979}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)  // Create a MultiUGVState message\n  m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n  m_multi_ugv_state_msg.header.frame_id = \"map\";\n  m_multi_ugv_state_msg.ugv_count = 0;\n\n  // Iterate through each UGV in the MultiUGVState structure\n  for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n    // Create a UGVState message\n    m_ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n    m_ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n    m_ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n    m_ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n    m_ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n    m_ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n    m_ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n    m_ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n    m_ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n    m_ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n    m_ugv_state_msg.attitude.z = m_multi_ugv_state.", "CodeBleu_score": 43.70263654821339}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\n    // Initialize MultiUGVState message\n    m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n    m_multi_ugv_state_msg.header.frame_id = \"swarm_control\";\n\n    // Iterate through each UGV state\n    for (int i = 0; i < m_multi_ugv_state.num_ugv; i++) {\n\n        // Initialize UGVState message\n        m_ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n        m_ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n        m_ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position[0];\n        m_ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position[1];\n        m_ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position[2];\n        m_ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity[0];\n        m_ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity[1];\n        m_ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity[2];\n        m_ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude[0];\n        m_ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude[1];\n        m_ugv_state_msg.attitude.z = m_multi_ugv_state.ugv_state[i].attitude[2];\n        m_ugv_state_msg.att", "CodeBleu_score": 42.53189737829645}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    double c = 0;\n    double c_prime = 0;\n    double c_double_prime = 0;\n    double c_triple_prime = 0;\n    double c_quadruple_prime = 0;\n    double c_quintuple_prime = 0;\n    double c_sextuple_prime = 0;\n    double c_septuple_prime = 0;\n    double c_octuple_prime = 0;\n    double c_nonuple_prime = 0;\n    double c_decuple_prime = 0;\n    double c_undecuple_prime = 0;\n    double c_duodecuple_prime = 0;\n    double c_tredecuple_prime = 0;\n    double c_quattuordecuple_prime = 0;\n    double c_quindecuple_prime = 0;\n    double c_sedecuple_prime = 0;\n    double c_septendecuple_prime = 0;\n    double c_octodecuple_prime = 0;\n    double c_novendecuple_prime = 0;\n    double c_vigintuple_prime = 0;\n    double c_unvigintuple_prime = 0;\n    double c_duovigintuple_prime = 0;\n    double c_trevigintuple_prime = 0;\n    double c_quattuorvigintuple_prime = 0;\n    double c_quinvigintuple_prime = 0;\n    double c_sesvigintuple_prime = 0;\n    double c_septenvigintuple_prime = 0;\n    double c_octovigintuple_prime = 0;\n    double c_novemvigintuple_prime = 0;\n    double c_trigintuple_prime = 0;\n    double c_untrigintuple_prime = 0;\n    double c_duotrigintuple_prime = 0;\n    double c_tr", "CodeBleu_score": 9.367546683351335}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  //\n  // 1. Get the start and end time of the B-spline\n  //\n  double T = (double)q.cols();\n  double t_start, t_end;\n  t_start = 0.0;\n  t_end = T;\n\n  //\n  // 2. Get the moving objects\n  //\n  std::vector<MovingObjectPtr> moving_objects;\n  moving_objects = getMovingObjects();\n\n  //\n  // 3. Compute the predicted positions of moving objects\n  //\n  std::vector<Eigen::Vector3d> moving_obj_predicted_positions;\n  std::vector<Eigen::Vector3d> moving_obj_predicted_velocities;\n  std::vector<Eigen::Vector3d> moving_obj_predicted_accelerations;\n  std::vector<double> moving_obj_predicted_yaws;\n  std::vector<double> moving_obj_predicted_yaw_rates;\n  std::vector<double> moving_obj_predicted_yaw_accelerations;\n  std::vector<double> moving_obj_predicted_times;\n  std::vector<double> moving_obj_predicted_times_wrt_start;\n  std::vector<double> moving_obj_predicted_times_wrt_end;\n  double t_start_wrt_end = t_end - t_start;\n  double t_wrt_end;\n  for (int i = 0; i < (int)moving_objects.size(); i++) {\n    // 3.1. Get the predicted positions of moving objects\n    moving_objects[i]->getPredictedPoses(t_start, t_end, moving_obj_predicted_positions, moving_obj_predicted_velocities,\n                                         moving_obj_predicted_accelerations, moving_obj_predicted_yaws,\n                                         moving_obj_predicted_yaw_rates, moving_obj_predicted_yaw_accelerations,\n                                         moving_obj_predicted_times);\n    // ", "CodeBleu_score": 33.39625162838498}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    // check the number of moving objects\n    if (moving_objects_.size() == 0) {\n        return;\n    }\n\n    // set the number of control points\n    int n = q.cols();\n\n    // set the number of moving objects\n    int m = moving_objects_.size();\n\n    // set the number of dimensions\n    int d = q.rows();\n\n    // set the size of the cost and gradient\n    cost = 0;\n    gradient.resize(d, n);\n    gradient.setZero();\n\n    // set the size of the predicted position of moving objects\n    Eigen::MatrixXd predicted_position(d, n);\n\n    // set the size of the distance between control points and moving objects\n    Eigen::MatrixXd distance(m, n);\n\n    // set the size of the distance error\n    Eigen::MatrixXd distance_error(m, n);\n\n    // set the size of the distance error gradient\n    Eigen::MatrixXd distance_error_gradient(d, n);\n\n    // set the size of the distance error gradient w.r.t. control points\n    Eigen::MatrixXd distance_error_gradient_wrt_control_points(d, n);\n\n    // set the size of the distance error gradient w.r.t. moving objects\n    Eigen::MatrixXd distance_error_gradient_wrt_moving_objects(d, m);\n\n    // set the size of the distance error gradient w.r.t. moving objects\n    Eigen::MatrixXd distance_error_gradient_wrt_moving_objects_wrt_moving_objects(d, m);\n\n    // set the size of the distance error gradient w.r.t. control points\n    Eigen::MatrixXd distance_error_gradient_wrt_control_points_wrt_moving_objects(d, m);\n\n    // set the size of the distance error gradient w.r.t. control points\n    Eigen::MatrixXd distance_error_gradient_wrt_control_points_wrt_control_points(d, n);\n\n    // set the size of the distance error gradient w.r.t. control points", "CodeBleu_score": 23.416682112711307}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    cost = 0.0;\n    gradient.setZero();\n\n    Eigen::VectorXd q_ref(3);\n    Eigen::VectorXd q_curr(3);\n    Eigen::VectorXd q_diff(3);\n    Eigen::VectorXd q_dot_ref(3);\n    Eigen::VectorXd q_dot_curr(3);\n    Eigen::VectorXd q_dot_diff(3);\n    Eigen::VectorXd q_ddot_ref(3);\n    Eigen::VectorXd q_ddot_curr(3);\n    Eigen::VectorXd q_ddot_diff(3);\n    Eigen::VectorXd q_ddot_diff_norm(3);\n\n    double a2 = 1.0;\n    double b2 = 1.0;\n\n    for (int i = 0; i < q.rows(); i++) {\n        q_ref << ref_points_[i].x, ref_points_[i].y, ref_points_[i].z;\n        q_curr << q(i, 0), q(i, 1), q(i, 2);\n        q_diff = q_ref - q_curr;\n        q_dot_ref << ref_points_[i].dx, ref_points_[i].dy, ref_points_[i].dz;\n        q_dot_curr << q(i, 3), q(i, 4), q(i, 5);\n        q_dot_diff = q_dot_ref - q_dot_curr;\n        q_ddot_ref << ref_points_[i].ddx, ref_points_[i].ddy, ref_points_[i].ddz;\n        q_ddot_curr << q(i, 6), q(i, 7), q(i, 8);\n        q_ddot_diff = q_ddot_ref - q_ddot_curr;\n        q_ddot_diff_norm = q_ddot_diff.normalized();\n\n        cost += a2 * q_diff.dot(q_diff) + b2 *", "CodeBleu_score": 35.19948239035061}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    double a2 = 0.01;\n    double b2 = 0.001;\n    double a1 = 0.01;\n    double b1 = 0.001;\n    double a0 = 0.01;\n    double b0 = 0.001;\n    double c = 0.01;\n\n    // Initialize cost to zero\n    cost = 0;\n\n    // Initialize gradient to zero\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    // Initialize the positional error and velocity vectors\n    Eigen::VectorXd error(3);\n    Eigen::VectorXd velocity(3);\n\n    // Initialize the derivative matrices\n    Eigen::MatrixXd dq(q.rows(), q.cols());\n    Eigen::MatrixXd dq2(q.rows(), q.cols());\n    Eigen::MatrixXd dq3(q.rows(), q.cols());\n    Eigen::MatrixXd dq4(q.rows(), q.cols());\n\n    // Iterate through the control points\n    for (int i = 0; i < q.rows(); i++) {\n        // Compute the positional error\n        error = q.row(i) - refPoints.row(i);\n\n        // Compute the velocity vector\n        velocity = (q.row(i + 1) - q.row(i - 1)) / 2;\n\n        // Compute the cost\n        cost += (a2 * error.dot(error) + b2 * velocity.dot(velocity));\n\n        // Compute the gradient\n        dq = 2 * a2 * error;\n        dq2 = 2 * b2 * velocity;\n        gradient.row(i) = dq.row(i) + dq2.row(i);\n\n        // Compute the positional error\n        error = q.row(i + 1) - refPoints.row(i + 1);\n\n        // Compute the velocity vector\n        velocity = (q.row(i + 2) - q.row(i)) / 2;\n\n        // Compute", "CodeBleu_score": 36.23466315230952}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  // initialize cost to zero\n  cost = 0.0;\n  gradient.setZero(q.rows(), q.cols());\n\n  // get the number of control points\n  int n = q.rows() / 4;\n\n  // iterate through all control points\n  for (int i = 0; i < n; i++) {\n    // get the current control point\n    Eigen::VectorXd p(4);\n    p << q(i * 4 + 0, 0), q(i * 4 + 1, 0), q(i * 4 + 2, 0), q(i * 4 + 3, 0);\n\n    // compute the positional error relative to reference points\n    Eigen::VectorXd error(4);\n    error << p(0) - ref_points_(i * 4 + 0, 0), p(1) - ref_points_(i * 4 + 1, 0), p(2) - ref_points_(i * 4 + 2, 0),\n        p(3) - ref_points_(i * 4 + 3, 0);\n\n    // compute the velocity vector\n    Eigen::VectorXd v(3);\n    v << p(3) - p(0), p(3) - p(1), p(3) - p(2);\n\n    // compute the cost and gradient\n    double c = a2 * error.dot(error) + b2 * v.dot(v);\n    cost += c;\n    gradient(i * 4 + 0, 0) += 2.0 * a2 * error(0) + 2.0 * b2 * v(0);\n    gradient(i * 4 + 1, 0) += 2.0 * a2 * error(1) + 2.0 * b2 * v(1);\n    gradient(i * 4 + 2, 0) += 2.0 * a2 * error(2) + 2.0 * b2 * v(2);\n    gradient(i * 4 + 3, 0) += 2.0 * a2 * error(3) + 2.0", "CodeBleu_score": 38.23343293991919}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()    double jerk = 0.0;\n\n    // Calculate the third derivative of the spline\n    this->calcThirdDerivative();\n\n    // Retrieve the knot times and control points of the jerk trajectory\n    vector<double> knot_times = this->getKnotTimes();\n    vector<double> control_points = this->getControlPoints();\n\n    // Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n    for (int i = 0; i < this->dimension; i++) {\n        for (int j = 0; j < this->num_control_points; j++) {\n            jerk += pow(control_points[i * this->num_control_points + j], 2) * (knot_times[j + 1] - knot_times[j]);\n        }\n    }\n\n    // Return the total jerk value\n    return jerk;\n}\n", "CodeBleu_score": 40.090628664649174}, {"code": "double UniformBspline::getJerk()    // TODO: Implement this function\n    double jerk = 0;\n    double temp = 0;\n    double temp2 = 0;\n    double temp3 = 0;\n    double temp4 = 0;\n    double temp5 = 0;\n    double temp6 = 0;\n    double temp7 = 0;\n    double temp8 = 0;\n    double temp9 = 0;\n    double temp10 = 0;\n    double temp11 = 0;\n    double temp12 = 0;\n    double temp13 = 0;\n    double temp14 = 0;\n    double temp15 = 0;\n    double temp16 = 0;\n    double temp17 = 0;\n    double temp18 = 0;\n    double temp19 = 0;\n    double temp20 = 0;\n    double temp21 = 0;\n    double temp22 = 0;\n    double temp23 = 0;\n    double temp24 = 0;\n    double temp25 = 0;\n    double temp26 = 0;\n    double temp27 = 0;\n    double temp28 = 0;\n    double temp29 = 0;\n    double temp30 = 0;\n    double temp31 = 0;\n    double temp32 = 0;\n    double temp33 = 0;\n    double temp34 = 0;\n    double temp35 = 0;\n    double temp36 = 0;\n    double temp37 = 0;\n    double temp38 = 0;\n    double temp39 = 0;\n    double temp40 = 0;\n    double temp41 = 0;\n    double temp42 = 0;\n    double temp43 = 0;\n    double temp44 = 0;\n    double temp45 = 0;\n    double temp46 = 0;\n    double temp47 = 0;\n    double temp48 = 0;\n    double temp49 = 0;\n    double temp50 = 0;\n    double temp5", "CodeBleu_score": 9.135473790914487}, {"code": "double UniformBspline::getJerk()\t// First, calculate the third derivative of the spline\n\tvector<vector<double> > jerk_traj = getThirdDerivative();\n\n\t// Next, retrieve the knot times and control points of the jerk trajectory\n\tvector<double> jerk_knots = jerk_traj[0];\n\tvector<vector<double> > jerk_control_points = jerk_traj[1];\n\n\t// Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tdouble jerk = 0;\n\tfor (int i = 0; i < jerk_control_points.size(); i++) {\n\t\tfor (int j = 0; j < jerk_control_points[i].size(); j++) {\n\t\t\tjerk += pow(jerk_control_points[i][j], 2) * (jerk_knots[i + 1] - jerk_knots[i]);\n\t\t}\n\t}\n\n\treturn jerk;\n}\n", "CodeBleu_score": 43.7088357710661}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)     Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n    return pos;\n}\n", "CodeBleu_score": 62.86309382919195}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)     Eigen::Vector4d pos;\n    pos[0] = (u - cx_) * depth / fx_;\n    pos[1] = (v - cy_) * depth / fy_;\n    pos[2] = depth;\n    pos[3] = 1;\n    return pos;\n}\n", "CodeBleu_score": 62.86309382919195}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)   Eigen::Vector4d point;\n  point(0) = (u - cx_) * depth / fx_;\n  point(1) = (v - cy_) * depth / fy_;\n  point(2) = depth;\n  point(3) = 1;\n  return point;\n}\n", "CodeBleu_score": 74.54704402418002}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\n\t// Extract drone ID from child_frame_id\n\tstd::string droneID = odom.child_frame_id;\n\tstd::string::size_type sz;\n\tint droneID_int = std::stoi(droneID, &sz);\n\n\t// Call rcvDroneOdomCallbackBase\n\ttry {\n\t\trcvDroneOdomCallbackBase(odom, droneID_int);\n\t}\n\tcatch (std::exception& e) {\n\t\tROS_ERROR_STREAM(\"DroneDetector::rcvDroneXOdomCallback - Failed to extract drone ID from child_frame_id: \" << odom.child_frame_id);\n\t}\n}\n", "CodeBleu_score": 47.970841742498685}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)  // Extract the drone ID from the child_frame_id field of the odometry message\n  try {\n    // Extract the drone ID from the child_frame_id field of the odometry message\n    std::string drone_id = extractDroneId(odom.child_frame_id);\n\n    // Call rcvDroneOdomCallbackBase with the odometry data and drone ID\n    rcvDroneOdomCallbackBase(odom, drone_id);\n  } catch (std::runtime_error& e) {\n    // Catch and print the exception\n    ROS_ERROR_STREAM(\"Failed to extract drone ID from child_frame_id: \" << odom.child_frame_id << std::endl << e.what());\n  }\n}\n", "CodeBleu_score": 45.12265636896805}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)  // Extract drone ID from child_frame_id\n  int drone_id;\n  try {\n    drone_id = extractDroneID(odom.child_frame_id);\n  } catch (const std::exception& e) {\n    ROS_ERROR_STREAM(e.what());\n    return;\n  }\n  // Call rcvDroneOdomCallbackBase\n  rcvDroneOdomCallbackBase(odom, drone_id);\n}\n", "CodeBleu_score": 49.876188689309174}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // Check if the drone is in the list of drones\n    auto drone_it = drones_.find(drone_id);\n    if (drone_it == drones_.end()) {\n        ROS_ERROR(\"Drone %d not found in the list of drones.\", drone_id);\n        return;\n    }\n\n    // Get the drone\n    DronePtr drone = drone_it->second;\n\n    // Get the drone's true pose\n    Eigen::Vector3d true_pose = drone->getTruePose();\n\n    // Check if the drone is in the image\n    Eigen::Vector2d pixel = camera_model_.project3dToPixel(true_pose);\n    if (pixel[0] < 0 || pixel[0] > camera_model_.imageWidth() || pixel[1] < 0 || pixel[1] > camera_model_.imageHeight()) {\n        ROS_ERROR(\"Drone %d is not in the image.\", drone_id);\n        return;\n    }\n\n    // Get the drone's true pixel position\n    Eigen::Vector2d true_pixel_position = drone->getTruePixelPosition();\n\n    // Calculate the pose error\n    Eigen::Vector2d error = pixel - true_pixel_position;\n    double error_norm = error.norm();\n    double error_norm_deg = error_norm * 180 / M_PI;\n\n    // Update the debug result\n    drone_id_ = drone_id;\n    drone_pose_ = true_pose;\n    drone_pixel_ = pixel;\n    drone_pixel_error_ = error;\n    drone_pixel_error_norm_ = error_norm;\n    drone_pixel_error_norm_deg_ = error_norm_deg;\n\n    // Publish the pose error\n    drone_pose_error_pub_.publish(error_norm_deg);\n\n    // Publish the debug result\n    debug_pub_.publish(debug_result_);\n}\n", "CodeBleu_score": 34.147434314349034}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // get the drone's pose in the camera frame\n    Eigen::Vector3d true_pose = get_true_pose(drone_id, true_pixel);\n\n    // check if the drone is in the camera frame\n    if (true_pose.head<2>().norm() > 0.5) {\n        // get the drone's pose in the world frame\n        Eigen::Vector3d world_pose = get_world_pose(drone_id, true_pixel);\n\n        // compute the pose error between the camera and world coordinates\n        double pose_error = (world_pose - true_pose).norm();\n\n        // update the debug result\n        debug_result.pose_error = pose_error;\n        debug_result.success = true;\n\n        // publish the pose error\n        pose_error_pub.publish(pose_error);\n    } else {\n        // update the debug result\n        debug_result.pose_error = 0.0;\n        debug_result.success = false;\n    }\n\n    // publish the debug result\n    debug_result_pub.publish(debug_result);\n}\n", "CodeBleu_score": 31.319622181384588}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // Create a vector to store the detected drone's true pose in the camera frame\n    Eigen::Vector3f true_pose_camera;\n    // Create a vector to store the detected drone's true pose in the world frame\n    Eigen::Vector3f true_pose_world;\n    // Create a vector to store the detected drone's estimated pose in the camera frame\n    Eigen::Vector3f estimated_pose_camera;\n    // Create a vector to store the detected drone's estimated pose in the world frame\n    Eigen::Vector3f estimated_pose_world;\n    // Create a vector to store the detected drone's pose error in the camera frame\n    Eigen::Vector3f pose_error_camera;\n    // Create a vector to store the detected drone's pose error in the world frame\n    Eigen::Vector3f pose_error_world;\n\n    // Create a vector to store the detected drone's true pose in the camera frame\n    Eigen::Vector3f true_pose_camera_debug;\n    // Create a vector to store the detected drone's true pose in the world frame\n    Eigen::Vector3f true_pose_world_debug;\n    // Create a vector to store the detected drone's estimated pose in the camera frame\n    Eigen::Vector3f estimated_pose_camera_debug;\n    // Create a vector to store the detected drone's estimated pose in the world frame\n    Eigen::Vector3f estimated_pose_world_debug;\n    // Create a vector to store the detected drone's pose error in the camera frame\n    Eigen::Vector3f pose_error_camera_debug;\n    // Create a vector to store the detected drone's pose error in the world frame\n    Eigen::Vector3f pose_error_world_debug;\n\n    // Create a vector to store the detected drone's true pose in the camera frame\n    Eigen::Vector3f true_pose_camera_debug_result;\n    // Create a vector to store the detected drone's true pose in the world frame\n    Eigen::Vector3f true_pose_world_debug_result;\n    // Create a vector to store the detected drone's estimated", "CodeBleu_score": 12.617347410079057}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->getCameFrom() != nullptr) {\n        current = current->getCameFrom();\n        path.push_back(current);\n    }\n    return path;\n}\n", "CodeBleu_score": 75.83578254936543}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)  vector<GridNodePtr> path;\n  path.push_back(current);\n\n  while (current->getParent() != nullptr) {\n    current = current->getParent();\n    path.push_back(current);\n  }\n\n  return path;\n}\n", "CodeBleu_score": 72.63347752235924}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\n\twhile (current->getCameFrom() != nullptr) {\n\t\tcurrent = current->getCameFrom();\n\t\tpath.push_back(current);\n\t}\n\n\treturn path;\n}\n", "CodeBleu_score": 70.54706467705128}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)    // convert start and end points to grid indices\n    if (!ConvertToIndex(start_pt, start_idx)) {\n        return false;\n    }\n    if (!ConvertToIndex(end_pt, end_idx)) {\n        return false;\n    }\n\n    // if start point is inside an obstacle, adjust it\n    if (IsObstacle(start_idx)) {\n        Vector3d new_start_pt;\n        if (!AdjustPoint(start_pt, end_pt, new_start_pt)) {\n            return false;\n        }\n        if (!ConvertToIndex(new_start_pt, start_idx)) {\n            return false;\n        }\n    }\n\n    // if end point is inside an obstacle, adjust it\n    if (IsObstacle(end_idx)) {\n        Vector3d new_end_pt;\n        if (!AdjustPoint(end_pt, start_pt, new_end_pt)) {\n            return false;\n        }\n        if (!ConvertToIndex(new_end_pt, end_idx)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 47.09577617855954}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)    //Convert the start and end points to grid indices\n    if (!ConvertToIndex(start_pt, start_idx)) {\n        return false;\n    }\n    if (!ConvertToIndex(end_pt, end_idx)) {\n        return false;\n    }\n\n    //Adjust the start and end points if they are inside obstacles\n    if (IsInObstacle(start_idx)) {\n        if (!AdjustStartEndPoint(start_pt, end_pt, start_idx, end_idx)) {\n            return false;\n        }\n    }\n    if (IsInObstacle(end_idx)) {\n        if (!AdjustStartEndPoint(end_pt, start_pt, end_idx, start_idx)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 42.879583248202294}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert start and end points to grid indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Adjust the start point if it is inside an obstacle\n\tif (IsInObstacle(start_idx)) {\n\t\tVector3d adjusted_start_pt = start_pt;\n\t\tif (!AdjustStartEndPoint(start_pt, end_pt, adjusted_start_pt)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!ConvertToIndex(adjusted_start_pt, start_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Adjust the end point if it is inside an obstacle\n\tif (IsInObstacle(end_idx)) {\n\t\tVector3d adjusted_end_pt = end_pt;\n\t\tif (!AdjustStartEndPoint(end_pt, start_pt, adjusted_end_pt)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!ConvertToIndex(adjusted_end_pt, end_idx)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 44.45737565591038}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)    // Get the minimum and maximum indices of the grid cells that are inside the specified region\n    Eigen::Vector3i min_id, max_id;\n    getGridIndex(min_pos, min_id);\n    getGridIndex(max_pos, max_id);\n\n    // Iterate over the grid coordinates from min_id to max_id and set the corresponding elements in the occupancy_buffer_inflate_ to zero\n    for (int x = min_id(0); x <= max_id(0); ++x) {\n        for (int y = min_id(1); y <= max_id(1); ++y) {\n            for (int z = min_id(2); z <= max_id(2); ++z) {\n                // Get the grid cell index\n                Eigen::Vector3i id(x, y, z);\n\n                // Get the corresponding index in the occupancy_buffer_inflate_\n                int idx = getIndex(id);\n\n                // Set the corresponding element in the occupancy_buffer_inflate_ to zero\n                occupancy_buffer_inflate_[idx] = 0.0;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 63.73074753946246}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)    Eigen::Vector3i min_id, max_id;\n    getGridCoords(min_pos, min_id);\n    getGridCoords(max_pos, max_id);\n\n    for (int x = min_id.x(); x <= max_id.x(); x++) {\n        for (int y = min_id.y(); y <= max_id.y(); y++) {\n            for (int z = min_id.z(); z <= max_id.z(); z++) {\n                setOccupancy(x, y, z, 0);\n                setDistance(x, y, z, 0);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 43.362742405903376}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  // Get the corresponding grid coordinates for the specified region\n  Eigen::Vector3i min_id, max_id;\n  getGridCoords(min_pos, min_id);\n  getGridCoords(max_pos, max_id);\n\n  // Iterate over the grid coordinates and set the corresponding elements in the occupancy_buffer_inflate_ to zero\n  for (int x = min_id(0); x <= max_id(0); x++) {\n    for (int y = min_id(1); y <= max_id(1); y++) {\n      for (int z = min_id(2); z <= max_id(2); z++) {\n        occupancy_buffer_inflate_(x, y, z) = 0.0;\n        distance_buffer_inflate_(x, y, z) = 0.0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 63.95899127324833}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d adjusted_pt = pt;\n    Eigen::Vector3d diff = pt - camera_pt;\n    double max_x = diff.x() > 0 ? map_size_x_ : -map_size_x_;\n    double max_y = diff.y() > 0 ? map_size_y_ : -map_size_y_;\n    double max_z = diff.z() > 0 ? map_size_z_ : -map_size_z_;\n    double min_x = diff.x() > 0 ? -map_size_x_ : map_size_x_;\n    double min_y = diff.y() > 0 ? -map_size_y_ : map_size_y_;\n    double min_z = diff.z() > 0 ? -map_size_z_ : map_size_z_;\n    double max_scale_x = diff.x() > 0 ? (max_x - pt.x()) / diff.x() : (min_x - pt.x()) / diff.x();\n    double max_scale_y = diff.y() > 0 ? (max_y - pt.y()) / diff.y() : (min_y - pt.y()) / diff.y();\n    double max_scale_z = diff.z() > 0 ? (max_z - pt.z()) / diff.z() : (min_z - pt.z()) / diff.z();\n    double min_scale_x = diff.x() > 0 ? (min_x - pt.x()) / diff.x() : (max_x - pt.x()) / diff.x();\n    double min_scale_y = diff.y() > 0 ? (min_y - pt.y()) / diff.y() : (max_y - pt.y()) / diff.y();\n    double min_scale_z = diff.z() > 0 ? (min_z - pt.z()) / diff.z() : (max_z - pt.z()) / diff.z();\n    double max_scale = std::min(std::min(max_scale_x, max_scale_y), max_scale_z", "CodeBleu_score": 33.12755785530969}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    // Calculate the difference vector between the point and the camera position\n    Eigen::Vector3d diff = pt - camera_pt;\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    double max_x = diff[0] > 0 ? diff[0] : -diff[0];\n    double max_y = diff[1] > 0 ? diff[1] : -diff[1];\n    double max_z = diff[2] > 0 ? diff[2] : -diff[2];\n\n    // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    double min_x = 1;\n    if (diff[0] < 0) {\n        for (double i = 0; i < max_x; i += 0.1) {\n            if (pt[0] - i >= 0) {\n                min_x = i;\n                break;\n            }\n        }\n    }\n    else {\n        for (double i = 0; i < max_x; i += 0.1) {\n            if (pt[0] + i <= map_size_[0]) {\n                min_x = i;\n                break;\n            }\n        }\n    }\n\n    double min_y = 1;\n    if (diff[1] < 0) {\n        for (double i = 0; i < max_y; i += 0.1) {\n            if (pt[1] - i >= 0) {\n                min_y = i;\n                break;\n            }\n        }\n    }\n    else {\n        for (double i = 0; i < max_y; i += 0.1) {\n            if (pt[1] + i <= map_size_[1]) {\n                min_y = i;\n                break;\n            }\n        }\n    }\n\n    double min_z = 1;\n    if (diff[2] < 0) {\n        for (double i = 0; i < max_z; i += 0.1) {\n            if (pt[2] - i >= 0) {\n               ", "CodeBleu_score": 38.30843339881538}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d adjusted_pt = pt;\n    Eigen::Vector3d max_translation = Eigen::Vector3d::Zero();\n    Eigen::Vector3d min_translation = Eigen::Vector3d::Zero();\n\n    // Determine the maximum and minimum translation coefficients along each axis\n    for (int i = 0; i < 3; i++) {\n        if (diff(i) > 0) {\n            max_translation(i) = (this->max_pt(i) - camera_pt(i)) / diff(i);\n            min_translation(i) = (this->min_pt(i) - camera_pt(i)) / diff(i);\n        }\n        else {\n            max_translation(i) = (this->min_pt(i) - camera_pt(i)) / diff(i);\n            min_translation(i) = (this->max_pt(i) - camera_pt(i)) / diff(i);\n        }\n    }\n\n    // Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries\n    for (int i = 0; i < 3; i++) {\n        if (max_translation(i) < min_translation(i)) {\n            adjusted_pt(i) = camera_pt(i) + max_translation(i) * diff(i);\n        }\n        else {\n            adjusted_pt(i) = camera_pt(i) + min_translation(i) * diff(i);\n        }\n    }\n\n    return adjusted_pt;\n}\n", "CodeBleu_score": 42.98488659084859}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  // Update the last occupancy update time\n  last_occupancy_update_ = ros::Time::now();\n\n  // If an update is needed\n  if (update_needed_) {\n    // Project the depth image into points and process them with raycasting\n    if (depth_image_received_) {\n      // Project the depth image into points\n      projectDepthImage();\n\n      // Process the points with raycasting\n      processPointsWithRaycasting();\n    }\n\n    // If the local map has been updated\n    if (local_map_updated_) {\n      // Clear and inflate the local map\n      clearAndInflateLocalMap();\n\n      // Reset the local map updated flag\n      local_map_updated_ = false;\n    }\n\n    // Reset the update needed flag\n    update_needed_ = false;\n  }\n\n  // Handle timeout errors for odometry or depth data\n  if (odom_timeout_) {\n    // Set the odometry timeout error flag\n    odom_timeout_error_ = true;\n\n    // Reset the odometry timeout error flag\n    odom_timeout_ = false;\n  }\n\n  if (depth_timeout_) {\n    // Set the depth timeout error flag\n    depth_timeout_error_ = true;\n\n    // Reset the depth timeout error flag\n    depth_timeout_ = false;\n  }\n}\n", "CodeBleu_score": 33.20198034203319}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\n    // Update the last occupancy update time\n    last_occupancy_update_ = ros::Time::now();\n\n    // If an update is needed, project the depth image into points and process them with raycasting\n    if (update_occupancy_flag_) {\n\n        // Project the depth image into points\n        projectDepth();\n\n        // Process the points with raycasting\n        raycastPoints();\n\n        // If the local map has been updated, clear and inflate the local map\n        if (local_map_updated_) {\n            clearLocalMap();\n            inflateLocalMap();\n            local_map_updated_ = false;\n        }\n\n        // Handle timeout errors for odometry or depth data and set relevant flags\n        if (odometry_timeout_) {\n            odometry_timeout_ = false;\n            odometry_timeout_flag_ = true;\n        }\n        if (depth_timeout_) {\n            depth_timeout_ = false;\n            depth_timeout_flag_ = true;\n        }\n    }\n\n    // Update the update occupancy flag\n    update_occupancy_flag_ = false;\n}\n", "CodeBleu_score": 33.02766941286085}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\n  // Update the last occupancy update time\n  last_occupancy_update_ = ros::Time::now();\n\n  // If the occupancy map has not been initialized, do nothing\n  if (!occupancy_map_initialized_) {\n    return;\n  }\n\n  // If the local map has not been initialized, do nothing\n  if (!local_map_initialized_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been inflated, do nothing\n  if (!local_map_inflated_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local map has not been cleared, do nothing\n  if (!local_map_cleared_) {\n    return;\n  }\n\n  // If the local", "CodeBleu_score": 32.52781186570858}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)    // Initialize accumulator\n    float accum = 0;\n    \n    // Iterate through images\n    for (int i = 0; i < image_fns.size(); i++) {\n        // Load image\n        Mat image = imread(image_fns[i]);\n        \n        // Load ground truth\n        Mat gt = imread(gt_fns[i]);\n        \n        // Load detected ellipses\n        Mat dt = imread(dt_fns[i]);\n        \n        // Evaluate detection performance\n        float f_measure = ellipse_evaluate(image, gt, dt, gt_angle_radians);\n        \n        // Accumulate F-measure\n        accum += f_measure;\n    }\n    \n    // Return average F-measure\n    return accum / image_fns.size();\n}\n", "CodeBleu_score": 62.352213130390496}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\n\t// create an instance of the ellipse_evaluator class\n\tellipse_evaluator eval;\n\n\t// iterate through the image filenames\n\tfor(int i = 0; i < image_fns.size(); i++) {\n\n\t\t// load the ground truth and detected ellipses\n\t\tvector<ellipse> gt = ellipse_evaluator::load_ellipses(gt_fns[i], gt_angle_radians);\n\t\tvector<ellipse> dt = ellipse_evaluator::load_ellipses(dt_fns[i], false);\n\n\t\t// evaluate the detection performance\n\t\teval.evaluate(gt, dt);\n\t}\n\n\t// return the average F-measure\n\treturn eval.get_average_f_measure();\n}\n", "CodeBleu_score": 49.07427849405127}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)  // Calculate the average F-measure by iterating through the images\n  float f_measure = 0;\n  for (int i = 0; i < image_fns.size(); i++) {\n    // Load the image\n    Mat image = imread(image_fns[i]);\n    if (!image.data) {\n      cout << \"Error: Could not load image \" << image_fns[i] << endl;\n      return -1;\n    }\n    // Load the ground truth\n    Mat gt = imread(gt_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n    if (!gt.data) {\n      cout << \"Error: Could not load ground truth \" << gt_fns[i] << endl;\n      return -1;\n    }\n    // Load the detected ellipses\n    Mat dt = imread(dt_fns[i], CV_LOAD_IMAGE_GRAYSCALE);\n    if (!dt.data) {\n      cout << \"Error: Could not load detected ellipses \" << dt_fns[i] << endl;\n      return -1;\n    }\n    // Evaluate the detection performance\n    float f_measure_i = _ellipse_evaluate(image, gt, dt, gt_angle_radians);\n    // Accumulate the F-measure\n    f_measure += f_measure_i;\n  }\n  // Return the average F-measure\n  return f_measure / image_fns.size();\n}\n", "CodeBleu_score": 52.7523392772272}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float angle;\n    if (foci != NULL) {\n        float angle1 = atan2(y - foci[0], x - foci[1]);\n        float angle2 = atan2(y - foci[2], x - foci[3]);\n        angle = angle2 - angle1;\n    } else {\n        angle = atan2(y, x);\n    }\n    if (angle < 0) {\n        angle += 2 * M_PI;\n    }\n    return angle;\n}\n", "CodeBleu_score": 42.04094054340624}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tfloat a = foci[0];\n\tfloat b = foci[1];\n\tfloat c = foci[2];\n\tfloat d = foci[3];\n\tfloat e = foci[4];\n\tfloat f = foci[5];\n\tfloat g = foci[6];\n\tfloat h = foci[7];\n\n\tfloat r = sqrt(pow(x - a, 2) + pow(y - b, 2));\n\tfloat s = sqrt(pow(x - c, 2) + pow(y - d, 2));\n\tfloat t = sqrt(pow(x - e, 2) + pow(y - f, 2));\n\tfloat u = sqrt(pow(x - g, 2) + pow(y - h, 2));\n\n\tfloat theta1 = atan2(y - b, x - a);\n\tfloat theta2 = atan2(y - d, x - c);\n\tfloat theta3 = atan2(y - f, x - e);\n\tfloat theta4 = atan2(y - h, x - g);\n\n\tfloat theta = 0.5 * (theta1 + theta2 + theta3 + theta4);\n\n\tif (r > 0 && s > 0 && t > 0 && u > 0) {\n\t\tfloat theta1 = atan2(y - b, x - a);\n\t\tfloat theta2 = atan2(y - d, x - c);\n\t\tfloat theta3 = atan2(y - f, x - e);\n\t\tfloat theta4 = atan2(y - h, x - g);\n\n\t\tfloat theta = 0.5 * (theta1 + theta2 + theta3 + theta4);\n\t}\n\n\treturn theta;\n}\n", "CodeBleu_score": 36.433400586874974}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float angle;\n    if (foci == NULL) {\n        angle = atan2(y, x);\n    } else {\n        float a = foci[0];\n        float b = foci[1];\n        float a2 = a*a;\n        float b2 = b*b;\n        float x2 = x*x;\n        float y2 = y*y;\n        float xy = x*y;\n        float f = (a2 - b2) / (a2 + b2);\n        float g = 2.0 * (a2 - b2) / (a2 + b2);\n        float h = (a2 - b2) / (a2 + b2);\n        float j = (a2 - b2) / (a2 + b2);\n        float k = (a2 - b2) / (a2 + b2);\n        float l = (a2 - b2) / (a2 + b2);\n        float m = (a2 - b2) / (a2 + b2);\n        float n = (a2 - b2) / (a2 + b2);\n        float o = (a2 - b2) / (a2 + b2);\n        float p = (a2 - b2) / (a2 + b2);\n        float q = (a2 - b2) / (a2 + b2);\n        float r = (a2 - b2) / (a2 + b2);\n        float s = (a2 - b2) / (a2 + b2);\n        float t = (a2 - b2) / (a2 + b2);\n        float u = (a2 - b2) / (a2 + b2);\n        float v = (a2 - b2) / (a2 + b2);\n        float w = (a2 - b2) / (a2 + b2);\n        float x3 = x2*x;\n        float y3 = y2*y;\n        float x4 = x2*x2;\n        float y4 = y2*y2;\n        float x5 = x2*x3;\n        float y5 = y2", "CodeBleu_score": 36.41369536255573}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)    int i, j;\n    float xmin, xmax, ymin, ymax, x, y;\n    float sum1, sum2;\n\n    xmin = vp1[start].x;\n    ymin = vp1[start].y;\n    xmax = vp1[start].x;\n    ymax = vp1[start].y;\n\n    for (i = start + 1; i < end; i++) {\n        x = vp1[i].x;\n        y = vp1[i].y;\n        if (x < xmin) {\n            xmin = x;\n        }\n        if (x > xmax) {\n            xmax = x;\n        }\n        if (y < ymin) {\n            ymin = y;\n        }\n        if (y > ymax) {\n            ymax = y;\n        }\n    }\n\n    sum1 = 0.0;\n    sum2 = 0.0;\n    for (i = start; i < end; i++) {\n        j = i + 1;\n        if (j == end) {\n            j = start;\n        }\n        sum1 += (vp1[j].x - vp1[i].x) * (vp1[j].y + vp1[i].y);\n        sum2 += (vp1[j].x - vp1[i].x) * (vp1[j].y - vp1[i].y);\n    }\n\n    if (sum1 < sum2) {\n        return false;\n    } else {\n        return true;\n    }\n}\n", "CodeBleu_score": 42.51697558615997}, {"code": "bool inline concave_check(VP& vp1, int start, int end)  double min_x = vp1[start].x;\n  double max_x = vp1[start].x;\n  double min_y = vp1[start].y;\n  double max_y = vp1[start].y;\n  for (int i = start + 1; i <= end; i++) {\n    if (vp1[i].x < min_x) {\n      min_x = vp1[i].x;\n    }\n    if (vp1[i].x > max_x) {\n      max_x = vp1[i].x;\n    }\n    if (vp1[i].y < min_y) {\n      min_y = vp1[i].y;\n    }\n    if (vp1[i].y > max_y) {\n      max_y = vp1[i].y;\n    }\n  }\n  double integral_above = 0;\n  double integral_below = 0;\n  for (int i = start; i <= end; i++) {\n    double x = vp1[i].x;\n    double y = vp1[i].y;\n    if (x < min_x) {\n      integral_above += (min_x - x) * y;\n      integral_below += (min_x - x) * min_y;\n    } else if (x > max_x) {\n      integral_above += (max_x - x) * y;\n      integral_below += (max_x - x) * max_y;\n    } else {\n      integral_above += (max_x - min_x) * y;\n      integral_below += (max_x - min_x) * (max_y + min_y) / 2;\n    }\n  }\n  return integral_above < integral_below;\n}\n", "CodeBleu_score": 44.53111685686399}, {"code": "bool inline concave_check(VP& vp1, int start, int end)  double xmin = vp1[start].x;\n  double xmax = vp1[start].x;\n  double ymin = vp1[start].y;\n  double ymax = vp1[start].y;\n  for (int i = start + 1; i < end; i++) {\n    if (vp1[i].x < xmin) xmin = vp1[i].x;\n    if (vp1[i].x > xmax) xmax = vp1[i].x;\n    if (vp1[i].y < ymin) ymin = vp1[i].y;\n    if (vp1[i].y > ymax) ymax = vp1[i].y;\n  }\n  double xint = 0.0;\n  double yint = 0.0;\n  for (int i = start; i < end; i++) {\n    xint += vp1[i].x;\n    yint += vp1[i].y;\n  }\n  xint /= (end - start);\n  yint /= (end - start);\n  double int_above = 0.0;\n  double int_below = 0.0;\n  for (int i = start; i < end; i++) {\n    int_above += (vp1[i].x - xint) * (vp1[i].y - yint);\n    int_below += (vp1[i].x - xint) * (vp1[i].y - ymin);\n  }\n  if (int_above < int_below) return false;\n  return true;\n}\n", "CodeBleu_score": 40.86593121042998}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)  for (int i = 0; i < msg->info.size(); i++) {\n    if (msg->info[i].name == \"T\") {\n      ellipse_det.is_detected = true;\n      ellipse_det.num_regain++;\n      ellipse_det.num_lost = 0;\n      ellipse_det.sight_angle = ellipse_det.sight_angle_backup;\n      return;\n    }\n  }\n  ellipse_det.is_detected = false;\n  ellipse_det.num_regain = 0;\n  ellipse_det.num_lost++;\n  if (ellipse_det.num_lost > VISION_THRES) {\n    ellipse_det.sight_angle = 0;\n  }\n}\n", "CodeBleu_score": 34.90278310940052}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)  for (int i = 0; i < msg->det_info.size(); i++) {\n    if (msg->det_info[i].det_name == \"T\") {\n      num_regain++;\n      num_lost = 0;\n    } else {\n      num_lost++;\n      num_regain = 0;\n    }\n  }\n  if (num_lost > VISION_THRES) {\n    is_detected = false;\n  } else if (num_regain > VISION_THRES) {\n    is_detected = true;\n  }\n  if (is_detected) {\n    ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n  } else {\n    ellipse_det.sight_angle[1] = ellipse_det.sight_angle[0];\n  }\n}\n", "CodeBleu_score": 65.8602126237936}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tfor (int i = 0; i < msg->det_num; i++) {\n\t\tif (msg->det_info[i].det_name == \"T\") {\n\t\t\tellipse_det.num_regain++;\n\t\t\tellipse_det.num_lost = 0;\n\t\t} else {\n\t\t\tellipse_det.num_regain = 0;\n\t\t\tellipse_det.num_lost++;\n\t\t}\n\t}\n\tif (ellipse_det.num_lost > VISION_THRES) {\n\t\tellipse_det.is_detected = false;\n\t} else if (ellipse_det.num_regain > VISION_THRES) {\n\t\tellipse_det.is_detected = true;\n\t}\n\tif (ellipse_det.is_detected) {\n\t\tellipse_det.sight_angle = ellipse_det.sight_angle_regain;\n\t} else {\n\t\tellipse_det.sight_angle = ellipse_det.sight_angle_lost;\n\t}\n}\n", "CodeBleu_score": 37.35829635917645}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  // Check if the current position is safe or not\n  bool is_safe = true;\n  if (occupy_map_ptr_->getOccupancy(cur_pos(0), cur_pos(1)) == 0) {\n    is_safe = false;\n  }\n\n  // Check if the current position is within the map boundaries\n  if (cur_pos(0) < 0.5 || cur_pos(0) > map_size_(0) - 0.5 || cur_pos(1) < 0.5 ||\n      cur_pos(1) > map_size_(1) - 0.5) {\n    is_safe = false;\n  }\n\n  // Check if the current position is within the safety distance of the obstacles\n  if (occupy_map_ptr_->getOccupancy(cur_pos(0), cur_pos(1)) == 1) {\n    std::vector<Eigen::Vector3d> near_obs_pos;\n    occupy_map_ptr_->getNearbyPoint(cur_pos, near_obs_pos, safe_distance);\n    if (near_obs_pos.size() != 0) {\n      is_safe = false;\n    }\n  }\n\n  return is_safe;\n}\n", "CodeBleu_score": 42.85205811966175}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  Eigen::Vector3d pos_check;\n  pos_check = cur_pos;\n  pos_check.z() = 0.0;\n  return Occupy_map_ptr->check_safety(pos_check, safe_distance);\n}\n", "CodeBleu_score": 52.88555247790916}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  bool is_safe = true;\n  double x_min, x_max, y_min, y_max;\n  double x_min_safe, x_max_safe, y_min_safe, y_max_safe;\n  double x_min_safe_2, x_max_safe_2, y_min_safe_2, y_max_safe_2;\n  double x_min_safe_3, x_max_safe_3, y_min_safe_3, y_max_safe_3;\n  double x_min_safe_4, x_max_safe_4, y_min_safe_4, y_max_safe_4;\n  double x_min_safe_5, x_max_safe_5, y_min_safe_5, y_max_safe_5;\n  double x_min_safe_6, x_max_safe_6, y_min_safe_6, y_max_safe_6;\n  double x_min_safe_7, x_max_safe_7, y_min_safe_7, y_max_safe_7;\n  double x_min_safe_8, x_max_safe_8, y_min_safe_8, y_max_safe_8;\n  double x_min_safe_9, x_max_safe_9, y_min_safe_9, y_max_safe_9;\n  double x_min_safe_10, x_max_safe_10, y_min_safe_10, y_max_safe_10;\n  double x_min_safe_11, x_max_safe_11, y_min_safe_11, y_max_safe_11;\n  double x_min_safe_12, x_max_safe_12, y_min_safe_12, y_max_safe_12;\n  double x_min_safe_13, x_max_safe_13, y_min_safe_13, y_max_safe_13;\n  double x_min_safe_14, x_max_safe_14, y", "CodeBleu_score": 12.055973591036715}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)    NodePtr current = end_node;\n    while (current != nullptr) {\n        path_nodes_.push_back(current);\n        current = current->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 53.8928929301791}, {"code": "void Astar::retrievePath(NodePtr end_node)  NodePtr current_node = end_node;\n  while (current_node != nullptr) {\n    path_nodes_.push_back(current_node);\n    current_node = current_node->getParent();\n  }\n  std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 52.93409109323646}, {"code": "void Astar::retrievePath(NodePtr end_node)    NodePtr node = end_node;\n    while (node->getParent() != NULL) {\n        path_nodes_.push_back(node);\n        node = node->getParent();\n    }\n    path_nodes_.push_back(node);\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 61.24090209196119}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)   if(sim_mode) {\n    double x_start = start_pos.position.x;\n    double y_start = start_pos.position.y;\n    double x_nei = odom->pose.pose.position.x;\n    double y_nei = odom->pose.pose.position.y;\n    double dist_nei = sqrt(pow(x_nei - x_start, 2) + pow(y_nei - y_start, 2));\n    if(dist_nei > 5) {\n      get_nei_state[id] = false;\n    }\n    else {\n      get_nei_state[id] = true;\n    }\n  }\n  state_nei[id][0] = odom->pose.pose.position.x;\n  state_nei[id][1] = odom->pose.pose.position.y;\n  state_nei[id][2] = odom->pose.pose.position.z;\n  state_nei[id][3] = odom->twist.twist.linear.x;\n  state_nei[id][4] = odom->twist.twist.linear.y;\n  state_nei[id][5] = odom->twist.twist.linear.z;\n  state_nei[id][6] = odom->twist.twist.angular.x;\n  state_nei[id][7] = odom->twist.twist.angular.y;\n  state_nei[id][8] = odom->twist.twist.angular.z;\n}\n", "CodeBleu_score": 55.47405634259282}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)   //ROS_INFO(\"nei_odom_cb\");\n  if(sim_mode) {\n    double dx = odom->pose.pose.position.x - start_x;\n    double dy = odom->pose.pose.position.y - start_y;\n    double dist = sqrt(dx*dx + dy*dy);\n    if(dist > 5.0) {\n      state_nei[id] = false;\n    }\n    else {\n      state_nei[id] = true;\n    }\n  }\n  else {\n    state_nei[id] = true;\n  }\n  state_nei_mutex.unlock();\n}\n", "CodeBleu_score": 46.063510894036924}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)   //ROS_INFO(\"Inside nei_odom_cb\");\n  //ROS_INFO(\"nei_odom_cb: id = %d\", id);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get_nei_state = %d\", nei_state[id].get_nei_state);\n  //ROS_INFO(\"nei_odom_cb: nei_state[id].get", "CodeBleu_score": 3.2892896623732404}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\n    //Check if odometry is ready\n    if (odom_ready == false) {\n        return;\n    }\n\n    //Update counter\n    update_counter++;\n\n    //If update counter is 5, update map\n    if (update_counter == 5) {\n\n        //Reset update counter\n        update_counter = 0;\n\n        //Get point cloud\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*msg, *cloud);\n\n        //Convert point cloud to vector of points\n        std::vector<pcl::PointXYZ> cloud_vec;\n        for (int i = 0; i < cloud->points.size(); i++) {\n            cloud_vec.push_back(cloud->points[i]);\n        }\n\n        //Update map\n        astar_map.update_map(cloud_vec, odom_x, odom_y, odom_yaw);\n\n        //Reset sensor ready flag\n        sensor_ready = false;\n\n    }\n\n}\n", "CodeBleu_score": 46.94209262652469}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  // Check if odometry is ready\n  if (!odom_ready)\n    return;\n\n  // Set sensor ready flag\n  sensor_ready = true;\n\n  // Increment update counter\n  update_counter++;\n\n  // Every fifth update, update Astar map\n  if (update_counter % 5 == 0) {\n    // Update Astar map\n    update_map(msg);\n\n    // Reset update counter\n    update_counter = 0;\n  }\n}\n", "CodeBleu_score": 47.98187282932729}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (!odom_ready) {\n    return;\n  }\n  // update the map\n  if (sensor_ready) {\n    if (update_counter == 5) {\n      update_counter = 0;\n      sensor_ready = false;\n      update_map(msg);\n    } else {\n      update_counter++;\n    }\n  } else {\n    sensor_ready = true;\n  }\n}\n", "CodeBleu_score": 55.41049310378613}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)    if (get_gpcl == false) {\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n        pcl::fromROSMsg(*global_point, cloud);\n        global_point_cloud = cloud;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud_ptr (new pcl::PointCloud<pcl::PointXYZ> (global_point_cloud));\n        pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud_inflated (new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::InflatePointCloud(global_point_cloud_ptr, global_point_cloud_inflated, inflation_radius);\n        global_point_cloud_inflated_ptr = global_point_cloud_inflated;\n    }\n}\n", "CodeBleu_score": 49.55799429709192}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)  if (!get_gpcl) {\n    get_gpcl = true;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_global (new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*global_point, *cloud_global);\n    cloud_global->header.frame_id = \"map\";\n    cloud_global->header.stamp = ros::Time::now();\n    cloud_global_ = cloud_global;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_global_inflated (new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*global_point, *cloud_global_inflated);\n    cloud_global_inflated->header.frame_id = \"map\";\n    cloud_global_inflated->header.stamp = ros::Time::now();\n    cloud_global_inflated_ = cloud_global_inflated;\n    inflate_pointcloud(cloud_global_inflated_, cloud_global_inflated_, inflation_radius_);\n    //publish the inflated point cloud\n    sensor_msgs::PointCloud2 global_point_inflated;\n    pcl::toROSMsg(*cloud_global_inflated_, global_point_inflated);\n    global_point_inflated.header.frame_id = \"map\";\n    global_point_inflated.header.stamp = ros::Time::now();\n    pub_cloud_global_.publish(global_point_inflated);\n  }\n}\n", "CodeBleu_score": 48.9758603327114}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)    if (get_gpcl == false) {\n        get_gpcl = true;\n        // convert the sensor message to a point cloud\n        pcl::fromROSMsg(*global_point, global_point_);\n        // store the point cloud\n        global_point_.header.frame_id = \"map\";\n        global_point_.header.stamp = ros::Time::now();\n        // inflate the point cloud\n        pcl::PointCloud<pcl::PointXYZ> inflated_global_point;\n        pcl::PointCloud<pcl::PointXYZ> inflated_global_point_temp;\n        pcl::VoxelGrid<pcl::PointXYZ> vg;\n        vg.setInputCloud(global_point_.makeShared());\n        vg.setLeafSize(global_inflation_length, global_inflation_length, global_inflation_length);\n        vg.filter(inflated_global_point);\n        // publish the inflated point cloud\n        sensor_msgs::PointCloud2 global_point_inflated;\n        pcl::toROSMsg(inflated_global_point, global_point_inflated);\n        global_point_inflated.header.frame_id = \"map\";\n        global_point_inflated.header.stamp = ros::Time::now();\n        global_point_inflated_pub.publish(global_point_inflated);\n        // publish the inflated point cloud with color\n        sensor_msgs::PointCloud2 global_point_inflated_color;\n        pcl::toROSMsg(inflated_global_point, global_point_inflated_color);\n        global_point_inflated_color.header.frame_id = \"map\";\n        global_point_inflated_color.header.stamp = ros::Time::now();\n        global_point_inflated_color.fields.resize(4);\n        global_point_inflated_color.fields[0].name = \"x\";\n        global_point_inflated_color.fields[0].offset = 0;\n        global_point_inflated_color.fields[0].datatype = 7;\n       ", "CodeBleu_score": 43.491880810729846}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)    // Convert laser scan to point cloud\n    sensor_msgs::PointCloud2 laser_cloud;\n    laserCloud.header = local_point->header;\n    laserCloud.header.frame_id = \"map\";\n    projector_.transformLaserScanToPointCloud(\"base_link\", *local_point, laserCloud, listener_);\n    pcl::fromROSMsg(laserCloud, local_map_);\n\n    // Merge local map with odometry data\n    if (is_simulation_ == false) {\n        // Get odometry data\n        tf::Quaternion q(odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z, odom.pose.pose.orientation.w);\n        tf::Matrix3x3 m(q);\n        double roll, pitch, yaw;\n        m.getRPY(roll, pitch, yaw);\n        double odom_x = odom.pose.pose.position.x;\n        double odom_y = odom.pose.pose.position.y;\n        double odom_z = odom.pose.pose.position.z;\n\n        // Transform local map to odometry frame\n        pcl::PointCloud<pcl::PointXYZI>::Ptr local_map_transformed (new pcl::PointCloud<pcl::PointXYZI>);\n        pcl::transformPointCloud(*local_map_, *local_map_transformed, Eigen::Affine3f(Eigen::Translation3f(odom_x, odom_y, odom_z)).rotate(Eigen::AngleAxisf(yaw, Eigen::Vector3f::UnitZ())));\n\n        // Merge local map with odometry data\n        *local_map_ = *local_map_transformed + *local_map_;\n    }\n\n    // Publish the local map\n    local_map_pub_.publish(local_map_);\n}\n", "CodeBleu_score": 43.5081706507315}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)  // Laser scan projection\n  sensor_msgs::PointCloud2 laser_cloud_temp;\n  projector_.transformLaserScanToPointCloud(base_frame_, *local_point, laser_cloud_temp, listener_);\n  pcl::fromROSMsg(laser_cloud_temp, laserCloud);\n  laserCloud.header.frame_id = base_frame_;\n  laserCloud.header.stamp = local_point->header.stamp;\n  laserCloud.header.seq = local_point->header.seq;\n\n  // If not in simulation mode, merge the local map with the odometry data\n  if (!simulation_) {\n    laserCloud = map_update_odom(laserCloud, odom);\n  }\n\n  // Publish the occupancy map\n  occupancy_map_pub_.publish(laserCloud);\n}\n", "CodeBleu_score": 45.62148304000354}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)  if (simulation_mode) {\n    // Converts laser scan data to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ> laserCloud;\n    sensor_msgs::PointCloud2 laserCloud_ros;\n    projector_.transformLaserScanToPointCloud(global_frame_id, *local_point, laserCloud_ros, tf_listener);\n    pcl::fromROSMsg(laserCloud_ros, laserCloud);\n\n    // Converts the laser scan to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr laserCloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n    *laserCloud_ptr = laserCloud;\n\n    // Adds the laser scan to the map\n    occupancy_map_.add_scan_to_map(laserCloud_ptr);\n  } else {\n    // Merges the local map with the provided odometry data\n    occupancy_map_.merge_map(odom);\n  }\n}\n", "CodeBleu_score": 46.43882644845986}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\n  if (map_update_ == true) {\n\n    // Convert the global point cloud map to a ROS message and publish it with the frame ID \"world\" to the global_pcl_pub topic.\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl_ptr_, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_pub_.publish(global_pcl_msg);\n\n    // Convert and publish the inflated point cloud to the inflate_pcl_pub topic with the same frame ID.\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl_ptr_, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub_.publish(inflate_pcl_msg);\n\n    // Set the flag to false.\n    map_update_ = false;\n  }\n}\n", "CodeBleu_score": 50.402118684104416}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)  if (map_update_ == true) {\n    map_update_ = false;\n    // Publish the global point cloud\n    sensor_msgs::PointCloud2 global_pcl;\n    pcl::toROSMsg(global_pcl_ptr, global_pcl);\n    global_pcl.header.frame_id = \"world\";\n    global_pcl_pub.publish(global_pcl);\n\n    // Publish the inflated point cloud\n    sensor_msgs::PointCloud2 inflate_pcl;\n    pcl::toROSMsg(inflate_pcl_ptr, inflate_pcl);\n    inflate_pcl.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl);\n  }\n}\n", "CodeBleu_score": 50.09141626886302}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)  // Convert the global point cloud map to a ROS message\n  sensor_msgs::PointCloud2 ros_cloud_msg;\n  pcl::toROSMsg(global_map, ros_cloud_msg);\n  ros_cloud_msg.header.frame_id = \"world\";\n  ros_cloud_msg.header.stamp = ros::Time::now();\n  // Publish the global point cloud map\n  global_pcl_pub.publish(ros_cloud_msg);\n\n  // Convert the inflated point cloud to a ROS message\n  sensor_msgs::PointCloud2 ros_inflate_cloud_msg;\n  pcl::toROSMsg(inflate_cloud, ros_inflate_cloud_msg);\n  ros_inflate_cloud_msg.header.frame_id = \"world\";\n  ros_inflate_cloud_msg.header.stamp = ros::Time::now();\n  // Publish the inflated point cloud\n  inflate_pcl_pub.publish(ros_inflate_cloud_msg);\n}\n", "CodeBleu_score": 54.629524410753014}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  // Check if we have received odometry\n  if (odom_ready) {\n    // Set sensor ready flag to true\n    sensor_ready = true;\n\n    // Update map\n    updateMap(msg);\n  }\n}\n", "CodeBleu_score": 47.76001548293017}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\n\t//ROS_INFO(\"Received new point cloud\");\n\n\tif (sensor_ready) {\n\t\treturn;\n\t}\n\n\t//ROS_INFO(\"Point cloud received\");\n\n\t//ROS_INFO(\"Converting point cloud to PCL point cloud\");\n\n\tpcl::fromROSMsg(*msg, cloud);\n\n\t//ROS_INFO(\"Point cloud converted\");\n\n\t//ROS_INFO(\"Updating A* algorithm's map\");\n\n\t// Update the map with the new point cloud data\n\tmap.updateMap(cloud, odometry.pose.pose.position.x, odometry.pose.pose.position.y, odometry.pose.pose.position.z);\n\n\t//ROS_INFO(\"A* algorithm's map updated\");\n\n\t//ROS_INFO(\"Setting sensor_ready to true\");\n\n\t// Set sensor_ready to true\n\tsensor_ready = true;\n\n\t//ROS_INFO(\"sensor_ready set to true\");\n}\n", "CodeBleu_score": 50.75744627268865}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (!odom_ready) {\n    return;\n  }\n  sensor_ready = true;\n  // if (map_ready) {\n  //   return;\n  // }\n  // std::cout << \"Lpointcloud_cb\" << std::endl;\n  // std::cout << \"odom_ready: \" << odom_ready << std::endl;\n  // std::cout << \"sensor_ready: \" << sensor_ready << std::endl;\n  // std::cout << \"map_ready: \" << map_ready << std::endl;\n  // std::cout << \"map_updated: \" << map_updated << std::endl;\n  // std::cout << \"map_updated_in_cb: \" << map_updated_in_cb << std::endl;\n  // std::cout << \"map_updated_in_cb_2: \" << map_updated_in_cb_2 << std::endl;\n  // std::cout << \"map_updated_in_cb_3: \" << map_updated_in_cb_3 << std::endl;\n  // std::cout << \"map_updated_in_cb_4: \" << map_updated_in_cb_4 << std::endl;\n  // std::cout << \"map_updated_in_cb_5: \" << map_updated_in_cb_5 << std::endl;\n  // std::cout << \"map_updated_in_cb_6: \" << map_updated_in_cb_6 << std::endl;\n  // std::cout << \"map_updated_in_cb_7: \" << map_updated_in_cb_7 << std::endl;\n  // std::cout << \"map_updated_in_cb_8: \" << map_updated_in_cb_8 << std::endl;\n  // std::cout << \"map_updated_in_cb_9: \" << map_updated_in_cb_9 << std::endl;\n  // std::cout << \"map_updated_in_cb_10: \" << map_updated_in_cb_10 << std::endl;\n  // std::cout << \"map_updated_in_cb_11: \"", "CodeBleu_score": 33.94438658232143}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Check if the robot is in a safe position to start walking\n  if (!isRobotSafe()) {\n    ROS_ERROR(\"Robot is not in a safe position to start walking.\");\n    return;\n  }\n\n  // Get the current time\n  ros::Time time_now = ros::Time::now();\n\n  // Update the body controller\n  body_controller_->update(time_now);\n\n  // Get the desired foot positions\n  std::vector<Eigen::VectorXd> foot_positions_desired = body_controller_->getFootPositions();\n\n  // Get the desired joint positions\n  Eigen::VectorXd joint_positions_desired = body_controller_->getJointPositions();\n\n  // Get the desired joint velocities\n  Eigen::VectorXd joint_velocities_desired = body_controller_->getJointVelocities();\n\n  // Get the desired joint torques\n  Eigen::VectorXd joint_torques_desired = body_controller_->getJointTorques();\n\n  // Get the current joint positions\n  Eigen::VectorXd joint_positions_current = getCurrentJointPositions();\n\n  // Get the current joint velocities\n  Eigen::VectorXd joint_velocities_current = getCurrentJointVelocities();\n\n  // Get the current joint torques\n  Eigen::VectorXd joint_torques_current = getCurrentJointTorques();\n\n  // Get the current foot positions\n  std::vector<Eigen::VectorXd> foot_positions_current = getCurrentFootPositions();\n\n  // Compute the joint positions to achieve the desired foot positions\n  Eigen::VectorXd joint_positions_command =\n      inverse_kinematics_->computeInverseKinematics(foot_positions_desired, joint_positions_current, joint_velocities_current);\n\n  // Compute the joint velocities to achieve the desired foot positions\n  Eigen::VectorXd joint_velocities_command =\n      inverse_kinematics_->computeInverseKinematicsVelocity(foot_positions_desired", "CodeBleu_score": 38.929760889130606}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Calculate desired foot positions\n  calculateTargetFootPositions();\n\n  // Calculate desired joint positions\n  calculateTargetJointPositions();\n\n  // Publish joint positions\n  publishJointPositions();\n\n  // Publish foot contact information\n  publishFootContact();\n}\n", "CodeBleu_score": 8.738745628090665}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the desired foot positions\n  bodyController_.calculateTargetFootPositions();\n\n  // Calculate the", "CodeBleu_score": 19.9185460777593}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])  // Create a new message\n  quadruped_msgs::ContactsStamped contacts;\n  // Set the current time stamp\n  contacts.header.stamp = ros::Time::now();\n  // Set the gait phase of each leg\n  contacts.contacts[0].phase = (int)leg_controller_->getCurrentGaitPhase(0);\n  contacts.contacts[1].phase = (int)leg_controller_->getCurrentGaitPhase(1);\n  contacts.contacts[2].phase = (int)leg_controller_->getCurrentGaitPhase(2);\n  contacts.contacts[3].phase = (int)leg_controller_->getCurrentGaitPhase(3);\n  // Set the foot contact status of each leg\n  contacts.contacts[0].contact = foot_contacts[0];\n  contacts.contacts[1].contact = foot_contacts[1];\n  contacts.contacts[2].contact = foot_contacts[2];\n  contacts.contacts[3].contact = foot_contacts[3];\n  // Publish the message\n  foot_contacts_publisher_.publish(contacts);\n}\n", "CodeBleu_score": 46.86979565489402}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])  if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    quadruped_msgs::ContactsStamped msg;\n    msg.header.stamp = ros::Time::now();\n    msg.header.frame_id = \"base_link\";\n\n    msg.contacts.resize(4);\n    for (int i = 0; i < 4; ++i) {\n      msg.contacts[i].name = \"foot_\" + std::to_string(i + 1);\n      msg.contacts[i].is_in_contact = foot_contacts[i];\n      msg.contacts[i].phase = gait_phase_[i];\n    }\n    foot_contacts_publisher_.publish(msg);\n  }\n}\n", "CodeBleu_score": 49.52574319967691}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])  if (foot_contacts_publisher_->trylock()) {\n    auto msg = foot_contacts_publisher_->msg_;\n    msg->header.frame_id = \"base_link\";\n    msg->header.stamp = time_keeper_->now();\n    for (int i = 0; i < 4; ++i) {\n      msg->contact_states[i] = foot_contacts[i];\n    }\n    foot_contacts_publisher_->unlockAndPublish();\n  }\n}\n", "CodeBleu_score": 41.3474191162035}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)\n    // Create a joints message with the first 12 joint positions\n    JointState joints_msg = JointState()\n    joints_msg.header = Header()\n    joints_msg.header.stamp = joints.header.stamp\n    joints_msg.name = self.joint_names\n    joints_msg.position = joints.position[0:12]\n\n    // Publish the joints message\n    self.pub_joints.publish(joints_msg)\n\n    // Create a joint trajectory message with the same positions and a specified duration\n    JointTrajectory joint_traj = JointTrajectory()\n    joint_traj.header = Header()\n    joint_traj.header.stamp = joints.header.stamp\n    joint_traj.joint_names = self.joint_names\n    joint_traj.points = [JointTrajectoryPoint()]\n    joint_traj.points[0].positions = joints.position[0:12]\n    joint_traj.points[0].time_from_start = Duration(secs=self.duration)\n\n    // Publish the joint trajectory message\n    self.pub_joint_traj.publish(joint_traj)\n\n}\n", "CodeBleu_score": 48.020425806584065}, {"code": "def joints_cmd_callback(self, joints)  // Create a joints message with the first 12 joint positions\n  JointState joints_msg = JointState()\n  joints_msg.header.stamp = joints.header.stamp\n  joints_msg.name = joints.name[0:12]\n  joints_msg.position = joints.position[0:12]\n  self.joints_pub.publish(joints_msg)\n\n  // Create a joint trajectory message with the same positions and a specified duration\n  JointTrajectory joints_traj = JointTrajectory()\n  joints_traj.header.stamp = joints.header.stamp\n  joints_traj.header.frame_id = joints.header.frame_id\n  joints_traj.joint_names = joints.name[0:12]\n  JointTrajectoryPoint point = JointTrajectoryPoint()\n  point.positions = joints.position[0:12]\n  point.time_from_start = rospy.Duration(1.0)\n  joints_traj.points.append(point)\n  self.joints_traj_pub.publish(joints_traj)\n}\n", "CodeBleu_score": 47.23059396920083}, {"code": "def joints_cmd_callback(self, joints)  // Create a minimal joints message with the first 12 joint positions\n  sensor_msgs::JointState joint_state_msg;\n  joint_state_msg.name = self.joint_names[0:12];\n  joint_state_msg.position = joints.position[0:12];\n  self.pub_joints.publish(joint_state_msg);\n\n  // Construct a joint trajectory message with the same positions and a specified duration\n  trajectory_msgs::JointTrajectory joint_trajectory_msg;\n  joint_trajectory_msg.header.stamp = rospy.Time.now();\n  joint_trajectory_msg.header.frame_id = \"base_link\";\n  joint_trajectory_msg.joint_names = self.joint_names[0:12];\n  trajectory_msgs::JointTrajectoryPoint point;\n  point.positions = joints.position[0:12];\n  point.velocities = [0.0] * 12;\n  point.accelerations = [0.0] * 12;\n  point.effort = [0.0] * 12;\n  point.time_from_start = rospy.Duration(0.25);\n  joint_trajectory_msg.points.append(point);\n  self.pub_joint_trajectory.publish(joint_trajectory_msg);\n}\n", "CodeBleu_score": 45.00647291542739}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Initialize foot contact states\n  for (int i = 0; i < 4; i++) {\n    footContact_[i] = false;\n  }\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string to identify the contact link\n    std::string coll1 = _msg->contact(i).collision1();\n    std::string coll2 = _msg->contact(i).collision2();\n    std::vector<std::string> coll1_split = split(coll1, ':');\n    std::vector<std::string> coll2_split = split(coll2, ':');\n    std::string coll1_link = coll1_split[coll1_split.size() - 1];\n    std::string coll2_link = coll2_split[coll2_split.size() - 1];\n\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (coll1_link == \"l_foot_contact\" || coll2_link == \"l_foot_contact\") {\n      footContact_[0] = true;\n    }\n    if (coll1_link == \"r_foot_contact\" || coll2_link == \"r_foot_contact\") {\n      footContact_[1] = true;\n    }\n    if (coll1_link == \"l_foot_contact_2\" || coll2_link == \"l_foot_contact_2\") {\n      footContact_[2] = true;\n    }\n    if (coll1_link == \"r_foot_contact_2\" || coll2_link == \"r_foot_contact_2\") {\n      footContact_[3] = true;\n    }\n  }\n}\n", "CodeBleu_score": 53.12204102847852}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Loop through all the contacts\n  for (int i = 0; i < _msg->contact_size(); ++i) {\n    // Get the two collision links involved in this contact\n    std::string collision1 = _msg->contact(i).collision1();\n    std::string collision2 = _msg->contact(i).collision2();\n\n    // Check if the collision string contains \"l_foot\"\n    if (collision1.find(\"l_foot\") != std::string::npos) {\n      // Set the left foot contact state to true\n      left_foot_contact_ = true;\n    } else if (collision2.find(\"l_foot\") != std::string::npos) {\n      // Set the left foot contact state to true\n      left_foot_contact_ = true;\n    } else {\n      // Check if the collision string contains \"r_foot\"\n      if (collision1.find(\"r_foot\") != std::string::npos) {\n        // Set the right foot contact state to true\n        right_foot_contact_ = true;\n      } else if (collision2.find(\"r_foot\") != std::string::npos) {\n        // Set the right foot contact state to true\n        right_foot_contact_ = true;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 44.11482948239543}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Reset foot contact states\n  for (int i = 0; i < 4; i++) {\n    foot_contact_[i] = false;\n  }\n\n  // For each contact in the message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Split the collision string to identify the contact link\n    std::string collision_str = _msg->contact(i).collision2();\n    std::string::size_type start = collision_str.find_first_of(\"/\");\n    std::string::size_type end = collision_str.find_last_of(\"/\");\n    std::string link_name = collision_str.substr(start + 1, end - start - 1);\n\n    // If a contact matches one of the foot links, set the corresponding foot contact state to true\n    if (link_name == \"l_foot\") {\n      foot_contact_[0] = true;\n    } else if (link_name == \"r_foot\") {\n      foot_contact_[1] = true;\n    } else if (link_name == \"l_hand\") {\n      foot_contact_[2] = true;\n    } else if (link_name == \"r_hand\") {\n      foot_contact_[3] = true;\n    }\n  }\n}\n", "CodeBleu_score": 57.62527305265366}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Ensure that the input is valid.\n  if (rotor_velocities == nullptr) {\n    return;\n  }\n  // If the controller is not active, set the rotor velocities to zero.\n  if (!is_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  // Calculate the desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration = Eigen::Vector3d::Zero();\n  Eigen::Vector3d desired_angular_acceleration = Eigen::Vector3d::Zero();\n  CalculateDesiredAcceleration(&desired_acceleration, &desired_angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust = desired_acceleration;\n  thrust.z() = 0.0;\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d desired_acceleration_and_angular_acceleration =\n      desired_angular_acceleration + thrust;\n\n  // Compute the rotor velocities.\n  Eigen::VectorXd rotor_velocities_vector =\n      Eigen::VectorXd::Zero(rotor_count_);\n  rotor_velocities_vector =\n      kRotorVelocityCoefficientMatrix * desired_acceleration_and_angular_acceleration;\n\n  // Ensure that the rotor velocities are positive.\n  for (int i = 0; i < rotor_count_; ++i) {\n    rotor_velocities_vector(i) =\n        std::max(rotor_velocities_vector(i), kEpsilon);\n  }\n\n  // Take the square root of each component.\n  rotor_velocities_vector =\n      rotor_velocities_vector.array().sqrt();\n\n  // Copy the result to the output.\n  *rotor_velocities = rotor_velocities_vector;\n}\n", "CodeBleu_score": 45.8301739287238}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  if (!is_valid_) {\n    LogWarning(\n        \"LeePositionController::CalculateRotorVelocities\",\n        \"Invalid state. Controller is not active.\");\n    return;\n  }\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!is_active_) {\n    *rotor_velocities = Eigen::VectorXd::Zero(rotor_count_);\n    return;\n  }\n\n  // Calculate the desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration;\n  Eigen::Vector3d desired_angular_acceleration;\n  CalculateDesiredAccelerationAndAngularAcceleration(&desired_acceleration,\n                                                    &desired_angular_acceleration);\n\n  // Project thrust onto the body z-axis.\n  Eigen::Vector3d thrust = desired_acceleration;\n  thrust.z() = 0;\n\n  // Combine angular acceleration and thrust into a single vector.\n  Eigen::Vector3d desired_acceleration_and_angular_acceleration =\n      desired_angular_acceleration + thrust;\n\n  // Compute the rotor velocities.\n  *rotor_velocities =\n      Eigen::VectorXd::Zero(rotor_count_);\n  (*rotor_velocities).block<3, 1>(0, 0) =\n      (rotor_velocity_matrix_ *\n       desired_acceleration_and_angular_acceleration).cwiseMax(0.0);\n}\n", "CodeBleu_score": 44.07413908846164}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities != nullptr);\n  assert(rotor_velocities->size() == kNumMotors);\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!IsActive()) {\n    *rotor_velocities << 0, 0, 0, 0;\n    return;\n  }\n\n  // Calculate the desired acceleration.\n  Eigen::Vector3d desired_acceleration =\n      desired_state_.acceleration -\n      Eigen::Vector3d(0, 0, kGravity).dot(desired_state_.position) *\n          Eigen::Vector3d(0, 0, 1);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration =\n      desired_state_.angular_acceleration -\n      desired_state_.angular_velocity.cross(desired_state_.position);\n\n  // Project the thrust onto the body z-axis.\n  double thrust_z = desired_acceleration.dot(Eigen::Vector3d(0, 0, 1));\n\n  // Combine the thrust and angular acceleration into a single vector.\n  Eigen::Vector3d desired_acceleration_projected =\n      desired_acceleration - thrust_z * Eigen::Vector3d(0, 0, 1);\n  Eigen::Vector3d desired_acceleration_combined =\n      desired_acceleration_projected +\n      desired_angular_acceleration.cross(desired_state_.position);\n\n  // Compute the rotor velocities.\n  *rotor_velocities =\n      kRotorVelocityCoefficient *\n      (Eigen::Matrix3d(Eigen::Quaterniond(\n           desired_state_.attitude.w(), desired_state_.attitude.x(),\n           desired_state_.attitude.y(), desired_state_.attitude.z())) *\n       desired_acceleration_combined);\n\n  // Ensure that the rotor velocities are non-negative.", "CodeBleu_score": 40.138652274266846}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  Eigen::Vector3d position_error;\n  Eigen::Vector3d velocity_error;\n\n  // Compute the position error\n  position_error = command_trajectory_.GetCurrentPosition() - odometry_.GetCurrentPosition();\n\n  // Compute the velocity error\n  velocity_error = command_trajectory_.GetCurrentVelocity() - odometry_.GetCurrentVelocity();\n  velocity_error = odometry_.GetCurrentRotation() * velocity_error;\n\n  // Compute the desired acceleration\n  Eigen::Vector3d desired_acceleration;\n  desired_acceleration = (position_gain_ * position_error) + (velocity_gain_ * velocity_error);\n\n  // Adjust for vehicle mass, gravity, and commanded acceleration\n  desired_acceleration = desired_acceleration / mass_ + gravity_;\n  desired_acceleration = desired_acceleration + command_trajectory_.GetCurrentAcceleration();\n\n  *acceleration = desired_acceleration;\n}\n", "CodeBleu_score": 42.572391669430154}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  // Get the current odometry data.\n  const Eigen::Vector3d& position = odometry_data_->GetPosition();\n  const Eigen::Vector3d& velocity = odometry_data_->GetVelocity();\n\n  // Get the command trajectory.\n  const Eigen::Vector3d& command_position = command_trajectory_->GetPosition();\n  const Eigen::Vector3d& command_velocity = command_trajectory_->GetVelocity();\n\n  // Calculate the position and velocity errors.\n  Eigen::Vector3d position_error = command_position - position;\n  Eigen::Vector3d velocity_error = command_velocity - velocity;\n\n  // Transform the velocity error to the world frame.\n  Eigen::Vector3d world_velocity_error =\n      Eigen::Quaterniond(odometry_data_->GetOrientation()).conjugate() * velocity_error;\n\n  // Calculate the desired acceleration.\n  *acceleration = (position_gain_ * position_error) + (velocity_gain_ * world_velocity_error) +\n                  (acceleration_gain_ * command_trajectory_->GetAcceleration()) -\n                  (Eigen::Vector3d::UnitZ() * gravity_magnitude_) -\n                  (Eigen::Vector3d::UnitZ() * (mass_ * world_velocity_error.z()));\n}\n", "CodeBleu_score": 44.9023896598162}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  // Calculate position error\n  Eigen::Vector3d position_error = odometry_.position - command_trajectory_.position;\n\n  // Calculate velocity error\n  Eigen::Vector3d velocity_error = odometry_.velocity - command_trajectory_.velocity;\n\n  // Calculate acceleration error\n  Eigen::Vector3d acceleration_error = odometry_.acceleration - command_trajectory_.acceleration;\n\n  // Calculate the desired acceleration\n  *acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error +\n                 acceleration_gain_ * acceleration_error;\n\n  // Adjust for vehicle mass\n  *acceleration /= vehicle_mass_;\n\n  // Adjust for gravity\n  *acceleration += Eigen::Vector3d(0, 0, -9.8);\n\n  // Adjust for commanded acceleration\n  *acceleration += command_trajectory_.acceleration;\n}\n", "CodeBleu_score": 41.97481448676516}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Check that the input is valid.\n  assert(rotor_velocities != nullptr);\n\n  // Check that the parameters are valid.\n  assert(params_.size() == kNumParams);\n  assert(params_[kOmega0] > 0.0);\n  assert(params_[kOmega1] > 0.0);\n  assert(params_[kOmega2] > 0.0);\n  assert(params_[kOmega3] > 0.0);\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(kNumMotors);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d desired_angular_acceleration;\n  desired_angular_acceleration <<\n      -params_[kOmega0] * state_.angular_acceleration(0) - params_[kOmega1] * state_.angular_acceleration(1) - params_[kOmega2] * state_.angular_acceleration(2),\n      params_[kOmega0] * state_.angular_acceleration(0) - params_[kOmega1] * state_.angular_acceleration(1) + params_[kOmega2] * state_.angular_acceleration(2),\n      -params_[kOmega0] * state_.angular_acceleration(0) + params_[kOmega1] * state_.angular_acceleration(1) - params_[kOmega2] * state_.angular_acceleration(2);\n\n  // Combine the desired angular acceleration with the thrust reference.\n  Eigen::VectorXd desired_angular_acceleration_with_thrust;\n  desired_angular_acceleration_with_thrust.resize(kNumMotors);\n  desired_angular_acceleration_with_thrust <<\n      desired_angular_acceleration,\n      params_[kOmega3] * state_.angular_acceleration(2);\n\n  // Compute the rotor velocities.\n  Eigen::VectorXd rotor_velocities_squared;\n  rotor", "CodeBleu_score": 36.36573064532157}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const    // Ensure the rotor velocities are sized correctly.\n    rotor_velocities->resize(num_rotors_);\n\n    // Calculate the desired angular acceleration.\n    Eigen::VectorXd desired_angular_acceleration =\n        thrust_reference_ -\n        Eigen::VectorXd(3) << 0.0, 0.0, g_;\n\n    // Combine the desired angular acceleration and thrust reference into a single vector.\n    Eigen::VectorXd desired_angular_acceleration_and_thrust_reference =\n        Eigen::VectorXd(4) << desired_angular_acceleration(0),\n                                 desired_angular_acceleration(1),\n                                 desired_angular_acceleration(2),\n                                 thrust_reference_(3);\n\n    // Compute the rotor velocities.\n    *rotor_velocities =\n        Eigen::VectorXd::Map(rotor_velocities_matrix_.data(),\n                             rotor_velocities_matrix_.size()) *\n        desired_angular_acceleration_and_thrust_reference;\n\n    // Ensure the rotor velocities are at least one.\n    for (int i = 0; i < num_rotors_; ++i) {\n        (*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 1.0);\n    }\n\n    // Take the square root of each component.\n    for (int i = 0; i < num_rotors_; ++i) {\n        (*rotor_velocities)(i) = std::sqrt((*rotor_velocities)(i));\n    }\n}\n", "CodeBleu_score": 43.61791983474207}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Check that the number of rotors is valid.\n  if (num_rotors_ != rotor_velocities->size()) {\n    throw std::invalid_argument(\"Number of rotors must match the number of rotor velocities.\");\n  }\n\n  // Check that the input is valid.\n  if (!std::isfinite(angular_acceleration_(0)) || !std::isfinite(angular_acceleration_(1)) ||\n      !std::isfinite(angular_acceleration_(2)) || !std::isfinite(thrust_reference_)) {\n    throw std::invalid_argument(\"Input must be finite.\");\n  }\n\n  // Resize the rotor velocities vector.\n  rotor_velocities->resize(num_rotors_);\n\n  // Combine the angular acceleration and thrust reference into a single vector.\n  Eigen::VectorXd desired_acceleration(3);\n  desired_acceleration << angular_acceleration_, thrust_reference_;\n\n  // Compute the rotor velocities.\n  (*rotor_velocities) = desired_acceleration * rotor_control_matrix_;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < num_rotors_; ++i) {\n    (*rotor_velocities)(i) = std::max((*rotor_velocities)(i), 1.0);\n  }\n\n  // Take the square root of each component.\n  (*rotor_velocities) = (*rotor_velocities).array().sqrt();\n}\n", "CodeBleu_score": 47.31829157513538}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    # find the start and end indices\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    # create a copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # update each attribute of the copied object\n    for attribute in sliced_object.attributes:\n        sliced_object.attributes[attribute] = sliced_object.attributes[attribute][start_index:end_index]\n\n    return sliced_object\n", "CodeBleu_score": 26.496555884800472}, {"code": "def slice(self, start_time, end_time)\n    # find the indices of the start and end times\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    # create a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # update each attribute of the copied object to contain only the sliced data\n    for attribute in self.__dict__:\n        if attribute == 'time':\n            sliced_object.time = self.time[start_index:end_index]\n        elif attribute == 'time_step':\n            sliced_object.time_step = self.time_step[start_index:end_index]\n        else:\n            sliced_object.__dict__[attribute] = self.__dict__[attribute][start_index:end_index]\n\n    return sliced_object\n\n", "CodeBleu_score": 32.089636292349425}, {"code": "def slice(self, start_time, end_time)\n    # Find the indices of the start and end times\n    start_index = self.find_nearest_index(start_time)\n    end_index = self.find_nearest_index(end_time)\n\n    # Make a deep copy of the object\n    new_object = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    new_object.time = new_object.time[start_index:end_index]\n    new_object.temperature = new_object.temperature[start_index:end_index]\n    new_object.pressure = new_object.pressure[start_index:end_index]\n    new_object.density = new_object.density[start_index:end_index]\n    new_object.mass = new_object.mass[start_index:end_index]\n    new_object.energy = new_object.energy[start_index:end_index]\n    new_object.enthalpy = new_object.enthalpy[start_index:end_index]\n    new_object.volume = new_object.volume[start_index:end_index]\n    new_object.internal_energy = new_object.internal_energy[start_index:end_index]\n    new_object.entropy = new_object.entropy[start_index:end_index]\n    new_object.gibbs_free_energy = new_object.gibbs_free_energy[start_index:end_index]\n    new_object.helmholtz_free_energy = new_object.helmholtz_free_energy[start_index:end_index]\n    new_object.speed_of_sound = new_object.speed_of_sound[start_index:end_index]\n    new_object.isentropic_exponent = new_object.isentropic_exponent[start_index:end_index]\n    new_object.isentropic_specific_heat = new_object.isentropic_specific_heat[start_index:end_index]\n    new_object.bulk_modulus = new", "CodeBleu_score": 12.593617007635938}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation from message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    euler_angles = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n\n    # Create Point object\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if self.last_waypoint != point or self.last_yaw != euler_angles[2]:\n        # Append point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaws.append(euler_angles[2])\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n\n        # Update last waypoint and yaw\n        self.last_waypoint = point\n        self.last_yaw = euler_angles[2]\n", "CodeBleu_score": 24.33298158318297}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    euler = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one\n    if self.last_point != point or self.last_yaw != euler[2]:\n        # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(euler[2])\n        self.msg_times.append(msg_time)\n        self.bag_times.append(bag_time)\n        self.last_point = point\n        self.last_yaw = euler[2]\n\n", "CodeBleu_score": 23.575021459909003}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    euler = euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n    # Check if the current waypoint is different from the last one by comparing position and yaw values\n    if self.last_waypoint is not None:\n        if point != self.last_waypoint.point or euler[2] != self.last_waypoint.yaw:\n            # Append new point, yaw, and corresponding times to their respective arrays\n            self.waypoints.append(point)\n            self.yaws.append(euler[2])\n            self.waypoint_times.append(msg_time)\n            self.bag_times.append(bag_time)\n            self.last_waypoint = Waypoint(point, euler[2])\n    else:\n        # Append new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.yaws.append(euler[2])\n        self.waypoint_times.append(msg_time)\n        self.bag_times.append(bag_time)\n        self.last_waypoint = Waypoint(point, euler[2])\n", "CodeBleu_score": 31.48041820343785}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == self.imu_topic_name:\n        msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs/1000000000\n        self.accel_x.append(msg.linear_acceleration.x)\n        self.accel_y.append(msg.linear_acceleration.y)\n        self.accel_z.append(msg.linear_acceleration.z)\n        self.time_stamps.append(msg_time)\n        self.bag_time_stamps.append(bag_time)\n", "CodeBleu_score": 36.03739844044781}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    # Convert message timestamp to seconds\n    imu_time = msg.header.stamp.to_sec()\n    # If the topic matches, append the linear acceleration data to the corresponding x, y, and z attributes\n    if topic == self.imu_topic_list[0]:\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.time_x.append(imu_time)\n        self.bag_time_x.append(bag_time)\n    elif topic == self.imu_topic_list[1]:\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.time_y.append(imu_time)\n        self.bag_time_y.append(bag_time)\n    elif topic == self.imu_topic_list[2]:\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time_z.append(imu_time)\n        self.bag_time_z.append(bag_time)\n", "CodeBleu_score": 22.067148812462946}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    # Convert the message timestamp to seconds.\n    msg_time = msg.header.stamp.secs + msg.header.stamp.nsecs / 1000000000.0\n    # For each IMU topic, if the topic matches, it appends the linear acceleration data to the corresponding x, y, and z attributes.\n    if topic == self.imu_topic:\n        self.acceleration_x.append(msg.linear_acceleration.x)\n        self.acceleration_y.append(msg.linear_acceleration.y)\n        self.acceleration_z.append(msg.linear_acceleration.z)\n        self.time_stamps.append(msg_time)\n        self.bag_time.append(bag_time)\n", "CodeBleu_score": 34.37444903070143}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n\n    # Create figure and subplot\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    # Plot each dataset\n    for i, dataset in enumerate(self.acceleration_datasets):\n        # Get the x and y data\n        x = dataset.get_x()\n        y = dataset.get_y()\n\n        # Plot the x, y, and z data\n        ax.plot(x, y[0], label='x', color='red')\n        ax.plot(x, y[1], label='y', color='green')\n        ax.plot(x, y[2], label='z', color='blue')\n\n    # Add labels and legend\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend()\n\n    # Add title\n    title = 'Accelerations'\n    if plot_suffix is not None:\n        title = title + ' ' + plot_suffix\n    ax.set_title(title)\n\n    # Save plot if saving plots is enabled\n    if self.save_plots:\n        # Construct filename\n        filename = self.plot_filename_prefix + 'accelerations'\n        if plot_suffix is not None:\n            filename = filename + '_' + plot_suffix\n        filename = filename + '.png'\n\n        # Save plot\n        plt.savefig(filename)\n\n    # Show plot\n    plt.show()\n\n", "CodeBleu_score": 36.118615091123566}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    if plot_suffix is None:\n        plot_suffix = ''\n    # Create a figure with a title and a subplot for accelerations\n    fig = plt.figure(figsize=(10, 8))\n    plt.suptitle(self.name + ' Acceleration Data')\n    plt.subplot(3, 1, 1)\n    # Plot the x, y, and z components over time with different colors and labels\n    plt.plot(self.acceleration_data['x'], color='red', label='x')\n    plt.plot(self.acceleration_data['y'], color='green', label='y')\n    plt.plot(self.acceleration_data['z'], color='blue', label='z')\n    plt.xlabel('time (s)')\n    plt.ylabel('acceleration (m/s^2)')\n    plt.legend()\n    # Add labels for the x and y axes and include a legend\n    plt.subplot(3, 1, 2)\n    plt.plot(self.acceleration_data['x'], color='red', label='x')\n    plt.plot(self.acceleration_data['y'], color='green', label='y')\n    plt.xlabel('time (s)')\n    plt.ylabel('acceleration (m/s^2)')\n    plt.legend()\n    # Add labels for the x and y axes and include a legend\n    plt.subplot(3, 1, 3)\n    plt.plot(self.acceleration_data['z'], color='blue', label='z')\n    plt.xlabel('time (s)')\n    plt.ylabel('acceleration (m/s^2)')\n    plt.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = self.name + '_accelerations' + plot_suffix + '.png'\n        plt.savefig(filename)\n\n", "CodeBleu_score": 33.84485556660699}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    # Create figure and subplot\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n\n    # Plot acceleration data\n    ax.plot(self.acceleration_data['x'], color='red', label='x')\n    ax.plot(self.acceleration_data['y'], color='green', label='y')\n    ax.plot(self.acceleration_data['z'], color='blue', label='z')\n\n    # Add labels and legend\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend()\n\n    # Add title and save plot\n    fig.suptitle('Acceleration Data')\n    if self.save_plots:\n        filename = 'AccelerationData'\n        if plot_suffix:\n            filename += plot_suffix\n        filename += '.png'\n        plt.savefig(filename, format='png')\n\n    # Show plot if enabled\n    if self.show_plots:\n        plt.show()\n\n    # Clear plot\n    plt.clf()\n", "CodeBleu_score": 34.39832353865494}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"Error: Please provide at least two pose indeces.\")\n        return\n    for i in range(len(pose_indeces) - 1):\n        compare_two_xyz(pose_indeces[i], pose_indeces[i + 1])\n", "CodeBleu_score": 27.958504583712866}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        raise Exception(\"You must provide at least two pose indices.\")\n    for i in range(len(pose_indeces) - 1):\n        self.compare_two_xyz(pose_indeces[i], pose_indeces[i + 1])\n\n", "CodeBleu_score": 29.76066547719123}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"ERROR: You need to provide at least two pose indices to compare.\")\n        return\n    for i in range(0, len(pose_indeces) - 1):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 38.65176127696633}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench.keys():\n        if start_time <= time <= end_time:\n            collision_times.append(time)\n    return collision_times\n", "CodeBleu_score": 38.52744048736682}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n  def get_collision_times_list(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times_list, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n  def get_collision_times_array(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times_array, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision", "CodeBleu_score": 38.292007388700874}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for collision in self.wrench:\n        if start_time <= collision.time <= end_time:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 37.93512643360498}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    absolute_settling_time = start_time + rospy.Duration(settling_time)\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 30.795088063195063}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n\n    absolute_settling_time = start_time + rospy.Duration(settling_time)\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 32.77914463490087}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 21.963783998164637}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate the multiplier\n  const float multiplier = 1000.0f / depth_scale_;\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_map(data, width * height);\n\n  // Calculate the RMS noise\n  const float rms_noise =\n      std::sqrt(std::pow(noise_std_dev_, 2) / (width * height));\n\n  // Apply noise to each pixel\n  for (uint32_t y = 0; y < height; y++) {\n    for (uint32_t x = 0; x < width; x++) {\n      const uint32_t pixel_index = y * width + x;\n      const float depth_value = data_map(pixel_index);\n\n      // If the pixel is in range\n      if (depth_value > 0) {\n        // Add noise to the pixel\n        data_map(pixel_index) =\n            depth_value +\n            (depth_value * (rms_noise * std::rand() / RAND_MAX) * multiplier);\n      } else {\n        // Set the pixel to a bad point value\n        data_map(pixel_index) = 0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 47.597591148976086}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n\n  Eigen::Map<Eigen::VectorXf> map(data, width * height);\n\n  // Calculate the multiplier based on camera parameters\n  float multiplier =\n      (float)(255.0 / (16.0 * depth_scale_ * depth_scale_ * depth_scale_));\n\n  // Get the RMS noise\n  float rms_noise = GetRMSNoise();\n\n  // Get the noise values\n  float noise_values[256];\n  GetNoiseValues(noise_values);\n\n  // Apply noise\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (map(i) > 0 && map(i) < 255) {\n      map(i) += (float)noise_values[map(i)] * multiplier * rms_noise;\n    } else {\n      map(i) = 0;\n    }\n  }\n}\n", "CodeBleu_score": 52.15450627992722}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate the multiplier based on the camera parameters\n  const float multiplier = 1.0f / (2.0f * 1000.0f);\n\n  // Map the data to an Eigen vector\n  Eigen::Map<Eigen::VectorXf> data_vec(data, width * height);\n\n  // Calculate the RMS noise\n  const float rms_noise = sqrt(2.0f * m_noise_variance);\n\n  // For each pixel, add noise if the pixel value is in range, otherwise set the\n  // pixel to a bad point value\n  for (uint32_t i = 0; i < width * height; i++) {\n    if (data_vec(i) > 0.0f && data_vec(i) < 4.0f) {\n      data_vec(i) += (m_rng() - 0.5f) * rms_noise * multiplier;\n    } else {\n      data_vec(i) = 0.0f;\n    }\n  }\n}\n", "CodeBleu_score": 43.02541537358094}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Retrieve the current simulation time.\n  common::Time current_sim_time = world_->GetSimTime();\n\n  // Convert the current simulation time to ROS time.\n  ros::Time current_ros_time = ros::Time(current_sim_time.sec,\n                                         current_sim_time.nsec);\n\n  // Write the trajectory message to the bag file using the specified namespace\n  // and waypoint topic.\n  bag_.write(namespace_ + \"/\" + waypoint_topic_, current_ros_time,\n             *trajectory_msg);\n}\n", "CodeBleu_score": 59.269529609298196}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get the current simulation time\n  common::Time current_time = world->GetSimTime();\n\n  // Convert the current simulation time to ROS time\n  ros::Time ros_time(current_time.sec, current_time.nsec);\n\n  // Write the trajectory message to a bag file using the specified namespace and waypoint topic\n  trajectory_pub.publish(trajectory_msg);\n  trajectory_bag.write(namespace_ + \"/\" + waypoint_topic_, ros_time,\n                      trajectory_msg);\n}\n", "CodeBleu_score": 58.42259747050098}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get the current simulation time\n  common::Time current_sim_time = world_->GetSimTime();\n\n  // Convert the current simulation time to ROS time\n  ros::Time current_ros_time = ros::Time(current_sim_time.sec,\n                                         current_sim_time.nsec);\n\n  // Write the trajectory message to the bag file using the specified namespace\n  // and waypoint topic\n  rosbag_->write(namespace_ + \"/\" + waypoint_topic_, current_ros_time,\n                 *trajectory_msg);\n}\n", "CodeBleu_score": 59.2844553139956}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)  // Convert simulation time to ROS time\n  ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n  // Create a message for the motor velocities\n  gazebo_msgs::Actuators actuators;\n  actuators.header.stamp = ros_now;\n\n  // Iterate through the motor joints and calculate the slowed-down rotational velocities\n  for (unsigned int i = 0; i < motor_joints_.size(); i++) {\n    // Calculate the slowed-down rotational velocities\n    double rotational_velocity = motor_joints_[i]->GetVelocity(0);\n    rotational_velocity = rotational_velocity * slowdown_factor_;\n\n    // Assign the slowed-down rotational velocities to the message\n    actuators.actuators.push_back(rotational_velocity);\n  }\n\n  // Write the data to a bag file\n  actuators_pub_.publish(actuators);\n}\n", "CodeBleu_score": 45.964170273430916}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)  // Prepare the message\n  ignition::msgs::Actuator actuator_msg;\n  actuator_msg.set_name(\"motors\");\n  actuator_msg.set_id(0);\n\n  // Iterate through the motors and calculate the slowed-down rotational velocities\n  for (unsigned int i = 0; i < this->motorJoints.size(); i++) {\n    actuator_msg.add_position(this->motorJoints[i]->GetVelocity(0) * this->motorVelocityCoefficients[i]);\n  }\n\n  // Set the message timestamp\n  actuator_msg.mutable_header()->mutable_stamp()->set_sec(now.sec);\n  actuator_msg.mutable_header()->mutable_stamp()->set_nsec(now.nsec);\n\n  // Write the message to the bag file\n  this->actuator_pub.publish(actuator_msg);\n}\n", "CodeBleu_score": 30.88874429689256}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)    // Convert Gazebo time to ROS time\n    ros::Time ros_now = ros::Time(now.sec, now.nsec);\n\n    // Prepare the message\n    sensor_msgs::JointState motor_msg;\n    motor_msg.header.stamp = ros_now;\n\n    // Iterate through the motor joints and calculate the slowed-down rotational velocities\n    for (unsigned int i = 0; i < this->motor_joints.size(); i++) {\n        // Calculate the slowed-down rotational velocities\n        double slowed_down_vel = this->motor_joints[i]->GetVelocity(0) / this->motor_velocity_slowdown_factor;\n\n        // Assign the slowed-down rotational velocities to the message\n        motor_msg.name.push_back(this->motor_joints[i]->GetName());\n        motor_msg.velocity.push_back(slowed_down_vel);\n    }\n\n    // Write the data to a bag file using the specified namespace and motor topic\n    this->motor_pub.publish(motor_msg);\n}\n", "CodeBleu_score": 43.893776097146954}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll * kMaxRollAngle;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch * kMaxPitchAngle;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate * kMaxYawRate;\n\n  // Set the throttle value\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Set the control surface angles\n  SetControlSurfaceAngles(roll_angle, pitch_angle, yaw_rate, throttle);\n}\n", "CodeBleu_score": 34.455456533347785}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  // If debug printing is enabled, log that the callback was called\n  if (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called.\\n\";\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to\n  // control surface angles for ailerons, elevator, and rudder respectively.\n  // Also set the throttle value from the thrust message.\n  double roll = roll_pitch_yawrate_thrust_msg->roll;\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate;\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust;\n\n  double aileron = roll * aileron_max_;\n  double elevator = -pitch * elevator_max_;\n  double rudder = yaw_rate * rudder_max_;\n\n  // Set the control surface angles for ailerons, elevator, and rudder\n  // respectively.\n  aileron_joint_->SetForce(0, aileron);\n  elevator_joint_->SetForce(0, elevator);\n  rudder_joint_->SetForce(0, rudder);\n\n  // Set the throttle value\n  throttle_joint_->SetForce(0, thrust);\n}\n", "CodeBleu_score": 40.77470864286976}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_) {\n    gzdbg << \"RollPitchYawrateThrustCallback called.\\n\";\n  }\n\n  // Convert normalized roll, pitch, and yaw rate to control surface angles.\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate;\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Convert normalized control surface angles to radians.\n  roll_angle = roll_angle * kMaxRollAngle;\n  pitch_angle = pitch_angle * kMaxPitchAngle;\n  yaw_rate = yaw_rate * kMaxYawRate;\n\n  // Set the control surface angles.\n  SetControlSurfaceAngles(roll_angle, pitch_angle, yaw_rate, thrust);\n}\n", "CodeBleu_score": 42.21886508517656}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // convert timeout to timeval\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // poll for new data\n  fd_set read_fds;\n  FD_ZERO(&read_fds);\n  FD_SET(this->mavlink_fd, &read_fds);\n  int ready_fds = pselect(this->mavlink_fd + 1, &read_fds, NULL, NULL, &timeout,\n                         NULL);\n  if (ready_fds == -1) {\n    gzerr << \"pselect failed with error \" << strerror(errno) << std::endl;\n    return;\n  }\n\n  // receive data\n  if (ready_fds > 0) {\n    uint8_t buf[MAVLINK_MAX_PACKET_LEN];\n    int len = read(this->mavlink_fd, buf, MAVLINK_MAX_PACKET_LEN);\n    if (len <= 0) {\n      gzerr << \"Error reading from mavlink fd\" << std::endl;\n      return;\n    }\n    mavlink_message_t msg;\n    for (int i = 0; i < len; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &this->status)) {\n        // handle message\n        handleMAVLinkMessage(&msg);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 50.92597249067603}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // Create a timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Poll for new messages\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->mavlink_fd, &fds);\n  int n = select(this->mavlink_fd + 1, &fds, NULL, NULL, &timeout);\n\n  if (n < 0) {\n    gzerr << \"select error\" << std::endl;\n    return;\n  }\n\n  if (n == 0) {\n    return;\n  }\n\n  // Receive data\n  char buf[MAVLINK_MAX_PACKET_LEN];\n  ssize_t nBytes = recv(this->mavlink_fd, buf, MAVLINK_MAX_PACKET_LEN, 0);\n\n  if (nBytes <= 0) {\n    gzerr << \"recv error\" << std::endl;\n    return;\n  }\n\n  // Parse messages\n  mavlink_message_t message;\n  for (unsigned i = 0; i < nBytes; i++) {\n    if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &message, &this->status)) {\n      this->handleMAVLinkMessage(&message);\n    }\n  }\n}\n", "CodeBleu_score": 51.26541767139883}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // Get the current time\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  // Convert the timeout to a timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs - timeout.tv_sec * 1000) * 1000;\n  // Set up the file descriptor set\n  fd_set fds;\n  FD_ZERO(&fds);\n  FD_SET(this->serialReadFd, &fds);\n  // Poll for data\n  int readyFds = pselect(this->serialReadFd + 1, &fds, NULL, NULL, &timeout,\n                         NULL);\n  // If data is available, receive it\n  if (readyFds > 0) {\n    // Get the current time\n    gettimeofday(&tv, NULL);\n    // Receive data\n    int n = read(this->serialReadFd, this->buffer, this->bufferLength);\n    if (n < 0) {\n      gzerr << \"Error reading from serial port: \" << strerror(errno) << \"\\n\";\n    } else if (n == 0) {\n      gzerr << \"Serial port disconnected.\\n\";\n    } else {\n      // Parse MAVLink messages\n      for (unsigned i = 0; i < n; i++) {\n        if (mavlink_parse_char(MAVLINK_COMM_0, this->buffer[i],\n                               &this->mavlink_status, &this->mavlink_message)) {\n          // Handle the message\n          this->handleMAVLinkMessage(&this->mavlink_message, &tv);\n        }\n      }\n    }\n  }\n}\n", "CodeBleu_score": 46.90800606777148}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close()   if (is_open_) {\n    // Stop the I/O service\n    io_service_.stop();\n\n    // Close the serial port\n    serial_port_.close();\n\n    // Join the I/O thread to clean up resources\n    if (io_thread_.joinable())\n      io_thread_.join();\n\n    is_open_ = false;\n  }\n}\n", "CodeBleu_score": 63.42672976633554}, {"code": "void GazeboMavlinkInterface::close()   boost::mutex::scoped_lock lock(mutex_);\n  if (opened_) {\n    // Stop the I/O service.\n    io_service_.stop();\n    // Close the serial device.\n    serial_.close();\n    opened_ = false;\n  }\n  // If the I/O thread is joinable, join it to clean up resources.\n  if (io_thread_.joinable()) {\n    io_thread_.join();\n  }\n}\n", "CodeBleu_score": 59.58160032936116}, {"code": "void GazeboMavlinkInterface::close()   boost::mutex::scoped_lock lock(mutex_);\n  if (opened_) {\n    // Stop the I/O service\n    io_service_.stop();\n\n    // Close the serial port\n    serial_port_.close();\n\n    // Join the thread to clean up resources\n    if (io_thread_.joinable()) {\n      io_thread_.join();\n    }\n\n    opened_ = false;\n  }\n}\n", "CodeBleu_score": 58.70226934914402}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation  ignition::math::Vector3d p0, p1, v0, v1, t;\n  double t0, t1, t_interp;\n\n  t0 = p0.X();\n  t1 = p1.X();\n  t_interp = t.X();\n\n  return (v0 + (v1 - v0) * (t_interp - t0) / (t1 - t0));\n}\n", "CodeBleu_score": 30.66376669928492}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    const ignition::math::Vector3d& _pos,\n    const ignition::math::Vector3d& _p0,\n    const ignition::math::Vector3d& _p1,\n    const ignition::math::Vector3d& _v0,\n    const ignition::math::Vector3d& _v1\n} {\n    // Calculate the distance between the two points\n    double d = _p1.Distance(_p0);\n\n    // Calculate the distance between the two points and the current position\n    double d0 = _pos.Distance(_p0);\n\n    // Calculate the distance between the two points and the current position\n    double d1 = _pos.Distance(_p1);\n\n    // Calculate the percentage of the distance between the two points and the current position\n    double p0 = d0 / d;\n\n    // Calculate the percentage of the distance between the two points and the current position\n    double p1 = d1 / d;\n\n    // Calculate the interpolated value between the two points\n    ignition::math::Vector3d result = _v0 + ((_v1 - _v0) * p0);\n\n    return result;\n}\n", "CodeBleu_score": 37.732604275779174}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation  ignition::math::Vector3d pos,\n  ignition::math::Vector3d pos1,\n  ignition::math::Vector3d pos2,\n  ignition::math::Vector3d val1,\n  ignition::math::Vector3d val2\n}", "CodeBleu_score": 24.464290535514785}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)\tif (this->time == _time) {\n\t\treturn;\n\t}\n\n\tthis->time = _time;\n\n\tif (this->looping) {\n\t\tthis->time = fmod(this->time, this->length);\n\t} else {\n\t\tthis->time = Math::Clamp(this->time, 0.0, this->length);\n\t}\n\n\tthis->UpdateTime();\n}\n", "CodeBleu_score": 45.25181925066297}, {"code": "void Animation::SetTime(double _time)\tif (this->time == _time) {\n\t\treturn;\n\t}\n\tthis->time = _time;\n\tthis->UpdateTime();\n}\n", "CodeBleu_score": 35.24251282231373}, {"code": "void Animation::SetTime(double _time)    if (this->time == _time) {\n        return;\n    }\n\n    this->time = _time;\n    this->UpdateTime();\n}\n", "CodeBleu_score": 35.88338635366903}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n    self.coordinate_frame = 1\n    self.motion_type = 0\n    self.target_motion = self.target_motion_from_position(self.position)\n    print(f\"Vehicle type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight mode: {self.flight_mode}\")\n\n", "CodeBleu_score": 48.91719792632076}, {"code": "def hover(self)\n    # Set coordinate frame to local\n    self.set_coordinate_frame(0)\n    # Set motion type to takeoff\n    self.set_motion_type(0)\n    # Create target motion using current position and yaw\n    target_motion = self.get_position()\n    target_motion.yaw = self.get_yaw()\n    # Set target motion\n    self.set_target_motion(target_motion)\n    # Print vehicle type, ID, and flight mode\n    print(\"Vehicle type: \" + str(self.get_vehicle_type()))\n    print(\"Vehicle ID: \" + str(self.get_vehicle_id()))\n    print(\"Flight mode: \" + str(self.get_flight_mode()))\n", "CodeBleu_score": 22.170674093367996}, {"code": "def hover(self)\n    self.coordinate_frame = mavutil.mavlink.MAV_FRAME_LOCAL_NED\n    self.motion_type = mavutil.mavlink.MAV_MOUNT_MODE_GIMBAL\n    self.target_system = self.target_system\n    self.target_component = self.target_component\n    self.mav.mav.command_long_send(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_DO_MOUNT_CONTROL, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.mav.mav.command_long_send(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_DO_MOUNT_CONTROL, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.mav.mav.command_long_send(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_DO_MOUNT_CONTROL, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.mav.mav.command_long_send(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_DO_MOUNT_CONTROL, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.mav.mav.command_long_send(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_DO_MOUNT_CONTROL, 0, 0, 0, 0, 0, 0, 0, 0)\n    self.mav.mav.command_long_send(self.target_system, self.target_component, mavutil.mavlink.MAV_CMD_DO_MOUNT_CONTROL, 0,", "CodeBleu_score": 9.061793457136638}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      self.flight_mode = 'HOVER'\n      rospy.wait_for_service('flight_mode_service')\n      flight_mode_service = rospy.ServiceProxy('flight_mode_service', FlightMode)\n      flight_mode_service(self.flight_mode)\n      if self.flight_mode == 'HOVER':\n        rospy.loginfo(\"Flight mode successfully switched to HOVER\")\n        return True\n      else:\n        rospy.logwarn(\"Flight mode switch to HOVER failed\")\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the hover flag to 1 and calls the hover method.\"\"\"\n    self.hover_flag = 1\n    self.hover_service()\n\n  def hover_service(self):\n    \"\"\"This function, hover_service, attempts to set the hover flag to 1 using hoverService.\\nIt prints a success message if the hover flag is set, and a failure message otherwise.\"\"\"\n    rospy.wait_for_service('hover_service')\n    hover_service = rospy.ServiceProxy('hover_service', Hover)\n    hover_service(self.hover_flag)\n    if self.hover_flag == 1:\n      rospy.loginfo(\"Hover flag successfully set to 1\")\n    else:\n      rospy.logwarn(\"Hover flag set to 1 failed\")\n\n  def land(self):\n    \"\"\"This function, land, attempts to land the vehicle using landService.\\nIt prints a success message if the land command is sent, and a failure message otherwise.\"\"\"\n    rospy.wait_for_service('land_service')\n    land_service = rospy.ServiceProxy('land_service', Land)\n    land_service()\n    rospy.loginfo(\"Land command sent\")\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, attempts to takeoff the vehicle using takeoffService.\\nIt prints a success message if the takeoff command is sent, and a failure message otherwise.\"", "CodeBleu_score": 33.18145188273366}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      mode_service = rospy.ServiceProxy('/mavros/set_mode', mavros_msgs.srv.SetMode)\n      mode_service(custom_mode=self.flight_mode)\n      rospy.sleep(1)\n      if self.flight_mode == 'OFFBOARD':\n        return True\n      else:\n        if self.flight_mode == 'STABILIZED':\n          mode = 'STABILIZED'\n        elif self.flight_mode == 'GUIDED':\n          mode = 'GUIDED'\n        elif self.flight_mode == 'ALTCTL':\n          mode = 'ALTCTL'\n        elif self.flight_mode == 'POSCTL':\n          mode = 'POSCTL'\n        else:\n          mode = 'MANUAL'\n        if self.flight_mode == 'ALTCTL' or self.flight_mode == 'POSCTL':\n          if self.flight_mode == 'ALTCTL':\n            mode_service(custom_mode='ALTCTL')\n          elif self.flight_mode == 'POSCTL':\n            mode_service(custom_mode='POSCTL')\n          rospy.sleep(1)\n          if self.flight_mode == 'ALTCTL':\n            mode = 'ALTCTL'\n          elif self.flight_mode == 'POSCTL':\n            mode = 'POSCTL'\n          if self.flight_mode == 'ALTCTL' or self.flight_mode == 'POSCTL':\n            if self.flight_mode == 'ALTCTL':\n              mode_service(custom_mode='ALTCTL')\n            elif self.flight_mode == 'POSCTL':\n              mode_service(custom_mode='POSCTL')\n            rospy.sleep(1)\n            if self.flight_mode == 'ALTCTL':\n              mode = 'ALTCTL'\n            elif self.flight_mode", "CodeBleu_score": 30.467817631093407}, {"code": "def flight_mode_switch(self)\n    # Check if the mode is HOVER\n    if self.flight_mode == 'HOVER':\n      # Set the hover flag to 1\n      self.hover = 1\n      # Call the hover method\n      self.hover()\n      # Print a success message\n      print(\"Hover mode activated\")\n      # Return True\n      return True\n    # If the mode is not HOVER, attempt to switch modes using flightModeService\n    else:\n      # Create a mode switch service message\n      mode_switch = FlightModeServiceRequest()\n      # Set the mode switch service message to the desired flight mode\n      mode_switch.base_mode = self.flight_mode\n      # Call the flightModeService to switch modes\n      self.flightModeService(mode_switch)\n      # If the mode switch succeeds, print a success message and return True\n      if mode_switch.mode_sent:\n        print(\"Mode change successful\")\n        return True\n      # If the mode switch fails, print a failure message and return False\n      else:\n        print(\"Mode change failed\")\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sends a hover command to the vehicle.\\nIt calls the hoverService to send the hover command.\\nIt prints a success message if the command is sent successfully, and a failure message otherwise.\\nThe function returns True if the command is sent successfully, and False if it fails.\"\"\"\n    # Create a hover service message\n    hover = HoverServiceRequest()\n    # Set the hover service message to 1\n    hover.enable = 1\n    # Call the hoverService to send the hover command\n    self.hoverService(hover)\n    # If the hover command is sent successfully, print a success message and return True\n    if hover.is_hovering:\n      print(\"Hover command sent\")\n      return True\n    # If the hover command fails, print a failure message and return False\n    else:\n      print(\"Hover command failed\")\n      return False\n\n  def arm(self):\n    \"\"\"This function, arm, arms the vehicle.\\nIt calls the armService to arm the vehicle.\\nIt prints a success message if the vehicle is armed, and a failure message otherwise.\\nThe function returns True if the", "CodeBleu_score": 32.22943839330771}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    # TODO: This function is not yet implemented\n    # TODO: Implement this function\n    # TODO: Implement the hover_state_transition function\n    # TODO: Implement the hold_state_transition function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set_motion_type function\n    # TODO: Implement the set_coordinate_frame function\n    # TODO: Implement the set_target_motion function\n    # TODO: Implement the set", "CodeBleu_score": 1.031650641025641}, {"code": "def cmd_vel_enu_callback(self, msg)\n\n    # Check if the hover flag is set. If so, call hover_state_transition.\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n\n    # Check if the hold flag is set. If so, call hold_state_transition.\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n\n    # If neither flag is set, set the motion type to 1, and construct the target motion using the message components.\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = np.array([msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z])\n", "CodeBleu_score": 55.964523448943915}, {"code": "def cmd_vel_enu_callback(self, msg)\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n    # TODO: add a check to make sure the message is valid\n   ", "CodeBleu_score": 1.031650641025641}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.hover_action()\n\n    elif self.hover_flag == 1:\n        if x < 0.01 and y < 0.01 and z < 0.01 and w < 0.002:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.hover_action()\n", "CodeBleu_score": 52.5165148594971}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.set_flight_mode()\n        else:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.set_flight_mode()\n            self.hover_action()\n    else:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.flight_mode = 'OFFBOARD'\n            self.set_flight_mode()\n        else:\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.set_flight_mode()\n            self.hover_action()\n", "CodeBleu_score": 43.760863839456306}, {"code": "def hover_state_transition(self, x, y, z, w)\n\n    # If any of the x, y, z values exceed 0.02 or w exceeds 0.005, it sets hover_flag to 0 and changes the flight mode to 'OFFBOARD'.\n    if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n\n    # If the flight mode is not \"HOVER\" and the conditions are met, it sets hover_flag to 1, changes the flight mode to 'HOVER', and initiates the hover action.\n    elif self.hover_flag == 0 and self.flight_mode != 'HOVER':\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.hover()\n", "CodeBleu_score": 56.91037687714369}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        yaw = q.yaw()\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw()\n    return yaw\n\n", "CodeBleu_score": 32.150643864703724}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n\n", "CodeBleu_score": 17.485641283375248}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    self.coordinate_frame = mavutil.mavlink.MAV_FRAME_LOCAL_NED\n    self.motion_type = mavutil.mavlink.MAV_MOUNT_MODE_MAVLINK_TARGETING\n    self.target_system = self.vehicle.target_system\n    self.target_component = self.vehicle.target_component\n    self.msg.target_system = self.vehicle.target_system\n    self.msg.target_component = self.vehicle.target_component\n    self.msg.type_mask = self.vehicle.type_mask\n    self.msg.x = 0\n    self.msg.y = 0\n    self.msg.z = 0\n    self.msg.yaw = self.vehicle.attitude.yaw\n    self.msg.pitch = 0\n    self.msg.roll = 0\n    self.msg.pitch_speed = 0\n    self.msg.yaw_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = 0\n    self.msg.pitch_speed = 0\n    self.msg.roll_speed = ", "CodeBleu_score": 19.881366374174345}, {"code": "def hover(self)\n\n    # Set coordinate frame to local\n    self.coordinate_frame = mavutil.mavlink.MAV_FRAME_LOCAL_NED\n\n    # Set motion type to hover\n    self.motion_type = mavutil.mavlink.MAV_MOUNT_MODE_MAVLINK_TARGETING\n\n    # Create target motion using the current position and yaw values\n    self.target_motion = mavutil.mavlink.MAVLink_mount_control_encode(\n        self.target_system, self.target_component, self.motion_type,\n        self.coordinate_frame, self.x, self.y, self.z, self.yaw)\n\n    # Print vehicle type, vehicle ID, and flight mode\n    print(f'Vehicle Type: {self.vehicle_type}')\n    print(f'Vehicle ID: {self.vehicle_id}')\n    print(f'Flight Mode: {self.flight_mode}')\n\n", "CodeBleu_score": 22.10935963108538}, {"code": "def hover(self)\n    # Set coordinate frame to local NED\n    self.set_coordinate_frame()\n\n    # Set motion type to \"motion-hover\"\n    self.set_motion_type()\n\n    # Construct a target motion using the current position and yaw\n    target_motion = self.get_target_motion()\n\n    # Print vehicle type, vehicle ID, and flight mode\n    print(\"Vehicle type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight mode:\", self.flight_mode)\n\n    return target_motion\n\n", "CodeBleu_score": 22.68904590230561}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n    # Set the hover flag if the mode is HOVER\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover_mode()\n\n    # If the mode is not HOVER, attempt to switch the flight mode\n    else:\n        # Create a FlightModeService message\n        flight_mode_service = FlightModeService()\n        # Set the flight mode\n        flight_mode_service.value = self.flight_mode\n        # Call the flight mode service\n        self.flight_mode_service(flight_mode_service)\n        # If the service returns a response, print the new flight mode and return True\n        if self.flight_mode_service.success:\n            print('Flight mode switched to: ' + self.flight_mode)\n            return True\n        # Otherwise, print a failure message and return False\n        else:\n            print('Flight mode switch failed')\n            return False\n\n", "CodeBleu_score": 34.02917611789169}, {"code": "def flight_mode_switch(self)\n\n    # Switch to HOVER mode\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n\n    # Switch to any other mode\n    else:\n        # Get the service\n        flight_mode_service = rospy.ServiceProxy('mavros/set_mode', SetMode)\n\n        # Set the flight mode\n        flight_mode_service(custom_mode=self.flight_mode)\n\n        # Check if the flight mode was changed\n        if self.flight_mode == self.get_flight_mode():\n            print('Flight mode changed to:', self.flight_mode)\n            return True\n        else:\n            print('Flight mode change failed!')\n            return False\n\n", "CodeBleu_score": 38.68640675930642}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover()\n    else:\n        self.flight_mode = self.flight_mode_service(self.flight_mode)\n        if self.flight_mode == '':\n            print('Flight mode switch failed')\n            return False\n        else:\n            print('Flight mode changed to {}'.format(self.flight_mode))\n            return True\n", "CodeBleu_score": 38.287046929245285}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward by multiplying the reward for each assignment by the number of times that assignment is in the algorithm.\\nIt then returns the total reward.\"\"\"\n    total_reward = 0\n    for assignment in self.algorithm:\n      if assignment in self.assignment:\n        total_reward += self.reward[assignment] * self.algorithm.count(assignment)\n    return total_reward\n\n  def visualize(self):\n    \"\"\"This function, visualize, prints the assignment, algorithm, play, and rond attributes to the terminal.\"\"\"\n    print('Assignment:', self.assignment)\n    print('Algorithm:', self.algorithm)\n    print('Play:', self.play)\n    print('Rond:', self.rond)\n\n", "CodeBleu_score": 44.24262194653725}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward.\\nIt calls the get_reward method for each agent and adds the reward to the total reward.\\nIt then returns the total reward.\"\"\"\n    total_reward = 0\n    for agent in self.agents:\n      total_reward += agent.get_reward(self.assignment, self.algorithm, self.play, self.rond)\n    return total_reward\n\n  def visualize(self):\n    \"\"\"This function, visualize, displays the agents in the environment.\"\"\"\n    plt.figure()\n    plt.title(\"Visualization of the environment\")\n    plt.xlim(0, self.width)\n    plt.ylim(0, self.height)\n    plt.xlabel(\"X\")\n    plt.ylabel(\"Y\")\n    for agent in self.agents:\n      plt.scatter(agent.x, agent.y, s=50, c=\"red\")\n    plt.show()\n\n  def __str__(self):\n    \"\"\"This function, __str__, returns a string representation of the environment.\"\"\"\n    return \"Environment(width=\" + str(self.width) + \", height=\" + str(self.height) + \", agents=\" + str(self.agents) + \")\"\n\n  def __repr__(self):\n    \"\"\"This function, __repr__, returns a string representation of the environment.\"\"\"\n    return \"Environment(width=\" + str(self.width) + \", height=\" + str(self.height) + \", agents=\" + str(self.agents) + \")\"\n\n", "CodeBleu_score": 46.96614573287319}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward for the agent.\\nIt first calculates the reward for each step in the play.\\nIt then sums the rewards for each step and returns the total reward.\"\"\"\n    reward = 0\n    for step in range(len(self.play)):\n      reward += self.get_reward(step)\n    return reward\n\n  def get_reward(self, step):\n    \"\"\"This function, get_reward, calculates the reward for a given step in the play.\\nIt first calculates the reward for the given step.\\nIt then calculates the reward for the given step and the previous step.\\nIt then calculates the reward for the given step and the next step.\\nIt then returns the sum of the rewards for the given step and the previous step and the next step.\"\"\"\n    reward = self.get_step_reward(step)\n    if step > 0:\n      reward += self.get_step_reward(step-1)\n    if step < len(self.play) - 1:\n      reward += self.get_step_reward(step+1)\n    return reward\n\n  def get_step_reward(self, step):\n    \"\"\"This function, get_step_reward, calculates the reward for a given step in the play.\\nIt first calculates the reward for the given step.\\nIt then calculates the reward for the given step and the previous step.\\nIt then calculates the reward for the given step and the next step.\\nIt then returns the sum of the rewards for the given step and the previous step and the next step.\"\"\"\n    reward = self.get_step_reward_for_step(step)\n    if step > 0:\n      reward += self.get_step_reward_for_step(step-1)\n    if step < len(self.play)", "CodeBleu_score": 41.70520357604667}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n    if msg.id == i:\n        self.local_pose = msg\n        if self.gcs_command == 1:\n            self.takeoff_target_pose = msg\n            self.hover_target_pose = msg\n        elif self.gcs_command == 2:\n            self.hover_target_pose = msg\n        elif self.gcs_command == 3:\n            self.hover_target_pose = msg\n            self.takeoff_target_pose = msg\n        elif self.gcs_command == 4:\n            self.takeoff_target_pose = msg\n        elif self.gcs_command == 5:\n            self.hover_target_pose = msg\n        self.global_pose.position.x = self.local_pose.position.x + self.x_bias\n        self.global_pose.position.y = self.local_pose.position.y + self.y_bias\n        self.global_pose.position.z = self.local_pose.position.z + self.z_bias\n        self.global_pose.orientation = self.local_pose.orientation\n", "CodeBleu_score": 21.661826223916496}, {"code": "def local_pose_callback(self, msg, i)\n    if msg.id == self.id:\n      self.local_pose = msg\n      # update the takeoff target pose\n      if self.takeoff_target_pose is not None:\n        self.takeoff_target_pose.position.x = msg.position.x + self.takeoff_target_pose.position.x\n        self.takeoff_target_pose.position.y = msg.position.y + self.takeoff_target_pose.position.y\n        self.takeoff_target_pose.position.z = msg.position.z + self.takeoff_target_pose.position.z\n      # update the hover target pose\n      if self.hover_target_pose is not None:\n        self.hover_target_pose.position.x = msg.position.x + self.hover_target_pose.position.x\n        self.hover_target_pose.position.y = msg.position.y + self.hover_target_pose.position.y\n        self.hover_target_pose.position.z = msg.position.z + self.hover_target_pose.position.z\n      # update the global pose\n      self.global_pose.position.x = msg.position.x + self.global_pose.position.x\n      self.global_pose.position.y = msg.position.y + self.global_pose.position.y\n      self.global_pose.position.z = msg.position.z + self.global_pose.position.z\n\n  def global_pose_callback(self, msg, i):\n    \"\"\"This function, global_pose_callback, updates the UAV's global pose based on incoming messages.\\nIf the message index matches the UAV ID, it sets the global_pose to the message.\\nIt also updates the local_pose for the UAV, applying a bias to the position coordinates.\"\"\"\n    if msg.id == self.id:\n      self.global_pose = msg\n      # update the local pose\n      self.local_pose.position.x = msg.position.x - self.local_pose.position.x\n      self.local_pose.position.y = msg.position.y - self.local_pose.position.y\n", "CodeBleu_score": 20.176949459406003}, {"code": "def local_pose_callback(self, msg, i)\n    if i == self.uav_id:\n      self.local_pose = msg\n    if self.gcs_command == 'takeoff':\n      self.takeoff_target_pose = msg\n    elif self.gcs_command == 'hover':\n      self.hover_target_pose = msg\n    self.global_pose.position.x = msg.position.x + self.local_pose.position.x\n    self.global_pose.position.y = msg.position.y + self.local_pose.position.y\n    self.global_pose.position.z = msg.position.z + self.local_pose.position.z\n\n  def gcs_callback(self, msg):\n    \"\"\"This function, gcs_callback, updates the GCS command based on incoming messages.\"\"\"\n    self.gcs_command = msg.data\n\n  def publish_pose(self):\n    \"\"\"This function, publish_pose, publishes the UAV's pose to the /uav_pose topic.\"\"\"\n    self.uav_pose_pub.publish(self.global_pose)\n\n  def publish_command(self):\n    \"\"\"This function, publish_command, publishes the UAV's command to the /uav_command topic.\"\"\"\n    self.uav_command_pub.publish(self.uav_command)\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, updates the UAV's takeoff_target_pose, hover_target_pose, and global_pose.\"\"\"\n    self.takeoff_target_pose.position.z = self.local_pose.position.z + self.takeoff_altitude\n    self.hover_target_pose.position.z = self.local_pose.position.z + self.takeoff_altitude\n    self.global_pose.position.z = self.local_pose.position.z + self.takeoff_altitude\n\n  def hover(self):\n    \"\"\"This function, hover, updates the UAV's hover_target_pose and global_pose.\"\"\"\n    self.hover_target_pose.position.z = self.local_pose.position.z + self.hover_altitude", "CodeBleu_score": 23.445238501445456}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n        return True\n    else:\n        return False\n", "CodeBleu_score": 62.862379601652705}, {"code": "def takeoff_detection(self)\n    if self.uav_state.arm_state == mavros_msgs.msg.State.ARMED and self.uav_state.position_z > 0.2:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 54.84297702004359}, {"code": "def takeoff_detection(self)\n    if self.arm_state == 'active':\n        if self.altitude > 0.2:\n            return True\n        else:\n            return False\n    else:\n        return False\n", "CodeBleu_score": 60.03719435848858}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    # Build the distance matrix\n    dist_matrix = np.zeros((orig_formation.num_uavs, change_formation.num_uavs))\n    for i in range(orig_formation.num_uavs):\n        for j in range(change_formation.num_uavs):\n            dist_matrix[i, j] = int(50 - np.linalg.norm(orig_formation.uav_positions[i] - change_formation.uav_positions[j]))\n\n    # Return the distance matrix\n    return dist_matrix\n", "CodeBleu_score": 24.36482402181059}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # Create a graph for the original formation\n    graph_orig = nx.Graph()\n    # Add nodes to the graph\n    for i in range(len(orig_formation)):\n        graph_orig.add_node(i)\n    # Add edges to the graph\n    for i in range(len(orig_formation)):\n        for j in range(len(orig_formation)):\n            if i != j:\n                # Calculate the Euclidean distance between the UAVs\n                distance = math.sqrt((orig_formation[i][0] - orig_formation[j][0]) ** 2 + (orig_formation[i][1] - orig_formation[j][1]) ** 2)\n                # Subtract the distance from 50 and convert to an integer\n                distance = int(50 - distance)\n                # Add the edge to the graph\n                graph_orig.add_edge(i, j, weight=distance)\n    # Create a graph for the changed formation\n    graph_change = nx.Graph()\n    # Add nodes to the graph\n    for i in range(len(change_formation)):\n        graph_change.add_node(i)\n    # Add edges to the graph\n    for i in range(len(change_formation)):\n        for j in range(len(change_formation)):\n            if i != j:\n                # Calculate the Euclidean distance between the UAVs\n                distance = math.sqrt((change_formation[i][0] - change_formation[j][0]) ** 2 + (change_formation[i][1] - change_formation[j][1]) ** 2)\n                # Subtract the distance from 50 and convert to an integer\n                distance = int(50 - distance)\n                # Add the edge to the graph\n                graph_change.add_edge(i, j, weight=distance)\n    return graph_orig, graph_change\n", "CodeBleu_score": 22.675541822761808}, {"code": "def build_graph(self, orig_formation, change_formation)\n    dist_mat = np.zeros((orig_formation.n, change_formation.n))\n    for i in range(orig_formation.n):\n        for j in range(change_formation.n):\n            dist = np.linalg.norm(orig_formation.uav_pos[i] - change_formation.uav_pos[j])\n            dist = 50 - dist\n            dist = int(dist)\n            dist_mat[i][j] = dist\n    return dist_mat\n", "CodeBleu_score": 27.96359752063581}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    self.left_visited[i] = True\n    for j in self.right_adjacency[i]:\n        if self.right_visited[j]:\n            continue\n        gap = self.left_label[i] - self.right_label[j]\n        if gap == 0:\n            self.right_visited[j] = True\n            if self.find_path(j):\n                return True\n            self.matching[i] = j\n            self.matching[j] = i\n            return True\n        self.slack[j] = min(self.slack[j], gap)\n    return False\n", "CodeBleu_score": 37.78693597526659}, {"code": "def find_path(self, i)\n    self.visited[i] = True\n    for j in self.adj[i]:\n        if self.visited[j]:\n            continue\n        gap = self.label[i] - self.label[j]\n        if gap == 0:\n            self.visited[j] = True\n            if self.find_path(j):\n                self.match[i] = j\n                self.match[j] = i\n                return True\n            else:\n                self.slack[j] = 0\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 44.004688757860706}, {"code": "def find_path(self, i)\n    self.visited[i] = True\n    for j in self.adj[i]:\n        if self.visited[j]:\n            continue\n        gap = self.label[i] - self.label[j]\n        if gap == 0:\n            self.visited[j] = True\n            if self.find_path(j):\n                return True\n            else:\n                self.match[i] = j\n                self.match[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    return False\n\n", "CodeBleu_score": 43.75018013317733}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n    # Initialize variables\n    label = self.label\n    slack = self.slack\n    slack_min = self.slack_min\n    slack_min_index = self.slack_min_index\n    slack_min_row = self.slack_min_row\n    slack_min_col = self.slack_min_col\n    zero_slack_row = self.zero_slack_row\n    zero_slack_col = self.zero_slack_col\n    visit_row = self.visit_row\n    visit_col = self.visit_col\n    path = self.path\n    path_row = self.path_row\n    path_col = self.path_col\n    # Initialize slack variables\n    for i in range(self.n_row):\n        slack[i,:] = self.c[i,:] - self.b[i,:]\n    # Initialize visit arrays\n    for i in range(self.n_row):\n        visit_row[i] = 0\n    for j in range(self.n_col):\n        visit_col[j] = 0\n    # Iterate over UAVs\n    for i in range(self.n_row):\n        # Initialize slack variables\n        for j in range(self.n_col):\n            slack[i,j] = self.c[i,j] - self.b[i,j]\n        # Initialize visit arrays\n        for j in range(self.n_col):\n            visit_col[j] = 0\n        # Find augmenting path\n        while 1:\n            # Find zero slack values\n            zero_slack_row[0] = 0\n            zero_slack_col[0] = 0\n            k = 0\n            for j in range(self.n_col):\n                if (slack[i,j] == 0) and (visit_col[j] == 0):\n                    zero_slack_row[k] = i\n                    zero_slack_col[k] = j\n                    k = k + 1\n            # If no zero slack values are", "CodeBleu_score": 21.672422252167035}, {"code": "def KM(self)\n    # Initialize the variables\n    self.slack = np.zeros(self.num_uavs)\n    self.visited = np.zeros((self.num_uavs, self.num_uavs))\n\n    # Iterate over the UAVs\n    for u in range(self.num_uavs):\n        # Initialize the slack variables\n        self.slack = np.zeros(self.num_uavs)\n        self.slack[u] = self.slack_init\n\n        # Reset the visited array\n        self.visited = np.zeros((self.num_uavs, self.num_uavs))\n\n        # Find the path\n        self.find_path(u)\n\n        # If no path was found, adjust the labels\n        if self.slack[u] != 0:\n            self.adjust_labels(u)\n\n    # Return the match results\n    return self.match_results\n\n", "CodeBleu_score": 17.98325795288569}, {"code": "def KM(self)\n    self.reset_visit_arrays()\n    self.initialize_slack_variables()\n    while True:\n        # Iterate over all UAVs, find the minimum slack value\n        min_slack_value = float('inf')\n        for uav in range(self.num_uavs):\n            for v in range(self.num_vertices):\n                if self.visit_array[uav][v] == 0 and self.slack_array[uav][v] < min_slack_value:\n                    min_slack_value = self.slack_array[uav][v]\n                    self.min_slack_uav = uav\n                    self.min_slack_v = v\n        # If no path is found, adjust labels based on the minimum slack value\n        if min_slack_value == float('inf'):\n            break\n        # If a path is found, augment the path\n        self.augment_path(self.min_slack_uav, self.min_slack_v)\n        # Update the slack variables\n        for uav in range(self.num_uavs):\n            for v in range(self.num_vertices):\n                if self.visit_array[uav][v] == 0:\n                    self.slack_array[uav][v] = min(self.slack_array[uav][v], self.cost_array[uav][v] - self.label_array[uav][self.matching_array[uav]] + self.label_array[uav][v])\n\n    # Return the match results for the right side of the bipartite graph\n    return self.matching_array\n\n", "CodeBleu_score": 26.874898369788646}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n\n    # Convert to HSV color space and define the range of yellow color in HSV\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Threshold the HSV image to get only yellow colors\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Bitwise-AND mask and original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n", "CodeBleu_score": 29.537592895953964}, {"code": "def yellow_dectection(image)\n    # Convert image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    # Create a mask for the color \"yellow\"\n    lower_yellow = np.array([18, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    # Apply the mask\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 30.50390927875736}, {"code": "def yellow_dectection(image)\n    # Convert to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the HSV boundaries for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([40, 255, 255])\n\n    # Create a mask for the yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image\n    res = cv2.bitwise_and(image, image, mask=mask)\n\n    return res\n\n", "CodeBleu_score": 29.440086488580548}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription    // This function, TagDetector::findStandaloneTagDescription, searches for a standalone tag description by ID.\\nIt checks the standalone_tag_descriptions_ map for the given ID.\\nIf the description is not found and printWarning is true, it logs a warning message.\\nIf found, it sets the descriptionContainer to the tag's description and returns true; otherwise, it returns false.\n    (\n        [this](\n            const std::string & tagID,\n            TagDescription & descriptionContainer,\n            bool printWarning\n        ) -> bool\n        {\n            const auto descriptionIterator = standalone_tag_descriptions_.find(tagID);\n            if (descriptionIterator != standalone_tag_descriptions_.end())\n            {\n                descriptionContainer = descriptionIterator->second;\n                return true;\n            }\n            else if (printWarning)\n            {\n                std::cerr << \"Warning: TagDetector::findStandaloneTagDescription: Could not find tag description for ID \" << tagID << std::endl;\n            }\n            return false;\n        }\n    )\n};\n", "CodeBleu_score": 48.43730212163048}, {"code": "bool TagDetector::findStandaloneTagDescription    (\n        const std::string & id,\n        TagDescriptionContainer & descriptionContainer,\n        bool printWarning\n    ) const {\n        auto it = standalone_tag_descriptions_.find(id);\n        if (it == standalone_tag_descriptions_.end()) {\n            if (printWarning) {\n                std::cerr << \"Warning: Standalone tag description not found for ID \\\"\" << id << \"\\\".\" << std::endl;\n            }\n            return false;\n        }\n        descriptionContainer = it->second;\n        return true;\n    }\n", "CodeBleu_score": 57.99092569341986}, {"code": "bool TagDetector::findStandaloneTagDescription  /*\n   * The function returns true if the standalone tag description is found, false otherwise.\n   */\n  bool found { false };\n\n  /*\n   * Check if the standalone tag description is in the map.\n   */\n  auto search { standalone_tag_descriptions_.find(id) };\n\n  /*\n   * If the description is found, set the descriptionContainer to the description and return true.\n   */\n  if (search != standalone_tag_descriptions_.end()) {\n    descriptionContainer = search->second;\n    found = true;\n  }\n\n  /*\n   * If the description is not found and printWarning is true, log a warning message.\n   */\n  if (!found && printWarning) {\n    ROS_WARN_STREAM(\"[TagDetector] Standalone tag description with ID \" << id << \" not found.\");\n  }\n\n  /*\n   * Return whether the description was found.\n   */\n  return found;\n}\n", "CodeBleu_score": 39.05661064008283}]}
