{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t desc_type;\n\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\n\tnext_desc = desc;\n\twhile (next_desc->bLength != 0) {\n\t\tdesc_type = next_desc->bDescriptorType;\n\t\tif (desc_type == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t UDC_DESC_STORAGE *) next_desc +\n\t\t\t\tnext_desc->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 37.36261679201877}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_conf_desc_t UDC_DESC_STORAGE *next_desc;\n\tuint8_t desc_len;\n\n\tnext_desc = desc;\n\twhile (next_desc->bLength != 0) {\n\t\tdesc_len = next_desc->bLength;\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)\n\t\t\t\t((uint8_t UDC_DESC_STORAGE *) next_desc + desc_len);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 34.00443757360052}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_conf_desc_t UDC_DESC_STORAGE *p = desc;\n\n\twhile (p->bLength) {\n\t\tif (p->bDescriptorType == desc_id) {\n\t\t\treturn p;\n\t\t}\n\t\tp = (usb_conf_desc_t UDC_DESC_STORAGE *) ((uint8_t *) p\n\t\t\t\t+ p->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 25.633524302766503}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tuint8_t *p;\n\tuint8_t i;\n\tuint8_t iface_desc_len;\n\n\t/* Check if there is a valid configuration */\n\tif (!udc_config_valid) {\n\t\treturn false;\n\t}\n\n\t/* Check if the interface number is within bounds */\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\t/* Iterate through the descriptors, starting from the beginning of the configuration descriptor */\n\tp = (uint8_t *) udc_config_desc;\n\tfor (i = 0; i < udc_config_desc->wTotalLength; i++) {\n\t\t/* Check if the descriptor is an interface descriptor */\n\t\tif (*p == USB_DESC_TYPE_INTERFACE) {\n\t\t\t/* Check if the interface number matches */\n\t\t\tif (p[2] == iface_num) {\n\t\t\t\t/* Check if the setting number matches */\n\t\t\t\tif (p[4] == setting_num) {\n\t\t\t\t\t/* Return true if the interface descriptor matches */\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Increment the pointer to the next descriptor */\n\t\tp += p[0];\n\t}\n\n\t/* Return false if no matching interface descriptor was found */\n\treturn false;\n}\n", "CodeBleu_score": 37.42933398437579}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)\tif (udc_config_desc == NULL) {\n\t\treturn false;\n\t}\n\n\tif (iface_num >= udc_config_desc->bNumInterfaces) {\n\t\treturn false;\n\t}\n\n\tuint8_t *desc = (uint8_t *) udc_config_desc;\n\tuint8_t *end = (uint8_t *) udc_config_desc + udc_config_desc->wTotalLength;\n\n\twhile (desc < end) {\n\t\tif (desc[1] == USB_DESC_TYPE_INTERFACE) {\n\t\t\tif (desc[2] == iface_num && desc[4] == setting_num) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdesc += desc[0];\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 36.039948495027005}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)    uint8_t *p;\n    uint8_t *p_end;\n    uint8_t iface_desc_len;\n    uint8_t iface_num_found = 0;\n    uint8_t setting_num_found = 0;\n\n    if (udc_config_desc == NULL) {\n        return false;\n    }\n\n    p = udc_config_desc;\n    p_end = udc_config_desc + udc_config_desc_len;\n    while (p < p_end) {\n        if (p[0] == USB_DESC_TYPE_INTERFACE) {\n            iface_num_found = p[2];\n            iface_desc_len = p[0];\n            setting_num_found = p[4];\n            if ((iface_num_found == iface_num) && (setting_num_found == setting_num)) {\n                return true;\n            }\n        }\n        p += p[0];\n    }\n\n    return false;\n}\n", "CodeBleu_score": 33.588163635437006}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void)\tuint8_t ep_num = (uint8_t)udc_req_std_bRequest;\n\tuint8_t ep_status = 0;\n\n\tif (udc_req_std_wLength != sizeof(ep_status)) {\n\t\treturn false;\n\t}\n\n\tif (udc_is_endpoint_halted(ep_num)) {\n\t\tep_status = 1;\n\t}\n\n\tudc_req_std_data_t data = {\n\t\t.payload = &ep_status,\n\t\t.length = sizeof(ep_status)\n\t};\n\n\tudc_req_std_data(data);\n\treturn true;\n}\n", "CodeBleu_score": 25.073537955415475}, {"code": "static bool udc_req_std_ep_get_status(void)    if (udc_req_std_get_len() != sizeof(uint16_t)) {\n        return false;\n    }\n\n    uint8_t ep = udc_req_std_get_value() & 0x7f;\n    uint16_t status = 0;\n    if (udc_endpoint_halted(ep)) {\n        status = 1;\n    }\n\n    udc_req_std_write(status);\n    return true;\n}\n", "CodeBleu_score": 20.500867358510906}, {"code": "static bool udc_req_std_ep_get_status(void)    uint8_t ep_num;\n    uint8_t ep_status;\n    uint8_t *resp_payload;\n    uint8_t resp_payload_len;\n\n    ep_num = udc_req_std_get_ep_num();\n    if (ep_num == 0) {\n        return false;\n    }\n\n    resp_payload_len = 2;\n    if (udc_req_std_get_req_len() != resp_payload_len) {\n        return false;\n    }\n\n    ep_status = 0;\n    if (ep_num & 0x80) {\n        ep_num = ep_num & 0x7F;\n        if (udc_ep_is_halted(ep_num)) {\n            ep_status = 1;\n        }\n    } else {\n        if (udc_ep_is_halted(ep_num | 0x80)) {\n            ep_status = 1;\n        }\n    }\n\n    resp_payload = udc_req_std_get_resp_payload();\n    resp_payload[0] = ep_status;\n    resp_payload[1] = 0;\n\n    return true;\n}\n", "CodeBleu_score": 40.99917455040085}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void)\tuint8_t iface_num;\n\tiface_num = (uint8_t)((usb_setup.wIndex >> 8) & 0xFF);\n\tif (udc_configured && (iface_num < udc_num_interfaces)) {\n\t\tiface_desc_t *iface_desc;\n\t\tiface_desc = udc_interface[iface_num];\n\t\tiface_desc->iface_setting = 0;\n\t\tif (iface_desc->iface_setting_handler->setup(iface_desc->iface_setting_handler) == false) {\n\t\t\treturn false;\n\t\t}\n\t\tiface_desc->iface_setting = (uint8_t)(usb_setup.wValue & 0xFF);\n\t\tif (iface_desc->iface_setting_handler->setup(iface_desc->iface_setting_handler) == false) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 33.732946807514644}, {"code": "static bool udc_req_iface(void)\tif (!udc_req_iface_common()) {\n\t\treturn false;\n\t}\n\n\tudi_api_t *udi_api = udi_apis[setup_req->wIndex];\n\tif (!udi_api) {\n\t\treturn false;\n\t}\n\n\tudi_api_t::setup_req_t udi_setup_req;\n\tudi_setup_req.bmRequestType = setup_req->bmRequestType;\n\tudi_setup_req.bRequest = setup_req->bRequest;\n\tudi_setup_req.wValue = setup_req->wValue;\n\tudi_setup_req.wIndex = setup_req->wIndex;\n\tudi_setup_req.wLength = setup_req->wLength;\n\n\tif (udi_api->setup(&udi_setup_req) == UDI_API_REQ_SETUP_VALID) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 41.85794379370284}, {"code": "static bool udc_req_iface(void)\tif (udc_state != UDC_STATE_CONFIGURED) {\n\t\treturn false;\n\t}\n\tif (req->wIndex > udc_num_interfaces) {\n\t\treturn false;\n\t}\n\tstruct udc_endpoint *ept;\n\tstruct udc_interface *iface = &udc_interfaces[req->wIndex];\n\tiface->desc->bAlternateSetting = iface->cur_altsetting;\n\tiface->desc->bInterfaceNumber = req->wIndex;\n\tiface->desc->bNumEndpoints = iface->num_endpoints;\n\tiface->desc->bInterfaceClass = iface->class;\n\tiface->desc->bInterfaceSubClass = iface->subclass;\n\tiface->desc->bInterfaceProtocol = iface->protocol;\n\tiface->desc->iInterface = iface->string_index;\n\tfor (uint8_t i = 0; i < iface->num_endpoints; i++) {\n\t\tept = &iface->endpoints[i];\n\t\tept->desc->bEndpointAddress = ept->address;\n\t\tept->desc->bmAttributes = ept->type;\n\t\tept->desc->wMaxPacketSize = ept->max_packet_size;\n\t\tept->desc->bInterval = ept->interval;\n\t}\n\tif (iface->handler->setup(iface->handler, req)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 39.75573352606875}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void)\tbool b_lun_available = false;\n\tuint8_t i;\n\tudi_msc_cbw_t cbw;\n\n\t// Initialize flags\n\tudi_msc_b_cbw_invalid = false;\n\tudi_msc_b_cbw_wait = false;\n\tudi_msc_b_cbw_out = false;\n\tudi_msc_b_cbw_phase = UDI_MSC_CBW_PHASE_CBW;\n\tudi_msc_b_cbw_error = UDI_MSC_CBW_ERROR_NONE;\n\tudi_msc_b_cbw_lun = 0;\n\tudi_msc_b_cbw_cb_length = 0;\n\tudi_msc_b_cbw_cb_lba = 0;\n\tudi_msc_b_cbw_cb_length_host = 0;\n\tudi_msc_b_cbw_cb_lba_host = 0;\n\tudi_msc_b_cbw_cb_length_device = 0;\n\tudi_msc_b_cbw_cb_lba_device = 0;\n\tudi_msc_b_cbw_cb_direction = UDI_MSC_CBW_CB_DIRECTION_OUT;\n\tudi_msc_b_cbw_cb_direction_host = UDI_MSC_CBW_CB_DIRECTION_OUT;\n\tudi_msc_b_cbw_cb_direction_device = UDI_MSC_CBW_CB_DIRECTION_OUT;\n\tudi_msc_b_cbw_cb_direction_data_toggle = UDI_MSC_CBW_CB_DIRECTION_DATA_TOGGLE_DATA0;\n\tudi_msc_b_cbw_cb_direction_data_toggle_host = UDI_MSC_CBW_CB_DIRECTION_DATA_TOGGLE_DATA0;\n\tudi_msc_b_cbw_cb_direction_data_toggle_device = UDI_MSC_CBW_CB", "CodeBleu_score": 32.309668188871335}, {"code": "bool udi_msc_enable(void)\tudi_msc_init();\n\tudi_msc_enable_ext();\n\tudi_msc_init_luns();\n\tudi_msc_init_lun_cbw();\n\treturn true;\n}\n\n", "CodeBleu_score": 6.772498177440965}, {"code": "bool udi_msc_enable(void)\tuint8_t lun;\n\tuint8_t i;\n\tudi_msc_cbw_t cbw;\n\tudi_msc_csw_t csw;\n\tudi_msc_trans_t trans;\n\tudi_msc_cbw_t *cbw_ptr;\n\tudi_msc_csw_t *csw_ptr;\n\tudi_msc_trans_t *trans_ptr;\n\tudi_msc_cbw_t *cbw_ptr_tmp;\n\tudi_msc_csw_t *csw_ptr_tmp;\n\tudi_msc_trans_t *trans_ptr_tmp;\n\tuint8_t cbw_ptr_nb;\n\tuint8_t csw_ptr_nb;\n\tuint8_t trans_ptr_nb;\n\tbool b_enable = false;\n\n\t// Initialize flags\n\tudi_msc_b_cbw_invalid = false;\n\tudi_msc_b_csw_invalid = false;\n\tudi_msc_b_trans_invalid = false;\n\tudi_msc_b_cbw_invalid_no_reset = false;\n\tudi_msc_b_csw_invalid_no_reset = false;\n\tudi_msc_b_trans_invalid_no_reset = false;\n\tudi_msc_b_cbw_invalid_reset = false;\n\tudi_msc_b_csw_invalid_reset = false;\n\tudi_msc_b_trans_invalid_reset = false;\n\tudi_msc_b_cbw_invalid_reset_no_reset = false;\n\tudi_msc_b_csw_invalid_reset_no_reset = false;\n\tudi_msc_b_trans_invalid_reset_no_reset = false;\n\tudi_msc_b_cbw_invalid_reset_reset = false;\n\tudi_msc_b_csw_invalid_reset_reset = false;\n\tudi_msc_b_trans_invalid_reset_reset = false;\n\tudi_msc_b_cbw_invalid_reset_reset", "CodeBleu_score": 20.516159917218175}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tif (UDD_EP_TRANSFER_OK != status) {\n\t\t/* Transfer error, then stop transfer */\n\t\tudi_msc_trans_stop();\n\t\treturn;\n\t}\n\n\tif (udi_msc_cbw_invalid) {\n\t\t/* Transfer error, then stop transfer */\n\t\tudi_msc_trans_stop();\n\t\treturn;\n\t}\n\n\tif (udi_msc_cbw_invalid) {\n\t\t/* Transfer error, then stop transfer */\n\t\tudi_msc_trans_stop();\n\t\treturn;\n\t}\n\n\tudi_msc_csw.data_residue -= nb_sent;\n\tif (udi_msc_csw.data_residue == 0) {\n\t\t/* CSW is ready to be sent */\n\t\tudi_msc_csw_valid = true;\n\t\tudi_msc_trans_stop();\n\t\treturn;\n\t}\n\n\tif (udi_msc_cbw.bmCBWFlags.DIR) {\n\t\t/* Data IN phase */\n\t\tudi_msc_trans_start_in();\n\t} else {\n\t\t/* Data OUT phase */\n\t\tudi_msc_trans_start_out();\n\t}\n}\n", "CodeBleu_score": 54.653091456607825}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)  if (UDD_EP_TRANSFER_OK != status) {\n    // Transfer error\n    // Stall the endpoint and wait a MSC reset to restart CBW reception\n    udd_ep_set_stall_wait(g_msc_ep_in);\n    g_msc_b_read_10.stall_requested = true;\n    return;\n  }\n\n  // Update the CSW\n  g_msc_csw.data_residue -= nb_sent;\n  if (0 == g_msc_csw.data_residue) {\n    // Transfer complete, send the CSW\n    g_msc_csw.status = MSC_CSW_STATUS_COMMAND_PASSED;\n    udi_msc_process_trans();\n  }\n}\n\n", "CodeBleu_score": 62.42201769370129}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)\tif (UDD_EP_TRANSFER_OK != status) {\n\t\t// Transfer error\n\t\tudi_msc_cbw_reset();\n\t\treturn;\n\t}\n\n\t// Update residue\n\tudi_msc_cbw.csw.dCSWDataResidue -= nb_sent;\n\t// Update CSW\n\tudi_msc_csw_process();\n}\n", "CodeBleu_score": 67.05024304307068}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void)\tudi_msc_cbw_t *cbw = &udi_msc_cbw;\n\tudi_msc_csw_t *csw = &udi_msc_csw;\n\tuint8_t *data = (uint8_t *) &udi_msc_cbw;\n\n\t// Prepare CSW\n\tcsw->dCSWSignature = UDI_MSC_CSW_SIGNATURE;\n\tcsw->dCSWTag = cbw->dCBWTag;\n\tcsw->dCSWDataResidue = cbw->dCBWDataTransferLength;\n\tcsw->bCSWStatus = udi_msc_cbw_status;\n\n\t// Convert to little endian\n\tdata[0] = csw->dCSWSignature;\n\tdata[1] = csw->dCSWTag;\n\tdata[2] = csw->dCSWTag >> 8;\n\tdata[3] = csw->dCSWTag >> 16;\n\tdata[4] = csw->dCSWTag >> 24;\n\tdata[5] = csw->dCSWDataResidue;\n\tdata[6] = csw->dCSWDataResidue >> 8;\n\tdata[7] = csw->dCSWDataResidue >> 16;\n\tdata[8] = csw->dCSWDataResidue >> 24;\n\tdata[9] = csw->bCSWStatus;\n\n\t// Send CSW\n\tudi_msc_bulk_trans_t trans;\n\ttrans.buf = data;\n\ttrans.buf_size = UDI_MSC_CSW_SIZE;\n\ttrans.callback = NULL;\n\tudi_msc_bulk_trans_out_run(&trans);\n}\n", "CodeBleu_score": 38.57406603229098}, {"code": "static void udi_msc_csw_process(void)\tif (udi_msc_cbw.dCBWDataTransferLength) {\n\t\tif (udi_msc_cbw.bmCBWFlags & UDI_MSC_CBW_DIRECTION_IN) {\n\t\t\tudi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_FAILED;\n\t\t\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n\t\t\tudi_msc_csw.bCSWStatus |= UDI_MSC_CSW_STATUS_PHASE_ERROR;\n\t\t\tudi_msc_csw_send();\n\t\t\tudi_msc_trans_stop(0);\n\t\t} else {\n\t\t\tudi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_FAILED;\n\t\t\tudi_msc_csw.dCSWDataResidue = udi_msc_cbw.dCBWDataTransferLength;\n\t\t\tudi_msc_csw.bCSWStatus |= UDI_MSC_CSW_STATUS_PHASE_ERROR;\n\t\t\tudi_msc_csw_send();\n\t\t\tudi_msc_trans_stop(0);\n\t\t}\n\t} else {\n\t\tudi_msc_csw.bCSWStatus = UDI_MSC_CSW_STATUS_PASS;\n\t\tudi_msc_csw_send();\n\t}\n}\n\n", "CodeBleu_score": 43.46058785773931}, {"code": "static void udi_msc_csw_process(void)\tuint8_t udi_msc_csw_data[UDI_MSC_BOT_CSW_SIZE];\n\tudi_msc_cbw_t *cbw = (udi_msc_cbw_t *) udi_msc_cbw_data;\n\tudi_msc_csw_t *csw = (udi_msc_csw_t *) udi_msc_csw_data;\n\tudi_msc_cbw_t *udi_msc_cbw_data = (udi_msc_cbw_t *) udi_msc_cbw_data;\n\tudi_msc_csw_t *udi_msc_csw_data = (udi_msc_csw_t *) udi_msc_csw_data;\n\tuint32_t udi_msc_cbw_data_residue = udi_msc_cbw_data_residue;\n\tuint32_t udi_msc_csw_data_residue = udi_msc_csw_data_residue;\n\tuint8_t udi_msc_cbw_data_direction = udi_msc_cbw_data_direction;\n\tuint8_t udi_msc_csw_data_direction = udi_msc_csw_data_direction;\n\n\t// Prepare CSW\n\tudi_msc_csw_data_residue = udi_msc_cbw_data_residue;\n\tcsw->signature = UDI_MSC_CSW_SIGNATURE;\n\tcsw->tag = cbw->tag;\n\tcsw->data_residue_lo = (uint8_t) udi_msc_csw_data_residue;\n\tcsw->data_residue_hi = (uint8_t) (udi_msc_csw_data_residue >> 8);\n\tcsw->status = udi_msc_csw_status;\n\n\t// Send CSW\n\tudi_msc_csw_data_", "CodeBleu_score": 32.119786347488585}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)    if (b_enable) {\n        cancelReset();\n    } else {\n        if (usb_get_cdc_line_coding(port).dwDTERate == 1200) {\n            initiateReset();\n        }\n    }\n}\n", "CodeBleu_score": 42.591468569320746}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)  if (b_enable) {\n    // Cancel any scheduled reset\n    cancelReset();\n  } else {\n    // Check if the DTR rate is 1200\n    if (usb_cdc_line_coding[port].dwDTERate == 1200) {\n      // Schedule a delayed system reset\n      scheduleReset();\n    }\n  }\n}\n", "CodeBleu_score": 39.194277840583815}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)\tif (b_enable) {\n\t\tcancelReset();\n\t} else {\n\t\tif (usb_task_cdc_get_baud_rate(port) == 1200) {\n\t\t\tscheduleReset();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.64977293027398}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)    uint8_t request_index;\n\n    // Check if the request type is vendor-specific and if the request index is 0x04 or 0x05\n    if ((USB_CONTROL_SETUP_PACKET.bmRequestType == USB_SETUP_VENDOR_TYPE) && ((USB_CONTROL_SETUP_PACKET.bRequest == 0x04) || (USB_CONTROL_SETUP_PACKET.bRequest == 0x05))) {\n        // Get the request index\n        request_index = USB_CONTROL_SETUP_PACKET.wIndex;\n\n        // Set the payload pointer to the correct index\n        USB_CONTROL_TRANSFER_DATA_POINTER = &usb_descriptor_data[request_index];\n\n        // Set the payload size to the correct index\n        USB_CONTROL_TRANSFER_DATA_SIZE = usb_descriptor_sizes[request_index];\n\n        // Return \"true\" if the request is processed\n        return true;\n    }\n\n    // Return \"false\" if the request index is not recognized\n    return false;\n}\n", "CodeBleu_score": 18.778633534784017}, {"code": "bool usb_task_other_requests(void)  if (usb_setup.Type == USB_SETUP_TYPE_VENDOR) {\n    if (usb_setup.bRequest == 0x04) {\n      usb_setup.wIndex = 0;\n      usb_setup.wLength = 0x0004;\n      usb_setup.wValue = 0x0001;\n      return true;\n    } else if (usb_setup.bRequest == 0x05) {\n      usb_setup.wIndex = 0;\n      usb_setup.wLength = 0x000C;\n      usb_setup.wValue = 0x0002;\n      return true;\n    }\n  }\n  return false;\n}\n", "CodeBleu_score": 18.334650225582738}, {"code": "bool usb_task_other_requests(void)  if (USB_OTHER_REQ_INDEX == usb_setup.bRequest) {\n    // Handle Microsoft-compatible ID descriptor requests\n    if (USB_SETUP_DEVICE_TO_HOST == usb_setup.bmRequestType) {\n      // Get Microsoft-compatible ID descriptor\n      usb_setup.wLength = 2;\n      usb_setup.wValue = 0x0004;\n      usb_setup.wIndex = 0x0000;\n      usb_setup.wLength = 0x0000;\n      usb_setup.bRequest = 0x06;\n      usb_setup.bmRequestType = 0x81;\n      return true;\n    } else if (USB_SETUP_HOST_TO_DEVICE == usb_setup.bmRequestType) {\n      // Set Microsoft-compatible ID descriptor\n      usb_setup.wLength = 2;\n      usb_setup.wValue = 0x0005;\n      usb_setup.wIndex = 0x0000;\n      usb_setup.wLength = 0x0000;\n      usb_setup.bRequest = 0x06;\n      usb_setup.bmRequestType = 0x01;\n      return true;\n    }\n  } else if (USB_OTHER_REQ_INDEX2 == usb_setup.bRequest) {\n    // Handle extended properties descriptor requests\n    if (USB_SETUP_DEVICE_TO_HOST == usb_setup.bmRequestType) {\n      // Get extended properties descriptor\n      usb_setup.wLength = 2;\n      usb_setup.wValue = 0x0005;\n      usb_setup.wIndex = 0x0000;\n      usb_setup.wLength = 0x0000;\n      usb_setup.bRequest = 0x06;\n      usb_setup.bmRequestType = 0x81;\n      return true;\n    } else if (USB_SETUP_HOST", "CodeBleu_score": 26.5428020260902}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte)    uint16_t i;\n    if (nbyte == 0) return;\n    for (i = 0; i < nbyte-1; i++) {\n        spiSend(0x00);\n        buf[i] = spiRec();\n    }\n    buf[nbyte-1] = spiRec();\n}\n", "CodeBleu_score": 52.64462312448581}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)  uint16_t i;\n  uint8_t dummy;\n\n  if (nbyte == 0) {\n    return;\n  }\n\n  // Send dummy byte to read the first byte\n  SPI1DAT = 0xFF;\n  while (!(SPI1STAT & 0x01));\n  buf[0] = SPI1BUF;\n\n  // Read the remaining bytes\n  for (i = 1; i < nbyte; i++) {\n    dummy = SPI1DAT;\n    while (!(SPI1STAT & 0x01));\n    buf[i] = SPI1BUF;\n  }\n\n  // Read the last byte\n  spiRec(&buf[i]);\n}\n", "CodeBleu_score": 45.4289533834938}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)\tuint16_t i;\n\n\tif (nbyte == 0)\n\t\treturn;\n\n\tfor (i = 0; i < nbyte - 1; i++) {\n\t\tSPI_SendData8(SPI2, 0x00);\n\t\twhile (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);\n\t\tbuf[i] = SPI_ReceiveData8(SPI2);\n\t}\n\n\tspiRec(buf + i);\n}\n", "CodeBleu_score": 44.032080256267136}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    pfnISR_Handler oldHandler;\n    uint32_t *vectors = (uint32_t *)SCB->VTOR;\n\n    /* Disable interrupts to ensure atomic operation */\n    __disable_irq();\n\n    /* Retrieve the current handler for the IRQ */\n    oldHandler = (pfnISR_Handler)vectors[irq + 16];\n\n    /* Replace the current handler with the new handler */\n    vectors[irq + 16] = (uint32_t)newHandler;\n\n    /* Re-enable interrupts */\n    __enable_irq();\n\n    /* Return the original ISR handler */\n    return oldHandler;\n}\n", "CodeBleu_score": 57.724315495988066}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tuint32_t *vectors = (uint32_t *)SCB->VTOR;\n\tpfnISR_Handler oldHandler;\n\n\t// Disable global interrupts\n\t__disable_irq();\n\n\t// Retrieve the old handler\n\toldHandler = (pfnISR_Handler)vectors[irq + 16];\n\n\t// Replace the old handler with the new handler\n\tvectors[irq + 16] = (uint32_t)newHandler;\n\n\t// Re-enable global interrupts\n\t__enable_irq();\n\n\treturn oldHandler;\n}\n", "CodeBleu_score": 57.36573515421003}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    pfnISR_Handler oldHandler = (pfnISR_Handler)0;\n    uint32_t *pVectTable;\n    uint32_t *pVectTableAddr;\n\n    /*\n     * Disable global interrupts to ensure atomic operation.\n     */\n    __disable_irq();\n\n    /*\n     * Retrieve the address of the relocated interrupt vector table.\n     */\n    pVectTableAddr = (uint32_t *)SCB->VTOR;\n    pVectTable = (uint32_t *)(*pVectTableAddr);\n\n    /*\n     * Retrieve the current handler for the specified IRQ.\n     */\n    oldHandler = (pfnISR_Handler)pVectTable[irq + 16];\n\n    /*\n     * Replace the current handler with the new handler.\n     */\n    pVectTable[irq + 16] = (uint32_t)newHandler;\n\n    /*\n     * Enable global interrupts.\n     */\n    __enable_irq();\n\n    /*\n     * Return the original ISR handler.\n     */\n    return oldHandler;\n}\n", "CodeBleu_score": 54.042803179759915}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek()  if (!usb_serial_connected) return -1;\n  if (usb_serial_available() > 0) {\n    const int c = usb_serial_peek();\n    if (c < 0) return c;\n    if (c == '\\n') {\n      if (parser.enabled) {\n        const int c2 = usb_serial_read();\n        if (c2 < 0) return c2;\n        if (c2 == '\\r') {\n          parser.process(parser.buffer);\n          parser.buffer[0] = '\\0';\n          parser.buffer_pos = 0;\n        }\n        else\n          parser.buffer[parser.buffer_pos++] = c2;\n      }\n      else {\n        usb_serial_read();\n        usb_serial_read();\n      }\n    }\n    return c;\n  }\n  return -1;\n}\n", "CodeBleu_score": 41.55057886080342}, {"code": "int MarlinSerialUSB::peek()  if (!rx_buffer_index) {\n    if (cdc_suspended) return -1;\n    if (!usb_serial_available()) return -1;\n    return usb_serial_peek();\n  }\n  return rx_buffer[rx_buffer_tail];\n}\n", "CodeBleu_score": 16.77141840676705}, {"code": "int MarlinSerialUSB::peek()  int c = -1;\n  if (is_enabled()) {\n    if (available()) {\n      c = read_data();\n      if (c < 0) return -1;\n      if (emergency_parser.enabled) emergency_parser.update(c);\n    }\n  }\n  return c;\n}\n", "CodeBleu_score": 44.22588738293579}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read()  if (usb_serial_available()) return usb_serial_getchar();\n  return -1;\n}\n", "CodeBleu_score": 5.582300070286267}, {"code": "int MarlinSerialUSB::read()  int c;\n  if (usb_serial_available()) {\n    c = usb_serial_getchar();\n    if (c != -1) {\n      #if ENABLED(EMERGENCY_PARSER)\n        emergency_parser.update(c);\n      #endif\n      return c;\n    }\n  }\n  return -1;\n}\n", "CodeBleu_score": 27.49282059041417}, {"code": "int MarlinSerialUSB::read()  if (available()) return buffer_ring.peek();\n  if (!usb_serial_is_connected()) return -1;\n  if (usb_serial_available() == 0) return -1;\n  const uint8_t c = usb_serial_read();\n  if (c == '\\n' && parser.enabled) parser.update('\\r');\n  return c;\n}\n", "CodeBleu_score": 36.326518687648566}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available()  if (usb_cdc_is_ready()) {\n    int count = 0;\n    while (usb_serial_available() > 0) {\n      usb_serial_read();\n      count++;\n    }\n    return count;\n  }\n  return 0;\n}\n", "CodeBleu_score": 45.92529423680895}, {"code": "int MarlinSerialUSB::available()  if (usb_serial_available()) return usb_serial_read_buffer_length();\n  return 0;\n}\n", "CodeBleu_score": 13.5015527882345}, {"code": "int MarlinSerialUSB::available()  if (usb_serial_available()) return usb_serial_read_free();\n  return 0;\n}\n", "CodeBleu_score": 12.828458377745633}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\n  if (!is_ready()) return false;\n\n  uint8_t * const p = value;\n  uint8_t * const end = p + size;\n\n  do {\n    uint8_t c;\n    if (!read_byte(pos, c)) return false;\n    if (writing) *p = c;\n    if (crc) *crc = crc16(c, *crc);\n  } while (++p < end);\n\n  return true;\n}\n", "CodeBleu_score": 48.347244260952706}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\n  uint8_t c;\n\n  while (size--) {\n    if (!read_byte(pos, c)) return false;\n    if (writing) *value = c;\n    if (crc) *crc = crc16((uint8_t)c, *crc);\n    value++;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 59.77031465437142}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)\n  uint8_t byte;\n\n  while (size--) {\n    if (!read_byte(pos, byte)) return false;\n    if (writing && value) *value = byte;\n    if (crc) *crc = crc16(byte, *crc);\n    if (value) value++;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 51.61942134208424}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  #if ENABLED(PWM_FALLBACK_SC)\n    #if ENABLED(PWM_FALLBACK_SC_DEBUG)\n      if (WITHIN(pin, PWM_FALLBACK_SC_PIN_FIRST, PWM_FALLBACK_SC_PIN_LAST)) {\n        SERIAL_ECHOPGM(\"analogWrite(pin=\");\n        serialprintPGM(pwm_names[pin - PWM_FALLBACK_SC_PIN_FIRST]);\n        SERIAL_ECHOPAIR(\", value=\", value);\n        SERIAL_ECHOPAIR(\", freq=\", freq);\n        SERIAL_ECHOLNPAIR(\", res=\", res);\n      }\n    #endif\n    if (WITHIN(pin, PWM_FALLBACK_SC_PIN_FIRST, PWM_FALLBACK_SC_PIN_LAST)) {\n      const uint8_t index = pin - PWM_FALLBACK_SC_PIN_FIRST;\n      const uint32_t sc_freq = (freq < 25500) ? 25500 : freq;\n      const uint8_t sc_res = (res > 8) ? 8 : res;\n      const uint8_t sc_val = (value > 255) ? 255 : value;\n      const uint8_t sc_val_inv = 255 - sc_val;\n      const uint8_t sc_val_inv_mask = (sc_val_inv < 128) ? 0xFF : 0x00;\n\n      if (sc_res == 8) {\n        switch (sc_freq) {\n          case 25500:\n            switch (index) {\n              case 0:\n                SC_PWM_PIN_0_REG = sc_val_inv_mask;\n                SC_PWM_PIN_0_REG = sc_val;\n                break;\n              case 1:\n                SC_PWM_PIN_", "CodeBleu_score": 32.86214186470524}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  if (WITHIN(pin, 0, NUM_DIGITAL_PINS - 1)) {\n    const uint8_t pin_index = digitalPinToPinInfoIndex(pin);\n    pin_t pwm_pin = get_pwm_pin(pin_index);\n    if (pwm_pin != NOT_ON_PWM) {\n      ledcWrite(pwm_pin, value);\n      return;\n    }\n  }\n  #if HAS_PWM_CNT\n    if (WITHIN(pin, 0, NUM_PWM_PINS - 1)) {\n      const uint8_t pin_index = digitalPinToPinInfoIndex(pin);\n      if (pwm_status[pin_index].state == PWM_ON) {\n        pwm_status[pin_index].state = PWM_SOFT_ON;\n        pwm_status[pin_index].soft_count = 0;\n        pwm_status[pin_index].soft_pwm_count = 0;\n        pwm_status[pin_index].soft_pwm_value = 0;\n        pwm_status[pin_index].soft_pwm_value_prev = 0;\n        pwm_status[pin_index].soft_pwm_freq = freq;\n        pwm_status[pin_index].soft_pwm_res = res;\n        pwm_status[pin_index].soft_pwm_value_prev = 0;\n        pwm_status[pin_index].soft_pwm_value = 0;\n        pwm_status[pin_index].soft_pwm_count = 0;\n        pwm_status[pin_index].soft_pwm_count_prev = 0;\n        pwm_status[pin_index].soft_pwm_count_prev2 = 0;\n        pwm_status[pin_index].soft_pwm_count_prev3 = 0;\n        pwm_status[pin_", "CodeBleu_score": 40.02271086204874}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  #if ENABLED(SOFTWARE_PWM)\n    if (pin < SOFT_PWM_COUNT) {\n      const uint8_t pwm_index = _get_pwm_index(pin);\n      if (pwm_index >= 0) {\n        // Use software PWM\n        _set_pwm_duty(pwm_index, value);\n        return;\n      }\n    }\n  #endif\n\n  // Use hardware PWM\n  ledcWrite(pin, value);\n}\n", "CodeBleu_score": 22.802369423168443}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value)  static_assert(DELAY_LENGTH == NUM_SERVOS, \"Servo delay array length must match the number of servos.\");\n  if (servo.attach(pin) == 0) {\n    servo.write(value);\n    delay(DELAY_ARRAY[channel]);\n    #ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n    servo.detach();\n    #endif\n  }\n}\n", "CodeBleu_score": 51.52103255252559}, {"code": "void Servo::move(const int value)  static_assert(sizeof(servo_delays) / sizeof(servo_delays[0]) == NUM_SERVOS, \"servo_delays array must be the same size as NUM_SERVOS\");\n  if (servo.attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH)) {\n    servo.write(value);\n    delay(servo_delays[channel]);\n    if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n      servo.detach();\n    }\n  }\n}\n", "CodeBleu_score": 51.36947704427692}, {"code": "void Servo::move(const int value)    static_assert(sizeof(SERVO_DELAYS) / sizeof(SERVO_DELAYS[0]) == SERVO_COUNT, \"SERVO_DELAYS array length must match SERVO_COUNT\");\n    if (attach(value)) {\n        write(value);\n        delay(SERVO_DELAYS[channel]);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) detach();\n    }\n}\n", "CodeBleu_score": 53.85813022039504}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample()  uint32_t pin_mask = 1;\n  uint32_t pin_state = 0;\n  uint32_t pin_sample = 0;\n  uint32_t port_data = 0;\n  uint32_t tick_count = 0;\n\n  for (int i = 0; i < PIN_COUNT; i++) {\n    pin_sample = i2s_buffer[i2s_buffer_pos][i];\n    pin_state = (port_data >> i) & 0x1;\n    tick_count = i2s_pin_state[i].tick_count;\n\n    if (pin_sample != 0) {\n      if (tick_count == 0) {\n        if (pin_state == 0) {\n          port_data |= pin_mask;\n        } else {\n          port_data &= ~pin_mask;\n        }\n        i2s_pin_state[i].tick_count = i2s_pin_state[i].period;\n      } else {\n        i2s_pin_state[i].tick_count--;\n      }\n    }\n\n    pin_mask <<= 1;\n  }\n\n  i2s_buffer[i2s_buffer_pos][PIN_COUNT] = port_data;\n  i2s_buffer_pos++;\n\n  if (i2s_buffer_pos == I2S_BUFFER_LENGTH) {\n    i2s_buffer_pos = 0;\n  }\n}\n", "CodeBleu_score": 28.734434398717784}, {"code": "void i2s_push_sample()\t// Iterate over all pins\n\tfor (uint8_t i = 0; i < NUM_PINS; i++) {\n\t\t// If the pin has active PWM\n\t\tif (pins[i].pwm_duty_cycle != 0) {\n\t\t\t// If the PWM tick count reaches zero\n\t\t\tif (pins[i].pwm_ticks == 0) {\n\t\t\t\t// Toggle the pin state between high and low based on its current state\n\t\t\t\tpins[i].state = !pins[i].state;\n\t\t\t\t// Set the tick count for the next transition\n\t\t\t\tpins[i].pwm_ticks = pins[i].pwm_duty_cycle;\n\t\t\t}\n\t\t\t// Decrement the PWM tick count\n\t\t\tpins[i].pwm_ticks--;\n\t\t}\n\t\t// Store the updated port data into the current position of the DMA buffer and increment the buffer position\n\t\ti2s_tx_buffer[i2s_tx_buffer_pos] = pins[i].state ? 0x8000 : 0x0000;\n\t\ti2s_tx_buffer_pos++;\n\t}\n}\n", "CodeBleu_score": 28.48409591668899}, {"code": "void i2s_push_sample()  uint8_t i;\n  uint8_t pwm_state = 0;\n  uint8_t pwm_mask = 1;\n  uint8_t pwm_pin_state = 0;\n  uint8_t pwm_pin_mask = 1;\n  uint8_t pwm_pin_count = 0;\n  uint8_t pwm_pin_mask_next = 0;\n  uint8_t pwm_pin_mask_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next_next_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  uint8_t pwm_pin_mask_next_next_next_next", "CodeBleu_score": 6.387627609025567}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)  hal_timer_t count;\n\n  if (timer_num == 0) {\n    count = TIMER0_COUNT;\n  } else if (timer_num == 1) {\n    count = TIMER1_COUNT;\n  } else if (timer_num == 2) {\n    count = TIMER2_COUNT;\n  } else if (timer_num == 3) {\n    count = TIMER3_COUNT;\n  } else {\n    count = 0;\n  }\n\n  return count;\n}\n", "CodeBleu_score": 30.065421293648896}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)\tuint32_t timer_count;\n\t\n\tswitch (timer_num) {\n\t\tcase 0:\n\t\t\ttimer_count = TIMER0_COUNT_REG;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttimer_count = TIMER1_COUNT_REG;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttimer_count = TIMER2_COUNT_REG;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttimer_count = TIMER3_COUNT_REG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttimer_count = 0;\n\t\t\tbreak;\n\t}\n\t\n\treturn timer_count;\n}\n", "CodeBleu_score": 30.4402626335689}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)  hal_timer_t timer_count = 0;\n  hal_timer_config_t *timer_config = &timer_config_array[timer_num];\n\n  switch (timer_config->timer_type) {\n    case HAL_TIMER_TYPE_GENERAL:\n      timer_count = timer_config->timer_regs->CNT;\n      break;\n\n    case HAL_TIMER_TYPE_CAPTURE:\n      timer_count = timer_config->timer_regs->CCR;\n      break;\n\n    case HAL_TIMER_TYPE_PWM:\n      timer_count = timer_config->timer_regs->CMR;\n      break;\n\n    default:\n      break;\n  }\n\n  return timer_count;\n}\n", "CodeBleu_score": 43.26112524900472}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  uint8_t c;\n  uint8_t * const p = value;\n  LOOP_L_N(i, size) {\n    c = eeprom_read_byte((uint8_t*)pos);\n    if (writing) *p = c;\n    if (crc) *crc = crc16(c, *crc);\n    pos++;\n    p++;\n  }\n  return false;\n}\n", "CodeBleu_score": 44.78810465931259}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\n  if (pos + size > persistent_store_size) {\n    SERIAL_ECHOLNPGM(\"PersistentStore::read_data() out of bounds.\");\n    return true;\n  }\n\n  const uint8_t * const base = persistent_store_data + pos;\n\n  if (writing) {\n    memcpy(value, base, size);\n  }\n\n  for (size_t i = 0; i < size; i++) {\n    const uint8_t b = base[i];\n    if (writing) {\n      value[i] = b;\n    }\n    *crc = crc16(b, *crc);\n  }\n\n  pos += size;\n  return false;\n}\n", "CodeBleu_score": 62.893402174948754}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)\n  uint16_t newcrc = *crc;\n\n  for (size_t i = 0; i < size; i++) {\n    uint8_t c;\n    eeprom_read_byte((uint8_t*)pos + i, c);\n    newcrc = crc16(newcrc, &c);\n    if (writing) value[i] = c;\n  }\n\n  pos += size;\n  *crc = newcrc;\n\n  return false;\n}\n", "CodeBleu_score": 69.7174134097126}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    uint32_t i;\n    bool success = false;\n    if (sdioHandle == NULL) {\n        printf(\"SDIO_WriteBlock: SDIO handle is null\\n\");\n        return false;\n    }\n    if (src == NULL) {\n        printf(\"SDIO_WriteBlock: Source pointer is null\\n\");\n        return false;\n    }\n    for (i = 0; i < SDIO_WRITE_RETRIES; i++) {\n        if (SD_WriteBlock(sdioHandle, block, src, SDIO_BLOCK_SIZE) == kStatus_Success) {\n            success = true;\n            break;\n        }\n        printf(\"SDIO_WriteBlock: Write failed, retrying...\\n\");\n    }\n    if (!success) {\n        printf(\"SDIO_WriteBlock: Write failed after %d retries\\n\", i);\n    }\n    return success;\n}\n", "CodeBleu_score": 38.002549451459245}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    uint32_t status = 0;\n    uint32_t retryCount = 0;\n\n    if (!sdioHandle || !src) {\n        return false;\n    }\n\n    while (retryCount < SDIO_MAX_RETRY_COUNT) {\n        status = SD_WriteBlock(sdioHandle, block, (uint32_t *) src);\n        if (status == SD_SUCCESS) {\n            return true;\n        }\n        retryCount++;\n    }\n\n    printf(\"ERROR: SDIO_WriteBlock() failed with status %d.\\n\", status);\n    return false;\n}\n", "CodeBleu_score": 37.346068299649495}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    if (src == NULL) {\n        printf(\"SDIO_WriteBlock: source pointer is null\\n\");\n        return false;\n    }\n\n    if (sdio_handle == NULL) {\n        printf(\"SDIO_WriteBlock: SDIO handle is null\\n\");\n        return false;\n    }\n\n    // Try to write the block up to a maximum number of times\n    for (int i = 0; i < SDIO_WRITE_RETRIES; i++) {\n        if (SD_OK == SD_WriteBlock(sdio_handle, block, (uint32_t *)src, 1000)) {\n            return true;\n        }\n    }\n\n    printf(\"SDIO_WriteBlock: failed to write block %d\\n\", block);\n    return false;\n}\n", "CodeBleu_score": 39.431823413791975}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)\tif (timer_num == TEMP_TIMER) {\n\t\tHAL_timer_start_temp(frequency);\n\t} else if (timer_num == STEP_TIMER) {\n\t\tHAL_timer_start_step(frequency);\n\t} else {\n\t\tHAL_assert_param(0);\n\t}\n}\n", "CodeBleu_score": 24.073466584742174}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)  switch (timer_num) {\n    case TEMP_TIMER_NUM:\n      HAL_timer_enable_interrupt(timer_num);\n      HAL_timer_start_pwm(timer_num, frequency, TEMP_TIMER_PRESCALE);\n      break;\n    case STEP_TIMER_NUM:\n      HAL_timer_enable_interrupt(timer_num);\n      HAL_timer_start_pwm(timer_num, frequency, STEP_TIMER_PRESCALE);\n      break;\n    default:\n      HAL_timer_enable_interrupt(timer_num);\n      HAL_timer_start_pwm(timer_num, frequency, 0);\n      break;\n  }\n}\n", "CodeBleu_score": 41.77509348049394}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)  if (timer_num == TEMP_TIMER) {\n    HAL_timer_enable_interrupt(TEMP_TIMER);\n    HAL_timer_set_frequency(TEMP_TIMER, frequency);\n    HAL_timer_set_isr_priority(TEMP_TIMER, TEMP_TIMER_ISR_PRIO, TEMP_TIMER_ISR_SUBPRIO);\n  }\n  else if (timer_num == STEP_TIMER) {\n    HAL_timer_enable_interrupt(STEP_TIMER);\n    HAL_timer_set_frequency(STEP_TIMER, frequency);\n    HAL_timer_set_isr_priority(STEP_TIMER, STEP_TIMER_ISR_PRIO, STEP_TIMER_ISR_SUBPRIO);\n  }\n  else {\n    // Timer channel is invalid\n    HAL_assert_ex(false, \"Timer channel is invalid.\");\n  }\n}\n", "CodeBleu_score": 43.43727403936803}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start()  if (accessing) return false;\n\n  if (!file.open(name, O_RDWR)) return false;\n\n  // Get the file size\n  int32_t size = file.size();\n  if (size < 0) return false;\n\n  // If the file is smaller than the EEPROM size, fill the remainder with the default erase value\n  if (size < EEPROM_SIZE) {\n    uint16_t i = size;\n    while (i < EEPROM_SIZE) {\n      data[i] = 0xFF;\n      i++;\n    }\n  }\n\n  // Read the file into the buffer\n  if (size > 0) file.read(data, size);\n\n  // Close the file\n  file.close();\n\n  // Set the flag\n  accessing = true;\n\n  return true;\n}\n", "CodeBleu_score": 31.17293278169435}, {"code": "bool PersistentStore::access_start()\n  const char * const fname = \"eeprom.dat\";\n  const uint16_t maxsize = persistentStore.capacity();\n\n  // Open file for reading\n  if (!eeprom_file.open(fname, O_RDONLY)) return false;\n\n  // Get file size\n  const uint16_t filesize = eeprom_file.fileSize();\n\n  // If the file is too small, erase the rest of the buffer\n  if (filesize < maxsize) {\n    uint8_t data = eeprom_is_ready ? 0xFF : 0;\n    while (filesize < maxsize) {\n      eeprom_file.write(&data, 1);\n      filesize++;\n    }\n  }\n\n  // Read the file into the buffer\n  eeprom_file.read(persistentStore.data, filesize);\n\n  // Close the file\n  eeprom_file.close();\n\n  return true;\n}\n", "CodeBleu_score": 39.048300383592974}, {"code": "bool PersistentStore::access_start()  if (!file.open(filename, O_RDWR | O_CREAT)) {\n    SERIAL_ECHOLNPAIR(\"open failed, errno: \", strerror(errno));\n    return false;\n  }\n\n  if (file.size() < EEPROM_SIZE) {\n    SERIAL_ECHOLNPGM(\"file too small\");\n    file.close();\n    return false;\n  }\n\n  if (file.size() > EEPROM_SIZE) {\n    SERIAL_ECHOLNPGM(\"file too large\");\n    file.close();\n    return false;\n  }\n\n  if (file.size() == EEPROM_SIZE) {\n    file.read(eeprom_data, EEPROM_SIZE);\n  }\n  else {\n    memset(eeprom_data, 0xFF, EEPROM_SIZE);\n  }\n\n  file.close();\n  return true;\n}\n", "CodeBleu_score": 34.388401748876355}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)  uint8_t r = 0;\n  uint8_t i;\n  for (i = 0; i < 8; i++) {\n    HAL_SPI_STM32_SpiClockLow();\n    if (b & 0x80) {\n      HAL_SPI_STM32_SpiMosiHigh();\n    } else {\n      HAL_SPI_STM32_SpiMosiLow();\n    }\n    HAL_SPI_STM32_SpiClockHigh();\n    r = (r << 1) | HAL_SPI_STM32_SpiMiso();\n    b = b << 1;\n  }\n  HAL_SPI_STM32_SpiDelay();\n  return r;\n}\n", "CodeBleu_score": 34.86662605896223}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t i;\n    uint8_t ret = 0;\n    for (i = 0; i < 8; i++) {\n        HAL_SPI_STM32_SpiWriteBit(0);\n        ret = (ret << 1) | HAL_SPI_STM32_SpiReadBit();\n        HAL_SPI_STM32_SpiWriteBit(1);\n    }\n    return ret;\n}\n", "CodeBleu_score": 32.569835877402255}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t i;\n    uint8_t r = 0;\n    for (i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_RESET);\n        if (b & 0x80) {\n            HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_SET);\n        } else {\n            HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, GPIO_PIN_RESET);\n        }\n        HAL_GPIO_WritePin(SPI_CLK_PORT, SPI_CLK_PIN, GPIO_PIN_SET);\n        if (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN) == GPIO_PIN_SET) {\n            r |= 0x01;\n        }\n        b = b << 1;\n    }\n    HAL_Delay(1);\n    return r;\n}\n", "CodeBleu_score": 42.223876840170384}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)  /* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE) {\n    /* Enable the AHB peripheral Clock */\n    RCC->AHBENR |= RCC_AHBPeriph;\n  }\n  else {\n    /* Disable the AHB peripheral Clock */\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}\n", "CodeBleu_score": 81.17769582044724}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)  /* Check the parameters */\n  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  }\n  else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}\n", "CodeBleu_score": 81.17769582044724}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)    /* Check the parameters */\n    assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));\n    assert_param(IS_FUNCTIONAL_STATE(NewState));\n\n    if (NewState != DISABLE) {\n        /* Enable the AHB peripheral clock */\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        /* Disable the AHB peripheral clock */\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}\n", "CodeBleu_score": 79.58798619099609}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  // Receive byte\n  uint8_t c = obj->regs->RX_DATA;\n\n  // If no parity error occurred\n  if (obj->regs->RX_STATUS & RX_STATUS_PARITY_ERROR_MASK) {\n    // If space is available in the receive buffer\n    if (obj->rx_head != obj->rx_tail) {\n      // Read from receive buffer and increment head\n      obj->rx_buffer[obj->rx_head] = c;\n      obj->rx_head = (obj->rx_head + 1) % SERIAL_RX_BUFFER_SIZE;\n    }\n\n    // Update emergency parser\n    if (obj->emergency_parser.enabled)\n      obj->emergency_parser.update(c);\n  }\n\n  // Clear RX_DATA_AVAILABLE interrupt flag\n  obj->regs->RX_STATUS = RX_STATUS_DATA_AVAILABLE_MASK;\n}\n", "CodeBleu_score": 44.81862529388123}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  uint8_t c = obj->regs->RBR;\n  if (obj->regs->LSR & UART_LSR_PE) {\n    // Parity error\n    obj->regs->ECR = UART_ECR_PE;\n  } else {\n    if (obj->rx_buff.head == obj->rx_buff.tail) {\n      // Buffer overflow\n      obj->regs->ECR = UART_ECR_OE;\n    } else {\n      // No error\n      uint8_t i = obj->rx_buff.head;\n      obj->rx_buff.buffer[i] = c;\n      obj->rx_buff.head = (i + 1) & (SERIAL_RX_BUFFER_SIZE - 1);\n      if (obj->rx_buff.head == obj->rx_buff.tail) {\n        obj->regs->IER &= ~UART_IER_RDI;\n      }\n      obj->regs->ECR = UART_ECR_FE;\n      if (obj->emergency_parser.enabled) {\n        obj->emergency_parser.index = (obj->emergency_parser.index + 1) & 3;\n        obj->emergency_parser.received[obj->emergency_parser.index] = c;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 37.23729846643922}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  uint32_t head = obj->rx_head;\n  uint32_t next = head + 1;\n  if (next >= obj->rx_buffer_size) next = 0;\n  if (next != obj->rx_tail) {\n    uint8_t c = obj->regs->RBR;\n    obj->rx_buffer[head] = c;\n    obj->rx_head = next;\n    obj->rx_bytes++;\n    if (obj->eparser) obj->eparser->update(c);\n  }\n}\n", "CodeBleu_score": 44.34266133192099}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\tif (timer_num == MF_TIMER_STEP) {\n\t\tif (step_timer_initialized && !step_timer_interrupt_attached) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Step_Handler);\n\t\t}\n\t}\n\telse if (timer_num == MF_TIMER_TEMP) {\n\t\tif (temp_timer_initialized && !temp_timer_interrupt_attached) {\n\t\t\tHAL_timer_attach_interrupt(timer_num, Temp_Handler);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.217273815434254}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)\n  if (timer_num == MF_TIMER_STEP) {\n    if (Step_Timer_Initialized && !Step_Timer_Has_Interrupt) {\n      HAL_timer_enable_interrupt_impl(STEP_TIMER_NUM);\n      Step_Timer_Has_Interrupt = true;\n    }\n  }\n  else if (timer_num == MF_TIMER_TEMP) {\n    if (Temp_Timer_Initialized && !Temp_Timer_Has_Interrupt) {\n      HAL_timer_enable_interrupt_impl(TEMP_TIMER_NUM);\n      Temp_Timer_Has_Interrupt = true;\n    }\n  }\n\n}\n", "CodeBleu_score": 32.78857884573774}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)  if (timer_num == MF_TIMER_STEP) {\n    if (step_timer_initialized && !step_timer_interrupt_attached) {\n      attachInterrupt(digitalPinToInterrupt(STEP_TIMER_PIN), Step_Handler, FALLING);\n      step_timer_interrupt_attached = true;\n    }\n  }\n  else if (timer_num == MF_TIMER_TEMP) {\n    if (temp_timer_initialized && !temp_timer_interrupt_attached) {\n      attachInterrupt(digitalPinToInterrupt(TEMP_TIMER_PIN), Temp_Handler, FALLING);\n      temp_timer_interrupt_attached = true;\n    }\n  }\n}\n", "CodeBleu_score": 32.54863759655316}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tif len(s) == 0 || len(sep) == 0 {\n\t\treturn -1\n\t}\n\n\tif len(sep) == 1 {\n\t\treturn LastIndexByte(s, sep[0])\n\t}\n\n\thash := Hash(sep)\n\tif hash == 0 {\n\t\treturn -1\n\t}\n\n\tn := len(s)\n\tm := len(sep)\n\tvar h uint64\n\tvar i int\n\tfor i = n - m; i >= 0; i-- {\n\t\th = Hash(s[i:i+m])\n\t\tif h == hash && Equal(s[i:i+m], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 38.83251429758211}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\tif len(s) < len(sep) {\n\t\treturn -1\n\t}\n\th := hash(sep)\n\tn := len(sep)\n\tvar hs uint64\n\tfor i := 0; i < n; i++ {\n\t\ths = hs*primeRK + uint64(s[i])\n\t}\n\tif hs == h {\n\t\tif Equal(s[:n], sep) {\n\t\t\treturn 0\n\t\t}\n\t}\n\tfor i := n; i < len(s); i++ {\n\t\ths = hs*primeRK + uint64(s[i]) - uint64(s[i-n])*primeRKPow[n]\n\t\tif hs == h {\n\t\t\tif Equal(s[i-n+1:i+1], sep) {\n\t\t\t\treturn i - n + 1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 39.9592241939971}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tif len(s) == 0 || len(sep) == 0 {\n\t\treturn -1\n\t}\n\tsepHash, sepHashBase := HashRabinKarp(sep)\n\tsHash, sHashBase := HashRabinKarp(s)\n\tif sHash == sepHash && Equal(s[:len(sep)], sep) {\n\t\treturn 0\n\t}\n\tfor i := len(s) - len(sep); i >= 0; i-- {\n\t\tsHash = sHashBase*byte(sHash) + s[i+len(sep)] - s[i]*byte(sHashBase)\n\t\tif sHash == sepHash && Equal(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 41.174570788916995}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.DisableInterrupts()\n\tif usbcdc.TxBuffer.Length > 0 {\n\t\tusbcdc.SendUSBInPacket()\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tusbcdc.RestoreInterrupts()\n}\n", "CodeBleu_score": 40.348367548514375}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.DisableInterrupts()\n\tif usbcdc.txc != 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txb, usbcdc.txc)\n\t\tusbcdc.txc = 0\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tusbcdc.EnableInterrupts()\n}\n", "CodeBleu_score": 38.78772606173324}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.DisableInterrupts()\n\tif usbcdc.TxBuffer.Available() > 0 {\n\t\tusbcdc.SendUSBInPacket(usbcdc.TxBuffer.Peek(usbcdc.TxBuffer.Available()))\n\t} else {\n\t\tusbcdc.waitTxc = false\n\t}\n\tusbcdc.EnableInterrupts()\n}\n", "CodeBleu_score": 44.151339177348184}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.setControl(i2c.Control.ClearInterruptFlag().SetStartCondition().SetEnable())\n\tfor !i2c.getControl().HasInterruptFlag() {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t}\n\ti2c.setAddress(address, write)\n}\n", "CodeBleu_score": 20.464280617725233}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.clearInterruptFlag()\n\ti2c.setStartCondition()\n\ti2c.waitForStartCondition()\n\ti2c.writeAddress(address, write)\n}\n", "CodeBleu_score": 20.279613628306297}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.cr.SetBits(I2C_CR1_START)\n\tfor !i2c.sr1.HasBits(I2C_SR1_SB) {\n\t}\n\ti2c.dr.Store(uint32(address)<<1 | uint32(write))\n\tfor !i2c.sr1.HasBits(I2C_SR1_ADDR) {\n\t}\n}\n", "CodeBleu_score": 23.27431502355572}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tif start < 0 || start > f.blockCount-1 {\n\t\treturn errors.New(\"start block number out of range\")\n\t}\n\tif len < 0 || start+len > f.blockCount {\n\t\treturn errors.New(\"length out of range\")\n\t}\n\n\t// Wait for any ongoing flash operations to complete.\n\tfor {\n\t\tif f.ReadStatusReg1()&0x01 == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Set the device to erase mode.\n\tf.WriteStatusReg1(0x02)\n\n\t// Erase the blocks.\n\tfor i := int64(0); i < len; i++ {\n\t\t// Calculate the start address of the block.\n\t\taddr := start + i\n\t\t// Send the erase command.\n\t\tf.WriteEnable()\n\t\tf.WriteEraseBlock(addr)\n\t\t// Wait for the flash to finish erasing the block.\n\t\tfor {\n\t\t\tif f.ReadStatusReg1()&0x01 == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the device back to read mode.\n\tf.WriteStatusReg1(0x00)\n\n\treturn nil\n}\n", "CodeBleu_score": 35.067454996792144}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tvar err error\n\tf.flash.Configure(flash.ERASE)\n\tfor i := start; i < start+len; i++ {\n\t\terr = f.flash.Erase(i)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tf.flash.Configure(flash.READ)\n\treturn nil\n}\n", "CodeBleu_score": 36.496159670837145}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\treturn nil\n}\n", "CodeBleu_score": 3.283230433686614}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 {\n\t\treturn 0, errors.New(\"invalid offset\")\n\t}\n\tif off >= int64(f.size) {\n\t\treturn 0, errors.New(\"offset exceeds flash memory size\")\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tif off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, errors.New(\"write exceeds flash memory size\")\n\t}\n\n\t// Pad the data to fit the write block size.\n\tp = pad(p, f.writeBlockSize)\n\n\t// Calculate the start address for writing.\n\tstartAddress := uint32(off)\n\n\t// Enable write mode on the flash memory controller.\n\tf.enableWriteMode()\n\n\t// Write the data in blocks.\n\tfor len(p) > 0 {\n\t\t// Write a block of data.\n\t\tblockSize := f.writeBlockSize\n\t\tif len(p) < int(blockSize) {\n\t\t\tblockSize = uint32(len(p))\n\t\t}\n\t\terr = f.writeBlock(startAddress, p[:blockSize])\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\n\t\t// Wait for the flash memory to be ready.\n\t\terr = f.waitForReady()\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\n\t\t// Update the variables.\n\t\tn += len(p[:blockSize])\n\t\tp = p[blockSize:]\n\t\tstartAddress += blockSize\n\t}\n\n\treturn n, nil\n}\n", "CodeBleu_score": 31.220073777236458}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, errors.New(\"write out of bounds\")\n\t}\n\tif int64(len(p)) == 0 {\n\t\treturn 0, nil\n\t}\n\tstart := int(off)\n\tend := start + len(p)\n\tfor start < end {\n\t\t// Calculate the start address for writing.\n\t\taddr := int(f.baseAddress) + start\n\t\t// Calculate the number of bytes to write in this iteration.\n\t\twriteSize := len(p) - start\n\t\tif writeSize > f.writeBlockSize {\n\t\t\twriteSize = f.writeBlockSize\n\t\t}\n\t\t// Pad the byte slice to fit the write block size.\n\t\tbuf := make([]byte, f.writeBlockSize)\n\t\tcopy(buf, p[start:start+writeSize])\n\t\t// Enable write mode on the flash memory controller.\n\t\tf.enableWriteMode()\n\t\t// Write the data in blocks.\n\t\tf.writeBlock(buf, addr)\n\t\t// Wait for the flash memory to be ready after each write operation.\n\t\tf.waitReady()\n\t\t// Disable write mode on the flash memory controller.\n\t\tf.disableWriteMode()\n\t\t// Increment the start address.\n\t\tstart += writeSize\n\t}\n\treturn len(p), nil\n}\n", "CodeBleu_score": 30.10304736801389}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\t// Check if the write operation exceeds the flash memory bounds.\n\tif off < 0 || off >= int64(f.size) {\n\t\treturn 0, errors.New(\"write operation exceeds the flash memory bounds\")\n\t}\n\n\t// Calculate the start address for writing.\n\taddr := f.base + uint32(off)\n\n\t// Pad the byte slice to fit the write block size.\n\tp = pad(p, int(f.blockSize))\n\n\t// Enable write mode on the flash memory controller.\n\tf.enableWriteMode()\n\n\t// Write the data in blocks.\n\tfor i := 0; i < len(p); i += int(f.blockSize) {\n\t\t// Wait for the flash memory to be ready.\n\t\tf.waitForReady()\n\n\t\t// Write the block.\n\t\tf.writeBlock(addr+uint32(i), p[i:i+int(f.blockSize)])\n\t}\n\n\t// Wait for the flash memory to be ready.\n\tf.waitForReady()\n\n\t// Disable write mode on the flash memory controller.\n\tf.disableWriteMode()\n\n\t// Return the number of bytes written.\n\treturn len(p), nil\n}\n", "CodeBleu_score": 29.213816109905643}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"unable to duplicate file descriptor: %s\", err)\n\t}\n\t// Open the directory.\n\tdir, err := syscall.Fdopendir(dupFd)\n\tif err != nil {\n\t\t// Close the duplicated file descriptor.\n\t\tsyscall.Close(dupFd)\n\t\t// Return the error.\n\t\treturn 0, \"\", fmt.Errorf(\"unable to open directory: %s\", err)\n\t}\n\t// Return the directory pointer.\n\treturn uintptr(dir), \"\", nil\n}\n", "CodeBleu_score": 47.484628297412044}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\t// Duplicate the file descriptor.\n\tdupFd, err := syscall.Dup(int(fd))\n\tif err != nil {\n\t\treturn 0, \"\", fmt.Errorf(\"duplicate file descriptor: %w\", err)\n\t}\n\t// Attempt to open the directory using the duplicated file descriptor.\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Close the duplicated file descriptor.\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", fmt.Errorf(\"open directory: %w\", err)\n\t\t}\n\t\tbreak\n\t}\n\treturn dir, \"\", nil\n}\n", "CodeBleu_score": 59.642139192720634}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tvar err error\n\tvar dir uintptr\n\tvar dupfd syscallFd\n\tvar errno syscall.Errno\n\tvar errstr string\n\tvar ok bool\n\tvar errstr2 string\n\n\t// Duplicate the provided file descriptor.\n\tdupfd, err = syscall.Dup(int(fd))\n\tif err != nil {\n\t\terrstr = fmt.Sprintf(\"syscall.Dup failed: %s\", err)\n\t\treturn 0, errstr, nil\n\t}\n\n\t// Loop until we either succeed or encounter an error other than \"syscall.EINTR\".\n\tfor {\n\t\tdir, err = syscall.Fdopendir(int(dupfd))\n\t\tif err != nil {\n\t\t\terrno, ok = err.(syscall.Errno)\n\t\t\tif !ok {\n\t\t\t\terrstr = fmt.Sprintf(\"syscall.Fdopendir failed: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif errno != syscall.EINTR {\n\t\t\t\terrstr = fmt.Sprintf(\"syscall.Fdopendir failed: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Close the duplicated file descriptor if we failed to open the directory.\n\tif err != nil {\n\t\terrstr2 = fmt.Sprintf(\"syscall.Close failed: %s\", syscall.Close(int(dupfd)))\n\t\tif errstr2 != \"\" {\n\t\t\terrstr = fmt.Sprintf(\"%s\\n%s\", errstr, errstr2)\n\t\t}\n\t}\n\n\t// Return the directory pointer and error.\n\treturn dir, errstr, err\n}\n", "CodeBleu_score": 43.14811282588845}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response)  uint32_t size = 0;\n  uint32_t total = 0;\n  uint32_t used = 0;\n\n  esp_partition_iterator_t partitionIterator = esp_partition_find(ESP_PARTITION_TYPE_APP, ESP_PARTITION_SUBTYPE_ANY, NULL);\n  if (partitionIterator == NULL) {\n    return 0;\n  }\n  esp_partition_t *partition = esp_partition_get(partitionIterator);\n  if (partition == NULL) {\n    return 0;\n  }\n  esp_image_metadata_t imageMetadata;\n  if (esp_image_verify(ESP_IMAGE_VERIFY, partition->address, &imageMetadata) == ESP_OK) {\n    if (response == FREE_SPACE) {\n      size = partition->size - imageMetadata.image_len;\n    } else {\n      size = imageMetadata.image_len;\n    }\n  }\n  esp_partition_iterator_release(partitionIterator);\n  return size;\n}\n", "CodeBleu_score": 47.69791169261749}, {"code": "static uint32_t sketchSize(sketchSize_t response)  uint32_t sketchSize = 0;\n  uint32_t freeSpace = 0;\n  uint32_t imageSize = 0;\n  uint32_t imageCRC = 0;\n  uint32_t imageMagic = 0;\n  uint32_t imageType = 0;\n  uint32_t imagePart = 0;\n  uint32_t imageNum = 0;\n  uint32_t imageSizePart = 0;\n  uint32_t imageCRCPart = 0;\n  uint32_t imageMagicPart = 0;\n  uint32_t imageTypePart = 0;\n  uint32_t imageNumPart = 0;\n  uint32_t imageSizePart2 = 0;\n  uint32_t imageCRCPart2 = 0;\n  uint32_t imageMagicPart2 = 0;\n  uint32_t imageTypePart2 = 0;\n  uint32_t imageNumPart2 = 0;\n  uint32_t imageSizePart3 = 0;\n  uint32_t imageCRCPart3 = 0;\n  uint32_t imageMagicPart3 = 0;\n  uint32_t imageTypePart3 = 0;\n  uint32_t imageNumPart3 = 0;\n  uint32_t imageSizePart4 = 0;\n  uint32_t imageCRCPart4 = 0;\n  uint32_t imageMagicPart4 = 0;\n  uint32_t imageTypePart4 = 0;\n  uint32_t imageNumPart4 = 0;\n  uint32_t imageSizePart5 = 0;\n  uint32_t imageCRCPart5 = 0;\n  uint32_t imageMagicPart5 = 0;\n  uint32_t imageTypePart5 = 0;\n  uint32_t imageNumPart5 = 0;\n  uint32_t imageSizePart6 = 0;\n  uint32_t imageCRCPart6", "CodeBleu_score": 7.583517207084495}, {"code": "static uint32_t sketchSize(sketchSize_t response)  uint32_t sketchSize = 0;\n  const esp_partition_t* partition = esp_ota_get_running_partition();\n  if (partition) {\n    const esp_partition_t* ota = esp_ota_get_next_update_partition(NULL);\n    if (ota && (ota->address == partition->address)) {\n      if (response) {\n        sketchSize = partition->size - (ota->size + ota->address - partition->address);\n      } else {\n        sketchSize = ota->size;\n      }\n    }\n  }\n  return sketchSize;\n}\n", "CodeBleu_score": 44.21499342690189}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)    uint32_t disk_sectors;\n    uint32_t disk_size;\n    uint32_t fat_size;\n    uint32_t fat_sectors;\n    uint32_t fat_entries;\n    uint32_t root_dir_sectors;\n    uint32_t root_dir_entries;\n    uint32_t data_sectors;\n    uint32_t data_size;\n    uint32_t data_start_sector;\n    uint32_t root_dir_start_sector;\n    uint32_t root_dir_start_cluster;\n    uint32_t fat_start_sector;\n    uint32_t fat_start_cluster;\n    uint32_t root_dir_start_cluster_offset;\n    uint32_t root_dir_cluster_offset;\n    uint32_t root_dir_entry_offset;\n    uint32_t cluster_offset;\n    uint32_t cluster_size;\n    uint32_t cluster_count;\n    uint32_t cluster_index;\n    uint32_t cluster_index_offset;\n    uint32_t cluster_index_offset_offset;\n    uint32_t cluster_index_offset_cluster;\n    uint32_t cluster_index_offset_cluster_offset;\n    uint32_t cluster_index_offset_cluster_offset_offset;\n    uint32_t cluster_index_offset_cluster_offset_offset_offset;\n    uint32_t cluster_index_offset_cluster_offset_offset_offset_offset;\n    uint32_t cluster_index_offset_cluster_offset_offset_offset_offset_offset;\n    uint32_t cluster_index_offset_cluster_offset_offset_offset_offset_offset_offset;\n    uint32_t cluster_index_offset_cluster_offset_offset_offset_offset_offset_offset_offset;\n    uint32_t cluster_index_offset_cluster_offset_offset_offset_offset_offset_offset_offset_offset;\n    uint32_t cluster", "CodeBleu_score": 6.909570358984333}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)  uint32_t bytes_per_sector;\n  uint32_t sectors_per_cluster;\n  uint32_t reserved_sectors;\n  uint32_t number_of_fats;\n  uint32_t number_of_root_entries;\n  uint32_t total_sectors;\n  uint32_t sectors_per_fat;\n  uint32_t sectors_per_track;\n  uint32_t number_of_heads;\n  uint32_t hidden_sectors;\n  uint32_t sectors_per_partition;\n  uint32_t boot_sector_offset;\n  uint32_t fat_offset;\n  uint32_t root_dir_offset;\n  uint32_t data_offset;\n  uint32_t i;\n  uint32_t j;\n  uint32_t k;\n  uint8_t *disk;\n  uint8_t *boot_sector;\n  uint8_t *fat;\n  uint8_t *root_dir;\n  uint8_t *data;\n  uint8_t *p;\n  uint8_t *q;\n  uint8_t *r;\n  uint8_t *s;\n  uint8_t *t;\n  uint8_t *u;\n  uint8_t *v;\n  uint8_t *w;\n  uint8_t *x;\n  uint8_t *y;\n  uint8_t *z;\n  uint8_t *a;\n  uint8_t *b;\n  uint8_t *c;\n  uint8_t *d;\n  uint8_t *e;\n  uint8_t *f;\n  uint8_t *g;\n  uint8_t *h;\n  uint8_t *i_p;\n  uint8_t *j_p;\n  uint8_t *k_p;\n  uint8_t *l_p;\n  uint8_t *m_p;\n  uint8_t *n_p", "CodeBleu_score": 8.770119775495175}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)\tuint32_t disk_size = MSC_DISK_SECTORS * MSC_DISK_SECTOR_SIZE;\n\tuint8_t *disk = (uint8_t *)malloc(disk_size);\n\tif (disk == NULL) {\n\t\tESP_LOGE(TAG, \"Failed to allocate %d bytes for RAM disk\", disk_size);\n\t\treturn false;\n\t}\n\tmemset(disk, 0, disk_size);\n\tmsc_disk = disk;\n\tmsc_disk_size = disk_size;\n\tmsc_disk_sectors = MSC_DISK_SECTORS;\n\tmsc_disk_sector_size = MSC_DISK_SECTOR_SIZE;\n\tmsc_disk_fat_start_sector = MSC_DISK_FAT_START_SECTOR;\n\tmsc_disk_fat_sectors = MSC_DISK_FAT_SECTORS;\n\tmsc_disk_data_start_sector = MSC_DISK_DATA_START_SECTOR;\n\tmsc_disk_data_sectors = MSC_DISK_DATA_SECTORS;\n\tmsc_disk_root_start_sector = MSC_DISK_ROOT_START_SECTOR;\n\tmsc_disk_root_sectors = MSC_DISK_ROOT_SECTORS;\n\tmsc_disk_root_entries = MSC_DISK_ROOT_ENTRIES;\n\tmsc_disk_root_entry_size = MSC_DISK_ROOT_ENTRY_SIZE;\n\tmsc_disk_root_entry_name_size = MSC_DISK_ROOT_ENTRY_NAME_SIZE;\n\tmsc_disk_root_entry_name_offset = MSC_DISK_ROOT_ENTRY_NAME_OFFSET;\n\tmsc_disk_root_entry_name_padding = MSC_DISK_ROOT_ENTRY_NAME_PADDING;\n\tmsc_disk_root_entry_extension_size = MSC_DISK_ROOT_ENTRY_EXTENSION_SIZE;\n", "CodeBleu_score": 25.63219899551215}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    esp_err_t err = ESP_OK;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        err = esp_partition_erase_range(partition, offset, SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Erase failed at 0x%x\", offset);\n            return err;\n        }\n    }\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Write failed at 0x%x\", offset);\n    }\n    return err;\n}\n", "CodeBleu_score": 67.35696859805435}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    esp_err_t err = ESP_OK;\n    if (offset % SPI_FLASH_SEC_SIZE == 0) {\n        err = spi_flash_erase_sector(offset / SPI_FLASH_SEC_SIZE);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Erase failed at 0x%08x\", offset);\n            return err;\n        }\n    }\n    err = spi_flash_write(offset, data, size);\n    return err;\n}\n", "CodeBleu_score": 52.41732804293693}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    esp_err_t err = ESP_OK;\n    uint32_t start_addr = partition->address + offset;\n    uint32_t sector_size = spi_flash_get_sector_size(start_addr);\n    uint32_t aligned_addr = start_addr - (start_addr % sector_size);\n\n    if (offset % sector_size == 0) {\n        // Sector-aligned write, so erase before writing...\n        err = spi_flash_erase_sector(aligned_addr / sector_size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase sector at 0x%08x\", aligned_addr);\n            return err;\n        }\n    }\n\n    err = spi_flash_write(start_addr, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write to flash at 0x%08x\", start_addr);\n        return err;\n    }\n\n    return err;\n}\n", "CodeBleu_score": 51.52686567152305}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t i = 0, j = 0, k = 0;\n    unsigned char c;\n    while(in[i] != '\\0' && k < maxlen) {\n        c = in[i];\n        if(c >= '0' && c <= '9')\n            c -= '0';\n        else if(c >= 'A' && c <= 'F')\n            c = c - 'A' + 10;\n        else if(c >= 'a' && c <= 'f')\n            c = c - 'a' + 10;\n        else {\n            i++;\n            continue;\n        }\n        if(i % 2 == 0)\n            out[j] = (c << 4);\n        else\n            out[j++] |= c;\n        i++;\n        k++;\n    }\n    return k;\n}\n", "CodeBleu_score": 39.30210772610769}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)\tsize_t i = 0;\n\tunsigned char c;\n\twhile (i < maxlen && in[0] != '\\0') {\n\t\tif (in[0] == ' ') {\n\t\t\tin++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[0] == '\\0') {\n\t\t\tbreak;\n\t\t}\n\t\tc = (unsigned char) in[0];\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tc -= '0';\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tc -= 'A' - 10;\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tc -= 'a' - 10;\n\t\t} else {\n\t\t\tin++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in[1] == '\\0') {\n\t\t\tbreak;\n\t\t}\n\t\tc <<= 4;\n\t\tc |= (unsigned char) in[1];\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tc -= '0';\n\t\t} else if (c >= 'A' && c <= 'F') {\n\t\t\tc -= 'A' - 10;\n\t\t} else if (c >= 'a' && c <= 'f') {\n\t\t\tc -= 'a' - 10;\n\t\t} else {\n\t\t\tin++;\n\t\t\tcontinue;\n\t\t}\n\t\tout[i++] = c;\n\t\tin += 2;\n\t}\n\treturn i;\n}\n", "CodeBleu_score": 30.360633322628694}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)  size_t len = 0;\n  size_t i = 0;\n  char c;\n  char c1;\n  char c2;\n  char c3;\n  char c4;\n  char c5;\n  char c6;\n  char c7;\n  char c8;\n  char c9;\n  char c10;\n  char c11;\n  char c12;\n  char c13;\n  char c14;\n  char c15;\n  char c16;\n  char c17;\n  char c18;\n  char c19;\n  char c20;\n  char c21;\n  char c22;\n  char c23;\n  char c24;\n  char c25;\n  char c26;\n  char c27;\n  char c28;\n  char c29;\n  char c30;\n  char c31;\n  char c32;\n  char c33;\n  char c34;\n  char c35;\n  char c36;\n  char c37;\n  char c38;\n  char c39;\n  char c40;\n  char c41;\n  char c42;\n  char c43;\n  char c44;\n  char c45;\n  char c46;\n  char c47;\n  char c48;\n  char c49;\n  char c50;\n  char c51;\n  char c52;\n  char c53;\n  char c54;\n  char c55;\n  char c56;\n  char c57;\n  char c58;\n  char c59;\n  char c60;\n  char c61;\n  char c62;\n  char c63;\n  char c64;\n  char c65;\n  char c66;\n  char c67;\n  char c68;\n  char c69;\n  char c70;\n  char c71;", "CodeBleu_score": 7.834037284263061}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void)  int freeSize = 0;\n\n  if (txRingBuffer == NULL) {\n    return 0;\n  }\n\n  if (xSemaphoreTake(txRingBuffer->lock, pdMS_TO_TICKS(100)) == pdTRUE) {\n    freeSize = txRingBuffer->freeSize();\n    xSemaphoreGive(txRingBuffer->lock);\n  }\n  return freeSize;\n}\n", "CodeBleu_score": 48.07927001008635}, {"code": "int HWCDC::availableForWrite(void)\tif (tx_buffer == NULL)\n\t\treturn 0;\n\tif (tx_lock == NULL)\n\t\treturn 0;\n\tif (xSemaphoreTake(tx_lock, 10) == pdTRUE) {\n\t\tint free = tx_buffer->availableForStore();\n\t\txSemaphoreGive(tx_lock);\n\t\treturn free;\n\t}\n\treturn 0;\n}\n", "CodeBleu_score": 51.38067041546254}, {"code": "int HWCDC::availableForWrite(void)\tint freeSize = 0;\n\n\tif (txRingBuffer == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (sem_wait(&txRingBuffer->semaphore) == 0) {\n\t\tfreeSize = txRingBuffer->getFreeSize();\n\t\tsem_post(&txRingBuffer->semaphore);\n\t}\n\n\treturn freeSize;\n}\n", "CodeBleu_score": 41.735917597750955}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)  lock();\n  _onReceiveCB = function;\n  _rxTimeout = onlyOnTimeout;\n  if (_onReceiveCB) {\n    _rxFifo.setFullThreshold(_rxFifo.getSize() - 1);\n    if (!_rxTask) {\n      _rxTask = xTaskCreatePinnedToCore(receiveTask, \"rx\", 2048, this, 1, NULL, _core);\n    }\n  }\n  unlock();\n}\n", "CodeBleu_score": 43.79168948168531}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    _onReceiveCB = function;\n    _rxTimeout = onlyOnTimeout;\n    _rxFullThreshold = 1;\n\n    if (function) {\n        _rxFullThreshold = 0;\n        if (!_rxTaskHandle) {\n            _rxTaskHandle = xTaskCreatePinnedToCore(receiveTask, \"HWSerialRx\", 2048, (void *)this, 1, &_rxTaskCore);\n        }\n    }\n}\n", "CodeBleu_score": 34.506185766136944}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)  if (function) {\n    _onReceiveCB = function;\n    _rxTimeout = onlyOnTimeout;\n    _rx_buffer_head = _rx_buffer_tail = 0;\n    _rx_buffer_count = 0;\n    _rx_buffer_full_count = 0;\n    _rx_buffer_overrun_count = 0;\n    _rx_buffer_overrun_count_last = 0;\n    _rx_buffer_overrun_count_last_time = 0;\n    _rx_buffer_overrun_count_last_time_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last_last_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last_last_last_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last_last_last_last_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last_last_last_last_last_last_last_last = 0;\n    _rx_buffer_overrun_count_last_time_last_last_last_last_last_last_last_last_last_last_last_last = 0;\n    _rx_buffer_", "CodeBleu_score": 17.602373901168363}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)    if (length < 1) return 0;\n    size_t index = 0;\n    char character;\n    while (1) {\n        int result = timedRead(&character, 1);\n        if (result < 1) {\n            // We timed out, or we reached the end of the stream\n            break;\n        }\n        // We got a character\n        if (character == terminator) {\n            // We reached the terminator, so stop reading\n            break;\n        }\n        // We didn't reach the terminator, so add the character to the buffer\n        if (index < length - 1) {\n            buffer[index] = character;\n            index++;\n        }\n    }\n    buffer[index] = 0;\n    return index;\n}\n", "CodeBleu_score": 62.01080582257064}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)  if (length < 1) return 0;\n  size_t index = 0;\n  while (1) {\n    int c = timedRead();\n    if (c < 0 || c == terminator || index == length - 1) {\n      buffer[index] = (char)c;\n      buffer[index + 1] = '\\0';\n      return index;\n    }\n    buffer[index] = (char)c;\n    index++;\n  }\n}\n", "CodeBleu_score": 72.02757485346628}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)  if (length < 1) return 0;\n  char c = 0;\n  size_t i = 0;\n  while (i < length) {\n    if (read(&c, 1) != 1) {\n      return i;\n    }\n    if (c == terminator) {\n      break;\n    }\n    *buffer++ = c;\n    i++;\n  }\n  *buffer = 0;\n  return i;\n}\n", "CodeBleu_score": 62.77001034235177}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  Serial.print(\"Tone: \");\n  Serial.print(pin);\n  Serial.print(\" \");\n  Serial.print(frequency);\n  Serial.print(\" \");\n  Serial.println(duration);\n\n  if (isPinUsed(pin)) {\n    Serial.println(\"Pin already in use.\");\n  } else {\n    setPinUsed(pin, true);\n    Serial.println(\"Pin set to used.\");\n    tone_queue.push(new Tone(pin, frequency, duration));\n    Serial.println(\"Tone added to queue.\");\n  }\n}\n", "CodeBleu_score": 33.20526071317036}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)    // Log the pin, frequency, and duration\n    Serial.print(\"Tone on pin \");\n    Serial.print(pin);\n    Serial.print(\" with frequency \");\n    Serial.print(frequency);\n    Serial.print(\" and duration \");\n    Serial.print(duration);\n    Serial.print(\" ms\\n\");\n\n    // Check if the pin is available or already in use\n    if (pinStatus[pin] == 0) {\n        // If the pin is available, initialize the tone and send a start command with the pin, frequency, and duration to a queue\n        pinStatus[pin] = 1;\n        pinMode(pin, OUTPUT);\n        tone(pin, frequency, duration);\n        toneQueue.push(Tone(pin, frequency, duration));\n    } else {\n        // If the pin is in use, log an error message instructing to stop the current tone on the pin first\n        Serial.print(\"Tone on pin \");\n        Serial.print(pin);\n        Serial.print(\" is already in use. Please stop the current tone first.\\n\");\n    }\n}\n", "CodeBleu_score": 37.137287648671396}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  Serial.println(\"tone\");\n  Serial.println(pin);\n  Serial.println(frequency);\n  Serial.println(duration);\n\n  if (pin == 11) {\n    Serial.println(\"Pin 11 is in use\");\n  } else {\n    Serial.println(\"Pin 11 is available\");\n    tone_queue.push(pin);\n    tone_queue.push(frequency);\n    tone_queue.push(duration);\n  }\n}\n", "CodeBleu_score": 31.03031614774811}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled)  if (!USB_STARTED) {\n    USB_WEBUSB_ENABLED = enabled;\n    return true;\n  }\n  if (enabled) {\n    if (USB_VERSION < 0x0210) {\n      USB_VERSION = 0x0210;\n    }\n    USB_WEBUSB_ENABLED = true;\n  } else {\n    USB_WEBUSB_ENABLED = false;\n  }\n  return false;\n}\n", "CodeBleu_score": 51.945417450638644}, {"code": "bool ESPUSB::webUSB(bool enabled)\tif (enabled) {\n\t\tif (!_usbStarted) {\n\t\t\t_usbEnabled = true;\n\t\t\treturn true;\n\t\t}\n\t\tif (usbVersion() < 0x0210) {\n\t\t\tusbVersion(0x0210);\n\t\t}\n\t}\n\t_usbEnabled = enabled;\n\treturn false;\n}\n", "CodeBleu_score": 45.14644304399089}, {"code": "bool ESPUSB::webUSB(bool enabled)  if (!usbStarted) {\n    webUSBEnabled = enabled;\n    return true;\n  }\n\n  if (enabled) {\n    if (usbVersion < 0x0210) {\n      usbVersion = 0x0210;\n      USB_CTRL_IN_BUF[0] = 0x02;\n      USB_CTRL_IN_BUF[1] = 0x10;\n      USB_CTRL_IN_BUF[2] = 0x00;\n      USB_CTRL_IN_BUF[3] = 0x00;\n      USB_CTRL_IN_BUF[4] = 0x00;\n      USB_CTRL_IN_BUF[5] = 0x00;\n      USB_CTRL_IN_BUF[6] = 0x00;\n      USB_CTRL_IN_BUF[7] = 0x00;\n      USB_CTRL_IN_BUF[8] = 0x00;\n      USB_CTRL_IN_BUF[9] = 0x00;\n      USB_CTRL_IN_BUF[10] = 0x00;\n      USB_CTRL_IN_BUF[11] = 0x00;\n      USB_CTRL_IN_BUF[12] = 0x00;\n      USB_CTRL_IN_BUF[13] = 0x00;\n      USB_CTRL_IN_BUF[14] = 0x00;\n      USB_CTRL_IN_BUF[15] = 0x00;\n      USB_CTRL_IN_BUF[16] = 0x00;\n      USB_CTRL_IN_BUF[17] = 0x00;\n      USB_CTRL_IN_BUF[18] = 0x00;\n      USB_CTRL_IN_BUF[19] = 0x00;\n      USB_CTRL_IN_BUF[20] = 0x", "CodeBleu_score": 44.22593911583362}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX()  uint8_t buf[64];\n  uint8_t len = 0;\n  uint8_t dropped = 0;\n  uint8_t i = 0;\n\n  while (USBSerial.available()) {\n    buf[i] = USBSerial.read();\n    i++;\n    if (i == sizeof(buf)) {\n      len = i;\n      dropped = i;\n      break;\n    }\n  }\n\n  if (len) {\n    if (len == dropped) {\n      logError(\"USB CDC receive overflow\");\n      postReceiveOverflow(dropped);\n    } else {\n      postReceive(len);\n    }\n  }\n}\n", "CodeBleu_score": 30.45662183460125}, {"code": "void USBCDC::_onRX()  uint8_t buf[64];\n  uint8_t n = 0;\n  while (Serial.available()) {\n    buf[n++] = Serial.read();\n  }\n  if (n > 0) {\n    if (receiveQueue.enqueue_isr(buf, n) == 0) {\n      // queue is full, post an overflow event\n      EventOverflow evt(n);\n      evt.dispatch();\n      LOG(L_ERROR, \"USB CDC receive queue overflowed; %u bytes dropped\\n\", n);\n    } else {\n      // queue is not full, post a receive event\n      EventReceive evt(n);\n      evt.dispatch();\n    }\n  }\n}\n", "CodeBleu_score": 17.786977886912098}, {"code": "void USBCDC::_onRX()\tuint8_t buf[CDC_RX_BUFFER_SIZE];\n\tint len = USBDevice.read(CDC_RX_ENDPOINT, buf, CDC_RX_BUFFER_SIZE);\n\tif (len > 0) {\n\t\tif (rxQueue.enqueue_all(buf, len) != len) {\n\t\t\tuint32_t dropped = rxQueue.size() + len - rxQueue.capacity();\n\t\t\trxQueue.clear();\n\t\t\tif (dropped > 0) {\n\t\t\t\tLOG(S_ERROR, \"USBCDC: RX overflow, %d bytes dropped\", dropped);\n\t\t\t\tEvent(USBCDC::EventType::RX_OVERFLOW, dropped);\n\t\t\t}\n\t\t}\n\t\tEvent(USBCDC::EventType::RX, len);\n\t}\n}\n", "CodeBleu_score": 21.560108628169132}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\":robot\")\n\trobot := a.getRobot(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"No robot found with name %s\", robotName)))\n\t\treturn\n\t}\n\n\tdevices := make(map[string]string)\n\tfor _, device := range robot.Devices {\n\t\tdevices[device.Name] = device.Type\n\t}\n\n\tjson, err := json.Marshal(devices)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"Error while marshalling devices\"))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(json)\n}\n", "CodeBleu_score": 33.08741172874978}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Retrieve the robot name from the URL path.\n\trobotName := req.URL.Path[len(\"/robots/\"):]\n\t// Check if a robot with the given name exists.\n\tif robot, ok := a.robots[robotName]; ok {\n\t\t// Gather the robot's devices into a JSON format.\n\t\tdevices := make([]map[string]interface{}, len(robot.devices))\n\t\tfor i, device := range robot.devices {\n\t\t\tdevices[i] = map[string]interface{}{\n\t\t\t\t\"name\":   device.name,\n\t\t\t\t\"type\":   device.typ,\n\t\t\t\t\"values\": device.values,\n\t\t\t}\n\t\t}\n\t\t// Write the JSON response to the HTTP response writer.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tjson.NewEncoder(res).Encode(map[string]interface{}{\n\t\t\t\"success\": true,\n\t\t\t\"devices\": devices,\n\t\t})\n\t} else {\n\t\t// Write a JSON response with an error message to the HTTP response writer.\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tjson.NewEncoder(res).Encode(map[string]interface{}{\n\t\t\t\"success\": false,\n\t\t\t\"error\":   fmt.Sprintf(\"No robot with the name '%s' was found.\", robotName),\n\t\t})\n\t}\n}\n", "CodeBleu_score": 45.678934569092945}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\t// Get the robot name from the URL path\n\trobotName := req.URL.Path[len(\"/robots/\"):]\n\n\t// Get the robot from the robot store\n\trobot := a.robotStore.Robot(robotName)\n\n\t// Check if the robot exists\n\tif robot == nil {\n\t\t// If not, return an error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"{\\\"error\\\":\\\"No robot found with the specified name\\\"}\"))\n\t\treturn\n\t}\n\n\t// Create a JSON array to hold the robot's devices\n\tvar devices []string\n\n\t// Iterate through the robot's devices\n\tfor _, device := range robot.Devices() {\n\t\t// Add the device's name to the JSON array\n\t\tdevices = append(devices, device.Name())\n\t}\n\n\t// Create a JSON object to hold the robot's name and devices\n\trobotDevices := map[string][]string{\"name\": robot.Name(), \"devices\": devices}\n\n\t// Create a JSON encoder\n\tencoder := json.NewEncoder(res)\n\n\t// Encode the robot's name and devices into the HTTP response writer\n\tencoder.Encode(robotDevices)\n}\n", "CodeBleu_score": 47.025113792943245}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\":robot\")\n\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with name \" + robotName + \" found\"))\n\t\treturn\n\t}\n\n\tconnections := []Connection{}\n\tfor _, conn := range robot.Connections {\n\t\tconnections = append(connections, Connection{\n\t\t\tName:        conn.Name,\n\t\t\tDescription: conn.Description,\n\t\t\tType:        conn.Type,\n\t\t\tDirection:   conn.Direction,\n\t\t\tValue:       conn.Value,\n\t\t})\n\t}\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 45.81893121341816}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\trobotName := req.URL.Path[len(\"/robots/\"):]\n\t// Check if the robot exists\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\t// If the robot does not exist, write an error message to the HTTP response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with the name \" + robotName + \" was found.\"))\n\t\treturn\n\t}\n\t// If the robot exists, convert its connections to JSON format and write them to the HTTP response\n\tconnections, err := json.Marshal(robot.connections)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"An error occurred while converting the robot's connections to JSON format.\"))\n\t\treturn\n\t}\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connections)\n}\n", "CodeBleu_score": 33.695540663809965}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robot\"]\n\n\t// Check if the robot exists\n\trobot := a.world.Robot(robotName)\n\tif robot == nil {\n\t\t// The robot does not exist, so return an error message\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprintf(res, \"No robot with name %s found\", robotName)\n\t\treturn\n\t}\n\n\t// The robot exists, so iterate through its connections and convert them to JSON format\n\tconnections := make([]Connection, 0)\n\tfor _, c := range robot.Connections() {\n\t\tconnections = append(connections, Connection{\n\t\t\tRobotName: c.RobotName,\n\t\t\tSensor:    c.Sensor,\n\t\t\tActuator:  c.Actuator,\n\t\t})\n\t}\n\n\t// Write the connections to the HTTP response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 44.65848561927098}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Get the robot and device names from the URL query parameters\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot exists\n\trobot := a.robots.Get(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, \"Robot not found\", nil)\n\t\treturn\n\t}\n\n\t// Check if the device exists\n\tdevice := robot.Device(deviceName)\n\tif device == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, \"Device not found\", nil)\n\t\treturn\n\t}\n\n\t// Read the command from the request body\n\tcommand := new(Command)\n\tif err := json.NewDecoder(req.Body).Decode(command); err != nil {\n\t\ta.writeJSON(res, http.StatusBadRequest, \"Invalid JSON request\", nil)\n\t\treturn\n\t}\n\n\t// Execute the command\n\tif err := device.Command(command.Name, command.Parameters...); err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, \"Error executing command\", nil)\n\t\treturn\n\t}\n\n\t// Write the response\n\ta.writeJSON(res, http.StatusOK, \"Command executed\", nil)\n}\n", "CodeBleu_score": 48.85033286500552}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Retrieve the robot name and device name from the URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if the robot exists.\n\tif _, ok := a.robots[robotName]; !ok {\n\t\t// The robot does not exist.\n\t\t// Write an error message as a JSON response.\n\t\ta.writeJSON(res, http.StatusNotFound, &Error{Message: fmt.Sprintf(\"robot %s does not exist\", robotName)})\n\t\treturn\n\t}\n\n\t// Check if the device exists.\n\tif _, ok := a.robots[robotName].Devices()[deviceName]; !ok {\n\t\t// The device does not exist.\n\t\t// Write an error message as a JSON response.\n\t\ta.writeJSON(res, http.StatusNotFound, &Error{Message: fmt.Sprintf(\"device %s does not exist\", deviceName)})\n\t\treturn\n\t}\n\n\t// Retrieve the command name from the URL query parameters.\n\tcommandName := req.URL.Query().Get(\"command\")\n\n\t// Check if the command exists.\n\tif _, ok := a.robots[robotName].Devices()[deviceName].Commands()[commandName]; !ok {\n\t\t// The command does not exist.\n\t\t// Write an error message as a JSON response.\n\t\ta.writeJSON(res, http.StatusNotFound, &Error{Message: fmt.Sprintf(\"command %s does not exist\", commandName)})\n\t\treturn\n\t}\n\n\t// Execute the command on the device.\n\tif err := a.robots[robotName].Devices()[deviceName].Commands()[commandName].Command().Run(); err != nil {\n\t\t// An error occurred while executing the command.\n\t\t// Write the error message as a JSON response.\n\t\ta.writeJSON(res, http.StatusInternalServerError, &Error{Message: err.Error()})\n\t\treturn\n\t}\n\n\t// Write a success message as a JSON response.\n\ta.writeJSON(res, http.", "CodeBleu_score": 49.207788972801126}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\t// Get robot name and device name from URL query parameters.\n\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\t// Check if robot exists.\n\tif _, ok := a.robots[robotName]; !ok {\n\t\ta.writeJSONError(res, http.StatusNotFound, \"Robot not found\", \"The robot \"+robotName+\" was not found.\")\n\t\treturn\n\t}\n\n\t// Check if device exists.\n\tif _, ok := a.robots[robotName].Devices()[deviceName]; !ok {\n\t\ta.writeJSONError(res, http.StatusNotFound, \"Device not found\", \"The device \"+deviceName+\" was not found on robot \"+robotName+\".\")\n\t\treturn\n\t}\n\n\t// Execute command on device.\n\terr := a.robots[robotName].Devices()[deviceName].Command(req.URL.Query().Get(\"command\"))\n\tif err != nil {\n\t\ta.writeJSONError(res, http.StatusInternalServerError, \"Error executing command\", \"An error occurred while executing the command \"+req.URL.Query().Get(\"command\")+\" on device \"+deviceName+\" on robot \"+robotName+\": \"+err.Error()+\".\")\n\t\treturn\n\t}\n\n\t// Write response.\n\ta.writeJSON(res, http.StatusOK, \"Command executed\", \"The command \"+req.URL.Query().Get(\"command\")+\" was executed on device \"+deviceName+\" on robot \"+robotName+\".\")\n}\n", "CodeBleu_score": 48.715803848942045}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 51.558350599462464}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// If the request is missing an Authorization header, return a 401 status and a WWW-Authenticate header\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the Authorization header is present, attempt to extract the username and password from the header\n\t\tvar user, pass string\n\t\tif _, err := fmt.Sscanf(auth, \"Basic %s\", &userAndPass); err != nil {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the username and password from the header\n\t\tdecoded, err := base64.StdEncoding.DecodeString(userAndPass)\n\t\tif err != nil {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Split the decoded string into the username and password\n\t\tparts := bytes.SplitN(decoded, []byte(\":\"), 2)\n\t\tif len(parts) != 2 {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Check if the username and password match the expected values\n\t\tuser = string(parts[0])\n\t\tpass = string(parts[1])\n\t\tif user != username || pass != password {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n", "CodeBleu_score": 45.29776361587465}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") != \"Basic \"+base64.StdEncoding.EncodeToString([]byte(username+\":\"+password)) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// If the request has the correct authorization header, we can proceed to the next handler\n\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t}\n}\n", "CodeBleu_score": 61.52132303413035}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, ErrNotSupported\n\t}\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaled := a.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 44.82872886679589}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"Sensor does not support analog read\")\n\t}\n\trawValue, err := a.connection.AnalogRead()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\tscaledValue := a.scale(rawValue)\n\ta.lastRead = time.Now()\n\ta.lastValue = rawValue\n\ta.lastScaledValue = scaledValue\n\treturn rawValue, scaledValue, nil\n}\n", "CodeBleu_score": 52.777370635803855}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"AnalogRead not supported\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scale(raw)\n\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 47.106550247175115}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tg := &GroveSoundSensorDriver{\n\t\tname: gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tpin:  pin,\n\t\tv:    a,\n\t}\n\tg.mutex = &sync.Mutex{}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase string:\n\t\t\tg.name = option.(string)\n\t\t}\n\t}\n\n\t// Check for analog reader\n\tif g.v == nil {\n\t\tg.v = a\n\t}\n\n\treturn g\n}\n", "CodeBleu_score": 36.78148444296816}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tg := &GroveSoundSensorDriver{\n\t\tname:         gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tconnector:    a,\n\t\tpin:          pin,\n\t\tmutex:        &sync.Mutex{},\n\t\tmaxValue:     1023,\n\t\tminValue:     0,\n\t\tsoundTimeout: 100 * time.Millisecond,\n\t\tsoundLevel:   0,\n\t}\n\n\tfor _, option := range opts {\n\t\tswitch option.(type) {\n\t\tcase string:\n\t\t\tg.name = option.(string)\n\t\tcase func(sensor *GroveSoundSensorDriver):\n\t\t\toption.(func(sensor *GroveSoundSensorDriver))(g)\n\t\t}\n\t}\n\n\t// Check if mutex was provided\n\tif g.mutex == nil {\n\t\tg.mutex = &sync.Mutex{}\n\t}\n\n\t// Create and start AnalogSensorDriver\n\tg.sensor = NewAnalogSensorDriver(a, pin, g.maxValue, g.minValue, g.mutex)\n\tg.sensor.Start()\n\n\treturn g\n}\n", "CodeBleu_score": 34.547936502880276}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tg := &GroveSoundSensorDriver{\n\t\tname:         gobot.DefaultName(\"GroveSoundSensor\"),\n\t\tconnector:    a,\n\t\tpin:          pin,\n\t\tsoundSensor:  gpio.NewGroveSoundSensor(pin),\n\t\tmutex:        &sync.Mutex{},\n\t\tcurrentValue: 0,\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase string:\n\t\t\tg.name = opt.(string)\n\t\t}\n\t}\n\n\t// Check if mutex was passed in\n\tif g.mutex == nil {\n\t\tg.mutex = &sync.Mutex{}\n\t}\n\n\tgobot.RegisterDriver(g)\n\n\treturn g\n}\n", "CodeBleu_score": 34.84340194147559}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error\t// Send the SoftReset command to the MFRC522\n\tif err := d.writeRegister(CommandReg, SoftResetCommand); err != nil {\n\t\treturn fmt.Errorf(\"failed to write to the command register: %w\", err)\n\t}\n\t// Wait for the power-down bit to be cleared\n\tif err := d.waitForPowerDownBit(false, 100*time.Millisecond); err != nil {\n\t\treturn fmt.Errorf(\"failed to wait for the power-down bit to be cleared: %w\", err)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 53.13703456003401}, {"code": "func (d *MFRC522Common) softReset() error\tif err := d.writeRegister(CommandReg, SoftResetCommand); err != nil {\n\t\treturn fmt.Errorf(\"failed to write to command register: %w\", err)\n\t}\n\tif err := d.waitFor(d.initDelay); err != nil {\n\t\treturn fmt.Errorf(\"timed out waiting for soft reset: %w\", err)\n\t}\n\t// Check the power-down bit in the command register to see if the reset succeeded.\n\tstatus, err := d.readRegister(CommandReg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read command register: %w\", err)\n\t}\n\tif status&0x80 != 0 {\n\t\treturn fmt.Errorf(\"soft reset failed, command register still has power-down bit set\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 60.22518931414245}, {"code": "func (d *MFRC522Common) softReset() error\td.WriteRegister(CommandReg, SoftResetCommand)\n\n\t// Wait for the power-down bit to clear\n\tfor i := 0; i < 10; i++ {\n\t\tif (d.ReadRegister(CommandReg) & 0x10) == 0 {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\t// Check if the power-down bit is still set\n\tif (d.ReadRegister(CommandReg) & 0x10) == 0x10 {\n\t\treturn fmt.Errorf(\"soft reset failed, power-down bit not cleared\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 35.47827210656911}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Get the number of bytes in the FIFO\n\tfifoLen, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t// Check if the FIFO has enough data\n\tif fifoLen < uint8(len(backData)) {\n\t\treturn 0, errors.New(\"FIFO has less data than expected\")\n\t}\n\t// Read the data from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t// Read the control register to get the last bits received\n\tcontrol, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn control & 0x07, nil\n}\n", "CodeBleu_score": 52.93951014203547}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\t// Read the number of bytes currently in the FIFO\n\tfifoLevel, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: error reading FIFOLevelReg: %v\", err)\n\t}\n\n\t// Check if the requested number of bytes is available in the FIFO\n\tif fifoLevel < uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"readFifo: FIFO has %d bytes available, but %d bytes were requested\", fifoLevel, len(backData))\n\t}\n\n\t// Read the bytes from the FIFO\n\tfor i := 0; i < len(backData); i++ {\n\t\t// Read a byte from the FIFO\n\t\tbackData[i], err = d.readRegister(FIFODataReg)\n\t\tif err != nil {\n\t\t\treturn 0, fmt.Errorf(\"readFifo: error reading FIFODataReg: %v\", err)\n\t\t}\n\t}\n\n\t// Read the control register to get the last bits received\n\tcontrol, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"readFifo: error reading ControlReg: %v\", err)\n\t}\n\n\treturn control & 0x07, nil\n}\n", "CodeBleu_score": 54.248657440323235}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tvar err error\n\tvar length uint8\n\tvar control uint8\n\tvar i uint8\n\n\t// Get the length of the data available in the FIFO\n\tlength, err = d.getFifoLength()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Check that the provided byte slice is the same length as the FIFO\n\tif length != uint8(len(backData)) {\n\t\treturn 0, errors.New(\"MFRC522: FIFO length does not match provided byte slice length\")\n\t}\n\n\t// Read the FIFO into the byte slice\n\tfor i = 0; i < length; i++ {\n\t\tbackData[i], err = d.readFifoByte()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Read the last bits from the control register\n\tcontrol, err = d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn control & 0x07, nil\n}\n", "CodeBleu_score": 43.543088570087875}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error\td.log.Debug(\"Halting communication with PICC\")\n\t// Create and send the command\n\tcmd := []byte{0x50, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0", "CodeBleu_score": 11.602707475527655}, {"code": "func (d *MFRC522Common) piccHalt() error\td.log(\"Halting PICC...\")\n\n\t// Create and send the command.\n\tcmd := []byte{0x50, 0x01}\n\tcrc := crc16(cmd)\n\tcmd = append(cmd, byte(crc>>8), byte(crc&0xFF))\n\n\tif err := d.write(cmd); err != nil {\n\t\treturn err\n\t}\n\n\t// Read the response (the error indication).\n\tresponse := make([]byte, 2)\n\tif err := d.read(response); err != nil {\n\t\treturn err\n\t}\n\n\t// Verify that the response is an error indication.\n\tif response[0] != 0xA0 {\n\t\treturn fmt.Errorf(\"error indication response is 0x%02X, expected 0xA0\", response[0])\n\t}\n\n\t// Verify that the error code indicates success.\n\tif response[1] != 0x00 {\n\t\treturn fmt.Errorf(\"error code is 0x%02X, expected 0x00\", response[1])\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 42.79051147482221}, {"code": "func (d *MFRC522Common) piccHalt() error\td.log.Debug(\"Halting communication with PICC\")\n\tvar err error\n\tvar data []byte\n\tdata, err = d.piccTransceive([]byte{0x50, 0x00})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif data[0] != 0x00 || data[1] != 0x00 {\n\t\treturn fmt.Errorf(\"Error while halting communication with PICC: %v\", data)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 33.61725586255503}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\t// Prepare the command\n\tcmd := []byte{CMD_READ, block}\n\t// Calculate CRC\n\tcrc := d.calcCRC(cmd)\n\t// Add CRC to the command\n\tcmd = append(cmd, crc[0], crc[1])\n\t// Transmit the command\n\terr := d.write(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Read the response\n\tresp, err := d.read(17)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check response\n\tif resp[0] != CMD_READ {\n\t\treturn nil, fmt.Errorf(\"read: invalid response: %v\", resp)\n\t}\n\t// Check CRC\n\tif resp[16] != calcCRC8(resp[:16]) {\n\t\treturn nil, fmt.Errorf(\"read: invalid CRC: %v\", resp)\n\t}\n\t// Return the data\n\treturn resp[1:15], nil\n}\n", "CodeBleu_score": 45.786317441101474}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tif d.debug {\n\t\tfmt.Printf(\"piccRead(%d)\\n\", block)\n\t}\n\t// Build command buffer\n\t// Read command header\n\tcmd := []byte{0x30, 0x00, 0x00, 0x00, 0x00, 0x00}\n\t// Calculate CRC_A\n\tcmdCrc := crc.New(crc.CRC16_IBM_3740)\n\tcmdCrc.Write(cmd[0:2])\n\tcmd[2] = byte(cmdCrc.Sum16() & 0xFF)\n\tcmd[3] = byte((cmdCrc.Sum16() >> 8) & 0xFF)\n\t// Append block address\n\tcmd[4] = block\n\t// Calculate CRC_A\n\tcmdCrc = crc.New(crc.CRC16_IBM_3740)\n\tcmdCrc.Write(cmd[4:5])\n\tcmd[5] = byte(cmdCrc.Sum16() & 0xFF)\n\tcmd[6] = byte((cmdCrc.Sum16() >> 8) & 0xFF)\n\t// Send the command\n\terr := d.write(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Wait for the card response\n\tresponse, err := d.read(16)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Check response header\n\tif response[0] != 0x31 {\n\t\treturn nil, fmt.Errorf(\"piccRead: invalid response header: 0x%02x\", response[0])\n\t}\n\t// Check response CRC_A\n\tresponseCrc := crc.New(crc.CRC16_IBM_3740)\n\tresponseCrc.Write(response[0:16])\n\tif response[16] != byte(responseCrc.Sum16()&0xFF) || response[17] != byte((responseCrc.Sum16()", "CodeBleu_score": 43.02374247402159}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\t// Prepare the command to be sent.\n\t// - First byte: READ command = 0x30.\n\t// - Second byte: Block address.\n\t// - Third byte: 0x00.\n\t// - Fourth byte: 0x00.\n\t// - Fifth byte: 0x00.\n\t// - Sixth byte: 0x00.\n\t// - Seventh byte: 0x00.\n\t// - Eighth byte: 0x00.\n\t// - Ninth byte: 0x00.\n\t// - Tenth byte: 0x00.\n\t// - Eleventh byte: CRC.\n\tcommand := []byte{0x30, block, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\n\t// Calculate CRC.\n\tcrc := d.calcCRC(command[:10])\n\n\t// Add CRC to command.\n\tcommand = append(command, crc[:]...)\n\n\t// Send the command.\n\tif err := d.sendCommand(command); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the response.\n\tresponse, err := d.readResponse()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the response is a valid response to the command.\n\tif len(response) != 16 {\n\t\treturn nil, errors.New(\"invalid response\")\n\t}\n\n\t// Return the data.\n\treturn response, nil\n}\n", "CodeBleu_score": 44.07658694765372}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// Prepare values for BitFramingReg\n\tvar (\n\t\ttxLastBits = uint8(0)\n\t\trxLastBits = uint8(0)\n\t)\n\tswitch reqMode {\n\tcase piccCMDGetTemperature:\n\t\t// For the PICC command \"Get Temperature\" we do not need to transmit any data\n\t\treqMode = piccCMDGetTemperature\n\t\ttxLastBits = 0\n\t\trxLastBits = 0\n\tcase piccCMDTransfer:\n\t\t// For the PICC command \"Transfer\" we need to transmit the address\n\t\treqMode = piccCMDTransfer\n\t\ttxLastBits = 0\n\t\trxLastBits = 0\n\tcase piccCMDHaltA:\n\t\t// For the PICC command \"Halt\" we do not need to transmit any data\n\t\treqMode = piccCMDHaltA\n\t\ttxLastBits = 0\n\t\trxLastBits = 0\n\tdefault:\n\t\t// All other request modes need to transmit data\n\t\treqMode = piccCMDGenAsk\n\t\ttxLastBits = 0\n\t\trxLastBits = 0\n\t}\n\t// Build the command buffer\n\tcmdBuffer := []byte{\n\t\tpiccCMDGenAsk,\n\t\t0x00,\n\t\t0x00,\n\t\t0x00,\n\t\t0x00,\n\t\t0x00,\n\t\t0x00,\n\t}\n\t// Set the command buffer to the correct address\n\tcmdBuffer[1] = byte(reqMode)\n\t// Set the last bits in the command buffer\n\tcmdBuffer[0] = byte(reqMode) | txLastBits\n\t// Clear the collision reg\n\tif err := d.writeRegister(collReg, 0x80); err != nil {\n\t\treturn err\n\t}\n\t// Transmit the command buffer\n\tif err := d.transceive(cmdBuffer, answer, rxLastBits); err != nil {\n\t\treturn err\n\t}\n", "CodeBleu_score": 34.223200424402336}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// Check if the answer buffer has at least 2 bytes of space.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small\")\n\t}\n\n\t// Clear the collision register.\n\td.clearBitMask(CollReg, 0x80)\n\n\t// Set the transmission settings.\n\tif reqMode == ModeTransceive {\n\t\td.writeRegister(BitFramingReg, 0x87)\n\t} else {\n\t\td.writeRegister(BitFramingReg, 0x07)\n\t}\n\n\t// Set the mode to transmit and receive.\n\td.writeRegister(ModeReg, 0x00)\n\n\t// Transmit the request and receive the answer.\n\terr := d.transceive(reqMode, answer)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"transceive failed: %w\", err)\n\t}\n\n\t// Check the response length.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer too short\")\n\t}\n\n\t// Check the command in the response.\n\tif answer[0] != reqMode+1 {\n\t\treturn fmt.Errorf(\"wrong response command\")\n\t}\n\n\t// Check the CRC.\n\tif answer[len(answer)-1] != d.calculateCRC8(answer[:len(answer)-1]) {\n\t\treturn fmt.Errorf(\"wrong CRC\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 51.03013278937435}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// Check if the answer buffer has at least 2 bytes of space.\n\tif len(answer) < 2 {\n\t\treturn fmt.Errorf(\"answer buffer too small: %d < 2\", len(answer))\n\t}\n\n\t// Clear specific bits in the collision register.\n\td.ClearBitMask(MFRC522_REG_COLL, 0x80)\n\n\t// Set the transmission to use only 7 bits of the last byte.\n\tif reqMode == MFRC522_TRANSCEIVE_TYPE_A || reqMode == MFRC522_TRANSCEIVE_TYPE_B {\n\t\td.SetBitMask(MFRC522_REG_TXMODE, 0x08)\n\t}\n\n\t// Build the request command.\n\t// The command code has to be sent twice to the PICC.\n\tcmd := []byte{reqMode, reqMode}\n\n\t// Send the command.\n\tif err := d.transceive(cmd, answer); err != nil {\n\t\treturn err\n\t}\n\n\t// Set transmission to use 8 bits of the last byte.\n\td.ClearBitMask(MFRC522_REG_TXMODE, 0x08)\n\n\treturn nil\n}\n", "CodeBleu_score": 52.572436902502474}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == nil {\n\t\treturn errors.New(\"step pin is not set\")\n\t}\n\n\terr := d.stepPin.Write(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.delay)\n\n\terr = d.stepPin.Write(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 63.06443459944412}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Lock the valueMutex to ensure thread safety while accessing shared variables.\n\t// The function then triggers a valid step by setting the step pin low, waiting for a delay, and setting the step pin high.\n\t// Depending on the direction, it increments or decrements the step number.\n\t// The function returns any error encountered during the digital write operations.\n\n\terr := d.stepPin.Write(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(d.delay)\n\terr = d.stepPin.Write(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 62.07571085073107}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low\n\terr := d.stepPin.Write(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the delay\n\ttime.Sleep(d.delay)\n\n\t// Set the step pin high\n\terr = d.stepPin.Write(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number\n\tif d.direction == Clockwise {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 61.353725637833655}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.distanceMutex.Lock()\n\tdefer d.distanceMutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStop = make(chan struct{})\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\td.distanceMonitorRunning = true\n\tgo d.distanceMonitor()\n\treturn nil\n}\n", "CodeBleu_score": 32.96132578540847}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.distanceMonitorMutex.Lock()\n\tdefer d.distanceMonitorMutex.Unlock()\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.distanceMonitorStop = make(chan struct{})\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\tgo d.distanceMonitor()\n\td.distanceMonitorRunning = true\n\treturn nil\n}\n", "CodeBleu_score": 33.53246236535942}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.distanceMonitorMutex.Lock()\n\tdefer d.distanceMonitorMutex.Unlock()\n\tif d.distanceMonitorStop != nil {\n\t\treturn errors.New(\"distance monitor already started\")\n\t}\n\td.distanceMonitorStop = make(chan struct{})\n\td.distanceMonitorWg = &sync.WaitGroup{}\n\td.distanceMonitorWg.Add(1)\n\tgo d.distanceMonitor()\n\treturn nil\n}\n", "CodeBleu_score": 34.164064940719385}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\treturn func(gpio int, duration time.Duration, edge string, level uint32, id uint32) {\n\t\tif level == 1 {\n\t\t\td.start = time.Now()\n\t\t} else {\n\t\t\tduration := time.Since(d.start)\n\t\t\td.start = time.Time{}\n\t\t\td.ch <- duration\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.68444588332171}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar startTime time.Time\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTime = time.Now()\n\t\t} else {\n\t\t\td.durationChannel <- time.Since(startTime)\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.40804412413466}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tvar startTimestamp time.Duration\n\treturn func(gpio int, duration time.Duration, edge string, level uint32, tick uint32) {\n\t\tif edge == \"rising\" {\n\t\t\tstartTimestamp = duration\n\t\t} else if edge == \"falling\" {\n\t\t\tduration := duration - startTimestamp\n\t\t\td.pulseDurationChan <- duration\n\t\t\tstartTimestamp = 0\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.83499993382774}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error\t// Lock the mutex to ensure exclusive access to the sensor.\n\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor to start the measurement.\n\tif err := d.trigger.Write(gpio.High); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(10 * time.Microsecond)\n\tif err := d.trigger.Write(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur.\n\tselect {\n\tcase <-d.done:\n\t\t// The measurement is complete.\n\t\treturn nil\n\tcase <-time.After(d.timeout):\n\t\t// The measurement timed out.\n\t\treturn errors.New(\"HCSR04: timeout waiting for measurement to complete\")\n\t}\n}\n", "CodeBleu_score": 54.984648325782004}, {"code": "func (d *HCSR04Driver) measureDistance() error\t// Lock the mutex to ensure exclusive access\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor\n\tif err := d.trigger(); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\tif err := d.waitForEcho(); err != nil {\n\t\treturn err\n\t}\n\n\t// Store the measured time in microseconds\n\td.time = d.pulseIn()\n\n\treturn nil\n}\n", "CodeBleu_score": 48.30339370330727}, {"code": "func (d *HCSR04Driver) measureDistance() error\t// Lock the mutex to ensure exclusive access to the HCSR04 sensor.\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor to start the measurement.\n\tif err := d.trig.Out(gpio.High); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(time.Microsecond)\n\tif err := d.trig.Out(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the sensor to complete the measurement or for a timeout to occur.\n\tselect {\n\tcase <-d.echo.WaitForEdge(-1):\n\t\t// Measure the time between the rising edge of the echo pin and the falling edge of the echo pin.\n\t\td.duration = d.echo.Duration()\n\tcase <-time.After(d.timeout):\n\t\treturn ErrTimeout\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 54.60695620209517}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n    # Check if the token is available in the environment variables\n    if 'ACCESS_TOKEN' in os.environ and 'EXPIRES_AT' in os.environ:\n        # Check if the token is still valid\n        if os.environ['EXPIRES_AT'] >= str(int(time.time())):\n            return os.environ['ACCESS_TOKEN']\n        # Check if a refresh token is available\n        if 'REFRESH_TOKEN' in os.environ:\n            # Fetch a new access token using the refresh token\n            response = requests.post(\n                'https://accounts.spotify.com/api/token',\n                data={\n                    'grant_type': 'refresh_token',\n                    'refresh_token': os.environ['REFRESH_TOKEN']\n                },\n                headers={\n                    'Authorization': 'Basic ' + base64.b64encode(\n                        (self.client_id + ':' + self.client_secret).encode('ascii')).decode('ascii')\n                }\n            )\n            # Check if the request was successful\n            if response.status_code == 200:\n                # Update the local state with the new authentication data\n                self.access_token = response.json()['access_token']\n                self.refresh_token = response.json()['refresh_token']\n                self.expires_at = int(time.time()) + response.json()['expires_in']\n                # Return the new access token\n                return self.access_token\n            # Raise an exception if the request failed\n            raise exceptions.AccountNotAuthorized('The account is not authorized.')\n        # Raise an exception if no refresh token is available\n        raise exceptions.AccountNotAuthorized('The account is not authorized.')\n    # Check if the access token is available in the local state\n    if self.access_token is not None and self.expires_at is not None:\n        # Check if the access token is still valid\n        if self.expires_at >= int(time.time()):\n            return self.access_token\n        # Check if a refresh token is available\n        if self.refresh", "CodeBleu_score": 40.36220584314364}, {"code": "def fetch_authentication_token(self)\n    if 'ACCESS_TOKEN' in os.environ and 'EXPIRES_AT' in os.environ:\n        if int(os.environ['EXPIRES_AT']) > int(time.time()):\n            return os.environ['ACCESS_TOKEN']\n        elif 'REFRESH_TOKEN' in os.environ:\n            try:\n                self.refresh_authentication_token()\n                return self.fetch_authentication_token()\n            except Exception as e:\n                print(e)\n                raise AccountNotAuthorized()\n        else:\n            raise AccountNotAuthorized()\n    elif os.path.exists(os.path.join(os.path.expanduser('~'), '.config', 'slack_sdk', 'authentication.json')):\n        with open(os.path.join(os.path.expanduser('~'), '.config', 'slack_sdk', 'authentication.json'), 'r') as f:\n            authentication_data = json.load(f)\n        if int(authentication_data['expires_at']) > int(time.time()):\n            return authentication_data['access_token']\n        elif 'refresh_token' in authentication_data:\n            try:\n                self.refresh_authentication_token()\n                return self.fetch_authentication_token()\n            except Exception as e:\n                print(e)\n                raise AccountNotAuthorized()\n        else:\n            raise AccountNotAuthorized()\n    else:\n        raise AccountNotAuthorized()\n", "CodeBleu_score": 37.44096630049657}, {"code": "def fetch_authentication_token(self)\n    # Check if token is available in environment variables\n    if self.token_env_var_name in os.environ:\n        return os.environ[self.token_env_var_name]\n\n    # Check if token is available in local state\n    if self.token_file_name in os.listdir(self.token_file_path):\n        with open(self.token_file_path + self.token_file_name, \"r\") as token_file:\n            token_data = json.load(token_file)\n            if token_data[\"expires_at\"] > time.time():\n                return token_data[\"access_token\"]\n            elif \"refresh_token\" in token_data:\n                # Refresh token is available, attempt to fetch new access token\n                token_data = self.refresh_authentication_token(token_data[\"refresh_token\"])\n                # Update local state with new token data\n                with open(self.token_file_path + self.token_file_name, \"w\") as token_file:\n                    json.dump(token_data, token_file)\n                return token_data[\"access_token\"]\n\n    # If all methods fail, raise an exception\n    raise AccountNotAuthorized()\n\n", "CodeBleu_score": 32.30972488939387}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n    if self.refresh_token:\n        self.delete_session()\n        self.refresh_token = None\n        try:\n            self.request(\"POST\", \"/v1/logout\", headers={\"Authorization\": f\"Bearer {self.refresh_token}\"})\n        except AccountError:\n            pass\n        return True\n    return False\n\n", "CodeBleu_score": 51.02057773994074}, {"code": "def logout(self)\n    try:\n        refresh_token = self.session.refresh_token\n        self.session.delete()\n        self.session.headers.update({\"Authorization\": \"Bearer \" + refresh_token})\n        self.session.post(self.base_url + \"/v1/logout\")\n        return True\n    except AccountError:\n        return True\n\n", "CodeBleu_score": 41.04864250865784}, {"code": "def logout(self)\n    if self.refresh_token is not None:\n        try:\n            self.session.post(\n                self.base_url + \"/v1/logout\",\n                headers={\"Authorization\": \"Bearer \" + self.refresh_token},\n            )\n        except AccountError:\n            pass\n        self.refresh_token = None\n        self.session.close()\n        return True\n    else:\n        return False\n\n", "CodeBleu_score": 45.78143727939315}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n    packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_metadata = self.package_metadata.get(package.name, {})\n        if package_metadata.get('external'):\n            packages.append({\n                'name': package.name,\n                'version': package.version,\n                'url': package_metadata.get('url')\n            })\n        else:\n            packages.append({\n                'name': package.name,\n                'version': package.version\n            })\n    return packages\n\n", "CodeBleu_score": 26.663110282313983}, {"code": "def dump_used_packages(self)\n    used_packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_metadata = self.get_package_metadata(package)\n        if package_metadata.external:\n            used_packages.append({\n                \"name\": package.name,\n                \"version\": package.version,\n                \"source_url\": package_metadata.source_url\n            })\n        else:\n            used_packages.append({\n                \"name\": package.name,\n                \"version\": package.version\n            })\n    return used_packages\n\n", "CodeBleu_score": 26.958233843390563}, {"code": "def dump_used_packages(self)\n    used_packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_metadata = self.get_package_metadata(package.name)\n        if package_metadata is None:\n            continue\n        if package_metadata.external:\n            package_metadata.source_url = package.source_url\n        used_packages.append(package_metadata)\n    return used_packages\n\n", "CodeBleu_score": 25.7579121466834}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if not env:\n        raise ValueError(\"The environment name is not specified.\")\n    if not targets:\n        targets = []\n    if not isinstance(targets, list):\n        targets = [targets]\n    if not isinstance(env, str):\n        raise ValueError(\"The environment name must be a string.\")\n    if not isinstance(targets, list):\n        raise ValueError(\"The targets must be a list.\")\n    if not isinstance(autoinstall, bool):\n        raise ValueError(\"The autoinstall option must be a boolean.\")\n    try:\n        platform = cls.get_platform(env)\n    except UndefinedEnvPlatformError:\n        raise\n    instance = cls(platform, autoinstall)\n    instance.set_env(env)\n    instance.configure_packages(targets)\n    return instance\n\n", "CodeBleu_score": 31.920401788946894}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if env not in cls.platform_specs:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(cls.platform_specs[env], autoinstall=autoinstall)\n    instance.set_env(env)\n    instance.configure_packages(targets=targets)\n    return instance\n\n  @classmethod\n  def from_file(cls, file, targets=None, autoinstall=False):\n    \"\"\"The function \"from_file\" creates and configures an instance of a project environment based on a specified environment specification file.\\nIt then creates a new instance of the class with the platform specification and autoinstall option, sets the project environment, and configures the project packages for the given environment and targets.\\nFinally, it returns the configured instance.\"\"\"\n    with open(file, 'r') as f:\n      spec = json.load(f)\n    instance = cls(spec, autoinstall=autoinstall)\n    instance.set_env(file)\n    instance.configure_packages(targets=targets)\n    return instance\n\n  @classmethod\n  def from_spec(cls, spec, targets=None, autoinstall=False):\n    \"\"\"The function \"from_spec\" creates and configures an instance of a project environment based on a specified platform specification.\\nIt then creates a new instance of the class with the platform specification and autoinstall option, sets the project environment, and configures the project packages for the given environment and targets.\\nFinally, it returns the configured instance.\"\"\"\n    instance = cls(spec, autoinstall=autoinstall)\n    instance.set_env(spec)\n    instance.configure_packages(targets=targets)\n    return instance\n\n  def set_env(self, env):\n    \"\"\"The function \"set_env\" sets the project environment for the instance.\"\"\"\n    self.env = env\n\n  def configure_packages(self, targets=None):\n    \"\"\"The function \"configure_packages\" configures the project packages for the given environment and targets.\"\"\"\n    self.packages = self.project.packages.configure(self.env, targets=targets)\n\n  def get_env_spec(self):\n    \"\"\"The function \"get_env_spec\" returns the platform", "CodeBleu_score": 33.227926422741874}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    if env not in cls.platform_specs:\n        raise UndefinedEnvPlatformError(env)\n    platform = cls.platform_specs[env]\n    instance = cls(platform, autoinstall)\n    instance.env = env\n    instance.set_targets(targets)\n    instance.configure_packages()\n    return instance\n\n  def set_targets(self, targets):\n    \"\"\"The function \"set_targets\" sets the targets of the project environment.\\nIt first checks if the targets are defined in the project configuration.\\nIf not, it raises an \"UndefinedTargetsError\".\\nIt then sets the targets of the project environment to the specified targets.\"\"\"\n    if targets is None:\n      targets = self.project.targets\n    if targets is None:\n      raise UndefinedTargetsError()\n    self.targets = targets\n\n  def configure_packages(self):\n    \"\"\"The function \"configure_packages\" configures the project packages for the given environment and targets.\\nIt first retrieves the project packages from the project configuration.\\nIf the packages are not found, it raises an \"UndefinedProjectPackagesError\".\\nIt then configures the project packages for the given environment and targets.\"\"\"\n    packages = self.project.packages\n    if packages is None:\n      raise UndefinedProjectPackagesError()\n    self.packages = packages\n    self.configure_package_versions()\n\n  def configure_package_versions(self):\n    \"\"\"The function \"configure_package_versions\" configures the package versions for the given environment and targets.\\nIt first retrieves the package versions from the project configuration.\\nIf the package versions are not found, it raises an \"UndefinedPackageVersionsError\".\\nIt then configures the package versions for the given environment and targets.\"\"\"\n    package_versions = self.project.package_versions\n    if package_versions is None:\n      raise UndefinedPackageVersionsError()\n    self.package_versions = package_versions\n    self.configure_package_versions_for_targets()\n\n  def configure_package_versions_for_targets(self):\n    \"\"\"The function \"configure_package_versions_for_targets\" configures the package versions", "CodeBleu_score": 31.936917296919464}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  uint8_t i;\n  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}\n", "CodeBleu_score": 66.91445493595957}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)    Wire.beginTransmission(AXP192_ADDRESS);\n    Wire.write(Addr);\n    Wire.endTransmission();\n    Wire.requestFrom(AXP192_ADDRESS, Size);\n    for (int i = 0; i < Size; i++) {\n        Buff[i] = Wire.read();\n    }\n}\n", "CodeBleu_score": 67.4268153594834}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(0x34);\n  Wire.write(Addr);\n  Wire.endTransmission();\n  Wire.requestFrom(0x34, Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}\n", "CodeBleu_score": 69.08222267670335}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us)  SetSleep();\n  if (time_in_us > 0) {\n    Write1Byte(0x36, 0x80);\n    Write1Byte(0x37, time_in_us & 0xFF);\n    Write1Byte(0x38, (time_in_us >> 8) & 0xFF);\n    Write1Byte(0x39, (time_in_us >> 16) & 0xFF);\n    Write1Byte(0x3A, (time_in_us >> 24) & 0xFF);\n    Write1Byte(0x35, 0x80);\n  } else {\n    Write1Byte(0x35, 0x00);\n  }\n  Write1Byte(0x33, 0x08);\n}\n", "CodeBleu_score": 52.55442760396867}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)  SetSleep();\n  if (time_in_us > 0) {\n    // Enable timer wakeup source\n    Write1Byte(0x36, 0x80);\n    Write1Byte(0x37, (uint8_t)(time_in_us & 0xff));\n    Write1Byte(0x38, (uint8_t)((time_in_us >> 8) & 0xff));\n    Write1Byte(0x39, (uint8_t)((time_in_us >> 16) & 0xff));\n  } else {\n    // Disable timer wakeup source\n    Write1Byte(0x36, 0x00);\n  }\n  Write1Byte(0x91, 0x08);\n}\n", "CodeBleu_score": 53.133598965840754}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)    SetSleep();\n    if (time_in_us > 0) {\n        uint8_t time_in_s = time_in_us / 1000000;\n        Write1Byte(0x36, time_in_s);\n    }\n    Write1Byte(0x91, 0x80);\n}\n", "CodeBleu_score": 39.91008693001344}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)  int y = tte_y;\n  int x = tte_x;\n\n  if (y == 0) {\n    y = tte_height - TTE_LINE_HEIGHT;\n  } else {\n    y -= TTE_LINE_HEIGHT;\n  }\n\n  if (tteBar) {\n    y -= TTE_BAR_HEIGHT;\n  }\n\n  if (y < 0) {\n    y = 0;\n  }\n\n  fillRect(x, y, tte_width, TTE_LINE_HEIGHT, color);\n\n  tte_y = y;\n\n  return y;\n}\n", "CodeBleu_score": 18.27217808137363}, {"code": "int Display::scroll_line(uint32_t color)  int y = tte_y;\n  if (tte_bar) {\n    fill_rect(0, 0, DISPLAY_WIDTH, TTE_HEIGHT, color);\n    tte_y = TTE_HEIGHT;\n  } else {\n    fill_rect(0, tte_y, DISPLAY_WIDTH, TTE_HEIGHT, color);\n    tte_y = (tte_y + TTE_HEIGHT) % (DISPLAY_HEIGHT - TTE_HEIGHT);\n  }\n  set_scroll_address(tte_y);\n  return y;\n}\n", "CodeBleu_score": 25.041424965486573}, {"code": "int Display::scroll_line(uint32_t color)  int y = y_start;\n  if (tteBar) {\n    y = y_start_bar;\n  }\n  fillRect(0, y, 320, 240, color);\n  y += 16;\n  if (y >= 232) {\n    y = 0;\n  }\n  setScrollAddress(y);\n  return y_start;\n}\n", "CodeBleu_score": 11.191923437495497}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if(ssids->isEmpty() || access_points->isEmpty()) {\n    return false;\n  }\n  if(!setSSIDs(ssids)) {\n    return false;\n  }\n  if(!setAccessPoints(access_points)) {\n    return false;\n  }\n  return start();\n}\n", "CodeBleu_score": 51.85554480843537}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)    bool success = true;\n    success &= setupAccessPoints(access_points);\n    success &= setupHTML(ssids);\n    if (success) {\n        start();\n    }\n    return success;\n}\n", "CodeBleu_score": 48.8189669754805}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if (!setupAccessPoints(ssids)) {\n    return false;\n  }\n  if (!setupHTMLContent(access_points)) {\n    return false;\n  }\n  startPortal();\n  return true;\n}\n", "CodeBleu_score": 64.11578064397385}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue()    if (queue_enabled_flag) {\n        if (queue.empty()) {\n            queue_enabled_flag = false;\n            return;\n        }\n        text = queue.front();\n        text_in = text.begin();\n        queue_enabled_flag = false;\n    }\n    queue_enabled_flag = true;\n}\n", "CodeBleu_score": 13.888577256539902}, {"code": "void GpsInterface::enable_queue()    if (queue_enabled_flag) {\n        if (!queue.empty()) {\n            queue.clear();\n            text.clear();\n            text_in.clear();\n        }\n    } else {\n        queue.clear();\n        text.clear();\n        text_in.clear();\n        queue_enabled_flag = true;\n    }\n}\n", "CodeBleu_score": 15.333736551306773}, {"code": "void GpsInterface::enable_queue()\tif (queue_enabled_flag) {\n\t\tif (queue == NULL) {\n\t\t\tqueue = new Queue<GpsInterface::GpsData>();\n\t\t}\n\t\tif (text == NULL) {\n\t\t\ttext = new char[GPS_TEXT_SIZE];\n\t\t}\n\t\tif (text_in == NULL) {\n\t\t\ttext_in = new char[GPS_TEXT_SIZE];\n\t\t}\n\t} else {\n\t\tif (queue != NULL) {\n\t\t\tqueue->flush();\n\t\t\tdelete queue;\n\t\t\tqueue = NULL;\n\t\t}\n\t\tif (text != NULL) {\n\t\t\tdelete text;\n\t\t\ttext = NULL;\n\t\t}\n\t\tif (text_in != NULL) {\n\t\t\tdelete text_in;\n\t\t\ttext_in = NULL;\n\t\t}\n\t\tqueue_enabled_flag = true;\n\t}\n}\n", "CodeBleu_score": 9.064533097707887}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea()    if (nmea_queue) {\n        while (!nmea_queue->empty()) {\n            nmea_queue->pop();\n        }\n        delete nmea_queue;\n        nmea_queue = new std::queue<std::string>;\n    } else {\n        nmea_queue = new std::queue<std::string>;\n    }\n}\n", "CodeBleu_score": 40.27766437528185}, {"code": "void GpsInterface::flush_queue_nmea()    if (queue_nmea != NULL) {\n        delete queue_nmea;\n        queue_nmea = new queue<string>();\n    } else {\n        queue_nmea = new queue<string>();\n    }\n}\n", "CodeBleu_score": 43.124671352936645}, {"code": "void GpsInterface::flush_queue_nmea()    if (queue_nmea) {\n        delete queue_nmea;\n        queue_nmea = new queue<string>;\n    } else {\n        queue_nmea = new queue<string>;\n    }\n}\n", "CodeBleu_score": 42.41643078759234}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    uint32_t x1, y1, x2, y2;\n    x1 = area->x1;\n    y1 = area->y1;\n    x2 = area->x2;\n    y2 = area->y2;\n    // Set the address window to the specified area\n    ili9341_set_window(x1, y1, x2, y2);\n    // Start a write transaction\n    ili9341_write_start();\n    // Iterate through each pixel in the area\n    for (int y = y1; y <= y2; y++) {\n      for (int x = x1; x <= x2; x++) {\n        // Write the corresponding color from the color buffer\n        ili9341_write_color(color_p->full);\n        color_p++;\n      }\n    }\n    // End the write transaction\n    ili9341_write_end();\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n  }\n", "CodeBleu_score": 51.79207446028779}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n\n    int32_t x;\n    int32_t y;\n\n    /*Set the working window*/\n    set_window(area->x1, area->y1, area->x2, area->y2);\n\n    /*Write every pixel in the area*/\n    for(y = area->y1; y <= area->y2; y++) {\n      for(x = area->x1; x <= area->x2; x++) {\n        /*Write the color to the display*/\n        write_data(color_p->full);\n        color_p++;\n      }\n    }\n\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n  }\n\n  /*Read an input device*/\n  void my_indev_read(lv_indev_drv_t * indev, lv_indev_data_t * data) {\n    static lv_coord_t last_x = 0;\n    static lv_coord_t last_y = 0;\n    static uint32_t last_btn = 0;\n    static lv_tick_t last_press = 0;\n\n    /*Save the pressed coordinates and the pressed button*/\n    if(data->state == LV_INDEV_STATE_PR) {\n      last_x = data->point.x;\n      last_y = data->point.y;\n      last_btn = data->btn_id;\n      last_press = xTaskGetTickCount();\n    }\n\n    /*Set the last pressed coordinates and button*/\n    data->point.x = last_x;\n    data->point.y = last_y;\n    data->btn_id = last_btn;\n\n    /*Save the state and set the pressed button*/\n    if(xTaskGetTickCount() - last_press < 100) data->state = LV_INDEV_STATE_PR;\n    else data->state = LV", "CodeBleu_score": 52.17306140687816}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    /*Set the working window*/\n    ili9341_set_window(area->x1, area->y1, area->x2, area->y2);\n\n    /*Write the color data*/\n    ili9341_write_data((uint8_t *)color_p, (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1) * LV_COLOR_SIZE / 8);\n\n    /*Tell the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp);\n  }\n", "CodeBleu_score": 33.12022630719894}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\t// Iterate through all nodes of the menu\n\tfor (int i = 0; i < menu->getNumberOfNodes(); i++) {\n\t\t// Get the menu node\n\t\tMenuNode * node = menu->getNode(i);\n\t\t// Print the name of the node with indentation\n\t\tstd::cout << std::string(layer * 2, ' ') << node->getName() << std::endl;\n\t\t// If the node has subnodes, call this function again\n\t\tif (node->hasSubNodes()) {\n\t\t\tshowMenuList(node->getSubMenu(), layer + 1);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.776745951566646}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    if (menu != NULL) {\n        for (int i = 0; i < menu->getNumberOfNodes(); i++) {\n            if (menu->getNode(i)->getType() == MenuNode::SEPARATOR) {\n                std::cout << std::string(layer * 4, ' ') << \"--\" << std::endl;\n            } else {\n                std::cout << std::string(layer * 4, ' ') << menu->getNode(i)->getName() << std::endl;\n            }\n            if (menu->getNode(i)->getType() == MenuNode::MENU) {\n                showMenuList(menu->getNode(i)->getMenu(), layer + 1);\n            }\n        }\n        std::cout << std::endl;\n    }\n}\n", "CodeBleu_score": 43.55454207872873}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)\tfor (int i = 0; i < menu->getMenuNodeCount(); i++) {\n\t\tif (menu->getMenuNode(i)->getMenu() != NULL) {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tstd::cout << \"  \";\n\t\t\t}\n\t\t\tstd::cout << menu->getMenuNode(i)->getName() << std::endl;\n\t\t\tshowMenuList(menu->getMenuNode(i)->getMenu(), layer + 1);\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < layer; j++) {\n\t\t\t\tstd::cout << \"  \";\n\t\t\t}\n\t\t\tstd::cout << menu->getMenuNode(i)->getName() << std::endl;\n\t\t}\n\t}\n\tstd::cout << std::endl;\n}\n", "CodeBleu_score": 45.76820405135086}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count)  int i = 0;\n  while (i < count) {\n    char ssid[7];\n    char mac[18];\n    int channel;\n    int rssi;\n    int security;\n    char* securityString;\n    sprintf(ssid, \"%06x\", random(0xFFFFFF));\n    sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", random(256), random(256), random(256), random(256), random(256), random(256));\n    channel = random(1, 15);\n    rssi = random(-100, -20);\n    security = random(0, 4);\n    securityString = getSecurityString(security);\n    Serial.print(i + 1);\n    Serial.print(\": \");\n    Serial.print(ssid);\n    Serial.print(\" (\");\n    Serial.print(securityString);\n    Serial.print(\") \");\n    Serial.print(mac);\n    Serial.print(\" \");\n    Serial.print(channel);\n    Serial.print(\" \");\n    Serial.print(rssi);\n    Serial.println();\n    i++;\n  }\n  return i;\n}\n", "CodeBleu_score": 44.18035300780715}, {"code": "int WiFiScan::generateSSIDs(int count)  // Create an empty list of SSIDs\n  ssids = new String[count];\n  // Iterate through the count\n  for (int i = 0; i < count; i++) {\n    // Create a random SSID\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += (char)random(97, 122);\n    }\n    // Create a random channel\n    int channel = random(1, 14);\n    // Create a random MAC address\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += (char)random(48, 57);\n      if (j != 5) {\n        mac += \":\";\n      }\n    }\n    // Add the SSID to the list\n    ssids[i] = \"{\\\"ssid\\\":\\\"\" + ssid + \"\\\",\\\"channel\\\":\" + channel + \",\\\"mac\\\":\\\"\" + mac + \"\\\"}\";\n    // Print the SSID to the serial output\n    Serial.println(ssids[i]);\n  }\n  return count;\n}\n", "CodeBleu_score": 42.58248267646273}, {"code": "int WiFiScan::generateSSIDs(int count)  int i;\n  for (i = 0; i < count; i++) {\n    char ssid[6];\n    char mac[18];\n    int channel;\n    randomSeed(micros());\n    for (int j = 0; j < 6; j++) {\n      ssid[j] = random(97, 123);\n    }\n    channel = random(1, 12);\n    sprintf(mac, \"%02X:%02X:%02X:%02X:%02X:%02X\", random(256), random(256), random(256), random(256), random(256), random(256));\n    SSIDList.add(ssid);\n    Serial.println(ssid);\n    Serial.println(channel);\n    Serial.println(mac);\n  }\n  return i;\n}\n", "CodeBleu_score": 51.73962738605189}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n    # [START pubsub_create_topic]\n    from google.cloud import pubsub_v1\n\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    topic = publisher.create_topic(topic_path)\n\n    print(f\"Topic {topic.name} created.\")\n    # [END pubsub_create_topic]\n\n", "CodeBleu_score": 77.60040216478555}, {"code": "def create_topic(project_id, topic_name)\n\n    from google.cloud import pubsub_v1\n\n    # Initialize a Pub/Sub client.\n    publisher = pubsub_v1.PublisherClient()\n\n    # Construct the topic path.\n    topic_path = publisher.topic_path(project_id, topic_name)\n\n    # Create the topic.\n    topic = publisher.create_topic(request={\"name\": topic_path})\n\n    print(f\"Topic created: {topic.name}\")\n\n", "CodeBleu_score": 69.7121745172126}, {"code": "def create_topic(project_id, topic_name)\n    publisher = pubsub.PublisherClient()\n    topic_path = publisher.topic_path(project_id, topic_name)\n    topic = publisher.create_topic(topic_path)\n    print(f\"Topic {topic.name} created.\")\n\n", "CodeBleu_score": 42.19364201519676}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n    import jwt\n    import time\n    import datetime\n    from google.oauth2 import service_account\n    from google.auth.transport import requests\n\n    now = datetime.datetime.utcnow()\n    payload = {\n        \"iat\": now,\n        \"exp\": now + datetime.timedelta(hours=1),\n        \"aud\": project_id\n    }\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n    credentials = service_account.Credentials.from_service_account_info(\n        {\"private_key\": private_key, \"client_email\": \"test@test.iam.gserviceaccount.com\"})\n    request = requests.Request()\n    jwt_token = credentials.sign_jwt(request, payload)\n    return jwt_token\n\n", "CodeBleu_score": 46.688821407016775}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    import time\n    import jwt\n\n    # Set the current UTC time to the issued time (iat)\n    issued_at_time = int(time.time())\n\n    # Set the expiration time (exp) to 60 seconds after the issued time (iat)\n    expiration_time = issued_at_time + 60\n\n    # Set the audience (aud) to the provided project ID\n    audience = project_id\n\n    # Read the private key file\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n\n    # Create the JWT\n    jwt_token = jwt.encode(\n        {\n            'iat': issued_at_time,\n            'exp': expiration_time,\n            'aud': audience\n        },\n        private_key,\n        algorithm=algorithm\n    )\n\n    return jwt_token\n\n", "CodeBleu_score": 49.4029244010048}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n\n    # [START create_jwt]\n    import time\n    import jwt\n    from google.oauth2 import service_account\n\n    # Create the JWT using the service account's private key.\n    now = int(time.time())\n    payload = {\n        'iat': now,\n        'exp': now + 3600,  # Expires in 1 hour\n        'aud': project_id\n    }\n    with open(private_key_file, 'r') as f:\n        private_key = f.read()\n    signed_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n    return signed_jwt\n    # [END create_jwt]\n\n", "CodeBleu_score": 52.807859091894606}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n    global bucket_name\n    global topic_name\n    global topic_name_event\n    global topic_name_event_url\n    global client\n    global event_url\n    global event_url_topic\n    global event_url_topic_name\n    global event_url_topic_name_url\n    global event_url_topic_name_url_url\n    global event_url_topic_name_url_url_url\n    global event_url_topic_name_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url_url_url_url_url_url_url_url_url_url_url\n    global event_url_topic_name_url_url_url_url_url_url", "CodeBleu_score": 5.761438716246539}, {"code": "def on_message(unused_client, unused_userdata, message)\n\n    print(\"Received message '\" + str(message.payload) + \"' on topic '\"\n          + message.topic + \"' with QoS \" + str(message.qos))\n    if message.payload == b'on':\n        # Capture a preview image\n        print(\"Capturing preview image...\")\n        capture_image()\n        # Upload the image to the specified S3 bucket\n        print(\"Uploading preview image to S3 bucket...\")\n        upload_image()\n        # Publish the image's URL to the specified MQTT event topic\n        print(\"Publishing preview image URL to MQTT event topic...\")\n        publish_image_url()\n    else:\n        print(\"off\")\n\n", "CodeBleu_score": 25.14789195026852}, {"code": "def on_message(unused_client, unused_userdata, message)\n    print(\"Received message '\" + str(message.payload) + \"' on topic '\"\n          + message.topic + \"' with QoS \" + str(message.qos))\n    if message.payload == b'on':\n        print('Taking a picture')\n        # Take a picture and save it to a file\n        camera.capture('image.jpg')\n        print('Picture taken')\n        # Upload the file to the bucket\n        print('Uploading to bucket')\n        s3.upload_file('image.jpg', bucket, 'image.jpg')\n        print('Uploaded')\n        # Get the URL of the uploaded image\n        print('Getting URL')\n        url = s3.Bucket(bucket).Object('image.jpg').get()['Body'].read().decode('utf-8')\n        print('URL: ' + url)\n        # Publish the URL to the MQTT topic\n        print('Publishing to topic')\n        client.publish(topic, url)\n        print('Published')\n    else:\n        print('off')\n\n", "CodeBleu_score": 43.66089161410803}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n    parser = argparse.ArgumentParser(\n        description=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter)\n    parser.add_argument(\n        '--project_id',\n        help='Project ID',\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"))\n    parser.add_argument(\n        '--registry_id',\n        help='Registry ID',\n        default='my-registry')\n    parser.add_argument(\n        '--device_id',\n        help='Device ID',\n        default='my-device')\n    parser.add_argument(\n        '--private_key_file',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region',\n        help='GCP cloud region.')\n    parser.add_argument(\n        '--ca_certs',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=10,\n        help='Number of messages to publish.')\n    parser.add_argument(\n        '--mqtt_bridge_hostname',\n        default='mqtt.googleapis.com',\n        help='MQTT bridge hostname.')\n    parser.add_argument(\n        '--mqtt_bridge_port',\n        default=8883,\n        type=int,\n        help='MQTT bridge port.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n        help='Expiration time, in minutes, for JWT tokens.')\n    parser.add_argument(\n        '--message_type',\n        choices=('event', 'state'),\n        default='event',\n        help=('Indicates whether the message to be published is a '\n              'te", "CodeBleu_score": 33.37417189153463}, {"code": "def parse_command_line_args()\n\n    parser = argparse.ArgumentParser(\n        description=\"Google Cloud IoT Core MQTT example.\"\n    )\n    parser.add_argument(\n        \"--project_id\",\n        help=\"GCP cloud project name\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\")\n    )\n    parser.add_argument(\n        \"--registry_id\",\n        help=\"Cloud IoT Core registry id\",\n        default=\"my-registry\"\n    )\n    parser.add_argument(\n        \"--device_id\",\n        help=\"Cloud IoT Core device id\",\n        default=\"my-device\"\n    )\n    parser.add_argument(\n        \"--private_key_file\",\n        help=\"Path to private key file.\",\n        default=\"rsa_private.pem\"\n    )\n    parser.add_argument(\n        \"--algorithm\",\n        choices=(\"RS256\", \"ES256\"),\n        help=\"Which encryption algorithm to use to generate the JWT.\",\n        default=\"RS256\"\n    )\n    parser.add_argument(\n        \"--cloud_region\",\n        help=\"GCP cloud region\",\n        default=\"us-central1\"\n    )\n    parser.add_argument(\n        \"--ca_certs\",\n        help=\"CA root from https://pki.google.com/roots.pem\",\n        default=\"roots.pem\"\n    )\n    parser.add_argument(\n        \"--num_messages\",\n        type=int,\n        help=\"Number of messages to publish.\",\n        default=1000\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_hostname\",\n        help=\"MQTT bridge hostname.\",\n        default=\"mqtt.googleapis.com\"\n    )\n    parser.add_argument(\n        \"--mqtt_bridge_port\",\n        type=int,\n        help=\"MQTT bridge port.\",\n        default=8883\n    )\n    parser.add_argument(\n        \"--message_type\",\n        choices=(\"event\", \"state\"),\n        help=\"Indicates whether", "CodeBleu_score": 32.30336932885514}, {"code": "def parse_command_line_args()\n\n    parser = argparse.ArgumentParser(description=\"Google Cloud IoT MQTT device connection example.\")\n    parser.add_argument(\n        \"--project_id\",\n        default=os.environ.get(\"GOOGLE_CLOUD_PROJECT\"),\n        help=\"GCP cloud project name\",\n    )\n    parser.add_argument(\"--registry_id\", required=True, help=\"Cloud IoT registry id\")\n    parser.add_argument(\"--device_id\", required=True, help=\"Cloud IoT device id\")\n    parser.add_argument(\"--private_key_file\", required=True, help=\"Path to private key file.\")\n    parser.add_argument(\"--algorithm\", choices=(\"RS256\", \"ES256\"), required=True, help=\"Which encryption algorithm to use to generate the JWT.\")\n    parser.add_argument(\"--cloud_region\", default=\"us-central1\", help=\"GCP cloud region\")\n    parser.add_argument(\"--ca_certs\", default=\"roots.pem\", help=\"CA root certificate.\")\n    parser.add_argument(\"--num_messages\", type=int, default=100, help=\"Number of messages to publish.\")\n    parser.add_argument(\"--mqtt_bridge_hostname\", default=\"mqtt.googleapis.com\", help=\"MQTT bridge hostname.\")\n    parser.add_argument(\"--mqtt_bridge_port\", default=8883, type=int, help=\"MQTT bridge port.\")\n\n    return parser.parse_args()\n", "CodeBleu_score": 45.15788452738739}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n    # The scopes below are the minimum required to use the Cloud IoT Core API.\n    # See the following documentation for more information:\n    # https://cloud.google.com/iot/docs/iam#roles\n    SCOPES = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # The version of the API to use.\n    API_VERSION = 'v1'\n\n    # The discovery URL for the API.\n    DISCOVERY_URL = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials and use them to build the client.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json)\n\n    scoped_credentials = credentials.with_scopes(SCOPES)\n\n    return discovery.build(\n        'cloudiot',\n        API_VERSION,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=DISCOVERY_URL)\n\n", "CodeBleu_score": 26.909425833970456}, {"code": "def get_client(service_account_json)\n    # The scopes below are the minimum required to use the Cloud IoT Core service.\n    # If you'd like to use other Google APIs, you must either add them to this list or\n    # create a new list and pass it in using the \"scopes\" parameter.\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # The version below specifies the version of the API to use.\n    # This must match the version in the discovery URL above.\n    api_version = 'v1'\n\n    # The discovery URL below identifies where to find the appropriate service\n    # configuration.\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Use the discovery URL to create a service object. This contains most of the\n    # methods for interacting with the API.\n    service = googleapiclient.discovery.build(\n        'cloudiot', api_version, discoveryServiceUrl=discovery_url,\n        credentials=service_account.Credentials.from_service_account_file(\n            service_account_json, scopes=scopes))\n\n    return service\n\n", "CodeBleu_score": 26.894747705548433}, {"code": "def get_client(service_account_json)\n    # Define the necessary API scopes, version, and discovery URL.\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials, scoped appropriately.\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json, scopes=scopes)\n\n    # Build the client for the Cloud IoT Core API.\n    return googleapiclient.discovery.build(\n        'cloudiot', api_version, credentials=credentials, discoveryServiceUrl=discovery_api)\n\n", "CodeBleu_score": 23.697568913703247}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n    # Retrieve the ASN1 code for the hash method\n    hash_code = get_hash_code(hash_method)\n    # Concatenate the ASN1 code with the hash value\n    to_sign = hash_code + hash_value\n    # Pad the concatenated value for signing\n    padded = pad_for_signing(to_sign)\n    # Encrypt the padded value using the private key\n    encrypted = priv_key.sign(padded, hash_method)\n    # Return the encrypted signature\n    return encrypted\n\n", "CodeBleu_score": 9.965567612343165}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    if hash_method == \"SHA-256\":\n        hash_asn1 = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"SHA-384\":\n        hash_asn1 = b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"SHA-512\":\n        hash_asn1 = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise Exception(\"Invalid hash method. Please choose one of the following: SHA-256, SHA-384, or SHA-512\")\n    hash_asn1_concat = hash_asn1 + hash_value\n    hash_asn1_concat_padded = hash_asn1_concat + b\"\\x00\" * ((119 - len(hash_asn1_concat)) % 128)\n    return encrypt(hash_asn1_concat_padded, priv_key)\n\n", "CodeBleu_score": 21.029139326437207}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    # Retrieve the ASN1 code for the hash method\n    if hash_method == \"SHA1\":\n        asn1_hash_method = b\"\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14\"\n    elif hash_method == \"SHA256\":\n        asn1_hash_method = b\"\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20\"\n    elif hash_method == \"SHA384\":\n        asn1_hash_method = b\"\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30\"\n    elif hash_method == \"SHA512\":\n        asn1_hash_method = b\"\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40\"\n    else:\n        raise Exception(\"Invalid hash method\")\n    # Concatenate the ASN1 code with the hash value\n    signed_hash = asn1_hash_method + hash_value\n    # Pad the signed hash for signing\n    signed_hash_padded = signed_hash + b\"\\x00\" * (128 - len(signed_hash))\n    # Encrypt the padded hash using the private key\n    signature = rsa.encrypt(signed_hash", "CodeBleu_score": 19.08920494361821}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n\n    # convert signature to integer\n    signature = int(signature, 16)\n\n    # decrypt signature\n    decrypted_signature = pow(signature, pub_key, pub_key.n)\n\n    # determine hash method\n    if decrypted_signature == 0:\n        hash_method = 'SHA-1'\n    elif decrypted_signature == 1:\n        hash_method = 'SHA-256'\n    elif decrypted_signature == 2:\n        hash_method = 'SHA-512'\n    else:\n        raise ValueError('Invalid signature')\n\n    # compute hash\n    if hash_method == 'SHA-1':\n        hash_obj = hashlib.sha1()\n    elif hash_method == 'SHA-256':\n        hash_obj = hashlib.sha256()\n    elif hash_method == 'SHA-512':\n        hash_obj = hashlib.sha512()\n\n    hash_obj.update(message.encode('utf-8'))\n    hash_obj = hash_obj.digest()\n\n    # reconstruct padded hash\n    if hash_method == 'SHA-1':\n        padded_hash = hash_obj + b'\\x00' * (20 - len(hash_obj))\n    elif hash_method == 'SHA-256':\n        padded_hash = hash_obj + b'\\x00' * (32 - len(hash_obj))\n    elif hash_method == 'SHA-512':\n        padded_hash = hash_obj + b'\\x00' * (64 - len(hash_obj))\n\n    # verify signature\n    if padded_hash != decrypted_signature:\n        raise ValueError('Invalid signature')\n\n    return hash_method\n\n", "CodeBleu_score": 27.352361750318316}, {"code": "def verify(message, signature, pub_key)\n    # Convert the signature to an integer\n    signature = int(signature.encode('hex'), 16)\n\n    # Decrypt the signature to obtain the clear signature\n    clear_signature = pow(signature, pub_key, N)\n\n    # Determine the hash method used\n    hash_method = get_hash_method(clear_signature)\n\n    # Compute the hash of the message\n    hash_of_message = hashlib.new(hash_method).update(message).digest()\n\n    # Reconstruct the expected padded hash\n    expected_padded_hash = pad_hash(hash_of_message, hash_method)\n\n    # If the expected padded hash does not match the clear signature, it raises a verification error\n    if clear_signature != expected_padded_hash:\n        raise VerificationError('Invalid signature')\n\n    # If the verification is successful, it returns the hash method name\n    return hash_method\n\n", "CodeBleu_score": 17.970768440027225}, {"code": "def verify(message, signature, pub_key)\n    # Convert the signature to an integer\n    sig = int(signature, 16)\n    # Decrypt the signature using the public key\n    clear_sig = pow(sig, pub_key, N)\n    # Determine the hash method used\n    hash_method = get_hash_method(clear_sig)\n    # Compute the hash of the message\n    hashed_message = hashlib.new(hash_method, message).hexdigest()\n    # Reconstruct the expected padded hash\n    expected_padded_hash = pad_hash(hashed_message, hash_method)\n    # Check if the expected padded hash matches the clear signature\n    if expected_padded_hash != clear_sig:\n        raise VerificationError\n    # Return the hash method name\n    return hash_method\n\n", "CodeBleu_score": 14.206329238988275}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT()  if (time(nullptr) > 1510644967) {\n    configTime(0, 0, \"pool.ntp.org\", \"time.nist.gov\");\n    Serial.println(\"Waiting for NTP time sync: \");\n    time_t now = time(nullptr);\n    while (now < 1510644967) {\n      delay(500);\n      Serial.print(\".\");\n      now = time(nullptr);\n    }\n    Serial.println(\"\");\n    struct tm timeinfo;\n    gmtime_r(&now, &timeinfo);\n    Serial.print(\"Current time: \");\n    Serial.print(asctime(&timeinfo));\n  }\n  Serial.println(\"Connecting to MQTT...\");\n  if (client.connect(MQTT_CLIENT_ID, MQTT_USER, MQTT_PASSWORD, MQTT_TOPIC_SUB, 1, 1, \"0\")) {\n    Serial.println(\"connected\");\n    client.subscribe(MQTT_TOPIC_SUB);\n  } else {\n    Serial.print(\"failed, rc=\");\n    Serial.print(client.state());\n    Serial.println(\" try again in 5 seconds\");\n    delay(5000);\n  }\n}\n", "CodeBleu_score": 39.28077268730814}, {"code": "static void connectMQTT()  // Get current time\n  time_t now = time(NULL);\n  if (now < 1000000000) {\n    Serial.println(\"The current time is not valid, please connect and sync\");\n    return;\n  }\n  // Generate new JWT using the current UNIX time format\n  jwt = generateJWT(now);\n  // Connect to MQTT client\n  client.connect(projectId, jwt);\n  // Set flag to send an MQTT SUBSCRIBE packet after the connection is established\n  shouldSubscribe = true;\n  // Print debug message\n  Serial.println(\"Connecting to MQTT...\");\n}\n", "CodeBleu_score": 46.629914923269524}, {"code": "static void connectMQTT()    // Get the current time\n    time_t now;\n    time(&now);\n\n    // If the current time is valid, update the JWT\n    if (now > 0) {\n        // Update the JWT\n        jwt_update(now);\n    }\n\n    // Connect to the MQTT client\n    if (aws_iot_mqtt_connect(&client, &connectParams) == NETWORK_RECONNECT) {\n        // Set a flag to send an MQTT SUBSCRIBE packet after the connection is established\n        subscribe_flag = true;\n        // Print a debug message indicating the MQTT connection attempt\n        ESP_LOGI(TAG, \"MQTT connection reestablished\");\n    } else {\n        ESP_LOGI(TAG, \"MQTT connection failed\");\n    }\n}\n", "CodeBleu_score": 40.00139217071619}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        uint8_t c = *str++;\n        if (c < '0' || c > '9') {\n            return str;\n        }\n        if (n >= UINT32_MAX / 10) {\n            return str;\n        }\n        n = n * 10 + (c - '0');\n    }\n    *num = n;\n    return str;\n}\n", "CodeBleu_score": 24.70768322243324}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)\tuint32_t n = 0;\n\tint i;\n\n\tfor (i = 0; i < width; i++) {\n\t\tuint8_t c = str[i];\n\t\tif (c < '0' || c > '9') {\n\t\t\treturn str;\n\t\t}\n\t\tn = (n * 10) + (c - '0');\n\t}\n\t*num = n;\n\treturn str + width;\n}\n", "CodeBleu_score": 22.58010476730893}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t n = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        n = n * 10 + (str[i] - '0');\n    }\n    *num = n;\n    return str + width;\n}\n", "CodeBleu_score": 21.625709998866206}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    int ret = 0;\n    int i = 0;\n    uint8_t* cert_data = NULL;\n    size_t cert_size = 0;\n    uint8_t* cert_ptr = NULL;\n    size_t cert_remaining = 0;\n    uint8_t* tbs_ptr = NULL;\n    size_t tbs_size = 0;\n    uint8_t* tbs_sig_ptr = NULL;\n    size_t tbs_sig_size = 0;\n    uint8_t* cert_sig_ptr = NULL;\n    size_t cert_sig_size = 0;\n    uint8_t* cert_sig_end_ptr = NULL;\n    uint8_t* cert_sig_end_ptr_prev = NULL;\n    uint8_t* cert_sig_end_ptr_prev2 = NULL;\n    uint8_t* cert_sig_end_ptr_prev3 = NULL;\n    uint8_t* cert_sig_end_ptr_prev4 = NULL;\n    uint8_t* cert_sig_end_ptr_prev5 = NULL;\n    uint8_t* cert_sig_end_ptr_prev6 = NULL;\n    uint8_t* cert_sig_end_ptr_prev7 = NULL;\n    uint8_t* cert_sig_end_ptr_prev8 = NULL;\n    uint8_t* cert_sig_end_ptr_prev9 = NULL;\n    uint8_t* cert_sig_end_ptr_prev10 = NULL;\n    uint8_t* cert_sig_end_ptr_prev11 = NULL;\n    uint8_t* cert_sig_end_ptr_prev12 = NULL;\n    uint8_t* cert_sig_end_ptr_prev13 = NULL;\n    uint8_t* cert_sig_end_ptr_prev14 = NULL;\n    uint8_t* cert_sig_end_ptr_prev15 = NULL;\n    uint8_t* cert_sig_end_ptr_prev16 = NULL;\n    uint8_t* cert_sig_end_ptr_prev", "CodeBleu_score": 11.085918121674688}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    int ret = 0;\n    uint8_t* cert_ptr = build_state->cert_def->cert_template;\n    size_t cert_size = build_state->cert_def->cert_size;\n    size_t cert_size_max = build_state->cert_def->cert_size_max;\n    size_t cert_offset = 0;\n    size_t cert_offset_max = 0;\n    size_t cert_offset_prev = 0;\n    size_t cert_offset_next = 0;\n    size_t cert_offset_next_max = 0;\n    size_t cert_offset_next_max_prev = 0;\n    size_t cert_offset_next_max_next = 0;\n    uint8_t* cert_next_ptr = NULL;\n    size_t cert_next_size = 0;\n    size_t cert_next_size_max = 0;\n    size_t cert_next_offset = 0;\n    size_t cert_next_offset_max = 0;\n    size_t cert_next_offset_max_prev = 0;\n    size_t cert_next_offset_max_next = 0;\n    uint8_t* cert_next_next_ptr = NULL;\n    size_t cert_next_next_size = 0;\n    size_t cert_next_next_size_max = 0;\n    size_t cert_next_next_offset = 0;\n    size_t cert_next_next_offset_max = 0;\n    size_t cert_next_next_offset_max_prev = 0;\n    size_t cert_next_next_offset_max_next = 0;\n    uint8_t* cert_next_next_next_ptr = NULL;\n    size_t cert_next_next_next_size = 0;\n    size_t cert_next_next_next_size_max = 0;\n    size_t cert_next_next_next_offset = 0;\n    size_t cert_next_next_next_offset_max = 0", "CodeBleu_score": 14.712173246146884}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    int ret = 0;\n    uint8_t *cert_data = build_state->cert_def->cert_template;\n    size_t cert_size = build_state->cert_def->cert_template_size;\n    uint8_t *cert_data_pos = build_state->cert_data;\n    uint8_t *cert_data_end = build_state->cert_data + build_state->cert_data_size;\n    uint8_t *cert_template_pos = build_state->cert_def->cert_template;\n    uint8_t *cert_template_end = build_state->cert_def->cert_template + build_state->cert_def->cert_template_size;\n    uint8_t *cert_template_size_pos = build_state->cert_def->cert_template + build_state->cert_def->cert_template_size - 2;\n    uint8_t *cert_template_max_size_pos = build_state->cert_def->cert_template + build_state->cert_def->cert_template_size - 3;\n    uint8_t *cert_template_size_val = cert_template_size_pos + 1;\n    uint8_t *cert_template_max_size_val = cert_template_max_size_pos + 1;\n    uint8_t *cert_template_size_val_end = cert_template_size_val + 2;\n    uint8_t *cert_template_max_size_val_end = cert_template_max_size_val + 2;\n    uint8_t *cert_template_data_pos = build_state->cert_def->cert_template + build_state->cert_def->cert_template_size - 1;\n    uint8_t *cert_template_data_end = build_state->cert_def->cert_template + build_state->cert_def->cert_template_size;\n    uint8_t *cert_template_data_size_pos = build_state->cert_def->cert_template + build_state->cert_def->cert_template_size - 3;\n    uint8_t", "CodeBleu_score": 10.915429472532049}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int ret = 0;\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, g_cert_tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the signature\n    ret = atcacert_verify_signature(cert_def, cert, cert_size, ca_public_key, g_cert_tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}\n", "CodeBleu_score": 58.7319336957496}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int ret = 0;\n    uint8_t ca_public_key_comp[72];\n    uint8_t ca_public_key_comp_size = 72;\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n    size_t  signature_size = 64;\n    uint8_t ca_comp_key[32];\n    uint8_t ca_comp_key_size = 32;\n    uint8_t ca_comp_key_signature[64];\n    uint8_t ca_comp_key_signature_size = 64;\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    // Get the TBS digest\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the signature\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the device public key\n    ret = atcacert_get_device_public_key(cert_def, cert, cert_size, ca_comp_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Get the device public key signature\n    ret = atcacert_get_device_public_key_signature(cert_def, cert, cert_size, ca_comp_key_signature);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    // Verify the device public key signature\n    ret = atcacert_verify_device_public_key_hw(ca_comp_key, ca_", "CodeBleu_score": 65.16718705429606}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    int ret = 0;\n    uint8_t tbs_digest[32];\n    uint8_t cert_signature[64];\n    size_t tbs_digest_size = 0;\n    size_t cert_signature_size = 0;\n    atcacert_device_loc_t ca_public_key_dev_loc;\n\n    if (cert_def == NULL || cert == NULL || cert_size == 0 || ca_public_key == NULL) {\n        return ATCACERT_E_BAD_PARAMS;\n    }\n\n    ret = atcacert_get_device_loc(&cert_def->ca_public_key, &ca_public_key_dev_loc);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest, &tbs_digest_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_get_cert_element(cert_def, cert, cert_size, cert_def->signature, cert_signature, &cert_signature_size);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    ret = atcacert_verify_hw(tbs_digest, tbs_digest_size, cert_signature, cert_signature_size, ca_public_key);\n    if (ret != ATCACERT_E_SUCCESS) {\n        return ret;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}\n", "CodeBleu_score": 67.53190435170278}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{    timerStruct_t *t = *list;\n    timerStruct_t *prev = NULL;\n    while (t != NULL) {\n        if (t == timer) {\n            if (prev == NULL) {\n                *list = t->next;\n            } else {\n                prev->next = t->next;\n            }\n            t->next = NULL;\n            return true;\n        }\n        prev = t;\n        t = t->next;\n    }\n    return false;\n}\n}\n", "CodeBleu_score": 36.835455288586104}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\ttimerStruct_t *tmp;\n\ttimerStruct_t *prev;\n\ttimerStruct_t *next;\n\n\tprev = NULL;\n\ttmp = *list;\n\n\twhile (tmp != NULL)\n\t{\n\t\tnext = tmp->next;\n\t\tif (tmp == timer)\n\t\t{\n\t\t\tif (prev == NULL)\n\t\t\t{\n\t\t\t\t*list = next;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprev->next = next;\n\t\t\t}\n\t\t\tfree(tmp);\n\t\t\treturn true;\n\t\t}\n\t\tprev = tmp;\n\t\ttmp = next;\n\t}\n\treturn false;\n}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 32.74612739916447}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{\ttimerStruct_t *curr = *list;\n\tif (curr == timer)\n\t{\n\t\t*list = timer->next;\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\ttimerStruct_t *prev = curr;\n\t\tcurr = curr->next;\n\t\twhile (curr != timer)\n\t\t{\n\t\t\tprev = curr;\n\t\t\tcurr = curr->next;\n\t\t}\n\t\tif (curr == timer)\n\t\t{\n\t\t\tprev->next = timer->next;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "CodeBleu_score": 28.740005260576496}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket)    int socket_fd;\n    struct socket_info *socket_info;\n\n    if (socket < 0) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n\n    socket_info = get_socket_info(socket);\n    if (socket_info == NULL) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n\n    socket_fd = socket_info->socket_fd;\n    socket_info->state = NOT_A_SOCKET;\n\n    if (close(socket_fd) < 0) {\n        switch (errno) {\n            case EBADF:\n                errno = ENOTSOCK;\n                break;\n            case EINTR:\n                errno = EINTR;\n                break;\n            default:\n                errno = EIO;\n                break;\n        }\n\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 51.21199162569107}, {"code": "int BSD_close(int socket)    int ret;\n    struct socket_info_t *socket_info = get_socket_info(socket);\n    if (socket_info == NULL) {\n        return BSD_ERROR;\n    }\n    socket_info->state = NOT_A_SOCKET;\n    ret = close(socket);\n    if (ret < 0) {\n        if (errno == EBADF) {\n            set_errno(EBADF);\n            return BSD_ERROR;\n        }\n        if (errno == EINTR) {\n            set_errno(EINTR);\n            return BSD_ERROR;\n        }\n        if (errno == EIO) {\n            set_errno(EIO);\n            return BSD_ERROR;\n        }\n        if (errno == EINVAL) {\n            set_errno(EINVAL);\n            return BSD_ERROR;\n        }\n        if (errno == EMFILE) {\n            set_errno(EMFILE);\n            return BSD_ERROR;\n        }\n        if (errno == ENFILE) {\n            set_errno(ENFILE);\n            return BSD_ERROR;\n        }\n        if (errno == ENOTSOCK) {\n            set_errno(ENOTSOCK);\n            return BSD_ERROR;\n        }\n    }\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 45.97358135821409}, {"code": "int BSD_close(int socket)\tint return_value;\n\tstruct socket_info *socket_ptr;\n\n\tsocket_ptr = get_socket(socket);\n\tif (socket_ptr == NULL) {\n\t\terrno = EBADF;\n\t\treturn BSD_ERROR;\n\t}\n\tsocket_ptr->state = NOT_A_SOCKET;\n\treturn_value = close(socket);\n\tif (return_value == -1) {\n\t\tif (errno == EBADF) {\n\t\t\terrno = ENOTSOCK;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 42.37479072922672}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog)\tint status = listen(socket, backlog);\n\tif (status == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EBADF:\n\t\t\t\terrno = BSD_EBADF;\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\terrno = BSD_ENOTSOCK;\n\t\t\t\tbreak;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\terrno = BSD_EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\terrno = BSD_EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase EADDRINUSE:\n\t\t\t\terrno = BSD_EADDRINUSE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terrno = BSD_ERROR;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 39.28354357234899}, {"code": "int BSD_listen(int socket, int backlog)\tint status;\n\tstatus = listen(socket, backlog);\n\tif (status == -1) {\n\t\tswitch (errno) {\n\t\t\tcase EACCES:\n\t\t\t\terrno = EBADF;\n\t\t\t\tbreak;\n\t\t\tcase EBADF:\n\t\t\t\tbreak;\n\t\t\tcase ENOTSOCK:\n\t\t\t\terrno = EBADF;\n\t\t\t\tbreak;\n\t\t\tcase EADDRINUSE:\n\t\t\t\terrno = EADDRINUSE;\n\t\t\t\tbreak;\n\t\t\tcase EINVAL:\n\t\t\t\terrno = EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase ENOTCONN:\n\t\t\t\terrno = ENOTCONN;\n\t\t\t\tbreak;\n\t\t\tcase EOPNOTSUPP:\n\t\t\t\terrno = EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terrno = EIO;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn BSD_ERROR;\n\t}\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 38.877837750795976}, {"code": "int BSD_listen(int socket, int backlog)\tint ret;\n\t\n\tif ((ret = listen(socket, backlog)) < 0) {\n\t\terrno = -ret;\n\t\treturn BSD_ERROR;\n\t}\n\t\n\treturn BSD_SUCCESS;\n}\n", "CodeBleu_score": 19.86128840852734}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)\tint ret = 0;\n\tint err = 0;\n\tint sock_type = 0;\n\tint sock_family = 0;\n\tint sock_protocol = 0;\n\n\tif (socket < 0) {\n\t\terr = EBADF;\n\t\tgoto error;\n\t}\n\n\tif (addr == NULL) {\n\t\terr = EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (addrlen == NULL) {\n\t\terr = EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (socket_get_type(socket, &sock_type) < 0) {\n\t\terr = EBADF;\n\t\tgoto error;\n\t}\n\n\tif (socket_get_family(socket, &sock_family) < 0) {\n\t\terr = EBADF;\n\t\tgoto error;\n\t}\n\n\tif (socket_get_protocol(socket, &sock_protocol) < 0) {\n\t\terr = EBADF;\n\t\tgoto error;\n\t}\n\n\tif (sock_type != SOCK_STREAM) {\n\t\terr = ENOTSOCK;\n\t\tgoto error;\n\t}\n\n\tif (sock_family == AF_INET) {\n\t\tstruct sockaddr_in addr_in;\n\t\tsocklen_t addrlen_in;\n\t\tint fd = -1;\n\n\t\taddrlen_in = *addrlen;\n\t\tif (addrlen_in > sizeof(struct sockaddr_in)) {\n\t\t\taddrlen_in = sizeof(struct sockaddr_in);\n\t\t}\n\n\t\tif ((fd = accept(socket, (struct sockaddr *)&addr_in, &addrlen_in)) < 0) {\n\t\t\terr = errno;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (addrlen_in > *addrlen) {\n\t\t\taddrlen_in = *addrlen;\n\t\t}\n\n\t\tmemset(addr, 0,", "CodeBleu_score": 38.09144373473097}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)    int ret;\n    int family;\n    int len;\n    int err;\n    struct sockaddr_storage sa;\n    struct sockaddr_storage * sa_ptr = &sa;\n    socklen_t sa_len = sizeof(sa);\n\n    /*\n     * Get the socket address family\n     */\n    len = sizeof(family);\n    if (getsockopt(socket, SOL_SOCKET, SO_DOMAIN, &family, &len) < 0) {\n        err = errno;\n        goto error;\n    }\n\n    /*\n     * Check the address family\n     */\n    if (family != AF_INET && family != AF_INET6) {\n        err = EAFNOSUPPORT;\n        goto error;\n    }\n\n    /*\n     * Call accept\n     */\n    ret = accept(socket, (struct sockaddr *) sa_ptr, &sa_len);\n    if (ret < 0) {\n        err = errno;\n        goto error;\n    }\n\n    /*\n     * Convert the socket address\n     */\n    if (family == AF_INET) {\n        struct sockaddr_in * sa_in = (struct sockaddr_in *) sa_ptr;\n        addr->sa_family = AF_INET;\n        addr->sa_len = sizeof(struct bsd_sockaddr_in);\n        ((struct bsd_sockaddr_in *) addr)->sin_port = ntohs(sa_in->sin_port);\n        ((struct bsd_sockaddr_in *) addr)->sin_addr = sa_in->sin_addr;\n    }\n    else {\n        struct sockaddr_in6 * sa_in6 = (struct sockaddr_in6 *) sa_ptr;\n        addr->sa_family = AF_INET6;\n        addr->sa_len = sizeof(struct bsd_sockaddr_in6);\n        ((struct bsd_sockaddr_in6 *) addr)->sin6_port = ntohs(sa_in6->sin6_port);\n        ((struct bsd_sockaddr_in6 *) addr)->sin6_addr = sa_in", "CodeBleu_score": 42.81334868430024}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)    int status;\n    int ret;\n    int err;\n    struct bsd_sockaddr_in * addr_in;\n    struct bsd_sockaddr_in6 * addr_in6;\n    struct bsd_sockaddr_un * addr_un;\n\n    if (socket < 0 || socket >= BSD_SOCKET_COUNT) {\n        err = BSD_EINVAL;\n        goto error;\n    }\n\n    switch (BSD_socket_table[socket].family) {\n        case BSD_AF_INET:\n            if (addrlen == NULL) {\n                err = BSD_EINVAL;\n                goto error;\n            }\n            if (*addrlen < sizeof(struct bsd_sockaddr_in)) {\n                err = BSD_EINVAL;\n                goto error;\n            }\n            addr_in = (struct bsd_sockaddr_in *)addr;\n            addr_in->sin_family = BSD_AF_INET;\n            status = BSD_accept(socket, (struct bsd_sockaddr *)addr_in, addrlen);\n            break;\n        case BSD_AF_INET6:\n            if (addrlen == NULL) {\n                err = BSD_EINVAL;\n                goto error;\n            }\n            if (*addrlen < sizeof(struct bsd_sockaddr_in6)) {\n                err = BSD_EINVAL;\n                goto error;\n            }\n            addr_in6 = (struct bsd_sockaddr_in6 *)addr;\n            addr_in6->sin6_family = BSD_AF_INET6;\n            status = BSD_accept(socket, (struct bsd_sockaddr *)addr_in6, addrlen);\n            break;\n        case BSD_AF_UNIX:\n            if (addrlen == NULL) {\n                err = BSD_EINVAL;\n                goto error;\n            }\n            if (*addrlen < sizeof(struct bsd_sockaddr_un)) {\n                err = BSD_EINVAL;\n                goto error;\n            }\n            addr_", "CodeBleu_score": 38.48700487241381}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT()  // Get current time\n  time_t currentTime = time(NULL);\n  if (currentTime < 0) {\n    Serial.println(\"Failed to obtain time\");\n  } else {\n    Serial.println(\"Time obtained: \" + String(currentTime));\n    // Update JWT with current time\n    jwt.setTime(currentTime);\n    // Connect to MQTT\n    Serial.println(\"Connecting to MQTT...\");\n    mqttClient.connect(jwt.c_str(), \"unused\", \"unused\");\n    // Set flag to send MQTT SUBSCRIBE packet\n    sendSubscribe = true;\n  }\n}\n", "CodeBleu_score": 54.01876662368288}, {"code": "static void connectMQTT()  unsigned long currentTime = millis();\n  if (currentTime < 1510644967) {\n    Serial.println(\"The current time is not valid, please update the time.\");\n    return;\n  }\n\n  // Disconnect before reconnecting\n  if (client.connected()) {\n    client.disconnect();\n  }\n\n  // Generate the JWT and the client ID. Please note that for simplicity, this example\n  // generates the JWT and the client ID on every run. In practice, these should be generated\n  // once, saved to storage, and re-used as needed.\n  jwt.generate(currentTime);\n  clientId = \"projects/\" + projectId + \"/locations/\" + cloudRegion +\n             \"/registries/\" + registryId + \"/devices/\" + deviceId;\n\n  // Setup the MQTT client\n  client.setServer(mqttBridgeHostname, mqttBridgePort);\n  client.setCallback(callback);\n\n  // Obtain a JWT and use it to connect to Google Cloud IoT Core via MQTT.\n  // Note that this example uses the ESP8266/Arduino WiFiClient class, but MQTT.js,\n  // which is included in the GitHub repository, uses the Node.js net module.\n  Serial.println(\"Connecting to WiFi.\");\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(100);\n  }\n\n  // Configure WiFiClientSecure to use the AWS IoT device credentials\n  client.setSecure(true);\n  client.setInsecure();\n  client.setTimeout(20000);\n  Serial.println(\"Connecting to Google Cloud IoT Core via MQTT, please wait...\");\n  if (!client.connect(clientId, jwt.token(), NULL)) {\n    Serial.println(\"Failed to connect to Google Cloud IoT Core via MQTT.\");\n    delay(1000);\n    return;\n  }\n\n  Serial.println(\"Connected to Google Cloud IoT Core via MQTT.\");\n\n ", "CodeBleu_score": 36.5114809779051}, {"code": "static void connectMQTT()  if (time(nullptr) < 1510644967) {\n    Serial.println(\"The system clock has not been set. Please set the system clock to a valid time.\");\n    return;\n  }\n  // Initialize a JWT\n  jwt.init();\n  // Set the time that the token will expire in\n  jwt.setExpires(3600);\n  // Set the audience for the token\n  jwt.setAudience(PROJECT_ID);\n  // Generate the JWT\n  jwt.generate();\n  // Set the client id to be used for MQTT\n  mqttClient.setId(CLIENT_ID);\n  // Set the username and password for MQTT\n  mqttClient.setUsernamePassword(CLIENT_EMAIL, jwt.sign(PRIVATE_KEY));\n  // Set the message callback to handle messages received from MQTT\n  mqttClient.onMessage(messageReceived);\n  // Connect to the MQTT broker\n  Serial.print(\"Connecting to MQTT...\");\n  mqttClient.connect(BROKER_HOST, BROKER_PORT);\n  Serial.println(\"done.\");\n}\n", "CodeBleu_score": 34.210933258884104}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void)    CLOUD_log(CLOUD_LOG_LEVEL_DEBUG, \"Disconnecting from cloud service...\");\n    if (CLOUD_client.connected) {\n        CLOUD_log(CLOUD_LOG_LEVEL_DEBUG, \"Disconnecting MQTT client...\");\n        CLOUD_client.disconnect();\n    }\n}\n", "CodeBleu_score": 42.539465239370585}, {"code": "void CLOUD_disconnect(void)\tif (MQTT_isConnected()) {\n\t\tMQTT_disconnect();\n\t\tLOG_DEBUG(\"MQTT disconnected\");\n\t}\n}\n", "CodeBleu_score": 21.09644864227711}, {"code": "void CLOUD_disconnect(void)\tif (CLOUD_connected) {\n\t\tCLOUD_connected = false;\n\t\tif (CLOUD_MQTT_client != NULL) {\n\t\t\tMQTT_Client_disconnect(CLOUD_MQTT_client);\n\t\t\tMQTT_Client_delete(CLOUD_MQTT_client);\n\t\t\tCLOUD_MQTT_client = NULL;\n\t\t}\n\t}\n\tCLOUD_debug(\"Disconnected from cloud service\");\n}\n", "CodeBleu_score": 39.76075260874269}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  uint8_t wifi_creds = passed_wifi_creds;\n  uint8_t wifi_status = WIFI_STATUS_ERROR;\n  uint8_t wifi_error = WIFI_ERROR_NONE;\n\n  if (wifi_creds == WIFI_CREDS_DEFAULT) {\n    wifi_creds = WIFI_CREDS_DEFAULT;\n    wifi_status = WIFI_STATUS_DEFAULT;\n    wifi_error = WIFI_ERROR_NONE;\n  } else {\n    wifi_creds = WIFI_CREDS_NEW;\n    wifi_status = WIFI_STATUS_NEW;\n    wifi_error = WIFI_ERROR_NONE;\n  }\n\n  if (wifi_creds == WIFI_CREDS_DEFAULT) {\n    if (WiFi.status() != WL_CONNECTED) {\n      WiFi.begin();\n      while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n      }\n    }\n  } else {\n    if (WiFi.status() != WL_CONNECTED) {\n      WiFi.begin(ssid, pass);\n      while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n      }\n    }\n  }\n\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"\");\n    Serial.println(\"WiFi connection failed!\");\n    Serial.println(\"\");\n    wifi_error = WIFI_ERROR_CONNECTION;\n  } else {\n    Serial.println(\"\");\n    Serial.println(\"WiFi connection successful!\");\n    Serial.println(\"\");\n    Serial.print(\"IP address: \");\n    Serial.println(WiFi.localIP());\n    Serial.println(\"\");\n  }\n\n  if (wifi_error == WIFI_ERROR_NONE) {\n    return true;\n  } else {\n", "CodeBleu_score": 35.18944784251776}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  // If new credentials were passed, use them\n  if (passed_wifi_creds == 1) {\n    // Set Wi-Fi mode to station (connect to an AP)\n    WiFi.mode(WIFI_STA);\n\n    // Connect to the specified SSID using the specified authentication type and password\n    WiFi.begin(ssid, password);\n\n    // Wait for the Wi-Fi connection to be established\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(500);\n      Serial.print(\".\");\n    }\n\n    // Print the IP address of the ESP32\n    Serial.println(\"\");\n    Serial.print(\"Connected to \");\n    Serial.println(ssid);\n    Serial.print(\"IP address: \");\n    Serial.println(WiFi.localIP());\n  }\n\n  // Otherwise, use the default credentials\n  else {\n    // Set Wi-Fi mode to station (connect to an AP)\n    WiFi.mode(WIFI_STA);\n\n    // Connect to the default SSID using the default authentication type and password\n    WiFi.begin();\n\n    // Wait for the Wi-Fi connection to be established\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(500);\n      Serial.print(\".\");\n    }\n\n    // Print the IP address of the ESP32\n    Serial.println(\"\");\n    Serial.print(\"Connected to \");\n    Serial.println(ssid);\n    Serial.print(\"IP address: \");\n    Serial.println(WiFi.localIP());\n  }\n\n  // If the connection failed, log an error message and return false\n  if (WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"\");\n    Serial.println(\"Connection to Wi-Fi access point failed\");\n    Serial.println(\"Check the SSID and password, then try again.\");\n    return false;\n  }\n\n  // Otherwise, return true\n  return true;\n}\n", "CodeBleu_score": 37.71245299385159}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  bool connected = false;\n  uint8_t wifi_creds = passed_wifi_creds;\n  if (wifi_creds == 0) {\n    wifi_creds = wifi_credentials;\n  }\n\n  if (wifi_creds == 1) {\n    WiFi.begin(ssid, password);\n  } else {\n    WiFi.begin();\n  }\n  // Wait for connection\n  Serial.print(\"Connecting to WiFi\");\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\".\");\n    delay(500);\n  }\n  Serial.println();\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n\n  if (WiFi.status() == WL_CONNECTED) {\n    connected = true;\n  }\n  return connected;\n}\n", "CodeBleu_score": 35.96581068022399}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map)  // Create a client to interact with the API.\n  const client = new GraphQLClient(endpoint, {\n    headers: {\n      authorization: `Bearer ${apiKey}`,\n    },\n  });\n\n  // Define a GraphQL query that retrieves a list of sensors.\n  const query = gql`\n    query GetSensors {\n      sensors {\n        id\n        name\n        latitude\n        longitude\n        sensordatavalues {\n          value\n        }\n      }\n    }\n  `;\n\n  // Send the query to the API.\n  const { data, errors } = await client.request(query);\n\n  // If the response contains data, log the retrieval of sensors.\n  if (data) {\n    console.log('Retrieved sensors');\n\n    // Iterate through each sensor and create a marker.\n    data.sensors.forEach((sensor) => {\n      // Create a marker for each sensor.\n      const marker = new H.map.Marker({\n        lat: sensor.latitude,\n        lng: sensor.longitude,\n      });\n\n      // Add the marker to the map.\n      map.addObject(marker);\n\n      // Attach a custom data object to the marker.\n      marker.setData(sensor);\n\n      // Add an event listener to the marker object.\n      marker.addEventListener('tap', (evt) => {\n        // Log the event.\n        console.log(evt.type, evt.target.getData());\n\n        // Create a bubble to display the sensor name and values.\n        const bubble = document.createElement('div');\n        bubble.style.backgroundColor = 'rgba(50, 50, 50, 0.8)';\n        bubble.style.color = '#fff';\n        bubble.style.position = 'absolute';\n        bubble.style.bottom = '10px';\n        bubble.style.left = '10px';\n        bubble.style.padding = '5px';\n        bubble.style.borderRadius = '5px';\n        bubble.style.width = '150px';\n        b", "CodeBleu_score": 35.0775137894917}, {"code": "async function DisplaySensors(map)  // Create a client\n  const client = new AWSAppSync.default({\n    url: 'https://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.appsync-api.us-east-1.amazonaws.com/graphql',\n    region: 'us-east-1',\n    auth: {\n      type: 'API_KEY',\n      apiKey: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "CodeBleu_score": 6.674177306808843}, {"code": "async function DisplaySensors(map)  const client = new ApolloClient({\n    uri: 'https://api.openaq.org/v1/graphql',\n    cache: new InMemoryCache(),\n  });\n\n  const query = gql`\n    query {\n      locations(\n        coordinates: [10.1865, 56.1725, 17.9936, 53.3478]\n        country: \"DK\"\n        has_geo: true\n        orderBy: { field: \"lastUpdated\", direction: DESC }\n      ) {\n        name\n        city\n        country\n        coordinates\n        location\n        lastUpdated\n        sources\n      }\n    }\n  `;\n\n  const { data } = await client.query({ query });\n  console.log(data);\n\n  if (data.locations.length > 0) {\n    console.log('Sensors retrieved');\n\n    data.locations.forEach((sensor) => {\n      const marker = new google.maps.Marker({\n        position: sensor.coordinates,\n        map,\n        title: sensor.name,\n      });\n    });\n  } else {\n    console.log('No sensors found');\n  }\n}\n", "CodeBleu_score": 38.081226491317686}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"sensor-marker\";\n  marker.style.backgroundColor = sensor.color;\n  marker.style.border = \"1px solid black\";\n  return marker;\n};\n", "CodeBleu_score": 34.833197628885124}, {"code": "const CreateSensorMarker = (sensor) =>  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"sensor-marker\";\n  marker.style.backgroundColor = sensor.color;\n  marker.style.border = `2px solid ${sensor.color}`;\n  return marker;\n};\n", "CodeBleu_score": 35.43459291981848}, {"code": "const CreateSensorMarker = (sensor) =>  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = sensor.color;\n  marker.style.border = `2px solid ${sensor.color}`;\n  return marker;\n};\n", "CodeBleu_score": 36.348050484767356}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import %s. Ensure that the package is installed. Error: %s\",\n            module_path,\n            err,\n        )\n        raise\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    requirements = module.REQUIREMENTS  # type: ignore\n    if not requirements:\n        return module\n    if not hass.config.skip_pip:\n        await async_process_requirements(hass, module_path, requirements)\n    return module\n\n", "CodeBleu_score": 43.351572497474145}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Unable to import %s: %s\", module_path, err)\n        raise\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if not hass.config.skip_pip:\n        _process_requirements(module.REQUIREMENTS, module_name)\n    return module\n\n", "CodeBleu_score": 36.55594279056128}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    if module_name in _MFA_MODULES:\n        return _MFA_MODULES[module_name]\n\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Failed to import %s: %s. See the log above for details\", module_path, err\n        )\n        raise\n\n    if module_name not in _MFA_MODULES:\n        _MFA_MODULES[module_name] = module\n\n    return module\n\n", "CodeBleu_score": 33.41554493419893}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    # Extract the PIN from the setup data.\n    pin = setup_data[\"pin\"]\n\n    # Check if the user already has an entry in the internal data list.\n    if user_id in self._data:\n        # If an entry exists, update the PIN.\n        self._data[user_id][\"pin\"] = pin\n    else:\n        # If no entry exists, add a new entry with the user ID and PIN to the data list.\n        self._data[user_id] = {\"pin\": pin}\n\n    # Return the setup data.\n    return setup_data\n\n  async def async_depose_user(self, user_id: str) -> None:\n    \"\"\"The function \"async_depose_user\" depose a user from using an MFA module.\\nIt removes the user's entry from the internal data list.\"\"\"\n    # Remove the user's entry from the internal data list.\n    del self._data[user_id]\n\n  async def async_validate(self, user_id: str, validation_data: Any) -> bool:\n    \"\"\"The function \"async_validate\" validates the user's authentication.\\nIt extracts the PIN from the provided validation data and checks if it matches the PIN in the internal data list.\\nIf the PIN matches, it returns True; otherwise, it returns False.\"\"\"\n    # Extract the PIN from the validation data.\n    pin = validation_data[\"pin\"]\n\n    # Check if the PIN matches the PIN in the internal data list.\n    if pin == self._data[user_id][\"pin\"]:\n        # If the PIN matches, return True.\n        return True\n    else:\n        # If the PIN does not match, return False.\n        return False\n", "CodeBleu_score": 39.05459859746417}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    self.data[user_id] = setup_data[\"pin\"]\n\n    return {\"pin\": setup_data[\"pin\"]}\n\n", "CodeBleu_score": 24.281899108053928}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    if user_id in self._users:\n        self._users[user_id][\"pin\"] = setup_data[\"pin\"]\n    else:\n        self._users[user_id] = {\"pin\": setup_data[\"pin\"]}\n\n    return True\n\n", "CodeBleu_score": 34.629703153510725}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n    if self.is_loaded:\n        return\n    async with self._lock:\n        if self.is_loaded:\n            return\n        data = await self._store.load()\n        if not data:\n            data = {}\n        self._user_settings = {}\n        for user_id, user_data in data.items():\n            user_settings = self._user_settings[user_id] = {}\n            for notify_type, notify_data in user_data.items():\n                user_settings[notify_type] = NotifySetting(notify_type, **notify_data)\n        self.is_loaded = True\n\n", "CodeBleu_score": 32.997522711152435}, {"code": "async def _async_load(self) -> None\n    async with self._lock:\n        if self._settings is None:\n            self._settings = await self._store.load()\n            if self._settings is None:\n                self._settings = {}\n            for user_id in self._settings:\n                self._settings[user_id] = NotifySetting(self._settings[user_id])\n\n", "CodeBleu_score": 28.542311650015474}, {"code": "async def _async_load(self) -> None\n    if self._user_settings is not None:\n        return\n\n    async with self._user_settings_lock:\n        if self._user_settings is not None:\n            return\n\n        user_data = await self._user_store.get_data()\n        if user_data is None:\n            user_data = {}\n\n        self._user_settings = {}\n        for user_id, user_data in user_data.items():\n            self._user_settings[user_id] = NotifySetting(\n                user_id,\n                user_data.get(\"notify_mode\"),\n                user_data.get(\"notify_time\"),\n                user_data.get(\"notify_timezone\"),\n                user_data.get(\"notify_on_mention\"),\n                user_data.get(\"notify_on_message\"),\n                user_data.get(\"notify_on_keyword\"),\n                user_data.get(\"notify_keywords\"),\n                user_data.get(\"notify_on_join\"),\n                user_data.get(\"notify_on_leave\"),\n                user_data.get(\"notify_on_invite\"),\n                user_data.get(\"notify_on_deinvite\"),\n                user_data.get(\"notify_on_kick\"),\n                user_data.get(\"notify_on_ban\"),\n                user_data.get(\"notify_on_unban\"),\n                user_data.get(\"notify_on_topic\"),\n                user_data.get(\"notify_on_nick\"),\n                user_data.get(\"notify_on_part\"),\n                user_data.get(\"notify_on_quit\"),\n                user_data.get(\"notify_on_account_join\"),\n                user_data.get(\"notify_on_account_leave\"),\n                user_data.get(\"notify_on_account_invite\"),\n                user_data.get(\"notify_on_account_deinvite\"),\n                user_data.get(\"notify_on_account_kick\"),\n                user_data.get(\"notify_on_account_ban\"),\n                user_data.get(\"notify_on_account_unban\"),\n                user_data.get(\"notify_on_account_", "CodeBleu_score": 26.64173449772106}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    # Get user settings\n    await self.async_get_user_settings(user_id)\n    # If no settings are found for the user, return False\n    if not self.user_settings[user_id]:\n        return False\n    # Get the notification settings for the user\n    notification_settings = self.user_settings[user_id][\"notification_settings\"]\n    # Get the OTP settings for the user\n    otp_settings = self.user_settings[user_id][\"otp_settings\"]\n    # If the OTP settings are not found for the user, return False\n    if not otp_settings:\n        return False\n    # Get the OTP secret for the user\n    otp_secret = otp_settings[\"otp_secret\"]\n    # If the OTP secret is not found for the user, return False\n    if not otp_secret:\n        return False\n    # If the OTP secret is not a valid base32 string, return False\n    if not is_base32(otp_secret):\n        return False\n    # Get the OTP algorithm for the user\n    otp_algorithm = otp_settings[\"otp_algorithm\"]\n    # If the OTP algorithm is not found for the user, return False\n    if not otp_algorithm:\n        return False\n    # If the OTP algorithm is not a valid OTP algorithm, return False\n    if otp_algorithm not in OTP_ALGORITHMS:\n        return False\n    # Get the OTP digits for the user\n    otp_digits = otp_settings[\"otp_digits\"]\n    # If the OTP digits is not found for the user, return False\n    if not otp_digits:\n        return False\n    # If the OTP digits is not a valid OTP digits, return False\n    if otp_digits not in OTP_DIGITS:\n        return False\n    # Get the OTP period for the user\n    otp_period = otp_settings[\"otp_period\"]\n    # If the OTP period is not found for the user, return False\n    if not otp_period:\n        return False\n    # If the OTP period is", "CodeBleu_score": 38.33627049789856}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    # Load user settings\n    await self.load_user_settings(user_id)\n\n    # Retrieve user settings\n    user_settings = self.users[user_id]\n\n    # Validate user input\n    validation_result = await self.validate_user_input(user_id, user_input, user_settings)\n\n    # Return validation result\n    return validation_result\n\n", "CodeBleu_score": 33.41982798377949}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    # Ensure user settings are loaded\n    await self.async_load_user_settings(user_id)\n\n    # Retrieve the notification settings for the specified user\n    user_settings = self._user_settings.get(user_id, {})\n\n    # If no settings are found for the user, return False\n    if not user_settings:\n        return False\n\n    # Validate the user input by verifying the OTP using an executor job\n    return await self.async_verify_otp(user_settings, user_input)\n\n", "CodeBleu_score": 38.05279201572251}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    try:\n        entity_entry = perm_lookup.entity_lookup[entity_id]\n    except KeyError:\n        return None\n\n    device_id = entity_entry.device_id\n    try:\n        device_entry = perm_lookup.device_lookup[device_id]\n    except KeyError:\n        return None\n\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n\n    try:\n        return area_dict[area_id]\n    except KeyError:\n        return None\n\n", "CodeBleu_score": 50.85331796542596}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.get_entity(entity_id)\n    if entity is None:\n        return None\n    device_entry = perm_lookup.get_device(entity.device_id)\n    if device_entry is None:\n        return None\n    area_id = device_entry.area_id\n    if area_id is None:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 57.84076624051481}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if entity_entry is None:\n        return None\n    device_entry = perm_lookup.get_device(entity_entry.device_id)\n    if device_entry is None:\n        return None\n    if device_entry.area_id is None:\n        return None\n    area_entry = perm_lookup.get_area(device_entry.area_id)\n    if area_entry is None:\n        return None\n    return area_dict.get(area_entry.entity_id)\n\n", "CodeBleu_score": 65.96818476895422}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy = PolicyType()\n    seen_categories = set()\n    for policy in policies:\n        for category, category_policy in policy.items():\n            if category not in seen_categories:\n                merged_policy[category] = PolicyType()\n                seen_categories.add(category)\n            for action, action_policy in category_policy.items():\n                if action not in merged_policy[category]:\n                    merged_policy[category][action] = PolicyType()\n                for resource, resource_policy in action_policy.items():\n                    if resource not in merged_policy[category][action]:\n                        merged_policy[category][action][resource] = PolicyType()\n                    for effect in resource_policy:\n                        merged_policy[category][action][resource].add(effect)\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 34.61530427227611}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, category_policy in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = {}\n            for action, action_policy in category_policy.items():\n                if action not in merged_policy[category]:\n                    merged_policy[category][action] = {}\n                for resource, resource_policy in action_policy.items():\n                    if resource not in merged_policy[category][action]:\n                        merged_policy[category][action][resource] = {}\n                    for effect in resource_policy:\n                        if effect not in merged_policy[category][action][resource]:\n                            merged_policy[category][action][resource][effect] = []\n                        merged_policy[category][action][resource][effect].append(resource_policy[effect])\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 32.618828121763514}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n\n    for policy in policies:\n        for category, category_policy in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = category_policy\n            else:\n                merged_policy[category] = merge_policy_categories(\n                    merged_policy[category], category_policy\n                )\n\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 50.39099084569541}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(f\"homeassistant.auth.providers.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import provider %s: %s\",\n            provider,\n            \"\".join(traceback.format_exception(type(err), err, err.__traceback__)),\n        )\n        raise HomeAssistantError() from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hass.config.skip_pip:\n        await async_process_requirements(hass, module.REQUIREMENTS)\n\n    return module\n\n", "CodeBleu_score": 39.74390385642728}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    module = importlib.import_module(f\"homeassistant.auth.providers.{provider}\")\n    if getattr(module, \"REQUIREMENTS\", None) is None:\n        return module\n    reqs = await async_get_integration_with_requirements(hass, DOMAIN, module.REQUIREMENTS)\n    if not reqs.requirements:\n        return module\n    await hass.helpers.discovery.async_process_requirements(\n        reqs.requirements,\n        log_func=lambda msg: _LOGGER.error(\n            \"Unable to set up %s integration: %s\", DOMAIN, msg\n        ),\n    )\n    return module\n\n", "CodeBleu_score": 31.464733720847953}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(provider)\n    except ImportError as err:\n        _LOGGER.error(\n            \"Unable to import auth provider %s: %s\",\n            provider,\n            err,\n        )\n        raise HomeAssistantError(\n            f\"Unable to import auth provider {provider}: {err}\"\n        ) from err\n\n    if provider in _PROCESSED_REQUIREMENTS:\n        return module\n\n    # Process the requirements for the provider\n    reqs = getattr(module, \"REQUIREMENTS\", [])\n    _PROCESSED_REQUIREMENTS.add(provider)\n    for req in reqs:\n        # If the requirement is a string, it is a package name\n        if isinstance(req, str):\n            # If the package is not installed, install it\n            if req not in _INSTALLED_PACKAGES:\n                await hass.async_add_executor_job(\n                    install_package, req, target=hass.config.path(PACKAGE_CACHE_DIR)\n                )\n                _INSTALLED_PACKAGES.add(req)\n        # If the requirement is a dict, it is a package with extras\n        elif isinstance(req, dict):\n            # If the package is not installed, install it\n            if req[\"package\"] not in _INSTALLED_PACKAGES:\n                await hass.async_add_executor_job(\n                    install_package,\n                    req[\"package\"],\n                    target=hass.config.path(PACKAGE_CACHE_DIR),\n                    extras=req.get(\"extras\", []),\n                )\n                _INSTALLED_PACKAGES.add(req[\"package\"])\n\n    return module\n\n", "CodeBleu_score": 43.61045617185584}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n    self.users = await self.store.get(self.name)\n    if self.users is None:\n        self.users = []\n    for user in self.users:\n        if user.username.lower() != user.username:\n            user.username = user.username.lower()\n    self.users = sorted(self.users, key=lambda user: user.username)\n\n", "CodeBleu_score": 26.214672362315394}, {"code": "async def async_load(self) -> None\n    try:\n        self.users = await self.store.get()\n    except KeyError:\n        self.users = []\n    self.users = [user for user in self.users if user[\"username\"] != user[\"name\"]]\n\n", "CodeBleu_score": 29.836613966873195}, {"code": "async def async_load(self) -> None\n    try:\n        self.users = await self.store.get()\n        if self.users is None:\n            self.users = []\n    except Exception:\n        self.users = []\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user[\"username\"] != user[\"username\"].lower():\n            user[\"username\"] = user[\"username\"].lower()\n\n    # Check for non-normalized usernames\n    for user in self.users:\n        if user", "CodeBleu_score": 20.324207220470406}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n\n    # Normalize the username\n    username = username.lower()\n\n    # Initialize a dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.kdf(\n        password=b\"\",\n        salt=b\"\",\n        desired_key_bytes=32,\n        rounds=10,\n    )\n\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        if user[\"username\"] == username:\n            # Decode the stored password hash\n            stored_hash = base64.b64decode(user[\"password\"])\n\n            # Use bcrypt's timing-safe check to compare the provided password with the stored hash\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                return\n\n            # Raise an \"InvalidAuth\" exception if the passwords do not match\n            raise InvalidAuth(\"Invalid username or password\")\n\n    # Raise an \"InvalidAuth\" exception if no matching user is found\n    raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 40.14224876218738}, {"code": "def validate_login(self, username: str, password: str) -> None\n\n    # Normalize the username\n    username = username.lower()\n\n    # Initialize a dummy hash to prevent timing attacks\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n\n    # Iterate through all users to find a matching username\n    for user in self.users:\n        if user[\"username\"] == username:\n            # Decode the stored password hash\n            stored_hash = base64.b64decode(user[\"password\"])\n\n            # Use bcrypt's timing-safe check to compare the provided password with the stored hash\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_hash):\n                # If the passwords match, return the user's ID\n                return user[\"id\"]\n            else:\n                # If the passwords do not match, raise an \"InvalidAuth\" exception\n                raise InvalidAuth\n\n    # If no matching user is found, perform a dummy hash check\n    if not bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash):\n        # If the dummy hash check fails, raise an \"InvalidAuth\" exception\n        raise InvalidAuth\n\n", "CodeBleu_score": 45.98914441149825}, {"code": "def validate_login(self, username: str, password: str) -> None\n\n    # Normalize username\n    username = username.lower()\n\n    # Initialize dummy hash\n    dummy_hash = bcrypt.kdf(\n        password=b\"\",\n        salt=self.salt,\n        desired_key_bytes=self.key_size,\n        rounds=self.rounds,\n    )\n\n    # Iterate through users\n    for user in self.users:\n        # If the username matches\n        if user[\"username\"] == username:\n            # Decode the stored password hash\n            stored_hash = base64.b64decode(user[\"password\"])\n\n            # Check if the password matches the stored hash\n            if bcrypt.checkpw(password, stored_hash):\n                # If the passwords match, return the user\n                return user\n\n            # If the passwords do not match, raise an \"InvalidAuth\" exception\n            raise InvalidAuth\n\n    # If no matching user is found, raise an \"InvalidAuth\" exception\n    raise InvalidAuth\n\n", "CodeBleu_score": 41.69119912557856}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n    username = self.normalize_username(username)\n    if username in self.users:\n        del self.users[username]\n    else:\n        raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 21.972164680910026}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = self.__normalize_username(username)\n    for i in range(len(self.__users)):\n        if self.__users[i].username == username:\n            del self.__users[i]\n            return\n    raise InvalidUser(self.user_not_found)\n\n", "CodeBleu_score": 31.183853018613217}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = self.normalize_username(username)\n    for user in self.users:\n        if user.username == username:\n            self.users.remove(user)\n            return\n    raise InvalidUser(message=\"user_not_found\")\n", "CodeBleu_score": 32.599822251694384}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.data:\n        await self.async_load()\n\n    try:\n        self.data.pop(credentials.data[CONF_USERNAME])\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 44.47249157944211}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if self.data is None:\n        await self.async_initialize()\n\n    try:\n        self.data.pop(credentials.unique_id)\n        await self.async_save()\n    except KeyError:\n        pass\n\n", "CodeBleu_score": 53.79862301814898}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.credentials:\n        await self.async_init_credentials()\n    try:\n        await self.credentials.async_remove_credentials(credentials)\n        await self.async_save_credentials()\n    except InvalidUser:\n        pass\n\n", "CodeBleu_score": 48.32688760530173}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined_threads: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive() or not thread.ident:\n            joined_threads.add(thread)\n            continue\n        thread.join(timeout=timeout)\n        if not thread.is_alive():\n            joined_threads.add(thread)\n        elif log:\n            print(f\"Thread {thread.name} still running\")\n        else:\n            pass\n    for thread in threads - joined_threads:\n        try:\n            thread.raise_exc(SystemExit)\n        except RuntimeError:\n            pass\n    return joined_threads\n\n", "CodeBleu_score": 45.859202874621616}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined: set[Thread] = set()\n    for thread in threads:\n        if not thread.is_alive():\n            joined.add(thread)\n        elif not hasattr(thread, \"ident\"):\n            joined.add(thread)\n        else:\n            if log:\n                print(f\"{thread.ident} is still running\")\n            thread.join(timeout)\n            if not thread.is_alive():\n                joined.add(thread)\n            else:\n                try:\n                    thread.raise_exception(SystemExit)\n                except Exception as e:\n                    print(f\"{thread.ident} raised {e}\")\n    return joined\n\n", "CodeBleu_score": 39.8073104151876}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined_threads: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive() and thread.ident:\n            thread.join(timeout=timeout)\n            if not thread.is_alive():\n                joined_threads.add(thread)\n            elif log:\n                print(f\"{thread.name} is still running.\")\n        else:\n            joined_threads.add(thread)\n    for thread in threads.difference(joined_threads):\n        if thread.is_alive():\n            try:\n                thread.raise_exc(SystemExit)\n            except Exception:\n                pass\n    return joined_threads\n\n", "CodeBleu_score": 44.11321187536017}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n    global _shutdown_lock\n    if not _shutdown_lock.acquire(False):\n        return\n    try:\n        # Calculate the total timeout\n        total_timeout = _shutdown_timeout\n        # Calculate the timeout for each thread\n        thread_timeout = total_timeout / len(_threads)\n        # Create a list of threads to join\n        threads_to_join = []\n        # Iterate over all threads\n        for thread in _threads:\n            # If the thread is not the main thread and is not a daemon thread and is still alive\n            if thread != threading.main_thread() and not thread.daemon and thread.is_alive():\n                # Add the thread to the list of threads to join\n                threads_to_join.append(thread)\n        # Join all threads\n        for thread in threads_to_join:\n            # Join the thread\n            thread.join(thread_timeout)\n            # If the thread is still alive\n            if thread.is_alive():\n                # Log a warning\n                logging.warning(f\"Failed to join thread '{thread.name}'.\")\n    finally:\n        _shutdown_lock.release()\n\n", "CodeBleu_score": 37.65454015792737}, {"code": "def deadlock_safe_shutdown() -> None\n    # get the total shutdown timeout\n    shutdown_timeout: float = get_shutdown_timeout()\n    # get the current thread\n    current_thread: threading.Thread = threading.current_thread()\n    # get all non-main, non-daemon, alive threads\n    non_main_non_daemon_alive_threads: List[threading.Thread] = [thread for thread in threading.enumerate() if thread is not current_thread and not thread.daemon and thread.is_alive()]\n    # calculate the timeout for each thread\n    thread_timeout: float = shutdown_timeout / len(non_main_non_daemon_alive_threads)\n    # attempt to join each thread within the calculated timeout\n    for thread in non_main_non_daemon_alive_threads:\n        try:\n            thread.join(timeout=thread_timeout)\n        except RuntimeError:\n            logging.warning(f\"Failed to join thread {thread.name} within {thread_timeout} seconds\")\n\n", "CodeBleu_score": 39.0512893304222}, {"code": "def deadlock_safe_shutdown() -> None\n\n    # Get the current thread\n    current_thread = threading.current_thread()\n\n    # Get all non-main, non-daemon, alive threads\n    all_threads = [thread for thread in threading.enumerate() if thread is not current_thread and not thread.daemon and thread.is_alive()]\n\n    # If there are no non-main, non-daemon, alive threads, then return\n    if not all_threads:\n        return\n\n    # Calculate the total shutdown timeout\n    total_shutdown_timeout = 10\n\n    # Calculate the timeout for each thread\n    thread_timeouts = [total_shutdown_timeout / len(all_threads)] * len(all_threads)\n\n    # Attempt to join each thread within the calculated timeout\n    for thread, timeout in zip(all_threads, thread_timeouts):\n        try:\n            thread.join(timeout)\n        except RuntimeError:\n            # Log a warning if joining a thread fails\n            logging.warning(f'Failed to join thread {thread.name}')\n\n", "CodeBleu_score": 37.054305777765826}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n      self._remaining_setups = remaining_with_setup_started\n      self.dispatcher.dispatch(self.signal, remaining_with_setup_started)\n    else:\n      self._remaining_setups = {}\n\n  def _async_setup_finished(self, setup_name: str, setup_result: dict[str, Any]) -> None:\n    \"\"\"The function \"_async_setup_finished\" is called when a setup is finished.\\nIt removes the setup from the remaining setups and dispatches the signal if there are remaining setups.\"\"\"\n    if setup_name in self._remaining_setups:\n      del self._remaining_setups[setup_name]\n      self._async_dispatch(self._remaining_setups)\n\n  def _async_setup_started(self, setup_name: str, setup_result: dict[str, Any]) -> None:\n    \"\"\"The function \"_async_setup_started\" is called when a setup is started.\\nIt adds the setup to the remaining setups and dispatches the signal if there are remaining setups.\"\"\"\n    self._remaining_setups[setup_name] = setup_result[\"start_time\"]\n    self._async_dispatch(self._remaining_setups)\n\n  def _async_setup_error(self, setup_name: str, setup_result: dict[str, Any]) -> None:\n    \"\"\"The function \"_async_setup_error\" is called when a setup is finished with an error.\\nIt removes the setup from the remaining setups and dispatches the signal if there are remaining setups.\"\"\"\n    if setup_name in self._remaining_setups:\n      del self._remaining_setups[setup_name]\n      self._async_dispatch(self._remaining_setups)\n\n  def _async_setup_cancelled(self, setup_name: str, setup_result: dict[str, Any]) -> None:\n    \"\"\"The function \"_async_setup_cancelled\" is called when a setup is cancelled.\\nIt removes the setup from the remaining setups and dispatches the signal if there are remaining setups.\"\"\"\n    if setup", "CodeBleu_score": 41.69926922615274}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    # If there are remaining setups or the previous state was not empty, send an internal dispatcher signal with the remaining setups.\n    if remaining_with_setup_started:\n      self._dispatcher_signal.send(self, remaining_with_setup_started=remaining_with_setup_started)\n\n    # Update the internal flag to reflect whether there are remaining setups.\n    self._remaining_setups = remaining_with_setup_started\n\n  def _async_dispatcher(self, remaining_with_setup_started: dict[str, float]) -> None:\n    \"\"\"The function \"_async_dispatcher\" is the callback for the internal dispatcher signal.\\nIt dispatches a signal with the remaining setups.\"\"\"\n    self.dispatcher_signal.send(self, remaining_with_setup_started=remaining_with_setup_started)\n\n  def _async_setup_started(self, setup: str) -> None:\n    \"\"\"The function \"_async_setup_started\" is the callback for the internal setup started signal.\\nIt updates the internal flag to reflect whether the setup has started.\"\"\"\n    self._setups_started.add(setup)\n\n  def _async_setup_finished(self, setup: str) -> None:\n    \"\"\"The function \"_async_setup_finished\" is the callback for the internal setup finished signal.\\nIt updates the internal flag to reflect whether the setup has finished.\"\"\"\n    self._setups_finished.add(setup)\n\n  def _async_setup_failed(self, setup: str) -> None:\n    \"\"\"The function \"_async_setup_failed\" is the callback for the internal setup failed signal.\\nIt updates the internal flag to reflect whether the setup has failed.\"\"\"\n    self._setups_failed.add(setup)\n\n  def _async_setup_succeeded(self, setup: str) -> None:\n    \"\"\"The function \"_async_setup_succeeded\" is the callback for the internal setup succeeded signal.\\nIt updates the internal flag to reflect whether the setup has succeeded.\"\"\"\n    self._setups_succeeded.add(setup)\n\n  def _async_setup_skipped(self", "CodeBleu_score": 45.034036725718806}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started:\n      self.dispatcher_signal.emit(remaining_with_setup_started)\n    self.remaining_setups = remaining_with_setup_started\n\n  def _async_dispatch_setup_started(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_started\" dispatches a signal when a setup is started.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self.dispatcher_setup_started_signal.emit(setup_name)\n    self.remaining_setups = {setup_name: self.remaining_setups[setup_name]}\n\n  def _async_dispatch_setup_finished(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_finished\" dispatches a signal when a setup is finished.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self.dispatcher_setup_finished_signal.emit(setup_name)\n    self.remaining_setups = {}\n\n  def _async_dispatch_setup_failed(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_failed\" dispatches a signal when a setup is failed.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self.dispatcher_setup_failed_signal.emit(setup_name)\n    self.remaining_setups = {}\n\n  def _async_dispatch_setup_canceled(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_canceled\" dispatches a signal when a setup is canceled.\\nIt then updates the internal flag to reflect whether there are remaining setups.\"\"\"\n    self.dispatcher_setup_canceled_signal.emit(setup_name)\n    self.remaining_setups = {}\n\n  def _async_dispatch_setup_finished_or_failed(self, setup_name: str) -> None:\n    \"\"\"The function \"_async_dispatch_setup_finished_or_failed\" dispatches a", "CodeBleu_score": 39.1777049818027}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # get the current content of bluetooth.py\n    bluetooth_py_path = config.path / \"bluetooth.py\"\n    bluetooth_py = bluetooth_py_path.read_text()\n\n    # generate the content of bluetooth.py\n    bluetooth_py_new = generate(integrations)\n\n    # if the content is the same, no need to validate\n    if bluetooth_py == bluetooth_py_new:\n        return\n\n    # if the content is different, check if it's valid\n    bluetooth_py_new_path = config.path / \"bluetooth.py.new\"\n    bluetooth_py_new_path.write_text(bluetooth_py_new)\n    try:\n        config.hass.async_call_service(\"script\", \"bluetooth_update\")\n    except HomeAssistantError as error:\n        # if the content is invalid, add an error to the configuration\n        config.add_error(\n            \"bluetooth.py\",\n            f\"{error}\\n\\nTo fix this, run the following command: `cp {bluetooth_py_new_path} {bluetooth_py_path}`\",\n        )\n\n", "CodeBleu_score": 42.6162862001213}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    if not config.get(\"bluetooth.py\", False):\n        return\n    bluetooth_file = Path(config[\"bluetooth.py\"])\n    if not bluetooth_file.exists():\n        config.error(\n            f\"Bluetooth file {bluetooth_file} does not exist. Please create it.\",\n            \"bluetooth.py\",\n        )\n        return\n\n    if not bluetooth_file.is_file():\n        config.error(\n            f\"Bluetooth file {bluetooth_file} is not a file. Please remove it.\",\n            \"bluetooth.py\",\n        )\n        return\n\n    bluetooth_content = bluetooth_file.read_text()\n\n    # Check if all integrations are being validated\n    for integration in integrations.values():\n        if integration.bluetooth:\n            continue\n        config.error(\n            f\"Integration {integration.name} does not have a bluetooth.py file.\",\n            \"bluetooth.py\",\n        )\n\n    # Generate the content of the bluetooth.py file\n    bluetooth_content_generated = \"\"\n    for integration in integrations.values():\n        if not integration.bluetooth:\n            continue\n        bluetooth_content_generated += integration.bluetooth\n\n    # Check if the content of the bluetooth.py file matches the generated content\n    if bluetooth_content_generated != bluetooth_content:\n        config.error(\n            \"Bluetooth file is not up to date. Please run the 'python3 -m homeassistant' command to generate the new bluetooth.py file.\",\n            \"bluetooth.py\",\n            fixable=True,\n            fixer=lambda: bluetooth_file.write_text(bluetooth_content_generated),\n        )\n\n", "CodeBleu_score": 37.74928610835093}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    if not config.cache_dir.exists():\n        config.cache_dir.mkdir(parents=True)\n    if not config.cache_dir.is_dir():\n        raise RuntimeError(f\"Cache directory {config.cache_dir} is not a directory\")\n    bluetooth_py = config.cache_dir / \"bluetooth.py\"\n    if not bluetooth_py.exists():\n        bluetooth_py.touch()\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n    if not bluetooth_py.is_file():\n        raise RuntimeError(f\"Cache file {bluetooth_py} is not a file\")\n", "CodeBleu_score": 25.27917022051851}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\tdata := url.Values{}\n\tdata.Set(\"refresh_token\", d.RefreshToken)\n\tdata.Set(\"client_id\", d.AppKey)\n\tdata.Set(\"client_secret\", d.AppSecret)\n\tdata.Set(\"grant_type\", \"refresh_token\")\n\n\treq, err := http.NewRequest(\"POST\", url, strings.NewReader(data.Encode()))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tlog.Printf(\"Dropbox: Refresh token failed: %s\", body)\n\t\treturn errors.New(\"Dropbox: Refresh token failed\")\n\t}\n\n\tvar tokenResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t\tTokenType   string `json:\"token_type\"`\n\t\tUID         string `json:\"uid\"`\n\t\tAccountID   string `json:\"account_id\"`\n\t}\n\n\terr = json.Unmarshal(body, &tokenResponse)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.AccessToken = tokenResponse.AccessToken\n\treturn nil\n}\n", "CodeBleu_score": 48.891601657381955}, {"code": "func (d *Dropbox) refreshToken() error\tdata := url.Values{}\n\tdata.Set(\"refresh_token\", d.RefreshToken)\n\tdata.Set(\"client_id\", d.AppKey)\n\tdata.Set(\"client_secret\", d.AppSecret)\n\tdata.Set(\"grant_type\", \"refresh_token\")\n\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(data.Encode()))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\n\tclient := http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"Error refreshing token: %s\\n\", string(body))\n\t\treturn errors.New(\"error refreshing token\")\n\t}\n\n\tvar token Token\n\terr = json.Unmarshal(body, &token)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.AccessToken = token.AccessToken\n\treturn nil\n}\n", "CodeBleu_score": 50.0193930638724}, {"code": "func (d *Dropbox) refreshToken() error\t// Create a request to send to the Dropbox OAuth2 token endpoint\n\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\trequest, err := http.NewRequest(http.MethodPost, url, strings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the headers to the request\n\trequest.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\trequest.Header.Add(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.appKey+\":\"+d.appSecret)))\n\n\t// Send the request to the Dropbox OAuth2 token endpoint\n\tclient := &http.Client{}\n\tresponse, err := client.Do(request)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Read the response body\n\tbody, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Parse the response body as JSON\n\tvar responseJSON map[string]interface{}\n\terr = json.Unmarshal(body, &responseJSON)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the response contains an access token, update the access token\n\tif _, ok := responseJSON[\"access_token\"]; ok {\n\t\td.accessToken = responseJSON[\"access_token\"].(string)\n\t}\n\n\t// If the response contains an error, log the error and return an error\n\tif _, ok := responseJSON[\"error\"]; ok {\n\t\tlog.Println(\"Error refreshing token:\", responseJSON[\"error\"].(string))\n\t\treturn errors.New(\"Error refreshing token\")\n\t}\n\n\t// Return nil if no errors occur\n\treturn nil\n}\n", "CodeBleu_score": 47.27451905256639}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\tif d.token == nil {\n\t\treturn nil, errors.New(\"token is nil\")\n\t}\n\tif d.token.AccessToken == \"\" {\n\t\treturn nil, errors.New(\"token has no access token\")\n\t}\n\tif d.token.RefreshToken == \"\" {\n\t\treturn nil, errors.New(\"token has no refresh token\")\n\t}\n\tif d.token.Expiry.Before(time.Now()) {\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tvar req *http.Request\n\tvar err error\n\tif callback != nil {\n\t\treq, err = callback(d.token.AccessToken, url, method)\n\t} else {\n\t\treq, err = http.NewRequest(method, url, nil)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\tif resp != nil {\n\t\tif err := base.SetReqBody(req, resp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tclient := &http.Client{}\n\tresp, err = client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\tif resp.StatusCode == 401 {\n\t\tif err := d.refreshToken(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.request(url, method, callback, resp)\n\t}\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\treturn nil, fmt.Errorf(\"request failed: %d %s\", resp.StatusCode, resp.Status)\n\t}\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}\n", "CodeBleu_score": 56.63961010771506}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\t// Set the authorization header.\n\theaders := map[string]string{\"Authorization\": \"Bearer \" + d.token.AccessToken}\n\n\t// Set the drive ID.\n\tif d.driveId != \"\" {\n\t\theaders[\"driveId\"] = d.driveId\n\t}\n\n\t// Set the request body.\n\tvar body []byte\n\tif resp != nil {\n\t\tbody = base.ToJSONBytes(resp)\n\t}\n\n\t// Send the request.\n\treturn d.client.Request(url, method, callback, body, headers)\n}\n", "CodeBleu_score": 25.668913829173917}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\tif d.token == nil {\n\t\treturn nil, errors.New(\"no token\")\n\t}\n\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\tclient := &http.Client{}\n\tvar respData []byte\n\tvar respErr error\n\tfor i := 0; i < 2; i++ {\n\t\trespData, respErr = client.Do(req)\n\t\tif respErr == nil {\n\t\t\tbreak\n\t\t}\n\t\tif !d.token.RefreshToken.Valid() {\n\t\t\treturn nil, respErr\n\t\t}\n\t\tif respErr != nil {\n\t\t\tif respErr.Error() == \"invalid_grant\" {\n\t\t\t\treturn nil, respErr\n\t\t\t}\n\t\t\tif respErr.Error() != \"401 Unauthorized\" {\n\t\t\t\treturn nil, respErr\n\t\t\t}\n\t\t}\n\t\tif respErr != nil {\n\t\t\td.token, err = d.refreshToken(d.token.RefreshToken.Token)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\tif respErr != nil {\n\t\treturn nil, respErr\n\t}\n\tif resp != nil {\n\t\terr = json.Unmarshal(respData, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn respData, nil\n}\n", "CodeBleu_score": 51.50196392088237}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\tvar (\n\t\tfileSize   = stream.Size()\n\t\tchunkSize  = d.chunkSize\n\t\tchunkCount = int(math.Ceil(float64(fileSize) / float64(chunkSize)))\n\t\tchunk      = make([]byte, chunkSize)\n\t\ti          int\n\t)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif i >= chunkCount {\n\t\t\tbreak\n\t\t}\n\n\t\tn, err := stream.Read(chunk)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// If the file is smaller than the chunk size, the last chunk will be smaller than the chunk size.\n\t\tif n < chunkSize {\n\t\t\tchunk = chunk[:n]\n\t\t}\n\n\t\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, bytes.NewReader(chunk))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\treq.Header.Set(\"Content-Length\", strconv.Itoa(n))\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", i*chunkSize, (i+1)*chunkSize-1, fileSize))\n\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {\n\t\t\treturn fmt.Errorf(\"chunk upload failed with status code %d\", resp.StatusCode)\n\t\t}\n\n\t\ti++\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 38.754563604274104}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\tvar (\n\t\tchunkSize = int64(1024 * 1024 * 5) // 5MB\n\t\tchunk     = make([]byte, chunkSize)\n\t\tchunkIdx  int\n\t\tchunkErr  error\n\t)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tchunkIdx, chunkErr = stream.Next(chunk)\n\t\tif chunkErr != nil {\n\t\t\tif chunkErr == io.EOF {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn chunkErr\n\t\t}\n\n\t\t// The last chunk might be smaller than the chunk size.\n\t\tif chunkIdx < chunkSize {\n\t\t\tchunk = chunk[:chunkIdx]\n\t\t}\n\n\t\tif err := d.uploadChunk(ctx, url, chunk); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.29024196262036}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate the chunk size.\n\tchunkSize := d.chunkSize(stream.Size())\n\n\t// Create a new HTTP request.\n\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to create a new HTTP request: %w\", err)\n\t}\n\n\t// Set the appropriate headers for the first chunk.\n\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes 0-%d/%d\", chunkSize-1, stream.Size()))\n\n\t// Create a new HTTP client.\n\tclient := &http.Client{\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\treturn http.ErrUseLastResponse\n\t\t},\n\t}\n\n\t// Create a new buffer.\n\tbuf := make([]byte, chunkSize)\n\n\t// Read the file in chunks and upload it to Google Drive.\n\tfor {\n\t\t// Check if the context was cancelled.\n\t\tif ctx.Err() != nil {\n\t\t\treturn ctx.Err()\n\t\t}\n\n\t\t// Read the file.\n\t\tn, err := stream.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn fmt.Errorf(\"failed to read the file: %w\", err)\n\t\t}\n\n\t\t// If the file is completely read, break the loop.\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Create a new buffer with the correct size.\n\t\tbuf = buf[:n]\n\n\t\t// Set the request body.\n\t\treq.Body = ioutil.NopCloser(bytes.NewReader(buf))\n\n\t\t// Send the request.\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to send the request: %w\", err)\n\t\t}\n\n\t\t// Check if the response status code is 308.\n\t\tif resp.StatusCode != http.StatusPerman", "CodeBleu_score": 39.804118192356356}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error\t// Bind JSON data from the request context and retrieve the \"mount_point\" value.\n\tvar request UmountStorageRequest\n\tif err := ctx.Bind(&request); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, ErrorResponse{\n\t\t\tError:       \"Failed to parse request body\",\n\t\t\tDescription: err.Error(),\n\t\t})\n\t}\n\n\t// If the mount point is empty, return a client error response.\n\tif request.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, ErrorResponse{\n\t\t\tError:       \"Invalid request\",\n\t\t\tDescription: \"The mount point is empty\",\n\t\t})\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point and return a service error response if unmounting fails.\n\tif err := umountStorage(request.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, ErrorResponse{\n\t\t\tError:       \"Failed to unmount storage\",\n\t\t\tDescription: err.Error(),\n\t\t})\n\t}\n\n\t// Delete the corresponding configuration and return a success response.\n\tif err := deleteStorageConfiguration(request.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, ErrorResponse{\n\t\t\tError:       \"Failed to delete storage configuration\",\n\t\t\tDescription: err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, SuccessResponse{\n\t\tSuccess: true,\n\t})\n}\n", "CodeBleu_score": 41.68071156157045}, {"code": "func UmountStorage(ctx echo.Context) error\t// Bind the request body to a new \"UmountStorageRequest\" object.\n\trequest := new(UmountStorageRequest)\n\tif err := ctx.Bind(request); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, &ErrorResponse{\n\t\t\tCode:    http.StatusBadRequest,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\n\t// If the mount point is empty, return a client error response.\n\tif request.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, &ErrorResponse{\n\t\t\tCode:    http.StatusBadRequest,\n\t\t\tMessage: \"mount point is empty\",\n\t\t})\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point.\n\tif err := UnmountStorage(request.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, &ErrorResponse{\n\t\t\tCode:    http.StatusInternalServerError,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\n\t// Delete the corresponding configuration.\n\tif err := DeleteStorage(request.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, &ErrorResponse{\n\t\t\tCode:    http.StatusInternalServerError,\n\t\t\tMessage: err.Error(),\n\t\t})\n\t}\n\n\t// Return a success response.\n\treturn ctx.JSON(http.StatusOK, &SuccessResponse{\n\t\tCode:    http.StatusOK,\n\t\tMessage: \"success\",\n\t})\n}\n", "CodeBleu_score": 45.21587726202561}, {"code": "func UmountStorage(ctx echo.Context) error\t// Bind JSON data from the request context\n\tvar requestData umountStorageRequest\n\tif err := ctx.Bind(&requestData); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, &errorResponse{\n\t\t\tError: err.Error(),\n\t\t})\n\t}\n\n\t// If the mount point is empty, return a client error response\n\tif requestData.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, &errorResponse{\n\t\t\tError: \"Mount point is required\",\n\t\t})\n\t}\n\n\t// Attempt to unmount the storage at the specified mount point and return a service error response if unmounting fails\n\tif err := umountStorage(requestData.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, &errorResponse{\n\t\t\tError: err.Error(),\n\t\t})\n\t}\n\n\t// Delete the corresponding configuration and return a success response\n\tif err := deleteStorage(requestData.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, &errorResponse{\n\t\t\tError: err.Error(),\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, &successResponse{\n\t\tSuccess: true,\n\t})\n}\n", "CodeBleu_score": 38.78241601502166}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters.\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is provided.\n\tif filePath == \"\" {\n\t\t// Return an error message if the file path is missing.\n\t\treturn ctx.JSON(http.StatusBadRequest, \"The file path is missing.\")\n\t}\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// Return an error message if the file does not exist.\n\t\treturn ctx.JSON(http.StatusNotFound, \"The file does not exist.\")\n\t}\n\n\t// Open the file.\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\t// Return an error message if the file could not be opened.\n\t\treturn ctx.JSON(http.StatusInternalServerError, \"The file could not be opened.\")\n\t}\n\n\t// Close the file.\n\tdefer file.Close()\n\n\t// Get the file size.\n\tfileInfo, _ := file.Stat()\n\tfileSize := fileInfo.Size()\n\n\t// Create a buffer to store the file content.\n\tbuffer := make([]byte, fileSize)\n\n\t// Read the file content into the buffer.\n\tfile.Read(buffer)\n\n\t// Return the file content to the client.\n\treturn ctx.Blob(http.StatusOK, http.DetectContentType(buffer), buffer)\n}\n", "CodeBleu_score": 37.28960039622585}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"filePath\")\n\t// Check if the file path is provided\n\tif filePath == \"\" {\n\t\t// Return a JSON response with an appropriate error message\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The file path is missing\"})\n\t}\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); err != nil {\n\t\t// Return a JSON response with an appropriate error message\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"The file does not exist\"})\n\t}\n\t// Return the file\n\treturn ctx.File(filePath)\n}\n", "CodeBleu_score": 35.067352506587234}, {"code": "func GetLocalFile(ctx echo.Context) error\t// Extract the path from the request.\n\tpath := ctx.QueryParam(\"path\")\n\n\t// If the path is missing, return an error message.\n\tif path == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, ErrorResponse{\n\t\t\tError: \"The 'path' query parameter is missing.\",\n\t\t})\n\t}\n\n\t// Prepend the path with the local directory path.\n\tpath = filepath.Join(\"./static/\", path)\n\n\t// Check if the file exists.\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, ErrorResponse{\n\t\t\tError: \"The file was not found.\",\n\t\t})\n\t}\n\n\t// Open the file.\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, ErrorResponse{\n\t\t\tError: \"Failed to open the file.\",\n\t\t})\n\t}\n\tdefer file.Close()\n\n\t// Get the file size.\n\tfileInfo, err := file.Stat()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, ErrorResponse{\n\t\t\tError: \"Failed to get the file size.\",\n\t\t})\n\t}\n\n\t// Get the file content type.\n\tcontentType := http.DetectContentType([]byte{})\n\tif ext := filepath.Ext(path); ext != \"\" {\n\t\tcontentType = mime.TypeByExtension(ext)\n\t}\n\n\t// Send the file to the client.\n\treturn ctx.Stream(http.StatusOK, contentType, file)\n}\n", "CodeBleu_score": 36.00002213129404}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.QueryParam(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.String(http.StatusBadRequest, \"missing name parameter\")\n\t}\n\tvar msg map[string]string\n\tif err := ctx.Bind(&msg); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\tif err := notify.Send(name, msg); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.String(http.StatusOK, \"notification sent\")\n}\n", "CodeBleu_score": 43.151989717433416}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"missing name parameter\")\n\t}\n\n\tvar msg Message\n\tif err := ctx.Bind(&msg); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\n\tif err := sendNotification(name, msg.Message); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, \"success\")\n}\n", "CodeBleu_score": 45.731581829356905}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tvar message map[string]string\n\n\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"name is required\"})\n\t}\n\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": err.Error()})\n\t}\n\n\tif _, ok := message[\"message\"]; !ok {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"message is required\"})\n\t}\n\n\tif err := sendNotification(name, message[\"message\"]); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": err.Error()})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"success\": true})\n}\n", "CodeBleu_score": 49.94428043225284}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error\t// Get the list of connections from the context\n\tconnections := ctx.Get(\"Connections\").(map[string]*websocket.Conn)\n\t// Get the WebSocket connection from the context\n\tws := ctx.Get(\"WS\").(*websocket.Conn)\n\t// Get the message sending service from the context\n\tmsgSendingService := ctx.Get(\"MessageSendingService\").(*MessageSendingService)\n\t// Add the WebSocket connection to the list of connections\n\tconnections[ws.RemoteAddr().String()] = ws\n\t// Ensure that the message sending service is running\n\tmsgSendingService.Start()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t// Read the next message from the WebSocket connection\n\t\t_, message, err := ws.ReadMessage()\n\t\t// If an error occurs\n\t\tif err != nil {\n\t\t\t// Print the error\n\t\t\tfmt.Println(err)\n\t\t\t// Break out of the loop\n\t\t\tbreak\n\t\t}\n\t\t// Print the message type, message, and any errors\n\t\tfmt.Println(\"Type:\", ws.LastPongMessage, \"Message:\", string(message), \"Error:\", err)\n\t}\n\t// Remove the WebSocket connection from the list of connections\n\tdelete(connections, ws.RemoteAddr().String())\n\t// If there are no more WebSocket connections\n\tif len(connections) == 0 {\n\t\t// Stop the message sending service\n\t\tmsgSendingService.Stop()\n\t}\n\t// Return nil\n\treturn nil\n}\n", "CodeBleu_score": 35.530554738428094}, {"code": "func NotifyWS(ctx echo.Context) error\t// Create a new WebSocket connection\\nand add it to the list of connections.\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\twsConnsMutex.Lock()\n\twsConns = append(wsConns, ws)\n\twsConnsMutex.Unlock()\n\n\t// Start the message sending service if it is not already running.\n\tif !messageSendingServiceRunning {\n\t\tgo sendMessages()\n\t\tmessageSendingServiceRunning = true\n\t}\n\n\t// Continuously read messages from the WebSocket connection and print the message type, message, and any errors.\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"recv: %s\\n\", msg)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 47.18625089720167}, {"code": "func NotifyWS(ctx echo.Context) error\t// Create a new WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\t// Start the message sending service\n\tgo sendMessages()\n\t// Enter a loop to continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\t_, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"Received message: %s\\n\", message)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 48.48351045905016}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tvar systemHardwareInfo struct {\n\t\tDriveModel  string `json:\"drive_model\"`\n\t\tArchitecture string `json:\"architecture\"`\n\t\tCPUInfo     string `json:\"cpu_info\"`\n\t}\n\n\tsystemHardwareInfo.DriveModel = GetDriveModel()\n\tsystemHardwareInfo.Architecture = GetArchitecture()\n\tsystemHardwareInfo.CPUInfo = GetCPUInfo()\n\n\treturn ctx.JSON(http.StatusOK, systemHardwareInfo)\n}\n", "CodeBleu_score": 16.40951496332277}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\t// Get drive model and architecture\n\tdriveModel := GetDriveModel()\n\tarchitecture := GetArchitecture()\n\n\t// Get CPU information\n\tcpuInfo := GetCPUInfo()\n\n\t// If CPU information is available\n\tif cpuInfo != nil {\n\t\t// Return drive model, architecture, and CPU information with a success message\n\t\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"message\": \"Successfully retrieved system hardware information\",\n\t\t\t\"drive_model\": driveModel,\n\t\t\t\"architecture\": architecture,\n\t\t\t\"cpu_info\": cpuInfo,\n\t\t})\n\t}\n\n\t// If CPU information is not available\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"message\": \"Successfully retrieved system hardware information\",\n\t\t\"drive_model\": driveModel,\n\t\t\"architecture\": architecture,\n\t})\n}\n", "CodeBleu_score": 21.02970989267267}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tvar err error\n\tvar info = make(map[string]interface{})\n\tvar hardware = make(map[string]interface{})\n\n\t// Get system hardware information.\n\thardware[\"model\"], err = GetSystemHardwareModel()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"failed to get system hardware model\",\n\t\t})\n\t}\n\n\thardware[\"architecture\"], err = GetSystemHardwareArchitecture()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"failed to get system hardware architecture\",\n\t\t})\n\t}\n\n\t// Get CPU information.\n\tcpuinfo, err := cpu.Info()\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\"error\": \"failed to get CPU information\",\n\t\t})\n\t}\n\n\t// If CPU information is available, return it.\n\tif len(cpuinfo) > 0 {\n\t\thardware[\"cpu\"] = cpuinfo\n\t\tinfo[\"hardware\"] = hardware\n\t\tinfo[\"message\"] = \"success\"\n\t\treturn ctx.JSON(http.StatusOK, info)\n\t}\n\n\t// If CPU information is not available, return \"nil\".\n\tinfo[\"hardware\"] = hardware\n\tinfo[\"message\"] = \"nil\"\n\treturn ctx.JSON(http.StatusOK, info)\n}\n", "CodeBleu_score": 25.284799222428084}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.client.Systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunning = append(running, service.Name)\n\t\t} else {\n\t\t\tnotRunning = append(notRunning, service.Name)\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}\n", "CodeBleu_score": 71.96954352762552}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.systemctl.ListServices(\"casaos*\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif service.ActiveState == \"active\" {\n\t\t\trunningServices = append(runningServices, service.Name)\n\t\t} else {\n\t\t\tnotRunningServices = append(notRunningServices, service.Name)\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}\n", "CodeBleu_score": 63.95709527900721}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\t// #nosec\n\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tif strings.Contains(service, \"running\") {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}\n", "CodeBleu_score": 63.68851477891005}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tif i.logger.IsDebug() {\n\t\ti.logger.Debug(\"Sending notification\", \"name\", name, \"message\", message)\n\t}\n\n\tevent := &notify.Event{\n\t\tName:    name,\n\t\tMessage: message,\n\t}\n\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\ti.logger.Error(\"Failed to marshal message\", \"message\", message, \"error\", err)\n\t\treturn\n\t}\n\n\tresponse, err := i.messageBus.Publish(name, jsonMessage)\n\tif err != nil {\n\t\ti.logger.Error(\"Failed to publish message\", \"name\", name, \"message\", message, \"error\", err)\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\ti.logger.Error(\"Failed to publish message\", \"name\", name, \"message\", message, \"status\", response.StatusCode, \"body\", string(response.Body))\n\t}\n}\n", "CodeBleu_score": 35.956881593831945}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tvar err error\n\tvar response *http.Response\n\tvar body []byte\n\tvar responseStatusCode int\n\tvar responseStatus string\n\tvar responseMessage string\n\tvar responseHeaders http.Header\n\tvar responseContentType string\n\tvar responseContentLength int\n\tvar responseBody string\n\tvar responseBodyJSON map[string]interface{}\n\tvar responseBodyError string\n\tvar responseBodyErrorMessage string\n\tvar responseBodyErrorDetails string\n\tvar responseBodyErrorMessageDetails string\n\tvar responseBodyErrorDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar responseBodyErrorMessageDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetailsDetails string\n\tvar response", "CodeBleu_score": 5.545283833156356}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\t// Serialize the message values to JSON strings\n\tvar messageJSON []byte\n\tvar err error\n\tif messageJSON, err = json.Marshal(message); err != nil {\n\t\ti.logger.Error(\"failed to marshal message\", \"error\", err)\n\t\treturn\n\t}\n\n\t// Publish the event to a message bus\n\tif err = i.bus.Publish(name, messageJSON); err != nil {\n\t\ti.logger.Error(\"failed to publish message\", \"error\", err)\n\t\treturn\n\t}\n\n\t// Log the response details\n\ti.logger.Info(\"sent notification\", \"name\", name, \"message\", string(messageJSON))\n}\n", "CodeBleu_score": 34.01277298667449}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\treturn c.messageBus\n}\n", "CodeBleu_score": 7.99176139360415}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient := message_bus.NewClientWithResponses(c.MessageBusServer)\n\treturn client\n}\n", "CodeBleu_score": 10.119604602662887}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tvar err error\n\tvar addr string\n\tif addr, err = c.getAddress(\"message-bus\"); err != nil {\n\t\taddr = \"error: \" + err.Error()\n\t}\n\treturn message_bus.NewClientWithResponses(addr)\n}\n", "CodeBleu_score": 25.925308775811047}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tip = strings.TrimSpace(ip)\n\tip = strings.Split(ip, \",\")[0]\n\tip = strings.TrimSpace(ip)\n\tip = strings.Split(ip, \":\")[0]\n\tip = strings.TrimSpace(ip)\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 63.3706992741226}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\tip = strings.TrimSpace(ip)\n\tip = strings.Split(ip, \",\")[0]\n\tip = strings.TrimSpace(ip)\n\n\tif ip == \"::1\" {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.TrimPrefix(ip, \"::ffff:\")\n\t}\n\n\treturn ip\n}\n", "CodeBleu_score": 61.46380968185468}, {"code": "func GetIP(request *http.Request) string\t// Check the \"x-forwarded-for\" header.\n\tif forwardedFor := request.Header.Get(\"x-forwarded-for\"); forwardedFor != \"\" {\n\t\t// Extract the first IP from the header.\n\t\tparts := strings.Split(forwardedFor, \",\")\n\t\tip := strings.TrimSpace(parts[0])\n\t\tif ip != \"\" {\n\t\t\treturn ip\n\t\t}\n\t}\n\n\t// If the \"x-forwarded-for\" header is not available, use the request's remote address.\n\tip, _, err := net.SplitHostPort(request.RemoteAddr)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\t// Convert the loopback addresses \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\"\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}\n", "CodeBleu_score": 49.4002339510561}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\tvar err error\n\tvar entryFilePath = c.config.Paths.Modules + \"entry.json\"\n\tvar entryFile *os.File\n\tvar entryFileContent []byte\n\tvar entryFileContentString string\n\tvar entryFileContentJSON []byte\n\tvar entryFileContentJSONString string\n\tvar entryFileContentJSONArray []byte\n\tvar entryFileContentJSONArrayString string\n\tvar entryFileContentJSONArrayJSON []byte\n\tvar entryFileContentJSONArrayJSONString string\n\tvar moduleDirectories []string\n\tvar moduleDirectoriesJSON []byte\n\tvar moduleDirectoriesJSONString string\n\tvar moduleDirectoriesJSONArray []byte\n\tvar moduleDirectoriesJSONArrayString string\n\tvar moduleDirectoriesJSONArrayJSON []byte\n\tvar moduleDirectoriesJSONArrayJSONString string\n\tvar moduleEntryFiles []string\n\tvar moduleEntryFilesJSON []byte\n\tvar moduleEntryFilesJSONString string\n\tvar moduleEntryFilesJSONArray []byte\n\tvar moduleEntryFilesJSONArrayString string\n\tvar moduleEntryFilesJSONArrayJSON []byte\n\tvar moduleEntryFilesJSONArrayJSONString string\n\tvar moduleEntryFilesContent []byte\n\tvar moduleEntryFilesContentString string\n\tvar moduleEntryFilesContentJSON []byte\n\tvar moduleEntryFilesContentJSONString string\n\tvar moduleEntryFilesContentJSONArray []byte\n\tvar moduleEntryFilesContentJSONArrayString string\n\tvar moduleEntryFilesContentJSONArrayJSON []byte\n\tvar moduleEntryFilesContentJSONArrayJSONString string\n\tvar moduleEntryFilesContentJSONArrayJSONArray []byte\n\tvar moduleEntryFilesContentJSONArrayJSONArrayString string\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSON []byte\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONString string\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONArray []byte\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONArrayString string\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONArrayJSON []byte\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONArrayJSONString string\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONArrayJSONArray []byte\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONArrayJSONArrayString string\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONArrayJSONArrayJSON []byte\n\tvar moduleEntryFilesContentJSONArrayJSONArrayJSONArray", "CodeBleu_score": 12.622274148077992}, {"code": "func (c *systemService) GenreateSystemEntry()\t// define paths for the modules directory and the entry file\n\tmodulesDirPath := filepath.Join(c.config.SystemDirPath, \"modules\")\n\tentryFilePath := filepath.Join(c.config.SystemDirPath, \"system.json\")\n\n\t// ensure the entry file exists\n\tif _, err := os.Stat(entryFilePath); os.IsNotExist(err) {\n\t\t// if the entry file does not exist, create it\n\t\t_, err := os.Create(entryFilePath)\n\t\tif err != nil {\n\t\t\t// if an error occurs during file creation, log it\n\t\t\tc.log.Errorf(\"An error occurred while creating the system entry file: %s\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// read each module directory for entry.json files\n\tvar entryJSONs []string\n\terr := filepath.Walk(modulesDirPath, func(path string, info os.FileInfo, err error) error {\n\t\t// if an error occurs during directory reading, log it\n\t\tif err != nil {\n\t\t\tc.log.Errorf(\"An error occurred while reading the modules directory: %s\", err)\n\t\t\treturn err\n\t\t}\n\n\t\t// if the file is not an entry.json file, skip it\n\t\tif info.Name() != \"entry.json\" {\n\t\t\treturn nil\n\t\t}\n\n\t\t// read the entry.json file\n\t\tentryJSON, err := ioutil.ReadFile(path)\n\t\tif err != nil {\n\t\t\t// if an error occurs during file reading, log it\n\t\t\tc.log.Errorf(\"An error occurred while reading an entry.json file: %s\", err)\n\t\t\treturn err\n\t\t}\n\n\t\t// append the entry.json file content to the entryJSONs array\n\t\tentryJSONs = append(entryJSONs, string(entryJSON))\n\t\treturn nil\n\t})\n\n\t// if an error occurs during directory reading, log it\n\tif err != nil {\n\t\tc.log.Errorf(\"An error occurred while reading the modules directory: %s\", err)\n\t\treturn", "CodeBleu_score": 41.14638287209055}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Define the modules directory path\n\tmodulesPath := \"./modules\"\n\n\t// Define the entry file path\n\tentryPath := \"./modules/entry.json\"\n\n\t// Ensure the modules directory exists\n\tif _, err := os.Stat(modulesPath); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"ERROR: The modules directory does not exist: %s\", modulesPath)\n\t}\n\n\t// Ensure the entry file exists\n\tif _, err := os.Stat(entryPath); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"ERROR: The entry file does not exist: %s\", entryPath)\n\t}\n\n\t// Read the entry file\n\tentryFile, err := os.Open(entryPath)\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR: Failed to open the entry file: %s\", entryPath)\n\t}\n\n\t// Read the entry file into a byte array\n\tentryFileBytes, err := ioutil.ReadAll(entryFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR: Failed to read the entry file: %s\", entryPath)\n\t}\n\n\t// Close the entry file\n\terr = entryFile.Close()\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR: Failed to close the entry file: %s\", entryPath)\n\t}\n\n\t// Unmarshal the entry file byte array into a JSON array\n\tvar entryJSONArray []interface{}\n\terr = json.Unmarshal(entryFileBytes, &entryJSONArray)\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR: Failed to unmarshal the entry file: %s\", entryPath)\n\t}\n\n\t// Define the modules directory file\n\tmodulesDirectory, err := os.Open(modulesPath)\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR: Failed to open the modules directory: %s\", modulesPath)\n\t}\n\n\t// Read the modules directory\n\tmodulesDirectoryFiles, err := modulesDirectory.Readdirnames(-1)\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR: Failed to", "CodeBleu_score": 41.42747454339885}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate over all network interfaces\n\tfor _, i := range interfaces {\n\t\t// Iterate over all system network names\n\t\tfor _, n := range c.networkNames {\n\t\t\t// Check if the network interface name matches the system network name\n\t\t\tif i.Name == n {\n\t\t\t\t// Get MAC address\n\t\t\t\taddress := i.HardwareAddr.String()\n\t\t\t\treturn address, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", errors.New(\"no matching interface found\")\n}\n", "CodeBleu_score": 67.10603575521472}, {"code": "func (c *systemService) GetMacAddress() (string, error) \t// Get a list of the system's network interfaces\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Iterate through the list of interfaces\n\tfor _, i := range ifaces {\n\t\t// Read the interface's attributes\n\t\t// If the MAC address doesn't exist, skip this interface\n\t\tif i.HardwareAddr == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the network name of the interface\n\t\tname, err := c.GetNetworkName(i.Name)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\t// If a network name is found, return the MAC address of this interface\n\t\tif name != \"\" {\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\n\t// If we made it this far, no interface with a MAC address was found\n\treturn \"\", errors.New(\"no MAC address found\")\n}\n", "CodeBleu_score": 52.742686749248094}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, i := range interfaces {\n\t\tif i.Flags&net.FlagUp == 0 {\n\t\t\tcontinue // interface down\n\t\t}\n\n\t\tif i.Flags&net.FlagLoopback != 0 {\n\t\t\tcontinue // loopback interface\n\t\t}\n\n\t\taddrs, err := i.Addrs()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tfor _, addr := range addrs {\n\t\t\tvar ip net.IP\n\t\t\tswitch v := addr.(type) {\n\t\t\tcase *net.IPNet:\n\t\t\t\tip = v.IP\n\t\t\tcase *net.IPAddr:\n\t\t\t\tip = v.IP\n\t\t\t}\n\t\t\tif ip == nil || ip.IsLoopback() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn i.HardwareAddr.String(), nil\n\t\t}\n\t}\n\treturn \"\", errors.New(\"are you connected to the network?\")\n}\n", "CodeBleu_score": 59.24762857310137}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)    int32_t ret = 0;\n    char *pDebugStr = NULL;\n    uint32_t debugStrSize = 0;\n    uint32_t debugStrOffset = 0;\n    uint32_t debugStrMaxSize = 0;\n    uint32_t debugStrSizeLeft = 0;\n\n    /*\n     * Check if the request is already registered.\n     */\n    if (pRequest->requestId != 0) {\n        ret = 1;\n        goto end;\n    }\n\n    /*\n     * Add a reference to the request object.\n     */\n    pRequest->requestId = ++g_requestIdCounter;\n\n    /*\n     * Increment the request count for the associated TSC object.\n     */\n    pTscObj->requestCount++;\n\n    /*\n     * If the TSC object has application information, update the application's request summary, including total and current request counts.\n     */\n    if (pTscObj->pApplication != NULL) {\n        pTscObj->pApplication->requestCount++;\n        pTscObj->pApplication->currentRequestCount++;\n    }\n\n    /*\n     * Log debug information about the new request.\n     */\n    debugStrSize = 200;\n    debugStrMaxSize = debugStrSize;\n    debugStrSizeLeft = debugStrSize;\n    pDebugStr = (char *)malloc(debugStrSize);\n    if (pDebugStr == NULL) {\n        ret = 2;\n        goto end;\n    }\n    memset(pDebugStr, 0, debugStrSize);\n    debugStrOffset +=\n        snprintf(pDebugStr + debugStrOffset, debugStrSizeLeft, \"Registering request: \");\n    debugStrSizeLeft -= debugStrOffset;\n    debugStrOffset +=\n        snprintf(pDebugStr + debugStrOffset, debugStrSizeLeft, \"Request ID: %\" PRIu32 \", \",\n                 pRequest->requestId);\n    debugStrSizeLeft -= debugStrOffset;\n    debugStrOffset +=\n        snprintf(pDebugStr + debugStrOffset, debugStrSizeLeft, \"TSC ID: %\" PRIu3", "CodeBleu_score": 38.70661381433058}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)\tint32_t rc = 0;\n\n\tif (pRequest != NULL) {\n\t\tif (pTscObj != NULL) {\n\t\t\tpTscObj->requestCount++;\n\t\t\tpTscObj->requestList.push_back(pRequest);\n\t\t\tif (pTscObj->pAppObj != NULL) {\n\t\t\t\tpTscObj->pAppObj->requestCount++;\n\t\t\t\tpTscObj->pAppObj->requestList.push_back(pRequest);\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = -1;\n\t}\n\treturn rc;\n}\n", "CodeBleu_score": 24.086923766022895}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)    int32_t status = 0;\n\n    if (pRequest != NULL) {\n        pRequest->pTscObj = pTscObj;\n        pRequest->pNext = pTscObj->pRequestList;\n        pTscObj->pRequestList = pRequest;\n        pTscObj->requestCount++;\n        if (pTscObj->pAppObj != NULL) {\n            pTscObj->pAppObj->requestCount++;\n            pTscObj->pAppObj->currentRequestCount++;\n        }\n        pRequest->requestId = pTscObj->requestCount;\n        pRequest->requestType = pTscObj->requestType;\n        pRequest->requestStatus = REQUEST_STATUS_NEW;\n        pRequest->requestStartTime = (uint32_t) time(NULL);\n        pRequest->requestEndTime = 0;\n        pRequest->requestError = 0;\n        pRequest->requestErrorStr[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0] = '\\0';\n        pRequest->requestErrorDetail[0]", "CodeBleu_score": 30.467965128727016}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    if (pRequest->m_dbName.compare(exceptDb) != 0) {\n        for (int i = 0; i < pRequest->m_dbNames.size(); i++) {\n            if (pRequest->m_dbNames[i].compare(exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n", "CodeBleu_score": 42.482480681241675}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    if (pRequest->m_pPrimaryDb != NULL && strcmp(pRequest->m_pPrimaryDb, exceptDb) != 0) {\n        return true;\n    }\n\n    for (int i = 0; i < pRequest->m_dbs.size(); i++) {\n        if (strcmp(pRequest->m_dbs[i].c_str(), exceptDb) != 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n", "CodeBleu_score": 47.945436304439845}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    if (!pRequest) {\n        return false;\n    }\n\n    if (pRequest->primaryDb && strcmp(pRequest->primaryDb, exceptDb) == 0) {\n        return false;\n    }\n\n    if (pRequest->dbList) {\n        for (int i = 0; i < pRequest->dbList->num; i++) {\n            if (strcmp(pRequest->dbList->list[i], exceptDb) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 51.82330670609675}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    bool rfp = false;\n\n    if (code == RPC_ERR_REDIRECT) {\n        switch (msgType) {\n        case tmsg_request:\n        case tmsg_response:\n        case tmsg_error:\n        case tmsg_event:\n        case tmsg_event_response:\n        case tmsg_event_error:\n            rfp = true;\n            break;\n        default:\n            rfp = false;\n            break;\n        }\n    }\n\n    return rfp;\n}\n", "CodeBleu_score": 33.400510809007635}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    bool rv = false;\n\n    if (code == SASL_NOMEM || code == SASL_BUFOVER) {\n        rv = true;\n    } else if (code == SASL_NOMECH) {\n        if (msgType != MSG_RESPONSE_CHALLENGE) {\n            rv = true;\n        }\n    } else if (code == SASL_BADMAC) {\n        if (msgType != MSG_RESPONSE_CHALLENGE) {\n            rv = true;\n        }\n    } else if (code == SASL_BADPROT) {\n        if (msgType != MSG_RESPONSE_CHALLENGE) {\n            rv = true;\n        }\n    } else if (code == SASL_FAIL) {\n        if (msgType != MSG_RESPONSE_CHALLENGE) {\n            rv = true;\n        }\n    }\n\n    return rv;\n}\n", "CodeBleu_score": 40.25877033455101}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    if (code == 0) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_LIST) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_LIST_BY_KEY) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_LIST_BY_KEY_PATTERN) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_LIST_BY_KEY_PATTERN_PAGE) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_LIST_PAGE) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_PAGE) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_PAGE_BY_KEY) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_PAGE_BY_KEY_PATTERN) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_PAGE_BY_KEY_PATTERN_PAGE) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_PAGE_BY_KEY_PATTERN_PAGE_ORDER) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_PAGE_BY_KEY_PATTERN_PAGE_ORDER_PAGE) {\n        return false;\n    }\n\n    if (msgType == TMSG_REQ_GET_HOST_INFO_PAGE", "CodeBleu_score": 44.526986061197114}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests)\tint i;\n\tint nRequests = pRequests->nObjects;\n\tint *pRequestIDs = pRequests->pRequestIDs;\n\tint *pRequestTypes = pRequests->pRequestTypes;\n\tchar **pRequestNames = pRequests->pRequestNames;\n\tint *pRequestSizes = pRequests->pRequestSizes;\n\tint *pRequestIDs2 = pRequests->pRequestIDs2;\n\tint *pRequestTypes2 = pRequests->pRequestTypes2;\n\tchar **pRequestNames2 = pRequests->pRequestNames2;\n\tint *pRequestSizes2 = pRequests->pRequestSizes2;\n\n\tfor (i = 0; i < nRequests; i++) {\n\t\tif (pRequestTypes[i] == 1) {\n\t\t\tif (pRequestIDs[i] != -1) {\n\t\t\t\tstopQuery(pRequestIDs[i], pRequestNames[i], pRequestSizes[i]);\n\t\t\t}\n\t\t}\n\t\telse if (pRequestTypes[i] == 2) {\n\t\t\tif (pRequestIDs2[i] != -1) {\n\t\t\t\tstopQuery(pRequestIDs2[i], pRequestNames2[i], pRequestSizes2[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 28.35105901833027}, {"code": "void stopAllRequests(SHashObj *pRequests)\tint i;\n\tint nRequests = pRequests->nObjects;\n\tfor (i = 0; i < nRequests; i++) {\n\t\tRequest *pRequest = (Request *)pRequests->pObjects[i];\n\t\tif (pRequest->nRequestID != 0) {\n\t\t\tif (pRequest->pQuery != NULL) {\n\t\t\t\tpRequest->pQuery->stop();\n\t\t\t\tpRequest->pQuery = NULL;\n\t\t\t}\n\t\t\tpRequest->nRequestID = 0;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 28.662378870766304}, {"code": "void stopAllRequests(SHashObj *pRequests)\tint i;\n\tint nRequests;\n\tint nRequestsToStop;\n\tint nRequestsToStopThisTime;\n\tint nRequestsToStopNextTime;\n\tint nRequestsStopped;\n\tint nRequestsStoppedThisTime;\n\tint nRequestsStoppedNextTime;\n\tint nRequestsToRelease;\n\tint nRequestsToReleaseThisTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsReleased;\n\tint nRequestsReleasedThisTime;\n\tint nRequestsReleasedNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint nRequestsToReleaseNextTime;\n\tint", "CodeBleu_score": 7.155211651403194}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport()    if (!crashReportingEnabled) {\n        return;\n    }\n    if (atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n        while (clientStop);\n    } else {\n        fprintf(stderr, \"tscStopCrashReport: Crash report thread already stopped.\\n\");\n    }\n}\n", "CodeBleu_score": 43.24595705577009}, {"code": "void tscStopCrashReport()    if (!crashReportingEnabled) {\n        return;\n    }\n\n    if (__sync_bool_compare_and_swap(&clientStop, 0, 1)) {\n        while (__sync_bool_compare_and_swap(&clientStop, 1, 0)) {\n            usleep(100000);\n        }\n    } else {\n        printf(\"tscStopCrashReport: Crash report thread already stopped.\\n\");\n    }\n}\n", "CodeBleu_score": 55.61276715545495}, {"code": "void tscStopCrashReport()    if (!tscCrashReportingEnabled()) {\n        return;\n    }\n    if (__sync_bool_compare_and_swap(&clientStop, 0, 1)) {\n        while (__sync_bool_compare_and_swap(&clientStop, 1, 0));\n    } else {\n        tscLog(\"Crash report thread already stopped\");\n    }\n}\n", "CodeBleu_score": 50.12564558726115}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)    int32_t rc = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t numViews = 0;\n    int32_t numCols = 0;\n    int32_t numColsToRemove = 0;\n    int32_t numColsToUpdate = 0;\n    int32_t numColsToAdd = 0;\n    int32_t numColsToAddThisView = 0;\n    int32_t numColsToRemoveThisView = 0;\n    int32_t numColsToUpdateThisView = 0;\n    int32_t numColsToAddThisViewThisIteration = 0;\n    int32_t numColsToUpdateThisViewThisIteration = 0;\n    int32_t numColsToRemoveThisViewThisIteration = 0;\n    int32_t numColsToRemoveThisViewThisIterationThisIteration = 0;\n    int32_t numColsToAddThisViewThisIterationThisIteration = 0;\n    int32_t numColsToUpdateThisViewThisIterationThisIteration = 0;\n    int32_t numColsToRemoveThisViewThisIterationThisIterationThisIteration = 0;\n    int32_t numColsToAddThisViewThisIterationThisIterationThisIteration = 0;\n    int32_t numColsToUpdateThisViewThisIterationThisIterationThisIteration = 0;\n    int32_t numColsToRemoveThisViewThisIterationThisIterationThisIterationThisIteration = 0;\n    int32_t numColsToAddThisViewThisIterationThisIterationThisIterationThisIteration = 0;\n    int32_t numColsToUpdateThisViewThisIterationThisIterationThisIterationThisIteration = 0;\n    int32_t numColsToRemoveThisViewThisIterationThisIterationThisIterationThisIterationThisIteration", "CodeBleu_score": 8.520349095524304}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)    int32_t rc = 0;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t k = 0;\n    int32_t l = 0;\n    int32_t numViews = 0;\n    int32_t numCols = 0;\n    int32_t numColsInCatalog = 0;\n    int32_t numColsToRemove = 0;\n    int32_t numColsToUpdate = 0;\n    int32_t numColsToAdd = 0;\n    int32_t numColsToAddInCatalog = 0;\n    int32_t numColsToRemoveInCatalog = 0;\n    int32_t numColsToUpdateInCatalog = 0;\n    int32_t numColsToAddInResponse = 0;\n    int32_t numColsToRemoveInResponse = 0;\n    int32_t numColsToUpdateInResponse = 0;\n    int32_t numColsToAddInCatalogAndResponse = 0;\n    int32_t numColsToRemoveInCatalogAndResponse = 0;\n    int32_t numColsToUpdateInCatalogAndResponse = 0;\n    int32_t numColsToAddInCatalogAndResponseAndResponse = 0;\n    int32_t numColsToRemoveInCatalogAndResponseAndResponse = 0;\n    int32_t numColsToUpdateInCatalogAndResponseAndResponse = 0;\n    int32_t numColsToAddInCatalogAndResponseAndCatalog = 0;\n    int32_t numColsToRemoveInCatalogAndResponseAndCatalog = 0;\n    int32_t numColsToUpdateInCatalogAndResponseAndCatalog = 0;\n    int32_t numColsToAddInCatalogAndResponseAndCatalogAndResponse = 0;\n    int32_t numColsToRemoveInCatalogAndResponseAndC", "CodeBleu_score": 9.009125449755942}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)  int32_t rc = 0;\n  int32_t i = 0;\n  int32_t j = 0;\n  int32_t numViews = 0;\n  int32_t numCols = 0;\n  int32_t numColsToRemove = 0;\n  int32_t numColsToAdd = 0;\n  int32_t numColsToUpdate = 0;\n  int32_t numColsRemoved = 0;\n  int32_t numColsAdded = 0;\n  int32_t numColsUpdated = 0;\n  int32_t numColsToUpdate2 = 0;\n  int32_t numColsUpdated2 = 0;\n  int32_t numColsRemoved2 = 0;\n  int32_t numColsAdded2 = 0;\n  int32_t numColsToAdd2 = 0;\n  int32_t numColsToRemove2 = 0;\n  int32_t numColsRemoved3 = 0;\n  int32_t numColsAdded3 = 0;\n  int32_t numColsToAdd3 = 0;\n  int32_t numColsToRemove3 = 0;\n  int32_t numColsUpdated3 = 0;\n  int32_t numColsToUpdate3 = 0;\n  int32_t numColsRemoved4 = 0;\n  int32_t numColsAdded4 = 0;\n  int32_t numColsToAdd4 = 0;\n  int32_t numColsToRemove4 = 0;\n  int32_t numColsUpdated4 = 0;\n  int32_t numColsToUpdate4 = 0;\n  int32_t numColsRemoved5 = 0;\n  int32_t numColsAdded5 = 0;\n  int32_t numColsToAdd5 = 0;", "CodeBleu_score": 8.221853491822484}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3Status status;\n    S3ResponsePropertiesCurl *propertiesCurl = (S3ResponsePropertiesCurl *)properties;\n    S3GetObjectContext *context = (S3GetObjectContext *)callbackData;\n\n    /* Extract the content length from the response properties. */\n    context->contentLength = propertiesCurl->contentLength;\n\n    /* If the content length is greater than zero, set the content length in the callback data structure. */\n    if (context->contentLength > 0) {\n        /* Set the content length in the callback data structure. */\n        context->contentLength = propertiesCurl->contentLength;\n    }\n\n    /* Set the content length to zero if the content length is less than or equal to zero. */\n    else {\n        context->contentLength = 0;\n    }\n\n    /* Set the status to indicate successful processing. */\n    status = S3StatusOK;\n\n    /* Return the status. */\n    return status;\n}\n", "CodeBleu_score": 56.454035557698326}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3Status status;\n    CallbackData *data = (CallbackData *) callbackData;\n\n    status = S3StatusOK;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    return status;\n}\n", "CodeBleu_score": 71.03712493151276}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3Status status = S3StatusOK;\n    S3_get_object_callback_data *callback_data = (S3_get_object_callback_data *) callbackData;\n    callback_data->content_length = properties->contentLength;\n    return status;\n}\n", "CodeBleu_score": 50.93883068106844}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync()    // Create checkpoint backup directory if it does not exist.\n    if (mkdir(CHECKPOINT_BACKUP_DIR, 0700) != 0) {\n        logError(\"Failed to create checkpoint backup directory.\");\n    }\n\n    // Remove empty directories from checkpoint backup directory.\n    removeEmptyDirs(CHECKPOINT_BACKUP_DIR);\n\n    // Generate Rsync configuration file.\n    if (generateRsyncConfig() != 0) {\n        logError(\"Failed to generate Rsync configuration file.\");\n    }\n\n    // Construct and execute command to start Rsync daemon.\n    char *cmd = malloc(sizeof(char) * (strlen(RSYNC_CMD) + strlen(RSYNC_PORT) + strlen(RSYNC_CONFIG_FILE) + 1));\n    strcpy(cmd, RSYNC_CMD);\n    strcat(cmd, RSYNC_PORT);\n    strcat(cmd, RSYNC_CONFIG_FILE);\n    if (system(cmd) != 0) {\n        logError(\"Failed to start Rsync daemon.\");\n    }\n    free(cmd);\n}\n", "CodeBleu_score": 27.924112686444335}, {"code": "void startRsync()    // Create the checkpoint backup directory\n    if (mkdir(CHECKPOINT_DIR, 0777) == -1) {\n        logError(\"Failed to create checkpoint backup directory\");\n        exit(1);\n    }\n\n    // Remove empty directories\n    removeEmptyDirectories();\n\n    // Generate the Rsync configuration file\n    if (generateRsyncConfig() == -1) {\n        logError(\"Failed to generate Rsync configuration file\");\n        exit(1);\n    }\n\n    // Construct and execute the command to start the Rsync daemon\n    char cmd[MAX_CMD_LEN];\n    sprintf(cmd, \"rsync --daemon --port=%d --config=%s\", RSYNC_PORT, RSYNC_CONFIG_FILE);\n    if (system(cmd) == -1) {\n        logError(\"Failed to start Rsync daemon\");\n        exit(1);\n    }\n\n    logInfo(\"Rsync daemon started successfully\");\n}\n", "CodeBleu_score": 27.955870660278638}, {"code": "void startRsync()  // Create the checkpoint directory\n  if (!createDirectory(CHECKPOINT_DIR)) {\n    log_error(LOG_TAG, \"Could not create checkpoint directory.\");\n  }\n\n  // Remove empty directories\n  removeEmptyDirectories();\n\n  // Generate Rsync configuration file\n  if (!generateRsyncConfig()) {\n    log_error(LOG_TAG, \"Could not generate Rsync configuration file.\");\n  }\n\n  // Construct and execute Rsync command\n  char rsync_cmd[100];\n  sprintf(rsync_cmd, \"rsync --daemon --no-detach --config %s\", RSYNC_CONFIG_FILE);\n  if (!executeCommand(rsync_cmd)) {\n    log_error(LOG_TAG, \"Could not start Rsync daemon.\");\n  }\n\n  log_info(LOG_TAG, \"Rsync daemon started successfully.\");\n}\n", "CodeBleu_score": 21.51658005485459}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId)  //#A\n  Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n  if (dispatcher == null)\n    throw new RuntimeException(\"Dispatcher \" + dispatcherId + \" not found\");\n  dispatcher.shutdownNow();\n  //#A\n}", "CodeBleu_score": 57.491151388295826}, {"code": "public void destroyDispatcher(String dispatcherId)\tsynchronized (this) {\n\t\tif (dispatcherId == null) {\n\t\t\tthrow new IllegalArgumentException(\"dispatcherId is null\");\n\t\t}\n\t\tDispatcher dispatcher = dispatchers.get(dispatcherId);\n\t\tif (dispatcher == null) {\n\t\t\tthrow new IllegalArgumentException(\"Dispatcher with ID '\" + dispatcherId + \"' not found\");\n\t\t}\n\t\tdispatcher.shutdown();\n\t\tdispatchers.remove(dispatcherId);\n\t}\n}\n", "CodeBleu_score": 52.54603705981692}, {"code": "public void destroyDispatcher(String dispatcherId)    if (dispatcherId == null) {\n        throw new IllegalArgumentException(\"The dispatcherId parameter is null\");\n    }\n    if (dispatcherId.length() == 0) {\n        throw new IllegalArgumentException(\"The dispatcherId parameter is empty\");\n    }\n    if (dispatcherId.equals(this.dispatcherId)) {\n        throw new IllegalArgumentException(\"The dispatcherId parameter is the same as the ID of the current dispatcher\");\n    }\n    Dispatcher d = (Dispatcher) this.dispatchers.remove(dispatcherId);\n    if (d == null) {\n        throw new RuntimeException(\"The dispatcher with ID '\" + dispatcherId + \"' is not registered\");\n    }\n    d.shutdown();\n}", "CodeBleu_score": 48.731996957048715}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    Set<TbActorId> children = actorChildren.get(parent);\n    if (children != null) {\n      for (TbActorId childId : children) {\n        if (childFilter.test(childId)) {\n          TbActorRef childRef = actorRefById.get(childId);\n          if (childRef != null) {\n            if (highPriority) {\n              childRef.tell(msg, ActorRef.noSender());\n            } else {\n              childRef.tellWithHighPriority(msg);\n            }\n          } else {\n            log.warn(\"[{}] Failed to broadcast message to child actor [{}]. Actor not registered.\", parent, childId);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n   */\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg) {\n    broadcastToChildren(parent, childFilter, msg, false);\n  }\n\n  private void broadcastToChildren(TbActorId parent, TbActorMsg msg) {\n    broadcastToChildren(parent, child -> true, msg);\n  }\n\n  private void broadcastToChildren(TbActorId parent, TbActorMsg msg, boolean highPriority) {\n    broadcastToChildren(parent, child -> true, msg, highPriority);\n  }\n\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority,\n                                   TbActorId exclude) {\n    Set<TbActorId> children = actorChildren.get(parent);\n    if (children != null) {\n      for (TbActorId childId : children) {\n        if", "CodeBleu_score": 44.18315576305052}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    TbActorRef parentRef = getOrCreateChildActor(parent);\n    if (parentRef != null) {\n      for (TbActorRef childRef : parentRef.getChildren()) {\n        if (childFilter.test(childRef.getId())) {\n          try {\n            if (highPriority) {\n              childRef.tellWithHighPriority(msg);\n            } else {\n              childRef.tell(msg);\n            }\n          } catch (Exception e) {\n            log.warn(\"[{}] Failed to send message to child actor: {}\", parent, childRef.getId(), e);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n   */\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg) {\n    broadcastToChildren(parent, childFilter, msg, false);\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n   */\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority, long timeout) {\n    TbActorRef parentRef = getOrCreateChildActor(parent);\n    if (parentRef != null) {\n      for (TbActorRef childRef : parentRef.getChildren()) {\n        if (childFilter.test(childRef.getId())) {\n          try {\n            if (highPriority)", "CodeBleu_score": 41.483157088597764}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    TbActorRef parentRef = getOrCreateChild(parent);\n    if (parentRef == null) {\n      log.warn(\"[{}][{}] Failed to send message to children because parent actor is not registered.\", tenantId, parent);\n      return;\n    }\n    for (TbActorRef childRef : parentRef.getChildren().values()) {\n      if (childFilter.test(childRef.getId())) {\n        try {\n          if (highPriority) {\n            childRef.tell(msg, ActorRef.noSender());\n          } else {\n            childRef.tell(msg);\n          }\n        } catch (ActorNotFoundException e) {\n          log.warn(\"[{}][{}] Failed to send message to child actor: {}\", tenantId, parent, childRef.getId());\n        }\n      }\n    }\n  }\n\n  /**\n   * The function \"broadcastToChildren\" sends a message to a filtered set of child actors of a specified parent actor.\\nIt retrieves the children of the parent actor from a map and filters them based on the provided predicate.\\nFor each filtered child actor, it attempts to send the message with an optional high priority.\\nIf a child actor is not registered, it logs a warning.\n   */\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg) {\n    broadcastToChildren(parent, childFilter, msg, false);\n  }\n\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, long timeout) {\n    broadcastToChildren(parent, childFilter, msg, false, timeout);\n  }\n\n  private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority, long timeout) {\n    TbActorRef parentRef = getOrCreateChild(parent);\n    if (parentRef == null) {\n      log.warn(\"[{}][{}] Failed to send message to children because parent actor is not registered.\", tenantId, parent);\n      return;", "CodeBleu_score": 41.09606822656511}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (msg.getRuleChainId() == null) {\n        log.debug(\"[{}] Received message [{}] without rule chain id. Ignoring.\", actorId, msg.getMsgType());\n        return;\n    }\n    if (stopping) {\n        if (highPriority && msg instanceof RuleNodeUpdateMsg) {\n            RuleNodeUpdateMsg ruleNodeUpdateMsg = (RuleNodeUpdateMsg) msg;\n            if (ruleNodeUpdateMsg.getMsgType() == MsgType.RULE_NODE_UPDATED_MSG && ruleNodeUpdateMsg.getError() != null) {\n                log.debug(\"[{}] Received RULE_NODE_UPDATED_MSG with error during destruction. Will attempt to reinitialize actor.\", actorId);\n                reinitActor(ruleNodeUpdateMsg.getError());\n            } else {\n                log.debug(\"[{}] Received message [{}] during destruction. Will notify message that actor has stopped.\", actorId, msg.getMsgType());\n                msg.getCallback().onFailure(new RuleEngineException(\"Actor is stopping!\"));\n            }\n        } else {\n            log.debug(\"[{}] Received message [{}] during destruction. Will notify message that actor has stopped.\", actorId, msg.getMsgType());\n            msg.getCallback().onFailure(new RuleEngineException(\"Actor is stopping!\"));\n        }\n        return;\n    }\n    if (highPriority) {\n        highPriorityMsgs.add(msg);\n    } else {\n        normalPriorityMsgs.add(msg);\n    }\n    processQueue();\n}\n", "CodeBleu_score": 50.77691181814543}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (destroying) {\n        if (highPriority && msg instanceof RuleNodeUpdatedMsg) {\n            if (((RuleNodeUpdatedMsg) msg).getMsgType() == MsgType.RULE_CHAIN_UPDATED_MSG) {\n                if (state == ActorState.FAILED) {\n                    log.info(\"[{}] Actor is being reinitialized\", getActorId());\n                    init(getActorCtx());\n                }\n            } else {\n                msg.getCallback().onFailure(new TbActorDestroyedException(getActorId()));\n            }\n        } else {\n            msg.getCallback().onFailure(new TbActorDestroyedException(getActorId()));\n        }\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 52.381833312959834}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (msg.getMsgType() == TbActorMsgType.RULE_NODE_UPDATED_MSG && msg.getRuleNodeId() != null) {\n        if (state == ActorState.STOPPED) {\n            if (msg.getMsgType() == TbActorMsgType.RULE_NODE_UPDATED_MSG) {\n                if (highPriority) {\n                    highPriorityMsgs.add(msg);\n                } else {\n                    normalPriorityMsgs.add(msg);\n                }\n                if (state == ActorState.STOPPED) {\n                    if (highPriorityMsgs.size() > 0) {\n                        processQueue(highPriorityMsgs);\n                    } else if (normalPriorityMsgs.size() > 0) {\n                        processQueue(normalPriorityMsgs);\n                    }\n                }\n            } else {\n                if (msg.getMsgType() == TbActorMsgType.RULE_CHAIN_TO_RULE_NODE_MSG) {\n                    if (highPriority) {\n                        highPriorityMsgs.add(msg);\n                    } else {\n                        normalPriorityMsgs.add(msg);\n                    }\n                    if (state == ActorState.STOPPED) {\n                        if (highPriorityMsgs.size() > 0) {\n                            processQueue(highPriorityMsgs);\n                        } else if (normalPriorityMsgs.size() > 0) {\n                            processQueue(normalPriorityMsgs);\n                        }\n                    }\n                } else {\n                    if (msg.getMsgType() == TbActorMsgType.RULE_CHAIN_TO_ROOT_RULE_MSG) {\n                        if (highPriority) {\n                            highPriorityMsgs.add(msg);\n                        } else {\n                            normalPriorityMsgs.add(msg);\n                        }\n                        if (state == ActorState.STOPPED) {\n                           ", "CodeBleu_score": 53.33272419041785}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox()\tif (mailbox.isEmpty()) {\n\t\tstatus = ActorStatus.FREE;\n\t\tscheduleQueueProcessing();\n\t\treturn;\n\t}\n\n\t// Process high priority messages\n\tif (!mailbox.highPriorityQueue.isEmpty()) {\n\t\tprocessMessages(mailbox.highPriorityQueue);\n\t\treturn;\n\t}\n\n\t// Process normal priority messages\n\tif (!mailbox.normalPriorityQueue.isEmpty()) {\n\t\tprocessMessages(mailbox.normalPriorityQueue);\n\t\treturn;\n\t}\n\n\t// Process low priority messages\n\tif (!mailbox.lowPriorityQueue.isEmpty()) {\n\t\tprocessMessages(mailbox.lowPriorityQueue);\n\t\treturn;\n\t}\n\n\t// Process any other messages\n\tif (!mailbox.otherPriorityQueue.isEmpty()) {\n\t\tprocessMessages(mailbox.otherPriorityQueue);\n\t\treturn;\n\t}\n}\n", "CodeBleu_score": 8.569026419317028}, {"code": "private void processMailbox()    // Iterate through the queues, attempting to process each message\n    while (true) {\n        if (highPriorityQueue.isEmpty()) {\n            if (normalPriorityQueue.isEmpty()) {\n                // No more messages, set the actor's status to free and schedule a queue processing attempt\n                setStatus(ActorStatus.FREE);\n                scheduleQueueProcessing();\n                return;\n            }\n            else {\n                // Process the next message in the normal priority queue\n                processMessage(normalPriorityQueue.poll());\n            }\n        }\n        else {\n            // Process the next message in the high priority queue\n            processMessage(highPriorityQueue.poll());\n        }\n    }\n}\n", "CodeBleu_score": 13.392499609844386}, {"code": "private void processMailbox()    while (true) {\n        try {\n            // process high priority messages first\n            if (highPriorityQueue.size() > 0) {\n                while (highPriorityQueue.size() > 0) {\n                    processMessage(highPriorityQueue.remove());\n                }\n            }\n\n            // process normal priority messages\n            while (normalPriorityQueue.size() > 0) {\n                processMessage(normalPriorityQueue.remove());\n            }\n\n            // no messages left to process, so set the actor as free\n            status = ActorStatus.FREE;\n\n            // schedule a queue processing attempt\n            scheduleQueueProcessing();\n\n            break;\n        } catch (InitializationFailureException e) {\n            // initialization failure, so destroy the actor\n            stopReason = e.getReason();\n            destroy();\n        } catch (Exception e) {\n            // process failure, so log the failure and apply the actor's process failure strategy\n            logger.error(\"Actor \" + name + \" failed to process a message.\", e);\n\n            // check if the actor's process failure strategy is to stop the actor\n            if (processFailureStrategy == ProcessFailureStrategy.STOP_ACTOR) {\n                // stop the actor\n                stopReason = StopReason.PROCESS_FAILURE;\n                destroy();\n            }\n        }\n    }\n}\n", "CodeBleu_score": 28.177952944636292}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause)\tif (stopReason == null) {\n\t\tstopReason = new StopReason(cause);\n\t}\n\tif (destroyInProgress.compareAndSet(false, true)) {\n\t\ttry {\n\t\t\texecutor.execute(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsetReadiness(false);\n\t\t\t\t\t\tactor.destroy(stopReason);\n\t\t\t\t\t\tnotifyQueuedMessages();\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlogger.warn(\"Exception during actor destruction.\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (Throwable e) {\n\t\t\tlogger.warn(\"Exception during actor destruction.\", e);\n\t\t}\n\t}\n}", "CodeBleu_score": 34.38093203708352}, {"code": "public void destroy(Throwable cause)    if (stopReason == null) {\n        stopReason = new StopReason(cause);\n    }\n    if (destroyInProgress) {\n        return;\n    }\n    destroyInProgress = true;\n    if (dispatcher != null) {\n        dispatcher.executor().execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    dispatcher.setActorReadiness(Actor.this, false);\n                    destroy(stopReason, cause);\n                } catch (Throwable t) {\n                    log.warn(\"Exception while destroying actor\", t);\n                }\n            }\n        });\n    }\n}\n", "CodeBleu_score": 42.15333821046523}, {"code": "public void destroy(Throwable cause)\tif (stopReason == null) {\n\t\tstopReason = new StopReason(cause);\n\t}\n\tif (!destroyInProgress) {\n\t\tdestroyInProgress = true;\n\t\texecutor.execute(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tsetReady(false);\n\t\t\t\t\tdestroy(stopReason);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlogger.warn(\"Exception during actor destruction\", t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n", "CodeBleu_score": 30.140424044260712}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.equals(SYSTEM_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.find(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitType rateLimitType = tenantProfile.getRateLimitType();\n    if (rateLimitType == RateLimitType.FREE) {\n        return true;\n    } else if (rateLimitType == RateLimitType.MONTHLY_FIXED) {\n        return checkMonthlyFixedRateLimit(tenantId, level, tenantProfile);\n    } else {\n        throw new IllegalStateException(\"Unsupported rate limit type: \" + rateLimitType);\n    }\n}\n", "CodeBleu_score": 47.629183201592895}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.equals(TenantId.SYS_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.get(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    TenantRateLimit tenantRateLimit = tenantProfile.getTenantRateLimit();\n    if (tenantRateLimit == null) {\n        return true;\n    }\n    long currentTime = System.currentTimeMillis();\n    long startTime = currentTime - tenantRateLimit.getTimeWindowSize();\n    long endTime = currentTime + tenantRateLimit.getTimeWindowSize();\n    int count = 0;\n    for (TenantRateLimit.TenantRateLimitItem rateLimitItem : tenantRateLimit.getRateLimitItems()) {\n        if (rateLimitItem.getApi().equals(api.name())) {\n            if (rateLimitItem.getLevel().equals(level.toString())) {\n                count = rateLimitItem.getCount();\n                break;\n            }\n        }\n    }\n    if (count == 0) {\n        return true;\n    }\n    int currentCount = 0;\n    for (TenantRateLimit.TenantRateLimitItem rateLimitItem : tenantRateLimit.getRateLimitItems()) {\n        if (rateLimitItem.getApi().equals(api.name())) {\n            if (rateLimitItem.getLevel().equals(level.toString())) {\n                currentCount += rateLimitItem.getCount();\n            }\n        }\n    }\n    if (currentCount > count) {\n        if (tenantRateLimit.isNotifyOnLimitExceeded()) {\n            sendRateLimitNotification(tenantId, api, level, currentCount, count, startTime, endTime);\n        }\n        return false;\n    }\n    return true;\n}\n", "CodeBleu_score": 51.3708475158098}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.equals(SYSTEM_TENANT_ID)) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileCache.findTenantProfileInfoById(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitType rateLimitType = tenantProfile.getRateLimitType();\n    if (rateLimitType == null) {\n        return true;\n    }\n    RateLimitConfig rateLimitConfig = rateLimitConfigCache.get(rateLimitType);\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    if (rateLimitConfig.getLimit() == 0) {\n        return true;\n    }\n    long currentTime = System.currentTimeMillis();\n    long timeWindowStart = currentTime - rateLimitConfig.getTimeWindow();\n    long timeWindowEnd = currentTime;\n    RateLimitQueue rateLimitQueue = rateLimitQueueMap.computeIfAbsent(tenantId, id -> new RateLimitQueue(rateLimitConfig.getLimit()));\n    boolean rateLimitExceeded = rateLimitQueue.add(api, level, timeWindowStart, timeWindowEnd);\n    if (rateLimitExceeded) {\n        rateLimitNotificationService.processRateLimitNotification(tenantId, api, level, timeWindowStart, timeWindowEnd);\n    }\n    return !rateLimitExceeded;\n}\n", "CodeBleu_score": 53.124983096824884}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions()    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\n    for (Map.Entry<String, DtlsSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.info(\"Evicted DTLS session with key \" + entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 52.81685316268903}, {"code": "public void evictTimeoutSessions()    long currentTime = System.currentTimeMillis();\n    long expirationTime = currentTime - sessionInactivityTimeout;\n    Iterator<Map.Entry<InetSocketAddress, DTLSClient>> iter = sessions.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry<InetSocketAddress, DTLSClient> entry = iter.next();\n        DTLSClient client = entry.getValue();\n        if (client.getLastActivityTime() < expirationTime) {\n            log.info(\"Evicting DTLS session for \" + entry.getKey() + \" due to inactivity.\");\n            iter.remove();\n        }\n    }\n}", "CodeBleu_score": 36.0544747903363}, {"code": "public void evictTimeoutSessions()\tlong expirationTime = System.currentTimeMillis() - inactivityTimeout;\n\tIterator<Map.Entry<Integer, DtlsSession>> it = dtlsSessions.entrySet().iterator();\n\twhile (it.hasNext()) {\n\t\tMap.Entry<Integer, DtlsSession> entry = it.next();\n\t\tif (entry.getValue().lastActivityTime < expirationTime) {\n\t\t\tit.remove();\n\t\t\tSystem.out.println(\"Removed DTLS session with ID \" + entry.getKey() + \" due to inactivity.\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.37874868166983}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries != null && !timeseries.isEmpty()) {\n        List<TsKvEntry> result = new ArrayList<>(timeseries.size());\n        timeseries.forEach((key, value) -> {\n            if (value != null && !value.isEmpty()) {\n                result.add(new BasicTsKvEntry(System.currentTimeMillis(), new StringDataEntry(key, value.get(0).asText())));\n            }\n        });\n        return result;\n    } else {\n        return Collections.emptyList();\n    }\n}\n", "CodeBleu_score": 49.43315597774583}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries == null || timeseries.isEmpty()) {\n        return Collections.emptyList();\n    } else {\n        List<TsKvEntry> result = new ArrayList<>(timeseries.size());\n        timeseries.forEach((key, value) -> {\n            if (value != null && !value.isEmpty()) {\n                value.forEach(v -> {\n                    try {\n                        result.add(new BasicTsKvEntry(System.currentTimeMillis(),\n                                new StringDataEntry(key, v.asText())));\n                    } catch (Exception e) {\n                        log.warn(\"[{}] Failed to parse value: {}\", key, v, e);\n                    }\n                });\n            }\n        });\n        return result;\n    }\n}", "CodeBleu_score": 47.025468117879385}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries == null || timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    return timeseries.entrySet().stream().flatMap(entry -> {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        if (values == null || values.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return values.stream().map(value -> new BasicTsKvEntry(System.currentTimeMillis(), toKvEntry(key, value)));\n    }).collect(Collectors.toList());\n}\n", "CodeBleu_score": 39.67318864029698}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken()\n    // Create a request map containing the current refresh token\n    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(REFRESH_TOKEN, tokenInfo.getRefreshToken());\n\n    // Create a POST request with the request map as the body\n    Request request = new Request.Builder()\n            .url(tokenInfo.getAuthEndpoint())\n            .post(RequestBody.create(MediaType.parse(\"application/json\"), new Gson().toJson(requestMap)))\n            .build();\n\n    // Send the request and get the response\n    try {\n        Response response = client.newCall(request).execute();\n        if (response.isSuccessful()) {\n            // Update the token information with the current timestamp and the response body\n            tokenInfo.setAccessToken(response.body().string());\n            tokenInfo.setLastUpdated(System.currentTimeMillis());\n        } else {\n            // If the response is unsuccessful, log the error message\n            log.error(\"Error while refreshing token. Response code: \" + response.code() + \", Response message: \" + response.message());\n        }\n    } catch (IOException e) {\n        // If an exception occurs, log the error message\n        log.error(\"Error while refreshing token. Exception message: \" + e.getMessage());\n    }\n}\n", "CodeBleu_score": 42.382111539745615}, {"code": "public void refreshToken()    // Create request map\n    Map<String, Object> requestMap = new HashMap<>();\n    requestMap.put(\"refresh_token\", refreshToken);\n\n    // Create request body\n    String requestBody = GsonUtil.getGson().toJson(requestMap);\n\n    // Create request\n    Request request = new Request.Builder()\n            .url(authenticationEndpoint)\n            .post(RequestBody.create(requestBody, MediaType.parse(\"application/json\")))\n            .build();\n\n    // Send request\n    try {\n        Response response = client.newCall(request).execute();\n        if (response.isSuccessful()) {\n            // Parse response\n            Map<String, Object> responseMap = GsonUtil.getGson().fromJson(response.body().string(), Map.class);\n\n            // Update token information\n            accessToken = (String) responseMap.get(\"access_token\");\n            refreshToken = (String) responseMap.get(\"refresh_token\");\n            tokenExpiry = System.currentTimeMillis() + (Long) responseMap.get(\"expires_in\") * 1000;\n        } else {\n            // Handle error response\n            throw new IOException(\"Unexpected code \" + response);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n", "CodeBleu_score": 42.47655995132348}, {"code": "public void refreshToken()    try {\n        String refreshToken = getRefreshToken();\n        Map<String, String> requestMap = new HashMap<>();\n        requestMap.put(\"grant_type\", \"refresh_token\");\n        requestMap.put(\"refresh_token\", refreshToken);\n        String response = HttpUtil.doPost(\n                getEndpoint() + \"/token\",\n                requestMap,\n                getClientId(),\n                getClientSecret()\n        );\n        setToken(response);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "CodeBleu_score": 40.38062937585928}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin()    long timestamp = System.currentTimeMillis();\n    String username = mUsernameEditText.getText().toString();\n    String password = mPasswordEditText.getText().toString();\n\n    Map<String, String> loginRequestMap = new HashMap<>();\n    loginRequestMap.put(\"username\", username);\n    loginRequestMap.put(\"password\", password);\n\n    String requestBody = new Gson().toJson(loginRequestMap);\n\n    Request request = new Request.Builder()\n            .url(mBaseUrl + \"/api/auth/login\")\n            .post(RequestBody.create(requestBody, MediaType.parse(\"application/json\")))\n            .build();\n\n    mOkHttpClient.newCall(request).enqueue(new Callback() {\n        @Override\n        public void onFailure(Call call, IOException e) {\n            e.printStackTrace();\n        }\n\n        @Override\n        public void onResponse(Call call, Response response) throws IOException {\n            if (response.isSuccessful()) {\n                String responseString = response.body().string();\n                Map<String, Object> responseMap = new Gson().fromJson(responseString, new TypeToken<Map<String, Object>>(){}.getType());\n                String token = (String) responseMap.get(\"token\");\n                String refreshToken = (String) responseMap.get(\"refreshToken\");\n\n                if (token != null && refreshToken != null) {\n                    mToken = token;\n                    mRefreshToken = refreshToken;\n                    mTokenTimestamp = timestamp;\n\n                    mTokenTextView.setText(mToken);\n                    mRefreshTokenTextView.setText(mRefreshToken);\n                    mTokenTimestampTextView.setText(Long.toString(mTokenTimestamp));\n                }\n            }\n        }\n    });\n}\n", "CodeBleu_score": 41.12786520347299}, {"code": " private void doLogin()\n        // Capture the current timestamp\n        long currentTime = System.currentTimeMillis();\n\n        // Create a login request map\n        Map<String, String> loginRequestMap = new HashMap<>();\n        loginRequestMap.put(\"username\", username);\n        loginRequestMap.put(\"password\", password);\n\n        // Send a POST request with the login request map\n        String loginResponse =\n                HttpClient.sendHttpPostRequest(\n                        baseUrl + \"/api/auth/login\", loginRequestMap);\n\n        // Parse the response and get the token information\n        JSONObject jsonObject = new JSONObject(loginResponse);\n        String accessToken = jsonObject.getString(\"accessToken\");\n        String refreshToken = jsonObject.getString(\"refreshToken\");\n\n        // Update the token information with the response data and the timestamp\n        tokenInfo.put(\"accessToken\", accessToken);\n        tokenInfo.put(\"refreshToken\", refreshToken);\n        tokenInfo.put(\"timestamp\", currentTime);\n    }\n\n    /**\n     * The function \"doRefreshToken\" performs a token refresh operation by sending a POST request to the authentication endpoint.\\nIt captures the current timestamp, creates a refresh token request map with the refresh token, and sends the request to the \"/api/auth/refresh\" URL.\\nUpon receiving the response, it updates the token information with the response data and the timestamp.\n     */\n    private void doRefreshToken() {\n\n        // Capture the current timestamp\n        long currentTime = System.currentTimeMillis();\n\n        // Create a refresh token request map\n        Map<String, String> refreshTokenRequestMap = new HashMap<>();\n        refreshTokenRequestMap.put(\"refreshToken\", tokenInfo.get(\"refreshToken\"));\n\n        // Send a POST request with the refresh token request map\n        String refreshTokenResponse =\n                HttpClient.sendHttpPostRequest(\n                        baseUrl + \"/api/auth/refresh\", refreshTokenRequestMap);\n\n        // Parse the response and get the token information\n        JSONObject jsonObject = new JSONObject(refreshTokenResponse);\n        String accessToken = jsonObject.getString(\"accessToken\");\n        String refreshToken = jsonObject.getString(\"refreshToken\");\n\n        // Update the token information with the response data and the timestamp\n        tokenInfo.", "CodeBleu_score": 49.271013550779706}, {"code": " private void doLogin()        String username = usernameField.getText();\n        String password = passwordField.getText();\n\n        if (username.isEmpty() || password.isEmpty()) {\n            Alert alert = new Alert(Alert.AlertType.ERROR);\n            alert.setTitle(\"Error\");\n            alert.setHeaderText(\"Please enter a username and password\");\n            alert.showAndWait();\n            return;\n        }\n\n        long timestamp = System.currentTimeMillis();\n        Map<String, String> loginRequest = new HashMap<>();\n        loginRequest.put(\"username\", username);\n        loginRequest.put(\"password\", password);\n\n        HttpResponse<String> response = Unirest.post(URL + \"/api/auth/login\")\n                .header(\"Content-Type\", \"application/json\")\n                .body(loginRequest)\n                .asString();\n\n        if (response.getStatus() == 200) {\n            try {\n                JSONObject jsonObject = new JSONObject(response.getBody());\n                String token = jsonObject.getString(\"token\");\n                String username = jsonObject.getString(\"username\");\n                String role = jsonObject.getString(\"role\");\n\n                tokenInfo.setToken(token);\n                tokenInfo.setUsername(username);\n                tokenInfo.setRole(role);\n                tokenInfo.setTimestamp(timestamp);\n            } catch (JSONException e) {\n                e.printStackTrace();\n            }\n        } else {\n            Alert alert = new Alert(Alert.AlertType.ERROR);\n            alert.setTitle(\"Error\");\n            alert.setHeaderText(\"Login failed\");\n            alert.showAndWait();\n        }\n    }\n", "CodeBleu_score": 54.81741604026875}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    return get(deviceId, Device.class);\n}\n", "CodeBleu_score": 4.953545859426253}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    return Optional.ofNullable(getForObject(\n        \"/api/device/{deviceId}\", Device.class, deviceId.getId()));\n}", "CodeBleu_score": 12.052156179188353}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    Optional<Device> device = Optional.empty();\n    try {\n        HttpResponse<String> response = Unirest.get(baseUrl + \"/api/device/\" + deviceId.getId())\n                .header(\"accept\", \"application/json\")\n                .header(\"X-Auth-Token\", authToken)\n                .asString();\n        if (response.getStatus() == 200) {\n            device = Optional.of(new Device(response.getBody()));\n        } else if (response.getStatus() == 404) {\n            device = Optional.empty();\n        } else {\n            throw new Exception(\"Unexpected response code \" + response.getStatus() + \" with message \" + response.getStatusText());\n        }\n    } catch (UnirestException e) {\n        throw new RuntimeException(\"Could not retrieve device with ID \" + deviceId.getId(), e);\n    }\n    return device;\n}", "CodeBleu_score": 45.92960455484153}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        return Optional.of(\n                restTemplate.postForObject(\n                        \"/api/device-with-credentials\",\n                        new DeviceWithCredentials(device, credentials),\n                        Device.class\n                )\n        );\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}\n", "CodeBleu_score": 41.84179813976742}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        // Create the request object\n        DeviceWithCredentials deviceWithCredentials = new DeviceWithCredentials(device, credentials);\n        // Send the request\n        ResponseEntity<Device> response = restTemplate.postForEntity(baseUrl + \"/api/device-with-credentials\", deviceWithCredentials, Device.class);\n        // Return the response\n        return Optional.of(response.getBody());\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 75.58902468359004}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        return Optional.of(deviceService.saveDeviceWithCredentials(device, credentials));\n    } catch (ResourceAccessException e) {\n        throw new ServiceException(e);\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}\n", "CodeBleu_score": 37.572808508203934}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val)  if (arguments.length === 1) {\n    this.brightness = val;\n  } else if (arguments.length === 2) {\n    this.brightness = this.brightness || {};\n    this.brightness[addr] = val;\n  }\n  return this;\n}\n", "CodeBleu_score": 43.419118444323544}, {"code": "brightness(addr, val)    if (arguments.length == 1) {\n        this.brightness = val;\n    } else {\n        this.devices[addr].brightness = val;\n    }\n    return this;\n}\n", "CodeBleu_score": 30.506976639338518}, {"code": "brightness(addr, val)\tif (arguments.length == 1) {\n\t\tthis.brightness = Math.round(val / 100 * 15);\n\t} else {\n\t\tthis.devices[addr].brightness = Math.round(val / 100 * 15);\n\t}\n\treturn this;\n}\n", "CodeBleu_score": 37.82374557349829}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr)  var obj = {};\n  for (var key in this) {\n    if (this.hasOwnProperty(key)) {\n      obj[key] = this[key].bind(this, addr);\n    }\n  }\n  return obj;\n}\n", "CodeBleu_score": 29.813616030206358}, {"code": "device(addr)  var device = Object.create(this);\n  device.address = addr;\n  for (var k in this) {\n    if (this.hasOwnProperty(k)) {\n      device[k] = this[k].bind(device);\n    }\n  }\n  return device;\n}\n", "CodeBleu_score": 27.93726684467586}, {"code": "device(addr)  const device = {};\n  for (const key of Object.getOwnPropertyNames(LedControl.prototype)) {\n    device[key] = this[key].bind(this, addr);\n  }\n  return device;\n}\n", "CodeBleu_score": 34.2465664299084}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) =>   methods.forEach(method => {\n    target[`${method}Async`] = (collection, duration, callback) => {\n      if (!(collection instanceof Collection)) {\n        throw new Error(`${method}Async: collection must be a Collection`);\n      }\n\n      if (typeof duration !== 'number') {\n        duration = 1000;\n      }\n\n      if (typeof callback !== 'function') {\n        throw new Error(`${method}Async: callback must be a function`);\n      }\n\n      const promises = [];\n      collection.forEach(element => {\n        promises.push(new Promise(resolve => {\n          setTimeout(() => {\n            target[method](element);\n            resolve();\n          }, duration);\n        }));\n      });\n\n      Promise.all(promises).then(() => {\n        callback();\n      });\n    };\n  });\n};\n", "CodeBleu_score": 38.42456182372346}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>   for (const method of methods) {\n    const originalMethod = target[method];\n    target[method] = function (...args) {\n      const duration = args.pop();\n      const callback = args.pop();\n      if (typeof callback !== 'function') {\n        throw new Error('Callback must be a function');\n      }\n      const promises = [];\n      this.forEach(element => {\n        promises.push(originalMethod.call(element, ...args));\n      });\n      Promise.all(promises).then(() => {\n        setTimeout(() => {\n          callback();\n        }, duration);\n      });\n    };\n  }\n};\n", "CodeBleu_score": 38.80828089236944}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>   methods.forEach(method => {\n    const originalMethod = target[method];\n    target[method] = (collection, duration, callback) => {\n      if (typeof duration === 'function') {\n        callback = duration;\n        duration = 1000;\n      }\n      if (typeof callback !== 'function') {\n        throw new Error(`Collection.${method} requires a callback function as the last argument`);\n      }\n      const promises = [];\n      collection.forEach(element => {\n        promises.push(new Promise((resolve, reject) => {\n          originalMethod.call(target, element, duration, err => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        }));\n      });\n      return Promise.all(promises).then(() => callback(null)).catch(callback);\n    };\n  });\n};\n", "CodeBleu_score": 48.36298749464042}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen()  var inputString = \"\";\n  var currentString = \"\";\n  var sentence = \"\";\n  var sentenceArray = [];\n  var sentenceComplete = false;\n\n  while (true) {\n    while (Serial.available()) {\n      var inChar = Serial.read();\n      inputString += String.fromCharCode(inChar);\n    }\n    sentenceArray = inputString.split(\"\\r\\n\");\n    if (sentenceArray.length > 1) {\n      sentence = sentenceArray.shift();\n      parseNmeaSentence(sentence);\n    }\n    inputString = sentenceArray.join(\"\\r\\n\");\n    delay(10);\n  }\n}\n", "CodeBleu_score": 30.259442424673498}, {"code": "listen()    let input = \"\";\n    let sentence = \"\";\n    while (true) {\n        let data = serial.readLine();\n        if (data == null) {\n            return;\n        }\n        input += data;\n        let sentences = input.split(\"\\r\\n\");\n        for (let i = 0; i < sentences.length - 1; i++) {\n            sentence = sentences[i];\n            parseNmeaSentence(sentence);\n        }\n        input = sentences[sentences.length - 1];\n    }\n}\n", "CodeBleu_score": 47.665325617125625}, {"code": "listen()  let input = \"\";\n  let sentence = \"\";\n  let incompleteSentence = \"\";\n\n  const port = new SerialPort(this.port, {\n    baudRate: this.baudRate,\n    dataBits: 8,\n    stopBits: 1,\n    parity: \"none\",\n    autoOpen: false,\n  });\n\n  port.open(function (err) {\n    if (err) {\n      return console.log(\"Error opening port: \", err.message);\n    }\n    console.log(\"Port opened\");\n\n    port.on(\"data\", function (data) {\n      input += data;\n      while (input.indexOf(\"\\r\\n\") > -1) {\n        sentence = input.substr(0, input.indexOf(\"\\r\\n\"));\n        input = input.substr(input.indexOf(\"\\r\\n\") + 2);\n        parseNmeaSentence(sentence);\n      }\n    });\n\n    port.on(\"error\", function (err) {\n      console.log(\"Error: \", err.message);\n    });\n  });\n}\n", "CodeBleu_score": 33.18104913428942}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_cfg *config = dev->config;\n\tint num_channels = 0;\n\tint num_samples = 0;\n\tint num_bytes = 0;\n\n\tif (sequence->channels == NULL) {\n\t\tLOG_ERR(\"No channels selected\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (int i = 0; i < sequence->channels->len; i++) {\n\t\tint channel = sequence->channels->list[i];\n\n\t\tif (channel < 0 || channel >= config->num_channels) {\n\t\t\tLOG_ERR(\"Invalid channel %d\", channel);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BIT(channel) & config->channels_mask) {\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (sequence->buffer == NULL) {\n\t\tLOG_ERR(\"No buffer provided\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution == 8) {\n\t\tnum_bytes = 1;\n\t} else if (sequence->resolution == 16) {\n\t\tnum_bytes = 2;\n\t} else {\n\t\tLOG_ERR(\"Invalid resolution %d\", sequence->resolution);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_samples = num_channels * sequence->oversampling;\n\n\tif (sequence->buffer_size < num_samples * num_bytes) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 46.710731317001795}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_cfg *config = dev->config;\n\tuint8_t active_channels = 0;\n\tuint8_t sample_size;\n\n\tfor (uint8_t i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i] != ADC_ACQUIRE_TIME) {\n\t\t\tactive_channels++;\n\t\t}\n\t}\n\n\tsample_size = config->resolution / 8;\n\n\tif (sequence->buffer_size < active_channels * sample_size) {\n\t\tLOG_ERR(\"Insufficient buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 40.23803485576642}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tconst struct adc_ad559x_cfg *config = dev->config;\n\tuint32_t channels = sequence->channels;\n\tuint8_t channel_count = 0;\n\n\tfor (uint8_t i = 0; i < config->channel_count; i++) {\n\t\tif (channels & BIT(i)) {\n\t\t\tchannel_count++;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < channel_count * sizeof(uint16_t)) {\n\t\tLOG_ERR(\"Insufficient memory\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 42.760906540461704}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)    struct adc_ad559x_data *data = dev->data;\n    struct adc_ad559x_dev_config *config = dev->config;\n    int ret = 0;\n\n    /* Check the buffer size */\n    if (sequence->options) {\n        LOG_ERR(\"Invalid option\");\n        return -EINVAL;\n    }\n\n    /* Check the channels */\n    if (sequence->channels[0].channel_id != ADC_AD559X_CHANNEL_0) {\n        LOG_ERR(\"Invalid channel\");\n        return -EINVAL;\n    }\n\n    /* Check the resolution */\n    if (sequence->resolution != ADC_AD559X_RESOLUTION) {\n        LOG_ERR(\"Invalid resolution\");\n        return -EINVAL;\n    }\n\n    /* Check the buffer size */\n    if (sequence->buffer_size < ADC_AD559X_RESULT_SIZE) {\n        LOG_ERR(\"Invalid buffer size\");\n        return -EINVAL;\n    }\n\n    /* Set the buffer */\n    data->buffer = sequence->buffer;\n\n    /* Start the ADC read context */\n    k_sem_take(&data->lock, K_FOREVER);\n    ret = ad5592_start_read(&config->ad5592, AD5592_CHANNEL_0);\n    if (ret) {\n        LOG_ERR(\"AD5592 start read failed\");\n        k_sem_give(&data->lock);\n        return ret;\n    }\n\n    /* Wait for the ADC read to complete */\n    k_sem_take(&data->sync, K_FOREVER);\n    k_sem_give(&data->lock);\n\n    return 0;\n}\n", "CodeBleu_score": 57.3283149003924}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)    struct adc_ad559x_data *data = dev->data;\n    const struct adc_ad559x_cfg *config = dev->config;\n    uint8_t *buffer = sequence->buffer;\n    uint32_t buffer_size = sequence->buffer_size;\n    uint8_t channel_count = sequence->channels;\n    uint8_t resolution = sequence->resolution;\n    uint8_t oversampling = sequence->oversampling;\n    uint8_t gain = sequence->gain;\n    uint8_t reference = sequence->reference;\n    uint8_t acquisition_time = sequence->acquisition_time;\n    uint8_t channel;\n    uint8_t channel_mask;\n    uint8_t channel_mask_count;\n    uint8_t channel_mask_idx;\n    uint8_t channel_mask_bit;\n    uint8_t channel_mask_bit_count;\n    int ret;\n    int i;\n    int j;\n\n    if (resolution != 12) {\n        LOG_ERR(\"Invalid resolution\");\n        return -EINVAL;\n    }\n\n    channel_mask_count = 0;\n    channel_mask = 0;\n    channel_mask_idx = 0;\n    channel_mask_bit = 0;\n    channel_mask_bit_count = 0;\n    for (i = 0; i < channel_count; i++) {\n        channel = sequence->channels_id[i];\n        if (channel >= config->channel_count) {\n            LOG_ERR(\"Invalid channel\");\n            return -EINVAL;\n        }\n        if (channel_mask_count == 0) {\n            channel_mask = config->channel_masks[channel];\n            channel_mask_count = config->channel_mask_counts[channel];\n            channel_mask_idx = 0;\n            channel_mask_bit = 0;\n            channel_mask_bit_count = 0;\n        }\n        if (channel_mask_idx < channel_mask_count) {\n            if (channel_mask_bit_count == 0", "CodeBleu_score": 45.1623122661074}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tconst struct adc_ad559x_cfg *config = dev->config;\n\tuint8_t i;\n\tint ret = 0;\n\n\tif (sequence->resolution != config->resolution) {\n\t\tLOG_ERR(\"Invalid resolution\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < sequence->channels; i++) {\n\t\tif (sequence->channels[i] >= config->channel_count) {\n\t\t\tLOG_ERR(\"Invalid channel\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sequence->buffer_size < sequence->channels) {\n\t\tLOG_ERR(\"Invalid buffer size\");\n\t\treturn -ENOMEM;\n\t}\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\tdata->buffer = sequence->buffer;\n\tdata->buffer_length = sequence->channels;\n\n\tadc_ad559x_set_channel(dev, sequence->channels[0]);\n\n\tadc_ad559x_set_conversion_mode(dev, AD559X_CONTINUOUS_CONVERSION);\n\n\tadc_ad559x_set_conversion_rate(dev, sequence->frequency);\n\n\tadc_ad559x_set_gain(dev, sequence->oversampling);\n\n\tadc_ad559x_start_conversion(dev);\n\n\tk_sem_take(&data->sem, K_FOREVER);\n\n\treturn ret;\n}\n", "CodeBleu_score": 48.65897511768553}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx)    // Get the ADC data structure from the context\n    struct adc_dev_s *dev = ctx->dev;\n\n    // Set the channels to be sampled\n    dev->ad_ops->ao_start_channels(dev, ctx->channels);\n\n    // Initialize the repeat buffer with the data buffer\n    memcpy(ctx->repeat_buffer, ctx->buffer, ctx->depth);\n\n    // Release a semaphore to signal the start of sampling\n    sem_post(&ctx->sem_start);\n}\n", "CodeBleu_score": 48.716631983108286}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)\tstruct adc_sampling_event_data *data;\n\tstruct adc_data *adc_data;\n\tstruct adc_data *repeat_data;\n\tuint8_t i;\n\n\tdata = (struct adc_sampling_event_data *)ctx->callback_data;\n\tadc_data = data->adc_data;\n\trepeat_data = data->repeat_data;\n\n\t/*\n\t * Set the channels to be sampled.\n\t */\n\tadc_set_channels(adc_data->adc, adc_data->channels);\n\n\t/*\n\t * Set the repeat buffer with the data buffer.\n\t */\n\tfor (i = 0; i < adc_data->num_channels; i++) {\n\t\trepeat_data->buffer[i] = adc_data->buffer[i];\n\t}\n\n\t/*\n\t * Release the semaphore to signal the start of sampling.\n\t */\n\tadc_data->semaphore = 1;\n}\n", "CodeBleu_score": 33.934696542223854}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)    struct adc_sampling_event *event = (struct adc_sampling_event *)ctx->event_queue->queue_get_free_slot();\n    if (event == NULL) {\n        return;\n    }\n    event->sampling_event_type = ADC_SAMPLING_EVENT_START;\n    event->adc_channel = ctx->adc_channel;\n    event->adc_channel_count = ctx->adc_channel_count;\n    ctx->event_queue->queue_add_event(event);\n}\n", "CodeBleu_score": 42.86860413690856}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    struct adc_data_container *data_container = &ctx->data_container;\n    if (repeat_sampling) {\n        data_container->buffer = data_container->repeat_buffer;\n    }\n}\n", "CodeBleu_score": 41.18457191039068}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)\tif (repeat_sampling) {\n\t\tctx->data->buffer = ctx->data->repeat_buffer;\n\t}\n}\n", "CodeBleu_score": 44.80883219049289}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    if (repeat_sampling) {\n        ctx->data->buffer = ctx->data->repeat_buffer;\n    }\n}\n", "CodeBleu_score": 46.92198217596435}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)\tint i;\n\tint ret;\n\tint channel;\n\tint channel_count;\n\tstruct adc_ad559x_channel_cfg *channels;\n\tstruct adc_ad559x_context *context;\n\tstruct adc_ad559x_buffer *buffer;\n\n\twhile (1) {\n\t\tk_sem_take(&data->start_sem, K_FOREVER);\n\n\t\tcontext = &data->context;\n\t\tbuffer = &data->buffer;\n\t\tchannels = context->channels;\n\t\tchannel_count = context->channel_count;\n\n\t\tfor (i = 0; i < channel_count; i++) {\n\t\t\tchannel = channels[i].channel;\n\n\t\t\tret = adc_read(context->dev, &buffer->buffer[channel],\n\t\t\t\t       channel);\n\t\t\tif (ret) {\n\t\t\t\tLOG_ERR(\"ADC read failed, channel %d\", channel);\n\t\t\t\tcontext->completed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tk_sem_give(&data->done_sem);\n\t}\n}\n", "CodeBleu_score": 39.89201696096995}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)    int i;\n    int ret;\n    int32_t adc_value;\n    struct adc_ad559x_channel_config *ch_cfg;\n    struct adc_ad559x_context *ctx;\n\n    while (1) {\n        /* Wait for semaphore to be released */\n        k_sem_take(&data->sem, K_FOREVER);\n\n        /* Iterate through active channels */\n        for (i = 0; i < data->channels; i++) {\n            ch_cfg = &data->channels_cfg[i];\n            ctx = &data->ctx;\n\n            /* Read ADC value */\n            ret = adc_ad559x_read_raw(ctx, ch_cfg->channel_id, &adc_value);\n            if (ret != 0) {\n                LOG_ERR(\"Failed to read ADC value for channel %d\", ch_cfg->channel_id);\n                data->status = ADC_AD559X_STATUS_ERROR;\n                break;\n            }\n\n            /* Store ADC value in buffer */\n            data->buffer[i] = adc_value;\n        }\n\n        /* Signal that sampling is done */\n        k_sem_give(&data->done);\n    }\n}\n", "CodeBleu_score": 43.004725395740685}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)    int ret;\n    int channel_idx;\n    int channel_count;\n    int channel_id;\n    int channel_value;\n    int channel_value_idx;\n    int channel_value_count;\n    int channel_value_buf_idx;\n    int channel_value_buf_count;\n    int channel_value_buf_size;\n    int channel_value_buf_offset;\n    int channel_value_buf_end;\n    struct adc_ad559x_channel_data *channel_data;\n    struct adc_ad559x_channel_value *channel_value_buf;\n\n    while (1) {\n        /* Wait for semaphore to be released */\n        sem_wait(&data->sem);\n\n        /* Iterate through channels */\n        channel_count = data->channel_count;\n        channel_data = data->channel_data;\n        for (channel_idx = 0; channel_idx < channel_count; channel_idx++) {\n            /* Read channel value */\n            channel_id = channel_data[channel_idx].id;\n            ret = adc_ad559x_channel_read(data->adc_dev, channel_id, &channel_value);\n            if (ret) {\n                LOG_ERR(\"Channel %d read failed: %d\", channel_id, ret);\n                data->channel_complete[channel_idx] = 1;\n                continue;\n            }\n\n            /* Store channel value */\n            channel_value_count = channel_data[channel_idx].value_count;\n            channel_value_buf_size = channel_data[channel_idx].value_buf_size;\n            channel_value_buf_offset = channel_data[channel_idx].value_buf_offset;\n            channel_value_buf_end = channel_value_buf_offset + channel_value_buf_size;\n            channel_value_buf = &data->channel_value_buf[channel_value_buf_offset];\n            channel_value_buf_count = channel_value_buf_end - channel_value_buf_offset;\n            channel_value_buf_idx = channel_data[channel_idx].", "CodeBleu_score": 27.480951451425017}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev)\tuint8_t config;\n\tint ret;\n\tuint8_t ready_time;\n\n\tret = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tready_time = (config & ADS1112_CONFIG_DR_MASK) >> ADS1112_CONFIG_DR_SHIFT;\n\n\tif (ready_time == 0) {\n\t\treturn 0;\n\t}\n\n\tk_sleep(K_MSEC(ready_time));\n\n\twhile (1) {\n\t\tret = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (config & ADS1112_CONFIG_DRDY) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tk_sleep(K_USEC(100));\n\t}\n}\n", "CodeBleu_score": 51.86759712469116}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    struct ads1112_data *data = dev->data;\n    struct ads1112_config *config = dev->config;\n    int ret = 0;\n    uint16_t cfg_reg;\n    uint8_t ready_time;\n\n    // Put the current thread to sleep for the device's specified ready time\n    k_sleep(K_MSEC(config->ready_time));\n\n    // Read the configuration register\n    ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &cfg_reg);\n    if (ret) {\n        return ret;\n    }\n\n    // Get the ready time from the configuration register\n    ready_time = (cfg_reg & ADS1112_CONFIG_DR_MASK) >> ADS1112_CONFIG_DR_SHIFT;\n\n    // If the device is not ready, repeatedly sleep for 100 microseconds and check the status again\n    while (!(cfg_reg & ADS1112_CONFIG_DRDY_MASK)) {\n        if (ready_time > 1) {\n            k_sleep(K_USEC(100));\n        }\n\n        // Read the configuration register again\n        ret = ads1112_read_reg(dev, ADS1112_REG_CONFIG, &cfg_reg);\n        if (ret) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 60.724324088172544}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)\tint ret;\n\tuint16_t reg_val;\n\tconst struct ads1112_config *cfg = dev->config;\n\tstruct ads1112_data *data = dev->data;\n\n\tk_sleep(K_USEC(cfg->drdy_ms));\n\n\tret = i2c_reg_read_word_be(data->i2c_master, cfg->i2c_slave_addr,\n\t\t\t\t   ADS1112_REG_CONFIG, &reg_val);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\twhile (reg_val & ADS1112_CONFIG_OS_MASK) {\n\t\tk_sleep(K_USEC(100));\n\t\tret = i2c_reg_read_word_be(data->i2c_master, cfg->i2c_slave_addr,\n\t\t\t\t\t   ADS1112_REG_CONFIG, &reg_val);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 50.69233308697938}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)    uint16_t required_buffer_size;\n    uint16_t buffer_size;\n    uint16_t samplings;\n\n    samplings = sequence->samplings;\n    if (sequence->options & ADC_SEQUENCE_OPTION_EXTRA_SAMPLINGS) {\n        samplings += sequence->extra_samplings;\n    }\n\n    required_buffer_size = samplings * sizeof(uint16_t);\n    buffer_size = sequence->buffer_size;\n\n    if (required_buffer_size > buffer_size) {\n        LOG_ERR(\"Buffer size is not sufficient\");\n        return -ENOMEM;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 48.45075042790403}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)    int buffer_size = sequence->buffer_size;\n    int samplings = sequence->samplings;\n    int options = sequence->options;\n\n    if (options & ADC_SEQUENCE_NO_EXTRA_SAMPLING) {\n        if (buffer_size < samplings) {\n            LOG_ERROR(\"Buffer size (%d) is too small for %d samplings\", buffer_size, samplings);\n            return -1;\n        }\n    } else {\n        int extra_samplings = 0;\n        if (options & ADC_SEQUENCE_START_AT_END) {\n            extra_samplings++;\n        }\n        if (options & ADC_SEQUENCE_EXTRA_SAMPLING_AT_START) {\n            extra_samplings++;\n        }\n        if (buffer_size < samplings + extra_samplings) {\n            LOG_ERROR(\"Buffer size (%d) is too small for %d samplings, %d extra samplings\", buffer_size, samplings, extra_samplings);\n            return -1;\n        }\n    }\n    return 0;\n}\n", "CodeBleu_score": 41.4622619007972}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)    if (sequence->buffer_size < (sequence->samplings + sequence->options.extra_samplings) * 2) {\n        LOG_ERROR(\"Buffer size is too small. Required: %d, given: %d\",\n                  (sequence->samplings + sequence->options.extra_samplings) * 2, sequence->buffer_size);\n        return -1;\n    }\n    return 0;\n}\n", "CodeBleu_score": 46.558334993757796}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tint ret = 0;\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Only channel 0 is supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Resolution not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(1)) {\n\t\tLOG_ERR(\"Channel 1 not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(2)) {\n\t\tLOG_ERR(\"Channel 2 not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(3)) {\n\t\tLOG_ERR(\"Channel 3 not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(4)) {\n\t\tLOG_ERR(\"Channel 4 not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(5)) {\n\t\tLOG_ERR(\"Channel 5 not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(6)) {\n\t\tLOG_ERR(\"Channel 6 not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(7)) {\n\t\tLOG_ERR(\"Channel 7 not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels & BIT(8)) {\n\t\tLOG_ERR(\"Channel 8 not supported\");\n", "CodeBleu_score": 38.48357580979263}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tint ret;\n\n\tif (!sequence->channels) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels[0] >= ADS1112_CHANNEL_COUNT) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels[0] < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Resolution not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\tLOG_ERR(\"Multi channel read not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->channels > 1) {\n\t\tLOG_ERR(\"Multi channel read not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Options not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->extra_samplings) {\n\t\tLOG_ERR(\"Extra samplings not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Options not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (sequence->options) {\n\t\tLOG_ERR(\"Options not supported\");\n\t\treturn", "CodeBleu_score": 37.65819919902839}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tstruct ads1112_data *data = dev->data;\n\tstruct ads1112_dev_config *config = dev->config;\n\tint ret;\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Resolution not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Resolution not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->channels != BIT(0)) {\n\t\tLOG_ERR(\"Only channel 0 supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->oversampling != 0) {\n\t\tLOG_ERR(\"Oversampling not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->resolution != 12) {\n\t\tLOG_ERR(\"Resolution not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->calibrate) {\n\t\tLOG_ERR(\"Calibration", "CodeBleu_score": 38.41324618862628}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_help(sh);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_apply_prop(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Error %d: failed to apply properties\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 65.12359951329474}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret = -1;\n\tstruct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Too few arguments\");\n\t\treturn -1;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -1;\n\t}\n\n\tif (argc > 2) {\n\t\tret = audio_codec_apply_prop(dev, argv[2]);\n\t} else {\n\t\tret = audio_codec_apply_prop(dev, NULL);\n\t}\n\n\tif (ret) {\n\t\tshell_error(sh, \"Error applying properties\");\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 53.812501766336176}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tstruct device *dev;\n\tchar *dev_name;\n\tchar *prop_name;\n\tchar *prop_value;\n\tint prop_len;\n\tint prop_value_len;\n\tint prop_type;\n\tint prop_id;\n\n\tif (argc < 3) {\n\t\tshell_error(sh, \"Wrong number of arguments\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_name = argv[1];\n\tprop_name = argv[2];\n\tprop_value = argv[3];\n\tprop_len = strlen(prop_name);\n\tprop_value_len = strlen(prop_value);\n\n\tdev = device_get_binding(dev_name);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_property_get(dev, prop_name, prop_len, &prop_type,\n\t\t\t\t       &prop_id);\n\tif (ret) {\n\t\tshell_error(sh, \"Property not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = audio_codec_property_set(dev, prop_name, prop_len, prop_type,\n\t\t\t\t       prop_id, prop_value, prop_value_len);\n\tif (ret) {\n\t\tshell_error(sh, \"Error setting property\");\n\t\treturn -EIO;\n\t}\n\n\tshell_print(sh, \"Property set successfully\");\n\treturn 0;\n}\n", "CodeBleu_score": 54.97417153317015}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)\tstruct mpxxdtyy_dev_data *const dev_data = DEV_DATA(dev);\n\tconst struct mpxxdtyy_dev_config *const dev_config = DEV_CFG(dev);\n\tenum mpxxdtyy_i2s_state state;\n\tint ret;\n\n\t/* Get current state */\n\tstate = dev_data->i2s_state;\n\n\t/* Determine command */\n\tswitch (cmd) {\n\tcase DMIC_TRIGGER_START:\n\t\t/* If already started, ignore request */\n\t\tif (state == MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Start command allowed only in idle state */\n\t\tif (state != MPXXDTYY_I2S_STATE_IDLE) {\n\t\t\tLOG_ERR(\"Invalid state %d for start command\", state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Set state to configured */\n\t\tstate = MPXXDTYY_I2S_STATE_CONFIGURED;\n\n\t\t/* Send start command */\n\t\tret = i2s_write(dev_config->i2s_dev, dev_config->i2s_channel,\n\t\t\t\tMPXXDTYY_I2S_START_CMD,\n\t\t\t\tsizeof(MPXXDTYY_I2S_START_CMD));\n\t\tif (ret) {\n\t\t\tLOG_ERR(\"Failed to send start command (%d)\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tcase DMIC_TRIGGER_STOP:\n\t\t/* If already stopped, ignore request */\n\t\tif (state == MPXXDTYY_I2S_STATE_IDLE) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Stop command allowed only in active state */\n\t\tif (state != MPXXDTYY_I2S_STATE_ACTIVE) {\n\t\t\tLOG_ERR(\"Invalid state %d for stop command\", state);\n\t\t\treturn -EINVAL;", "CodeBleu_score": 52.03719499482855}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)  struct mpxxdtyy_dev_data *const dev_data = DEV_DATA(dev);\n  int ret;\n\n  switch (cmd) {\n    case DMIC_TRIGGER_START:\n      if (dev_data->state != MPXXDTYY_STATE_CONFIGURED) {\n        LOG_ERR(\"Device is not in configured state\");\n        return -EINVAL;\n      }\n\n      LOG_INF(\"Starting device\");\n\n      ret = mpxxdtyy_i2s_start(dev);\n      if (ret) {\n        LOG_ERR(\"Failed to start device\");\n        return ret;\n      }\n\n      dev_data->state = MPXXDTYY_STATE_ACTIVE;\n      break;\n\n    case DMIC_TRIGGER_STOP:\n      if (dev_data->state != MPXXDTYY_STATE_ACTIVE) {\n        LOG_ERR(\"Device is not in active state\");\n        return -EINVAL;\n      }\n\n      LOG_INF(\"Stopping device\");\n\n      ret = mpxxdtyy_i2s_stop(dev);\n      if (ret) {\n        LOG_ERR(\"Failed to stop device\");\n        return ret;\n      }\n\n      dev_data->state = MPXXDTYY_STATE_CONFIGURED;\n      break;\n\n    default:\n      return -EINVAL;\n  }\n\n  return 0;\n}\n", "CodeBleu_score": 53.766815033218606}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)    struct mpxxdtyy_dev_data *dev_data = dev->data;\n    enum mpxxdtyy_i2s_cmd i2s_cmd;\n    int ret;\n\n    switch (cmd) {\n    case DMIC_TRIGGER_START:\n        if (dev_data->state == MPXXDTYY_STATE_READY) {\n            i2s_cmd = MPXXDTYY_I2S_CMD_START;\n            dev_data->state = MPXXDTYY_STATE_ACTIVE;\n        } else {\n            LOG_ERR(\"Invalid trigger command %d in state %d\", cmd, dev_data->state);\n            return -EINVAL;\n        }\n        break;\n    case DMIC_TRIGGER_STOP:\n        if (dev_data->state == MPXXDTYY_STATE_ACTIVE) {\n            i2s_cmd = MPXXDTYY_I2S_CMD_STOP;\n            dev_data->state = MPXXDTYY_STATE_READY;\n        } else {\n            LOG_ERR(\"Invalid trigger command %d in state %d\", cmd, dev_data->state);\n            return -EINVAL;\n        }\n        break;\n    default:\n        LOG_ERR(\"Invalid trigger command %d\", cmd);\n        return -EINVAL;\n    }\n\n    ret = i2s_write(dev_data->i2s_dev, &i2s_cmd, sizeof(i2s_cmd));\n    if (ret) {\n        LOG_ERR(\"I2S write failed: %d\", ret);\n        return ret;\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 59.22441066169046}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t command = 0;\n\n\tif (enabled) {\n\t\tcommand = data->display_mode_command | ENABLE_DISPLAY;\n\t\tif (data->cursor_enabled) {\n\t\t\tcommand |= ENABLE_CURSOR;\n\t\t}\n\t\tif (data->cursor_blink_enabled) {\n\t\t\tcommand |= ENABLE_CURSOR_BLINK;\n\t\t}\n\t}\n\n\tdata->display_enabled = enabled;\n\n\tif (data->display_enabled) {\n\t\tLOG_INF(\"Display enabled\");\n\t} else {\n\t\tLOG_INF(\"Display disabled\");\n\t}\n\n\tif (data->cursor_enabled) {\n\t\tLOG_INF(\"Cursor enabled\");\n\t} else {\n\t\tLOG_INF(\"Cursor disabled\");\n\t}\n\n\tif (data->cursor_blink_enabled) {\n\t\tLOG_INF(\"Cursor blink enabled\");\n\t} else {\n\t\tLOG_INF(\"Cursor blink disabled\");\n\t}\n\n\tif (i2c_reg_write_byte(data->i2c_dev, data->i2c_address, COMMAND_DISPLAY_MODE, command) < 0) {\n\t\tLOG_ERR(\"Error while setting display mode\");\n\t}\n}\n", "CodeBleu_score": 53.113058734131634}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)    struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t command = 0x00;\n\n    if (enabled) {\n        command |= HD44780_DISPLAY_ON;\n        if (data->cursor_enabled) {\n            command |= HD44780_CURSOR_ON;\n        }\n        if (data->blink_enabled) {\n            command |= HD44780_BLINK_ON;\n        }\n    }\n\n    auxdisplay_hd44780_write_command(dev, command);\n}\n", "CodeBleu_score": 51.66860049638006}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)\tstruct auxdisplay_hd44780_data *data = dev->data;\n\tuint8_t cmd = 0;\n\tif (enabled) {\n\t\tcmd = data->display_mode_cmd;\n\t\tif (data->cursor_enabled) {\n\t\t\tcmd |= HD44780_DISPLAY_MODE_CURSOR_ON;\n\t\t}\n\t\tif (data->cursor_blink_enabled) {\n\t\t\tcmd |= HD44780_DISPLAY_MODE_CURSOR_BLINK_ON;\n\t\t}\n\t}\n\tdata->display_enabled = enabled;\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->display_enabled) {\n\t\tcmd |= HD44780_DISPLAY_MODE_DISPLAY_ON;\n\t}\n\tif (data->", "CodeBleu_score": 58.42013493982796}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev)    struct auxdisplay_itron_data *data = dev->data;\n    int ret = 0;\n    int busy_status = 0;\n\n    if (data->busy_gpio_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get(data->busy_gpio_port, data->busy_gpio_pin);\n    if (ret < 0) {\n        return ret;\n    }\n\n    busy_status = ret;\n    return busy_status;\n}\n", "CodeBleu_score": 54.57485483011002}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)    int rc;\n    struct auxdisplay_itron_data *data = dev->data;\n\n    if (!data->busy_gpio.port) {\n        return -ENOTSUP;\n    }\n\n    rc = gpio_pin_get(data->busy_gpio.port, data->busy_gpio.pin);\n    if (rc < 0) {\n        return rc;\n    }\n\n    return rc;\n}\n", "CodeBleu_score": 59.62853073595229}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)\tstruct auxdisplay_itron_data *data = dev->data;\n\tconst struct auxdisplay_itron_config *config = dev->config;\n\tint ret;\n\tint busy;\n\n\tif (config->busy_gpio_port == NULL) {\n\t\treturn -ENOTSUP;\n\t}\n\n\tret = gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tbusy = ret;\n\tif (busy) {\n\t\tLOG_DBG(\"Busy\");\n\t} else {\n\t\tLOG_DBG(\"Not busy\");\n\t}\n\n\treturn busy;\n}\n", "CodeBleu_score": 63.087494901808164}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tstruct auxdisplay_serlcd_data *data = dev->data;\n\tint ret;\n\n\tuint8_t buffer[2];\n\n\tbuffer[0] = data->config->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write(data->i2c_dev, buffer, sizeof(buffer), data->config->i2c_address);\n\tk_msleep(data->config->i2c_delay);\n\treturn ret;\n}\n", "CodeBleu_score": 51.75327841183102}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tint ret;\n\tuint8_t buffer[3];\n\tconst struct auxdisplay_serlcd_config *config = dev->config;\n\n\tbuffer[0] = config->special_command_prefix;\n\tbuffer[1] = command;\n\tbuffer[2] = 0;\n\n\tret = i2c_write(config->i2c_master, buffer, sizeof(buffer), config->i2c_slave_address);\n\tk_sleep(config->special_command_delay);\n\n\treturn ret;\n}\n", "CodeBleu_score": 61.04204809147019}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tstruct auxdisplay_serlcd_driver_data *data = dev->data;\n\tuint8_t buffer[2];\n\tint ret;\n\n\tbuffer[0] = data->special_command_prefix;\n\tbuffer[1] = command;\n\n\tret = i2c_write(data->i2c_dev, buffer, sizeof(buffer), data->i2c_addr);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to write to I2C device\");\n\t\treturn ret;\n\t}\n\n\tk_msleep(data->delay_after_special_command);\n\n\treturn 0;\n}\n", "CodeBleu_score": 49.70423911048751}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tstruct bbram_emul_data *data_dev = dev->data;\n\n\tif (offset > data_dev->size) {\n\t\tLOG_ERR(\"Offset is out of range\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((size + offset) > data_dev->size) {\n\t\tLOG_ERR(\"Size is out of range\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, &data_dev->data[offset], size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 44.51400847660819}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tstruct bbram_emul_data *data_emul = dev->data;\n\tuint8_t *buf = data_emul->buf;\n\tuint8_t *buf_end = buf + data_emul->size;\n\n\tif (offset + size > data_emul->size) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (data == NULL) {\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(data, buf + offset, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 50.51083398988065}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\tstruct bbram_emul_data *data_emul = dev->data;\n\tstruct bbram_emul_cfg *cfg = dev->config;\n\n\t/* Check if the read size is valid. */\n\tif (size == 0 || size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not exceed the memory bounds. */\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not involve invalid memory. */\n\tif ((offset < cfg->invalid_offset) ||\n\t    (offset + size > cfg->invalid_offset + cfg->invalid_size)) {\n\t\treturn -EFAULT;\n\t}\n\n\t/* Copy data from the specified offset in the device's memory to the\n\t * provided buffer.\n\t */\n\tmemcpy(data, &data_emul->mem[offset], size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 55.663875875569836}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *data_emul = dev->data;\n\tuint8_t *buf = data_emul->buf;\n\tuint8_t *buf_end = buf + BBRAM_EMUL_SIZE;\n\tint ret;\n\n\t/* Check if the write size is valid */\n\tif (size == 0 || size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state */\n\tif (data_emul->invalid) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tmemcpy(buf + offset, data, size);\n\n\t/* Write the data to the file */\n\tret = bbram_emul_write_file(dev, buf, BBRAM_EMUL_SIZE);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 47.48760514166897}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *data_p = dev->data;\n\tstruct bbram_emul_cfg *cfg = dev->config;\n\n\t/* Check if the write size is valid. */\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM. */\n\tif (offset + size > cfg->size) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is not in an invalid state. */\n\tif (data_p->state != BBRAM_EMUL_STATE_VALID) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory. */\n\tmemcpy(data_p->data + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 58.455772884602695}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\tstruct bbram_emul_data *data_dev = dev->data;\n\tuint8_t *bbram_data = data_dev->bbram_data;\n\tint ret = 0;\n\n\tif (offset + size > BBRAM_SIZE) {\n\t\tLOG_ERR(\"Write request exceeds BBRAM size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data_dev->invalid) {\n\t\tLOG_ERR(\"BBRAM is in invalid state\");\n\t\treturn -EIO;\n\t}\n\n\tif (offset < BBRAM_RESERVED_SIZE) {\n\t\tLOG_ERR(\"Write request is in reserved area\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(bbram_data + offset, data, size);\n\n\treturn ret;\n}\n", "CodeBleu_score": 48.83297018622321}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tconst struct device *dev;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device name missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = device_get_binding(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t*bbram_dev = dev;\n\n\treturn 0;\n}\n", "CodeBleu_score": 66.78920424878648}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tif (argc == 1) {\n\t\tLOG_ERR(\"Device not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tLOG_ERR(\"Device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 59.70969548140251}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tint ret;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Device not specified. Use \\\"bbram help\\\" for help.\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found.\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bbram_init(*bbram_dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to initialize %s.\", argv[1]);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 63.434426437407595}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev)\tint rx_count;\n\tint rx_remaining = h4_hdr_len - h4_hdr_read;\n\tuint8_t *hdr_buf = h4_hdr_buf;\n\n\trx_count = uart_fifo_read(dev, hdr_buf + h4_hdr_read, rx_remaining);\n\tif (rx_count < 0) {\n\t\tLOG_ERR(\"Error reading from UART: %d\", rx_count);\n\t} else {\n\t\th4_hdr_read += rx_count;\n\t}\n}\n", "CodeBleu_score": 32.939444545031776}, {"code": "static void h4_read_hdr(const struct device *dev)    struct h4_dev_data *const dev_data = DEV_DATA(dev);\n    uint8_t *hdr_buf = dev_data->hdr_buf;\n    uint8_t *hdr_buf_ptr = dev_data->hdr_buf_ptr;\n    uint8_t hdr_buf_len = dev_data->hdr_buf_len;\n    uint8_t hdr_buf_remaining = dev_data->hdr_buf_remaining;\n    uint8_t hdr_buf_len_read = dev_data->hdr_buf_len_read;\n    uint8_t hdr_buf_len_needed = dev_data->hdr_buf_len_needed;\n    uint8_t hdr_buf_len_to_read = hdr_buf_len - hdr_buf_len_read;\n    uint8_t hdr_buf_len_to_read_now = MIN(hdr_buf_len_to_read, hdr_buf_remaining);\n    uint8_t hdr_buf_len_read_now;\n\n    if (hdr_buf_len_to_read_now) {\n        hdr_buf_len_read_now = uart_fifo_read(dev, hdr_buf_ptr, hdr_buf_len_to_read_now);\n        if (hdr_buf_len_read_now) {\n            hdr_buf_ptr += hdr_buf_len_read_now;\n            hdr_buf_len_read += hdr_buf_len_read_now;\n            hdr_buf_remaining -= hdr_buf_len_read_now;\n            dev_data->hdr_buf_ptr = hdr_buf_ptr;\n            dev_data->hdr_buf_len_read = hdr_buf_len_read;\n            dev_data->hdr_buf_remaining = hdr_buf_remaining;\n        } else {\n            LOG_ERR(\"Error reading header from UART FIFO\");\n        }\n    }\n\n    if (hdr_buf_len_read", "CodeBleu_score": 36.80879188660667}, {"code": "static void h4_read_hdr(const struct device *dev)\tint rc;\n\tint bytes_read = 0;\n\tint bytes_remaining = h4_hdr_len - h4_hdr_read;\n\tint bytes_to_read = bytes_remaining;\n\tif (bytes_remaining > H4_BUF_SIZE) {\n\t\tbytes_to_read = H4_BUF_SIZE;\n\t}\n\trc = uart_fifo_read(dev, h4_buf, bytes_to_read);\n\tif (rc < 0) {\n\t\tLOG_ERR(\"Error reading from UART: %d\", rc);\n\t} else {\n\t\tbytes_read = rc;\n\t\th4_hdr_read += bytes_read;\n\t}\n}\n", "CodeBleu_score": 41.32004818791467}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len)\tuint8_t buf[33];\n\tsize_t read;\n\n\tread = uart_fifo_read(uart, buf, sizeof(buf));\n\tif (read == 0) {\n\t\tLOG_ERR(\"Failed to read from UART\");\n\t}\n\n\treturn read;\n}\n", "CodeBleu_score": 40.50161056874244}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)\tint rc;\n\tuint8_t buf[33];\n\tsize_t read = 0;\n\n\twhile (len > 0) {\n\t\tsize_t n = len;\n\n\t\tif (n > sizeof(buf)) {\n\t\t\tn = sizeof(buf);\n\t\t}\n\n\t\trc = uart_fifo_read(uart, buf, n);\n\t\tif (rc < 0) {\n\t\t\tLOG_ERR(\"UART read failed: %d\", rc);\n\t\t\treturn 0;\n\t\t}\n\n\t\tread += rc;\n\t\tlen -= rc;\n\t}\n\n\treturn read;\n}\n", "CodeBleu_score": 37.274351941901976}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)    uint8_t tmp[33];\n    size_t read;\n    int err;\n\n    err = uart_fifo_read(uart, tmp, sizeof(tmp), &read);\n    if (err) {\n        LOG_ERR(\"Failed to read from UART: %d\", err);\n        return 0;\n    }\n\n    return read;\n}\n", "CodeBleu_score": 52.17995389199811}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    uint8_t i;\n    uint8_t highest = 0xff;\n    uint8_t priority;\n    struct zbus_observer *obs;\n\n    for (i = 0; i < ZBUS_CHANNEL_OBSERVER_COUNT; i++) {\n        obs = &chan->observers[i];\n        if (obs->enabled) {\n            priority = obs->priority;\n            if (priority < highest) {\n                highest = priority;\n            }\n        }\n    }\n\n    chan->highest_observer_priority = highest;\n}\n", "CodeBleu_score": 29.59657669675801}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tstruct zbus_observer *obs;\n\tuint32_t highest_prio = 0;\n\n\tchan_lock(chan);\n\n\tobs = chan->observer_list;\n\twhile (obs != NULL) {\n\t\tif (obs->priority < highest_prio && obs->enabled) {\n\t\t\thighest_prio = obs->priority;\n\t\t}\n\t\tobs = obs->next;\n\t}\n\n\tchan->highest_observer_priority = highest_prio;\n\n\tchan_unlock(chan);\n}\n", "CodeBleu_score": 21.161546116073225}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    uint32_t highest_prio = UINT32_MAX;\n    bool enabled = false;\n    for (size_t i = 0; i < chan->observer_count; i++) {\n        struct zbus_observer *obs = chan->observers[i];\n        if (obs->enabled) {\n            enabled = true;\n            if (obs->priority < highest_prio) {\n                highest_prio = obs->priority;\n            }\n        }\n    }\n    chan->highest_observer_priority = highest_prio;\n    chan->enabled = enabled;\n}\n", "CodeBleu_score": 27.729792180047948}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)\tfor (uint8_t i = 0; i < ZBUS_CHANNELS; i++) {\n\t\tif (zbus_channels[i].observer == obs) {\n\t\t\tupdate_channel_hop(&zbus_channels[i]);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 16.400159763297346}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct zbus_channel *ch;\n    struct zbus_channel_observer *ch_obs;\n    LIST_FOREACH(ch, &channels, next) {\n        ch_obs = &ch->observers[ch->num_observers];\n        if (ch_obs->observer == obs) {\n            update_channel(ch, ch_obs);\n        }\n    }\n}\n", "CodeBleu_score": 20.945600394887435}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct zbus_channel *ch;\n    struct zbus_channel_observation *obs_ch;\n\n    SLIST_FOREACH(ch, &zbus_channels, next) {\n        SLIST_FOREACH(obs_ch, &ch->observations, next) {\n            if (obs_ch->observer == obs) {\n                update_channel(ch);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 19.061040813748647}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)\tif (z_is_in_isr()) {\n\t\treturn -1;\n\t}\n\tif (obs == NULL) {\n\t\treturn -1;\n\t}\n\tk_spinlock_key_t key = k_spin_lock(&zbus_lock);\n\tobs->prio = z_thread_priority_get(k_current_get());\n\tfor (int i = 0; i < obs->channels.len; i++) {\n\t\tstruct zbus_channel *ch = obs->channels.data[i];\n\t\tch->prio = obs->prio;\n\t}\n\tk_spin_unlock(&zbus_lock, key);\n\treturn 0;\n}\n", "CodeBleu_score": 36.69437373763261}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    if (z_is_in_isr()) {\n        return -1;\n    }\n    if (obs == NULL) {\n        return -1;\n    }\n    z_spin_lock(&obs->lock);\n    z_thread_set_priority(obs->thread, Z_THREAD_PRIORITY_MIN);\n    zbus_chan_set_priority(obs->chan, Z_THREAD_PRIORITY_MIN);\n    z_spin_unlock(&obs->lock);\n    return 0;\n}\n", "CodeBleu_score": 43.065869406629595}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    if (z_is_in_isr()) {\n        return -1;\n    }\n    if (!obs) {\n        return -1;\n    }\n    z_spinlock_acquire(&obs->lock);\n    obs->priority = Z_THREAD_PRIORITY_MIN;\n    for (int i = 0; i < Z_CHANNEL_MAX_CHANNELS; i++) {\n        if (obs->channels[i]) {\n            obs->channels[i]->observer_priority = obs->priority;\n        }\n    }\n    z_spinlock_release(&obs->lock);\n    return 0;\n}\n", "CodeBleu_score": 39.970890660588296}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)\tint ret;\n\tk_spinlock_key_t key;\n\tstruct zbus_chan_ctx *ctx;\n\tstruct zbus_chan_ctx *next;\n\tstruct zbus_chan_ctx *prev;\n\tk_timeout_t end;\n\n\tif (!chan) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_is_in_isr()) {\n\t\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\t\treturn -EBUSY;\n\t\t}\n\t\ttimeout = Z_TIMEOUT_TICKS(timeout);\n\t}\n\n\tkey = k_spin_lock(&chan->lock);\n\n\tif (chan->ctx_head) {\n\t\tctx = chan->ctx_head;\n\t\tif (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (K_TIMEOUT_EQ(timeout, K_FOREVER)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t\tend = k_uptime_get() + timeout;\n\t\twhile (1) {\n\t\t\tif (ctx->prio == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (k_uptime_get() > end) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tctx = ctx->next;\n\t\t\tif (ctx == chan->ctx_head) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tctx->prio = 1;\n\t\tret = 0;\n\t} else {\n\t\tctx = &chan->ctx;\n\t\tctx->prio = 1;\n\t\tret = 0;\n\t}\n\n", "CodeBleu_score": 35.617498921879054}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)    ZBUS_CHECK_NULL_PARAM(chan);\n    k_timeout_t _timeout = timeout;\n    if (k_is_in_isr()) {\n        _timeout = K_NO_WAIT;\n    }\n    struct zbus_chan_notify_context ctx = {\n        .chan = chan,\n        .timeout = _timeout,\n        .priority = k_is_in_isr(),\n        .err = 0,\n    };\n    k_mutex_lock(&chan->lock, _timeout);\n    if (ctx.err) {\n        return ctx.err;\n    }\n    if (chan->notify) {\n        chan->notify(chan, &ctx);\n    }\n    k_mutex_unlock(&chan->lock);\n    return ctx.err;\n}\n", "CodeBleu_score": 31.391668564016616}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)    if (chan == NULL) {\n        return -EINVAL;\n    }\n\n    k_timeout_t to = timeout;\n    if (k_is_in_isr()) {\n        to = K_NO_WAIT;\n    }\n\n    struct zbus_chan_ctx ctx = {\n        .prio = -1,\n        .end = k_uptime_get_32() + k_timeout_ticks(to),\n    };\n\n    k_spinlock_key_t key = k_spin_lock(&chan->lock);\n\n    int err = zbus_chan_notify_locked(chan, &ctx);\n\n    k_spin_unlock(&chan->lock, key);\n\n    return err;\n}\n", "CodeBleu_score": 37.07160020743186}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tuint32_t temp;\n\tif (Int & 0x80000000) {\n\t\tif (enable) {\n\t\t\ttemp = ETH->INTEN |= (Int & 0x7FFFFFFF);\n\t\t} else {\n\t\t\ttemp = ETH->INTEN & (~Int);\n\t\t}\n\t} else {\n\t\tif (enable) {\n\t\t\ttemp = ETH->INTENA |= Int;\n\t\t} else {\n\t\t\ttemp = ETH->INTENA & (~Int);\n\t\t}\n\t}\n\tETH->INTEN = temp;\n}\n", "CodeBleu_score": 34.81868928507473}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)  uint32_t tmp = 0;\n\n  /* Check the parameters */\n  assert_param(IS_ETH_IT(Int));\n  assert_param(IS_BOOL(enable));\n\n  /* Check the interrupt enable flag */\n  if (enable) {\n    /* Check if the interrupt is normal or abnormal */\n    if (Int & 0x80000000) {\n      /* Get the normal interrupt enable register value */\n      tmp = ETH->EIMR;\n      /* Set the normal interrupts */\n      tmp |= Int;\n      /* Write back the normal interrupts */\n      ETH->EIMR = tmp;\n    } else {\n      /* Get the abnormal interrupt enable register value */\n      tmp = ETH->EIMR;\n      /* Set the abnormal interrupts */\n      tmp |= Int;\n      /* Write back the abnormal interrupts */\n      ETH->EIMR = tmp;\n    }\n  } else {\n    /* Check if the interrupt is normal or abnormal */\n    if (Int & 0x80000000) {\n      /* Get the normal interrupt enable register value */\n      tmp = ETH->EIMR;\n      /* Clear the normal interrupts */\n      tmp &= ~Int;\n      /* Write back the normal interrupts */\n      ETH->EIMR = tmp;\n    } else {\n      /* Get the abnormal interrupt enable register value */\n      tmp = ETH->EIMR;\n      /* Clear the abnormal interrupts */\n      tmp &= ~Int;\n      /* Write back the abnormal interrupts */\n      ETH->EIMR = tmp;\n    }\n  }\n}\n", "CodeBleu_score": 48.7382706195067}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)  uint32_t tmpreg = 0;\n  /* Check the parameters */\n  assert_param(IS_ETH_IT(Int));\n  assert_param(IS_BOOL(enable));\n  if (enable) {\n    /* Enable the selected interrupts */\n    tmpreg = ETH->INT_EN;\n    /* Check if the selected interrupt is abnormal or normal */\n    if ((Int & 0x80000000) != (uint32_t)RESET) {\n      /* Enable the selected abnormal interrupts */\n      tmpreg |= (Int & 0x7FFFFFFF);\n    } else {\n      /* Enable the selected normal interrupts */\n      tmpreg |= Int;\n    }\n    /* Write to ETH INT_EN */\n    ETH->INT_EN = tmpreg;\n  } else {\n    /* Disable the selected interrupts */\n    tmpreg = ETH->INT_EN;\n    /* Check if the selected interrupt is abnormal or normal */\n    if ((Int & 0x80000000) != (uint32_t)RESET) {\n      /* Disable the selected abnormal interrupts */\n      tmpreg &= ~(Int & 0x7FFFFFFF);\n    } else {\n      /* Disable the selected normal interrupts */\n      tmpreg &= ~Int;\n    }\n    /* Write to ETH INT_EN */\n    ETH->INT_EN = tmpreg;\n    /* Clear the selected interrupt pending bits */\n    ETH->INT_ST = Int;\n  }\n}\n", "CodeBleu_score": 45.66690095174508}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)  ETH_TX_DESC *txdesc;\n  uint32_t first, nxtdesc;\n  uint32_t i;\n\n  /* Get the first Tx descriptor address of the list */\n  first = (uint32_t)ETH->TDESAR;\n\n  /* Search for a free descriptor */\n  do {\n    /* Point to the next descriptor */\n    txdesc = (ETH_TX_DESC *)(first);\n    nxtdesc = (uint32_t)txdesc->Buffer2NextDescAddr;\n\n    /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */\n    if ((txdesc->Status & ETH_DMATXDESC_OWN) == (uint32_t)RESET) {\n      /* Check if the descriptor is the first descriptor of the segment */\n      if ((txdesc->Status & ETH_DMATXDESC_FS) != (uint32_t)RESET) {\n        /* Check if previous segment is available */\n        if (ETH->TDESAR != (uint32_t)RESET) {\n          return ((ETH_TX_DESC *)(ETH->TDESAR));\n        } else {\n          return (txdesc);\n        }\n      } else {\n        return (txdesc);\n      }\n    }\n\n    /* Set the first as the current descriptor */\n    first = nxtdesc;\n\n    /* Increment number of attempts */\n    i++;\n  } while ((i < ETH_TXBUFNB) && (first != (uint32_t)RESET));\n\n  /* There are no free descriptors */\n  return ((ETH_TX_DESC *)(uint32_t)RESET);\n}\n", "CodeBleu_score": 42.96388951650445}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)\tETH_TX_DESC *pTxDesc = (ETH_TX_DESC *)ETH_BASE_ADDR + ETH_TX_DESC_BASE;\n\tuint32_t i;\n\n\tfor (i = 0; i < ETH_TX_DESC_CNT; i++) {\n\t\tif ((pTxDesc->tdes0 & ETH_TX_DESC_OWN) == 0) {\n\t\t\treturn pTxDesc;\n\t\t}\n\t\tpTxDesc++;\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 29.64440383672447}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)    ETH_TX_DESC *txDesc;\n\n    /* Get the first free descriptor */\n    txDesc = ETH_TX_DESC_BASE;\n    while (txDesc->status & ETH_TX_DESC_OWN) {\n        txDesc++;\n        if (txDesc == (ETH_TX_DESC_BASE + ETH_TX_DESC_COUNT)) {\n            txDesc = ETH_TX_DESC_BASE;\n        }\n    }\n\n    return txDesc;\n}\n", "CodeBleu_score": 41.337832417124886}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n    RT_ASSERT(channel < CYP_ADC_CHANNEL_NUM);\n\n    struct cyp_adc_device *cyp_adc_device = (struct cyp_adc_device *)device->parent.user_data;\n    cy_rslt_t result;\n\n    if (cyp_adc_device->cyp_adc_channel[channel].cyp_adc_channel_id == CY_CAPSENSE_INVALID_CHANNEL) {\n        LOG_E(\"ADC channel %d is not initialized\", channel);\n        return -RT_ERROR;\n    }\n\n    result = Cy_CSDADC_SetValue(cyp_adc_device->cyp_adc_channel[channel].cyp_adc_channel_id, *value);\n    if (result != CY_RSLT_SUCCESS) {\n        LOG_E(\"ADC channel %d set value failed\", channel);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 53.08944873802437}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    csd_dac_chan_config_t *dac_config;\n    csd_dac_chan_config_t *dac_config_ptr;\n    cy_en_csd_status_t status;\n\n    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    dac_config = (csd_dac_chan_config_t *)device->config.user_data;\n    RT_ASSERT(dac_config != RT_NULL);\n\n    dac_config_ptr = &dac_config[channel];\n    RT_ASSERT(dac_config_ptr != RT_NULL);\n\n    status = Cy_CSD_DAC_Init(dac_config_ptr);\n    if (status != CY_CSD_SUCCESS) {\n        LOG_E(\"DAC init failed, error code: %d\", status);\n        return RT_ERROR;\n    }\n\n    status = Cy_CSD_DAC_OutputEnable(dac_config_ptr, *value);\n    if (status != CY_CSD_SUCCESS) {\n        LOG_E(\"DAC output enable failed, error code: %d\", status);\n        return RT_ERROR;\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 51.14522841896466}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    cy_rslt_t result = CY_RSLT_SUCCESS;\n    cy_csd_dac_channel_t dac_channel;\n    cy_stc_csd_dac_config_t dac_config;\n    struct cyp_dac_device *cyp_dac_device = (struct cyp_dac_device *)device;\n\n    RT_ASSERT(cyp_dac_device != RT_NULL);\n\n    dac_channel = (cy_csd_dac_channel_t)channel;\n\n    /* Initialize the DAC configuration structure */\n    cy_stc_csd_dac_config_t_init(&dac_config);\n\n    /* Initialize the DAC configuration structure */\n    dac_config.dacGain = CY_CSD_DAC_GAIN_1;\n    dac_config.dacRef = CY_CSD_DAC_REF_VREF;\n    dac_config.dacFormat = CY_CSD_DAC_FORMAT_UNSIGNED12;\n    dac_config.dacSrc = CY_CSD_DAC_SRC_INTERNAL;\n    dac_config.dacLfsrOutput = false;\n    dac_config.dacOutputMode = CY_CSD_DAC_OUTPUT_NORMAL;\n\n    /* Initialize the DAC */\n    result = Cy_CSD_DAC_Init(cyp_dac_device->base, dac_channel, &dac_config);\n\n    if (result != CY_RSLT_SUCCESS) {\n        rt_kprintf(\"Failed to initialize the DAC.\\n\");\n        return RT_ERROR;\n    }\n\n    /* Enable the DAC */\n    result = Cy_CSD_DAC_OutputEnable(cyp_dac_device->base, dac_channel, *value);\n\n    if (result != CY_RSLT_SUCCESS) {\n        rt_kprintf(\"Failed to enable the DAC.\\n\");\n        return RT_ERROR;\n    }\n\n", "CodeBleu_score": 46.31976575939011}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\tint ret = RT_EOK;\n\trt_uint32_t end_addr;\n\n\tif (addr + size > IFX_FLASH_SIZE) {\n\t\tLOG_E(\"Read operation would exceed flash memory end address!\\n\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tend_addr = addr + size;\n\tfor (; addr < end_addr; addr++) {\n\t\t*buf++ = *(rt_uint8_t *)addr;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 35.97349756851288}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)    if (addr + size > FLASH_END_ADDRESS) {\n        return -RT_EINVAL;\n    }\n\n    ifx_flash_read(addr, buf, size);\n\n    return size;\n}\n", "CodeBleu_score": 23.857008007789222}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)\tint ret = 0;\n\n\tif (addr + size > IFX_FLASH_END_ADDRESS) {\n\t\tLOG_E(\"Reading beyond flash memory end address! (0x%08X)\", addr + size);\n\t\treturn -RT_EINVAL;\n\t}\n\n\tif (size == 0) {\n\t\treturn 0;\n\t}\n\n\tif (size % 4 != 0) {\n\t\tLOG_E(\"Size must be a multiple of 4!\");\n\t\treturn -RT_EINVAL;\n\t}\n\n\tfor (int i = 0; i < size; i += 4) {\n\t\t*(rt_uint32_t *) (buf + i) = *(rt_uint32_t *) (addr + i);\n\t}\n\n\treturn size;\n}\n", "CodeBleu_score": 43.435743671877304}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    uint32_t count;\n\n    RT_ASSERT(timer != RT_NULL);\n    RT_ASSERT(timer->parent.user_data != RT_NULL);\n\n    count = cyhal_timer_read((cyhal_timer_t *)timer->parent.user_data);\n\n    return count;\n}\n", "CodeBleu_score": 59.15007674613304}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)    cyhal_timer_t *obj = (cyhal_timer_t *)timer->parent.user_data;\n    return cyhal_timer_read(obj);\n}\n", "CodeBleu_score": 20.615279200213145}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)  rt_uint32_t count;\n\n  RT_ASSERT(timer != RT_NULL);\n\n  count = cyhal_timer_read(&timer->timer);\n\n  return count;\n}\n", "CodeBleu_score": 48.45344806616033}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void)    while (1) {\n        if (pthread_mutex_trylock(&dfs_lock_mutex) == 0) {\n            return;\n        }\n        if (errno != EBUSY) {\n            assert(0);\n        }\n        usleep(100000);\n    }\n}\n", "CodeBleu_score": 24.675054202226296}, {"code": "void dfs_lock(void)  /*\n   * This is the default implementation, which uses a mutex.\n   * It is not necessary to implement this function.\n   */\n  pthread_mutex_lock(&dfs_mutex);\n}\n", "CodeBleu_score": 7.504672064772477}, {"code": "void dfs_lock(void)\tint result;\n\t\n\t/* Attempt to take the lock. */\n\tresult = pthread_mutex_lock(&dfs_lock_mutex);\n\t\n\t/* If the lock was busy, wait for it to become available. */\n\twhile (result == EBUSY) {\n\t\tresult = pthread_mutex_trylock(&dfs_lock_mutex);\n\t}\n\t\n\t/* If the lock acquisition failed for any other reason, trigger an assertion failure. */\n\tif (result != 0) {\n\t\tfprintf(stderr, \"DFS lock acquisition failed.\\n\");\n\t\tassert(0);\n\t}\n}\n", "CodeBleu_score": 39.79903449440477}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint i;\n\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\tif (fdt->fd[i] == NULL)\n\t\t\treturn i;\n\t}\n\tif (fdt->maxfd == fdt->size) {\n\t\t/* Expand the fd table */\n\t\tint newsize = fdt->size * 2;\n\t\tstruct file **newfd = kmalloc(sizeof(struct file *) * newsize);\n\t\tif (newfd == NULL)\n\t\t\treturn -1;\n\t\tmemcpy(newfd, fdt->fd, sizeof(struct file *) * fdt->size);\n\t\tkfree(fdt->fd);\n\t\tfdt->fd = newfd;\n\t\tfdt->size = newsize;\n\t}\n\treturn fdt->maxfd++;\n}\n", "CodeBleu_score": 32.31479711878299}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint i;\n\tint fd;\n\n\t/* Search for an empty slot starting from the specified index */\n\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\tif (fdt->fd_array[i] == NULL) {\n\t\t\tfd = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == fdt->maxfd) {\n\t\t/* No empty slot is found. Expand the fd table */\n\t\tif (fd_table_expand(fdt) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfd = fdt->maxfd - 1;\n\t}\n\n\treturn fd;\n}\n", "CodeBleu_score": 38.64510317709785}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)\tint fd;\n\tint i;\n\n\tfor (i = startfd; i < fdt->maxfd; i++) {\n\t\tif (fdt->fd_array[i] == NULL) {\n\t\t\tfd = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == fdt->maxfd) {\n\t\t/* No empty slot found, expand the fd table */\n\t\tif (fd_table_expand(fdt) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn fd;\n}\n", "CodeBleu_score": 37.05918994596216}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error)    rt_int32_t i;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (i = 0; i < sizeof(error_tab) / sizeof(error_tab[0]); i++) {\n        if (error_tab[i].value == error) {\n            return error_tab[i].desc;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}\n", "CodeBleu_score": 61.18485911350764}, {"code": "const char *rt_strerror(rt_err_t error)    rt_int32_t index;\n\n    if (error < 0)\n        error = -error;\n\n    for (index = 0; index < sizeof(error_tab) / sizeof(error_tab[0]); index ++) {\n        if (error_tab[index].err_code == error)\n            return error_tab[index].err_str;\n    }\n\n    return \"EUNKNOWN\";\n}\n", "CodeBleu_score": 60.591445325309266}, {"code": "const char *rt_strerror(rt_err_t error)    rt_uint32_t index;\n\n    if (error < 0) {\n        error = -error;\n    }\n\n    for (index = 0; index < sizeof(error_tab) / sizeof(error_tab[0]); index++) {\n        if (error_tab[index].value == error) {\n            return error_tab[index].desc;\n        }\n    }\n\n    return \"EUNKNOWN\";\n}\n", "CodeBleu_score": 54.883520023871}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_base_t lock;\n    rt_err_t result;\n    rt_uint8_t i;\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* try to find an empty slot */\n    for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_thread_idle_hook_list[i] == RT_NULL) {\n            rt_thread_idle_hook_list[i] = hook;\n            result = RT_EOK;\n            goto __exit;\n        }\n    }\n\n    /* no empty slot */\n    result = -RT_EFULL;\n", "CodeBleu_score": 59.36098975248867}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\trt_base_t level;\n\trt_err_t result = RT_EOK;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* find an empty slot */\n\tfor (int i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (rt_thread_idle_hook_list[i] == RT_NULL) {\n\t\t\trt_thread_idle_hook_list[i] = hook;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* find no empty slot */\n\tif (i == RT_IDLE_HOOK_LIST_SIZE) {\n\t\tresult = -RT_EFULL;\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 47.07063625350575}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_base_t level;\n    rt_err_t result = RT_EFULL;\n\n    level = rt_hw_interrupt_disable();\n\n    for (int i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n        if (rt_thread_idle_hook_list[i] == RT_NULL) {\n            rt_thread_idle_hook_list[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}\n", "CodeBleu_score": 55.13188573459611}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))  rt_err_t result;\n  rt_base_t lock;\n  rt_thread_idle_hook_t *iter;\n\n  result = RT_EOK;\n  lock = rt_hw_interrupt_disable();\n  for (iter = rt_thread_idle_hook_list; iter != RT_NULL; iter = iter->next) {\n    if (iter->hook == hook) {\n      iter->hook = RT_NULL;\n      break;\n    }\n  }\n  if (iter == RT_NULL) {\n    result = -RT_ERROR;\n  }\n  rt_hw_interrupt_enable(lock);\n  return result;\n}\n", "CodeBleu_score": 43.03635883288459}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_base_t lock;\n    rt_err_t result = RT_EOK;\n    register rt_thread_t tid;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    /* disable interrupt */\n    lock = rt_hw_interrupt_disable();\n\n    /* find thread idle object */\n    tid = rt_thread_self();\n\n    /* remove hook */\n    if (tid->idle == hook) {\n        tid->idle = RT_NULL;\n    }\n    else {\n        result = -RT_ERROR;\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(lock);\n\n    return result;\n}\n", "CodeBleu_score": 23.78415449294583}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))\trt_err_t result;\n\trt_base_t level;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\t/* disable interrupt */\n\tlevel = rt_hw_interrupt_disable();\n\n\t/* check whether the hook is in the idle hook list */\n\tfor (int i = 0; i < RT_THREAD_IDLE_HOOK_LIST_SIZE; i++) {\n\t\tif (rt_thread_idle_hook_list[i] == hook) {\n\t\t\t/* set the entry to null */\n\t\t\trt_thread_idle_hook_list[i] = RT_NULL;\n\t\t\tresult = RT_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* if not found, set the result to error */\n\tif (i == RT_THREAD_IDLE_HOOK_LIST_SIZE) {\n\t\tresult = -RT_ERROR;\n\t}\n\n\t/* enable interrupt */\n\trt_hw_interrupt_enable(level);\n\n\treturn result;\n}\n", "CodeBleu_score": 57.265270656383514}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    struct rt_thread *thread;\n    struct rt_list_node *node;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* ensure the scheduler is unlocked */\n    RT_DEBUG_NOT_IN_SCHEDULE;\n\n    /* suspend the current thread */\n    rt_thread_suspend(rt_thread_self());\n\n    /* check suspend list */\n    if (rt_list_isempty(susp_list)) {\n        /* resume self */\n        rt_thread_resume(rt_thread_self());\n\n        return RT_EOK;\n    }\n\n    /* wakeup all suspended thread */\n    for (node = susp_list->next; node != susp_list; node = node->next) {\n        thread = rt_list_entry(node, struct rt_thread, tlist);\n\n        /* remove thread from suspend list */\n        rt_list_remove(&thread->tlist);\n\n        /* resume thread */\n        thread->error = thread_error;\n        rt_thread_resume(thread);\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 43.8723674316081}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_thread_t thread;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* make sure the scheduler is unlocked */\n    RT_DEBUG_NOT_IN_SCHEDULER;\n\n    /* resume all suspended threads in the list */\n    while (!rt_list_isempty(susp_list)) {\n        /* get next suspended thread */\n        thread = rt_list_entry(susp_list->next, struct rt_thread, tlist);\n        /* remove thread from suspended list */\n        rt_list_remove(&(thread->tlist));\n        /* resume thread */\n        rt_thread_resume(thread);\n        /* set error code to thread */\n        thread->error = thread_error;\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 39.214932640651426}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    struct rt_thread *thread;\n    rt_list_t *list;\n\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* ensure scheduler unlocked */\n    RT_DEBUG_NOT_IN_SCHEDULE;\n\n    /* check parameters */\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* get suspended list */\n    list = susp_list;\n\n    /* resume all suspended threads */\n    while (!rt_list_isempty(list)) {\n        /* get thread entry */\n        thread = rt_list_entry(list->next, struct rt_thread, tlist);\n\n        /* remove thread from suspended list */\n        rt_list_remove(&(thread->tlist));\n\n        /* resume thread */\n        rt_thread_resume(thread);\n\n        /* set error code */\n        thread->error = thread_error;\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 41.322663539464465}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t dev_old, dev_new;\n\n    /* get current console device */\n    dev_old = rt_console_get_device();\n\n    /* find new console device */\n    dev_new = rt_device_find(name);\n    if (dev_new == RT_NULL) {\n        return RT_NULL;\n    }\n\n    if (dev_new == dev_old) {\n        return dev_old;\n    }\n\n    /* close old console device */\n    if (dev_old != RT_NULL) {\n        rt_device_close(dev_old);\n    }\n\n    /* open new console device */\n    if (rt_device_open(dev_new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return RT_NULL;\n    }\n\n    /* set new console device */\n    rt_console_set_device(dev_new);\n\n    return dev_old;\n}\n", "CodeBleu_score": 60.02271529699588}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    if (name == RT_NULL) return RT_NULL;\n\n    old_console = rt_console_get_device();\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) return RT_NULL;\n\n    if (new_console != old_console) {\n        if (old_console != RT_NULL) {\n            rt_device_close(old_console);\n        }\n        rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        rt_console_set_device(new_console);\n    }\n\n    return old_console;\n}\n", "CodeBleu_score": 52.7726647820282}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t old_console = RT_NULL;\n    rt_device_t new_console = RT_NULL;\n\n    if (name == RT_NULL) {\n        return RT_NULL;\n    }\n\n    /* get current console device */\n    old_console = rt_console_get_device();\n\n    /* find new console device */\n    new_console = rt_device_find(name);\n    if (new_console == RT_NULL) {\n        return old_console;\n    }\n\n    /* if new console device is not same as old console device */\n    if (new_console != old_console) {\n        /* close old console device */\n        if (old_console != RT_NULL) {\n            rt_device_close(old_console);\n        }\n\n        /* open new console device */\n        if (rt_device_open(new_console, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_OFLAG_STREAM) != RT_EOK) {\n            return old_console;\n        }\n\n        /* set new console device */\n        rt_console_set_device(new_console);\n    }\n\n    return old_console;\n}\n", "CodeBleu_score": 53.23459650506906}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type)\tint count = 0;\n\tstruct rt_object_information *information;\n\tregister rt_base_t temp;\n\n\tinformation = rt_object_get_information(type);\n\tif (information == RT_NULL)\n\t\treturn 0;\n\n\trt_enter_critical();\n\t/* lock object list */\n\ttemp = information->object_list->lock;\n\tinformation->object_list->lock = 1;\n\n\t/* iterate object list */\n\tcount = 0;\n\t{\n\t\tregister struct rt_object *object;\n\n\t\tfor (object = information->object_list->object_list; object != RT_NULL; object = object->list_node.next)\n\t\t\tcount ++;\n\t}\n\n\t/* unlock object list */\n\tinformation->object_list->lock = temp;\n\trt_exit_critical();\n\n\treturn count;\n}\n", "CodeBleu_score": 46.00000388282086}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tint length = 0;\n\tstruct rt_object *object;\n\tregister rt_base_t temp;\n\n\tRT_DEBUG_NOT_IN_INTERRUPT;\n\n\tobject = rt_object_get_first(type);\n\n\t/* lock scheduler */\n\ttemp = rt_enter_critical();\n\n\twhile (object != RT_NULL)\n\t{\n\t\tlength ++;\n\t\tobject = object->next;\n\t}\n\n\t/* unlock scheduler */\n\trt_exit_critical(temp);\n\n\treturn length;\n}", "CodeBleu_score": 32.471120935234275}, {"code": "int rt_object_get_length(enum rt_object_class_type type)\tregister rt_base_t temp;\n\tregister rt_object_t object;\n\tregister rt_uint16_t counter;\n\n\tcounter = 0U;\n\n\t/* lock the object list */\n\trt_enter_critical();\n\n\t/* get the first object */\n\tobject = rt_object_table[type].object_list;\n\n\twhile (object != RT_NULL) {\n\t\tcounter ++;\n\t\tobject = object->next;\n\t}\n\n\t/* unlock the object list */\n\trt_exit_critical();\n\n\treturn counter;\n}\n", "CodeBleu_score": 33.234671850151365}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object)    rt_base_t lock_result;\n    rt_object_t object_next;\n    struct rt_object_information *information;\n\n    /* parameter check */\n    RT_ASSERT(object != RT_NULL);\n\n    /* get object information */\n    information = (struct rt_object_information *)object;\n\n    /* lock object */\n    lock_result = rt_hw_interrupt_disable();\n\n    /* remove object from object list */\n    object_next = information->object_list_next;\n    if (object_next != RT_NULL)\n    {\n        object_next->information->object_list_prev = information->object_list_prev;\n    }\n    *(information->object_list_prev) = object_next;\n\n    /* unlock object */\n    rt_hw_interrupt_enable(lock_result);\n\n    /* set object type to unknown */\n    object->type = RT_Object_Unknown;\n\n    /* invoke object detach hook */\n    if (rt_object_detach_hook != RT_NULL)\n    {\n        rt_object_detach_hook(object);\n    }\n}\n", "CodeBleu_score": 50.44361420411274}, {"code": "void rt_object_detach(rt_object_t object)    rt_list_t *list;\n    rt_base_t lock_result;\n\n    RT_ASSERT(object != RT_NULL);\n\n    /* check object type */\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* get object list */\n    list = &(rt_object_container[object->type]);\n\n    /* lock object list */\n    lock_result = rt_hw_interrupt_disable();\n    if (rt_list_isempty(list)) {\n        rt_hw_interrupt_enable(lock_result);\n        return;\n    }\n\n    /* remove object from list */\n    rt_list_remove(&(object->list));\n\n    /* unlock object list */\n    rt_hw_interrupt_enable(lock_result);\n\n    /* set object type */\n    object->type = 0;\n\n    return;\n}\n", "CodeBleu_score": 43.35589303418374}, {"code": "void rt_object_detach(rt_object_t object)    register rt_list_t *list;\n    register rt_base_t temp;\n    register rt_object_t obj;\n\n    /* parameter check */\n    if (object == RT_NULL)\n        return;\n\n    /* call object detach hook */\n    if (object->type != RT_Object_Class_Unknown)\n        rt_object_detach_hook(object);\n\n    /* get object list */\n    list = &(rt_object_container[object->type]);\n\n    /* disable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* remove object from object list */\n    for (obj = (rt_object_t)list->next; obj != (rt_object_t)list; obj = (rt_object_t)obj->list.next) {\n        if (obj == object) {\n            rt_list_remove(&(object->list));\n            break;\n        }\n    }\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(temp);\n\n    /* set object type */\n    object->type = RT_Object_Class_Unknown;\n}\n", "CodeBleu_score": 43.9250865029575}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)\trt_err_t err;\n\trt_custom_object_t co;\n\trt_custom_object_destroy_t destroy;\n\n\tif (obj == NULL) {\n\t\treturn RT_ERR_NULL_POINTER;\n\t}\n\n\tif (obj->type != RT_OBJECT_TYPE_CUSTOM) {\n\t\treturn RT_ERR_INVALID_ARG;\n\t}\n\n\tco = (rt_custom_object_t) obj;\n\tdestroy = co->destroy;\n\n\tif (destroy != NULL) {\n\t\terr = destroy(co);\n\t} else {\n\t\terr = RT_ERR_OK;\n\t}\n\n\trt_free(co);\n\n\treturn err;\n}\n", "CodeBleu_score": 42.24112852449711}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t ret = RT_EOK;\n    rt_custom_object_t object;\n\n    if (obj == RT_NULL) {\n        return -RT_EEMPTY;\n    }\n\n    if (obj->type != RT_Object_Class_Custom) {\n        return -RT_ERROR;\n    }\n\n    object = (rt_custom_object_t)obj;\n\n    if (object->destroy) {\n        ret = object->destroy(object);\n    }\n\n    rt_free(object);\n\n    return ret;\n}\n", "CodeBleu_score": 52.52048729205268}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t ret = RT_EOK;\n    rt_custom_object_t co = (rt_custom_object_t)obj;\n\n    /* check object */\n    RT_ASSERT(co != RT_NULL);\n\n    /* check object type */\n    RT_ASSERT(rt_object_get_type(&co->parent) == RT_Object_Class_Custom);\n\n    /* check object parent */\n    RT_ASSERT(rt_object_is_systemobject(&co->parent));\n\n    /* check destroy method */\n    RT_ASSERT(co->destroy != RT_NULL);\n\n    /* call destroy method */\n    ret = co->destroy(co);\n\n    /* delete object */\n    rt_object_delete(&co->parent);\n\n    return ret;\n}\n", "CodeBleu_score": 45.676005941315324}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void)    /*\n     * Retrieve the current thread\n     */\n    thread_t* current_thread = get_current_thread();\n    /*\n     * Enter critical section\n     */\n    ENTER_CRITICAL();\n    /*\n     * Close the thread\n     */\n    _close_thread(current_thread);\n    /*\n     * Exit critical section\n     */\n    EXIT_CRITICAL();\n    /*\n     * Trigger a context switch to the next task\n     */\n    _context_switch_request();\n}\n", "CodeBleu_score": 24.476572973061028}, {"code": "static void _thread_exit(void)    thread_t *thread = thread_current();\n    critical_enter();\n    thread_close(thread);\n    thread_defunct(thread);\n    critical_exit();\n    scheduler_schedule();\n}\n", "CodeBleu_score": 51.572636027272026}, {"code": "static void _thread_exit(void)\t_thread_t *current_thread = _get_current_thread();\n\t_enter_critical_section();\n\t_close_thread(current_thread);\n\t_exit_critical_section();\n\t_scheduler_yield();\n}\n", "CodeBleu_score": 23.568922862545616}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter)\tstruct thread *thread = (struct thread *)parameter;\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\tscheduler_lock();\n\tif (thread->state != THREAD_SUSPENDED) {\n\t\tscheduler_unlock();\n\t\treturn;\n\t}\n\tthread->error = ETIMEDOUT;\n\tthread_remove(thread);\n\tthread_insert(thread);\n\tscheduler_unlock();\n}\n", "CodeBleu_score": 35.07522843854814}, {"code": "static void _thread_timeout(void *parameter)\tstruct thread *thread;\n\n\tthread = (struct thread *)parameter;\n\n\tif (thread == NULL) {\n\t\treturn;\n\t}\n\n\tif (thread->state != THREAD_SUSPENDED) {\n\t\treturn;\n\t}\n\n\t_thread_mutex_lock(&_thread_mutex, &_thread_cur_task->mutex_list);\n\n\tthread->error = ETIMEDOUT;\n\n\t_thread_ready_insert(thread);\n\n\t_thread_mutex_unlock(&_thread_mutex, &_thread_cur_task->mutex_list);\n}\n", "CodeBleu_score": 38.437021741893254}, {"code": "static void _thread_timeout(void *parameter)    thread_t *thread;\n\n    /* Verify parameter. */\n    if (parameter == NULL) {\n        return;\n    }\n\n    /* Get the thread. */\n    thread = (thread_t *)parameter;\n\n    /* Lock the scheduler. */\n    _scheduler_lock();\n\n    /* Verify the thread is suspended. */\n    if (thread->state != THREAD_SUSPENDED) {\n        /* Unlock the scheduler. */\n        _scheduler_unlock();\n\n        /* Return indicating an error. */\n        return;\n    }\n\n    /* Set the thread's error number to a timeout value. */\n    thread->error = ETIMEDOUT;\n\n    /* Remove the thread from the suspend list. */\n    _list_remove(&thread->suspend_link);\n\n    /* Insert the thread into the ready list. */\n    _list_insert_first(&_ready_list, &thread->ready_link);\n\n    /* Unlock the scheduler. */\n    _scheduler_unlock();\n}\n", "CodeBleu_score": 32.720823270297075}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_mutex_t mutex;\n\trt_thread_t next;\n\n\tif (thread->pending_object != NULL) {\n\t\tmutex = (rt_mutex_t)thread->pending_object;\n\t\tthread->pending_object = NULL;\n\t\tthread->pending_object_type = RT_OBJECT_TYPE_NONE;\n\n\t\tif (thread->pending_object_waiting_list != NULL) {\n\t\t\trt_list_remove(&thread->pending_object_waiting_list->list);\n\t\t\tthread->pending_object_waiting_list = NULL;\n\t\t}\n\n\t\tmutex->lock_holder = NULL;\n\t\tmutex->lock_holder_count = 0;\n\t\tmutex->lock_holder_priority = 0;\n\t\tmutex->lock_holder_priority_ceiling = 0;\n\t\tmutex->lock_holder_priority_ceiling_enabled = 0;\n\t\tmutex->lock_holder_priority_inherit = 0;\n\t\tmutex->lock_holder_priority_inherit_enabled = 0;\n\t\tmutex->lock_holder_priority_ceiling_inherit = 0;\n\t\tmutex->lock_holder_priority_ceiling_inherit_enabled = 0;\n\t\tmutex->lock_holder_priority_ceiling_inherit_pending = 0;\n\t\tmutex->lock_holder_priority_ceiling_inherit_pending_enabled = 0;\n\t\tmutex->lock_holder_priority_ceiling_inherit_pending_disabled = 0;\n\t\tmutex->lock_holder_priority_ceiling_inherit_pending_disabled_enabled = 0;\n\t}\n\n\twhile (thread->mutex_list != NULL) {\n\t\tmutex = (rt_mutex_t)thread->mutex_list->object;\n\t\tthread->mutex_list = thread->mutex_list->next;\n\n\t\tmutex->lock_holder = NULL;\n\t\tmut", "CodeBleu_score": 32.27411851671739}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)    rt_mutex_t mutex;\n    rt_list_t *node;\n    rt_list_t *next;\n\n    /* lock the thread's spinlock */\n    rt_spin_lock(&thread->spinlock);\n\n    /* check if the thread is waiting on a mutex */\n    if (thread->pending_object != RT_NULL) {\n        /* remove the thread from the mutex's waiting list */\n        mutex = (rt_mutex_t)thread->pending_object;\n        rt_list_remove(&thread->tlist);\n        thread->pending_object = RT_NULL;\n\n        /* clear the pending object */\n        rt_object_clear_flag(&mutex->parent, RT_OBJECT_FLAG_PENDING);\n    }\n\n    /* release all mutexes the thread has taken */\n    for (node = thread->mutex_list.next; node != &thread->mutex_list; node = next) {\n        rt_mutex_t mutex;\n\n        /* get mutex */\n        mutex = (rt_mutex_t)rt_list_entry(node, struct rt_mutex, parent.list);\n        next = node->next;\n\n        /* remove the mutex from the thread's taken list */\n        rt_list_remove(node);\n\n        /* release the mutex */\n        mutex->owner_nest--;\n        if (mutex->owner_nest == 0) {\n            mutex->owner = RT_NULL;\n        }\n\n        /* release the mutex */\n        rt_mutex_release(mutex);\n    }\n\n    /* unlock the thread's spinlock */\n    rt_spin_unlock(&thread->spinlock);\n}\n", "CodeBleu_score": 50.636484174259024}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)\trt_mutex_t mutex;\n\trt_thread_t current;\n\trt_list_t *node;\n\trt_list_t *next;\n\n\tif (thread->waiting_mutex == NULL) {\n\t\treturn;\n\t}\n\n\tmutex = thread->waiting_mutex;\n\n\t/* Lock the mutex spinlock */\n\trt_spin_lock(mutex->spinlock);\n\n\t/* Remove the thread from the mutex's waiting list */\n\tnode = &thread->waiting_node;\n\tnext = node->next;\n\trt_list_remove(node);\n\n\t/* Clear the pending object */\n\tthread->pending_object = NULL;\n\n\t/* Release all mutexes the thread has taken */\n\tcurrent = rt_thread_self();\n\twhile (thread->taken_mutex != NULL) {\n\t\trt_mutex_t mutex = thread->taken_mutex;\n\t\tthread->taken_mutex = mutex->taken_by;\n\t\tmutex->taken_by = NULL;\n\t\tmutex->lock_count = 0;\n\t\tmutex->owner = NULL;\n\t\tmutex->spinlock = NULL;\n\t\trt_spin_unlock(mutex->spinlock);\n\t\trt_event_signal(&mutex->event, current);\n\t}\n\n\t/* Restore the spinlock state */\n\trt_spin_unlock(mutex->spinlock);\n}\n", "CodeBleu_score": 39.06839373660581}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    register rt_base_t temp;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    /* thread type check */\n    RT_ASSERT(thread->flag & RT_THREAD_TYPE_MAIN);\n\n    /* thread state change */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* priority attribute */\n    thread->number = rt_list_len(&thread->parent.child);\n\n    /* reset thread error number */\n    thread->error = RT_EOK;\n\n    /* reset thread yield count */\n    thread->yield_count = 0;\n\n    /* reset thread timer */\n    rt_timer_control(&(thread->thread_timer),\n                     RT_TIMER_CTRL_SET_TIME,\n                     &thread->init_tick);\n\n    /* insert to schedule ready list */\n    rt_schedule_insert_thread(thread);\n\n    /* enable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* resume thread */\n    rt_schedule_lock();\n    rt_schedule_insert_thread(thread);\n    rt_schedule_unlock();\n\n    /* trigger a scheduling */\n    if (need_schedule() != RT_FALSE)\n        rt_schedule();\n\n    /* enable interrupt */\n    rt_hw_interrupt_enable(temp);\n\n    return RT_EOK;\n}", "CodeBleu_score": 43.24366643833548}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    register rt_base_t temp;\n    register rt_base_t level;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n\n    /* thread type check */\n    RT_DEBUG_NOT_IN_INTERRUPT;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -RT_ERROR;\n\n    /* thread is not initialized */\n    if (thread->stat != RT_THREAD_INIT)\n        return -", "CodeBleu_score": 31.595571338238038}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    register rt_base_t temp;\n    register rt_base_t value;\n\n    /* thread check */\n    RT_ASSERT(thread != RT_NULL);\n    RT_ASSERT(thread->stat == RT_THREAD_INIT);\n    RT_ASSERT(thread->type == RT_Thread_Type_Main);\n\n    /* set current priority attribute */\n    thread->current_priority = thread->init_priority;\n\n    /* reset thread stat */\n    thread->stat = RT_THREAD_SUSPEND;\n\n    /* insert to schedule ready queue */\n    rt_schedule_insert_thread(thread);\n\n    /* enable interrupt */\n    temp = rt_hw_interrupt_disable();\n\n    /* change to the thread */\n    rt_schedule();\n\n    /* disable interrupt */\n    rt_hw_interrupt_enable(temp);\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 49.22512538888013}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_err_t result = -RT_ERROR;\n    rt_uint32_t level;\n    rt_timer_t timer;\n\n    /* check if the highest level of the timer skip list is not empty */\n    for (level = RT_TIMER_SKIP_LIST_LEVEL - 1; level != 0; level--) {\n        if (!rt_list_isempty(&timer_list[level])) {\n            /* get the first timer entry */\n            timer = rt_list_entry(timer_list[level].next, struct rt_timer, list);\n\n            /* set the timeout tick */\n            *timeout_tick = timer->timeout_tick;\n\n            /* return OK */\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    return result;\n}\n", "CodeBleu_score": 40.45787281871238}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_err_t result = RT_ERROR;\n    struct rt_timer *timer;\n\n    RT_ASSERT(timer_list != RT_NULL);\n    RT_ASSERT(timeout_tick != RT_NULL);\n\n    if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1])) {\n        return -RT_ETIMEOUT;\n    }\n\n    timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);\n    *timeout_tick = timer->timeout_tick;\n\n    result = RT_EOK;\n\n    return result;\n}\n", "CodeBleu_score": 73.83500665736207}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_tick_t min_timeout;\n    rt_list_t *l;\n    struct rt_timer *timer;\n\n    min_timeout = RT_TICK_MAX;\n\n    /* get the first timer */\n    l = timer_list[0].next;\n    if (l != &timer_list[0]) {\n        timer = rt_list_entry(l, struct rt_timer, row[0]);\n        min_timeout = timer->timeout_tick;\n    }\n\n    /* get the second timer */\n    l = timer_list[1].next;\n    if (l != &timer_list[1]) {\n        timer = rt_list_entry(l, struct rt_timer, row[1]);\n        if (timer->timeout_tick < min_timeout)\n            min_timeout = timer->timeout_tick;\n    }\n\n    /* get the third timer */\n    l = timer_list[2].next;\n    if (l != &timer_list[2]) {\n        timer = rt_list_entry(l, struct rt_timer, row[2]);\n        if (timer->timeout_tick < min_timeout)\n            min_timeout = timer->timeout_tick;\n    }\n\n    /* get the fourth timer */\n    l = timer_list[3].next;\n    if (l != &timer_list[3]) {\n        timer = rt_list_entry(l, struct rt_timer, row[3]);\n        if (timer->timeout_tick < min_timeout)\n            min_timeout = timer->timeout_tick;\n    }\n\n    /* get the fifth timer */\n    l = timer_list[4].next;\n    if (l != &timer_list[4]) {\n        timer = rt_list_entry(l, struct rt_timer, row[4]);\n        if (timer->timeout_tick < min_timeout)\n            min_timeout = timer->timeout_tick;\n    }\n\n    /* get the sixth timer */\n    l = timer_list[5].next;\n    if (l != &timer_list[5]) {\n        timer = rt_list", "CodeBleu_score": 38.87846207410181}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)  rt_timer_t timer;\n\n  /* Check parameters */\n  RT_ASSERT(timeout != RT_NULL);\n  RT_ASSERT(time > 0);\n\n  /* Allocate memory */\n  timer = rt_object_allocate(RT_Object_Class_Timer, name);\n  if (timer == RT_NULL)\n    return RT_NULL;\n\n  /* Initialize timer */\n  timer->timeout_function = timeout;\n  timer->parameter        = parameter;\n  timer->time             = time;\n  timer->flag             = flag;\n\n  return timer;\n}\n", "CodeBleu_score": 56.478590252159954}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)  /* Enter critical section */\n  rt_enter_critical();\n\n  /* Check the timeout function */\n  if (timeout == RT_NULL) {\n    /* Leave critical section */\n    rt_exit_critical();\n\n    return RT_NULL;\n  }\n\n  /* Check the time */\n  if (time == 0) {\n    /* Leave critical section */\n    rt_exit_critical();\n\n    return RT_NULL;\n  }\n\n  /* Allocate memory for timer object */\n  rt_timer_t timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n  if (timer == RT_NULL) {\n    /* Leave critical section */\n    rt_exit_critical();\n\n    return RT_NULL;\n  }\n\n  /* Initialize timer object */\n  timer->timeout_func = timeout;\n  timer->parameter    = parameter;\n  timer->time         = time;\n  timer->flag         = flag;\n\n  /* Leave critical section */\n  rt_exit_critical();\n\n  return timer;\n}\n", "CodeBleu_score": 51.228756577129296}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)  rt_timer_t timer;\n\n  /* Check parameters */\n  RT_ASSERT(timeout != RT_NULL);\n  RT_ASSERT(time > 0);\n\n  /* Allocate memory */\n  timer = (rt_timer_t)rt_object_allocate(RT_Object_Class_Timer, name);\n  if (timer == RT_NULL) return RT_NULL;\n\n  /* Set timer parameters */\n  timer->timeout_func = timeout;\n  timer->parameter    = parameter;\n  timer->time         = time;\n  timer->flag         = flag;\n\n  return timer;\n}\n", "CodeBleu_score": 56.445951372701096}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Create a new response recorder to capture the response\n\trec := httptest.NewRecorder()\n\t// Create a new context to pass the request and response recorder\n\tctx := context.WithValue(req.Context(), chi.RouteCtxKey, chi.NewRouteContext())\n\t// Create a new request with the context\n\tr := req.WithContext(ctx)\n\t// Call the first handler in the chain\n\ta.handlers[0](rec, r)\n\t// If the response is unauthorized, send a 401 Unauthorized error response\n\tif rec.Code == http.StatusUnauthorized {\n\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\t// If the response is not unauthorized, copy the headers and body to the original response\n\tfor k, v := range rec.Header() {\n\t\tres.Header()[k] = v\n\t}\n\tres.WriteHeader(rec.Code)\n\tres.Write(rec.Body.Bytes())\n}\n", "CodeBleu_score": 58.01303221976015}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\tvar (\n\t\thandler http.Handler\n\t\trec     = httptest.NewRecorder()\n\t)\n\n\t// Check if request is authorized\n\tfor _, h := range a.handlers {\n\t\thandler = h(req)\n\t\thandler.ServeHTTP(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\ta.error(res, req, http.StatusUnauthorized, \"Not authorized\", nil)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Forward request to router\n\ta.router.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 46.747876207410336}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\tvar (\n\t\terr     error\n\t\trec     *httptest.ResponseRecorder\n\t\thandled bool\n\t)\n\n\tfor _, handler := range a.handlers {\n\t\trec = httptest.NewRecorder()\n\t\thandler.ServeHTTP(rec, req)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thandled = true\n\t\t\ta.sendNotAuthorized(res, req, rec)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !handled {\n\t\ta.router.ServeHTTP(res, req)\n\t}\n\n\treturn\n}\n", "CodeBleu_score": 46.797647372542826}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\t// The file name is the last element in the path\n\tfileName := path[strings.LastIndex(path, \"/\")+1:]\n\t// The file extension is the last element in the file name\n\tfileExtension := fileName[strings.LastIndex(fileName, \".\")+1:]\n\t// The file name is the first element in the path\n\tfileName = path[:strings.Index(path, \"/\")]\n\t// The file extension is the first element in the file name\n\tfileExtension = fileName[:strings.Index(fileName, \".\")]\n\t// Retrieve the asset from the file system\n\tasset, err := a.assets.Open(path)\n\tif err != nil {\n\t\t// If the asset is not found, return a 404 error\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\t// Set the Content-Type header based on the file extension\n\tswitch fileExtension {\n\tcase \"css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \"js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \"html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\t// Write the asset content to the response\n\tio.Copy(res, asset)\n}\n", "CodeBleu_score": 45.472584797500545}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tif path == \"\" || path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tfile, err := a.fs.Open(path)\n\tif err != nil {\n\t\ta.log.Printf(\"Error opening %s: %s\", path, err)\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\tdefer file.Close()\n\tif strings.HasSuffix(path, \".js\") {\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\t} else if strings.HasSuffix(path, \".css\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t} else if strings.HasSuffix(path, \".html\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\tio.Copy(res, file)\n}\n", "CodeBleu_score": 46.36510292085541}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \t// Get the path of the requested asset.\n\tpath := req.URL.Path\n\t// If the path is \"/\", then serve the index.html file.\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\t// If the path is \"/favicon.ico\", then serve the favicon.ico file.\n\tif path == \"/favicon.ico\" {\n\t\tpath = \"/favicon.ico\"\n\t}\n\t// Open the asset file.\n\tfile, err := a.fs.Open(path)\n\t// If an error occurs, return a 404 error.\n\tif err != nil {\n\t\thttp.NotFound(res, req)\n\t\treturn\n\t}\n\t// Close the asset file.\n\tdefer file.Close()\n\t// Get the file extension.\n\text := filepath.Ext(path)\n\t// Set the Content-Type header based on the file extension.\n\tswitch ext {\n\tcase \".js\":\n\t\tres.Header().Set(\"Content-Type\", \"application/javascript\")\n\tcase \".css\":\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\tcase \".html\":\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\tcase \".ico\":\n\t\tres.Header().Set(\"Content-Type\", \"image/x-icon\")\n\t}\n\t// Write the asset content to the response.\n\tio.Copy(res, file)\n}\n", "CodeBleu_score": 48.78728769764228}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\trobotName := mux.Vars(req)[\"robotName\"]\n\n\t// Find the robot using the master instance\n\trobot := a.master.findRobot(robotName)\n\n\t// If the robot is found, gather its connections and convert them to JSON format\n\tif robot != nil {\n\t\t// Gather the robot's connections\n\t\tconnections := robot.Connections()\n\n\t\t// Convert the connections to JSON format\n\t\tjsonConnections, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\ta.log.Error(err)\n\t\t\treturn\n\t\t}\n\n\t\t// Write the JSON response containing the connections\n\t\tres.Write(jsonConnections)\n\t} else {\n\t\t// Write a JSON error message indicating that no robot was found with the specified name\n\t\tres.Write([]byte(`{\"error\": \"No robot found with name: ` + robotName + `\"}`))\n\t}\n}\n", "CodeBleu_score": 35.48798326130536}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Extract the robot name from the request URL\n\trobotName := req.URL.Path[len(\"/api/robots/\"):]\n\n\t// Find the robot with the specified name\n\trobot := a.master.RobotByName(robotName)\n\n\t// If the robot was found\n\tif robot != nil {\n\t\t// Gather the robot connections\n\t\tconnections := robot.Connections()\n\n\t\t// Convert the connections to JSON format\n\t\tconnectionsJSON, err := json.Marshal(connections)\n\n\t\t// If an error occurred while converting the connections to JSON format\n\t\tif err != nil {\n\t\t\t// Write a JSON error message indicating that the connections could not be converted to JSON format\n\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\": \\\"Could not convert robot connections to JSON format: %s\\\"}\", err)))\n\t\t} else {\n\t\t\t// Write the JSON response containing the connections\n\t\t\tres.WriteHeader(http.StatusOK)\n\t\t\tres.Write(connectionsJSON)\n\t\t}\n\t} else {\n\t\t// Write a JSON error message indicating that no robot was found with the specified name\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\": \\\"No robot found with name '%s'\\\"}\", robotName)))\n\t}\n}\n", "CodeBleu_score": 32.14426523532751}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\t// Get robot name from URL\n\trobotName := req.URL.Query().Get(\":name\")\n\n\t// Find robot with the given name\n\trobot := a.master.findRobot(robotName)\n\n\t// If robot is found, gather its connections and convert them to JSON format\n\tif robot != nil {\n\t\tconnections := robot.getConnections()\n\t\tjsonConnections, err := json.Marshal(connections)\n\t\tif err != nil {\n\t\t\ta.log.Errorf(\"Failed to marshal robot connections: %s\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Write JSON response containing the connections\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write(jsonConnections)\n\t} else {\n\t\t// Write JSON error message indicating that no robot was found with the specified name\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.Write([]byte(`{\"error\": \"No robot found with the specified name\"}`))\n\t}\n}\n", "CodeBleu_score": 38.860849942922826}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif pair[0] != username || pair[1] != password {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.71170272033138}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tuser, pass, ok := r.BasicAuth()\n\t\tif !ok || user != username || pass != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\t// The request is authenticated.\n\t\t// You can serve the resource as normal.\n\t\tfmt.Fprintln(w, \"Success! You are authorized to see this text.\")\n\t}\n}\n", "CodeBleu_score": 52.56802650944359}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Header.Get(\"Authorization\") == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tauth := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(auth) != 2 || auth[0] != \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(auth[1])\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif len(pair) != 2 || !validate(pair[0], pair[1], username, password) {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 48.185768096302894}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \t// Calculate the slope and intercept for the scaling transformation\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Ensure the output is clamped within the target range\n\t\treturn int(math.Max(math.Min(slope*input+intercept, float64(toMax)), float64(toMin)))\n\t}\n}\n", "CodeBleu_score": 56.03462065356229}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \t// Calculate the slope and intercept for the scaling transformation\n\tslope := float64(toMax - toMin) / (fromMax - fromMin)\n\tintercept := float64(toMin) - slope * fromMin\n\n\t// Return a function that performs the scaling\n\treturn func(input float64) (value int) {\n\t\t// Calculate the scaled value\n\t\tvalue = int(slope*input + intercept)\n\n\t\t// Ensure the output is clamped within the target range\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 57.74701269575382}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tslope := float64(toMax-toMin) / (fromMax-fromMin)\n\tintercept := float64(toMin) - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 54.52596027015323}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"Connection does not support analog read\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.scale\n\n\ta.lastRawValue = raw\n\ta.lastScaledValue = scaled\n\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 49.179880270085725}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, ErrNotAnalogReadable\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := float64(raw) * a.scale\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 47.73196162909375}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif a.connection == nil || !a.connection.SupportsAnalogRead() {\n\t\treturn 0, 0, errors.New(\"AnalogSensorDriver requires an analog reader\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 49.74379281103902}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - float64(fromMin)*m\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}\n", "CodeBleu_score": 44.7359134648887}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - m*float64(fromMin)\n\treturn func(x int) float64 {\n\t\treturn m*float64(x) + n\n\t}\n}\n", "CodeBleu_score": 50.2302590210742}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tm := (toMax - toMin) / float64(fromMax - fromMin)\n\tn := toMin - float64(fromMin)*m\n\treturn func(value int) float64 {\n\t\treturn m*float64(value) + n\n\t}\n}\n", "CodeBleu_score": 45.17712717184125}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\td := &GrovePiezoVibrationSensorDriver{\n\t\tname: gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tconn: a,\n\t\tpin:  pin,\n\t}\n\n\tfor _, opt := range opts {\n\t\tswitch opt.(type) {\n\t\tcase string:\n\t\t\td.name = opt.(string)\n\t\tcase []float64:\n\t\t\td.threshold = opt.([]float64)\n\t\t}\n\t}\n\n\td.mutex = &sync.Mutex{}\n\n\td.AddEvent(Vibration)\n\n\td.vibration = false\n\n\tif err := d.Start(); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn d\n}\n", "CodeBleu_score": 45.78711210425851}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\toptions := NewGrovePiezoVibrationSensorDriverOptions()\n\tfor _, o := range opts {\n\t\to.apply(options)\n\t}\n\tg := &GrovePiezoVibrationSensorDriver{\n\t\tname:   options.name,\n\t\tpin:    pin,\n\t\treader: a,\n\t}\n\tg.vibration = NewGrovePiezoVibrationSensorDriverEvent(g.name, \"vibration\", \"Vibration Detected\")\n\tg.vibration.SetActiveLow(options.activeLow)\n\tg.vibration.SetInactiveValue(options.inactiveValue)\n\tg.vibration.SetActiveValue(options.activeValue)\n\tg.vibration.SetQuietValue(options.quietValue)\n\tg.vibration.SetQuietTime(options.quietTime)\n\tg.vibration.SetEventType(options.eventType)\n\tg.vibration.SetPayloadType(options.payloadType)\n\tg.vibration.SetPayload(options.payload)\n\tg.vibration.SetContext(options.context)\n\tg.vibration.SetBlacklist(options.blacklist)\n\tg.vibration.SetWhitelist(options.whitelist)\n\tg.vibration.SetFilterValue(options.filterValue)\n\tg.vibration.SetFilterType(options.filterType)\n\tg.vibration.SetFilterMin(options.filterMin)\n\tg.vibration.SetFilterMax(options.filterMax)\n\tg.vibration.SetFilterMinDelta(options.filterMinDelta)\n\tg.vibration.SetFilterMaxDelta(options.filterMaxDelta)\n\tg.vibration.SetFilterMinPeriod(options.filterMinPeriod)\n\tg.vibration.SetFilterMaxPeriod(options.filterMaxPeriod)\n\tg.vibration.SetFilterPeriod(options.filterPeriod)\n\tg.vibration.SetFilterMinCount(options.filterMinCount)\n\tg.vibration.SetFilterMaxCount(options.filterMaxCount)\n\tg.vibration.SetFilterCount(options.filterCount)\n\tg.", "CodeBleu_score": 27.753575446436873}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\toptions := NewGrovePiezoVibrationSensorDriverOptions()\n\tfor _, o := range opts {\n\t\to.apply(options)\n\t}\n\td := &GrovePiezoVibrationSensorDriver{\n\t\tname:   gobot.DefaultName(\"GrovePiezoVibrationSensor\"),\n\t\tvibration: gobot.NewEvent(),\n\t\tpin:      pin,\n\t\tp:        a,\n\t}\n\td.mutex = &sync.Mutex{}\n\td.AddEvent(d.Event(d.vibration))\n\td.AddEvent(d.Event(d.Data))\n\td.AddEvent(d.Event(d.Error))\n\td.AddEvent(d.Event(d.Start))\n\td.AddEvent(d.Event(d.Halt))\n\td.AddEvent(d.Event(d.Init))\n\td.AddEvent(d.Event(d.Connect))\n\td.AddEvent(d.Event(d.Disconnect))\n\td.AddEvent(d.Event(d.Enable))\n\td.AddEvent(d.Event(d.Disable))\n\td.AddEvent(d.Event(d.On))\n\td.AddEvent(d.Event(d.Off))\n\treturn d\n}\n", "CodeBleu_score": 34.09859862139147}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\treturn d.connection.Tone(hz, duration)\n}\n", "CodeBleu_score": 6.482465312782629}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tif d.isClosed() {\n\t\treturn ErrClosed\n\t}\n\n\tif hz <= 0 {\n\t\treturn ErrInvalidFrequency\n\t}\n\n\tif duration <= 0 {\n\t\treturn ErrInvalidDuration\n\t}\n\n\tif d.buzzer == nil {\n\t\treturn ErrBuzzerNotInitialized\n\t}\n\n\tif d.buzzer.Pin() == NoPin {\n\t\treturn ErrBuzzerNotInitialized\n\t}\n\n\treturn d.buzzer.Tone(hz, duration)\n}\n", "CodeBleu_score": 27.24731908162215}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tif hz < 0 || duration < 0 {\n\t\treturn fmt.Errorf(\"Invalid arguments\")\n\t}\n\tif d.buzzer == nil {\n\t\treturn fmt.Errorf(\"Buzzer not initialized\")\n\t}\n\n\tif d.buzzer.pin == 0 {\n\t\treturn fmt.Errorf(\"Buzzer not connected\")\n\t}\n\n\tif d.buzzer.pin == 0 {\n\t\treturn fmt.Errorf(\"Buzzer not connected\")\n\t}\n\n\tperiod := int(1000000 / hz)\n\ttempo := int(60000 / (d.buzzer.bpm * 4))\n\tnumToggles := int(duration * 1000 / tempo)\n\n\tfor i := 0; i < numToggles; i++ {\n\t\terr := d.buzzer.Toggle()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Microsecond)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 42.74234727395748}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.SleepPin == nil {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\tif !d.SleepPin.Read() {\n\t\treturn errors.New(\"sleep pin is not active\")\n\t}\n\td.stop()\n\td.SleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 35.29768728396471}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not set\")\n\t}\n\n\tif !d.sleepPin.Get() {\n\t\treturn errors.New(\"sleep pin is not active\")\n\t}\n\n\td.stop()\n\td.sleepPin.Set(false)\n\td.sleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 35.76737422493354}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\t// Check if the sleep pin is set\n\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin is not set\")\n\t}\n\n\t// Stop any ongoing operations\n\td.stop()\n\n\t// Set the sleep pin to low\n\td.sleepPin.Low()\n\n\t// Mark the driver as sleeping\n\td.isSleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 31.841544616194895}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tpath, params, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpin := gpio.NewAnalogInput(path, params)\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 53.872714707959425}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins map is not initialized\")\n\t}\n\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\n\tif path, params, err := a.translate(id); err == nil {\n\t\tpin := a.factory(path, params)\n\t\ta.pins[id] = pin\n\t\treturn pin, nil\n\t} else {\n\t\treturn nil, err\n\t}\n}\n", "CodeBleu_score": 48.91213672630233}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, fmt.Errorf(\"Pins map not initialized\")\n\t}\n\tif pin, ok := a.pins[id]; ok {\n\t\treturn pin, nil\n\t}\n\tpath, err := a.translate(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpin := &AnalogPin{\n\t\tpath: path,\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 53.94687047621822}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getDigitalPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.DigitalWrite(val)\n}\n", "CodeBleu_score": 64.41762580680286}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pin.DigitalWrite(val)\n}\n", "CodeBleu_score": 58.39401632570067}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.getPin(id, gpio.OUT)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn pin.DigitalWrite(val)\n}\n", "CodeBleu_score": 64.5135032519786}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif a.digitalPins == nil {\n\t\ta.digitalPins = make(map[string]gobot.DigitalPinner)\n\t}\n\n\tif _, ok := a.digitalPins[id]; !ok {\n\t\tchip, line, err := a.translateIDToChipAndLine(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin := gpio.NewDigitalPin(chip, line)\n\t\tfor _, option := range opts {\n\t\t\toption(pin)\n\t\t}\n\t\ta.digitalPins[id] = pin\n\t}\n\n\treturn a.digitalPins[id], nil\n}\n", "CodeBleu_score": 39.90405230998387}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif len(a.pins) == 0 {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor not connected\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\tchip, line, err := parsePinID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = &DigitalPin{\n\t\t\tid:      id,\n\t\t\tchip:    chip,\n\t\t\tline:    line,\n\t\t\toptions: opts,\n\t\t}\n\t\ta.pins[id] = pin\n\t} else {\n\t\tpin.options = append(pin.options, opts...)\n\t}\n\n\tif err := pin.Init(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 53.984092245338545}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif a.digitalPins == nil {\n\t\treturn nil, errors.New(\"DigitalPinsAdaptor is not connected\")\n\t}\n\tif a.digitalPins[id] == nil {\n\t\tchip, line, err := a.translateID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpin := gpio.NewDigitalPin(chip, line)\n\t\tfor _, o := range opts {\n\t\t\to(pin)\n\t\t}\n\t\ta.digitalPins[id] = pin\n\t} else {\n\t\tfor _, o := range opts {\n\t\t\to(a.digitalPins[id])\n\t\t}\n\t}\n\treturn a.digitalPins[id], nil\n}\n", "CodeBleu_score": 44.79727730773034}]}
