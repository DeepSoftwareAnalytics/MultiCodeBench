{"instance_id": "37c223ece5db", "generation_result": [{"code": "#include <stdint.h> // For uint8_t type\n#include <stddef.h> // For NULL macro\n\n/*\n * A utility structure demonstrated for USB descriptors that would typically exist\n * in an actual USB stack implementation.\n */\ntypedef struct {\n    uint8_t bLength;     // The length of the descriptor in bytes\n    uint8_t bDescriptorType; // Descriptor Type\n    // Other fields would go here depending on the type of descriptor\n} usb_conf_desc_t;\n\n// `UDC_DESC_STORAGE` could be a specific qualifier like for specific memory segment,\n// here we just assume it is empty for the sake of this example.\n#ifndef UDC_DESC_STORAGE\n#define UDC_DESC_STORAGE\n#endif\n\n/*\n * The function \"udc_next_desc_in_iface\" searches for the next USB descriptor within a given \n * interface descriptor. It starts from the provided descriptor, moves to the next descriptor \n * by incrementing the descriptor pointer by the length of the current descriptor, \n * and continues this until it either finds the specified descriptor type or reaches the \n * end of the interface descriptor.\n *\n * If it finds the specified descriptor type, it returns a pointer to that descriptor; \n * otherwise, it returns \"NULL\".\n */\nstatic usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id) {\n    while (desc != NULL && desc->bLength > 0) {\n        // Move to the next descriptor\n        desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)desc + desc->bLength);\n\n        // Check if this is the descriptor type we're looking for\n        if (desc->bDescriptorType == desc_id) {\n            return desc;\n        }\n    }\n\n    // If no descriptor found or end of descriptors reached\n    return NULL;\n}", "CodeBleu_score": 50.705538289250086}, {"code": "#include <stdint.h>\n#include <stddef.h> // For NULL\n\n// A typical USB descriptor's fields represented as a structured type.\ntypedef struct {\n    uint8_t bLength;          // Length of the descriptor in bytes\n    uint8_t bDescriptorType;  // Descriptor Type\n} usb_conf_desc_t;\n\n// Macro or compiler directive for descriptor storage may be needed for alignment or special memory\n#define UDC_DESC_STORAGE\n\n// Function to iterate over USB descriptors within an interface to find a specific descriptor type\nstatic usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(\n    usb_conf_desc_t UDC_DESC_STORAGE *desc, \n    uint8_t desc_id) {\n    \n    // Pointer to process through the descriptors\n    usb_conf_desc_t UDC_DESC_STORAGE *current_desc = desc;\n\n    // Continue until we reach a null pointer (typically at the end of descriptor array)\n    while (current_desc != NULL) {\n        // If the current descriptor type is the one we're looking for, return it.\n        if (current_desc->bDescriptorType == desc_id) {\n            return current_desc;\n        }\n\n        // Move to the next descriptor, ensured by adding the length of the current descriptor\n        // to the current pointer (typecast to char* for correct pointer arithmetic)\n        uint8_t length = current_desc->bLength;\n        if (length == 0) {\n            // Prevent infinite loops if a descriptor incorrectly reports a zero length\n            break;\n        }\n\n        current_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((char *)current_desc + length);\n        \n        // Optionally, add a condition to break out when current_descriptor exceeds \n        // the end of expected memory range (e.g., the end of a configuration descriptor area).\n    }\n\n    return NULL; // Return NULL if no matching descriptor is found\n}", "CodeBleu_score": 48.90547246507816}, {"code": "/* \n * Function to search for the next USB descriptor within a certain interface descriptor.\n * This function begins its search from a given starting descriptor and goes through each subsequent descriptor.\n * It stops when it finds a descriptor with the matching 'desc_id' or when it reaches the end of the interface group.\n */\nstatic usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id) {\n    usb_conf_desc_t UDC_DESC_STORAGE * current_desc = desc;\n\n    /* Continue scanning while there is a valid descriptor present in the interface */\n    while (current_desc != NULL) {\n        /* Move to the next descriptor by incrementing by the 'bLength' of the current descriptor */\n        current_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t *)current_desc + current_desc->bLength);\n\n        /* Check if we have reached or overshot the end of descriptors block */\n        if ((uint8_t *)current_desc >= UDC_DESC_LIMIT)\n            return NULL;\n\n        /* Return the descriptor if it matches the requested 'desc_id' */\n        if (current_desc->bDescriptorType == desc_id)\n            return current_desc;\n    }\n\n    /* If no matching descriptor is found, return NULL */\n    return NULL;\n}", "CodeBleu_score": 48.96322460363174}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n// Assuming hypothetical global USB configuration information, represented with these structures\ntypedef struct {\n    uint8_t bLength; \n    uint8_t bDescriptorType; \n    uint8_t bInterfaceNumber;\n    uint8_t bAlternateSetting;\n    // Other fields omitted for brevity...\n} USB_InterfaceDescriptor;\n\ntypedef struct {\n    USB_InterfaceDescriptor* descriptors; // Array of interface descriptors\n    size_t num_descriptors; // Number of descriptors in the array\n    bool valid;              // Flag indicating if the configuration is valid\n} USB_Configuration;\n\nextern USB_Configuration g_current_usb_config; // Hypothetical current USB configuration\n\n// Utility function to check if the descriptor is an interface descriptor\nstatic bool is_interface_descriptor(uint8_t bDescriptorType) {\n    const uint8_t USB_DESC_TYPE_INTERFACE = 4; // Hypothetical constant for interface descriptor type\n    return bDescriptorType == USB_DESC_TYPE_INTERFACE;\n}\n\nstatic bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num) {\n    // Check if the current configuration is valid\n    if (!g_current_usb_config.valid) {\n        return false;\n    }\n\n    // Loop through the available descriptors in the current configuration\n    for (size_t i = 0; i < g_current_usb_config.num_descriptors; i++) {\n        USB_InterfaceDescriptor* desc = &g_current_usb_config.descriptors[i];\n        \n        // Check if this is an interface descriptor and matches the interface and setting numbers\n        if (is_interface_descriptor(desc->bDescriptorType) &&\n            desc->bInterfaceNumber == iface_num &&\n            desc->bAlternateSetting == setting_num) {\n            return true;\n        }\n    }\n\n    // No matching interface descriptor was found\n    return false;\n}", "CodeBleu_score": 33.07676626805382}, {"code": "#include <stdbool.h>\n#include <stdint.h>\n\n// Assuming we have access to the USB configuration structure\nextern usb_config_t *current_usb_config;\nextern int usb_config_length;\n\nstatic bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num) {\n    // Check if there's a valid USB configuration loaded\n    if (current_usb_config == NULL) {\n        return false;\n    }\n\n    // Pointer to the current position within the configuration descriptor\n    uint8_t *desc_pointer = (uint8_t*)current_usb_config;\n    uint8_t *end_pointer = desc_pointer + usb_config_length;\n\n    // Iterate over the descriptors\n    while (desc_pointer < end_pointer) {\n        // Ensure that the descriptor at least has the length and type fields accessible\n        if (desc_pointer + 1 > end_pointer) {\n            break;\n        }\n\n        uint8_t length = desc_pointer[0];\n        uint8_t type = desc_pointer[1];\n\n        // Check if the length is reasonable\n        if (length < 2 || desc_pointer + length > end_pointer) {\n            break;\n        }\n\n        // USB descriptor types\n        const uint8_t USB_DT_INTERFACE = 0x04;  // USB interface descriptor type\n\n        // If it's an interface descriptor\n        if (type == USB_DT_INTERFACE && length >= sizeof(usb_iface_desc_t)) {\n            usb_iface_desc_t *iface_desc = (usb_iface_desc_t *)desc_pointer;\n\n            // Check if the interface descriptor matches the interface and setting numbers\n            if (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n                return true;\n            }\n        }\n\n        // Move to the next descriptor\n        desc_pointer += length;\n    }\n\n    return false;\n}", "CodeBleu_score": 38.82681154687272}, {"code": "#include <stdbool.h>\n#include <stdint.h>\n\n// Assuming `usb_config_descriptor` provides access to the current USB configuration's full descriptor\nextern const uint8_t *usb_config_descriptor;\nextern const uint16_t usb_config_length;\n\n// USB Descriptor types\n#define USB_DT_INTERFACE 0x04\n\n// USB Interface Descriptor structure placeholder\ntypedef struct {\n    uint8_t bLength;\n    uint8_t bDescriptorType;\n    uint8_t bInterfaceNumber;\n    uint8_t bAlternateSetting;\n    uint8_t bNumEndpoints;\n    uint8_t bInterfaceClass;\n    uint8_t bInterfaceSubClass;\n    uint8_t bInterfaceProtocol;\n    uint8_t iInterface;\n} usb_interface_descriptor_t;\n\nstatic bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num) {\n    // Validate if the USB configuration is loaded\n    if (usb_config_descriptor == NULL || usb_config_length == 0) {\n        return false;\n    }\n\n    // Iterate through the configuration descriptor to find the interface descriptor\n    const uint8_t *ptr = usb_config_descriptor;\n    const uint8_t *end = usb_config_descriptor + usb_config_length;\n\n    while (ptr < end) {\n        // Minimum length check for valid descriptor availability\n        if ((end - ptr) < sizeof(usb_interface_descriptor_t)) {\n            break;\n        }\n\n        // Check for an interface descriptor type\n        if (ptr[1] == USB_DT_INTERFACE) {\n            const usb_interface_descriptor_t *iface_desc = (const usb_interface_descriptor_t *)ptr;\n\n            // Check if the current descriptor matches the specified interface and setting numbers\n            if (iface_desc->bInterfaceNumber == iface_num && iface_desc->bAlternateSetting == setting_num) {\n                // Found the matching interface descriptor\n                return true;\n            }\n\n            // Adjust pointer past this descriptor\n            ptr += iface_desc->bLength;\n        } else {\n            // Skip the current descriptor (assumes length is in first byte)\n            ptr += ptr[0];\n        }\n    }\n\n    // No matching interface descriptor found\n    return false;\n}", "CodeBleu_score": 35.93974233446037}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "#include <stdbool.h>\n#include <stdint.h>\n\n/* Mock definitions for USB endpoint status */\n#define USB_ENDPOINT_STATUS_SIZE 2  // Normally, endpoint status size is 2 bytes in USB\n#define EP_HALTED 1\n#define EP_ACTIVE 0\n\n/* Example of endpoint structure and function to get status - To be adapted to actual USB stack and architecture specifics */\ntypedef struct {\n    uint8_t endpoint_address;\n    bool halted;  // true if halted, false if active\n} USB_Endpoint;\n\nextern USB_Endpoint usb_endpoints[];  // Array of endpoints, defined elsewhere\nextern uint16_t wLength;              // The requested length (passed from the USB stack)\nextern uint16_t wIndex;               // Endpoint index (passed from the USB stack)\nextern uint8_t *usb_response_buffer;  // Buffer to place the response (passed from the USB stack)\n\nstatic bool is_endpoint_halted(uint8_t endpoint_index) {\n    // Check if the endpoint at the given index is halted\n    return usb_endpoints[endpoint_index].halted;\n}\n\nstatic bool udc_req_std_ep_get_status(void) {\n    // Check if the request length is correct\n    if (wLength != USB_ENDPOINT_STATUS_SIZE) {\n        return false;\n    }\n\n    // Extract the endpoint index from the wIndex - LSB is the endpoint number\n    uint8_t ep_index = wIndex & 0xFF;\n\n    // Get whether the endpoint is halted\n    bool halted = is_endpoint_halted(ep_index);\n\n    // Set the response with the endpoint status\n    usb_response_buffer[0] = halted ? EP_HALTED : EP_ACTIVE;\n    usb_response_buffer[1] = 0;  // Second byte should always be zero\n\n    return true;\n}", "CodeBleu_score": 39.55172471623479}, {"code": "static bool udc_req_std_ep_get_status(void) {\n    // Define the size of the endpoint status data.\n    const uint16_t expected_data_length = 2;\n    \n    // Check if the request length matches the expected length.\n    if (usb_device_request.length != expected_data_length) {\n        return false;\n    }\n    \n    // Get the endpoint from the setup packet.\n    uint8_t endpoint_address = usb_device_request.index & 0xFF;\n    \n    // Check the status of the endpoint.\n    bool endpoint_is_halted = is_endpoint_halted(endpoint_address);\n    \n    // Define endpoint status: 0x0001 if halted, 0x0000 if not.\n    uint16_t endpoint_status = endpoint_is_halted ? 0x0001 : 0x0000;\n    \n    // Set up the response payload.\n    // Note: Assuming that 'response_data' is defined somewhere in this scope or globally.\n    response_data[0] = endpoint_status & 0xFF;        // Lower byte\n    response_data[1] = (endpoint_status >> 8) & 0xFF; // Higher byte\n    \n    // Send the endpoint status response.\n    usb_transfer_response(response_data, expected_data_length);\n    \n    return true;\n}", "CodeBleu_score": 30.440966278042247}, {"code": "static bool udc_req_std_ep_get_status(void)\n{\n    /* Size of the endpoint status, expected to be 2 bytes (USB Standard) */\n    const uint16_t expected_length = 2;\n    uint16_t status_payload = 0;\n    \n    /* Check if the request length matches expected length of status */\n    if (usb_control_request.wLength != expected_length) {\n        return false; // Stalling the response as length does not match expected status length\n    }\n\n    /* Determine endpoint from the wIndex field of the control request\n       USB setup packet wIndex field contains the endpoint number */\n    uint8_t endpoint_index = usb_control_request.wIndex & 0x0F;\n    bool direction_in = (usb_control_request.wIndex & 0x80) == 0x80;\n\n    /* Determine if the specified endpoint is halted or not */\n    if (is_endpoint_halted(endpoint_index, direction_in)) {\n        status_payload = 1; // Endpoint is halted\n    } else {\n        status_payload = 0; // Endpoint is not halted\n    }\n\n    /* Setup the response payload. In USB, status response is little-endian */\n    uint8_t response[2];\n    response[0] = (uint8_t)(status_payload & 0xFF);\n    response[1] = (uint8_t)((status_payload >> 8) & 0xFF);\n\n    /* Send back the response */\n    usb_send_control_response(response, sizeof(response));\n    \n    return true;\n}\n\n/* Helper function to check if an endpoint is halted */\nstatic bool is_endpoint_halted(uint8_t endpoint_index, bool direction_in) {\n    /* Implementation-dependent function */\n    /* Return true if endpoint is halted, false otherwise */\n    return endpoint_halt_status[endpoint_index][direction_in ? 1 : 0];\n}\n\n/* Placeholder for sending the control response */\nstatic void usb_send_control_response(uint8_t *data, uint16_t length) {\n    /* Implementation-dependent function */\n}", "CodeBleu_score": 42.42581792586089}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "{\n    // Check if the device is in a configured state\n    if (udc_is_configured()) {\n        // Get the interface number requested\n        uint8_t interface = udd_get_interface();\n\n        // Validate the interface number\n        if (!udi_interface_is_valid(interface)) {\n            return false;\n        }\n\n        // Update the default descriptor of the requested interface\n        const usb_iface_desc_t *default_iface_desc = udi_get_default_iface_desc(interface);\n        if (!udc_update_iface_desc(default_iface_desc)) {\n            return false;\n        }\n\n        // Update to the current alternate setting of the interface\n        const usb_iface_desc_t *current_iface_desc = udi_get_current_iface_desc(interface);\n        if (!udc_update_iface_desc(current_iface_desc)) {\n            return false;\n        }\n\n        // Forward the SETUP request to the corresponding UDI handler\n        udi_api_t *udi_api = udi_get_api(interface);\n        if (udi_api && udi_api->setup) {\n            return udi_api->setup();\n        }\n    }\n\n    return false;\n}", "CodeBleu_score": 37.16094682392455}, {"code": "#include <stdbool.h>\n\n// Definitions (These would typically be derived from your specific USB stack and hardware setup)\n#define USB_CONFIGURED 1\nextern uint8_t usb_device_state;\nextern int usb_current_interface;\nextern int usb_alternate_setting;\nextern bool udi_handler_setup();\n\n// Mock function: to demonstrate could be implemented or from some driver/library\nbool update_interface_descriptor(int interface_number, int setting);\n\nstatic bool udc_req_iface(void) {\n    // Check if the device is in the configured state\n    if (usb_device_state != USB_CONFIGURED) {\n        return false;  // Device is not configured\n    }\n\n    // Validate the requested interface number (Simple example check here)\n    if (usb_current_interface < 0) {\n        return false;  // Invalid interface number\n    }\n\n    // Update the interface descriptor to default setting\n    if (!update_interface_descriptor(usb_current_interface, 0)) {\n        return false;  // Failed to update to default setting\n    }\n\n    // Update to the current alternate setting\n    if (!update_interface_descriptor(usb_current_interface, usb_alternate_setting)) {\n        return false;  // Failed to update to alternate setting\n    }\n\n    // Forward the SETUP request to the corresponding UDI handler\n    return udi_handler_setup();\n}\n\n// Example implementations of necessary functions, these would normally come from your driver or library\nbool update_interface_descriptor(int interface_number, int setting) {\n    // Here you would update the hardware or software state to match the desired configuration\n    return true;  // Assuming always successful for example purposes\n}\n\n// Mock UDI handler setup function: would be implemented as per your USB configuration\nbool udi_handler_setup() {\n    // Process the SETUP request\n    // Return true if successful, false if not\n    return true;\n}", "CodeBleu_score": 49.52417579634366}, {"code": "#include <stdbool.h>\n\n// Hypothetical external definitions and prototype\nextern bool usb_device_is_configured(void);\nextern int get_requested_interface_number(void);\nextern bool interface_number_is_valid(int iface_num);\nextern bool update_interface_to_default_setting(int iface_num);\nextern bool update_interface_to_alternate_setting(int iface_data);\nextern struct udi_api* get_udi_api_for_interface(int iface_num);\nextern struct usb_req* get_current_setup_request(void);\n\nstruct udi_api {\n    bool (*setup)(struct usb_req* req);\n};\n\nstatic bool udc_req_iface(void) {\n    // Step 1: Check if device is configured\n    if (!usb_device_is_configured()) {\n        return false;\n    }\n        \n    // Step 2: Retrieve the requested interface number\n    int iface_num = get_requested_interface_number();\n\n    // Step 3: Check if the interface number is valid\n    if (!interface_number_is_valid(iface_num)) {\n        return false;\n    }\n\n    // Step 4: Update the interface descriptor to the default setting\n    if (!update_interface_to_default_setting(iface_num)) {\n        return false;\n    }\n\n    // Step 5: Update to the current alternate setting\n    if (!update_interface_to_alternate_setting(iface_num)) {\n        return false;\n    }\n\n    // Step 6: Get the corresponding UDI API for the interface\n    struct udi_api* udi_handler = get_udi_api_for_interface(iface_num);\n    if (udi_handler == NULL || udi_handler->setup == NULL) {\n        return false;\n    }\n\n    // Step 7: Get the current SETUP request\n    struct usb_req* current_setup_req = get_current_setup_request();\n    if (current_setup_req == NULL) {\n        return false;\n    }\n\n    // Step 8: Forward the SETUP request to the UDI handler and return the result\n    return udi_handler->setup(current_setup_req);\n}", "CodeBleu_score": 33.57892613973984}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void) {\n    // Initialize internal states and flags\n    bool lun_ready = false;\n    int num_luns = udi_msc_get_num_luns(); // Assume this is a function to fetch the number of LUNs\n\n    // Check if there are any LUNs to manage\n    if (num_luns == 0) {\n        return false; // No LUNs available\n    }\n\n    // External enable function call\n    if (!external_msc_enable()) { // Assume this is a function that attempts to enable MSC externally and returns bool\n        return false; // External enable function failed\n    }\n\n    // Unloading the medium on each LUN\n    for (int lun = 0; lun < num_luns; lun++) {\n        if (!udi_msc_unload_lun(lun)) { // Assume this function unloads the medium for a given LUN and returns bool\n            continue; // If unloading fails, continue with other LUNs\n        }\n    }\n\n    // Everything set, now waiting for CBW reception\n    // This function may continuously check or set up an interrupt for receiving a CBW\n    udi_msc_start_cbw_reception(); // Assume this function starts the procedure to wait/receive a CBW\n\n    return true; // MSC enabled successfully\n}", "CodeBleu_score": 35.86787314470368}, {"code": "bool udi_msc_enable(void) {\n    // Initialize flags and other parameters\n    bool is_media_loaded = false;\n    bool external_enable_successful = true;\n\n    // Retrieve the number of Logical Unit Numbers (LUNs)\n    int num_luns = msc_get_number_of_luns();\n\n    if (num_luns == 0) {\n        // No LUNs are available, cannot enable MSC\n        return false;\n    }\n\n    // Loop over each LUN to unload the medium\n    for (int lun = 0; lun < num_luns; lun++) {\n        // Assuming a function that unloads medium for a specific LUN\n        if (!msc_unload_media(lun)) {\n            // If unloading failed, set flag to false\n            is_media_loaded = false;\n        }\n    }\n\n    // External function to enable MSC interface; returns true if successful\n    external_enable_successful = msc_external_enable();\n\n    if (!external_enable_successful) {\n        // External enabling failed, cannot proceed\n        return false;\n    }\n\n    // Start the Mass Storage Class interface by waiting for a Command Block Wrapper (CBW)\n    msc_wait_for_cbw();\n\n    return true; // Successfully completed initialization and starting MSC\n}", "CodeBleu_score": 46.006641691158094}, {"code": "#include <stdbool.h>\n\n// This might be part of some larger project, which includes these variables elsewhere\nextern bool udi_msc_media_unload(int lun); // Simulate medium unload for each LUN\nextern bool udi_external_enable(void); // External enable function\nextern int get_number_of_luns(void); // Function to retrieve the number of LUNs\n\nbool udi_msc_enable(void) {\n    // Retrieve the number of LUNs from a supposed system function\n    int num_luns = get_number_of_luns();\n    if (num_luns == 0) {\n        // No LUNs are available, return false\n        return false;\n    }\n\n    // Attempt to enable the device externally, maybe some hardware or system level enable\n    if (!udi_external_enable()) {\n        // If the external enabling fails, return false\n        return false;\n    }\n\n    // Unload medium on each LUN\n    for (int lun = 0; lun < num_luns; lun++) {\n        if(!udi_msc_media_unload(lun)) {\n            // If unable to unload medium on any LUN, consider this a critical failure\n            return false;\n        }\n    }\n\n    // Here we would start the MSC process, assuming waiting for Command Block Wrapper (CBW) reception\n    // Initialization of the process to wait for CBW should go here\n    // For example:\n    // if (!msc_start_cbw_reception()) {\n    //     return false;\n    // }\n\n    // Since we successfully initialized everything, return true\n    return true;\n}", "CodeBleu_score": 39.01824809452859}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent, udd_ep_id_t ep) {\n    // Check the transfer completion status\n    if (status != UDD_EP_TRANSFER_OK) {\n        // Transfer not successful, wait for a MSC setup reset to restart CBW reception\n        msc_reset_cbw();\n        return;\n    }\n\n    // Transfer was successful, update the sense data\n    msc_update_sense_data();\n\n    // Decrease the data residue in the CSW by the amount of data sent\n    msc_csw.residue -= nb_sent;\n\n    // Process the updated CSW\n    msc_process_csw();\n}", "CodeBleu_score": 59.394622743726075}, {"code": "#include <stdbool.h>\n\n// Mock definitions for types and constants (modify according to actual definitions in your context)\ntypedef int udd_ep_status_t;\ntypedef size_t iram_size_t;\ntypedef int udd_ep_id_t;\n\n#define UDD_EP_TRANSFER_OK 0        // Assume 0 is the status for a successful transfer\n#define MSC_CBW_SIZE 31             // Assume Command Block Wrapper has a constant size\n\n// Global or external definitions (should be defined corresponding to actual implementation detail)\nextern bool msc_setup_reset;\nextern udd_ep_id_t msc_ep_in;\nextern void msc_reset_cbw(void);\nextern void msc_update_csw(iram_size_t nb_sent);\nextern void msc_update_sense_data(void);\n\nstatic void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent, udd_ep_id_t ep) {\n    // Check if the transfer status indicates failure\n    if (status != UDD_EP_TRANSFER_OK) {\n        // Implement handling for failed data transfer\n        if (msc_setup_reset) {\n            // A MSC setup reset is needed to restart CBW reception\n            msc_reset_cbw();\n            msc_setup_reset = false; // Reset the reset flag after handling\n        }\n    } else {\n        // Handle successful data transfer\n        // Update the sense data as the operation was successful\n        msc_update_sense_data();\n        \n        // Decrease the data residue in the Command Status Wrapper (CSW) by the amount of data sent\n        msc_update_csw(nb_sent);\n\n        // Continue processing the updated CSW\n        // This might involve sending more data, checking command completion, etc.\n        // Mock function to process updated CSW, define it as per actual implementation detail\n        process_updated_csw();\n    }\n}\n\n// You would need to implement or define the following functions according to your specific requirements:\n// void msc_reset_cbw(void);\n// void msc_update_csw(iram_size_t nb_sent);\n// void msc_update_sense_data(void);\n// void process_updated_csw(void);", "CodeBleu_score": 40.3756856927425}, {"code": "// Include or assume existence of necessary headers and definitions including CSW and CBW handling\n#include \"udi_msc_types.h\"\n#include \"usb_protocol_msc.h\"\n\n// Function to handle completion of data transfer in MSC\nstatic void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent, udd_ep_id_t ep) {\n    // Check the status of the transfer\n    if (status != UDD_EP_TRANSFER_OK) {\n        // Transfer was not successful\n        // Handling error or waiting for an MSC Setup Reset\n        if (udi_msc_wait_reset_msc()) {\n            udi_msc_restart_cbw_reception();\n        } else {\n            // Proper error handling, like logging error or signaling some LED/error flag\n            // Error reporting mechanism or similar\n        }\n    } else {\n        // Transfer was successful\n        // Update the sense data according to the specific application needs or status\n        udi_msc_update_sense_data(SD_WRITE_OK); //SD_WRITE_OK is a placeholder for actual sense code\n\n        // Decrease the data residue in the CSW by the amount of data sent\n        if (g_udi_msc_csw.dDataResidue > nb_sent) {\n            g_udi_msc_csw.dDataResidue -= nb_sent;\n        } else {\n            g_udi_msc_csw.dDataResidue = 0;\n        }\n        \n        // Further process the CSW, sending it back to host or transitioning to the next stage\n        udi_msc_process_csw();\n\n        // Optionally start receiving the next CBW if required\n        udi_msc_receive_next_cbw();\n    }\n}", "CodeBleu_score": 50.03562204857741}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n// Presuming some constants and structures based on context.\n\n#define USB_ENDPOINT_IN  0x80\n#define USB_ENDPOINT_OUT 0x00\n\n// Simulation of USB endpoint stalling function\nstatic void usb_stall_endpoint(uint8_t endpoint) {\n    // Stalls the specified endpoint\n    // This is a placeholder function\n}\n\n// Placeholder for USB send function\nstatic bool usb_send(uint8_t endpoint, const void* data, uint32_t length) {\n    // Sends data over USB\n    // This is a placeholder function\n    return true;\n}\n\n// Assuming previously defined or globally accessible structures and variables\ntypedef struct {\n    uint32_t signature;\n    uint32_t tag;\n    uint32_t dataResidue;\n    uint8_t status;\n} CommandStatusWrapper;\n\ntypedef struct {\n    uint8_t flags;\n} CommandBlockWrapper;\n\nextern CommandBlockWrapper current_cbw;\nextern CommandStatusWrapper current_csw;\n\n// Function to convert to little-endian; adjust as necessary\nstatic uint32_t to_little_endian(uint32_t value) {\n    return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 |\n           (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24;\n}\n\n// Main function implementation\nstatic void udi_msc_csw_process(void) {\n    // Handle data residue and stall condition\n    if (current_csw.dataResidue != 0) {\n        // Determine the endpoint direction from the CBW\n        uint8_t endpoint = (current_cbw.flags & USB_ENDPOINT_IN) ? USB_ENDPOINT_IN : USB_ENDPOINT_OUT;\n        \n        // Stall the endpoint\n        usb_stall_endpoint(endpoint);\n    }\n\n    // Prepare the CSW by setting its tag and converting the data residue\n    current_csw.tag = current_cbw.tag; // Presuming it must correlate with the CBW tag\n    current_csw.dataResidue = to_little_endian(current_csw.dataResidue);\n\n    // Send CSW over the appropriate IN endpoint, assuming fixed endpoint for CSW\n    uint8_t csw_endpoint = USB_ENDPOINT_IN; // Typically the control endpoint, adjust as necessary\n    if (!usb_send(csw_endpoint, &current_csw, sizeof(current_csw))) {\n        // Error handling or retry mechanism can be placed here if necessary\n    }\n}", "CodeBleu_score": 40.867105173129765}, {"code": "static void udi_msc_csw_process(void) {\n    // Check for non-zero data residue\n    if (msc_csw.dDataResidue != 0) {\n        // Stall the appropriate endpoint based on the CBW direction\n        if (msc_cbw.bmCBWFlags & 0x80) {\n            // Direction is IN (device to host), stall IN endpoint\n            udi_msc_stall_in();\n        } else {\n            // Direction is OUT (host to device), stall OUT endpoint\n            udi_msc_stall_out();\n        }\n    }\n\n    // Prepare the CSW (Command Status Wrapper)\n    // Copy the Command Block Wrapper (CBW) tag to CSW tag\n    msc_csw.dCSWTag = msc_cbw.dCBWTag;\n\n    // Convert data residue to little-endian format\n    msc_csw.dDataResidue = to_little_endian(msc_csw.dDataResidue);\n\n    // Set CSW status\n    // Assuming msc_csw.bCSWStatus is to be determined based on some conditions or set in other parts of the implementation.\n    // For example, let's assume:\n    msc_csw.bCSWStatus = (msc_csw.dDataResidue != 0) ? CSW_STATUS_FAILED : CSW_STATUS_SUCCESS;\n\n    // Send the CSW back to the host\n    udi_msc_send_csw();\n}", "CodeBleu_score": 51.973083171579205}, {"code": "#include <stdint.h>\n#include <stdbool.h>\n\n// Assume these are defined elsewhere\nextern uint32_t data_residue; // The data residue from the last operation.\nextern bool data_direction; // Direction of CBW data, assumed `true` for IN, `false` for OUT.\nextern uint32_t cbw_tag; // Current Command Block Wrapper tag.\n\n// Prototypes - these would need real implementations\nvoid usb_endpoint_stall(bool direction);\nvoid send_csw(uint32_t tag, uint32_t residue);\nuint32_t to_little_endian(uint32_t value);\n\n// Function Implementation\nstatic void udi_msc_csw_process(void) {\n    // Step 1: Check for non-zero data residue\n    if (data_residue != 0) {\n        // Step 2: Stall the endpoint depending on the direction in CBW\n        usb_endpoint_stall(data_direction);\n\n        // Step 3 onwards might be handled after stall...assuming direct handling here:\n    }\n\n    // Step 3: Prepare CSW: Set its tag from CBW\n    uint32_t csw_tag = cbw_tag;\n\n    // Step 4: Convert data residue to little endian\n    uint32_t le_residue = to_little_endian(data_residue);\n\n    // Step 5: Send the CSW\n    send_csw(csw_tag, le_residue);\n}\n\n// Example implementations for assumed functions\nvoid usb_endpoint_stall(bool direction) {\n    if (direction) {\n        // Stall IN endpoint\n        // actual_stall_endpoint(endpoint_in_address);\n    } else {\n        // Stall OUT endpoint\n        // actual_stall_endpoint(endpoint_out_address);\n    }\n}\n\nuint32_t to_little_endian(uint32_t value) {\n    return (value & 0xFF) << 24 |\n           (value & 0xFF00) << 8 |\n           (value & 0xFF0000) >> 8 |\n           (value & 0xFF000000) >> 24;\n}\n\nvoid send_csw(uint32_t tag, uint32_t residue) {\n    // Code to send the CSW over USB\n    // usb_msc_send_csw(tag, residue);\n}", "CodeBleu_score": 31.455996460831315}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "#include <stdint.h>\n#include <stdbool.h>\n\n// Assuming `initiateReset` and `cancelReset` are declared elsewhere in the codebase.\nextern void initiateReset();\nextern void cancelReset();\n\nvoid usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable) {\n    // Presuming `getDTRRate` retrieves the DTR baud rate for the specified port.\n    int dtrRate = getDTRRate(port);\n\n    // Check if rate is 1200 and adapt behavior based on the DTR status.\n    if (dtrRate == 1200) {\n        if (!b_enable) {\n            // When DTR signal is disabled and the rate is 1200bps,\n            // we initiate a delayed reset via a reset controller.\n            initiateReset();\n        } else {\n            // If DTR signal is enabled, we cancel any scheduled resets.\n            cancelReset();\n        }\n    }\n}", "CodeBleu_score": 41.066132028563764}, {"code": "#include <stdbool.h>\n#include <stdint.h>\n\n// Placeholder for external functions that should be defined elsewhere in your application\nextern void write_to_reset_controller(void);  // Function to write to the reset controller\nextern void initiateReset(void);              // Function to initiate system reset\nextern void cancelReset(void);                // Function to cancel any scheduled system reset\nextern uint16_t get_baud_rate(uint8_t port);  // Function to get current baud rate of the port\n\nvoid usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable) {\n    // Check current baud rate for the specified port\n    uint16_t baud_rate = get_baud_rate(port);\n    \n    // Check the DTR status and the baud rate\n    if (baud_rate == 1200) {\n        if (!b_enable) {\n            // DTR is disabled at baud rate of 1200, schedule a system reset\n            write_to_reset_controller();\n            initiateReset();\n        }\n    }\n    \n    if (b_enable) {\n        // DTR is enabled, cancel any pending system resets\n        cancelReset();\n    }\n}", "CodeBleu_score": 33.68941969820972}, {"code": "#include <stdbool.h>\n#include <stdint.h>\n\n// Mock functions to represent the system reset functionality\nvoid writeResetController() {\n    // Code to handle writing to the hardware reset controller\n}\n\nvoid initiateReset() {\n    // Code to initiate system reset\n}\n\nvoid cancelReset() {\n    // Code to cancel any pending system reset\n}\n\nvoid usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable) {\n    // Logically store the DTR state and settings, possibly in some global or static memory\n    static bool dtr_status[256]; // Assuming a maximum of 256 ports\n    static int dtr_rate[256]; // DTR rate associated with each port\n\n    // Update the DTR status for the specified port\n    dtr_status[port] = b_enable;\n\n    // Check if DTR rate is 1200 for the specified port\n    if (dtr_rate[port] == 1200) {\n        if (!b_enable) {\n            // DTR signal is disabled at a rate of 1200, schedule a system reset\n            writeResetController();\n            initiateReset();\n        } else {\n            // If DTR signal is enabled, cancel any scheduled reset\n            cancelReset();\n        }\n    }\n}", "CodeBleu_score": 43.715893437041935}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "#include <stdbool.h>\n#include <stdint.h>\n\n// Assuming there are external defines or imports providing these values\nextern uint8_t* ms_compatible_id_descriptor;\nextern uint32_t ms_compatible_id_descriptor_size;\nextern uint8_t* ms_ext_prop_descriptor;\nextern uint32_t ms_ext_prop_descriptor_size;\n\n// Placeholder for the control request data structure and function to update its payload\ntypedef struct {\n    uint8_t request_index;\n    uint8_t* data_pointer;\n    uint32_t data_size;\n} control_request_t;\n\nextern control_request_t usb_control_request;\nextern void update_control_request_payload(uint8_t* data_pointer, uint32_t data_size);\n\n// Function to check the request type and process requests based on indices\nbool usb_task_other_requests(void) {\n    // Checking which USB Vendor-specific request has been received\n    switch(usb_control_request.request_index) {\n        case 0x04: // Microsoft OS 1.0 Descriptor request index (commonly used for Compatible ID descriptor)\n            update_control_request_payload(ms_compatible_id_descriptor, ms_compatible_id_descriptor_size);\n            return true;  // Indicate that the request has been processed\n\n        case 0x05: // Microsoft OS 1.0 Descriptor request index for Extended properties\n            update_control_request_payload(ms_ext_prop_descriptor, ms_ext_prop_descriptor_size);\n            return true; // Indicate that the request has been processed\n\n        default:\n            // If the request index is not recognized, return false\n            return false;\n    }\n}", "CodeBleu_score": 17.8740518415184}, {"code": "#include <stdbool.h>\n\n#define MICROSOFT_COMPAT_ID_INDEX 0x04\n#define MICROSOFT_EXT_PROP_INDEX 0x05\n\n// Assuming these are defined somewhere appropriately\nextern unsigned char* control_request_payload;\nextern int control_request_size;\n\nbool usb_task_other_requests(void) {\n    int request_index = get_request_index(); // Pseudo function to get the current control transfer request index\n\n    switch (request_index) {\n        case MICROSOFT_COMPAT_ID_INDEX:\n            // Set pointer and size for Microsoft Compatible ID descriptor\n            control_request_payload = get_microsoft_compat_id_descriptor(); // Assume this function returns a pointer to the descriptor\n            control_request_size = get_microsoft_compat_id_size();  // Assume this function returns the size of the descriptor\n            return true;\n\n        case MICROSOFT_EXT_PROP_INDEX:\n            // Set pointer and size for Microsoft Extended Properties descriptor\n            control_request_payload = get_microsoft_ext_prop_descriptor(); // Assume this function returns a pointer to the descriptor\n            control_request_size = get_microsoft_ext_prop_size();  // Assume this function returns the size of the descriptor\n            return true;\n\n        default:\n            // Request index not recognized, do not process\n            return false;\n    }\n}\n\n// Placeholder for assumed external functions, should be implemented specifically per actual context\nint get_request_index() {\n    // Implementation depends on actual system firmware/API\n    return 0;\n}\n\nunsigned char* get_microsoft_compat_id_descriptor() {\n    static unsigned char descriptor[] = {}; // Details should be filled in with actual descriptor content\n    return descriptor;\n}\n\nint get_microsoft_compat_id_size() {\n    return sizeof(get_microsoft_compat_id_descriptor());\n}\n\nunsigned char* get_microsoft_ext_prop_descriptor() {\n    static unsigned char ext_prop_descriptor[] = {}; // Details should be filled in with actual descriptor content\n    return ext_prop_descriptor;\n}\n\nint get_microsoft_ext_prop_size() {\n    return sizeof(get_microsoft_ext_prop_descriptor());\n}", "CodeBleu_score": 28.267196745159072}, {"code": "#include <stdbool.h>\n\n// Mock definitions for the setup packet structure and control transfer details.\ntypedef struct {\n    uint8_t bmRequestType;\n    uint8_t bRequest;\n    uint16_t wValue;\n    uint16_t wIndex;\n    uint16_t wLength;\n} USB_SetupPacket;\n\n// Assuming extern declarations for these handlers\nextern void* get_microsoft_compat_id_descriptor(uint16_t* size);\nextern void* get_microsoft_ext_prop_descriptor(uint16_t* size);\nextern USB_SetupPacket SetupPacket; // This would typically be provided by the USB driver context\nextern void usb_control_send_data(void* data, uint16_t size);\n\nbool usb_task_other_requests(void) {\n    // Assume that the request type and request are part of a Vendor-Specific control request logic provided elsewhere\n    const uint8_t REQ_MS_VENDOR_CODE = 0x30; // Vendor request code for Microsoft descriptors (for example)\n\n    // Check if this is a vendor-specific request for Microsoft descriptors\n    if (SetupPacket.bmRequestType & 0x60) { // mask to check if this is vendor type request\n        switch (SetupPacket.wIndex) {\n            case 0x04: { // Microsoft Compatible ID Feature Descriptor\n                if (SetupPacket.bRequest == REQ_MS_VENDOR_CODE) {\n                    uint16_t size;\n                    void *pDescriptor = get_microsoft_compat_id_descriptor(&size);\n                    if (pDescriptor != NULL && size > 0) {\n                        usb_control_send_data(pDescriptor, size);\n                        return true;\n                    }\n                }\n                break;\n            }\n            case 0x05: { // Microsoft Extended Properties Feature Descriptor\n                if (SetupPacket.bRequest == REQ_MS_VENDOR_CODE) {\n                    uint16_t size;\n                    void *pDescriptor = get_microsoft_ext_prop_descriptor(&size);\n                    if (pDescriptor != NULL && size > 0) {\n                        usb_control_send_data(pDescriptor, size);\n                        return true;\n                    }\n                }\n                break;\n            }\n            default:\n                // If the index is not recognized, return false to allow further processing\n                break;\n        }\n    }\n    // If we reach here, the required vendor-specific request was not processed\n    return false;\n}", "CodeBleu_score": 30.132368629354563}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte) {\n    if (nbyte == 0) {\n        return;\n    }\n\n    uint8_t dummy_byte = 0xFF; // Commonly used dummy byte for SPI\n    uint16_t i;\n\n    for (i = 0; i < nbyte - 1; i++) {\n        // Send a dummy byte to generate clock signal\n        while (!(SPI1->SR & SPI_SR_TXE));  // Wait for transmit buffer to be empty\n        SPI1->DR = dummy_byte;\n\n        // Wait for the byte to be received\n        while (!(SPI1->SR & SPI_SR_RXNE)); // Wait for receive buffer not empty\n        buf[i] = SPI1->DR; // Read the received byte\n    }\n\n    // Read the last byte using separate function\n    buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 43.913580278363526}, {"code": "#include <stdint.h> // For uint8_t and uint16_t data types\n\n// Dummy functions representing SPI hardware interactions.\n// These should be replaced with real hardware specific implementations\nvoid spiSend(uint8_t data) {\n    // Simulates sending a byte over SPI.\n    // Replace it with the actual SPI send function.\n}\n\nuint8_t spiRec() {\n    // Simulates receiving a byte over SPI.\n    // Replace it with the actual SPI receive function.\n    return 0xFF; // Dummy data, replace with actual received data.\n}\n\nvoid spiRead(uint8_t *buf, uint16_t nbyte) {\n    if (nbyte == 0) return; // If no bytes to read, return immediately.\n\n    uint16_t i;\n    for (i = 0; i < nbyte - 1; i++) {\n        spiSend(0xFF); // Send dummy byte to generate clock for receiving byte.\n        buf[i] = spiRec(); // Store received byte into the buffer.\n    }\n\n    // Read and store the last byte\n    buf[nbyte - 1] = spiRec();\n}", "CodeBleu_score": 39.635005769927325}, {"code": "#include <stdint.h>\n\n// Assumed external function prototypes (since actual SPI hardware control APIs depend on the specific platform/hardware)\nextern void spiSendDummyByte(void);  // Sends a dummy byte to trigger SPI data reception\nextern uint8_t spiReceiveByte(void); // Receives a byte from SPI\nextern uint8_t spiRec(void);         // Alternative function generally used to perform a receive operation in a specific manner as the last byte\n\nvoid spiRead(uint8_t *buf, uint16_t nbyte) {\n    // Check if there is anything to read\n    if (nbyte == 0) {\n        return;\n    }\n\n    // Read nbyte-1 bytes in a loop\n    for (uint16_t i = 0; i < nbyte - 1; i++) {\n        spiSendDummyByte();              // Send a dummy byte to push the SPI clock\n        buf[i] = spiReceiveByte();       // Store the incoming byte into the buffer\n    }\n\n    // Read the last byte using the special spiRec function\n    buf[nbyte - 1] = spiRec();           // Read and store the last byte using a potentially different method\n}", "CodeBleu_score": 35.04169890328518}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "#include <stdint.h> // Include standard definitions\n\n// Type definition for a pointer to an ISR handler function\ntypedef void (*pfnISR_Handler)(void);\n\n// Assumed global declaration for the base address of the interrupt vector table\nextern pfnISR_Handler *g_pVectorTable;\n\nvoid disable_interrupts();\nvoid enable_interrupts();\n\n/**\n * @brief Installs a new interrupt service routine (ISR) handler for a specified interrupt request (IRQ) and returns the original handler.\n * \n * @param irq The IRQ number for which to change the ISR.\n * @param newHandler Pointer to the new ISR function.\n * @return pfnISR_Handler The original ISR handler.\n */\npfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler) {\n    // Ensuring IRQ number is within plausible range (example limit; adjust as necessary).\n    if (irq < 0 || irq >= MAX_IRQ_NUMBER)\n        return NULL;\n\n    disable_interrupts();  // Disable interrupts to ensure atomic access\n\n    // Retrieve the current handler from the vector table\n    pfnISR_Handler originalHandler = g_pVectorTable[irq];\n\n    // Insert the new handler into the vector table\n    g_pVectorTable[irq] = newHandler;\n\n    enable_interrupts(); // Re-enable interrupts\n\n    return originalHandler;  // Return the original handler\n}\n\n// Platform-dependent implementations of interrupt control (simulated for this context)\nvoid disable_interrupts() {\n    __asm(\"CPSID i\"); // Arm-specific instruction to disable interrupts\n}\n\nvoid enable_interrupts() {\n    __asm(\"CPSIE i\"); // Arm-specific instruction to enable interrupts\n}", "CodeBleu_score": 43.53450439288305}, {"code": "#include <stdint.h>\n\n// Define the type for the ISR Handler function pointer\ntypedef void (*pfnISR_Handler)(void);\n\n// IRQ number type definition\ntypedef int IRQn_Type;\n\n// Interrupt Vector Table structure\nextern pfnISR_Handler* InterruptVectorTable;\n\n// Function to disable global interrupts, typically IRQs\nvoid disable_global_interrupts() {\n    __asm(\"CPSID i\"); // ARM Cortex-M instruction to disable interrupts\n}\n\n// Function to enable global interrupts, typically IRQs\nvoid enable_global_interrupts() {\n    __asm(\"CPSIE i\"); // ARM Cortex-M instruction to enable interrupts\n}\n\n// Abstract representation to get the address of the relocated interrupt vector table\npfnISR_Handler* get_interrupt_vector_table_address() {\n    // Assuming a fixed location or some sort of mechanism to retrieve it\n    // e.g., reading from a specific system control block register or a fixed memory location\n    return InterruptVectorTable;\n}\n\n// Foundation of 'install_isr' function based on the provided docstring\npfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler) {\n    // Retrieve the interrupt vector table\n    pfnISR_Handler* vectorTable = get_interrupt_vector_table_address();\n\n    // Disable global interrupts\n    disable_global_interrupts();\n\n    // Retrieve the current handler for the specified IRQ and replace it with the new handler\n    pfnISR_Handler originalHandler = vectorTable[irq];\n    vectorTable[irq] = newHandler;\n\n    // Re-enable global interrupts\n    enable_global_interrupts();\n\n    // Return the original handler\n    return originalHandler;\n}", "CodeBleu_score": 39.132553793179845}, {"code": "typedef void (*pfnISR_Handler)(void);  // Define a function pointer type for ISR handlers\n\nextern pfnISR_Handler* interrupt_vector_table;  // Assuming this points to the interrupt vector table\n\n#include <stdint.h>\n\n// Mock definition for IRQn_Type for this example\ntypedef uint32_t IRQn_Type;\n\n// Function to disable all interrupts (platform-specific implementation needed)\nvoid disable_interrupts(void) {\n    // Implementation depends on the architecture.\n    // For example, on ARM Cortex-M, you might use __disable_irq();\n}\n\n// Function to enable all interrupts (platform-specific implementation needed)\nvoid enable_interrupts(void) {\n    // Implementation depends on the architecture.\n    // For example, on ARM Cortex-M, you might use __enable_irq();\n}\n\npfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler) {\n    if (!newHandler) {\n        return NULL;  // Check if the new handler is not NULL\n    }\n\n    disable_interrupts();  // Disable interrupts to prevent ISR during swap\n\n    // Assuming the interrupt vector table is at a known location and each entry is a pfnISR_Handler\n    pfnISR_Handler oldHandler = interrupt_vector_table[irq];  // Get the current ISR handler\n    interrupt_vector_table[irq] = newHandler;  // Set the new ISR handler\n\n    enable_interrupts();  // Re-enable interrupts\n\n    return oldHandler;  // Return the old ISR handler\n}", "CodeBleu_score": 40.790742504053995}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek() {\n    // Check if USB CDC is configured and connected\n    if (!usb_cdc_is_connected()) {\n        return -1;  // CDC not enabled or not configured\n    }\n    \n    // Check if there are bytes available in the receive buffer\n    if (serial_available()) {\n        char next_char = serial_peek();  // Peek at the next character without removing it from the buffer\n        \n        // If emergency parser is enabled, process the peeked character\n        if (emergency_parser_enabled) {\n            emergency_parse(next_char);\n        }\n        \n        return next_char;  // Return the character casted to int (if char is unsigned, casting ensures correct value)\n    }\n\n    // No bytes available\n    return -1;\n}", "CodeBleu_score": 33.72336619856783}, {"code": "#include <USBSerial.h>\n\nclass MarlinSerialUSB {\npublic:\n    USBSerial usbSerial;  // Assuming an object of USBSerial type for serial operations\n    bool emergencyParserEnabled;\n\n    MarlinSerialUSB() : emergencyParserEnabled(false) {\n        // Constructor initializes USB serial connection\n        usbSerial.begin();  // Begin USB serial communication\n    }\n\n    void enableEmergencyParser() {\n        emergencyParserEnabled = true;\n    }\n\n    void disableEmergencyParser() {\n        emergencyParserEnabled = false;\n    }\n\n    int peek() {\n        if (!usbSerial) {\n            // Check if USB CDC is not enabled or configured\n            return -1;\n        }\n        \n        if (usbSerial.available()) {\n            int nextChar = usbSerial.peek();  // Read the next character without removing it from the buffer\n            if (emergencyParserEnabled) {\n                // Process the character if emergency parser is enabled\n                processEmergencyCharacter(nextChar);\n            }\n            return nextChar;\n        } else {\n            // No characters are available in the buffer\n            return -1;\n        }\n    }\n\nprivate:\n    void processEmergencyCharacter(int ch) {\n        // A placeholder function that gets called if the emergency parser is enabled\n        // Here you would manage specific characters that trigger emergency actions\n    }\n};", "CodeBleu_score": 30.34739856323029}, {"code": "int MarlinSerialUSB::peek() {\n    if (!USBDevice.configured() || !SerialUSB.available()) { \n        return -1; // Return -1 if the interface is not configured or if no data is available\n    }\n\n    // Peek at the next character without removing it from the buffer\n    int charVal = SerialUSB.peek();\n\n    // Typically USB CDC implementations do not process data at the peek stage, only on read, \n    // but if any special processing such as an emergency parser is necessary which deviates from common behavior, it can be handled here.\n    // Just be sure this implementation conforms with how you have framed your data flow.\n    \n    // Notice: Add any type of preprocessing conditions here if applicable\n    // if (emergency_parser_enabled && emergencyCondition(charVal)) {\n    //     handleEmergency(charVal);\n    // }\n\n    return charVal; // return the peeked character\n}", "CodeBleu_score": 22.454526152766732}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read() {\n    // Check if there is a pending character.\n    if (!pendingCharacter.empty()) {\n        char ch = pendingCharacter.front();\n        pendingCharacter.pop();\n        return ch;\n    }\n\n    // Check if the USB CDC (Communications Device Class) is enabled and configured.\n    if (!usb_cdc_enabled || !usb_configured()) {\n        return -1;\n    }\n\n    // Check if there are any bytes available to read from the PC\n    if (usb_available() == 0) {\n        return -1;\n    }\n\n    // Read a byte\n    char byteRead = usb_read();\n\n    // Update the emergency parser if it is enabled\n    #ifdef ENABLE_EMERGENCY_PARSER\n        emergency_parser.update(byteRead);\n    #endif\n\n    // Return the read character\n    return byteRead;\n}", "CodeBleu_score": 48.055469733435906}, {"code": "int MarlinSerialUSB::read() {\n    // Check if USB CDC is enabled and configured\n    if (!USBDevice.configured() || !plugged()) {\n        return -1;  // Return -1 if USB is not properly configured or not plugged in\n    }\n\n    // Check if there is a character pending\n    if (pendingCharacter >= 0) {\n        int retChar = pendingCharacter;\n        pendingCharacter = -1;  // Reset pending character\n        return retChar;  // Return the pending character\n    }\n\n    // Check if there are bytes available from the PC\n    if (USBSerial.available() <= 0) {\n        return -1;  // Return -1 if no bytes are available to read\n    }\n\n    // Read the available byte\n    int charRead = USBSerial.read();\n\n    // Update emergency parser if enabled\n    #ifdef EMERGENCY_PARSER_ENABLED\n    emergency_parser.update(charRead);\n    #endif\n\n    return charRead;  // Return the read character\n}", "CodeBleu_score": 44.16099328222267}, {"code": "int MarlinSerialUSB::read() {\n    // Check if there is a pending character in the buffer and return it\n    if (!rx_buffer.isEmpty()) {\n        return rx_buffer.dequeue();\n    }\n\n    // Check if USB CDC is enabled and configured\n    if (!USBDevice.configured()) {\n        return -1;\n    }\n\n    // Check if there are any bytes available from the PC\n    if (USBDevice.available() == 0) {\n        return -1;\n    }\n\n    // Read a byte\n    int ch = USBDevice.readByte();\n\n    // Optionally, check for emergency parsing feature if enabled.\n#ifdef ENABLE_EMERGENCY_PARSER\n    emergency_parser.update(ch);\n#endif\n\n    // Return the byte that was read\n    return ch;\n}", "CodeBleu_score": 41.03293109555891}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available() {\n    // Check the number of bytes available in the serial buffer\n    int count = usb_serial_get_pending_data_count();\n\n    if (count > 0) {\n        // Return the number of available characters if more than zero\n        return count;\n    } else {\n        // Check if USB CDC is configured and can potentially receive data\n        if (usb_serial_is_cdc_enabled()) {\n            // Check for any other condition or return a specific status indicating it's ready but no data\n            return 0; // No data available, but CDC is enabled\n        } else {\n            // Return a negative value or specific error code indicating USB CDC is not ready\n            return -1;\n        }\n    }\n}", "CodeBleu_score": 46.60051412815685}, {"code": "#include \"MarlinSerialUSB.h\"\n\nint MarlinSerialUSB::available() {\n    // Assuming `serialBuffer` is a data member that holds the character buffer for USB serial communication\n    // and `pendingCharacters()` is a member function that returns the count of unread characters in the buffer.\n    int pendingCount = serialBuffer.pendingCharacters();\n\n    if (pendingCount > 0) {\n        return pendingCount;  // Return number of characters waiting to be read\n    } else {\n        // Assuming `isUSBCDCReady()` is a method to check if the USB CDC interface is connected and ready\n        if (isUSBCDCReady()) {\n            return 0;  // USB CDC is ready, but no characters are pending\n        } else {\n            return -1; // USB CDC is not ready, indicating a status issue\n        }\n    }\n}\n\nbool MarlinSerialUSB::isUSBCDCReady() {\n    // Hypothetical function to check readiness of USB CDC\n    // This could be linked to actual hardware or USB middleware stack status checks\n    // Here, we assume `usbCDCStatus` is a status flag indicating readiness\n    return usbCDCStatus;\n}", "CodeBleu_score": 44.3298129571855}, {"code": "int MarlinSerialUSB::available() {\n    // Check if there are characters in the USB serial buffer\n    if (!usbSerialBuffer.empty()) {\n        // Return the number of available characters in the buffer\n        return usbSerialBuffer.size();\n    }\n\n    // If the buffer is empty, check the state of the USB communication\n    if (usbCDC.isEnabled() && usbCDC.isReady()) {\n        // If the USB CDC is enabled and ready, check and return further available characters\n        return usbCDC.availableCharactersCount();\n    } else {\n        // If USB CDC is not ready or not enabled, return 0 indicating no characters are available\n        return 0;\n    }\n}", "CodeBleu_score": 30.516703632668996}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "#include <cstdint> // For standard fixed-width integers\n\nclass PersistentStore {\npublic:\n    // I'm using a simplified placeholder CRC calculation using XOR for demonstration.\n    void update_crc(uint16_t &crcValue, uint8_t data) {\n        crcValue ^= data;\n    }\n\n    bool read_persistent_storage(int pos, uint8_t &data) {\n        // This should actually read a byte from persistent storage starting at position 'pos'.\n        // Here is a dummy implementation for the example:\n        // Let's pretend our storage is just consecutive bytes starting from 0x00, 0x01, and so on.\n        data = static_cast<uint8_t>(pos % 256);\n        return true; // Return true indicating read was successful\n    }\n\n    bool read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing = true) {\n        for (size_t i = 0; i < size; ++i) {\n            uint8_t data = 0;\n            if (!read_persistent_storage(pos, data)) {\n                return false; // failed to read storage\n            }\n            \n            // Update CRC\n            update_crc(*crc, data);\n\n            // If writing is true, write to the provided buffer\n            if (writing && value != nullptr) {\n                value[i] = data;\n            }\n\n            // Increment the position after reading each byte\n            pos++;\n        }\n        \n        return false; // As mentioned, the function returns false after completing the operation\n    }\n};\n\nint main() {\n    int startPosition = 0;\n    uint8_t buffer[100];\n    uint16_t crc = 0;\n    PersistentStore store;\n    bool result = store.read_data(startPosition, buffer, 100, &crc);\n\n    return 0;\n}", "CodeBleu_score": 37.590841740494405}, {"code": "#include <cstdint>\n\n// Hypothetical function signatures assumed needed\nuint8_t read_byte_from_storage(int position);\nvoid update_crc(uint16_t *crc, uint8_t data);\n\nclass PersistentStore {\npublic:\n    bool read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing = true) {\n        // Check for valid input parameters\n        if (crc == nullptr || size == 0) {\n            return false;\n        }\n\n        // Main loop to read data from storage\n        for (size_t i = 0; i < size; ++i) {\n            // Read a byte from storage\n            uint8_t data = read_byte_from_storage(pos);\n            \n            // Optionally, write the data to the 'value' buffer if provided\n            if (writing && value != nullptr) {\n                value[i] = data;\n            }\n\n            // Update the CRC with the data\n            update_crc(crc, data);\n\n            // Increment the read position\n            ++pos;\n        }\n\n        return false;  // According to the spec, always return false.\n    }\n};\n\n// Note: Functions read_byte_from_storage and update_crc should be implemented based on the actual storage and CRC algorithm being used.", "CodeBleu_score": 37.880511261159015}, {"code": "#include <cstdint>\n\nclass PersistentStore {\npublic:\n    // Placeholder for actual data reading method\n    uint8_t read_byte(int &pos);\n\n    // This method calculates the CRC update given a byte and existing CRC.\n    // It is a simple representation, actual implementation might be different depending on CRC algorithm used.\n    static void update_crc(uint16_t &crc, uint8_t data);\n\n    // Main read_data function described in the docstring\n    bool read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing = true) {\n        for (size_t i = 0; i < size; ++i) {\n            // Read a single byte from position pos\n            uint8_t byte = read_byte(pos);\n\n            // Optionally write byte to value buffer\n            if (value && writing) {\n                value[i] = byte;\n            }\n\n            // Update CRC value if crc pointer is provided\n            if (crc) {\n                update_crc(*crc, byte);\n            }\n\n            // Move to the next position\n            ++pos;\n        }\n        // Always returns false as per the docstring\n        return false;\n    }\n};\n\n// Placeholder implementation of update_crc method\nvoid PersistentStore::update_crc(uint16_t &crc, uint8_t data) {\n    crc = (crc >> 8) | (crc << 8);\n    crc ^= data;\n    crc ^= (crc & 0xff) >> 4;\n    crc ^= crc << 12;\n    crc ^= (crc & 0xff) << 5;\n}\n\n// Example of reading from a storage\nuint8_t PersistentStore::read_byte(int &pos) {\n    static const uint8_t example_data[] = {0x12, 0xAB, 0xCD, 0xEF}; // Example storage data\n    uint8_t byte = example_data[pos % (sizeof(example_data) / sizeof(example_data[0]))]; // Simulate reading from position\n    return byte;\n}\n\n// Inclusion of iostream for example usage\n#include <iostream>\n\nint main() {\n    PersistentStore store;\n    int position = 0;\n    uint8_t buffer[100];\n    uint16_t crc = 0;\n\n    store.read_data(position, buffer, sizeof(buffer), &crc);\n\n    std::cout << \"Data read to buffer up to position \" << position << \" with CRC: \" << crc << std::endl;\n    return 0;\n}", "CodeBleu_score": 39.52100648439669}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "#include <Arduino.h>\n\n#define PWM_FREQUENCY 5000          // Default PWM frequency\n#define PWM_RESOLUTION 8            // Default resolution (8-bit)\n#define MAX_HARDWARE_CHANNELS 16    // Placeholder for the number of available hardware channels\n\n// Static variable to track if software PWM is initialized\nstatic bool softwarePWMInitialized = false;\n\nvoid analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq = PWM_FREQUENCY, const uint16_t res = PWM_RESOLUTION) {\n    // Ensure pin is set to OUTPUT mode\n    pinMode(pin, OUTPUT);\n\n    // First, try to associate pin with a hardware PWM channel\n    bool hwPwmSuccess = false;\n    for (int channel = 0; channel < MAX_HARDWARE_CHANNELS; ++channel) {\n        if (ledcAttachPin(pin, channel) == 0) {\n            // Set PWM properties\n            ledcSetup(channel, freq, res);\n            // Scale the value according to the resolution\n            uint32_t dutyCycle = map(value, 0, pow(2, res) - 1, 0, 255);\n            ledcWrite(channel, dutyCycle);\n            hwPwmSuccess = true;\n            break;\n        }\n    }\n\n    if (!hwPwmSuccess) {\n        // Hardware PWM failed, attempt to use software PWM\n        if (!softwarePWMInitialized) {\n            // Initialization code for software PWM, e.g., start a timer\n            initSoftwarePWMIfNecessary();\n            softwarePWMInitialized = true;\n        }\n\n        // Allocate or find existing software PWM slot and set PWM\n        updatePWM(pin, value, freq, res);\n    }\n}\n\n// Dummy functions to emulate function behavior as needed.\nvoid initSoftwarePWMIfNecessary() {\n    // Initialize required timers and structures for software PWM.\n    // This is highly platform and implementation specific.\n}\n\nvoid updatePWM(pin_t pin, uint16_t value, uint32_t freq, uint16_t res) {\n    // Software PWM update (simplified version).\n    Serial.printf(\"Software PWM on pin %d to value %d at freq %dHz, resolution %d bits\\n\", pin, value, freq, res);\n}", "CodeBleu_score": 35.127495342274564}, {"code": "#include <Arduino.h>\n\n#define MAX_PWM_CHANNELS 16\n#define DEFAULT_PWM_FREQUENCY 5000\n#define HARDWARE_RES 8\n\n// Stub for hardware PWM channels management\nstruct PWMChannel {\n    pin_t pin;\n    bool inUse;\n    uint8_t channel;\n};\nPWMChannel pwmChannels[MAX_PWM_CHANNELS];\nint usedChannels = 0;\n\n// Initialize all PWM channels to not in use\nvoid initializePWMChannels() {\n    for (int i = 0; i < MAX_PWM_CHANNELS; ++i) {\n        pwmChannels[i].inUse = false;\n        pwmChannels[i].channel = i;\n    }\n}\n\n// Function to find an empty PWM channel\nint allocateChannel() {\n    for (int i = 0; i < MAX_PWM_CHANNELS; ++i) {\n        if (!pwmChannels[i].inUse) {\n            pwmChannels[i].inUse = true;\n            return i;\n        }\n    }\n    return -1;  // All channels are used\n}\n\n// Attach a pin to a PWM channel\nbool attachPinToPWM(const pin_t pin, uint16_t value, uint32_t freq) {\n    int channel = allocateChannel();\n    if (channel == -1) return false;  // No channels available\n\n    pwmChannels[channel].pin = pin;\n    ledcSetup(channel, freq, HARDWARE_RES);\n    ledcAttachPin(pin, channel);\n    ledcWrite(channel, value);\n\n    return true;\n}\n\n// Attempt to use hardware PWM, fallback to software PWM\nvoid analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq = DEFAULT_PWM_FREQUENCY, const uint16_t res = HARDWARE_RES) {\n    if (!attachPinToPWM(pin, value, freq)) {\n        // Currently, simple software PWM simulation\n        uint16_t pwmValue = map(value, 0, pow(2, res) - 1, 0, 127);  // convert to 7-bit if using software PWM\n        // More complex software PWM logic to manage timing would be needed in actual implementation.\n        analogWrite(pin, pwmValue); // Use default Arduino function as a fallback (Assuming its a non-PWM for simplicity)\n    }\n}\n\nvoid setup() {\n    initializePWMChannels();\n    // Setup code here\n}\n\nvoid loop() {\n    // Loop code here\n}", "CodeBleu_score": 42.268124307553784}, {"code": "#include <Arduino.h>\n\n#define PWM_FREQUENCY 5000 // Default PWM frequency\n#define TIMER_WIDTH 8      // Default timer resolution in bits\n\nstatic const int AVAILABLE_HARDWARE_CHANNELS = 16; // Example value, depends on specific hardware\nstatic int usedHardwareChannels = 0;\nstatic bool timersInitialized = false;\n\nstruct SoftwarePWM {\n    pin_t pin;\n    uint16_t pwmValue;\n    bool isActive;\n};\n\nstatic SoftwarePWM softwarePWMs[10]; // Array to hold software PWM states\nstatic uint8_t softwarePWMCount = 0; // Count of software-controlled PWM pins\n\nvoid analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq = PWM_FREQUENCY, const uint16_t res = TIMER_WIDTH) {\n    if (!timersInitialized) {\n        // Initialize the PWM timer at first use\n        ledcSetup(0, freq, res);\n        timersInitialized = true;\n    }\n\n    // Attempt to use a hardware PWM channel\n    if (usedHardwareChannels < AVAILABLE_HARDWARE_CHANNELS) {\n        ledcAttachPin(pin, usedHardwareChannels);\n        ledcWrite(usedHardwareChannels, map(value, 0, 65535, 0, (1 << res) - 1));\n        usedHardwareChannels++;\n        return;\n    }\n\n    // Check if pin already has a software PWM setup\n    for (int i = 0; i < softwarePWMCount; i++) {\n        if (softwarePWMs[i].pin == pin) {\n            softwarePWMs[i].pwmValue = map(value, 0, 65535, 0, 127); // Assuming 7-bit internal representation\n            return;\n        }\n    }\n\n    if (softwarePWMCount < sizeof(softwarePWMs) / sizeof(SoftwarePWM)) {\n        softwarePWMs[softwarePWMCount].pin = pin;\n        softwarePWMs[softwarePWMCount].pwmValue = map(value, 0, 65535, 0, 127);\n        softwarePWMs[softwarePWMCount].isActive = true;\n        softwarePWMCount++;\n    } else {\n        // No available software or hardware channels\n        Serial.println(\"Error: No available channels for PWM\");\n    }\n}", "CodeBleu_score": 43.7817392487039}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "#include <Arduino.h>\n#include <Servo.h>\n\n// Assuming the DEACTIVATE_SERVOS_AFTER_MOVE macro and SERVO_DELAY_ARRAY are defined elsewhere in your code.\n// For example:\n// #define DEACTIVATE_SERVOS_AFTER_MOVE true\n// constexpr unsigned int SERVO_DELAY_ARRAY[] = {1000, 1200, 1100}; // delays in milliseconds for each servo channel\n\nclass Servo {\n    int channel; // Assuming each servo has a channel associated with it.\n    Servo servoMotor;\n\npublic:\n    Servo(int ch) : channel(ch) {}\n\n    void attach(int pin) {\n        servoMotor.attach(pin); // Attach servo to a specific pin.\n    }\n\n    void detach() {\n        servoMotor.detach(); // Detach servo from its pin.\n    }\n\n    void move(const int value) {\n        static_assert(sizeof(SERVO_DELAY_ARRAY) / sizeof(SERVO_DELAY_ARRAY[0]) > 0, \"SERVO_DELAY_ARRAY must have at least one element.\");\n\n        // Ensure the channel is within the bounds of the SERVO_DELAY_ARRAY\n        if (channel >= 0 && channel < int(sizeof(SERVO_DELAY_ARRAY) / sizeof(SERVO_DELAY_ARRAY[0]))) {\n            // Attach the servo, write the position and delay accordingly.\n            servoMotor.write(value);\n\n            // Wait for the motion to complete\n            delay(SERVO_DELAY_ARRAY[channel]);\n\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n            // Optionally detach the servo if specified\n            detach();\n#endif\n        } else {\n            // Handle case where channel is out of range\n            Serial.println(\"Error: Servo channel is out of range.\");\n        }\n    }\n};\n\n// Example usage:\nvoid setup() {\n    // Assume servo is on channel 0 and connected to pin 9\n    Servo myServo(0);\n    myServo.attach(9);\n    myServo.move(90); // Move servo to 90 degrees\n}\n\nvoid loop() {\n    // Put other code here\n}", "CodeBleu_score": 35.73357630848872}, {"code": "#include <cassert>\n\nvoid Servo::move(const int value) {\n    // Verify the length of servo delay array using a static assertion\n    static_assert(sizeof(this->servoDelay) / sizeof(this->servoDelay[0]) == NUM_SERVOS,\n                  \"Servo delay array size does not match the number of servos\");\n\n    // Check if the servo can be attached\n    if (this->attach()) {\n        // Write the value to move the servo\n        this->write(value);\n\n        // Fetch the appropriate delay from the servoDelay array\n        int delayTime = this->servoDelay[this->channel];\n\n        // Wait for the servo to move to its position\n        delay(delayTime);\n\n        // Conditionally detach the servo after the move if defined\n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n        this->detach();\n#endif\n    } else {\n        // Handle the error when servo cannot be attached\n        Serial.println(\"Error: Servo could not be attached.\");\n    }\n}", "CodeBleu_score": 39.08394690640027}, {"code": "#include <Servo.h>\n\nclass Servo {\n    public:\n    // Servo object\n    Servo myServo;\n\n    // Servo properties\n    int channel;\n    static const int number_of_servos = 5;\n    int servo_delay[number_of_servos] = {1000, 1200, 1000, 1100, 1200}; // delay times for different servos\n    \n    void move(const int value) {\n        static_assert(sizeof(servo_delay)/sizeof(servo_delay[0]) == number_of_servos, \"Size of servo_delay array must match number_of_servos\");\n\n        if (myServo.attach(pin[channel])) { // attaches the servo on a channel to the used pin\n            myServo.write(value); // instruct servo to move to 'value' position\n            delay(servo_delay[channel]); // delays are based on the specific servo channel\n            \n#ifdef DEACTIVATE_SERVOS_AFTER_MOVE\n            myServo.detach(); // optionally detach the servo\n#endif\n        }\n    }\n};", "CodeBleu_score": 35.537691951076056}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "#include <stdint.h>\n#include <stdbool.h>\n\n// Assume hardware-specific constants and the dma_buffer setup\n#define NUM_PINS 8 // Example number of pins\n#define DMA_BUFFER_SIZE 256 // Example buffer size\n\nstruct PWM_Pin {\n    uint8_t pin_state; // 0 = low, 1 = high\n    uint16_t duty_cycle; // Duty cycle (0-1000 for 0%-100%)\n    uint16_t tick_count; // Current tick count down timer\n    uint16_t high_ticks; // Number of ticks to remain high\n    uint16_t low_ticks; // Number of ticks to remain low\n};\n\n// Example DMA buffer (8 channels, one for each pin)\nvolatile uint8_t dma_buffer[DMA_BUFFER_SIZE]; \nvolatile uint16_t dma_buffer_index = 0;\n\nstruct PWM_Pin pins[NUM_PINS]; // Our emulation of PWM pins\n\n// Function to simulate the PWM management per pin\nvoid i2s_push_sample() {\n    uint8_t port_data = 0; // Current value for all pins aggregated into a byte\n\n    // Update each pin's state\n    for (int i = 0; i < NUM_PINS; i++) {\n        // Check and manage the tick count\n        if (pins[i].tick_count == 0) {\n            // Toggle pin state\n            if (pins[i].pin_state == 1) {\n                pins[i].pin_state = 0;\n                pins[i].tick_count = pins[i].low_ticks; // Reload ticks for low state\n            } else {\n                pins[i].pin_state = 1;\n                pins[i].tick_count = pins[i].high_ticks; // Reload ticks for high state\n            }\n        } else {\n            // Decrease tick count\n            pins[i].tick_count--;\n        }\n\n        // Update aggregated port data based on the pin state\n        if (pins[i].pin_state == 1) {\n            port_data |= (1 << i); // Set bit i if pin_state is high\n        } else {\n            port_data &= ~(1 << i); // Clear bit i if pin_state is low\n        }\n    }\n\n    // Store the current port state into DMA buffer\n    dma_buffer[dma_buffer_index] = port_data;\n\n    // Move to the next position in DMA buffer\n    dma_buffer_index = (dma_buffer_index + 1) % DMA_BUFFER_SIZE;\n}", "CodeBleu_score": 23.27840469347708}, {"code": "#include <stdint.h>\n#include <string.h>\n\n#define NUM_PINS 8\n#define DMA_BUFFER_SIZE 1024\n\n// Simulating a PWM pin state and configuration\ntypedef struct {\n    uint8_t pin_number;           // The identifier for the pin\n    uint32_t duty_cycle;          // Value from 0 to 100 representing percentage\n    uint32_t period_ticks;        // Number of ticks for one cycle\n    uint32_t current_tick_count;  // Counter to track when to toggle\n    uint8_t state;                // Current state of the pin (HIGH or LOW)\n} PWM_Pin;\n\n// Example global variables as placeholders for actual implementation\nPWM_Pin pwm_pins[NUM_PINS];\nuint8_t dma_buffer[DMA_BUFFER_SIZE];\nuint32_t dma_buffer_index = 0;\n\n// A pseudo-function to simulate toggling of pin states\nuint8_t toggle_state(uint8_t current) {\n    return (current == 1) ? 0 : 1;\n}\n\nvoid i2s_push_sample() {\n    uint8_t port_data = 0; // Bitfield to represent the state of all pins\n\n    for (int i = 0; i < NUM_PINS; i++) {\n        PWM_Pin *pin = &pwm_pins[i];\n\n        // Decrement tick count or reset and toggle pin state if needed\n        if (pin->current_tick_count == 0) {\n            pin->state = toggle_state(pin->state);\n            pin->current_tick_count = ((pin->state == 1) ? pin->duty_cycle : (100 - pin->duty_cycle)) * (pin->period_ticks / 100);\n        } else {\n            pin->current_tick_count--;\n        }\n\n        // Set the corresponding bit in port_data if the pin is high\n        if (pin->state == 1) {\n            port_data |= (1 << pin->pin_number);\n        }\n    }\n\n    // Store the combined port data in the DMA buffer and handle buffer overflow\n    dma_buffer[dma_buffer_index++] = port_data;\n    if (dma_buffer_index >= DMA_BUFFER_SIZE) {\n        dma_buffer_index = 0; // Reset buffer index or handle as appropriate\n    }\n}", "CodeBleu_score": 25.392994730721487}, {"code": "#include <stdint.h>\n#include <stdbool.h>\n\n// Assuming a simple definition of pin data structure and DMA and other needed structures/constants.\n#define MAX_PINS 8\n#define DMA_BUFFER_SIZE 1024\n\ntypedef struct {\n    uint8_t pin_number;\n    uint16_t duty_cycle;\n    bool pin_state; // False = Low, True = High\n    uint16_t tick_count;\n} PinConfig;\n\n// Pretending we have a DMA buffer\nuint8_t dma_buffer[DMA_BUFFER_SIZE];\nint dma_buffer_index = 0;\n\n// Mock-up for managing pins\nPinConfig pwm_pins[MAX_PINS];\n\nvoid i2s_push_sample() {\n    uint8_t port_data = 0;\n\n    for (int i = 0; i < MAX_PINS; i++) {\n        // Check if PWM is active on the pin\n        if (pwm_pins[i].duty_cycle > 0) {\n            // Decrement tick count and check if it has reached zero\n            if (--pwm_pins[i].tick_count == 0) {\n                // Toggle pin state\n                pwm_pins[i].pin_state = !pwm_pins[i].pin_state;\n\n                // Reset the tick count based on pin state\n                if (pwm_pins[i].pin_state)\n                    pwm_pins[i].tick_count = pwm_pins[i].duty_cycle;\n                else\n                    pwm_pins[i].tick_count = 255 - pwm_pins[i].duty_cycle; // Assuming PWM period is 255\n            }\n            // Set the corresponding bit in port_data based on the pin state\n            if (pwm_pins[i].pin_state) {\n                port_data |= (1 << pwm_pins[i].pin_number);\n            }\n        }\n    }\n\n    // Write the updated port data to the DMA buffer\n    if (dma_buffer_index < DMA_BUFFER_SIZE) {\n        dma_buffer[dma_buffer_index++] = port_data;\n    } else {\n        // Handle buffer overflow, maybe reset or send warning\n        dma_buffer_index = 0; // Example reset\n    }\n}", "CodeBleu_score": 26.320609538735813}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "#include <stdint.h>\n\n// Assume max number of timers we can handle\n#define MAX_TIMERS 10\n\n// Simulated timer counters storage\nstatic uint32_t timers_counters[MAX_TIMERS] = {0};\n\n// Prototype declaration\nuint32_t HAL_timer_get_count(const uint8_t timer_num);\n\nuint32_t HAL_timer_get_count(const uint8_t timer_num) {\n    if (timer_num >= MAX_TIMERS) {\n        // In case an invalid timer number is passed\n        return 0;\n    }\n    // Return the current counter value for the specified timer\n    return timers_counters[timer_num];\n}", "CodeBleu_score": 37.792871301867656}, {"code": "#include <stdint.h>\n\n// Assuming a simplistic microcontroller environment where the number of timers is fixed.\n#define TOTAL_TIMERS 4\n\n// Simulating the timer registers that would typically be in hardware.\nvolatile uint32_t timer_registers[TOTAL_TIMERS] = {0};\n\n// Struct to emulate timer in hardware abstraction layer\ntypedef struct {\n    uint32_t count;\n} hal_timer_t;\n\n/*\n * The function \"HAL_timer_get_count\" retrieves the current counter value of a specified hardware timer.\n * It takes a timer number as input, accesses the corresponding timer configuration, and fetches the current counter value from the hardware timer.\n * The function then returns this counter value.\n */\nhal_timer_t HAL_timer_get_count(const uint8_t timer_num) {\n    hal_timer_t timer_data = {0};\n\n    // Safety check to avoid accessing out of bounds timer numbers\n    if (timer_num < TOTAL_TIMERS) {\n        // Retrieve the timer count from the hardware simulation register\n        timer_data.count = timer_registers[timer_num];\n    } else {\n        // Handle the error case, where the timer number is invalid\n        // Usually, you might return an error code, set special flags, exceptions, etc.\n        // Here, we just set the count to a value that indicates an invalid input.\n        timer_data.count = UINT32_MAX;\n    }\n\n    return timer_data;\n}\n\n// A simple demonstration of how the function can be called.\nint main() {\n    // Initialize one of the timers (assume timer 2) to a known value\n    timer_registers[2] = 12345;\n\n    // Get the count of timer 2 using the HAL function\n    hal_timer_t timer2_data = HAL_timer_get_count(2);\n    printf(\"Timer 2 count: %u\\n\", timer2_data.count);\n\n    // Try an invalid timer number, expecting error handling (using UINT32_MAX)\n    hal_timer_t timer_invalid = HAL_timer_get_count(5);\n    printf(\"Invalid Timer count: %u\\n\", (timer_invalid.count == UINT32_MAX) ? \"Error\" : \"OK\");\n\n    return 0;\n}", "CodeBleu_score": 42.187202951123446}, {"code": "#include <stdint.h>\n\n// Assuming 'TimerConfig' is a structure that holds the timer configurations\ntypedef struct {\n    uint32_t counter;  // Current counter value\n    // Other possible timer configuration fields\n} TimerConfig;\n\n// Assuming an array that holds the configurations for each timer\nextern TimerConfig timerConfigs[];\n\n// Function to get the current counter value of a specified hardware timer\nhal_timer_t HAL_timer_get_count(const uint8_t timer_num) {\n    // Access the timer configuration using the timer number\n    TimerConfig config = timerConfigs[timer_num];\n\n    // Return the current counter value\n    return config.counter;\n}", "CodeBleu_score": 43.4786299014206}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "#include <cstdint>\n#include <EEPROM.h>\n\nclass PersistentStore {\npublic:\n    // CRC16-CCITT function to update the CRC\n    uint16_t compute_crc(uint16_t current_crc, uint8_t byte) {\n        current_crc = (uint8_t)(current_crc >> 8) | (current_crc << 8);\n        current_crc ^= byte;\n        current_crc ^= (uint8_t)(current_crc & 0xff) >> 4;\n        current_crc ^= (current_crc << 8) << 4;\n        current_crc ^= ((current_crc & 0xff) << 4) << 1;\n        return current_crc;\n    }\n\n    bool read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, bool writing = true) {\n        // Process each byte in the specified size\n        for (size_t i = 0; i < size; ++i) {\n            // Read a byte from EEPROM at position pos\n            uint8_t byte = EEPROM.read(pos);\n\n            // Update the CRC with the read byte\n            *crc = compute_crc(*crc, byte);\n\n            // If writing flag is true, write the byte into the buffer\n            if (writing) {\n                value[i] = byte;\n            }\n\n            // Increment the position\n            pos++;\n        }\n        \n        // Function returns false upon completion according to the documentation\n        return false;\n    }\n};\n\n// Example of utilization\nint main() {\n    PersistentStore store;\n    uint8_t buffer[128];            // Buffer into which data will be read\n    int position = 0;               // Starting position in EEPROM\n    uint16_t crc = 0xFFFF;          // Initial CRC value\n    size_t size = sizeof(buffer);   // Number of bytes to read\n    \n    bool result = store.read_data(position, buffer, size, &crc);\n    return result; // As per the given implementation, this should return false\n}", "CodeBleu_score": 50.80336500881709}, {"code": "#include <EEPROM.h> // Required to interact with EEPROM\n\nclass PersistentStore {\npublic:\n    // Function to read data from EEPROM, update CRC, and optionally write to buffer\n    bool read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing = true) {\n        uint16_t current_crc = 0xFFFF; // Initialize CRC start value\n        \n        for (size_t i = 0; i < size; ++i) {\n            uint8_t data = EEPROM.read(pos + i); // Read byte from EEPROM\n            current_crc = update_crc(current_crc, data); // Update CRC with read byte\n            \n            if (writing) {\n                value[i] = data; // Store byte in buffer if writing flag is true\n            }\n        }\n\n        *crc = current_crc;  // Store the updated CRC value\n        pos += size;         // Update position by the number of bytes read\n        \n        return false; // Return false upon completion as specified\n    }\n\nprivate:\n    // Simplified CRC-16 update function (a real implementation might use specific polynomials, reflect-in/out, etc.)\n    uint16_t update_crc(uint16_t crc, uint8_t data) {\n        crc ^= data;\n        for (uint8_t i = 0; i < 8; i++) {\n            if (crc & 0x0001)\n                crc = (crc >> 1) ^ 0xA001;\n            else\n                crc >>= 1;\n        }\n        return crc;\n    }\n};", "CodeBleu_score": 53.59254696537017}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/) {\n    for (size_t i = 0; i < size; i++) {\n        uint8_t data_byte = EEPROM.read(pos);\n        \n        // Update CRC with the new data byte\n        if (crc != nullptr) {\n            *crc = update_crc(*crc, data_byte);\n        }\n        \n        // Store data in provided buffer if writing is true\n        if (writing) {\n            value[i] = data_byte;\n        }\n        \n        // Increment the EEPROM position\n        pos++;\n    }\n\n    return false;\n}\n\nuint16_t PersistentStore::update_crc(uint16_t current_crc, uint8_t data_byte) {\n    // Placeholder code for CRC16 calculation\n    current_crc ^= (uint16_t)data_byte << 8;\n\n    for (int i = 0; i < 8; i++) {\n        if (current_crc & 0x8000)\n            current_crc = (current_crc << 1) ^ 0x1021; // Polynomial used in CRC-CCITT\n        else\n            current_crc = current_crc << 1;\n    }\n\n    return current_crc;\n}", "CodeBleu_score": 54.792786599658115}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#define RETRY_LIMIT 5\n\n// Mock functions to simulate SDIO operations\nbool mock_sdio_write(uint32_t block, const uint8_t *data, uint32_t size) {\n    // Simulate some sort of hardware failure or condition\n    static int simulate_failure = RETRY_LIMIT - 2;\n    if (simulate_failure > 0) {\n        simulate_failure--;\n        return false;\n    }\n    return true;\n}\n\nbool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {\n    if (!src) {\n        printf(\"Error: Source data pointer is NULL\\n\");\n        return false;\n    }\n    \n    int retries = 0;\n    bool written = false;\n    const uint32_t blockSize = 512; // typical SD card block size, assuming this for demonstration\n\n    while (retries < RETRY_LIMIT && !written) {\n        if (mock_sdio_write(block, src, blockSize)) {\n            written = true;\n        } else {\n            printf(\"Attempt %d to write block %u failed, retrying...\\n\", retries + 1, block);\n            retries++;\n        }\n    }\n\n    if (!written) {\n        printf(\"Failed to write block %u after %d attempts.\\n\", block, RETRY_LIMIT);\n        return false;\n    }\n\n    return true;\n}\n\nint main() {\n    uint8_t dataBlock[512] = {0}; // Example data block initializing with zeros\n    uint32_t blockNum = 10; // Example block number to write to\n\n    bool result = SDIO_WriteBlock(blockNum, dataBlock);\n    if (result) {\n        printf(\"Block %u successfully written.\\n\", blockNum);\n    } else {\n        printf(\"Writing operation failed.\\n\");\n    }\n\n    return 0;\n}", "CodeBleu_score": 34.35716222097726}, {"code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n// Mock definitions for global variables and functions\n#define MAX_RETRIES 5\nextern sdio_handle_t SDIO_global; // Hypothetical SDIO handle\nbool SDIO_SendCommand(sdio_handle_t *handle, uint32_t cmd, uint32_t arg);\n\nbool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {\n    if (SDIO_global == NULL || src == NULL) {\n        printf(\"Invalid pointer provided.\\n\");\n        return false;\n    }\n\n    int retries = 0;\n    bool writeSuccess = false;\n    while (retries < MAX_RETRIES && !writeSuccess) {\n        // Simulate sending a command to write a block - you will need real SDIO commands in actual implementation\n        writeSuccess = SDIO_SendCommand(&SDIO_global, WRITE_CMD, block);\n        if (!writeSuccess) {\n            retries++;\n            printf(\"Write attempt %d failed, retrying...\\n\", retries);\n        } \n    }\n\n    if (!writeSuccess) {\n        printf(\"Failed to write data after %d attempts.\\n\", MAX_RETRIES);\n        return false;\n    }\n    \n    return true;\n}", "CodeBleu_score": 39.51350130513762}, {"code": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\n// Mock definitions for simplicity, in actual code should be replaced with real hardware definitions.\n#define SDIO_SUCCESS 0\n#define MAX_RETRY_COUNT 3\n\nextern int SDIO_Write(uint32_t block, const uint8_t *src); // Assumed to be defined elsewhere; interface to hardware.\n\nbool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {\n    // Assert that the SDIO handle and source pointer are not null.\n    if (src == NULL) {\n        printf(\"Error: Source data pointer is NULL!\\n\");\n        return false;\n    }\n\n    int retry = 0;\n    int result = 0;\n\n    do {\n        // Try to write the block.\n        result = SDIO_Write(block, src);\n\n        if (result == SDIO_SUCCESS) {\n            return true; // Write operation succeeded.\n        }\n\n        // Increment retry count if the write operation failed.\n        retry++;\n    } while (retry < MAX_RETRY_COUNT);\n\n    // If all retries fail.\n    printf(\"Error: Failed to write data to block %u after %d retries.\\n\", block, MAX_RETRY_COUNT);\n    return false;\n}", "CodeBleu_score": 42.36755368432863}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "#include <assert.h> // Include assertion library\n\n// Constants and types assumed to exist from the external environment\ntypedef enum {\n    TEMPERATURE_TIMER,   // Timer for temperature control\n    STEP_TIMER,          // Timer for stepper control\n    NUM_TIMERS           // Total number of timer channels\n} timer_channel_t;\n\n// Assume there are functions available for configuring each timer type\nextern void configure_temperature_timer(uint32_t frequency, uint32_t prescale);\nextern void configure_stepper_timer(uint32_t frequency, uint32_t prescale);\nextern void set_callback_priority_temperature(int priority);\nextern void set_callback_priority_stepper(int priority);\n\n/**\n * Set the frequency and prescale based on timer channel and start the timer.\n * @param timer_num The timer channel to start.\n * @param frequency Frequeny in Hz to be set for the timer.\n */\nvoid HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency) {\n    switch (timer_num) {\n        case TEMPERATURE_TIMER:\n            {\n                // Example prescale values for temperature timer\n                uint32_t temperature_timer_prescale = 8;\n                // Set up the temperature hardware timer with the desired frequency and prescale\n                configure_temperature_timer(frequency, temperature_timer_prescale);\n                // Set the callback priority specific to temperature control\n                set_callback_priority_temperature(5);\n            }\n            break;\n        \n        case STEP_TIMER:\n            {\n                // Example prescale values for stepper motor timer\n                uint32_t stepper_timer_prescale = 4;\n                // Set up the stepper hardware timer with the desired frequency and prescale\n                configure_stepper_timer(frequency, stepper_timer_prescale);\n                // Set the callback priority specific to stepper control\n                set_callback_priority_stepper(3);\n            }\n            break;\n        \n        default:\n            // An invalid timer number is provided\n            assert(\"Invalid timer channel\" && false);\n            break;\n    }\n}", "CodeBleu_score": 23.03761039558475}, {"code": "#include <assert.h>\n\n// Simulation of timer configuration functions that might be available on a hardware abstraction layer\nvoid Timer_Start(timer_channel_t timer, uint32_t prescaler, uint32_t frequency);\nvoid Timer_Set_Prescaler(timer_channel_t timer, uint32_t prescaler);\nvoid Timer_Set_Callback_Priority(timer_channel_t timer, uint32_t priority);\n\n// Constants for prescaler values and priorities\n#define TEMP_TIMER_PRESCALER 8\n#define STEP_TIMER_PRESCALER 16\n#define TEMP_PRIORITY 5\n#define STEP_PRIORITY 3\n\n// Enum definition for timer channels, assuming this is defined somewhere in the code\ntypedef enum {\n    TIMER_CHANNEL_TEMP,\n    TIMER_CHANNEL_STEP,\n    TIMER_CHANNEL_INVALID\n} timer_channel_t;\n\nvoid HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency) {\n    switch(timer_num) {\n        case TIMER_CHANNEL_TEMP:\n            Timer_Set_Prescaler(timer_num, TEMP_TIMER_PRESCALER);\n            Timer_Start(timer_num, TEMP_TIMER_PRESCALER, frequency);\n            Timer_Set_Callback_Priority(timer_num, TEMP_PRIORITY);\n            break;\n\n        case TIMER_CHANNEL_STEP:\n            Timer_Set_Prescaler(timer_num, STEP_TIMER_PRESCALER);\n            Timer_Start(timer_num, STEP_TIMER_PRESCALER, frequency);\n            Timer_Set_Callback_Priority(timer_num, STEP_PRIORITY);\n            break;\n\n        case TIMER_CHANNEL_INVALID:\n        default:\n            // If the timer channel is invalid, trigger an assertion failure\n            assert(0 && \"Invalid timer channel passed to HAL_timer_start\");\n            break;\n    }\n}", "CodeBleu_score": 28.172674620957327}, {"code": "#include <assert.h>  // To include assert for handling invalid timer channel\n\n// Define timer channels for clarity assuming these will be provided externally\ntypedef enum {\n    TIMER_CHANNEL_TEMP,\n    TIMER_CHANNEL_STEP,\n    TIMER_CHANNEL_INVALID\n} timer_channel_t;\n\n// Define constants for timer prescale values, priority settings, etc.\n#define TEMP_TIMER_PRESCALE 256\n#define STEP_TIMER_PRESCALE 128\n#define TEMP_CALLBACK_PRIORITY 3\n#define STEP_CALLBACK_PRIORITY 2\n\n// Assumed function prototypes for setting up timer hardware\nvoid configure_timer(timer_channel_t channel, uint32_t prescale, uint32_t frequency);\nvoid set_callback_priority(timer_channel_t channel, uint32_t priority);\n\n// Mock functions: assuming replace them with actual hardware interfacing functions\nvoid configure_timer(timer_channel_t channel, uint32_t prescale, uint32_t frequency) {\n    // Hardware-specific timer configuration (dummy implementation)\n    printf(\"Configuring Timer %d with Prescale %u and Frequency %u Hz\\n\", channel, prescale, frequency);\n}\n\nvoid set_callback_priority(timer_channel_t channel, uint32_t priority) {\n    // Hardware-specific callback priority setting (dummy implementation)\n    printf(\"Setting callback priority for Timer %d to %u\\n\", channel, priority);\n}\n\n// Define function implementation based on mock or actual setup\nvoid HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency) {\n    switch (timer_num) {\n        case TIMER_CHANNEL_TEMP:\n            configure_timer(TIMER_CHANNEL_TEMP, TEMP_TIMER_PRESCALE, frequency);\n            set_callback_priority(TIMER_CHANNEL_TEMP, TEMP_CALLBACK_PRIORITY);\n            break;\n            \n        case TIMER_CHANNEL_STEP:\n            configure_timer(TIMER_CHANNEL_STEP, STEP_TIMER_PRESCALE, frequency);\n            set_callback_priority(TIMER_CHANNEL_STEP, STEP_CALLBACK_PRIORITY);\n            break;\n            \n        default:\n            assert(\"Invalid timer channel\" && false);\n            break;  // Not strictly necessary after assert, but good practice for maintainability\n    }\n}", "CodeBleu_score": 30.294800308608117}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "#include <fstream>  // For file operations\n#include <cstring>  // For memset\n\nclass PersistentStore {\npublic:\n    // Assuming EEPROM_SIZE and DEFAULT_ERASE_VALUE are defined somewhere in the class or globally\n    static const size_t EEPROM_SIZE = 1024;  // Example EEPROM size\n    static const char DEFAULT_ERASE_VALUE = 0xFF;  // Typical EEPROM erase value\n    char buffer[EEPROM_SIZE];\n\n    bool access_start() {\n        std::ifstream file(\"eeprom.bin\", std::ios::binary | std::ios::ate);  // Open file for binary read and get its size directly\n        \n        if (!file.is_open()) {\n            return false;  // Could not open the file\n        }\n\n        size_t fileSize = file.tellg();  // Get the size of the file\n        file.seekg(0, std::ios::beg);  // Go back to the start of the file\n\n        if (fileSize < EEPROM_SIZE) {\n            // File exists but has a size less than expected, read content and fill the rest\n            file.read(buffer, fileSize);\n            std::memset(buffer + fileSize, DEFAULT_ERASE_VALUE, EEPROM_SIZE - fileSize);  // Fill the rest with DEFAULT_ERASE_VALUE\n        } else {\n            // File is of correct or excess size, just read the needed amount\n            file.read(buffer, EEPROM_SIZE);\n        }\n\n        file.close();  // Close the file\n        return true;\n    }\n};", "CodeBleu_score": 31.529178911915402}, {"code": "#include <fstream>\n#include <cstring> // for memset\n\nclass PersistentStore {\nprivate:\n    static const size_t EEPROM_SIZE = 1024; // Size of EEPROM in bytes\n    static const char* EEPROM_FILENAME; // EEPROM file name\n    static const unsigned char ERASE_VALUE = 0xFF; // Default value to fill EEPROM\n\n    unsigned char buffer[EEPROM_SIZE]; // Buffer to hold EEPROM data\n\npublic:\n    PersistentStore() {\n        EEPROM_FILENAME = \"eeprom.bin\";\n    }\n\n    bool access_start() {\n        std::ifstream file(EEPROM_FILENAME, std::ios::binary);\n        \n        if (!file.is_open()) {\n            return false;\n        }\n\n        // Get the file size\n        file.seekg(0, std::ios::end);\n        size_t fileSize = file.tellg();\n        file.seekg(0, std::ios::beg);\n\n        if (fileSize > EEPROM_SIZE) {\n            fileSize = EEPROM_SIZE; // Truncate file size to max EEPROM_SIZE if over\n        }\n\n        // Read the contents of the file\n        file.read(reinterpret_cast<char*>(buffer), fileSize);\n\n        // Check and fill the remainder of the buffer if the file is smaller than EEPROM_SIZE\n        if (fileSize < EEPROM_SIZE) {\n            std::memset(buffer + fileSize, ERASE_VALUE, EEPROM_SIZE - fileSize);\n        }\n\n        file.close();\n        return true;\n    }\n};", "CodeBleu_score": 30.82793203418528}, {"code": "#include <fstream>\n#include <cstring>  // For std::memset\n\nclass PersistentStore {\npublic:\n    static constexpr size_t EEPROM_SIZE = 1024; // Assuming EEPROM size of 1024 bytes\n    static constexpr char EEPROM_FILENAME[] = \"eeprom.bin\";\n    static constexpr unsigned char DEFAULT_ERASE_VALUE = 0xFF; // Default EEPROM erased value\n\nprivate:\n    unsigned char buffer[EEPROM_SIZE];\n\npublic:\n    bool access_start() {\n        std::ifstream eeprom_file(EEPROM_FILENAME, std::ios::binary | std::ios::ate);\n        \n        if (!eeprom_file.is_open()) {\n            return false;  // File could not be opened\n        }\n        \n        std::streamsize size = eeprom_file.tellg();\n        eeprom_file.seekg(0, std::ios::beg);\n\n        if (size > EEPROM_SIZE) {\n            size = EEPROM_SIZE; // Read only up to the EEPROM size if file is larger\n        }\n\n        if (!eeprom_file.read(reinterpret_cast<char*>(buffer), size)) {\n            eeprom_file.close();\n            return false; // File read error\n        }\n\n        // If file size is less than the EEPROM Size, fill the rest with DEFAULT_ERASE_VALUE\n        if (size < EEPROM_SIZE) {\n            std::memset(buffer + size, DEFAULT_ERASE_VALUE, EEPROM_SIZE - size);\n        }\n\n        eeprom_file.close();\n        return true;\n    }\n};", "CodeBleu_score": 31.009887282265165}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "#include <stdint.h>\n#include <stdbool.h>\n\n// Mock definitions for GPIO operations and registers. Replace with actual MCU specific APIs/HAL drivers.\n#define GPIO_PIN_RESET 0\n#define GPIO_PIN_SET 1\n#define SPI_MODE3_CLK_DELAY 10  // Small delay in microseconds, value depends on your timing requirements\n\n// Function prototypes for GPIO operations (implement these according to your platform)\nvoid HAL_GPIO_WritePin(int pin, uint8_t state);\nvoid HAL_GPIO_DelayMicroseconds(int delay);\nuint8_t HAL_GPIO_ReadPin(int pin);\n\n// Definitions for MOSI, MISO, and SCK pins (replace with actual pin numbers)\n#define MOSI_PIN 7\n#define MISO_PIN 6\n#define SCK_PIN 5 \n  \nuint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b) {\n    uint8_t received_byte = 0;\n\n    // Iterating through each bit in the byte (8 bits)\n    for (int i = 0; i < 8; i++) {\n        // Set SCK pin low prior to sending bit\n        HAL_GPIO_WritePin(SCK_PIN, GPIO_PIN_RESET);\n        \n        // Write MSB (Most Significant Bit) to MOSI\n        // Check if MSB is 1, write 1, else write 0\n        // MSB of b is b & (1 << 7), shifted right to make it either 1 or 0\n        HAL_GPIO_WritePin(MOSI_PIN, (b & 0x80) >> 7);\n        \n        // Set SCK pin high to clock the data to slave\n        HAL_GPIO_WritePin(SCK_PIN, GPIO_PIN_SET);\n        \n        // Read the bit from MISO pin while clock is high\n        // Shift received_byte left by 1 (make space for new bit) and OR it with the new bit\n        received_byte = (received_byte << 1) | HAL_GPIO_ReadPin(MISO_PIN);\n        \n        // Shift the send byte left by 1 so that the next bit becomes the MSB in the next loop iteration\n        b <<= 1;\n        \n        // Small delay post transfer if required for timing adjustments\n        HAL_GPIO_DelayMicroseconds(SPI_MODE3_CLK_DELAY);\n    }\n\n    return received_byte;\n}", "CodeBleu_score": 36.3988032314926}, {"code": "#include <stdint.h>\n#include <stdbool.h>\n\n// Hardware-specific definitions (example definitions, must be customized per actual hardware)\n#define SPI_MOSI_PIN  (0u)  // Define as per the actual pin connected to MOSI\n#define SPI_MISO_PIN  (1u)  // Define as per the actual pin connected to MISO\n#define SPI_CLOCK_PIN (2u)  // Define as per the actual pin connected to CLOCK\n#define SPI_DELAY()   do { for (volatile int i = 0; i < 1000; i++); } while (0)  // Simple delay loop\n\nvoid writePin(uint8_t pin, bool val) {\n    // Add your hardware specific functionality to set the pin state\n}\n\nbool readPin(uint8_t pin) {\n    // Add your hardware specific functionality to read the pin state\n    return false; // Placeholder return\n}\n\nvoid toggleClock() {\n    writePin(SPI_CLOCK_PIN, true);\n    SPI_DELAY();\n    writePin(SPI_CLOCK_PIN, false);\n    SPI_DELAY();\n}\n\nuint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b) {\n    uint8_t received = 0;\n    for (int i = 0; i < 8; ++i) {\n        writePin(SPI_CLOCK_PIN, false);            // Set clock pin low\n        writePin(SPI_MOSI_PIN, (b & 0x80) != 0);  // Write MSB of b to MOSI pin\n        toggleClock();                            // Toggle clock pin high, then low\n        received <<= 1;                           // Shift received byte left\n        if (readPin(SPI_MISO_PIN)) {              // If MISO pin is high\n            received |= 1;                        // Set LSB of received byte\n        }\n        b <<= 1;                                  // Shift b left for next bit operation\n    }\n    SPI_DELAY();  // Small delay after transmission\n    return received;\n}", "CodeBleu_score": 36.33563752538247}, {"code": "#include \"gpio.h\"  // Hypothetical header for GPIO actions\n\n#define SPI_CLK_PIN 3     // Example GPIO pin number for SPI Clock\n#define SPI_MOSI_PIN 5    // Example GPIO pin number for SPI MOSI\n#define SPI_MISO_PIN 7    // Example GPIO pin number for SPI MISO\n#define BIT_DELAY 5       // Microseconds to delay between bits\n\nuint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t sendData) {\n    uint8_t receivedData = 0;\n    // Loop through each bit (MSB first)\n    for (int bitPos = 7; bitPos >= 0; bitPos--) {\n        // Set Clock low before sending data (Mode 3: CPOL=1)\n        gpio_write(SPI_CLK_PIN, 0);\n\n        // Write data to MOSI (shift sendData bit to MSB, then write it to the pin)\n        gpio_write(SPI_MOSI_PIN, (sendData >> bitPos) & 0x01);\n\n        // Introducing delay for setup\n        delay_us(BIT_DELAY);\n\n        // Toggle Clock high to read data\n        gpio_write(SPI_CLK_PIN, 1);\n\n        // Read bit from MISO\n        uint8_t readBit = gpio_read(SPI_MISO_PIN);\n\n        // Incorporate read bit into receivedData\n        receivedData = (receivedData << 1) | readBit;\n\n        // Introducing delay to complete the clock period\n        delay_us(BIT_DELAY);\n\n        // Return Clock to high idle state (CPOL=1)\n        gpio_write(SPI_CLK_PIN, 0);\n    }\n\n    // Small delay to separate consecutive SPI transfers, not strictly necessary\n    delay_us(BIT_DELAY);\n\n    return receivedData;\n}", "CodeBleu_score": 34.37049604271998}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "#include <stdint.h>  // Include stdint for uint32_t definition\n\n// Assuming we have the following definitions somewhere in your program\n// Define AHBENR register memory mapped address, use actual address for your platform\n#define AHBENR  (*(volatile uint32_t *)0x40021014)\n\n// Definitions for RCC_AHBPeriph for simplicity, you need to use actual peripheral specifics\n#define RCC_AHBPeriph_GPIOA     0x00000001\n#define RCC_AHBPeriph_GPIOB     0x00000002\n// Add other peripherals as required...\n\n// Possible Disable/Enable states\ntypedef enum {DISABLE = 0, ENABLE = 1} FunctionalState;\n\nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState) {\n    if (NewState != DISABLE) {\n        // Enable the clock\n        AHBENR |= RCC_AHBPeriph; // Set the bit corresponding to the peripheral\n    } else {\n        // Disable the clock\n        AHBENR &= ~RCC_AHBPeriph; // Clear the bit corresponding to the peripheral\n    }\n}", "CodeBleu_score": 40.6049308572631}, {"code": "#include <stdint.h>\n#include \"stm32f10x.h\"\n\ntypedef enum {DISABLE = 0, ENABLE = 1} FunctionalState;\n\nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState) {\n    // Validate input parameters\n    if (NewState != DISABLE && NewState != ENABLE) {\n        return; // NewState must be either ENABLE or DISABLE\n    }\n\n    if (NewState == ENABLE) {\n        // Enable the AHB peripheral clock\n        RCC->AHBENR |= RCC_AHBPeriph;\n    } else {\n        // Disable the AHB peripheral clock\n        RCC->AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 50.0602873763676}, {"code": "#include <stdint.h>  // Standard header for uint32_t definition\n\n// Assuming these constants and types are defined appropriately:\n// #define RCC_AHBENR *((volatile uint32_t*)0xSomeAddress)\n// typedef enum {DISABLE = 0, ENABLE = 1} FunctionalState;\n\nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState) {\n    // Validate inputs: Ensure RCC_AHBPeriph corresponds to a valid peripheral bit\n    if ((RCC_AHBPeriph & 0xValidPeripheralMask) == 0) {\n        return; // Invalid peripheral bit, maybe raise an error or handle it appropriately.\n    }\n\n    // Assume RCC_AHBENR is the AHB peripheral clock enable register\n    // It is common for such addresses to be available in device header files\n    // and we directly manipulate them here.\n\n    if (NewState == ENABLE) {\n        // Enable the clock: Set the bit corresponding to RCC_AHBPeriph\n        RCC_AHBENR |= RCC_AHBPeriph;\n    } else if (NewState == DISABLE) {\n        // Disable the clock: Clear the bit corresponding to RCC_AHBPeriph\n        RCC_AHBENR &= ~RCC_AHBPeriph;\n    }\n}", "CodeBleu_score": 38.21442779841975}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj) {\n    // Check if there is a parity error using the serial API, if so, return without processing further\n    if (serial_get_parity_error(obj)) {\n        serial_clear_parity_error(obj);\n        return;\n    }\n\n    // Read a byte from the serial hardware\n    int data = serial_read(obj);\n\n    // Check if data was successfully read\n    if (data != -1) {\n        unsigned char received_byte = static_cast<unsigned char>(data);\n\n        // Calculate next buffer index\n        uint8_t next_index = (rx_buffer.head + 1) % RX_BUFFER_SIZE;\n\n        // Check for buffer overflow\n        if (next_index != rx_buffer.tail) {\n            // Store the received byte into the buffer if space is available\n            rx_buffer.buffer[rx_buffer.head] = received_byte;\n            // Update the head index\n            rx_buffer.head = next_index;\n        } else {\n            // Handle buffer overflow, e.g., by discarding data or logging an error\n        }\n\n        // If the emergency parser is enabled, update it with received byte\n#ifdef ENABLE_EMERGENCY_PARSER\n        emergency_parser.update(received_byte);\n#endif\n    }\n}", "CodeBleu_score": 42.97593205677772}, {"code": "#include \"MarlinSerial.h\"  // Include the header file (if available) \n\nvoid MarlinSerial::_rx_complete_irq(serial_t *obj) {\n    // Check if the data register is empty\n    if (serial_rx_ready(obj)) {\n        // Read byte from the serial port\n        uint8_t c = serial_read_byte(obj);\n\n        // Check for parity error or any other frame error (assuming serial frame error check function is available)\n        if (serial_get_errors(obj) & SERIAL_ERROR_PARITY) {\n            // Log or handle the parity error\n            serial_clear_errors(obj);  // Clear errors after handling\n        } else {\n            // Calculate next buffer index\n            uint8_t next_index = (rx_buffer.head + 1) % RX_BUFFER_SIZE;\n\n            // Check for overflow\n            if (next_index != rx_buffer.tail) {\n                // There is space in the buffer\n                rx_buffer.data[rx_buffer.head] = c;     // Store byte in buffer\n                rx_buffer.head = next_index;            // Update head index\n\n                // If emergency parsing is enabled invoke the emergency parser\n    #ifdef ENABLE_EMERGENCY_PARSER\n                emergency_parser.update(c);\n    #endif\n            } else {\n                // Buffer overflow, handle accordingly, e.g., error logging or discard the character\n                // (Optional handling code here)\n            }\n        }\n    }\n}", "CodeBleu_score": 39.689354470888894}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj) {\n    // Check for a parity error\n    if (serial_get_parity_error(obj)) {\n        // Clear the error if necessary\n        serial_clear_parity_error(obj);\n        return; // Exit the function as the data is invalid\n    }\n\n    // Read the byte from the serial port\n    uint8_t received_byte = serial_getc(obj);\n\n    // Calculate the next head index\n    uint8_t next_head = (rx_buffer_head + 1) % RX_BUFFER_SIZE;\n\n    // Check if there is space in the receive buffer\n    if (next_head != rx_buffer_tail) {\n        // Store the byte if there is space\n        rx_buffer[rx_buffer_head] = received_byte;\n        // Update buffer head\n        rx_buffer_head = next_head;\n    } else {\n        // Handle buffer full situation, maybe with an error or a simple discard\n    }\n\n    // Handle emergency parsing if enabled\n    #if ENABLED(EMERGENCY_PARSER)\n    emergency_parser.update(received_byte);\n    #endif\n}", "CodeBleu_score": 37.05487196456868}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "#include <stdint.h>\n#include <stdbool.h>\n\n// Constants representing timer numbers\n#define MF_TIMER_STEP 0\n#define MF_TIMER_TEMP 1\n\n// Function prototypes for checking and attaching interrupts\nbool isTimerInitialized(uint8_t timer_num);\nbool isInterruptAttached(uint8_t timer_num);\nvoid attachInterrupt(uint8_t timer_num, void (*handler)(void));\n\n// Interrupt Handlers\nvoid Step_Handler(void);\nvoid Temp_Handler(void);\n\nvoid HAL_timer_enable_interrupt(const uint8_t timer_num) {\n    // Check if the timer is initialized and does not have an interrupt attached\n    if (isTimerInitialized(timer_num) && !isInterruptAttached(timer_num)) {\n        // Depending on the timer number, attach the appropriate handler\n        if (timer_num == MF_TIMER_STEP) {\n            attachInterrupt(timer_num, Step_Handler);\n        } else if (timer_num == MF_TIMER_TEMP) {\n            attachInterrupt(timer_num, Temp_Handler);\n        }\n    }\n}", "CodeBleu_score": 28.874485551292622}, {"code": "// Define constants for the timer numbers and handler names for clarity\n#define MF_TIMER_STEP  1\n#define MF_TIMER_TEMP  2\n\n// Mock-up structure definition, assuming structure array holds initialization and interrupt attached status.\nextern TimerStruct timers[];\n\n// Forward declaration of handlers for better organization and avoiding undefined references\nvoid Step_Handler(void);\nvoid Temp_Handler(void);\n\nvoid HAL_timer_enable_interrupt(const uint8_t timer_num) {\n    // Check if the specified timer number is within our valid range\n    if (timer_num < 1 || timer_num > 2) {\n        return; // Invalid timer number, simply return.\n    }\n\n    // Check if the specific timer is initialized and does not have an interrupt attached yet\n    if (timers[timer_num].initialized && !timers[timer_num].interrupt_attached) {\n        // Attach interrupt based on the timer number\n        if (timer_num == MF_TIMER_STEP) {\n            // Attach Step_Handler to the timer's interrupt\n            timers[timer_num].interrupt_handler = Step_Handler;\n        } else if (timer_num == MF_TIMER_TEMP) {\n            // Attach Temp_Handler to the timer's interrupt\n            timers[timer_num].interrupt_handler = Temp_Handler;\n        }\n\n        // Setting flag to indicate that interrupt is now attached.\n        timers[timer_num].interrupt_attached = 1;\n\n        // Optional: enable interrupt in hardware, not shown in this pseudo/mock-up code\n        // e.g., enableTimerInterrupt(timer_num);\n    }\n}", "CodeBleu_score": 29.714119339861604}, {"code": "#include <stdint.h>\n\n// Assuming these are the timer numbers for demonstration.\n#define MF_TIMER_STEP 1\n#define MF_TIMER_TEMP 2\n\n// Mock functions to check the state of the timer and to enable interrupts\nextern int is_timer_initialized(uint8_t timer_num);\nextern int has_interrupt(uint8_t timer_num);\nextern void enable_interrupt_handler(uint8_t timer_num, void (*handler)());\n\n// Interrupt handlers (assume defined elsewhere)\nvoid Step_Handler();\nvoid Temp_Handler();\n\nvoid HAL_timer_enable_interrupt(const uint8_t timer_num) {\n    // First, check if timer is initialized\n    if (is_timer_initialized(timer_num)) {\n        // Check if the timer does not already have an interrupt attached\n        if (!has_interrupt(timer_num)) {\n            // Depending on the timer number, attach the correct interrupt handler\n            if (timer_num == MF_TIMER_STEP) {\n                enable_interrupt_handler(timer_num, Step_Handler);\n            } else if (timer_num == MF_TIMER_TEMP) {\n                enable_interrupt_handler(timer_num, Temp_Handler);\n            } else {\n                // add logs or actions for any unsupported timer numbers\n            }\n        } else {\n            // Optionally handle the case or log where an interrupt is already attached\n        }\n    } else {\n        // Optionally handle the case or log where the timer is not initialized\n    }\n}", "CodeBleu_score": 26.141081038323744}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int {\n\tbase := 257 // A prime number used as the base in polynomial rolling hash.\n\tmod := 1000000007 // A large prime number for taking mod of hash value.\n\n\tif len(sep) > len(s) {\n\t\treturn -1\n\t}\n\tif len(sep) == 0 {\n\t\treturn len(s)\n\t}\n\n\t// Precompute the base^len(sep) % mod for use in removing old digit.\n\tpowerOfBaseSepLen := 1\n\tfor i := 0; i < len(sep); i++ {\n\t\tpowerOfBaseSepLen = (powerOfBaseSepLen * base) % mod\n\t}\n\n\t// Calculate the hash of sep\n\tvar hashSep int64\n\tfor i := 0; i < len(sep); i++ {\n\t\thashSep = (hashSep*base + int64(sep[i])) % mod\n\t}\n\n\t// Calculate the hash of the last len(sep) characters of s\n\tvar currentHash int64\n\tfor i := len(s) - len(sep); i < len(s); i++ {\n\t\tcurrentHash = (currentHash*base + int64(s[i])) % mod\n\t}\n\n\t// Check if the last part of s matches sep\n\tif currentHash == hashSep && Equal(s[len(s)-len(sep):], sep) {\n\t\treturn len(s) - len(sep)\n\t}\n\n\t// Move the window from the end of s to the beginning\n\tfor i := len(s) - len(sep) - 1; i >= 0; i-- {\n\t\t// Remove the old last element and add the new first element in the hash\n\t\tcurrentHash = (currentHash - int64(s[i+len(sep)])*int64(powerOfBaseSepLen) % mod + mod) % mod\n\t\tcurrentHash = (currentHash*base + int64(s[i])) % mod\n\n\t\tif currentHash == hashSep && Equal(s[i:i+len(sep)], sep) {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n\n// Equal checks if two slices ([]byte) or two strings are equal.\nfunc Equal[T string | []byte](a, b T) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "CodeBleu_score": 37.668379419899004}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int {\n\tif len(sep) == 0 || len(s) < len(sep) {\n\t\treturn -1\n\t}\n\n\tbase := 256    // Assuming a charset of ASCII 256 characters\n\tprime := 101    // A prime number to avoid hash overflow\n\n\tsepLen := len(sep)\n\tsLen := len(s)\n\tsepHash := 0\n\tsHash := 0\n\thighestPow := 1 // highestPow = base^(m-1) modulo prime\n\n\t// Calculate the hash of the separator and the highest power of base\n\tfor i := 0; i < sepLen; i++ {\n\t\tsepHash = (base*sepHash + int(sep[i])) % prime\n\t\tif i < sepLen-1 {\n\t\t\thighestPow = (highestPow * base) % prime\n\t\t}\n\t}\n\n\t// Calculate the hash value of the last window of text\n\twindowStart := sLen - sepLen\n\tfor i := 0; i < sepLen; i++ {\n\t\tsHash = (sHash*base + int(s[windowStart+i])) % prime\n\t}\n\n\t// Check the match for the hash from the end to the start\n\tfor i := sLen - sepLen; i >= 0; i-- {\n\t\tif sHash == sepHash {\n\t\t\t// Verify the sliced window against sep due to possible hash collision\n\t\t\tmatchFound := true\n\t\t\tfor j := 0; j < sepLen; j++ {\n\t\t\t\tif s[i+j] != sep[j] {\n\t\t\t\t\tmatchFound = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif matchFound {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\t// Recalculate hash: remove the old character and add the new one\n\t\tif i > 0 {\n\t\t\tsHash = (base*(sHash-int(s[i+sepLen-1])*highestPow) + int(s[i-1])) % prime\n\t\t\tif sHash < 0 {\n\t\t\t\tsHash += prime\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1 // if no match is found\n}", "CodeBleu_score": 36.2917629483743}, {"code": "package main\n\nimport (\n\t\"hash\"\n\t\"hash/fnv\"\n\t\"math\"\n)\n\n// LastIndexRabinKarp performs a reverse Rabin-Karp search to find the last occurrence of a substring within a string or byte slice.\n// It calculates the hash of the substring and uses it to compare against the hash of substrings in the main string from the end towards the beginning.\n// If a matching hash is found and the actual substring matches, it returns the starting index of the last occurrence; otherwise, it returns -1.\nfunc LastIndexRabinKarp[T string | []byte](s, sep T) int {\n    sepLen := len(sep)\n    sLen := len(s)\n    if sepLen == 0 {\n        return sLen\n    }\n    if sLen == 0 || sepLen > sLen {\n        return -1\n    }\n\n    // Create a hasher\n    hasher := fnv.New32a()\n    var sepHash uint32\n    hasher.Write(sep)\n    sepHash = hasher.Sum32()\n    \n    hashPower := uint32(math.Pow(256, float64(sepLen-1)))\n    \n    var lastHash uint32\n    hasher.Reset()\n    hasher.Write(s[sLen-sepLen:])\n    lastHash = hasher.Sum32()\n    \n    // Check edge case for substring at the end\n    if lastHash == sepHash && equalSlice(s[sLen-sepLen:], sep) {\n        return sLen - sepLen\n    }\n    \n    // Rolling hash over s from the end backwards.\n    for i := sLen - sepLen - 1; i >= 0; i-- {\n        // Roll the hash: remove the old end and add a new beginning\n        lastHash = (lastHash - uint32(s[i+sepLen])*hashPower)*256 + uint32(s[i])\n        if lastHash == sepHash && equalSlice(s[i:i+sepLen], sep) {\n            return i\n        }\n    }\n    \n    return -1\n}\n\n// equalSlice checks if two slices of type T are equal\nfunc equalSlice[T comparable](a, b T) bool {\n    return a == b\n}\n\nfunc main() {\n    text := \"This is a test string and a test example\"\n    pattern := \"test\"\n    \n    lastIdx := LastIndexRabinKarp[string](text, pattern)\n    println(\"Last occurrence index:\", lastIdx)\n}", "CodeBleu_score": 41.61929693158308}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush() {\n    // First, disable interrupts to avoid any conflict while accessing the transmit buffer.\n    interruptState := usbcdc.DisableInterrupts()\n\n    // Check if there is data in the transmit buffer.\n    if len(usbcdc.transmitBuffer) > 0 {\n        // There is data to send.\n        // Send the data to the USB endpoint.\n        usbcdc.SendUSBInPacket(usbcdc.transmitBuffer)\n        // Clear the transmit buffer after it has been sent.\n        usbcdc.transmitBuffer = nil\n    } else {\n        // No data is available, set waitTxc to false.\n        usbcdc.waitTxc = false\n    }\n\n    // Restore the interrupt state.\n    usbcdc.RestoreInterrupts(interruptState)\n}", "CodeBleu_score": 46.666124239685374}, {"code": "func (usbcdc *USBCDC) Flush() {\n    // First, disable interrupts to prevent conflicts, assuming a method exists to do so.\n    usbcdc.DisableInterrupts()\n    defer usbcdc.EnableInterrupts() // Use defer to ensure interrupts are re-enabled.\n\n    // Check if there is any data in the transmit buffer.\n    if len(usbcdc.txBuffer) > 0 {\n        // There is data to send; use the SendUSBInPacket method.\n        err := usbcdc.SendUSBInPacket(usbcdc.txBuffer)\n        // Handle potential errors during transmission.\n        if err != nil {\n            // Log error or handle it as required\n            fmt.Printf(\"Error sending data: %s\\n\", err.Error())\n        }\n\n        // Assuming SendUSBInPacket sends all data successfully and clears the buffer:\n        usbcdc.txBuffer = nil\n    } else {\n        // No data available in the transmit buffer, set waitTxc to false.\n        usbcdc.waitTxc = false\n    }\n\n    // Interrupts will be re-enabled here due to the defer statement at the start.\n}", "CodeBleu_score": 49.93721619698206}, {"code": "func (usbcdc *USBCDC) Flush() {\n    // disable interrupts to ensure exclusive access to shared resources\n    interruptStatus := disableInterrupts()\n\n    // check if there is any data in the transmit buffer\n    if len(usbcdc.transmitBuffer) > 0 {\n        // send data to the USB endpoint\n        usbcdc.SendUSBInPacket(usbcdc.transmitBuffer)\n\n        // clear the transmit buffer after sending\n        usbcdc.transmitBuffer = nil\n    } else {\n        // if no data is available, set waitTxc to false\n        usbcdc.waitTxc = false\n    }\n\n    // restore the initial interrupt state\n    restoreInterrupts(interruptStatus)\n}", "CodeBleu_score": 38.1090753578735}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "// Clear the interrupt flag, put a start condition on the SDA line, and enable the I2C module\n    i2c.Control = START_CONDITION | ENABLE_MODULE | CLEAR_INTERRUPT\n\n    // Wait for the start condition to be transmitted by checking the interrupt flag\n    for (i2c.Control & INTERRUPT_FLAG) == 0 {\n        // Optionally, you can include some timeout functionality to prevent infinite loops\n        // or handle any errors according to system requirements.\n    }\n\n    // Calculate the shifted address and also set the read/write bit\n    var modeBit uint8\n    if write {\n        modeBit = 0  // Write mode\n    } else {\n        modeBit = 1  // Read mode\n    }\n    shiftedAddress := (address << 1) | modeBit\n\n    // Write the address to the bus\n    i2c.Data = shiftedAddress\n    i2c.Control |= SEND_BIT\n\n    // Wait for the address to be transmitted\n    for (i2c.Control & INTERRUPT_FLAG) == 0 {\n        // Similarly, consider including a timeout or error handling mechanism.\n    }\n\n    // Optionally, clear the start condition after the address is sent if needed:\n    // i2c.Control &= ^START_CONDITION\n\n    // The method could also return an error status if proper error conditions and management is implemented.\n}", "CodeBleu_score": 25.454619158719627}, {"code": "func (i2c *I2C) start(address uint8, write bool) {\n    // Clear interrupt flag, issue start condition, enable I2C\n    i2c.ControlRegister = (i2c.CLEAR_FLAG | i2c.START_CONDITION | i2c.I2C_ENABLE)\n\n    // Wait for the start condition to complete\n    for i2c.ControlRegister&i2c.INTERRUPT_FLAG == 0 {\n        // wait until the interrupt flag is set indicating that the start condition has been transmitted\n    }\n\n    // Set the address. If write flag is false (i.e., read operation), set the read bit (usually the LSB)\n    if write {\n        i2c.DataRegister = address << 1 // Shift left to make space for read/write bit\n    } else {\n        i2c.DataRegister = (address << 1) | 1 // Set LSB to 1 for read\n    }\n\n    // Clear the interrupt flag to send the address\n    i2c.ControlRegister &= ^i2c.INTERRUPT_FLAG\n}", "CodeBleu_score": 30.360511544040957}, {"code": "func (i2c *I2C) start(address uint8, write bool) {\n    // Set the control register: clear the interrupt flag, put a start condition, enable the I2C module\n    i2c.ControlRegister = CR_START | CR_ENABLE | CR_IF_CLEAR\n\n    // Wait for the start condition to be transmitted (interrupt flag will be set once done)\n    for i2c.ControlRegister & CR_IF == 0 {}\n\n    // Set address and adjust for read/write operation\n    // Shift the address left by 1 bit and set the LSB to 0 (write) or 1 (read), according to the flag\n    if write {\n        i2c.DataRegister = address << 1 // LSB is 0 for write operation\n    } else {\n        i2c.DataRegister = (address << 1) | 1 // LSB is 1 for read operation\n    }\n\n    // Clear the start condition and wait for the address to be transmitted\n    i2c.ControlRegister &= ^CR_START\n\n    // Wait until the address frame is done being sent\n    for i2c.ControlRegister & CR_IF == 0 {}\n}", "CodeBleu_score": 31.142809470381206}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f *flashBlockDevice) EraseBlocks(start, len int64) error {\n    // Calculate the start address by multiplying the start block number by the block size.\n    startAddress := start * f.blockSize\n\n    // Ensure that there is no ongoing operation by checking if the flash is busy.\n    if f.IsFlashBusy() {\n        return fmt.Errorf(\"flash is currently busy\")\n    }\n\n    // Configure the flash for erasing.\n    if err := f.ConfigureForErase(); err != nil {\n        return fmt.Errorf(\"failed to configure flash for erasing: %v\", err)\n    }\n\n    // Erase the specified number of blocks.\n    for i := int64(0); i < len; i++ {\n        currentBlockAddress := startAddress + (i * f.blockSize)\n\n        // Start erasing of the current block.\n        if err := f.EraseBlock(currentBlockAddress); err != nil {\n            return fmt.Errorf(\"failed to erase block at address %d: %v\", currentBlockAddress, err)\n        }\n\n        // Wait until the flash is no longer busy after erasing one block.\n        for f.IsFlashBusy() {\n        }\n    }\n\n    // Set the flash back to read mode.\n    f.SetReadMode()\n\n    return nil\n}", "CodeBleu_score": 33.53049898905092}, {"code": "// EraseBlocks erases a specified number of blocks in the flash memory starting from a given block index.\nfunc (f *flashBlockDevice) EraseBlocks(start, count int64) error {\n    // Calculate the start address for the blocks to be erased\n    startAddress := start * f.blockSize\n\n    // Wait for any ongoing flash operations to complete\n    if err := f.waitForFlashReady(); err != nil {\n        return err\n    }\n\n    for i := int64(0); i < count; i++ {\n        // Calculate the address of the block to erase\n        address := startAddress + i*f.blockSize\n\n        // Configure the flash for erasing\n        if err := f.setupFlashErase(); err != nil {\n            return err\n        }\n        \n        // Erase the block\n        if err := f.eraseFlashBlock(address); err != nil {\n            return err\n        }\n\n        // Wait until the flash is no longer busy after erasing\n        if err := f.waitForFlashReady(); err != nil {\n            return err\n        }\n    }\n\n    // Set the flash back to read mode\n    if err := f.setFlashReadMode(); err != nil {\n        return err\n    }\n\n    return nil\n}\n\n// Dummy methods to represent flash control operations\nfunc (f *flashBlockDevice) waitForFlashReady() error {\n    // Implement waiting mechanism specific to your hardware or simulate delay\n    return nil\n}\n\nfunc (f *flashBlockDevice) setupFlashErase() error {\n    // Implement the flash settings required before erasing\n    return nil\n}\n\nfunc (f *flashBlockDevice) eraseFlashBlock(address int64) error {\n    // Implement block erasing logic here\n    return nil\n}\n\nfunc (f *flashBlockDevice) setFlashReadMode() error {\n    // Implement setting the flash back into read mode after erasing\n    return nil\n}", "CodeBleu_score": 34.34899703230974}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error {\n    // Calculate the start address using the start block number and block size\n    startAddress := start * f.BlockSize\n\n    // Wait for any ongoing flash operations to complete\n    for f.flashBusy() {\n        // optionally sleep or yield time\n        time.Sleep(10 * time.Millisecond)\n    }\n\n    // Configure flash to erase mode\n    f.EnableEraseMode()\n\n    for i := int64(0); i < len; i++ {\n        // Calculate the address of the block to be erased\n        blockAddress := startAddress + (i * f.BlockSize)\n\n        // Erase the block\n        f.EraseBlock(blockAddress)\n\n        // Wait until the flash is no longer busy before proceeding to the next block\n        for f.flashBusy() {\n            // optionally sleep or yield time\n            time.Sleep(10 * time.Millisecond)\n        }\n    }\n\n    // Set the flash back to read mode\n    f.EnableReadMode()\n\n    // Return nil indicating success\n    return nil\n}", "CodeBleu_score": 35.14070486278212}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f *flashBlockDevice) WriteAt(p []byte, off int64) (int, error) {\n    // Check if the write operation exceeds the flash memory bounds\n    if off < 0 || off+int64(len(p)) > f.size {\n        return 0, fmt.Errorf(\"write operation exceeds flash memory bounds\")\n    }\n\n    // Calculate the start address for writing\n    startAddress := f.baseAddress + off\n\n    // Pad the byte slice to fit the write block size\n    remainder := len(p) % f.writeBlockSize\n    if remainder != 0 {\n        padding := make([]byte, f.writeBlockSize-remainder)\n        p = append(p, padding...)\n    }\n\n    // Enable write mode on the flash memory controller\n    f.controller.enableWriteMode()\n\n    // Write the data in blocks\n    bytesWritten := 0\n    for i := 0; i < len(p); i += f.writeBlockSize {\n        block := p[i : i+f.writeBlockSize]\n        if err := f.controller.writeBlock(startAddress+int64(i), block); err != nil {\n            return bytesWritten, err\n        }\n        bytesWritten += len(block)\n\n        // Wait for the flash memory to be ready\n        f.controller.waitForReady()\n    }\n\n    // Return the number of bytes written\n    return bytesWritten, nil\n}", "CodeBleu_score": 29.64025975448238}, {"code": "// WriteAt writes data to a flash memory device at a specified offset.\nfunc (f *flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error) {\n    totalSize := int64(len(f.data))\n    dataLen := int64(len(p))\n\n    // Check if the write operation exceeds the flash memory bounds.\n    if off < 0 || off+dataLen > totalSize {\n        return 0, fmt.Errorf(\"write out of bounds\")\n    }\n\n    // Calculate the actual write start position.\n    writePos := off\n\n    // Padding calculation if needed to align with block size requirement.\n    blockSize := int64(f.blockSize)\n    overflow := (writePos + dataLen) % blockSize\n    if overflow != 0 {\n        padSize := blockSize - overflow\n        padding := make([]byte, padSize)\n        p = append(p, padding...)\n    }\n\n    // Enable write mode on the flash memory controller.\n    f.controller.EnableWriteMode()\n\n    // Write data in blocks.\n    for i := int64(0); i < dataLen; i += blockSize {\n        end := i + blockSize\n        if end > dataLen {\n            end = dataLen\n        }\n\n        // Write a block of data to the flash.\n        if err := f.controller.WriteBlock(f.data[writePos+i:writePos+end]); err != nil {\n            return int(i), fmt.Errorf(\"failed to write block at %d: %w\", writePos+i, err)\n        }\n\n        // Wait until the flash memory is ready.\n        f.controller.WaitForReady()\n\n        // Increment the number of bytes successfully written.\n        n += int(end - i)\n    }\n\n    // Return the number of bytes written.\n    return n, nil\n}", "CodeBleu_score": 30.813418723063467}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error) {\n\t// Check if writing p would exceed the size of the flash memory.\n\tif off < 0 || off+int64(len(p)) > int64(len(f.memory)) {\n\t\treturn 0, fmt.Errorf(\"write operation exceeds flash memory bounds\")\n\t}\n\n\t// Calculate the block-aligned start address.\n\tblockSize := f.blockSize\n\tstartAddress := off - (off % int64(blockSize))\n\n\t// Calculate padding needed to align with the block size.\n\tpaddingSize := blockSize - (len(p) % blockSize)\n\tif paddingSize != blockSize {\n\t\tp = append(p, make([]byte, paddingSize)...)\n\t}\n\n\t// Enable write mode.\n\tf.controller.enableWriteMode(true)\n\tdefer f.controller.enableWriteMode(false)\n\n\t// Write data in blocks of blockSize.\n\tfor i := 0; i < len(p); i += blockSize {\n\t\tblockData := p[i : i+blockSize]\n\t\tif err := f.controller.write(blockData, startAddress+int64(i)); err != nil {\n\t\t\treturn i, fmt.Errorf(\"failed to write data at address %d: %w\", startAddress+int64(i), err)\n\t\t}\n\t\t// Wait for flash ready.\n\t\tf.controller.waitForFlashReady()\n\t}\n\treturn len(p) - paddingSize, nil\n}", "CodeBleu_score": 32.07942531855582}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "package main\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n)\n\nfunc darwinOpenDir(fd int) (uintptr, error) {\n\t// Duplicate the file descriptor to avoid affecting the original fd\n\tdupFD, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to duplicate file descriptor: %v\", err)\n\t}\n\n\t// Attempt to open the directory repeatedly if interrupted by a signal\n\tfor {\n\t\tdirPtr, err := syscall.Fdopendir(dupFD)\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\t// If the call was interrupted, try again\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\t// Close the duplicated file descriptor on error\n\t\t\t\tsyscall.Close(dupFD)\n\t\t\t\treturn 0, fmt.Errorf(\"failed to open directory: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\treturn dirPtr, nil // Successfully opened directory\n\t}\n}\n\nfunc main() {\n\t// Example usage:\n\t// Open a directory referred by fd. You should replace 0 with an appropriate fd value.\n\tdirPtr, err := darwinOpenDir(0)\n\tif err != nil {\n\t\tfmt.Printf(\"Error opening directory: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Directory opened successfully, pointer: %d\\n\", dirPtr)\n\t}\n}", "CodeBleu_score": 47.57704780381076}, {"code": "package main\n\nimport (\n\t\"syscall\"\n)\n\n// darwinOpenDir attempts to open a directory file descriptor on a Darwin (macOS) system.\n// It first duplicates the provided file descriptor and checks for errors.\n// If successful, it then repeatedly attempts to open the directory using \"syscall.Fdopendir\"\n// until it either succeeds or encounters an error other than \"syscall.EINTR\".\n// If an error occurs, it closes the duplicated file descriptor and returns the error message;\n// otherwise, it returns the directory pointer with no error.\nfunc darwinOpenDir(fd int) (uintptr, error) {\n\t// Duplicate the file descriptor\n\tdupFd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Try to open the directory with the duplicated file descriptor\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupFd)\n\t\tif err != nil {\n\t\t\tif err == syscall.EINTR {\n\t\t\t\t// If the call was interrupted, retry\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// For other errors, clean up and return the error\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, err\n\t\t}\n\t\tbreak // success\n\t}\n\n\t// Successfully opened the directory\n\treturn dir, nil\n}", "CodeBleu_score": 69.33005424562796}, {"code": "package main\n\nimport (\n\t\"syscall\"\n)\n\n// darwinOpenDir attempts to open a directory file descriptor on a Darwin (macOS) system.\n// It first duplicates the provided file descriptor and checks for errors.\n// If successful, it then repeatedly attempts to open the directory using \"syscall.Fdopendir\" until it either\n// succeeds or encounters an error other than \"syscall.EINTR\".\n// If an error occurs, it closes the duplicated file descriptor\n// and returns the error message; otherwise, it returns the directory pointer with no error.\nfunc darwinOpenDir(fd int) (uintptr, error) {\n\tdupfd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Attempt to open the directory, retrying if interrupted by a signal\n\tvar dir uintptr\n\tfor {\n\t\tdir, err = syscall.Fdopendir(dupfd)\n\t\tif err != syscall.EINTR {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tsyscall.Close(dupfd) // Close duplicated fd on failure to open directory\n\t\treturn 0, err\n\t}\n\n\treturn dir, nil\n}", "CodeBleu_score": 72.64274758476168}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "#include <Arduino.h>\n#include \"esp_partition.h\"\n\nstatic uint32_t sketchSize(boolean response) {\n    // Get the partition labeled as the 'app' partition where the sketch runs\n    const esp_partition_t* running_partition = esp_ota_get_running_partition();\n\n    if (running_partition == nullptr) {\n        return 0; // Return 0 if the partition cannot be obtained\n    }\n    \n    if (!response) {\n        // If response is false, return the size of the sketch (used size)\n        return running_partition->size;\n    } else {\n        // If response is true, return the free space in the partition\n        size_t total_size = running_partition->size;\n        size_t used_size = ESP.getSketchSize();\n        return total_size - used_size; \n    }\n}", "CodeBleu_score": 45.32838189591117}, {"code": "#include \"esp_ota_ops.h\"\n#include \"esp_partition.h\"\n\ntypedef enum {\n    FREE_SPACE, // Indicates the caller wants the free space in the partition\n    USED_SPACE  // Indicates the caller wants the used space (size of the sketch)\n} sketchSize_t;\n\nstatic uint32_t sketchSize(sketchSize_t response) {\n    const esp_partition_t *partition;\n\n    // Get the partition where the application is currently running\n    partition = esp_ota_get_running_partition();\n    if (partition == NULL) {\n        return 0; // Return zero if the partition cannot be determined\n    }\n\n    if (response == FREE_SPACE) {\n        // Calculate free space by subtracting the used size from the total size of the partition\n        return partition->size - partition->used_size;\n    } else if (response == USED_SPACE) {\n        // Return the used size of the partition, which is equivalent to the size of the sketch\n        return partition->used_size;\n    }\n\n    return 0; // Default return in case of unexpected 'response' value\n}", "CodeBleu_score": 40.92395135192209}, {"code": "#include <Arduino.h>\n#ifdef ESP32\n  #include <ESP32.h> // This include might vary depending on the actual IDF setup or Arduino core environment\n#elif defined(ESP8266)\n  #include <ESP8266WiFi.h>\n#endif\n\n// Enum to define the possible types of responses the function can handle\nenum sketchSize_t { GET_FREE_SPACE, GET_SKETCH_SIZE };\n\nstatic uint32_t sketchSize(sketchSize_t response) {\n    if (response == GET_FREE_SPACE) {\n        // Return the free space available in the partition\n        return ESP.getFreeSketchSpace();\n    } else if (response == GET_SKETCH_SIZE) {\n        // Return the actual size of the sketch\n        return ESP.getSketchSize();\n    }\n    \n    // Optionally handle unknown response types\n    return 0;  // Indicating an error or unsupported response parameter\n}", "CodeBleu_score": 29.292586690699096}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#define SECTOR_SIZE 512\n#define NUM_SECTORS 2048  // Example size of the RAM disk\n#define BOOT_SECTOR_SIZE SECTOR_SIZE\n#define FAT_TABLE_SIZE (SECTOR_SIZE * 2)  // Example FAT table size for simplicity\n\n// Simulated memory for the RAM disk\nstatic uint8_t *ram_disk = NULL;\n\n// Function prototypes\nstatic void setup_boot_sector(const char *volume_label, uint32_t serial_number);\nstatic void setup_fat_table();\n\nstatic bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number) {\n    // Calculate the required size for the RAM disk (simple sum of components, for example)\n    size_t disk_size = SECTOR_SIZE * NUM_SECTORS; \n\n    // Attempt to allocate memory for the RAM disk\n    ram_disk = (uint8_t *)malloc(disk_size);\n    if (!ram_disk) {\n        fprintf(stderr, \"Error: Failed to allocate memory for RAM disk\\n\");\n        return false;\n    }\n\n    // Clear RAM disk memory\n    memset(ram_disk, 0, disk_size);\n\n    // Setup boot sector with the volume label and serial number\n    setup_boot_sector(volume_label, serial_number);\n\n    // Setup the FAT table\n    setup_fat_table();\n\n    // Normally here we set up the root directory, possibly add a firmware file entry if applicable\n\n    printf(\"RAM disk setup completed successfully.\\n\");\n    return true;\n}\n\nstatic void setup_boot_sector(const char *volume_label, uint32_t serial_number) {\n    // Simulated boot sector configuration\n    // Typically you'd do more binary structuring filling depending on the FAT type etc.\n    if (strlen(volume_label) > 11) {\n        fprintf(stderr, \"Error: Volume label too long\\n\");\n        return;\n    }\n    \n    char boot_sector[BOOT_SECTOR_SIZE] = {0};\n    \n    // Example setup: first bytes can be used for a jump instruction and OEM ID in real boot sector\n    sprintf(boot_sector, \"MSDOS5.0\");  // Dummy OEM ID\n    memcpy(boot_sector + 3, volume_label, strlen(volume_label));\n    memcpy(boot_sector + 14, &serial_number, sizeof(serial_number));\n\n    // Copy customized boot sector into RAM disk\n    memcpy(ram_disk, boot_sector, BOOT_SECTOR_SIZE);\n}\n\nstatic void setup_fat_table() {\n    // Set up a very rudimentary FAT table. Here we're just initializing; real disks need proper FAT setup.\n    memset(ram_disk + BOOT_SECTOR_SIZE, 0xFF, FAT_TABLE_SIZE); // Some dummy FAT value\n}\n\nint main() {\n    const char *label = \"MYVOLUME\";\n    uint32_t serial = 12345678;  // Example serial number\n\n    if (msc_update_setup_disk(label, serial)) {\n        printf(\"Disk setup succeeded.\\n\");\n    } else {\n        printf(\"Disk setup failed.\\n\");\n    }\n\n    // Clean up\n    if (ram_disk) {\n        free(ram_disk);\n    }\n\n    return 0;\n}", "CodeBleu_score": 41.07921277998305}, {"code": "#define SECTOR_SIZE 512\n#define NUM_SECTORS 2048  // Example size of the RAM disk in sectors\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n// For the simplicity of this example, we will assume the disk organization of a FAT16.\ntypedef struct {\n    uint8_t bootjmp[3];\n    char oem_name[8];\n    uint16_t bytes_per_sector;\n    uint8_t sectors_per_cluster;\n    uint16_t reserved_sectors;\n    uint8_t num_fats;\n    uint16_t root_dir_entries;\n    uint16_t total_sectors_short; // if zero, later field is used\n    uint8_t media_descriptor;\n    uint16_t fat_size_sectors;\n    uint16_t sectors_per_track;\n    uint16_t number_of_heads;\n    uint32_t hidden_sectors;\n    uint32_t total_sectors_long;\n    uint8_t drive_number;\n    uint8_t current_head;\n    uint8_t boot_signature;\n    uint32_t volume_id;\n    char volume_label[11];\n    char fs_type[8];\n} __attribute__((packed)) FatBootSector;\n\nstatic uint8_t *ram_disk = NULL;\n\nstatic void create_boot_sector(FatBootSector *bs, const char *volume_label, uint32_t serial_number) {\n    memset(bs, 0, sizeof(FatBootSector));\n    memcpy(bs->bootjmp, (uint8_t[]){0xEB, 0x3C, 0x90}, 3);\n    strcpy(bs->oem_name, \"MSDOS5.0\");\n    bs->bytes_per_sector = SECTOR_SIZE;\n    bs->sectors_per_cluster = 1;\n    bs->reserved_sectors = 1;\n    bs->num_fats = 2;\n    bs->root_dir_entries = 224;\n    bs->media_descriptor = 0xF8;\n    bs->fat_size_sectors = 9;\n    bs->sectors_per_track = 32;\n    bs->number_of_heads = 64;\n    bs->total_sectors_short = 0;\n    bs->total_sectors_long = NUM_SECTORS;\n    bs->drive_number = 0x80;\n    bs->boot_signature = 0x29;\n    bs->volume_id = serial_number;\n    strncpy(bs->volume_label, volume_label, sizeof(bs->volume_label) - 1);\n    strcpy(bs->fs_type, \"FAT16   \");\n}\n\nstatic bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number) {\n    // Allocate memory for the RAM disk\n    ram_disk = (uint8_t *)malloc(NUM_SECTORS * SECTOR_SIZE);\n    if (!ram_disk) {\n        fprintf(stderr, \"Error allocating memory for RAM disk.\\n\");\n        return false;\n    }\n\n    // Initialize boot sector\n    FatBootSector *bs = (FatBootSector *)ram_disk;\n    create_boot_sector(bs, volume_label, serial_number);\n\n    // Clear remaining sectors (assuming disk after boots sector is zeroed)\n    memset(ram_disk + SECTOR_SIZE, 0, NUM_SECTORS * SECTOR_SIZE - SECTOR_SIZE);\n\n    return true;\n}", "CodeBleu_score": 33.998511195845424}, {"code": "#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Constants for disk creation\n#define SECTOR_SIZE 512\n#define SECTOR_COUNT 2880 // 1.44MB floppy disk size in sectors\n#define ROOT_DIR_ENTRIES 224\n#define FAT_COPIES 2\n#define FAT_SIZE_SECTORS (SECTOR_COUNT / 10) // Simple approximation\n\n// Function prototypes for any additional helper functions you might use.\nvoid setupBootSector(uint8_t *disk, const char *volume_label, uint32_t serial_number);\nvoid setupFAT(uint8_t *disk);\nvoid setupRootDirectory(uint8_t *disk, const char *filename);\n\nstatic bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number) {\n    uint32_t disk_size = SECTOR_SIZE * SECTOR_COUNT;\n    uint8_t *ram_disk = (uint8_t *)calloc(disk_size, 1); // Allocate and zero-initialize memory\n\n    if (!ram_disk) {\n        // Memory allocation failed, log the error\n        fprintf(stderr, \"Error: Unable to allocate memory for the RAM disk.\\n\");\n        return false; // Return failure\n    }\n\n    // Setup boot sector with volume label and serial number\n    setupBootSector(ram_disk, volume_label, serial_number);\n\n    // Setup the FAT tables\n    setupFAT(ram_disk);\n\n    // Optionally add a root directory entry (this part could depend on some condition; here assumed filename \"firmware.bin\")\n    setupRootDirectory(ram_disk, \"firmware.bin\");\n\n    // Here, additional steps might include other filesystem setups, error handling/logging, etc.\n\n    // For now simply assume it all went well\n    free(ram_disk); // Don't forget to free the allocated memory (or ensure it's freed in real application usage)\n    return true; // Return success\n}\n\nvoid setupBootSector(uint8_t *disk, const char *volume_label, uint32_t serial_number) {\n    // Simple example how you might setup a boot sector, albeit not complete or accurate\n    memcpy(disk + 3, \"MSWIN4.1\", 8); // OEM Identifier\n    *((uint32_t*)(disk + 39)) = serial_number; // Serial number in boot sector\n    memcpy(disk + 43, volume_label, strlen(volume_label)); // Volume label\n}\n\nvoid setupFAT(uint8_t *disk) {\n    // Setup FAT here, notably marking the necessary reserved and bad sectors\n    uint8_t *fat_sector = disk + SECTOR_SIZE; // FAT starts right after boot sector\n    fat_sector[0] = 0xF8; // First byte of FAT for media descriptor\n    for (int i = 1; i < FAT_SIZE_SECTORS * SECTOR_SIZE; i++) {\n        fat_sector[i] = 0xFF; // Just mark as bad for simplification\n    }\n}\n\nvoid setupRootDirectory(uint8_t *disk, const char *filename) {\n    // Create directory entry at root for simplicity\n    uint8_t *root_dir = disk + (1 + FAT_COPIES * FAT_SIZE_SECTORS) * SECTOR_SIZE; // Calculate root directory position\n    memcpy(root_dir, filename, strlen(filename)); // Simple directory entry\n    root_dir[11] = 0x20; // File attribute (bitmask: readonly, hidden, system file, volume label, subdirectory, archive)\n}\n\n// Main function just to demonstrate; remove or ignore it in an embedded context\nint main() {\n    if (msc_update_setup_disk(\"MYDISK\", 123456789)) {\n        printf(\"RAM disk setup successfully.\\n\");\n    } else {\n        printf(\"Failed to setup RAM disk.\\n\");\n    }\n    return 0;\n}", "CodeBleu_score": 39.80914050850086}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "#include \"esp_log.h\"\n#include \"esp_partition.h\"\n#include \"esp_err.h\"\n\n#define FLASH_SECTOR_SIZE 4096 // Assume flash sector size of 4KB\n\nstatic const char* TAG = \"msc_update_write\";\n\nstatic esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size) {\n    if (partition == NULL || data == NULL) {\n        ESP_LOGE(TAG, \"Invalid argument, partition or data is NULL\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    // Check if the provided offset is aligned to the sector size\n    if (offset % FLASH_SECTOR_SIZE != 0) {\n        ESP_LOGE(TAG, \"Offset 0x%x is not sector aligned\", offset);\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    // Calculate the sector where the write begins\n    uint32_t start_sector = offset / FLASH_SECTOR_SIZE;\n\n    // Erase the sector before writing\n    esp_err_t result = esp_partition_erase_range(partition, start_sector * FLASH_SECTOR_SIZE, FLASH_SECTOR_SIZE);\n    if (result != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase flash sector at 0x%x\", start_sector * FLASH_SECTOR_SIZE);\n        return result;\n    }\n\n    // Write the data to the specified partition and offset\n    result = esp_partition_write(partition, offset, data, size);\n    if (result != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to partition\");\n        return result;\n    }\n\n    ESP_LOGI(TAG, \"Update write successful at offset 0x%x\", offset);\n    return result;\n}", "CodeBleu_score": 41.53378632905963}, {"code": "#include \"esp_log.h\"\n#include \"esp_partition.h\"\n#include \"esp_err.h\"\n\n#define FLASH_SECTOR_SIZE 4096\n\nstatic const char* TAG = \"msc_update_write\";\n\n// Function to check if the provided offset is aligned to the flash sector size.\nstatic bool is_offset_aligned(uint32_t offset) {\n    return (offset % FLASH_SECTOR_SIZE) == 0;\n}\n\nstatic esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, const void *data, size_t size) {\n    if (!is_offset_aligned(offset)) {\n        ESP_LOGE(TAG, \"Offset is not aligned to flash sector size\");\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    esp_err_t err;\n    \n    // Check if there's a need to erase sector\n    if (size >= FLASH_SECTOR_SIZE) {\n        // Calculate the number of sectors to erase\n        int num_sectors = (size + FLASH_SECTOR_SIZE - 1) / FLASH_SECTOR_SIZE;\n\n        // Erase the calculated number of sectors\n        for (int i = 0; i < num_sectors; ++i) {\n            uint32_t sector_offset = (offset / FLASH_SECTOR_SIZE + i) * FLASH_SECTOR_SIZE;\n            if ((err = esp_partition_erase_range(partition, sector_offset, FLASH_SECTOR_SIZE)) != ESP_OK) {\n                ESP_LOGE(TAG, \"Failed to erase flash at offset %d\", sector_offset);\n                return err; // Return the error code from erase operation\n            }\n        }\n    }\n\n    // Perform the write operation\n    if ((err = esp_partition_write(partition, offset, data, size)) != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to flash at offset %d\", offset);\n        return err; // Return the error code from write operation\n    }\n\n    // Return success if all operations are success\n    return ESP_OK;\n}", "CodeBleu_score": 41.164982953629966}, {"code": "#include \"esp_log.h\"\n#include \"esp_partition.h\"\n#include \"esp_err.h\"\n\n#define FLASH_SECTOR_SIZE 4096\n#define ESP_OK 0\n#define ESP_ERR_INVALID_SIZE -1\n#define ESP_ERR_FLASH_OP_FAIL -2\n\nstatic esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size) {\n    // Check if the offset is aligned to the sector size\n    if (offset % FLASH_SECTOR_SIZE != 0) {\n        ESP_LOGE(\"msc_update_write\", \"Offset 0x%08x is not aligned with sector size 0x%X\", offset, FLASH_SECTOR_SIZE);\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    // Calculate number of sectors\n    uint32_t sectors_to_erase = (size + FLASH_SECTOR_SIZE - 1) / FLASH_SECTOR_SIZE;\n\n    // Erase the flash\n    esp_err_t erase_status = esp_partition_erase_range(partition, offset, sectors_to_erase * FLASH_SECTOR_SIZE);\n    if (erase_status != ESP_OK) {\n        ESP_LOGE(\"msc_update_write\", \"Failed to erase flash: 0x%04x\", erase_status);\n        return erase_status;\n    }\n\n    // Write the data\n    esp_err_t write_status = esp_partition_write(partition, offset, data, size);\n    if (write_status != ESP_OK) {\n        ESP_LOGE(\"msc_update_write\", \"Failed to write to partition: 0x%04x\", write_status);\n    }\n\n    return write_status;\n}", "CodeBleu_score": 41.855625854620726}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "#include <cctype>\n#include <cmath>\n\nsize_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in) {\n    size_t idx = 0; // Index in the output array\n    size_t in_idx = 0; // Index in the input string\n\n    // Helper function to convert a single hex character to its byte value\n    auto hex_char_to_byte = [](char c) -> int {\n        if (c >= '0' && c <= '9') {\n            return c - '0';\n        } else if (c >= 'a' && c <= 'f') {\n            return 10 + (c - 'a');\n        } else if (c >= 'A' && c <= 'F') {\n            return 10 + (c - 'A');\n        } else {\n            return -1; // Indicates a non-hex character\n        }\n    };\n\n    // Loop through input string two characters at a time to form one byte\n    while (in[in_idx] != '\\0' && idx < maxlen) {\n        // Convert the first hex character\n        int nibble1 = hex_char_to_byte(in[in_idx]);\n        if (nibble1 != -1) { // Check if it's a valid hex character\n            in_idx++;\n            // Convert the next hex character\n            if (in[in_idx] != '\\0') {\n                int nibble2 = hex_char_to_byte(in[in_idx]);\n                if (nibble2 != -1) { // Check if it's also a valid hex character\n                    out[idx++] = static_cast<unsigned char>((nibble1 << 4) | nibble2);\n                    in_idx++;\n                }\n            }\n        } else {\n            in_idx++; // Skip invalid character and move to the next\n        }\n    }\n\n    // Return the number of bytes written to the output array\n    return idx;\n}", "CodeBleu_score": 36.24635567995475}, {"code": "#include <cctype>   // For isxdigit function\n#include <cstring>  // For string functions\n\nsize_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in) {\n    size_t outIndex = 0; // Index for output array\n    size_t inIndex = 0;  // Index for input string\n\n    // Iterate through the input string two characters at a time\n    while (in[inIndex] != '\\0' && outIndex < maxlen) {\n        // Skip non-hexadecimal characters\n        while (in[inIndex] != '\\0' && !std::isxdigit(in[inIndex])) {\n            inIndex++;\n        }\n\n        // Check if we have at least two hex digits\n        if (in[inIndex] == '\\0' || in[inIndex+1] == '\\0') {\n            break;\n        }\n\n        // Temporary variables to store each half-byte\n        unsigned char high, low;\n        \n        // Convert first hex digit (high nibble)\n        if (std::isdigit(in[inIndex]))\n            high = in[inIndex] - '0';\n        else if (std::isupper(in[inIndex]))\n            high = in[inIndex] - 'A' + 10;\n        else\n            high = in[inIndex] - 'a' + 10;\n\n        // Convert second hex digit (low nibble)\n        if (std::isdigit(in[inIndex+1]))\n            low = in[inIndex+1] - '0';\n        else if (std::isupper(in[inIndex+1]))\n            low = in[inIndex+1] - 'A' + 10;\n        else\n            low = in[inIndex+1] - 'a' + 10;\n\n        // Combine the two half bytes and place it into the output array\n        out[outIndex++] = (high << 4) | low;\n\n        // Move the input index forward by 2 to process the next pair of digits\n        inIndex += 2;\n    }\n\n    // Return the number of bytes written to the output array\n    return outIndex;\n}", "CodeBleu_score": 35.445770172830386}, {"code": "#include <cctype>\n\nsize_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in) {\n    size_t index = 0; // Index to keep track of the number of bytes written to the output\n    while (*in && index < maxlen) {\n        unsigned char byte = 0; // To store the byte value from a pair of hexadecimal characters\n        bool validByte = true;\n\n        for (int i = 0; i < 2; ++i) {\n            // Shift byte left by 4 on second loop iteration to make room for the second nybble\n            byte <<= 4;\n            if (*in) {\n                if (isdigit(*in)) {\n                    byte |= *in - '0';\n                } else if (*in >= 'a' && *in <= 'f') {\n                    byte |= 10 + (*in - 'a');\n                } else if (*in >= 'A' && *in <= 'F') {\n                    byte |= 10 + (*in - 'A');\n                } else {\n                    // not a valid hexadecimal character, skip it\n                    validByte = false;\n                    break;\n                }\n                ++in;\n            } else {\n                // The string ended unexpectedly; handle as single nibble or as error\n                validByte = false;\n                break;\n            }\n        }\n\n        // Only store byte if both characters formed a valid byte\n        if (validByte) {\n            out[index++] = byte;\n        }\n    }\n\n    return index; // Return the number of bytes written to the output\n}", "CodeBleu_score": 35.723379504393584}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "#include <iostream>\n#include <chrono>\n\nint HWCDC::availableForWrite(void) {\n    // Check if the transmit ring buffer and its lock are initialized.\n    if (!initialized) {\n        std::cerr << \"Error: Ring buffer or lock not initialized.\" << std::endl;\n        return 0;  // Indicating that no space is available if not initialized.\n    }\n\n    // Try to take the semaphore lock within a time limit to access the ring buffer.\n    if (semaphoreLock.try_lock_for(std::chrono::milliseconds(TIMEOUT_PERIOD))) {\n        // If the lock is successfully obtained, calculate the available space.\n        int freeSpace = ringBuffer.getFreeSpace();\n\n        // Release the lock after use.\n        semaphoreLock.unlock();\n        \n        // Return the available free space in the ring buffer.\n        return freeSpace;\n    } else {\n        // If the lock could not be obtained within the timeout, return 0 indicating failure.\n        std::cerr << \"Error: Could not obtain lock within timeout period.\" << std::endl;\n        return 0;\n    }\n}", "CodeBleu_score": 38.073218381965845}, {"code": "int HWCDC::availableForWrite(void) {\n    // Ensure the transmit ring buffer and its lock are initialized\n    if (txRingBuffer == nullptr || txRingBufferLock == nullptr) {\n        return 0;\n    }\n\n    // Attempt to take the lock on the ring buffer within a timeout\n    if (xSemaphoreTake(txRingBufferLock, portMAX_DELAY) == pdTRUE) {\n        // Successfully took the lock, calculate the available space\n        int tail = txRingBuffer->tail;\n        int head = txRingBuffer->head;\n        int size = txRingBuffer->size;\n\n        // Release the lock\n        xSemaphoreGive(txRingBufferLock);\n\n        // Calculate free space in the buffer\n        if (head >= tail) {\n            return (size - 1 - head + tail);\n        } else {\n            return (tail - head - 1);\n        }\n    } else {\n        // Failed to take the lock\n        return 0;\n    }\n}", "CodeBleu_score": 55.278373269823675}, {"code": "#include <mutex>\n#include <chrono>\n\nclass RingBuffer {\npublic:\n    int size() const; // Returns the number of elements in the buffer\n    int capacity() const; // Returns the capacity of the buffer\n};\n\nclass HWCDC {\n    RingBuffer transmitRingBuffer;\n    std::mutex mtx;\n    int bufferCapacity;\n\npublic:\n    HWCDC(int capacity) : bufferCapacity(capacity) {\n        // initializing the buffer with a specific capacity\n    }\n\n    int availableForWrite(void) {\n        // Attempts to acquire the lock\n        std::unique_lock<std::mutex> lock(mtx, std::defer_lock);\n\n        // Try to lock mutex within certain timeout duration\n        if (lock.try_lock_for(std::chrono::milliseconds(100))) { // 100 milliseconds as example timeout\n            int sizeUsed = transmitRingBuffer.size();\n            int sizeFree = bufferCapacity - sizeUsed;\n\n            // Release the lock implicitly by lock destructor\n            return sizeFree;\n        } else {\n            // Return 0 if the lock is not acquired\n            return 0;\n        }\n    }\n};", "CodeBleu_score": 36.29529709075502}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout) {\n    // Lock the serial port mutex before making changes to the class members\n    _mutex.lock();\n\n    // Assign the provided callback function to the class member\n    _onReceiveCB = function;\n\n    // Set the receive timeout behavior configuration\n    _onlyOnTimeout = onlyOnTimeout;\n    \n    // Check if the callback function is not NULL\n    if (function != nullptr) {\n        // Configure the FIFO full threshold for triggering the callback\n        if (!onlyOnTimeout) {\n            // If the callback should trigger immediately when FIFO is full (and not only on timeout),\n            // we can set the threshold to a suitable level, e.g., FIFO full\n            _serialPort.setFIFOTriggerLevel(FIFO_FULL);\n        } else {\n            // If the callback should trigger only on timeout, set a minimum FIFO threshold level\n            _serialPort.setFIFOTriggerLevel(FIFO_ONE_BYTE);\n        }\n\n        // Check if the event task does not exist and create it if needed\n        if (_eventTask == nullptr) {\n            _eventTask = createSerialEventTask();\n        }\n    }\n\n    // Unlock the serial port mutex after making changes\n    _mutex.unlock();\n}", "CodeBleu_score": 48.86055048577081}, {"code": "#include <mutex>\n\nclass HardwareSerial {\npublic:\n    typedef void (*OnReceiveCb)(const uint8_t* buffer, int length); // Callback signature\n\nprivate:\n    OnReceiveCb _onReceiveCB;\n    int _rxTimeout;\n    bool _onlyOnTimeout;\n    std::mutex _serialMutex;\n\npublic:\n    HardwareSerial() : _onReceiveCB(nullptr), _rxTimeout(1000), _onlyOnTimeout(false) {}\n\n    void onReceive(OnReceiveCb function, bool onlyOnTimeout);\n};\n\nvoid HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout) {\n    std::lock_guard<std::mutex> lock(_serialMutex);  // Lock the serial mutex\n    _onReceiveCB = function;                        // Set the provided callback function\n    _onlyOnTimeout = onlyOnTimeout;                 // Set the receive timeout behavior\n    \n    // If there's a valid callback function\n    if (_onReceiveCB != nullptr) {\n        // Conditionally configure FIFO threshold or timeout depending on \"onlyOnTimeout\"\n        if (!_onlyOnTimeout) {\n            // Configure the FIFO to notify callback whenever it is full or some other threshold is met\n            setFifoFullThreshold();\n        } else {\n            // Configure to call the callback only when the timeout expires\n            setReceiveTimeout(_rxTimeout);\n        }\n\n        // Create or confirm creation of an event task for handling the receive interrupts or polling\n        ensureEventTaskExists();\n    }\n\n    // The mutex will be unlocked automatically when the lock_guard is destructed at scope exit\n}\n\nvoid HardwareSerial::setFifoFullThreshold() {\n    // Function to configure hardware FIFO full threshold :)\n    // Example implementation could set hardware registers or control lines\n}\n\nvoid HardwareSerial::setReceiveTimeout(int timeout) {\n    // Set hardware or software timout for receiving data\n    // Example implementation could involve setting timer registers or configuring a watchdog\n}\n\nvoid HardwareSerial::ensureEventTaskExists() {\n    // Check if there's already a task for handling data receive events\n    // If not, create and configure the task\n}", "CodeBleu_score": 43.630227331578546}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout) {\n    // Locking the serial mutex to prevent race conditions.\n    _serialMutex.lock();\n\n    // Set the callback function _onReceiveCB with the provided function.\n    _onReceiveCB = function;\n\n    // Configure the receive timeout configuration based on onlyOnTimeout and _rxTimeout.\n    if (onlyOnTimeout) {\n        // Configure to trigger the callback only on a timeout condition\n        _configTimeout(_rxTimeout, true); // assuming there exists a method to configure timeouts\n    } else {\n        // Set the behavior to trigger the callback whenever data is received.\n        _configTimeout(_rxTimeout, false); // assuming there exists a method to configure timeouts\n    }\n\n    // Check if the callback function is not NULL, indicating that a callback is expected to be used.\n    if (_onReceiveCB != NULL) {\n        // Set the FIFO full threshold. This is where you decide when the \"full\" event is triggered based on your buffer size\n        // e.g., fifo_set_full_threshold(128); Assume some reasonable threshold or derived from hardware specifics \n        // and a hypothetical function exists for this configuration.\n\n        // Create an event task for handling received data unless it already exists.\n        if (!_eventTaskCreated) {\n            _createEventTask();  // assuming a method to create an event task to handle incoming data\n            _eventTaskCreated = true;\n        }\n    }\n\n    // Unlock the serial mutex.\n    _serialMutex.unlock();\n}", "CodeBleu_score": 51.41849799478353}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length) {\n    if (length < 1) {\n        return 0; // Return 0 according to function's spec when length is less than 1\n    }\n\n    size_t count = 0;\n    int c;\n\n    while (count < length - 1) { // Ensure there is space for the null terminator\n        c = timedRead(); // Read a character from the stream with a timeout\n        \n        // Check for end of stream (-1 indicates no more data)\n        if (c == -1) break;\n        \n        // Store character read into buffer\n        buffer[count++] = (char)c;\n        \n        // Stop if the terminator character is encountered\n        if ((char)c == terminator) {\n            break;\n        }\n    }\n\n    // Add null terminator to the buffer if there is space\n    buffer[count] = '\\0';\n    \n    return count;\n}", "CodeBleu_score": 63.420085722729645}, {"code": "#include <cstddef>  // for size_t\n\nclass Stream {\npublic:\n    // Placeholder for an actual function to read characters from a Stream with a timeout\n    int timedRead() {\n        // In practice, this method should be implemented to perform reading of a character \n        // from the hardware stream with some kind of timeout management.\n        // Here we provide a dummy placeholder.\n        return EOF; // EOF should be handled as the end of the stream indication.\n    }\n\n    size_t readBytesUntil(char terminator, char *buffer, size_t length) {\n        if (length < 1) {\n            // If length is less than 1, we return 0 as noted in the docstring\n            return 0;\n        }\n\n        size_t index = 0;\n        while (index < length - 1) { // reserve space for null terminator\n            int c = timedRead();\n            \n            if (c == EOF) {\n                break; // end of the stream\n            }\n            \n            if (c == terminator) {\n                break; // terminator found\n            }\n            \n            // Store the character in the buffer\n            buffer[index++] = (char)c;\n        }\n        \n        // Null terminate the buffer\n        buffer[index] = '\\0';\n        \n        return index; // Return the number of characters occupied in the buffer excluding the null terminator\n    }\n};", "CodeBleu_score": 65.66459817542906}, {"code": "#include <string.h>  // for size_t definition\n\nclass Stream {\npublic:\n    int timedRead();  // Mock-up declaration.\n\n    // Implement readBytesUntil with given constraints.\n    size_t readBytesUntil(char terminator, char *buffer, size_t length) {\n        if (length < 1) return 0;\n\n        size_t count = 0;\n        int c;\n\n        while (count < length - 1) {  // Reserve space for null terminator\n            c = timedRead();          // Read a character\n\n            if (c == -1) break;       // End of stream or timeout\n            if (c == terminator) break;  // Terminator found, do not include in buffer\n\n            buffer[count++] = (char)c;   // Store the character in the buffer\n        }\n\n        buffer[count] = '\\0';  // Null terminate the string\n        return count;\n    }\n};", "CodeBleu_score": 54.038340237453376}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_PINS 256\nbool pinUsage[MAX_PINS] = { false }; // array to track if pins are in use\n\n// Assume sending command to queue is done through this function (to be implemented)\nvoid sendToneCommandToQueue(uint8_t pin, unsigned int frequency, unsigned long duration) {\n    // Example function that should interface with the hardware control system.\n    printf(\"Sending tone command to queue: Pin %d, Frequency %u Hz, Duration %lu ms\\n\", pin, frequency, duration);\n}\n\n// Function to check if pin is available or in use\nbool isPinAvailable(uint8_t pin) {\n    return !pinUsage[pin];\n}\n\n// Function to mark pin as used\nvoid usePin(uint8_t pin) {\n    pinUsage[pin] = true;\n}\n\n// Function to mark pin as free\nvoid freePin(uint8_t pin) {\n    pinUsage[pin] = false;\n}\n\nvoid tone(uint8_t pin, unsigned int frequency, unsigned long duration) {\n    printf(\"Request to generate tone: Pin %d, Frequency %u Hz, Duration %lu ms\\n\", pin, frequency, duration);\n\n    if (pin >= MAX_PINS) {\n        printf(\"Error: Invalid pin number. The pin number must be less than %d.\\n\", MAX_PINS);\n        return;\n    }\n\n    // Check if the pin is available\n    if (isPinAvailable(pin)) {\n        usePin(pin); // Mark the pin as used\n        sendToneCommandToQueue(pin, frequency, duration);\n    } else {\n        // The pin is in use\n        printf(\"Error: Pin %d is currently in use. Please stop the current tone before starting a new one.\\n\", pin);\n    }\n}", "CodeBleu_score": 36.13671648160034}, {"code": "#include <stdio.h>\n\n// Mock function to check if a pin is in use. Return 0 if not in use.\nint isPinInUse(uint8_t pin) {\n    // This should contain your logic to check if the pin is already in use\n    return 0; // Change it according to the real implementation.\n}\n\n// Mock function to start the tone on a specified pin.\nvoid startTone(uint8_t pin, unsigned int frequency, unsigned long duration) {\n    // This should contain your logic to actually start the tone\n    printf(\"Tone started on pin %d with frequency %u Hz for %lu ms\\n\", pin, frequency, duration);\n}\n\n// Mock function to send tone command to a queue or handling system.\nvoid sendToneCommandToQueue(uint8_t pin, unsigned int frequency, unsigned long duration) {\n    // This should contain logic to send the tone command to the appropriate handling queue\n    printf(\"Command queued for pin %d with frequency %u Hz for %lu ms\\n\", pin, frequency, duration);\n}\n\nvoid tone(uint8_t pin, unsigned int frequency, unsigned long duration) {\n    printf(\"Request to generate tone on pin %d with frequency %u Hz for %lu ms\\n\", pin, frequency, duration);\n\n    if (!isPinInUse(pin)) {\n        startTone(pin, frequency, duration);\n        sendToneCommandToQueue(pin, frequency, duration);\n    } else {\n        printf(\"Error: Pin %d is already in use. Please stop the current tone before starting a new one.\\n\", pin);\n    }\n}", "CodeBleu_score": 32.179808080641074}, {"code": "#include <stdio.h>\n#include <stdbool.h>\n\n// Mockup function to simulate checking pin availability\nbool isPinAvailable(uint8_t pin) {\n    // This could interact with actual hardware or system registry to check pin status\n    // For simulation, we will assume all pins are available\n    return true;\n}\n\n// Mockup function to simulate starting a tone\nvoid startTone(uint8_t pin, unsigned int frequency, unsigned long duration) {\n    printf(\"Starting tone on pin %d with frequency %u and duration %lu ms\\n\", pin, frequency, duration);\n}\n\n// Mockup function to simulate stopping a tone\nvoid stopTone(uint8_t pin) {\n    printf(\"Stopping tone on pin %d\\n\", pin);\n}\n\nvoid tone(uint8_t pin, unsigned int frequency, unsigned long duration) {\n    // Log the pin, frequency, and duration\n    printf(\"Requested to generate tone on pin %d with frequency %u Hz for %lu ms duration.\\n\", pin, frequency, duration);\n    \n    // Check if the pin is available or already in use\n    if (isPinAvailable(pin)) {\n        // Pin is available\n        printf(\"Pin %d is available\\n\", pin);\n        // Initialize the tone\n        printf(\"Initializing tone...\\n\");\n        // Send a start command with the pin, frequency, and duration\n        startTone(pin, frequency, duration);\n    } else {\n        // Pin is in use\n        printf(\"Error: Pin %d is currently in use. Please stop the current tone before starting a new one.\\n\", pin);\n        // Optionally, you could stop the tone automatically and then retry starting the new tone:\n        // stopTone(pin);\n        // startTone(pin, frequency, duration);\n    }\n}", "CodeBleu_score": 33.017328580651906}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled) {\n    // Check if the USB has started or not\n    if (!usbStarted) {\n        // Update the state of WebUSB enabled based on input\n        webUSBEnabled = enabled;\n\n        // If enabling WebUSB, ensure USB version is at least 0x0210\n        if (enabled && usbVersion < 0x0210) {\n            usbVersion = 0x0210;\n        }\n\n        // Return true indicating USB has not started\n        return true;\n    }\n\n    // Return false as USB has already started\n    return false;\n}", "CodeBleu_score": 60.571842919316}, {"code": "bool ESPUSB::webUSB(bool enabled) {\n    if (!usbStarted) {        // Check if USB has started.\n        webUSBEnabled = enabled;  // Set WebUSB enabled state.\n\n        // Ensure USB version is at least 2.10 (0x0210) when WebUSB is enabled.\n        if (enabled) {\n            if (usbVersion < 0x0210) {\n                usbVersion = 0x0210;\n            }\n        }\n\n        // USB hasn't started yet\n        return true;\n    }\n\n    // If USB has started, return false indicating no change required.\n    return false;\n}", "CodeBleu_score": 50.65992974099138}, {"code": "bool ESPUSB::webUSB(bool enabled) {\n    if (!usbStarted) {\n        webUSBEnabled = enabled;\n        if (enabled) {\n            if (usbVersion < 0x0210) {\n                usbVersion = 0x0210;\n            }\n        }\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 53.765316691414164}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX() {\n    // Buffer for incoming data, size depends on typical data packet size and system resources\n    uint8_t buffer[256];\n    size_t receivedBytes = 0;\n    int overflowCounter = 0;\n\n    // Attempt to read data from USB CDC into buffer\n    receivedBytes = this->readData(buffer, sizeof(buffer));\n\n    // Processing each byte of received data\n    for (size_t i = 0; i < receivedBytes; ++i) {\n        // Try to send byte to the receive queue\n        if (!receiveQueue.push(buffer[i])) {\n            // Queue full, increment the overflow counter\n            overflowCounter++;\n        }\n    }\n\n    // If overflow occurred\n    if (overflowCounter > 0) {\n        // Post an overflow event and log the error\n        postEvent(USB_CDC_EVENT_OVERFLOW, overflowCounter);\n        LogError(\"Queue overflow: %d bytes dropped\", overflowCounter);\n    }\n\n    // If data was successfully read\n    if (receivedBytes > 0) {\n        // Post a receive event\n        postEvent(USB_CDC_EVENT_RECEIVED, receivedBytes);\n    }\n}\n\n// Dummy implementations for demonstration purposes\n\nvoid USBCDC::postEvent(int eventType, size_t eventData) {\n    // Log or handle USB CDC event\n    std::cout << \"Event Type: \" << eventType << \", Data: \" << eventData << std::endl;\n}\n\nbool Queue::push(uint8_t byte) {\n    // Add byte to queue if there's space\n    if (size < capacity) {\n        data[tail] = byte;\n        tail = (tail + 1) % capacity;\n        size++;\n        return true;\n    }\n    return false;\n}\n\nsize_t USBCDC::readData(uint8_t* buffer, size_t maxSize) {\n    // Simulate read operation from USB device\n    const char* fakeData = \"Example data from USB\";\n    size_t dataLength = std::min(strlen(fakeData), maxSize);\n    memcpy(buffer, fakeData, dataLength);\n    return dataLength;\n}", "CodeBleu_score": 38.489857545870244}, {"code": "void USBCDC::_onRX() {\n    if (!checkInputReady()) {\n        return; // No data to read\n    }\n\n    // Buffer to store incoming data\n    const int BUFFER_SIZE = 256;\n    uint8_t buffer[BUFFER_SIZE];\n    \n    // Read data into the buffer\n    int bytesRead = readDataIntoBuffer(buffer, BUFFER_SIZE);\n    if (bytesRead <= 0) {\n        return; // No data was read, or an error occurred\n    }\n\n    // Attempt to send each byte to the receive queue\n    int bytesDropped = 0;\n    for (int i = 0; i < bytesRead; ++i) {\n        if (!queue.enqueue(buffer[i])) {\n            ++bytesDropped; // Increment the dropped bytes counter if enqueue fails\n        }\n    }\n\n    if (bytesDropped > 0) {\n        // Post an overflow event and log an error\n        postOverflowEvent(bytesDropped);\n        std::cerr << \"Error: Queue overflow. \" << bytesDropped << \" bytes dropped.\" << std::endl;\n    }\n\n    // If bytes were successfully read and queued, post a receive event\n    if (bytesRead - bytesDropped > 0) {\n        postReceiveEvent(bytesRead - bytesDropped);\n    }\n}", "CodeBleu_score": 29.378939163208283}, {"code": "void USBCDC::_onRX() {\n    uint8_t buffer[MAX_BUFFER_SIZE];\n    int bytesRead = readUSBData(buffer, MAX_BUFFER_SIZE);  // Assume readUSBData is a function that reads data and returns number of bytes read\n    if (bytesRead > 0) {\n        bool allDataQueued = true;\n        int droppedBytes = 0;\n\n        for (int i = 0; i < bytesRead; ++i) {\n            if (!rxQueue.push(buffer[i])) {  // Assume rxQueue.push attempts to push data into the queue\n                allDataQueued = false;\n                droppedBytes++;\n            }\n        }\n\n        if (!allDataQueued) {\n            logError(\"Queue overflow, dropped bytes: \" + std::to_string(droppedBytes));  // Assume logError logs error messages\n            postEvent(OVERFLOW_EVENT, droppedBytes);  // Assume postEvent handles events, OVERFLOW_EVENT is an event type for overflow\n        } else {\n            postEvent(RECEIVE_EVENT, bytesRead);  // RECEIVE_EVENT is an event type for successful reception\n        }\n    } else {\n        logError(\"No data received or read error occurred.\");\n    }\n}", "CodeBleu_score": 30.959621499930112}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "package main\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n)\n\n// API struct would have a method robotDevices and access to a data source.\ntype API struct {\n    Robots map[string][]string // Map of robot name to list of devices.\n}\n\n// RobotDevicesError to encapsulate an error response.\ntype RobotDevicesError struct {\n    Message string `json:\"message\"`\n}\n\n// RobotDevicesResponse for success response.\ntype RobotDevicesResponse struct {\n    RobotName string   `json:\"robot_name\"`\n    Devices   []string `json:\"devices\"`\n}\n\nfunc (a *API) robotDevices(res http.ResponseWriter, req *http.Request) {\n    // Get robot name from query string\n    query := req.URL.Query()\n    robotName := query.Get(\"name\")\n    if robotName == \"\" {\n        http.Error(res, \"Robot name is required\", http.StatusBadRequest)\n        return\n    }\n\n    // Check if robot exists\n    devices, exists := a.Robots[robotName]\n    if !exists {\n        // Return an error response if the robot does not exist\n        res.WriteHeader(http.StatusNotFound)\n        json.NewEncoder(res).Encode(RobotDevicesError{Message: \"No robot found with the specified name\"})\n        return\n    }\n\n    // If robot exists, return the list of devices\n    res.WriteHeader(http.StatusOK)\n    json.NewEncoder(res).Encode(RobotDevicesResponse{RobotName: robotName, Devices: devices})\n}\n\nfunc main() {\n    api := API{\n        Robots: map[string][]string{\n            \"Alpha\": {\"Sensor\", \"Camera\"},\n            \"Beta\":  {\"Actuator\", \"Gyro\"},\n        },\n    }\n\n    http.HandleFunc(\"/robotDevices\", api.robotDevices)\n    http.ListenAndServe(\":8080\", nil)\n}", "CodeBleu_score": 36.9191386873782}, {"code": "import (\n    \"encoding/json\"\n    \"net/http\"\n)\n\n// Assume these are given part of the API structure\ntype API struct {\n    Robots map[string][]string // map from robot name to a list of devices\n}\n\nfunc (a *API) robotDevices(res http.ResponseWriter, req *http.Request) {\n    // Decode the request to get the robot name\n    vars := mux.Vars(req)\n    robotName := vars[\"robotName\"]\n\n    // Check if the robot exists and retrieve devices\n    devices, exists := a.Robots[robotName]\n    if !exists {\n        // Robot does not exist, return an error message\n        res.WriteHeader(http.StatusNotFound)\n        json.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the specified name\"})\n        return\n    }\n\n    // Robot does exist, return devices\n    res.WriteHeader(http.StatusOK)\n    json.NewEncoder(res).Encode(map[string][]string{\"devices\": devices})\n}", "CodeBleu_score": 30.38174095362175}, {"code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n\n// Assume Robot and Device are defined somewhere\n\ntype Robot struct {\n\tName    string\n\tDevices []Device\n}\n\ntype Device struct {\n\tID       string\n\tType     string\n\tSettings map[string]interface{}\n}\n\ntype API struct {\n\t// This hypothetical field robots would hold robot data.\n\t// In an actual application, this might be replaced by a database access layer.\n\trobots map[string]Robot\n}\n\n// RobotDevices handles HTTP requests to retrieve devices associated with a specific robot.\nfunc (a *API) RobotDevices(res http.ResponseWriter, req *http.Request) {\n\t// Extract robot name from the query parameter `name`\n\trobotName := req.URL.Query().Get(\"name\")\n\tif robotName == \"\" {\n\t\thttp.Error(res, \"Robot name is required\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Check if the robot exists\n\trobot, exists := a.robots[robotName]\n\tif !exists {\n\t\thttp.Error(res, \"No robot found with the specified name\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Robot exists, serialize its devices to JSON\n\tencodedDevices, err := json.Marshal(robot.Devices)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Set the content type and write the JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(encodedDevices)\n}\n\nfunc main() {\n\ta := API{\n\t\trobots: map[string]Robot{\n\t\t\t\"Alpha\": {\n\t\t\t\tName: \"Alpha\",\n\t\t\t\tDevices: []Device{\n\t\t\t\t\t{ID: \"1\", Type: \"Sensor\", Settings: map[string]interface{}{\"sensitivity\": \"high\"}},\n\t\t\t\t\t{ID: \"2\", Type: \"Actuator\", Settings: map[string]interface{}{\"speed\": \"medium\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Setup basic http server for demonstration\n\thttp.HandleFunc(\"/robots\", a.RobotDevices)\n\thttp.ListenAndServe(\":8080\", nil)\n}", "CodeBleu_score": 44.99007598211981}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype API struct {\n\tRobots map[string][]string // assume Robots is a map of robot names to their connections\n}\n\n// robotConnections handles HTTP requests to retrieve the connections of a specified robot.\n// It extracts the robot name from the request URL and checks if the robot exists.\n// If the robot is found, it iterates through its connections, converts them to JSON format,\n// and writes them to the HTTP response.\n// If the robot is not found, it writes an error message to the HTTP response indicating\n// that no robot with the specified name was found.\nfunc (a *API) robotConnections(res http.ResponseWriter, req *http.Request) {\n\t// Extract the robot name from the URL\n\tsegments := strings.Split(req.URL.Path, \"/\") // Assuming URL pattern like `/robots/{robotName}/connections`\n\tif len(segments) < 3 {\n\t\thttp.Error(res, \"Invalid request, robot name is missing in URL\", http.StatusBadRequest)\n\t\treturn\n\t}\n\trobotName := segments[2]\n\n\t// Check if the robot exists\n\tconnections, exists := a.Robots[robotName]\n\tif !exists {\n\t\thttp.Error(res, \"No robot found with the given name\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Robot found, serialize its connections to JSON\n\tconnectionsJSON, err := json.Marshal(connections)\n\tif err != nil {\n\t\thttp.Error(res, \"Failed to serialize connections\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Set Content-Type header and write the JSON response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tres.Write(connectionsJSON)\n}", "CodeBleu_score": 30.96059716094153}, {"code": "import (\n    \"encoding/json\"\n    \"net/http\"\n    \"strings\"\n)\n\n// Assuming API struct and Robot data structure might look like this:\ntype API struct {\n    Robots map[string]*Robot\n}\n\ntype Robot struct {\n    Name        string\n    Connections []string\n}\n\nfunc (a *API) robotConnections(res http.ResponseWriter, req *http.Request) {\n    // Extract the last part of the URL path assuming it's the robot name\n    pathParts := strings.Split(req.URL.Path, \"/\")\n    robotName := pathParts[len(pathParts)-1]\n\n    // Check if the robot exists\n    robot, found := a.Robots[robotName]\n    if !found {\n        http.Error(res, \"No robot found with the specified name\", http.StatusNotFound)\n        return\n    }\n\n    // If the robot is found, marshal its connections into JSON\n    connectionsJSON, err := json.Marshal(robot.Connections)\n    if err != nil {\n        http.Error(res, \"Failed to parse connections data\", http.StatusInternalServerError)\n        return\n    }\n\n    // Set header and write the JSON data to response\n    res.Header().Set(\"Content-Type\", \"application/json\")\n    res.WriteHeader(http.StatusOK)\n    res.Write(connectionsJSON)\n}", "CodeBleu_score": 32.711692710970524}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request) {\n    // Assuming URL path is in the format /robots/{robotName}/connections\n    parts := strings.Split(req.URL.Path, \"/\")\n    if len(parts) < 4 {\n        http.Error(res, \"Invalid request URL\", http.StatusBadRequest)\n        return\n    }\n    robotName := parts[2]\n\n    // Assuming we have `a.robots` as the data store, which maps robot names to a list of connections\n    connections, exists := a.robots[robotName]\n    if !exists {\n        http.Error(res, fmt.Sprintf(\"No robot with the name '%s' found\", robotName), http.StatusNotFound)\n        return\n    }\n\n    response, err := json.Marshal(connections)\n    if err != nil {\n        http.Error(res, \"Failed to serialize connections\", http.StatusInternalServerError)\n        return\n    }\n\n    res.Header().Set(\"Content-Type\", \"application/json\")\n    res.WriteHeader(http.StatusOK)\n    res.Write(response)\n}", "CodeBleu_score": 31.310205068594964}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "import (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n\t\"gobot.io/x/gobot\"\n)\n\nfunc (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request) {\n\t// Set the response header to application/json for all responses\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\n\t// Parse the URL query parameters\n\tqueryParams := req.URL.Query()\n\trobotName := queryParams.Get(\"robot\")\n\tdeviceName := queryParams.Get(\"device\")\n\tcommand := queryParams.Get(\"command\")\n\n\tif robotName == \"\" || deviceName == \"\" || command == \"\" {\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"missing robot, device, or command parameter\"})\n\t\treturn\n\t}\n\n\t// Find the robot based on the robotName, assuming a method a.getRobotByName exists\n\trobot, err := a.getRobotByName(robotName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"error retrieving robot: \" + err.Error()})\n\t\treturn\n\t}\n\n\t// Find the device within the robot\n\tvar device gobot.Driver\n\tfor _, d := range robot.Devices() {\n\t\tif d.Name() == deviceName {\n\t\t\tdevice = d\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif device == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"device not found\"})\n\t\treturn\n\t}\n\n\t// Execute the command on the device\n\terr = device.Command(command)()\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"error executing command: \" + err.Error()})\n\t\treturn\n\t}\n\n\t// All done, report success\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(map[string]string{\"success\": \"command executed\"})\n}\n\n// Assuming this method is part of the API to get a robot by name\nfunc (a *API) getRobotByName(name string) (*gobot.Robot, error) {\n\t// Example function for retrieving robot\n\tfor _, robot := range a.robots {\n\t\tif robot.Name == name {\n\t\t\treturn robot, nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"robot named %s not found\", name)\n}", "CodeBleu_score": 42.87183725043923}, {"code": "import (\n    \"encoding/json\"\n    \"net/http\"\n)\n\nfunc (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request) {\n    // Extract query parameters from the URL\n    query := req.URL.Query()\n    robotName := query.Get(\"robot\")\n    deviceName := query.Get(\"device\")\n    command := query.Get(\"command\")\n\n    // Response structure for JSON output\n    type response struct {\n        Success bool   `json:\"success\"`\n        Message string `json:\"message\"`\n    }\n\n    // Check if robot name and device name are present\n    if robotName == \"\" || deviceName == \"\" {\n        res.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(res).Encode(response{Success: false, Message: \"Robot or device name missing in parameters\"})\n        return\n    }\n\n    // Now we assume `GetDevice` is a method that checks if the device exists\n    // This method must be defined in your Gobot integration\n    device, err := a.GetDevice(robotName, deviceName)\n    if err != nil {\n        res.WriteHeader(http.StatusInternalServerError)\n        json.NewEncoder(res).Encode(response{Success: false, Message: \"Error retrieving device: \" + err.Error()})\n        return\n    }\n\n    // Check if a command is specified\n    if command == \"\" {\n        res.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(res).Encode(response{Success: false, Message: \"No command specified\"})\n        return\n    }\n\n    // Execute the command using a method from Gobot (assuming 'ExecuteCommand' exists and handles the command execution)\n    err = device.ExecuteCommand(command)\n    if err != nil {\n        res.WriteHeader(http.StatusInternalServerError)\n        json.NewEncoder(res).Encode(response{Success: false, Message: \"Failed to execute command: \" + err.Error()})\n        return\n    }\n\n    // If everything went fine\n    res.WriteHeader(http.StatusOK)\n    json.NewEncoder(res).Encode(response{Success: true, Message: \"Command executed successfully\"})\n}", "CodeBleu_score": 41.30421944420696}, {"code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\n\t\"gobot.io/x/gobot\"\n)\n\n// API holds the Gobot framework and potentially other elements needed for API methods.\ntype API struct {\n\tGobot *gobot.Master\n}\n\n// DeviceCommandRequest is used to decode the JSON request with the device and the command.\ntype DeviceCommandRequest struct {\n\tDevice  string `json:\"device\"`\n\tCommand string `json:\"command\"`\n}\n\n// ErrorResponse is used to send an error in a structured format.\ntype ErrorResponse struct {\n\tMessage string `json:\"message\"`\n}\n\n// executeRobotDeviceCommand handles HTTP requests to execute a command on a robot device.\n// It retrieves the robot and device names from the URL query parameters and checks if the device exists.\n// If the device exists, it executes the specified command on the device using the Gobot framework.\n// If an error occurs while retrieving the device, it writes the error message as a JSON response.\nfunc (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request) {\n\t// Parse the device command from the query parameters\n\tqueryParams := req.URL.Query()\n\tdeviceName := queryParams.Get(\"device\")\n\tcommand := queryParams.Get(\"command\")\n\n\tif deviceName == \"\" || command == \"\" {\n\t\t// Handle missing parameters\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tjson.NewEncoder(res).Encode(ErrorResponse{Message: \"Missing device or command parameters\"})\n\t\treturn\n\t}\n\n\t// Find the device in the gobot master\n\tvar device gobot.Device\n\tfor _, robot := range a.Gobot.Robots() {\n\t\tfor _, dev := range robot.Devices() {\n\t\t\tif dev.Name() == deviceName {\n\t\t\t\tdevice = dev\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif device != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif device == nil {\n\t\t// Handle device not found\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(ErrorResponse{Message: \"Device not found\"})\n\t\treturn\n\t}\n\n\t// Execute the command using a switch case or other appropriate logic\n\t// This is a placeholder and needs specific implementation based on actual commands and devices\n\tswitch command {\n\tcase \"start\":\n\t\t// Implement actual command execution logic, e.g., startDevice(device)\n\tcase \"stop\":\n\t\t// Implement actual command execution logic, e.g., stopDevice(device)\n\tdefault:\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t\tjson.NewEncoder(res).Encode(ErrorResponse{Message: \"Command not supported\"})\n\t\treturn\n\t}\n\n\t// Successful execution if no errors occur\n\tres.WriteHeader(http.StatusOK)\n\tjson.NewEncoder(res).Encode(map[string]string{\"status\": \"success\"})\n}", "CodeBleu_score": 42.68438245868176}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "import (\n    \"encoding/base64\"\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc BasicAuth(username, password string) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Define the expected Authorization header using the provided username and password\n        credentials := username + \":\" + password\n        encodedCredentials := base64.StdEncoding.EncodeToString([]byte(credentials))\n        expectedAuthorizationHeader := \"Basic \" + encodedCredentials\n\n        // Get the Authorization header from the request\n        authorizationHeader := r.Header.Get(\"Authorization\")\n\n        // Check if the Authorization header matches the expected header\n        if authorizationHeader != expectedAuthorizationHeader {\n            // If they do not match, set the WWW-Authenticate header and return a 401 Unauthorized status\n            w.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\", charset=\"UTF-8\"`)\n            http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n            return\n        }\n\n        // If the credentials match, proceed with the next handler function\n        // Print a success message to indicate credentials passed (in a real application, proceed with next handler)\n        fmt.Fprintf(w, \"Authentication successful\")\n    }\n}", "CodeBleu_score": 51.741056467999044}, {"code": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"net/http\"\n)\n\n// BasicAuth creates an HTTP handler function that implements basic authentication using\n// a specified username and password. It checks the Authorization header from incoming\n// requests and compares it with the expected value for the given credentials.\n// If the credentials do not match, it sets the WWW-Authenticate header and responds\n// with a 401 Unauthorized status.\nfunc BasicAuth(username, password string) http.HandlerFunc {\n\t// Prepare the correct authorization string\n\texpectedAuth := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Get the Authorization header from the request\n\t\tauth := r.Header.Get(\"Authorization\")\n\n\t\t// Check if the Authorization header matches the expected value\n\t\tif auth != expectedAuth {\n\t\t\t// If authentication fails, send a WWW-Authenticate header and a 401 Unauthorized status\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"restricted\"`)\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If authentication is successful, proceed with the request\n\t\tw.Write([]byte(\"Authentication successful. Access to resources granted.\"))\n\t}\n}\n\nfunc main() {\n\t// Setup a simple server\n\thttp.HandleFunc(\"/\", BasicAuth(\"admin\", \"password\"))\n\thttp.ListenAndServe(\":8080\", nil)\n}", "CodeBleu_score": 54.48853509994035}, {"code": "package main\n\nimport (\n    \"encoding/base64\"\n    \"net/http\"\n    \"strings\"\n)\n\n// BasicAuth creates an HTTP handler function that implements basic authentication using a specified username and password.\n// It compares the \"Authorization\" header from incoming requests with the expected value\n// based on the provided credentials. If comparison fails, it sets the \"WWW-Authenticate\" header\n// and responds with \"401 Unauthorized\" status and an error message.\n// If comparison succeeds, the request proceeds to the next handler.\nfunc BasicAuth(username, password string) http.HandlerFunc {\n    // Generate the correct basic authentication encoded string from the provided username and password\n    authValue := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\n    // The returned HTTP handler function\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Retrieve the Authorization header from the incoming request\n        authHeader := r.Header.Get(\"Authorization\")\n\n        // Compare the Authorization header to the expected credentials string\n        if authHeader != authValue {\n            // If the Authorization header does not match, respond with a 401 Unauthorized error\n            w.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n            http.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n            return\n        }\n\n        // If authentication succeeds, allow the next handler to run.\n        // Typically you would pass the next handler as a parameter to the BasicAuth function\n        // For the purpose of this example, the next handler is not defined, you could modify this\n        // function to take an additional handler parameter which represents the next handler.\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", BasicAuth(\"admin\", \"password\")(func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"Hello, you are authenticated!\"))\n    }))\n    http.ListenAndServe(\":8080\", nil)\n}", "CodeBleu_score": 54.04702340654672}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "package sensor\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n)\n\n// AnalogSensorDriver provides access and utility functions for an analog sensor.\ntype AnalogSensorDriver struct {\n\t// Assuming locks, current configuration and state as part of the struct\n\tsensorLock sync.Mutex\n\tsensorConfig SensorConfig\n\tlastRawValue int\n\tlastScaledValue float64\n}\n\n// SensorConfig represents the sensor's configuration regarding scaling.\ntype SensorConfig struct {\n\tScaleFactor float64\n\tIsConnected bool\n}\n\n// analogSensorRead reads the value from an analog sensor and returns the raw and scaled values. \n// It locks the sensor for reading, checks if the connection supports analog reading, and retrieves the raw sensor value.\n// It then scales the raw value according to the sensor's configuration, updates the last read values, and returns both the raw and scaled values,\n// or an error if the reading fails.\nfunc (a *AnalogSensorDriver) analogSensorRead() (int, float64, error) {\n\ta.sensorLock.Lock()\n\tdefer a.sensorLock.Unlock()\n\n\t// Check if the sensor is connected\n\tif !a.sensorConfig.IsConnected {\n\t\treturn 0, 0.0, fmt.Errorf(\"sensor is not connected\")\n\t}\n\n\t// Simulate sensor reading, here you should replace it with actual hardware read\n\trawValue := ReadHardwareSensor()\n\n\t// Scale the raw value\n\tscaleFactor := a.sensorConfig.ScaleFactor\n\tscaledValue := float64(rawValue) * scaleFactor\n\n\t// Update the last read values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}\n\n// ReadHardwareSensor is a mock function to simulate reading from hardware\nfunc ReadHardwareSensor() int {\n\t// In real implementation, you would add code to interface with hardware\n\t// Returning a mock sensor value\n\treturn 42\n}", "CodeBleu_score": 34.54810108263391}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error) {\n    // Step 1: Lock the sensor for reading\n    a.sensorLock.Lock()\n    defer a.sensorLock.Unlock()\n\n    // Step 2: Check if analog reading is supported\n    if !a.supportsAnalog {\n        return 0, 0.0, fmt.Errorf(\"analog reading not supported\")\n    }\n\n    // Step 3: Read the raw sensor value\n    rawValue, err := a.readRawValue()\n    if err != nil {\n        return 0, 0.0, fmt.Errorf(\"error reading from sensor: %v\", err)\n    }\n\n    // Step 4: Scale the raw value\n    scaledValue := float64(rawValue) * a.scaleFactor + a.offset\n\n    // Step 5: Update the last read values\n    a.lastRaw = rawValue\n    a.lastScaled = scaledValue\n\n    // Step 6: Return the both values (raw and scaled) and nil error if there were no errors\n    return rawValue, scaledValue, nil\n}\n\n// Assumed support functions\nfunc (a *AnalogSensorDriver) readRawValue() (int, error) {\n    // Simulating read operation\n    // This should be replaced with the actual sensor reading logic\n    return 123, nil // for example purposes\n}", "CodeBleu_score": 42.80492323260244}, {"code": "// AnalogSensorDriver is assumed to be a struct that handles the operations of an analog sensor.\n// Below would be an example implementation of such a struct and associated method based on the docstring provided.\n\npackage main\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\n// AnalogSensorDriver - a struct to handle analog sensor data reads including its current configuration.\ntype AnalogSensorDriver struct {\n\tisConnected     bool\n\tisAnalogCapable bool\n\tlastRawValue    int\n\tlastScaledValue float64\n\tscaleFactor     float64\n\tlock            chan bool\n}\n\n// analogSensorRead reads the value from an analog sensor and returns the raw and scaled values.\n// It locks the sensor for reading, checks if the connection supports analog reading, retrieves the raw sensor value,\n// scales the raw value according to the sensor's configuration, updates the last read values,\n// and returns both the raw and scaled values, or an error if the reading fails.\nfunc (a *AnalogSensorDriver) analogSensorRead() (int, float64, error) {\n\t// Locking the sensor to prevent concurrent reads\n\ta.lock <- true\n\tdefer func() { <-a.lock }()\n\n\tif !a.isConnected {\n\t\treturn 0, 0.0, errors.New(\"sensor not connected\")\n\t}\n\n\tif !a.isAnalogCapable {\n\t\treturn 0, 0.0, errors.New(\"sensor does not support analog reading\")\n\t}\n\n\t// Simulating sensor analog read function which should be implemented depending on the sensor and the library used for reading it.\n\trawValue, err := a.simulatedSensorRead()\n\tif err != nil {\n\t\treturn 0, 0.0, err\n\t}\n\n\t// Scale the raw value based on the sensor configuration\n\tscaledValue := a.scaleValue(rawValue)\n\n\t// Update last read values\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}\n\n// simulatedSensorRead simulates the reading from a sensor.\n// This should ideally be replaced with an actual function to read sensor values.\nfunc (a *AnalogSensorDriver) simulatedSensorRead() (int, error) {\n\t// Simulation here just returning a fixed value, in practice, this could be input from GPIO or an ADC read.\n\treturn 42, nil // Simulated value\n}\n\n// scaleValue scales an integer raw value using the configured scale factor.\nfunc (a *AnalogSensorDriver) scaleValue(rawValue int) float64 {\n\treturn float64(rawValue) * a.scaleFactor\n}\n\nfunc main() {\n\t// Sample usage\n\tdriver := AnalogSensorDriver{\n\t\tisConnected:     true,\n\t\tisAnalogCapable: true,\n\t\tscaleFactor:     0.05,\n\t\tlock:            make(chan bool, 1),\n\t}\n\n\traw, scaled, err := driver.analogSensorRead()\n\tif err != nil {\n\t\tprintln(\"Error reading sensor:\", err.Error())\n\t\treturn\n\t}\n\tprintln(\"Raw Value:\", raw, \"Scaled Value:\", scaled)\n}", "CodeBleu_score": 39.7228037272974}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver {\n    // Create a new instance of AnalogSensorDriver which is assumed to handle lower-level operations with an analog sensor.\n    sensorDriver := new(AnalogSensorDriver)\n    sensorDriver.Init(a, pin, opts...)\n    \n    // Create the GroveSoundSensorDriver with the initialized AnalogSensorDriver.\n    groveDriver := &GroveSoundSensorDriver{\n        AnalogSensorDriver: sensorDriver,\n        Name:               \"Grove Sound Sensor\",\n    }\n    \n    // Return the pointer to the newly created GroveSoundSensorDriver.\n    return groveDriver\n}", "CodeBleu_score": 31.921350176769046}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver {\n\t// Create a new instance of GroveSoundSensorDriver\n\tdriver := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: AnalogSensorDriver{\n\t\t\treader: a,\n\t\t\tpin:    pin,\n\t\t\topts:   opts,\n\t\t},\n\t\tName: \"Grove Sound Sensor\",\n\t}\n\t\n\t// Additional initializations can be done here if necessary\n\n\t// Return the pointer to the newly created GroveSoundSensorDriver\n\treturn driver\n}", "CodeBleu_score": 37.32934517353376}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\n    // Create an instance of the AnalogSensorDriver\n    sensorDriver := NewAnalogSensorDriver(a, pin, opts...)\n\n    // Initialize the GroveSoundSensorDriver with the sensorDriver instance\n    newGroveDriver := &GroveSoundSensorDriver{\n        AnalogSensorDriver: sensorDriver,\n        Name:               \"Grove Sound Sensor\",\n    }\n\n    // Return the pointer to the newly created GroveSoundSensorDriver\n    return newGroveDriver\n}", "CodeBleu_score": 32.79712211120277}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error {\n\t// Define the address of the CommandReg and the soft reset command\n\tconst CommandReg byte = 0x01\n\tconst softResetCommand byte = 0x0F\n\n\t// Write the soft reset command to the CommandReg\n\tif err := d.writeReg(CommandReg, softResetCommand); err != nil {\n\t\treturn fmt.Errorf(\"failed to write soft reset command: %w\", err)\n\t}\n\n\t// Wait for the device to initialize\n\ttime.Sleep(50 * time.Millisecond)\n\n\t// Read the CommandReg again to check if the reset is done\n\tstatus, err := d.readReg(CommandReg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read command register after reset: %w\", err)\n\t}\n\n\t// Check if the PowerDown bit (bit 4) is still set\n\tif (status & 0x10) != 0 {\n\t\treturn errors.New(\"soft reset failed, device still in power down mode\")\n\t}\n\n\treturn nil\n}\n\n// Assume the presence of `writeReg` and `readReg` helper methods to interact with hardware registers.\n// Example method signatures:\n// func (d *MFRC522Common) writeReg(regAddr byte, value byte) error\n// func (d *MFRC522Common) readReg(regAddr byte) (byte, error)", "CodeBleu_score": 55.062549716552944}, {"code": "func (d *MFRC522Common) softReset() error {\n    // Constant to define the soft reset command\n    const softResetCmd byte = 0x0F\n    // Register address for the CommandReg\n    const commandReg byte = 0x01\n    // Power-down bit in the command register\n    const powerDownBit byte = 0x10\n\n    // Initialization delay in milliseconds\n    const initDelay = 50\n\n    // Writing the soft reset command to the Command register\n    if err := d.writeRegister(commandReg, softResetCmd); err != nil {\n        return fmt.Errorf(\"writing soft reset command failed: %w\", err)\n    }\n\n    // Waiting for the specified initialization time\n    time.Sleep(initDelay * time.Millisecond)\n\n    // Reading the Command register to check the status\n    status, err := d.readRegister(commandReg)\n    if err != nil {\n        return fmt.Errorf(\"reading command register failed: %w\", err)\n    }\n\n    // Checking if the power-down bit is still set\n    if status&powerDownBit != 0 {\n        return errors.New(\"soft reset failed: device is still in power-down mode\")\n    }\n\n    // If successful, return nil indicating no errors\n    return nil\n}", "CodeBleu_score": 57.176501307591444}, {"code": "func (d *MFRC522Common) softReset() error {\n\t// Define command constants\n\tconst commandReg = 0x01\n\tconst softResetCommand = 0x0F\n\tconst powerDownBit = 0x10\n\tconst initializationTime = 50 * time.Millisecond\n\n\t// Write the soft reset command to the command register\n\terr := d.writeRegister(commandReg, softResetCommand)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to write soft reset command: %w\", err)\n\t}\n\n\t// Wait for the specified initialization time\n\ttime.Sleep(initializationTime)\n\n\t// Read the command register to check the status\n\tstatus, err := d.readRegister(commandReg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read command register after reset: %w\", err)\n\t}\n\n\t// Check for the power-down bit\n\tif status&powerDownBit != 0 {\n\t\treturn errors.New(\"initialization took too long, power-down bit is still set\")\n\t}\n\n\t// Return nil if everything is fine\n\treturn nil\n}", "CodeBleu_score": 53.70930363183945}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error) {\n    // Read the FIFO Length register to get number of bytes stored in FIFO buffer\n    fifoLevel, err := d.readFromRegister(FIFO_LEVEL_REG)\n    if err != nil {\n        return 0, fmt.Errorf(\"error reading FIFO level register: %w\", err)\n    }\n\n    // Check if the actual FIFO length matches the expected length in backData\n    if int(fifoLevel) != len(backData) {\n        return 0, fmt.Errorf(\"expected FIFO length %d bytes; found %d bytes\", len(backData), fifoLevel)\n    }\n\n    // Read bytes from FIFO and fill backData\n    for i := range backData {\n        byteValue, err := d.readFromRegister(FIFO_DATA_REG)\n        if err != nil {\n            return 0, fmt.Errorf(\"error reading from FIFO: %w\", err)\n        }\n        backData[i] = byteValue\n    }\n\n    // Read the control register to get the last bits received\n    lastBits, err := d.readFromRegister(CONTROL_REG)\n    if err != nil {\n        return 0, fmt.Errorf(\"error reading control register: %w\", err)\n    }\n\n    // Get only the relevant bits for last bits received\n    mask := uint8(0x07) // assuming last bits are stored in the three LSBs of the control register\n    lastBitsReceived := lastBits & mask\n\n    return lastBitsReceived, nil\n}\n\n// Auxiliary functions assumed:\n// This readFromRegister method must be implemented for actual register read operations\nfunc (d *MFRC522Common) readFromRegister(regAddress byte) (byte, error) {\n    // This function should handle the communication to read a single byte from a register of the MFRC522\n    // Error handling and actual communication details are implementation-specific\n    return 0, nil\n}", "CodeBleu_score": 43.855190868550444}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error) {\n    // Check the number of bytes available in the FIFO buffer.\n    numBytesInFIFO, err := d.readRegister(FIFOLevelReg)\n    if err != nil {\n        return 0, fmt.Errorf(\"error reading FIFO level: %v\", err)\n    }\n\n    // Convert the count to a uint8 and compare it to the length of the byte slice.\n    if int(numBytesInFIFO) != len(backData) {\n        return 0, fmt.Errorf(\"mismatch in FIFO bytes and the length of the provided slice: %d available vs %d expected\", numBytesInFIFO, len(backData))\n    }\n\n    // Read each byte from the FIFO into the byte slice.\n    for i := 0; i < len(backData); i++ {\n        byteValue, err := d.readRegister(FIFODataReg)\n        if err != nil {\n            return 0, fmt.Errorf(\"error reading from FIFO data register at index %d: %v\", i, err)\n        }\n        backData[i] = byteValue\n    }\n\n    // Read the control register to understand the last bits received.\n    controlBits, err := d.readRegister(ControlReg)\n    if err != nil {\n        return 0, fmt.Errorf(\"error reading control register: %v\", err)\n    }\n\n    // Assuming ControlReg provides the last bits in lower nibble (bottom 4 bits).\n    lastBits := controlBits & 0x0F\n\n    return lastBits, nil\n}", "CodeBleu_score": 53.37874979445753}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error) {\n    // Check the number of bytes available in FIFO\n    availableBytes, err := d.getFIFODataCount()\n    if err != nil {\n        return 0, fmt.Errorf(\"error getting FIFO data count: %w\", err)\n    }\n\n    // Compare available bytes with expected length\n    if availableBytes != len(backData) {\n        return 0, fmt.Errorf(\"FIFO length mismatch: expected %d bytes, got %d bytes\", len(backData), availableBytes)\n    }\n\n    // Read bytes from FIFO into backData slice\n    for i := range backData {\n        if byteValue, err := d.readByteFromFIFO(); err != nil {\n            return 0, fmt.Errorf(\"error reading byte from FIFO: %w\", err)\n        } else {\n            backData[i] = byteValue\n        }\n    }\n\n    // Read control register to get last bits received\n    lastBits, err := d.readControlRegister()\n    if err != nil {\n        return 0, fmt.Errorf(\"error reading control register: %w\", err)\n    }\n\n    return lastBits, nil\n}\n\n// Assume implementation for getFIFODataCount\nfunc (d *MFRC522Common) getFIFODataCount() (int, error) {\n    // This should communicate with the device to get the FIFO count\n    return someAPI.GetFifoLength(), nil\n}\n\n// Assume implementation for readByteFromFIFO\nfunc (d *MFRC522Common) readByteFromFIFO() (byte, error) {\n    // This should read a single byte from FIFO\n    return someAPI.ReadFifoByte(), nil\n}\n\n// Assume implementation for readControlRegister\nfunc (d *MFRC522Common) readControlRegister() (uint8, error) {\n    // This should read the control register\n    return someAPI.ReadControlRegister(), nil\n}", "CodeBleu_score": 42.08580735328301}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error {\n    // Log debug message if debug is enabled\n    if d.debug {\n        log.Println(\"Halting PICC communication.\")\n    }\n\n    // Define the halt command\n    haltCommand := []byte{0x50, 0x00}  // HALT command, usually 0x50 followed by 0x00\n\n    // Calculate CRC for the halt command\n    crc, err := d.CalculateCRC(haltCommand)\n    if err != nil {\n        return fmt.Errorf(\"error calculating CRC: %w\", err)\n    }\n\n    // Append CRC to the command\n    haltCommandWithCRC := append(haltCommand, crc...)\n\n    // Send the halt command to the PICC\n    err = d.SendCommand(haltCommandWithCRC)\n    if err != nil {\n        return fmt.Errorf(\"error sending halt command: %w\", err)\n    }\n\n    // Generally, an error response that the card is halted signifies success\n    errorReceived, err := d.VerifyHalting()\n    if err != nil {\n        return fmt.Errorf(\"error verifying halting: %w\", err)\n    }\n    if !errorReceived {\n        return fmt.Errorf(\"expected error response indicating successful halting, but none was received\")\n    }\n\n    return nil\n}", "CodeBleu_score": 49.793292532864754}, {"code": "func (d *MFRC522Common) piccHalt() error {\n    // Check if debugging is enabled and log a message\n    if d.debug {\n        log.Println(\"Halting communication with PICC\")\n    }\n\n    // Define the halt command according to ISO/IEC 14443\n    haltCommand := []byte{0x50, 0x00} // HALT command is 0x50 followed by 0x00\n\n    // Calculate CRC for the halt command\n    crcResult := d.calculateCRC(haltCommand) // Assuming d has a method calculateCRC that takes a byte slice and returns a CRC\n\n    // Append the CRC result to the halt command\n    haltCommand = append(haltCommand, crcResult...)\n\n    // Send the command to the PICC\n    err := d.sendToPICC(haltCommand) // Assuming d has a method sendToPICC that takes a byte slice and returns an error if applicable\n    if err != nil {\n        // Normally, we expect an error indicating that halting was successful as the card will not respond to the command\n        log.Println(\"Error sending halt command to PICC:\", err)\n        return err\n    }\n\n    // If no error, or a specific error indicating success, return nil\n    return nil\n}", "CodeBleu_score": 45.419421900818215}, {"code": "func (d *MFRC522Common) piccHalt() error {\n    // Log a debug message if debugging is enabled\n    if d.isDebug {\n        d.logger.Println(\"Halting communication with PICC\")\n    }\n\n    // Define the command to halt\n    haltCommand := []byte{0x50, 0x00} // HLTA command and parameter as specified in ISO 14443-3\n\n    // Calculate CRC for the halt command\n    crc, err := d.calculateCRC(haltCommand)\n    if err != nil {\n        return fmt.Errorf(\"failed to calculate CRC: %v\", err)\n    }\n\n    // Append CRC to the command\n    haltCommandWithCRC := append(haltCommand, crc...)\n\n    // Send the command to the PICC\n    err = d.sendCommand(haltCommandWithCRC)\n    if err != nil {\n        return fmt.Errorf(\"failed to send halt command: %v\", err)\n    }\n\n    // Verify error status to ensure command was taken as expected\n    // Reading error, as after HALT command PICC should not respond and should go to HALT state\n    if d.isError() {\n        return nil // Expected no response, hence treated as a success\n    } else {\n        return fmt.Errorf(\"PICC did not halt as expected\")\n    }\n}", "CodeBleu_score": 46.84746845350393}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "package rfid\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Assume MFRC522Common has necessary hardware IO functions and state handling.\ntype MFRC522Common struct {\n    spiDevice SPIInterface // Hypothetical interface to handle SPI communication\n}\n\nfunc (d *MFRC522Common) piccRead(block uint8) ([]byte, error) {\n\t// Command for PICC_READ.\n\tconst piccReadCommand = 0x30\n\tcommand := []byte{piccReadCommand, block}\n\n\t// Calculate CRC for the command. Let's assume 'calculateCRC' is a defined method on the device.\n\tcrc, err := d.calculateCRC(command)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error calculating CRC: %w\", err)\n\t}\n\n\t// Append CRC to the command.\n\tcommandWithCRC := append(command, crc...)\n\n\t// Send command to the RFID card using a hypothetical send function.\n\t// Assume sendCommand handles the complete transaction including any necessary wait time.\n\tresponse, err := d.sendCommand(commandWithCRC)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error sending command to the RFID card: %w\", err)\n\t}\n\n\t// Assume response includes status byte and back data, check if status byte indicates a success.\n\t// This is hypothetical; actual response handling will depend on the RFID system's specifics.\n\tif response[0] != 0x00 {\n\t\treturn nil, errors.New(\"RFID read error\")\n\t}\n\n\t// Extract actual data block.\n\tdataBlock := response[1:] // Assuming the first byte is status and the rest is data.\n\n\t// Return the data block, assuming it should not exceed 16 bytes.\n\tif len(dataBlock) > 16 {\n\t\treturn nil, errors.New(\"data block length error\")\n\t}\n\n\treturn dataBlock, nil\n}\n\n// Hypothetical SPI interface definition, handling low-level communication specifics.\ntype SPIInterface interface {\n\tWrite(data []byte) ([]byte, error)\n}\n\n// Add below mentioned functions here for completeness, e.g., calculateCRC, sendCommand.", "CodeBleu_score": 40.89928289863352}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error) {\n    // The MFRC522's command codes\n    const piccCmdRead = 0x30\n\n    // Frame the read command with the block address\n    command := []byte{piccCmdRead, block}\n\n    // Calculate the CRC for the command\n    crc, err := d.calculateCRC(command)\n    if err != nil {\n        return nil, fmt.Errorf(\"error calculating CRC: %w\", err)\n    }\n\n    // Append the CRC to the command\n    command = append(command, crc...)\n\n    // Communicate with the card using the command\n    results, err := d.transmit(command)\n    if err != nil {\n        return nil, fmt.Errorf(\"transmit error: %w\", err)\n    }\n\n    // Results typically contains status flag, data (16 bytes) and CRC\n    status := results[0]\n    if status != 0x00 {\n        return nil, fmt.Errorf(\"RFID read error: status %x\", status)\n    }\n\n    // The data should only be 16 bytes if everything is correct, excluding status byte and CRC bytes\n    dataBytes := results[1 : len(results)-2] // Skipping the status byte and CRC at the end\n    return dataBytes, nil\n}", "CodeBleu_score": 46.94500730879941}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error) {\n    // Construct the read command for the MFRC522 RFID reader\n    // Command format for PICC_READ: 0x30 (PICC_READ command code), block address, CRC_A\n    cmd := []byte{0x30, block}\n\n    // Calculate CRC_A for the command\n    crc, err := d.calculateCRC(cmd)\n    if err != nil {\n        return nil, fmt.Errorf(\"error calculating CRC: %v\", err)\n    }\n\n    // Append CRC to the command\n    cmd = append(cmd, crc...)\n\n    // Send command to RFID card\n    response, err := d.transmitToPICC(cmd)\n    if err != nil {\n        return nil, fmt.Errorf(\"error transmitting to PICC: %v\", err)\n    }\n\n    // Check if the response is valid (minimum of 16 bytes data + 2 bytes CRC)\n    if len(response) < 18 {\n        return nil, fmt.Errorf(\"invalid response length: expected at least 18 bytes, got %d\", len(response))\n    }\n\n    // Verify CRC on the received data\n    expectedCRC, err := d.calculateCRC(response[:16])\n    if err != nil {\n        return nil, fmt.Errorf(\"error calculating CRC on response: %v\", err)\n    }\n\n    if !bytes.Equal(response[16:18], expectedCRC) {\n        return nil, fmt.Errorf(\"CRC mismatch: expected %x, got %x\", expectedCRC, response[16:18])\n    }\n\n    // Return the data block excluding the CRC\n    return response[:16], nil\n}", "CodeBleu_score": 42.98386572223338}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error {\n    // Check if the answer buffer has sufficient space.\n    if len(answer) < 2 {\n        return fmt.Errorf(\"answer buffer must have at least 2 bytes\")\n    }\n\n    // Clear relevant bits in the collision register.\n    // Assuming presence of a method `clearCollisionBits()` for this purpose.\n    d.clearCollisionBits()\n\n    // Conditionally adjust transmission settings for certain request modes.\n    switch reqMode {\n    case 0x26, 0x52: // Assuming these modes require specific bit handling.\n        if err := d.setTransmissionBits(7); err != nil {\n            return fmt.Errorf(\"failed to set transmission bits: %v\", err)\n        }\n    default:\n        if err := d.setTransmissionBits(8); err != nil {\n            return fmt.Errorf(\"failed to set transmission default bits: %v\", err)\n        }\n    }\n\n    // Communicate with the PICC using the transceive command.\n    // Assuming presence of a method `transceive()` to handle communication.\n    transceiveError := d.transceive(reqMode, answer)\n    if transceiveError != nil {\n        return fmt.Errorf(\"transceive failed: %v\", transceiveError)\n    }\n\n    // Assuming no errors were encountered, return nil indicating success.\n    return nil\n}", "CodeBleu_score": 57.81747440316387}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error {\n\t// Ensures the answer buffer has at least 2 bytes.\n\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer too small\")\n\t}\n\n\t// Clear specific bits in the collision register - assume CollisionReg is a symbolic constant\n\t// and clearCollisionBits is a bitmask defined earlier for which bits to clear.\n\terr := d.clearRegisterBitMask(CollisionReg, clearCollisionBits)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to clear collision bits: %w\", err)\n\t}\n\n\t// Set transmission size: if reqMode is for example 0x26 (RequestA), use only 7 bits of the last byte.\n\tif reqMode == RequestA {\n\t\terr = d.writeRegister(BitFramingReg, 0x07) // 0x07 to transmit only the last 7 bits\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to set bit framing: %w\", err)\n\t}\n\n\t// Send the command using transceive.\n\tcmd := []byte{reqMode}\n\terr, backData, backLen := d.transceive(cmd, answer, len(answer))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"transceive error: %w\", err)\n\t}\n\n\t// Assuming valid data should be at least 2 bytes to consider as a correct response.\n\tif backLen < 2 {\n\t\treturn errors.New(\"received data too short\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 52.72059266845667}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error {\n    // Ensure there's enough space in the answer buffer.\n    if len(answer) < 2 {\n        return fmt.Errorf(\"answer buffer is too small\")\n    }\n    \n    // Clear relevant bits in the collision register.\n    collisionReg := 0x0A // Assuming 0x0A is the collision register address, you might need to adjust this value.\n    if err := d.clearRegisterBits(collisionReg, 0x80); err != nil { // Assuming 0x80 might be the bit mask, adjust as necessary.\n        return fmt.Errorf(\"failed to clear collision bits: %w\", err)\n    }\n\n    // Set up the communication frame depending on the request mode.\n    frame := []byte{reqMode}\n    txLastBits := uint8(0)\n    if reqMode == SomeReqModeConstant { // Assuming there is a const defining some specific reqMode\n        txLastBits = 7 // If the request mode requires, only the last 7 bits of the last byte should be transmitted.\n    }\n\n    // Communicate with the PICC\n    err := d.transceive(frame, answer, txLastBits)\n    if err != nil {\n        return fmt.Errorf(\"transceive failed: %w\", err)\n    }\n\n    return nil\n}", "CodeBleu_score": 49.86428792012698}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "import (\n\t\"time\"\n)\n\n// onePinStepping performs a single step operation for an EasyDriver stepper motor controller.\n// It locks the valueMutex to ensure thread safety while accessing shared variables.\n// The function then triggers a valid step by setting the step pin low, waiting for a delay, and setting the step pin high.\n// Depending on the direction, it increments or decrements the step number.\n// The function returns any error encountered during the digital write operations.\nfunc (d *EasyDriver) onePinStepping() error {\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Set the step pin low\n\tif err := d.setPinLow(d.StepPin); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the required step delay\n\ttime.Sleep(d.StepDelay)\n\n\t// Set the step pin high\n\tif err := d.setPinHigh(d.StepPin); err != nil {\n\t\treturn err\n\t}\n\n\t// Depending on the direction of the stepper, increment or decrement the current step count\n\tif d.Direction == \"forward\" {\n\t\td.CurrentStep++\n\t} else {\n\t\td.CurrentStep--\n\t}\n\n\treturn nil\n}\n\n// Helper functions to interact with GPIO pins (assuming they are part of the EasyDriver struct methods)\nfunc (d *EasyDriver) setPinLow(pin int) error {\n\t// Implement the hardware-specific function to set a pin low (abstracted for illustration)\n\treturn nil\n}\n\nfunc (d *EasyDriver) setPinHigh(pin int) error {\n\t// Implement the hardware-specific function to set a pin high (abstracted for illustration)\n\treturn nil\n}", "CodeBleu_score": 60.59282344824387}, {"code": "import (\n\t\"sync\"\n\t\"time\"\n)\n\n// EasyDriver represents the stepper motor controller\ntype EasyDriver struct {\n\tstepPin    int           // GPIO pin connected to the Step on the driver\n\tdirection  bool          // True if direction is forward, false if backward\n\tstepNumber int           // Count of steps taken\n\tvalueMutex *sync.Mutex   // Mutex to lock when changing critical shared variables\n}\n\n// onePinStepping performs a single step operation for an EasyDriver stepper motor controller.\nfunc (d *EasyDriver) onePinStepping() error {\n\t// Lock the mutex to ensure thread safety\n\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a step by setting the step pin low\n\tif err := digitalWrite(d.stepPin, LOW); err != nil {\n\t\treturn err\n\t}\n\t// Wait for a specified delay (e.g., 1 millisecond)\n\ttime.Sleep(1 * time.Millisecond)\n\n\t// Set the step pin high to complete the step\n\tif err := digitalWrite(d.stepPin, HIGH); err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number depending on the direction\n\tif d.direction {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n\n// digitalWrite is a placeholder function to simulate writing a value to a GPIO pin.\n// This function should be replaced with actual GPIO manipulation functions.\nfunc digitalWrite(pin int, value int) error {\n\t// Logic to set the pin's value\n\t// (This should interact with actual GPIO controls on your hardware platform)\n\treturn nil\n}\n\nconst (\n\tLOW  = 0 // LOW value for digital output\n\tHIGH = 1 // HIGH value for digital output\n)", "CodeBleu_score": 54.4832870294638}, {"code": "// Here's how the function could be completed:\nfunc (d *EasyDriver) onePinStepping() error {\n    // Lock the mutex before accessing or modifying the shared variables.\n    d.valueMutex.Lock()\n    defer d.valueMutex.Unlock()\n\n    // Set the step pin low.\n    if err := d.digitalWrite(d.stepPin, LOW); err != nil {\n        return fmt.Errorf(\"error setting step pin low: %w\", err)\n    }\n\n    // Wait for the step delay.\n    time.Sleep(d.stepDelay)\n\n    // Set the step pin high to complete the step.\n    if err := d.digitalWrite(d.stepPin, HIGH); err != nil {\n        return fmt.Errorf(\"error setting step pin high: %w\", err)\n    }\n\n    // Based on the direction, increment or decrement the step count.\n    if d.direction == FORWARD {\n        d.currentStep++\n    } else {\n        d.currentStep--\n    }\n\n    return nil\n}", "CodeBleu_score": 60.603934407077695}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "import (\n    \"errors\"\n    \"sync\"\n    \"time\"\n    \"log\"\n)\n\n// HCSR04Driver represents a driver for an HCSR04 ultrasonic sensor.\ntype HCSR04Driver struct {\n    running    bool           // Indicates if the monitoring is currently running\n    mutex      sync.Mutex     // Mutex to secure access to the start/stop processes\n    stopChan   chan struct{}  // Channel used to signal stopping of the monitoring\n    wg         sync.WaitGroup // WaitGroup to manage goroutines\n}\n\n// StartDistanceMonitor initiates continuous distance monitoring.\nfunc (d *HCSR04Driver) StartDistanceMonitor() error {\n    d.mutex.Lock()\n    defer d.mutex.Unlock()\n\n    // Check if monitoring is already running\n    if d.running {\n        return errors.New(\"distance monitor is already running\")\n    }\n\n    // Start the monitoring by setting up a channel for stop signal and marking it as running\n    d.stopChan = make(chan struct{})\n    d.wg.Add(1) // Add a goroutine to the WaitGroup\n    d.running = true\n\n    go func() {\n        defer d.wg.Done()\n        timer := time.NewTicker(time.Second)\n        defer timer.Stop()\n\n        for {\n            select {\n            case <-d.stopChan:\n                return\n            case <-timer.C:\n                distance, err := d.MeasureDistance()\n                if err != nil {\n                    log.Printf(\"Error measuring distance: %v\", err)\n                    continue\n                }\n                log.Printf(\"Measured distance: %v cm\", distance)\n            }\n        }\n    }()\n    \n    return nil\n}\n\n// MeasureDistance simulates a distance measurement, this should be replaced by actual HCSR04 reading logic.\nfunc (d *HCSR04Driver) MeasureDistance() (float64, error) {\n    // Simulation logic, replace with actual implementation as needed.\n    return 100.0, nil // Simulated distance reading.\n}", "CodeBleu_score": 41.99767658686505}, {"code": "// Assuming some context with necessary imports and package declarations.\n// Also assuming struct `HCSR04Driver` and required dependencies, like logger, etc., have been defined elsewhere.\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\n// HCSR04Driver is a driver for an HC-SR04 ultrasonic sensor.\ntype HCSR04Driver struct {\n\tmutex sync.Mutex\n\trunning bool\n\tstopChan chan bool\n\twg sync.WaitGroup\n}\n\n// StartDistanceMonitor initiates continuous distance monitoring for an HCSR04 ultrasonic sensor.\nfunc (d *HCSR04Driver) StartDistanceMonitor() error {\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Check if a monitoring process is already running\n\tif d.running {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\t// Initialize the stop channel and set monitoring status\n\td.stopChan = make(chan bool)\n\td.running = true\n\n\td.wg.Add(1)\n\tgo func() {\n\t\tdefer d.wg.Done()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\t// Assuming logging method is previously defined\n\t\t\t\t\tlog.Printf(\"error measuring distance: %v\", err)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"measured distance: %v cm\", distance)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 500) // Interval of 500ms between measurements\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n// MeasureDistance simulates distance measurement process, must be implemented.\nfunc (d *HCSR04Driver) MeasureDistance() (float64, error) {\n\t// Dummy implementation. Replace with actual measurement logic\n\treturn 0, nil\n}", "CodeBleu_score": 39.225946355327125}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error {\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Check if the distance monitor is already running\n\tif d.isMonitoring {\n\t\treturn fmt.Errorf(\"distance monitor is already running\")\n\t}\n\n\t// Create a stop channel and prepare for monitoring\n\td.stopChan = make(chan struct{})\n\td.isMonitoring = true\n\n\t// Start the goroutine for monitoring\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.stopChan:\n\t\t\t\td.isMonitoring = false\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\t// Execute the distance sensing code\n\t\t\t\tdistance, err := d.MeasureDistance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error measuring distance: %s\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Process the measured distance\n\t\t\t\tfmt.Printf(\"Measured distance: %d cm\\n\", distance)\n\t\t\t\t\n\t\t\t\t// Sleep for a fixed interval before the next measurement\n\t\t\t\ttime.Sleep(500 * time.Millisecond) // Adjust interval as required\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}", "CodeBleu_score": 46.613100167573975}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\ntype HCSR04Driver struct {\n    pulseStart  int64\n    pulseEnd    int64\n    durationChan chan time.Duration\n}\n\n// createEventHandler generates an event handler to measure the duration of an ultrasonic pulse. \n// It initializes the variable pulseStart to track the start timestamp of the pulse.\n// When a rising edge event is detected, it records the timestamp.\n// When a falling edge event is detected, it calculates the duration of the pulse,\n// sends this duration to a channel, and resets the start timestamp.\nfunc (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32) {\n    return func(id int, timestamp time.Duration, eventType string, pinNum uint32, pinState uint32) {\n        switch eventType {\n        case \"rise\":\n            d.pulseStart = timestamp.Nanoseconds() // Assuming timestamp provides a time.Duration, we convert it to nanoseconds.\n        case \"fall\":\n            if d.pulseStart != 0 {\n                d.pulseEnd = timestamp.Nanoseconds()\n                duration := time.Duration(d.pulseEnd - d.pulseStart)\n                d.durationChan <- duration // send duration to the channel\n                d.pulseStart = 0 // Reset the start timestamp\n            }\n        }\n    }\n}\n\nfunc main() {\n    durationChan := make(chan time.Duration, 1)\n    driver := HCSR04Driver{\n        pulseStart:  0,\n        pulseEnd:    0,\n        durationChan: durationChan,\n    }\n    \n    handler := driver.createEventHandler()\n    // Simulate a rising edge event\n    handler(1, time.Duration(500)*time.Millisecond, \"rise\", 23, 1)\n    // Simulate a falling edge event\n    handler(1, time.Duration(502)*time.Millisecond, \"fall\", 23, 0)\n    \n    // Read the duration from the channel\n    duration := <-durationChan\n    fmt.Printf(\"Duration of the pulse: %v\\n\", duration)\n}", "CodeBleu_score": 35.28370187261656}, {"code": "package main\n\nimport (\n\t\"time\"\n)\n\n// HCSR04Driver models a driver for the HC-SR04 ultrasonic sensor.\ntype HCSR04Driver struct {\n\tdurationChan chan time.Duration // Channel to send pulse duration\n}\n\n// createEventHandler returns a closure that handles GPIO pin change events and computes the pulse duration.\nfunc (d *HCSR04Driver) createEventHandler() func(edgeType int, timeStamp time.Duration, pinName string, valueBefore uint32, valueAfter uint32) {\n\tvar start time.Duration // to track the start timestamp of the pulse\n\n\treturn func(edgeType int, timeStamp time.Duration, pinName string, valueBefore uint32, valueAfter uint32) {\n\t\tif edgeType == 1 { // Assuming 1 represents a rising edge\n\t\t\tstart = timeStamp // Record the timestamp at rising edge\n\t\t} else if edgeType == 0 { // Assuming 0 represents a falling edge\n\t\t\tif start != 0 { // Ensure start has been set\n\t\t\t\tduration := timeStamp - start // Calculate the pulse duration\n\t\t\t\td.durationChan <- duration   // Send the duration to the channel\n\t\t\t\tstart = 0                    // Reset start timestamp\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 41.66711882800325}, {"code": "package main\n\nimport (\n    \"time\"\n)\n\ntype HCSR04Driver struct {\n    pulseStart time.Time\n    durationChan chan time.Duration\n}\n\n// createEventHandler returns a closure that handles pulse start and end events for the HCSR04 sensor.\nfunc (d *HCSR04Driver) createEventHandler() func(edgeType int, timestamp time.Time) {  \n    return func(edgeType int, timestamp time.Time) {\n        // Check if edgeType corresponds to rising edge\n        if edgeType == 1 {  // assuming 1 represents a rising edge\n            // Record the start time of the pulse\n            d.pulseStart = timestamp\n        } else if edgeType == 0 {  // assuming 0 represents a falling edge\n            // Calculate pulse duration only if start time is non-zero (to avoid incorrect calculation when start was not set)\n            if !d.pulseStart.IsZero() {\n                // Calculate duration\n                duration := timestamp.Sub(d.pulseStart)\n                // Send the calculated duration to the duration channel\n                d.durationChan <- duration\n                // Reset the pulse start time\n                d.pulseStart = time.Time{}  // Resetting to zero value\n            }\n        }\n    }\n}", "CodeBleu_score": 36.330416110445086}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "import (\n\t\"errors\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype HCSR04Driver struct {\n\ttriggerPin, echoPin uint\n\tmutex                sync.Mutex\n}\n\n// Timeout for waiting for echo pulse\nconst measurementTimeout = 1 * time.Second\n\nfunc (d *HCSR04Driver) measureDistance() error {\n\t// Lock the mutex to ensure exclusive access to the sensor\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the sensor by sending a high pulse to the trigger pin\n\tpinHigh(d.triggerPin)\n\ttime.Sleep(10 * time.Microsecond) // 10 microsecond pulse to trigger\n\tpinLow(d.triggerPin)\n\n\t// Wait for the echo response\n\tstartTime := time.Now()\n\tfor pinRead(d.echoPin) == 0 {\n\t\tif time.Since(startTime) >= measurementTimeout {\n\t\t\treturn errors.New(\"timeout waiting for high signal on echo pin\")\n\t\t}\n\t}\n\n\t// Measure how long the echo pin stays high, indicating distance\n\tstart := time.Now()\n\tfor pinRead(d.echoPin) != 0 {\n\t\tif time.Since(startTime) >= measurementTimeout {\n\t\t\treturn errors.New(\"timeout waiting for low signal on echo pin\")\n\t\t}\n\t}\n\telapsed := time.Since(start)\n\n\t// Calculate and print the duration for which the echo pin was high\n\tmeasuredTime := elapsed.Microseconds()\n\td.processMeasurement(measuredTime)\n\n\treturn nil\n}\n\nfunc pinHigh(pin uint) {\n\t// This would be a simple mock placeholder to set the GPIO pin high\n}\n\nfunc pinLow(pin uint) {\n\t// This would be a simple mock placeholder to set the GPIO pin low\n}\n\nfunc pinRead(pin uint) int {\n\t// Read the GPIO pin status, returning 1 if high and 0 if low\n\t// Mock implementation, should be replaced with actual GPIO read code\n\treturn 1 // Just for illustrative purposes\n}\n\nfunc (d *HCSR04Driver) processMeasurement(measuredTime int64) {\n\t// Calculate distance or store the time, whatever is needed\n}", "CodeBleu_score": 42.42299645879667}, {"code": "package main\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\n// HCSR04Driver represents the HCSR04 sensor connected to specific GPIO pins.\ntype HCSR04Driver struct {\n\ttriggerPin uint\n\techoPin    uint\n\tmutex      chan bool\n\ttimeout    time.Duration\n}\n\n// NewHCSR04Driver creates a new instance of HCSR04Driver.\nfunc NewHCSR04Driver(triggerPin uint, echoPin uint, timeout time.Duration) *HCSR04Driver {\n\treturn &HCSR04Driver{\n\t\ttriggerPin: triggerPin,\n\t\techoPin:    echoPin,\n\t\tmutex:      make(chan bool, 1),\n\t\ttimeout:    timeout,\n\t}\n}\n\n// measureDistance measures the distance using the HCSR04 sensor.\n// It locks the measurement mutex, triggers the sensor, waits for the measurement to complete,\n// handles timeout, and unlocks the mutex.\nfunc (d *HCSR04Driver) measureDistance() error {\n\td.mutex <- true // Lock the mutex\n\tdefer func() {\n\t\t<-d.mutex // Unlock the mutex after processing\n\t}()\n\n\t// Trigger the sensor\n\terr := d.triggerSensor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for echo or timeout\n\tduration, err := d.waitForEcho()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Calculate the distance based on time of flight\n\tdistance := d.calculateDistance(duration)\n\t\n\t// Print or handle the distance value\n\tprintln(\"Measured Distance:\", distance, \"cm\")\n\n\treturn nil\n}\n\nfunc (d *HCSR04Driver) triggerSensor() error {\n\t// Assuming a function/library to write to GPIO pin is available\n\tif err := writeToGPIOPin(d.triggerPin, true); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(10 * time.Microsecond) // Send a 10 \u00b5s pulse\n\treturn writeToGPIOPin(d.triggerPin, false)\n}\n\nfunc (d *HCSR04Driver) waitForEcho() (time.Duration, error) {\n\tstartTime := time.Now()\n\tfor {\n\t\t// Handle timeout\n\t\tif time.Since(startTime) > d.timeout {\n\t\t\treturn 0, errors.New(\"timeout reached waiting for echo\")\n\t\t}\n\t\t// Assuming a function/library to read GPIO pin is available\n\t\tif echo, _ := readFromGPIOPin(d.echoPin); echo {\n\t\t\treturn time.Since(startTime), nil\n\t\t}\n\t}\n}\n\nfunc (d *HCSR04Driver) calculateDistance(duration time.Duration) float64 {\n\t// Speed of sound in air in cm/\u00b5s is approximately 0.0343\n\tspeedOfSoundCmPerUs := 0.0343\n\t// Return the distance (round-trip, hence the division by 2)\n\treturn float64(duration.Nanoseconds()/1000) * speedOfSoundCmPerUs / 2\n}\n\n// Mock/placeholder functions for GPIO functionalities, to be implemented based on specific platform\nfunc writeToGPIOPin(pin uint, high bool) error {\n\t// Interact with hardware or a GPIO library\n\treturn nil\n}\n\nfunc readFromGPIOPin(pin uint) (bool, error) {\n\t// Read from hardware GPIO pin\n\treturn false, nil // Placeholder\n}\n\nfunc main() {\n\t// Example usage\n\tdriver := NewHCSR04Driver(5, 6, 3*time.Second)\n\tif err := driver.measureDistance(); err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t}\n}", "CodeBleu_score": 41.81149986048759}, {"code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// HCSR04Driver represents a driver for managing the HCSR04 sensor.\ntype HCSR04Driver struct {\n\ttriggerPin uint\n\techoPin    uint\n\tmutex      sync.Mutex\n}\n\n// measureDistance measures the distance using the HCSR04 sensor.\nfunc (d *HCSR04Driver) measureDistance() error {\n\td.mutex.Lock()\n\tdefer d.mutex.Unlock() // Ensure the mutex is unlocked after measurement or in case of error.\n\n\t// Trigger the sensor by setting the trigger pin high for 10\u00b5s.\n\terr := gpioWrite(d.triggerPin, true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to trigger sensor: %v\", err)\n\t}\n\ttime.Sleep(time.Microsecond * 10)\n\tif err := gpioWrite(d.triggerPin, false); err != nil {\n\t\treturn fmt.Errorf(\"failed to reset trigger: %v\", err)\n\t}\n\n\t// Wait for echo\n\techoStart := time.Now()\n\tfor {\n\t\tread, err := gpioRead(d.echoPin)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error reading echo pin: %v\", err)\n\t\t}\n\t\tif read {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(echoStart) > time.Millisecond*100 { // Timeout of 100ms\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo pin to be high\")\n\t\t}\n\t}\n\n\tstart := time.Now()\n\tfor {\n\t\tread, err := gpioRead(d.echoPin)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error reading echo pin: %v\", err)\n\t\t}\n\t\tif !read {\n\t\t\tbreak\n\t\t}\n\t\tif time.Since(start) > time.Millisecond*100 { // Timeout of 100ms\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo pin to go low\")\n\t\t}\n\t}\n\n\tduration := time.Since(start)\n\tdistance := (duration.Seconds() * 34300) / 2 // Speed of sound in air 343 m/s.\n\tfmt.Printf(\"Measured distance: %.2f cm\\n\", distance)\n\n\treturn nil\n}\n\n// stub functions to simulate gpio operations\nfunc gpioWrite(pin uint, state bool) error {\n\t// simulate writing to a GPIO pin\n\treturn nil\n}\n\nfunc gpioRead(pin uint) (bool, error) {\n\t// simulate reading from a GPIO pin, assuming returning true immediately.\n\treturn true, nil\n}\n\n// Example main function to show the usage of HCSR04Driver.\nfunc main() {\n\tdriver := HCSR04Driver{triggerPin: 1, echoPin: 2}\n\tif err := driver.measureDistance(); err != nil {\n\t\tfmt.Println(\"Error measuring distance:\", err)\n\t}\n}", "CodeBleu_score": 42.16321931783769}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "import os\nimport time\nfrom datetime import datetime\n\nclass AccountNotAuthorized(Exception):\n    \"\"\"Custom exception to indicate lack of authorization.\"\"\"\n    pass\n\nclass Application:\n    def fetch_authentication_token(self):\n        \"\"\"Retrieve the authentication token using various methods.\"\"\"\n        # Check if the token is stored as an environment variable\n        token = os.getenv(\"AUTH_TOKEN\")\n        if token and self.is_token_valid(token):\n            return token\n        \n        # Check local state (could be a file, database, etc)\n        local_state = self.read_local_state()\n        if local_state:\n            access_token = local_state.get('access_token')\n            expires_at = local_state.get('expires_at')\n            if access_token and datetime.now() < datetime.fromtimestamp(expires_at):\n                return access_token\n            \n            # If token has expired and there is a refresh token\n            refresh_token = local_state.get('refresh_token')\n            if refresh_token:\n                new_token, new_expires_at = self.refresh_access_token(refresh_token)\n                if new_token:\n                    # Update local state with new token data\n                    self.update_local_state(new_token, new_expires_at, refresh_token)\n                    return new_token\n        \n        # If all methods fail to retrieve a valid token\n        raise AccountNotAuthorized(\"Authentication methods failed to authorize account\")\n    \n    def is_token_valid(self, token):\n        \"\"\"Check if the given token is still valid using a mock validity check.\"\"\"\n        # Here you should implement your real token validity check logic\n        return True\n    \n    def read_local_state(self):\n        \"\"\"Read the local state from a database or file system (mocked).\"\"\"\n        # Here you should implement your local read logic\n        # This implementation is just a placeholder\n        return {\n            'access_token': 'old_token',\n            'expires_at': time.time() - 3600,  # expired one hour ago\n            'refresh_token': 'valid_refresh_token'\n        }\n    \n    def refresh_access_token(self, refresh_token):\n        \"\"\"Use a refresh token to gain a new access token (mocked implementation).\"\"\"\n        # Implement the actual refresh logic with API, here like below is just for show \n        new_token = \"new_valid_token\"\n        new_expires_at = time.time() + 3600  # valid for one more hour\n        return new_token, new_expires_at\n    \n    def update_local_state(self, access_token, expires_at, refresh_token):\n        \"\"\"Update the local storage with new token details (mocked).\"\"\"\n        # You should replace this with an actual update method which could write to a file or a database\n        print(f\"Updated token: {access_token}, expires at: {expires_at}, using refresh_token: {refresh_token}\")\n\n# Example usage:\napp = Application()\ntry:\n    token = app.fetch_authentication_token()\n    print(f\"Authentication Token: {token}\")\nexcept AccountNotAuthorized as e:\n    print(e)", "CodeBleu_score": 36.47696641987278}, {"code": "import os\nimport time\nfrom requests import post\nimport json\n\nclass AccountNotAuthorized(Exception):\n    pass\n\nclass AuthenticationManager:\n    def __init__(self, local_storage_path):\n        self.local_storage_path = local_storage_path\n    \n    def fetch_authentication_token(self):\n        \"\"\"\n        Retrieves the authentication token for the application.\n        It first checks if the token is available in the environment variables.\n        If not, it checks the local state for a valid access token and its expiration time.\n        If the access token is expired but a refresh token is available, it attempts to \n        fetch a new access token using the refresh token.\n        If successful, it updates the local state with the new authentication data and returns\n        the new access token.\n        If all methods fail, it raises an \"AccountNotAuthorized\" exception.\n        \"\"\"\n\n        # Check environment variables\n        env_token = os.getenv('AUTHENTICATION_TOKEN')\n        if env_token:\n            print(\"Using token from environment variables.\")\n            return env_token\n\n        # Read local state\n        try:\n            with open(self.local_storage_path, 'r') as file:\n                token_data = json.load(file)            \n        except (FileNotFoundError, json.JSONDecodeError):\n            token_data = {}\n\n        current_time = time.time()\n        access_token = token_data.get('access_token')\n        expires_at = token_data.get('expires_at', 0)\n        refresh_token = token_data.get('refresh_token')\n\n        # Check if access token is still valid\n        if access_token and current_time < expires_at:\n            print(\"Using valid token from local state.\")\n            return access_token\n        \n        # Refresh access token using refresh token\n        if refresh_token:\n            print(\"Attempting to refresh access token using refresh token.\")\n            new_token_data = self.refresh_access_token(refresh_token)\n            if new_token_data:\n                # Update local state with new token data\n                with open(self.local_storage_path, 'w') as file:\n                    json.dump(new_token_data, file)\n                return new_token_data['access_token']\n\n        # If all authentication methods fail\n        raise AccountNotAuthorized(\"All methods to retrieve or refresh an authentication token have failed.\")\n\n    def refresh_access_token(self, refresh_token):\n        \"\"\"A hypothetical function that would call an authentication API to refresh the access token.\"\"\"\n        # Assuming an API endpoint for refreshing tokens exists\n        refresh_endpoint = \"https://api.example.com/auth/refresh\"\n        data = {'refresh_token': refresh_token}\n        response = post(refresh_endpoint, json=data)\n        if response.status_code == 200:\n            return response.json()\n        else:\n            print(\"Failed to refresh the access token.\")\n        return None", "CodeBleu_score": 35.65543713385936}, {"code": "import os\nimport json\nimport requests\nfrom datetime import datetime\n\nclass AuthenticationError(Exception):\n    pass\n\nclass AuthenticationService:\n    def fetch_authentication_token(self):\n        # Environment variable check\n        token = os.getenv('AUTH_TOKEN')\n        if token:\n            return token\n\n        # Local state check\n        try:\n            with open('local_state.json', 'r') as file:\n                data = json.load(file)\n                access_token = data.get('access_token')\n                expiration = datetime.fromisoformat(data['expiration'])\n                refresh_token = data.get('refresh_token')\n\n            # Check if access token is still valid\n            if datetime.now() < expiration:\n                return access_token\n\n            # Attempt to refresh the token using refresh token\n            if refresh_token:\n                refreshed_token = self._refresh_access_token(refresh_token)\n                if refreshed_token:\n                    return refreshed_token\n\n        except FileNotFoundError:\n            pass  # No local state file is found, proceed to raise exception\n\n        # If no valid token found, raise an exception\n        raise AuthenticationError(\"Account not authorized\")\n\n    def _refresh_access_token(self, refresh_token):\n        refresh_url = 'https://api.example.com/oauth/refresh'\n        headers = {'Content-Type': 'application/json'}\n        payload = {'refresh_token': refresh_token}\n        response = requests.post(refresh_url, headers=headers, json=payload)\n\n        if response.status_code == 200:\n            new_auth_data = response.json()\n            # Update new tokens to the local state\n            new_local_state = {\n                'access_token': new_auth_data['access_token'],\n                'expiration': (datetime.now() + timedelta(seconds=new_auth_data['expires_in'])).isoformat(),\n                'refresh_token': new_auth_data.get('refresh_token', refresh_token)  # Reuse old refresh token if none provided\n            }\n\n            with open('local_state.json', 'w') as file:\n                json.dump(new_local_state, file)\n\n            return new_auth_data['access_token']\n\n        return None", "CodeBleu_score": 36.74910423617621}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "import requests\n\nclass YourClassName:\n    def logout(self):\n        \"\"\"\n        The function \"logout\" logs the user out by performing the following steps:\n        It retrieves the refresh token, deletes the local session,\n        and then attempts to send a POST request to the \"/v1/logout\"\n        endpoint with the refresh token.\n        If an AccountError occurs during the request, it is ignored.\n        The function returns \"True\" after completing these steps.\n        \"\"\"\n        # Assuming refresh token and session are stored in this manner\n        refresh_token = self.get_refresh_token()\n        self.delete_local_session()\n        \n        # Prepare the request\n        url = \"https://api.example.com/v1/logout\"\n        headers = {\"Content-Type\": \"application/json\"}\n        payload = {\"refresh_token\": refresh_token}\n        \n        try:\n            # Send POST request\n            response = requests.post(url, json=payload, headers=headers)\n            response.raise_for_status()  # will not handle AccountError here explicitly\n        \n        except requests.exceptions.HTTPError as e:\n            # Assuming that AccountError is related to invalid account actions or failed verifications\n            if \"AccountError\" in str(e):\n                pass  # ignore AccountError\n            \n        return True\n\n    def get_refresh_token(self):\n        # This method would interact with whatever stores the refresh token\n        # Example return\n        return \"your_refresh_token\"\n\n    def delete_local_session(self):\n        # This method would handle the logic to terminate/delete local session data\n        pass", "CodeBleu_score": 48.14359257953617}, {"code": "import requests\n\nclass Authentication:\n    def logout(self):\n        \"\"\"The function \"logout\" logs the user out by performing the following steps:\n        It retrieves the refresh token, deletes the local session, and then attempts to send a POST request to the \"/v1/logout\" endpoint with the refresh token.\n        If an AccountError occurs during the request, it is ignored.\n        The function returns \"True\" after completing these steps.\"\"\"\n        \n        try:\n            # Retrieve the refresh token from the local session\n            refresh_token = self.session.get('refresh_token')\n            \n            # Delete the local session\n            self.session.clear()\n\n            # Prepare the request to log out via API\n            url = \"http://example.com/api/v1/logout\"\n            headers = {'Content-Type': 'application/json'}\n            payload = {'refresh_token': refresh_token}\n\n            # Perform the POST request to the API\n            response = requests.post(url, json=payload, headers=headers)\n            response.raise_for_status()  # This will raise an exception for HTTP errors\n            \n        except requests.HTTPError as err:\n            print(f\"HTTP error occurred: {err}\")  # In real usage, you might want to log this instead\n        except Exception as err:\n            # Log other exceptions which might be critical\n            print(f\"An error occurred: {err}\")\n        except AccountError:\n            # Ignore AccountError as per the requirement\n            pass\n        \n        return True", "CodeBleu_score": 47.35788308920952}, {"code": "import requests\n\nclass UserSession:\n    def __init__(self, session_data):\n        self.session_data = session_data\n\n    def get_refresh_token(self):\n        \"\"\"Simulate retrieval of a refresh token from session data.\"\"\"\n        return self.session_data.get('refresh_token', '')\n\n    def delete_local_session(self):\n        \"\"\"Simulate the deletion of local session data.\"\"\"\n        self.session_data = {}\n        print(\"Local session data has been cleared.\")\n\n    def logout(self):\n        \"\"\"Logout the user by deleting the refresh token and local session data, then performing a logout API call.\n\n        It retrieves the refresh token, deletes the local session, and then\n        attempts to send a POST request to the \"/v1/logout\" endpoint \n        with the refresh token.\n        \n        If an error occurs during the request, it is ignored.\n        \n        The function returns \"True\" after completing these steps.\n        \"\"\"\n        # Retrieve the refresh token\n        refresh_token = self.get_refresh_token()\n        \n        # Delete the local session data\n        self.delete_local_session()\n        \n        # Define the API URL for logout\n        api_url = \"https://api.example.com/v1/logout\"\n        \n        # Define the headers and the body of the request\n        headers = {'Content-Type': 'application/json'}\n        body = {'refresh_token': refresh_token}\n        \n        # Perform the POST request to the /v1/logout endpoint\n        try:\n            response = requests.post(api_url, json=body, headers=headers)\n            response.raise_for_status()  # Raise exception for HTTP errors\n        except requests.exceptions.HTTPError as e:\n            print(f\"HTTPError occurred: {e}\")\n        except requests.exceptions.RequestException as e:\n            # Ignore other request exceptions like connection error\n            print(f\"Request exception ignored: {e}\")\n        \n        # Return True to indicate the logout process is complete\n        return True\n\n# Example usage:\nsession_data = {'refresh_token': 'abcd1234'}\nuser_session = UserSession(session_data)\nlogout_success = user_session.logout()\nprint(\"Logout successful:\", logout_success)", "CodeBleu_score": 39.78132811725804}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self):\n    # Sample list representing all_packages\n    all_packages = [\n        {'name': 'numpy', 'version': '1.21.0', 'optional': False, 'external': False},\n        {'name': 'pandas', 'version': '1.3.1', 'optional': False, 'external': True, 'url': 'https://pandas.pydata.org/'},\n        {'name': 'pytest', 'version': '6.2.4', 'optional': True, 'external': False},\n        {'name': 'requests', 'version': '2.25.1', 'optional': False, 'external': True, 'url': 'https://requests.readthedocs.io/'}\n    ]\n    \n    used_packages = []\n    for package in all_packages:\n        if not package['optional']:\n            package_info = {\n                'name': package['name'],\n                'version': package['version']\n            }\n            if package.get('external', False):\n                package_info['url'] = package['url']\n            used_packages.append(package_info)\n    \n    return used_packages\n\n# Example Usage\n# Assuming this method is part of a class, instantiate the class and call the method.\n# my_instance = MyClass()\n# print(my_instance.dump_used_packages())", "CodeBleu_score": 24.03119678878397}, {"code": "import pkg_resources\n\nclass PackageManager:\n    def dump_used_packages(self):\n        \"\"\"\n        Returns a list of non-optional packages with their names and versions.\n        It also includes the source URL in the result if the package's metadata indicates it is external.\n        \n        :return: List of dictionaries, each containing package name, version, and optionally source URL.\n        \"\"\"\n        used_packages_info = []\n\n        for pkg in pkg_resources.working_set:\n            # Assuming 'non-optional' means all packages currently installed\n            # For demonstration, let's consider external packages as those whose locations are not standard dist-packages or site-packages.\n            pkg_info = {\n                \"name\": pkg.project_name,\n                \"version\": pkg.version\n            }\n\n            # Checking if the package location suggests it might be external (simplified heuristic)\n            if 'site-packages' not in pkg.location and 'dist-packages' not in pkg.location:\n                pkg_info['source_url'] = 'External source possibly private or non-standard'\n\n            used_packages_info.append(pkg_info)\n\n        return used_packages_info\n\n# Example Usage:\npm = PackageManager()\nprint(pm.dump_used_packages())", "CodeBleu_score": 27.059349809544976}, {"code": "import pkg_resources\n\nclass PackageInspector:\n    def __init__(self):\n        self.optional_packages = set([\"examplepackage1\", \"examplepackage2\"])  # Example set of optional packages\n        self.external_sources = {\n            \"packagename\": \"https://packageurl.com\"  # Example mapping for external packages\n        }\n    \n    def is_optional(self, package):\n        \"\"\"Determines if the given package is optional.\"\"\"\n        return package.project_name in self.optional_packages\n    \n    def is_external(self, package):\n        \"\"\"Determines if the given package is external, returning its URL if true.\"\"\"\n        return self.external_sources.get(package.project_name, None)\n    \n    def dump_used_packages(self):\n        \"\"\"Returns a list of non-optional packages with their names and versions.\n        It iterates through the packages, skips optional ones, and collects metadata for the others.\n        If a package's metadata indicates it is external, it includes the source URL in the result.\n        Finally, it returns the list of packages with their respective information.\"\"\"\n        package_list = []\n        for pkg in pkg_resources.working_set:\n            if not self.is_optional(pkg):\n                package_info = {\"name\": pkg.project_name, \"version\": pkg.version}\n                external_url = self.is_external(pkg)\n                if external_url:\n                    package_info[\"url\"] = external_url\n                package_list.append(package_info)\n        return package_list\n\n# Example usage:\ninspector = PackageInspector()\nused_packages = inspector.dump_used_packages()\nprint(used_packages)", "CodeBleu_score": 29.184564051429025}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "class UndefinedEnvPlatformError(Exception):\n    pass\n\nclass ProjectEnvironment:\n    def __init__(self, env_name, platform_spec, autoinstall=False):\n        self.env_name = env_name\n        self.platform_spec = platform_spec\n        self.autoinstall = autoinstall\n        self.installed_packages = []\n\n    def set_project_environment(self):\n        print(f\"Environment '{self.env_name}' with platform specifications '{self.platform_spec}' is now set.\")\n\n    def configure_packages(self, targets):\n        if self.autoinstall:\n            print(\"Auto-installation is enabled.\")\n            # Assume installation logic for specified targets\n            self.installed_packages += targets\n            print(f\"Installed packages: {', '.join(targets) if targets else 'No targets specified'}\")\n        else:\n            print(\"Auto-installation is not enabled. No packages were installed.\")\n\n    @classmethod\n    def from_env(cls, env, targets=None, autoinstall=False):\n        # Assuming `project_config` is a dictionary with environment specs.\n        project_config = {\n            'env1': 'Platform-1',\n            'env2': 'Platform-2',\n            'env3': 'Platform-3'\n        }\n        \n        if env not in project_config:\n            raise UndefinedEnvPlatformError(f\"Environment {env} does not have defined platform specifications.\")\n        \n        platform_spec = project_config[env]\n        instance = cls(env, platform_spec, autoinstall)\n        instance.set_project_environment()\n        \n        if targets:\n            instance.configure_packages(targets)\n        else:\n            # call to configure with no specific target packages\n            instance.configure_packages(targets)\n            \n        return instance\n\n# Example Usage\ntry:\n    project_env = ProjectEnvironment.from_env('env1', ['package1', 'package2'], autoinstall=True)\nexcept UndefinedEnvPlatformError as e:\n    print(e)", "CodeBleu_score": 26.200025294438944}, {"code": "class UndefinedEnvPlatformError(Exception):\n    \"\"\"Exception raised when an environment platform is unspecified.\"\"\"\n    pass\n\nclass ProjectEnvironment:\n    def __init__(self, platform_spec, autoinstall=False):\n        self.platform_spec = platform_spec\n        self.autoinstall = autoinstall\n        self.packages = {}\n\n    def set_environment(self, env):\n        print(f\"Environment set to: {env}\")\n\n    def configure_packages(self, targets):\n        if targets is None:\n            targets = []\n        print(f\"Configuring packages for targets: {targets}\")\n        for target in targets:\n            self.packages[target] = True\n\n    @classmethod\n    def from_env(cls, env, targets=None, autoinstall=False):\n        \"\"\"\n        The function \"from_env\" creates and configures an instance of a project environment\n        based on a specified environment name.\n        It retrieves the platform specification for the environment from the project configuration.\n        If the specification is not found, it raises an \"UndefinedEnvPlatformError\".\n        It then creates a new instance of the class with the platform specification and autoinstall option,\n        sets the project environment, and configures the project packages for the given environment and targets.\n        Finally, it returns the configured instance.\n        \"\"\"\n        project_configs = {\n            \"development\": {\"platform_spec\": \"development_spec\"},\n            \"production\": {\"platform_spec\": \"production_spec\"},\n        }\n\n        # Retrieve platform specification for the environment\n        if env not in project_configs or \"platform_spec\" not in project_configs[env]:\n            raise UndefinedEnvPlatformError(f\"Platform specification for environment '{env}' is not defined.\")\n\n        platform_spec = project_configs[env][\"platform_spec\"]\n        \n        # Create instance\n        instance = cls(platform_spec, autoinstall)\n        \n        # Set up environment context\n        instance.set_environment(env)\n        \n        # Configure the packages for given targets\n        instance.configure_packages(targets)\n        \n        # Return the configured instance\n        return instance\n\n# Example usage:\ntry:\n    dev_env = ProjectEnvironment.from_env(\"development\", targets=[\"db\", \"api\"], autoinstall=True)\nexcept UndefinedEnvPlatformError as e:\n    print(e)", "CodeBleu_score": 23.659370239563316}, {"code": "class UndefinedEnvPlatformError(Exception):\n    \"\"\"Exception for undefined environment platform.\"\"\"\n    pass\n\nclass ProjectEnv:\n    def __init__(self, platform, autoinstall=False):\n        self.platform = platform\n        self.autoinstall = autoinstall\n        self.packages = []\n\n    def set_environment(self, env):\n        \"\"\"Set the active environment properties.\"\"\"\n        print(f\"Environment set to: {env}\")\n\n    def configure_packages(self, targets=None):\n        \"\"\"Configure packages for the given environment and targets.\"\"\"\n        print(f\"Packages configured for platform: {self.platform} with targets: {targets}\")\n\nclass ProjectConfig:\n    platforms = {\n        'development': 'Linux',\n        'staging': 'Windows',\n        'production': 'macOS'\n    }\n\n    @classmethod\n    def from_env(cls, env, targets=None, autoinstall=False):\n        \"\"\"Create and configure an instance based on an environment name.\"\"\"\n        if env not in cls.platforms:\n            raise UndefinedEnvPlatformError(f\"Platform specification for environment '{env}' is undefined.\")\n        \n        platform = cls.platforms[env]\n        instance = cls(platform, autoinstall)\n        instance.set_environment(env)\n        instance.configure_packages(targets)\n        return instance\n\n# Example usage:\nif __name__ == \"__main__\":\n    try:\n        env_instance = ProjectConfig.from_env('development', targets=['web', 'api'], autoinstall=True)\n    except UndefinedEnvPlatformError as e:\n        print(e)", "CodeBleu_score": 28.12360434294169}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff) {\n    // Start I2C transmission to the AXP192 at its I2C address (0x34)\n    Wire.beginTransmission(0x34);\n\n    // Send the register address from where the data reading should begin\n    Wire.write(Addr);\n\n    // End the transmission\n    Wire.endTransmission();\n\n    // Request the specific number of bytes from the AXP192\n    Wire.requestFrom(0x34, (int)Size);\n\n    // Read the bytes and store them into the provided buffer\n    int i = 0;\n    while (Wire.available() && i < Size) {\n        Buff[i] = Wire.read();\n        i++;\n    }\n}", "CodeBleu_score": 65.12890227575156}, {"code": "#include <Wire.h> // Required for I2C communication\n\n/*\n * This member function of the AXP192 class reads a specified number of bytes\n * from a given address of the AXP192 device. It uses I2C protocol for communication.\n * \n * Params:\n * - Addr: The starting address from which to read bytes.\n * - Size: The number of bytes to read.\n * - Buff: A pointer to an array where the read bytes will be stored.\n */\nvoid AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff) {\n    if (Buff == nullptr || Size == 0) {\n        return; // Exit if the buffer is null or size is zero\n    }\n\n    Wire.beginTransmission(0x34); // Begin transmission to device with I2C address 0x34\n    Wire.write(Addr);             // Specify the initial register address to read from\n    Wire.endTransmission();       // End transmission\n\n    Wire.requestFrom(0x34, Size); // Request 'Size' bytes from the device\n    int i = 0;\n    while (Wire.available() && i < Size) { // While bytes are available to read\n        Buff[i++] = Wire.read();           // Read a byte and store it in the buffer\n    }\n}", "CodeBleu_score": 48.074375866025335}, {"code": "#include <Wire.h>  // Include the Wire library to enable I2C communication\n\nvoid AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff) {\n    // Start an I2C transmission\n    Wire.beginTransmission(0x34);  // Start I2C transmission to the AXP192 device (address 0x34)\n    Wire.write(Addr);  // Specify the start register address to read from\n    Wire.endTransmission(false);  // End transmission but hold the I2C bus (send a repeated start)\n\n    // Request 'Size' bytes from the AXP192, and specify a stop condition after the last byte\n    Wire.requestFrom(0x34, Size, true);  \n    \n    // Check if the device returned the expected number of bytes.\n    int index = 0;\n    while (Wire.available() && index < Size) {  // While bytes are available to read and we have not filled our buffer\n        Buff[index++] = Wire.read();  // Read a byte and store it in the buffer\n    }\n\n    if (index != Size) {\n        // Handle error: Not enough bytes received\n        // You might want to add some error handling code here.\n    }\n    // Optionally end transmission\n    // Wire.endTransmission();  // This is generally not necessary as requestFrom() stops the transmission\n}", "CodeBleu_score": 48.025626591609964}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us) {\n    // Prepare the AXP192 for sleep\n    SetSleep();\n\n    // If a specific duration is provided (non-zero), set up a timer for wakeup\n    if (time_in_us > 0) {\n        EnableTimerWakeup(time_in_us);\n    } else {\n        // If duration is zero, disable timer wakeup\n        DisableTimerWakeup();\n    }\n\n    // Initiate deep sleep\n    EnterDeepSleep();\n}", "CodeBleu_score": 53.23400100111052}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us) {\n    // Call SetSleep to prepare the device for sleep\n    this->SetSleep();\n\n    // Check if a non-zero duration is provided\n    if (time_in_us > 0) {\n        // Enable a timer to wake up the device after the specified time in microseconds\n        this->EnableTimerWakeup(time_in_us);\n    } else {\n        // Disable the timer wakeup source if the duration is zero\n        this->DisableTimerWakeup();\n    }\n\n    // Initiate deep sleep\n    this->EnterDeepSleep();\n}", "CodeBleu_score": 42.980346177717536}, {"code": "#include <stdint.h> // For uint64_t\n\n// Simulate the implementation of AXP192 class for demonstration purposes.\nclass AXP192 {\npublic:\n    void SetSleep();\n    void EnableTimerWakeup(uint64_t time_in_us);\n    void DisableTimerWakeup();\n    void InitiateDeepSleep(uint64_t time_in_us);\n};\n\nvoid AXP192::SetSleep() {\n    // Code to set the AXP192 device in a ready-to-sleep state.\n    // Example assumed operations might include reducing power to peripherals, etc.\n    // (Placeholder implementation)\n}\n\nvoid AXP192::EnableTimerWakeup(uint64_t time_in_us) {\n    // Code to enable timer to wake the device after given microseconds.\n    // (Placeholder implementation)\n}\n\nvoid AXP192::DisableTimerWakeup() {\n    // Code to disable any timer-based wakeup mechanism.\n    // (Placeholder implementation)\n}\n\nvoid AXP192::InitiateDeepSleep(uint64_t time_in_us) {\n    // Code to put the device fully into deep sleep mode.\n    // If time_in_us > 0, the sleep should be timed based on the EnableTimerWakeup configuration.\n    // (Placeholder implementation)\n}\n\nvoid AXP192::DeepSleep(uint64_t time_in_us) {\n    // Prepare the AXP192 for sleep mode\n    SetSleep();\n    \n    // Depending on the duration, set up a timer or disable the timer wakeup\n    if (time_in_us > 0) {\n        EnableTimerWakeup(time_in_us);\n    } else {\n        DisableTimerWakeup();\n    }\n    \n    // Initiate deep sleep for the specified duration or indefinitely\n    InitiateDeepSleep(time_in_us);\n}", "CodeBleu_score": 60.16618910700122}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)\n{\n    // Store the current starting y-coordinate\n    int previousY = startY;\n\n    // Check if the special condition 'tteBar' is met to use alternative top fixed area\n    if (tteBar) {\n        startY = fixedTopBarY;\n    }\n\n    // Calculate new y-coordinate by adding the height of a text line\n    startY += lineHeight;\n\n    // Check and wrap around if y exceeds the display boundaries minus the bottom fixed area\n    if (startY >= (displayHeight - fixedBottomArea)) {\n        startY = fixedTopArea; // start again from the top fixed area assuming it wraps around\n    }\n\n    // Fill the rectangle area with the specified color at the new y-coordinate\n    fillRectangle(0, startY, displayWidth, lineHeight, color);\n\n    // Update the display's scroll address to new y-coordinate\n    setScrollAddress(startY);\n\n    // Return the previous y-coordinate\n    return previousY;\n}", "CodeBleu_score": 24.8647498681192}, {"code": "int Display::scroll_line(uint32_t color) {\n    int prevY = currentY; // Store current y-coordinate\n    \n    // Determine the starting y-coordinate considering tteBar\n    int topFixedArea = (tteBar) ? alternativeTopFixedArea : standardTopFixedArea;\n    \n    // Using the currentY, fill the rectangle with the specified color\n    fillRect(0, currentY, getWidth(), lineHeight, color); // Assumes rectangle filling from (x, y, width, height, color)\n    \n    // Update the y-coordinate to the next line, handle wrapping\n    currentY += lineHeight;\n    if (currentY > getHeight() - bottomFixedArea) { // Checks if currentY exceeds display height minus bottom fixed area\n        currentY = topFixedArea;  // Wraps around to top fixed area\n    }\n    \n    // Update the display scroll address or refresh it here\n    updateScrollAddress(); // Pseudo-method for updating display scroll properties or redrawing the screen\n\n    return prevY; // Return the previous y-coordinate\n}", "CodeBleu_score": 19.693245467870703}, {"code": "int Display::scroll_line(uint32_t color) {\n    // Save the current y-coordinate before modifying it\n    int previousY = scrollY;\n\n    // Define offsets for areas not to be scrolled (e.g., status bars)\n    int topFixedArea = tteBar ? TOP_FIXED_BAR_TTE : TOP_FIXED_BAR_REGULAR;\n    int bottomFixedArea = BOTTOM_FIXED_BAR;\n\n    // Calculate the new scroll position\n    scrollY += LINE_HEIGHT;\n    if (scrollY > (displayHeight - bottomFixedArea - topFixedArea)) {\n        scrollY = topFixedArea;\n    }\n\n    // Fill the new line with the specified color\n    fill_rect(0, scrollY, displayWidth, LINE_HEIGHT, color);\n\n    // Update the scroll address of the display\n    update_scroll_address(scrollY);\n\n    // Return the previous y-coordinate\n    return previousY;\n}", "CodeBleu_score": 27.326795480733736}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "#include <LinkedList.h> // Assuming uses LinkedList library\n\nstruct ssid {\n    String name;\n    int encryptionType; // For our purposes we define encryption type as an int, e.g., 0 for open, 1 for WEP, etc.\n};\n\nstruct AccessPoint {\n    String ssid;\n    String password;\n    int channel;\n    int hidden; // 0 for visible, 1 for hidden\n};\n\nclass EvilPortal {\npublic:\n    bool begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points) {\n        bool setupAPs = setupAccessPoints(access_points);\n        bool setupHTML = setupHTMLContent();\n\n        if (!setupAPs || !setupHTML) {\n            return false;\n        } else {\n            startPortal();\n            return true;\n        }\n    }\n\nprivate:\n    // Assuming we have these helper methods, although they are also to be implemented.\n    bool setupAccessPoints(LinkedList<AccessPoint>* access_points) {\n        // Logic to configure and activate access points goes here\n        // Implementation details could include interfacing with hardware-specific libraries\n        // For the sake of example, we'll assume successful configuration.\n        for (int i = 0; i < access_points->size(); i++) {\n            AccessPoint ap = access_points->get(i);\n            // Fake setup, assuming success\n            Serial.println(\"Setting up: \" + ap.ssid);\n        }\n        return true;\n    }\n\n    bool setupHTMLContent() {\n        // Logic to setup HTML content for the portal goes here\n        // For the sake of example, we'll assume this successfully sets up\n        Serial.println(\"Setting up HTML content.\");\n        return true;\n    }\n\n    void startPortal() {\n        // Logic to activate the portal goes here\n        Serial.println(\"Portal started.\");\n    }\n};", "CodeBleu_score": 46.89208115910453}, {"code": "#include <LinkedList.h>  // Include the LinkedList library if not already included.\n\n// Define the AccessPoint struct or class if not already defined.\nstruct AccessPoint {\n    String ssid;\n    String password;\n    int channel;\n    bool hidden;\n    // Add any other necessary fields or methods.\n};\n\nclass EvilPortal {\nprivate:\n    LinkedList<String>* ssidsList;\n    LinkedList<AccessPoint>* apList;\n    bool setupAccessPoints(LinkedList<AccessPoint>* access_points);\n    bool setupHTMLContent();\n\npublic:\n    bool begin(LinkedList<String>* ssids, LinkedList<AccessPoint>* access_points);\n};\n\nbool EvilPortal::setupAccessPoints(LinkedList<AccessPoint>* access_points) {\n    // Implement the logic to configure each access point.\n    for (int i = 0; i < access_points->size(); i++) {\n        AccessPoint ap = access_points->get(i);\n        // Here you would add logic to configure hardware/network settings.\n        // Simulating setup failure for example.\n        if (ap.ssid.empty() || ap.password.empty()) {\n            return false;\n        }\n        // Set up AP in the system (pseudo-code)\n        // if (!hardware.setAP(ap.ssid, ap.password, ap.channel, ap.hidden)) {\n        //     return false;\n        // }\n    }\n    return true;\n}\n\nbool EvilPortal::setupHTMLContent() {\n    // Implement the logic to set up the HTML content for the portal.\n    // This is a stub, assuming the configuration is successful.\n    // In practical scenarios, setup might involve loading files, setting up servers, etc.\n\n    // Simulating HTML content setup.\n    return true;\n}\n\nbool EvilPortal::begin(LinkedList<String>* ssids, LinkedList<AccessPoint>* access_points) {\n    this->ssidsList = ssids;\n    this->apList = access_points;\n\n    if (!setupAccessPoints(access_points)) {\n        return false;\n    }\n\n    if (!setupHTMLContent()) {\n        return false;\n    }\n\n    // Simulate starting the portal here (pseudocode).\n    // if (!startPortal()) {\n    //    return false;\n    // }\n\n    return true;\n}", "CodeBleu_score": 46.286737626505726}, {"code": "{\n    // Initialize the HTML content of the portal\n    if (!setupHTMLContent()) {\n        return false;  // fail to set up HTML content\n    }\n\n    // Attempt to set up each access point with the respective SSID\n    for (int i = 0; i < access_points->size(); i++) {\n        AccessPoint* ap = access_points->get(i);\n        if (ap == nullptr || !ap->setup(ssids->get(i))) {\n            return false;  // fail to set up an access point\n        }\n    }\n\n    // Start the portal after successful setup\n    if (!startPortal()) {\n        return false;  // fail to start the portal\n    }\n\n    return true;  // setup and start were successful\n}", "CodeBleu_score": 41.0811493784308}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "#include <queue>\n#include <string>\n\nclass GpsInterface {\nprivate:\n    std::queue<std::string> queue; // Queue to manage the GPS data\n    bool queue_enabled_flag;    // Flag to check if queue is enabled\n    std::string text;           // Some text data used by the GPS interface\n    std::string text_in;        // An input text data for the queue\n    \npublic:\n    GpsInterface() : queue_enabled_flag(false) {}   // Constructor to initialize the enabled flag to false\n\n    // Function to enable the queue\n    void enable_queue() {\n        if (queue_enabled_flag) {\n            // Queue is already enabled, ensure initializations\n            queue = std::queue<std::string>(); // Re-initialize the queue\n            text.clear();  // Initialize/clear the text\n            text_in.clear();  // Initialize/clear the input text\n        } else {\n            // Queue is not enabled, flush the existing queue and enable it\n            while (!queue.empty()) {\n                queue.pop();   // Remove all elements from the queue\n            }\n            queue_enabled_flag = true;  // Set the enabled flag to true\n        }\n    }\n};\n\n// This code snippet outlines the construction of the enable_queue function within a GpsInterface class.\n// It assumes that queue, text, and text_in are class attributes and that there exists a queue_enabled_flag to handle enabling state.", "CodeBleu_score": 7.533415264443856}, {"code": "void GpsInterface::enable_queue() {\n    // Check if the queue is already enabled\n    if (queue_enabled_flag) {\n        // Queue is already enabled; initialize queue, text, and text_in\n        queue.clear();  // Clear existing data in the queue\n        text = \"\";      // Reset text\n        text_in = \"\";   // Reset text_in\n    } else {\n        // Queue is not enabled; flush the existing queue (if necessary) and enable it\n        queue.clear();  // Clear any existing data in the queue\n        queue_enabled_flag = true;  // Set the flag to state that the queue is now enabled\n    }\n}", "CodeBleu_score": 12.27551118312652}, {"code": "#include <queue>\n#include <string>\n\nclass GpsInterface {\nprivate:\n    std::queue<std::string> queue;      // Queue to store data.\n    bool queue_enabled_flag;            // Flag to check if the queue is enabled.\n    std::string text, text_in;          // Additional string variables (assuming their usage in the interface).\n\npublic:\n    GpsInterface() : queue_enabled_flag(false) {}  // Constructor to initialize queue to disabled.\n\n    // Function to manage the state of the queue for GPS interface\n    void enable_queue() {\n        if (queue_enabled_flag) {\n            // Reinitialize the components if queue is already enabled\n            while (!queue.empty()) {\n                queue.pop();  // Ensure the queue is empty\n            }\n            text.clear();    // Clear text variable\n            text_in.clear(); // Clear text_in variable\n        } else {\n            // First, flush the existing data in the queue\n            while (!queue.empty()) {\n                queue.pop();\n            }\n            // Then set the queue_enabled_flag to true\n            queue_enabled_flag = true;\n        }\n    }\n};", "CodeBleu_score": 7.958429318531122}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea() {\n    // Lock the queue mutex to prevent other threads from accessing it during modification\n    std::lock_guard<std::mutex> lock(queue_mutex);\n\n    // Check if the queue exists\n    if (nmea_queue) {\n        // Delete the existing queue to clear it\n        delete nmea_queue;\n    }\n    \n    // Create a new queue\n    nmea_queue = new std::queue<std::string>();\n}", "CodeBleu_score": 41.25324615318373}, {"code": "void GpsInterface::flush_queue_nmea() {\n    // Check if the queue exists\n    if (nmea_queue != nullptr) {\n        // Clear the queue if it is not empty\n        while (!nmea_queue->empty()) {\n            nmea_queue->pop();\n        }\n        // Alternatively, we can delete the existing queue and create a new one\n        delete nmea_queue;\n    }\n\n    // Create a new queue\n    nmea_queue = new std::queue<std::string>();  // assuming nmea_queue is of type std::queue<std::string>*\n}", "CodeBleu_score": 39.98265756047353}, {"code": "void GpsInterface::flush_queue_nmea() {\n    // Check if the current queue exists\n    if (nmea_queue != nullptr) {\n        // Clear the existing queue\n        delete nmea_queue;\n    }\n\n    // Create a new queue to replace the old one or establish a new one\n    nmea_queue = new std::queue<std::string>();\n}", "CodeBleu_score": 38.80801685581977}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "void my_disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p) {\n    // Start a new write transaction\n    lcd_start_transaction();\n\n    // Set the address window to the specified area\n    lcd_set_address_window(area->x1, area->y1, area->x2, area->y2);\n\n    // Calculate the number of pixels to update\n    int total_pixels = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n\n    // Iterate through each pixel and send color data\n    for (int i = 0; i < total_pixels; i++) {\n        lcd_write_color(*(color_p++));\n    }\n\n    // End the write transaction\n    lcd_end_transaction();\n\n    // Notify the display driver that the flush is done\n    lv_disp_flush_ready(disp_drv);\n}", "CodeBleu_score": 43.721675593723376}, {"code": "#include \"device_display_driver.h\"  // Include the header for display handling, modify as per actual usage\n\nvoid my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {\n    if(disp == NULL || area == NULL || color_p == NULL) {\n        lv_disp_flush_ready(disp); // Notify library that flush is done with invalid input\n        return;\n    }\n\n    // Start a new write transaction\n    device_display_start_write();\n\n    // Set the address window to update the correct area\n    device_display_set_address_window(area->x1, area->y1, area->x2, area->y2);\n\n    // Calculate the number of pixels to update\n    int num_pixels = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n\n    // Write out each pixel's color data from the buffer\n    for (int i = 0; i < num_pixels; i++) {\n        // Assume the device_display_write_color function takes a single lv_color_t and writes it\n        device_display_write_color(color_p[i]);\n    }\n\n    // End the write transaction\n    device_display_stop_write();\n\n    // Notify the LVGL library that flushing is complete, so it can continue processing other things\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 45.92592680936743}, {"code": "void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {\n    if (disp == NULL || area == NULL || color_p == NULL) {\n        // End the display flush with an error if parameters are invalid\n        lv_disp_flush_ready(disp);\n        return;\n    }\n\n    // Start a write transaction (specific commands depend on the display driver used)\n    disp_driver_start_write();\n\n    // Set the address window corresponding to the specified area\n    disp_driver_set_address_window(area->x1, area->y1, area->x2, area->y2);\n\n    // Calculate the number of pixels to be updated\n    int total_pixels = (area->x2 - area->x1 + 1) * (area->y2 - area->y1 + 1);\n\n    // Iterate through each pixel in the specified area\n    for (int i = 0; i < total_pixels; i++) {\n        // Write the color of the current pixel\n        disp_driver_send_pixel_color(color_p[i]);\n    }\n\n    // End the write transaction\n    disp_driver_end_write();\n\n    // Notify the library that the display flush is done\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 49.05785918863512}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "#include <iostream>\n#include <string>\n#include <vector>\n\nclass MenuNode {\npublic:\n    std::string name;\n    Menu* subMenu; // Pointer to a sub-menu if it exists, null otherwise\n\n    MenuNode(std::string n, Menu* menu = nullptr) : name(n), subMenu(menu) {}\n};\n\nclass Menu {\npublic:\n    std::vector<MenuNode*> nodes;\n\n    ~Menu() { // Destructor to clean up heap-allocated MenuNodes\n        for (auto node : nodes)\n            delete node;\n    }\n\n    void addNode(MenuNode* node) {\n        nodes.push_back(node);\n    }\n\n    std::vector<MenuNode*>& getNodes() {\n        return nodes;\n    }\n};\n\nclass MenuFunctions {\npublic:\n    void showMenuList(Menu* menu, int layer) {\n        if (menu == nullptr) return;\n\n        std::string indent(layer * 4, ' '); // Create indentation string\n        \n        for (auto node : menu->getNodes()) {\n            std::cout << indent << node->name << std::endl;\n            \n            if (node->subMenu) { // Recursively call `showMenuList` if submenu exists\n                showMenuList(node->subMenu, layer + 1);\n            }\n        }\n\n        if (layer == 0) { // Print a new line only after the topmost nodes are printed\n            std::cout << std::endl;\n        }\n    }\n};\n\n// Usage\nint main() {\n    Menu mainMenu;\n    Menu subMenu1;\n    Menu subMenu2;\n    \n    subMenu1.addNode(new MenuNode(\"Subitem 1.1\"));\n    subMenu1.addNode(new MenuNode(\"Subitem 1.2\"));\n    \n    subMenu2.addNode(new MenuNode(\"Subitem 2.1\"));\n    subMenu2.addNode(new MenuNode(\"Subitem 2.2\"));\n\n    mainMenu.addNode(new MenuNode(\"Item 1\"));\n    mainMenu.addNode(new MenuNode(\"Item 2\", &subMenu1)); // Pass subMenu1 for \"Item 2\"\n    mainMenu.addNode(new MenuNode(\"Item 3\", &subMenu2)); // Pass subMenu2 for \"Item 3\"\n\n    MenuFunctions menuFunctions;\n    menuFunctions.showMenuList(&mainMenu, 0);\n    \n    return 0;\n}", "CodeBleu_score": 37.48783228465257}, {"code": "#include <vector>\n#include <iostream>\n#include <string>\n\n// Assuming the definition of Menu and MenuNode classes\nclass MenuNode {\npublic:\n    std::string name;\n    std::vector<MenuNode*> children;\n\n    MenuNode(std::string n) : name(n) {}\n\n    void addChild(MenuNode* child) {\n        children.push_back(child);\n    }\n};\n\nclass Menu {\npublic:\n    std::vector<MenuNode*> nodes;\n\n    void addNode(MenuNode* node) {\n        nodes.push_back(node);\n    }\n\n    std::vector<MenuNode*> getNodes() const {\n        return nodes;\n    }\n};\n\n// Part of the MenuFunctions class\nclass MenuFunctions {\npublic:\n    static void showMenuList(Menu* menu, int layer = 0) {\n        if (!menu) return;\n\n        std::vector<MenuNode*> nodes = menu->getNodes();\n        for (auto node : nodes) {\n            // Print current node with indentation\n            for (int i = 0; i < layer; i++) {\n                std::cout << \"  \"; // Two spaces per layer of indentation\n            }\n            std::cout << (node ? node->name : \"Unnamed\") << std::endl;\n\n            // Recursive call if node has children\n            if (!node->children.empty()) {\n                Menu subMenu;              // Create a submenu for child nodes\n                for (auto child : node->children) {\n                    subMenu.addNode(child); // Add child nodes to the submenu\n                }\n                showMenuList(&subMenu, layer + 1);\n            }\n        }\n        // Print an empty line after listing all nodes at the current level\n        std::cout << std::endl;\n    }\n};\n\n// Example usage\nint main() {\n    Menu menu;\n    MenuNode* node1 = new MenuNode(\"Main\");\n    MenuNode* node1Child = new MenuNode(\"SubMenu1\");\n    MenuNode* node1Child2 = new MenuNode(\"SubMenu2\");\n    node1->addChild(node1Child);\n    node1->addChild(node1Child2);\n\n    menu.addNode(node1);\n\n    MenuFunctions::showMenuList(&menu);\n    return 0;\n}", "CodeBleu_score": 45.40504197776641}, {"code": "#include <iostream>\n#include <string>\n\nclass Menu {\npublic:\n    std::string name;\n    std::vector<Menu*> children;\n\n    Menu(const std::string& name) : name(name) {}\n\n    void addChild(Menu* child) {\n        children.push_back(child);\n    }\n};\n\nclass MenuFunctions {\npublic:\n    // Recursive function to display menu list with indentation\n    void showMenuList(Menu *menu, int layer) {\n        if (menu == nullptr)\n            return;\n\n        std::string indent(layer*2, ' '); // Create an indentation string using spaces\n        std::cout << indent << menu->name << std::endl;\n\n        // Recursively call showMenuList for each child\n        for (Menu* child : menu->children) {\n            showMenuList(child, layer + 1);\n        }\n\n        if (layer == 0) {\n            std::cout << std::endl;  // Print an extra line after all nodes are printed\n        }\n    }\n};\n\nint main() {\n    Menu* root = new Menu(\"Main Menu\");\n    Menu* fileMenu = new Menu(\"File\");\n    Menu* editMenu = new Menu(\"Edit\");\n    Menu* viewMenu = new Menu(\"View\");\n\n    root->addChild(fileMenu);\n    root->addChild(editMenu);\n    root->addChild(viewMenu);\n\n    fileMenu->addChild(new Menu(\"New\"));\n    fileMenu->addChild(new Menu(\"Open\"));\n    fileMenu->addChild(new Menu(\"Save\"));\n    fileMenu->addChild(new Menu(\"Exit\"));\n\n    editMenu->addChild(new Menu(\"Cut\"));\n    editMenu->addChild(new Menu(\"Copy\"));\n    editMenu->addChild(new Menu(\"Paste\"));\n\n    MenuFunctions functions;\n    functions.showMenuList(root, 0);\n\n    // Freeing memory (In a real application, use smart pointers instead of raw pointers)\n    delete root;\n    delete fileMenu;\n    delete editMenu;\n    delete viewMenu;\n\n    return 0;\n}", "CodeBleu_score": 34.34201826337848}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <random>\n#include <sstream>\n#include <iomanip>\n\nclass WiFiScan {\npublic:\n    struct SSIDInfo {\n        std::string ssid;\n        int channel;\n        std::string mac;\n    };\n\n    int generateSSIDs(int count);\n\nprivate:\n    std::string generateRandomSSID();\n    std::string generateRandomMAC();\n    int generateRandomChannel();\n};\n\nstd::string WiFiScan::generateRandomSSID() {\n    static const char alphanum[] =\n        \"0123456789\"\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefghijklmnopqrstuvwxyz\";\n    int len = sizeof(alphanum) - 1;\n    std::string ssid;\n    for (int i = 0; i < 6; i++)\n        ssid += alphanum[rand() % len];\n    return ssid;\n}\n\nstd::string WiFiScan::generateRandomMAC() {\n    std::ostringstream oss;\n    for(int i = 0; i < 6; i++) {\n        if (i != 0)\n            oss << \":\";\n        oss << std::hex << std::setw(2) << std::setfill('0') << (rand() % 256);\n    }\n    return oss.str();\n}\n\nint WiFiScan::generateRandomChannel() {\n    return rand() % 13 + 1;  // Assuming channels 1-13\n}\n\nint WiFiScan::generateSSIDs(int count) {\n    std::vector<SSIDInfo> ssids;\n    ssids.reserve(count);\n    for (int i = 0; i < count; i++) {\n        SSIDInfo info;\n        info.ssid = generateRandomSSID();\n        info.channel = generateRandomChannel();\n        info.mac = generateRandomMAC();\n        ssids.push_back(info);\n        std::cout << \"SSID: \" << info.ssid << \", Channel: \" << info.channel << \", MAC: \" << info.mac << std::endl;\n    }\n    return count;\n}", "CodeBleu_score": 40.73793058212869}, {"code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n\nclass WiFiScan {\npublic:\n    int generateSSIDs(int count);\n};\n\n// Helper function to generate a random MAC address\nstd::string generateRandomMAC() {\n    const char* hexDigits = \"0123456789ABCDEF\";\n    std::string macAddress;\n    for (int i = 0; i < 6; i++) {\n        macAddress += hexDigits[rand() % 16];\n        macAddress += hexDigits[rand() % 16];\n        if (i < 5) macAddress += \":\";\n    }\n    return macAddress;\n}\n\n// Helper function to generate a random SSID\nstd::string generateRandomSSID() {\n    std::string ssid;\n    for (int i = 0; i < 6; i++) {\n        ssid += (rand() % 26) + 'A'; // Generate random capital letter SSIDs\n    }\n    return ssid;\n}\n\nint WiFiScan::generateSSIDs(int count) {\n    std::srand(std::time(NULL));  // Seed the random number generator with current time\n    \n    std::vector<std::string> ssidList;\n    for (int i = 0; i < count; i++) {\n        std::string ssid = generateRandomSSID();\n        int channel = rand() % 13 + 1;  // Random channel between 1 and 13\n        std::string macAddress = generateRandomMAC();\n        \n        std::cout << \"SSID: \" << ssid << \", Channel: \" << channel << \", MAC: \" << macAddress << std::endl;\n        ssidList.push_back(ssid);\n    }\n    \n    return ssidList.size();  // Return the number of generated SSIDs\n}\n\n// Optionally this main function to test\nint main() {\n    WiFiScan scanner;\n    int generatedCount = scanner.generateSSIDs(5);\n    std::cout << \"Total SSIDs generated: \" << generatedCount << std::endl;\n    return 0;\n}", "CodeBleu_score": 39.84779742696575}, {"code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n  \nclass WiFiScan {\npublic:\n    // Function to generate a random string of a fixed length, assuming ASCII alphabetic characters\n    std::string randomSSID() {\n        const char charset[] =\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n            \"abcdefghijklmnopqrstuvwxyz\";\n        std::string ssid;\n        for (int i = 0; i < 6; ++i) {\n            ssid += charset[rand() % (sizeof(charset) - 1)];\n        }\n        return ssid;\n    }\n\n    // Function to generate a random MAC address\n    std::string randomMAC() {\n        char mac[18];\n        snprintf(mac, sizeof(mac), \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                 rand() % 256,\n                 rand() % 256,\n                 rand() % 256,\n                 rand() % 256,\n                 rand() % 256,\n                 rand() % 256);\n        return std::string(mac);\n    }\n\n    // Function to simulate WiFi scanning and generate SSIDs\n    int generateSSIDs(int count) {\n        srand(time(nullptr)); // Seed the random number generator\n\n        std::vector<std::string> ssids;\n        for (int i = 0; i < count; ++i) {\n            std::string ssid = randomSSID();\n            std::string mac = randomMAC();\n            int channel = rand() % 14 + 1; // Assuming WiFi channels 1-14\n\n            std::cout << \"SSID: \" << ssid << \"   Channel: \" << channel << \"   MAC: \" << mac << std::endl;\n            ssids.push_back(ssid);\n        }\n\n        return ssids.size();\n    }\n};", "CodeBleu_score": 37.639843315881805}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "from google.cloud import pubsub_v1\n\ndef create_topic(project_id, topic_name):\n    \"\"\"The function \"create_topic\" creates a new topic in Google Cloud Pub/Sub.\n    It initializes a PublisherClient, constructs the topic path using the provided project ID and topic name,\n    and creates the topic.\n    After successfully creating the topic, it prints a confirmation message with the topic details.\n\n    Args:\n        project_id (str): The Google Cloud project ID.\n        topic_name (str): The name of the topic to be created.\n\n    Returns:\n        None\n    \"\"\"\n    # Initialize a Publisher client\n    publisher = pubsub_v1.PublisherClient()\n    # Construct topic path\n    topic_path = publisher.topic_path(project_id, topic_name)\n    \n    # Create the topic\n    try:\n        topic = publisher.create_topic(request={\"name\": topic_path})\n        print(f\"Topic created: {topic.name}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return", "CodeBleu_score": 61.81632776821524}, {"code": "from google.cloud import pubsub_v1\n\ndef create_topic(project_id, topic_name):\n    \"\"\"The function \"create_topic\" creates a new topic in Google Cloud Pub/Sub.\n    It initializes a PublisherClient, constructs the topic path using the provided project ID\n    and topic name, and creates the topic.\n    After successfully creating the topic, it prints a confirmation message with the topic details.\"\"\"\n    \n    # Initialize a Publisher client\n    publisher = pubsub_v1.PublisherClient()\n    # Construct the full topic path\n    topic_path = publisher.topic_path(project_id, topic_name)\n    \n    try:\n        # Create the topic\n        topic = publisher.create_topic(request={\"name\": topic_path})\n        \n        # Print a confirmation with the topic details\n        print(f\"Topic created: {topic.name}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        raise\n\n# Example usage:\n# create_topic(\"your-gcp-project-id\", \"your-topic-name\")", "CodeBleu_score": 60.001715906812514}, {"code": "bash\npip install google-cloud-pubsub", "CodeBleu_score": 0.0}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "import jwt\nimport datetime\n\ndef create_jwt(project_id, private_key_file, algorithm):\n    \"\"\"\n    Generates a JSON Web Token (JWT) for authentication purposes.\n    It sets the issued time (iat) to the current UTC time and the expiration time (exp) to one hour later.\n    The audience (aud) field is set to the provided GCP project ID.\n    The private key is read from the specified file, and the JWT is created using the specified algorithm.\n    The function returns the encoded JWT.\n    \"\"\"\n    # Reading the private key from the file\n    with open(private_key_file, 'r') as key_file:\n        private_key = key_file.read()\n\n    # Preparing the claims (payload) of the JWT\n    now = datetime.datetime.utcnow()\n    payload = {\n        'iat': now,\n        'exp': now + datetime.timedelta(hours=1),\n        'aud': project_id\n    }\n\n    # Creating and returning the JWT\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n    return encoded_jwt\n\n# Example usage:\n# generate_jwt = create_jwt('your-project-id', 'path/to/your/private/key.pem', 'RS256')\n# print(generate_jwt)", "CodeBleu_score": 54.36836919746567}, {"code": "bash\npip install pyjwt[crypto]", "CodeBleu_score": 0.0}, {"code": "import jwt\nimport time\nfrom pathlib import Path\n\ndef create_jwt(project_id, private_key_file, algorithm):\n    \"\"\"\n    The function \"create_jwt\" generates a JSON Web Token (JWT) for authentication purposes.\n    It sets the issued time (iat) to the current UTC time and the expiration time (exp) to one hour later.\n    The audience (aud) field is set to the provided GCP project ID.\n    The private key is read from the specified file, and the JWT is created using the specified algorithm.\n    The function returns the encoded JWT.\n    \"\"\"\n    # Read the private key from a file\n    try:\n        with open(private_key_file, \"r\") as file:\n            private_key = file.read()\n    except IOError:\n        raise IOError(\"Unable to read the private key file.\")\n\n    # Prepare JWT claims\n    current_time = int(time.time())\n    claims = {\n        'iat': current_time,            # Issued at time\n        'exp': current_time + 3600,     # Expiration time (+1 hour)\n        'aud': project_id               # Audience (project ID)\n    }\n\n    # Encode the JWT using the loaded private key and specified algorithm\n    try:\n        encoded_jwt = jwt.encode(claims, private_key, algorithm=algorithm)\n    except Exception as e:\n        raise Exception(f\"Failed to encode JWT: {str(e)}\")\n\n    return encoded_jwt", "CodeBleu_score": 41.573151157335246}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "import paho.mqtt.client as mqtt\nimport boto3\nfrom picamera import PiCamera\nfrom io import BytesIO\nimport time\nimport os\n\n# Placeholder values\nBUCKET_NAME = \"your-bucket-name\"\nREGION = \"your-region\"\nAWS_ACCESS_KEY = \"your-aws-access-key\"\nAWS_SECRET_KEY = \"your-aws-secret-key\"\nTOPIC_IMAGE_URL = \"images/urls\"\n\ndef on_message(unused_client, unused_userdata, message):\n    \"\"\"The function \"on_message\" is a callback that handles incoming messages for a subscribed device.\n    It prints the received message's payload, topic, and QoS.\n    If the payload is \"on\", it captures a preview image, uploads the file to a specified bucket, and publishes the file's URL to an MQTT event topic.\n    If the payload is not \"on\", it simply prints \"off\".\"\"\"\n    print(f\"Received message '{message.payload.decode()}' on topic '{message.topic}' with QoS {message.qos}\")\n    \n    if message.payload.decode() == \"on\":\n        # Capturing image\n        camera = PiCamera()\n        stream = BytesIO()\n        \n        try:\n            camera.start_preview()\n            time.sleep(2)  # Camera warm-up time\n            camera.capture(stream, 'jpeg')\n        finally:\n            camera.close()\n        \n        stream.seek(0)\n        image_data = stream.read()\n        \n        # Uploading to S3\n        client = boto3.client(\n            's3',\n            region_name=REGION,\n            aws_access_key_id=AWS_ACCESS_KEY,\n            aws_secret_access_key=AWS_SECRET_KEY\n        )\n        file_name = f\"capture-{int(time.time())}.jpg\"\n        client.upload_fileobj(\n            BytesIO(image_data), \n            BUCKET_NAME, \n            file_name,\n            ExtraArgs={'ContentType': 'image/jpeg'}\n        )\n        \n        file_url = f\"https://{BUCKET_NAME}.s3.{REGION}.amazonaws.com/{file_name}\"\n        \n        # Publish URL to MQTT topic\n        unused_client.publish(TOPIC_IMAGE_URL, file_url)\n        \n        print(f\"Capture and upload successful. URL: {file_url}\")\n    elif message.payload.decode() == \"off\":\n        print(\"off\")", "CodeBleu_score": 32.08526639186535}, {"code": "import paho.mqtt.client as mqtt\nimport subprocess\nfrom google.cloud import storage\nimport uuid\n\ndef on_message(unused_client, unused_userdata, message):\n    \"\"\"\n    The function \"on_message\" is a callback that handles incoming messages for a subscribed device.\n    It prints the received message's payload, topic, and QoS.\n    If the payload is \"on\", it captures a preview image, uploads the file to a specified bucket, \n    and publishes the file's URL to an MQTT event topic.\n    If the payload is not \"on\", it simply prints \"off\".\n    \"\"\"\n    payload = message.payload.decode('utf-8')\n    topic = message.topic\n    qos = message.qos\n\n    print(f\"Received message payload: {payload}, topic: {topic}, QoS: {qos}\")\n\n    if payload == \"on\":\n        # Capture image using the camera, here assuming Raspberry Pi with camera module\n        image_filename = f\"capture_{uuid.uuid4()}.jpg\"\n        # Command to capture image using Raspberry Pi camera\n        subprocess.run(['raspistill', '-o', image_filename])\n        \n        # Setup Google Cloud Storage bucket info\n        bucket_name = \"your-bucket-name\"\n        client = storage.Client()\n        bucket = client.get_bucket(bucket_name)\n        blob = bucket.blob(image_filename)\n        \n        # Upload the captured image to the specified bucket\n        blob.upload_from_filename(image_filename)\n\n        # Formulate the public URL to the uploaded image\n        public_url = f\"https://storage.googleapis.com/{bucket_name}/{image_filename}\"\n        \n        # Publish the URL back to MQTT on a specific topic \n        event_topic = \"events/image_captured\"\n        unused_client.publish(event_topic, public_url, qos=1)\n\n        print(f\"Published image URL on MQTT topic '{event_topic}': {public_url}\")\n    else:\n        print(\"off\")\n\n# Note: You must configure and initialize the MQTT client elsewhere in your code", "CodeBleu_score": 38.103304883269125}, {"code": "import paho.mqtt.client as mqtt\nimport picamera\nimport boto3\nimport os\nfrom datetime import datetime\n\n# Dummy implementations for the unspecified functions and variables\ndef upload_file_to_bucket(file_path, bucket_name):\n    \"\"\"Simulate file upload to a specified AWS S3 bucket.\"\"\"\n    s3 = boto3.client('s3')\n    file_name = os.path.basename(file_path)\n    s3.upload_file(file_path, bucket_name, file_name)\n    return f'https://s3.amazonaws.com/{bucket_name}/{file_name}'\n\ndef publish_url_to_mqtt(url, topic, client):\n    \"\"\"Publish URL to an MQTT topic.\"\"\"\n    client.publish(topic, url)\n\ndef capture_image(file_path):\n    \"\"\"Capture an image and save it to the specified file path using the PiCamera.\"\"\"\n    with picamera.PiCamera() as camera:\n        camera.resolution = (1024, 768)\n        camera.capture(file_path)\n\n# Configuration constants\nBUCKET_NAME = 'your-bucket-name'  # AWS S3 Bucket name\nEVENT_TOPIC = 'your/event/topic'  # MQTT event topic where the URL will be published\nMQTT_BROKER = 'your-mqtt-broker-address'  # MQTT Broker Address\n\ndef on_message(unused_client, unused_userdata, message):\n    \"\"\"\n    The function \"on_message\" is a callback that handles incoming messages for a\n    subscribed device.\n    It prints the received message's payload, topic, and QoS.\n    If the payload is \"on\", it captures a preview image, uploads the file to a specified\n    bucket, and publishes the file's URL to an MQTT event topic.\n    If the payload is not \"on\", it simply prints \"off\".\n    \"\"\"\n    print(f\"Received message with topic: {message.topic}, QoS: {message.qos}\")\n    payload = message.payload.decode('utf-8')\n    print(f\"Payload: {payload}\")\n\n    if payload.lower() == \"on\":\n        # Capture image and store in a local file\n        timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")\n        file_path = f'/tmp/image_{timestamp}.jpg'\n        capture_image(file_path)\n        \n        # Upload the file to S3 and get the URL\n        url = upload_file_to_bucket(file_path, BUCKET_NAME)\n        \n        # Publish the URL to the MQTT event topic\n        publish_url_to_mqtt(url, EVENT_TOPIC, unused_client)\n        \n    elif payload.lower() == \"off\":\n        print(\"off\")", "CodeBleu_score": 34.22460478553239}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "import argparse\nimport os\n\ndef parse_command_line_args():\n    \"\"\"\n    The function \"parse_command_line_args\" parses command line arguments for a Google Cloud IoT MQTT device connection.\n    It requires the project ID and subscription name, with the project ID defaulting to the value of the \"GOOGLE_CLOUD_PROJECT\" environment variable if not provided.\n    It returns the parsed arguments.\n    \"\"\"\n    \n    # Create a parser object\n    parser = argparse.ArgumentParser(description=\"Parse command line arguments for Google Cloud IoT MQTT device connection.\")\n    \n    # Add project ID argument with a default value from environment variables\n    parser.add_argument('--project_id', default=os.getenv('GOOGLE_CLOUD_PROJECT'),\n                        help='Your Google Cloud project ID (defaults to the GOOGLE_CLOUD_PROJECT environment variable).')\n    \n    # Add subscription name argument\n    parser.add_argument('--subscription_name', required=True,\n                        help='Subscription name for the Google Cloud Pub/Sub to receive messages.')\n    \n    # Parse the arguments passed to the command line\n    args = parser.parse_args()\n    \n    # Return the parsed arguments\n    return args\n\n# Example usage (for demonstration/verification purposes may be removed or commented out):\n# if __name__ == \"__main__\":\n#     args = parse_command_line_args()\n#     print(f'Project ID: {args.project_id}')\n#     print(f'Subscription Name: {args.subscription_name}')", "CodeBleu_score": 60.275024977409}, {"code": "import argparse\nimport os\n\ndef parse_command_line_args():\n    \"\"\"\n    The function \"parse_command_line_args\" parses command line arguments for a Google Cloud IoT MQTT device connection.\n    It requires the project ID and subscription name, with the project ID defaulting to the value of the \"GOOGLE_CLOUD_PROJECT\" \n    environment variable if not provided.\n    It returns the parsed arguments.\n    \"\"\"\n    \n    # Create an ArgumentParser object\n    parser = argparse.ArgumentParser(description='Parse command line arguments for Google Cloud IoT MQTT device connection.')\n    \n    # Add arguments to the parser\n    # Project ID, defaults to GOOGLE_CLOUD_PROJECT environment variable if not explicitly provided\n    default_project_id = os.getenv('GOOGLE_CLOUD_PROJECT', None)\n    parser.add_argument('-p', '--project_id', default=default_project_id, required=default_project_id is None, \n                        help='Google Cloud Project ID (default: GOOGLE_CLOUD_PROJECT environment variable)')\n    \n    # Subscription name (optional)\n    parser.add_argument('-s', '--subscription', required=True,\n                        help='Subscription name')\n\n    # Parse the arguments\n    args = parser.parse_args()\n    \n    # Return the parsed arguments\n    return args\n\n# Usage example (this line would be outside of the function in your actual script)\n# if __name__ == '__main__':\n#    parsed_args = parse_command_line_args()\n#    print(parsed_args)", "CodeBleu_score": 51.66780518186804}, {"code": "import argparse\nimport os\n\ndef parse_command_line_args():\n    \"\"\"\n    Parses command line arguments for a Google Cloud IoT MQTT device connection.\n    \n    Requires the project ID and subscription name, with the project ID defaulting to\n    the value of the \"GOOGLE_CLOUD_PROJECT\" environment variable if not provided.\n    \n    Returns:\n        argparse.Namespace: The parsed arguments, including project_id and subscription_name.\n    \"\"\"\n    # Create the argument parser\n    parser = argparse.ArgumentParser(description='Parse command line arguments for Google Cloud IoT MQTT device connection.')\n    \n    # Get default project id from environment variable\n    default_project_id = os.getenv('GOOGLE_CLOUD_PROJECT')\n    \n    # Add arguments to the parser\n    parser.add_argument('--project_id', default=default_project_id, required=(default_project_id is None),\n                        help='Google Cloud project ID. Defaults to the GOOGLE_CLOUD_PROJECT environment variable.')\n    parser.add_argument('--subscription_name', required=True, \n                        help='Subscription name for the MQTT device connection.')\n    \n    # Parse the arguments\n    args = parser.parse_args()\n    \n    return args", "CodeBleu_score": 54.44335776327589}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "from google.oauth2 import service_account\nfrom googleapiclient.discovery import build\n\ndef get_client(service_account_json):\n    \"\"\"\n    The function \"get_client\" creates and returns a client for the Google Cloud IoT Core service.\n    It takes a path to a service account JSON file as input and defines the necessary API scopes, version,\n    and discovery URL. It then loads the service account credentials, scopes them appropriately,\n    and uses them to build and return the client for the Cloud IoT Core service using the discovery API URL.\n    \"\"\"\n    # Define the API-specific details\n    api_name = 'cloudiot'\n    api_version = 'v1'\n    discovery_url = f'https://cloudiot.googleapis.com/$discovery/rest?version={api_version}'\n\n    # Define the scopes required by the API\n    scopes = ['https://www.googleapis.com/auth/cloud-platform']\n\n    # Load the service account credentials from the JSON file\n    credentials = service_account.Credentials.from_service_account_file(\n        service_account_json,\n        scopes=scopes\n    )\n\n    # Build and return the client\n    client = build(api_name, api_version, credentials=credentials, discoveryServiceUrl=discovery_url)\n    return client", "CodeBleu_score": 50.9996807526918}, {"code": "bash\npip install google-auth google-auth-httplib2 google-api-python-client", "CodeBleu_score": 0.6410294430979018}, {"code": "bash\npip install google-api-python-client google-auth", "CodeBleu_score": 0.6410256410256615}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "bash\npip install cryptography", "CodeBleu_score": 0.0}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\nimport hashlib\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import pkcs1_15\n\ndef sign_hash(hash_value, priv_key, hash_method):\n    \"\"\"\n    The function \"sign_hash\" signs a given hash value using a specified private key and hash method.\n    It first retrieves the ASN1 code for the hash method and raises an error if the hash method is invalid.\n    It then concatenates the ASN1 code with the hash value, pads the result for signing, and encrypts the padded hash using the private key.\n    The function returns the encrypted signature as a byte block.\n    \n    :param hash_value: A bytes object representing the hash that needs to be signed.\n    :param priv_key: A RSA key object (from Crypto.PublicKey.RSA) representing the private key to use for signing.\n    :param hash_method: A string representing the hash method used (e.g., 'SHA256').\n    :return: A bytes object representing the encrypted signature.\n    \"\"\"\n    \n    # Map of hash methods to their respective hash class in the hashlib library\n    hash_methods = {\n        'SHA1': hashlib.sha1,\n        'SHA256': hashlib.sha256,\n        'SHA384': hashlib.sha384,\n        'SHA512': hashlib.sha512,\n    }\n    \n    # Retrieve the hash class based on user input and raise an error if the hash method is not found\n    if hash_method not in hash_methods:\n        raise ValueError(f\"Unsupported hash method: {hash_method}\")\n        \n    # Get the hash class for the chosen hash method\n    hash_class = hash_methods[hash_method]\n    \n    # Create a hash object\n    hasher = hash_class()\n    \n    # Assuming the hash_value is already calculated, directly use it to get the digest\n    digest = hasher.new(hash_value)\n    \n    # Create a signer object\n    signer = pkcs1_15.new(priv_key)\n    \n    # Sign the digest\n    signature = signer.sign(digest)\n    \n    # Return the signature\n    return signature\n\n# Note: This function assumes that the hash_value is already the correct byte sequence for the hash method. \n# The user needs to generate the private key and get the hash value before calling this function. \n\n# Example usage:\n# from Crypto.PublicKey import RSA\n# key = RSA.generate(2048)\n# data = b\"Hello, world!\"\n# hashed_data = hashlib.sha256(data).digest()\n# print(sign_hash(hashed_data, key, 'SHA256'))", "CodeBleu_score": 38.885373864868896}, {"code": "pip install cryptography", "CodeBleu_score": 0.0}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "from cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey\nfrom cryptography.exceptions import InvalidSignature\n\n\ndef verify(message, signature, pub_key):\n    \"\"\"\n    The function \"verify\" checks the validity of a signature for a given message using a public key.\n    It converts the signature to an integer and decrypts it to obtain the clear signature.\n    The function then determines the hash method used, computes the hash of the message, and reconstructs the expected padded hash.\n    If the expected padded hash does not match the clear signature, it raises a verification error.\n    If the verification is successful, it returns the hash method name.\n\n    :param message: bytes, the original message that was signed.\n    :param signature: bytes, the signature that needs to be verified.\n    :param pub_key: RSAPublicKey, the public key used for verification.\n    :return: str, the name of the hash method used in creating the signature.\n    :raises: ValueError if the signature verification fails.\n    \"\"\"\n    \n    # Typical hash algorithms used in PKCS#1 v1.5\n    hash_algorithms = {\n        hashes.SHA256: \"SHA-256\",\n        hashes.SHA384: \"SHA-384\",\n        hashes.SHA512: \"SHA-512\",\n        hashes.SHA1: \"SHA-1\"\n    }\n\n    for hash_algo, hash_name in hash_algorithms.items():\n        try:\n            # Attempt verification with each hash algorithm\n            pub_key.verify(\n                signature,\n                message,\n                padding.PKCS1v15(),\n                hash_algo()\n            )\n            # If verification is successful, return the hash method name\n            return hash_name\n        except InvalidSignature:\n            continue  # Try the next algorithm\n\n    # If none of the hash algorithms succeeded, raise a verification error\n    raise ValueError(\"Signature verification failed\")", "CodeBleu_score": 22.40067021306581}, {"code": "from cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import load_pem_public_key\nfrom cryptography.exceptions import InvalidSignature\n\ndef verify(message, signature, pub_key):\n    \"\"\"\n    The function \"verify\" checks the validity of a signature for a given message using a public key.\n    It converts the signature to an integer and decrypts it to obtain the clear signature.\n    The function then determines the hash method used, computes the hash of the message, \n    and reconstructs the expected padded hash.\n    If the expected padded hash does not match the clear signature, it raises a verification error.\n    If the verification is successful, it returns the hash method name.\n    \n    Args:\n    - message (bytes): The original message that was presumably signed.\n    - signature (bytes): The signature to be verified.\n    - pub_key (bytes): The PEM-encoded public key used for verifying the signature.\n\n    Returns:\n    - str: Name of the hash method used if the verification is successful.\n\n    Raises:\n    - ValueError: If the verification fails.\n    \"\"\"\n\n    # Load the public key\n    public_key = load_pem_public_key(pub_key)\n\n    # Attempt to verify the signature\n    try:\n        # As stated before, we'll use PKCS#1 v1.5 and SHA-256\n        public_key.verify(\n            signature,\n            message,\n            padding.PKCS1v15(),\n            hashes.SHA256()\n        )\n    except InvalidSignature:\n        raise ValueError(\"Invalid signature.\")\n\n    return \"SHA-256\"\n\n# Example usage:\n# Assuming you have `public_key` and `signature` in PEM format and bytes respectively.\n# message = b\"Your message here\"\n# signature = b'signature in bytes'\n# pub_key = b'''-----BEGIN PUBLIC KEY-----\n# MIIBIjANBgkqhkiG9w...\n# -----END PUBLIC KEY-----'''\n# print(verify(message, signature, pub_key))", "CodeBleu_score": 22.137225221470924}, {"code": "from cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.serialization import load_pem_public_key\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nimport cryptography.exceptions\n\ndef verify(message, signature, pub_key):\n    \"\"\"\n    The function \"verify\" checks the validity of a signature for a given message using a public key.\n    It converts the signature to an integer and decrypts it to obtain the clear signature.\n    The function then determines the hash method used, computes the hash of the message, and reconstructs the expected padded hash.\n    If the expected padded hash does not match the clear signature, it raises a verification error.\n    If the verification is successful, it returns the hash method name.\n    \n    Args:\n    message (bytes): The original message that was signed.\n    signature (bytes): The signature of the message.\n    pub_key (bytes): The public key used for verification in PEM format.\n\n    Returns:\n    str: The hash method name used in signing.\n    \"\"\"\n    # Load the public key\n    public_key = load_pem_public_key(pub_key)\n\n    # Try different hash algorithms\n    hash_algorithms = [\n        hashes.SHA256(),\n        hashes.SHA384(),\n        hashes.SHA512(),\n        hashes.SHA3_256(),\n        hashes.SHA3_384(),\n        hashes.SHA3_512()\n    ]\n    \n    # Initialize flag to track successful verification\n    verified = False\n    used_hash_algo = \"\"\n\n    for hash_algo in hash_algorithms:\n        try:\n            # Attempt to verify the signature\n            public_key.verify(\n                signature,\n                message,\n                padding.PSS(\n                    mgf=padding.MGF1(hash_algo),\n                    salt_length=padding.PSS.MAX_LENGTH\n                ),\n                hash_algo\n            )\n            verified = True\n            used_hash_algo = hash_algo.name\n            break\n        except (cryptography.exceptions.InvalidSignature, ValueError):\n            continue\n\n    if verified:\n        return used_hash_algo\n    else:\n        raise ValueError(\"Verification failed! The signature could not be verified.\")\n\n# Example usage:\n# Requires `message`, `signature`, and `pub_key` in the appropriate binary format.\n# print(verify(b\"your message here\", b\"signature in bytes\", b\"public key in pem format\"))", "CodeBleu_score": 28.69857508150835}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "#include <stdio.h>\n#include <time.h>\n\n// Mock functions provided for simulation purposes\nvoid updateJWT(char* tokenString);\nvoid MQTTconnect();\nextern int mqttSubscribeFlag;  // This is defined somewhere else in your codebase\n\n// Prints current time and if valid, updates JWT and connects to MQTT\nstatic void connectMQTT() {\n    // Retrieve the current time\n    time_t currentTime = time(NULL);\n\n    if (currentTime == -1) {\n        // Error in retrieving time\n        printf(\"Failed to get the current time\\n\");\n        return;\n    }\n\n    // Assuming updateJWT accepts a unix time formatted token string\n    char tokenString[256];\n    snprintf(tokenString, sizeof(tokenString), \"%ld\", currentTime);\n    updateJWT(tokenString);\n\n    // Connect to MQTT client\n    MQTTconnect();\n    \n    // Set the flag to send an MQTT SUBSCRIBE packet after successful connection\n    mqttSubscribeFlag = 1;\n\n    // Print debug message\n    printf(\"Attempting to connect to MQTT with token: %s\\n\", tokenString);\n}", "CodeBleu_score": 48.44854395982323}, {"code": "#include <stdio.h>\n#include <time.h>\n\n// Simulated external API functions and variables\nextern void updateJWT(int currentUnixTime);\nextern void connectMQTTClient();\nextern int mqttSubscribeFlag;\n\n// Gets the current Unix time, if possible\nstatic int getCurrentUnixTime() {\n    time_t currentTime = time(NULL);\n    if (currentTime == ((time_t)-1)) {\n        // Handle error, if getting the time fails\n        perror(\"Failed to get the current time\");\n        return -1;\n    }\n    return (int)currentTime;\n}\n\n// Function to establish an MQTT connection\nstatic void connectMQTT() {\n    // Retrieve the current UNIX time\n    int unixTime = getCurrentUnixTime();\n    if (unixTime == -1) {\n        printf(\"Unable to get the current UNIX time. Connection attempt aborted.\\n\");\n        return;\n    }\n    \n    // Update the JWT using the current UNIX time\n    updateJWT(unixTime);\n    \n    // Connect to the MQTT client\n    connectMQTTClient();\n    \n    // Set the flag for MQTT SUBSCRIBE packet\n    mqttSubscribeFlag = 1;\n    \n    // Debug message indicating an MQTT connection attempt\n    printf(\"Attempting to connect to MQTT with updated JWT.\\n\");\n}", "CodeBleu_score": 50.01248797186098}, {"code": "#include <time.h>\n#include <stdio.h>\n\n// Function prototypes for assumed external or previous defined functions\nvoid updateJWT(long currentTime);\nvoid MQTTConnect();\nextern int sendMQTTPacket();\n\nstatic void connectMQTT() {\n    // Retrieve the current time\n    time_t currentTime = time(NULL);\n\n    // Check if the time retrieval was successful\n    if (currentTime != -1) {\n        // Update JWT using the current UNIX time\n        updateJWT(currentTime);\n\n        // Connect to the MQTT client\n        MQTTConnect();\n        \n        // Set flag to send MQTT SUBSCRIBE packet\n        int sendResult = sendMQTTPacket();\n        if (sendResult == 0) {\n            printf(\"MQTT SUBSCRIBE packet sent successfully.\\n\");\n        } else {\n            printf(\"Failed to send MQTT SUBSCRIBE packet.\\n\");\n        }\n    } else {\n        printf(\"Failed to retrieve current time, MQTT connection not attempted.\\n\");\n    }\n\n    // Print debug message indicating the MQTT connection attempt\n    printf(\"Attempting MQTT connection...\\n\");\n}", "CodeBleu_score": 47.18662203293128}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "#include <stdint.h>\n#include <limits.h>\n\n/*\n * The function \"str_to_uint\" converts a string of digits into an unsigned integer.\n * It takes a string pointer, the width of the string, and a pointer to store the resulting number.\n * It checks each character to ensure it is a digit and calculates the numeric value.\n * If the string contains non-digit characters or represents a number too large to handle, it returns the original string pointer as an error indicator.\n * If successful, it returns a pointer to the position just past the processed digits.\n */\nstatic const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num) {\n    const uint8_t* end = str + width;\n    *num = 0; // Initialize the number to 0.\n    \n    for (const uint8_t* p = str; p < end; p++) {\n        if (*p < '0' || *p > '9') {  // Check if the character is a digit\n            return str; // Return the original string pointer if non-digit is found.\n        }\n        \n        uint32_t next_digit = *p - '0';\n        \n        // Check for overflow conditions before multiplication and addition\n        if (*num > UINT32_MAX / 10 || (*num == UINT32_MAX / 10 && next_digit > UINT32_MAX % 10)) {\n            return str; // Return the original pointer if the number would overflow.\n        }\n        \n        *num = *num * 10 + next_digit; // Multiply by 10 and add the current digit.\n    }\n    \n    return end; // Return the pointer just past the last processed digit.\n}", "CodeBleu_score": 48.21387391821652}, {"code": "#include <stdint.h>\n#include <limits.h>\n\nstatic const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num) {\n    uint32_t result = 0;\n    const uint8_t* end = str + width;\n\n    for (const uint8_t* ptr = str; ptr < end; ptr++) {\n        // Check if the character is a numeric digit\n        if (*ptr < '0' || *ptr > '9') {\n            return str;  // Error: non-digit character found\n        }\n\n        // Convert character to decimal digit\n        uint8_t digit = *ptr - '0';\n\n        // Check for potential overflow\n        if (result > (UINT32_MAX / 10) || (result == UINT32_MAX / 10 && digit > UINT32_MAX % 10)) {\n            return str;  // Error: number would overflow\n        }\n\n        // Update the result\n        result = result * 10 + digit;\n    }\n\n    // Assign the result to the output variable\n    *num = result;\n\n    // Return the pointer position just past the last processed digit\n    return end;\n}", "CodeBleu_score": 41.85367739543339}, {"code": "#include <stdint.h>\n#include <ctype.h>\n\n/*\n * The function \"str_to_uint\" converts a string of digits into an unsigned integer.\n * It takes a string pointer, the width of the string, and a pointer to store the resulting number.\n * It checks each character to ensure it is a digit and calculates the numeric value.\n * If the string contains non-digit characters or represents a number too large to handle, it returns the original string pointer as an error indicator.\n * If successful, it returns a pointer to the position just past the processed digits.\n */\nstatic const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num) {\n    const uint8_t* ptr = str;\n    *num = 0; // Initialize result number\n    \n    for (int i = 0; i < width; ++i) {\n        // Check current character is a digit\n        if (!isdigit(ptr[i])) {\n            return str; // Not a valid digit, return original string pointer\n        }\n        \n        // Append to number\n        uint32_t next_num = *num * 10 + (ptr[i] - '0');\n        \n        // Check for overflow\n        if (next_num < *num) {\n            return str; // If overflow occurs, return original string pointer\n        }\n        \n        *num = next_num;\n    }\n\n    // Successfully processed all digits, return position just past the last processed digit\n    return ptr + width;\n}", "CodeBleu_score": 36.135102379977944}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "#include <stdio.h>\n#include <string.h>\n\n// Definition for the timestamp structure\ntypedef struct {\n    int tm_sec;   // seconds\n    int tm_min;   // minutes\n    int tm_hour;  // hours\n    int tm_mday;  // day of the month\n    int tm_mon;   // month (Note: January = 0)\n    int tm_year;  // year (year since 1900)\n} atcacert_tm_utc_t;\n\n#define RFC5280_UTC_TIME_LENGTH 13 // yyMMddHHmmssZ\n\n// Error codes\n#define ATCACERT_E_SUCCESS 0\n#define ATCACERT_E_DECODING_ERROR -1\n#define ATCACERT_E_INVALID_DATE -2\n\n/**\n * Decodes RFC5280 UTC formatted date string into a atcacert_tm_utc_t structure.\n * \n * @param date Input date string in RFC5280 UTC time (YYMMDDHHMMSSZ)\n * @param tm A pointer to a timestamp structure to fill\n * @return 0 on success, otherwise a negative error code\n */\nint atcacert_date_dec_rfc5280_utc(const char* date, atcacert_tm_utc_t* tm) {\n    if (strlen(date) != RFC5280_UTC_TIME_LENGTH || date[RFC5280_UTC_TIME_LENGTH - 1] != 'Z') {\n        return ATCACERT_E_INVALID_DATE;\n    }\n\n    int year, month, day, hour, minute, second;\n\n    // Scan the input string into the respective date and time parts\n    if (sscanf(date, \"%2d%2d%2d%2d%2d%2dZ\", &year, &month, &day, &hour, &minute, &second) != 6) {\n        return ATCACERT_E_DECODING_ERROR;\n    }\n\n    tm->tm_sec = second;\n    tm->tm_min = minute;\n    tm->tm_hour = hour;\n    tm->tm_mday = day;\n    tm->tm_mon = month - 1;  // TM structure expects month in range 0-11\n    if (year < 50) {\n        tm->tm_year = 2000 + year - 1900;\n    } else {\n        tm->tm_year = 1900 + year - 1900;\n    }\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 36.32647179263214}, {"code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define SUCCESS 0\n#define ERROR_INVALID_FORMAT -1\n#define ERROR_DECODING -2\n\ntypedef struct {\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n} timestamp_t;\n\nint atcacert_date_dec_rfc5280_utc(const char* date_str, timestamp_t* timestamp) {\n    if (date_str == NULL || timestamp == NULL) {\n        return ERROR_INVALID_FORMAT;\n    }\n\n    if (sscanf(date_str, \"%2d%2d%2d%2d%2d%2dZ\",\n               &timestamp->year, &timestamp->month, &timestamp->day,\n               &timestamp->hour, &timestamp->minute, &timestamp->second) != 6) {\n        return ERROR_DECODING;\n    }\n\n    // Convert 2-digit year to 4-digits (RFC 5280 rule)\n    if (timestamp->year < 50) {\n        timestamp->year += 2000;\n    } else {\n        timestamp->year += 1900;\n    }\n\n    // Further validations can be added if needed (e.g., valid month, day-of-month)\n\n    return SUCCESS;\n}", "CodeBleu_score": 39.97629517726018}, {"code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define ATCACERT_E_SUCCESS 0\n#define ATCACERT_E_DECODING_ERROR -1\n\ntypedef struct {\n    int tm_year;\n    int tm_mon;\n    int tm_mday;\n    int tm_hour;\n    int tm_min;\n    int tm_sec;\n} atcacert_tm_utc_t;\n\n/*\n * Decodes a date in RFC5280 UTC format into a timestamp structure.\n * Inputs:\n * - formatted_date: Date in \"YYMMDDHHMMSSZ\" format\n * - timestamp: Pointer to the timestamp structure to populate\n * Returns:\n * - 0 on success\n * - Negative error code on failure\n */\nint atcacert_date_dec_rfc5280_utc(const char* formatted_date, atcacert_tm_utc_t* timestamp) {\n    int year, month, day, hour, minute, second;\n\n    if (strlen(formatted_date) != 13 || formatted_date[12] != 'Z') \n        return ATCACERT_E_DECODING_ERROR;\n\n    /* Convert each component. If any part fail, return an error code. */\n    if (sscanf(formatted_date, \"%2d%2d%2d%2d%2d%2dZ\", &year, &month, &day, &hour, &minute, &second) != 6)\n        return ATCACERT_E_DECODING_ERROR;\n    \n    /* Adjust the year to be fully qualified */\n    year += (year < 50) ? 2000 : 1900;\n\n    /* Initialize the timestamp structure with the converted values */\n    timestamp->tm_year = year;\n    timestamp->tm_mon = month;\n    timestamp->tm_mday = day;\n    timestamp->tm_hour = hour;\n    timestamp->tm_min = minute;\n    timestamp->tm_sec = second;\n\n    return ATCACERT_E_SUCCESS;\n}", "CodeBleu_score": 36.23515160716528}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "#include <stdint.h>\n#include <stddef.h>\n\n#define SUCCESS 0\n#define ERR_NULL_PARAMETER -1\n#define ERR_INVALID_SIGNATURE -2\n#define ERR_VERIFY_FAILED -3\n\ntypedef struct {\n    // This represents some structure relevant to your certificate\n    // For the purpose of this example, it's kept abstract\n    int dummy;\n} atcacert_def_t;\n\n// Dummy external functions to represent possible existing utilities.\nint get_tbs_digest(const atcacert_def_t* cert_def, const uint8_t* cert, size_t cert_size, uint8_t digest[32]) {\n    // Supposed to extract and hash TBS part of the certificate\n    // Placeholder functionality\n    return SUCCESS;\n}\n\nint get_signature(const atcacert_def_t* cert_def, const uint8_t* cert, size_t cert_size, uint8_t signature[64]) {\n    // Supposed to extract signature from the certificate\n    // Placeholder functionality\n    return SUCCESS;\n}\n\nint verify_signature(const uint8_t* digest, const uint8_t* signature, const uint8_t public_key[64]) {\n    // Supposed to verify the signature using the public key\n    // Placeholder functionality\n    return SUCCESS;\n}\n\nint atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]) {\n    if (!cert_def || !cert || !ca_public_key) {\n        return ERR_NULL_PARAMETER;\n    }\n\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    // Retrieve the TBS (To-Be-Signed) digest\n    int ret = get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != SUCCESS) {\n        return ret;\n    }\n\n    // Retrieve the certificate's signature\n    ret = get_signature(cert_def, cert, cert_size, signature);\n    if (ret != SUCCESS) {\n        return ret;\n    }\n\n    // Verify the TBS digest against the signature\n    ret = verify_signature(tbs_digest, signature, ca_public_key);\n    if (ret != SUCCESS) {\n        return ERR_VERIFY_FAILED;\n    }\n\n    return SUCCESS; // Verification successful\n}", "CodeBleu_score": 56.95305516721587}, {"code": "#include <stdio.h>\n\n// Error codes\n#define ATCACERT_SUCCESS 0\n#define ATCACERT_INVALID_PARAM -1\n#define ATCACERT_VERIFY_FAILED -2\n\n// Note: Imitating necessary function stubs and types\ntypedef struct {\n    // cert definition struct\n    int tbs_offset; //example member: offset to to-be-signed area\n    int tbs_length; //example member: length of to-be-signed area\n    int sig_offset; //example member: offset to the signature in the certificate\n    int sig_length; //example member: length of the signature\n} atcacert_def_t;\n\n// Placeholder implementations for needed cryptographic functions\nint hw_verify(const uint8_t *digest, size_t digest_len, const uint8_t *signature, size_t sig_len, const uint8_t ca_public_key[64]) {\n    // Placeholder for the hardware-specific signature verification API\n    // Returns 0 if verified successfully, non-zero otherwise\n    // This should connect to hardware cryptography module\n    return 0; // Assume verification always successful for this stub\n}\n\nint get_digest(const uint8_t *data, size_t data_len, uint8_t *digest) {\n    // Compute a cryptographic hash. Placeholder only.\n    for (size_t i = 0; i < data_len && i < 32; ++i)\n        digest[i] = data[i]; // Dummy hash\n    return 0; // Always successful in this stub\n}\n\n// Main function to verify the certificate using hardware acceleration\nint atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]) {\n    if (!cert_def || !cert || cert_size == 0 || !ca_public_key) {\n        return ATCACERT_INVALID_PARAM;\n    }\n\n    // Extract the To-Be-Signed (TBS) part of the certificate\n    if (cert_def->tbs_offset + cert_def->tbs_length > cert_size) {\n        return ATCACERT_INVALID_PARAM; // Out of bounds check\n    }\n    const uint8_t *tbs_ptr = cert + cert_def->tbs_offset;\n\n    // Extract the signature from the certificate\n    if (cert_def->sig_offset + cert_def->sig_length > cert_size) {\n        return ATCACERT_INVALID_PARAM; // Out of bounds check\n    }\n    const uint8_t *signature = cert + cert_def->sig_offset;\n\n    // Compute digest\n    uint8_t digest[32]; // Assuming a SHA-256 for the sake of example\n    int result = get_digest(tbs_ptr, cert_def->tbs_length, digest);\n    if (result != 0) {\n        return ATCACERT_VERIFY_FAILED; // Unable to compute digest\n    }\n\n    // Verify the signature\n    result = hw_verify(digest, sizeof(digest), signature, cert_def->sig_length, ca_public_key);\n    if (result != 0) {\n        return ATCACERT_VERIFY_FAILED; // Signature verification failed\n    }\n\n    return ATCACERT_SUCCESS;\n}", "CodeBleu_score": 31.588106098893693}, {"code": "#include <stddef.h>\n#include <stdint.h>\n#include <string.h>  // To include necessary functions like memcmp.\n#include \"atcacert_def_t.h\"  // Assume this is the header for certificate definitions.\n\n// Error codes\n#define ATCACERT_VERIFY_SUCCESS 0\n#define ATCACERT_VERIFY_FAIL -1\n#define ATCACERT_BAD_INPUT_ERROR -2\n\n// Dummy functions to represent the hardware acceleration features.\n// Should be replaced with real hardware-accelerated cryptographic function calls.\nint hw_verify_signature(const uint8_t *digest, size_t digest_len, const uint8_t *signature, size_t signature_len, const uint8_t *public_key) {\n    // Simulation of hardware-accelerated signature verification\n    // This function should be implemented for real-world uses\n    return 0; // Success\n}\n\nint get_tbs_digest(const uint8_t* cert, size_t cert_size, uint8_t* out_digest, size_t* out_digest_len) {\n    // Simulation of extracting and digesting the TBS (To Be Signed) part of a certificate\n    // Fill `out_digest` with the calculated hash and set `out_digest_len` appropriately.\n    return 0; // Success\n}\n\nint atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64]) {\n    // Check for null inputs\n    if (!cert_def || !cert || !ca_public_key) {\n        return ATCACERT_BAD_INPUT_ERROR;\n    }\n\n    // Extract TBS digest\n    uint8_t tbs_digest[32]; // Assuming SHA-256 digests\n    size_t digest_len = sizeof(tbs_digest);\n    int ret = get_tbs_digest(cert, cert_size, tbs_digest, &digest_len);\n    if (ret != 0) {\n        return ATCACERT_VERIFY_FAIL; // Failed to get TBS digest\n    }\n\n    // Extract signature from the certificate (this would actually depend heavily on the format of the certificate)\n    uint8_t signature[64]; // Assuming an ECC P-256 signature\n    size_t signature_len = sizeof(signature);\n    memcpy(signature, cert + cert_size - signature_len, signature_len); // Simplified assumption about certificate structure\n\n    // Verify the signature using hardware acceleration\n    ret = hw_verify_signature(tbs_digest, digest_len, signature, signature_len, ca_public_key);\n    if (ret != 0) {\n        return ATCACERT_VERIFY_FAIL; // Signature verification failed\n    }\n\n    return ATCACERT_VERIFY_SUCCESS; // Successfully verified\n}", "CodeBleu_score": 40.08347752170345}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "#include <stdbool.h>\n\ntypedef struct timerStruct_t {\n    struct timerStruct_t* next; // Next timer in the list\n} timerStruct_t;\n\n/* \n * Deletes a timer from a given timer list.\n *\n * Parameters:\n * list - Pointer to the head of the timer list\n * timer - Timer to be deleted from the list\n * \n * Returns:\n * true if the timer was successfully deleted,\n * false if the timer was not found in the list.\n */\nbool timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer) {\n    if (list == NULL || *list == NULL || timer == NULL) {\n        return false; // Null pointer given as input\n    }\n\n    timerStruct_t * volatile *curr = list;\n    while (*curr != NULL) {\n        if (*curr == timer) {\n            *curr = (*curr)->next; // Remove the timer from the list\n            return true;\n        }\n        curr = &((*curr)->next); // Move to the next element in the list\n    }\n\n    return false; // Timer not found in the list\n}", "CodeBleu_score": 28.567399150483823}, {"code": "#include <stdbool.h>\n#include <stddef.h>\n\ntypedef struct timerStruct {\n    struct timerStruct* next;\n} timerStruct_t;\n\n/**\n * Removes a timer from a linked list.\n * \n * @param list A double pointer to the head of the timer list.\n * @param timer The timer to remove from the list.\n * @return true if the timer was successfully removed, false otherwise.\n */\nbool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer) \n{\n    if (list == NULL || *list == NULL || timer == NULL) {\n        return false; // Null pointers, return false since deletion isn't possible.\n    }\n    \n    timerStruct_t *current = *list;\n    timerStruct_t *prev = NULL;\n\n    while (current != NULL) {\n        if (current == timer) {\n            if (prev == NULL) {\n                // Timer is the first in the list.\n                *list = current->next;\n            } else {\n                // Timer is in the middle or end of the list.\n                prev->next = current->next;\n            }\n            return true;\n        }\n        prev = current;\n        current = current->next;\n    }\n\n    return false; // Timer wasn't found in the list.\n}", "CodeBleu_score": 46.089419028949166}, {"code": "#include <stdbool.h>\n#include <string.h>\n#include <stdint.h>\n\ntypedef struct {\n    uint8_t *ca_pub_key;\n    uint8_t *certificate;\n    size_t size;\n} CertInfo;\n\n// Mock cryptographic functions\nint get_tbs_digest(uint8_t *cert, size_t size, uint8_t *digest, size_t *digest_len) {\n    // Just a placeholder as the actual implementation depends on specific cryptographic library\n    return 0;\n}\n\nint verify_signature(uint8_t *digest, size_t digest_len, uint8_t *signature, size_t signature_len, uint8_t *pub_key) {\n    // Placeholder\n    return 0;\n}\n\n// Error codes\n#define ERR_NULL_PARAM -1\n#define ERR_VERIFICATION_FAILED -2\n#define SUCCESS 0\n\nint atcacert_verify_cert_hw(CertInfo *cert_info) {\n    if (cert_info == NULL || cert_info->ca_pub_key == NULL || cert_info->certificate == NULL) {\n        return ERR_NULL_PARAM;\n    }\n\n    uint8_t digest[32];  // Adjust size according to expected hash size e.g., SHA-256\n    size_t digest_len = sizeof(digest);\n    int err = get_tbs_digest(cert_info->certificate, cert_info->size, digest, &digest_len);\n    if (err != 0) {\n        return err;\n    }\n\n    // Assuming signature is at the end of the certificate and has a fixed size (Example)\n    uint8_t *signature = cert_info->certificate + cert_info->size - 64;\n    size_t signature_len = 64;  // Example signature length: e.g., ECDSA using P-256\n\n    err = verify_signature(digest, digest_len, signature, signature_len, cert_info->ca_pub_key);\n    if (err != 0) {\n        return ERR_VERIFICATION_FAILED;\n    }\n\n    return SUCCESS;\n}", "CodeBleu_score": 34.91784910827484}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "#include <stdio.h>\n\n#define BSD_SUCCESS 0\n#define BSD_ERROR -1\n#define NOT_A_SOCKET -2\n\n// Dummy socket states array for simulation\nint sockets[256] = {0}; // Assuming a max of 256 open sockets\n\n// Function to retrieve socket state\nint get_socket_state(int socket) {\n    if (socket < 0 || socket >= 256) {\n        return NOT_A_SOCKET;\n    }\n    return sockets[socket];\n}\n\n// Function to set socket state\nvoid set_socket_state(int socket, int state) {\n    if (socket >= 0 && socket < 256) {\n        sockets[socket] = state;\n    }\n}\n\n// Dummy close function\nint close(int socket) {\n    if (get_socket_state(socket) == NOT_A_SOCKET) {\n        return -1; // Simulate an error if the socket is invalid\n    }\n    set_socket_state(socket, NOT_A_SOCKET);\n    return 0;\n}\n\nint BSD_close(int socket) {\n    // Check if the socket exists\n    if(get_socket_state(socket) != NOT_A_SOCKET){\n        // Set state to NOT_A_SOCKET\n        set_socket_state(socket, NOT_A_SOCKET);\n        \n        // Call close and check for errors\n        if(close(socket) == -1){\n            perror(\"Close failed\");\n            return BSD_ERROR;\n        }\n        return BSD_SUCCESS;\n    } else {\n        // The socket wasn't open or valid\n        perror(\"Socket is not valid\");\n        return BSD_ERROR;\n    }\n}", "CodeBleu_score": 41.59806257572164}, {"code": "#include <unistd.h>  // For close()\n#include <errno.h>   // For errno\n\n#define BSD_SUCCESS 0\n#define BSD_ERROR -1\n#define NOT_A_SOCKET -1\n\n// Mock of retrieving and setting socket state; actual implementation depends on underlying system\nint retrieve_socket_state(int socket) {\n    // Dummy implementation, in reality this should check if the socket is valid.\n    return 0; // Consider 0 as a valid socket state\n}\n\nvoid set_socket_state(int socket, int state) {\n    // This is a placeholder; real implementation depends on socket management in the system.\n}\n\nint BSD_close(int socket) {\n    int socket_state = retrieve_socket_state(socket);\n\n    // Check if it's a valid socket\n    if (socket_state == NOT_A_SOCKET) {\n        errno = EBADF; // Bad file descriptor error\n        return BSD_ERROR;\n    }\n\n    // Set state to NOT_A_SOCKET signalizing the socket is now closed\n    set_socket_state(socket, NOT_A_SOCKET);\n\n    // Attempt to close the socket\n    if (close(socket) == -1) {\n        // Check errno for the specific error and act accordingly\n        // For simplicity, just translate to BSD_ERROR\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 44.733716422983186}, {"code": "#include <unistd.h>\n#include <errno.h>\n\n#define BSD_SUCCESS 0\n#define BSD_ERROR -1\n#define NOT_A_SOCKET -1\n\n// Assuming socket_info structure and its management functions are defined elsewhere:\n// struct socket_info {\n//     int sock_id;\n//     int state;\n// };\n// struct socket_info sockets[MAX_SOCKETS];\n\n// Let's complete the function as per the description:\nint BSD_close(int socket) {\n    // Check if socket is valid (assuming get_socket_info is a function that retrieves socket info by id)\n    struct socket_info *si = get_socket_info(socket);\n    if (si == NULL || si->state == NOT_A_SOCKET) {\n        errno = EBADF; // Bad file descriptor error\n        return BSD_ERROR;\n    }\n\n    // Set the socket's state to NOT_A_SOCKET\n    si->state = NOT_A_SOCKET;\n\n    // Attempt to close the socket\n    if (close(socket) == -1) {\n        // An error occurred, set the appropriate error based on errno\n        switch (errno) {\n            case EBADF:\n                // The file descriptor is invalid.\n                errno = EBADF;\n                break;\n            case EINTR:\n                // The close call was interrupted by a signal.\n                errno = EINTR;\n                break;\n            case EIO:\n                // An I/O error occurred.\n                errno = EIO;\n                break;\n            default:\n                // An unspecified error occurred.\n                break;\n        }\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 52.79986554205072}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "#include <sys/socket.h>\n#include <errno.h>\n\n#define BSD_SUCCESS 0\n#define BSD_ERROR -1\n\nint BSD_listen(int socket, int backlog) {\n    // Call the standard listen function and capture the result\n    int result = listen(socket, backlog);\n    \n    // Check for an error\n    if (result == -1) {\n        // Set errno based on listen function error\n        errno = result;\n        return BSD_ERROR;\n    }\n    \n    // If no error, return success\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 24.195513268215052}, {"code": "#include <sys/socket.h> // for using the listen function and socket constants\n#include <errno.h>      // for handling error numbers\n\n#define BSD_SUCCESS 0\n#define BSD_ERROR -1\n\nint BSD_listen(int socket, int backlog) {\n    if (listen(socket, backlog) == -1) {\n        // listen failed, set errno appropriately\n        switch (errno) {\n            case EBADF:         // The argument sockfd is not a valid descriptor.\n            case ENOTSOCK:      // The argument sockfd is not a socket.\n            case EOPNOTSUPP:    // The socket is not of a type that supports the listen operation.\n            default:\n                break; // Default case just breaks the switch, leaving the errno as set by the failing listen call.\n        }\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 37.279357940334485}, {"code": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <errno.h>\n\n#define BSD_SUCCESS 0\n#define BSD_ERROR -1\n\nint BSD_listen(int socket, int backlog) {\n    // Attempt to set the socket in listen mode with given backlog\n    if (listen(socket, backlog) == -1) {\n        // If listen returns -1, an error has occurred.\n        // The global variable errno is automatically set by listen function to indicate the error.\n        return BSD_ERROR;\n    }\n    // If there's no error, return BSD_SUCCESS.\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 21.101506449739674}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "#include <sys/socket.h>\n#include <errno.h>\n\n#define SUCCESS 0\n#define ERROR_UNSUPPORTED_FAMILY -1\n#define ERROR_ACCEPT_FAILED -2\n\nstruct bsd_sockaddr {\n    sa_family_t sa_family;  // Address family\n    char sa_data[14];       // Family-specific address information\n};\n\nint BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen) {\n    // First, check if the address pointer and length pointer are valid.\n    if (addr == NULL || addrlen == NULL) {\n        errno = EINVAL;\n        return ERROR_ACCEPT_FAILED;\n    }\n\n    // Check the address family support.\n    if (addr->sa_family != AF_INET && addr->sa_family != AF_INET6) {\n        errno = EAFNOSUPPORT;\n        return ERROR_UNSUPPORTED_FAMILY;\n    }\n\n    // Try to accept a connection on the socket.\n    int accepted_socket = accept(socket, (struct sockaddr *) addr, addrlen);\n    if (accepted_socket == -1) {\n        // Accept failed, set appropriate error based on the errno.\n        if (errno == ECONNABORTED || errno == EINVAL || errno == EMFILE || errno == EWOULDBLOCK) {\n            return ERROR_ACCEPT_FAILED;\n        }\n    }\n\n    // If accept succeeds, return the newly accepted socket descriptor.\n    return accepted_socket;\n}", "CodeBleu_score": 42.27274182971918}, {"code": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <errno.h>\n\n// Custom implementation of the BSD compatible accept function\nint BSD_accept(int socket, struct sockaddr *addr, socklen_t *addrlen) {\n    // Check if addr is NULL or addrlen is NULL, which both are invalid\n    if (!addr || !addrlen) {\n        errno = EINVAL; // Set errno to EINVAL indicating invalid arguments\n        return -1; // Return error code -1 indicating an error\n    }\n\n    // Check the address family\n    if (addr->sa_family != AF_INET && addr->sa_family != AF_INET6) {\n        errno = EAFNOSUPPORT; // Set errno to EAFNOSUPPORT indicating address family not supported\n        return -1; // Return error code -1 indicating an error \n    }\n\n    // Call the original accept function\n    int accepted_socket = accept(socket, addr, addrlen);\n\n    // Check if the accept function failed\n    if (accepted_socket == -1) {\n        // Leave errno set by the accept function which will indicate the specific error\n        return -1; // Return error code -1 indicating an error\n    }\n\n    // If everything is successful, return the new socket file descriptor for the accepted connection\n    return accepted_socket;\n}", "CodeBleu_score": 28.231136280211267}, {"code": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <errno.h>\n\n#define SUCCESS 0\n#define ERROR_UNSUPPORTED_AF -1\n#define ERROR_ACCEPT_FAILED -2\n\n/*\n * The function \"BSD_accept\" accepts a connection on a given socket.\n * It converts the socket address to a supported format and checks the address family.\n * If the address family is supported, it calls the accept function to accept the connection.\n * If the address family is not supported, it sets an error and returns an error code.\n * If the accept function fails, it sets the appropriate error based on the socket value and returns an error code.\n * If the accept function succeeds, it returns a success code.\n */\nint BSD_accept(int socket, struct sockaddr *addr, socklen_t *addrlen) {\n    if (addr == NULL || addrlen == NULL) {\n        errno = EINVAL; // Invalid argument\n        return ERROR_ACCEPT_FAILED;\n    }\n\n    // Convert the socket address into a usable format or ensure it's valid (mostly applicable if more\n    // processing was needed or if more complex address format handling was required)\n    // Currently assuming addr provided is valid for simplicity.\n    \n    // Check the address family, ensure it's a supported family (AF_INET or AF_INET6 for internet protocols)\n    if (addr->sa_family != AF_INET && addr->sa_family != AF_INET6) {\n        errno = EAFNOSUPPORT;  // Address family not supported\n        return ERROR_UNSUPPORTED_AF;\n    }\n\n    // Attempt to accept a connection on the socket\n    int accepted_socket = accept(socket, addr, addrlen);\n    if (accepted_socket == -1) {\n        // Here, you could differentiate between various errors and handle as necessary\n        // This would set errno automatically from the accept's internal workings\n        return ERROR_ACCEPT_FAILED;\n    }\n\n    // If we succeed\n    return accepted_socket;  // return the descriptor of the accepted socket\n}", "CodeBleu_score": 35.46898356635943}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "#include <stdio.h>\n#include <time.h> // for time functions\n#include <stdbool.h> // for the bool type\n\n/* Function to check if the current UNIX time is considered valid */\nbool isTimeValid(time_t currentTime) {\n    // For example, we might consider time invalid if it is before a certain timestamp\n    time_t earliestValidTime = 1609459200; // Example: January 1, 2021\n    return currentTime >= earliestValidTime;\n}\n\n/* Function to update JWT with current time offset, hypothetically */\nvoid updateJWTWithTimeOffset(time_t currentTime) {\n    printf(\"JWT updated with time offset based on current time: %ld\\n\", currentTime);\n    // Placeholder for JWT update logic\n}\n\n/* Mock function to initiate the MQTT connection, real implementation might vary */\nvoid initMQTTConnection() {\n    printf(\"Attempting to initiate MQTT connection...\\n\");\n    // Placeholder for real MQTT connection initialization\n}\n\n/* Main function to connect to MQTT */\nstatic void connectMQTT() {\n    time_t currentTime = time(NULL); // Get current UNIX time\n    printf(\"Current UNIX time: %ld\\n\", currentTime);\n\n    if (!isTimeValid(currentTime)) {\n        printf(\"Error: Invalid current time. Cannot connect to MQTT.\\n\");\n        return;\n    }\n\n    // Updating JWT\n    updateJWTWithTimeOffset(currentTime);\n\n    // Initiating MQTT connection\n    initMQTTConnection();\n\n    // Normally here we would have more code to handle the connection results\n    // and send an MQTT SUBSCRIBE packet\n    printf(\"Connection attempt has been made, waiting for response...\\n\");\n\n    // Suppose the flag to indicate we need to send a SUBSCRIBE packet is global\n    extern bool sendSubscribeFlag;\n    sendSubscribeFlag = true;  // Setting the flag to send an MQTT SUBSCRIBE packet\n}\n\n// Usage of the function would be initiated elsewhere in the program\nint main() {\n    connectMQTT();\n    return 0;\n}", "CodeBleu_score": 42.76375605747342}, {"code": "#include <stdio.h>\n#include <time.h>\n#include <stdbool.h>\n\n// Assumed external functions and variables\nextern void updateJWTWithTime(time_t currentTime);\nextern bool connectToBroker(const char* jwtToken, const char* brokerAddress);\nextern void sendMQTTSubscribe();\n\n// Global or static variables\nstatic bool isMQTTConnected = false;\nstatic const char *brokerAddress = \"mqtt://your-broker-address.com\";\n\nstatic void connectMQTT() {\n    // Get the current time in UNIX timestamp format\n    time_t currentTime;\n    time(&currentTime);\n    \n    // Validate if the time is correctly fetched\n    if (currentTime != -1) {\n        // Update the JWT with the current time (this function should ideally perform the timestamp update)\n        updateJWTWithTime(currentTime);\n        \n        // Debug message indicating attempt to connect\n        printf(\"Connecting to MQTT Broker at %s with timestamp %ld\\n\", brokerAddress, (long)currentTime);\n        \n        // Attempt to connect to the MQTT broker\n        if (connectToBroker(\"your_jwt_token_here\", brokerAddress)) {\n            isMQTTConnected = true;\n            printf(\"Connection successful.\\n\");\n            \n            // Send MQTT SUBSCRIBE message now that we are connected\n            sendMQTTSubscribe();\n            printf(\"MQTT Subscribe packet sent.\\n\");\n        } else {\n            // Handle connection failure (could retry, log error, etc.)\n            printf(\"Connection to MQTT broker failed.\\n\");\n            isMQTTConnected = false;\n        }\n    } else {\n        // Handle the case where current time could not be fetched\n        printf(\"Failed to acquire the current time.\\n\");\n    }\n}", "CodeBleu_score": 39.416712870178074}, {"code": "#include <stdio.h>\n#include <time.h>\n#include <stdbool.h>\n\n// Assuming we have these external or mock functions available\nextern void updateJWT(long currentTime);\nextern void startMQTTConnection();\nextern void printDebug(const char *message);\nextern bool isTimeValid(long currentTime);\n\nstatic bool mqttConnected = false;\n\nstatic void connectMQTT() {\n    // Retrieve current time in UNIX format\n    time_t currentTime = time(NULL);\n\n    // Check if the time is valid\n    if (isTimeValid(currentTime)) {\n        // Update JWT with current time offset\n        updateJWT(currentTime);\n\n        // Print debug message for connection attempt\n        printDebug(\"Attempting to connect to MQTT broker.\");\n\n        // Initiate MQTT connection\n        startMQTTConnection();\n\n        // Set flag to send SUBSCRIBE packet once connected\n        mqttConnected = true;        \n    } else {\n        // Print debug message for invalid time\n        printDebug(\"Invalid current time, cannot connect.\");\n    }\n}\n\n// This context may not run directly without actual MQTT library functions and their correct initializations", "CodeBleu_score": 50.29063070510278}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "#include <stdio.h>\n\n// Define the possible states of MQTT connection for simulation purposes\ntypedef enum {\n    CONNECTED,\n    DISCONNECTED\n} ConnectionState;\n\n// Mock object to represent the MQTT client connection\ntypedef struct {\n    ConnectionState state;\n} MQTTClient;\n\n// Global MQTT client instance\nMQTTClient mqttClient = {CONNECTED}; // Assume initially connected\n\n// Function to log a debug message\nvoid log_debug(const char* message) {\n    printf(\"DEBUG: %s\\n\", message);\n}\n\n// Function to disconnect MQTT client\nvoid disconnect_mqtt_client(MQTTClient* client) {\n    if (client->state == CONNECTED) {\n        // Log disconnecting message\n        log_debug(\"Disconnecting MQTT Client...\");\n\n        // Simulated disconnection logic\n        client->state = DISCONNECTED;\n\n        // Confirm disconnection\n        log_debug(\"MQTT Client disconnected successfully.\");\n    } else {\n        log_debug(\"MQTT Client is already disconnected.\");\n    }\n}\n\nvoid CLOUD_disconnect(void) {\n    // Log initial debug message\n    log_debug(\"Disconnecting from cloud service...\");\n\n    // Check connection state and disconnect if connected\n    disconnect_mqtt_client(&mqttClient);\n}\n\n// Example of using the CLOUD_disconnect function\nint main(void) {\n    // Disconnect from cloud service\n    CLOUD_disconnect();\n\n    // Attempt to disconnect again to test state handling\n    CLOUD_disconnect();\n\n    return 0;\n}", "CodeBleu_score": 45.26179569833978}, {"code": "#include <stdio.h>\n\n// Definition of the connection state owner, assuming it's an enum or similar\ntypedef enum {\n    CONNECTED,\n    DISCONNECTED,\n    CONNECTING,\n    DISCONNECTION_IN_PROGRESS\n} ConnectionState;\n\n// Assuming we have a structure for the MQTT client\ntypedef struct {\n    char* host;             // Hostname of the MQTT broker\n    int port;               // Port number of the broker\n    ConnectionState state;  // Current state of the MQTT connection\n} MQTTClient;\n\n// Global MQTT client instance\nMQTTClient mqttClient = {\n    \"example.cloudservice.com\",\n    1883,\n    DISCONNECTED\n};\n\n// Function to log messages\nvoid log_debug(const char* message) {\n    printf(\"DEBUG: %s\\n\", message);\n}\n\n// Function to disconnect MQTT client\nvoid disconnect_MQTT_client(MQTTClient *client) {\n    if (client->state == CONNECTED) {\n        // Placeholder for actual disconnection logic\n        printf(\"Disconnecting from MQTT broker at %s:%d\\n\", client->host, client->port);\n        // Update the state to 'DISCONNECTED'\n        client->state = DISCONNECTED;\n        log_debug(\"MQTT client disconnected.\");\n    } else {\n        log_debug(\"MQTT client is not connected. No action taken.\");\n    }\n}\n\n// CLOUD_disconnect function implementation\nvoid CLOUD_disconnect(void) {\n    log_debug(\"Disconnecting from the cloud service...\");\n    \n    // Check the connection state and disconnect if connected\n    if (mqttClient.state == CONNECTED) {\n        disconnect_MQTT_client(&mqttClient);\n    }\n}\n\nint main() {\n    // Simulate initial connection\n    mqttClient.state = CONNECTED;\n    log_debug(\"MQTT client initially connected.\");\n\n    // Call CLOUD_disconnect to test its implementation\n    CLOUD_disconnect();\n\n    return 0;\n}", "CodeBleu_score": 44.07364603575192}, {"code": "#include <stdio.h>\n\n// Assuming the following external functions/types are defined elsewhere:\n// - mqttClient: a structure or handle representing an MQTT client\n// - isConnected: a function that checks if the MQTT client is connected\n// - getClientInfo: a function that retrieves connection info of the MQTT client\n// - disconnectMqttClient: a function to disconnect the MQTT client\n\nextern mqttClient client;\nextern int isConnected(mqttClient *client);\nextern void getClientInfo(mqttClient *client);\nextern void disconnectMqttClient(mqttClient *client);\n\nvoid CLOUD_disconnect(void) {\n    // Log a debug message for disconnecting\n    printf(\"Disconnecting from the cloud service...\\n\");\n\n    // Check if MQTT client is connected\n    if (isConnected(&client)) {\n        // Retrieve client information\n        printf(\"Retrieving client connection information...\\n\");\n        getClientInfo(&client);\n\n        // Disconnect the MQTT client\n        printf(\"Disconnecting the MQTT client...\\n\");\n        disconnectMqttClient(&client);\n\n        // Confirm disconnection\n        printf(\"MQTT client disconnected successfully.\\n\");\n    } else {\n        // Log the status if not connected\n        printf(\"MQTT client is not currently connected.\\n\");\n    }\n}", "CodeBleu_score": 34.13595674151787}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\n// Assuming these are predefined somewhere in the project\n#define DEFAULT_SSID \"defaultSSID\"\n#define DEFAULT_AUTH_TYPE AUTH_WPA2_PSK  // Example auth type\n#define DEFAULT_PASSWORD \"defaultPassword\"\n\n// Example placeholder function definitions for Wi-Fi operations\nbool wifi_initialize();\nbool wifi_connect(const char *ssid, int authType, const char *pass);\nvoid log_error(const char *error);\nvoid update_network_error(int error_code);\n\n// Mockup definitions for authentication types\nenum {\n    AUTH_OPEN,\n    AUTH_WEP,\n    AUTH_WPA_PSK,\n    AUTH_WPA2_PSK,\n    AUTH_WPA3_PSK\n};\n\ntypedef struct {\n    const char* ssid;\n    int authType;\n    const char* password;\n} WiFiCredentials;\n\n// Global variable that stores new credentials\nWiFiCredentials newCredentials;\n\n// Function to check if new credentials are passed\n// In this example, 'passed_wifi_creds' is considered as a boolean flag\nbool wifi_connectToAp(uint8_t passed_wifi_creds) {\n    bool success;\n    \n    if (passed_wifi_creds) {\n        // Attempt to connect using new credentials\n        success = wifi_connect(newCredentials.ssid, newCredentials.authType, newCredentials.password);\n    } else {\n        // Attempt to connect using default credentials\n        success = wifi_connect(DEFAULT_SSID, DEFAULT_AUTH_TYPE, DEFAULT_PASSWORD);\n    }\n    \n    if (!success) {\n        log_error(\"Failed to connect to WiFi AP\");\n        update_network_error(1); // Arbitrary error code for connection failure\n        return false;\n    }\n    \n    return true;\n}", "CodeBleu_score": 38.81024423567359}, {"code": "#include <stdbool.h>\n#include <stdio.h>\n\n// Hypothetical functions\nbool connectWithCredentials(const char* ssid, const char* authType, const char* password);\nbool connectWithDefault();\nvoid logError(const char* message);\nvoid updateNetworkErrorStatus();\n\n// Actual function definition\nbool wifi_connectToAp(uint8_t passed_wifi_creds) {\n    bool connected;\n\n    if (passed_wifi_creds != 0) {\n        // Assuming you would get these details from somewhere else when passed_wifi_creds is non-zero\n        const char* ssid = \"NewNetworkSSID\";\n        const char* authType = \"WPA2\";\n        const char* password = \"securepassword123\";\n\n        // Attempt to connect using provided details\n        connected = connectWithCredentials(ssid, authType, password);\n    } else {\n        // Use default credentials\n        connected = connectWithDefault();\n    }\n\n    if (!connected) {\n        // Handling the case where the connection attempt fails\n        logError(\"Failed to connect to the Wi-Fi network.\");\n        updateNetworkErrorStatus();\n\n        return false;\n    }\n\n    // If connected, return true\n    return true;\n}\n\n// These are placeholders for actual implementations\nbool connectWithCredentials(const char* ssid, const char* authType, const char* password) {\n    // Pretend to connect to a Wi-Fi network with these parameters.\n    // Return true if successful, false if connection failed.\n    return true;  // Assume success for demonstration.\n}\n\nbool connectWithDefault() {\n    // Pretend to connect using default settings.\n    return true;  // Assume success for demonstration.\n}\n\nvoid logError(const char* message) {\n    // Mock error logging.\n    printf(\"Error: %s\\n\", message);\n}\n\nvoid updateNetworkErrorStatus() {\n    // Mock updating network error status.\n    printf(\"Network status: Error\\n\");\n}", "CodeBleu_score": 40.53902563200951}, {"code": "#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\n// Let's assume there exist placeholders for default values and constants for simulation.\n#define DEFAULT_SSID \"DefaultSSID\"\n#define DEFAULT_AUTH_TYPE \"WPA2\"\n#define AUTH_NONE \"NONE\"\n#define DEFAULT_PASSWORD \"DefaultPassword\"\n#define MAX_SSID_LEN 32\n#define MAX_PASSWORD_LEN 64\n\ntypedef struct {\n    char ssid[MAX_SSID_LEN];\n    char auth_type[16]; // E.g., WPA2, WEP, NONE\n    char password[MAX_PASSWORD_LEN];\n} WifiCredentials;\n\n// Simulated functions for connecting to WiFi which obviously aren't real.\nbool hardware_connectWiFi(const char* ssid, const char* auth_type, const char* password) {\n    // Simulate a WiFi connection attempt.\n    printf(\"Attempting to connect to SSID: %s with %s authorization...\\n\", ssid, auth_type);\n\n    // A simple simulation for the connection being always successful (it would return a boolean value in real implementations).\n    return true; \n}\n\nvoid log_error(const char* error_message) {\n    printf(\"Error: %s\\n\", error_message);\n}\n\nbool wifi_connectToAp(uint8_t passed_wifi_creds) {\n    WifiCredentials wifiCredentials;\n\n    // Determine if custom credentials are passed, using hypothetical condition.\n    if (passed_wifi_creds == 1) {\n        printf(\"Using new WiFi credentials.\\n\");\n        // Hypothetical way of setting credentials.\n        strcpy(wifiCredentials.ssid, \"ExampleSSID\");\n        strcpy(wifiCredentials.auth_type, \"WPA2\");\n        strcpy(wifiCredentials.password, \"ExamplePassword\");\n    } else {\n        printf(\"Using default WiFi credentials.\\n\");\n        strcpy(wifiCredentials.ssid, DEFAULT_SSID);\n        strcpy(wifiCredentials.auth_type, DEFAULT_AUTH_TYPE);\n        strcpy(wifiCredentials.password, DEFAULT_PASSWORD);\n    }\n\n    // Attempt connection\n    bool connectionStatus = hardware_connectWiFi(wifiCredentials.ssid, wifiCredentials.auth_type, wifiCredentials.password);\n    if (!connectionStatus) {\n        log_error(\"Failed to connect to the WiFi access point.\");\n        // Hypothetical status updater function might be called here, e.g., update_network_error_status();\n        return false;\n    }\n    \n    printf(\"Connected successfully.\\n\");\n    return true;\n}", "CodeBleu_score": 33.750341681195614}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map) {\n    // Assuming `graphqlClient` is a pre-configured GraphQL client\n    // and `gql` allows us to create a GraphQL query.\n\n    try {\n        // Define the GraphQL query\n        const query = gql`\n            query {\n                sensors {\n                    id\n                    name\n                    location {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        `;\n\n        // Send the query using the GraphQL client\n        const response = await graphqlClient.query({\n            query: query\n        });\n\n        if (response.data && response.data.sensors) {\n            console.log(\"Successfully retrieved sensors:\", response.data.sensors);\n            \n            // Iterate through the sensor data to create and place markers on the map\n            response.data.sensors.forEach(sensor => {\n                if (sensor.location && sensor.location.latitude && sensor.location.longitude) {\n                    // Create a marker at the sensor's location\n                    const marker = new Marker({\n                        position: { lat: sensor.location.latitude, lng: sensor.location.longitude },\n                        map: map,\n                        title: sensor.name\n                    });\n\n                    // Optionally: Add other marker properties or events\n                }\n            });\n        } else {\n            console.log(\"No sensor data found in the response\");\n        }\n    } catch (error) {\n        console.error(\"Failed to fetch sensor data:\", error);\n    }\n}", "CodeBleu_score": 41.920042456687334}, {"code": "async function DisplaySensors(map) {\n    try {\n        // Create a client instance for GraphQL requests\n        const client = new ApolloClient({\n            uri: 'https://your-graphql-endpoint.com/graphql',\n            cache: new InMemoryCache()\n        });\n\n        // Define the GraphQL query to fetch sensor data\n        const query = gql`\n            query {\n                sensors {\n                    id\n                    name\n                    location {\n                        latitude\n                        longitude\n                    }\n                }\n            }\n        `;\n\n        // Send the query to the API\n        const result = await client.query({\n            query: query\n        });\n\n        // Log the API response\n        console.log('API Response:', result);\n\n        // Check if the response contains data\n        if (result.data && result.data.sensors) {\n            console.log('Retrieved', result.data.sensors.length, 'sensors.');\n\n            // Iterate through each sensor data\n            result.data.sensors.forEach(sensor => {\n                const { latitude, longitude } = sensor.location;\n\n                // Create a marker for each sensor\n                const marker = new google.maps.Marker({\n                    position: { lat: latitude, lng: longitude },\n                    map: map, // Place marker on the provided map\n                    title: sensor.name\n                });\n\n                // Optionally, you could add a click listener to the marker\n                marker.addListener('click', () => {\n                    alert('Sensor: ' + sensor.name);\n                });\n            });\n        } else {\n            console.log('No sensors data found.');\n        }\n    } catch (error) {\n        console.error('Failed to display sensors:', error);\n    }\n}", "CodeBleu_score": 36.51871257220273}, {"code": "async function DisplaySensors(map) {\n    // Create a GraphQL client\n    const endpoint = 'https://your-graphql-endpoint.com/graphql';\n    const fetchGraphQL = async (query) => {\n        const headers = { 'Content-Type': 'application/json' };\n        const response = await fetch(endpoint, {\n            method: 'POST',\n            headers: headers,\n            body: JSON.stringify({ query }),\n        });\n        return response.json();\n    };\n\n    // GraphQL query to retrieve sensor data\n    const query = `\n    {\n        sensors {\n            id\n            location {\n                latitude\n                longitude\n            }\n        }\n    }`;\n\n    try {\n        // Fetch data using the GraphQL client\n        const response = await fetchGraphQL(query);\n        console.log('API response:', response);\n\n        // Check if there is data present\n        if (response.data && response.data.sensors) {\n            console.log('Successfully retrieved sensors.');\n            // Iterate over each sensor to create and place a marker on the map\n            response.data.sensors.forEach(sensor => {\n                if (sensor.location && sensor.location.latitude && sensor.location.longitude) {\n                    // Assuming 'map' is an instance of a Map class that has a method to add a marker\n                    const marker = new map.Marker({\n                        position: new map.LatLng(sensor.location.latitude, sensor.location.longitude),\n                        map: map,\n                        title: 'Sensor ID: ' + sensor.id\n                    });\n\n                    console.log('Marker placed on map for sensor:', sensor.id);\n                }\n            });\n        } else {\n            console.log('No sensor data found in response.');\n        }\n    } catch (error) {\n        console.error('Failed to fetch sensor data:', error);\n    }\n}", "CodeBleu_score": 31.773316623028546}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>\n  // Create a div element to represent the sensor marker\n  const marker = document.createElement('div');\n\n  // Setting the ID of the marker to the sensor's unique ID\n  marker.id = `sensor-${sensor.id}`;\n\n  // Assigning a specific class name for common styles\n  marker.className = 'sensor-marker';\n\n  // Applying specific styles to the marker\n  marker.style.backgroundColor = 'blue'; // Default color as blue\n  marker.style.border = '2px solid black';\n  marker.style.width = '20px';\n  marker.style.height = '20px';\n  marker.style.borderRadius = '50%'; // Makes the div circular\n  marker.style.display = 'inline-block';\n\n  // Returning the created marker element\n  return marker;\n};", "CodeBleu_score": 31.697013265228712}, {"code": "const CreateSensorMarker = (sensor) =>\n/**\n * This function, `CreateSensorMarker`, generates an HTML div element representing a sensor marker.\n * It sets the marker's id using the sensor's unique ID, assigns it a specific class name,\n * and styles it with a default color and border.\n * The function returns the created marker element.\n */\nconst CreateSensorMarker = (sensor) => {\n    // Create a new div element\n    const marker = document.createElement(\"div\");\n\n    // Setting the marker's ID using the sensor's unique ID\n    marker.id = `sensor-${sensor.id}`;\n\n    // Assign a specific class name\n    marker.className = 'sensor-marker';\n\n    // Assign styles for default color and border\n    marker.style.backgroundColor = 'red';       // A default color (red for visibility)\n    marker.style.border = '2px solid black';    // A simple black border\n    marker.style.width = '10px';                // Setting the width of the marker\n    marker.style.height = '10px';               // Setting the height of the marker\n    marker.style.borderRadius = '50%';          // Making the marker circular\n\n    // Return the created marker element\n    return marker;\n};\n\n// Example sensor object\nconst exampleSensor = { id: 1 };\n\n// Create a marker\nconst sensorMarker = CreateSensorMarker(exampleSensor);\n\n// Assume you have a 'map' div where you want to append this marker\nconst mapDiv = document.getElementById('map');\nmapDiv.appendChild(sensorMarker);", "CodeBleu_score": 40.048127498750574}, {"code": "const CreateSensorMarker = (sensor) =>\n  // Create a div element to represent the sensor marker\n  const marker = document.createElement('div');\n\n  // Set the marker's id using the sensor's unique ID\n  marker.id = `sensor-${sensor.id}`;\n\n  // Assign a specific class name to the marker\n  marker.className = 'sensor-marker';\n\n  // Style the marker with a default color and border\n  marker.style.backgroundColor = 'red';\n  marker.style.border = '2px solid black';\n  marker.style.width = '20px';\n  marker.style.height = '20px';\n  marker.style.borderRadius = '50%'; // Optional: makes it a circle\n\n  // Return the created marker element\n  return marker;\n};", "CodeBleu_score": 33.70095788600406}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "import logging\nimport types\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.exceptions import HomeAssistantError\nimport importlib\n\nasync def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType:\n    \"\"\"\n    Asynchronously loads a multi-factor authentication (MFA) module for Home Assistant.\n    It constructs the module path and attempts to import the module, logging and raising an error if the import fails.\n    If the module has requirements and pip installation is not skipped, it processes these requirements.\n    The function checks if the module's requirements have already been processed to avoid redundant installations.\n    Finally, it returns the loaded module.\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    \n    # Try to import the MFA module\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as e:\n        logger.error(f\"Failed to import MFA module {module_name}: {e}\")\n        raise HomeAssistantError(f\"Failed to import MFA module {module_name}\") from e\n\n    # Check if the module has a REQUIREMENTS attribute\n    if hasattr(module, 'REQUIREMENTS'):\n        requirements = module.REQUIREMENTS\n        # Make sure we process these requirements only if they have not been handled\n        if not hass.config.skip_pip and not hasattr(module, '_requirements_processed'):\n            from homeassistant.util.package import async_process_requirements\n            try:\n                # Process the requirements asynchronously\n                await async_process_requirements(hass, module_path, requirements)\n                setattr(module, '_requirements_processed', True)\n            except Exception as exc:\n                logger.error(f\"Could not handle requirements for MFA module {module_name}: {exc}\")\n                raise HomeAssistantError(f\"Could not install requirements for MFA module {module_name}\") from exc\n\n    return module", "CodeBleu_score": 40.58466660286037}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\nimport sys\nimport logging\nimport importlib\nfrom homeassistant.core import HomeAssistant\nimport types\n\nlogger = logging.getLogger(__name__)\n\nasync def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType:\n    \"\"\"The function \"_load_mfa_module\" asynchronously loads a multi-factor authentication (MFA) module for Home Assistant.\n    It constructs the module path and attempts to import the module, logging and raising an error if the import fails.\n    If the module has requirements and pip installation is not skipped, it processes these requirements.\n    The function checks if the module's requirements have already been processed to avoid redundant installations.\n    Finally, it returns the loaded module.\n    \"\"\"\n    module_path = f\"homeassistant.auth.mfa_modules.{module_name}\"\n    try:\n        # Attempt to import the MFA module\n        module = importlib.import_module(module_path)\n        logger.info(f\"Successfully loaded MFA module: {module_name}\")\n    except ImportError as import_error:\n        # Log and raise error if import fails\n        logger.error(f\"Failed to load MFA module {module_name}: {import_error}\")\n        raise ImportError(f\"Cannot load MFA module {module_name}\") from import_error\n\n    if hasattr(module, 'REQUIREMENTS'):\n        processed_requirements = getattr(hass.data, 'processed_requirements', set())\n        requirements = module.REQUIREMENTS\n        \n        if not hass.config.skip_pip:\n            # Process each requirement that hasn't been processed yet\n            for requirement in requirements:\n                if requirement not in processed_requirements:\n                    logger.info(f\"Processing requirement for {module_name}: {requirement}\")\n                    # Assume an asynchronous method hass.helpers.requirement.async_process_requirements handles pip installation\n                    await hass.helpers.requirement.async_process_requirements(hass, module_name, [requirement])\n                    processed_requirements.add(requirement)\n                    setattr(hass.data, 'processed_requirements', processed_requirements)\n        else:\n            logger.info(\"Skipping pip installation as per configuration\")\n\n    return module", "CodeBleu_score": 39.749282757584595}, {"code": "import importlib\nimport types\nimport logging\nfrom homeassistant.core import HomeAssistant\n\nlogger = logging.getLogger(__name__)\n\nasync def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType:\n    \"\"\"\n    The function \"_load_mfa_module\" asynchronously loads a multi-factor authentication\n    (MFA) module for Home Assistant. It constructs the module path and attempts to import\n    the module, logging and raising an error if the import fails. If the module has\n    requirements and pip installation is not skipped, it processes these requirements.\n    The function checks if the module's requirements have already been processed to avoid\n    redundant installations. Finally, it returns the loaded module.\n    \"\"\"\n    try:\n        # Construct the module path assuming a conventions based structure\n        module_path = f\"homeassistant.components.{module_name}.mfa_module\"\n\n        # Attempt to dynamically import the specified MFA module\n        mfa_module = importlib.import_module(module_path)\n        \n        # Check and process requirements if any, assumes `requirements` exists within the module\n        if hasattr(mfa_module, 'REQUIREMENTS') and mfa_module.REQUIREMENTS:\n            logger.info(f\"Processing requirements for MFA module '{module_name}'\")\n            # Assume existence of a helper function \"async_process_requirements\"\n            # in HomeAssistant that handles requirement installation.\n            # This is a placeholder and should align with actual implementation in Hass.\n            await hass.async_process_requirements(module_path, mfa_module.REQUIREMENTS)\n\n        return mfa_module\n\n    except ImportError as e:\n        logger.error(f\"Failed to import MFA module {module_name}: {str(e)}\")\n        raise ImportError(f\"Cannot load MFA module {module_name}.\") from e\n    except Exception as ex:\n        logger.error(f\"An error occurred while loading MFA module {module_name}: {str(ex)}\")\n        raise Exception(f\"Error loading MFA module {module_name}.\") from ex", "CodeBleu_score": 34.49867679674278}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "from typing import Any, List, Dict\n\nclass MFASetupService:\n    def __init__(self):\n        self.user_data: List[Dict[str, Any]] = []\n\n    async def async_setup_user(self, user_id: str, setup_data: Any) -> None:\n        \"\"\"The function \"async_setup_user\" sets up a user to use an MFA module.\n        It extracts the PIN from the provided setup data and checks if the user already has an entry in the internal data list.\n        If an entry exists, it updates the PIN; otherwise, it adds a new entry with the user ID and PIN to the data list.\n\n        Args:\n            user_id (str): The unique identifier for the user.\n            setup_data (Any): Data containing the PIN for MFA setup.\n\n        Returns:\n            None: This method updates the internal list and does not return any value.\n        \"\"\"\n        pin = setup_data.get('pin')  # Assuming setup_data is a dictionary containing the PIN\n        if pin is None:\n            raise ValueError(\"PIN must be provided in the setup data\")\n\n        # Check for an existing user entry\n        existing_user = next((entry for entry in self.user_data if entry['user_id'] == user_id), None)\n        \n        # Update the PIN if the user already exists\n        if existing_user:\n            existing_user['pin'] = pin\n        else:\n            # Add new user entry if not found\n            self.user_data.append({'user_id': user_id, 'pin': pin})", "CodeBleu_score": 37.568995971557165}, {"code": "from typing import Any\n\nclass MFASetupService:\n    def __init__(self):\n        self.data_list = []\n\n    async def async_setup_user(self, user_id: str, setup_data: Any) -> Any:\n        \"\"\"\n        The function \"async_setup_user\" sets up a user to use an MFA module.\n        It extracts the PIN from the provided setup data and checks if the user already has an entry in the internal data list.\n        If an entry exists, it updates the PIN; otherwise, it adds a new entry with the user ID and PIN to the data list.\n\n        Args:\n        user_id (str): The user's ID who is setting up the MFA.\n        setup_data (Any): The data required for setup, expected to include a 'pin' field.\n\n        Returns:\n        Any: A success message indicating the new or updated status of the user's MFA setup.\n        \"\"\"\n        # Extract the PIN from the setup data\n        pin = setup_data.get('pin') if isinstance(setup_data, dict) and 'pin' in setup_data else None\n        if pin is None:\n            raise ValueError(\"Invalid setup data: 'pin' is required\")\n\n        # Check if an entry for the user already exists\n        existing_entry = next((entry for entry in self.data_list if entry['user_id'] == user_id), None)\n\n        if existing_entry:\n            # Update the existing entry with the new PIN\n            existing_entry['pin'] = pin\n            status = \"updated\"\n        else:\n            # Create a new entry with the user ID and PIN\n            self.data_list.append({'user_id': user_id, 'pin': pin})\n            status = \"added\"\n\n        return f\"User {user_id} MFA setup {status} successfully.\"", "CodeBleu_score": 35.19073121537569}, {"code": "from typing import Any, Dict, List\n\nclass MFA_Module:\n    def __init__(self):\n        # Assuming there is a list to store user data with PIN\n        self.users_data: List[Dict[str, Any]] = []\n    \n    async def async_setup_user(self, user_id: str, setup_data: Any) -> Any:\n        \"\"\"The function \"async_setup_user\" sets up a user to use an MFA module.\n        It extracts the PIN from the provided setup data and checks if the user already has an entry in the internal data list.\n        If an entry exists, it updates the PIN; otherwise, it adds a new entry with the user ID and PIN to the data list.\n        \n        Args:\n            user_id (str): The identifier for the user.\n            setup_data (Any): The data provided during setup, expected to include a PIN.\n        \n        Returns:\n            Any: The updated or new user entry in the data list.\n        \"\"\"\n        # Assuming setup_data is a dictionary containing a 'pin' key\n        pin = setup_data.get('pin')\n        \n        # Check if user already exists\n        user_entry = None\n        for entry in self.users_data:\n            if entry['user_id'] == user_id:\n                user_entry = entry\n                break\n        \n        if user_entry:\n            # Update existing user's PIN\n            user_entry['pin'] = pin\n        else:\n            # Add new user with PIN\n            user_entry = {'user_id': user_id, 'pin': pin}\n            self.users_data.append(user_entry)\n        \n        return user_entry\n\n# Example of setting up and using the module\nmfa_module = MFA_Module()\nsetup_data = {'pin': '1234'}\nuser_id = 'user123'\n\n# Setup user asynchronously\nimport asyncio\n\nasync def main():\n    result = await mfa_module.async_setup_user(user_id, setup_data)\n    print(result)\n\nasyncio.run(main())", "CodeBleu_score": 34.91200344161011}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "import asyncio\n\nclass NotifySetting:\n    def __init__(self, user_id, settings):\n        self.user_id = user_id\n        self.settings = settings\n\nclass YourClass:\n    def __init__(self):\n        self.user_settings = {}\n        self.initialization_lock = asyncio.Lock()\n        self.settings_loaded = False\n\n    async def _async_load(self) -> None:\n        \"\"\"Asynchronously loads stored user data.\n        It acquires an initialization lock to ensure thread safety and checks if user settings are already loaded.\n        If not, it attempts to load data from the user store.\n        If the data is empty, it initializes an empty dictionary for user settings.\n        It then populates the user settings by creating \"NotifySetting\" objects for each user based on the loaded data.\"\"\"\n        async with self.initialization_lock:\n            if self.settings_loaded:\n                return\n            \n            # Simulating async data fetching from a store\n            data = await self.fetch_user_data()\n\n            if not data:\n                self.user_settings = {}\n            else:\n                for user_id, settings in data.items():\n                    self.user_settings[user_id] = NotifySetting(user_id, settings)\n            \n            self.settings_loaded = True\n\n    async def fetch_user_data(self) -> dict:\n        # Simulate fetching user data from an async data store\n        # Example data fetched might look like:\n        # { 'user1': {'email': True, 'sms': False},\n        #   'user2': {'email': False, 'sms': True}}\n        return {\n            'user1': {'email': True, 'sms': False},\n            'user2': {'email': False, 'sms': True}\n        }\n\n# Example Usage:\n# your_class_instance = YourClass()\n# await your_class_instance._async_load()", "CodeBleu_score": 26.62441506144716}, {"code": "import asyncio\n\nclass NotifySetting:\n    def __init__(self, user_id, settings):\n        self.user_id = user_id\n        self.settings = settings\n\nclass UserStore:\n    async def load_user_data(self):\n        # This should be replaced with the actual data loading logic\n        return {'user1': {'email': 'email@example.com', 'sms': True}, 'user2': {'email': 'example2@example.com', 'sms': False}}\n\nclass UserSettingsService:\n    def __init__(self):\n        self.is_initialized = False\n        self.initialization_lock = asyncio.Lock()\n        self.user_store = UserStore()\n        self.user_settings = {}\n\n    async def _async_load(self) -> None:\n        \"\"\"The function \"_async_load\" asynchronously loads stored user data.\n        It acquires an initialization lock to ensure thread safety and checks if user settings are already loaded.\n        If not, it attempts to load data from the user store.\n        If the data is empty, it initializes an empty dictionary for user settings.\n        It then populates the user settings by creating \"NotifySetting\" objects for each user based on the loaded data.\"\"\"\n        \n        # Ensure that data loading is thread-safe\n        async with self.initialization_lock:\n            if self.is_initialized:\n                return  # Return if already initialized\n\n            # Load data from the user store\n            data = await self.user_store.load_user_data()\n            if not data:\n                self.user_settings = {}  # Initialize to empty if no data\n            else:\n                # Create NotifySetting objects for each user\n                self.user_settings = {user_id: NotifySetting(user_id, settings) for user_id, settings in data.items()}\n            \n            # Mark as initialized\n            self.is_initialized = True\n\n# Example usage:\n# user_setting_service = UserSettingsService()\n# asyncio.run(user_setting_service._async_load())", "CodeBleu_score": 30.18399733986999}, {"code": "import asyncio\nfrom threading import Lock\n\nclass NotifySetting:\n    \"\"\"Placeholder class to represent notification settings.\"\"\"\n    def __init__(self, user_id, settings):\n        self.user_id = user_id\n        self.settings = settings\n\nclass UserDataStore:\n    \"\"\"Placeholder class representing the storage system for user data.\"\"\"\n    async def load_user_data(self):\n        # Mock of loading data from a storage system.\n        return {\n            'user1': {'email': True, 'sms': False},\n            'user2': {'email': False, 'sms': True},\n        }\n\nclass UserSettingsManager:\n    def __init__(self):\n        self.user_settings = {}\n        self.initialization_lock = Lock()\n        self.data_store = UserDataStore()\n\n    async def _async_load(self) -> None:\n        \"\"\"Asynchronously loads stored user data.\n        Acquires an initialization lock to ensure thread safety and checks if user settings are already loaded.\n        If not, it attempts to load data from the user store.\n        If the data is empty, it initializes an empty dictionary for user settings.\n        It then populates the user settings by creating \"NotifySetting\" objects for each user based on the loaded data.\"\"\"\n        async with asyncio.Lock():\n            if not self.user_settings:  # Check if user settings are already loaded to avoid reloading\n                data = await self.data_store.load_user_data()\n                if not data:\n                    self.user_settings = {}  # Initialize a blank dictionary if data is empty\n                else:\n                    self.user_settings = {\n                        user_id: NotifySetting(user_id, settings)\n                        for user_id, settings in data.items()\n                    }\n\n# Sample usage:\nasync def main():\n    manager = UserSettingsManager()\n    await manager._async_load()\n    print(manager.user_settings)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())", "CodeBleu_score": 26.97425207917904}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import Any, Dict\n\nclass UserSettingsManager:\n    \"\"\"Mock or stub class to manage user settings.\"\"\"\n    settings = {\n        'user123': {'otp': '123456'},\n        'user456': {'otp': '654321'}\n    }\n\n    @staticmethod\n    def load_user_settings(user_id: str):\n        \"\"\"Simulate loading user settings.\"\"\"\n        return UserSettingsManager.settings.get(user_id)\n\nclass OTPValidator:\n    \"\"\"Mock or stub for OTP validation.\"\"\"\n    @staticmethod\n    def validate_otp(stored_otp: str, provided_otp: str) -> bool:\n        \"\"\"Simulate OTP validation.\"\"\"\n        return stored_otp == provided_otp\n\nclass MyClass:\n    def __init__(self, executor: ThreadPoolExecutor):\n        self.executor = executor\n\n    async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool:\n        \"\"\"\n        Asynchronously validates user input for a given user ID.\n        It ensures user settings are loaded, then retrieves the notification settings for the specified user.\n        If no settings are found for the user, it returns False.\n        Otherwise, it validates the user input by verifying the OTP using an executor job and returns True if the validation passes.\n        \"\"\"\n        # Load user settings\n        user_settings = UserSettingsManager.load_user_settings(user_id)\n        if not user_settings:\n            return False\n        \n        # Retrieve OTP from user input and user settings\n        input_otp = user_input.get('otp')\n        stored_otp = user_settings.get('otp')\n\n        # Use ThreadPoolExecutor to handle OTP validation in a thread\n        loop = asyncio.get_running_loop()\n        result = await loop.run_in_executor(\n            self.executor,\n            OTPValidator.validate_otp,\n            stored_otp,\n            input_otp\n        )\n\n        return result\n\n# Usage Example\nexecutor = ThreadPoolExecutor()\nmy_class = MyClass(executor)\n\nasync def main():\n    user_id = \"user123\"\n    user_input = {\"otp\": \"123456\"}\n    result = await my_class.async_validate(user_id, user_input)\n    print(f\"Validation result for {user_id}: {result}\")\n\n    user_id = \"userxxx\"\n    result = await my_class.async_validate(user_id, user_input)\n    print(f\"Validation result for {user_id}: {result}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())", "CodeBleu_score": 30.412100134053784}, {"code": "import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import Any, Dict\n\nclass MyValidationService:\n    def __init__(self):\n        self.executor = ThreadPoolExecutor()\n\n    async def load_user_settings(self, user_id: str) -> dict:\n        # Simulate an asynchronous database or API call\n        return await asyncio.sleep(0.1, {'notification_settings': {'otp_required': True, 'otp': '123456'}})\n\n    def validate_otp(self, user_otp: str, correct_otp: str) -> bool:\n        return user_otp == correct_otp\n\n    async def async_validate(self, user_id: str, user_input: Dict[str, Any]) -> bool:\n        \"\"\"The function \"async_validate\" asynchronously validates user input for a given user ID.\n        It ensures user settings are loaded, then retrieves the notification settings for the specified user.\n        If no settings are found for the user, it returns False.\n        Otherwise, it validates the user input by verifying the OTP using an executor job and returns True if the validation passes.\"\"\"\n        settings = await self.load_user_settings(user_id)\n        if not settings or 'notification_settings' not in settings:\n            return False\n    \n        notification_settings = settings['notification_settings']\n        if not notification_settings.get('otp_required', False):\n            return False\n    \n        if 'otp' not in user_input:\n            return False\n\n        user_otp = user_input['otp']\n        correct_otp = notification_settings['otp']\n\n        # Run OTP validation in a thread pool to prevent blocking the asyncio event loop\n        loop = asyncio.get_running_loop()\n        is_valid = await loop.run_in_executor(self.executor, self.validate_otp, user_otp, correct_otp)\n        return is_valid\n\n# Example usage\nasync def main():\n    validator = MyValidationService()\n    is_valid = await validator.async_validate(\"user123\", {'otp': '123456'})\n    print(\"Validation result:\", is_valid)\n\nasyncio.run(main())", "CodeBleu_score": 30.888361862575742}, {"code": "import asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import Any, Dict\n\nclass YourClass:\n    def __init__(self):\n        self.executor = ThreadPoolExecutor()\n\n    async def load_user_settings(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Asynchronously load user-specific settings.\n        In reality, this would involve an async call to a database or external API.\n        \"\"\"\n        return {\"otp\": \"123456\"}  # Placeholder implementation\n\n    async def async_validate(self, user_id: str, user_input: Dict[str, Any]) -> bool:\n        \"\"\"\n        The function \"async_validate\" asynchronously validates user input for a given user ID.\n        It ensures user settings are loaded, then retrieves the notification settings for the specified user.\n        If no settings are found for the user, it returns False.\n        Otherwise, it validates the user input by verifying the OTP using an executor job and returns True if the validation passes.\n        \"\"\"\n        settings = await self.load_user_settings(user_id)\n        if not settings:\n            return False\n\n        # Retrieve OTP settings which would normally be part of the user's settings\n        user_otp = settings.get(\"otp\")\n        if not user_otp:\n            # If no OTP setup for the user, cannot validate\n            return False\n\n        # Imagine user_input contains an 'otp' key with the OTP to validate\n        input_otp = user_input.get(\"otp\")\n\n        # Simulate OTP check\n        def validate_otp(input_otp, stored_otp):\n            return input_otp == stored_otp\n\n        # Use ThreadPoolExecutor to run the OTP validation check\n        otp_valid = await asyncio.get_running_loop().run_in_executor(\n            self.executor,\n            validate_otp,\n            input_otp,\n            user_otp\n        )\n\n        return otp_valid\n\n# Assuming YourClass is instantiated and used elsewhere", "CodeBleu_score": 32.71299485698907}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None:\n    \"\"\"\n    The function \"_lookup_area\" retrieves entity permissions based on the entity's area.\n    It first fetches the entity entry using the entity ID.\n    If the entity or its associated device is not found, it returns None.\n    Next, it retrieves the device entry and checks if it has an associated area.\n    If the device entry or area ID is missing, it returns None.\n    Finally, it returns the permissions for the area from the provided area dictionary.\n    \n    Parameters:\n    - perm_lookup: PermissionLookup, a mapping or data access object handling permission lookups.\n    - area_dict: SubCategoryDict, a dictionary format holding area permissions mappings.\n    - entity_id: str, the ID of the entity for which permissions are being fetched.\n\n    Returns:\n    - ValueType: The permission level or type found for the area, or None if any details are missing.\n    \"\"\"\n\n    # Fetching the entity entry using the provided entity_id\n    entity_entry = perm_lookup.get_entity(entity_id)\n    \n    # Check if the entity or its device is missing\n    if not entity_entry or not entity_entry.device:\n        return None\n    \n    # Retrieving the device entry\n    device_entry = entity_entry.device\n    \n    # Check if the device has an associated area ID\n    if not device_entry.area_id:\n        return None\n    \n    # Retrieve the permission level from the area_dict for the given area_id\n    area_permissions = area_dict.get(device_entry.area_id)\n    \n    return area_permissions", "CodeBleu_score": 53.736904092757484}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None:\n    \"\"\"The function \"_lookup_area\" retrieves entity permissions based on the entity's area.\n    It first fetches the entity entry using the entity ID.\n    If the entity or its associated device is not found, it returns None.\n    Next, it retrieves the device entry and checks if it has an associated area.\n    If the device entry or area ID is missing, it returns None.\n    Finally, it returns the permissions for the area from the provided area dictionary.\"\"\"\n\n    # Fetch entity entry using the entity_id\n    entity_entry = perm_lookup.get_entity_entry(entity_id)\n    if not entity_entry:\n        return None\n\n    # Get device related to the entity\n    device_id = entity_entry.get('device_id')\n    if not device_id:\n        return None\n\n    # Fetch device entry\n    device_entry = perm_lookup.get_device_entry(device_id)\n    if not device_entry:\n        return None\n\n    # Check for associated area\n    area_id = device_entry.get('area_id')\n    if not area_id:\n        return None\n\n    # Retrieve permissions for the area\n    permissions = area_dict.get(area_id)\n    return permissions\n\n# Definitions for assumed classes or structures based on the usage in the function:\n\nfrom typing import Dict, Optional\n\nclass PermissionLookup:\n    def __init__(self, entity_map: Dict[str, Dict], device_map: Dict[str, Dict]):\n        self.entity_map = entity_map\n        self.device_map = device_map\n\n    def get_entity_entry(self, entity_id: str) -> Optional[Dict]:\n        return self.entity_map.get(entity_id)\n\n    def get_device_entry(self, device_id: str) -> Optional[Dict]:\n        return self.device_map.get(device_id)\n\nSubCategoryDict = Dict[str, ValueType]  # Map of area_id to permissions\nValueType = any  # Could be any type depending on system requirements", "CodeBleu_score": 45.384056638493355}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None:\n    \"\"\"\n    The function \"_lookup_area\" retrieves entity permissions based on the entity's area.\n    It first fetches the entity entry using the entity ID.\n    If the entity or its associated device is not found, it returns None.\n    Next, it retrieves the device entry and checks if it has an associated area.\n    If the device entry or area ID is missing, it returns None.\n    Finally, it returns the permissions for the area from the provided area dictionary.\n\n    Args:\n    - perm_lookup (PermissionLookup): An object that has methods to get entity and device data.\n    - area_dict (SubCategoryDict): A dictionary mapping area IDs to permissions values.\n    - entity_id (str): The ID of the entity for which to find permissions.\n\n    Returns:\n    - ValueType | None: The permission for the entity's area, or None if no valid permission is found.\n    \"\"\"\n\n    # Fetch the entity entry using the given entity ID\n    entity_entry = perm_lookup.get_entity(entity_id)\n    if entity_entry is None or 'device_id' not in entity_entry:\n        # If the entity entry is missing or no device_id is associated, return None\n        return None\n\n    # Retrieve the device entry using the device_id found in entity entry\n    device_id = entity_entry['device_id']\n    device_entry = perm_lookup.get_device(device_id)\n    if device_entry is None or 'area_id' not in device_entry:\n        # If the device entry is missing or no area_id is associated, return None\n        return None\n\n    # Fetch the area_id from the device entry\n    area_id = device_entry['area_id']\n\n    # Retrieve the permissions for the area using area_id from the area dictionary\n    permissions = area_dict.get(area_id)\n    \n    # Return the permissions or None if the area_id does not exist\n    return permissions", "CodeBleu_score": 59.83210578106305}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "from typing import Dict, Any\n\nPolicyType = Dict[str, Any]  # Define PolicyType as a dictionary for the example\n\ndef merge_policies(policies: list[PolicyType]) -> PolicyType:\n    \"\"\"\n    Merges multiple policy dictionaries into a single policy.\n    It initializes a new policy dictionary and a set to track seen categories.\n    For each policy and each category within it, if the category hasn't been seen,\n    it adds the category to the set and merges the corresponding categories from all policies.\n    The merged policy dictionary is cast to the appropriate type and returned.\n\n    Args:\n    policies (list[PolicyType]): List of policy dictionaries to be merged.\n\n    Returns:\n    PolicyType: A single merged policy dictionary.\n    \"\"\"\n    merged_policy = {}\n    seen_categories = set()\n\n    # Loops through each policy provided in the list\n    for policy in policies:\n        # For each category in the current policy\n        for category, details in policy.items():\n            # Check if the category has been added to the merged_policy\n            if category not in seen_categories:\n                # Add the category to the set of seen categories\n                seen_categories.add(category)\n                # Initialize or merge the category details into merged_policy\n                if category not in merged_policy:\n                    merged_policy[category] = details\n                else:\n                    # Assuming merging means updating the details if they exist\n                    merged_policy[category].update(details)\n\n    return merged_policy", "CodeBleu_score": 40.81294064836299}, {"code": "from typing import Dict, Any\n\nPolicyType = Dict[str, Any]  # Assuming Policy type is a dictionary where keys are string identifiers for categories\n\ndef merge_policies(policies: list[PolicyType]) -> PolicyType:\n    \"\"\"\n    Merges multiple policy dictionaries into a single policy.\n    \n    It initializes a new policy dictionary and iteratively merges categories from each provided policy.\n    If a category appears in more than one policy, the details from later policies overwrite earlier ones.\n    \n    Arguments:\n    policies -- list of policy dictionaries to merge\n\n    Returns:\n    A single policy dictionary containing all unique categories from the input policies.\n    \"\"\"\n    merged_policy: PolicyType = {}\n    \n    for policy in policies:\n        for category, rules in policy.items():\n            if category in merged_policy:\n                # Since we are to \"merge\" not \"replace\", this logic may be expanded based on actual merging needs\n                # e.g., updating only specific subfields, combining lists, etc.\n                # Here, for simplicity, we update directly\n                merged_policy[category].update(rules)\n            else:\n                merged_policy[category] = rules.copy()  # Use copy to avoid mutating the original rules\n    \n    return merged_policy\n\n# Example usage:\n# Assuming we define specifics for PolicyType as necessary later.", "CodeBleu_score": 36.443663876755124}, {"code": "PolicyType = {\n    \"category1\": {\"setting1\": value1, \"setting2\": value2},\n    \"category2\": {\"setting1\": value3, \"setting2\": value4}\n}", "CodeBleu_score": 4.121001060927444}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "import logging\nimport types\nimport importlib\n\nfrom homeassistant.exceptions import HomeAssistantError\nfrom homeassistant.core import HomeAssistant\nfrom homeassistant.util.package import install_package\n\n_LOGGER = logging.getLogger(__name__)\n\nasync def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType:\n    \"\"\"\n    Asynchronously loads an authentication provider module for Home Assistant.\n    It attempts to import the specified provider module and logs an error if the import fails, \n    raising a \"HomeAssistantError\". If the module has no additional requirements or the \n    requirements should be skipped, it returns the module. Otherwise, it processes the module's \n    requirements and updates the processed requirements set before returning the module.\n    \"\"\"\n    try:\n        # Import the authentication provider module dynamically\n        module_name = f\"homeassistant.auth.providers.{provider}\"\n        module = importlib.import_module(module_name)\n        _LOGGER.debug(\"Successfully imported authentication provider %s\", provider)\n        \n        # Check if there are additional requirements specific to this module\n        if hasattr(module, 'REQUIREMENTS') and module.REQUIREMENTS:\n            requirements = module.REQUIREMENTS\n            for requirement in requirements:\n                # Asynchronously install package requirements for the modeller\n                await hass.async_add_executor_job(install_package, requirement)\n                _LOGGER.debug(\"Successfully installed requirement %s for provider %s\", requirement, provider)\n            \n    except ImportError as err:\n        _LOGGER.error(\"Unable to import authentication provider %s: %s\", provider, err)\n        raise HomeAssistantError(f\"Failed to import authentication provider {provider}\") from err\n    except Exception as e:\n        _LOGGER.error(\"Error loading or installing requirements for provider %s: %s\", provider, e)\n        raise HomeAssistantError(f\"Error handling the provider {provider}: {e}\") from e\n\n    return module", "CodeBleu_score": 40.69965561519159}, {"code": "import types\nimport importlib\nimport sys\nfrom homeassistant.exceptions import HomeAssistantError\n\nasync def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType:\n    \"\"\"\n    Asynchronously loads an authentication provider module for Home Assistant.\n    Attempts to import the specified provider module and logs an error if the import fails, raising a \"HomeAssistantError\".\n    If the module has no additional requirements or the requirements should be skipped, it returns the module.\n    Otherwise, it processes the module's requirements and updates the processed requirements set before returning the module.\n    \"\"\"\n    \n    # Constructing the full module path\n    module_path = f\"homeassistant.auth.providers.{provider}\"\n\n    try:\n        # Import the module dynamically using importlib\n        module = importlib.import_module(module_path)\n    except ImportError:\n        # Log error and raise HomeAssistantError\n        hass.logger.error(f\"Failed to load authentication provider module '{module_path}'\")\n        raise HomeAssistantError(f\"Could not load authentication provider module: {provider}\")\n\n    # Assuming the module might have a 'REQUIREMENTS' attribute listing dependency strings\n    if hasattr(module, 'REQUIREMENTS'):\n        requirements = getattr(module, 'REQUIREMENTS')\n        # Process each requirement - this is just a placeholder for the actual logic\n        for requirement in requirements:\n            # Method to check/install each requirement - could also be async\n            await hass.async_process_requirement(module_path, requirement)\n\n    return module", "CodeBleu_score": 34.918452836485024}, {"code": "import importlib\nimport logging\nimport sys\nfrom homeassistant.exceptions import HomeAssistantError\nimport types\nfrom typing import Type\nfrom collections.abc import Awaitable\n\n# Assumed HomeAssistant type for the purpose of this task\nclass HomeAssistant:\n    pass\n\nasync def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType:\n    \"\"\"\n    Asynchronously loads an authentication provider module for Home Assistant.\n    It attempts to import the specified provider module and logs an error if the import fails,\n    raising a \"HomeAssistantError\".\n    If the module has no additional requirements or the requirements should be skipped,\n    it returns the module. Otherwise, it processes the module's requirements and updates the\n    processed requirements set before returning the module.\n    \n    Args:\n    - hass: An instance of HomeAssistant\n    - provider: The string identifier for the provider module to load\n\n    Returns:\n    - A Python module of the authentication provider\n\n    Raises:\n    - HomeAssistantError: If the module cannot be imported or other loading issues occur\n    \"\"\"\n    module_name = f\"homeassistant.auth.providers.{provider}\"\n    \n    try:\n        # Try to dynamically import the module\n        module = importlib.import_module(module_name)\n    except ImportError as e:\n        # Log error and raise an exception if import fails\n        logging.error(f\"Failed to import auth provider module: {module_name}. Error: {str(e)}\")\n        raise HomeAssistantError(f\"Failed to import auth provider module {module_name}\")\n\n    # In reality, here you should check and process any additional module requirements,\n    # such as dependencies that need to be installed, and possibly other asynchronous setup tasks.\n    # For this example, we skip these steps.\n\n    return module", "CodeBleu_score": 28.56956129938588}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "bash\npip install aiofiles", "CodeBleu_score": 0.0}, {"code": "import json\n\nclass UserDataLoader:\n    def __init__(self):\n        self.users = []\n\n    async def load_data(self) -> dict:\n        \"\"\"Simulate an asynchronous data loading from a JSON file or database.\"\"\"\n        try:\n            with open('userdata.json', 'r') as file:\n                data = json.load(file)\n            return data\n        except FileNotFoundError:\n            return {}  # Empty data if file not found\n\n    def normalize_username(self, username: str) -> str:\n        \"\"\"Normalize the username to a standard format.\"\"\"\n        return username.strip().lower()  # Example normalization: trim spaces, convert to lower case\n\n    async def async_load(self) -> None:\n        \"\"\"The function 'async_load' asynchronously loads stored user data.\n        It attempts to load data from the store and initializes an empty users list if no data is found.\n        It then checks for non-normalized usernames within the loaded data and assigns the data to an internal variable.\"\"\"\n        # Load the data asynchronously\n        data = await self.load_data()\n\n        # Initialize users list if no data is found\n        if not data:\n            self.users = []\n        else:\n            # Normalize usernames and reassign them\n            for user in data.get(\"users\", []):\n                normalized_username = self.normalize_username(user[\"username\"])\n                user[\"username\"] = normalized_username\n            self.users = data.get(\"users\", [])\n\n# Example usage\n# import asyncio\n# \n# loader = UserDataLoader()\n# asyncio.run(loader.async_load())\n# print(loader.users)", "CodeBleu_score": 27.717289167770975}, {"code": "bash\npip install aiofiles", "CodeBleu_score": 0.0}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "import bcrypt\n\nclass InvalidAuth(Exception):\n    \"\"\"Custom exception to denote invalid authentication attempts.\"\"\"\n    pass\n\nclass User:\n    def __init__(self, username, password_hash):\n        self.username = username\n        self.password_hash = password_hash\n\nclass Authenticator:\n    def __init__(self, users):\n        self.users = users\n\n    def validate_login(self, username: str, password: str) -> None:\n        \"\"\"\n        The function \"validate_login\" verifies a user's login credentials.\n        It normalizes the provided username and initializes a dummy hash to prevent timing attacks.\n        It iterates through all users to find a matching username.\n        If no matching user is found, it performs a dummy hash check and raises an \"InvalidAuth\" exception.\n        If a user is found, it decodes the stored password hash and uses bcrypt's timing-safe check to compare the provided password with the stored hash.\n        If the passwords do not match, it raises an \"InvalidAuth\" exception.\n        \"\"\"\n        normalized_username = username.strip().lower()\n        dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())  # Used for constant time comparison in case of not found user.\n\n        found_user = None\n        for user in self.users:\n            # Normalize stored usernames as well\n            if user.username.lower() == normalized_username:\n                found_user = user\n                break\n\n        if found_user is None:\n            # Execute a dummy password check for security reasons (to mitigate timing attacks)\n            bcrypt.checkpw(password.encode(), dummy_hash)\n            raise InvalidAuth(\"Invalid username or password\")\n\n        # Verify the password against the actual user's password hash.\n        user_password_hash = found_user.password_hash.encode()\n        if not bcrypt.checkpw(password.encode(), user_password_hash):\n            raise InvalidAuth(\"Invalid username or password\")\n\n# Example usage:\ntry:\n    users = [User(\"John\", bcrypt.hashpw(b\"password123\", bcrypt.gensalt())),\n             User(\"Jane\", bcrypt.hashpw(b\"pass456\", bcrypt.gensalt()))]\n    auth = Authenticator(users)\n    auth.validate_login(\"john\", \"password123\")\n    print(\"Login successful!\")\nexcept InvalidAuth as auth_error:\n    print(str(auth_error))", "CodeBleu_score": 41.983338072635135}, {"code": "import bcrypt\nfrom typing import List, Dict\n\nclass InvalidAuth(Exception):\n    \"\"\"Custom exception raised when authentication fails.\"\"\"\n    pass\n\nclass User:\n    def __init__(self, username: str, hashed_password: bytes):\n        self.username = username\n        self.hashed_password = hashed_password\n\nclass UserManager:\n    def __init__(self):\n        self.users: List[User] = []\n\n    def add_user(self, username: str, password: str) -> None:\n        hashed_password = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n        self.users.append(User(username, hashed_password))\n\n    def validate_login(self, username: str, password: str) -> None:\n        \"\"\"The function \"validate_login\" verifies a user's login credentials.\n        It normalizes the provided username and initializes a dummy hash to prevent timing attacks.\n        It iterates through all users to find a matching username.\n        If no matching user is found, it performs a dummy hash check and raises an \"InvalidAuth\" exception.\n        If a user is found, it decodes the stored password hash and uses bcrypt's timing-safe check to compare the provided password with the stored hash.\n        If the passwords do not match, it raises an \"InvalidAuth\" exception.\"\"\"\n        \n        normalized_username = username.strip().lower()\n        dummy_hash = bcrypt.hashpw(\"dummy_password\".encode(), bcrypt.gensalt())\n        \n        user_found = None\n        for user in self.users:\n            if user.username.lower() == normalized_username:\n                user_found = user\n                break\n\n        if not user_found:\n            # Perform dummy hash check to prevent timing attacks\n            bcrypt.checkpw(\"dummy_password\".encode(), dummy_hash)\n            raise InvalidAuth(\"Invalid username or password\")\n\n        # Decode stored hashed password and compare\n        if not bcrypt.checkpw(password.encode(), user_found.hashed_password):\n            raise InvalidAuth(\"Invalid username or password\")", "CodeBleu_score": 42.91791257274543}, {"code": "import bcrypt\n\nclass InvalidAuth(Exception):\n    \"\"\"Exception raised for invalid authentication.\"\"\"\n    pass\n\nclass AuthenticationSystem:\n    def __init__(self):\n        # dummy users for example\n        self.users = [\n            {'username': 'user1', 'password_hash': bcrypt.hashpw('pass123'.encode(), bcrypt.gensalt())},\n            {'username': 'user2', 'password_hash': bcrypt.hashpw('mypassword'.encode(), bcrypt.gensalt())}\n        ]\n\n    def validate_login(self, username: str, password: str) -> None:\n        \"\"\"\n        Verifies a user's login credentials. It normalizes the provided username and initializes a dummy hash to \n        prevent timing attacks. It iterates through all users to find a matching username. If no matching user is \n        found, it performs a dummy hash check and raises an \"InvalidAuth\" exception. If a user is found, it decodes \n        the stored password hash and uses bcrypt's timing-safe check to compare the provided password with the stored \n        hash. If the passwords do not match, it raises an \"InvalidAuth\" exception.\n        \"\"\"\n        # Normalize username\n        normalized_username = username.lower().strip()\n\n        # To prevent timing attacks initialize a dummy hash\n        dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n\n        user_found = None\n        for user in self.users:\n            if user['username'].lower() == normalized_username:\n                user_found = user\n                break\n\n        if not user_found:\n            # Use the dummy hash to perform a hash check to keep time consistent\n            bcrypt.checkpw(password.encode(), dummy_hash)\n            raise InvalidAuth(\"Invalid username or password.\")\n\n        # User is found, check password against the user's hash\n        user_hash = user_found['password_hash']\n        if not bcrypt.checkpw(password.encode(), user_hash):\n            raise InvalidAuth(\"Invalid username or password.\")\n\n# Example Usage:\nauth_system = AuthenticationSystem()\ntry:\n    auth_system.validate_login(\"user1\", \"pass123\")\n    print(\"Login successful\")\nexcept InvalidAuth as e:\n    print(str(e))", "CodeBleu_score": 42.296316703340544}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "class InvalidUser(Exception):\n    pass\n\nclass AuthenticationManager:\n    def __init__(self):\n        self.users = []\n\n    async def async_remove_auth(self, username: str) -> None:\n        \"\"\"\n        The function \"async_remove_auth\" removes a user's authentication.\n        It normalizes the provided username and searches for the user in the users list.\n        If the user is found, it removes the user from the list.\n        If the user is not found, it raises an \"InvalidUser\" exception with the message \"user_not_found\".\n        \"\"\"\n        \n        # Normalize the username\n        normalized_username = username.strip().lower()\n        \n        # Check if the user exists\n        found = False\n        for user in self.users:\n            if user == normalized_username:\n                self.users.remove(normalized_username)\n                found = True\n                break\n        \n        # If user not found, raise an exception\n        if not found:\n            raise InvalidUser(\"user_not_found\")\n\n# Example usage:\n# auth_manager = AuthenticationManager()\n# auth_manager.users = [\"john_doe\", \"alice_smith\"]\n# await auth_manager.async_remove_auth(\" Alice_Smith \")\n# print(auth_manager.users) # Should print ['john_doe']", "CodeBleu_score": 31.609008718030264}, {"code": "class InvalidUser(Exception):\n    \"\"\"Custom Exception to be raised when the user is not found.\"\"\"\n    pass\n\nclass AuthenticationSystem:\n    def __init__(self):\n        # Assuming 'self.users' is simply a list of usernames.\n        self.users = ['JohnDoe', 'JaneSmith', 'AliceJohnson']\n    \n    async def async_remove_auth(self, username: str) -> None:\n        \"\"\"The function 'async_remove_auth' removes a user's authentication.\\n\n        It normalizes the provided username and searches for the user in the users list.\\n\n        If the user is found, it removes the user from the list.\\n\n        If the user is not found, it raises an 'InvalidUser' exception with the message 'user_not_found'.\n\n        Args:\n        - username (str): The username of the user whose authentication needs to be removed.\n        \n        Raises:\n        - InvalidUser: If the user with the given username is not found in the list.\n        \"\"\"\n        # Normalize the username\n        normalized_username = username.lower()\n\n        # Check if the user exists in the list\n        if normalized_username in [user.lower() for user in self.users]:\n            # Remove the user by reconstructing the list without the user\n            self.users = [user for user in self.users if user.lower() != normalized_username]\n        else:\n            # Raise an exception if the user is not found\n            raise InvalidUser(f\"user_not_found\")\n\n# Example of using the above class:\n# Create an instance of AuthenticationSystem\nauth_system = AuthenticationSystem()\n\n# Async function calls such as this are usually run in an event loop\nimport asyncio\n\n# Define a test to remove a user asynchronously\nasync def test_remove_auth():\n    try:\n        await auth_system.async_remove_auth('janedoe')\n        print(\"User removed successfully.\")\n        print(\"Updated users list:\", auth_system.users)\n    except InvalidUser as e:\n        print(str(e))\n\n# Run the async test function\nasyncio.run(test_remove_auth())", "CodeBleu_score": 29.21012570350769}, {"code": "class InvalidUser(Exception):\n    \"\"\"Exception raised when a user is not found.\"\"\"\n    pass\n\nclass UserManager:\n    def __init__(self):\n        self.users = []  # This will store user details or usernames.\n\n    def normalize_username(self, username):\n        \"\"\"Normalize the username to a standardized format.\"\"\"\n        return username.strip().lower()\n\n    async def async_remove_auth(self, username: str) -> None:\n        \"\"\"Remove a user's authentication by username.\n        \n        Parameters:\n        username (str): The username of the user to remove authentication for.\n\n        Raises:\n        InvalidUser: If the user is not found in the user list.\n        \n        \"\"\"\n        normalized_username = self.normalize_username(username)\n        for i, user in enumerate(self.users):\n            if self.normalize_username(user) == normalized_username:\n                del self.users[i]\n                return\n        \n        raise InvalidUser(\"user_not_found\")\n\n# Usage Example:\n# Create an instance of UserManager\nuser_manager = UserManager()\nuser_manager.users.append(\"JohnDoe\")\nuser_manager.users.append(\"JaneDoe\")\n\n# Asynchronous removal of a user\nimport asyncio\n\nasync def main():\n    try:\n        await user_manager.async_remove_auth(\"  johnDoe \")  # Testing with space and different case\n        print(user_manager.users)  # Should show that JohnDoe has been removed\n    except InvalidUser as e:\n        print(e)\n\nasyncio.run(main())", "CodeBleu_score": 33.44224290901163}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "class Credentials:\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\nclass AuthenticationManager:\n    # Dummy class to simulate authentication data management\n    def __init__(self):\n        self.auth_data = {}\n\n    def initialize(self):\n        # Idempotent initialization\n        pass\n\n    def remove_authentication(self, username):\n        if username not in self.auth_data:\n            raise ValueError(\"User invalid or not found\")\n        del self.auth_data[username]\n\n    def save_changes(self):\n        # Here you could interact with a database or an external system\n        print(\"Changes saved.\")\n\nclass MyClass:\n    def __init__(self, auth_manager: AuthenticationManager):\n        self.auth_manager = auth_manager\n    \n    async def async_will_remove_credentials(self, credentials: Credentials) -> None:\n        \"\"\"Handles the removal of authentication data when credentials are deleted.\n        If the data is not initialized, it initializes it first.\n        It then attempts to remove the authentication associated with the given username and save the changes.\n        If the user is invalid, it catches and ignores the exception.\"\"\"\n        \n        # Ensure the authentication data is initialized\n        self.auth_manager.initialize()\n        \n        try:\n            # Attempt to remove the authentication associated with the given username\n            self.auth_manager.remove_authentication(credentials.username)\n        except ValueError as e:\n            # Ignore exception if user is invalid\n            print(f\"Exception caught: {str(e)}\")\n            \n        # Save changes\n        self.auth_manager.save_changes()\n\n# Example usage\nauth_manager = AuthenticationManager()\nmy_object = MyClass(auth_manager)\ncredentials = Credentials(\"user1\", \"password123\")\n\nimport asyncio\n# Run the asynchronous function\nasyncio.run(my_object.async_will_remove_credentials(credentials))", "CodeBleu_score": 38.49540394159175}, {"code": "class Credentials:\n    \"\"\"A simple class representing user credentials.\"\"\"\n    def __init__(self, username):\n        self.username = username\n\nclass AuthenticationManager:\n    \"\"\"Class to manage user authentication data.\"\"\"\n    \n    def __init__(self):\n        self.credentials_db = {}  # Mock of database for storing credentials\n    \n    async def async_will_remove_credentials(self, credentials: Credentials) -> None:\n        \"\"\"\n        Removes authentication data when credentials are deleted.\n        Initializes data if not already initialized.\n        Attempts to remove authentication associated with the given username.\n        If user is invalid, the exception is ignored.\n        \n        Parameters:\n        credentials (Credentials): The credentials object containing the username.\n        \"\"\"\n        if not self.credentials_db:\n            self.credentials_db = {}  # Initialize data storage as a dictionary for simplicity\n        \n        try:\n            if credentials.username in self.credentials_db:\n                # Remove the user's data if the username exists in credentials database\n                del self.credentials_db[credentials.username]\n                print(f\"Credentials removed for user: {credentials.username}\")\n            else:\n                # Username not found, we just avoid throwing an exception\n                print(f\"No credentials found for user: {credentials.username}, nothing was removed\")\n        except KeyError as e:\n            # Exception handling for removing credentials which might probably be unnecessary due to our checks\n            # But included here for demonstrating safe coding practices and meet doc requirement\n            print(f\"Exception caught during credentials removal: {str(e)}\")", "CodeBleu_score": 25.459264655928514}, {"code": "from typing import Any\n\nclass Credentials:\n    def __init__(self, username: str):\n        self.username = username\n\nclass CredentialManager:\n    def __init__(self):\n        # assuming this is an asynchronous database or a storage\n        self.storage = {}\n    \n    async def initialize(self):\n        # Initialize or prepare the storage if necessary\n        pass\n\n    async def remove_credentials(self, username: str) -> bool:\n        \"\"\"\n        Removes credentials for the given username.\n        Returns True if removal was successful, else False.\n        \"\"\"\n        if username in self.storage:\n            del self.storage[username]\n            return True\n        return False\n\n    async def save_changes(self):\n        # Any required action to persist changes would be here\n        pass\n\nclass CredentialHandler:\n    def __init__(self):\n        self.credentials_manager = CredentialManager()\n\n    async def async_will_remove_credentials(self, credentials: Credentials) -> None:\n        \"\"\"\n        Handles the removal of authentication data when credentials are deleted.\n        If the data is not initialized, it initializes it first.\n        It then attempts to remove the authentication associated with the given username and save the changes.\n        If the user is invalid, it catches and ignores the exception.\n        \"\"\"\n        try:            \n            # Attempt data initialization; note that this should be idempotent and safe to call multiple times\n            await self.credentials_manager.initialize()\n            \n            # Try to remove the credentials\n            removal_success = await self.credentials_manager.remove_credentials(credentials.username)\n            \n            if removal_success:\n                # Save changes if removal was successful\n                await self.credentials_manager.save_changes()\n            else:\n                print(f\"No credentials found for username: {credentials.username}\")\n        except Exception as e:\n            # Handle or log the exception depending on the specifications\n            print(f\"Failed to remove credentials for {credentials.username}: {str(e)}\")\n\n# An example to use this class\nasync def main():\n    handler = CredentialHandler()\n    creds = Credentials(\"exampleUser\")\n    await handler.async_will_remove_credentials(creds)\n\n# Run the main function (needs an event loop environment, e.g., asyncio.run(main()) in Python 3.7+)", "CodeBleu_score": 38.85404283162258}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "import threading\nimport logging\n\ndef join_or_interrupt_threads(\n    threads: set[threading.Thread], timeout: float, log: bool\n) -> set[threading.Thread]:\n    \"\"\"\n    The function \"join_or_interrupt_threads\" attempts to join or interrupt a set of threads.\n    It calculates the timeout for each thread and tries to join them within the specified timeout.\n    If a thread is no longer alive or has no identifier, it is added to the joined set.\n    If logging is enabled, it logs threads that are still running.\n    It then attempts to raise a SystemExit exception in any remaining threads.\n    The function returns the set of successfully joined threads.\n    \"\"\"\n\n    joined_threads = set()\n    timeout_per_thread = timeout / len(threads) if threads else timeout\n\n    for thread in threads:\n        thread.join(timeout_per_thread)\n        if not thread.is_alive():\n            joined_threads.add(thread)\n        elif log:\n            logging.warning(f\"Thread {thread.name} did not finish in time.\")\n\n    remaining_threads = threads - joined_threads\n    for thread in remaining_threads:\n        # Attempt to raise an exception in the thread\n        if thread.is_alive():\n            try:\n                thread._tstate_lock.release()\n                thread._stop()\n                if log:\n                    logging.info(f\"SystemExit raised in thread {thread.name}.\")\n            except Exception as e:\n                if log:\n                    logging.error(f\"Failed to stop thread {thread.name}: {e}\")\n\n    return joined_threads", "CodeBleu_score": 45.7752767085497}, {"code": "import threading\nimport time\nimport logging\n\ndef join_or_interrupt_threads(\n    threads: set[threading.Thread], timeout: float, log: bool\n) -> set[threading.Thread]:\n    \"\"\"\n    The function \"join_or_interrupt_threads\" attempts to join or interrupt a set of threads.\n    It calculates the timeout for each thread and tries to join them within the specified timeout.\n    If a thread is no longer alive or has no identifier, it is added to the joined set.\n    If logging is enabled, it logs threads that are still running.\n    It then attempts to raise a SystemExit exception in any remaining threads.\n    The function returns the set of successfully joined threads.\n    \"\"\"\n    \n    # Initialize the joined threads set\n    joined_threads = set()\n    \n    # Calculate equal timeout for each thread if there are multiple threads\n    if threads:\n        individual_timeout = timeout / len(threads)\n    else:\n        individual_timeout = timeout\n        \n    # Attempt to join each thread within the calculated timeout\n    for thread in threads:\n        thread.join(timeout=individual_timeout)\n        if not thread.is_alive():\n            joined_threads.add(thread)\n        elif log:\n            logging.info(f\"Thread {thread.name} is still running after timeout.\")\n    \n    # Attempt to interrupt any remaining threads\n    for thread in threads:\n        if thread.is_alive() and thread.ident is not None:\n            try:\n                threading.Thread(target=thread.join).start()  # Use another thread to enforce join\n                time.sleep(individual_timeout)\n                if thread.is_alive():\n                    # Forcing thread exit as clean shutdown failed\n                    import ctypes\n                    ctypes.pythonapi.PyThreadState_SetAsyncExc(\n                        ctypes.c_long(thread.ident), ctypes.py_object(SystemExit))\n            except Exception as e:\n                if log:\n                    logging.error(f\"Failed to interrupt thread {thread.name}: {str(e)}\")\n\n    return joined_threads", "CodeBleu_score": 46.20564638328952}, {"code": "from threading import Thread\nimport time\nimport logging\n\ndef join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]:\n    \"\"\"\n    The function \"join_or_interrupt_threads\" attempts to join or interrupt a set of threads.\n    It calculates the timeout for each thread and tries to join them within the specified timeout.\n    If a thread is no longer alive or has no identifier, it is added to the joined set.\n    If logging is enabled, it logs threads that are still running.\n    It then attempts to raise a `SystemExit` exception in any remaining threads.\n    The function returns the set of successfully joined threads.\n\n    Args:\n    threads (set[Thread]): The threads to join or interrupt.\n    timeout (float): The maximum time in seconds to wait for each thread to terminate.\n    log (bool): If true, enables the logging of still running threads.\n\n    Returns:\n    set[Thread]: A set of threads that were successfully joined or terminated.\n    \"\"\"\n    joined_threads = set()\n    start_time = time.time()\n    for thread in threads:\n        # Calculate the remaining timeout to be used when attempting to join the thread\n        remaining_time = timeout - (time.time() - start_time)\n        if remaining_time > 0:\n            thread.join(remaining_time)\n\n        # Check if the thread has finished\n        if not thread.is_alive():\n            joined_threads.add(thread)\n        else:\n            # Log the thread if it's still active and logging is enabled\n            if log:\n                logging.warning(f'Thread {thread.name} is still running.')\n\n            # Attempt to raise SystemExit in running threads\n            try:\n                thread._stop()  # Using a protected method as a last resort\n            except Exception as e:\n                if log:\n                    logging.error(f\"Error stopping thread {thread.name}: {str(e)}\")\n\n    return joined_threads", "CodeBleu_score": 48.618006585752056}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "import threading\nimport logging\nimport time\n\ndef deadlock_safe_shutdown() -> None:\n    \"\"\"The function \"deadlock_safe_shutdown\" performs a shutdown that avoids deadlocks.\n    It identifies all non-main, non-daemon, alive threads and calculates a timeout for each thread\n    based on the total shutdown timeout divided by the number of remaining threads.\n    It then attempts to join each thread within the calculated timeout and logs a warning if joining a thread fails.\"\"\"\n\n    total_shutdown_timeout = 30  # Total timeout in seconds for the entire shutdown process\n    active_threads = [thread for thread in threading.enumerate() if thread is not threading.main_thread() and not thread.daemon and thread.is_alive()]\n    num_active_threads = len(active_threads)\n\n    if num_active_threads == 0:\n        logging.info(\"No non-daemon threads to shutdown.\")\n        return\n\n    timeout_per_thread = total_shutdown_timeout / num_active_threads\n\n    for thread in active_threads:\n        thread.join(timeout_per_thread)\n        if thread.is_alive():\n            logging.warning(f\"Thread {thread.name} could not be joined within {timeout_per_thread:.2f} seconds.\")", "CodeBleu_score": 52.499445668757694}, {"code": "import threading\nimport logging\nimport time\n\ndef deadlock_safe_shutdown(total_shutdown_timeout: float = 5.0) -> None:\n    \"\"\"The function \"deadlock_safe_shutdown\" performs a shutdown that avoids deadlocks.\n    \n    It identifies all non-main, non-daemon, alive threads and calculates a timeout \n    for each thread based on the total shutdown timeout divided by the number of remaining threads.\n    It then attempts to join each thread within the calculated timeout and logs a warning \n    if joining a thread fails.\n    \n    Args:\n        total_shutdown_timeout (float): The total number of seconds allocated for all threads to\n                                        be safely shut down.\n    \"\"\"\n    # Allowance to add waiting time between checks\n    min_wait_time = 0.1\n    \n    # Collect all threads excluding main/dameon threads that are still alive\n    main_thread = threading.main_thread()\n    threads = []\n    for thread in threading.enumerate():\n        if thread is not main_thread and not thread.daemon and thread.is_alive():\n            threads.append(thread)\n    \n    if not threads:\n        logging.info(\"No non-daemon threads to shut down.\")\n        return\n\n    # Calculate timeout for each thread\n    num_threads = len(threads)\n    individual_timeout = max(min_wait_time, total_shutdown_timeout / num_threads)\n    \n    # Logging setup: configure logging to show warnings\n    logging.basicConfig(level=logging.WARNING)\n    \n    # Attempt to join each thread with a timeout\n    failed_threads = []\n    for thread in threads:\n        thread.join(timeout=individual_timeout)\n        if thread.is_alive():\n            failed_threads.append(thread.name)\n\n    # Log warnings for threads that failed to join\n    for thread_name in failed_threads:\n        logging.warning(f\"Failed to join thread within timeout: {thread_name}\")\n\n    if not failed_threads:\n        logging.info(\"Successfully shut down all threads.\")\n\n# Example usage:\n# deadlock_safe_shutdown()", "CodeBleu_score": 37.12364269486109}, {"code": "import threading\nimport logging\nimport time\n\ndef deadlock_safe_shutdown(total_shutdown_timeout=30.0) -> None:\n    \"\"\"\n    The function \"deadlock_safe_shutdown\" performs a shutdown that avoids deadlocks.\n    It identifies all non-main, non-daemon, alive threads and calculates a timeout for each thread based on the total shutdown timeout divided by the number of remaining threads.\n    It then attempts to join each thread within the calculated timeout and logs a warning if joining a thread fails.\n\n    Parameters:\n        total_shutdown_timeout (float): the total time in seconds allotted for the shutdown process\n    \"\"\"\n    # Initialize logging\n    logging.basicConfig(level=logging.INFO)\n    main_thread = threading.main_thread()\n    threads = [t for t in threading.enumerate() if t is not main_thread and not t.daemon and t.is_alive()]\n\n    num_threads = len(threads)\n    if num_threads == 0:\n        return\n\n    per_thread_timeout = total_shutdown_timeout / num_threads\n\n    for thread in threads:\n        thread.join(per_thread_timeout)\n        if thread.is_alive():\n            logging.warning(f\"Failed to join thread {thread.name} within the timeout period ({per_thread_timeout:.2f} seconds).\")\n\n# Example usage of the deadlock_safe_shutdown function:\nif __name__ == \"__main__\":\n    deadlock_safe_shutdown()", "CodeBleu_score": 37.35104702996572}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": "class MyClass:\n    def __init__(self):\n        self._has_remaining_setups = False\n\n    def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None:\n        \"\"\"\n        The function \"_async_dispatch\" dispatches a signal based on the state of remaining setups.\n        If there are setups remaining or the previous state was not empty, it sends an internal dispatcher signal \n        with the remaining setups.\n        It then updates the internal flag to reflect whether there are remaining setups.\n        \"\"\"\n        \n        has_remaining = bool(remaining_with_setup_started)\n        # Check if there are any setups remaining or if the previous state indicated there were remaining setups\n        if has_remaining or self._has_remaining_setups:\n            self._dispatch_signal(remaining_with_setup_started)\n\n        # Update the internal state to reflect the current status of remaining setups\n        self._has_remaining_setups = has_remaining\n\n    def _dispatch_signal(self, data: dict[str, float]) -> None:\n        \"\"\"\n        Sends some kind of internal signal (could be a literal signal, a message queue system, a log entry, etc.)\n        This function should be implemented according to the actual dispatch system in use.\n        \"\"\"\n        print(\"Dispatching signal with the following data:\", data)\n        # Imagine here we'd interact with an actual dispatch system like a message bus, logging system or an event handler", "CodeBleu_score": 33.91666245949344}, {"code": "class SetupManager:\n    def __init__(self):\n        # A flag to check if there were setups remaining in the previous state\n        self._previous_state_not_empty = False\n        \n        # The internal dispatcher (stub implementation or placeholder),\n        # Assuming a method stub that simulates sending signals\n        self._dispatch_signal = self._simulate_dispatch_signal\n\n    def _simulate_dispatch_signal(self, remaining_setups):\n        # Simulation of internal dispatcher handling method\n        print(f\"Dispatch signal with remaining setups: {remaining_setups}\")\n    \n    def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None:\n        \"\"\"The function \"_async_dispatch\" dispatches a signal based on the state of remaining setups.\n        If there are setups remaining or the previous state was not empty, it sends an internal dispatcher signal with the remaining setups.\n        It then updates the internal flag to reflect whether there are remaining setups.\n        \n        Args:\n            remaining_with_setup_started (dict[str, float]): A dictionary where keys are setup identifiers and values are the time or stage at which they were started.\n        \"\"\"\n        # Check if there are any remaining setups or if the previous state was not empty\n        if remaining_with_setup_started or self._previous_state_not_empty:\n            # Send signal with the details of remaining setups\n            self._dispatch_signal(remaining_with_setup_started)\n        \n        # Update the internal state flag based on current remaining setups\n        self._previous_state_not_empty = bool(remaining_with_setup_started)", "CodeBleu_score": 37.599720881266336}, {"code": "class SetupManager:\n    def __init__(self):\n        self._setups_pending = False\n\n    def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None:\n        \"\"\"The function \"_async_dispatch\" dispatches a signal based on the state of remaining setups.\n        If there are setups remaining or the previous state was not empty, it sends an internal dispatcher signal with the remaining setups.\n        It then updates the internal flag to reflect whether there are remaining setups.\n\n        Args:\n        remaining_with_setup_started (dict[str, float]): A dictionary where keys are setup identifiers and values are\n                                                         some numeric data associated (e.g., timestamps, counters).\n        \"\"\"\n        # Check if there are any setups remaining or if the previous state was to have setups pending\n        if remaining_with_setup_started or self._setups_pending:\n            # Dispatch an internal signal\n            self._send_internal_signal(remaining_with_setup_started)\n\n            # Update the internal flag to reflect the current state of remaining setups\n            self._setups_pending = bool(remaining_with_setup_started)\n\n    def _send_internal_signal(self, data: dict[str, float]):\n        \"\"\"Simulate dispatching a signal with setup data.\"\"\"\n        print(\"Dispatching signal with data:\", data)\n\n# Example of usage:\nif __name__ == \"__main__\":\n    manager = SetupManager()\n    manager._async_dispatch({'setup1': 12.34})\n    manager._async_dispatch({})\n    manager._async_dispatch({'setup2': 56.78})", "CodeBleu_score": 36.66850991054641}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "class Integration:\n    def __init__(self, name: str, config: dict):\n        self.name = name\n        self.config = config\n\nclass Config:\n    def __init__(self):\n        self.errors = []\n\n    def add_error(self, error: str):\n        self.errors.append(error)\n\ndef read_current_bluetooth_file():\n    # Mock reading a file, return file content as string\n    return \"current_bluetooth_setup\"\n\ndef generate_bluetooth_config(integrations: dict[str, Integration]):\n    # Simulate taking integration details and generating a configuration string\n    configs = []\n    for name, integration in integrations.items():\n        config_details = f\"{name}: {integration.config}\"\n        configs.append(config_details)\n    return \"\\n\".join(configs)\n\ndef validate(integrations: dict[str, Integration], config: Config) -> None:\n    \"\"\"\n    Verifies the correctness of the bluetooth.py file. Generates and validates \n    the Bluetooth content based on provided integrations and stores it in the configuration cache.\n    If specific integrations are not being validated, it reads the current content of bluetooth.py \n    and compares it with the generated content. \n    If the contents differ, it adds an error to the configuration indicating \n    that bluetooth.py is not up to date and provides a fixable suggestion.\n    \"\"\"\n    generated_config = generate_bluetooth_config(integrations)\n    current_config = read_current_bluetooth_file()\n\n    if current_config != generated_config:\n        config.add_error(\"bluetooth.py is not up-to-date. Please update it with the following configuration:\")\n        config.add_error(generated_config)\n\n# Usage Example\nintegrations = {\n    \"lighting\": Integration(\"lighting\", {\"enabled\": True}),\n    \"heating\": Integration(\"heating\", {\"enabled\": False})\n}\n\nconfig = Config()\nvalidate(integrations, config)\n\nif config.errors:\n    for error in config.errors:\n        print(error)", "CodeBleu_score": 34.5415219778542}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\ndef validate(integrations: dict[str, Integration], config: Config) -> None:\n    \"\"\"\n    The function \"validate\" verifies the correctness of the bluetooth.py file for Home Assistant.\n    It generates and validates the Bluetooth content based on provided integrations and stores it in the configuration cache.\n    If specific integrations are not being validated, it reads the current content of bluetooth.py and compares it with the generated content.\n    If the contents differ, it adds an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.\n    \"\"\"\n    # Generate the expected Bluetooth content from provided integrations\n    expected_content = \"\"\n    for integration in integrations.values():\n        expected_content += f\"{integration.name}: {integration.version}\\n\"\n\n    # Retrieve the current content of the bluetooth.py file\n    with open(\"bluetooth.py\", \"r\") as file:\n        current_content = file.read()\n\n    # Compare the current content with the expected content\n    if current_content.strip() != expected_content.strip():\n        # The contents differ, add error to the config and suggest a fix\n        config.update_error(\n            \"Bluetooth configurations are not up to date. Please regenerate the bluetooth.py file.\"\n        )\n        # Here we can implement the functionality to autofix by writing expected_content to bluetooth.py\n        # For example:\n        # with open(\"bluetooth.py\", \"w\") as file:\n        #     file.write(expected_content)\n        # Note: Care must be taken with such auto-write in a production environment due to potential data loss\n        # and security concerns. Always ensure proper file handling, permissions, and safety measures.\n        print(\"ERROR: bluetooth.py needs to be updated.\")\n    else:\n        print(\"Validation successful: bluetooth.py is up to date.\")\n\n# Assuming Integration and Config classes are defined elsewhere as the types suggest\n# For example, an Integration might have properties like 'name' and 'version' while Config might handle errors and configurations state.\n", "CodeBleu_score": 36.00708072390185}, {"code": "import hashlib\n\ndef validate(integrations: dict[str, Integration], config: Config) -> None:\n    \"\"\"The function validates the correctness of the bluetooth.py file for Home Assistant.\n    It generates and validates the Bluetooth content based on provided integrations and stores it in \n    the configuration cache. If specific integrations are not being validated, it reads the current\n    content of bluetooth.py and compares it with the generated content. If the contents differ, it adds\n    an error to the configuration indicating that bluetooth.py is not up to date and provides a fixable suggestion.\"\"\"\n\n    # Step 1: Generate Bluetooth content from integrations\n    generated_content = generate_bluetooth_content(integrations)\n\n    # Step 2: Read current contents of bluetooth.py\n    try:\n        with open('bluetooth.py', 'r') as file:\n            current_content = file.read()\n    except FileNotFoundError:\n        current_content = \"\"  # If file doesn't exist, set current_content to empty string\n\n    # Step 3: Compare generated content to current content\n    if not compare_contents(generated_content, current_content):\n        # Step 4: Contents differ, add an error to the configuration\n        error_message = \"bluetooth.py is not up to date. Please update it with the latest integrations.\"\n        config.add_error(error_message)\n        config.suggest_fix(\"Please regenerate bluetooth.py using the provided integration details.\")\n\ndef generate_bluetooth_content(integrations: dict[str, Integration]) -> str:\n    \"\"\"Simulates generating content for a Bluetooth configuration file based on integrations.\"\"\"\n    # Assuming a simple joining of integration names and details\n    content = \"\\n\".join(f\"{name}: {integration.detail()}\" for name, integration in integrations.items())\n    return content\n\ndef compare_contents(generated: str, current: str) -> bool:\n    \"\"\"Compares two contents via hashing to ensure that even very large contents can be compared efficiently.\"\"\"\n    hash_gen = hashlib.sha256(generated.encode()).hexdigest()\n    hash_cur = hashlib.sha256(current.encode()).hexdigest()\n    return hash_gen == hash_cur", "CodeBleu_score": 39.7523810113999}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n)\n\ntype Dropbox struct {\n    RefreshToken string\n    AppKey       string\n    AppSecret    string\n    AccessToken  string\n}\n\nfunc (d *Dropbox) refreshToken() error {\n    endpoint := \"https://api.dropboxapi.com/oauth2/token\"\n    data := url.Values{}\n    data.Set(\"grant_type\", \"refresh_token\")\n    data.Set(\"refresh_token\", d.RefreshToken)\n    data.Set(\"client_id\", d.AppKey)\n    data.Set(\"client_secret\", d.AppSecret)\n\n    req, err := http.NewRequest(\"POST\", endpoint, bytes.NewBufferString(data.Encode()))\n    if err != nil {\n        return fmt.Errorf(\"failed to create request: %v\", err)\n    }\n    req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n    client := &http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return fmt.Errorf(\"failed to send request: %v\", err)\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        responseBytes, _ := ioutil.ReadAll(resp.Body)\n        return fmt.Errorf(\"failed to refresh token, response status: %s, response body: %s\", resp.Status, string(responseBytes))\n    }\n\n    var tokenResponse struct {\n        AccessToken string `json:\"access_token\"`\n    }\n    if err := json.NewDecoder(resp.Body).Decode(&tokenResponse); err != nil {\n        return fmt.Errorf(\"error decoding response json: %v\", err)\n    }\n\n    d.AccessToken = tokenResponse.AccessToken\n    return nil\n}\n\nfunc main() {\n    dropbox := &Dropbox{\n        RefreshToken: \"your-refresh-token\",\n        AppKey:       \"your-app-key\",\n        AppSecret:    \"your-app-secret\",\n    }\n\n    if err := dropbox.refreshToken(); err != nil {\n        fmt.Println(\"Error refreshing token:\", err)\n    } else {\n        fmt.Println(\"Token refreshed successfully. New access token:\", dropbox.AccessToken)\n    }\n}", "CodeBleu_score": 44.842568237370685}, {"code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\ntype Dropbox struct {\n\tRefreshToken string\n\tAppKey       string\n\tAppSecret    string\n\tAccessToken  string // assuming this struct field exists\n}\n\n// refreshToken refreshes the access token for a Dropbox instance.\n// It sends a POST request to the Dropbox OAuth2 token endpoint with the refresh token, app key, and app secret.\n// If the request succeeds, it updates the access token; otherwise, it logs the response and returns an error if any issues occur.\nfunc (d *Dropbox) refreshToken() error {\n\tconst endpoint = \"https://api.dropboxapi.com/oauth2/token\"\n\n\tdata := map[string]string{\n\t\t\"grant_type\":    \"refresh_token\",\n\t\t\"refresh_token\": d.RefreshToken,\n\t\t\"client_id\":     d.AppKey,\n\t\t\"client_secret\": d.AppSecret,\n\t}\n\n\tjsonData, err := json.Marshal(data)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error marshalling data: %v\", err)\n\t}\n\n\treq, err := http.NewRequest(\"POST\", endpoint, bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating request: %v\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending request to Dropbox API: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := ioutil.ReadAll(resp.Body)\n\t\treturn fmt.Errorf(\"error refreshing token, status: %d, body: %s\", resp.StatusCode, string(body))\n\t}\n\n\tresult := map[string]string{}\n\tif err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n\t\treturn fmt.Errorf(\"error decoding response: %v\", err)\n\t}\n\n\tif newToken, ok := result[\"access_token\"]; ok {\n\t\td.AccessToken = newToken\n\t} else {\n\t\treturn fmt.Errorf(\"access_token not found in response\")\n\t}\n\n\tfmt.Println(\"Token successfully refreshed\")\n\treturn nil\n}\n\nfunc main() {\n\t// Example usage\n\tdropbox := Dropbox{\n\t\tRefreshToken: \"your-refresh-token\",\n\t\tAppKey:       \"your-app-key\",\n\t\tAppSecret:    \"your-app-secret\",\n\t}\n\terr := dropbox.refreshToken()\n\tif err != nil {\n\t\tfmt.Println(\"Failed to refresh token:\", err)\n\t} else {\n\t\tfmt.Println(\"Refreshed token successfully. New token:\", dropbox.AccessToken)\n\t}\n}", "CodeBleu_score": 44.840309664360724}, {"code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\n// Dropbox represents the structure holding necessary OAuth details and credentials.\ntype Dropbox struct {\n\tAppKey      string\n\tAppSecret   string\n\tRefreshToken string\n\tAccessToken string\n}\n\n// refreshToken refreshes the access token for a Dropbox instance.\nfunc (d *Dropbox) refreshToken() error {\n\t// Setting up the endpoint and the request body\n\tendpoint := \"https://api.dropboxapi.com/oauth2/token\"\n\tdata := fmt.Sprintf(\"grant_type=refresh_token&refresh_token=%s\", d.RefreshToken)\n\tbody := bytes.NewBufferString(data)\n\n\t// Preparing the HTTP request with basic authentication\n\treq, err := http.NewRequest(\"POST\", endpoint, body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error creating request: %w\", err)\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.SetBasicAuth(d.AppKey, d.AppSecret)\n\n\t// Making the HTTP request\n\tclient := http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error sending request: %w\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Reading response body\n\trespData, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading response body: %w\", err)\n\t}\n\n\t// Handling non-200 status codes\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"refresh failed, status: %d, body: %s\", resp.StatusCode, string(respData))\n\t}\n\n\t// Unmarshaling the response body into a map\n\tvar result map[string]interface{}\n\terr = json.Unmarshal(respData, &result)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error unmarshaling response: %w\", err)\n\t}\n\n\t// Updating the access token on successful refresh\n\tif accessToken, ok := result[\"access_token\"].(string); ok {\n\t\td.AccessToken = accessToken\n\t} else {\n\t\treturn fmt.Errorf(\"error fetching new access token\")\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 44.44687020591033}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "import (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n)\n\n// request sends an authenticated HTTP request to a specified Google Drive URL using a given method.\n// It sets the authorization header with the access token and includes parameters for supporting all drives.\n// If a callback is provided, it customizes the request; if a response structure is provided, it sets the request result.\n// The function handles errors, including refreshing the token if a 401 error occurs, and retries the request after refreshing the token.\n// It returns the response body or an error if the request fails.\nfunc (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error) {\n\trequestBody := bytes.Buffer{}\n\tif callback != nil {\n\t\terr := callback(&requestBody)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treq, err := http.NewRequest(method, url, &requestBody)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\treq.Header.Add(\"SupportsAllDrives\", \"true\")\n\n\tresponse, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer response.Body.Close()\n\n\tif response.StatusCode == http.StatusUnauthorized {\n\t\terr = d.RefreshToken()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.AccessToken)\n\t\tresponse, err = http.DefaultClient.Do(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer response.Body.Close()\n\t}\n\n\tif response.StatusCode >= 400 {\n\t\treturn nil, errors.New(\"HTTP request failed with status: \" + response.Status)\n\t}\n\n\tbodyBytes, err := ioutil.ReadAll(response.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp != nil {\n\t\terr := json.Unmarshal(bodyBytes, resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn bodyBytes, nil\n}", "CodeBleu_score": 56.885741478878856}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error) {\n    // Create a new request with the provided method and URL\n    req, err := http.NewRequest(method, url, nil)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create request: %v\", err)\n    }\n\n    // Add the authorization header with the access token\n    req.Header.Add(\"Authorization\", \"Bearer \" + d.AccessToken)\n\n    // Set the header to support all drives\n    req.Header.Add(\"X-Support-All-Drives\", \"true\")\n\n    // Apply any client-specific customizations (e.g., additional headers)\n    if callback != nil {\n        callback(req)\n    }\n\n    client := &http.Client{}\n\n    // Execute the HTTP request\n    response, err := client.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"error sending request: %v\", err)\n    }\n    defer response.Body.Close()\n\n    // Read the response body\n    body, err := ioutil.ReadAll(response.Body)\n    if err != nil {\n        return nil, fmt.Errorf(\"error reading response body: %v\", err)\n    }\n\n    // Check for a 401 Unauthorized response (token refresh needed)\n    if response.StatusCode == http.StatusUnauthorized {\n        // Refresh the token\n        err := d.refreshToken()\n        if err != nil {\n            return nil, fmt.Errorf(\"error refreshing token: %v\", err)\n        }\n\n        // Retry the request with new token\n        return d.request(url, method, callback, resp)\n    }\n\n    // Handle other non-success status codes\n    if response.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"received non-OK HTTP status: %s\", response.Status)\n    }\n\n    // If a response structure is provided, decode the response into it\n    if resp != nil {\n        err := json.Unmarshal(body, resp)\n        if err != nil {\n            return nil, fmt.Errorf(\"error decoding JSON response into resp: %v\", err)\n        }\n    }\n\n    return body, nil\n}", "CodeBleu_score": 56.88032760244355}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error) {\n    // Create a new HTTP request\n    req, err := http.NewRequest(method, url, nil)\n    if err != nil {\n        return nil, fmt.Errorf(\"error creating request: %v\", err)\n    }\n\n    // Set the authorization header\n    req.Header.Set(\"Authorization\", \"Bearer \" + d.accessToken)\n\n    // If the callback is provided, allow it to customize the request\n    if callback != nil {\n        callback(req)\n    }\n\n    // Send the HTTP request\n    response, err := d.httpClient.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"error sending request: %v\", err)\n    }\n    defer response.Body.Close()\n\n    // Check if the response status indicates the need to refresh token\n    if response.StatusCode == http.StatusUnauthorized {\n        // Attempt to refresh the token\n        if err = d.refreshToken(); err != nil {\n            return nil, fmt.Errorf(\"error refreshing token: %v\", err)\n        }\n        // If the token is refreshed, retry the original request with the new token\n        return d.request(url, method, callback, resp)\n    }\n\n    // Read response body\n    body, err := io.ReadAll(response.Body)\n    if err != nil {\n        return nil, fmt.Errorf(\"error reading response body: %v\", err)\n    }\n\n    // Decode response into provided response structure if available\n    if resp != nil {\n        if err := json.Unmarshal(body, resp); err != nil {\n            return nil, fmt.Errorf(\"error decoding response: %v\", err)\n        }\n    }\n\n    // Return the raw response body and nil as error\n    return body, nil\n}", "CodeBleu_score": 55.27047063147379}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "import (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// Assuming a preset chunk size; modify according to your requirement or adjust dynamically based on file size.\nconst chunkSize = 10 * 1024 * 1024 // 10 MB\n\nfunc (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error {\n\tbuffer := make([]byte, chunkSize)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Context was cancelled or timed out\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t\t// Read data from the file stream\n\t\t\tn, readErr := stream.Read(buffer)\n\t\t\tif readErr != nil && readErr != io.EOF {\n\t\t\t\treturn fmt.Errorf(\"read error: %w\", readErr)\n\t\t\t}\n\t\t\tif n == 0 {\n\t\t\t\treturn nil // No more data to read, end the upload session\n\t\t\t}\n\n\t\t\t// Create a new HTTP request for uploading this chunk\n\t\t\treq, err := http.NewRequest(http.MethodPut, url, bytes.NewReader(buffer[:n]))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"request creation failed: %w\", err)\n\t\t\t}\n\n\t\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\t\treq.Header.Set(\"Content-Length\", fmt.Sprintf(\"%d\", n))\n\n\t\t\t// Send the HTTP request\n\t\t\tresp, err := d.httpClient.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed uploading chunk: %w\", err)\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\tif resp.StatusCode != http.StatusOK {\n\t\t\t\treturn fmt.Errorf(\"server returned non-OK status: %d\", resp.StatusCode)\n\t\t\t}\n\n\t\t\tif readErr == io.EOF {\n\t\t\t\t// This was the last chunk\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}", "CodeBleu_score": 33.09649131432619}, {"code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// GoogleDrive struct as part of Google Drive API requirement\ntype GoogleDrive struct{}\n\n// FileStreamer allows for reading files in streams\ntype FileStreamer interface {\n\tRead(p []byte) (n int, err error)\n}\n\n// chunkUpload uploads a file to Google Drive in chunks. \nfunc (d *GoogleDrive) chunkUpload(ctx context.Context, stream FileStreamer, url string) error {\n\tconst chunkSize = 256 * 1024 // 256 KB\n\n\t// Create a buffer with the chunk size\n\tbuffer := make([]byte, chunkSize)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err() // Handle context cancellation\n\n\t\tdefault:\n\t\t\t// Read from the stream in chunks\n\t\t\tbytesRead, err := stream.Read(buffer)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn err // Return any reading errors\n\t\t\t}\n\n\t\t\t// Make a HTTP request to upload the current chunk\n\t\t\treq, err := http.NewRequestWithContext(ctx, \"POST\", url, io.NopCloser(io.BytesReader(buffer[:bytesRead])))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Set necessary headers, e.g., Content-Range, Content-Length, etc.\n\t\t\t// These headers will depend on the specifics of the Google Drive API and the upload protocol used.\n\t\t\t// Example: req.Header.Set(\"Content-Range\", \"bytes x-y/total\")\n\t\t\treq.Header.Set(\"Content-Length\", strconv.Itoa(bytesRead))\n\n\t\t\t// Actual network communication: sending the HTTP request\n\t\t\tresp, err := http.DefaultClient.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\t// Check for a successful response code\n\t\t\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\t\t\treturn errors.New(\"failed to upload chunk\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 31.676512166511927}, {"code": "import (\n    \"bytes\"\n    \"context\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n)\n\nconst (\n    chunkSize = 256 * 1024 // 256 KB\n)\n\nfunc (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error {\n    // Initialize the client for HTTP requests\n    client := http.DefaultClient\n\n    // Calculate the total size of the file\n    fileSize, err := stream.Size()\n    if err != nil {\n        return fmt.Errorf(\"error getting file size: %v\", err)\n    }\n\n    var offset int64\n    for offset < fileSize {\n        // Check if the context is cancelled\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        default:\n        }\n\n        // Determine the size of the next chunk\n        nextChunkSize := min(chunkSize, fileSize-offset)\n        buffer := make([]byte, nextChunkSize)\n\n        // Read the chunk from the stream\n        _, err := stream.Read(buffer)\n        if err != nil {\n            return fmt.Errorf(\"error reading from file stream: %v\", err)\n        }\n\n        // Create HTTP request to upload the chunk\n        req, err := http.NewRequestWithContext(ctx, \"PUT\", url, bytes.NewBuffer(buffer))\n        if err != nil {\n            return fmt.Errorf(\"error creating request: %v\", err)\n        }\n\n        // Set headers to indicate the byte range being uploaded\n        req.Header.Set(\"Content-Type\", \"application/octet-stream\")\n        req.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", offset, offset+int64(len(buffer))-1, fileSize))\n\n        // Perform the HTTP request to upload the chunk\n        resp, err := client.Do(req)\n        if err != nil {\n            return fmt.Errorf(\"error uploading chunk: %v\", err)\n        }\n\n        // Check the response status\n        if resp.StatusCode < 200 || resp.StatusCode >= 300 {\n            return fmt.Errorf(\"unsuccessful chunk upload, status code: %d\", resp.StatusCode)\n        }\n\n        // Update the offset for next chunk\n        offset += int64(len(buffer))\n    }\n\n    // Finish the upload process\n    return nil\n}\n\n// min is a helper function to calculate the minimum of two values\nfunc min(a, b int64) int64 {\n    if a < b {\n        return a\n    }\n    return b\n}", "CodeBleu_score": 44.36784649790769}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "import (\n\t\"net/http\"\n\t\"os/exec\"\n\t\"github.com/labstack/echo/v4\"\n)\n\n// UmountStorage unmounts a storage device at a given mount point extracted from the request's JSON payload.\nfunc UmountStorage(ctx echo.Context) error {\n\t// Struct to hold the JSON request body\n\ttype Request struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\n\t// Create an instance of Request to bind the incoming JSON data\n\tvar req Request\n\tif err := ctx.Bind(&req); err != nil {\n\t\t// Handle JSON binding error\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid input data\")\n\t}\n\n\t// Check if the mount point is provided\n\tif req.MountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Mount point is required\")\n\t}\n\n\t// Attempt to unmount the storage\n\tcmd := exec.Command(\"umount\", req.MountPoint)\n\tif err := cmd.Run(); err != nil {\n\t\t// Return an internal server error if the unmount operation fails\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to unmount the storage device\")\n\t}\n\n\t// Assuming a function `DeleteStorageConfiguration` exists to handle configuration cleanup\n\tif err := DeleteStorageConfiguration(req.MountPoint); err != nil {\n\t\t// If configuration deletion fails, respond accordingly\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, \"Failed to delete storage configuration\")\n\t}\n\n\t// Return a success response\n\treturn ctx.NoContent(http.StatusOK)\n}\n\n// Dummy function to represent configuration deletion. Replace or modify according to actual implementation.\nfunc DeleteStorageConfiguration(mountPoint string) error {\n\t// actual implementation goes here\n\treturn nil\n}", "CodeBleu_score": 33.007158420148805}, {"code": "// UmountStorage handles the unmounting of a storage device.\n// It binds JSON data from the request context and retrieves the \"mount_point\" value.\n// If the mount point is empty, it returns a client error response.\n// It attempts to unmount the storage at the specified mount point and returns a service error response if unmounting fails.\n// If successful, it deletes the corresponding configuration and returns a success response.\nfunc UmountStorage(ctx echo.Context) error {\n    // Define a struct for binding JSON request\n    type request struct {\n        MountPoint string `json:\"mount_point\"`\n    }\n\n    // Initialize variable to hold the request data\n    var req request\n\n    // Bind incoming JSON data to the struct\n    if err := ctx.Bind(&req); err != nil {\n        return ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"Invalid request body\"})\n    }\n\n    // Check if the mount point is empty\n    if req.MountPoint == \"\" {\n        return ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"Mount point is required\"})\n    }\n\n    // Attempt to unmount the storage at the specified mount point\n    if err := unmountStorage(req.MountPoint); err != nil {\n        return ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": \"Failed to unmount storage\"})\n    }\n\n    // Assuming a function exists to delete the configuration for the mount point\n    if err := deleteConfig(req.MountPoint); err != nil {\n        return ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": \"Failed to delete storage configuration\"})\n    }\n\n    // Return success response\n    return ctx.JSON(http.StatusOK, echo.Map{\"message\": \"Storage unmounted successfully\"})\n}\n\n// unmountStorage simulates the unmounting process\n// In a real scenario, os/exec or syscall should be used to run `umount` command or system calls.\nfunc unmountStorage(mountPoint string) error {\n    // Simulated unmounting logic, replace with actual command in production\n    // For example:\n    // cmd := exec.Command(\"umount\", mountPoint)\n    // if err := cmd.Run(); err != nil {\n    //     return err\n    // }\n    return nil // Return nil to simulate success for now\n}\n\n// deleteConfig simulates deleting the configuration for a mount point\nfunc deleteConfig(mountPoint string) error {\n    // Simulated configuration deletion logic, replace with actual handling in production\n    return nil // Return nil to simulate success for now\n}", "CodeBleu_score": 33.00854915490014}, {"code": "package main\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"github.com/labstack/echo/v4\"\n)\n\n// UmountStorage handles the unmounting of a storage device.\n// It binds JSON data from the request context and retrieves the \"mount_point\" value.\n// If the mount point is empty, it returns a client error response.\n// It attempts to unmount the storage at the specified mount point and returns a service error response if unmounting fails.\n// If successful, it deletes the corresponding configuration and returns a success response.\nfunc UmountStorage(ctx echo.Context) error {\n\t// Create a struct to hold the input JSON data\n\ttype Request struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\n\t// Initialize a new instance of the Request struct\n\tvar req Request\n\n\t// Bind the incoming JSON to the struct\n\tif err := ctx.Bind(&req); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"Invalid input data\"})\n\t}\n\n\t// Check if the mount point is provided\n\tif req.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"Mount point is required\"})\n\t}\n\n\t// Attempt to unmount the storage\n\tif err := exec.Command(\"umount\", req.MountPoint).Run(); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": \"Failed to unmount storage\"})\n\t}\n\n\t// Delete corresponding configuration or perform cleanup\n\t// Placeholder: Actual deletion logic depends on where/how configurations are stored\n\t// os.Remove(\"path/to/configuration\")\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"message\": \"Storage unmounted successfully\"})\n}\n\nfunc main() {\n\te := echo.New()\n\te.POST(\"/umount\", UmountStorage)\n\te.Logger.Fatal(e.Start(\":8080\"))\n}", "CodeBleu_score": 31.835119765954182}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "package main\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\n\t\"github.com/labstack/echo/v4\"\n)\n\n// GetLocalFile handles HTTP requests to retrieve a local file.\n// It extracts the file path from the query parameters and checks if the path is provided.\n// If the path is missing or the file does not exist, it returns a JSON response with an appropriate error message.\n// If the file exists, it returns the file to the client.\nfunc GetLocalFile(ctx echo.Context) error {\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the path query parameter is provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"message\": \"File path is required\"})\n\t}\n\n\t// Check if the file exists \n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"message\": \"File does not exist\"})\n\t} else if err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"message\": \"Error checking file existence\"})\n\t}\n\n\t// Return the file\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 34.83826403380546}, {"code": "import (\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc GetLocalFile(ctx echo.Context) error {\n\t// Extracting file path from query parameters\n\tfilePath := ctx.QueryParam(\"path\")\n\n\t// Check if the file path is not provided\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"File path is required\"})\n\t}\n\n\t// Check if the file exists\n\t_, err := os.Stat(filePath)\n\tif os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File does not exist\"})\n\t}\n\n\t// If there's an unknown error attempting to check file existence\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t}\n\n\t// Return the file\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 37.610125947020364}, {"code": "import (\n\t\"net/http\"\n\t\"os\"\n)\n\n// GetLocalFile handles HTTP requests to retrieve a local file.\n// It extracts the file path from the query parameters and checks if the path is provided.\n// If the path is missing or the file does not exist, it returns a JSON response with an appropriate error message.\n// If the file exists, it returns the file to the client.\nfunc GetLocalFile(ctx echo.Context) error {\n\t// Retrieve the 'path' query parameter from the request URL.\n\tfilePath := ctx.QueryParam(\"path\")\n\tif filePath == \"\" {\n\t\t// If the 'path' query parameter is empty or not provided, return an error.\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\"error\": \"File path is required\"})\n\t}\n\n\t// Check if the file exists at the given path\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\t// If the file does not exist, return an error.\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\"error\": \"File does not exist\"})\n\t}\n\n\t// If the file exists, serve it.\n\treturn ctx.File(filePath)\n}", "CodeBleu_score": 35.96352270123777}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "package main\n\nimport (\n\t\"net/http\"\n\t\"github.com/labstack/echo/v4\"\n)\n\n// PostNotifyMessage handles HTTP POST requests to send a notification.\n// It retrieves the \"name\" parameter from the request context and binds the request body to a message map.\n// If binding fails, it returns a bad request error with the binding error message.\n// If successful, it sends the notification using the \"name\" and \"message\", then returns a success response.\nfunc PostNotifyMessage(ctx echo.Context) error {\n\t// Retrieve the \"name\" parameter from the request context\n\tname := ctx.Param(\"name\")\n\tif name == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"name parameter is required\"})\n\t}\n\n\t// Create a map to bind the request body to\n\tmessage := make(map[string]interface{})\n\n\t// Attempt to bind the request body to the message map\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"failed to bind request body\", \"details\": err.Error()})\n\t}\n\n\t// Dummy function to simulate sending a notification\n\terr := sendNotification(name, message)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": \"failed to send notification\", \"details\": err.Error()})\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"message\": \"notification sent successfully\"})\n}\n\n// Dummy sendNotification function for example purposes\nfunc sendNotification(name string, message map[string]interface{}) error {\n\t// Logic to send the notification would be implemented here\n\t// For demonstration, we'll just assume it always succeeds\n\treturn nil\n}", "CodeBleu_score": 55.78447151966897}, {"code": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"net/http\"\n)\n\n// PostNotifyMessage handles HTTP POST requests to send a notification.\n// It retrieves the \"name\" parameter from the request context and binds the request body to a message map.\n// If binding fails, it returns a bad request error with the binding error message.\n// If successful, it sends the notification using the \"name\" and \"message\", then returns a success response.\nfunc PostNotifyMessage(ctx echo.Context) error {\n\t// Retrieve name parameter from the query or path\n\tname := ctx.QueryParam(\"name\")  // If \"name\" is expected to be in query parameters\n\t// Alternatively, if \"name\" is expected to be in path parameters, use:\n\t// name := ctx.Param(\"name\")\n\n\t// Define a map to hold the message content\n\tvar message map[string]interface{}\n\n\t// Binding the request body to the map\n\tif err := ctx.Bind(&message); err != nil {\n\t\t// If binding fails, return a bad request status with the error message\n\t\treturn ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"Failed to bind request body: \" + err.Error()})\n\t}\n\n\t// Simulate sending a notification (You can replace this with actual send logic)\n\tif err := sendNotification(name, message); err != nil {\n\t\t// If sending the notification fails, handle the error (e.g., return an internal server error)\n\t\treturn ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": \"Failed to send notification: \" + err.Error()})\n\t}\n\n\t// If the process is successful, return a success response\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"message\": \"Notification sent successfully.\"})\n}\n\n// Dummy function to simulate sending a notification\nfunc sendNotification(name string, message map[string]interface{}) error {\n\t// Implement notification sending logic here\n\t// e.g., pushing a message to a notification service or logging\n\n\treturn nil  // Return nil if successful or an error if failed\n}", "CodeBleu_score": 52.17265290114257}, {"code": "import (\n    \"net/http\"\n    \"github.com/labstack/echo/v4\"\n)\n\n// PostNotifyMessage handles HTTP POST requests to send a notification.\n// It retrieves the \"name\" parameter from the request context and binds the request body to a message map.\n// If binding fails, it returns a bad request error with the binding error message.\n// If successful, it sends the notification using the \"name\" and \"message\", then returns a success response.\nfunc PostNotifyMessage(ctx echo.Context) error {\n    // Retrieve \"name\" from query parameters or path variables\n    name := ctx.Param(\"name\")\n    if name == \"\" {\n        return ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"name parameter is required\"})\n    }\n\n    // Bind incoming JSON body to a map\n    message := make(map[string]interface{})\n    if err := ctx.Bind(&message); err != nil {\n        return ctx.JSON(http.StatusBadRequest, echo.Map{\"error\": \"failed to bind request body\", \"details\": err.Error()})\n    }\n\n    // Placeholder for sending the notification\n    // You may need to replace this with actual logic to send the notification to a system or service\n    err := sendNotification(name, message)\n    if err != nil {\n        return ctx.JSON(http.StatusInternalServerError, echo.Map{\"error\": \"failed to send notification\", \"details\": err.Error()})\n    }\n\n    // Return success response\n    return ctx.JSON(http.StatusOK, echo.Map{\"message\": \"Notification sent successfully\"})\n}\n\n// Mock function to simulate sending a notification, replace or implement as necessary.\nfunc sendNotification(name string, message map[string]interface{}) error {\n    // Logic to send notification, possibly to external service or messaging system\n    // This is a dummy implementation\n    return nil // Assume success, no error\n}", "CodeBleu_score": 55.361833985941765}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "import (\n    \"github.com/labstack/echo/v4\"\n    \"github.com/gorilla/websocket\"\n    \"log\"\n)\n\nvar (\n    upgrader = websocket.Upgrader{\n        ReadBufferSize:  1024,\n        WriteBufferSize: 1024,\n        CheckOrigin: func(r *http.Request) bool {\n            return true // Optionally put your check here (e.g., checking the origin)\n        },\n    }\n    connections []*websocket.Conn\n)\n\nfunc NotifyWS(ctx echo.Context) error {\n    // Upgrade the HTTP server connection to the WebSocket protocol\n    ws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n    if err != nil {\n        return err\n    }\n    \n    // Add the WebSocket connection to our list of connections\n    connections = append(connections, ws)\n    \n    // Start a new goroutine for listening to messages on the WebSocket\n    go func(ws *websocket.Conn) {\n        defer func() {\n            ws.Close()\n        }()\n        \n        for {\n            // Read message from WebSocket connection\n            _, msg, err := ws.ReadMessage()\n            if err != nil {\n                log.Println(\"Error reading message:\", err)\n                break\n            }\n            \n            log.Println(\"Received message:\", string(msg))\n        }\n    }(ws)\n\n    return nil\n}", "CodeBleu_score": 39.447887061729844}, {"code": "import (\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\t// You might want to configure the CheckOrigin field in a production setting to check the Origin header against expected origins.\n\tCheckOrigin: func(c echo.Context) bool { return true },\n}\n\nfunc NotifyWS(c echo.Context) error {\n\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the WebSocket to a global list of connections (not implemented here)\n\t// For example: globals.connections = append(globals.connections, ws)\n\n\t// Ensure that some WebSocket message handling service is running (message pump, broadcaster, etc.)\n\t// Not implemented here - typically you might start these services earlier in your application lifecycle or ensure they are running\n\n\t// Reads messages from WebSocket and handle them\n\tfor {\n\t\t// Read message from websocket\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tif websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {\n\t\t\t\tc.Logger().Error(\"error: \", err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\t// Process the message (for now, just print it out)\n\t\tc.Logger().Infof(\"Received ws message: %s\", string(msg))\n\t}\n\n\treturn nil\n}", "CodeBleu_score": 41.66226179068834}, {"code": "package main\n\nimport (\n\t\"log\"\n\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/labstack/echo/v4/middleware\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\t// Default upgrader options; adjust buffer sizes, check origin etc., as needed.\n\tupgrader = websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true // or implement your own logic\n\t\t},\n\t}\n\t// This would be a global or shared list of websocket connections\n\tactiveConnections []*websocket.Conn\n)\n\n// NotifyWS handles WebSocket requests for the Echo framework.\nfunc NotifyWS(ctx echo.Context) error {\n\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\tlog.Println(\"Error upgrading to websocket:\", err)\n\t\treturn err\n\t}\n\tdefer ws.Close()\n\n\t// Add the new WebSocket connection to the list of active connections\n\tactiveConnections = append(activeConnections, ws)\n\n\tlog.Println(\"New WebSocket connection established. Total connections:\", len(activeConnections))\n\n\t// Ensure message sending service is running (specific implementation needed based on app design)\n\n\t// Read messages continuously\n\tfor {\n\t\t_, msg, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading websocket message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"Received message: %s\\n\", msg)\n\t\t// Handle messages (Echoing back is just an example)\n\t\tif err := ws.WriteMessage(websocket.TextMessage, msg); err != nil {\n\t\t\tlog.Println(\"Error sending message:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\t// Remove the closed connection from the list\n\tfor i, conn := range activeConnections {\n\t\tif conn == ws {\n\t\t\tactiveConnections = append(activeConnections[:i], activeConnections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tlog.Println(\"WebSocket connection closed. Total connections:\", len(activeConnections))\n\n\treturn nil\n}\n\nfunc main() {\n\t// Create a new Echo instance\n\te := echo.New()\n\te.Use(middleware.Logger())\n\n\t// Route => handler\n\te.GET(\"/ws\", NotifyWS)\n\n\t// Start server\n\te.Logger.Fatal(e.Start(\":8080\"))\n}", "CodeBleu_score": 37.07225913733222}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "package main\n\nimport (\n\t\"github.com/labstack/echo/v4\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"encoding/json\"\n)\n\n// HardwareInfo structure for JSON response\ntype HardwareInfo struct {\n\tDriveModel    string `json:\"drive_model\"`\n\tArchitecture  string `json:\"architecture\"`\n\tCPUInfo       string `json:\"cpu_info,omitempty\"`\n\tSuccess       bool   `json:\"success\"`\n\tErrorMessage  string `json:\"error_message,omitempty\"`\n}\n\n// getDriveModel simulates retrieval of the drive model. \n// You would replace this with an actual implementation.\nfunc getDriveModel() (string, error) {\n\t// Simulating disk model information retrieval.\n\treturn \"ExampleSSDModel123\", nil\n}\n\n// getCPUInfo retrieves the CPU information using the 'lscpu' command on UNIX-like systems.\nfunc getCPUInfo() (string, error) {\n\tcmd := exec.Command(\"lscpu\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(output), nil\n}\n\n// GetSystemHardwareInfo retrieves system hardware information and returns it as JSON.\nfunc GetSystemHardwareInfo(ctx echo.Context) error {\n\t// Fetching drive model\n\tdriveModel, err := getDriveModel()\n\tif err != nil {\n\t\treturn ctx.JSON(500, HardwareInfo{Success: false, ErrorMessage: \"Failed to get drive model\"})\n\t}\n\n\t// Fetch architecture using runtime package\n\tarchitecture := runtime.GOARCH\n\n\t// Fetching CPU information\n\tcpuInfo, err := getCPUInfo()\n\tif err != nil {\n\t\t// Return information without CPU info if there is an error fetching it.\n\t\treturn ctx.JSON(200, HardwareInfo{\n\t\t\tDriveModel:   driveModel,\n\t\t\tArchitecture: architecture,\n\t\t\tSuccess:      true,\n\t\t})\n\t}\n\n\t// Create HardwareInfo object\n\thardwareInfo := HardwareInfo{\n\t\tDriveModel:   driveModel,\n\t\tArchitecture: architecture,\n\t\tCPUInfo:      cpuInfo,\n\t\tSuccess:      true,\n\t}\n\n\t// Return JSON response with hardware information\n\treturn ctx.JSON(200, hardwareInfo)\n}\n\nfunc main() {\n\t// Initialize Echo instance\n\te := echo.New()\n\n\t// Route to handle GET request on `/hardware-info`\n\te.GET(\"/hardware-info\", GetSystemHardwareInfo)\n\n\t// Start server\n\te.Logger.Fatal(e.Start(\":8080\"))\n}", "CodeBleu_score": 23.08130464550188}, {"code": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"github.com/labstack/echo/v4\"\n\t\"github.com/shirou/gopsutil/disk\"\n\t\"runtime\"\n)\n\n// The function \"GetSystemHardwareInfo\" retrieves and returns system hardware information as a JSON response.\n// It gathers the drive model and architecture, and if CPU information is available, it returns this data with a success message.\n// If CPU information is not available, it returns \"nil\".\n\nfunc GetSystemHardwareInfo(ctx echo.Context) error {\n\t// Fetch CPU architecture\n\tarchitecture := runtime.GOARCH\n\n\t// Fetch drive information\n\tdrives, err := disk.Partitions(false)\n\tif err != nil {\n\t\treturn ctx.JSON(500, map[string]string{\"error\": \"Failed to retrieve drive information\"})\n\t}\n\n\tdriveModels := []string{}\n\tfor _, part := range drives {\n\t\tdriveInfo, err := disk.IOCounters(part.Device)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, info := range driveInfo {\n\t\t\tdriveModels = append(driveModels, info.Model)\n\t\t}\n\t}\n\n\t// Package the response\n\tinfo := map[string]interface{}{\n\t\t\"architecture\": architecture,\n\t\t\"drives\":       driveModels,\n\t}\n\n\t// Check if essential CPU information is present\n\tif len(driveModels) == 0 {\n\t\treturn ctx.JSON(200, \"nil\") // No drive information could imply no CPU information available\n\t}\n\n\t// Return successful JSON response with the hardware information\n\treturn ctx.JSON(200, info)\n}\n\nfunc main() {\n\t// Assuming main function and setup of Echo framework goes here.\n}", "CodeBleu_score": 24.35799858999925}, {"code": "import (\n    \"github.com/labstack/echo/v4\"\n    \"runtime\"\n    \"encoding/json\"\n    \"net/http\"\n)\n\ntype SystemInfo struct {\n    DriveModel    string `json:\"drive_model\"`\n    Architecture  string `json:\"architecture\"`\n    CPUInfo       string `json:\"cpu_info,omitempty\"`\n}\n\n// GetSystemHardwareInfo retrieves and returns system hardware information as a JSON response.\n// It gathers the drive model and architecture. If CPU information is available, it returns this data with a success message.\n// If CPU information is not available, it returns nil.\nfunc GetSystemHardwareInfo(ctx echo.Context) error {\n    // For demonstration, let's assume some static values, in real scenarios\n    // these should be retrieved from the system\n    driveModel := \"Example SSD 1TB\"\n    architecture := runtime.GOARCH\n    cpuInfo := \"Intel i7-8750H\" // This could be an empty string if not found\n\n    systemInfo := SystemInfo{\n        DriveModel:   driveModel,\n        Architecture: architecture,\n        CPUInfo:      cpuInfo,\n    }\n\n    // Check if CPU information is missing. If so, set the CPUInfo field to an empty string\n    if systemInfo.CPUInfo == \"\" {\n        return ctx.JSON(http.StatusOK, nil)\n    }\n\n    // Marshal the system information into a JSON response\n    jsonResponse, err := json.Marshal(systemInfo)\n    if err != nil {\n        return ctx.NoContent(http.StatusInternalServerError)\n    }\n\n    // Send the JSON response with the system information\n    return ctx.JSONBlob(http.StatusOK, jsonResponse)\n}", "CodeBleu_score": 22.138555075423483}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "package service\n\nimport (\n\t\"strings\"\n\t// Assume there is a `systemctl` package implemented\n\t\"systemctl\"\n)\n\ntype service struct {}\n\nfunc (s *service) Services() (map[bool][]string, error) {\n\t// Initialize the map to store result with keys as boolean and values as slices of strings\n\tresults := make(map[bool][]string)\n\tresults[true] = []string{}\n\tresults[false] = []string{}\n\n\t// Call ListServices from systemctl\n\tservices, err := systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Loop through each service and categorize them\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service.Name, \"casaos*\") {\n\t\t    // Determine if the service is active or not\n\t\t    isActive := service.Status == \"running\"\n\n\t\t    if isActive {\n\t\t        results[true] = append(results[true], service.Name)\n\t\t    } else {\n\t\t        results[false] = append(results[false], service.Name)\n\t\t    }\n\t\t}\n\t}\n\n\treturn results, nil\n}", "CodeBleu_score": 39.76769807857362}, {"code": "func (s *service) Services() (map[bool][]string, error) {\n    // Call to ListServices to retrieve all services\n    services, err := s.systemctl.ListServices()\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to list services: %w\", err)\n    }\n\n    // Initialize map to store running and not running services\n    categorizedServices := make(map[bool][]string)\n    runningServices := []string{}\n    notRunningServices := []string{}\n\n    // Iterate over all services returned by ListServices\n    for _, service := range services {\n        // Check if the service name matches the pattern \"casaos*\"\n        if strings.HasPrefix(service.Name, \"casaos\") {\n            // Check the running status of the service\n            if service.Status == \"running\" {\n                runningServices = append(runningServices, service.Name)\n            } else {\n                notRunningServices = append(notRunningServices, service.Name)\n            }\n        }\n    }\n\n    // Populate the map with running and not running services classified by their names\n    categorizedServices[true] = runningServices\n    categorizedServices[false] = notRunningServices\n\n    // Return the map with services categorized by running status\n    return categorizedServices, nil\n}", "CodeBleu_score": 49.04264698914046}, {"code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/coreos/go-systemd/v22/dbus\"\n)\n\n// Assuming you have a service struct\ntype service struct {\n\tconn *dbus.Conn\n}\n\n// Services retrieves a list of services matching \"casaos*\" and categorizes them based on their running status.\n// It uses `systemctl.ListUnitsByPatterns` to get the services and checks for errors.\n// It then separates the services into running and not running lists based on their status.\n// Finally, it returns a map with boolean keys indicating the running status,\n// each pointing to the corresponding list of service names.\nfunc (s *service) Services() (map[bool][]string, error) {\n\t// Connect to the system bus if not already connected\n\tif s.conn == nil {\n\t\tvar err error\n\t\ts.conn, err = dbus.New()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Retrieve all units that match the pattern \"casaos*\"\n\tunits, err := s.conn.ListUnitsByPatterns([]string{}, []string{\"casaos*\"})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Map to hold running (true) and not running (false) services\n\tstatusMap := make(map[bool][]string)\n\tfor _, unit := range units {\n\t\t// Check if the unit is actively running\n\t\tisRunning := unit.ActiveState == \"active\"\n\t\t// Append to the correct list based on whether it is running or not\n\t\tstatusMap[isRunning] = append(statusMap[isRunning], unit.Name)\n\t}\n\n\treturn statusMap, nil\n}\n\nfunc main() {\n\tsvc := &service{}\n\tresults, err := svc.Services()\n\tif err != nil {\n\t\tfmt.Printf(\"Error retrieving services: %s\\n\", err)\n\t\treturn\n\t}\n\n\t// Print the running and not running services\n\tfor status, services := range results {\n\t\tfmt.Printf(\"Running: %t\\n\", status)\n\t\tfor _, service := range services {\n\t\t\tfmt.Println(\" -\", service)\n\t\t}\n\t}\n}", "CodeBleu_score": 35.3425019410614}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{}) {\n\t// Marshal the message map to JSON\n\tjsonData, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Error while marshalling message: %s\", err)\n\t\treturn // Exit the function on error\n\t}\n\n\t// Publish event to the message bus\n\terr = i.messageBus.Publish(name, jsonData)\n\tif err != nil {\n\t\tlog.Printf(\"Error while publishing message: %s\", err)\n\t\treturn // Exit the function on error\n\t}\n\n\t// Log the successful transmission of the notification\n\tlog.Printf(\"Successfully sent notification for %s\", name)\n}", "CodeBleu_score": 32.53092575585539}, {"code": "import (\n    \"encoding/json\"\n    \"log\"\n\n    \"github.com/streadway/amqp\"\n)\n\n// notifyServer struct represents a server with a message bus connection.\ntype notifyServer struct {\n    connection *amqp.Connection\n}\n\n// SendNotify sends a notification with a given name and message map.\n// It serializes the message values to JSON strings and publishes the event to a message bus, logging any errors that occur during publishing.\n// If the response status code is not OK, it logs the failure along with the response details.\nfunc (i *notifyServer) SendNotify(name string, message map[string]interface{}) {\n    // Encode message map to JSON\n    messageJSON, err := json.Marshal(message)\n    if err != nil {\n        log.Printf(\"Failed to encode message to JSON: %v\", err)\n        return\n    }\n\n    // Ensure the connection to the message bus is open\n    if i.connection == nil {\n        log.Println(\"Message bus connection is not established\")\n        return\n    }\n\n    // Open a channel\n    channel, err := i.connection.Channel()\n    if err != nil {\n        log.Printf(\"Failed to open a channel: %v\", err)\n        return\n    }\n    defer channel.Close()\n\n    // Declare a queue\n    queue, err := channel.QueueDeclare(\n        name,    // Queue name\n        false,   // Durable\n        false,   // Delete when unused\n        false,   // Exclusive\n        false,   // No-wait\n        nil,     // Arguments\n    )\n    if err != nil {\n        log.Printf(\"Failed to declare a queue: %v\", err)\n        return\n    }\n\n    // Publish the message\n    err = channel.Publish(\n        \"\",         // Exchange\n        queue.Name, // Routing key (queue name)\n        false,      // Mandatory\n        false,      // Immediate\n        amqp.Publishing{\n            ContentType: \"application/json\",\n            Body:        messageJSON,\n        },\n    )\n    if err != nil {\n        log.Printf(\"Failed to publish message: %v\", err)\n        return\n    }\n\n    log.Printf(\"Notification sent: %s\", name)\n}", "CodeBleu_score": 36.79371882503251}, {"code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n\n    // Hypothetical message bus library\n    \"github.com/some/messagebus\"\n)\n\n// notifyServer struct definition - making an assumption about its structure\ntype notifyServer struct{\n    Bus *messagebus.MessageBus // Assuming a message bus type\n}\n\n// SendNotify sends a notification with a given name and message map.\n// It serializes the message values to JSON strings and publishes the event to a message bus,\n// logging any errors that occur during publishing.\n// If the response status code is not OK, it logs the failure along with the response details.\nfunc (i *notifyServer) SendNotify(name string, message map[string]interface{}) {\n    // Serialize the message map to JSON\n    messageJSON, err := json.Marshal(message)\n    if err != nil {\n        log.Printf(\"Error serializing message: %v\", err)\n        return\n    }\n\n    // Publish the event to the message bus\n    response, err := i.Bus.Publish(name, messageJSON)\n    if err != nil {\n        log.Printf(\"Error publishing message: %v\", err)\n        return\n    }\n\n    // Check if the response status is not OK\n    if response.StatusCode != 200 { // Assuming HTTP-style status codes\n        log.Printf(\"Failed to send notification with status: %d, details: %s\", response.StatusCode, response.Details)\n    } else {\n        log.Printf(\"Notification sent successfully\")\n    }\n}\n\nfunc main() {\n    // Initialize your messagebus and notifyServer\n    bus := messagebus.New() // Assumes a constructor function\n    server := notifyServer{Bus: bus}\n    \n    // Build a message map\n    messageMap := map[string]interface{}{\n        \"title\": \"New Notification\",\n        \"body\": \"This is a test notification.\",\n    }\n\n    // Send notification\n    server.SendNotify(\"Alert\", messageMap)\n}", "CodeBleu_score": 33.386084340124846}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "package main\n\nimport (\n    \"message_bus\" // This import assumes message_bus is a package managing the message bus client.\n)\n\n// Assuming 'store' is a previously declared type that represents a storage or context \n// from which runtime configuration can be extracted, and ClientWithResponses\n// is a type defined in the message_bus package that includes server address and other configuration.\ntype store struct {\n    runtimePath string\n}\n\n// Assuming defaultAddress holds the fallback address in case retrieving\n// the actual message bus address fails.\nconst defaultAddress string = \"http://error_default_address.com\"\n\n// MessageBus creates and returns a new message bus client with configured server address.\n// It initializes the client to either retrieved message bus address or to a default error message.\nfunc (c *store) MessageBus() *message_bus.ClientWithResponses {\n    address := c.getMessageBusAddress()\n\n    client := message_bus.NewClientWithResponses()\n    if address != \"\" {\n        client.SetServer(address)\n    } else {\n        client.SetServer(defaultAddress)\n    }\n\n    return client\n}\n\n// getMessageBusAddress attempts to retrieve the message bus address. \n// We assume there's an internal or external method to actually access this information\n// which could be filesystem, environment variable, or configuration management system.\n// Returns empty string if unable to retrieve the address.\nfunc (c *store) getMessageBusAddress() string {\n    // Example pseudo-code, actual implementation depends on how addresses are managed.\n    address, err := SomeExternalLibrary.GetAddress(c.runtimePath)\n    if err != nil {\n        // Log the error and return an empty string\n        // fmt.Printf(\"Failed to retrieve message bus address: %v\\n\", err)\n        return \"\"\n    }\n    return address\n}", "CodeBleu_score": 37.306440839175295}, {"code": "// The function \"MessageBus\" creates and returns a new message bus client with responses.\n// It initializes the client and attempts to retrieve the message bus address using a specified runtime path.\n// If the address is found, it sets the client's server to the retrieved address; otherwise, it sets the server to a default error message.\n// The function then returns the initialized client.\nfunc (s *store) MessageBus() *message_bus.ClientWithResponses {\n    address, err := s.getRuntimeMessageBusAddress()\n    if err != nil {\n        return &message_bus.ClientWithResponses{\n            Server: \"Error: Unable to retrieve Message Bus address.\",\n        }\n    }\n\n    client := message_bus.NewClientWithResponses(address)\n    return client\n}\n\n// getRuntimeMessageBusAddress simulates getting a message bus address from runtime configuration.\n// This is a placeholder method intended to represent fetching a configuration from a typical store.\nfunc (s *store) getRuntimeMessageBusAddress() (string, error) {\n    if runtimeAddress := s.config.MessageBusAddress; runtimeAddress != \"\" {\n        return runtimeAddress, nil\n    }\n    return \"\", fmt.Errorf(\"no address configured\")\n}", "CodeBleu_score": 39.3216883544502}, {"code": "package main\n\nimport (\n    \"fmt\"\n    \"message_bus\"\n    \"os\"\n)\n\ntype store struct {\n    RuntimePath string\n}\n\n// MessageBus creates and returns a new message bus client with responses.\n// It initializes the client and attempts to retrieve the message bus address using a specified runtime path.\n// If the address is found, it sets the client's server to the retrieved address; otherwise, it sets the server to a default error message.\n// The function then returns the initialized client.\nfunc (c *store) MessageBus() *message_bus.ClientWithResponses {\n    var messageBusAddress string\n    if c.RuntimePath == \"\" {\n        c.RuntimePath = \"/default/path/to/runtime\"\n    }\n\n    // Simulate reading a message bus address from a runtime configuration file or environment variable\n    messageBusAddress, found := os.LookupEnv(\"MESSAGE_BUS_ADDRESS\")\n    if !found || messageBusAddress == \"\" {\n        // Fallback if no address found\n        fmt.Println(\"Message bus address not found, using default error address\")\n        messageBusAddress = \"http://erroraddress\"\n    }\n\n    // Initialize the client for the message bus\n    client, err := message_bus.NewClientWithResponses(messageBusAddress)\n    if err != nil {\n        fmt.Printf(\"Failed to create message bus client: %s\\n\", err)\n        return nil\n    }\n\n    return client\n}", "CodeBleu_score": 37.397927076836616}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string {\n\t// First, check the X-Forwarded-For header for any forwarded IP addresses.\n\txForwardedFor := request.Header.Get(\"X-Forwarded-For\")\n\tif xForwardedFor != \"\" {\n\t\t// Split the header value by comma as it might contain multiple IPs\n\t\tips := strings.Split(xForwardedFor, \",\")\n\t\t// Trim any spaces that might be around the IP address\n\t\tfirstIP := strings.TrimSpace(ips[0])\n\t\treturn normalizeIP(firstIP)\n\t}\n\n\t// If X-Forwarded-For is not set, fall back to using the remote address.\n\tremoteAddr := request.RemoteAddr\n\n\t// HTTP requests contain the port number in RemoteAddr, so we need to strip it\n\tip, _, err := net.SplitHostPort(remoteAddr)\n\tif err != nil {\n\t\t// In case the IP address is without a port, use it directly\n\t\tip = remoteAddr\n\t}\n\treturn normalizeIP(ip)\n}\n\n// normalizeIP handles converting loopback IP addresses and prepares the final IP address for return.\nfunc normalizeIP(ip string) string {\n\t// Check for the loopback addresses and convert them to \"127.0.0.1\"\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\treturn \"127.0.0.1\"\n\t}\n\treturn ip\n}", "CodeBleu_score": 43.13478205710243}, {"code": "import (\n    \"net/http\"\n    \"strings\"\n)\n\nfunc GetIP(request *http.Request) string {\n    // retrieves the IP address from an HTTP request.\n    var ip string\n    \n    // Check the \"x-forwarded-for\" header and extracts the first IP if present.\n    xForwardedFor := request.Header.Get(\"x-forwarded-for\")\n    if xForwardedFor != \"\" {\n        ips := strings.Split(xForwardedFor, \",\")\n        if len(ips) > 0 {\n            ip = strings.TrimSpace(ips[0])\n        }\n    }\n    \n    // If the header is not available, use the request's remote address.\n    if ip == \"\" {\n        ip = request.RemoteAddr // This contains port so we may need to strip the port.\n        ip = strings.Split(ip, \":\")[0]\n    }\n    \n    // Convert loopback addresses \"::1\" and \"::ffff:127.0.0.1\" to \"127.0.0.1\"\n    if ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n        ip = \"127.0.0.1\"\n    }\n\n    return ip\n}", "CodeBleu_score": 64.80845862742595}, {"code": "func GetIP(request *http.Request) string {\n    // First, extract the IP address from the 'x-forwarded-for' header if available\n    xForwardedFor := request.Header.Get(\"x-forwarded-for\")\n    if xForwardedFor != \"\" {\n        splitIPs := strings.Split(xForwardedFor, \",\")\n        if len(splitIPs) > 0 {\n            return strings.TrimSpace(splitIPs[0])\n        }\n    }\n\n    // If 'x-forwarded-for' header is not present, use the remote address\n    remoteIP := request.RemoteAddr\n    // Extract IP from the remote address which might contain the port\n    ip, _, err := net.SplitHostPort(remoteIP)\n    if err != nil {\n        ip = remoteIP // In case of an error, use the remoteIP directly\n    }\n\n    // Normalize loopback addresses\n    if ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n        return \"127.0.0.1\"\n    }\n\n    return ip\n}", "CodeBleu_score": 44.168549295951806}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\n\u5206\u6790\u5931\u8d25", "CodeBleu_score": 0.8620689655172413}, {"code": "import (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// A mock structure for systemService\ntype systemService struct {\n\tmodulesDir   string\n\tentryFilePath string\n}\n\n// GenreateSystemEntry generates a consolidated system entry JSON file\n// It defines paths for the modules directory and the entry file, ensuring the entry file exists\n// It reads each module directory for entry.json files, concatenates their content into a single JSON array,\n// and writes this array to the entry file path.\n// Errors encountered during directory reading, file reading, or file writing are logged accordingly.\nfunc (c *systemService) GenreateSystemEntry() {\n\t// Make sure the directory exists\n\tif _, err := os.Stat(c.modulesDir); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"Modules directory does not exist: %s\", c.modulesDir)\n\t\treturn\n\t}\n\n\t// Initialize a slice to hold all entries\n\tvar allEntries []interface{}\n\n\t// Walk through the modules directory to find all entry.json files\n\tfilepath.Walk(c.modulesDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error accessing path %q: %v\\n\", path, err)\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() && filepath.Base(path) == \"entry.json\" {\n\t\t\t// Read the entry.json file\n\t\t\tfileContents, err := ioutil.ReadFile(path)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to read file: %s, error: %v\", path, err)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Parse the JSON content\n\t\t\tvar entryData interface{}\n\t\t\tif err = json.Unmarshal(fileContents, &entryData); err != nil {\n\t\t\t\tlog.Printf(\"Failed to parse JSON file: %s, error: %v\", path, err)\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Append to the allEntries slice\n\t\t\tallEntries = append(allEntries, entryData)\n\t\t}\n\t\treturn nil\n\t})\n\n\t// Convert the allEntries slice to JSON\n\tconsolidatedData, err := json.Marshal(allEntries)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to marshal consolidated entries: %v\", err)\n\t}\n\n\t// Write the consolidated JSON to the entry file\n\tif err = ioutil.WriteFile(c.entryFilePath, consolidatedData, 0644); err != nil {\n\t\tlog.Fatalf(\"Failed to write consolidated entries to file: %v\", err)\n\t}\n}", "CodeBleu_score": 44.47753036918681}, {"code": "package system\n\nimport (\n    \"encoding/json\"\n    \"io/ioutil\"\n    \"os\"\n    \"path/filepath\"\n    \"log\"\n)\n\ntype systemService struct {\n    ModulesDirectory string // path to modules directories\n    EntryFilePath    string // path to the consolidated JSON entry file\n}\n\n// GenerateSystemEntry reads entry.json files from each module directory, concatenates them into a JSON array,\n// and writes the concatenated JSON data to a consolidated entry file.\nfunc (c *systemService) GenerateSystemEntry() {\n    var entries []map[string]interface{}\n\n    // Read directories within ModulesDirectory\n    dirs, err := ioutil.ReadDir(c.ModulesDirectory)\n    if err != nil {\n        log.Printf(\"Failed to read directory %s: %v\", c.ModulesDirectory, err)\n        return\n    }\n\n    // Iterate over each directory and read 'entry.json' files\n    for _, dir := range dirs {\n        if dir.IsDir() {\n            entryPath := filepath.Join(c.ModulesDirectory, dir.Name(), \"entry.json\")\n            fileContent, err := ioutil.ReadFile(entryPath)\n            if err != nil {\n                log.Printf(\"Failed to read file %s: %v\", entryPath, err)\n                continue\n            }\n            \n            var entryData map[string]interface{}\n            if err := json.Unmarshal(fileContent, &entryData); err != nil {\n                log.Printf(\"Failed to unmarshal JSON from %s: %v\", entryPath, err)\n                continue\n            }\n            \n            entries = append(entries, entryData)\n        }\n    }\n\n    // Now, write the concatenated JSON data to a file\n    jsonData, err := json.Marshal(entries)\n    if err != nil {\n        log.Printf(\"Failed to marshal JSON: %v\", err)\n        return\n    }\n\n    err = ioutil.WriteFile(c.EntryFilePath, jsonData, 0644)\n    if err != nil {\n        log.Printf(\"Failed to write to file %s: %v\", c.EntryFilePath, err)\n    }\n}", "CodeBleu_score": 42.286635129850616}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "package main\n\nimport (\n\t\"errors\"\n\t\"net\"\n)\n\ntype systemService struct {\n\t// Add relevant fields if necessary\n}\n\n// GetMacAddress retrieves the MAC address of a network interface.\n// It first gets a list of network interfaces and checks for errors.\n// Then, it retrieves a list of network names from the system service.\n// It iterates over the interfaces and network names, returning the MAC address of the first matching interface.\n// If no matching interface is found, it returns an error.\nfunc (c *systemService) GetMacAddress() (string, error) {\n\t// Get a list of network interfaces.\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Check for available interfaces and ensure they have a hardware address\n\tfor _, intf := range interfaces {\n\t\tif len(intf.HardwareAddr) > 0 {\n\t\t\treturn intf.HardwareAddr.String(), nil\n\t\t}\n\t}\n\n\t// If no valid interface or MAC address is found, return an error.\n\treturn \"\", errors.New(\"no valid network interface found\")\n}", "CodeBleu_score": 50.24994966828089}, {"code": "package main\n\nimport (\n\t\"errors\"\n\t\"net\"\n)\n\ntype systemService struct{}\n\n// GetMacAddress retrieves the MAC address of a network interface.\n// It first gets the list of network interfaces and checks for errors.\n// It then iterates over the interfaces, returning the MAC address of the first available interface.\n// If no valid interface is found or an error occurs, it returns an error.\nfunc (c *systemService) GetMacAddress() (string, error) {\n\t// Retrieve all network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Traverse the list of interfaces\n\tfor _, iface := range interfaces {\n\t\t// Skip loopback interfaces and those that don't have a MAC address\n\t\tif iface.Flags&net.FlagLoopback != 0 || iface.HardwareAddr.String() == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Return the MAC address as a string\n\t\treturn iface.HardwareAddr.String(), nil\n\t}\n\n\t// Return an error if no suitable interface was found\n\treturn \"\", errors.New(\"no suitable interface found\")\n}\n\nfunc main() {\n\tss := systemService{}\n\tmac, err := ss.GetMacAddress()\n\tif err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t} else {\n\t\tprintln(\"MAC address:\", mac)\n\t}\n}", "CodeBleu_score": 54.49324318833955}, {"code": "package main\n\nimport (\n\t\"errors\"\n\t\"net\"\n)\n\ntype systemService struct {\n\t// Assume there are other members in the systemService structure\n}\n\n// GetMacAddress retrieves the MAC address of a network interface.\n// It first gets a list of network interfaces and checks for errors.\n// Then, it retrieves a list of network names from the system service.\n// It iterates over the interfaces and network names,\n// returning the MAC address of the first matching interface.\n// If no matching interface is found, it returns an error.\nfunc (c *systemService) GetMacAddress() (string, error) {\n\t// Get the list of network interfaces\n\tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t\n\t// Assume a method that retrieves network names from system service\n\tnetworkNames := c.getNetworkNames()\n\n\t// Iterate over all interfaces and check if their name matches one of the network names\n\tfor _, intf := range interfaces {\n\t\tfor _, name := range networkNames {\n\t\t\tif intf.Name == name {\n\t\t\t\t// Check if the interface has a valid MAC address\n\t\t\t\tif intf.HardwareAddr != nil {\n\t\t\t\t\treturn intf.HardwareAddr.String(), nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Appropriate error if no matching network interface is found\n\treturn \"\", errors.New(\"no matching network interface found\")\n}\n\n// Dummy implementation for demonstration: Assume this effectively gets the network names.\nfunc (c *systemService) getNetworkNames() []string {\n\t// This would normally interact with some system configuration or state to determine which network names to check\n\t// Here we just return some dummy data\n\treturn []string{\"eth0\", \"wlan0\"}\n}\n\n// Example usage\nfunc main() {\n\tss := systemService{}\n\tmac, err := ss.GetMacAddress()\n\tif err != nil {\n\t\tprintln(\"Error:\", err.Error())\n\t} else {\n\t\tprintln(\"MAC Address:\", mac)\n\t}\n}", "CodeBleu_score": 58.34542642632985}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "#include <stdio.h>\n#include <stdint.h>\n\ntypedef struct {\n    // Assuming some structure members relevant to requests\n    int referenceCount; \n} SRequestObj;\n\ntypedef struct {\n    int requestCount;\n    struct {\n        int totalRequests;\n        int currentRequests;\n    } appInfo;\n    int hasAppInfo; // flag to indicate presence of application info\n} STscObj;\n\n/* Add reference to the request */\nstatic void addReference(SRequestObj *pRequest) {\n    pRequest->referenceCount++;\n}\n\n/* Log the request details */\nstatic void logRequest(SRequestObj *pRequest, STscObj *pTscObj) {\n    printf(\"Request registered. TSC request count: %d, Reference count: %d\\n\",\n        pTscObj->requestCount, pRequest->referenceCount);\n}\n\n/* Register the request */\nstatic int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj) {\n    if (pRequest == NULL || pTscObj == NULL) {\n        return -1; // Return an error code for null pointer\n    }\n    \n    addReference(pRequest);\n    pTscObj->requestCount++;\n\n    if (pTscObj->hasAppInfo) {\n        pTscObj->appInfo.totalRequests++;\n        pTscObj->appInfo.currentRequests++;\n    }\n\n    logRequest(pRequest, pTscObj);\n\n    return 0; // success code\n}\n\nint main() {\n    SRequestObj request = {0};\n    STscObj tsc = {\n        .requestCount = 0,\n        .appInfo = {0, 0},\n        .hasAppInfo = 1\n    };\n\n    if (registerRequest(&request, &tsc) == 0) {\n        printf(\"Request successfully registered.\\n\");\n    } else {\n        printf(\"Error in registering request.\\n\");\n    }\n\n    return 0;\n}", "CodeBleu_score": 37.57427774954393}, {"code": "#include <stdio.h>\n\ntypedef struct {\n    int requestCount;\n    int applicationInfoPresent;  // boolean: 1 if present, 0 if not\n    int totalRequestCount;\n    int currentRequestCount;\n} STscObj;\n\ntypedef struct {\n    int placeholder;  // Placeholder field representing request object's content.\n} SRequestObj;\n\n// Mock function to simulate debug logging\nvoid logDebugInfo(const char* message) {\n    printf(\"%s\\n\", message);\n}\n\nstatic int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj) {\n    if (pRequest == NULL || pTscObj == NULL) {\n        logDebugInfo(\"registerRequest: Null pointer provided for Request or TSC object.\");\n        return -1;  // Or any other suitable failure code.\n    }\n\n    // Increment the general request count associated with TSC.\n    pTscObj->requestCount++;\n\n    // If the TSC object has application information, update application request summary.\n    if (pTscObj->applicationInfoPresent) {\n        pTscObj->totalRequestCount++;  // Considering this is the overall total of requests.\n        pTscObj->currentRequestCount++;  // Increment current request count, we may need to decrement this elsewhere when a request completes.\n    }\n\n    // Logging debug information about the new request\n    logDebugInfo(\"registerRequest: New request registered successfully.\");\n\n    return 0;  // Success code\n}", "CodeBleu_score": 26.835358658308518}, {"code": "#include <stdio.h>\n#include <stdint.h>\n\ntypedef struct {\n    // Assume some structure fields.\n} SRequestObj;\n\ntypedef struct {\n    int requestCount;\n    struct {\n        int totalRequests;\n        int currentRequests;\n    } appInfo;\n    int hasAppInfo;\n} STscObj;\n\nstatic int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj) {\n    // Step 1: Verify the pointers\n    if (pRequest == NULL || pTscObj == NULL) {\n        printf(\"Error: Null pointer provided to registerRequest\\n\");\n        return -1;  // Indicate error with a negative code\n    }\n\n    // Step 2: (Assuming request obj linking is through storing the count or ID)\n    // This would be more specific with an actual requirement, like attaching request to a list\n\n    // Step 3: Increment the request count for TSC\n    pTscObj->requestCount++;\n\n    // Step 4: If the TSC object has an application, update the request summary\n    if (pTscObj->hasAppInfo) {\n        pTscObj->appInfo.totalRequests++;          // Total requests incremented\n        pTscObj->appInfo.currentRequests++;        // Current requests (this session) incremented\n    }\n\n    // Step 5: Logging\n    printf(\"Debug: New request registered. Total requests now %d. Current requests this session %d.\\n\",\n           pTscObj->appInfo.totalRequests,\n           pTscObj->appInfo.currentRequests);\n\n    // Step 6: Return success code\n    return 0;\n}", "CodeBleu_score": 23.40913686610517}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "#include <string.h> // For strcmp and strtok\n#include <stdbool.h> // For bool type\n\ntypedef struct {\n    char* primaryDatabase; // Primary database of the request\n    char** databases; // List of databases in the request\n    int databaseCount; // Number of databases in the list\n} SRequestObj;\n\nstatic bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb) {\n    // Check if the primary database is the same as the exception database\n    if (strcmp(pRequest->primaryDatabase, exceptDb) == 0) {\n        // Primary database is the exception database, return false\n        return false;\n    }\n    \n    // Iterate over the list of databases associated with the request\n    for (int i = 0; i < pRequest->databaseCount; i++) {\n        char* db = pRequest->databases[i];\n\n        // We need to ignore any schema prefix; assuming format `schema.database`\n        // Strip out schema if it exists by finding the first dot and taking the substring after it\n        char* dbName = strchr(db, '.');\n        if (dbName != NULL) {\n            dbName++; // Move past the '.'\n        } else {\n            dbName = db; // No schema prefix, use as is\n        }\n\n        // Compare the database name after stripping schema to the exception database\n        if (strcmp(dbName, exceptDb) == 0) {\n            // Found a match to the exception database, return false\n            return false;\n        }\n    }\n    \n    // No databases matched the exception database\n    return true;\n}", "CodeBleu_score": 57.68674565506209}, {"code": "#include <stdbool.h>\n#include <string.h>\n#include <stddef.h>\n\ntypedef struct {\n    char* primaryDb;\n    char** otherDbs; // Assume it's NULL terminated.\n} SRequestObj;\n\n// Helper function to compare database names ignoring schema\nstatic bool dbMatch(char* dbName, char* exceptDb) {\n    if (dbName == NULL || exceptDb == NULL)\n        return false;\n    // Compare ignoring the schema, assuming schema and db are separated by '.'\n    char* shortDbName = strchr(dbName, '.');\n    if (shortDbName == NULL) {\n        shortDbName = dbName; // No schema present, use the whole name\n    } else {\n        shortDbName++; // Skip the dot\n    }\n    return strcmp(shortDbName, exceptDb) == 0;\n}\n\nstatic bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb) {\n    // Check primary database\n    if (dbMatch(pRequest->primaryDb, exceptDb)) {\n        return false;\n    }\n\n    // Check other databases\n    for (size_t i = 0; pRequest->otherDbs[i] != NULL; i++) {\n        if (dbMatch(pRequest->otherDbs[i], exceptDb)) {\n            return false;\n        }\n    }\n\n    // If no match found, return true\n    return true;\n}", "CodeBleu_score": 43.91981683797401}, {"code": "#include <stdbool.h>\n#include <string.h>\n\ntypedef struct {\n    char* primaryDb;\n    char** databases;\n    int numDatabases;\n} SRequestObj;\n\nstatic bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb) {\n    // Start by comparing the primary database of the request to the exception database\n    if (strcmp(pRequest->primaryDb, exceptDb) == 0) {\n        // The primary database is the exception database, return false.\n        return false;\n    }\n    \n    // Now iterate through the list of associated databases\n    for (int i = 0; i < pRequest->numDatabases; i++) {\n        const char* db = pRequest->databases[i];\n        // Compare each database ignoring the schema (text after a dot)\n        // Find the position of dot (if it exists)\n        const char* dot = strchr(db, '.');\n        int dbLength = dot ? (dot - db) : (int)strlen(db);\n        \n        // Check if the current database's relevant part matches the exceptDb\n        if (strncmp(db, exceptDb, dbLength) == 0 && strlen(exceptDb) == dbLength) {\n            // Found a match, return false\n            return false;\n        }\n    }\n    \n    // No databases matched the exception database, return true\n    return true;\n}", "CodeBleu_score": 51.64928719263919}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "#include <stdbool.h>\n#include <stdint.h>\n\n// Specify the message types using a typedef enum for clarity.\ntypedef enum {\n    MSG_TYPE_A,\n    MSG_TYPE_B,\n    MSG_TYPE_C,\n    MSG_TYPE_D,\n    // Add more message types as required.\n} tmsg_t;\n\n// Need redirection if the code is negative \n// and the message type is not one of the specified non-redirectable types.\nstatic bool clientRpcRfp(int32_t code, tmsg_t msgType) {\n    if (code < 0) { // Assume negative codes mean an error needing redirection\n        switch (msgType) {\n            case MSG_TYPE_A:\n            case MSG_TYPE_B:\n            case MSG_TYPE_C:\n                // These message types do not need redirection even with an error code.\n                return false;\n            default:\n                // Other message types need redirection.\n                return true;\n        }\n    } else {\n        // If code is not negative, no redirection is required.\n        return false;\n    }\n}", "CodeBleu_score": 37.80730713645326}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)\n    /*\n     * Define error codes that indicate redirection is needed.\n     * For example, let's assume error codes 301, 302, and 303 indicate redirection.\n     */\n    int redirectionErrorCodes[] = {301, 302, 303};\n    int numRedirectionCodes = sizeof(redirectionErrorCodes) / sizeof(redirectionErrorCodes[0]);\n\n    // Message types that should not be redirected, regardless of error code.\n    tmsg_t nonRedirectableMessageTypes[] = {MSG_TYPE_1, MSG_TYPE_2, MSG_TYPE_3};\n    int numNonRedirectableTypes = sizeof(nonRedirectableMessageTypes) / sizeof(nonRedirectableMessageTypes[0]);\n\n    // Check if the error code is one of the redirection codes.\n    bool needsRedirection = false;\n    for (int i = 0; i < numRedirectionCodes; i++) {\n        if (code == redirectionErrorCodes[i]) {\n            needsRedirection = true;\n            break;\n        }\n    }\n\n    // If it needs redirection, check further if the message type is redirectable.\n    if (needsRedirection) {\n        for (int j = 0; j < numNonRedirectableTypes; j++) {\n            if (msgType == nonRedirectableMessageTypes[j]) {\n                // If message type is not redirectable, return false.\n                return false;\n            }\n        }\n        // If message type is redirectable, return true.\n        return true;\n    }\n\n    // If the error code does not indicate the need for redirection, return false.\n    return false;\n}", "CodeBleu_score": 30.94482574810114}, {"code": "#include <stdbool.h>\n#include <stdint.h>\n\n// Assuming that tmsg_t is an enumerated data type, defined accordingly\ntypedef enum {\n    MESSAGE_TYPE_A,\n    MESSAGE_TYPE_B,\n    MESSAGE_TYPE_C,\n    MESSAGE_TYPE_D,\n    MESSAGE_TYPE_E\n} tmsg_t;\n\n// Define error codes that imply a need for redirection\n#define ERR_NEEDS_REDIRECTION 302\n\n// Function to determine if a redirection is needed\nstatic bool clientRpcRfp(int32_t code, tmsg_t msgType) {\n    // Check if the error code corresponds to a redirection requirement\n    if (code == ERR_NEEDS_REDIRECTION) {\n        // Check if the message type is not one of the specified types that should not be redirected\n        switch (msgType) {\n            case MESSAGE_TYPE_A:\n            case MESSAGE_TYPE_B:\n            case MESSAGE_TYPE_C:\n                // These message types do not need redirection\n                return false;\n            default:\n                // If it's any other type, redirection is needed\n                return true;\n        }\n    } else {\n        // If the error code does not imply a need for redirection, return false\n        return false;\n    }\n}", "CodeBleu_score": 43.34612092483967}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "#include <stdio.h>\n\n// Define a structure for a request object\ntypedef struct {\n    int request_id;\n    int is_active;\n} Request;\n\n// Define the hash table object holding requests\ntypedef struct {\n    Request **requests;  // Array of pointers to Request objects\n    int size;            // Total slots in the hash table\n    int (*hash_function)(int); // Function pointer to calculate hash for a given request_id\n} SHashObj;\n\n// Function prototype to stop a request\nvoid stopRequest(Request *req) {\n    if (req != NULL && req->is_active) {\n        printf(\"Stopping request ID %d\\n\", req->request_id);\n        req->is_active = 0; // Mark the request as stopped.\n    }\n}\n\n// Function to simulate acquiring each request\nRequest *acquireRequest(SHashObj *hashObj, int index) {\n    if (index < hashObj->size) {\n        return hashObj->requests[index];\n    }\n    return NULL;\n}\n\n// Function to iterate and stop all requests in the SHashObj\nvoid stopAllRequests(SHashObj *pRequests) {\n    if (pRequests == NULL || pRequests->requests == NULL) {\n        printf(\"No requests to process.\\n\");\n        return;\n    }\n\n    int i;\n    for (i = 0; i < pRequests->size; i++) {\n        Request *req = acquireRequest(pRequests, i);\n        if (req != NULL) {\n            stopRequest(req);\n        }\n    }\n}\n\n// Implement here any additional functions you might need, like hash_table initialization, request creation, etc.", "CodeBleu_score": 38.53739904910668}, {"code": "#include <stdio.h>\n\n// I'll assume there are necessary headers and types for managing the requests\ntypedef struct {\n    int requestId;  // Unique identifier for a request\n    int isQueryActive;\n} Request;\n\ntypedef struct {\n    Request **requests;  // Array of pointers to Request objects\n    int count;           // Number of requests\n} SHashObj;\n\n/**\n * Acquires the request. Here we assume this function ensures the functionality\n * related to safely acquiring or locking the request for operations.\n */\nvoid acquireRequest(Request *request) {\n    // Imaginary functionality to lock or acquire a request\n    printf(\"Request ID %d acquired.\\n\", request->requestId);\n}\n\n/**\n * Releases the request after operations are done. It might include unlocking\n * or releasing any resources tied up with the operation.\n */\nvoid releaseRequest(Request *request) {\n    // Imaginary functionality to unlock or release the request\n    printf(\"Request ID %d released.\\n\", request->requestId);\n}\n\n/**\n * Stops the query associated with a particular request.\n */\nvoid stopRequestQuery(Request *request) {\n    // Check if the query is active before trying to stop it\n    if (request->isQueryActive) {\n        printf(\"Stopping query for Request ID %d.\\n\", request->requestId);\n        request->isQueryActive = 0;  // Simulate query stopping\n    } else {\n        printf(\"Query for Request ID %d already stopped.\\n\", request->requestId);\n    }\n}\n\nvoid stopAllRequests(SHashObj *pRequests) {\n    if (pRequests == NULL) {\n        printf(\"No requests to process.\\n\");\n        return;\n    }\n\n    for (int i = 0; i < pRequests->count; i++) {\n        Request *currentRequest = pRequests->requests[i];\n        if (currentRequest != NULL) {\n            acquireRequest(currentRequest);\n            stopRequestQuery(currentRequest);\n            releaseRequest(currentRequest);\n        }\n    }\n}", "CodeBleu_score": 36.82070444238569}, {"code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Define the request structure, assuming each request has an ID and a status.\ntypedef struct Request {\n    int requestID;\n    int isActive; // 1 for active, 0 for not active\n} Request;\n\n// Define the hash table node and hash table structure.\ntypedef struct HashNode {\n    Request* request;\n    struct HashNode* next;\n} HashNode;\n\ntypedef struct SHashObj {\n    HashNode** buckets; // Array of pointers to HashNode\n    int size;           // Number of buckets in the hash table\n} SHashObj;\n\n// Function prototype for stopping a request\nvoid stopRequest(Request* request) {\n    if (request && request->isActive) {\n        printf(\"Stopping Request ID: %d\\n\", request->requestID);\n        request->isActive = 0; // Mark request as inactive\n    }\n}\n\n// The function to stop all requests in a hash table as requested.\nvoid stopAllRequests(SHashObj *pRequests) {\n    if (!pRequests || !pRequests->buckets) {\n        return; // Handle null pointer or empty hash table scenario\n    }\n\n    // Iterate through each bucket\n    for (int i = 0; i < pRequests->size; i++) {\n        HashNode* node = pRequests->buckets[i];\n\n        // Iterate through linked list in each bucket\n        while (node) {\n            stopRequest(node->request);\n            node = node->next;\n        }\n    }\n}\n\n// Example of initializing and testing the function\nint main() {\n    // Example usage\n    int numBuckets = 10;\n    SHashObj hashTable;\n    hashTable.size = numBuckets;\n    hashTable.buckets = (HashNode**)calloc(numBuckets, sizeof(HashNode*));\n\n    // Adding dummy request data\n    for (int i = 0; i < numBuckets; i++) {\n        Request *newRequest = malloc(sizeof(Request));\n        newRequest->requestID = i+1;\n        newRequest->isActive = 1;\n\n        HashNode* newNode = malloc(sizeof(HashNode));\n        newNode->request = newRequest;\n        newNode->next = hashTable.buckets[i];\n        hashTable.buckets[i] = newNode;\n    }\n\n    // Stop all requests\n    stopAllRequests(&hashTable);\n\n    // Cleanup memory\n    for (int i = 0; i < numBuckets; i++) {\n        HashNode* node = hashTable.buckets[i];\n        while (node) {\n            HashNode* temp = node;\n            free(temp->request);\n            node = node->next;\n            free(temp);\n        }\n    }\n\n    free(hashTable.buckets);\n    return 0;\n}", "CodeBleu_score": 35.11040054101938}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "#include <stdatomic.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n// Assuming these are globals or part of a struct somewhere in the program\natomic_bool crashReportingEnabled = ATOMIC_VAR_INIT(true);\natomic_int clientStop = ATOMIC_VAR_INIT(0);\n\nvoid tscStopCrashReport() {\n    // Check if crash reporting is enabled\n    if (!atomic_load_explicit(&crashReportingEnabled, memory_order_acquire)) {\n        printf(\"Crash reporting is not enabled.\\n\");\n        return;\n    }\n\n    // Attempt to set the clientStop flag to 1 using atomic compare-and-exchange\n    int expected = 0;\n    if (!atomic_compare_exchange_strong_explicit(&clientStop, &expected, 1, memory_order_acq_rel, memory_order_acquire)) {\n        printf(\"Crash report thread already stopped or in the process of stopping.\\n\");\n        return;\n    }\n\n    // Wait until the clientStop flag is set back to 0\n    while (atomic_load_explicit(&clientStop, memory_order_acquire) != 0) {\n        // This could include some delay like sleep(1) to reduce busy waiting,\n        // but it's not mandated by the specified requirements.\n    }\n    \n    printf(\"Crash report thread has been successfully stopped.\\n\");\n}", "CodeBleu_score": 40.647662644783146}, {"code": "#include <stdatomic.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n// Assuming the existence of the following global variables:\nextern atomic_bool crashReportingEnabled;  // Indicates if crash reporting is enabled\nextern atomic_bool clientStop;             // Flag indicating to stop the crash reporting thread\n\nvoid tscStopCrashReport() {\n    // First, check if crash reporting is currently enabled\n    if (!atomic_load(&crashReportingEnabled)) {\n        printf(\"Crash reporting is not enabled.\\n\");\n        return;\n    }\n\n    // Set clientStop flag to 1 to initiate stopping of the crash report thread\n    bool expected = false;\n    if (!atomic_compare_exchange_strong(&clientStop, &expected, true)) {\n        printf(\"Crash report thread is already instructed to stop.\\n\");\n        return;\n    }\n\n    // Wait for the crash report thread to set clientStop back to 0\n    while (atomic_load(&clientStop)) {\n        // Here you could consider adding a sleep to avoid a busy wait or using a more suitable thread synchronization method\n    }\n\n    printf(\"Crash report thread has been successfully stopped.\\n\");\n}", "CodeBleu_score": 40.4046540208279}, {"code": "#include <stdio.h>\n#include <stdatomic.h>\n\n// Assuming necessary libraries are included and setup for thread and other resources are already defined globally.\n// Example global variables that could be used:\n// volatile atomic_flag isCrashReportingEnabled = ATOMIC_FLAG_INIT; // Indicates if crash reporting is initialized\n// atomic_int clientStop = 0; // Acts as a flag for stopping the crash report thread\n\nextern volatile atomic_flag isCrashReportingEnabled;\nextern atomic_int clientStop;\n\nvoid tscStopCrashReport() {\n    // First, check if crash reporting is enabled.\n    if (!atomic_flag_test_and_set(&isCrashReportingEnabled)) {\n        printf(\"Crash reporting is disabled.\\n\");\n        return; // Exit if crash reporting isn't enabled\n    }\n\n    // Attempt to stop the crash report thread by setting clientStop flag to 1.\n    int expected = 0;\n    if (!atomic_compare_exchange_strong(&clientStop, &expected, 1)) {\n        printf(\"Failed to stop the crash report thread; it may already be stopped.\\n\");\n        return;\n    }\n\n    // Wait for the crash report thread to acknowledge that it's stopped.\n    while (atomic_load(&clientStop) != 0) {\n        // Here you should ideally use a sleep function to avoid busy waiting.\n        // Using sleep or similar to yield processor is recommended to prevent CPU spinning.\n        // sleep(1); // Let's wait for a bit (pseudo code)\n    }\n\n    // Reset crash reporting enabled flag\n    atomic_flag_clear(&isCrashReportingEnabled);\n    printf(\"Crash report thread has been successfully stopped.\\n\");\n}", "CodeBleu_score": 42.434359322167595}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "#include <stdlib.h>\n#include <stdint.h>\n\n// Assuming the following structures and constants exist\ntypedef struct {\n    int numColumns;\n    char *viewName;\n} SViewInfo;\n\ntypedef struct {\n    SViewInfo *views;\n    size_t numViews;\n} SViewInfoArray;\n\ntypedef struct SCatalog {\n    // Definition of catalog with assumption it has a function to update or remove views\n    void (*updateView)(struct SCatalog *catalog, const char *viewName, int numColumns);\n    void (*removeView)(struct SCatalog *catalog, const char *viewName);\n} SCatalog;\n\n#define SUCCESS 0\n#define DESERIALIZATION_ERROR -1\n#define CLEANUP_ERROR -2\n\n// Assumed function prototypes\nint deserializeViewInfo(void *value, int32_t valueLen, SViewInfoArray **ppViewInfo);\nvoid destroyViewInfoArray(SViewInfoArray *pViewInfoArray);\n\nstatic int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog) {\n    SViewInfoArray *pViewInfoArray = NULL;\n\n    // Deserialize the heartbeat response\n    int result = deserializeViewInfo(value, valueLen, &pViewInfoArray);\n    if (result != SUCCESS) {\n        // Deserialization failed\n        return DESERIALIZATION_ERROR;\n    }\n\n    // Process each view metadata\n    for (size_t i = 0; i < pViewInfoArray->numViews; i++) {\n        SViewInfo *view = &pViewInfoArray->views[i];\n        // Check number of columns to decide on action\n        if (view->numColumns > 0) {\n            // Update the view metadata in the catalog\n            pCatalog->updateView(pCatalog, view->viewName, view->numColumns);\n        } else {\n            // Remove the view from the catalog\n            pCatalog->removeView(pCatalog, view->viewName);\n        }\n    }\n\n    // Clean up response array\n    destroyViewInfoArray(pViewInfoArray);\n\n    return SUCCESS;\n}", "CodeBleu_score": 36.10041208887267}, {"code": "#include <stdlib.h>\n\ntypedef struct {\n    char *viewName;\n    int numColumns;\n} SViewInfo;\n\ntypedef struct {\n    SViewInfo *views;\n    int viewCount;\n} SViewInfoResponse;\n\nstruct SCatalog {\n    // catalog data structure definition, assuming it supports methods for updating and removing views\n    void (*updateView)(struct SCatalog *self, const char *viewName, int numColumns);\n    void (*removeView)(struct SCatalog *self, const char *viewName);\n};\n\n// Assuming there's a function for deserialization\nextern int deserializeViewData(void *data, int dataLen, SViewInfoResponse **outResponse);\n\n// Cleanup helper function\nstatic void cleanupResponse(SViewInfoResponse *response) {\n    if (response != NULL) {\n        free(response->views);\n        free(response);\n    }\n}\n\nstatic int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog) {\n    SViewInfoResponse *response = NULL;\n    \n    // Deserialize the response\n    int result = deserializeViewData(value, valueLen, &response);\n    if (result != 0) {\n        // Deserialization failed, handle error\n        return result; // return error code\n    }\n\n    // Process each view metadata in the response\n    for (int i = 0; i < response->viewCount; ++i) {\n        SViewInfo *view = &response->views[i];\n        // Check number of columns to decide whether to update or remove\n        if (view->numColumns > 0) {\n            pCatalog->updateView(pCatalog, view->viewName, view->numColumns);\n        } else {\n            pCatalog->removeView(pCatalog, view->viewName);\n        }\n    }\n\n    // Cleanup the response\n    cleanupResponse(response);\n\n    return 0; // Success code\n}", "CodeBleu_score": 38.730636077652505}, {"code": "#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *viewName;\n    int numColumns;\n} ViewMetaData;\n\ntypedef struct {\n    int numViews;\n    ViewMetaData *views;\n} ViewInfoResponse;\n\n// Prototype for deserialization routine \u2013 assumes existence\nint deserializeViewInfo(const void *value, int32_t valueLen, ViewInfoResponse **response);\n\n// Prototype for cleanup routine \u2013 assumes existence\nvoid cleanupViewInfoResponse(ViewInfoResponse *response);\n\n// Prototype for update or remove from catalog\nvoid updateOrRemoveView(struct SCatalog *pCatalog, ViewMetaData *viewData);\n\nstatic int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog) {\n    ViewInfoResponse *response = NULL;\n\n    // Step 1: Deserialize the response\n    if (deserializeViewInfo(value, valueLen, &response) != 0) {\n        // Deserialization failed, perform necessary cleanup\n        if (response) {\n            cleanupViewInfoResponse(response);\n        }\n        return -1;  // Return an error code\n    }\n\n    // Step 2: Iterate through the deserialized view metadata\n    for (int i = 0; i < response->numViews; i++) {\n        updateOrRemoveView(pCatalog, &response->views[i]);\n    }\n\n    // Step 3: Cleanup the deserialized response\n    cleanupViewInfoResponse(response);\n\n    return 0;  // Return a success code\n}", "CodeBleu_score": 34.93985713355702}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "#include <stdint.h>\n\n// Define a struct that might represent the callback data structure.\ntypedef struct {\n    uint64_t contentLength;\n} CallbackStruct;\n\n// Define the potential enum values for S3 statuses as they aren't given.\ntypedef enum {\n    S3StatusOK = 0,          // Assuming 0 is the value representing OK status\n    S3StatusError = 1        // Assuming there might be an error status\n} S3Status;\n\n// Provided function signature:\nstatic S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData) {\n    // Cast void pointer to the expected callback data structure.\n    CallbackStruct *data = (CallbackStruct *)callbackData;\n\n    if (properties == NULL || data == NULL) {\n        return S3StatusError; // Return error in case of null pointers\n    }\n\n    // Check the contentLength from the properties and update it in the callback data.\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0; // Set content length to zero if the response property's length is non-positive\n    }\n\n    return S3StatusOK; // Return S3StatusOK indicating successful processing\n}", "CodeBleu_score": 64.58112944646025}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData) {\n    // Cast callback data to the appropriate structure (assuming it's known and named CallbackData)\n    CallbackData *data = (CallbackData*)callbackData;\n    \n    if (properties && data) {\n        // Check if content length is available and greater than zero\n        if (properties->contentLength > 0) {\n            data->contentLength = properties->contentLength;\n        } else {\n            // If content length is not available or not greater than zero, set to zero\n            data->contentLength = 0;\n        }\n    } else {\n        // If properties or callbackData are NULL, log this case if required\n        // Uncomment and complete the next line if logging is desired:\n        // fprintf(stderr, \"Error: Invalid properties or callbackData in responsePropertiesCallback.\\n\");\n        return S3StatusError;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 70.27858331542643}, {"code": "/*\n * The function \"responsePropertiesCallback\" processes S3 response properties to extract the content length.\n * It updates the content length in the provided callback data structure if the content length from the response properties is greater than zero; otherwise, it sets the content length to zero.\n * The function returns \"S3StatusOK\" to indicate successful processing.\n */\n#include <stddef.h> // For NULL\n\n// Return Status Enumeration (just a generic representation for this example)\ntypedef enum {\n    S3StatusOK = 0,\n    S3StatusError = 1\n} S3Status;\n\n// S3 Response Properties structure (hypothetical structure relevant to the context)\ntypedef struct {\n    long contentLength; // Assuming content-length is stored as a long integer\n} S3ResponseProperties;\n\n// Callback data may involve a structure where we store the content length (example structure)\ntypedef struct {\n    long contentLength;\n} CallbackData;\n\n// Function Definition\nstatic S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData) {\n    if (properties == NULL || callbackData == NULL) {\n        return S3StatusError;\n    }\n\n    CallbackData *data = (CallbackData *)callbackData;\n\n    if (properties->contentLength > 0) {\n        data->contentLength = properties->contentLength;\n    } else {\n        data->contentLength = 0;\n    }\n\n    return S3StatusOK;\n}", "CodeBleu_score": 63.42775133204427}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nvoid startRsync() {\n    // Directory for the checkpoint backups\n    const char* backupDir = \"/path/to/backup/dir\";\n    const char* rsyncConfigFile = \"/path/to/rsyncd.conf\";\n    const char* rsyncCommandFormat = \"rsync --daemon --port=%d --config=%s\";\n    int rsyncPort = 8873;  // example Rsync port number\n    \n    // Create backup directory, log error if it fails\n    if (mkdir(backupDir, 0777) != 0 && errno != EEXIST) {\n        perror(\"Failed to create backup directory\");\n        return;\n    }\n    \n    // Remove empty directories in the backup folder\n    system((\"find \" + std::string(backupDir) + \" -type d -empty -delete\").c_str());\n    \n    // Generate Rsync configuration file\n    FILE* configFile = fopen(rsyncConfigFile, \"w\");\n    if (configFile == NULL) {\n        perror(\"Failed to open Rsync configuration file\");\n        return;\n    }\n    \n    // Writing simulation to rsync configuration file\n    fprintf(configFile, \"uid = nobody\\n\");\n    fprintf(configFile, \"gid = nobody\\n\");\n    fprintf(configFile, \"use chroot = no\\n\");\n    fprintf(configFile, \"[backup]\\n\");\n    fprintf(configFile, \"path = %s\\n\", backupDir);\n    fprintf(configFile, \"read only = false\\n\");\n\n    // Close the configuration writing stream\n    fclose(configFile);\n\n    // Command to start the Rsync daemon\n    char rsyncCommand[256];\n    sprintf(rsyncCommand, rsyncCommandFormat, rsyncPort, rsyncConfigFile);\n    \n    if (system(rsyncCommand) == -1) {\n        perror(\"Failed to start Rsync daemon\");\n    } else {\n        printf(\"Rsync server started successfully on port %d\\n\", rsyncPort);\n    }\n}", "CodeBleu_score": 31.46674453314247}, {"code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n// Define constants for path and configs\n#define BACKUP_DIR \"/path/to/backup\"\n#define RSYNC_CONFIG_FILE \"/path/to/rsyncd.conf\"\n#define RSYNC_DAEMON_COMMAND \"/usr/bin/rsync\"\n#define RSYNC_PORT \"873\" // Default Rsync port\n\n/**\n * Log error messages to the console or log file.\n */\nvoid logError(const char *message) {\n    fprintf(stderr, \"Error: %s\\n\", message);\n}\n\n/**\n * Log info messages to the console or log file.\n */\nvoid logInfo(const char *message) {\n    printf(\"Info: %s\\n\", message);\n}\n\n/**\n * Create the checkpoint backup directory.\n */\nint createBackupDirectory() {\n    if (mkdir(BACKUP_DIR, 0777) == -1) {\n        perror(\"Failed to create backup directory\");\n        return -1;\n    }\n    return 0;\n}\n\n/**\n * Remove empty directories in the backup path recursively.\n */\nvoid removeEmptyDirectories(const char *path) {\n    // Simple command using system call, more complex operations require directory listing and recursion\n    char cmd[1024];\n    sprintf(cmd, \"find %s -type d -empty -delete\", path);\n    system(cmd);\n}\n\n/**\n * Generate an Rsync configuration file.\n */\nint generateRsyncConfig() {\n    FILE *file = fopen(RSYNC_CONFIG_FILE, \"w\");\n    if (!file) {\n        logError(\"Failed to open Rsync configuration file for writing\");\n        return -1;\n    }\n\n    fprintf(file, \"uid = root\\n\");\n    fprintf(file, \"gid = root\\n\");\n    fprintf(file, \"use chroot = no\\n\");\n    fprintf(file, \"max connections = 4\\n\");\n    fprintf(file, \"pid file = /var/run/rsyncd.pid\\n\");\n    fprintf(file, \"log file = /var/log/rsyncd.log\\n\");\n    fprintf(file, \"[backup]\\n\");\n    fprintf(file, \"path = %s\\n\", BACKUP_DIR);\n    fprintf(file, \"comment = Backup\\n\");\n    fprintf(file, \"read only = false\\n\");\n\n    fclose(file);\n    return 0;\n}\n\n/**\n * Execute the Rsync daemon.\n */\nint startRsyncDaemon() {\n    char cmd[1024];\n    sprintf(cmd, \"%s --daemon --config=%s --port=%s\", RSYNC_DAEMON_COMMAND, RSYNC_CONFIG_FILE, RSYNC_PORT);\n    if (system(cmd) != 0) {\n        logError(\"Failed to start Rsync daemon\");\n        return -1;\n    }\n    return 0;\n}\n\nvoid startRsync() {\n    if (createBackupDirectory() != 0) {\n        logError(\"Could not create backup directory\");\n        return;\n    }\n\n    removeEmptyDirectories(BACKUP_DIR);\n    logInfo(\"Removed empty directories from backup path\");\n\n    if (generateRsyncConfig() != 0) {\n        logError(\"Failed to create Rsync configuration\");\n        return;\n    }\n\n    logInfo(\"Generated Rsync configuration file successfully\");\n\n    if (startRsyncDaemon() == 0) {\n        logInfo(\"Rsync server started successfully\");\n    } else {\n        logError(\"Failed to start Rsync server\");\n    }\n}", "CodeBleu_score": 35.32116689868261}, {"code": "#include <iostream>\n#include <fstream>\n#include <filesystem>\n#include <cstdlib>\n#include <cstdio>\n\nvoid startRsync() {\n    const std::string checkpointDir = \"/path/to/checkpoint/directory\";\n    const std::string rsyncConfigFile = \"/path/to/rsync/rsyncd.conf\";\n    const int rsyncPort = 873; // Default Rsync port\n\n    // Create the checkpoint backup directory if it does not exist\n    if (!std::filesystem::exists(checkpointDir)) {\n        try {\n            std::filesystem::create_directories(checkpointDir);\n        } catch (const std::filesystem::filesystem_error &e) {\n            std::cerr << \"Failed to create checkpoint directory: \" << e.what() << std::endl;\n            return;\n        }\n    }\n\n    // Removing empty directories in the checkpoint directory\n    for (const auto& entry : std::filesystem::directory_iterator(checkpointDir)) {\n        if (std::filesystem::is_directory(entry) && std::filesystem::is_empty(entry)) {\n            std::filesystem::remove(entry);\n        }\n    }\n\n    // Generate Rsync configuration file\n    std::ofstream configFile(rsyncConfigFile);\n    if (!configFile.is_open()) {\n        std::cerr << \"Failed to open Rsync configuration file.\" << std::endl;\n        return;\n    }\n    \n    configFile << \"pid file = /var/run/rsyncd.pid\\n\";\n    configFile << \"log file = /var/log/rsync.log\\n\";\n    configFile << \"port = \" << rsyncPort << \"\\n\";\n    configFile << \"[backup]\\n\";\n    configFile << \"path = \" << checkpointDir << \"\\n\";\n    configFile << \"comment = Checkpoint backups\\n\";\n    configFile << \"read only = no\\n\";\n    configFile.close();\n\n    // Construct command to start Rsync daemon with configuration\n    std::string command = \"rsync --daemon --config=\" + rsyncConfigFile;\n    \n    // Execute the command\n    int result = system(command.c_str());\n    if (result != 0) { // check execution status\n        std::cerr << \"Failed to start Rsync daemon, return code \" << result << std::endl;\n    } else {\n        std::cout << \"Rsync daemon started successfully on port \" << rsyncPort << std::endl;\n    }\n}", "CodeBleu_score": 35.20495797408384}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class DispatcherManager {\n    private Map<String, ExecutorService> dispatchers = new ConcurrentHashMap<>();\n\n    /**\n     * The function \"destroyDispatcher\" removes and shuts down a dispatcher identified by its ID.\n     * It retrieves the dispatcher from the dispatchers collection and, if found, shuts down its\n     * executor immediately.\n     * If the dispatcher is not found, it throws a runtime exception indicating that the dispatcher\n     * with the specified ID is not registered.\n     * \n     * @param dispatcherId the ID of the dispatcher to be destroyed\n     */\n    public void destroyDispatcher(String dispatcherId) {\n        ExecutorService dispatcher = dispatchers.get(dispatcherId);\n        \n        if (dispatcher != null) {\n            dispatcher.shutdownNow(); // This attempts to stop all actively executing tasks and halts the processing of waiting tasks.\n            dispatchers.remove(dispatcherId); // Remove the dispatcher entry from the map.\n        } else {\n            throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered.\");\n        }\n    }\n    \n    /**\n     * Registers a dispatcher with a given ID and initializes its executor service.\n     * \n     * @param dispatcherId the ID of the dispatcher to be registered.\n     */\n    public void registerDispatcher(String dispatcherId) {\n        if (!dispatchers.containsKey(dispatcherId)) {\n            dispatchers.put(dispatcherId, Executors.newCachedThreadPool()); // Optionally use newFixedThreadPool or others depending on use case\n        } else {\n            throw new IllegalStateException(\"A dispatcher with ID \" + dispatcherId + \" is already registered.\");\n        }\n    }\n}", "CodeBleu_score": 56.701945031730574}, {"code": "import java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class DispatcherManager {\n\n    // Assuming a map to store dispatchers by their IDs\n    private Map<String, ExecutorService> dispatchers = new ConcurrentHashMap<>();\n\n    /**\n     * The function \"destroyDispatcher\" removes and shuts down a dispatcher identified by its ID.\n     * It retrieves the dispatcher from the dispatchers collection and, if found, shuts down its executor immediately.\n     * If the dispatcher is not found, it throws a runtime exception indicating that the dispatcher with the specified ID is not registered.\n     */\n    public void destroyDispatcher(String dispatcherId) {\n        // Check if the dispatcher with the given ID is present\n        ExecutorService dispatcher = dispatchers.get(dispatcherId);\n\n        if (dispatcher == null) {\n            // Throw exception if the dispatcher isn't found\n            throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n        } else {\n            // Shutdown the dispatcher's executor immediately\n            dispatcher.shutdownNow();\n\n            // Remove the dispatcher from the collection\n            dispatchers.remove(dispatcherId);\n        }\n    }\n\n    // Other methods to manage dispatchers can be added here...\n}", "CodeBleu_score": 58.499273197164484}, {"code": "import java.util.Map;\nimport java.util.concurrent.ExecutorService;\n\npublic class DispatcherManager {\n    // Assuming there's a map that holds the relationship between dispatcher ID and its corresponding ExecutorService\n    private Map<String, ExecutorService> dispatchers;\n\n    public DispatcherManager(Map<String, ExecutorService> dispatchers) {\n        this.dispatchers = dispatchers;\n    }\n\n    /**\n     * The function \"destroyDispatcher\" removes and shuts down a dispatcher identified by its ID.\n     * It retrieves the dispatcher from the dispatchers collection and, if found, shuts down its executor immediately.\n     * If the dispatcher is not found, it throws a runtime exception indicating that the dispatcher with the specified ID is not registered.\n     * \n     * @param dispatcherId The ID of the dispatcher to be destroyed.\n     */\n    public void destroyDispatcher(String dispatcherId) {\n        // Check if the dispatcher exists\n        if (!dispatchers.containsKey(dispatcherId)) {\n            throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n        }\n\n        // Retrieve the executor service associated with the dispatcher ID\n        ExecutorService dispatcher = dispatchers.get(dispatcherId);\n\n        // Shutdown the executor immediately\n        dispatcher.shutdownNow();\n\n        // Remove the dispatcher from the collection\n        dispatchers.remove(dispatcherId);\n    }\n}", "CodeBleu_score": 45.89776765855747}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": "private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority) {\n    // Retrieve the children list of the specified parent actor from the actor map.\n    Set<TbActorId> children = actorSystem.getChildren(parent);\n\n    // Logging for debugging: Shows which parent's children are being processed\n    System.out.println(\"Broadcasting to children of: \" + parent);\n\n    // Iterate through each child of the parent actor.\n    for (TbActorId child : children) {\n        // Check if the child meets the conditions specified by the childFilter predicate.\n        if (childFilter.test(child)) {\n            // If the child actor is part of the actor system, send the message.\n            if (actorSystem.isRegistered(child)) {\n                System.out.println(\"Sending message to: \" + child + \" with high priority: \" + highPriority);\n                actorSystem.sendMessage(child, msg, highPriority);\n            } else {\n                // Log a warning message if the child actor is not registered in the actor system.\n                System.out.println(\"Warning: Attempted to send a message to an unregistered child actor: \" + child);\n            }\n        }\n    }\n}", "CodeBleu_score": 49.12521556895349}, {"code": "import java.util.Map;\nimport java.util.function.Predicate;\nimport java.util.logging.Logger;\n\n// Assume appropriate imports for TbActorId, TbActorMsg, and other domain-specific imports\n\npublic class ActorSystem {\n\n    private Map<TbActorId, ActorRef> actors; // Map to manage actors\n    private Logger logger = Logger.getLogger(ActorSystem.class.getName());\n\n    /**\n     * Initializes the ActorSystem with a given map of actors.\n     *\n     * @param actors A map of TbActorId to ActorRef representing all actors.\n     */\n    public ActorSystem(Map<TbActorId, ActorRef> actors) {\n        this.actors = actors;\n    }\n\n    /**\n     * Sends a message to all child actors of a given parent that match a predicate.\n     *\n     * @param parent The parent actor's ID.\n     * @param childFilter A predicate to filter which children should receive the message.\n     * @param msg The message to be sent.\n     * @param highPriority Whether the message should be sent with high priority or not.\n     */\n    private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority) {\n        // Retrieve the children of the parent actor - this part is pseudo and needs actual implementation details\n        List<TbActorId> children = getChildrenOfActor(parent);\n        \n        for (TbActorId child : children) {\n            if (childFilter.test(child)) {\n                ActorRef childActor = actors.get(child);\n                if (childActor != null) {\n                    sendMessageToActor(childActor, msg, highPriority);\n                } else {\n                    logger.warning(\"Actor with ID \" + child + \" not registered!\");\n                }\n            }\n        }\n    }\n\n    /**\n     * This method would handle the specifics of message sending including priority consideration.\n     *\n     * @param childActor The actor reference to which the message has to be sent.\n     * @param msg The message to be sent.\n     * @param highPriority Whether the message should be sent as high priority.\n     */\n    private void sendMessageToActor(ActorRef childActor, TbActorMsg msg, boolean highPriority) {\n        if (highPriority) {\n            childActor.tell(msg, ActorRef.noSender());\n        } else {\n            childActor.tell(msg, ActorRef.noSender());\n        }\n    }\n\n    /**\n     * Placeholder for method to retrieve children of a given actor.\n     *\n     * @param parent The parent actor's ID.\n     * @return List of child actor IDs.\n     */\n    private List<TbActorId> getChildrenOfActor(TbActorId parent) {\n        // Simulated retrieval mechanism\n        return new ArrayList<>(); // should return actual list of children based on `parent`\n    }\n}", "CodeBleu_score": 40.646048811058}, {"code": "private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority) {\n    // Retrieve all child actors from a map using the parent ID\n    List<TbActorId> children = childrenMap.get(parent);\n    \n    if (children == null) {\n        // Log a message if no children found for the given parent\n        System.out.println(\"No children found for parent with ID: \" + parent);\n        return;\n    }\n    \n    // Process each child actor\n    for (TbActorId child : children) {\n        // Apply the filter to determine if the child should receive the message\n        if (childFilter.test(child)) {\n            // Check if the child actor is registered before sending a message\n            if (actorRegistry.contains(child)) {\n                // Send the message to the filtered and registered child\n                if (highPriority) {\n                    // Send with high priority if specified\n                    sendMessageWithPriority(child, msg);\n                } else {\n                    // Send normally if not high priority\n                    sendMessage(child, msg);\n                }\n            } else {\n                // Log warning if the child actor ID is not registered\n                System.out.println(\"Warning: Child actor not registered: \" + child);\n            }\n        }\n    }\n}\n\nprivate void sendMessage(TbActorId actor, TbActorMsg msg) {\n    // Implementation to send message to the specified actor\n    actorSystem.sendMessage(actor, msg);\n}\n\nprivate void sendMessageWithPriority(TbActorId actor, TbActorMsg msg) {\n    // Implementation to send message with higher priority\n    actorSystem.sendMessageWithPriority(actor, msg);\n}", "CodeBleu_score": 41.53055420348474}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority) {\n    // Check if the actor is currently in the process of being destroyed.\n    if (isDestructionInProgress) {\n        if (msg.getType() == TbActorMsgType.RULE_NODE_UPDATED_MSG && highPriority) {\n            // Potentially reinitialize the actor if high priority update message is received during destruction\n            if (!isInitialized()) {\n                try {\n                    initialize();\n                } catch (Exception e) {\n                    System.err.println(\"Failed to reinitialize the actor: \" + e.getMessage());\n                }\n            }\n        } else {\n            msg.notifyStopped();\n        }\n    } else {\n        // If destruction is not in progress, process the message based on its priority.\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        // Attempt to process the queue after enqueuing the new message\n        processQueue();\n    }\n}\n\nprivate void processQueue() {\n    while (!highPriorityMsgs.isEmpty()) {\n        TbActorMsg msg = highPriorityMsgs.poll();\n        processMessage(msg);\n    }\n    while (!normalPriorityMsgs.isEmpty()) {\n        TbActorMsg msg = normalPriorityMsgs.poll();\n        processMessage(msg);\n    }\n}\n\nprivate void processMessage(TbActorMsg msg) {\n    // Processing logic for the messages stored in the queue.\n    // Details depend on the specific actions required for each message type.\n    System.out.println(\"Processing message of type: \" + msg.getType());\n}\n\n// Dummy method to mimic message stop notification\nprivate void notifyStopped() {\n    System.out.println(\"Actor has stopped.\");\n}\n\n// Dummy method to mimic actor initialization status check\nprivate boolean isInitialized() {\n    // return actual initialization status\n    return true;\n}\n\n// Dummy method to mimic actor initialization\nprivate void initialize() throws Exception {\n    // Initialization logic here\n}\n\n// Example message type enumeration for the actor messaging system\nenum TbActorMsgType {\n    RULE_NODE_CREATED_MSG,\n    RULE_NODE_UPDATED_MSG,\n    RULE_NODE_DELETED_MSG\n}\n\n// Example message class for the actor messaging system\nclass TbActorMsg {\n    private TbActorMsgType type;\n\n    public TbActorMsg(TbActorMsgType type) {\n        this.type = type;\n    }\n\n    public TbActorMsgType getType() {\n        return type;\n    }\n\n    public void notifyStopped() {\n        System.out.println(\"Notification: Actor has stopped processing \"+ type);\n    }\n}\n\n// Example use of message enqueuing assuming external definition of queues and destruction flag\nprivate Queue<TbActorMsg> highPriorityMsgs = new LinkedList<>();\nprivate Queue<TbActorMsg> normalPriorityMsgs = new LinkedList<>();\nprivate boolean isDestructionInProgress = false;", "CodeBleu_score": 53.64809483870373}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority) {\n    if (actorState == ActorState.ACTIVE) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    } else if (actorState == ActorState.STOPPED && msg.getType() == TbActorMsg.MsgType.RULE_NODE_UPDATED_MSG) {\n        if (initializationFailed) {\n            try {\n                reinitializeActor();\n            } catch (Exception e) {\n                // Log the exception and handle reinitialization failure\n                System.err.println(\"Actor reinitialization failed: \" + e.getMessage());\n            }\n        }\n    } else {\n        msg.notifyActorStopped();\n    }\n}", "CodeBleu_score": 56.69190467017171}, {"code": "import java.util.ArrayDeque;\nimport java.util.Queue;\n\n// Simple enumeration to represent message types.\nenum MessageType {\n    RULE_NODE_UPDATED_MSG,\n    // other specific message types can be defined here\n    NORMAL_MSG \n}\n\n// Message class assumed based on given requirement\nclass TbActorMsg {\n    MessageType messageType;\n\n    public TbActorMsg(MessageType messageType) {\n        this.messageType = messageType;\n    }\n\n    public void notifyActorStopped() {\n        System.out.println(\"Actor has stopped processing due to destruction phase.\");\n    }\n}\n\n// Main Actor class\npublic class Actor {\n    private boolean actorDestructing = false;\n    private boolean initialized = true;\n    private Queue<TbActorMsg> highPriorityMsgs = new ArrayDeque<>();\n    private Queue<TbActorMsg> normalPriorityMsgs = new ArrayDeque<>();\n\n    private void processMessageQueue() {\n        while (!highPriorityMsgs.isEmpty()) {\n            // Assuming process method exists to handle message.\n            process(highPriorityMsgs.remove());\n        }\n        while (!normalPriorityMsgs.isEmpty()) {\n            process(normalPriorityMsgs.remove());\n        }\n    }\n\n    private void process(TbActorMsg msg) {\n        // Processing the message based on the type\n        System.out.println(\"Processing message of type: \" + msg.messageType);\n        // Additional message-specific processing could be included here.\n    }\n\n    private void reinitializeActor() {\n        // This method would handle actor reinitialization.\n        System.out.println(\"Reinitializing actor\");\n        initialized = true; // Assuming the actor is successfully reinitialized.\n    }\n\n    /**\n     * Enqueues messages to different queues based on their priority and the state of the actor.\n     * @param msg The message to be enqueued.\n     * @param highPriority Boolean indicating if the message has high priority.\n     */\n    public void enqueue(TbActorMsg msg, boolean highPriority) {\n        if (actorDestructing) {\n            if (msg.messageType == MessageType.RULE_NODE_UPDATED_MSG && !initialized) {\n                reinitializeActor();\n                return;  // likely expecting to restart handling after reinitialization\n            } else {\n                msg.notifyActorStopped();\n                return;\n            }\n        }\n\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processMessageQueue();\n    }\n\n    // Methods to simulate actor state changes\n    public void startDestruction() {\n        actorDestructing = true;\n    }\n\n    public void stopDestruction() {\n        actorDestructing = false;\n    }\n\n    // Main method to test handling\n    public static void main(String[] args) {\n        Actor actor = new Actor();\n        actor.enqueue(new TbActorMsg(MessageType.NORMAL_MSG), false);\n        actor.startDestruction();\n        actor.enqueue(new TbActorMsg(MessageType.RULE_NODE_UPDATED_MSG), true); // simulating high-priority message during destruction\n    }\n}", "CodeBleu_score": 46.79531892838858}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox() {\n    int throughputLimit = getThroughputLimit(); // Assumes a method to get current throughput limit\n    int messagesProcessed = 0;\n\n    try {\n        while (messagesProcessed < throughputLimit && !actorIsStopped()) {\n            Message message = getNextMessage();\n\n            if (message == null) {\n                actor.setStatus(FREE);\n                scheduleQueueProcessing();\n                break;\n            }\n\n            try {\n                actor.process(message);\n                messagesProcessed++;\n            } catch (InitializationException ie) {\n                actor.setStopReason(\"Initialization Failure\");\n                actor.destroy();\n                break;\n            } catch (Exception e) {\n                System.err.println(\"Processing failed: \" + e.getMessage());\n                actor.processFailureStrategy(e);\n                if (actor.shouldStopAfterFailure()) {\n                    break;\n                }\n            }\n        }\n    } catch (Exception e) {\n        System.err.println(\"Unexpected error: \" + e.getMessage());\n        // In case of unexpected failures, we can either stop the actor, log it, or take other appropriate actions.\n    }\n}\n\nprivate Message getNextMessage() {\n    if (!highPriorityQueue.isEmpty()) {\n        return highPriorityQueue.poll();\n    } else if (!normalPriorityQueue.isEmpty()) {\n        return normalPriorityQueue.poll();\n    }\n    return null;\n}\n\nprivate void scheduleQueueProcessing() {\n    // Code to schedule future processing, might be using a task scheduler or a similar mechanism\n}\n\nprivate boolean actorIsStopped() {\n    return actor.getStatus() == STOPPED;\n}", "CodeBleu_score": 33.59353225001845}, {"code": "import java.util.Queue;\n\npublic class Actor {\n    private State state;\n    private Queue<Message> highPriorityQueue;\n    private Queue<Message> normalPriorityQueue;\n    private int maxThroughput;\n    private int messagesProcessed;\n\n    public Actor(Queue<Message> highPriorityQueue, Queue<Message> normalPriorityQueue, int maxThroughput) {\n        this.state = State.ACTIVE;\n        this.highPriorityQueue = highPriorityQueue;\n        this.normalPriorityQueue = normalPriorityQueue;\n        this.maxThroughput = maxThroughput;\n        this.messagesProcessed = 0;\n    }\n\n    private enum State {\n        ACTIVE, FREE, STOPPED\n    }\n\n    private void processMailbox() {\n        try {\n            while (state == State.ACTIVE && messagesProcessed < maxThroughput) {\n                Message message = getNextMessage();\n\n                if (message == null) {\n                    state = State.FREE;\n                    // Schedule next processing attempt if needed...\n                    scheduleQueueProcessing();\n                    break;\n                }\n\n                processMessage(message);\n                messagesProcessed++;\n            }\n        } catch (InitializationException ie) {\n            state = State.STOPPED;\n            destroyActor();\n        } catch (Exception e) {\n            logException(e);\n            applyFailureStrategy();\n        }\n    }\n\n    private Message getNextMessage() {\n        if (!highPriorityQueue.isEmpty()) {\n            return highPriorityQueue.poll();\n        } else if (!normalPriorityQueue.isEmpty()) {\n            return normalPriorityQueue.poll();\n        }\n        return null;\n    }\n\n    private void processMessage(Message message) {\n        // Placeholder for message processing\n        System.out.println(\"Processing message: \" + message.getContent());\n    }\n\n    private void destroyActor() {\n        // Placeholder for cleanup and destruction\n        System.out.println(\"Actor destroyed\");\n    }\n\n    private void logException(Exception e) {\n        // Log exception appropriately\n        e.printStackTrace();\n    }\n\n    private void applyFailureStrategy() {\n        // Decide based on the type of failure, whether to stop or take other actions\n        state = State.STOPPED;\n    }\n\n    private void scheduleQueueProcessing() {\n        // Placeholder: Schedule the next attempt to process the mailbox\n        System.out.println(\"Queue will be processed again\");\n    }\n}", "CodeBleu_score": 28.779463523839272}, {"code": "private void processMailbox() {\n    final int THROUGHPUT_LIMIT = 10; // example throughput limit\n    int processedCount = 0;\n    \n    try {\n        while (processedCount < THROUGHPUT_LIMIT && actor.isAvailable()) {\n            Message nextMessage = getNextMessage();\n\n            if (nextMessage == null) {\n                actor.setStatus(Status.FREE);\n                scheduleQueueProcessing();\n                break;\n            }\n\n            try {\n                actor.process(nextMessage);\n                processedCount++;\n            } catch (InitializationFailureException ife) {\n                actor.setStopReason(\"Initialization failed\");\n                actor.destroy();\n                break;\n            } catch (Exception e) {\n                logFailure(e);\n                if (!actor.processFailure(nextMessage)) {\n                    break; // Stop processing if the failure strategy demands stopping\n                }\n            }\n        }\n    } finally {\n        if (actor.getStatus() != Status.FREE) {\n            actor.scheduleProcessing(); // Reschedule if not free\n        }\n    }\n}\n\n/**\n * Assuming existence of the following support methods/classes/enums:\n * - actor.isAvailable() : Checks if the actor is ready to process another message\n * - getNextMessage() : Retrieves the next message from the queue, high priority first\n * - actor.process(Message message) : Processes the message\n * - InitializationFailureException : Specific exception for initialization failures\n * - actor.setStopReason(String reason) : Sets the reason for stopping the process\n * - actor.destroy() : Cleans up resources used by the actor\n * - logFailure(Exception e) : Logs the failure exception\n * - actor.processFailure(Message message) : Performs failure handling and returns whether to continue processing\n * - actor.setStatus(Status status) : Sets the actor's current status\n * - Status : Enum for actor statuses like FREE, BUSY, etc.\n * - scheduleQueueProcessing() : Schedules processing of queues at a later time\n * - actor.scheduleProcessing() : Schedules another processing round for the actor\n */", "CodeBleu_score": 33.08589770358288}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "import java.util.concurrent.ExecutorService;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class Actor {\n    private volatile boolean destructionInProgress = false;\n    private volatile String stopReason = null;\n    private ExecutorService dispatcherExecutor;\n    private Logger logger = Logger.getLogger(Actor.class.getName());\n\n    /**\n     * Constructs an Actor with a specified ExecutorService for dispatching tasks.\n     * @param dispatcherExecutor the ExecutorService for task dispatching\n     */\n    public Actor(ExecutorService dispatcherExecutor) {\n        this.dispatcherExecutor = dispatcherExecutor;\n    }\n\n    /**\n     * Sets the stop reason if it is not already set.\n     * This should be thread-safe.\n     * @param reason the reason for stopping\n     */\n    private synchronized void setStopReason(String reason) {\n        if (stopReason == null) {\n            stopReason = reason;\n        }\n    }\n\n    /**\n     * This action simulates destroying this actor, cleaning up resources, etc.\n     */\n    private void onDestruct() {\n        System.out.println(\"Actor is being destroyed with reason: \" + stopReason);\n    }\n\n    /**\n     * Notifies queued messages that the actor is stopping.\n     */\n    private void notifyQueuedMessages() {\n        System.out.println(\"All queued messages have been notified of the actor's stoppage.\");\n    }\n\n    /**\n     * Initiates the destruction of this actor with a specified cause.\n     * It sets the stop reason if not already set and marks the destruction as in progress.\n     * The function then schedules a task on the dispatcher's executor to set the actor's readiness to \"not ready\", invoke the actor's destroy method with the stop reason and cause, and notify all queued messages of the actor's stoppage.\n     * Any exceptions during this process are logged with a warning.\n     * \n     * @param cause the Throwable cause of destruction\n     */\n    public void destroy(Throwable cause) {\n        // Thread safety to ensure this section can only be entered once\n        synchronized (this) {\n            if (destructionInProgress) {\n                return;\n            }\n            destructionInProgress = true;\n        }\n\n        // Set stop reason based on the given cause\n        setStopReason(cause.toString());\n\n        // Schedule the actual destruction task\n        dispatcherExecutor.execute(() -> {\n            try {\n                System.out.println(\"Setting actor readiness to 'not ready'.\");\n                onDestruct();\n                notifyQueuedMessages();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Exception occurred during destruction\", e);\n            }\n        });\n    }\n}", "CodeBleu_score": 34.30870479202537}, {"code": "public class Actor {\n    private boolean stopReasonSet = false;\n    private boolean destructionInProgress = false;\n    private String stopReason;\n    private Dispatcher dispatcher;\n    private List<Message> messageQueue = new ArrayList<>();\n    \n    // Assuming Dispatcher's basic implementation\n    public class Dispatcher {\n        private Executor executor;\n\n        public Dispatcher(Executor executor) {\n            this.executor = executor;\n        }\n        \n        public void execute(Runnable task) {\n            executor.execute(task);\n        }\n    }\n\n    // Message class to represent queued messages\n    public class Message {\n        public void notifyOfStoppage(String reason) {\n            System.out.println(\"Message stopped due to: \" + reason);\n        }\n    }\n\n    public Actor(Dispatcher dispatcher) {\n        this.dispatcher = dispatcher;\n    }\n    \n    public void destroy(Throwable cause) {\n        if (!stopReasonSet) {\n            stopReason = cause.getMessage();  // Simplified stop reason\n            stopReasonSet = true;\n        }\n        \n        destructionInProgress = true;\n        \n        dispatcher.execute(() -> {\n            try {\n                setReadiness(false);\n                onDestroy(stopReason, cause);\n                notifyMessages();\n            } catch (Exception e) {\n                System.err.println(\"Warning: Exception during destruction - \" + e.getMessage());\n            }\n        });\n    }\n\n    private void setReadiness(boolean ready) {\n        // Set actor's readiness to the specified state\n        System.out.println(\"Readiness set to \" + ready);\n    }\n\n    private void onDestroy(String reason, Throwable cause) {\n        // Perform specific destruction logic, assuming a placeholder implementation\n        System.out.println(\"Destroying actor due to: \" + reason + \", Cause: \" + cause);\n    }\n\n    private void notifyMessages() {\n        messageQueue.forEach(m -> m.notifyOfStoppage(stopReason));\n        messageQueue.clear();\n    }\n}", "CodeBleu_score": 31.110444364318322}, {"code": "import java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class ActorSystem {\n    private static final Logger LOGGER = Logger.getLogger(ActorSystem.class.getName());\n\n    private Actor actor; // Assuming `actor` is an instance of some Actor class.\n    private Dispatcher dispatcher; // Assuming `dispatcher` manages task execution.\n\n    /**\n     * Initiates the destruction of an actor with a specified cause.\n     * It sets the stop reason if not already set and marks the destruction as in progress.\n     * Then schedules a task on the dispatcher's executor to set the actor's readiness to \"not ready\",\n     * invoke the actor's destroy method with the stop reason and cause, and notify all queued messages of the actor's stoppage.\n     * Any exceptions during this process are logged with a warning.\n     *\n     * @param cause The Throwable that is the cause for destroying the actor.\n     */\n    public void destroy(Throwable cause) {\n        try {\n            // Set the stop reason if not already defined.\n            if (!actor.hasStopReason()) {\n                actor.setStopReason(cause);\n            }\n\n            // Mark the destruction as in progress.\n            actor.setDestructionInProgress(true);\n\n            // Schedule the cleanup task on the dispatcher's executor.\n            dispatcher.getExecutor().execute(() -> {\n                try {\n                    // Set actor readiness to \"not ready\".\n                    actor.setReadiness(false);\n\n                    // Destroy the actor with the stop reason and cause.\n                    actor.destroy(cause);\n\n                    // Notify all queued messages.\n                    actor.notifyAllQueuedMessages(\"Actor is destroyed due to: \" + cause.getMessage());\n\n                } catch (Exception e) {\n                    // Log any exceptions raised during the destruction task.\n                    LOGGER.log(Level.WARNING, \"Exception occurred during actor destruction\", e);\n                } finally {\n                    actor.setDestructionInProgress(false);\n                }\n            });\n        } catch (Exception e) {\n            // Log exceptions raised during the setup of destruction.\n            LOGGER.log(Level.WARNING, \"Failed to initiate actor destruction\", e);\n        }\n    }\n}", "CodeBleu_score": 34.63422413510081}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound) throws TenantProfileNotFoundException {\n    // Check if the tenant ID is for the system tenant which is exempt from rate limits.\n    if (tenantId.equals(TenantId.SYSTEM_TENANT_ID)) {\n        return true;\n    }\n\n    // Retrieve the tenant's profile.\n    TenantProfile profile = TenantProfileService.getProfile(tenantId);\n    if (profile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(\"Tenant profile not found for tenant ID: \" + tenantId);\n        }\n    }\n\n    // Fetch the rate limit configuration from the tenant profile.\n    RateLimitConfig rateLimitConfig = profile.getRateLimitConfig(level);\n\n    // Check the current rate for the specified API and its limit.\n    RateLimiter rateLimiter = RateLimiterService.getRateLimiter(api, tenantId, level);\n    boolean isRateUnderLimit = rateLimiter.tryConsume(1);\n\n    // If the rate exceeds the specified limit, process the notification.\n    if (!isRateUnderLimit) {\n        notifyRateLimitExceeded(tenantId, api, rateLimitConfig);\n    }\n\n    // Return the result of the rate limit check.\n    return isRateUnderLimit;\n}\n\n/**\n * This method is responsible for sending notifications when a rate limit is exceeded.\n */\nprivate void notifyRateLimitExceeded(TenantId tenantId, LimitedApi api, RateLimitConfig rateLimitConfig) {\n    // Implementation for sending notification about rate limit violation.\n    // For example: Send an email, log a message, etc.\n    System.out.println(\"Rate limit exceeded for API: \" + api + \", Tenant: \" + tenantId + \", Limit: \" + rateLimitConfig.getMaxRequests());\n}", "CodeBleu_score": 51.276686125807394}, {"code": "public class TenantProfileNotFoundException extends Exception {\n    public TenantProfileNotFoundException(String message) {\n        super(message);\n    }\n}\n\npublic class LimitedApi {\n    // Details about the API such as name, current call count, etc.\n    private String name;\n    private int currentCallCount;\n\n    public LimitedApi(String name, int currentCallCount) {\n        this.name = name;\n        this.currentCallCount = currentCallCount;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getCurrentCallCount() {\n        return currentCallCount;\n    }\n\n    public void incrementCallCount() {\n        this.currentCallCount++;\n    }\n}\n\npublic class TenantId {\n    private String id;\n\n    public TenantId(String id) {\n        this.id = id;\n    }\n\n    public String getId() {\n        return id;\n    }\n}\n\npublic class TenantProfile {\n    private String tenantId;\n    private Integer rateLimit;\n\n    public TenantProfile(String tenantId, Integer rateLimit) {\n        this.tenantId = tenantId;\n        this.rateLimit = rateLimit;\n    }\n\n    public Integer getRateLimit() {\n        return rateLimit;\n    }\n}\n\npublic class RateLimitService {\n    private Map<TenantId, TenantProfile> tenantProfiles;\n\n    public RateLimitService() {\n        this.tenantProfiles = new HashMap<>();\n    }\n\n    public TenantProfile getTenantProfile(TenantId tenantId) {\n        return tenantProfiles.get(tenantId);\n    }\n\n    public void processRateLimitNotification(LimitedApi api, TenantProfile profile) {\n        System.out.println(\"Rate limit exceeded for API: \" + api.getName() + \" of Tenant: \" + profile.tenantId);\n    }\n}\n\npublic boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound) {\n    if (tenantId.getId().equals(\"system\")) {\n        return true;  // System tenant bypasses rate limits.\n    }\n\n    TenantProfile profile = (new RateLimitService()).getTenantProfile(tenantId);\n\n    if (profile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(\"Tenant profile not found for ID: \" + tenantId.getId());\n        }\n    }\n\n    api.incrementCallCount(); \n    if (profile.getRateLimit() != null && api.getCurrentCallCount() > profile.getRateLimit()) {\n        (new RateLimitService()).processRateLimitNotification(api, profile);\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 39.009137049459156}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound) throws TenantProfileNotFoundException {\n    // Check if the tenant ID corresponds to the system tenant. If so, bypass rate limit check.\n    if (tenantId.equals(TenantId.SYSTEM_TENANT_ID)) {\n        return true;\n    }\n\n    // Retrieve the tenant's profile\n    TenantProfile tenantProfile = TenantProfileService.getProfile(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(\"Tenant profile not found for ID: \" + tenantId);\n        }\n    }\n\n    // Fetch rate limit configuration from the tenant profile\n    RateLimitConfiguration config = tenantProfile.getRateLimitConfig();\n\n    // Check the rate limit\n    RateLimiter rateLimiter = RateLimiterFactory.getRateLimiter(config, level);\n    if (!rateLimiter.tryAcquire()) {\n        processRateLimitNotification(tenantId, api);\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Helper method to process rate limit notification\n */\nprivate void processRateLimitNotification(TenantId tenantId, LimitedApi api) {\n    System.out.printf(\"Rate limit exceeded for tenantId=%s on api=%s%n\", tenantId, api);\n}\n\n// Assuming necessary classes like TenantProfile, TenantId, LimitedApi exist\n// Assuming methods like getProfile, getRateLimitConfig, getRateLimiter and tryAcquire exist\n// Assuming RuntimeExceptions or specific checked exceptions for tenant retrieval failure and notification processing issues", "CodeBleu_score": 51.48726406115583}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "import java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n// Assuming a Session class exists which holds session details including the last activity time.\nclass Session {\n    private long lastActivityTime;\n\n    public Session(long lastActivityTime) {\n        this.lastActivityTime = lastActivityTime;\n    }\n\n    public long getLastActivityTime() {\n        return lastActivityTime;\n    }\n}\n\npublic class SessionManager {\n    private Map<String, Session> dtlsSessions; // Store for DTLS sessions\n    private long timeoutInMillis; // Inactivity timeout in milliseconds\n\n    public SessionManager(long timeoutInMillis) {\n        this.dtlsSessions = new HashMap<>();\n        this.timeoutInMillis = timeoutInMillis;\n    }\n\n    /**\n     * Evicts DTLS sessions that have been inactive longer than the specified timeout.\n     */\n    public void evictTimeoutSessions() {\n        long currentMillis = System.currentTimeMillis();\n        long expirationTime = currentMillis - timeoutInMillis;\n\n        Iterator<Map.Entry<String, Session>> it = dtlsSessions.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<String, Session> entry = it.next();\n            if (entry.getValue().getLastActivityTime() < expirationTime) {\n                System.out.println(\"Removing session \" + entry.getKey() + \" due to inactivity.\"); // Log before removal\n                it.remove(); // Removes current session if inactive\n            }\n        }\n    }\n\n    // Methods to add sessions or update activity time for testing\n    public void addSession(String sessionId, Session session) {\n        dtlsSessions.put(sessionId, session);\n    }\n\n    public static void main(String[] args) {\n        SessionManager manager = new SessionManager(30000); // Let's say 30 seconds timeout\n        manager.addSession(\"session1\", new Session(System.currentTimeMillis() - 60000)); // 1 minute ago, should timeout\n        manager.addSession(\"session2\", new Session(System.currentTimeMillis())); // recent, should not timeout\n\n        manager.evictTimeoutSessions(); // Testing eviction\n\n        // Assuming a method to list sessions (or print directly from the map)\n    }\n}", "CodeBleu_score": 33.58366248681036}, {"code": "import java.util.Iterator;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\npublic class DTLSManager {\n    private Map<String, DTLSsession> sessions;\n    private long inactivityTimeout;\n    private static final Logger logger = Logger.getLogger(DTLSManager.class.getName());\n\n    public DTLSManager(Map<String, DTLSsession> sessions, long inactivityTimeout) {\n        this.sessions = sessions;\n        this.inactivityTimeout = inactivityTimeout;\n    }\n\n    /**\n     * Removes DTLS sessions that have been inactive for a duration longer than the specified timeout.\n     * It calculates the expiration time based on the current time minus the inactivity timeout.\n     * It then iterates over the entries in the DTLS sessions map and removes those\n     * with a last activity time older than the calculated expiration time, logging each removal.\n     */\n    public void evictTimeoutSessions() {\n        long now = System.currentTimeMillis();\n        long expirationTime = now - inactivityTimeout;\n\n        Iterator<Map.Entry<String, DTLSsession>> sessionIterator = sessions.entrySet().iterator();\n        while (sessionIterator.hasNext()) {\n            Map.Entry<String, DTLSsession> entry = sessionIterator.next();\n            DTLSsession session = entry.getValue();\n\n            if (session.getLastActivityTime() < expirationTime) {\n                sessionIterator.remove();\n                logger.info(\"Evicted DTLS session with ID: \" + entry.getKey() + \" due to inactivity.\");\n            }\n        }\n    }\n\n    // Mock class representing a DTLS session with the last activity time.\n    public static class DTLSsession {\n        private long lastActivityTime;\n\n        public DTLSsession(long lastActivityTime) {\n            this.lastActivityTime = lastActivityTime;\n        }\n\n        public long getLastActivityTime() {\n            return lastActivityTime;\n        }\n    }\n}", "CodeBleu_score": 35.39623393884458}, {"code": "import java.util.Iterator;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\npublic class DTLSSessionManager {\n\n    // Assuming there's a map to store sessions with their last activity timestamp.\n    // The key is the session identifier, and the value is the last active timestamp.\n    private Map<String, Long> dtlsSessionsMap;\n    \n    // The inactivity timeout duration in milliseconds.\n    private long inactivityTimeoutMillis;\n    \n    // Logger instance to log the actions taken in the session manager.\n    private static final Logger LOGGER = Logger.getLogger(DTLSSessionManager.class.getName());\n\n    public DTLSSessionManager(Map<String, Long> dtlsSessionsMap, long inactivityTimeoutMillis) {\n        this.dtlsSessionsMap = dtlsSessionsMap;\n        this.inactivityTimeoutMillis = inactivityTimeoutMillis;\n    }\n\n    /**\n     * Removes DTLS sessions that have been inactive for longer than the specified timeout.\n     * It calculates the expiration time based on the current time minus the inactivity timeout.\n     * It iterates over the entries in the DTLS sessions map and removes those with a last activity time older than the calculated expiration time,\n     * logging each removal.\n     */\n    public void evictTimeoutSessions() {\n        // Calculate expiration threshold time based on the current time and inactivity timeout.\n        long currentTimeMillis = System.currentTimeMillis();\n        long expirationThreshold = currentTimeMillis - inactivityTimeoutMillis;\n\n        // Using an iterator to avoid ConcurrentModificationException while removing.\n        Iterator<Map.Entry<String, Long>> iterator = dtlsSessionsMap.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String, Long> entry = iterator.next();\n            long lastActivityTime = entry.getValue();\n            \n            // Check if the session last activity time is earlier than expiration threshold.\n            if (lastActivityTime < expirationThreshold) {\n                // Logging the session ID and its last activity time before removing.\n                LOGGER.info(\"Removing DTLS session \" + entry.getKey() + \" due to inactivity. Last active: \" + lastActivityTime);\n                // Removing the entry.\n                iterator.remove();\n            }\n        }\n    }\n}", "CodeBleu_score": 35.524418856774446}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "import com.fasterxml.jackson.databind.JsonNode;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class TsKvEntry {\n    private String key;\n    private List<JsonNode> values;\n\n    public TsKvEntry(String key, List<JsonNode> values) {\n        this.key = key;\n        this.values = values;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public List<JsonNode> getValues() {\n        return values;\n    }\n\n    @Override\n    public String toString() {\n        return \"TsKvEntry{\" +\n               \"key='\" + key + '\\'' +\n               \", values=\" + values +\n               '}';\n    }\n}\n\npublic static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries) {\n    List<TsKvEntry> entries = new ArrayList<>();\n\n    if (timeseries == null || timeseries.isEmpty()) {\n        return entries; // return empty list if input map is empty or null\n    }\n\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        if (values != null) {\n            entries.add(new TsKvEntry(key, values)); // create and add TsKvEntry instance to the list\n        }\n    }\n\n    return entries;\n}", "CodeBleu_score": 34.266982039108015}, {"code": "import com.fasterxml.jackson.databind.JsonNode;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class TsKvEntry {\n    private String key;\n    private List<JsonNode> values;\n\n    // Constructor\n    public TsKvEntry(String key, List<JsonNode> values) {\n        this.key = key;\n        this.values = values;\n    }\n\n    // Getter and Setter\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public List<JsonNode> getValues() {\n        return values;\n    }\n\n    public void setValues(List<JsonNode> values) {\n        this.values = values;\n    }\n\n    @Override\n    public String toString() {\n        return \"TsKvEntry{\" + \"key='\" + key + '\\'' + \", values=\" + values + '}';\n    }\n}\n\npublic class TimeseriesConverter {\n    /**\n     * The function \"toTimeseries\" converts a map of timeseries data into a list of TsKvEntry objects.\n     * It first checks if the input map is not empty.\n     * If not empty, it iterates over the map entries, parses the values, and constructs a list of TsKvEntry objects for each key-value pair in the map.\n     * If the input map is empty, it returns an empty list.\n     */\n    public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries) {\n        List<TsKvEntry> entries = new ArrayList<>();\n\n        if (timeseries != null && !timeseries.isEmpty()) {\n            for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n                String key = entry.getKey();\n                List<JsonNode> values = entry.getValue();\n                entries.add(new TsKvEntry(key, values));\n            }\n        }\n\n        return entries;\n    }\n\n    // You can add a main method to test this function if necessary\n    public static void main(String[] args) {\n        // Example usage\n        // Assuming you have a way to fill the timeseries map and JsonNode is a part of Jackson library\n    }\n}", "CodeBleu_score": 33.641628672495415}, {"code": "import com.fasterxml.jackson.databind.JsonNode;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\npublic static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries) {\n    List<TsKvEntry> entries = new ArrayList<>();\n    if (!timeseries.isEmpty()) {\n        for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n            String key = entry.getKey();\n            List<JsonNode> values = entry.getValue();\n            for (JsonNode value : values) {\n                TsKvEntry tsKvEntry = new TsKvEntry(key, value);\n                entries.add(tsKvEntry);\n            }\n        }\n    }\n    return entries;\n}\n\npublic static class TsKvEntry {\n    private String key;\n    private JsonNode value;\n\n    public TsKvEntry(String key, JsonNode value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public JsonNode getValue() {\n        return value;\n    }\n\n    // Override toString for better display if needed\n    @Override\n    public String toString() {\n        return \"TsKvEntry{\" +\n               \"key='\" + key + '\\'' +\n               \", value=\" + value +\n               '}';\n    }\n}", "CodeBleu_score": 35.57805594614349}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Instant;\nimport org.json.JSONObject;\n\npublic void refreshToken() {\n    // HttpClient instance\n    HttpClient client = HttpClient.newHttpClient();\n\n    // URI for the authentication endpoint\n    String endpoint = \"https://api.example.com/auth/refresh\";\n    URI uri = URI.create(endpoint);\n    \n    // Suppose refreshToken is stored somewhere it can be retrieved\n    String currentRefreshToken = \"your_refresh_token_here\";\n\n    // Setting up the request body\n    JSONObject data = new JSONObject();\n    data.put(\"refresh_token\", currentRefreshToken);\n    \n    // Create HttpRequest\n    HttpRequest request = HttpRequest.newBuilder()\n            .uri(uri)\n            .header(\"Content-Type\", \"application/json\")\n            .POST(HttpRequest.BodyPublishers.ofString(data.toString()))\n            .build();\n\n    try {\n        // Send the request and receive the response\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        // Handling the response\n        if (response.statusCode() == 200) {\n            String responseBody = response.body();\n            JSONObject jsonResponse = new JSONObject(responseBody);\n            \n            // Assuming the response JSON has access_token and other token details\n            String newAccessToken = jsonResponse.getString(\"access_token\");\n            String newRefreshToken = jsonResponse.getString(\"refresh_token\");\n            \n            // Update the tokens and current timestamp somewhere in your application data\n            // This could involve storing them in a database or a static variable\n            updateTokenDetails(newAccessToken, newRefreshToken, Instant.now());\n            \n            System.out.println(\"Token refreshed successfully.\");\n        } else {\n            // Handle errors or unsuccessful status codes\n            System.out.println(\"Failed to refresh token: \" + response.statusCode());\n        }\n    } catch (Exception e) {\n        System.out.println(\"Exception occurred while refreshing token: \" + e.getMessage());\n        e.printStackTrace();\n    }\n}\n\nprivate void updateTokenDetails(String accessToken, String refreshToken, Instant timestamp) {\n    // Implement this method to update token information in your storage\n    // For example:\n    System.out.println(\"Access Token: \" + accessToken);\n    System.out.println(\"Refresh Token: \" + refreshToken);\n    System.out.println(\"Token Timestamp: \" + timestamp);\n}", "CodeBleu_score": 29.63934480789047}, {"code": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.io.OutputStream;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class AuthenticationManager {\n    private String refreshToken;\n    private String accessToken;\n    private long tokenLastUpdated;\n\n    public AuthenticationManager(String refreshToken) {\n        this.refreshToken = refreshToken;\n    }\n\n    public void refreshToken() {\n        try {\n            // Endpoint URL\n            String authEndpoint = \"https://example.com/auth/token\";\n\n            // Create request payload\n            Map<String, String> requestBody = new HashMap<>();\n            requestBody.put(\"refresh_token\", this.refreshToken);\n\n            // Serialize the payload to JSON\n            ObjectMapper objectMapper = new ObjectMapper();\n            String jsonPayload = objectMapper.writeValueAsString(requestBody);\n\n            // Send POST request\n            String response = sendPostRequest(authEndpoint, jsonPayload);\n\n            // Process the response to update tokens\n            Map<String, String> responseMap = objectMapper.readValue(response, Map.class);\n            this.accessToken = responseMap.get(\"access_token\");\n            this.refreshToken = responseMap.get(\"refresh_token\");\n            \n            // Update the timestamp\n            this.tokenLastUpdated = System.currentTimeMillis();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String sendPostRequest(String requestUrl, String payload) throws IOException {\n        URL url = new URL(requestUrl);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; utf-8\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        connection.setDoOutput(true);\n\n        try (OutputStream os = connection.getOutputStream()) {\n            byte[] input = payload.getBytes(\"utf-8\");\n            os.write(input, 0, input.length);\n        }\n\n        StringBuilder response = new StringBuilder();\n        connection.getInputStream().transferTo(java.nio.file.Files.newOutputStream(java.nio.file.Paths.get(response.toString())));\n\n        return response.toString();\n    }\n}", "CodeBleu_score": 30.84274171683033}, {"code": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpRequest.BodyPublishers;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.time.Instant;\nimport org.json.JSONObject; // Requires the JSON library\n\npublic class AuthenticationService {\n\n    private String refreshToken;\n    private String accessToken;\n    private static final String AUTH_ENDPOINT = \"https://example.com/api/auth/refresh\";\n\n    public AuthenticationService(String refreshToken) {\n        this.refreshToken = refreshToken;\n    }\n\n    public void refreshToken() {\n        try {\n            // Step 1: Create a request map containing the current refresh token\n            JSONObject requestBody = new JSONObject();\n            requestBody.put(\"refresh_token\", this.refreshToken);\n\n            // Step 2: Send a POST request to the authentication endpoint\n            HttpClient client = HttpClient.newHttpClient();\n            HttpRequest request = HttpRequest.newBuilder()\n                    .uri(URI.create(AUTH_ENDPOINT))\n                    .header(\"Content-Type\", \"application/json\")\n                    .POST(BodyPublishers.ofString(requestBody.toString()))\n                    .build();\n\n            HttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n\n            // Step 3: Check response status\n            if (response.statusCode() == 200) {\n                // Step 4: Parse response body and update token information\n                JSONObject responseBody = new JSONObject(response.body());\n                this.accessToken = responseBody.getString(\"access_token\");\n                this.refreshToken = responseBody.getString(\"refresh_token\"); // Update the refresh token if it's returned\n                // Optionally, we can store a timestamp or additional data\n                System.out.println(\"Token refreshed successfully at \" + Instant.now());\n\n            } else {\n                // Handle invalid response or error (e.g., refresh token is invalid)\n                throw new Exception(\"Failed to refresh token. Status code: \" + response.statusCode());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            // Handle exceptions such as network errors\n            System.out.println(\"Error refreshing token: \" + e.getMessage());\n        }\n    }\n}", "CodeBleu_score": 27.15496223845505}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": "import java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class AuthenticationService {\n\n    // Example credentials, these should be securely managed or obtained dynamically in a real scenario\n    private String username = \"user\";\n    private String password = \"password\";\n    \n    // Token data\n    private String token;\n    private long tokenTimestamp;\n\n    private void doLogin() {\n        // Step 1: Capture the current timestamp\n        tokenTimestamp = new Date().getTime();\n        \n        // Step 2: Create the login request map\n        Map<String, String> credentials = new HashMap<>();\n        credentials.put(\"username\", username);\n        credentials.put(\"password\", password);\n        \n        // Step 3: Prepare request data in JSON format\n        ObjectMapper mapper = new ObjectMapper();\n        String requestData = \"\";\n        try {\n            requestData = mapper.writeValueAsString(credentials);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        \n        // Step 4: Set up URL and open connection\n        try {\n            URL url = new URL(\"https://example.com/api/auth/login\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setRequestProperty(\"Accept\", \"application/json\");\n            conn.setDoOutput(true);\n\n            // Step 5: Send JSON data\n            conn.getOutputStream().write(requestData.getBytes(StandardCharsets.UTF_8));\n            \n            // Step 6: Check response and handle it\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                // Read response JSON\n                String responseJson = new String(conn.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\n                Map<String, Object> responseMap = mapper.readValue(responseJson, Map.class);\n                \n                // Update token information with the response data\n                token = (String) responseMap.get(\"token\");\n\n                System.out.println(\"Login successful. Token: \" + token);\n            } else {\n                System.out.println(\"Login failed. HTTP error code: \" + conn.getResponseCode());\n                // Handle error appropriately here\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}", "CodeBleu_score": 36.232956208005795}, {"code": "import java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class AuthService {\n\n    private String token;\n    private long tokenTimestamp;\n\n    private void doLogin() {\n        String username = \"yourUsername\";  // Replace with actual username\n        String password = \"yourPassword\";  // Replace with actual password\n        String endpoint = \"http://example.com/api/auth/login\";\n\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(endpoint);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/json\");\n            connection.setRequestProperty(\"Accept\", \"application/json\");\n            connection.setDoOutput(true);\n\n            // Write JSON payload to the request body\n            Map<String, String> loginDetails = Map.of(\"username\", username, \"password\", password);\n            String jsonInputString = new JSONObject(loginDetails).toString();\n            try (OutputStream os = connection.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);\n            }\n\n            // Read response\n            try (BufferedReader br = new BufferedReader(\n                new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) {\n                StringBuilder response = new StringBuilder();\n                String responseLine = null;\n                while ((responseLine = br.readLine()) != null) {\n                    response.append(responseLine.trim());\n                }\n                \n                // Assuming the response JSON contains {\"token\": \"<token_value>\"}\n                JSONObject responseJson = new JSONObject(response.toString());\n                token = responseJson.getString(\"token\");\n                tokenTimestamp = new Date().getTime();  // Capture the current timestamp\n            }\n\n            System.out.println(\"Logged in successfully. Token: \" + token);\n        } catch (Exception e) {\n            System.out.println(\"Error during login: \" + e.getMessage());\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    // Additional methods for handling authentication, tokens etc. can be added here\n}", "CodeBleu_score": 27.33957646216857}, {"code": "private void doLogin() {\n    // Capture the current timestamp\n    long timestamp = System.currentTimeMillis();\n\n    try {\n        // Setup HTTP client\n        HttpClient client = HttpClient.newHttpClient();\n\n        // Create the credentials map\n        Map<String, String> loginCredentials = new HashMap<>();\n        loginCredentials.put(\"username\", \"user123\");\n        loginCredentials.put(\"password\", \"password\");\n\n        // Convert the credentials map to JSON\n        String requestBody = new Gson().toJson(loginCredentials);\n\n        // Create the POST request with the credentials\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"http://example.com/api/auth/login\"))\n                .header(\"Content-Type\", \"application/json\")\n                .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                .build();\n\n        // Send the request and receive the response\n        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        if (response.statusCode() == 200) {\n            // Parse the response to get the token\n            String token = new Gson().fromJson(response.body(), Map.class).get(\"token\").toString();\n\n            // Update token information (store to a pertinent place, perhaps a member variable or a database)\n            updateTokenInfo(token, timestamp);\n        } else {\n            System.out.println(\"Login failed with status code: \" + response.statusCode());\n        }\n    } catch (InterruptedException | IOException e) {\n        System.out.println(\"An error occurred during the login process: \" + e.getMessage());\n        Thread.currentThread().interrupt();\n    }\n}\n\nprivate void updateTokenInfo(String token, long timestamp) {\n    // Update token information logic here\n    System.out.println(\"Token: \" + token + \" received at timestamp: \" + timestamp);\n}", "CodeBleu_score": 40.41420653806706}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Optional;\n\npublic class DeviceService {\n\n    private static final String BASE_URL = \"http://example.com/api/device/\";\n    private final HttpClient httpClient = HttpClient.newHttpClient();\n\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        // Build the URI and create the GET request\n        URI uri = URI.create(BASE_URL + deviceId.getId());\n        HttpRequest request = HttpRequest.newBuilder()\n                                         .uri(uri)\n                                         .GET()\n                                         .build();\n\n        try {\n            // Send the request and handle the response\n            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 200) {\n                Device device = parseDevice(response.body());\n                return Optional.of(device);\n            } else if (response.statusCode() == 404) {\n                return Optional.empty();\n            } else {\n                throw new RuntimeException(\"Server returned HTTP error code: \" + response.statusCode());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to retrieve device by id: \" + deviceId, e);\n        }\n    }\n\n    private Device parseDevice(String json) {\n        // Parse JSON using your chosen library (e.g., Jackson)\n        return new Device(); // Placeholder implementation\n    }\n}", "CodeBleu_score": 44.52039732394311}, {"code": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.Optional;\n\npublic class DeviceService {\n\n    // Assuming Device and DeviceId are defined elsewhere in your application\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        HttpClient httpClient = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(URI.create(\"http://example.com/api/device/\" + deviceId.toString()))\n            .GET()\n            .build();\n\n        try {\n            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n\n            if (response.statusCode() == 200) { // Assuming a 200 OK response contains the device data\n                Device device = parseDeviceFromJson(response.body());\n                return Optional.of(device);\n            } else if (response.statusCode() == 404) {\n                return Optional.empty(); // Device not found\n            } else {\n                throw new RuntimeException(\"Failed to fetch device: \" + response.statusCode());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Exception occurred while fetching device\", e);\n        }\n    }\n\n    private Device parseDeviceFromJson(String json) {\n        // Implement JSON parsing logic, possibly using libraries like Jackson or Gson\n        // Example:\n        // Gson gson = new Gson();\n        // return gson.fromJson(json, Device.class);\n        \n        return new Device(); // Placeholder\n    }\n\n    // Assuming Device and DeviceId classes are like this:\n    public static class Device {\n        // Device fields and methods here\n    }\n\n    public static class DeviceId {\n        private final String id;\n\n        public DeviceId(String id) {\n            this.id = id;\n        }\n\n        @Override\n        public String toString() {\n            return id;\n        }\n    }\n}", "CodeBleu_score": 45.028748400040485}, {"code": "import java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Optional;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class DeviceService {\n\n    /**\n     * Retrieves a device by its ID using a REST API call.\n     * Sends a GET request to the \"/api/device/{deviceId}\" endpoint and returns the device wrapped in an Optional if found.\n     * If a 404 (Not Found) error occurs, it returns an empty Optional.\n     * For other HTTP errors, it rethrows the exception.\n     *\n     * @param deviceId the ID of the device to retrieve\n     * @return Optional containing the found Device or empty if not found\n     * @throws IOException if there is an I/O error with the API call\n     * @throws RuntimeException for non-404 HTTP errors\n     */\n    public Optional<Device> getDeviceById(DeviceId deviceId) {\n        HttpURLConnection connection = null;\n        \n        try {\n            URL url = new URL(\"http://example.com/api/device/\" + deviceId.getId());\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"GET\");\n            connection.setRequestProperty(\"Accept\", \"application/json\");\n\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                return Optional.empty();\n            } else if (responseCode != HttpURLConnection.HTTP_OK) {\n                throw new RuntimeException(\"HTTP error code: \" + responseCode);\n            }\n\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            StringBuilder response = new StringBuilder();\n\n            while ((inputLine = in.readLine()) != null) {\n                response.append(inputLine);\n            }\n            in.close();\n\n            // Assuming the JSON response is directly mapped to a Device object\n            Device device = parseDeviceFromJson(response.toString());\n            return Optional.ofNullable(device);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error occurred while fetching device by ID: \" + deviceId.getId(), e);\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n\n    /**\n     * Parses JSON string to a Device object\n     *\n     * @param jsonResponse the JSON response string\n     * @return Device parsed from the JSON string\n     */\n    private Device parseDeviceFromJson(String jsonResponse) {\n        // Implement JSON parsing logic, possibly using a library like Jackson or Gson\n        // Example:\n        // Gson gson = new Gson();\n        // return gson.fromJson(jsonResponse, Device.class);\n        return null;  // mock return for example purposes\n    }\n\n    // Assuming Device and DeviceId classes\n    private static class Device {\n        // Device fields and methods\n    }\n\n    private static class DeviceId {\n        private String id;\n\n        public String getId() {\n            return id;\n        }\n\n        public DeviceId(String id) {\n            this.id = id;\n        }\n    }\n}", "CodeBleu_score": 40.44423498538578}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.util.Optional;\n\npublic class DeviceService {\n\n    public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials) {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = buildRequest(device, credentials);\n\n        try {\n            HttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n\n            if (response.statusCode() == 404) {\n                return Optional.empty();\n            } else if (response.statusCode() == 200) {\n                Device savedDevice = parseDevice(response.body());\n                return Optional.ofNullable(savedDevice);\n            } else {\n                throw new RuntimeException(\"Unexpected response status: \" + response.statusCode());\n            }\n        } catch (Exception e) {\n            if (e instanceof InterruptedException) {\n                Thread.currentThread().interrupt();\n            }\n            throw new RuntimeException(\"Error saving device with credentials: \" + e.getMessage(), e);\n        }\n    }\n\n    private HttpRequest buildRequest(Device device, DeviceCredentials credentials) {\n        String requestBody = toJson(device, credentials);\n\n        return HttpRequest.newBuilder()\n                .uri(URI.create(\"http://yourapi.com/api/device-with-credentials\"))\n                .header(\"Content-Type\", \"application/json\")\n                .POST(HttpRequest.BodyPublishers.ofString(requestBody))\n                .build();\n    }\n\n    private String toJson(Device device, DeviceCredentials credentials) {\n        // This method should serialize Device and Credentials objects to JSON string\n        // Here using a dummy implementation. You should use a library like Jackson or Gson in real cases.\n        return \"{\\\"device\\\": \\\"\" + device.toString() + \"\\\", \" +\n               \"\\\"credentials\\\": \\\"\" + credentials.toString() + \"\\\"}\";\n    }\n\n    private Device parseDevice(String responseBody) {\n        // This method should deserialize the response body back to a Device object.\n        // Again, using a dummy implementation. Use Jackson or Gson in realistic scenarios.\n        return new Device(); // assume a constructor or appropriate method exists.\n    }\n}\n\nclass Device {\n    // Device class fields and methods\n}\n\nclass DeviceCredentials {\n    // DeviceCredentials class fields and methods\n}", "CodeBleu_score": 42.25501463844155}, {"code": "import java.util.Optional;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials) {\n    HttpURLConnection connection = null;\n    try {\n        // Create the JSON object to be sent\n        JSONObject requestBody = new JSONObject();\n        requestBody.put(\"device\", device.toJSON());\n        requestBody.put(\"credentials\", credentials.toJSON());\n\n        // Setup POST request\n        URL url = new URL(\"http://example.com/api/device-with-credentials\");\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=UTF-8\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        connection.setDoOutput(true);\n\n        // Write the JSON body to the request\n        OutputStream os = connection.getOutputStream();\n        os.write(requestBody.toString().getBytes(StandardCharsets.UTF_8));\n        os.close();\n\n        // Check the response code\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            // Read the response\n            InputStream is = connection.getInputStream();\n            String response = new String(is.readAllBytes(), StandardCharsets.UTF_8);\n            JSONObject jsonResponse = new JSONObject(response);\n            \n            // Parse the response to create a Device object\n            Device savedDevice = Device.fromJSON(jsonResponse.getJSONObject(\"device\"));\n            return Optional.of(savedDevice);\n        } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n            return Optional.empty();\n        } else {\n            throw new IOException(\"Server returned non-OK status: \" + responseCode);\n        }\n    } catch (Exception e) {\n        if (e instanceof IOException) {\n            throw (IOException) e; // Rethrow the IOException\n        }\n        throw new RuntimeException(\"Unexpected exception\", e);\n    } finally {\n        if (connection != null) {\n            connection.disconnect();\n        }\n    }\n}", "CodeBleu_score": 40.13986165785385}, {"code": "import java.util.Optional;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.io.OutputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class DeviceManager {\n    // Define a method to save a device with credentials\n    public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials) {\n        try {\n            // Create a URL object for the API endpoint\n            URL url = new URL(\"http://example.com/api/device-with-credentials\");\n\n            // Open a connection and configure it for POST\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/json\");\n            conn.setDoOutput(true);\n\n            // Convert the device and credentials to a JSON string\n            String jsonInputString = toJson(device, credentials);\n\n            // Write the JSON data to the request body\n            try (OutputStream os = conn.getOutputStream()) {\n                byte[] input = jsonInputString.getBytes(StandardCharsets.UTF_8);\n                os.write(input, 0, input.length);\n            }\n\n            // Get the response code to determine the outcome of the operation\n            int responseCode = conn.getResponseCode();\n            if (responseCode == HttpURLConnection.HTTP_OK) {\n                // Read the device from the response\n                try (InputStream is = conn.getInputStream()) {\n                    Device savedDevice = readDeviceFromInputStream(is);\n                    return Optional.of(savedDevice);\n                }\n            } else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {\n                return Optional.empty();\n            } else {\n                throw new RuntimeException(\"Failed to save device: \" + conn.getResponseMessage());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error occurred while saving device\", e);\n        }\n    }\n\n    // Helper method to convert device and credentials to JSON\n    private String toJson(Device device, DeviceCredentials credentials) {\n        // Implementation depends on the JSON library used (e.g., Gson, Jackson)\n        // Using simple concatenation for demonstration\n        return \"{\\\"device\\\": \\\"\" + device.toString() + \"\\\", \\\"credentials\\\": \\\"\" + credentials.toString() + \"\\\"}\";\n    }\n\n    // Helper method to read a Device object from InputStream\n    private Device readDeviceFromInputStream(InputStream is) {\n        // Implementation depends on how the response is received (JSON, XML, etc.)\n        // This is a placeholder that should be replaced with actual parsing logic\n        return new Device(); // Return a new device object (replace with actual parsing)\n    }\n}", "CodeBleu_score": 41.57991082279386}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "class LEDController {\n    constructor() {\n        this.devices = new Map();  // Mock representation of each device and its brightness\n        this.maxBrightnessValue = 15;  // Max brightness value for LED device\n    }\n\n    /**\n     * Adjusts the brightness of LED devices.\n     * If only one argument is provided (val), it sets the brightness for all devices to the given value.\n     * If two arguments are provided (addr, val), it sets the brightness for the specified device address\n     * to the given value, mapped from a percentage (0-100) to a scale used by the LED controller (0-15).\n     * \n     * @param {number|undefined} addr - The address of the device to adjust. If undefined, adjust all devices.\n     * @param {number} val - The brightness value in percentage (0-100) or direct scale value if no addr provided.\n     * @returns {LEDController} - Returns itself for method chaining.\n     */\n    brightness(addr, val) {\n        if (addr === undefined) {\n            // val is interpreted as brightness for all devices\n            this.devices.forEach((_, key) => this.devices.set(key, this.mapPercentageToScale(val)));\n        } else {\n            // addr is specified, interpret val as a percentage and map it\n            this.devices.set(addr, this.mapPercentageToScale(val));\n        }\n        return this;  // Enable chaining by returning the instance\n    }\n\n    /**\n     * Maps a percentage value (0-100) to the controller's scale (0-15).\n     * \n     * @param {number} percentage - The brightness percentage.\n     * @returns {number} - Mapped brightness value according to the controller's scale.\n     */\n    mapPercentageToScale(percentage) {\n        return Math.round((percentage / 100) * this.maxBrightnessValue);\n    }\n\n    // Just a utility method for setting up devices\n    addDevice(addr) {\n        this.devices.set(addr, 0);  // Default brightness is 0.\n    }\n}\n\n// Example usage\nconst ledController = new LEDController();\nledController.addDevice(1);\nledController.addDevice(2);\n\n// Setting brightness of a specific device\nledController.brightness(1, 50);\n\n// Setting all device brightness to a specific value\nledController.brightness(undefined, 70);\n\nconsole.log(ledController.devices);", "CodeBleu_score": 39.6820843321376}, {"code": "class LEDController {\n  constructor() {\n    this.devices = {};\n    this.brightnessLevels = {};\n    // Assuming a mock-up mapped addresses to device names\n    this.deviceAddresses = {\n      1: 'LED1',\n      2: 'LED2',\n      // Add more addresses as needed\n    };\n  }\n\n  // Function to adjust the brightness\n  brightness(addr, val = null) {\n    // Normalize the value to be within the LED controller scale 0-15\n    const normalizeBrightness = (percentageVal) => Math.round((percentageVal / 100) * 15);\n\n    // If val is null, assume setting all devices to the brightness given in addr\n    if (val === null) {\n      const normalizedBrightnessAll = normalizeBrightness(addr);\n      for (let deviceAddress in this.deviceAddresses) {\n        this.brightnessLevels[this.deviceAddresses[deviceAddress]] = normalizedBrightnessAll;\n      }\n    } else {\n      // Set specified device address' brightness, addr = address, val = percentage value\n      const deviceName = this.deviceAddresses[addr];\n      if (!deviceName) {\n        throw new Error(`No device found at address ${addr}`);\n      }\n      this.brightnessLevels[deviceName] = normalizeBrightness(val);\n    }\n\n    // Return this for method chaining\n    return this;\n  }\n}\n\n// Example usage:\nconst ledController = new LEDController();\nledController.brightness(50); // Set all devices to normalized level from 50% brightness\nledController.brightness(1, 75); // Set device at address 1 to normalized level from 75% brightness\n\nconsole.log(ledController.brightnessLevels); // Should show updated brightness levels", "CodeBleu_score": 21.72406184132128}, {"code": "/**\n * Adjusts the brightness of LED devices.\n * @param {number | undefined} addr - If a single parameter is provided, it sets the brightness for all devices. If two parameters are provided, this represents the device address.\n * @param {number | undefined} val - The brightness value as a percentage (0-100).\n * @returns {object} The context object for method chaining.\n */\nfunction brightness(addr, val) {\n    // Access or simulate access to a global or contextual object that manages the LED devices\n    let controller = this.ledController;\n\n    if (typeof val === \"undefined\") {\n        // One parameter case: Set all devices to the percentage as brightness\n        val = addr;\n        controller.setAllBrightness(scaleBrightness(val));\n    } else {\n        // Two parameter case: Set a specific device's brightness\n        controller.setDeviceBrightness(addr, scaleBrightness(val));\n    }\n    \n    // Function to scale the brightness from a percentage (0-100) to the LED controller's scale (0-15)\n    function scaleBrightness(percent) {\n        return Math.round((percent / 100) * 15);\n    }\n    \n    return this; // Enables method chaining by returning the context object\n}\n\n// Assuming the context object and functions setAllBrightness and setDeviceBrightness are correctly set in the actual implementation environment.", "CodeBleu_score": 37.4743733987099}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "function device(addr) {\n    // The object that will store the methods with bound address\n    let boundMethods = {};\n\n    // Combining the properties from LedControl prototype and this object's own properties\n    let properties = Object.getOwnPropertyNames(Object.getPrototypeOf(LedControl)).concat(Object.getOwnPropertyNames(this));\n\n    // Iterate through each property and bind it to the address if it's a function\n    properties.forEach(property => {\n        let value = this[property] ?? LedControl.prototype[property];\n        if (typeof value === 'function') {\n            boundMethods[property] = value.bind(this, addr);\n        }\n    });\n\n    return boundMethods;\n}", "CodeBleu_score": 36.17643801605204}, {"code": "function device(addr) {\n  // The \"device\" function uses the \"LedControl\" prototype and own properties to generate a new object\n  let deviceObject = {};\n\n  // Iterate over the prototype properties of LedControl\n  for (let key in LedControl.prototype) {\n    if (typeof LedControl.prototype[key] === 'function') {\n      // Bind each function to the given address\n      deviceObject[key] = LedControl.prototype[key].bind(deviceObject, addr);\n    }\n  }\n\n  // Iterate over the own properties of this object\n  for (let key in this) {\n    if (this.hasOwnProperty(key) && typeof this[key] === 'function') {\n      // Bind each function to the address\n      deviceObject[key] = this[key].bind(deviceObject, addr);\n    }\n  }\n\n  // Return the object with methods bound to the specific address\n  return deviceObject;\n}", "CodeBleu_score": 44.76301092017284}, {"code": "function device(addr) {\n    let deviceObject = {};\n    \n    // Binding methods from LedControl's prototype\n    let proto = LedControl.prototype;\n    for (let key of Object.getOwnPropertyNames(proto)) {\n        let method = proto[key];\n        if (typeof method === 'function') {\n            deviceObject[key] = method.bind({address: addr});\n        }\n    }\n\n    // Binding methods from the current object's own properties\n    for (let key of Object.keys(this)) {\n        let ownMethod = this[key];\n        if (typeof ownMethod === 'function') {\n            deviceObject[key] = ownMethod.bind({address: addr});\n        }\n    }\n\n    return deviceObject;\n}", "CodeBleu_score": 31.78838808922594}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "/**\n * The function \"installCallbackReconciliation\" adds callback reconciliation methods to a target object for a given list of methods.\n * For each specified method, it creates a function that schedules the method to be called on each element in the collection,\n * with a specified duration and callback.\n * If the duration is not provided, it defaults to 1000 milliseconds.\n * It ensures the callback is a function, collects promises for each method call, and invokes the callback once all promises are resolved.\n */\nCollection.installCallbackReconciliation = (target, methods) => {\n    methods.forEach(method => {\n        target[method] = (collection, duration = 1000, callback) => {\n            // Validate that callback is a function\n            if (typeof callback !== \"function\") {\n                throw new Error(\"Callback must be a function\");\n            }\n\n            // Collect promises for each method call\n            let promises = collection.map(item => {\n                return new Promise((resolve) => {\n                    setTimeout(() => {\n                        resolve(item[method]());\n                    }, duration);\n                });\n            });\n\n            // Once all promises are resolved, call the callback\n            Promise.all(promises)\n                .then(results => {\n                    callback(results);\n                })\n                .catch(error => {\n                    console.error('Error when executing method calls:', error);\n                });\n        };\n    });\n};", "CodeBleu_score": 31.972889499819857}, {"code": "/**\n * The function \"installCallbackReconciliation\" adds callback reconciliation methods to a target object for a given list of methods.\n * For each specified method, it creates a function that schedules the method to be called on each element in the collection,\n * with a specified duration and callback.\n * If the duration is not provided, it defaults to 1000 milliseconds.\n * It ensures the callback is a function, collects promises for each method call, and invokes the callback once all promises are resolved.\n */\n\nCollection.installCallbackReconciliation = (target, methods) =>  {\n    methods.forEach(method => {\n        // Creating a new method based on the original method name that accepts duration and callback\n        target[method + 'WithCallback'] = (duration = 1000, callback) => {\n            if (typeof callback !== 'function') {\n                throw new Error('Callback must be a function');\n            }\n\n            // Collecting promises to resolve the method calls on all elements in the collection\n            const promises = target.map(item => {\n                return new Promise(resolve => {\n                    setTimeout(() => {\n                        resolve(item[method]());\n                    }, duration);\n                });\n            });\n\n            // Once all promises are resolved, execute the callback with the results\n            Promise.all(promises)\n                .then(results => callback(results))\n                .catch(error => console.error('Error executing methods with callback:', error));\n        };\n    });\n};", "CodeBleu_score": 30.60987328779772}, {"code": "// Defining the installCallbackReconciliation function\nCollection.installCallbackReconciliation = (target, methods) => {\n    methods.forEach(method => {\n        // Original method backup\n        const originalMethod = target[method];\n\n        // Check if the original method exists and is a function\n        if (typeof originalMethod !== 'function') {\n            throw new Error(`Method ${method} is not available on the target`);\n        }\n\n        // Enhanced method with callback reconciliation\n        target[method] = (collection, duration = 1000, callback) => {\n            // Ensure callback is a function\n            if (typeof callback !== 'function') {\n                throw new Error('Callback must be a function');\n            }\n\n            // Collect all promises from method calls on the elements of the collection\n            const promises = collection.map(item => {\n                // Schedule each method call on the items of the collection with a delay\n                return new Promise(resolve => {\n                    setTimeout(() => {\n                        resolve(originalMethod.call(item));\n                    }, duration);\n                });\n            });\n\n            // Wait for all promises to resolve, then call the callback\n            Promise.all(promises).then(results => {\n                callback(results);\n            });\n        };\n    });\n};", "CodeBleu_score": 33.416359880217584}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "bash\npip install pyserial", "CodeBleu_score": 3.517202294020337e-09}, {"code": "import serial\n\ndef parseNmeaSentence(sentence):\n    # Placeholder function for parsing the NMEA sentence.\n    # This function should be defined to handle specific parsing.\n    print(f\"Parsing sentence: {sentence}\")\n\ndef listen():\n    # Open the serial port\n    # Replace '/dev/ttyUSB0' with your serial port and configure baudrate accordingly.\n    ser = serial.Serial('/dev/ttyUSB0', baudrate=4800, timeout=1)\n\n    incomplete_sentence = \"\"\n\n    try:\n        while True:\n            # Read data from the serial port\n            data = ser.read(ser.inWaiting()).decode('utf-8')\n            \n            if data:\n                # Append new data to any incomplete sentence from the last read\n                input_string = incomplete_sentence + data\n                \n                # Split the input string into sentences using '\\r\\n'\n                sentences = input_string.split('\\r\\n')\n                \n                # The last element might be incomplete if data doesn't end with '\\r\\n'\n                incomplete_sentence = sentences[-1] if not input_string.endswith('\\r\\n') else \"\"\n                \n                # Process each complete sentence\n                for sentence in sentences[:-1]:\n                    parseNmeaSentence(sentence)\n    except KeyboardInterrupt:\n        print(\"Stopping serial port listening due to user interrupt.\")\n\n    # Close the serial port\n    ser.close()", "CodeBleu_score": 29.878070818545144}, {"code": "import serial\n\ndef parseNmeaSentence(sentence):\n    # Placeholder for sentence parsing logic\n    print(f\"Parsing: {sentence}\")\n\ndef listen():\n    # Configure the serial port\n    ser = serial.Serial('/dev/ttyUSB0', 4800, timeout=1)  # Adjust the port name and baud rate as needed\n\n    buffer = ''  # This will hold incoming data and leftover incomplete sentences\n\n    try:\n        while True:\n            # Read data from the serial port\n            data = ser.read(ser.in_waiting or 1)  # Read all available data or wait for at least one byte\n            if data:\n                # Decode to UTF-8 and append to the buffer\n                buffer += data.decode('utf-8')\n                \n                # Split the buffer by newline characters (assuming \\r\\n as the delimiter)\n                parts = buffer.split('\\r\\n')\n                \n                # Process all parts except the last, as we can't be sure the last part is complete\n                for part in parts[:-1]:\n                    parseNmeaSentence(part)\n\n                # Use the last part as the new buffer (it might be an incomplete sentence)\n                buffer = parts[-1]\n                \n    except KeyboardInterrupt:\n        print(\"Stopped listening\")\n    finally:\n        # Ensure the serial port is properly closed\n        ser.close()\n\n# You might need to adjust certain parts of this code depending on the actual hardware setup and requirements.", "CodeBleu_score": 29.176055573043836}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "#include <stdbool.h>\n\n#define ERROR_INSUFFICIENT_MEMORY -1\n#define SUCCESS 0\n\n/*\n * Ad-hoc structure definitions, illustrating a hypothetical device interface.\n */\nstruct device {\n    int channel_mask;  // Bitmask where each bit represents an active/inactive channel\n};\n\nstruct adc_sequence {\n    int buffer_size; // Size of the buffer in bytes\n    int resolution;  // Resolution of ADC in bits\n};\n\nstatic int count_active_channels(int channel_mask) {\n    int count = 0;\n    while (channel_mask != 0) {\n        if (channel_mask & 1) {\n            count++;\n        }\n        channel_mask >>= 1;\n    }\n    return count;\n}\n\nstatic int adc_ad559x_calculate_sample_size(int resolution) {\n    return (resolution + 7) / 8;\n}\n\nstatic int adc_ad559x_validate_buffer_size(const struct device *dev,\n                                           const struct adc_sequence *sequence) {\n    int active_channels = count_active_channels(dev->channel_mask);\n    int sample_size = adc_ad559x_calculate_sample_size(sequence->resolution);\n    int required_buffer_size = active_channels * sample_size;\n\n    if (sequence->buffer_size >= required_buffer_size) {\n        return SUCCESS;\n    } else {\n        return ERROR_INSUFFICIENT_MEMORY;\n    }\n}\n\n/*\n * Example Usage:\n * struct device adc_device = { .channel_mask = 0x0F };  // 4 active channels (bits 0-3)\n * struct adc_sequence sequence = { .buffer_size = 16, .resolution = 12 };\n * int status = adc_ad559x_validate_buffer_size(&adc_device, &sequence);\n */", "CodeBleu_score": 32.65439398676098}, {"code": "#include <stdint.h> // for data type definitions\n\n#define ADC_MAX_CHANNELS 8\n\nstruct adc_sequence {\n    uint32_t channels; // Bitmask of enabled channels\n    size_t buffer_size; // Size of the provided buffer in bytes\n    uint8_t sample_size; // Size of each sample in bytes\n};\n\nstruct device {\n    // Device-specific context (not used in this function, included for completeness)\n    void *context;\n};\n\n/* Calculate the number of active channels based on the channel bitmask */\nstatic int adc_ad559x_get_active_channels_count(uint32_t channel_mask) {\n    int count = 0;\n    for (int i = 0; i < ADC_MAX_CHANNELS; ++i) {\n        if (channel_mask & (1 << i)) {\n            ++count;\n        }\n    }\n    return count;\n}\n\n/* Validate the buffer size for an ADC sequence */\nstatic int adc_ad559x_validate_buffer_size(const struct device *dev,\n                                           const struct adc_sequence *sequence) {\n    int active_channels = adc_ad559x_get_active_channels_count(sequence->channels);\n    size_t required_buffer_size = active_channels * sequence->sample_size;\n\n    if (sequence->buffer_size < required_buffer_size) {\n        return -1; // Insufficient memory\n    }\n\n    return 0; // Success\n}", "CodeBleu_score": 38.69086877154369}, {"code": "#include <stddef.h>\n#include <stdint.h>\n\n/* Hypothetical constants and structures */\n#define ADC_CHANNEL_MAX 8  // Example maximum number of ADC channels\n#define ADC_SAMPLE_WIDTH_BYTES 2  // Assume each sample is 2 bytes\n\n/* Hypothetical error codes */\n#define SUCCESS 0\n#define ERROR_INSUFFICIENT_BUFFER -1\n\n/* Dummy structures definitions for illustration */\nstruct adc_sequence {\n    uint8_t resolution;        // ADC resolution in bits\n    uint32_t buffer_size;      // size of the buffer in bytes\n    uint8_t active_channels;   // bitmask of active channels\n};\n\nstruct device {\n    /* Device specific properties, not used in validation */\n};\n\n/*\n * The function \"adc_ad559x_validate_buffer_size\" validates the buffer size for an ADC sequence.\n * It calculates the number of active channels and the needed buffer size based on the number of channels and the size of each data sample.\n * If the provided buffer size is insufficient, it returns an error code indicating insufficient memory; otherwise, it returns 0 indicating success.\n */\nstatic int adc_ad559x_validate_buffer_size(const struct device *dev,\n                                           const struct adc_sequence *sequence) {\n    // Calculate number of active channels by counting bits in active_channels\n    uint8_t active_channel_count = 0;\n    uint8_t channel_mask = sequence->active_channels;\n    while (channel_mask) {\n        active_channel_count += channel_mask & 1;\n        channel_mask >>= 1;\n    }\n\n    // Determine needed buffer size\n    size_t needed_buffer_size = active_channel_count * ADC_SAMPLE_WIDTH_BYTES;\n\n    // Check if provided buffer size is sufficient\n    if (sequence->buffer_size < needed_buffer_size) {\n        return ERROR_INSUFFICIENT_BUFFER; // Buffer too small\n    }\n\n    return SUCCESS; // Buffer size is adequate\n}", "CodeBleu_score": 29.228540939942437}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#define EXPECTED_RESOLUTION 10 // example, the expected resolution\n#define MAX_CHANNELS 8\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n\nstruct device {\n    // implementation specific details\n};\n\nstruct adc_sequence {\n    uint8_t resolution;\n    uint8_t *channels;\n    size_t num_channels;\n    uint32_t buffer_size;\n    uint8_t *buffer; // buffer to store the ADC read data\n};\n\n// Helper function to check if channels are valid\nstatic bool are_channels_valid(const uint8_t *channels, size_t num_channels) {\n    for (size_t i = 0; i < num_channels; i++) {\n        if (channels[i] >= MAX_CHANNELS) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence) {\n    // Check if resolution matches\n    if (sequence->resolution != EXPECTED_RESOLUTION) {\n        printf(\"Error: Resolution mismatch\\n\");\n        return -EINVAL; // Invalid argument error\n    }\n\n    // Check if channels are valid\n    if (!are_channels_valid(sequence->channels, sequence->num_channels)) {\n        printf(\"Error: Invalid channel(s) specified\\n\");\n        return -EINVAL;\n    }\n\n    // Validate buffer size\n    if (sequence->buffer_size < sequence->num_channels * sizeof(uint32_t)) { // assuming each reading consumes 4 bytes\n        printf(\"Error: Insufficient buffer size\\n\");\n        return -EINVAL;\n    }\n\n    // If all checks are good, start the ADC read operation dummy code\n    printf(\"Starting ADC read operation\\n\");\n\n    // Mock-up simulate the read operation filling buffer with dummy adc values\n    for (uint8_t i = 0; i < sequence->num_channels; ++i) {\n        if (i * sizeof(uint32_t) < sequence->buffer_size) {\n            uint32_t simulated_value = 0xFFF & ((i+1) * 0x111); // some dummy values\n            memcpy(&(sequence->buffer[i * sizeof(uint32_t)]), &simulated_value, sizeof(uint32_t));\n            printf(\"Channel %d read value: %u\\n\", sequence->channels[i], simulated_value);\n        }\n    }\n\n    // Return success\n    return 0;\n}\n\n// Main function\nint main() {\n    // Example setup and call\n    struct device myDevice;\n\n    uint8_t channels[] = {0, 1, 2}; // Example channels to read\n    uint32_t buffer[3];\n    struct adc_sequence seq = {\n        .resolution = EXPECTED_RESOLUTION,\n        .channels = channels,\n        .num_channels = ARRAY_SIZE(channels),\n        .buffer_size = sizeof(buffer),\n        .buffer = (uint8_t*)buffer\n    };\n\n    int result = adc_ad559x_start_read(&myDevice, &seq);\n    if (result == 0) {\n        printf(\"ADC read operation completed successfully.\\n\");\n    }\n\n    return result;\n}", "CodeBleu_score": 33.45502643195104}, {"code": "#include <stdio.h>\n#include <errno.h>\n#include <stdbool.h>\n\n// Fake definitions for demonstration purposes\n#define EXPECTED_RESOLUTION 12 // Example: 12-bit resolution\n#define VALID_CHANNELS 0x0FFF  // Example bitmask where channels 0-11 are valid\n#define BUFFER_SIZE_REQUIRED(num_channels) (num_channels * sizeof(int))\n\n// Mock structures for example purposes\nstruct device {\n    void *internal;\n    // Additional device-specific fields\n};\n\nstruct adc_sequence {\n    int resolution;\n    unsigned long channel_mask;\n    int *buffer;\n    size_t buffer_size;\n};\n\n// Function prototypes for assumed used internal functions\nstatic void log_error(const char *error_message);\nstatic bool start_adc_read_context(const struct device *dev, const struct adc_sequence *sequence);\n\n// The actual function implementation\nstatic int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence) {\n    // Check if the resolution matches the expected resolution\n    if (sequence->resolution != EXPECTED_RESOLUTION) {\n        log_error(\"Resolution mismatch error\");\n        return -EINVAL; // EINVAL is typically used for invalid argument errors\n    }\n\n    // Check if the specified channels are valid\n    if ((sequence->channel_mask & ~VALID_CHANNELS) != 0) {\n        log_error(\"Invalid channel error\");\n        return -EINVAL;\n    }\n\n    // Calculate number of channels from the channel mask\n    int num_channels = 0;\n    for (int i = 0; i < 32; i++) {\n        if (sequence->channel_mask & (1 << i)) {\n            num_channels++;\n        }\n    }\n\n    // Validate the buffer size\n    if (sequence->buffer_size < BUFFER_SIZE_REQUIRED(num_channels)) {\n        log_error(\"Insufficient buffer size\");\n        return -ENOMEM;\n    }\n\n    // Set up the buffer and start the ADC read context\n    if (!start_adc_read_context(dev, sequence)) {\n        log_error(\"Failed to start ADC read context\");\n        return -EIO;\n    }\n\n    // Simulating a wait for the read operation to complete (this would typically involve an ISR or a semaphore in actual code)\n    printf(\"ADC read operation completed.\\n\");\n\n    return 0; // Return success (0)\n}\n\n// Mock function definitions\nstatic void log_error(const char *error_message) {\n    printf(\"Error: %s\\n\", error_message);\n}\n\nstatic bool start_adc_read_context(const struct device *dev, const struct adc_sequence *sequence) {\n    printf(\"Starting ADC read context...\\n\");\n    // Assuming operation starts successfully\n    return true;\n}", "CodeBleu_score": 43.258006442473686}, {"code": "#include <stdio.h>\n#include <stdbool.h>\n#include <errno.h>\n\n// Mock definitions to represent device and sequence structure.\ntypedef struct {\n    // Device specific fields (mocked)\n} const struct device;\n\ntypedef struct {\n    int resolution;     // In bits\n    unsigned int channels;    // Channel mask\n    int buffer_size;    // Size of the buffer for read data\n    int *buffer;        // Pointer to data buffer\n} const struct adc_sequence;\n\n// Error codes\n#define EINVAL -1   // Invalid argument\n#define EIO -2      // Input/output error\n#define SUCCESS 0   // Success\n\n// Function declarations\nbool validate_resolution(int resolution);\nbool validate_channels(unsigned int channels);\nbool validate_buffer_size(int buffer_size);\n\nstatic int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence) {\n    // Check resolution\n    if (!validate_resolution(sequence->resolution)) {\n        printf(\"Error: Invalid resolution.\\n\");\n        return EINVAL;\n    }\n\n    // Check channels\n    if (!validate_channels(sequence->channels)) {\n        printf(\"Error: Invalid channel selection.\\n\");\n        return EINVAL;\n    }\n\n    // Check buffer size\n    if (!validate_buffer_size(sequence->buffer_size)) {\n        printf(\"Error: Insufficient buffer size.\\n\");\n        return EINVAL;\n    }\n\n    // Mocked function to simulate ADC operation\n    int result = perform_adc_read(dev, sequence);\n    if (result != SUCCESS) {\n        printf(\"Error: ADC read operation failed.\\n\");\n        return EIO;\n    }\n\n    // Supposed waiting mechanism and read completion is successful\n    printf(\"ADC read operation completed successfully.\\n\");\n    return SUCCESS;\n}\n\n// Mock functions for validation and ADC read\nbool validate_resolution(int resolution) {\n    return (resolution == 12);  // Assume valid resolution is 12 bits\n}\n\nbool validate_channels(unsigned int channels) {\n    return (channels <= 0xFF);  // Assume valid channels range from 0x01 to 0xFF\n}\n\nbool validate_buffer_size(int buffer_size) {\n    return (buffer_size >= 256);  // Assume a minimum buffer size\n}\n\nint perform_adc_read(const struct device *dev, const struct adc_sequence *sequence) {\n    // Simulation of an ADC read operation, mocked.\n    return SUCCESS;  // Assume operation always succeeds in this mock\n}\n\n// Example of using the adc_ad559x_start_read function\nint main() {\n    const struct device device;\n    struct adc_sequence sequence = {12, 0x1F, 256, NULL};\n\n    int result = adc_ad559x_start_read(&device, &sequence);\n    if (result == SUCCESS) {\n        printf(\"Read operation initiated successfully.\\n\");\n    }\n\n    return 0;\n}", "CodeBleu_score": 39.22852723115609}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "#include <semaphore.h>\n#include <string.h>\n\nstruct adc_data {\n    // Add members as required (e.g., channel_number, sampling_rate, buffer, etc.)\n    int* buffer; \n    int n_channels;\n};\n\nstruct adc_context {\n    struct adc_data data;\n    semaphore_t semaphore;\n};\n\nstatic void adc_context_start_sampling(struct adc_context *ctx) {\n    if (ctx == NULL) {\n        return; // Optionally, handle error as required\n    }\n\n    // Retrieve the ADC data structure from the context\n    struct adc_data *adc = &ctx->data;\n\n    // Assuming 'buffer' needs to be initialized or reset before sampling\n    memset(adc->buffer, 0, sizeof(int) * adc->n_channels);\n\n    // Set the channel configuration and initiate sampling hardware (These functions are assumed to exist)\n    adc_configure_channels(adc->n_channels);\n    adc_initiate_sampling();\n    \n    // Signal the semaphore to indicate that sampling has started\n    semaphore_release(&ctx->semaphore);\n}\n\n// Mock-up additional necessary functions; these need real implementations:\nvoid adc_configure_channels(int n_channels) {\n    // Platform/hardware specific ADC channel configuration code here\n}\n\nvoid adc_initiate_sampling() {\n    // Platform/hardware specific code to start the ADC sampling here\n}\n\nvoid semaphore_release(semaphore_t *sem) {\n    // Release the semaphore\n    sem_post(sem);\n}", "CodeBleu_score": 35.85360476477}, {"code": "#include <semaphore.h>  // Include semaphore library if needed\n\nstatic void adc_context_start_sampling(struct adc_context *ctx) {\n    if (ctx == NULL) {\n        return; // Handle null pointer if the context is not properly passed\n    }\n\n    if (!ctx->initialized) {\n        // Optionally handle the case where the context hasn't been initialized\n        // This part depends on if there's some kind of init function for ctx\n        return;\n    }\n\n    // Assuming adc_data is a structure within ctx that requires configuration\n    struct adc_data *adc = &ctx->adc_data;\n\n    // Set the channels to be sampled, usually done in the ADC initialization\n    // This is hardware and ADC dependent and typically set up in ADC configuration\n    adc_configure_channels(adc);\n\n    // Initialize repeat buffer with the data buffer\n    // Assume adc_data has a member repeat_buffer (a buffer which might store ADC results)\n    if (adc->repeat_buffer && adc->data_buffer) {\n        memcpy(adc->repeat_buffer, adc->data_buffer, adc->buffer_size);\n    }\n\n    // Release semaphore to signal the start of sampling\n    // Assume there is a semaphore part of the adc_context structure\n    if (ctx->semaphore) {\n        sem_post(ctx->semaphore);\n    }\n\n    // Start ADC sampling, assuming a hardware-specific function is called here\n    adc_start_conversion(adc);\n}", "CodeBleu_score": 33.524131821370375}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx) {\n    if (!ctx) {\n        // Log or handle NULL context error if appropriate\n        return;\n    }\n\n    // Step 1: Retrieve the ADC data structure from the context\n    struct adc_data *adcData = ctx->adc_data;\n\n    if (!adcData) {\n        // Log or handle NULL adc_data error if appropriate\n        return;\n    }\n\n    // Step 2: Set the channels to be sampled\n    // Assuming adcData has a 'channels' field that should be set according to some desired configuration\n    adcData->channels = ctx->config.channel_config;\n\n    // Step 3: Initialize the repeat buffer with the data buffer\n    // This could include copying the initial data values into the buffer, or configuring buffer pointers\n    // Assuming 'buffer' to be the destination and 'repeat_buffer' as the source\n    // You could also have a 'buffer_size' field in your context or adcData\n    memcpy(adcData->repeat_buffer, adcData->buffer, ctx->buffer_size);\n\n    // Step 4: Release a semaphore to signal the start of sampling\n    // The actual implementation depends on the OS or platform you are using, e.g., POSIX semaphores, FreeRTOS semaphores, etc.\n    // Here, just using a generic function name `release_semaphore` which should be defined according to your semaphore handling implementation\n    release_semaphore(&(ctx->sampling_semaphore));\n\n    // Optional: You could log or do further handling if required\n    // printf(\"ADC sampling started for channels mask: %u\\n\", adcData->channels);\n}", "CodeBleu_score": 39.564138042799065}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "struct adc_data {\n    uint8_t *buffer;  // Pointer to the current data buffer\n};\n\nstruct adc_context {\n    struct adc_data *data;  // ADC data\n    uint8_t *repeat_buffer; // Pointer to the buffer used for repeated sampling\n};", "CodeBleu_score": 9.754833335645129}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling) {\n    // Check if the 'ctx' pointer is not NULL\n    if (ctx == NULL) {\n        return; // Optionally, handle the error as appropriate\n    }\n    \n    // If repeat sampling is enabled, update the buffer pointer to point to the repeat buffer.\n    if (repeat_sampling) {\n        ctx->buffer_pointer = ctx->repeat_buffer; // Assuming 'repeat_buffer' is a member of ctx\n    } else {\n        // If repeat sampling is not enabled, restore the original buffer pointer\n        // This assumes that there is a way to restore the original buffer. You might need a different handling here.\n        ctx->buffer_pointer = ctx->original_buffer; // Assuming 'original_buffer' is a member of ctx\n    }\n}", "CodeBleu_score": 47.423109400117454}, {"code": "#include <stdbool.h>\n#include <stddef.h>  // for NULL definition\n\nstruct adc_context {\n    void *current_buffer;       // Current buffer pointer\n    void *repeat_buffer;        // Buffer to use when repeat sampling is enabled\n};\n\n/**\n * Updates the buffer pointer in the ADC context.\n * If repeat sampling is enabled, sets the buffer pointer to the repeat buffer.\n * \n * @param ctx A pointer to the adc_context structure.\n * @param repeat_sampling A boolean value indicating whether repeat sampling is enabled.\n */\nstatic void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling) {\n    // Ensure the context pointer is not NULL to prevent dereferencing a NULL pointer.\n    if (ctx == NULL) {\n        // Logging or error handling could be implemented here if required.\n        return;\n    }\n\n    // Check if repeat sampling is enabled\n    if (repeat_sampling) {\n        // Check if the repeat buffer is available.\n        if (ctx->repeat_buffer != NULL) {\n            // Set the current buffer to the repeat buffer.\n            ctx->current_buffer = ctx->repeat_buffer;\n        } else {\n            // Handle the case where repeat_buffer is not set but should be available.\n            // Logging or error handling could be added here.\n        }\n    } else {\n        // Code to handle what should happen when repeat_sampling is not enabled,\n        // if any adjustments on ctx->current_buffer are needed.\n        // This part is dependent on further requirements or context.\n    }\n}", "CodeBleu_score": 47.29914169882169}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "#include <stdio.h>\n#include <stdbool.h>\n#include <semaphore.h>\n\nstruct adc_ad559x_data {\n    int *buffer;              // Buffer to store ADC data\n    int num_channels;         // Number of active channels\n    bool *active_channels;    // Array indicating active channels\n    sem_t *semaphore;         // Semaphore for syncing acquisition\n    bool acquisition_complete; // Flag to indicate completion of acquisition process\n    int (*read_adc)(int channel); // Function pointer for reading ADC value per channel\n};\n\n// Mock function to simulate ADC read, can return -1 to indicate failure\nint read_adc_channel(int channel) {\n    // Dummy implementation, replace this with actual ADC read code for your hardware\n    return (channel * 10) + (rand() % 10);  // Simulated varying results\n}\n\nstatic void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data) {\n    sem_wait(data->semaphore);  // Wait for semaphore\n\n    for (int i = 0; i < data->num_channels; i++) {\n        if (data->active_channels[i]) {\n            int adc_value = data->read_adc(i);\n            if (adc_value == -1) {\n                fprintf(stderr, \"Error reading ADC channel %d\\n\", i);\n                data->acquisition_complete = true;\n                break;  // Exit on failure\n            }\n            data->buffer[i] = adc_value;\n        }\n    }\n\n    data->acquisition_complete = true;  // Mark acquisition as complete\n    sem_post(data->semaphore);          // Signal completion\n}\n\nint main() {\n    int buffer[8];\n    bool active_channels[8] = {true, true, true, true, false, false, true, true};\n    sem_t semaphore;\n    sem_init(&semaphore, 0, 1);\n\n    struct adc_ad559x_data data = {\n        .buffer = buffer,\n        .num_channels = 8,\n        .active_channels = active_channels,\n        .semaphore = &semaphore,\n        .acquisition_complete = false,\n        .read_adc = read_adc_channel\n    };\n\n    adc_ad559x_acquisition_thread(&data);\n\n    // Optionally display the results\n    for (int i = 0; i < data.num_channels; i++) {\n        if (data.active_channels[i])\n            printf(\"Channel %d: %d\\n\", i, data.buffer[i]);\n    }\n\n    sem_destroy(&semaphore);\n\n    return 0;\n}", "CodeBleu_score": 27.39449212980532}, {"code": "#include <stdio.h>\n#include <stdbool.h>\n#include <semaphore.h>\n#include <pthread.h>\n\n// Presumed structure for holding adc data\nstruct adc_ad559x_data {\n    int num_channels;\n    int *active_channels;\n    int *results_buffer;\n    bool acquisition_complete;\n    sem_t semaphore;\n};\n\n// Presumed prototype of an adc reading function\nint read_adc_channel(int channel, int *value);\n\nstatic void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data) {\n    if (data == NULL) return;\n\n    // Continue acquiring data in a loop\n    while (true) {\n        // Wait for the semaphore to be released\n        sem_wait(&data->semaphore);\n\n        // Iterate through the list of active channels\n        for (int i = 0; i < data->num_channels; ++i) {\n            int channel = data->active_channels[i];\n            int read_value = 0;\n\n            // Read ADC value\n            if (read_adc_channel(channel, &read_value) == 0) {\n                // Store the result\n                data->results_buffer[i] = read_value;\n            } else {\n                // Log an error if reading fails\n                printf(\"Error reading from channel %d\\n\", channel);\n                data->acquisition_complete = true; // Mark context as complete on error\n                break;\n            }\n        }\n\n        // Mark acquisition as complete (if all goes well)\n        data->acquisition_complete = true;\n\n        // Signal that sampling is done for this cycle\n        sem_post(&data->semaphore);\n        \n        // Break loop if acquisition is marked complete due to error\n        if(data->acquisition_complete) {\n            break;\n        }\n    }\n}\n\n// This is where thread function might be invoked (in actual application setup)\nint main() {\n    struct adc_ad559x_data adc_data;\n    // Initialization of adc_data and semaphores, setting up thread, etc., would be done here\n    \n    return 0;\n}", "CodeBleu_score": 30.638749516117286}, {"code": "#include <semaphore.h>  // Include semaphore functions for synchronization\n#include <stdbool.h>    // Include for boolean definitions\n#include <pthread.h>    // Include for threading\n#include <stdio.h>      // Include for logging (printf)\n\n// Function prototype for reading from the ADC channel\nbool read_adc_channel(int channel, int *result);\n\nstatic void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data) {\n    if (data == NULL) {\n        return;\n    }\n\n    while (1) {\n        // Wait for semaphore to be released signaling data is ready to acquire\n        sem_wait(&data->sem);\n\n        // Iterate through each active channel\n        for (int i = 0; i < data->num_of_channels; i++) {\n            int channel = data->active_channels[i];\n            int adc_result;\n\n            // read ADC value for the current channel\n            if (!read_adc_channel(channel, &adc_result)) {\n                printf(\"Error reading from ADC channel %d\\n\", channel);\n                data->is_complete = true;  // Mark the ADC context as complete if read fails\n                break;\n            }\n\n            // Store the result in the respective buffer slot\n            data->buffer[channel] = adc_result;\n        }\n\n        // Signal that ADC sampling is done for now\n        sem_post(&data->sample_done_sem);\n        \n        // Check if thread termination has been requested\n        if (data->shutdown) {\n            break;\n        }\n    }\n}\n\n// Assuming the 'read_adc_channel' is an already defined function for actual ADC hardware read\nbool read_adc_channel(int channel, int *result) {\n    // Placeholder function for reading the ADC\n    // In practical implementation, this should interface with actual ADC hardware\n    // Return true if read was successful, false if failed\n    // This is a placeholder implementation just for compile-ability\n    *result = 0;  // Dummy value, need to replace with actual ADC hardware interaction\n    return true;  // Assume it to be successful\n}", "CodeBleu_score": 29.740885004522806}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "#include <unistd.h>    // May require adjusting based on specific hardware libraries for delaying\n\nstatic const int READY_TIME_MICROSECONDS = 1000;  // Initial ready time\nstatic const int POLLING_INTERVAL_MICROSECONDS = 100;  // Interval between status checks\n\n/*\n * The function \"ads1112_wait_data_ready\" waits for the ADS1112 device to be ready for data reading.\n * It puts the current thread to sleep for the device's specified ready time, then reads the configuration \n * register to check the status. If the device is not ready, it repeatedly sleeps for 100 microseconds \n * and checks the status again until the device is ready. If an error occurs during register reading, \n * it returns the error code; otherwise, it returns 0 when the device is ready.\n */\nstatic int ads1112_wait_data_ready(const struct device *dev) {\n    // Waiting for the device ready time\n    usleep(READY_TIME_MICROSECONDS);\n\n    int status;\n    int error;\n\n    do {\n        // Read the configuration or status register\n        error = read_device_register(dev, &status);\n        if (error != 0) {\n            return error;  // Return error if read failed\n        }\n\n        // Check if the device status indicates ready\n        if (status & ADS1112_STATUS_READY_MASK) {\n            return 0;  // Device is ready\n        }\n\n        // Sleep a bit before polling the status again\n        usleep(POLLING_INTERVAL_MICROSECONDS);\n    } while (!(status & ADS1112_STATUS_READY_MASK));  // Continue until device is ready\n\n    return 0;  // Success\n}", "CodeBleu_score": 29.90491268644395}, {"code": "#include <unistd.h>  // for usleep\n\n// Simulation of the configuration register bit that indicates readiness\n#define CONFIG_REG_READY_BIT 0x01\n\n// Mock function to read from the ADS1112 configuration register\n// Normally, you would communicate over I2C or SPI to retrieve this data.\nstatic int read_config_register(const struct device *dev, int *config_reg) {\n    *config_reg = *config_reg | CONFIG_REG_READY_BIT; // Simulate device is ready\n    return 0;  // return 0 to indicate success\n}\n\nstatic int ads1112_wait_data_ready(const struct device *dev) {\n    const int ready_time = 100000; // ready time in microseconds\n    const int check_interval = 100; // check interval in microseconds\n    int config_reg = 0;\n    int error;\n\n    // Initial wait for the device specific ready time\n    usleep(ready_time);\n\n    while (1) {\n        // Read the configuration register to check the device's status\n        error = read_config_register(dev, &config_reg);\n        if (error != 0) {\n            return error;  // Return error code if read failed\n        }\n\n        // Check if the ready bit is set in the configuration register\n        if (config_reg & CONFIG_REG_READY_BIT) {\n            return 0;  // Device is ready, return 0\n        }\n\n        // Wait 100 microseconds before checking again\n        usleep(check_interval);\n    }\n}", "CodeBleu_score": 38.625981401967614}, {"code": "#include <unistd.h>\n#include <stdint.h>\n#include <errno.h>\n\n#define ADS1112_REG_CONFIG   0x01  /* Example config register address */\n#define CONVERSION_READY_BIT 0x80  /* Example bit to check conversion status */\n\n// Simulated external function that read from a device register. Normally provided by the hardware abstraction layer.\nextern int read_register(const struct device *dev, uint8_t reg, uint8_t *value);\n\n// Simulated external function that encapsulates an accurate sleep mechanism\nextern void usleep(uint32_t micro_seconds);\n\nstatic int ads1112_wait_data_ready(const struct device *dev) {\n    if (dev == NULL) {\n        return -EINVAL;\n    }\n\n    const uint32_t ready_wait_time = 8000;  // Device ready time, specific to ADS1112\n    const uint32_t retry_delay_us = 100;    // Delay time in microseconds\n\n    // Wait initial ready time\n    usleep(ready_wait_time);\n\n    uint8_t config_value = 0;\n    int error_code = 0;\n    \n    // Read the config register to check if data is ready\n    error_code = read_register(dev, ADS1112_REG_CONFIG, &config_value);\n    if (error_code) {  // Handle error from read_register\n        return error_code;\n    }\n    \n    // Check if the conversion is ready\n    while (!(config_value & CONVERSION_READY_BIT)) {\n        // Sleep for a short duration before checking again\n        usleep(retry_delay_us);\n\n        // Read the config register again\n        error_code = read_register(dev, ADS1112_REG_CONFIG, &config_value);\n        if (error_code) {  // Handle error from read_register\n            return error_code;\n        }\n    }\n\n    // Successfully confirmed the data readiness\n    return 0;\n}", "CodeBleu_score": 45.21693448104441}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "#include <stdio.h>\n\n// Assume a definition for struct adc_sequence that includes at least num_samples and buffer_size.\nstruct adc_sequence {\n    int num_samples;\n    int buffer_size;\n};\n\n// Simple logging utility function\nvoid adc_log_error(const char *message) {\n    printf(\"Error: %s\\n\", message);\n}\n\nstatic int ads1112_validate_buffer_size(const struct adc_sequence *sequence) {\n    // Assume that each sample requires one unit of buffer space. Multiply num_samples by this unit.\n    int required_buffer_size = sequence->num_samples;\n\n    // Check if the provided buffer_size is less than the required buffer size\n    if (sequence->buffer_size < required_buffer_size) {\n        // Log error\n        adc_log_error(\"Insufficient buffer size for the requested number of samples.\");\n        \n        // Return an error code (typically, negative values are used for errors)\n        return -1;\n    }\n\n    // If buffer size is adequate, return 0 indicating success.\n    return 0;\n}\n\n// Example usage of the function\nint main() {\n    struct adc_sequence sequence = {10, 8}; // 10 samples needed, but buffer size is 8\n    int result = ads1112_validate_buffer_size(&sequence);\n    if (result == 0) {\n        printf(\"Buffer size is sufficient.\\n\");\n    }\n    return result;\n}", "CodeBleu_score": 41.235757874063246}, {"code": "#include <stdio.h>\n\n// Assuming definition of the adc_sequence structure\ntypedef struct adc_sequence {\n    int num_samplings;         // Number of samplings\n    int extra_samplings;       // Extra samplings\n    int buffer_size;           // Size of the buffer\n} adc_sequence;\n\n// Defining error code for insufficient buffer size\n#define INSUFFICIENT_BUFFER_ERROR 1\n\nstatic int ads1112_validate_buffer_size(const struct adc_sequence *sequence) {\n    // Calculate required buffer size\n    int required_size = (sequence->num_samplings + sequence->extra_samplings) * sizeof(int); // Assuming each sample is an int\n\n    // Check if the actual buffer size is sufficient\n    if (sequence->buffer_size < required_size) {\n        // Log an error message\n        fprintf(stderr, \"Error: Buffer size is insufficient. Required size: %d, Given size: %d\\n\", required_size, sequence->buffer_size);\n        // Return non-zero error code\n        return INSUFFICIENT_BUFFER_ERROR;\n    }\n\n    // If buffer size is sufficient, return 0\n    return 0;\n}\n\n// Example usage\nint main() {\n    adc_sequence my_sequence = {\n        10,  // Number of samplings\n        2,   // Extra samplings\n        48   // Buffer size (in bytes)\n    };\n\n    // Validate buffer size\n    int result = ads1112_validate_buffer_size(&my_sequence);\n    if (result == 0) {\n        printf(\"Buffer size is sufficient.\\n\");\n    }\n    return result;\n}", "CodeBleu_score": 40.64401039641038}, {"code": "#include <stdio.h>\n\n// Assuming a predefined structure for adc_sequence and a constant representing the size of a single sample.\n#define SIZE_OF_SAMPLE 2 // Assume each sample is 2 bytes (for example, 16-bit ADC values).\n#define ERROR_CODE -1\n\n// A simplified version of the adc_sequence structure for example purposes.\nstruct adc_sequence {\n    int buffer_size; // Buffer size in bytes.\n    int resolution; // Not used directly in this function, but typically important for real implementations.\n    int oversampling; // Extra samplings for improved accuracy.\n    int num_samples; // Number of samples to be taken.\n};\n\nstatic int ads1112_validate_buffer_size(const struct adc_sequence *sequence) {\n    if (sequence == NULL) {\n        puts(\"Error: adc_sequence pointer is NULL\");\n        return ERROR_CODE;\n    }\n    \n    // Calculate required buffer size considering the number of samples and any oversampling.\n    int required_buffer_size = (sequence->num_samples + sequence->oversampling) * SIZE_OF_SAMPLE;\n    \n    // Check if the allocated buffer size meets or exceeds the required buffer size.\n    if (sequence->buffer_size < required_buffer_size) {\n        printf(\"Error: Insufficient buffer size. Required: %d, Provided: %d\\n\", required_buffer_size, sequence->buffer_size);\n        return ERROR_CODE;\n    }\n    \n    // If the buffer is sufficiently large, return 0 indicating success.\n    return 0;\n}", "CodeBleu_score": 40.21477519641964}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "#include <stdbool.h>\n\n// Mock variables to simulate device and sequence handling\n#define ADC_SUCCESS 0\n#define ADC_ERROR -1\n#define ADC_READ_OPERATION_IN_PROGRESS 1\n\nstruct adc_sequence {\n    uint8_t *buffer;\n    int length;\n};\n\nstruct device {\n    uint8_t *data;\n    bool is_busy;\n};\n\nint ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence, bool wait) {\n    // Check if the device or sequence pointers are NULL\n    if (!dev || !sequence) {\n        return ADC_ERROR;\n    }\n\n    // Check the sequence validity (e.g., non-null buffer and positive length)\n    if (!sequence->buffer || sequence->length <= 0) {\n        return ADC_ERROR;\n    }\n\n    // Simulate device busy state\n    if (dev->is_busy) {\n        return ADC_READ_OPERATION_IN_PROGRESS;\n    }\n\n    // Assign the sequence buffer to the device data (simulate)\n    ((struct device *)dev)->data = sequence->buffer;\n    ((struct device *)dev)->is_busy = true;\n\n    // Start the ADC read operation (simulate)\n    // Normally, here you would configure the ADC hardware and start the read\n    // For simulation, we update the buffer with dummy data\n    for (int i = 0; i < sequence->length; ++i) {\n        sequence->buffer[i] = (uint8_t)(i & 0xFF); // Example dummy data\n    }\n\n    // If wait is true, simulate the ADC read operation blocking till it completes\n    if (wait) {\n        while (dev->is_busy) {\n            // In an actual implementation, you would wait for an interrupt or a read-complete signal\n            // We simulate an instant read\n            ((struct device *)dev)->is_busy = false;\n        }\n        return ADC_SUCCESS; // Return success after read completion\n    }\n\n    return ADC_SUCCESS;\n}", "CodeBleu_score": 41.36940557655109}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence, bool wait) {\n    // Check if the device or sequence pointers are NULL\n    if (dev == NULL || sequence == NULL) {\n        return -EINVAL;  // Return an invalid argument error\n    }\n\n    // Check if ADC sequence is valid\n    if (sequence->channels == 0) {\n        return -EINVAL;  // No channel specified, return error\n    }\n\n    // Assign sequence buffer to device-specific data if valid\n    struct ads1112_data *data = dev->data;\n    data->buffer = sequence->buffer;\n    data->buffer_size = sequence->buffer_size;\n\n    // Start an asynchronous ADC read\n    int err = ads1112_start_adc_convert(dev);\n    if (err != 0) {\n        return err;  // Return error code if ADC start failed\n    }\n\n    if (wait) {\n        // Wait for the read operation to complete\n        err = ads1112_wait_for_conversion_complete(dev, sequence->timeout);\n        if (err != 0) {\n            return err;  // Return error if waiting failed or timeout occurred\n        }\n\n        // If waiting successful, process & store the conversion result\n        err = ads1112_process_conversion_result(dev);\n        if (err != 0) {\n            return err;  // Return error if processing result failed\n        }\n    }\n\n    return 0;  // Return success code\n}", "CodeBleu_score": 51.06735745747184}, {"code": "#include <stdbool.h> // For using the 'bool' type\n\n// Assuming these structs are predefined in the environment or SDK\nstruct device {\n    // device-specific attributes\n};\n\nstruct adc_sequence {\n    // sequence-specific attributes such as buffer, length, etc.\n};\n\n// Utility function to validate ADC sequence\nstatic bool validate_adc_sequence(const struct adc_sequence *sequence) {\n    // Mock validation logic:\n    if (sequence != NULL && sequence->buffer != NULL && sequence->length > 0) {\n        return true; // Assuming sequence is valid if conditions are met\n    } else {\n        return false;\n    }\n}\n\n// Pseudo SDK function to start ADC read (mocked)\nstatic void start_adc_read(const struct device *dev, const struct adc_sequence *sequence) {\n    // Actual starter code to begin ADC read would be here\n}\n\n// Pseudo SDK function to complete ADC read (mocked)\nstatic int complete_adc_read(const struct device *dev, const struct adc_sequence *sequence) {\n    // Actual completion status handling code would be here\n    return 0; // Assume 0 means success\n}\n\nstatic int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n                                  bool wait) {\n    // First, validate the ADC sequence\n    if (!validate_adc_sequence(sequence)) {\n        return -1; // Return an error code if sequence is not valid\n    }\n\n    // Assign sequence data to the device (mocked)\n    // Assuming a function or mechanism such as: device->data = sequence\n\n    // Start the ADC read process\n    start_adc_read(dev, sequence);\n\n    if (wait) {\n        // If wait is true, we need to ensure the read completes before returning\n        return complete_adc_read(dev, sequence);\n    }\n\n    return 0; // Assume starting read is successful\n}", "CodeBleu_score": 42.49686497430285}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "#include <stdio.h>\n#include <string.h>\n\n// Placeholder structure and functions typically provided by the SDK or hardware abstraction layer\nstruct audio_codec_device {\n    // Properties of the codec\n    int properties_applied_successfully;\n};\n\nstruct device_manager {\n    struct audio_codec_device *device;\n    int (*get_device_by_name)(const char *name, struct audio_codec_device **dev);\n    void (*apply_properties)(struct audio_codec_device *dev);\n};\n\n// Mock instance assuming it's globally accessible or retrievable somehow\nextern struct device_manager device_manager;\n\nstatic int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"ERROR: Not enough arguments. Usage: %s <device_name>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char *device_name = argv[1];\n    struct audio_codec_device *device = NULL;\n\n    // Try to retrieve the device based on the name provided in argv[1]\n    if (device_manager.get_device_by_name(device_name, &device) != 0 || device == NULL) {\n        printf(\"ERROR: Device '%s' not found.\\n\", device_name);\n        return -2; // Differentiate error types\n    }\n\n    // Apply properties to the device\n    device_manager.apply_properties(device);\n\n    // Check if properties were applied successfully based on a status flag or similar in the device structure\n    if (!device->properties_applied_successfully) {\n        printf(\"ERROR: Failed to apply properties to device '%s'.\\n\", device_name);\n        return -3;\n    }\n\n    printf(\"Properties applied successfully to device '%s'.\\n\", device_name);\n    return 0; // Success\n}\n\n// Note that the actual functions and their implementations would differ based on the SDK.", "CodeBleu_score": 39.81209079250052}, {"code": "#include <stdio.h>\n#include <shell/shell.h>\n#include <device.h>\n\n/* Assume that there exists a function that applies properties to the codec device */\nextern int codec_apply_properties(struct device *dev);\n\nstatic int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[]) {\n    // Check if the correct number of arguments are passed\n    if (argc != 2) {\n        shell_error(sh, \"Invalid number of arguments.\");\n        return -1;\n    }\n    \n    // Device name from command line arguments\n    const char *dev_name = argv[1];\n    \n    // Get device binding\n    struct device *dev = device_get_binding(dev_name);\n    if (!dev) {\n        // Logging error if device is not found\n        shell_error(sh, \"Device not found: %s\", dev_name);\n        return -2;\n    }\n\n    // Apply properties to the device\n    int result = codec_apply_properties(dev);\n    if (result != 0) {\n        // Log error if the properties could not be applied successfully\n        shell_error(sh, \"Failed to apply properties to the device: %s\", dev_name);\n        return result;\n    }\n\n    // If everything is okay, confirm the operation success\n    shell_print(sh, \"Properties applied successfully to the device: %s\", dev_name);\n    return 0;\n}", "CodeBleu_score": 50.691957867528714}, {"code": "#include <stdio.h>\n#include <string.h>\n\n// Mock structure and API functions for demonstration; should be replaced with real API in actual implementation\nstruct device {\n    const char* name;\n    int is_bound;\n};\n\n// Function to retrieve a device by name\nstruct device* device_get_binding(const char* name) {\n    static struct device codec_device = {\"AudioCodec\", 1};  // example device\n    if (strcmp(name, codec_device.name) == 0) {\n        return &codec_device;\n    }\n    return NULL;\n}\n\n// Function to apply properties to the device\nint apply_codec_properties(struct device* dev) {\n    if (!dev->is_bound) {\n        return -2;  // Error code for unbound device\n    }\n    // Simulate applying properties\n    printf(\"Applying properties to device: %s\\n\", dev->name);\n    return 0;  // success\n}\n\n// Constants for error codes\n#define ERR_DEVICE_NOT_FOUND -1\n#define SUCCESS 0\n\nstatic int cmd_apply_prop(const struct shell *sh, size_t argc, char **argv) {\n    if (argc < 2) {\n        printf(\"Usage: %s <device_name>\\n\", argv[0]);\n        return ERR_DEVICE_NOT_FOUND;\n    }\n\n    const char *device_name = argv[1];\n    struct device *dev = device_get_binding(device_name);\n\n    if (dev == NULL) {\n        printf(\"Error: Device not found\\n\");\n        return ERR_DEVICE_NOT_FOUND;\n    }\n\n    int result = apply_codec_properties(dev);\n    if (result != SUCCESS) {\n        printf(\"Error: Failed to apply properties to the device\\n\");\n        return result;\n    }\n\n    printf(\"Properties applied successfully to device %s\\n\", device_name);\n    return SUCCESS;\n}", "CodeBleu_score": 38.22240112709145}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "#include <stdio.h>\n#include <stdbool.h>\n\n// Enum for DMIC trigger commands\nenum dmic_trigger {\n    DMIC_TRIGGER_START,\n    DMIC_TRIGGER_STOP\n};\n\n// Enum for device states\nenum device_state {\n    DEVICE_CONFIGURED,\n    DEVICE_ACTIVE,\n    DEVICE_IDLE\n};\n\n// Mock definition for a device structure\nstruct device {\n    enum device_state state;\n};\n\n// Mock function for sending I2S command, returns 0 on success, non-zero on failure\nint send_i2s_command(const struct device *dev, const char *command) {\n    // Example sending command logic\n    printf(\"Sending I2S Command: %s\\n\", command);\n    return 0; // Assume success for demonstration\n}\n\nint mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd) {\n    int status;\n    const char *i2s_cmd = NULL;\n\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (dev->state == DEVICE_CONFIGURED) {\n                i2s_cmd = \"START\";\n                dev->state = DEVICE_ACTIVE;\n            } else {\n                fprintf(stderr, \"Error: Device not in correct state to start (current state: %d)\\n\", dev->state);\n                return -1; // Error code for incorrect state\n            }\n            break;\n        case DMIC_TRIGGER_STOP:\n            if (dev->state == DEVICE_ACTIVE) {\n                i2s_cmd = \"STOP\";\n                dev->state = DEVICE_IDLE;\n            } else {\n                fprintf(stderr, \"Error: Device not in correct state to stop (current state: %d)\\n\", dev->state);\n                return -1; // Error code for incorrect state\n            }\n            break;\n        default:\n            fprintf(stderr, \"Unsupported command\\n\");\n            return -2; // Error code for unsupported command\n    }\n\n    // Sending the I2S command\n    status = send_i2s_command(dev, i2s_cmd);\n    if (status != 0) {\n        fprintf(stderr, \"Error sending I2S command: %s\\n\", i2s_cmd);\n        return -3; // Error code for command failure\n    }\n\n    return 0; // Success\n}", "CodeBleu_score": 49.104429334037434}, {"code": "#include <stdio.h>\n#include <string.h>\n\n// Enum declaration to simulate DMIC trigger command types\ntypedef enum {\n    DMIC_TRIGGER_START,\n    DMIC_TRIGGER_STOP\n} dmic_trigger;\n\n// Simulated device structure with state information\ntypedef struct {\n    const char* name;\n    enum {\n        DEVICE_STATE_CONFIGURED,\n        DEVICE_STATE_ACTIVE,\n        DEVICE_STATE_STOPPED,\n        DEVICE_STATE_ERROR\n    } state;\n} device;\n\n// Function to simulate sending an I2S command\nint send_i2s_command(const device *dev, const char *command) {\n    if (strcmp(command, \"START\") == 0 || strcmp(command, \"STOP\") == 0) {\n        printf(\"I2S command '%s' sent to device '%s'\\n\", command, dev->name);\n        return 0; // Success\n    }\n    return -1; // Failure\n}\n\nint mpxxdtyy_i2s_trigger(const device *dev, dmic_trigger cmd) {\n    if (dev == NULL) {\n        return -1; // NULL device pointer\n    }\n\n    int result;\n    switch (cmd) {\n        case DMIC_TRIGGER_START:\n            if (dev->state == DEVICE_STATE_CONFIGURED) {\n                result = send_i2s_command(dev, \"START\");\n                if (result == 0) {\n                    ((device *)dev)->state = DEVICE_STATE_ACTIVE;\n                } else {\n                    printf(\"Error sending START command to device '%s'.\\n\", dev->name);\n                    ((device *)dev)->state = DEVICE_STATE_ERROR;\n                    return -1;\n                }\n            } else {\n                printf(\"Device '%s' is not in a configurable state.\\n\", dev->name);\n                return -1;\n            }\n            break;\n        case DMIC_TRIGGER_STOP:\n            if (dev->state == DEVICE_STATE_ACTIVE) {\n                result = send_i2s_command(dev, \"STOP\");\n                if (result == 0) {\n                    ((device *)dev)->state = DEVICE_STATE_STOPPED;\n                } else {\n                    printf(\"Error sending STOP command to device '%s'.\\n\", dev->name);\n                    ((device *)dev)->state = DEVICE_STATE_ERROR;\n                    return -1;\n                }\n            } else {\n                printf(\"Device '%s' is not in an active state.\\n\", dev->name);\n                return -1;\n            }\n            break;\n    }\n\n    return 0; // Success\n}\n\nint main() {\n    // Create a mock device in the CONFIGURED state ready to be started\n    device myDevice = {\"AudioDevice\", DEVICE_STATE_CONFIGURED};\n\n    int result = mpxxdtyy_i2s_trigger(&myDevice, DMIC_TRIGGER_START);\n    if (result == 0) {\n        printf(\"Device '%s' successfully started.\\n\", myDevice.name);\n    }\n\n    // Now stop the device.\n    result = mpxxdtyy_i2s_trigger(&myDevice, DMIC_TRIGGER_STOP);\n    if (result == 0) {\n        printf(\"Device '%s' successfully stopped.\\n\", myDevice.name);\n    }\n\n    return 0;\n}", "CodeBleu_score": 43.14077686810101}, {"code": "#include <stdio.h>\n#include <string.h>\n\n// Mock definitions for enums and structs for the sake of example since the real definitions are not provided.\ntypedef enum {\n    DMIC_TRIGGER_START,\n    DMIC_TRIGGER_STOP\n} dmic_trigger;\n\ntypedef struct {\n    int state;\n} device;\n\n// States\n#define STATE_CONFIGURED 1\n#define STATE_ACTIVE 2\n#define STATE_ERROR -1\n\nint send_i2s_command(const struct device *dev, const char *command);\n\n// Logger function for errors\nvoid log_error(const char *message) {\n    printf(\"Error: %s\\n\", message);\n}\n\nint mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd) {\n    if (dev == NULL) {\n        log_error(\"Invalid device pointer\");\n        return STATE_ERROR;\n    }\n\n    const char* command_str;\n    int suggested_state;\n\n    switch(cmd) {\n        case DMIC_TRIGGER_START:\n            if (dev->state != STATE_CONFIGURED) {\n                log_error(\"Device not in configured state\");\n                return STATE_ERROR;\n            }\n            command_str = \"START\";\n            suggested_state = STATE_ACTIVE;\n            break;\n\n        case DMIC_TRIGGER_STOP:\n            if (dev->state != STATE_ACTIVE) {\n                log_error(\"Device not in active state\");\n                return STATE_ERROR;\n            }\n            command_str = \"STOP\";\n            suggested_state = STATE_CONFIGURED;\n            break;\n\n        default:\n            log_error(\"Unsupported command\");\n            return STATE_ERROR;\n    }\n\n    int result = send_i2s_command(dev, command_str);\n    if (result == 0) { // Assuming 0 is success\n        // Function that updates the state of a device\n        ((struct device *)dev)->state = suggested_state;\n        printf(\"Command %s executed successfully. State changed to %d\\n\", command_str, suggested_state);\n        return 0; // Success\n    } else {\n        log_error(\"Failed to send I2S command\");\n        return result; // Error code from sending command function\n    }\n}\n\n// Dummy function for demonstrating purpose\nint send_i2s_command(const struct device *dev, const char *command) {\n    printf(\"Sending I2S command %s for the device\\n\", command);\n    return 0; // Simulate success\n}\n\n// Main function (for testing purposes)\nint main() {\n    struct device dev1 = {STATE_CONFIGURED};\n    struct device dev2 = {STATE_ACTIVE};\n\n    mpxxdtyy_i2s_trigger(&dev1, DMIC_TRIGGER_START); // Should succeed\n    mpxxdtyy_i2s_trigger(&dev2, DMIC_TRIGGER_STOP);  // Should succeed\n\n    // These should fail\n    mpxxdtyy_i2s_trigger(&dev1, DMIC_TRIGGER_STOP);\n    mpxxdtyy_i2s_trigger(&dev2, DMIC_TRIGGER_START);\n\n    return 0;\n}", "CodeBleu_score": 47.64989845871605}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define HD44780_CMD_DISPLAY_CONTROL 0x08\n#define HD44780_FLAG_DISPLAY_ON 0x04\n#define HD44780_FLAG_CURSOR_ON 0x02\n#define HD44780_FLAG_BLINK_ON 0x01\n\nstruct device {\n    bool is_cursor_visible;\n    bool is_blinkmode_enabled;\n};\n\nvoid write_command_to_device(const struct device *dev, unsigned char command) {\n    // Device-specific function to send command to HD44780\n    printf(\"Sending command 0x%02X to device\\n\", command);\n}\n\nstatic void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled) {\n    // Start by setting up the base command for display mode configuration\n    unsigned char command = HD44780_CMD_DISPLAY_CONTROL;\n   \n    // Modify command based on display enable flag\n    if (enabled) {\n        command |= HD44780_FLAG_DISPLAY_ON;\n    }\n\n    // Modify command based on cursor visibility\n    if (dev->is_cursor_visible) {\n        command |= HD44780_FLAG_CURSOR_ON;\n    }\n\n    // Modify command based on blink mode setting\n    if (dev->is_blinkmode_enabled) {\n        command |= HD44780_FLAG_BLINK_ON;\n    }\n    \n    // Send the modified command to the display\n    write_command_to_device(dev, command);\n}\n\n// Example of using the function\nint main() {\n    struct device my_display = {true, true};  // Example device that has cursor visible and blink mode enabled\n    auxdisplay_hd44780_set_display_mode(&my_display, true);  // Enable the display\n    return 0;\n}", "CodeBleu_score": 50.345114463114406}, {"code": "#include <stdbool.h>\n#include <stdint.h>\n\n#define HD44780_CMD_FUNCTION_SET 0x20\n#define HD44780_CMD_DISPLAY_CONTROL 0x08\n#define HD44780_FLAG_DISPLAY_ON 0x04\n#define HD44780_FLAG_CURSOR_ON 0x02\n#define HD44780_FLAG_BLINK_ON 0x01\n\nstruct device {\n    uint8_t display_mode;\n    bool cursor_on;\n    bool blink_on;\n};\n\n/**\n * Sends a command to the HD44780 display device.\n * @param dev Pointer to the device structure.\n * @param command The command byte to send.\n */\nstatic void hd44780_send_command(const struct device *dev, uint8_t command) {\n    // Implementation depends on the specific hardware interaction, e.g., I2C, GPIO\n    // Example: i2c_write_byte(dev->i2c_address, command);\n    // For demonstration, we'll assume a simple function:\n    printf(\"Command sent: 0x%02X\\n\", command);\n}\n\n/**\n * Configures the display mode of an HD44780 auxiliary display.\n * This function initializes the display, sets display, cursor and blink according\n * to the settings in the device struct, and then updates the display.\n * @param dev Pointer to the device structure.\n * @param enabled Flag indicating whether the display should be enabled or disabled.\n */\nstatic void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled) {\n    uint8_t command = HD44780_CMD_DISPLAY_CONTROL;\n\n    if (enabled) {\n        command |= HD44780_FLAG_DISPLAY_ON;\n    }\n\n    if (dev->cursor_on) {\n        command |= HD44780_FLAG_CURSOR_ON;\n    }\n\n    if (dev->blink_on) {\n        command |= HD44780_FLAG_BLINK_ON;\n    }\n\n    hd44780_send_command(dev, command);\n}\n\n// Usage example (assuming external initialization of a device structure)\nint main() {\n    struct device my_display = {\n        .display_mode = HD44780_CMD_DISPLAY_CONTROL,\n        .cursor_on = true,\n        .blink_on = false,\n    };\n\n    // Enable the display\n    auxdisplay_hd44780_set_display_mode(&my_display, true);\n\n    // Modify settings and update\n    my_display.cursor_on = false;\n    my_display.blink_on = true;\n    auxdisplay_hd44780_set_display_mode(&my_display, true);\n\n    return 0;\n}", "CodeBleu_score": 50.596386982855435}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled) {\n    // Define command bits for HD44780 display commands\n    const uint8_t DISPLAY_CONTROL_CMD = 0x08;\n    const uint8_t DISPLAY_ON = 0x04;\n    const uint8_t CURSOR_ON = 0x02;\n    const uint8_t BLINK_ON = 0x01;\n\n    // Start with basic display control command for HD44780\n    uint8_t command = DISPLAY_CONTROL_CMD;\n\n    // Retrieve configuration from the device\n    // Assuming the device structure has access to configuration about cursor and blink settings\n    bool cursor_enabled = dev->config->cursor_enabled;\n    bool blink_enabled = dev->config->blink_enabled;\n\n    // Modify the command based on cursor and blink settings from the device config\n    if (cursor_enabled) {\n        command |= CURSOR_ON;\n    }\n    if (blink_enabled) {\n        command |= BLINK_ON;\n    }\n\n    // If display is enabled, set the display on bit\n    if (enabled) {\n        command |= DISPLAY_ON;\n    }\n\n    // We assume here the `device_send_command` is a function to send commands to the HD44780 hardware\n    device_send_command(dev, command);\n}", "CodeBleu_score": 47.36737493085402}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "#include <errno.h>\n\n// Assuming there exists a structure 'itron_device_config' that holds configuration details of the device\ntypedef struct {\n    int busy_gpio_port;\n    bool is_gpio_port_defined;\n} itron_device_config;\n\n// Assuming there's a method to fetch device's configuration\nconst itron_device_config* get_itron_config(const struct device *dev);\n\n// Assuming a method to read a GPIO pin\nint gpio_pin_read(int port);\n\nstatic int auxdisplay_itron_is_busy(const struct device *dev) {\n    // Get the configuration for the device\n    const itron_device_config* config = get_itron_config(dev);\n\n    if (!config) {\n        // Configuration fetch failed, handle as appropriate (optional)\n        return -EINVAL; // Invalid argument\n    }\n\n    // Check if the busy GPIO port is defined\n    if (!config->is_gpio_port_defined) {\n        // Return not supported error code\n        return -ENOTSUP;\n    }\n\n    // Otherwise, get the status of the busy GPIO pin\n    int status = gpio_pin_read(config->busy_gpio_port);\n    \n    // Interpret the read status as required, here assuming 1 or 0 as BUSY\n    if (status == 1) {\n        return 1; // Busy\n    } else if (status == 0) {\n        return 0; // Not busy\n    } else {\n        // Assuming any other read value is an error, return a general purpose error\n        return -EIO; // Input/output error\n    }\n}", "CodeBleu_score": 21.999842662508645}, {"code": "#include <errno.h> // For the ENOTSUP macro\n\nstruct device_config {\n    int busy_pin;    // Assuming an integer represents the pin number, -1 if not defined\n};\n\nstruct device {\n    const struct device_config *config;\n    // Other necessary device fields...\n};\n\n// We assume there's a function to read a GPIO pin, which returns the pin status (0 for not busy, 1 for busy)\nextern int gpio_read(int pin);\n\nstatic int auxdisplay_itron_is_busy(const struct device *dev) {\n    if (dev == NULL || dev->config == NULL) {\n        return -ENOTSUP;\n    }\n\n    int busy_pin = dev->config->busy_pin;\n    \n    // If the busy pin isn't defined properly\n    if (busy_pin == -1) {\n        return -ENOTSUP;\n    }\n\n    // Read the status of the busy GPIO pin\n    int status = gpio_read(busy_pin);\n\n    // Assume gpio_read returns 0 if not busy, 1 if busy\n    if (status == 0) {\n        // Not busy\n        return 0;\n    } else {\n        // Busy\n        return 1;\n    }\n}", "CodeBleu_score": 53.32956531392368}, {"code": "#include <errno.h>  // For the -ENOTSUP error code\n\n// Assumptions:\n// 1. There exists a structure that stores GPIO configuration which can be accessed via device.\n// 2. The device configuration contains a member maybe called `config` that includes details about the GPIO pin used for checking if the device is busy.\n// 3. There exists a method for reading the state of a GPIO pin.\n// 4. There is a valid GPIO API that supports pin reading and is linked with error handling.\n\n// First, let's define these assumptions with pseudocode or using typical structs we might expect:\n\nstruct gpio_config {\n    int busy_pin;              // GPIO pin number for the BUSY status\n    const struct device *gpio_dev; // Pointer to the GPIO device\n};\n\nstruct auxdisplay_device {\n    struct gpio_config config;\n};\n\nstatic int auxdisplay_itron_is_busy(const struct device *dev) {\n    const struct auxdisplay_device *display_dev = (const struct auxdisplay_device *)dev;\n\n    // Check if the busy GPIO port is defined (assuming -1 means undefined)\n    if (display_dev->config.busy_pin == -1) {\n        return -ENOTSUP;  // Port not supported\n    }\n\n    // Get the GPIO device linked to this pin for better abstraction\n    const struct device *gpio_dev = display_dev->config.gpio_dev;\n    \n    // Read the state of the busy GPIO pin\n    bool pin_state;\n    int err = gpio_pin_read(gpio_dev, display_dev->config.busy_pin, &pin_state);\n\n    // If there's an error reading the pin, return the error from gpio_pin_read\n    if (err) {\n        return err;\n    }\n\n    // Return the state of the busy pin (assuming true means busy)\n    return pin_state ? 0 : -EBUSY; // You might also return pin_state directly if defined as per system conventions\n}\n\n// Please note that actual function implementations may need specific includes or more concrete API details from their respective hardware abstraction layers or operating systems.", "CodeBleu_score": 48.729475065924525}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\n{\n    // Results variable for I2C operation\n    int result;\n\n    // Special command prefix typically something like 0xFE for serial LCD\n    uint8_t command_prefix = 0xFE; // Assuming that 0xFE is the prefix\n    \n    // Buffer to hold the prefix and the command\n    uint8_t buffer[2];\n    buffer[0] = command_prefix;\n    buffer[1] = (uint8_t)command;  // Cast command to uint8_t if needed\n\n    // Write the buffer to the LCD device using the I2C bus\n    result = i2c_write(dev->i2c_bus, buffer, sizeof(buffer), dev->i2c_address);\n    if (result != 0) {\n        return result; // Return error if I2C write failed\n    }\n\n    // Introduce a delay as specified in the device configuration\n    // This assumes there is a field in `dev` for delay time in milliseconds\n    k_sleep(K_MSEC(dev->command_delay_ms));\n\n    // Return the result of the I2C write operation, which should be 0 if no errors\n    return result;\n}", "CodeBleu_score": 49.954968678016506}, {"code": "#include <linux/i2c.h>\n#include <linux/delay.h>\n\n#define SPECIAL_COMMAND_PREFIX 0xFE\n\nstatic int auxdisplay_serlcd_send_special_command(const struct device *dev,\n                                                  const enum auxdisplay_serlcd_special_command command) {\n    struct i2c_client *client = to_i2c_client(dev);\n    u8 buffer[2];\n    int ret;\n\n    // Construct the command buffer\n    buffer[0] = SPECIAL_COMMAND_PREFIX;\n    buffer[1] = command;\n\n    // Write the special command to the LCD via I2C\n    ret = i2c_master_send(client, buffer, sizeof(buffer));\n    if (ret < 0) {\n        dev_err(&client->dev, \"Failed to send special command: %d\\n\", ret);\n        return ret;\n    }\n\n    // Introduce a delay as per device's specification\n    msleep(100);\n\n    return 0;\n}", "CodeBleu_score": 47.78271938942136}, {"code": "static int auxdisplay_serlcd_send_special_command(const struct device *dev,\n                                                  const enum auxdisplay_serlcd_special_command command) \n{\n    int ret;\n    uint8_t buffer[2]; // Assuming the command fits in one byte and one byte for the prefix.\n\n    const uint8_t special_prefix = 0xFE; // Hypothetical prefix for a special command; adjust appropriately.\n\n    // Prepare the command buffer\n    buffer[0] = special_prefix;\n    buffer[1] = (uint8_t)command;\n\n    // Send the command buffer to the device via I2C\n    ret = i2c_write(dev->i2c_bus, buffer, sizeof(buffer), dev->i2c_addr);\n    \n    // Check if the write was successful\n    if (ret < 0) {\n        return ret; // return if there was an I2C error\n    }\n\n    // Delay after sending the command as required\n    // Assuming there's a function delay_ms() available that corresponds to the device configuration\n    delay_ms(dev->config->command_delay_ms);\n\n    return ret; // Return the result of the write operation\n}", "CodeBleu_score": 45.83748137378742}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "#include <stdint.h>\n#include <stddef.h>\n\n#define BBRAM_SIZE 1024  // Suppose the BBRAM size is 1024 bytes for this example\n\nstruct device {\n    uint8_t bbram_data[BBRAM_SIZE];\n};\n\n#define SUCCESS 0\n#define ERR_INVALID_PARAMETER -1\n#define ERR_OUT_OF_BOUNDS -2\n\nstatic int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n                           uint8_t *data) {\n    if (!dev || !data) {\n        return ERR_INVALID_PARAMETER; // Error: invalid pointer passed to function\n    }\n\n    if (offset + size > BBRAM_SIZE) {\n        return ERR_OUT_OF_BOUNDS;     // Error: read operation would exceed BBRAM boundaries\n    }\n\n    // Perform the read from the BBRAM data buffer.\n    for (size_t i = 0; i < size; i++) {\n        data[i] = dev->bbram_data[offset + i];\n    }\n\n    return SUCCESS; // Successfully read data and copied to the buffer\n}", "CodeBleu_score": 35.76361269202033}, {"code": "#include <stdint.h>   // For uint8_t\n#include <stddef.h>   // For size_t\n\n// Constants\n#define BBRAM_SIZE 1024  // Assuming size of the BBRAM memory\n\n// Error codes\n#define ERR_INVALID_ARG -1\n#define ERR_OUT_OF_BOUNDS -2\n\n// Mock-up of BBRAM memory\nstatic uint8_t bbram[BBRAM_SIZE];\n\nstatic int bbram_emul_read(const struct device *dev, size_t offset, size_t size, uint8_t *data) {\n    // Check if the arguments are valid\n    if (!dev || !data) {\n        return ERR_INVALID_ARG;\n    }\n\n    // Check that the read operation does not go out of bounds\n    if (offset + size > BBRAM_SIZE) {\n        return ERR_OUT_OF_BOUNDS;\n    }\n\n    // Perform the memory copy operation\n    for (size_t i = 0; i < size; i++) {\n        data[i] = bbram[offset + i];\n    }\n\n    // Return success\n    return 0;\n}", "CodeBleu_score": 36.6482827231859}, {"code": "#include <stddef.h>\n#include <stdint.h>\n\n#define BBRAM_MEMORY_SIZE 1024  // for example, BBRAM size can vary as per actual device specs\n#define ERR_INVALID_OFFSET -1\n#define ERR_EXCEEDED_MEMORY -2\n\n// This is a placeholder for the actual BBRAM memory structure that would ideally be part of the device structure.\nstruct bbram_device_memory {\n    uint8_t memory[BBRAM_MEMORY_SIZE];\n};\n \nstatic int bbram_emul_read(const struct device *dev, size_t offset, size_t size, uint8_t *data) {\n    // Cast the given device's driver_data to our BBRAM memory structure\n    struct bbram_device_memory *bbram = (struct bbram_device_memory *)(dev->driver_data);\n\n    // Check if the offset is valid\n    if (offset >= BBRAM_MEMORY_SIZE) {\n        return ERR_INVALID_OFFSET;\n    }\n\n    // Check if the read operation exceeds the bounds of the memory\n    if (offset + size > BBRAM_MEMORY_SIZE) {\n        return ERR_EXCEEDED_MEMORY;\n    }\n\n    // Copy data from BBRAM memory to provided data buffer\n    for (size_t i = 0; i < size; i++) {\n        data[i] = bbram->memory[offset + i];\n    }\n\n    // Return 0 on successful read\n    return 0;\n}", "CodeBleu_score": 37.03153801826678}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\n    // Retrieve the BBRAM device context; assuming it has \"memory\" and \"size\" properties\n    struct bbram_emul *emul = device_get_emul_data(dev);\n    if (emul == NULL) {\n        return -ENODEV; // Return an error if the BBRAM device context is invalid\n    }\n\n    // Check if BBRAM is in an invalid state\n    if (emul->invalid_state) {\n        return -EIO; // Return an I/O error if the BBRAM is in an invalid state\n    }\n\n    // Check if the write size and offset are valid\n    if (offset + size > emul->size) {\n        return -EINVAL; // Return an invalid argument error if the operation goes out of bounds\n    }\n\n    // Perform the data copy operation\n    memcpy(emul->memory + offset, data, size);\n\n    // Return success\n    return 0;\n}", "CodeBleu_score": 49.429202063358424}, {"code": "// Define the total size of the BBRAM simulation (adjust this as needed).\n#define BBRAM_SIZE 1024\n\n// Simulated state of the BBRAM.\nstatic uint8_t bbram_memory[BBRAM_SIZE];\nstatic bool invalid_state = false;\n\nstatic int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n                            const uint8_t *data) {\n    // Check if the BBRAM is in an invalid state.\n    if (invalid_state) {\n        return -1;  // Simulation of an error due to invalid BBRAM state.\n    }\n\n    // Check if the size is zero or if data pointer is NULL.\n    if (size == 0 || data == NULL) {\n        return -1;  // Invalid size or NULL data pointer.\n    }\n\n    // Check if the offset and size stay within the bounds of the BBRAM.\n    if (offset + size > BBRAM_SIZE) {\n        return -1;  // Attempted to write beyond the bounds of the BBRAM.\n    }\n\n    // Perform the writing operation.\n    for (size_t i = 0; i < size; ++i) {\n        bbram_memory[offset + i] = data[i];\n    }\n\n    return 0;  // Return 0 to indicate a successful operation.\n}", "CodeBleu_score": 37.01857423812452}, {"code": "#include <stddef.h>\n#include <stdint.h>\n\n#define BBRAM_SIZE 4096 // Assuming BBRAM size (in bytes)\n#define DEVICE_OK 0     // Device operation successful\n#define DEVICE_ERROR -1 // Device operation failed (generic error)\n\ntypedef struct {\n    int status;          // Device status representing the state, 0 for valid, non-zero for invalid state\n    uint8_t memory[BBRAM_SIZE];\n} BBRAM_Device;\n\ntypedef struct device {\n    BBRAM_Device *bbram; // Pointer to the BBRAM Device\n} device;\n\n/*\n * The function \"bbram_emul_write\" writes data to a Battery-Backed RAM (BBRAM) emulation device.\n * It checks if the write size is valid, if the write operation stays within the bounds of the BBRAM, and if the BBRAM is not in an invalid state.\n * If these checks pass, it copies the data to the specified offset within the device's memory.\n * If any check fails, it returns an error; otherwise, it returns 0 to indicate success.\n */\nstatic int bbram_emul_write(const struct device *dev, size_t offset, size_t size, const uint8_t *data) {\n    // Check if the device is in a valid state\n    if (dev->bbram->status != DEVICE_OK) {\n        return DEVICE_ERROR;\n    }\n\n    // Check the boundaries of the write operation\n    if (offset + size > BBRAM_SIZE) {\n        return DEVICE_ERROR;\n    }\n\n    // Copy data to the memory of BBRAM\n    for (size_t i = 0; i < size; ++i) {\n        dev->bbram->memory[offset + i] = data[i];\n    }\n\n    return DEVICE_OK; // Indicate successful write\n}", "CodeBleu_score": 37.01267429197907}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "#include <device.h>\n#include <logging/log.h>\n#include <stdlib.h>\n\n/* Return Codes */\n#define ERROR_INVALID_ARGUMENT -1\n#define ERROR_DEVICE_NOT_FOUND -2\n#define SUCCESS 0\n\nLOG_MODULE_REGISTER(parse_device);\n\nstatic inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev) {\n    /* Step 1: Check for minimum required arguments. */\n    if (argc < 2) {\n        LOG_ERR(\"Insufficient arguments provided.\");\n        if (sh != NULL) {\n            shell_error(sh, \"Usage: %s <device_name>\", argv[0]);\n        }\n        return ERROR_INVALID_ARGUMENT;\n    }\n\n    /* Step 2: Try to bind to the BBRAM device with the name provided in argv[1]. */\n    *bbram_dev = device_get_binding(argv[1]);\n    if (*bbram_dev == NULL) {\n        LOG_ERR(\"BBRAM device '%s' not found.\", argv[1]);\n        if (sh != NULL) {\n            shell_error(sh, \"BBRAM device '%s' not found.\", argv[1]);\n        }\n        return ERROR_DEVICE_NOT_FOUND;\n    }\n\n    /* Device found and bound successfully. */\n    LOG_INF(\"BBRAM device '%s' successfully bound.\", argv[1]);\n    if (sh != NULL) {\n        shell_print(sh, \"BBRAM device '%s' successfully bound.\", argv[1]);\n    }\n    return SUCCESS;\n}", "CodeBleu_score": 53.43283014836842}, {"code": "#include <device.h>\n#include <drivers/bbram.h>\n#include <shell/shell.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define ARGV_DEVICE_NAME_INDEX 1\n#define ERROR_INVALID_ARGS -1\n#define ERROR_DEVICE_NOT_FOUND -2\n\nstatic inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev) {\n    // Check if device name is provided\n    if (argc <= ARGV_DEVICE_NAME_INDEX) { \n        shell_fprintf(sh, SHELL_ERROR, \"Error: Device name argument missing.\\n\");\n        return ERROR_INVALID_ARGS;\n    }\n\n    // Attempt to retrieve the device\n    const char* device_name = argv[ARGV_DEVICE_NAME_INDEX];\n    *bbram_dev = device_get_binding(device_name);\n    if (*bbram_dev == NULL) {\n        shell_fprintf(sh, SHELL_ERROR, \"Error: Device '%s' not found.\\n\", device_name);\n        return ERROR_DEVICE_NOT_FOUND;\n    }\n\n    // Device found and successfully retrieved\n    shell_fprintf(sh, SHELL_INFO, \"Device '%s' successfully bound.\\n\", device_name);\n    return 0;\n}", "CodeBleu_score": 42.94292913708081}, {"code": "#include <device.h>\n#include <logging/log.h>\n\nLOG_MODULE_REGISTER(device_parser);\n\n#define ERROR_INVALID_ARG -1\n#define ERROR_DEVICE_NOT_FOUND -2\n\n/*\n * The function \"parse_device\" checks for and retrieves a BBRAM device based on command-line arguments.\n * It verifies that the required argument for the device is provided.\n * If not, it logs an error and returns an invalid argument error code.\n * It attempts to bind to the specified device and, if unsuccessful, logs an error and returns a device not found error code.\n * If successful, it returns 0.\n */\nstatic inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev) {\n    if (argc < 2) {\n        LOG_ERR(\"Insufficient arguments provided\");\n        shell_fprintf(sh, SHELL_ERROR, \"Usage: %s <device_name>\\n\", argv[0]);\n        return ERROR_INVALID_ARG;\n    }\n\n    const char *device_name = argv[1];\n    *bbram_dev = device_get_binding(device_name);\n\n    if (*bbram_dev == NULL) {\n        LOG_ERR(\"No device found with the name %s\", device_name);\n        shell_fprintf(sh, SHELL_ERROR, \"Device '%s' not found\\n\", device_name);\n        return ERROR_DEVICE_NOT_FOUND;\n    }\n\n    LOG_INF(\"Device %s bound successfully\", device_name);\n    return 0;\n}", "CodeBleu_score": 50.04090070863255}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "#include <device.h>\n#include <logging/log.h>\n#include <drivers/uart.h>\n\nLOG_MODULE_REGISTER(h4_uart);\n\n// Assume the header size is constant; adjust according to data specification\n#define H4_HEADER_SIZE 4\n\nstatic int bytes_already_read = 0;\nstatic uint8_t header_buf[H4_HEADER_SIZE];\n\nstatic void h4_read_hdr(const struct device *dev) {\n    if (!dev) {\n        LOG_ERR(\"Device not initialized\");\n        return;\n    }\n\n    // Calculate remaining bytes to read for completing the header\n    int remaining_bytes = H4_HEADER_SIZE - bytes_already_read;\n\n    // If remaining bytes is zero or negative, header is already complete\n    if (remaining_bytes <= 0) {\n        LOG_INF(\"Header already read\");\n        return;\n    }\n\n    // Read data from UART\n    int read_result = uart_fifo_read(dev, &header_buf[bytes_already_read], remaining_bytes);\n\n    if (read_result < 0) {\n        // Handle read error\n        LOG_ERR(\"Failed to read from UART device with error %d\", read_result);\n        return;\n    } else if (read_result == 0) {\n        LOG_ERR(\"No data available to read from UART device\");\n        return;\n    }\n\n    // Update number of bytes successfully read\n    bytes_already_read += read_result;\n\n    if (bytes_already_read < H4_HEADER_SIZE) {\n        LOG_INF(\"Read partially completed header: %d bytes read out of %d total\", bytes_already_read, H4_HEADER_SIZE);\n    } else {\n        LOG_INF(\"Header read successfully\");\n    }\n}", "CodeBleu_score": 40.09879567569408}, {"code": "#include <stdio.h>\n#include <string.h>\n\n#define UART_HEADER_SIZE 4  // Assumed size of the header\n\nstatic uint8_t header_buffer[UART_HEADER_SIZE];\nstatic size_t header_bytes_read = 0;\n\nstatic void h4_read_hdr(const struct device *dev) {\n    // Check the amount of data available in the UART buffer\n    size_t bytes_available = uart_fifo_read_avail(dev);\n    \n    // Calculate how many bytes we still need to read to fill the header\n    size_t bytes_to_read = UART_HEADER_SIZE - header_bytes_read;\n    if (bytes_available > 0) {\n        // Read the data from UART\n        size_t read_bytes = uart_fifo_read(dev, header_buffer + header_bytes_read, bytes_to_read);\n\n        if (read_bytes < 0) {\n            // Handle read error\n            printf(\"Failed to read from UART device\\n\");\n        } else {\n            // Update the number of bytes read\n            header_bytes_read += read_bytes;\n\n            if (header_bytes_read == UART_HEADER_SIZE) {\n                // Successfully read the complete header\n                printf(\"Header read successfully. Data: \");\n                for (int i = 0; i < UART_HEADER_SIZE; ++i) {\n                    printf(\"%02x \", header_buffer[i]);\n                }\n                printf(\"\\n\");\n\n                // Reset header_bytes_read for the next operation\n                header_bytes_read = 0;\n            }\n        }\n    } else {\n        // No data available to read\n        printf(\"No data available in UART FIFO to read\\n\");\n    }\n}", "CodeBleu_score": 34.38806676339823}, {"code": "#include <device.h>  // Assume this header defines struct device and relevant UART APIs\n#include <logging/log.h> // For logging errors\n\nLOG_MODULE_REGISTER(h4_uart); // Set up logging for this module\n\n#define HEADER_SIZE 4 // Define the expected size of the header\n\nstatic uint8_t header_buffer[HEADER_SIZE]; // buffer to store header data\nstatic size_t header_bytes_read = 0; // Number of bytes already read\n\n// This function will simulate reading from a UART FIFO\nstatic int uart_fifo_read(const struct device *dev, uint8_t *data, int length) {\n    // Hardware-specific API should be used here to read from the UART\n    // Returning a simulative value for the sake of example\n    return 0; // Simulate no bytes read or error\n}\n\nstatic void h4_read_hdr(const struct device *dev) {\n    while (header_bytes_read < HEADER_SIZE) {\n        int retval = uart_fifo_read(dev, &header_buffer[header_bytes_read], HEADER_SIZE - header_bytes_read);\n        \n        if (retval < 0) {\n            // Log an error using the logging subsystem\n            LOG_ERR(\"Failed to read from UART FIFO: error %d\", retval);\n            return; // Exit the function on read failure\n        } else {\n            // Update the count of header bytes read\n            header_bytes_read += retval;\n\n            // If all bytes have been read successfully\n            if (header_bytes_read == HEADER_SIZE) {\n                LOG_INF(\"Successfully read the full header\");\n                header_bytes_read = 0; // Reset for the next header read\n                // Further processing can be done here\n            }\n        }\n    }\n\n    // Optional: Handle case where not all data is read in one function call, if necessary\n    // This could involve resetting state, setting up interrupts, DMA, etc.\n}", "CodeBleu_score": 28.742442370661426}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "#include <stddef.h>\n#include <stdint.h>\n#include <logging/log.h>\n\nLOG_MODULE_REGISTER(h4_uart);\n\n#define MAX_READ_LENGTH 33\n\nstatic size_t h4_discard(const struct device *uart, size_t len) {\n    uint8_t buffer[MAX_READ_LENGTH];\n    size_t bytes_to_read;\n    size_t bytes_read = 0;\n    size_t total_read = 0;\n\n    while (len > 0) {\n        bytes_to_read = (len < MAX_READ_LENGTH) ? len : MAX_READ_LENGTH;\n        ssize_t result = uart_fifo_read(uart, buffer, bytes_to_read);\n        \n        if (result < 0) {\n            LOG_ERR(\"Failed to read UART FIFO\");\n            return 0; // Error occurred, return 0 as per documentation\n        }\n\n        bytes_read = (size_t) result;\n        total_read += bytes_read;\n        len -= bytes_read;\n\n        if (bytes_read < bytes_to_read) {\n            // Unable to read more data, possibly end of data\n            break;\n        }\n    }\n\n    return total_read;\n}", "CodeBleu_score": 31.82842258168862}, {"code": "static size_t h4_discard(const struct device *uart, size_t len) {\n    uint8_t temp_buffer[33];\n    size_t read_count = 0;\n    size_t total_read = 0;\n\n    // Check if requested length is larger than the buffer size\n    while (total_read < len) {\n        size_t to_read = (len - total_read > sizeof(temp_buffer)) ? sizeof(temp_buffer) : len - total_read;\n        \n        // Perform the reading from UART\n        read_count = uart_fifo_read(uart, temp_buffer, to_read);\n        \n        // Check if the read operation was successful\n        if (read_count == 0) {\n            printk(\"Error: Failed to read from UART\\n\");\n            return 0;  // Return 0 to indicate failure\n        }\n        \n        // Accumulate the total number of bytes read\n        total_read += read_count;\n    }\n\n    // Return the total number of bytes successfully read and discarded\n    return total_read;\n}", "CodeBleu_score": 35.582298711896144}, {"code": "#include <stddef.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <drivers/uart.h>\n#include <logging/log.h>\n\nLOG_MODULE_REGISTER(h4_discard_module, LOG_LEVEL_ERR);\n\nstatic size_t h4_discard(const struct device *uart, size_t len) {\n    uint8_t temp_buffer[33]; // Temporary buffer to hold discarded bytes\n    size_t total_read = 0;\n    int read_result;\n\n    while (total_read < len) {\n        // Calculate number of bytes to read from hardware FIFO\n        size_t to_read = (len - total_read) > sizeof(temp_buffer) ? sizeof(temp_buffer) : (len - total_read);\n\n        // Try to read up to `to_read` bytes from the UART\n        read_result = uart_fifo_read(uart, temp_buffer, to_read);\n        \n        if (read_result < 0) {\n            LOG_ERR(\"Failed to read from UART device\");\n            return 0;  // Return 0 on read failure\n        }\n\n        // Accumulate the number of bytes successfully read\n        total_read += read_result;\n\n        // If ust_fifo_read read less than what we wanted, means no more data, break the loop\n        if (read_result != to_read) {\n            break;\n        }\n    }\n\n    return total_read;\n}", "CodeBleu_score": 37.482464790459346}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "#include <pthread.h>  // Include pthread for using mutex in multi-threading environments\n\n/*\n * Structure definitions for observers and channels would be something like this.\n * Assuming some plausible structure like:\n */\ntypedef struct observer {\n    int priority;\n    int enabled;  // This is typically a boolean (0 or 1) to indicate enabled/disabled\n} observer_t;\n\ntypedef struct zbus_channel {\n    pthread_mutex_t mutex;  // Mutex to lock the channel data\n    observer_t *observers;  // Array of observers\n    int num_observers;      // Number of observers\n    int highest_observer_priority;  // Highest observer priority\n} zbus_channel_t;\n\n/*\n * The function \"chan_update_hop\" updates the highest observer priority for a given channel.\n * It locks the channel data and iterates through the observers, checking each observer's \n * priority and whether it is enabled. If an observer has a higher priority (lower numerical value)\n * than the current highest, it updates the highest observer priority.\n * Finally, it sets the channel's highest observer priority to the determined value.\n */\nstatic inline void chan_update_hop(const struct zbus_channel *chan) {\n    int i;\n    int currentHighestPriority = INT_MAX;  // Initialize to the highest possible integer\n\n    // Lock the channel mutex to prevent concurrent modifications\n    pthread_mutex_lock(&chan->mutex);\n\n    // Iterate over all observers\n    for (i = 0; i < chan->num_observers; ++i) {\n        if (chan->observers[i].enabled && chan->observers[i].priority < currentHighestPriority) {\n            // Update the current highest priority found among enabled observers\n            currentHighestPriority = chan->observers[i].priority;\n        }\n    }\n\n    // Check if a valid lowest priority has been found and update the channel's highest observer priority.\n    if (currentHighestPriority != INT_MAX) {\n        chan->highest_observer_priority = currentHighestPriority;\n    }\n\n    // Unlock the channel mutex\n    pthread_mutex_unlock(&chan->mutex);\n}", "CodeBleu_score": 32.41164990126085}, {"code": "#include <limits.h> // For INT_MAX\n\n/**\n * Struct definitions assumed as not provided with the question.\n */\ntypedef struct {\n    int priority;\n    int enabled;\n} observer_t;\n\ntypedef struct {\n    observer_t *observers;  // Array of observers\n    int num_observers;      // Number of observers\n    int highest_observer_priority;\n} zbus_channel;\n\n/**\n * Updates the highest observer priority for a given channel.\n * It locks the channel data and iterates through the observers, checking each observer's priority\n * and whether it is enabled. \n * If an observer has a higher priority (lower numerical value) than the current highest,\n * it updates the highest observer priority.\n * Finally, it sets the channel's highest observer priority to the determined value.\n */\nstatic inline void chan_update_hop(const struct zbus_channel *chan) {\n    // Lock the channel data (Assuming some kind of locking mechanism in real-case scenarios)\n    // For this example, I'm commenting it out.\n    // lock_channel(chan); \n\n    int min_priority = INT_MAX;\n\n    for (int i = 0; i < chan->num_observers; ++i) {\n        observer_t observer = chan->observers[i];\n        if (observer.enabled && observer.priority < min_priority) {\n            min_priority = observer.priority;\n        }\n    }\n\n    // Update channel's highest observer priority\n    ((struct zbus_channel *)chan)->highest_observer_priority = min_priority;\n\n    // Unlock channel data (Assuming some kind of locking mechanism in real-case scenarios)\n    // unlock_channel(chan);\n}", "CodeBleu_score": 28.691470756182124}, {"code": "/* Ensure the header files for necessary functionalities are included */\n#include <pthread.h> // Required for mutex functions\n#include <limits.h>  // Required for INT_MAX\n\n/*\n * The function \"chan_update_hop\" updates the highest observer priority for a given channel.\n * It locks the channel data and iterates through the observers, checking each observer's priority\n * and whether it is enabled.\n * If an observer has a higher priority (lower numerical value) than the current highest, \n * it updates the highest observer priority.\n * Finally, it sets the channel's highest observer priority to the determined value.\n */\nstatic inline void chan_update_hop(const struct zbus_channel *chan) {\n    pthread_mutex_lock(&chan->mutex); // Lock the channel mutex to ensure thread safety\n\n    int highest_priority = INT_MAX;  // Start with the highest possible integer value\n    struct zbus_observer *observer = chan->observers;  // Beginning of observer linked-list\n  \n    // Iterate through all observers in the linked-list\n    while (observer != NULL) {\n        if (observer->enabled) {\n            // If the observer is enabled and has a lower (better) priority than current highest, update\n            if (observer->priority < highest_priority) {\n                highest_priority = observer->priority;\n            }\n        }\n        observer = observer->next; // Move to the next node in linked list\n    }\n\n    // Set the channel's highest observer priority with the found lowest value\n    chan->highest_observer_priority = highest_priority;\n\n    pthread_mutex_unlock(&chan->mutex); // Unlock the mutex\n}", "CodeBleu_score": 30.446273033109705}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "/*\n * The function \"update_all_channels_hop\" updates all channels observed by a given observer.\n * It iterates through each channel observation and checks if the observer matches the provided observer.\n * If they match, it calls the function to update the channel.\n */\nstatic inline void update_all_channels_hop(const struct zbus_observer *obs) {\n    // Assuming `zbus_get_channel_count()` and `zbus_get_channel_by_index(index)` are available functions\n    // to interact with the channel data, and `update_channel()` is the function to update a specific channel.\n    int total_channels = zbus_get_channel_count();\n    for (int i = 0; i < total_channels; i++) {\n        struct zbus_channel *channel = zbus_get_channel_by_index(i);\n        // Assuming `channel->observer` is the pointer to observer of this channel\n        if (channel->observer == obs) {\n            update_channel(channel);\n        }\n    }\n}", "CodeBleu_score": 14.813687890974176}, {"code": "#include <stddef.h> // For NULL\n\n// Hypothetical struct and functions that might exist in your codebase\nstruct zbus_channel {\n    struct zbus_observer *observer;\n};\n\nstruct channel_array {\n    struct zbus_channel *channels;\n    int count;\n};\n\nextern struct channel_array global_channels;\nextern void update_channel(struct zbus_channel *channel);\n\nstatic inline void update_all_channels_hop(const struct zbus_observer *obs) {\n    if (obs == NULL) {\n        return; // Safety check for NULL observer\n    }\n\n    // Iterate through global list of channels\n    for (int i = 0; i < global_channels.count; ++i) {\n        // Check each channel's observer\n        if (global_channels.channels[i].observer == obs) {\n            // The observer matches, update this channel\n            update_channel(&global_channels.channels[i]);\n        }\n    }\n}", "CodeBleu_score": 17.577495182830777}, {"code": "#include <stddef.h> // For NULL definition\n#include <stdint.h> // For integer types\n\n// Assuming this function is defined elsewhere in the system\nextern void update_channel(struct zbus_channel *channel);\n\nstatic inline void update_all_channels_hop(const struct zbus_observer *obs) {\n    // Assuming global list or array of channels\n    extern struct zbus_channel channels[];\n    extern size_t num_channels; // total number of channels\n\n    if (obs == NULL) {\n        return; // Safety check to prevent dereferencing NULL\n    }\n\n    for (size_t i = 0; i < num_channels; i++) {\n        struct zbus_channel *channel = &channels[i];\n        // Assuming each channel has a pointer to its observer\n        if (channel->observer == obs) {\n            update_channel(channel);\n        }\n    }\n}", "CodeBleu_score": 15.237034438115066}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "#include <assert.h>  // Include for using assert\n#include <stdbool.h>  // Include for boolean definitions \n\n// Placeholder structures for demonstration purposes\nstruct zbus_observer {\n    int priority;\n    bool is_attached;\n    // Other members as required...\n};\n\n// Placeholder for ISR detection function (must be user defined)\nbool in_isr() {\n    // This should be replaced with actual logic to test if in ISR\n    return false;\n}\n\n// Placeholder for min thread priority variable\n#define MIN_THREAD_PRIORITY  255  \n\n// Placeholder function to update channels (must be user defined)\nvoid update_channels(const struct zbus_observer *obs) {\n    // Actual implementation needed\n}\n\n// Placeholder for acquiring and releasing spinlock\nvoid lock_spinlock() {\n    // Actual implementation needed\n}\n\nvoid unlock_spinlock() {\n    // Actual implementation needed\n}\n\nint zbus_obs_detach_from_thread(struct zbus_observer *obs) {\n    assert(obs != NULL);  // Ensures observer is not null\n    assert(!in_isr()); // Ensures this is not called within an ISR\n\n    lock_spinlock();\n\n    obs->priority = MIN_THREAD_PRIORITY; // Set observer's priority to minimum thread priority\n    update_channels(obs);  // Update channels associated with this observer\n\n    unlock_spinlock();\n\n    return 0;  // Return 0 on success\n}", "CodeBleu_score": 42.17336558548329}, {"code": "#include <assert.h>\n#include <stdint.h>\n#include <stdbool.h>\n\n// Mock definitions for types and enums that might be part of Zephyr or the context from which the code snippet comes\ntypedef struct zbus_observer {\n    int priority;\n    // assume there exists a list or array for channels; for simplicity's sake, let's assume a fixed array of channels\n    int channels[10];\n} zbus_observer;\n\n// Mock of ISR check and priority definitions\n#define ISR_MODE() false // Simulating that this is not an ISR mode\n#define MIN_THREAD_PRIORITY 255 // assuming 255 is the minimal thread priority used as a placeholder\n\n// Stubs for extern or undefined functions: spinlock handling and possibly a channel updater\ntypedef int k_spinlock_key_t;\nvoid k_spin_lock(struct k_spinlock* sl) {}\nvoid k_spin_unlock(struct k_spinlock* sl, k_spinlock_key_t key) {}\n\nstruct k_spinlock lock; // define the lock\n\nvoid update_observer_channels(struct zbus_observer *obs) {\n    // A placeholder for detail on how channels should be updated.\n}\n\n/*\n * Detaches the given observer from the thread and processes all associated channels.\n * Returns 0 on successful operation.\n * Assumes obs is not null and not called from an ISR context.\n */\nint zbus_obs_detach_from_thread(struct zbus_observer *obs) {\n    assert(obs != NULL);\n    assert(!ISR_MODE()); // Check we are not in ISR mode\n\n    // Lock the spinlock\n    k_spinlock_key_t key = k_spin_lock(&lock);\n\n    // Set observer's priority to minimum thread priority\n    obs->priority = MIN_THREAD_PRIORITY;\n\n    // Update all channels associated with the observer\n    update_observer_channels(obs);\n\n    // Unlock the spinlock\n    k_spin_unlock(&lock, key);\n\n    return 0;\n}", "CodeBleu_score": 41.32435850731609}, {"code": "#include <assert.h>\n#include <stdbool.h>\n\n// Mockup definitions and functions\n#define THREAD_PRIORITY_MIN 255\n\nstruct zbus_observer {\n   int priority;\n   // Other observer details\n};\n\nstatic inline bool k_is_in_isr(void) {\n    // Placeholder for checking if currently in ISR\n    return false;\n}\n\nvoid k_spin_lock(void* lock) {\n    // Lock the spinlock\n}\n\nvoid k_spin_unlock(void* lock) {\n    // Unlock the spinlock\n}\n\nvoid update_observer_channels(struct zbus_observer *obs) {\n    // Placeholder for updating channels logic\n}\n\nint zbus_obs_detach_from_thread(struct zbus_observer *obs) {\n    static void* my_lock;  // Assuming a lock is globally defined or passed in some manner\n\n    // Check we are not in ISR and observer is not null\n    assert(!k_is_in_isr());\n    assert(obs != NULL);\n\n    // Locking mechanism\n    k_spin_lock(&my_lock);\n\n    // Set observer's priority to minimum\n    obs->priority = THREAD_PRIORITY_MIN;\n\n    // Update channels associated with the observer\n    update_observer_channels(obs);\n\n    // Unlocking mechanism\n    k_spin_unlock(&my_lock);\n\n    return 0;  // Return success\n}", "CodeBleu_score": 42.44037033025816}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "#include <assert.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/_timespec.h> // For timespec structures, or any other appropriate headers for your system\n\n// Assuming the necessary types and structures are defined elsewhere:\n// struct zbus_channel - Presumed to exist\n\n// This could be a placeholder for any system-specific error code enumeration or definitions\ntypedef enum {\n    ZBUS_SUCCESS = 0,            // No error\n    ZBUS_ERROR_UNLOCK_FAIL,      // Error in unlocking the channel\n    ZBUS_ERROR_INVALID_CHANNEL,  // Error due to invalid (NULL) channel\n    ZBUS_ERROR_NOTIFICATION_FAIL // Error in notification process\n} zbus_error_t;\n\n// Placeholder for zbus system ISR check function\nbool zbus_in_isr(void) {\n    // Implementation depends on system specifics.\n    return false; // default return\n}\n\n// Placeholder timeout management, meant to illustrate potential functionality\nint zbus_adjust_timeout(k_timeout_t *timeout) {\n    if (zbus_in_isr()) {\n        // Adjust the timeout because we're in an ISR context\n        *timeout = K_NO_WAIT; // Assume K_NO_WAIT is a constant that indicates no waiting\n    }\n    return 0;\n}\n\n// Example lock and unlock functions for the channel\nvoid zbus_channel_lock(const struct zbus_channel *chan) {\n    // Implementation depends on your concurrency controls\n    // For example, mutex lock or semaphore take\n}\n\nvoid zbus_channel_unlock(const struct zbus_channel *chan) {\n    // Implementation depends on your concurrency controls\n    // For example, mutex unlock or semaphore give\n}\n\n// Notification function which is the core logic to handle notifying the channel\nint zbus_perform_notification(const struct zbus_channel *chan) {\n    // Actual notification logic should be implemented here\n    return ZBUS_SUCCESS;\n}\n\nint zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout) {\n    assert(chan != NULL); // Assert to ensure channel is not null\n    \n    if (chan == NULL) {\n        return ZBUS_ERROR_INVALID_CHANNEL;\n    }\n    \n    // Adjust timeout in case we are in an ISR\n    zbus_adjust_timeout(&timeout);\n    \n    zbus_channel_lock(chan); // Lock the channel to ensure thread-safe access\n    \n    int status = zbus_perform_notification(chan); // Perform the actual notification logic\n    \n    zbus_channel_unlock(chan); // Always unlock after locking\n    \n    // Handle potential errors from the notification logic\n    if (status != ZBUS_SUCCESS) {\n        return ZBUS_ERROR_NOTIFICATION_FAIL;\n    }\n    \n    return ZBUS_SUCCESS;\n}", "CodeBleu_score": 36.61184623730034}, {"code": "#include <assert.h>\n#include <stdbool.h>\n#include \"zbus.h\"\n#include \"k_time.h\"\n#include \"lock.h\"\n\n/* Simulated function for error reporting (you may need to adapt this part) */\nint report_error(const char *message) {\n    // Implement the function to handle/report an error\n    printf(\"Error: %s\\n\", message);\n    return -1;\n}\n\nint zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout) {\n    // Step 1: Assert that the channel is not null\n    assert(chan != NULL);\n    if (chan == NULL) {\n        return report_error(\"Channel is NULL\");\n    }\n\n    // Step 2: Adjust timeout if in ISR (Interrupt Service Routine), typically a system-specific task\n    if (am_i_in_isr()) {\n        timeout = K_NO_WAIT;  // Assume K_NO_WAIT is a constant that represents 0 or immediate timeout\n    }\n\n    // Step 3: Calculate the end time for notification based on the timeout\n    int64_t current_time = k_uptime_get();  // Get the current uptime (you might need to define this function)\n    int64_t end_time = current_time + k_time_to_ms(timeout);  // Convert timeout to milliseconds \n\n    // Step 4: Initialize context priority (optional, depending on real application)\n    int priority = get_thread_priority();  // Hypothetical function\n\n    // Step 5: Lock the channel to assure atomic access during notification\n    if (!lock_channel(chan)) {\n        return report_error(\"Failed to lock channel\");\n    }\n\n    // Execute notification logic here\n    int notify_result = chan->notify(chan, timeout);\n    if (notify_result != 0) {\n        unlock_channel(chan);\n        return report_error(\"Notification failed\");\n    }\n\n    // Step 6: Unlock the channel after executing the notification logic\n    unlock_channel(chan);\n\n    // Step 7: Return any error encountered operations\n    return notify_result;  // Assuming notify function returns an int representing success or failure\n}\n\n/* Additional helper functions you might need to implement or adjust depending on environment */\nbool am_i_in_isr() {\n    // Implementation depends on the specific system\n    return false;  // Placeholder response\n}\n\nint64_t k_time_to_ms(k_timeout_t timeout) {\n    // Convert k_timeout_t to milliseconds; implementation may vary\n    return timeout;  // Placeholder implementation\n}\n\nbool lock_channel(const struct zbus_channel *chan) {\n    // Locking mechanism implementation, depending on system specifics\n    return true;  // Placeholder\n}\n\nvoid unlock_channel(const struct zbus_channel *chan) {\n    // Unlocking mechanism implementation, depending on system specifics\n}\n\nint get_thread_priority() {\n    return 0;  // Placeholder priority level\n}\n\n/* Assume other necessary system or mock functions are appropriately defined elsewhere */", "CodeBleu_score": 42.05541297771752}, {"code": "#include <kernel.h>\n#include <sys/__assert.h>\n#include <stdbool.h>\n#include <logging/log.h>\n\n// Define a LOGGER, assuming logging is configured elsewhere\nLOG_MODULE_DECLARE(zbus_channel, LOG_LEVEL_INFO);\n\nint zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout){\n    __ASSERT_NO_MSG(chan != NULL);  // Assert that the channel pointer is not NULL\n\n    // Check if we are in an Interrupt Service Routine (ISR) context\n    if (k_is_in_isr()) {\n        timeout = K_NO_WAIT;  // Do not wait if in ISR\n    }\n\n    // Calculate the end time based on the current time and timeout\n    k_timeout_t end_time = k_time_add(k_uptime_get(), timeout);\n\n    int error = 0;\n    \n    // Lock the channel for exclusive access\n    if (k_mutex_lock(&chan->lock, timeout) != 0) {\n        LOG_ERR(\"Failed to lock channel\");\n        return -EBUSY;  // return with an error if unable to lock\n    }\n\n    // Place where the channel notification logic would go. Simulated as a log for this example.\n    LOG_INF(\"Notifying zbus channel: %p with timeout %d ms\", (void *)chan, k_timeout_to_ms(timeout));\n\n    // Release the lock\n    k_mutex_unlock(&chan->lock);\n\n    // Perform any error handling necessary (simplified)\n    if (error != 0) {\n        LOG_ERR(\"Error encountered during notification: %d\", error);\n        return error;  // Return with error code\n    }\n\n    // Return success if all operations completed without error\n    return 0;\n}", "CodeBleu_score": 42.326335808409965}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "#include <stdint.h>\n#include <stdbool.h>\n\n#define ETH_REG_INTERRUPT_ENABLE    0xSomeAddress /* Placeholder for real register address */\n#define ETH_REG_INTERRUPT_STATUS    0xSomeOtherAddress /* Placeholder for real register address */\n\n#define ETH_INTERRUPT_NORMAL        0x0001   /* Example bit mask for a \"normal\" interrupt */\n#define ETH_INTERRUPT_ABNORMAL      0x0002   /* Example bit mask for an \"abnormal\" interrupt */\n\nvoid ETH_ITConfig(uint32_t Int, bool enable) {\n    // Simulated hardware register (should be replaced with actual hardware interface)\n    static volatile uint32_t *interruptEnableReg = (uint32_t *)ETH_REG_INTERRUPT_ENABLE;\n    static volatile uint32_t *interruptStatusReg = (uint32_t *)ETH_REG_INTERRUPT_STATUS;\n\n    // Validate the interrupt identifier, assuming validation means checking against a range or specific values\n    if (Int & (ETH_INTERRUPT_NORMAL | ETH_INTERRUPT_ABNORMAL)) {\n        if (enable) {\n            // Enable the interrupt\n            *interruptEnableReg |= Int;  // Sets the corresponding bit(s) to enable the interrupt\n        } else {\n            // Disable the interrupt\n            *interruptEnableReg &= ~Int; // Clears the corresponding bit(s) to disable the interrupt\n        }\n        \n        // Ideally we might want to also modify interrupt priority configuration or handle other interrupt management tasks.\n        \n    } else {\n        // Handle invalid interrupt identifier, e.g., logging or returning an error.\n        // For a typical microcontroller code, you might just silently ignore or include error handling\n        // e.g. printf(\"Invalid interrupt identifier: %u\\n\", Int); // Simple console output massage\n    }\n\n    // Additional steps might be required such as updating status flags or clearing pending interrupts etc.\n    // For instance:\n    // *interruptStatusReg |= Int; // Simulate setting the status (clearing pending flags or similar might require a different approach)\n}", "CodeBleu_score": 22.549399803882558}, {"code": "#include <stdint.h>\n\n// Hypothetical definitions for Ethernet control registers and interrupt flags\n#define ETH_IRQ_ENABLE_REG        (*(volatile uint32_t*)0x40028038)  // Hypothetical IRQ enable register address\n#define ETH_NORMAL_IRQ_MASK       0x0000FFFF  // Lower half for normal interrupts\n#define ETH_ABNORMAL_IRQ_MASK     0xFFFF0000  // Upper half for abnormal interrupts\n\ntypedef enum { FALSE, TRUE } BOOL;\n\n/**\n * Configures the enabling or disabling of Ethernet interrupts.\n * \n * @param Int    The interrupt flag mask indicating which interrupts to enable or disable.\n * @param enable BOOL flag indicating whether to enable (TRUE) or disable (FALSE) the interrupts.\n */\nvoid ETH_ITConfig(uint32_t Int, BOOL enable) {\n    if (enable) {\n        // Enable the specified interrupts\n        if (Int & ETH_NORMAL_IRQ_MASK) {\n            // If the interrupts include any 'normal' interrupts:\n            ETH_IRQ_ENABLE_REG |= (Int & ETH_NORMAL_IRQ_MASK);\n        }\n        if (Int & ETH_ABNORMAL_IRQ_MASK) {\n            // If the interrupts include any 'abnormal' interrupts:\n            ETH_IRQ_ENABLE_REG |= (Int & ETH_ABNORMAL_IRQ_MASK);\n        }\n    } else {\n        // Disable the specified interrupts\n        ETH_IRQ_ENABLE_REG &= ~Int;\n\n        // Optional: Check if any normal or abnormal interrupts are still enabled and reconfigure enable bits accordingly\n        // This is only necessary if there is a requirement to modify control bits based on remaining active interrupts\n        if (!(ETH_IRQ_ENABLE_REG & ETH_NORMAL_IRQ_MASK)) {\n            // No more normal interrupts enabled, possibly adjust control settings\n        }\n        if (!(ETH_IRQ_ENABLE_REG & ETH_ABNORMAL_IRQ_MASK)) {\n            // No more abnormal interrupts enabled, possibly adjust control settings\n        }\n    }\n}", "CodeBleu_score": 34.16803581755035}, {"code": "#include <stdint.h>\n\n#define ETH_DMAIER        (*(volatile uint32_t*)0x4002801C) // Hypothetical address\n#define ETH_DMA_NIS_BIT   (1 << 0)  // Normal interrupt summary bit\n#define ETH_DMA_AIS_BIT   (1 << 1)  // Abnormal interrupt summary bit\n#define ETH_DMA_ALL_BITS  (ETH_DMA_NIS_BIT | ETH_DMA_AIS_BIT) \n\ntypedef int BOOL;  // Define BOOL as it's not inherently part of C language\n\n// Function to enable or disable Ethernet interrupts\nvoid ETH_ITConfig(uint32_t Int, BOOL enable) {\n    // Critical section start: typically protect register access if necessary\n    // Lock hardware or disable related interrupts\n\n    if (enable) {\n        // Enable the specified interrupts\n        ETH_DMAIER |= Int & ETH_DMA_ALL_BITS;\n    } else {\n        // Disable the specified interrupts\n        ETH_DMAIER &= ~(Int & ETH_DMA_ALL_BITS);\n    }\n\n    // Refreshing or modifying configuration based on remaining enabled interrupts (may be optional based on use case)\n    uint32_t enabledInts = ETH_DMAIER & ETH_DMA_ALL_BITS;\n\n    if (enabledInts == 0) {\n        // If no relevant interrupts are enabled, additional processing might be needed here\n        // For instance, completely disable some features/hardware or go to power saving mode, etc.\n    }\n\n    // Critical section end\n    // Unlock hardware or enable previously disabled interrupts\n}\n\n/*\n * Usage example\n * To call the function, you would typically pass the interrupt types combined as flags along with the enable/disable command:\n * ETH_ITConfig(ETH_DMA_NIS_BIT | ETH_DMA_AIS_BIT, 1);  // To enable both normal and abnormal interrupts\n * ETH_ITConfig(ETH_DMA_NIS_BIT, 0);  // To disable normal interrupts only\n */", "CodeBleu_score": 25.076666065591525}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "#include <stddef.h> // For NULL\n\n#define NUM_TX_DESC 16 // Example value for total number of TX descriptors\n\ntypedef struct {\n    int own; // 0 = software, 1 = hardware\n    // other properties like buffer pointers may be here\n} ETH_TX_DESC;\n\nETH_TX_DESC txDescList[NUM_TX_DESC]; // Array of all available TX descriptors\nint currentTxDescIndex = 0; // Start at the first descriptor\n\nETH_TX_DESC *ETH_AcquireFreeTxDesc(void) {\n    int startIdx = currentTxDescIndex; // Remember starting point to detect a full loop\n\n    do {\n        if (txDescList[currentTxDescIndex].own == 0) { // Check if descriptor is free (owned by software)\n            return &txDescList[currentTxDescIndex]; // Return pointer to free descriptor\n        }\n        currentTxDescIndex = (currentTxDescIndex + 1) % NUM_TX_DESC; // Move to the next descriptor, wrap around using modulus\n    } while (currentTxDescIndex != startIdx); // Continue until we have checked all descriptors\n\n    return NULL; // No free descriptor found\n}", "CodeBleu_score": 34.04618196514965}, {"code": "#include \"ethernet.h\" // Assume this is the header where ETH_TX_DESC and related constants are declared.\n\nETH_TX_DESC *ETH_AcquireFreeTxDesc(void) {\n    // Presuming 'txDescList' is an accessible array of ETH_TX_DESC from somewhere in your system\n    // and 'txDescCount' is the number of descriptors in this list\n    // Also presuming each descriptor has a field 'status' with a bitflag named OWN\n    static unsigned int currentDescriptorIndex = 0;\n    unsigned int startDescriptorIndex = currentDescriptorIndex;\n\n    do {\n        ETH_TX_DESC *desc = &txDescList[currentDescriptorIndex];\n        \n        // Check if the descriptor is owned by CPU (OWN bit is 0)\n        if ((desc->status & OWN_BIT) == 0) {\n            return desc;\n        }\n\n        // Move to the next descriptor\n        currentDescriptorIndex = (currentDescriptorIndex + 1) % txDescCount;\n\n    } while (currentDescriptorIndex != startDescriptorIndex);\n\n    // If no descriptor is found\n    return 0;\n}", "CodeBleu_score": 40.82123486554469}, {"code": "// Type definition for an Ethernet transmit descriptor.\ntypedef struct ETH_TX_DESC {\n    uint32_t status;\n    uint32_t buffer;\n} ETH_TX_DESC;\n\n// Typically, there might be a predefined constant to define ownership.\n#define OWNERSHIP_BIT 0x80000000  // Example bit definition that might indicate ownership.\n\n// Assuming a fixed number of descriptors available.\n#define NUM_TX_DESC 64\n\n// Descriptor list.\nETH_TX_DESC txDescList[NUM_TX_DESC];\n\n// Current index tracking the last checked descriptor.\nstatic int currentDescIndex = 0;\n\nETH_TX_DESC *ETH_AcquireFreeTxDesc(void) {\n    int startDescIndex = currentDescIndex; // Remember the starting index.\n    do {\n        // Get the current descriptor.\n        ETH_TX_DESC *currentDesc = &txDescList[currentDescIndex];\n\n        // Check if the descriptor is owned by the software (i.e., free for use).\n        if (!(currentDesc->status & OWNERSHIP_BIT)) {\n            // Mark the descriptor as acquired.\n            currentDesc->status |= OWNERSHIP_BIT; // Set the ownership bit to indicate it's now owned by device.\n            return currentDesc; // Return the free descriptor.\n        }\n\n        // Move to the next descriptor.\n        currentDescIndex = (currentDescIndex + 1) % NUM_TX_DESC;\n\n    } while (currentDescIndex != startDescIndex); // Continue until we have circled back to the start.\n\n    return NULL; // No free descriptor was found.\n}", "CodeBleu_score": 36.6271585089694}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value) {\n    // Assert that the device pointer is not null\n    if (device == NULL) {\n        rt_kprintf(\"DAC device is null!\\n\");\n        return -RT_ERROR;\n    }\n\n    // Check that the channel is within a valid range for this device\n    if (channel >= device->channel_count) {\n        rt_kprintf(\"Invalid channel number %d\\n\", channel);\n        return -RT_ERROR;\n    }\n\n    // Initialize DAC device configuration if required\n    if (!device->is_initialized) {\n        if (device->ops->init(device) != RT_EOK) {\n            rt_kprintf(\"Failed to initialize DAC device\\n\");\n            return -RT_ERROR;\n        }\n        device->is_initialized = RT_TRUE;\n    }\n\n    // Set DAC channel value\n    rt_err_t status = device->ops->write(device, channel, *value);\n    if (status != RT_EOK) {\n        rt_kprintf(\"Failed to write to DAC channel %d\\n\", channel);\n        return status;  // return the error status from the write operation.\n    }\n\n    // Enable DAC output\n    if (!device->ops->enable(device, channel)) {\n        rt_kprintf(\"Failed to enable DAC channel %d\\n\", channel);\n        return -RT_ERROR;\n    }\n\n    // Return RT_EOK on successful operation\n    return RT_EOK;\n}", "CodeBleu_score": 49.60221092757535}, {"code": "#include <assert.h>  // Include assert for assertions\n\n// Error codes and success codes\n#define RT_EOK 0  // No error\n#define RT_ERROR -1  // Generic error\n\n// Assuming Cy_CSDIDAC_OutputEnable is a predefined function\n// Mockup of the CSDIDAC interface function\nint Cy_CSDIDAC_OutputEnable(rt_uint32_t channel, rt_uint32_t value);\n\n// Function to initialize and enable DAC on a specific channel\nstatic rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t value) {\n    // Assert device is not NULL\n    assert(device != NULL);\n\n    // Simulate retrieving corresponding DAC channel\n    // Assuming we are directly using the passed channel parameter in the Cy_CSDIDAC_OutputEnable function\n\n    // Enable DAC output with the specified value\n    if (Cy_CSDIDAC_OutputEnable(channel, value) == 0) {  // Assuming 0 means success in Cy_CSDIDAC_OutputEnable\n        return RT_EOK;  // Return OK if successful\n    } else {\n        // Log error - assuming a simple placeholder function for logging\n        printf(\"Error: Failed to enable DAC output on channel %u\\n\", channel);\n        return RT_ERROR;  // Return an error code if failed\n    }\n}", "CodeBleu_score": 43.46404592373075}, {"code": "#include <assert.h> // To use assert for null check\n\nstatic rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t value) {\n    // Step 1: Ensure device is not NULL\n    assert(device != NULL); // This will terminate the program if device is NULL\n    \n    if (device == NULL) {\n        return -RT_ERROR; // Return error if device is NULL\n    }\n    \n    // Step 2: Retrieve DAC channel\n    // Assuming there exists a function to get the DAC channel (Pseudo code) \n    struct dac_channel *dac_ch = get_dac_channel(device, channel);\n    if (dac_ch == NULL) {\n        return -RT_ERROR; // Return error if channel retrieval fails\n    }\n    \n    // Step 3: Enable the DAC output with specified value\n    // Assuming Cy_CSDIDAC_OutputEnable is an available function to enable the DAC output\n    // Pseudo function call, adjust to actual API:\n    if (Cy_CSDIDAC_OutputEnable(dac_ch, value) != RT_EOK) {\n        return -RT_ERROR; // Return error if enabling the DAC output fails\n    }\n    \n    // Step 4: If here, everything was successful\n    return RT_EOK; // Success result\n}", "CodeBleu_score": 43.508458068123026}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "#include <stdio.h> // Standard input/output definitions\n#include <stdint.h> // Standard integer types\n\n#define FLASH_BASE_ADDR 0x08000000\n#define FLASH_SIZE 0x8000 // 32 KiB\n\n// Error code definitions\n#define SUCCESS 0\n#define ERROR_INVALID_ARGUMENT -1\n\n/*\n * Mock of flash read operation for demonstration purposes.\n * This is just to simulate reading bytes from flash storage.\n */\nint mock_flash_read_function(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size) {\n    // Simulating reading by just setting the buffer values to a pattern\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = (rt_uint8_t)(addr + i);\n    }\n    return size;\n}\n\nint ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size) {\n    // Check if the address or size is out of bounds of the flash memory\n    if (addr < FLASH_BASE_ADDR || (addr + size) > (FLASH_BASE_ADDR + FLASH_SIZE)) {\n        printf(\"Error: Address out of bounds or size too large for flash memory.\\n\");\n        return ERROR_INVALID_ARGUMENT; \n    }\n\n    // Perform the mock read operation\n    int bytesRead = mock_flash_read_function(addr, buf, size);\n\n    // Return the actual number of bytes read\n    return bytesRead;\n}", "CodeBleu_score": 41.78272003489383}, {"code": "#include <stdint.h>\n#include <stdio.h>\n\n// Assume MAX_FLASH_SIZE is the maximum size of the flash\n#define MAX_FLASH_SIZE 0x20000 // Example: 128 KB of flash memory\n#define INVALID_ARGUMENT -1\n#define LOG_ERROR printf\n\n// Mock flash memory for the example\nrt_uint8_t flash_memory[MAX_FLASH_SIZE];\n\n// Initialize some elements in flash memory for demonstration purposes\nvoid init_flash() {\n    for (rt_uint32_t i = 0; i < MAX_FLASH_SIZE; i++) {\n        flash_memory[i] = i % 256; // Fill with some data\n    }\n}\n\n/*\n * The function \"ifx_flash_read_32k\" reads data from flash memory into a buffer.\n * It first checks if the read operation would exceed the flash memory's end address and logs an error if it does, returning an invalid argument error code.\n * If the address is valid, it reads the specified size of data from the flash memory address into the buffer, byte by byte.\n * Finally, it returns the number of bytes read.\n */\nint ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size) {\n    // Check if the read operation would go beyond the flash memory size\n    if (addr + size > MAX_FLASH_SIZE) {\n        LOG_ERROR(\"Error: Attempting to read beyond flash memory size at address %u\\n\", addr);\n        return INVALID_ARGUMENT;\n    }\n\n    // Perform the read operation\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = flash_memory[addr + i];\n    }\n\n    return size; // Return the number of bytes read\n}\n\nint main() {\n    init_flash();\n\n    rt_uint32_t addr = 0x1F000; // Example start address\n    rt_uint32_t size = 0x1000; // Example size (4KB)\n    rt_uint8_t buffer[0x1000]; // Allocate buffer\n\n    int result = ifx_flash_read_32k(addr, buffer, size);\n    if (result != INVALID_ARGUMENT) {\n        printf(\"Read %d bytes from flash successfully!\\n\", result);\n        // Optionally, print the buffer contents\n        for (int i = 0; i < result; i++) {\n            if (i % 16 == 0) printf(\"\\n\");\n            printf(\"%02x \", buffer[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"Failed to read from flash memory.\\n\");\n    }\n\n    return 0;\n}", "CodeBleu_score": 36.69762762917532}, {"code": "#include <stdio.h>\n\n#define FLASH_SIZE 32768 // Assuming the flash size is 32KB\n#define FLASH_START_ADDR 0x08000000 // Sample start address of the flash memory\n#define INVALID_ARGUMENT -1\n\n/**\n * The function \"ifx_flash_read_32k\" reads data from flash memory into a buffer.\n * It first checks if the read operation would exceed the flash memory's end address and logs an error if it does,\n * returning an invalid argument error code.\n * If the address is valid, it reads the specified size of data from the flash memory address into the buffer, byte by byte.\n * Finally, it returns the number of bytes read.\n */\nint ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size) {\n    rt_uint32_t flash_end_addr = FLASH_START_ADDR + FLASH_SIZE; // End address of flash memory\n\n    // Check if the read operation would exceed the flash memory's end address\n    if (addr < FLASH_START_ADDR || addr + size > flash_end_addr) {\n        printf(\"Error: Read operation exceeds flash memory bounds.\\n\");\n        return INVALID_ARGUMENT;\n    }\n\n    // Pointer to the flash memory start address\n    const rt_uint8_t *flash_memory = (const rt_uint8_t *)FLASH_START_ADDR;\n\n    // Read data into buffer\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = flash_memory[addr - FLASH_START_ADDR + i];\n    }\n\n    // Return number of bytes read\n    return size;\n}", "CodeBleu_score": 41.856684264793365}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "#include <assert.h>   // For assert()\n#include \"cyhal_timer.h\"  // Hypothetical include for cyhal_timer, assuming Cypress HAL or similar\n\nstatic rt_uint32_t timer_counter_get(rt_hwtimer_t *timer) {\n    assert(timer != NULL);  // Ensure the timer pointer is not null\n\n    // Assuming timer->user_data holds a pointer to the relevant hardware timer object\n    cyhal_timer_t* hardware_timer = (cyhal_timer_t*) timer->user_data;\n    assert(hardware_timer != NULL);  // Ensure the hardware timer object is not null\n\n    // Read current timer count via a hardware abstraction layer (HAL) function\n    rt_uint32_t count = cyhal_timer_read(hardware_timer);\n\n    return count;  // Return the count value\n}", "CodeBleu_score": 45.84786461715344}, {"code": "#include <assert.h>  // For assert()\n#include <stdint.h>  // For uint32_t definition\n\n// Assuming these are relevant platform-specific headers or that they need to be defined elsewhere\n#include \"rt_hardware.h\"           // Hypothetical header for hardware timer types and functions\n#include \"cyhal_timer.h\"           // Hypothetical header for Cypress HAL timer functions\n\nstatic rt_uint32_t timer_counter_get(rt_hwtimer_t *timer) {\n    // Ensuring the timer pointer is not NULL before proceeding\n    assert(timer != NULL);\n\n    // Retrieve the timer object from the timer's user data\n    // Assuming userData stores a pointer to a cyhal_timer_t struct or similar\n    cyhal_timer_t *timer_data = (cyhal_timer_t *)timer->userData;\n\n    // Read the current count of the timer\n    rt_uint32_t count = cyhal_timer_read(timer_data);\n\n    // Return the count value\n    return count;\n}", "CodeBleu_score": 46.793782093598466}, {"code": "#include \"cyhal_api.h\"  // Assume this is where `cyhal_timer_read` is declared\n\nstatic rt_uint32_t timer_counter_get(rt_hwtimer_t *timer) {\n    // Step 1: Assert that the provided timer is not null\n    if (timer == NULL) {\n        // Typically you would handle a null pointer error; for simplicity, return a special error value or zero\n        return 0;\n    }\n\n    // Step 2: Retrieve the timer object from the timer's user data\n    cyhal_timer_t *hardware_timer = (cyhal_timer_t *) timer->user_data;\n    if (hardware_timer == NULL) {\n        // If the hardware timer pointer is also null, this is an error.\n        return 0;\n    }\n\n    // Step 3: Use cyhal_timer_read to get the current timer count\n    uint32_t timer_count = cyhal_timer_read(hardware_timer);\n\n    // Step 4: Return the count value\n    return timer_count;\n}", "CodeBleu_score": 47.62080145769366}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n// Assuming mutex is a global variable\npthread_mutex_t mutex;\n\nvoid dfs_lock(void) {\n    int ret;\n\n    while (1) {\n        ret = pthread_mutex_lock(&mutex);\n        \n        if (ret == 0) {\n            // Mutex successfully acquired\n            return;\n        } else if (ret == EBUSY) {\n            // Mutex is busy, continue to try\n            continue;\n        } else {\n            // Any other error will cause an assertion failure\n            fprintf(stderr, \"Failed to acquire mutex: %s\\n\", strerror(ret));\n            abort();\n        }\n    }\n}", "CodeBleu_score": 29.220699148888684}, {"code": "#include <pthread.h>\n#include <assert.h>\n#include <errno.h>\n\npthread_mutex_t filesystem_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid dfs_lock(void) {\n    int ret;\n    while (1) {\n        ret = pthread_mutex_lock(&filesystem_mutex);\n        if (ret == 0) {\n            // Lock acquired successfully\n            break;\n        } else if (ret == EBUSY) {\n            // Mutex is already locked by another thread, continue trying\n            continue;\n        } else {\n            // Fatal error encountered while trying to acquire the lock\n            assert(0);  // Trigger an assertion failure\n        }\n    }\n}", "CodeBleu_score": 31.022824600484412}, {"code": "#include <assert.h>\n#include <errno.h>\n#include <pthread.h>\n#include <stdio.h>\n\n// Assume the mutex is defined globally\npthread_mutex_t filesystem_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid dfs_lock(void) {\n    int result;\n    while (1) {\n        result = pthread_mutex_lock(&filesystem_mutex);\n        if (result == 0) {\n            // Lock acquired successfully\n            break;\n        } else if (result == EBUSY) {\n            // Mutex is busy; retry locking\n            continue;\n        } else {\n            // Mutex acquisition failed for an unexpected reason; assert failure\n            assert(0 && \"Mutex acquisition failed unexpectedly.\");\n        }\n    }\n}", "CodeBleu_score": 28.65957374839432}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INIT_FDTABLE_SIZE 256\n\nstruct dfs_fdtable {\n    char* fds;  // Array to represent file descriptor status: 0 = free, 1 = used\n    int size;   // Current size of fds array\n};\n\n// Helper to expand the fdtable size\nstatic int expand_fdtable(struct dfs_fdtable *fdt) {\n    int new_size = fdt->size * 2;\n    char* new_fds = (char*) realloc(fdt->fds, new_size);\n    if (!new_fds) {\n        return -1;\n    }\n    // Initialize new slots to 0 (free)\n    memset(new_fds + fdt->size, 0, new_size - fdt->size);\n    \n    fdt->fds = new_fds;\n    fdt->size = new_size;\n    return 0;\n}\n\n// Implementation of fd_slot_alloc\nstatic int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd) {\n    if (startfd >= fdt->size) {\n        if (expand_fdtable(fdt) == -1) {\n            return -1;  // Expansion failed\n        }\n    }\n\n    // Search for an empty slot starting from startfd\n    for (int i = startfd; i < fdt->size; i++) {\n        if (fdt->fds[i] == 0) {  // Check if the slot is free\n            fdt->fds[i] = 1;  // Mark the slot as used\n            return i;\n        }\n    }\n\n    // Attempt to expand the fd table if no slot found\n    if (expand_fdtable(fdt) == -1) {\n        return -1;  // Expansion failed\n    }\n\n    // Allocate in newly expanded part\n    for (int i = startfd; i < fdt->size; i++) {\n        if (fdt->fds[i] == 0) {\n            fdt->fds[i] = 1;\n            return i;\n        }\n    }\n\n    // In unlikely case, return -1 as the fallback\n    return -1;\n}\n\n// Initialize fd table\nstruct dfs_fdtable* fdtable_init() {\n    struct dfs_fdtable *fdt = malloc(sizeof(struct dfs_fdtable));\n    if (!fdt) return NULL;\n\n    fdt->fds = calloc(INIT_FDTABLE_SIZE, sizeof(char));\n    if (!fdt->fds) {\n        free(fdt);\n        return NULL;\n    }\n    \n    fdt->size = INIT_FDTABLE_SIZE;\n    return fdt;\n}\n\nint main() {\n    // Example usage\n    struct dfs_fdtable *fdt = fdtable_init();\n    if (fdt) {\n        int fd = fd_slot_alloc(fdt, 0);\n        printf(\"Allocated fd: %d\\n\", fd);\n        \n        fd = fd_slot_alloc(fdt, 0);\n        printf(\"Allocated fd: %d\\n\", fd);\n        \n        fd = fd_slot_alloc(fdt, 257);  // Trigger expansion\n        printf(\"Allocated fd after expansion: %d\\n\", fd);\n        \n        free(fdt->fds);\n        free(fdt);\n    } else {\n        printf(\"Failed to initialize fd table\\n\");\n    }\n    \n    return 0;\n}", "CodeBleu_score": 34.402521066051385}, {"code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FDS 1024  // Maximum size of FD table for this example\n\nstruct dfs_fdtable {\n    int *fds;        // Array of file descriptors\n    int size;        // Current size of the fd array\n};\n\nstatic int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd) {\n    if (fdt == NULL || startfd < 0) {\n        return -1;  // Invalid table or startfd\n    }\n\n    // Search for an empty slot starting from startfd\n    for (int i = startfd; i < fdt->size; i++) {\n        if (fdt->fds[i] == -1) {  // Assuming -1 indicates an unused fd slot\n            return i;\n        }\n    }\n\n    // If no slots available, attempt to expand the FD table\n    if (fdt->size < MAX_FDS) {\n        int old_size = fdt->size;\n        int new_size = (fdt->size * 2 > MAX_FDS) ? MAX_FDS : fdt->size * 2;\n\n        // Allocate new fds array with increased size\n        int *new_fds = realloc(fdt->fds, new_size * sizeof(int));\n        if (new_fds == NULL) {\n            return -1;  // Expansion failed due to memory allocation error\n        }\n\n        // Initialize new slots as empty\n        for (int i = old_size; i < new_size; i++) {\n            new_fds[i] = -1;\n        }\n\n        // Update structure with new data\n        fdt->fds = new_fds;\n        fdt->size = new_size;\n\n        // Return the first new slot\n        return old_size;\n    }\n\n    // Expansion wasn't possible because we hit MAX_FDS\n    return -1;  \n}\n\nint main() {\n    // Example of using the fd_slot_alloc function\n    struct dfs_fdtable fdt;\n    fdt.size = 5;\n    fdt.fds = malloc(fdt.size * sizeof(int));\n    for (int i = 0; i < fdt.size; i++) {\n        fdt.fds[i] = -1;  // Initialize all slots as empty\n    }\n\n    int slot = fd_slot_alloc(&fdt, 0);\n    if (slot != -1) {\n        printf(\"Allocated slot at index: %d\\n\", slot);\n        fdt.fds[slot] = 1;  // Imitating fd allocation\n    } else {\n        printf(\"Failed to allocate a slot\\n\");\n    }\n\n    // Cleanup\n    free(fdt.fds);\n\n    return 0;\n}", "CodeBleu_score": 39.276420874093546}, {"code": "#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#define MAX_FD 1024  // Example maximum for file descriptors\n\nstruct dfs_fdtable {\n    bool *fds;  // Array to indicate whether fd slot is used or not\n    int size;   // Current number of slots in the fd table\n};\n\n/**\n * Internal helper function to expand the file descriptor table.\n * Returns true if successful, false otherwise.\n */\nstatic bool expand_fdtable(struct dfs_fdtable *fdt) {\n    if (fdt->size >= MAX_FD) {\n        return false;  // Cannot expand beyond maximum limit\n    }\n    \n    int newSize = fdt->size * 2;\n    if (newSize > MAX_FD) {\n        newSize = MAX_FD;\n    }\n\n    bool *new_fds = (bool *)realloc(fdt->fds, newSize * sizeof(bool));\n    if (!new_fds) {\n        return false;  // Expansion failed due to memory allocation error\n    }\n\n    // Initialize the new slots as 'false' (empty)\n    for (int i = fdt->size; i < newSize; i++) {\n        new_fds[i] = false;\n    }\n\n    fdt->fds = new_fds;\n    fdt->size = newSize;\n    return true;\n}\n\n/**\n * Allocates an empty file descriptor (fd) slot in the file descriptor table.\n * It searches for an empty slot starting from the specified index.\n * If no empty slot is found, it attempts to expand the fd table.\n * Returns the index of the allocated slot or -1 if expansion fails.\n */\nstatic int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd) {\n    // Ensure starting point is within current bounds\n    if (startfd < 0) {\n        startfd = 0;\n    }\n\n    // Search for an available slot starting from startfd\n    for (int i = startfd; i < fdt->size; i++) {\n        if (!fdt->fds[i]) {\n            fdt->fds[i] = true;  // Mark the slot as used\n            return i;\n        }\n    }\n\n    // If no slot was found, attempt to expand the table\n    if (expand_fdtable(fdt)) {\n        // After expansion, continue the search from where it left off\n        for (int i = startfd; i < fdt->size; i++) {\n            if (!fdt->fds[i]) {\n                fdt->fds[i] = true;  // Mark the slot as used\n                return i;\n            }\n        }\n    }\n\n    // If unable to expand, return error code\n    return -1;\n}", "CodeBleu_score": 38.01253009826231}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "#include <stddef.h>\n\ntypedef int rt_err_t;\n\n// Placeholder for a list of error strings aligned with error codes.\nstatic const char *error_strings[] = {\n    \"EOK\",        // 0\n    \"EPERM\",      // 1\n    \"ENOENT\",     // 2\n    \"ESRCH\",      // 3\n    \"EINTR\",      // 4\n    \"EIO\",        // 5\n    \"ENXIO\",      // 6\n    \"E2BIG\",      // 7\n    \"ENOEXEC\",    // 8\n    \"EBADF\",      // 9\n    \"ECHILD\",     // 10\n    // Add additional mapped errors here\n};\nstatic const int num_error_strings = sizeof(error_strings) / sizeof(error_strings[0]);\n\nconst char *rt_strerror(rt_err_t error) {\n    // Ensure the error code is non-negative\n    if (error < 0) {\n        error = -error;\n    }\n\n    // Check if the error code is within the bounds of our list\n    if (error < num_error_strings) {\n        return error_strings[error];\n    }\n\n    // Return a default string if the error code isn't known\n    return \"EUNKNOWN\";\n}", "CodeBleu_score": 32.894601792392216}, {"code": "#include <stddef.h>\n\n// Example error codes as enum, assuming `rt_err_t` is some integer type (often an enum)\ntypedef enum {\n    RT_SUCCESS = 0, // No error\n    RT_FAIL = 1,    // Generic failure\n    RT_MEMERR = 2,  // Memory error\n    RT_TIMEOUT = 3, // Timeout error\n    // Add more specific error codes as needed\n    RT_MAX_ERRORS   // Gives the count of error messages\n} rt_err_t;\n\n// Corresponding error strings for the error codes\nconst char *error_strings[] = {\n    \"Success\",           // RT_SUCCESS\n    \"Generic Failure\",   // RT_FAIL\n    \"Memory Error\",      // RT_MEMERR\n    \"Timeout Error\",     // RT_TIMEOUT\n    // Additional error strings corresponding to the enum above\n};\n\nconst char *rt_strerror(rt_err_t error) {\n    // Ensure error code is positive\n    error = (error < 0) ? -error : error;\n    \n    // Check it's within range of known error codes\n    if (error < RT_MAX_ERRORS) {\n        return error_strings[error];\n    } else {\n        return \"EUNKNOW\";\n    }\n}", "CodeBleu_score": 26.389215443758673}, {"code": "// Assuming the list of error strings and maximum known error code are defined as:\n#include <stddef.h>\n\ntypedef int rt_err_t;\n\n// Minimum and maximum error codes\n#define RT_ERR_MIN 0\n#define RT_ERR_MAX 4\n\n// Error messages corresponding to error codes\nconst char *error_strings[] = {\n    \"Success\",                 // Corresponds to error code 0\n    \"Invalid Argument\",        // Corresponds to error code 1\n    \"Timeout\",                 // Corresponds to error code 2\n    \"Out of Memory\",           // Corresponds to error code 3\n    \"Device Not Found\"         // Corresponds to error code 4\n};\n\nconst char *rt_strerror(rt_err_t error) {\n    // Convert error to a positive value if it's negative\n    if (error < 0) {\n        error = -error;\n    }\n\n    // Check if error is within the range of known errors\n    if (error >= RT_ERR_MIN && error <= RT_ERR_MAX) {\n        return error_strings[error];\n    }\n\n    // Return \"Unknown Error\" if the error code is not within the range\n    return \"Unknown Error\";\n}", "CodeBleu_score": 30.47872475846215}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "#include <stdint.h>\n\n// Assuming constants RT_EOK and -RT_EFULL are predefined in the corresponding RTOS headers\n#define RT_EOK 0\n#define RT_EFULL -1\n\n// Max number of hooks that can be installed\n#define MAX_IDLE_HOOKS 10\n\n// Declaration of the idle hook list array\nstatic void (*idle_hooks[MAX_IDLE_HOOKS])(void) = {NULL};\n// Function to acquire a spinlock\nvoid spinlock_acquire(void);\n// Function to release a spinlock\nvoid spinlock_release(void);\n\n// Function to set an idle hook\nrt_err_t rt_thread_idle_sethook(void (*hook)(void)) {\n    if (hook == NULL) {\n        return -2; // Invalid function pointer\n    }\n    \n    spinlock_acquire(); // Lock the spinlock to ensure thread safety\n\n    // Iterate through the hook list to find an empty slot\n    for (int i = 0; i < MAX_IDLE_HOOKS; i++) {\n        if (idle_hooks[i] == NULL) {\n            idle_hooks[i] = hook; // Assign the hook to the empty slot\n            spinlock_release(); // Release the spinlock\n            return RT_EOK; // Return success code\n        }\n    }\n\n    spinlock_release(); // Release the spinlock if no empty slot is found\n    return RT_EFULL; // Return error code indicating that all hook slots are full\n}", "CodeBleu_score": 38.20048627439402}, {"code": "#include <rtthread.h>\n\n#define RT_HOOK_LIST_SIZE  8       // Placeholder for the maximum number of idle hooks allowed\n#define RT_EOK             0       // Error code for successful operation\n#define RT_EFULL           -1      // Error code indicating the hook list is full\n\nstatic void (*idle_hook_list[RT_HOOK_LIST_SIZE])(void) = {0}; // Idle hook list initialized to NULL\nstatic rt_spinlock_t idle_hook_lock;  // Spinlock for thread safety\n\nvoid rt_thread_idle_init(void)\n{\n    rt_spin_lock_init(&idle_hook_lock);\n}\n\nrt_err_t rt_thread_idle_sethook(void (*hook)(void))\n{\n    rt_err_t result = RT_EFULL; // Default return is that the hook list is full\n    rt_base_t level;\n\n    if (!hook)\n        return -RT_ERROR; // Return error if hook is NULL\n\n    level = rt_spin_lock_irqsave(&idle_hook_lock); // Acquire spinlock, saving interrupt state\n\n    // Iterate through the hook list to find an empty slot\n    for (int i = 0; i < RT_HOOK_LIST_SIZE; i++) {\n        if (idle_hook_list[i] == NULL) {\n            idle_hook_list[i] = hook;  // Assign the hook to the empty slot\n            result = RT_EOK;           // Set success as the result\n            break;                     // Exit the loop as we have placed the hook\n        }\n    }\n\n    rt_spin_unlock_irqrestore(&idle_hook_lock, level); // Release spinlock, restoring interrupt state\n    \n    return result; // Return the result, either RT_EOK or RT_EFULL\n}", "CodeBleu_score": 51.87853945331915}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))\n\u5206\u6790\u5931\u8d25", "CodeBleu_score": 4.166666666666666}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "#include <rtthread.h>\n#include <rthw.h>\n\n// Assuming MAX_IDLE_HOOKS is defined somewhere representing the maximum number of idle hooks.\n#define MAX_IDLE_HOOKS 10\n\nstatic void (*idle_hook_list[MAX_IDLE_HOOKS])() = {0}; // Array to store the hooks\nstatic rt_spinlock_t idle_hook_lock; // Spinlock for thread safety\n\nrt_err_t rt_thread_idle_delhook(void (*hook)(void)) {\n    rt_base_t level;\n    int i;\n\n    // Lock the spinlock\n    level = rt_hw_interrupt_disable(); // Disable interrupts and acquire lock\n    rt_spin_lock(&idle_hook_lock);\n\n    // Iterate through the idle hook list\n    for (i = 0; i < MAX_IDLE_HOOKS; i++) {\n        if (idle_hook_list[i] == hook) {\n            // Set the corresponding entry to null\n            idle_hook_list[i] = RT_NULL;\n\n            // Unlock the spinlock\n            rt_spin_unlock(&idle_hook_lock);\n            rt_hw_interrupt_enable(level); // Re-enable interrupts\n\n            return RT_EOK; // Return success code\n        }\n    }\n\n    // Unlock the spinlock\n    rt_spin_unlock(&idle_hook_lock);\n    rt_hw_interrupt_enable(level); // Re-enable interrupts\n\n    return -RT_ENOSYS; // Return error code if hook not found\n}", "CodeBleu_score": 56.12330362179687}, {"code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define RT_EOK 0            // Success code\n#define RT_ERROR -1         // General error code\n#define RT_ENOSYS -2        // Operation not supported code\n\n#define MAX_IDLE_HOOKS 10   // Assuming there's a limit on the number of hooks that can be installed\n\nvoid (*idle_hooks[MAX_IDLE_HOOKS])(void); // Array of function pointers for hooks\nbool spinlock = false;                   // Spinlock simulation (not real spinlock)\n\n// Lock the spinlock\nvoid spin_lock(bool *lock) {\n    // Simple spin lock implementation (not suitable for actual multi-threaded environments)\n    while (__sync_lock_test_and_set(lock, true)) {\n        // busy-wait\n    }\n}\n\n// Unlock the spinlock\nvoid spin_unlock(bool *lock) {\n    __sync_lock_release(lock);\n}\n\n// Function to remove a hook from the idle hook list\nrt_err_t rt_thread_idle_delhook(void (*hook)(void)) {\n    rt_err_t result = RT_ENOSYS; // Start with an error code indicating that the hook is not found\n\n    // Lock the spinlock for thread safety\n    spin_lock(&spinlock);\n\n    // Iterate through the hook list to find and remove the specified hook\n    for (int i = 0; i < MAX_IDLE_HOOKS; i++) {\n        if (idle_hooks[i] == hook) {\n            idle_hooks[i] = NULL; // Set the hook to NULL if found\n            result = RT_EOK;      // Update result to indicate success\n            break;\n        }\n    }\n\n    // Unlock the spinlock\n    spin_unlock(&spinlock);\n\n    // Return the result\n    return result;\n}\n\nint main() {\n    // Assuming we have an example hook function for demonstration\n    void exampleHook(void) {\n        printf(\"Idle hook running\\n\");\n    }\n\n    // Install exampleHook into the idle hook list for demonstration purposes (not implemented here)\n    for (int i = 0; i < MAX_IDLE_HOOKS; i++) {\n        if (idle_hooks[i] == NULL) {\n            idle_hooks[i] = exampleHook;\n            break;\n        }\n    }\n\n    // Attempt to delete the hook\n    rt_err_t res = rt_thread_idle_delhook(exampleHook);\n    if (res == RT_EOK) {\n        printf(\"Hook successfully removed.\\n\");\n    } else if (res == RT_ENOSYS) {\n        printf(\"Hook not found.\\n\");\n    } else {\n        printf(\"Error in removing the hook.\\n\");\n    }\n\n    return 0;\n}", "CodeBleu_score": 47.11096812996669}, {"code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define RT_EOK 0\n#define RT_ERROR -1\n\ntypedef int rt_err_t;\n\n// Assuming a reasonable maximum number of idle hooks\n#define MAX_IDLE_HOOKS 10\n\nvoid (*idle_hooks[MAX_IDLE_HOOKS]) (void) = {NULL};  // Array to store hooks\nint spinlock = 0;  // Simplified spinlock\n\n// Function to lock the spinlock\nvoid lock_spinlock(int *lock) {\n    while (__sync_lock_test_and_set(lock, 1)) {\n        // Busy wait\n    }\n}\n\n// Function to unlock the spinlock\nvoid unlock_spinlock(int *lock) {\n    __sync_lock_release(lock);\n}\n\n/**\n * Removes a specified hook from the idle hook list.\n * It locks the spinlock to ensure thread safety and iterates through the idle hook list to find the specified hook.\n * If found, it sets the corresponding entry to NULL and returns a success code (RT_EOK).\n * If the hook is not found, it returns an error code (RT_ERROR) indicating that the operation is not supported.\n * Finally, it unlocks the spinlock and returns the result.\n */\nrt_err_t rt_thread_idle_delhook(void (*hook)(void)) {\n    if (hook == NULL) {\n        return RT_ERROR;\n    }\n\n    rt_err_t result = RT_ERROR;\n    lock_spinlock(&spinlock);\n\n    for (int i = 0; i < MAX_IDLE_HOOKS; i++) {\n        if (idle_hooks[i] == hook) {\n            idle_hooks[i] = NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    unlock_spinlock(&spinlock);\n    return result;\n}\n\n// Example hook for testing\nvoid sample_hook(void) {\n    printf(\"Sample hook executed\\n\");\n}\n\nint main() {\n    // Simulate adding hooks manually\n    idle_hooks[0] = sample_hook;\n    idle_hooks[1] = NULL;\n\n    // Trying to remove an existing hook\n    if (rt_thread_idle_delhook(sample_hook) == RT_EOK) {\n        printf(\"Hook removed successfully.\\n\");\n    } else {\n        printf(\"Failed to remove hook.\\n\");\n    }\n\n    // Trying to remove a non-existing hook\n    if (rt_thread_idle_delhook(sample_hook) == RT_EOK) {\n        printf(\"Hook removed successfully.\\n\");\n    } else {\n        printf(\"Failed to remove hook; not found.\\n\");\n    }\n\n    return 0;\n}", "CodeBleu_score": 42.65044570432095}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "#include <stddef.h> // for NULL definition\n\n/* Assume definitions similar to below exist in the RTOS */\ntypedef int rt_err_t;\ntypedef struct rt_list {\n    struct rt_list *next;         /* point to next node. */\n    struct rt_list *prev;         /* point to prev node. */\n} rt_list_t;\n\ntypedef struct rt_thread {\n    rt_list_t tlist;              /* the list node in thread list */\n    /* other thread management fields */\n} rt_thread_t;\n\n/* Error codes */\n#define RT_EOK 0                  /* No error */\n\n/* Function Prototypes - Assuming these would exist in the RTOS API being used */\nvoid rt_scheduler_lock(void);\nvoid rt_scheduler_unlock(void);\nvoid rt_thread_resume(rt_thread_t *thread);\nint rt_list_isempty(const rt_list_t *list);\nvoid rt_list_remove(rt_list_t *node);\n\nrt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error) {\n    if (susp_list == NULL) {\n        return -1;  // Or some error code indicating invalid input\n    }\n\n    rt_scheduler_lock();  // Lock the scheduler\n\n    /* Traverse through all entries in the suspension list and resume each thread */\n    while (!rt_list_isempty(susp_list)){\n        rt_list_t *node = susp_list->next; // Get the first node in the list\n        rt_thread_t *thread = rt_list_entry(node, rt_thread_t, tlist); // container_of pattern to get the thread struct from the list node\n\n        /* Remove the node from the list before resuming, to avoid list corruption */\n        rt_list_remove(node);\n\n        /* Resume the thread, passing along any error code if necessary; assuming function signature might allow this */\n        rt_thread_resume(thread);\n    }\n\n    rt_scheduler_unlock();  // Unlock the scheduler\n\n    return RT_EOK;  // Return RT_EOK indicating successful completion\n}", "CodeBleu_score": 27.638244563388348}, {"code": "#include \"rtthread.h\"\n\n/*\n * The function \"rt_susp_list_resume_all\" resumes all threads in a given suspension list.\n * It starts by ensuring the scheduler is unlocked and then dequeues and wakes up each suspended\n * thread from the list one by one until the list is empty.\n * It returns RT_EOK to indicate successful completion.\n */\nrt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error) {\n    // Ensure scheduler is unlocked\n    rt_enter_critical();  // Lock scheduler to manipulate threads safely\n    rt_thread_t *thread;\n    \n    // While the suspension list is not empty\n    while (!rt_list_isempty(susp_list)) {\n        // Get the first thread in the suspension list\n        rt_list_t *node = rt_list_remove_first(susp_list);\n        // Get the thread container from the list node\n        thread = rt_list_entry(node, rt_thread_t, tlist);\n\n        // Set the thread error status\n        thread->error = thread_error;\n\n        // Wake up the thread\n        rt_thread_resume(thread);\n    }\n\n    // Unlock scheduler after operations\n    rt_exit_critical();\n\n    return RT_EOK; // Indicate successful completion\n}", "CodeBleu_score": 32.2142305211908}, {"code": "#include \"rtthread.h\"\n\n/*\n * Resumes all threads in a given suspension list.\n * This function ensures the scheduler is unlocked, then dequeues and wakes up each suspended thread from the list one by one until the list is empty.\n * @param susp_list Pointer to the suspension list containing the threads to be resumed.\n * @param thread_error Error code to set for each thread when resuming.\n * @return Returns RT_EOK indicating successful completion.\n */\nrt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)\n{\n    rt_thread_t *thread;\n    rt_list_t *node;\n\n    /* Lock the scheduler to ensure thread-safe list operations */\n    rt_enter_critical();\n\n    /* Iterate through each node in the list, remove it, and resume the thread */\n    while (!rt_list_isempty(susp_list))\n    {\n        /* Get the first thread in the suspension list */\n        node = rt_list_remove(susp_list->next);\n        thread = rt_list_entry(node, rt_thread_t, tlist);\n\n        /* Change thread status and set the error code */\n        thread->error = thread_error;\n        thread->stat &= ~RT_THREAD_SUSPEND;\n\n        /* Resume the thread */\n        rt_thread_resume(thread);\n    }\n\n    /* Unlock the scheduler after operations */\n    rt_exit_critical();\n\n    /* Return RT_EOK after successfully resuming all threads */\n    return RT_EOK;\n}", "CodeBleu_score": 33.30762948784229}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name) {\n    // Get the current console device\n    rt_device_t old_device = rt_console_get_device();\n    \n    // Check if the new device name is the same as the current device\n    if (old_device != NULL && strcmp(name, old_device->parent.name) == 0) {\n        // If names are the same, return the current device without changes\n        return old_device;\n    }\n\n    // Find the new console device by its name\n    rt_device_t new_device = rt_device_find(name);\n    if (new_device == NULL) {\n        // If the device is not found, return the old device\n        return old_device;\n    }\n    \n    // Close the current console device if it exists and open the new device\n    if (old_device != NULL) {\n        rt_device_close(old_device);\n    }\n\n    // Open the new console device with both read and write accessibility (assuming flags such as RT_DEVICE_FLAG_RDWR denote this)\n    if (rt_device_open(new_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n        // Set the new console device using a specific RT_Thread API that manages the console device pointer\n        rt_console_set_device(new_device);\n    } else {\n        // If unable to open the new device, restore and reopen the old device\n        if (old_device != NULL) {\n            rt_device_open(old_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        }\n        // Return the old device as setting new device failed\n        return old_device;\n    }\n\n    // Return the old device after the successful setting of the new device\n    return old_device;\n}", "CodeBleu_score": 51.11731562741662}, {"code": "#include <stdio.h>\n#include <string.h>\n\n// Assume these types and functions are defined in the RTOS\ntypedef struct rt_device {\n    char name[20];\n    int flags;\n    // other possible device-specific fields\n} rt_device_t;\n\n// Placeholder for global current console device pointer\nrt_device_t* current_console_device;\n\n// Simulated functions (these would be provided by the RTOS)\nrt_device_t* rt_device_find(const char* name);\nvoid rt_device_close(rt_device_t* device);\nint rt_device_open(rt_device_t* device, int flags);\n\nrt_device_t* rt_console_set_device(const char *name) {\n    if (name == NULL) return NULL;\n\n    // Save the old console device\n    rt_device_t* old_device = current_console_device;\n    \n    // Finding the new device by name\n    rt_device_t* new_device = rt_device_find(name);\n    if (new_device == NULL) {\n        printf(\"Device not found: %s\\n\", name);\n        return old_device; // or return NULL according to error handling policy\n    }\n\n    // Check if the new device is the same as the current device\n    if (new_device == current_console_device) {\n        printf(\"New device is the same as the current console device: %s\\n\", name);\n        return old_device; // no change needed\n    }\n\n    // Valid device and different; close current device if exists\n    if (current_console_device != NULL) {\n        rt_device_close(current_console_device);\n    }\n\n    // Open the new device\n    if (rt_device_open(new_device, /* flags */ O_RDWR | O_STREAM) != 0) {\n        printf(\"Failed to open device: %s\\n\", name);\n        // Restore old device if necessary\n        if (old_device != NULL) {\n            rt_device_open(old_device, O_RDWR | O_STREAM);\n            current_console_device = old_device;\n        }\n        return old_device;\n    }\n\n    // Set the new device as the console device\n    current_console_device = new_device;\n\n    return old_device;\n}", "CodeBleu_score": 54.68840645466542}, {"code": "#include \"rt_device.h\" // Assuming there's a header file where all declarations and relevant types (like `rt_device_t`) are present.\n\nextern rt_device_t current_console_device;   // There should be a global or externally managed variable holding the current console device instance.\n\nrt_device_t rt_console_set_device(const char *name) {\n    if (name == NULL) {\n        return NULL; // Safety check to handle null pointer dereference possibility\n    }\n\n    // Save the current console device.\n    rt_device_t old_device = current_console_device;\n\n    // Find new device by name.\n    rt_device_t new_device = rt_device_find(name);\n    if (new_device == NULL) {\n        return old_device; // Return old device if new one not found.\n    }\n\n    // Check if new device is the same as the current device.\n    if (new_device == old_device) {\n        return old_device; // Return old device if device is not different.\n    }\n\n    // Close the current console device if it exists and is open.\n    if (current_console_device != NULL) {\n        rt_device_close(current_console_device);\n    }\n\n    // Open new console device with necessary flags (for example, read/write and stream).\n    // Note: Flags such as RT_DEVICE_FLAG_RDWR or RT_DEVICE_FLAG_STREAM may or may not exist depending on your specific implementation.\n    if (rt_device_open(new_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM) == RT_EOK) {\n        // Set new device as the current console device.\n        current_console_device = new_device;\n    } else {\n        // Handle unsuccessful open operation, restore old device.\n        current_console_device = old_device;\n        rt_device_open(current_console_device, RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n        return old_device;\n    }\n\n    // Return the old console device.\n    return old_device;\n}", "CodeBleu_score": 54.393505438320865}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "#include <stddef.h> // For NULL\n\n/* Assuming there's a global list that holds all objects of different types */\nextern struct rt_object_container all_objects[];\n\n/* Mock implementation of rt_object and rt_object_container as they are not defined here */\nstruct rt_object {\n    enum rt_object_class_type type;\n    struct rt_object* next; // Pointer to next object in the linked list\n};\n\nstruct rt_object_container {\n    struct rt_object* first_object; // Pointer to the first object in the list of this type\n    pthread_spinlock_t spinlock; // Spinlock for thread safety\n};\n\nint rt_object_get_length(enum rt_object_class_type type) {\n    int count = 0;\n    \n    /* Access the container for the specified type */\n    struct rt_object_container* container = &all_objects[type];\n    \n    /* Lock the spinlock to ensure thread safety */\n    pthread_spin_lock(&(container->spinlock));\n    \n    /* Traverse the list of objects and count them */\n    struct rt_object* current = container->first_object;\n    while (current != NULL) {\n        if (current->type == type) {\n            count++;\n        }\n        current = current->next;\n    }\n    \n    /* Unlock the spinlock after processing */\n    pthread_spin_unlock(&(container->spinlock));\n    \n    /* Return the total count of objects of the specified type */\n    return count;\n}", "CodeBleu_score": 44.61962986234758}, {"code": "#include <linux/spinlock.h>\n\n/* You would need real definitions of these depending on your actual environment */\n\ntypedef enum {\n    RT_OBJECT_TYPE_THREAD,\n    RT_OBJECT_TYPE_SEMAPHORE,\n    RT_OBJECT_TYPE_MUTEX,\n    // add other object types\n} rt_object_class_type;\n\ntypedef struct rt_object {\n    rt_object_class_type type;\n    struct rt_object *next; // Assume objects are linked in some global list\n} rt_object;\n\n/* A real implementation would require real object containers defined elsewhere */\nextern rt_object *global_object_list; \nextern spinlock_t rt_spinlock;\n\nint rt_object_get_length(enum rt_object_class_type type) {\n    rt_object *obj;\n    int count = 0;\n\n    /* Lock the spin lock to protect the global object list */\n    spin_lock(&rt_spinlock);\n\n    /* Iterate through all objects in the global list */\n    for (obj = global_object_list; obj != NULL; obj = obj->next) {\n        if (obj->type == type) {\n            count++; // Increment count if object type matches\n        }\n    }\n\n    /* Release the spinlock */\n    spin_unlock(&rt_spinlock);\n\n    /* Return the count of the objects of the specified type */\n    return count;\n}", "CodeBleu_score": 44.06595246157106}, {"code": "#include <stdint.h>    // For fixed size integer types\n#include <stddef.h>    // For NULL definition\n\n// Assuming the existence of these structures and variables in the system\n// Define a mock object and list structure for illustration purposes only.\ntypedef struct rt_object {\n    struct rt_object* next; // Link to the next object in the list\n    enum rt_object_class_type object_type; \n} rt_object;\n\ntypedef struct rt_list {\n    rt_object* head;  // Pointer to the first object in the list\n} rt_list;\n\n// Mock global list of all objects\nextern rt_list object_list;\n\n// Mock spinlock functions (exact implementation will depend on the specific environment)\nvoid spin_lock(volatile int *lock);\nvoid spin_unlock(volatile int *lock);\n\n// Assuming we have a global lock for object operations\nvolatile int object_list_lock;\n\nint rt_object_get_length(enum rt_object_class_type type) {\n    int count = 0;\n    rt_object* current_object;\n    \n    // Acquire the lock to ensure thread safety while accessing the list\n    spin_lock(&object_list_lock);\n    \n    // Iterate through the list of objects\n    current_object = object_list.head;\n    while (current_object != NULL) {\n        if (current_object->object_type == type) {\n            count++;  // Increment count if the object type matches\n        }\n        current_object = current_object->next;  // Move to the next object in the list\n    }\n    \n    // Release the lock after accessing the list\n    spin_unlock(&object_list_lock);\n    \n    return count;  // Return the count of objects of the specified type\n}\n\n// Mock implementation of spinlock functions\nvoid spin_lock(volatile int *lock) {\n    // Implement locking mechanism, e.g., using TAS (Test-And-Set)\n    while (__sync_lock_test_and_set(lock, 1)) {\n        // Spin wait\n    }\n}\n\nvoid spin_unlock(volatile int *lock) {\n    // Release lock\n    __sync_lock_release(lock);\n}\n\nenum rt_object_class_type {\n    TYPE_A,\n    TYPE_B,\n    // Other types...\n};", "CodeBleu_score": 40.68941273183821}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object) {\n    if (object == NULL) {\n        return;\n    }\n\n    // Call to a predefined hook function for detaching the object\n    // Supposing this hook function must be included or externally defined.\n    rt_object_detach_hook(object);\n\n    // Retrieve the object information structure and lock spinlock\n    rt_base_t level = rt_hw_interrupt_disable();  // Assuming disabling interrupts act as locking the spinlock\n\n    // Remove the object from its list\n    rt_list_remove(&(object->list));\n    \n    // Unlock the spinlock\n    rt_hw_interrupt_enable(level);  // Assuming that restoring previous interrupt state acts as unlocking\n    \n    // Set the object's type to zero (invalid type)\n    object->type = 0;\n}", "CodeBleu_score": 26.763842064024203}, {"code": "#include <assert.h>  // For assert() if needed\n#include \"rtthread.h\"  // Assuming that RT-Thread relevant types and functions are declared here.\n\nvoid rt_object_detach(rt_object_t object) {\n    // Check to ensure the provided object is not null\n    if (object == NULL) {\n        return;  // Can optionally handle error or assert here\n    }\n\n    // Assume there's a function for calling the hook before detaching\n    rt_pre_detach_hook(object);\n    \n    // Retrieve the object's information structure which includes the lock and link pointers\n    rt_object_information_t *info = rt_object_get_information(object->type);\n    \n    // Lock its spinlock to ensure no other thread modifies the object concurrently\n    rt_spin_lock(&(info->lock));\n\n    // Remove the object from its list, ensuring safe removal in thread-safe environment\n    rt_list_remove(&(object->list));\n\n    // Unlock the spinlock\n    rt_spin_unlock(&(info->lock));\n \n    // Option to call a hook after detachment, if required\n    rt_post_detach_hook(object);\n\n    // Set the object's type to zero\n    object->type = RT_Object_Class_Null;\n  \n    // Optionally, you can notify about successful detachment\n}", "CodeBleu_score": 43.64013801118807}, {"code": "#include \"rtthread.h\"  // Assumed necessary for including rt-object-related definitions and functions, adjust the include if the actual environment differs.\n\nvoid rt_object_detach(rt_object_t object) {\n    // NULL check for the passed object\n    if (object == NULL) {\n        return; // If object is NULL, exit the function as no operation should be performed.\n    }\n    \n    // Call detach hook if it exists.\n    if (rt_object_detach_hook != NULL) {\n        rt_object_detach_hook(object);\n    }\n    \n    // Retrieve object information and lock the spinlock\n    rt_base_t level = rt_hw_interrupt_disable(); // Disabling interrupt to implement lock (using spinlock or alike might depend on actual environment)\n\n    // Safety check to ensure the object is indeed on a list before attempting to remove it.\n    if (object->list.next != NULL) {\n        // Remove the object from the list it is attached to\n        rt_list_remove(&(object->list));\n    }\n\n    // Unlock spinlock\n    rt_hw_interrupt_enable(level); // Re-enable interrupts\n    \n    // Set the type of object to zero, essentially \"detaching\" or \"invalidating\" it\n    object->type = 0;\n}", "CodeBleu_score": 36.162200729284535}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "#include <stddef.h>  // for NULL\n\ntypedef enum {\n    RT_EOK = 0,       /* No Error */\n    RT_EINVAL = -1,   /* Invalid Error */\n} rt_err_t;\n\ntypedef struct {\n    void* (*destroy)(void);\n    const char* type;\n} rt_object_t;\n\n#define CUSTOM_OBJECT_TYPE \"CustomObject\"\n\nrt_err_t rt_custom_object_destroy(rt_object_t* obj) {\n    // Step 1: Check if the object is valid\n    if (obj == NULL) {\n        return RT_EINVAL;\n    }\n\n    // Step 2: Check if it is of the correct object type\n    if (obj->type == NULL || strcmp(obj->type, CUSTOM_OBJECT_TYPE) != 0) {\n        return RT_EINVAL;\n    }\n\n    // Step 3 and Step 5: If there's a destroy method, call it and store its result\n    rt_err_t destroy_result = RT_EOK;\n    if (obj->destroy != NULL) {\n        void* result = obj->destroy();\n        destroy_result = (result == NULL) ? RT_EOK : RT_EINVAL;\n    }\n\n    // Step 4: 'Delete' the object - Since it's C, we typically free the memory\n    free(obj);\n    obj = NULL;\n\n    return destroy_result;\n}", "CodeBleu_score": 40.82995572336671}, {"code": "#include <stdlib.h> \n\n/* Define return types for easier management */\ntypedef enum {\n    RT_ERR_OK,\n    RT_ERR_INVALID,\n    RT_ERR_WRONG_TYPE\n} rt_err_t;\n\n/* Define a mock struct for demonstration */\ntypedef struct rt_object {\n    void *object;\n    const char *type;\n    rt_err_t (*destroy)(struct rt_object *obj);\n} rt_object_t;\n\n/* Define a custom method to destroy the object, provided in the structure */\nrt_err_t custom_destroy_method(rt_object_t *obj) {\n    if (obj->object) {\n        free(obj->object);\n        obj->object = NULL;\n        return RT_ERR_OK;\n    }\n    return RT_ERR_INVALID;\n}\n\n/* Implementation of the actual function as described in the comment */\nrt_err_t rt_custom_object_destroy(rt_object_t *obj) {\n    if (obj == NULL) {\n        return RT_ERR_INVALID;\n    }\n    \n    if (obj->type == NULL || strcmp(obj->type, \"CustomObject\") != 0) {\n        return RT_ERR_WRONG_TYPE;\n    }\n    \n    rt_err_t result = RT_ERR_OK;\n    if (obj->destroy != NULL) {\n        result = obj->destroy(obj);\n    } else {\n        free(obj->object);\n        obj->object = NULL;\n    }\n    \n    free(obj);\n    return result;\n}", "CodeBleu_score": 42.449209122296416}, {"code": "#include <stdbool.h>\n#include <stdlib.h>\n\n// Define error codes\ntypedef enum {\n    RT_ERR_OK = 0,\n    RT_ERR_INVALID,\n    RT_ERR_NOT_CUSTOM_OBJ,\n    RT_ERR_DELETE_FAIL\n} rt_err_t;\n\n// Definition of object types\ntypedef enum {\n    RT_OBJ_TYPE_DEFAULT,\n    RT_OBJ_TYPE_CUSTOM\n} rt_object_type_t;\n\n// Sample object structure\ntypedef struct {\n    rt_object_type_t type;\n    bool (*destroy)(void*); // pointer to the destroy function; returns true on successful destroy\n} rt_object_t;\n\n// Function to check if the object is valid\nbool is_valid_rt_object(rt_object_t* obj) {\n    return obj != NULL && obj->type == RT_OBJ_TYPE_CUSTOM;\n}\n\n// The rt_custom_object_destroy function destroys a custom RT object\nrt_err_t rt_custom_object_destroy(rt_object_t* obj) {\n    if (!obj) {\n        return RT_ERR_INVALID;\n    }\n\n    if (obj->type != RT_OBJ_TYPE_CUSTOM) {\n        return RT_ERR_NOT_CUSTOM_OBJ;\n    }\n\n    bool destroy_result = true;\n    // Check if the destroy method exists, then call it\n    if (obj->destroy) {\n        destroy_result = obj->destroy(obj);\n    }\n\n    // Simulate deleting the object\n    free(obj);\n    obj = NULL; // Ensure the pointer is cleared after deletion\n\n    // Return appropriate error based on destruction success\n    return destroy_result ? RT_ERR_OK : RT_ERR_DELETE_FAIL;\n}", "CodeBleu_score": 41.29014076411529}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "#include <stddef.h>\n\n/* Assuming these functions or structures are defined elsewhere in the codebase */\nextern void enter_critical_section();\nextern void exit_critical_section();\nextern void add_to_defunct_thread_list(void *thread);\nextern void *get_current_thread();\nextern void close_thread(void *thread);\nextern void schedule_next_task();\n\nstatic void _thread_exit(void) {\n    /* Retrieve the current thread */\n    void *current_thread = get_current_thread();\n\n    /* Enter critical section to prevent race conditions */\n    enter_critical_section();\n    \n    /* Close the thread, marking it as no longer schedulable */\n    close_thread(current_thread);\n    \n    /* Add the thread to the list of threads that are defunct */\n    add_to_defunct_thread_list(current_thread);\n    \n    /* Exit the critical section */\n    exit_critical_section();\n\n    /* Trigger a context switch to the next task */\n    schedule_next_task();\n}", "CodeBleu_score": 51.513512690759896}, {"code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Assuming we have a thread struct and related functions defined elsewhere as per OS requirements.\ntypedef struct thread {\n    int thread_id;\n    int is_active;\n    struct thread* next;\n} thread_t;\n\n// Global variables for simplicity. In actual OS code, these would likely be part of a thread manager or similar structure.\nthread_t* current_thread = NULL;\nthread_t* defunct_thread_list = NULL;\n\n// Function prototypes\nthread_t* get_current_thread();\nvoid enter_critical_section();\nvoid exit_critical_section();\nvoid scheduler();\nvoid add_to_defunct_thread_list(thread_t* thread);\n\n// Simulated function to retrieve the current thread. In a real environment, this would interface with the thread manager.\nthread_t* get_current_thread() {\n    // Dummy implementation, return the global current_thread\n    return current_thread;\n}\n\n// Simulated function to enter a critical section\nvoid enter_critical_section() {\n    printf(\"Entered critical section.\\n\");\n}\n\n// Simulated function to exit a critical section\nvoid exit_critical_section() {\n    printf(\"Exited critical section.\\n\");\n}\n\n// Simulated function to trigger the scheduler\nvoid scheduler() {\n    printf(\"Scheduler triggered.\\n\");\n}\n\n// Simulated function to add a thread to the defunct thread list\nvoid add_to_defunct_thread_list(thread_t* thread) {\n    thread->next = defunct_thread_list;\n    defunct_thread_list = thread;\n    printf(\"Thread %d added to defunct thread list.\\n\", thread->thread_id);\n}\n\n// Implementation of the _thread_exit function as described\nstatic void _thread_exit(void) {\n    // Retrieve the current thread\n    thread_t* thread = get_current_thread();\n    \n    // Critical section start\n    enter_critical_section();\n\n    // Mark the thread as inactive or ready to shutdown\n    thread->is_active = 0;\n\n    // Close the thread resources, if any (here we simply mark the thread and move it to a defunct list)\n    add_to_defunct_thread_list(thread);\n\n    // Critical section end\n    exit_critical_section();\n\n    // Trigger a scheduler to handle context switch\n    scheduler();\n}\n\n// Main function to simulate behavior (omit in actual implementation)\nint main() {\n    // Simulate thread initialization\n    current_thread = malloc(sizeof(thread_t));\n    current_thread->thread_id = 1;\n    current_thread->is_active = 1;\n\n    // Simulate thread exit\n    _thread_exit();\n\n    free(current_thread);\n    return 0;\n}", "CodeBleu_score": 47.69002813497023}, {"code": "#include <stdio.h>\n\n// Assuming some external or previously defined structures and functions exist:\n// Definitions for `thread_t`, `scheduler_next_task`, `enter_critical_section`, and `exit_critical_section`.\ntypedef struct thread {\n    int id;\n    struct thread* next; // for linked list\n} thread_t;\n\n// Global variable representing the current thread\nthread_t* current_thread = NULL;\n\n// Linked list head for defunct threads\nthread_t* defunct_thread_list = NULL;\n\n// Prototype for an assumed function that handles context switching\nvoid scheduler_next_task(void);\n\n// Prototypes for critical section utilities\nvoid enter_critical_section(void);\nvoid exit_critical_section(void);\n\n// Function to add a thread to the defunct list\nvoid add_to_defunct_list(thread_t* thread) {\n    thread->next = defunct_thread_list;\n    defunct_thread_list = thread;\n}\n\nstatic void _thread_exit(void) {\n    if (!current_thread) {\n        printf(\"No current thread to exit.\\n\");\n        return;\n    }\n\n    enter_critical_section(); // Enter critical section\n\n    // Log exiting thread\n    printf(\"Exiting thread %d\\n\", current_thread->id);\n\n    // Add the thread to the defunct list\n    add_to_defunct_list(current_thread);\n\n    // Nothing else is done with the current thread here. Assuming it's cleared or reused later\n    current_thread = NULL; // Clear current thread\n\n    exit_critical_section(); // Exit critical section\n    \n    // Call the scheduler to switch to the next task\n    scheduler_next_task();\n}\n\n// Mock function implementation for the scheduler to change context\nvoid scheduler_next_task(void) {\n    printf(\"Switching to the next available thread/task.\\n\");\n    // Logic to switch to next task would happen here\n}\n\n// Mock function implementations - stubs for critical section management\nvoid enter_critical_section(void) {\n    // OS-specific or platform-specific code to disable interrupts or similar to enter a critical section\n    printf(\"Entered critical section.\\n\");\n}\n\nvoid exit_critical_section(void) {\n    // OS-specific or platform-specific code to enable interrupts or similar to exit a critical section\n    printf(\"Exited critical section.\\n\");\n}\n\nint main() {\n    // Mock setup for demonstration\n    thread_t thread1 = {1, NULL};\n    current_thread = &thread1;\n\n    _thread_exit(); // Simulation of exiting the thread\n\n    return 0;\n}", "CodeBleu_score": 47.36461363928724}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "#include <stdbool.h>\n#include <stddef.h>\n\n// Assume these are defined elsewhere in your system\nextern void lock_scheduler();\nextern void unlock_scheduler();\nextern bool is_thread_suspended(void* thread);\nextern void remove_thread_from_suspend_list(void* thread);\nextern void insert_thread_into_ready_list(void* thread);\nextern int ERR_TIMEOUT;  // Error code for timeout, assumed to be defined elsewhere\n\n// This represents a basic thread structure\ntypedef struct {\n    int error_num;  // Error number indicating why the thread was woken up\n    // Add other thread-related states and properties tailored to your system\n} Thread;\n\nstatic void _thread_timeout(void *parameter) {\n    if (parameter == NULL) {\n        return; // Handle NULL pointer to ensure safety\n    }\n    \n    Thread* thread = (Thread*) parameter;\n    \n    lock_scheduler(); // Lock the scheduler to avoid race conditions\n\n    if (!is_thread_suspended(thread)) {\n        unlock_scheduler(); // Unlock scheduler if the thread is not suspended\n        return; // Early return if thread is not actually suspended\n    }\n\n    thread->error_num = ERR_TIMEOUT; // Set timeout error number\n\n    remove_thread_from_suspend_list(thread); // Move thread out of suspended list\n    insert_thread_into_ready_list(thread); // Move thread into ready list to make it available for scheduling\n\n    unlock_scheduler(); // Unlock the scheduler after modifying thread and list states\n    \n    // Optionally: Trigger scheduler to consider newly readied thread\n}\n\n// Mock definitions of external functions if they are not implemented\nvoid lock_scheduler() {\n    // Implementation absent\n}\n\nvoid unlock_scheduler() {\n    // Implementation absent\n}\n\nbool is_thread_suspended(void* thread) {\n    // Placeholder return value for compilation purposes\n    return true;\n}\n\nvoid remove_thread_from_suspend_list(void* thread) {\n    // Placeholder for actual implementation\n}\n\nvoid insert_thread_into_ready_list(void* thread) {\n    // Placeholder for actual implementation\n}", "CodeBleu_score": 34.37556037973868}, {"code": "#include <stddef.h>\n#include <pthread.h>\n#include <errno.h>\n\n// Assuming thread control block structure\ntypedef struct thread {\n    int is_suspended;\n    int errno;\n    struct thread* prev_suspended;\n    struct thread* next_suspended;\n    struct thread* prev_ready;\n    struct thread* next_ready;\n    // Add other members as necessary, for instance the pthread_t identifier, etc.\n} thread_t;\n\n// Assuming global linked lists for scheduling\nthread_t *suspend_list_head = NULL; // linked list of suspended threads\nthread_t *ready_list_head = NULL; // linked list of ready threads\n\n// Function prototypes\nvoid remove_from_list(thread_t **head, thread_t *t);\nvoid insert_into_list(thread_t **head, thread_t *t);\nvoid lock_scheduler();\nvoid unlock_scheduler();\nvoid reschedule();\n\nstatic void _thread_timeout(void *parameter) {\n    if (parameter == NULL) {\n        return;\n    }\n    \n    // Cast input parameter to thread type\n    thread_t *thread = (thread_t *)parameter;\n\n    // Lock the scheduler to prevent concurrency issues\n    lock_scheduler();\n\n    // Validate if the thread is in suspended state\n    if (!thread->is_suspended) {\n        unlock_scheduler();\n        return;  // Thread is not suspended, exit the function\n    }\n\n    // Set thread's error number to ETIMEDOUT\n    thread->errno = ETIMEDOUT;\n\n    // Remove thread from the suspend list\n    remove_from_list(&suspend_list_head, thread);\n\n    // Insert thread into the ready list\n    insert_into_list(&ready_list_head, thread);\n\n    // Thread is no longer suspended\n    thread->is_suspended = 0;\n\n    // Unlock the scheduler to allow other operations\n    unlock_scheduler();\n\n    // Ideally, some form of rescheduling should be triggered here\n    reschedule();\n}\n\nvoid remove_from_list(thread_t **head, thread_t *t) {\n    if (t->prev_suspended != NULL) {\n        t->prev_suspended->next_suspended = t->next_suspended;\n    } else {\n        *head = t->next_suspended;\n    }\n    if (t->next_suspended != NULL) {\n        t->next_suspended->prev_suspended = t->prev_suspended;\n    }\n    t->next_suspended = NULL;\n    t->prev_suspended = NULL;\n}\n\nvoid insert_into_list(thread_t **head, thread_t *t) {\n    t->next_ready = *head;\n    if (*head != NULL) {\n        (*head)->prev_ready = t;\n    }\n    *head = t;\n    t->prev_ready = NULL;\n}\n\n// Mock functions to illustrate the example\nvoid lock_scheduler() {\n    // Implement mutex lock or another method depending on OS\n}\n\nvoid unlock_scheduler() {\n    // Implement mutex unlock or another method depending on OS\n}\n\nvoid reschedule() {\n    // Trigger a scheduler/rescheduler\n}", "CodeBleu_score": 30.519457600488348}, {"code": "#include <some_scheduler.h>  // Hypothetical include for accessing scheduler and thread functions\n\nstatic void _thread_timeout(void *parameter) {\n    // Assuming 'Thread' is a struct that represents a thread\n    Thread *thread = (Thread *)parameter;\n\n    if (thread == NULL) {\n        return;  // Parameter check: ensure the thread reference is valid\n    }\n\n    // Lock the scheduler to prevent context switching during modification\n    scheduler_lock();\n\n    if (thread->state == SUSPENDED) {\n        // Verify thread was previously suspended\n        thread->errorNum = ETIMEDOUT;  // Set error number to timeout value (assuming ETIMEDOUT is defined elsewhere)\n        \n        // Remove the thread from the suspend list\n        suspend_list_remove(thread);\n\n        // Insert it into the ready list\n        ready_list_insert(thread);\n\n        // Change thread state to READY\n        thread->state = READY; \n    }\n\n    // Unlock the scheduler and allow rescheduling\n    scheduler_unlock();\n\n    // Optional: Rescheduling might be required here, depends on the system's scheduler design\n    scheduler_reschedule();\n}", "CodeBleu_score": 34.623758263639296}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "#include <stdbool.h>\n\ntypedef struct mutex {\n    // Assuming there's a list of threads waiting for this mutex\n    struct thread_list *waiting_list;\n} rt_mutex_t;\n\ntypedef struct thread {\n    rt_mutex_t *waiting_on_mutex;\n    struct mutex_list *owned_mutexes;\n    int spinlock;  // Representing spinlock as an integer for locking purposes\n} rt_thread_t;\n\nvoid _thread_spin_lock(int *lock);\nvoid _thread_spin_unlock(int *lock);\n\nvoid remove_thread_from_mutex_waiting_list(rt_thread_t *thread, rt_mutex_t *mutex);\nvoid release_owned_mutexes(rt_thread_t *thread);\n\nstatic void _thread_detach_from_mutex(rt_thread_t *thread) {\n    // Lock the thread's spinlock\n    _thread_spin_lock(&thread->spinlock);\n    \n    // Check if the thread is waiting on a mutex\n    if (thread->waiting_on_mutex) {\n        // If waiting, remove from the mutex's waiting list\n        remove_thread_from_mutex_waiting_list(thread, thread->waiting_on_mutex);\n        // Clear the mutex waiting status\n        thread->waiting_on_mutex = NULL;\n    }\n    \n    // Release all mutexes the thread currently holds\n    release_owned_mutexes(thread);\n    \n    // Unlock the thread's spinlock\n    _thread_spin_unlock(&thread->spinlock);\n}\n\nvoid _thread_spin_lock(int *lock) {\n    // Dummy implementation for locking\n    while (__sync_lock_test_and_set(lock, 1)) {\n        // spin wait\n    }\n}\n\nvoid _thread_spin_unlock(int *lock) {\n    __sync_lock_release(lock);\n}\n\nvoid remove_thread_from_mutex_waiting_list(rt_thread_t *thread, rt_mutex_t *mutex) {\n    // Assuming we have a function to remove the thread from a mutex waiting list\n    // actual implementation depends on how the list is managed\n}\n\nvoid release_owned_mutexes(rt_thread_t *thread) {\n    // Iterate through the list of owned mutexes and release them\n    // This code depends heavily on how such a list is managed\n}", "CodeBleu_score": 40.67861335249911}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread) {\n    // Lock the thread's spinlock\n    rt_spin_lock(&thread->spinlock);\n\n    // If the thread is waiting on a mutex\n    if (thread->pending_mutex != NULL) {\n        // Remove the thread from the mutex's waiting list\n        rt_mutex_remove_from_waiting_list(thread->pending_mutex, thread);\n\n        // Clear the pending mutex object\n        thread->pending_mutex = NULL;\n    }\n\n    // Release all mutexes the thread has taken\n    while (!rt_list_empty(&thread->mutex_hold_list)) {\n        rt_mutex_t mutex = rt_list_entry(thread->mutex_hold_list.next, rt_mutex_t, hold_list);\n        rt_mutex_release(mutex);\n    }\n\n    // Restore the spinlock state\n    rt_spin_unlock(&thread->spinlock);\n}", "CodeBleu_score": 33.896906875499205}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread) {\n    // Lock the thread's spinlock\n    rt_spin_lock(&(thread->spinlock));\n\n    // If the thread is waiting on a mutex, remove it from the mutex's waiting list.\n    if (thread->pending_mutex != NULL) {\n        // Assume `rt_mutex_t` is the type for mutexes, and it has a linked list `waiting_list`.\n        rt_mutex_t mutex = thread->pending_mutex;\n        \n        // Remove the thread from the mutex's waiting list.\n        if (mutex->waiting_list == thread) {\n            // If the thread is the first in the list, point the list head to the next element.\n            mutex->waiting_list = thread->waiting_list_next;\n        } else {\n            // If the thread is not the first, find it in the list and remove it.\n            rt_thread_t iter = mutex->waiting_list;\n            while (iter != NULL && iter->waiting_list_next != thread) {\n                iter = iter->waiting_list_next;\n            }\n            if (iter != NULL) {\n                iter->waiting_list_next = thread->waiting_list_next;\n            }\n        }\n        \n        // Clear the pending mutex and waiting list next pointer.\n        thread->pending_mutex = NULL;\n        thread->waiting_list_next = NULL;\n    }\n\n    // Release all mutexes the thread has taken.\n    while (thread->owned_mutexes != NULL) {\n        // Assume each `owned_mutex` struct has a `next` pointer.\n        rt_mutex_t mutex = thread->owned_mutexes;\n        thread->owned_mutexes = mutex->next;\n        \n        // Release the mutex: assumes a hypothetical function for releasing mutex owned by a thread.\n        rt_mutex_release(mutex, thread);  // This function might need to be implemented.\n    }\n\n    // Release the thread's spinlock\n    rt_spin_unlock(&(thread->spinlock));\n}", "CodeBleu_score": 36.63472333492178}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "def rt_thread_startup(thread):\n    \"\"\"\n    Starts a given thread. It first checks that the thread is not None, is in the initialization state, and is of the correct type.\n    It logs the thread's name and priority, calculates its priority attributes, and resets its state to suspended.\n    Finally, it resumes the thread and triggers a scheduler if available, returning RT_EOK upon successful startup.\n\n    Args:\n    thread (rt_thread_t): The thread object to be started.\n\n    Returns:\n    str: Return code 'RT_EOK' if operation is successful, otherwise an appropriate error code.\n    \"\"\"\n    if thread is None:\n        return \"RT_ERROR_NULL\"\n    \n    if not thread.state == \"INIT\" or not hasattr(thread, 'priority'):\n        return \"RT_ERROR_STATE\"\n    \n    print(f\"Starting thread: {thread.name}, Priority: {thread.priority}\")\n    \n    # Calculate priority and other required thread attributes\n    thread.priority_attr = calculate_priority_attribute(thread.priority)\n    \n    # Reset thread state to \"SUSPENDED\"\n    thread.state = \"SUSPENDED\"\n    \n    # Resume the thread\n    result_of_resume = resume_thread(thread)\n    \n    if result_of_resume == \"SUCCESS\":\n        # Trigger the scheduler\n        trigger_scheduler()\n\n        # Set the state to \"RUNNING\"\n        thread.state = \"RUNNING\"\n\n        return \"RT_EOK\"\n    else:\n        return result_of_resume\n\ndef calculate_priority_attribute(priority):\n    # Dummy function for calculating priority attributes; implementation depends on specifics\n    return f\"attr_based_on_{priority}\"\n\ndef resume_thread(thread):\n    # Suppose this function attempts to resume the thread\n    try:\n        # Your thread resuming logic goes here\n        print(f\"Resuming {thread.name}\")\n        return \"SUCCESS\"\n    except Exception as e:\n        print(f\"Failed to resume {thread.name}: {str(e)}\")\n        return \"FAILED_TO_RESUME\"\n\ndef trigger_scheduler():\n    # Dummy scheduler trigger function\n    print(\"Scheduler triggered\")", "CodeBleu_score": 32.071979487655575}, {"code": "#include <stdio.h>\n\ntypedef struct rt_thread {\n    int state;\n    char *name;\n    int priority;\n    int type;\n} rt_thread_t;\n\n#define RT_THREAD_TYPE_CORRECT 0x01\n#define RT_THREAD_INIT 0x00\n#define RT_THREAD_SUSPEND 0x02\n#define RT_EOK 0\n#define RT_ERROR -1\n\n// Placeholder function for setting thread priority attributes\nvoid calculate_priority_attributes(rt_thread_t *thread) {\n    // Implementation specific\n}\n\n// Placeholder function for resuming thread\nvoid rt_thread_resume(rt_thread_t *thread) {\n    // Change state to 'running' or similar, based on system specifics\n    thread->state = 'R'; // Example state: Running\n}\n\n// Placeholder for enabling the scheduler\nvoid trigger_scheduler(void) {\n    // Implementation specific\n}\n\nrt_err_t rt_thread_startup(rt_thread_t *thread) {\n    if (thread == NULL) {\n        return RT_ERROR;\n    }\n    if (thread->state != RT_THREAD_INIT) {\n        return RT_ERROR;\n    }\n    if (thread->type != RT_THREAD_TYPE_CORRECT) {\n        return RT_ERROR;\n    }\n\n    // Log thread's name and priority\n    printf(\"Starting thread: %s with priority: %d\\n\", thread->name, thread->priority);\n\n    // Calculate priority attributes\n    calculate_priority_attributes(thread);\n\n    // Reset state to suspended\n    thread->state = RT_THREAD_SUSPEND;\n\n    // Resume the thread\n    rt_thread_resume(thread);\n\n    // Trigger the scheduler\n    trigger_scheduler();\n\n    return RT_EOK;\n}", "CodeBleu_score": 37.40361067998763}, {"code": "#include <stdio.h>\n\n// Enumeration for error types\ntypedef enum {\n    RT_EOK = 0,        // No error\n    RT_ERROR = 1,      // General error\n    RT_EINVAL = 2,     // Invalid argument\n} rt_err_t;\n\n// Enumeration for thread states\ntypedef enum {\n    RT_THREAD_INIT = 0,\n    RT_THREAD_SUSPENDED,\n    RT_THREAD_RUNNING,\n} rt_thread_state_t;\n\n// Structure to represent a thread\ntypedef struct {\n    char* name;\n    int priority;\n    rt_thread_state_t state;\n    int type;         // Simulated type info (for verification purposes)\n} rt_thread_t;\n\n// Function declarations (placeholders for actual implementations)\nvoid rt_thread_scheduler();\nvoid rt_thread_resume(rt_thread_t* thread);\nvoid calculate_priority_attributes(rt_thread_t* thread);\n\n// Constants for expected types\nconst int RT_THREAD_TYPE_EXPECTED = 1;\n\n// Function to start up a thread\nrt_err_t rt_thread_startup(rt_thread_t* thread) {\n    if (thread == NULL) {\n        return RT_EINVAL;\n    }\n    if (thread->state != RT_THREAD_INIT) {\n        return RT_ERROR;\n    }\n    if (thread->type != RT_THREAD_TYPE_EXPECTED) {\n        return RT_EINVAL;\n    }\n\n    // Log thread information\n    printf(\"Starting thread: %s\\n\", thread->name);\n    printf(\"Thread priority: %d\\n\", thread->priority);\n\n    // Calculate priority attributes (placeholder logic)\n    calculate_priority_attributes(thread);\n\n    // Reset thread state to suspended before actual startup\n    thread->state = RT_THREAD_SUSPENDED;\n\n    // Resume the thread\n    rt_thread_resume(thread);\n\n    // Simulate setting the thread's state to running and triggering the scheduler\n    thread->state = RT_THREAD_RUNNING;\n    rt_thread_scheduler();\n\n    return RT_EOK;\n}\n\n// Definitions for placeholder functions\nvoid calculate_priority_attributes(rt_thread_t* thread) {\n    // Might adjust thread's priority based on some logic\n}\n\nvoid rt_thread_resume(rt_thread_t* thread) {\n    // Resume the thread execution (simulated)\n}\n\nvoid rt_thread_scheduler() {\n    // Trigger the scheduler to reevaluate thread priorities and execute the appropriate thread (simulated)\n}\n\nint main() {\n    // Example of starting a thread\n    rt_thread_t my_thread = { \"ExampleThread\", 10, RT_THREAD_INIT, RT_THREAD_TYPE_EXPECTED };\n    rt_err_t result = rt_thread_startup(&my_thread);\n    if (result == RT_EOK) {\n        printf(\"Thread started successfully.\\n\");\n    } else {\n        printf(\"Failed to start thread.\\n\");\n    }\n    return 0;\n}", "CodeBleu_score": 35.41499515795699}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "#include <stdio.h>\n\n// Assuming these are the definitions:\ntypedef int rt_err_t;  // Type for error codes\n#define RT_EOK 0       // No error\n#define RT_ERROR -1    // Generic error code\n\ntypedef unsigned long rt_tick_t;  // Type for ticks\n\ntypedef struct rt_timer {\n    rt_tick_t timeout;  // When the timer should expire\n    struct rt_timer *next;  // Next timer in the list\n} rt_timer_t;\n\ntypedef struct {\n    rt_timer_t *head;  // Head of the list\n} rt_list_t;\n\n// Function under discussion:\nstatic rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick) {\n    // Check the highest level list is not NULL or empty\n    if (timer_list == NULL || timer_list[0].head == NULL) {\n        return RT_ERROR;  // Return error if list is empty or not initialized\n    }\n\n    // Get the first timer in the list\n    rt_timer_t *first_timer = timer_list[0].head;\n\n    // Check if the first timer is not NULL\n    if (first_timer != NULL) {\n        *timeout_tick = first_timer->timeout;  // Set the timeout tick\n        return RT_EOK;  // Successful, return OK\n    } else {\n        return RT_ERROR;  // Error: Timer list is structurally present but no timers are available\n    }\n}", "CodeBleu_score": 38.84825755128822}, {"code": "#include \"rtdef.h\" // Assuming RT_EOK, RT_ERROR, and other definitions exist here\n\n/* Example definitions for list and tick operations, these may vary depending on the actual environment/OS */\n#define RT_EOK 0\n#define RT_ERROR -1\ntypedef struct rt_list_node {\n    struct rt_list_node *next; // Pointer to the next node in the list\n    rt_tick_t timeout;         // Timeout value represented by this node\n} rt_list_node;\n\ntypedef struct rt_list_t {\n    rt_list_node *head; // Start of the list\n} rt_list_t;\n\nstatic rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick) {\n    if (timer_list == NULL || timeout_tick == NULL) {\n        return RT_ERROR; // Error handling in case of null pointers\n    }\n    \n    rt_list_t *list_head = &timer_list[0]; // Assuming highest level is at index 0\n    rt_list_node *first_timer = list_head->head; // Get the first entry in the list\n    \n    if (first_timer == NULL) {\n        return RT_ERROR; // Return error if the list is empty\n    }\n    \n    *timeout_tick = first_timer->timeout; // Set provided timeout tick to timer's timeout value\n    return RT_EOK; // Return RT_EOK on successful operation\n}", "CodeBleu_score": 34.79113580206481}, {"code": "#include <stdint.h>  // For uint32_t definitions\n\n/* Definition for error codes */\n#define RT_EOK 0       // No error\n#define RT_ERROR -1    // Generic error\n\n/* Basic structures, assuming types */\ntypedef int rt_err_t;\ntypedef uint32_t rt_tick_t;\n\n/* Node of a doubly linked list */\ntypedef struct rt_list_node {\n    struct rt_list_node *next;\n    struct rt_list_node *prev;\n} rt_list_node_t;\n\n/* Timer list is a skip list structure */\ntypedef struct rt_list_t {\n    rt_list_node_t head[1];  // Simplified to show only one level\n} rt_list_t;\n\n/* Function to check if the list is empty */\nstatic inline int rt_list_is_empty(const rt_list_t *l) {\n    return l->head[0].next == &l->head[0];\n}\n\n/* Timer entry structure */\ntypedef struct {\n    rt_list_node_t list;\n    rt_tick_t timeout;\n} rt_timer_t;\n\nstatic rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick) {\n    /* Ensure the array is not NULL and timeout_tick is valid */\n    if (timer_list == NULL || timeout_tick == NULL) {\n        return RT_ERROR;\n    }\n\n    /* Check if the highest level (level 0 here for simplification) is not empty */\n    if (!rt_list_is_empty(&timer_list[0])) {\n        /* Get the first timer node */\n        rt_list_node_t *first_node = timer_list[0].head[0].next;\n\n        /* Cast it to the rt_timer_t structure */\n        rt_timer_t *first_timer = (rt_timer_t *)((char *)first_node - offsetof(rt_timer_t, list));\n\n        /* Set the timeout value */\n        *timeout_tick = first_timer->timeout;\n\n        return RT_EOK;\n    }\n\n    /* If the list is empty */\n    return RT_ERROR;\n}", "CodeBleu_score": 37.179028490876654}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "#include <stdlib.h> // For `malloc` and `NULL`\n\n// Definition of `rt_timer_t`, modify as per the actual definition in your project\ntypedef struct rt_timer {\n    const char *name;\n    void (*timeout)(void *parameter);\n    void *parameter;\n    rt_tick_t time;\n    rt_uint8_t flag;\n} rt_timer_t;\n\n// It's assumed `rt_tick_t` is defined elsewhere in your project\ntypedef unsigned int rt_tick_t;\ntypedef unsigned char rt_uint8_t;\n\nrt_timer_t *rt_timer_create(const char *name,\n                            void (*timeout)(void *parameter),\n                            void *parameter,\n                            rt_tick_t time,\n                            rt_uint8_t flag) {\n    // Check if the provided `timeout` function pointer is not NULL\n    if (timeout == NULL) {\n        return NULL; // Invalid timeout function, return NULL\n    }\n\n    // Check if the time is within a valid range (assuming some limit, here exemplified as MAX_TICK_VALUE)\n    // This value should be defined according to system requirements\n    const rt_tick_t MAX_TICK_VALUE = ~0; // Maximum value for rt_tick_t (depends on definition)\n    if (time == 0 || time > MAX_TICK_VALUE) {\n        return NULL; // Time is not within the valid range, return NULL\n    }\n\n    // Allocate memory for the rt_timer_t structure\n    rt_timer_t *new_timer = (rt_timer_t *)malloc(sizeof(rt_timer_t));\n    if (new_timer == NULL) {\n        return NULL; // Memory allocation failed, return NULL\n    }\n\n    // Initialize the timer structure with the provided values\n    new_timer->name = name;\n    new_timer->timeout = timeout;\n    new_timer->parameter = parameter;\n    new_timer->time = time;\n    new_timer->flag = flag;\n\n    // Return the pointer to the newly created timer\n    return new_timer;\n}", "CodeBleu_score": 37.91846350331323}, {"code": "#include <stdlib.h>  // For malloc() and NULL\n\n#define RT_TICK_MAX 0xFFFFFFFF\n\ntypedef unsigned int rt_tick_t;       // Assuming rt_tick_t is an unsigned int\ntypedef unsigned char rt_uint8_t;     // Assuming rt_uint8_t is an unsigned char\n\n// Assuming some structure for rt_timer_t can look like this\ntypedef struct rt_timer_t {\n    const char *name;\n    void (*timeout)(void *parameter);\n    void *parameter;\n    rt_tick_t time;\n    rt_uint8_t flag;\n} rt_timer_t;\n\n\nrt_timer_t *rt_timer_create(const char *name,\n                            void (*timeout)(void *parameter),\n                            void *parameter,\n                            rt_tick_t time,\n                            rt_uint8_t flag) {\n    // Check that the timeout function is not null\n    if (timeout == NULL) {\n        return NULL;  // Return NULL if timeout function is not provided\n    }\n\n    // Check if the provided time is within a valid range\n    if (time > RT_TICK_MAX) {\n        return NULL;  // Return NULL if time is out of valid range\n    }\n\n    // Allocate memory for the timer object\n    rt_timer_t *timer = (rt_timer_t *)malloc(sizeof(rt_timer_t));\n    if (timer == NULL) {\n        return NULL;  // Return NULL if memory allocation fails\n    }\n\n    // Initialize the timer with the provided values\n    timer->name = name;\n    timer->timeout = timeout;\n    timer->parameter = parameter;\n    timer->time = time;\n    timer->flag = flag;\n\n    return timer;  // Return the pointer to the newly created timer object\n}", "CodeBleu_score": 39.094554074504906}, {"code": "#include <stdlib.h>  // For malloc and NULL\n\n// Define a basic custom type for rt_tick_t and rt_uint8_t\ntypedef unsigned long rt_tick_t;\ntypedef unsigned char rt_uint8_t;\n\n// Struct definition for a timer\ntypedef struct rt_timer {\n    const char* name;\n    void (*timeout)(void* parameter);\n    void* parameter;\n    rt_tick_t time;\n    rt_uint8_t flag;\n} rt_timer_t;\n\nrt_timer_t *rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag) {\n    // Check for the validity of the timeout function and time constraints\n    if (timeout == NULL || time == 0) {\n        return NULL; // Return NULL as per precondition check\n    }\n\n    // Allocate memory for the timer object\n    rt_timer_t *timer = (rt_timer_t*) malloc(sizeof(rt_timer_t));\n    if (timer == NULL) {\n        // Return NULL if memory allocation failed\n        return NULL;\n    }\n\n    // Initialize the timer properties\n    timer->name = name;\n    timer->timeout = timeout;\n    timer->parameter = parameter;\n    timer->time = time;\n    timer->flag = flag;\n\n    return timer; // Return the pointer to the newly created timer object\n}", "CodeBleu_score": 39.41630353016863}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "import (\n\t\"net/http\"\n\t\"net/http/httptest\"\n)\n\ntype API struct {\n\thandlers []http.Handler\n\trouter   http.Handler\n}\n\nfunc (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n\t// Iterate through all the handlers\n\tfor _, handler := range a.handlers {\n\t\t// Create a new ResponseRecorder to capture the handler response\n\t\trecorder := httptest.NewRecorder()\n\n\t\t// Process the request using the handler\n\t\thandler.ServeHTTP(recorder, req)\n\n\t\t// Copy headers from the recorder to the original response writer\n\t\tfor k, v := range recorder.Header() {\n\t\t\tfor _, val := range v {\n\t\t\t\tres.Header().Add(k, val)\n\t\t\t}\n\t\t}\n\n\t\t// Check for a 401 Unauthorized status\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\t// Stop processing and respond with \"Not Authorized\"\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise, write the recorder's body to the original response writer (Optionally)\n\t\t// res.Write(recorder.Body.Bytes())\n\t}\n\n\t// If none of the handlers returned a 401 status, forward the request to the router\n\ta.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 61.18788666911665}, {"code": "package main\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n)\n\ntype API struct {\n\thandlers []http.Handler\n\trouter   http.Handler\n}\n\n// ServeHTTP processes an HTTP request by sequentially passing it through a series of handlers.\n// For each handler, it captures the response using a recorder and copies the recorder's headers to the original response.\n// If any handler returns a \"401 Unauthorized\" status, it sends a \"Not Authorized\" error response and stops further processing.\n// If all handlers pass without unauthorized status, it forwards the request to the router for further handling.\nfunc (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n\tfor _, handler := range a.handlers {\n\t\t// Create a new response recorder\n\t\trecorder := httptest.NewRecorder()\n\n\t\t// Serve the http request to handler\n\t\thandler.ServeHTTP(recorder, req)\n\n\t\t// Copy headers from the recorder to the original response writer\n\t\tfor k, v := range recorder.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\n\t\t// Check if the status code is 401 Unauthorized\n\t\tif recorder.Code == http.StatusUnauthorized {\n\t\t\t// Send a \"Not Authorized\" error response and stop processing\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Copy the body from the recorder to the original response writer\n\t\tif body := recorder.Body.Bytes(); len(body) > 0 {\n\t\t\tres.Write(body)\n\t\t}\n\t}\n\n\t// If no handler stopped processing because of unauthorized status, forward to the router for further processing\n\tif a.router != nil {\n\t\ta.router.ServeHTTP(res, req)\n\t}\n}\n\nfunc main() {\n\t// Usage example\n}", "CodeBleu_score": 75.18845687898418}, {"code": "package main\n\nimport (\n    \"net/http\"\n    \"net/http/httptest\"\n)\n\ntype Handler interface {\n    ServeHTTP(http.ResponseWriter, *http.Request)\n}\n\ntype API struct {\n    handlers []Handler\n    router   http.Handler\n}\n\nfunc (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n    for _, handler := range a.handlers {\n        // Create a new recorder to capture the response\n        recorder := httptest.NewRecorder()\n        \n        // Serve the request using the current handler\n        handler.ServeHTTP(recorder, req)\n        \n        // Copy headers from the recorder to the actual response writer\n        for k, v := range recorder.Header() {\n            res.Header()[k] = v\n        }\n\n        // Check the status code for a \"401 Unauthorized\"\n        if recorder.Code == http.StatusUnauthorized {\n            // Send a \"Not Authorized\" error response and stop processing\n            http.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n            return\n        }\n\n        // Copy the body from the recorder to the actual response writer\n        if _, err := res.Write(recorder.Body.Bytes()); err != nil {\n            http.Error(res, \"Failed to write response\", http.StatusInternalServerError)\n            return\n        }\n    }\n\n    // If all handlers pass, forward the request to the router\n    a.router.ServeHTTP(res, req)\n}", "CodeBleu_score": 74.29761811426853}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "import (\n    \"io/ioutil\"\n    \"net/http\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nfunc (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// Extract the path from the URL\n\tpath := req.URL.Path\n\n\t// Define the base directory where your static files are stored (e.g., \"static\")\n\tbaseDir := \"static\"\n\n\t// Construct the full file path\n\tfilePath := filepath.Join(baseDir, path)\n\n\t// Read the file\n\tdata, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\t// If an error occurs, log it, set a 404 status, and return\n\t\thttp.Error(res, \"File not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\t// Get the file extension\n\text := filepath.Ext(filePath)\n\n\t// Determine the correct content type for the response header\n\tcontentType := \"text/plain\" // Default content type\n\tswitch strings.ToLower(ext) {\n\tcase \".js\":\n\t\tcontentType = \"application/javascript\"\n\tcase \".css\":\n\t\tcontentType = \"text/css\"\n\tcase \".html\":\n\t\tcontentType = \"text/html\"\n\t}\n\n\t// Set the content type in the response header\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the data to the response\n\tres.Write(data)\n}", "CodeBleu_score": 47.21223221579478}, {"code": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path\"\n\t\"strings\"\n)\n\ntype API struct {}\n\n// robeaux serves static assets as per HTTP requests.\nfunc (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n\t// Assume static files are located in the \"static\" directory\n\tbasePath := \"static\"\n\n\t// Get the requested file path from the request URL\n\tfilePath := path.Join(basePath, req.URL.Path)\n\n\t// Determine the content type based on the file's extension\n\tcontentType := \"text/plain\" // Default content type\n\tswitch strings.ToLower(path.Ext(filePath)) {\n\tcase \".js\":\n\t\tcontentType = \"application/javascript\"\n\tcase \".css\":\n\t\tcontentType = \"text/css\"\n\tcase \".html\":\n\t\tcontentType = \"text/html\"\n\t}\n\n\t// Read the file content from the disk\n\tdata, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\t// If the file is not found or there's an error reading it, send a 404 response\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"404 - File not found\"))\n\t\treturn\n\t}\n\n\t// Set the Content-Type header\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\t// Write the file content to the response\n\tres.Write(data)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(res http.ResponseWriter, req *http.Request) {\n\t\tapi := API{}\n\t\tapi.robeaux(res, req)\n\t})\n\n\t// Starting the server\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}", "CodeBleu_score": 41.784621233018804}, {"code": "import (\n    \"net/http\"\n    \"os\"\n    \"path\"\n    \"strings\"\n)\n\nfunc (a *API) robeaux(res http.ResponseWriter, req *http.Request) {\n    // Derive the file path from the URL path plus a base directory with static assets\n    baseDir := \"./static\" // directory where the static files are stored\n    filePath := path.Join(baseDir, req.URL.Path)\n\n    // Read the file content\n    asset, err := os.ReadFile(filePath)\n    if err != nil {\n        // If the file cannot be read, return a 404 error\n        http.Error(res, \"File not found\", http.StatusNotFound)\n        return\n    }\n\n    // Determine the content type based on the file extension\n    contentType := \"application/octet-stream\" // Default MIME type\n    switch ext := strings.ToLower(path.Ext(filePath)); ext {\n    case \".html\":\n        contentType = \"text/html\"\n    case \".css\":\n        contentType = \"text/css\"\n    case \".js\":\n        contentType = \"application/javascript\"\n    }\n\n    // Set the Content-Type header\n    res.Header().Set(\"Content-Type\", contentType)\n\n    // Write the read content to response\n    res.WriteHeader(http.StatusOK)\n    res.Write(asset) // Write the data to the response writer\n}", "CodeBleu_score": 44.8849748119175}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "import (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype API struct {\n\tmaster *Master  // Assuming Master structure has a method to get robot by name\n}\n\ntype Connection struct{\n\t// Define the structure of connections your robot will have\n\tName string `json:\"name\"`\n\tType string `json:\"type\"`\n}\n\n// robotConnections handles HTTP requests to retrieve the connections of a specified robot.\n// It extracts the robot name from the request URL and finds the corresponding robot using the master instance.\n// If the robot is found, it gathers its connections and converts them to JSON format.\n// The function then writes the JSON response containing the connections.\n// If the robot is not found, it writes a JSON error message indicating that no robot was found with the specified name.\nfunc (a *API) robotConnections(res http.ResponseWriter, req *http.Request) {\n\t// Extracting robot name from the URL\n\trobotName := strings.TrimPrefix(req.URL.Path, \"/robotConnections/\")\n\n\t// Look for the robot in the master\n\trobot, err := a.master.GetRobotByName(robotName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the name \" + robotName})\n\t\treturn\n\t}\n\n\t// Obtain connections of the robot\n\tconnections := robot.GetConnections()\n\n\t// Prepare response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tres.WriteHeader(http.StatusOK)\n\tif err := json.NewEncoder(res).Encode(connections); err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"Failed to encode connections\"})\n\t}\n}\n\n// Assuming GetRobotByName and GetConnections methods need to be defined based on your 'Master' and 'Robot' structures respectively.", "CodeBleu_score": 35.04748054344503}, {"code": "import (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// Assume Master type and Robot type are defined elsewhere with appropriate methods.\ntype API struct {\n\tMaster *Master // Assumes Master contains method to get Robot by name\n}\n\n// Robot defines a type for robots with a method Connections that returns their connections.\ntype Robot struct {\n\tName string\n}\n\nfunc (r *Robot) Connections() []string {\n\t// Example return data, in practice this method should access the robot's connection information.\n\treturn []string{\"Robot1\", \"Robot2\"}\n}\n\nfunc (a *API) robotConnections(res http.ResponseWriter, req *http.Request) {\n\t// Extract robot name from URL. Here it's assumed URL is of the form /robots/{robotName}/connections\n\tparts := strings.Split(req.URL.Path, \"/\")\n\tif len(parts) < 4 {\n\t\thttp.Error(res, \"Invalid request URL.\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\trobotName := parts[2] // This assumes the URL pattern as mentioned above\n\n\t// Find robot by name\n\trobot := a.Master.GetRobotByName(robotName)\n\tif robot == nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"No robot found with the specified name\"})\n\t\treturn\n\t}\n\n\t// Get connections of the robot\n\tconnections := robot.Connections()\n\n\t// Convert connections to JSON and write to response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(map[string]interface{}{\n\t\t\"connections\": connections,\n\t})\n}", "CodeBleu_score": 34.848266606473224}, {"code": "import (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// Assume a predefined type `API` that includes a `Master` which manages robots.\ntype API struct {\n\tMaster *Master\n}\n\n// Master is a struct that may have a method to find robots.\ntype Master struct {\n\t// Assume there is a data structure that holds robots.\n\tRobots map[string]*Robot\n}\n\n// Robot is a simple struct to hold connections.\ntype Robot struct {\n\tConnections []string\n}\n\nfunc (m *Master) FindRobot(name string) *Robot {\n\tif robot, ok := m.Robots[name]; ok {\n\t\treturn robot\n\t}\n\treturn nil\n}\n\nfunc (a *API) robotConnections(res http.ResponseWriter, req *http.Request) {\n\t// Split the URL to get the robot's name. Assuming URL is like \"/robots/{robotName}/connections\"\n\tparts := strings.Split(req.URL.Path, \"/\")\n\tif len(parts) < 4 {\n\t\thttp.Error(res, \"Invalid URL format\", http.StatusBadRequest)\n\t\treturn\n\t}\n\trobotName := parts[2]\n\n\t// Find the robot using the robotName\n\trobot := a.Master.FindRobot(robotName)\n\tif robot == nil {\n\t\tres.Header().Set(\"Content-Type\", \"application/json\")\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\n\t\t\t\"error\": \"No robot found with the specified name\",\n\t\t})\n\t\treturn\n\t}\n\n\t// If robot is found, encode its connections to JSON and write the response\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(map[string][]string{\n\t\t\"connections\": robot.Connections,\n\t})\n}", "CodeBleu_score": 35.091074979832314}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"net/http\"\n)\n\n// BasicAuth creates an HTTP handler that enforces Basic Authentication.\n// It checks the \"Authorization\" header in the request against a base64-encoded\n// username and password. If the comparison fails, it sets the \"WWW-Authenticate\" \n// header and returns a \"Not Authorized\" response with a 401 status code.\nfunc BasicAuth(username, password string) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Format the correct authorization value for comparison\n        authValue := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(username+\":\"+password))\n\n        // Retrieve the Authorization header from the request\n        authHeader := r.Header.Get(\"Authorization\")\n\n        // Check if the provided credentials match the expected ones\n        if authHeader != authValue {\n            w.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n            w.WriteHeader(http.StatusUnauthorized)\n            w.Write([]byte(\"Not Authorized\"))\n            return\n        }\n\n        // If authentication succeeds, process the request\n        w.Write([]byte(\"Authenticated successfully\"))\n    }\n}\n\nfunc main() {\n    // Create a test server with basic authentication\n    http.HandleFunc(\"/\", BasicAuth(\"admin\", \"password\"))\n    http.ListenAndServe(\":8080\", nil)\n}", "CodeBleu_score": 52.34218187837136}, {"code": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// BasicAuth returns an http.HandlerFunc that enforces basic authentication.\nfunc BasicAuth(username, password string) http.HandlerFunc {\n\t// Encode the username and password in the required base64 format for HTTP Basic Auth.\n\tencodedCredentials := base64.StdEncoding.EncodeToString([]byte(username + \":\" + password))\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Retrieve the Authorization header from the request.\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\n\t\t// Check if the Authorization header is present and formatted correctly.\n\t\tif !strings.HasPrefix(authHeader, \"Basic \") {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Extract the actual encoded credentials from the Authorization header.\n\t\treceivedCredentials := strings.TrimPrefix(authHeader, \"Basic \")\n\n\t\t// Compare the received credentials with the expected credentials.\n\t\tif receivedCredentials != encodedCredentials {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If credentials match, handle the request; you could call the next handler if desired.\n\t\tw.Write([]byte(\"Access Granted\"))\n\t}\n}\n\nfunc main() {\n\t// Setup a basic server with the BasicAuth middleware.\n\thttp.HandleFunc(\"/\", BasicAuth(\"user\", \"pass\"))\n\thttp.ListenAndServe(\":8080\", nil)\n}", "CodeBleu_score": 51.765075806319224}, {"code": "package main\n\nimport (\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// BasicAuth creates an HTTP handler that enforces Basic Authentication.\n// It checks the \"Authorization\" header in the request against a base64-encoded username and password.\n// If the comparison fails, it sets the \"WWW-Authenticate\" header and returns a \"Not Authorized\" response with a 401 status code.\nfunc BasicAuth(username, password string) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\t// Retrieve the Authorization header from the request\n\t\tauthHeader := r.Header.Get(\"Authorization\")\n\t\t\n\t\t// Check if the Authorization header is not empty\n\t\tif authHeader == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// split the authHeader into \"Basic\" and the base64encoded part\n\t\tparts := strings.SplitN(authHeader, \" \", 2)\n\t\tif len(parts) != 2 || parts[0] != \"Basic\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Decode the base64 part of the header\n\t\tdecoded, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Check if the decoded credentials format is username:password\n\t\tcreds := strings.SplitN(string(decoded), \":\", 2)\n\t\tif len(creds) != 2 || creds[0] != username || creds[1] != password {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// If the credentials are correct, call the next handler\n\t\t// Or simply inform that the authentication is successful for this example\n\t\tw.Write([]byte(\"Authentication Successful\"))\n\t}\n}", "CodeBleu_score": 47.797349532913806}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "package main\n\nimport \"math\"\n\nfunc AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) int {\n    // Calculate the range spans in both the input and output ranges\n    inputSpan := fromMax - fromMin\n    outputSpan := float64(toMax - toMin)\n\n    // Create a function to be returned by AnalogActuatorLinearScaler\n    return func(input float64) int {\n        // Calculate how far input is from the fromMin in terms of fraction span of input range\n        fraction := (input - fromMin) / inputSpan\n\n        // Scale to the output range\n        scaledOutput := float64(toMin) + fraction*outputSpan\n\n        // Convert the output to an integer, since we need to return an integer\n        value := int(math.Round(scaledOutput))\n\n        // Clamp the result to the specified output range\n        if value < toMin {\n            value = toMin\n        } else if value > toMax {\n            value = toMax\n        }\n\n        return value\n    }\n}\n\n// Usage example:\nfunc main() {\n    scaler := AnalogActuatorLinearScaler(0.0, 100.0, 0, 255)\n    result := scaler(50.0)\n    println(\"Scaled Value:\", result)\n}", "CodeBleu_score": 52.35705099850394}, {"code": "// AnalogActuatorLinearScaler creates a linear scaler function to convert an input float value from one range to an integer value in another range.\n// It calculates the slope and intercept for the scaling transformation and returns a function that performs the scaling.\n// The returned function ensures the output is clamped within the target range.\nfunc AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) int {\n    // Calculate the slope of the linear transformation\n    slope := float64(toMax-toMin) / (fromMax - fromMin)\n    \n    // Create the closure function to apply the scaling to the input\n    return func(input float64) int {\n        // First, translate the input range to start from 0\n        normalizedInput := input - fromMin\n        \n        // Apply the scaling factor (slope)\n        scaledValue := float64(toMin) + slope*normalizedInput\n        \n        // Clamp the output value to ensure it remains within the desired target range.\n        if scaledValue < float64(toMin) {\n            return toMin\n        } else if scaledValue > float64(toMax) {\n            return toMax\n        }\n        \n        // Convert the scaled floating point number back to an integer\n        return int(scaledValue)\n    }\n}", "CodeBleu_score": 62.20696036318167}, {"code": "// AnalogActuatorLinearScaler creates a linear scaler function to convert an input\n// float64 value from one range to an integer value in another range.\n// It calculates the slope and intercept for the scaling transformation and returns\n// a function that performs the scaling. The returned function ensures the output is\n// clamped within the target range.\nfunc AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) int {\n    // Calculate scaling factor (slope) and the offset (intercept)\n    slope := (float64(toMax) - float64(toMin)) / (fromMax - fromMin)\n    intercept := float64(toMin) - slope*fromMin\n\n    // Return a function that takes input, applies linear transformation and clamps the output\n    return func(input float64) int {\n        // Apply linear scaling formula\n        scaledValue := slope*input + intercept\n\n        // Convert to int and clamp the value to ensure it stays within the specified range\n        intScaledValue := int(scaledValue)\n        if intScaledValue < toMin {\n            intScaledValue = toMin\n        } else if intScaledValue > toMax {\n            intScaledValue = toMax\n        }\n\n        return intScaledValue\n    }\n}", "CodeBleu_score": 54.606341097853026}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "type AnalogSensorDriver struct {\n    mutex          sync.Mutex\n    pin            int\n    connection     *SomeConnectionType\n    lastRawValue   int\n    lastScaledValue float64\n}", "CodeBleu_score": 1.2049138026131012}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error) {\n    // Locking the mutex to ensure thread safety.\n    a.mutex.Lock()\n    defer a.mutex.Unlock()\n\n    // Check if the connection is valid and supports analog reading.\n    if a.connection == nil {\n        return 0, 0.0, fmt.Errorf(\"connection is not initialized\")\n    }\n\n    if !a.connection.SupportsAnalog {\n        return 0, 0.0, fmt.Errorf(\"analog reading not supported on this connection\")\n    }\n\n    // Reading the raw value from the sensor attached to the specified pin.\n    rawValue, err := a.connection.ReadAnalog(a.pin)\n    if err != nil {\n        return 0, 0.0, fmt.Errorf(\"error reading from analog sensor: %v\", err)\n    }\n\n    // Calculating the scaled value based on some scaling factor.\n    // Assuming the scaling factor is part of the structure or globally defined.\n    scaledValue := float64(rawValue) * a.scalingFactor\n\n    // Updating the last raw and scaled values.\n    a.lastRawValue = rawValue\n    a.lastScaledValue = scaledValue\n\n    // Returning the raw value, scaled value, and no error (nil).\n    return rawValue, scaledValue, nil\n}", "CodeBleu_score": 46.15728979284046}, {"code": "// analogSensorRead reads the value from an analog sensor.\n// It locks the mutex to ensure thread safety and verifies that the connection supports analog reading.\n// If the connection is valid, it reads the raw value from the specified pin and updates the last raw and scaled values.\n// It returns the raw value, the scaled value, and any error encountered during the read operation.\nfunc (a *AnalogSensorDriver) analogSensorRead() (int, float64, error) {\n    // Locking the mutex to prevent race conditions\n    a.mutex.Lock()\n    defer a.mutex.Unlock()\n\n    // Check if the sensor's connection supports analog reading\n    if !a.connection.IsAnalogSupported() {\n        return 0, 0.0, fmt.Errorf(\"analog reading not supported on this connection\")\n    }\n\n    // Read the raw value from the sensor\n    rawValue, err := a.connection.ReadAnalog(a.pin)\n    if err != nil {\n        return 0, 0.0, err\n    }\n\n    // Scale the raw value to get a meaningful result according to sensor specifics or calibration\n    scaledValue := a.scaleValue(rawValue)\n\n    // Store last read values for any possible future reference within the driver\n    a.lastRawValue = rawValue\n    a.lastScaledValue = scaledValue\n\n    return rawValue, scaledValue, nil\n}\n\n// scaleValue might be a method that converts the raw sensor value based on some calibration logic or scaling algorithm.\nfunc (a *AnalogSensorDriver) scaleValue(rawValue int) float64 {\n    // This is a placeholder scaling calculation. Actual implementation may vary.\n    // For example, converting a 10-bit ADC value to a voltage, assuming a reference voltage of 5V:\n    return float64(rawValue) * (5.0 / 1023.0)\n}", "CodeBleu_score": 48.849424704769774}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "// Calculate slope (m) and intercept (n) for the transformation\n    slope := (toMax - toMin) / float64(fromMax - fromMin)\n    intercept := toMin - slope*float64(fromMin)\n    \n    // Define and return the scaling function using closure\n    return func(input int) float64 {\n        // Convert input using the linear transformation formula y = mx + n\n        scaledValue := slope*float64(input) + intercept\n        \n        // Ensure the output is clipped to the max and min of the target range\n        if scaledValue > toMax {\n            scaledValue = toMax\n        } else if scaledValue < toMin {\n            scaledValue = toMin\n        }\n        \n        return scaledValue\n    }\n}", "CodeBleu_score": 55.499187060401624}, {"code": "// AnalogSensorLinearScaler returns a function that maps integers from one range\n// (fromMin to fromMax) linearly to a floating-point range (toMin to toMax).\nfunc AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n    // Calculate the coefficients for the linear transformation\n    // m is the scale coefficient (slope)\n    m := (toMax - toMin) / float64(fromMax-fromMin)\n    // n is the offset coefficient (intercept)\n    n := toMin - m*float64(fromMin)\n\n    // Return the closure that will perform the scaling\n    return func(value int) float64 {\n        // Convert the input value and ensure the result is within the output bounds\n        scaledValue := m*float64(value) + n\n\n        // Clamp the result to stay within the range toMin to toMax\n        if scaledValue < toMin {\n            scaledValue = toMin\n        } else if scaledValue > toMax {\n            scaledValue = toMax\n        }\n\n        return scaledValue\n    }\n}", "CodeBleu_score": 64.49763810344672}, {"code": "// AnalogSensorLinearScaler returns a scaling function that linearly maps input values between ranges.\n// The function computes the transformation based on the minimum and maximum values of the source and target ranges.\n// Parameter fromMin is the minimum input value that the sensor can provide.\n// Parameter fromMax is the maximum input value that the sensor can provide.\n// Parameter toMin is the minimum value of the transformed output range.\n// Parameter toMax is the maximum value of the transformed output range.\nfunc AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 {\n    // Calculate the slope (m)\n    slope := (toMax - toMin) / float64(fromMax-fromMin)\n\n    // Calculate the intercept (n)\n    intercept := toMin - slope*float64(fromMin)\n    \n    // Return a function that applies the linear transformation\n    return func(x int) float64 {\n        // Ensure x remains within the expected input range (although this is optional)\n        if x < fromMin {\n            x = fromMin\n        } else if x > fromMax {\n            x = fromMax\n        }\n        \n        // Linearly scale the input value\n        scaledValue := float64(x)*slope + intercept\n        \n        // Return the scaled value, ensuring it remains within the output range\n        if scaledValue < toMin {\n            return toMin\n        } else if scaledValue > toMax {\n            return toMax\n        }\n        return scaledValue\n    }\n}", "CodeBleu_score": 61.51224216980265}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "package main\n\n// Let's assume these methods and types\ntype AnalogReader interface {\n\tRead(pin string) (int, error)\n}\n\n// Driver for the piezo vibration sensor\ntype GrovePiezoVibrationSensorDriver struct {\n\tdriverName    string\n\tanalogSensor  AnalogSensorDriver\n\tvibrationPin  string\n\tvibrationData chan int\n}\n\ntype AnalogSensorDriver struct {\n\tReader AnalogReader\n\tpin    string\n\topts   []interface{}\n}\n\n// Constructor for AnalogSensorDriver\nfunc NewAnalogSensorDriver(reader AnalogReader, pin string, opts ...interface{}) *AnalogSensorDriver {\n\treturn &AnalogSensorDriver{Reader: reader, pin: pin, opts: opts}\n}\n\n// Constructor for GrovePiezoVibrationSensorDriver\nfunc NewGrovePiezoVibrationSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GrovePiezoVibrationSensorDriver {\n\tdriver := &GrovePiezoVibrationSensorDriver{\n\t\tdriverName:    \"GrovePiezoVibrationSensor\",\n\t\tanalogSensor:  *NewAnalogSensorDriver(a, pin, opts...),\n\t\tvibrationPin:  pin,\n\t\tvibrationData: make(chan int),\n\t}\n\n\tgo driver.listenVibration()\n\n\treturn driver\n}\n\n// listenVibration handles the data events\nfunc (d *GrovePiezoVibrationSensorDriver) listenVibration() {\n\tfor {\n\t\tdata, err := d.analogSensor.Reader.Read(d.vibrationPin)\n\t\tif err != nil {\n\t\t\tpanic(\"Failed to read data from sensor\")\n\t\t}\n\t\tif data > 1000 {\n\t\t\td.vibrationData <- data\n\t\t}\n\t}\n}\n\n// Main method for demonstration purposes\nfunc main() {\n\t// Example implementation details might be necessary to run this\n}", "CodeBleu_score": 32.88123794246558}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver {\n\t// Create a new analog sensor driver\n\tdriver := NewAnalogSensorDriver(a, pin, opts...)\n\t\n\t// Setting a default name for the driver, change \"VibrationSensor\" to a suitable name\n\tdriver.SetName(\"VibrationSensor\")\n\t\n\t// Set up an event listener to trigger on data events\n\terr := driver.On(\"data\", func(data interface{}) {\n\t\t// Assuming data is an integer (casting might be necessary)\n\t\tvibrationValue, ok := data.(int)\n\t\tif !ok {\n\t\t\tpanic(\"Data is not of type int\")\n\t\t}\n\t\t\n\t\t// Publish a vibration event if the data exceeds a threshold of 1000\n\t\tif vibrationValue > 1000 {\n\t\t\tdriver.Publish(\"vibrationEvent\", \"Vibration detected\")\n\t\t}\n\t})\n\t\n\t// Handle error, if occurred when setting up the event listener\n\tif err != nil {\n\t\tpanic(\"Failed to set up data event listener\")\n\t}\n\t\n\t// Return the initialized driver\n\treturn driver\n}", "CodeBleu_score": 34.8086007707494}, {"code": "// NewGrovePiezoVibrationSensorDriver creates and initializes a new Grove Piezo Vibration Sensor driver.\nfunc NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver {\n\t// Initialize the underlying AnalogSensorDriver\n\tdriver := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t}\n\n\t// Set a default name for the driver; can be replaced by an option if provided\n\tdriver.Name = \"GrovePiezoVibrationSensor\"\n\n\t// Add a default vibration detection event\n\tdriver.AddEvent(\"vibration\")\n\n\t// Setup event listener for data events\n\terr := driver.AnalogSensorDriver.On(\"data\", func(data interface{}) {\n\t\t// Check if the event data exceed the threshold\n\t\tif value, ok := data.(int); ok && value > 1000 {\n\t\t\t// Publish a vibration event when threshold is exceeded\n\t\t\tdriver.Publish(\"vibration\", value)\n\t\t}\n\t})\n\n\t// Error handling while setting up the event listener\n\tif err != nil {\n\t\tpanic(\"Failed to set up event listener for Grove Piezo Vibration Sensor\")\n\t}\n\n\treturn driver\n}", "CodeBleu_score": 43.9563530703453}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error {\n    // Calculate the period of the tone (in seconds)\n    period := 1 / hz\n\n    // Convert period in seconds to duration in nanoseconds for more precise timing\n    periodNanoseconds := period * float64(time.Second)\n\n    // Determine how long the tone should be played overall in nanoseconds\n    durationNanoseconds := duration * float64(time.Second)\n\n    // Calculate the time to stop playing the tone\n    endTime := time.Now().Add(time.Duration(durationNanoseconds))\n\n    for time.Now().Before(endTime) {\n        // Turn the buzzer on\n        if err := d.buzzerOn(); err != nil {\n            return err\n        }\n\n        // Wait for half the period (high phase of the tone)\n        time.Sleep(time.Duration(periodNanoseconds / 2))\n\n        // Turn the buzzer off\n        if err := d.buzzerOff(); err != nil {\n            return err\n        }\n\n        // Wait for the other half of the period (low phase of the tone)\n        time.Sleep(time.Duration(periodNanoseconds / 2))\n    }\n\n    return nil\n}", "CodeBleu_score": 50.60966191891433}, {"code": "import (\n    \"time\"\n    \"math\"\n    \"errors\"\n)\n\ntype BuzzerDriver struct {\n    // You might have fields here for managing the buzzer state\n}\n\n// Tone generates a tone on a buzzer at the specified frequency (hz) for the specified duration.\nfunc (d *BuzzerDriver) Tone(hz, duration float64) error {\n    if hz <= 0 {\n        return errors.New(\"frequency must be positive\")\n    }\n    if duration <= 0 {\n        return errors.New(\"duration must be positive\")\n    }\n\n    period := 1 / hz            // Calculate the period of the wave\n    halfPeriod := period / 2    // Calculate half period to create a square wave\n    \n    // Convert the period and half-period from seconds to nanoseconds for time.Sleep accuracy\n    periodDuration := time.Duration(period * float64(time.Second))\n    halfPeriodDuration := time.Duration(halfPeriod * float64(time.Second))\n\n    endTime := time.Now().Add(time.Duration(duration * float64(time.Second)))\n\n    for time.Now().Before(endTime) {\n        if err := d.turnBuzzerOn(); err != nil {\n            return err  // Check for error on buzzer control\n        }\n        time.Sleep(halfPeriodDuration) // Sleep for half the period to keep the buzzer on\n\n        if err := d.turnBuzzerOff(); err != nil {\n            return err  // Check for error on buzzer control\n        }\n        time.Sleep(halfPeriodDuration) // Sleep for half the period to keep the buzzer off\n    }\n\n    return nil\n}\n\nfunc (d *BuzzerDriver) turnBuzzerOn() error {\n    // Insert hardware-specific code to turn the buzzer on\n    return nil\n}\n\nfunc (d *BuzzerDriver) turnBuzzerOff() error {\n    // Insert hardware-specific code to turn the buzzer off\n    return nil\n}", "CodeBleu_score": 46.034335244080665}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error {\n    if hz <= 0 {\n        return fmt.Errorf(\"frequency must be greater than zero\")\n    }\n\n    // Convert frequency to period in seconds, then to milliseconds\n    period := 1 / hz   // seconds per cycle\n    halfPeriod := period / 2 * 1000 // converted to milliseconds, half for on, half for off\n\n    // Calculate the total number of cycles to play based on duration in seconds\n    // duration in seconds\n    numCycles := int(duration * hz)\n\n    // Buzzer control loop\n    for i := 0; i < numCycles; i++ {\n        // Turn on the buzzer\n        err := d.TurnOn()\n        if err != nil {\n            return fmt.Errorf(\"failed to turn on the buzzer: %v\", err)\n        }\n\n        // Wait for half the period (duty cycle start)\n        time.Sleep(time.Duration(halfPeriod) * time.Millisecond)\n\n        // Turn off the buzzer\n        err = d.TurnOff()\n        if err != nil {\n            return fmt.Errorf(\"failed to turn off the buzzer: %v\", err)\n        }\n\n        // Wait for half the period (duty cycle end)\n        time.Sleep(time.Duration(halfPeriod) * time.Millisecond)\n    }\n\n    return nil\n}", "CodeBleu_score": 46.52880162356045}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error {\n    // Check if the sleep pin is set\n    if d.sleepPin == nil {\n        return fmt.Errorf(\"sleep pin not set\")\n    }\n\n    // Stop any ongoing operations\n    d.stopOperations() // Assuming there is a method to stop all operations\n\n    // Set the sleep pin to low to enable sleep mode\n    d.setPinLow(d.sleepPin) // Assuming there is a method to set a pin low\n\n    // Mark the driver as sleeping\n    d.isSleeping = true\n    \n    return nil\n}", "CodeBleu_score": 33.38961413260406}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error {\n    // Check if the sleep pin is set\n    if d.sleepPin == nil {\n        return fmt.Errorf(\"sleep pin not configured\")\n    }\n    \n    // Stop any ongoing operations\n    d.stop()\n\n    // Set the sleep pin to low (sleep mode)\n    d.sleepPin.Low()\n\n    // Mark the driver as sleeping\n    d.isSleeping = true\n    \n    return nil\n}", "CodeBleu_score": 32.84007386939227}, {"code": "// sleepWithSleepPin puts the EasyDriver into sleep mode using the configured sleep pin.\n// It checks if the sleep pin is set, returning an error if it is not.\n// It stops any ongoing operations and sets the sleep pin to low, which is the active state for sleeping.\n// Finally, it marks the driver as sleeping and returns nil.\nfunc (d *EasyDriver) sleepWithSleepPin() error {\n    // Check if sleep pin is configured\n    if d.sleepPin == nil {\n        return fmt.Errorf(\"sleep pin not configured\")\n    }\n\n    // Stop any ongoing motor operations if required\n    d.stopMotor()\n\n    // Set the sleep pin to LOW to enable sleep mode\n    err := d.sleepPin.Write(gpio.Low)\n    if err != nil {\n        return err\n    }\n\n    // Mark the driver as sleeping\n    d.isSleeping = true\n\n    return nil\n}", "CodeBleu_score": 46.920398108854805}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "package main\n\nimport \"errors\"\n\n// Assuming gobot.AnalogPinner is an interface possibly defined earlier or in another package\ntype AnalogPinner interface {\n    Initialize(path string, params map[string]string) error\n}\n\n// AnalgPinsAdaptor struct holds the map of initialized pins\ntype AnalogPinsAdaptor struct {\n    pins map[string]AnalogPinner\n    initialized bool\n}\n\n// analogPin retrieves or initializes an analog pin for a given ID.\nfunc (a *AnalogPinsAdaptor) analogPin(id string) (AnalogPinner, error) {\n    // Check if the AnalogPins adaptor is initialized\n    if !a.initialized {\n        return nil, errors.New(\"analog pins adaptor not initialized\")\n    }\n\n    // Check if the pin already exists\n    if pin, exists := a.pins[id]; exists {\n        return pin, nil // Return the existing pin\n    }\n    \n    // Translate the ID to obtain the path and parameters for a new pin\n    path, params := translateID(id)\n    \n    // Initialize a new analog pin\n    newPin := someAnalogPinType{} // This would ideally be a type that implements the AnalogPinner interface\n    err := newPin.Initialize(path, params)\n    if err != nil {\n        return nil, err\n    }\n    \n    // Store the new pin in the pins map\n    a.pins[id] = newPin\n    \n    // Return the newly created pin\n    return newPin, nil\n}\n\n// Dummy function to simulate the translation of an ID to a device path and parameters\nfunc translateID(id string) (string, map[string]string) {\n    // Dummy translation logic\n    return \"/dev/analog/\" + id, map[string]string{\"param1\": \"value1\", \"param2\": \"value2\"}\n}\n\n// someAnalogPinType is an example implementation of the AnalogPinner interface\ntype someAnalogPinType struct {/* Implement fields as needed */}\nfunc (p *someAnalogPinType) Initialize(path string, params map[string]string) error {\n    // Implementation details dependent on the required initializations\n    return nil\n}", "CodeBleu_score": 38.80134315102396}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error) {\n    // Check if the map of pins is initialized\n    if a.pins == nil {\n        return nil, fmt.Errorf(\"pins map not initialized\")\n    }\n\n    // Check if the pin is already initialized and present in the map\n    if pin, found := a.pins[id]; found {\n        return pin, nil\n    }\n\n    // If the pin is not present, translate the ID to obtain the path and parameters\n    path, params, err := translateIDToPinInfo(id)\n    if err != nil {\n        return nil, fmt.Errorf(\"unable to translate ID to pin info: %s\", err)\n    }\n\n    // Initialize new analog pin with the obtained path and parameters\n    newPin, err := gobot.NewAnalogPin(path, params)\n    if err != nil {\n        return nil, fmt.Errorf(\"error initializing new pin: %s\", err)\n    }\n\n    // Store the new pin in the map\n    a.pins[id] = newPin\n\n    // Return the newly created pin\n    return newPin, nil\n}\n\n// Helper function to translate ID to pin path and parameters\nfunc translateIDToPinInfo(id string) (path string, params map[string]interface{}, err error) {\n    // Implement translation logic based on ID, for example:\n    switch id {\n    case \"A0\":\n        return \"/sys/devices/analogA0\", map[string]interface{}{\"resolution\": 10}, nil\n    case \"A1\":\n        return \"/sys/devices/analogA1\", map[string]interface{}{\"resolution\": 10}, nil\n    default:\n        return \"\", nil, fmt.Errorf(\"unsupported pin ID\")\n    }\n}", "CodeBleu_score": 44.62126121174627}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error) {\n    if a.pins == nil {\n        return nil, errors.New(\"pins map not initialized\")\n    }\n\n    // Check if the pin is already present in the map\n    if pin, exists := a.pins[id]; exists {\n        return pin, nil\n    }\n\n    // Pin is not present; need to initialize a new analog pin\n    path, params, err := translatePinID(id)\n    if err != nil {\n        return nil, err\n    }\n\n    newPin, err := initAnalogPinWithPathAndParams(path, params)\n    if err != nil {\n        return nil, err\n    }\n\n    // Store the new pin in the map\n    a.pins[id] = newPin\n\n    return newPin, nil\n}", "CodeBleu_score": 48.03181523278522}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n    // Lock the mutex to ensure exclusive access to the pin resources\n    a.mutex.Lock()\n    defer a.mutex.Unlock()\n\n    // Attempt to retrieve the pin with the specified ID\n    pin, err := a.GetPin(id, Output)\n    if err != nil {\n        return err // Return the error if the pin could not be retrieved or is not an output pin\n    }\n\n    // Write the digital value to the pin\n    err = pin.Write(val)\n    if err != nil {\n        return err // Return the error if the write operation failed\n    }\n\n    return nil // Successfully written to the pin\n}", "CodeBleu_score": 61.1399785063785}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n    // Lock the mutex to ensure thread safety\n    a.mutex.Lock()\n    defer a.mutex.Unlock()\n\n    // Retrieve the digital pin by its ID\n    pin, err := a.GetPin(id, \"output\")\n    if err != nil {\n        return fmt.Errorf(\"failed to get pin: %v\", err)\n    }\n\n    // Write the digital value to the pin\n    err = pin.Write(val)\n    if err != nil {\n        return fmt.Errorf(\"failed to write to pin: %v\", err)\n    }\n\n    return nil\n}", "CodeBleu_score": 62.43112426238089}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error {\n    a.mutex.Lock()\n    defer a.mutex.Unlock()  // Ensure that the mutex is unlocked after writing or in case of an error\n\n    // Retrieve the pin by ID with output direction\n    pin, err := a.GetPin(id, \"output\")\n    if err != nil {\n        return err  // Return the error if the pin cannot be retrieved or does not support output\n    }\n\n    // Write the value to the digital pin\n    err = pin.Write(val)\n    if err != nil {\n        return err  // Return any error that occurs during the write operation\n    }\n\n    return nil  // Successful write to the pin\n}", "CodeBleu_score": 59.58412900036445}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error) {\n\tif !a.connected {\n\t\treturn nil, fmt.Errorf(\"adaptor is not connected\")\n\t}\n\n\tpin, ok := a.pins[id]\n\tif !ok {\n\t\t// Pin does not exist, create it\n\t\tchip, line, err := translatePinID(id)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to translate pin ID: %w\", err)\n\t\t}\n\n\t\tpin = NewDigitalPin(chip, line)\n\t\tif err := InitializePin(pin); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unable to initialize pin: %w\", err)\n\t\t}\n\t\t\n\t\t// Store the new pin\n\t\ta.pins[id] = pin\n\t}\n\t\n\t// Apply options to the pin\n\tfor _, opt := range opts {\n\t\tif !opt(pin) {\n\t\t\treturn nil, fmt.Errorf(\"failed to configure pin\")\n\t\t}\n\t}\n\n\treturn pin, nil\n}\n\n// Assistance function to aid in translating a pin's ID to chip and line numbers.\nfunc translatePinID(id string) (int, int, error) {\n\t// This is a stub implementation\n\t// In a real scenario, this should convert a digital pin ID to the chip and line used by the system hardware.\n\treturn 1, 1, nil\n}\n\n// Assistance function to initialize a digital pin\nfunc InitializePin(pin gobot.DigitalPinner) error {\n\t// This should initialize the hardware pin\n\t// For example, setting initial direction or default state.\n\t// This is a stub implementation.\n\treturn nil\n}\n\ntype DigitalPin struct {\n\tChip int\n\tLine int\n}\n\nfunc NewDigitalPin(chip, line int) gobot.DigitalPinner {\n\treturn &DigitalPin{\n\t\tChip: chip,\n\t\tLine: line,\n\t}\n}\n\ntype DigitalPinsAdaptor struct {\n\tconnected bool\n\tpins      map[string]gobot.DigitalPinner\n}\n\n// Example interface implementations for clarity\ntype gobot.DigitalPinner interface {\n\tgobot.DigitalPinOptioner\n}\n\ntype gobot.DigitalPinOptioner interface {\n\tOption() bool // Stub method to demonstrate options functionality\n}", "CodeBleu_score": 43.20276791057521}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error) {\n    // Step 1: Check for connected pins. Assuming `connectedPins` is a map in the adaptor.\n    if len(a.connectedPins) == 0 {\n        return nil, fmt.Errorf(\"no pins connected on this adaptor\")\n    }\n    \n    // Step 2: Try to retrieve the pin by its ID\n    var pin gobot.DigitalPinner\n    var exists bool\n    if pin, exists = a.connectedPins[id]; !exists {\n        // If the pin does not exist, translate ID and create a new pin.\n        chip, line, err := translatePinID(id)\n        if err != nil {\n            return nil, fmt.Errorf(\"could not translate pin ID: %s, error: %v\", id, err)\n        }\n        pin = a.createPin(chip, line)\n        if pin == nil {\n            return nil, fmt.Errorf(\"failed to create a digital pin for chip %d, line %d\", chip, line)\n        }\n        // Store the new pin in the map\n        a.connectedPins[id] = pin\n    }\n    \n    // Step 3: Apply the options to the pin\n    for _, option := range opts {\n        if !option(pin) {\n            return nil, fmt.Errorf(\"failed to apply options to pin %s\", id)\n        }\n    }\n    \n    // Step 4: Return the configured pin\n    return pin, nil\n}", "CodeBleu_score": 44.93343733562012}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error) {\n    // Check if the adaptor is connected to any pins\n    if len(a.pins) == 0 {\n        return nil, fmt.Errorf(\"adaptor not connected to any pins\")\n    }\n\n    // Attempt to retrieve the pin by its ID\n    pin, exists := a.pins[id]\n    if !exists {\n        // If pin does not exist, translate the ID to get chip and line information\n        chip, line, err := translatePinID(id)\n        if err != nil {\n            return nil, err\n        }\n        // Initialize a new digital pin\n        pin = NewDigitalPin(chip, line)\n        \n        // Store the new pin for future references\n        a.pins[id] = pin\n    }\n\n    // Apply options to the pin\n    for _, opt := range opts {\n        if !opt(pin) {\n            return nil, fmt.Errorf(\"failed to apply option to pin %s\", id)\n        } \n    }\n\n    // Return the configured pin\n    return pin, nil\n}\n\nfunc translatePinID(id string) (chip int, line int, err error) {\n    // Dummy function to simulate ID translation\n    if id == \"1\" {\n        return 0, 1, nil\n    } else {\n        return 0, 0, fmt.Errorf(\"unknown pin ID\")\n    }\n}\n\ntype DigitalPinsAdaptor struct {\n    pins map[string]gobot.DigitalPinner\n}\n\nfunc NewDigitalPin(chip, line int) gobot.DigitalPinner {\n    // Details for creating a new digital pin would be handled here\n    return &DigitalPin{chip: chip, line: line}\n}", "CodeBleu_score": 48.13080882867284}]}
