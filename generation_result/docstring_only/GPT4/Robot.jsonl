{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <filesystem>\n#include <fstream>\n\nnamespace fs = std::filesystem;\n\nclass Client {\npublic:\n    std::vector<std::string> GetRequiredFiles(const std::string &folder, const bool download) const {\n        std::vector<std::string> requiredFiles;\n        fs::path folderPath(folder);\n\n        // Check if folder path exists and is a directory\n        if (!fs::exists(folderPath) || !fs::is_directory(folderPath)) {\n            std::cerr << \"Error: Folder does not exist or is not a directory.\" << std::endl;\n            return requiredFiles;\n        }\n\n        // Iterate over the files in the folder and add to the list\n        for (const auto& entry : fs::directory_iterator(folderPath)) {\n            if (entry.is_regular_file()) {\n                std::string filePath = entry.path().string();\n                requiredFiles.push_back(filePath);\n\n                // If download is true, check if the file exists locally\n                if (download) {\n                    if (!fs::exists(filePath)) {\n                        // Simulate file request/download\n                        std::cout << \"Downloading file: \" << filePath << std::endl;\n                        std::ofstream outfile(filePath);\n                        outfile << \"Contents of \" << filePath << std::endl; // Simulating file content\n                        outfile.close();\n                    } else {\n                        // Log that the file is found in cache\n                        std::cout << \"File found in cache: \" << filePath << std::endl;\n                    }\n                }\n            }\n        }\n        return requiredFiles;\n    }\n};", "CodeBleu_score": 43.82793152904091}, {"code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <filesystem>\n\nclass Client {\npublic:\n    std::vector<std::string> GetRequiredFiles(const std::string &folder, const bool download) const {\n        namespace fs = std::filesystem;\n        std::vector<std::string> requiredFiles;\n\n        // Check if the folder exists\n        if (!fs::exists(folder)) {\n            std::cout << \"Folder does not exist: \" << folder << std::endl;\n            return requiredFiles;\n        }\n\n        // Iterate through each file in the directory\n        for (const auto& entry : fs::directory_iterator(folder)) {\n            if (entry.is_regular_file()) {\n                std::string filePath = entry.path().string();\n                requiredFiles.push_back(filePath);\n\n                // Check if we need to handle downloading\n                if (download) {\n                    // Check if the file exists locally\n                    if (!fs::exists(filePath)) {\n                        // Simulate file download\n                        std::cout << \"Requesting and downloading file: \" << filePath << std::endl;\n                    } else {\n                        // Log file found in cache\n                        std::cout << \"File found in cache: \" << filePath << std::endl;\n                    }\n                }\n            }\n        }\n\n        return requiredFiles;\n    }\n};\n\n// Example usage:\nint main() {\n    Client client;\n    std::vector<std::string> files = client.GetRequiredFiles(\"/path/to/folder\", true);\n    std::cout << \"Required files:\" << std::endl;\n    for (const auto& file : files) {\n        std::cout << file << std::endl;\n    }\n    return 0;\n}", "CodeBleu_score": 44.442462590914985}, {"code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <filesystem> // C++17 standard header for file operations\n#include <fstream>    // Stream class to read and write from/to files\n\nclass Client {\npublic:\n    std::vector<std::string> GetRequiredFiles(const std::string &folder, const bool download) const;\n\n    // Assuming these are class member functions for simplicity,\n    // in practice they might be implemented differently\n    void RequestFile(const std::string& filename) const {\n        std::cout << \"Requesting file: \" << filename << std::endl;\n        // Implementation for requesting the file\n    }\n\n    void Log(const std::string& message) const {\n        std::cout << message << std::endl;\n    }\n};\n\nstd::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const {\n    namespace fs = std::filesystem; // Namespace for simplified file operations\n    std::vector<std::string> requiredFiles;\n\n    // Assuming folder is a directory that exists and we have read permission.\n    if (!fs::exists(folder) || !fs::is_directory(folder)) {\n        Log(\"Invalid or non-existent folder specified.\");\n        return requiredFiles;\n    }\n\n    for (const auto& entry : fs::directory_iterator(folder)) {\n        if (entry.is_regular_file()) {\n            const auto& path = entry.path();\n            const std::string filename = path.filename().string();\n\n            // Add all file names found in the directory to the list\n            requiredFiles.push_back(filename);\n\n            // If the download flag is set, check file's local existence and manage accordingly\n            if (download) {\n                if (!fs::exists(path)) {\n                    RequestFile(filename);  // Function requesting the file\n                    Log(\"Downloading: \" + filename);\n                } else {\n                    Log(\"File found in cache: \" + filename);\n                }\n            }\n        }\n    }\n\n    return requiredFiles;\n}", "CodeBleu_score": 44.47326713377338}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "#include <iostream>\n\n// Assume these namespaces and types are defined elsewhere in the codebase\nnamespace rpc {\n    struct Actor {};\n    struct ActorDescription {};\n    enum class AttachmentType { None, SpringArm, SpringArmGhost };\n    using ActorId = int;\n}\n\nnamespace geom {\n    struct Transform {\n        float x, y, z; // Simplified representation of a transformation\n    };\n}\n\nclass Client {\n    public:\n        rpc::Actor SpawnActorWithParent(\n            const rpc::ActorDescription &description,\n            const geom::Transform &transform,\n            rpc::ActorId parent,\n            rpc::AttachmentType attachment_type,\n            const std::string& socket_name) {\n            \n            // Check for specific attachment type conditions\n            if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n                // Check if transformation is valid to prevent ill-formed transformations\n                if (transform.x == 0 && transform.y == 0 && transform.z != 0) {\n                    std::cerr << \"Warning: Transformation is only in the z-axis which might not be valid for SpringArm types.\\n\";\n                }\n            }\n\n            // Here, internallySpawnActorWithParent would be a method that actually spawns the actor with the given transformations and settings.\n            rpc::Actor spawned_actor = internallySpawnActorWithParent(description, transform, parent, attachment_type, socket_name);\n\n            return spawned_actor;\n        }\n\n    private:\n        rpc::Actor internallySpawnActorWithParent(\n            const rpc::ActorDescription &description,\n            const geom::Transform &transform,\n            rpc::ActorId parent,\n            rpc::AttachmentType attachment_type,\n            const std::string& socket_name) {\n                // Implementation details that would handle actual spawning logic,\n                // interfacing with the backend, rendering system, etc.\n                rpc::Actor actor;\n                // Logic to create and register the actor given description, transformation, etc.\n                return actor;\n        }\n};\n\nint main() {\n    // Assumed that ActorDescription and Transform are properly constructed\n    Client game_client;\n    rpc::ActorDescription description;\n    geom::Transform transform{1, 2, 3};\n    std::string socket_name = \"Hand_Hold\";\n    rpc::Actor spawned_actor = game_client.SpawnActorWithParent(description, transform, 1, rpc::AttachmentType::SpringArm, socket_name);\n}", "CodeBleu_score": 46.53127938959438}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name) {\n      \n    // Check for SpringArm or SpringArmGhost attachment type\n    if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        // Check if the transformation in 'z' axis only (x and y are zero)\n        if (transform.translation.x == 0 && transform.translation.y == 0 && transform.translation.z != 0) {\n            std::cerr << \"Warning: Transformation with non-zero z-coordinate only may lead to undefined behavior with the SpringArm attachment.\" << std::endl;\n        }\n    }\n\n    // Call the internal function to spawn actor with parent.\n    rpc::Actor spawned_actor = this->SpawnActorInternal(description, transform, parent, attachment_type, socket_name);\n\n    // Return the newly spawned actor.\n    return spawned_actor;\n}", "CodeBleu_score": 45.57377895125661}, {"code": "#include <iostream>\n#include <cmath> // for fabs\n\nrpc::Actor Client::SpawnActorWithParent(\n    const rpc::ActorDescription &description,\n    const geom::Transform &transform,\n    rpc::ActorId parent,\n    rpc::AttachmentType attachment_type,\n    const std::string& socket_name) {\n    \n    // Check for special condition with SpringArm or SpringArmGhost attachment types\n    if (attachment_type == rpc::AttachmentType::SpringArm || attachment_type == rpc::AttachmentType::SpringArmGhost) {\n        // Note: Assuming transform.translation holds x, y, and z as an accessible struct or similar\n        if (fabs(transform.translation.x) < 0.001f && fabs(transform.translation.y) < 0.001f && fabs(transform.translation.z) >= 0.001f) {\n            std::cerr << \"Warning: Invalid transformation for SpringArm attachment, translation in the Z-axis without XY may yield unexpected behavior.\\n\";\n        }\n    }\n\n    // Assuming _SpawnActorWithinParent is a implemented member function dealing with the actual spawning\n    // and setup of parent-child hierarchy based on ActorDescription, Transform, parent Actor ID, etc.\n    return _SpawnActorWithinParent(description, transform, parent, attachment_type, socket_name);\n}", "CodeBleu_score": 45.176713279880566}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "#include <functional>\n#include <iostream>\n\n// Assuming necessary includes and namespace usage:\nusing Buffer = std::vector<uint8_t>;  // Example Buffer definition\n\nnamespace rpc {\n    typedef int ActorId;  // Example ActorId definition\n}\n\nclass StreamingClient {\npublic:\n    void Subscribe(uint32_t GBufferId, const Buffer& token, std::function<void(Buffer)> callback) {\n        // Dummy implementation; in a real scenario, immediately invoke callback with dummy data\n        Buffer data = {0x01, 0x02, 0x03};  // Dummy data\n        callback(data);\n    }\n};\n\nclass Client {\n    StreamingClient streamingClient;\n\n    Buffer RetrieveToken(rpc::ActorId ActorId, uint32_t GBufferId) {\n        // Simulate retrieving a token for the G-buffer\n        Buffer token = {0x01, 0x02, 0x03, 0x04};  // Dummy token data\n        return token;\n    }\n\npublic:\n    void SubscribeToGBuffer(\n        rpc::ActorId ActorId,\n        uint32_t GBufferId,\n        std::function<void(Buffer)> callback) {\n        Buffer token = RetrieveToken(ActorId, GBufferId);\n        streamingClient.Subscribe(GBufferId, token, callback);\n    }\n};\n\n// Example usage\nint main() {\n    Client client;\n    client.SubscribeToGBuffer(123, 456, [](Buffer buffer) {\n        std::cout << \"Received buffer with size \" << buffer.size() << std::endl;\n        for (auto byte : buffer) {\n            std::cout << \"0x\" << std::hex << (int)byte << ' ';\n        }\n        std::cout << std::endl;\n    });\n\n    return 0;\n}", "CodeBleu_score": 36.469200111478315}, {"code": "#include <iostream>\n#include <functional>\n#include <string>\n\nclass Buffer {\npublic:\n    std::string data;\n\n    Buffer(const std::string& data) : data(data) {} // Constructor to initialize the buffer with data\n};\n\nclass rpc {\npublic:\n    using ActorId = int; // Assuming ActorId is just an int for simplification.\n};\n\nclass Client {\npublic:\n    void SubscribeToGBuffer(rpc::ActorId ActorId, uint32_t GBufferId, std::function<void(Buffer)> callback) {\n        // Simulating retrieval of a token for a G-buffer based on given ActorId and GBufferId\n        std::string tokenData = \"Token [ActorId: \" + std::to_string(ActorId) + \", GBufferId: \" + std::to_string(GBufferId) + \"]\";\n        \n        // Simulating the creation of a buffer with the token data\n        Buffer buffer(tokenData);\n        \n        // \"Subscribing\" to the streaming client using the provided callback\n        if (callback) {\n            callback(buffer);\n        }\n    }\n};\n\n// Example of usage:\n\nvoid PrintBufferData(Buffer buffer) {\n    std::cout << \"Received buffer data: \" << buffer.data << std::endl;\n}\n\nint main() {\n    Client client;\n    int actorId = 1;\n    uint32_t gBufferId = 101;\n    \n    // Subscribing to the GBuffer with an example callback that prints the received buffer's data\n    client.SubscribeToGBuffer(actorId, gBufferId, PrintBufferData);\n\n    return 0;\n}", "CodeBleu_score": 35.573978053236274}, {"code": "// Assuming necessary headers are included, like <functional>, and interfaces for rpc, client, and buffer systems.\n\nvoid Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback) {\n    // Retrieve the token for the specified GBufferId associated with the ActorId\n    Token token = GetGBufferToken(ActorId, GBufferId);\n\n    if (!token.IsValid()) {\n        throw std::runtime_error(\"Failed to retrieve a valid token for GBuffer\");\n    }\n\n    // Copy token data\n    Token copyOfToken = token;  // Assuming copy constructor handles appropriate deep copy, if necessary\n\n    // Subscribe to streaming client using the callback\n    try {\n        streaming_client_.Subscribe(copyOfToken, callback);\n    } catch (const std::exception& e) {\n        std::cerr << \"Subscription failed: \" << e.what() << std::endl;\n        throw;\n    }\n}\n\n// Assuming presence of these methods or handling them accordingly\nToken Client::GetGBufferToken(rpc::ActorId actorId, uint32_t gBufferId) {\n    // Implementation for retrieving a token, could involve network calls, cache check, etc.\n    // Returning a placeholder token, real implementation needed\n    return Token(actorId, gBufferId);  // Assuming Token has a constructor accepting these values\n}\n\nvoid StreamingClient::Subscribe(Token token, std::function<void(Buffer)> callback) {\n    // Implementation for subscribing to a StreamingClient\n    // This might involve network operations, registering the callback in some event loop etc.\n}", "CodeBleu_score": 39.089002313469}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "#include <memory>\n\nclass WalkerNavigation {\npublic:\n    WalkerNavigation() {\n        // Constructor implementation, if required\n    }\n};\n\nclass Episode {\nprivate:\n    std::shared_ptr<WalkerNavigation> navigation;\n\npublic:\n    std::shared_ptr<WalkerNavigation> CreateNavigationIfMissing() {\n        if (!navigation) {  // Check If navigation does NOT exist.\n            navigation = std::make_shared<WalkerNavigation>();  // Create a new WalkerNavigation instance.\n        }\n        return navigation;  // Return the existing or newly created navigation object.\n    }\n};", "CodeBleu_score": 32.894196963363974}, {"code": "#include <memory>\n\nclass WalkerNavigation {\npublic:\n    WalkerNavigation() {\n        // Constructor logic for WalkerNavigation if needed\n    }\n    // Additional methods or data members\n};\n\nclass Episode {\nprivate:\n    std::shared_ptr<WalkerNavigation> navigation;\n\npublic:\n    std::shared_ptr<WalkerNavigation> CreateNavigationIfMissing() {\n        if (navigation == nullptr) {\n            navigation = std::make_shared<WalkerNavigation>();\n        }\n        return navigation;\n    }\n};", "CodeBleu_score": 41.824236057836664}, {"code": "#include <memory>\n\n// Assuming WalkerNavigation and Episode are part of a namespace or some context which hasn't been specified.\nclass WalkerNavigation {\npublic:\n    WalkerNavigation() {\n        // Constructor implementation here (if needed).\n    }\n    // Additional methods and members of WalkerNavigation.\n};\n\nclass Episode {\nprivate:\n    std::shared_ptr<WalkerNavigation> navigation;\n\npublic:\n    std::shared_ptr<WalkerNavigation> CreateNavigationIfMissing() {\n        // Check if the navigation object is nullptr and create it if so\n        if (!navigation) {\n            navigation = std::make_shared<WalkerNavigation>();\n        }\n        return navigation;\n    }\n\n    // Other members and methods of Episode.\n};\n\nint main() {\n    // For demonstration we are assuming we can just create an Episode object like this.\n    // Further integration with the rest of the application logic may be needed based on your specific setup.\n\n    Episode myEpisode;\n    auto navigation = myEpisode.CreateNavigationIfMissing();\n    // Navigation can now be used as required\n\n    return 0;\n}", "CodeBleu_score": 41.89508706861121}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "#include <chrono>\n#include <thread>\n\n/*\n * This function, SynchronizeFrame, attempts to synchronize a given frame with \n * the episode state within a specified timeout duration. \n * It continuously checks if the current frame of the episode state is less than \n * the given frame and yields control if true.\n * If the timeout duration is exceeded, the function returns false.\n * If synchronization is successful within the timeout, it triggers a tick in \n * the TrafficManager and returns true.\n */\n\nstatic bool SynchronizeFrame(uint64_t frame, const Episode &episode, std::chrono::milliseconds timeout) {\n    using namespace std::chrono;\n    auto start_time = steady_clock::now();\n    auto end_time = start_time + timeout;\n\n    while (steady_clock::now() < end_time) {\n        if (episode.GetCurrentFrame() >= frame) {\n            episode.GetTrafficManager().Tick();\n            return true;\n        }\n        std::this_thread::yield(); // Yield the execution to other threads.\n    }\n    \n    return false; // Timeout occurred before synchronizing.\n}", "CodeBleu_score": 41.64947566923807}, {"code": "#include <chrono>\n#include <thread>\n\nusing namespace std::chrono;\n\nstatic bool SynchronizeFrame(uint64_t frame, const Episode &episode, milliseconds timeout) {\n    auto start_time = steady_clock::now();\n\n    while (episode.GetCurrentFrame() < frame) {\n        // Check if the timeout has been exceeded\n        if (duration_cast<milliseconds>(steady_clock::now() - start_time) > timeout) {\n            return false;\n        }\n\n        // Yield the control to other processes or threads\n        std::this_thread::sleep_for(milliseconds(1));\n    }\n\n    // If the current frame is equal to or higher than the desired frame\n    TrafficManager::Tick();  // Assuming there is a static method Tick in TrafficManager\n    return true;\n}", "CodeBleu_score": 36.904048583391834}, {"code": "#include <chrono>\n\nstatic bool SynchronizeFrame(uint64_t frame, const Episode &episode, std::chrono::milliseconds timeout) {\n    auto start_time = std::chrono::steady_clock::now();\n\n    // Loop until the current frame of the episode matches or exceeds the target frame,\n    // or until the timeout has been reached.\n    while (episode.GetCurrentFrame() < frame) {\n        auto current_time = std::chrono::steady_clock::now();\n        auto elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(current_time - start_time);\n\n        // Check if the elapsed time has exceeded the timeout duration\n        if (elapsed_time > timeout) {\n            return false; // Timeout has occurred before synchronization\n        }\n        \n        // Yield control to other processes or threads, sleeping briefly\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n    }\n    \n    // Successful synchronization within the timeout\n    // Trigger a tick in the TrafficManager here if necessary (functionality/context specific)\n    episode.GetTrafficManager().Tick();\n\n    return true;\n}", "CodeBleu_score": 50.24837371713641}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "#include <chrono>\n#include <thread>\n#include <stdexcept>\n\nclass EpisodeProxy {\npublic:\n    std::string episodeID;\n    // Assume EpisodeProxy has other necessary methods and properties\n};\n\nclass Simulator {\npublic:\n    EpisodeProxy currentEpisode;\n\n    Simulator() {}\n\n    EpisodeProxy LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers) {\n        const int timeout = 5000; // Timeout of 5000 milliseconds\n        const int retryInterval = 200; // Retry interval of 200 milliseconds\n        int timeElapsed = 0; // Track the elapsed time\n\n        // Start loading the episode\n        LoadMap(map_name, reset_settings, map_layers);\n\n        // Initial episode ID before change\n        std::string initialEpisodeID = currentEpisode.episodeID;\n        \n        // Waiting for new episode ID\n        while (timeElapsed <= timeout) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(retryInterval));\n            timeElapsed += retryInterval;\n\n            // Update the status of current episode\n            UpdateCurrentEpisode();\n\n            if (currentEpisode.episodeID != initialEpisodeID) {\n                return currentEpisode;  // Successfully loaded new episode\n            }\n        }\n\n        // If the code reaches here, it means failure to load within the timeout\n        throw std::runtime_error(\"Failed to load new episode within the timeout period.\");\n    }\n\n    void LoadMap(std::string map_name, bool reset_settings, rpc::MapLayer map_layers) {\n        // Simulate map loading\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        // Simulates changing the episode\n        currentEpisode.episodeID = \"new_episode_id_\" + map_name;\n    }\n\n    void UpdateCurrentEpisode() {\n        // Simulating an update from perhaps a network or database update\n        // In this example, it's static but assume it might check a server or a cache\n    }\n};\n\n// You need to define rpc::MapLayer prior to this if it's not defined elsewhere\nnamespace rpc {\n    enum class MapLayer {\n        DEFAULT,\n        TRAFFIC,\n        WEATHER,\n        CUSTOM\n    };\n}", "CodeBleu_score": 40.17076937624127}, {"code": "class Simulator {\npublic:\n    EpisodeProxy LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers) {\n        // Assuming there are methods to perform these functions, e.g.,\n        //   SetMap(std::string name, bool resetSettings, rpc::MapLayer layers)\n        //   GetCurrentEpisodeID() for checking episode changes\n        \n        // Current episode ID before loading new episode\n        auto currentEpisodeID = GetCurrentEpisodeID();\n\n        // Load the map with new settings\n        SetMap(map_name, reset_settings, map_layers);\n        \n        // Timeout setting\n        const int timeoutSeconds = 10;  // Maximum time to wait for map to load\n        auto startTime = std::chrono::steady_clock::now();\n        \n        // Keep polling to see if the episode has changed\n        while (std::chrono::steady_clock::now() - startTime < std::chrono::seconds{timeoutSeconds}) {\n            auto newEpisodeID = GetCurrentEpisodeID();\n            if (newEpisodeID != currentEpisodeID) {\n                // Load was successful; return new EpisodeProxy\n                return GetEpisodeProxy(newEpisodeID);\n            }\n            \n            // Sleep for a short while before retrying\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        }\n\n        // If we exit the loop, we did not connect successfully\n        throw std::runtime_error(\"Failed to load or connect to new Episode within timeout period.\");\n    }\n\nprivate:\n    std::string GetCurrentEpisodeID() {\n        // This should be implemented to return current episode ID\n    }\n\n    void SetMap(std::string map_name, bool reset, rpc::MapLayer layers) {\n        // Implement setting logic for load map\n    }\n\n    EpisodeProxy GetEpisodeProxy(std::string episodeID) {\n        // This should create or return an EpisodeProxy object for given ID\n    }\n};", "CodeBleu_score": 42.206378283119015}, {"code": "#include <iostream>\n#include <stdexcept>\n#include <chrono>\n#include <thread>\n\nclass EpisodeProxy {\n    std::string episodeID;\n\npublic:\n    EpisodeProxy(std::string id) : episodeID(id) {}\n\n    std::string getEpisodeID() const {\n        return episodeID;\n    }\n};\n\nnamespace rpc {\n    enum class MapLayer {\n        Base,\n        Objects,\n        Traffic,\n        // Add additional layers as needed\n    };\n}\n\nclass Simulator {\npublic:\n    EpisodeProxy LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers) {\n        int max_attempts = 5;   // Number of maximum attempts\n        int attempt = 0;        // Initial attempt count\n        int timeout_ms = 1000;  // Timeout in milliseconds\n\n        std::string currentEpisodeID = getCurrentEpisodeID();\n        std::string newEpisodeID;\n\n        // Attempt to load new episode within a certain timeout period\n        while (attempt < max_attempts) {\n            attempt++;\n            loadMap(map_name, reset_settings, map_layers);\n            newEpisodeID = getCurrentEpisodeID();\n\n            if (currentEpisodeID != newEpisodeID) {\n                std::cout << \"Episode loaded successfully\" << std::endl;\n                return EpisodeProxy(newEpisodeID);\n            }\n\n            // If episode not loaded, wait and try again\n            std::this_thread::sleep_for(std::chrono::milliseconds(timeout_ms));\n            std::cout << \"Attempt \" << attempt << \": Failed to connect, trying again...\" << std::endl;\n        }\n\n        // If all attempts are exhausted, throw runtime error\n        throw std::runtime_error(\"Failed to connect to new episode after \" + std::to_string(max_attempts) + \" attempts.\");\n    }\n\nprivate:\n    std::string getCurrentEpisodeID() {\n        // Implementation to get ID from the simulator\n        return \"sampleID\";  // This should be a real method retrieving the ID\n    }\n\n    void loadMap(std::string map_name, bool reset_settings, rpc::MapLayer map_layers) {\n        std::cout << \"Loading map: \" << map_name << ((reset_settings) ? \", with reset\" : \", no reset\") \n                  << \". Layer: \" << static_cast<int>(map_layers) << std::endl;\n        // Process of loading map and corresponding layers\n    }\n};", "CodeBleu_score": 39.923567638558964}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "#include <stdexcept> // Include for std::runtime_error\n#include <cassert> // Include for assert\n\nvoid Simulator::RegisterAIController(const WalkerAIController &controller) {\n    // Assert that the episode is not null\n    assert(episode != NULL);\n\n    // Retrieve the walker associated with the given controller\n    Walker* walker = episode->findWalkerById(controller.getWalkerId());\n    \n    // Throw an exception if the walker is not found\n    if (!walker) {\n        throw std::runtime_error(\"Walker with the given ID not found\");\n    }\n  \n    // Create navigation for walker if it does not already exist\n    if (walker->navigation == NULL) {\n        walker->navigation = new Navigation();\n    }\n\n    // Register the walker with the controller's ID\n    episode->registerWalker(controller.getId(), walker);\n}", "CodeBleu_score": 44.80909218472641}, {"code": "#include <stdexcept>\n#include <cassert>\n\nclass WalkerAIController {\npublic:\n    int getId() const;\n};\n\nclass Walker {\npublic:\n    // Assuming some functionality that might exist on Walker\n    void setController(const WalkerAIController& controller);\n};\n\nclass Simulator {\n    std::map<int, Walker*> walkers;\n    bool episodeNotNull;\n\npublic:\n    Simulator() : episodeNotNull(true) {}\n    void RegisterAIController(const WalkerAIController &controller);\n};\n\nvoid Simulator::RegisterAIController(const WalkerAIController &controller) {\n    assert(episodeNotNull);  // Assert that the episode is not null\n\n    int controllerId = controller.getId();\n\n    // Retrieve the walker associated with the controller ID\n    auto it = walkers.find(controllerId);\n    if (it == walkers.end()) {\n        throw std::runtime_error(\"Walker not found for the provided controller ID.\");\n    }\n\n    Walker* walker = it->second;\n\n    if (walker == nullptr) {\n        // Optionally handle the case where walker pointer might be unexpectedly null\n        throw std::runtime_error(\"Associated walker is null.\");\n    }\n\n    // Optionally, this could be a place where navigation for the walker is created or verified\n    // For example: if (!walker->navigationAvailable()) { walker->createNavigation(); }\n\n    // Register the walker with the controller's ID\n    walker->setController(controller);\n}", "CodeBleu_score": 48.684935538723785}, {"code": "#include <stdexcept>\n#include <iostream>\n#include <assert.h>\n\nclass WalkerAIController {\npublic:\n    int getID() const { return id; }\n    // Other member functions\nprivate:\n    int id;\n    // Other data members\n};\n\nclass Walker {\npublic:\n    Walker() {}\n    void setControllerID(int id) { controllerID = id; }\n    // Other member functions and data members\nprivate:\n    int controllerID;\n};\n\nclass Simulator {\npublic:\n    Simulator() : episode(nullptr) {}\n\n    void RegisterAIController(const WalkerAIController &controller) {\n        // Ensure episode is not null\n        assert(episode != nullptr && \"Episode cannot be null\");\n\n        // Attempt to retrieve walker from some data structure, assume walkers is a map for this example\n        auto it = walkers.find(controller.getID());\n        if (it == walkers.end()) {\n            throw std::runtime_error(\"Walker for given controller ID not found\");\n        }\n\n        Walker* walker = it->second;\n        \n        if (walker == nullptr) {\n            throw std::runtime_error(\"Walker is null\");\n        }\n        \n        // If the walker doesn't have navigation, let's create one\n        if (!walker->hasNavigation()) {\n            walker->createNavigation();\n        }\n\n        // Assign this controller to the walker\n        walker->setControllerID(controller.getID());\n\n        std::cout << \"Controller with ID \" << controller.getID() << \" successfully registered to a walker.\" << std::endl;\n    }\n\n    // Other member functions and data members\nprivate:\n    struct Episode* episode;  // Hypothetical structure pointer for episode management\n    std::map<int, Walker*> walkers;  // Map of walkers indexed by ID\n};\n\nint main() {\n    Simulator sim;\n    WalkerAIController controller; // Assuming there's way to set up or retrieve a fully initialized controller\n    try {\n        sim.RegisterAIController(controller);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}", "CodeBleu_score": 47.49591733829692}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "// Implement the body of SpawnActor function based on the provided description\n\nSharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name) {\n\n    // Step 1: Create the actor using the blueprint and the specified transform\n    SharedPtr<Actor> newActor = MakeShared<Actor>(blueprint, transform);\n\n    // Step 2: Check if a parent is specified\n    if (parent != nullptr) {\n        // Attach the new actor to the parent\n        parent->AttachChild(newActor, attachment_type, socket_name);\n        \n        // Log parent-child relation\n        std::cout << \"Actor \" << newActor->GetName() << \" spawned as child of \" << parent->GetName() << \" at socket \" << socket_name << std::endl;\n    } else {\n        // Log independent spawning\n        std::cout << \"Actor \" << newActor->GetName() << \" spawned independently.\" << std::endl;\n    }\n\n    // Step 3: Register the actor in the current episode\n    this->current_episode.RegisterActor(newActor);\n\n    // Step 4: Apply the garbage collection policy\n    this->ApplyGarbageCollectionPolicy(newActor, gc);\n\n    // Step 5: Log the creation\n    std::cout << \"Actor \" << newActor->GetName() << \" created with ID \" << newActor->GetId() << std::endl;\n\n    // Step 6: Return the new actor\n    return newActor;\n}", "CodeBleu_score": 44.40746266169819}, {"code": "// First, create a new actor instance using the blueprint\n    SharedPtr<Actor> actor = CreateActor(blueprint);\n    if (!actor) {\n        std::cerr << \"Failed to create actor from blueprint.\" << std::endl;\n        return nullptr; // Fail and return nullptr if actor could not be created.\n    }\n\n    // Apply the transformation to the actor\n    actor->SetTransform(transform);\n\n    // If a parent is specified, attach to it\n    if (parent != nullptr) {\n        // Attach the actor to the parent according to the attachment type and socket\n        if (!parent->AttachActor(actor, attachment_type, socket_name)) {\n            std::cerr << \"Failed to attach actor to parent.\" << std::endl;\n            return nullptr; // If attachment fails, return nullptr\n        }\n    }\n\n    // Register the actor in the current episode\n    if (!RegisterActorInCurrentEpisode(actor)) {\n        std::cerr << \"Failed to register actor in current episode.\" << std::endl;\n        return nullptr; // If registration fails, return nullptr\n    }\n\n    // Apply garbage collection policy to the new actor\n    ApplyGarbageCollectionPolicy(actor, gc);\n\n    // Log creation details\n    LogActorCreation(actor, blueprint, transform, parent, attachment_type, socket_name);\n\n    // Return the newly created actor\n    return actor;\n}\n\n// Helpers (assuming signatures are known and their implementations are appropriate)\nSharedPtr<Actor> CreateActor(const ActorBlueprint &blueprint);\nbool RegisterActorInCurrentEpisode(const SharedPtr<Actor>& actor);\nvoid ApplyGarbageCollectionPolicy(const SharedPtr<Actor>& actor, GarbageCollectionPolicy gc);\nvoid LogActorCreation(const SharedPtr<Actor>& actor, const ActorBlueprint &blueprint, const geom::Transform &transform, const Actor *parent, rpc::AttachmentType attachment_type, const std::string& socket_name);\nbool Actor::AttachActor(const SharedPtr<Actor> &child, rpc::AttachmentType type, const std::string &socket_name);\nvoid Actor::SetTransform(const geom::Transform &transform);", "CodeBleu_score": 42.41689982504818}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)\n{\n    // Create a new actor based on the provided blueprint\n    SharedPtr<Actor> new_actor = std::make_shared<Actor>(blueprint, transform);\n\n    // If a parent actor is specified, attach the new actor as a child\n    if (parent != nullptr) {\n        parent->AttachChild(new_actor, attachment_type, socket_name);\n    }\n\n    // Register the actor within the current episode\n    episode_.RegisterActor(new_actor);\n\n    // Apply the garbage collection policy specified\n    new_actor->SetGarbageCollectionPolicy(gc);\n\n    // Log the creation details\n    Log(\"Actor Created: ID=\" + std::to_string(new_actor->GetID()) + \", Blueprint=\" + blueprint.GetName());\n\n    // Return the newly created actor\n    return new_actor;\n}\n", "CodeBleu_score": 36.43287349715797}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "#include <iostream>\n#include <functional>\n#include <memory>\n\nclass SensorData {\n    // Sensor data content\n};\n\nnamespace sensor {\n    using SensorData = ::SensorData;\n    // possibly other sensor-related definitions\n}\n\nclass Client {\npublic:\n    void SubscribeToStream(const Sensor& sensor, std::function<void(std::shared_ptr<sensor::SensorData>)> dataHandler) {\n        // Implementation to subscribe to sensor's data stream\n        // Example:\n        std::cout << \"Subscribing to sensor stream...\" << std::endl;\n        // Simulate received data:\n        auto data = std::make_shared<sensor::SensorData>();\n        dataHandler(data);\n    }\n};\n\nclass Episode {\npublic:\n    bool IsValid() const {\n        // Implementation to check if the episode is valid\n        return true;  // Assume always valid for this example\n    }\n};\n\nclass Sensor {\n    // Sensor related members\n};\n\nclass Simulator {\nprivate:\n    Client client;\n    SharedPtr<Episode> currentEpisode;\n\npublic:\n    void SubscribeToSensor(\n        const Sensor& sensor,\n        std::function<void(SharedPtr<sensor::SensorData>)> callback) {\n\n        // Check if the episode is valid\n        if (!currentEpisode || !currentEpisode->IsValid()) {\n            std::cerr << \"Invalid episode, cannot subscribe to sensor.\" << std::endl;\n            return;\n        }\n\n        // Subscribe to the sensor's data stream\n        client.SubscribeToStream(sensor, [this, callback](std::shared_ptr<sensor::SensorData> data) {\n            if (!currentEpisode || !currentEpisode->IsValid()) {\n                std::cerr << \"Invalid episode when processing received data.\" << std::endl;\n                return;\n            }\n\n            // Call the user-provided callback with the associated data\n            callback(data);\n        });\n    }\n};", "CodeBleu_score": 39.62500285336422}, {"code": "void Simulator::SubscribeToSensor(\n    const Sensor& sensor,\n    std::function<void(SharedPtr<sensor::SensorData>)> callback) {\n\n    // Check if the episode is valid\n    if (!currentEpisode || !currentEpisode->IsValid()) {\n        std::cerr << \"Invalid episode.\" << std::endl;\n        return;\n    }\n\n    // Set up a lambda to serve as the callback for when new sensor data arrives\n    auto sensorDataHandler = [this, callback](const auto& rawStreamData) {\n        // Deserialize the incoming stream data into sensor data\n        SharedPtr<sensor::SensorData> sensorData = DeserializeSensorData(rawStreamData);\n\n        if (!sensorData) {\n            std::cerr << \"Failed to deserialize sensor data.\" << std::endl;\n            return;\n        }\n\n        // Associate the data with the current episode\n        sensorData->SetEpisode(currentEpisode);\n\n        // Invoke the provided callback with the sensor data\n        callback(sensorData);\n    };\n\n    // Subscribe to the sensor's data stream using the client object\n    client.SubscribeToStream(sensor.GetStreamId(), sensorDataHandler);\n}\n\nSharedPtr<sensor::SensorData> Simulator::DeserializeSensorData(const std::string& data) {\n    // Assuming a generic approach to deserialization that could vary depending on sensor type and data format\n    // This is a stub and should be replaced with actual deserialization logic\n    return std::make_shared<sensor::SensorData>(data); // Simplified example for demonstration purposes\n}", "CodeBleu_score": 43.65317635698815}, {"code": "#include <memory>\n#include <functional>\n\nclass Simulator {\npublic:\n    void SubscribeToSensor(\n        const Sensor& sensor,\n        std::function<void(std::shared_ptr<sensor::SensorData>)> callback)\n    {\n        // Step 1: Check if the current episode is valid\n        if (!currentEpisode.isValid()) {\n            throw std::runtime_error(\"Invalid episode\");\n        }\n\n        // Step 2: Subscribe to the sensor's data stream\n        client.SubscribeToStream(sensor.getStreamId(),\n            [this, callback](const auto &rawData) {\n                // Step 3: Handle the incoming data\n                try {\n                    // Deserialize the raw data into usable sensor data\n                    auto sensorData = std::make_shared<sensor::SensorData>(DeserializeSensorData(rawData));\n\n                    // Associate the sensor data with the current episode\n                    sensorData->setEpisode(currentEpisode);\n\n                    // Invoke the original callback with the prepared sensor data\n                    callback(sensorData);\n                } catch (const std::exception& e) {\n                    std::cerr << \"Failed to handle sensor data: \" << e.what() << std::endl;\n                }\n            }\n        );\n    }\n\nprivate:\n    Client client; // Assuming 'Client' is a class handling communication\n    Episode currentEpisode; // Assuming 'Episode' is a class representing an episode context\n\n    sensor::SensorData DeserializeSensorData(const std::string& rawData) {\n        // Implement deserialization logic specific to the sensor data expected\n        // This is a placeholder logic\n        return sensor::SensorData(rawData);\n    }\n};", "CodeBleu_score": 39.99614249270734}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "#include <vector>\n#include <memory>\n#include <algorithm>\n\nclass WalkerNavigation {\n    std::vector<WalkerController*> walkers;\n    NavigationModule* navigationModule;\n    Simulator* simulator;\n\npublic:\n    WalkerNavigation(NavigationModule* navModule, Simulator* sim) : navigationModule(navModule), simulator(sim) {}\n\n    void Tick(std::shared_ptr<Episode> episode) {\n        // Load current walkers\n        this->walkers = episode->GetWalkers();\n        \n        // Check if the list of walkers is empty\n        if (walkers.empty()) return;\n\n        // Get current state of the episode\n        EpisodeState currentState = episode->GetState();\n\n        // Remove any walkers that no longer exist\n        walkers.erase(std::remove_if(walkers.begin(), walkers.end(),\n                                     [&](WalkerController* walker) {\n                                         return !episode->WalkerExists(walker->GetId());\n                                     }), \n                      walkers.end());\n\n        // Update vehicles in the crowd\n        episode->UpdateVehicles();\n\n        // Update the crowd in the navigation module\n        navigationModule->UpdateCrowd(walkers);\n\n        // Apply states in a batch to the simulator\n        for (auto walker : walkers) {\n            Transform walkerTransform = walker->GetTransform();\n            float walkerSpeed = walker->GetSpeed();\n            simulator->ApplyWalkerState(walker->GetId(), walkerTransform, walkerSpeed);\n        }\n\n        // Remove killed walkers\n        for (auto walker : walkers) {\n            if (walker->IsDead()) {\n                // Handling the removal from the crowd\n                navigationModule->RemoveFromCrowd(walker);\n                // Destroy their controller\n                delete walker;\n            }\n        }\n\n        // Clean up or refresh the list of walkers\n        walkers.erase(std::remove_if(walkers.begin(), walkers.end(),\n                                     [](const WalkerController* walker) {\n                                         return walker->IsDead();\n                                     }), \n                      walkers.end());\n    }\n};", "CodeBleu_score": 34.807438054991614}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode) {\n    // 1. Load current walkers:\n    auto walkers = episode->GetWalkers();\n    if (walkers.empty()) {\n        return; // Return if walker list is empty.\n    }\n\n    // 2. Retrieve and update episode state:\n    auto state = episode->GetState();\n    episode->UpdateState(state);\n\n    // 3. Remove non-existent walkers:\n    for (auto it = walkers.begin(); it != walkers.end();) {\n        if (!episode->WalkerExists(*it)) {\n            it = walkers.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    // 4. Update the vehicles in crowd and crowd itself:\n    navigationModule->UpdateVehiclesInCrowd(walkers);\n    navigationModule->UpdateCrowd(state);\n\n    // 5. Apply transforms and speeds to each walker:\n    std::vector<Transform> transforms;\n    std::vector<float> speeds;\n    transforms.reserve(walkers.size());\n    speeds.reserve(walkers.size());\n\n    for (const auto& walker : walkers) {\n        Transform transform = walker->GetTransform();\n        float speed = walker->GetSpeed();\n        transforms.push_back(transform);\n        speeds.push_back(speed);\n    }\n\n    // 6. Batch apply simulator transforms and speeds:\n    simulator->BatchApplyTransformsAndSpeeds(walkers, transforms, speeds);\n\n    // 7. Check and remove killed walkers:\n    for (auto it = walkers.begin(); it != walkers.end();) {\n        if ((*it)->IsKilled()) {\n            navigationModule->RemoveFromCrowd(*it);\n            (*it)->DestroyController();\n            it = walkers.erase(it); // Remove walker from list.\n        } else {\n            ++it;\n        }\n    }\n}", "CodeBleu_score": 47.47350349557395}, {"code": "#include <memory>\n#include <vector>\n#include <algorithm>\n\nclass Walker {\npublic:\n    int id;\n    bool isAlive;\n    Transform transform;\n    float speed;\n};\n\nclass Episode {\npublic:\n    std::vector<Walker> walkers;\n    State getCurrentState() {\n        // Return the current state of the simulation episode\n        return State();\n    }\n    \n    void removeDestroyedWalkers(std::vector<Walker>& walkers) {\n        walkers.erase(\n            std::remove_if(walkers.begin(), walkers.end(), [](const Walker& walker) { \n                return !walker.isAlive; \n            }), \n            walkers.end()\n        );\n    }\n};\n\nclass NavigationModule {\npublic:\n    void updateVehicles(std::vector<Walker>& walkers) {\n        // Update vehicle-related behaviors based on provided walkers\n    }\n\n    void updateCrowd(std::vector<Walker>& walkers) {\n        // Update crowd simulation based on walkers\n    }\n};\n\nclass WalkerNavigation {\nprivate:\n    NavigationModule navigation;\n\n    void handleDeadWalkers(std::vector<Walker>& walkers) {\n        for (auto& walker : walkers) {\n            if (!walker.isAlive) {\n                // Destroy the walker's controller if necessary\n                destroyController(walker);\n            }\n        }\n    }\n\n    void destroyController(Walker& walker) {\n        // Logic to destroy a walker's controller\n    }\n\npublic:\n    void Tick(std::shared_ptr<Episode> episode) {\n        // Load current walkers\n        auto& walkers = episode->walkers;\n\n        // If no walkers, return\n        if (walkers.empty()) {\n            return;\n        }\n\n        // Get current state of the episode\n        auto state = episode->getCurrentState();\n\n        // Remove any walkers that no longer exist\n        episode->removeDestroyedWalkers(walkers);\n\n        // Update vehicles and the crowd in the navigation module\n        navigation.updateVehicles(walkers);\n        navigation.updateCrowd(walkers);\n\n        // Apply new states to the simulator in a batch\n        applyBatchStates(walkers);\n\n        // Check if any walker has been killed\n        handleDeadWalkers(walkers);\n    }\n\n    void applyBatchStates(const std::vector<Walker>& walkers) {\n        for (const auto& walker : walkers) {\n            // Apply walker's state to the simulator\n            applyState(walker);\n        }\n    }\n\n    void applyState(const Walker& walker) {\n        // Implement the application of the walker's transform and speed to the simulator\n    }\n};", "CodeBleu_score": 33.46964134275261}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "#include <vector>\n#include <string>\n\n// Assuming definition of rpc::ActorDescription\nnamespace rpc {\n    class ActorDescription {\n    public:\n        void SetUID(std::string uid) { this->uid = uid; }\n        void SetID(std::string id) { this->id = id; }\n        void AddAttribute(const std::string &attribute) {\n            attributes.push_back(attribute);\n        }\n        \n    private:\n        std::string uid;\n        std::string id;\n        std::vector<std::string> attributes;\n    };\n}\n\n// Example ActorBlueprint class with assumed properties.\nclass ActorBlueprint {\npublic:\n    // Assume these member functions exist to get the relevant fields as necessary.\n    std::string GetUID() const { return uid; }\n    std::string GetID() const { return id; }\n    const std::vector<std::string>& GetAttributes() const { return attributes; }\n\n    rpc::ActorDescription MakeActorDescription() const {\n        rpc::ActorDescription desc;\n        desc.SetUID(GetUID());\n        desc.SetID(GetID());\n\n        for (const auto& attribute : GetAttributes()) {\n            desc.AddAttribute(attribute);\n        }\n        \n        return desc;\n    }\n\nprivate:\n    std::string uid = \"12345\";\n    std::string id = \"67890\";\n    std::vector<std::string> attributes = {\"Attribute1\", \"Attribute2\"};\n};\n\nint main() {\n    ActorBlueprint blueprint;\n    rpc::ActorDescription description = blueprint.MakeActorDescription();\n    // Use the description object as needed\n}", "CodeBleu_score": 42.626520973935044}, {"code": "#include \"ActorBlueprint.h\"\n#include \"rpc/ActorDescription.h\"\n\nrpc::ActorDescription ActorBlueprint::MakeActorDescription() const {\n    // Create a new instance of rpc::ActorDescription\n    rpc::ActorDescription description;\n\n    // Initialize the description with UID and ID\n    description.UID = this->UID;\n    description.ID = this->ID;\n\n    // Reserve space for attributes\n    description.attributes.reserve(this->attributes.size());\n\n    // Copy each attribute from ActorBlueprint to the description\n    for (const auto& attribute : this->attributes) {\n        description.attributes.push_back(attribute);\n    }\n\n    // Return the fully constructed rpc::ActorDescription object\n    return description;\n}", "CodeBleu_score": 64.66931915288738}, {"code": "#include \"ActorBlueprint.h\"\n#include \"ActorDescription.h\"  // Assuming rpc::ActorDescription is defined here\n\nrpc::ActorDescription ActorBlueprint::MakeActorDescription() const {\n    rpc::ActorDescription desc;\n\n    // Assuming rpc::ActorDescription has methods setUID, setID and that ActorBlueprint has\n    // methods getUID and getID, which retrieve UID and ID of the actor, respectively.\n    desc.setUID(this->getUID());\n    desc.setID(this->getID());\n\n    // Reserving attribute space if needed (if rpc::ActorDescription has such functionality)\n    // and assuming an std::vector<AttributeType> is used to handle attributes in ActorBlueprint.\n    desc.reserveAttributes(this->attributes.size());\n\n    // Assuming there's a method in rpc::ActorDescription to add attributes one by one.\n    for (const auto& attribute : this->attributes) {\n        desc.addAttribute(attribute);\n    }\n\n    return desc;\n}", "CodeBleu_score": 50.614084540811255}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "#include <vector>\n#include <memory>\n#include <string>\n\nclass Blueprint {\npublic:\n    // Assume Blueprint has a method to check and get the attribute value.\n    bool getAttributeValue(const std::string& attributeName, std::string& outValue) const {\n        // The actual logic to get attribute should be implemented here.\n        // Below is a dummy implementation for demonstration.\n        // Let's assume each blueprint has a map or similar structure storing attributes.\n        auto it = attributes.find(attributeName);\n        if (it != attributes.end()) {\n            outValue = it->second;\n            return true;\n        }\n        return false;\n    }\n\nprivate:\n    std::map<std::string, std::string> attributes; // Attributes map\n};\n\nclass BlueprintLibrary {\npublic:\n    std::vector<SharedPtr<Blueprint>> blueprints;\n\n    SharedPtr<BlueprintLibrary> FilterByAttribute(const std::string &name, const std::string& value) const {\n        // Create a new BlueprintLibrary to hold the filtered blueprints.\n        SharedPtr<BlueprintLibrary> filteredLibrary = std::make_shared<BlueprintLibrary>();\n\n        // Iterate over all blueprints in the current library.\n        for (auto &bp : blueprints) {\n            std::string attributeValue;\n            // Check if the blueprint has the specified attribute with the desired value.\n            if (bp->getAttributeValue(name, attributeValue) && attributeValue == value) {\n                // If the attribute exists and matches the specified value, add to the filtered library.\n                filteredLibrary->blueprints.push_back(bp);\n            }\n        }\n\n        // Return the new library containing only filtered blueprints.\n        return filteredLibrary;\n    }\n};\n\n// Usage of BluePrintLibrary.\nint main() {\n    // Setup an example library and call FilterByAttribute.\n    auto myLibrary = std::make_shared<BlueprintLibrary>();\n\n    // Sample blueprints population to myLibrary would happen here.\n    // Filter method invocation example\n    auto filteredLibrary = myLibrary->FilterByAttribute(\"color\", \"blue\");\n\n    return 0;\n}", "CodeBleu_score": 44.93848413012579}, {"code": "#include <vector>\n#include <memory>\n#include <string>\n\nclass Blueprint {\npublic:\n    bool HasAttribute(const std::string& name) const {\n        // Check if the attribute name exists in the blueprint\n        // Placeholder implementation\n        return true;\n    }\n\n    std::string GetAttributeValue(const std::string& name) const {\n        // Return the value of the attribute\n        // Placeholder implementation\n        return \"matchingValue\";\n    }\n};\n\nclass BlueprintLibrary {\nprivate:\n    std::vector<std::shared_ptr<Blueprint>> blueprints;\n\npublic:\n    // This method filters blueprints by a specified attribute name and value.\n    std::shared_ptr<BlueprintLibrary> FilterByAttribute(\n        const std::string& name, const std::string& value) const {\n        auto filteredLibrary = std::make_shared<BlueprintLibrary>();\n\n        for (const auto& blueprint : blueprints) {\n            if (blueprint->HasAttribute(name)) {\n                std::string attributeValue = blueprint->GetAttributeValue(name);\n                if (attributeValue == value) {\n                    filteredLibrary->blueprints.push_back(blueprint);\n                }\n            }\n        }\n\n        return filteredLibrary;\n    }\n};", "CodeBleu_score": 46.04952586717472}, {"code": "#include <vector>\n#include <memory>\n#include <string>\n\nclass Blueprint {\npublic:\n    bool HasAttribute(const std::string& attrName) const {\n        // Implement logic to check if attribute exists.\n        return true;  // Placeholder implementation\n    }\n\n    std::string GetAttributeValue(const std::string& attrName) const {\n        // Implement logic to get the attribute value.\n        return \"\";  // Placeholder implementation\n    }\n};\n\nclass BlueprintLibrary {\nprivate:\n    std::vector<std::shared_ptr<Blueprint>> blueprints;\n\npublic:\n    // Returns a new BlueprintLibrary containing only the Blueprints that match the provided name/value pairing.\n    std::shared_ptr<BlueprintLibrary> FilterByAttribute(const std::string &name, const std::string& value) const {\n        auto resultLibrary = std::make_shared<BlueprintLibrary>();\n    \n        for (const auto& blueprint : blueprints) {\n            if (blueprint->HasAttribute(name)) {\n                // Assuming that GetAttributeValue returns the value as a string.\n                if (blueprint->GetAttributeValue(name) == value) {\n                    // Add the blueprint to the result if it matches the criteria\n                    resultLibrary->AddBlueprint(blueprint);\n                }\n            }\n        }\n    \n        return resultLibrary;\n    }\n\n    // Utility to add blueprints to the library\n    void AddBlueprint(std::shared_ptr<Blueprint> blueprint) {\n        blueprints.push_back(blueprint);\n    }\n};", "CodeBleu_score": 42.004260528485005}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "#include <fstream>\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass FileTransfer {\npublic:\n    bool WriteFile(const std::string& baseFolder, const std::string& version, const std::string& path, const std::vector<uint8_t>& content) {\n        // Construct the full file path\n        std::string fullPath = baseFolder + \"/\" + version + \"/\" + path;\n        \n        // Validate the file path (in a real-world scenario, this could include checking if the path is safe, directories exist, etc.)\n        // A simple example of validation could be checking if baseFolder and version are not empty.\n        if (baseFolder.empty() || version.empty()) {\n            std::cerr << \"Invalid base folder or version provided.\" << std::endl;\n            return false;\n        }\n\n        // Open the file in binary mode to write, truncating existing contents\n        std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n        \n        if (!file) {\n            // File failed to open\n            std::cerr << \"Failed to open file: \" << fullPath << std::endl;\n            return false;\n        }\n        \n        // Write content to the file\n        if (!content.empty()) {\n            file.write(reinterpret_cast<const char*>(content.data()), content.size());\n        }\n        \n        // Close the file automatically by destructor of ofstream\n        // Return true to indicate the write was successful\n        return true;\n    }\n};\n\nint main() {\n    // Creating an instance of FileTransfer\n    FileTransfer ft;\n\n    // Test data for writing to a file\n    std::vector<uint8_t> data = {'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!'};\n    std::string baseFolder = \"/example\";\n    std::string version = \"v1\";\n    std::string filePath = \"test.txt\";\n\n    // Write the data to a file and capture the result\n    bool success = ft.WriteFile(baseFolder, version, filePath, data);\n    if (success) {\n        std::cout << \"File was written successfully.\" << std::endl;\n    } else {\n        std::cout << \"Failed to write file.\" << std::endl;\n    }\n\n    return 0;\n}", "CodeBleu_score": 37.09264796055795}, {"code": "#include <fstream>\n#include <vector>\n#include <string>\n\nclass FileTransfer {\npublic:\n    // Constructor might be necessary to initialize baseFolder and version if needed.\n    // std::string baseFolder;\n    // std::string version;\n    bool WriteFile(const std::string& path, const std::vector<uint8_t>& content);\n};\n\nbool FileTransfer::WriteFile(const std::string& path, const std::vector<uint8_t>& content) {\n    // Construct full file path (assuming baseFolder and version are class members)\n    // std::string fullPath = baseFolder + \"/\" + version + \"/\" + path;\n    \n    // For simplicity, using path directly if no extra path info provided\n    std::ofstream file(path, std::ios::out | std::ios::binary | std::ios::trunc);\n    \n    if (!file.is_open()) {\n        // File opening failed\n        return false;\n    }\n    \n    // Write content to file\n    if (!content.empty()) {\n        file.write(reinterpret_cast<const char*>(content.data()), content.size());\n    }\n    \n    // Check if write was successful\n    if (file.fail()) {\n        file.close();\n        return false;\n    }\n    \n    // Close file and return success\n    file.close();\n    return true;\n}\n\n// Usage demonstration (assuming you have the relevant setup for it)\n// int main() {\n//     FileTransfer ft;\n//     std::vector<uint8_t> content = { 'H', 'e', 'l', 'l', 'o' };\n//     bool result = ft.WriteFile(\"example.bin\", content);\n//     if (result) {\n//         std::cout << \"Write successful.\" << std::endl;\n//     } else {\n//         std::cout << \"Write failed.\" << std::endl;\n//     }\n//     return 0;\n// }", "CodeBleu_score": 36.83690028077986}, {"code": "#include <fstream>\n#include <filesystem>\n\nbool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content) {\n    // Construct the full file path\n    std::filesystem::path filePath = std::filesystem::current_path() / path;\n\n    // Ensure the directory exists before writing the file\n    std::filesystem::path directory = filePath.parent_path();\n    if (!std::filesystem::exists(directory)) {\n        std::filesystem::create_directories(directory);\n    }\n\n    // Open the file in binary mode to write and truncate any existing content\n    std::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n    \n    // Check if the file was successfully opened\n    if (!file.is_open()) {\n        return false;\n    }\n\n    // Write content to the file\n    if (!content.empty()) {\n        file.write(reinterpret_cast<const char*>(content.data()), content.size());\n    }\n\n    // Close the file (optional, as the destructor will close it automatically)\n    file.close();\n\n    return true;\n}", "CodeBleu_score": 44.243563388181826}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "#include <memory>       // For std::shared_ptr\n#include <cmath>        // For cos, sin\n\nclass LaneInvasionCallback {\npublic:\n    struct Bounds {\n        size_t frame;\n        std::vector<std::pair<float, float>> corners;\n        \n        Bounds(size_t fr, const std::vector<std::pair<float, float>>& crn) : frame(fr), corners(crn) {}\n    };\n\n    std::shared_ptr<const Bounds> MakeBounds(\n        const size_t frame,\n        const geom::Transform &transform) const {\n        // Parent bounding box corners\n        std::vector<std::pair<float, float>> parentExtents = {{-1.0f, -1.0f}, {1.0f, -1.0f}, {1.0f, 1.0f}, {-1.0f, 1.0f}};\n        \n        // Get the yaw (rotation about the z-axis) to rotate points\n        double yaw = transform.rotation.yaw * M_PI / 180; // Convert degrees to radians\n        double sinYaw = std::sin(yaw);\n        double cosYaw = std::cos(yaw);\n        \n        // Initialize new corners adjusted by transform's location\n        std::vector<std::pair<float, float>> newCorners;\n        newCorners.reserve(parentExtents.size());\n        \n        for (const auto& corner : parentExtents) {\n            float xPrime = (float)(cosYaw * corner.first - sinYaw * corner.second);\n            float yPrime = (float)(sinYaw * corner.first + cosYaw * corner.second);\n            // Translate each corner by the given position\n            newCorners.emplace_back(xPrime + transform.location.x, yPrime + transform.location.y);\n        }\n        \n        // Create and return a Bounds object\n        return std::make_shared<const Bounds>(frame, newCorners);\n    }\n};\n\n// Example struct for `geom::Transform`.\nnamespace geom {\n    struct Transform {\n        struct Rotation {\n            double yaw; // Rotation around the z-axis in degrees\n        };\n        \n        struct Location {\n            float x, y, z;\n        };\n\n        Rotation rotation;\n        Location location;\n    };\n}", "CodeBleu_score": 30.303131130425733}, {"code": "#include <cmath>\n#include <memory>\n\nstd::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n    const size_t frame,\n    const geom::Transform &transform) const {\n\n    // Assuming geom::Transform consists of position and rotation (yaw) and \n    // LaneInvasionCallback::Bounds includes frame number and corners as attributes.\n\n    // Retrieve parent bounding box location and extents\n    geom::Point parentLocation = parentBoundingBox_.getLocation();\n    geom::Extent parentExtent = parentBoundingBox_.getExtent();\n\n    // Calculate new bounding box location by adding transform's translation\n    geom::Point newLocation = {\n        parentLocation.x + transform.location.x,\n        parentLocation.y + transform.location.y,\n        parentLocation.z + transform.location.z\n    };\n\n    // Calculate the cosine and sine of the yaw angle (rotation around the z-axis)\n    double cos_yaw = std::cos(transform.rotation.yaw);\n    double sin_yaw = std::sin(transform.rotation.yaw);\n\n    // Points for the extents of the bounding box\n    const double half_width = parentExtent.width / 2.0;\n    const double half_depth = parentExtent.depth / 2.0;\n\n    std::vector<geom::Point> corners;\n    corners.reserve(4);\n\n    // Calculate the rotated corners of the bounding box\n    std::vector<std::pair<double, double>> offsets = {\n        {half_width, half_depth},\n        {-half_width, half_depth},\n        {-half_width, -half_depth},\n        {half_width, -half_depth}\n    };\n\n    for (const auto& offset : offsets) {\n        double x_offset = offset.first;\n        double z_offset = offset.second;\n\n        // Rotate the offsets\n        double x_new = x_offset * cos_yaw - z_offset * sin_yaw;\n        double z_new = x_offset * sin_yaw + z_offset * cos_yaw;\n\n        // Translate and apply offsets to the new location\n        corners.emplace_back(newLocation.x + x_new, newLocation.y, newLocation.z + z_new);\n    }\n\n    // Create Bounds object and return\n    std::shared_ptr<const LaneInvasionCallback::Bounds> bounds = \n        std::make_shared<const LaneInvasionCallback::Bounds>(frame, corners);\n\n    return bounds;\n}", "CodeBleu_score": 33.53727058461175}, {"code": "#include <memory>\n#include <cmath>\n\nnamespace geom {\n    struct Transform {\n        double x;\n        double y;\n        double yaw;  // In radians\n    };\n}\n\nclass LaneInvasionCallback {\npublic:\n    struct Bounds {\n        size_t frame;\n        std::array<std::pair<double, double>, 4> corners;\n    };\n\n    // Assumption: Parent bounds center at (0, 0) for simplicity.\n    // In practice, you might need to adjust this to use the actual parent bounding box location.\n    std::shared_ptr<const Bounds> MakeBounds(const size_t frame, const geom::Transform &transform) const {\n        // Create a new Bounds object\n        auto bounds = std::make_shared<Bounds>();\n        bounds->frame = frame;\n\n        // Extent of the bounding box around the center (half-widths and half-heights)\n        double half_width = 1.0; // These should be set to proper values\n        double half_height = 2.0; // These should be set to proper values\n\n        // Calculate the corners of the bounding box before rotation\n        std::pair<double, double> top_right(half_width, half_height);\n        std::pair<double, double> top_left(-half_width, half_height);\n        std::pair<double, double> bottom_right(half_width, -half_height);\n        std::pair<double, double> bottom_left(-half_width, -half_height);\n\n        // Helper function to rotate a point around the origin\n        auto rotate = [](double x, double y, double yaw) {\n            return std::make_pair(\n                x * cos(yaw) - y * sin(yaw),\n                x * sin(yaw) + y * cos(yaw)\n            );\n        };\n\n        // Rotate and translate each corner\n        bounds->corners[0] = rotate(top_right.first, top_right.second, transform.yaw);\n        bounds->corners[1] = rotate(top_left.first, top_left.second, transform.yaw);\n        bounds->corners[2] = rotate(bottom_right.first, bottom_right.second, transform.yaw);\n        bounds->corners[3] = rotate(bottom_left.first, bottom_left.second, transform.yaw);\n\n        // Translate corners based on the transform's location\n        for (auto &corner : bounds->corners) {\n            corner.first += transform.x;\n            corner.second += transform.y;\n        }\n\n        return bounds;\n    }\n};", "CodeBleu_score": 33.05362003087804}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "#include <iostream>\n#include <mutex>\n#include <map>\n\nclass Light {\npublic:\n    std::string id;\n    std::string state;  // e.g., \"ON\", \"OFF\"\n\n    Light(std::string id, std::string state) : id(id), state(state) {}\n};\n\nclass LightManager {\n    std::map<std::string, Light> _lights;\n    std::mutex _lightMutex;\npublic:\n    void QueryLightsStateToServer();\nprivate:\n    void UpdateLight(std::string id, std::string state);\n};\n\nvoid LightManager::QueryLightsStateToServer() {\n    _lightMutex.lock();\n    try {\n        // Simulate fetching data from the server\n        std::map<std::string, std::string> serverLights = { {\"light1\", \"ON\"}, {\"light2\", \"OFF\"} }; // This would typically be fetched from a server API\n        \n        // Update or create light objects based on server info\n        for (const auto& serverLight : serverLights) {\n            std::string id = serverLight.first;\n            std::string state = serverLight.second;\n            UpdateLight(id, state);\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception when updating lights: \" << e.what() << std::endl;\n    }\n    _lightMutex.unlock();\n}\n\nvoid LightManager::UpdateLight(std::string id, std::string state) {\n    auto it = _lights.find(id);\n    if (it != _lights.end()) {\n        it->second.state = state;\n    } else {\n        _lights[id] = Light(id, state);\n    }\n}\n\nint main() {\n    LightManager manager;\n    manager.QueryLightsStateToServer();\n    \n    return 0;\n}", "CodeBleu_score": 33.2302803083714}, {"code": "#include <mutex>\n\nclass Light {\npublic:\n    // attributes related to the light itself like id, state, etc.\n    std::string id;\n    bool state;\n\n    Light(const std::string& id, bool state) : id(id), state(state) {}\n};\n\nclass LightManager {\nprivate:\n    std::map<std::string, Light> _lights;  // map of light id to Light object\n    std::mutex _mutex;\n    // Assume some server class or API\n    ServerAPI _server;\n\npublic:\n    void QueryLightsStateToServer() {\n        // Guard to lock the mutex\n        std::lock_guard<std::mutex> lock(_mutex);\n        \n        // Query the server for current state of lights\n        auto lightsData = _server.getLightsState(); // We assume getLightsState returns std::map<string, bool> representing light ID and their state.\n\n        // Iterate through the lights data received from server\n        for (const auto& lightData : lightsData) {\n            const std::string& id = lightData.first;\n            bool state = lightData.second;\n\n            // Check if the light already exists in the map\n            auto it = _lights.find(id);\n            if (it != _lights.end()) {\n                // If light exists, update its state\n                it->second.state = state;\n            } else {\n                // If light does not exist, create a new Light object and add to map\n                _lights[id] = Light(id, state);\n            }\n        }\n    }\n};", "CodeBleu_score": 40.582423658136904}, {"code": "#include <mutex>\n\nvoid LightManager::QueryLightsStateToServer() {\n    // Lock mutex to ensure thread safety across potentially multithreaded accesses\n    std::lock_guard<std::mutex> lock(_mutex);\n\n    // Simulate a query to a server for new state of lights.\n    auto newStates = server->getLightsState();\n\n    // Iterate through the new light states retrieved from the server\n    for (const auto& newState : newStates) {\n        auto lightId = newState.first;\n        auto state = newState.second;\n\n        // Check if the light with this ID already exists in our local store\n        if (_lights.find(lightId) == _lights.end()) {\n            // If not found, create a new light object and add to the map\n            _lights[lightId] = std::make_shared<Light>(lightId, state);\n        } else {\n            // If found, just update the state\n            _lights[lightId]->setState(state);\n        }\n    }\n}", "CodeBleu_score": 39.15512693736585}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "#include <mutex>\n#include <string>\n\nclass LightManager {\npublic:\n    // Constructor, destructor and other methods\n\n    void UpdateServerLightsState(bool discard_client);\n\nprivate:\n    std::mutex mtx;\n    bool dirty_flag;\n    std::string current_light_states;\n    bool changes_exist;\n\n    void SendMessageToServer(const std::string& message);\n    std::string CreateLightStateMessage();\n    void ResetChanges();\n};\n\nvoid LightManager::UpdateServerLightsState(bool discard_client) {\n    // Lock mutex to ensure thread safety\n    std::lock_guard<std::mutex> lock(mtx);\n    \n    // Check if there are any changes that need to be sent to the server \n    // or if we're discarding client changes based on input\n    if (changes_exist && !discard_client) {\n        // Create a message for the updated light states\n        std::string message = CreateLightStateMessage();\n        \n        // Send the updated message to the server\n        SendMessageToServer(message);\n        \n        // After updating, clear the changes and reset the dirty flag\n        ResetChanges();\n    }\n}\n\nvoid LightManager::SendMessageToServer(const std::string& message) {\n    // Code to send a message to the server (implementation depends on network setup)\n    // e.g., using sockets, HTTP clients, etc.\n    // Example: NetworkingClass::Send(message);\n}\n\nstd::string LightManager::CreateLightStateMessage() {\n    // Create a structured message containing the states of the lights\n    // This could be formatted as JSON, XML, etc., depending on server requirements\n    return \"{ \\\"lightStates\\\": \\\"\" + current_light_states + \"\\\" }\";\n}\n\nvoid LightManager::ResetChanges() {\n    // Reset dirty flag and clear changes existence\n    dirty_flag = false;\n    changes_exist = false;\n}", "CodeBleu_score": 29.208986099790447}, {"code": "#include <mutex>\n\nvoid LightManager::UpdateServerLightsState(bool discard_client) {\n    std::lock_guard<std::mutex> lock(mutex); // Lock the mutex to ensure thread safety\n\n    if (dirty || discard_client) {  // Check if there have been changes or if we are discarding client changes\n        // Create a message with the current state of all lights\n        std::string message;\n        message.reserve(256);  // Pre-allocate some memory to avoid multiple allocations\n        message.append(\"LightsStateUpdate:\");\n\n        for (const auto& light : lights) {\n            message.append(light.id + \"=\" + (light.isOn ? \"ON\" : \"OFF\") + \";\");\n        }\n\n        // Send the message to the server\n        server->sendMessage(message);\n\n        // Clear the changes and reset the dirty flag after successful update\n        for (auto& light : lights) {\n            light.hasChanged = false;\n        }\n        dirty = false;\n    }\n}", "CodeBleu_score": 35.88983373931909}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client) {\n    // Lock the mutex first to ensure thread safety\n    std::lock_guard<std::mutex> lock(mutex_);\n    \n    // Check if there have been any changes and if the client shouldn't be discarded\n    if (dirty_flag_ && !discard_client) {\n        // Create a message with the updated light states\n        std::string message = \"Update:LightsState:\";\n        for (const auto& light : lights_) {\n            message += std::to_string(light.id) + \"=\" + (light.is_on ? \"1\" : \"0\") + \";\";\n        }\n\n        // Send the message to the server\n        server_interface_.send(message);\n\n        // After sending, clear the changes to avoid duplicate updates\n        for (auto& light : lights_) {\n            light.has_changed = false;\n        }\n\n        // Reset the dirty flag\n        dirty_flag_ = false;\n    }\n}", "CodeBleu_score": 33.995263422598676}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "#include <iostream>\n\nclass ServerSideSensor {\nprivate:\n    std::string id;\n    std::string context;\n\npublic:\n    ServerSideSensor(std::string sensorID, std::string sensorContext) : id(sensorID), context(sensorContext) {}\n\n    void Send(std::string message) {\n        // Log a debug message when the function is called.\n        std::cout << \"Debug: Send function called with message: \" << message << std::endl;\n\n        // Check if the sensor's ID is \"sensor.other.v2x_custom\".\n        if (id != \"sensor.other.v2x_custom\") {\n            // Log a warning if the ID is not what is expected.\n            std::cout << \"Warning: Sensor ID is not 'sensor.other.v2x_custom', it is: \" << id << std::endl;\n            return;\n        }\n\n        // If the sensor's ID matches, simulate sending a message to the episode using the sensor's context.\n        std::cout << \"Info: Sending message to episode using context (\" << context << \"): \" << message << std::endl;\n    }\n};\n\nint main() {\n    ServerSideSensor sensor1(\"sensor.other.v2x_custom\", \"Episode XYZ\");\n    sensor1.Send(\"Message payload for episode.\");\n\n    ServerSideSensor sensor2(\"sensor.other.different_id\", \"Episode ABC\");\n    sensor2.Send(\"This message will not be sent to the episode.\");\n    \n    return 0;\n}", "CodeBleu_score": 37.42388878983597}, {"code": "#include <iostream>  // Include for console output\n\nclass ServerSideSensor {\n    std::string sensorId;  // Sensor ID field\n    // Assuming Context is a class that has methods to manage sensor-related contexts\n    Context* sensorContext;\n\npublic:\n    ServerSideSensor(std::string id, Context* context) : sensorId(id), sensorContext(context) {}\n\n    void Send(std::string message) {\n        std::cout << \"Send called with message: \" << message << std::endl;  // Log debug message\n\n        // Check if the sensor ID matches \"sensor.other.v2x_custom\"\n        if (sensorId != \"sensor.other.v2x_custom\") {\n            std::cerr << \"Warning: Sensor ID does not match 'sensor.other.v2x_custom'\" << std::endl;\n            return;  // Exit if sensor ID is incorrect\n        }\n\n        // Send message using the sensor's context\n        if (sensorContext != nullptr) {\n            sensorContext->sendMessage(message);  // Assuming sendMessage is a method in Context to send a message\n        }\n    }\n};\n\n// Mock class definition for Context\nclass Context {\npublic:\n    void sendMessage(std::string msg) {\n        std::cout << \"Message sent: \" << msg << std::endl;\n    }\n};\n\nint main() {\n    // Create a context object\n    Context *context = new Context();\n\n    // Create sensor object with invalid sensorId for testing\n    ServerSideSensor wrongSensor(\"sensor.other.invalid\", context);\n    wrongSensor.Send(\"Test Message 1\");\n\n    // Create sensor object with valid sensorId for testing\n    ServerSideSensor correctSensor(\"sensor.other.v2x_custom\", context);\n    correctSensor.Send(\"Test Message 2\");\n\n    delete context;\n    return 0;\n}", "CodeBleu_score": 38.72179526849793}, {"code": "#include <iostream>\n#include <string>\n\nclass ServerSideSensor {\nprivate:\n    std::string sensorID;\n    void* context; // Assuming context is a placeholder for some episode communication setup\n\npublic:\n    // Constructor to initialize the sensor with its ID\n    ServerSideSensor(std::string id, void* ctx) : sensorID(id), context(ctx) {}\n\n    // Send method as described in the documentation\n    void Send(std::string message) {\n        std::cout << \"Debug: Sending message...\\n\"; // Log debug message\n\n        // Check if the sensor's ID matches the expected value\n        if (sensorID != \"sensor.other.v2x_custom\") {\n            std::cerr << \"Warning: Sensor ID does not match 'sensor.other.v2x_custom'.\\n\"; // Log warning\n            return; // Return early as per requirement\n        }\n\n        // Here, since this is a simulated example, the actual sending mechanism is undefined.\n        // Normally, you would use some sending logic applicable to your context here, e.g., sending over a network or calling another method.\n        std::cout << \"Message from sensor [\" << sensorID << \"]: \" << message << \"\\n\";\n        // Call to hypothetical method to send the message, using the context, can be mocked or explained here\n        sendMessageToEpisode(context, message);\n    }\n\nprivate:\n    // Hypothetical helper function to simulate message sending\n    void sendMessageToEpisode(void* episodeContext, std::string msg) {\n        // You would implement the specific communication details here.\n        // For demonstration purposes, just print the message being \"sent\".\n        std::cout << \"Sending to episode: \" << msg << \"\\n\";\n    }\n};\n\nint main() {\n    // Example of creating a ServerSideSensor and using the Send method\n    void* episodeContext = nullptr; // Placeholder for actual context\n    ServerSideSensor sensor(\"sensor.other.v2x_custom\", episodeContext);\n    sensor.Send(\"Hello World!\"); // Expected to send the message\n\n    ServerSideSensor sensorInvalid(\"sensor.generic.xyz\", episodeContext);\n    sensorInvalid.Send(\"This should not send.\"); // Expected to log a warning and not send\n\n    return 0;\n}", "CodeBleu_score": 35.98909002091627}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "#include <iostream>\n\nclass TrafficManager {\npublic:\n    static void RegisterVehicle(Vehicle* vehicle, uint16_t port) {\n        std::cout << \"Vehicle registered with Traffic Manager on port \" << port << \"\\n\";\n    }\n\n    static void UnregisterVehicle(Vehicle* vehicle) {\n        std::cout << \"Vehicle unregistered from Traffic Manager\\n\";\n    }\n};\n\nclass Vehicle {\nprivate:\n    bool autopilotEnabled;\n    uint16_t trafficManagerPort;\n\npublic:\n    void SetAutopilot(bool enabled, uint16_t tm_port) {\n        if (enabled) {\n            // Enable autopilot\n            autopilotEnabled = true;\n            trafficManagerPort = tm_port;\n            // Register this vehicle with the traffic manager\n            TrafficManager::RegisterVehicle(this, trafficManagerPort);\n        } else if (autopilotEnabled) {\n            // Disable autopilot only if it was previously enabled\n            autopilotEnabled = false;\n            // Unregister this vehicle from the traffic manager\n            TrafficManager::UnregisterVehicle(this);\n            trafficManagerPort = 0; // Reset port to a neutral value when autopilot is disabled\n        }\n    }\n\n    // Constructor\n    Vehicle() : autopilotEnabled(false), trafficManagerPort(0) {}\n\n    // Destructor\n    ~Vehicle() {\n        // Ensure we unregister if the vehicle is destroyed while autopilot is enabled\n        if (autopilotEnabled) {\n            TrafficManager::UnregisterVehicle(this);\n        }\n    }\n};", "CodeBleu_score": 31.391007863677352}, {"code": "#include <iostream>\n\nclass Vehicle {\nprivate:\n    bool autopilotActive;\n    uint16_t trafficManagerPort;\n\n    void registerWithTrafficManager(uint16_t port) {\n        // Simulating a vehicle registration with a traffic manager system on the specified port\n        std::cout << \"Vehicle is registered with Traffic Manager at port: \" << port << std::endl;\n    }\n\n    void unregisterFromTrafficManager() {\n        // Simulate a vehicle deregistration from a traffic manager\n        std::cout << \"Vehicle is unregistered from Traffic Manager.\" << std::endl;\n    }\n\npublic:\n    // Constructor\n    Vehicle() : autopilotActive(false), trafficManagerPort(0) {}\n\n    // Method to enable/disable autopilot based on the provided parameters\n    void SetAutopilot(bool enabled, uint16_t tm_port) {\n        if (enabled) {\n            // If the autopilot is being enabled and it wasn't already enabled\n            if (!autopilotActive) {\n                autopilotActive = true;  // Set the autopilot mode to active\n                trafficManagerPort = tm_port;  // Set the traffic manager port\n                registerWithTrafficManager(tm_port);  // Register with Traffic Manager\n            } else if (trafficManagerPort != tm_port) {\n                // If autopilot was already enabled but the port has changed, re-register to new port\n                unregisterFromTrafficManager();  // Unregister from old port\n                trafficManagerPort = tm_port;  // Update to new port\n                registerWithTrafficManager(tm_port);  // Register with the new port\n            }\n        } else {\n            if (autopilotActive) {\n                // If autopilot is being disabled and it was enabled\n                autopilotActive = false;\n                unregisterFromTrafficManager();  // Unregister from Traffic Manager\n                trafficManagerPort = 0; // Clear the traffic manager port\n            }\n        }\n    }\n};\n\nint main() {\n    Vehicle myCar;\n    myCar.SetAutopilot(true, 8080);  // Will register the vehicle at port 8080\n    myCar.SetAutopilot(false, 8080);  // Will unregister the vehicle\n    return 0;\n}", "CodeBleu_score": 35.56154438119253}, {"code": "#include <iostream>  // Used for demonstration purposes.\n\nclass TrafficManager {\npublic:\n    static void RegisterVehicle(Vehicle* vehicle, uint16_t port) {\n        std::cout << \"Vehicle registered to Traffic Manager on port \" << port << std::endl;\n    }\n\n    static void UnregisterVehicle(Vehicle* vehicle, uint16_t port) {\n        std::cout << \"Vehicle unregistered from Traffic Manager on port \" << port << std::endl;\n    }\n};\n\nclass Vehicle {\nprivate:\n    bool autopilotEnabled;\n    uint16_t trafficManagerPort;\n\npublic:\n    Vehicle() : autopilotEnabled(false), trafficManagerPort(0) {}\n\n    void SetAutopilot(bool enabled, uint16_t tm_port) {\n        if (enabled) {\n            // Register the vehicle to the traffic manager\n            if (!autopilotEnabled) {  // to prevent re-registration\n                TrafficManager::RegisterVehicle(this, tm_port);\n                autopilotEnabled = true;\n                trafficManagerPort = tm_port;\n                std::cout << \"Autopilot enabled and vehicle registered.\\n\";\n            } else {\n                std::cout << \"Autopilot already enabled. No action taken.\\n\";\n            }\n        } else {\n            // Unregister the vehicle from the traffic manager\n            if (autopilotEnabled) {\n                TrafficManager::UnregisterVehicle(this, trafficManagerPort);\n                autopilotEnabled = false;\n                std::cout << \"Autopilot disabled and vehicle unregistered.\\n\";\n            } else {\n                std::cout << \"Autopilot already disabled. No action taken.\\n\";\n            }\n        }\n    }\n};\n\nint main() {\n    Vehicle v;\n    v.SetAutopilot(true, 8080);  // Enable autopilot.\n    v.SetAutopilot(true, 8080);  // Try enabling again to see what happens.\n    v.SetAutopilot(false, 8080); // Disable autopilot.\n    v.SetAutopilot(false, 8080); // Try disabling again.\n}", "CodeBleu_score": 36.23535589354259}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start() {\n    // Register the AI controller with the episode\n    if (episode != nullptr) {\n        episode->RegisterAIController(this);\n    } else {\n        std::cerr << \"Error: Episode is nullptr, cannot register AI controller.\" << std::endl;\n        return;\n    }\n\n    // Retrieve the walker actor\n    if (walkerActor == nullptr) {\n        std::cerr << \"Error: Walker actor not set or is nullptr.\" << std::endl;\n        return;\n    }\n\n    // Add the walker actor to the navigation system\n    if (navigator != nullptr) {\n        navigator->AddActor(walkerActor->GetPosition());\n    } else {\n        std::cerr << \"Warning: Navigator is nullptr, cannot add walker actor to navigation system.\" << std::endl;\n    }\n\n    // Disable physics simulation and collisions\n    walkerActor->DisablePhysics();\n    walkerActor->DisableCollisions();\n}", "CodeBleu_score": 35.557994778109524}, {"code": "void WalkerAIController::Start() {\n    // Register the AI controller with the episode\n    Episode->RegisterAIController(this);\n\n    // Retrieve the walker actor\n    WalkerActor* walker = GetWalkerActor();\n\n    // Add walker to the navigation system at its current location\n    NavigationSystem->AddWalker(walker, walker->GetCurrentLocation());\n\n    // Disable physics and collisions\n    walker->DisablePhysics();\n    walker->DisableCollision();\n}", "CodeBleu_score": 25.51424520941108}, {"code": "void WalkerAIController::Start() {\n    // Register the AI controller with the episode\n    Episode->RegisterAIController(this);\n\n    // Retrieve the walker actor\n    WalkerActor* walker = GetWalkerActor();\n\n    if (walker) {\n        // Add the walker actor to the navigation system\n        FVector currentPosition = walker->GetCurrentPosition();\n        NavigationSystem->AddActor(walker, currentPosition);\n\n        // Disable the physics simulation for the walker actor\n        walker->DisablePhysicsSimulation();\n\n        // Disable collisions for the walker actor\n        walker->DisableCollisions();\n    } else {\n        // Log an error if the walker actor is not found\n        LogError(\"Walker actor not found in Start of WalkerAIController\");\n    }\n}", "CodeBleu_score": 34.208007510956705}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "#include <iostream>\n\nclass Navigation {\npublic:\n    bool IsValid() const { return true; }\n    void SetSpeed(float speed) {\n        std::cout << \"Speed set to: \" << speed << std::endl;\n    }\n};\n\nclass Walker {\npublic:\n    Navigation* GetNavigationInstance() {\n        static Navigation instance;\n        return &instance;\n    }\n};\n\nclass WalkerAIController {\nprivate:\n    Walker* parent_walker;\n\npublic:\n    WalkerAIController(Walker* walker) : parent_walker(walker) {}\n\n    void SetMaxSpeed(const float max_speed) {\n        if (parent_walker == nullptr) {\n            std::cerr << \"WalkerAIController: No walker is associated with this controller.\" << std::endl;\n            return;\n        }\n\n        Navigation* navigation = parent_walker->GetNavigationInstance();\n        if (!navigation || !navigation->IsValid()) {\n            std::cerr << \"WalkerAIController: Invalid navigation instance.\" << std::endl;\n            return;\n        }\n\n        try {\n            navigation->SetSpeed(max_speed);\n            std::cout << \"WalkerAIController: Max speed set successfully.\" << std::endl;\n        } catch (const std::exception& e) {\n            std::cerr << \"WalkerAIController: Failed to set max speed - \" << e.what() << std::endl;\n        }\n    }\n};\n\nint main() {\n    Walker walker;\n    WalkerAIController aiController(&walker);\n    aiController.SetMaxSpeed(5.0f);\n    return 0;\n}", "CodeBleu_score": 38.51841121910847}, {"code": "#include <iostream>\n\nclass NavigationInstance {\npublic:\n    bool IsValid() const { return true; }\n    bool SetMaxSpeed(float speed) {\n        // Lets assume the function successfully sets the speed\n        return true;\n    }\n};\n\nclass Walker {\npublic:\n    NavigationInstance* GetNavigationInstance() {\n        return new NavigationInstance(); // Returns a new navigation instance for this example\n    }\n};\n\nclass WalkerAIController {\nprivate:\n    Walker* parentWalker;\n    \npublic:\n    WalkerAIController(Walker* walker) : parentWalker(walker) {}\n\n    // Function to simulate setting max speed of a Walker\n    void SetMaxSpeed(const float max_speed) {\n        if (!parentWalker) {\n            std::cerr << \"Warning: Parent Walker is not found.\" << std::endl;\n            return;\n        }\n        \n        NavigationInstance* navigation = parentWalker->GetNavigationInstance();\n        if (!navigation || !navigation->IsValid()) {\n            std::cerr << \"Warning: Invalid navigation instance.\" << std::endl;\n            return;\n        }\n        \n        if (!navigation->SetMaxSpeed(max_speed)) {\n            std::cerr << \"Warning: Failed to set max speed.\" << std::endl;\n        } else {\n            std::cout << \"Max speed set to \" << max_speed << std::endl;\n        }\n    }\n};\n\nint main() {\n    Walker walker;\n    WalkerAIController controller(&walker);\n    controller.SetMaxSpeed(3.5f); // Set max speed to 3.5\n    return 0;\n}", "CodeBleu_score": 37.87070926954938}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed) {\n    // Check if the navigation instance exists and is valid\n    if (!navigation_instance || !navigation_instance->IsValid()) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Navigation instance is invalid.\"));\n        return;\n    }\n\n    // Try to get the parent walker from the navigation instance\n    Walker* parent_walker = navigation_instance->GetParentWalker();\n    if (!parent_walker) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Parent walker not found.\"));\n        return;\n    }\n\n    // Attempt to set the maximum speed on the parent walker\n    bool success = parent_walker->SetMaxSpeed(max_speed);\n    if (!success) {\n        UE_LOG(LogTemp, Warning, TEXT(\"Failed to set the maximum speed for the walker.\"));\n    } else {\n        UE_LOG(LogTemp, Log, TEXT(\"Maximum speed set to %f for the walker.\"), max_speed);\n    }\n}", "CodeBleu_score": 44.41743346609011}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "#include <vector>\n#include <memory>\n\nclass Waypoint {\npublic:\n    std::vector<std::shared_ptr<Waypoint>> GetPrevious(double distance) const;\n    // Other members and functions of Waypoint\n};\n\nstd::vector<std::shared_ptr<Waypoint>> Waypoint::GetPrevious(double distance) const {\n    std::vector<std::shared_ptr<Waypoint>> result;\n    // Assuming parentMap is accessible and has a method getPreviousWaypoints\n    std::vector<Waypoint> previousWaypoints = parentMap.getPreviousWaypoints(this, distance);\n\n    for (const auto& waypoint : previousWaypoints) {\n        result.push_back(std::make_shared<Waypoint>(waypoint));\n    }\n\n    return result;\n}", "CodeBleu_score": 39.40569913770601}, {"code": "#include <vector>\n#include <memory> // For std::shared_ptr\n\nclass Waypoint {\npublic:\n    std::vector<std::shared_ptr<Waypoint>> GetPrevious(double distance) const;\n\nprivate:\n    Map* parentMap; // Hypothetical member variable pointing to the parent map object\n};\n\nstd::vector<std::shared_ptr<Waypoint>> Waypoint::GetPrevious(double distance) const {\n    // Resultant vector of shared pointers to waypoints\n    std::vector<std::shared_ptr<Waypoint>> result;\n\n    // Assume parentMap is a pointer to the Map object which contains the method getPreviousWaypoints\n    // This method is assumed to return a vector of raw pointers to waypoints \n    std::vector<Waypoint*> previousWaypoints = parentMap->getPreviousWaypoints(this, distance);\n\n    // Create shared_ptr from raw pointers and add to the result vector\n    for (Waypoint* waypoint : previousWaypoints) {\n        result.push_back(std::shared_ptr<Waypoint>(waypoint));\n    }\n\n    return result;\n}", "CodeBleu_score": 35.526310522602245}, {"code": "#include <vector>  // For using std::vector\n#include \"SharedPtr.h\"  // Assuming SharedPtr is defined somewhere, similar to std::shared_ptr\n\n// Assuming the Waypoint class and Map class are defined something like below\nclass Waypoint {\npublic:\n    // Assuming Map type has a method to get previous waypoints\n    Map *parentMap;  \n\n    // Function to get previous waypoints from the current waypoint at a specified distance\n    std::vector<SharedPtr<Waypoint>> GetPrevious(double distance) const {\n        std::vector<SharedPtr<Waypoint>> result;  // Vector to hold result\n        \n        // Check if parentMap is valid\n        if (parentMap == nullptr) {\n            return result;  // Return empty vector if no parent map\n        }\n\n        // Get the previous waypoints from the parent map\n        std::vector<Waypoint*> previousWaypoints = parentMap->GetPreviousWaypoints(this, distance);\n\n        // Transform each raw pointer into a SharedPtr and add to result\n        for (Waypoint* wp : previousWaypoints) {\n            result.push_back(SharedPtr<Waypoint>(new Waypoint(*wp)));\n        }\n\n        return result;  // Return the vector of shared waypoints\n    }\n};\n\n// Definition of Map class with a method to get previous waypoints\nclass Map {\npublic:\n    // This function should be implemented to retrieve previous waypoints\n    std::vector<Waypoint*> GetPreviousWaypoints(const Waypoint* waypoint, double distance) const {\n        // Example implementation, or details should be filled according to actual scenario\n        std::vector<Waypoint*> waypoints;\n        // Imagine we can find and push back relevant waypoints based on some logic\n        return waypoints;\n    }\n};\n\n// SharedPtr should be a template class managing resource, similar to std::shared_ptr\ntemplate <typename T>\nclass SharedPtr {\nprivate:\n    T* ptr;  // managed pointer\npublic:\n    explicit SharedPtr(T* p = nullptr) : ptr(p) {}\n    ~SharedPtr() { delete ptr; }\n    T& operator*() { return *ptr; }\n    T* operator->() { return ptr; }\n    // Implement copy and move operations if required\n};", "CodeBleu_score": 40.86996924389789}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "#include <vector>\n#include <unordered_set>\n#include <memory>\n\nclass Signal {\npublic:\n    std::string id; // Assume each signal has a unique identifier\n    double position_x, position_y; // Position of the signal\n};\n\nclass Landmark {\npublic:\n    Landmark(const Waypoint& wp, const Signal& sig) : waypoint(wp), signal(sig) {}\n\nprivate:\n    Waypoint waypoint;\n    Signal signal;\n};\n\nclass Waypoint {\npublic:\n    Waypoint(double x, double y) : x(x), y(y) {}\n\n    std::vector<SharedPtr<Landmark>> GetAllLandmarksInDistance(double distance, bool stop_at_junction) const;\n\nprivate:\n    double x, y;\n\n    std::vector<Signal> GetSignalsInDistance(double distance) const;\n};\n\nclass SharedPtr {\npublic:\n    template<typename T>\n    static std::shared_ptr<T> make_shared(const T& obj) {\n        return std::make_shared<T>(obj);\n    }\n};\n\nstd::vector<Signal> Waypoint::GetSignalsInDistance(double distance) const {\n    // Mock implementation, should interact with a signal provider system\n    std::vector<Signal> signals;\n    // Imagine we have some signals around\n    if (stop_at_junction) {\n        // Only get those signals that are near to a junction if the flag is true\n    }\n    // For simplicity, assuming we just return a fixed set of signals for demonstration\n    return signals;\n}\n\nstd::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(double distance, bool stop_at_junction) const {\n    std::vector<Signal> signals = this->GetSignalsInDistance(distance);\n    std::unordered_set<std::string> seen_signals;\n    std::vector<SharedPtr<Landmark>> landmarks;\n\n    for (const auto& signal : signals) {\n        // Check if we have seen this signal already\n        if (seen_signals.find(signal.id) == seen_signals.end()) {\n            // Mark this signal as seen\n            seen_signals.insert(signal.id);\n            // Create a new Waypoint and Landmark based on the signal's location\n            Waypoint new_waypoint(signal.position_x, signal.position_y);\n            Landmark new_landmark(new_waypoint, signal);\n            // Use the SharedPtr utility to wrap the new landmark\n            landmarks.push_back(SharedPtr::make_shared(new_landmark));\n        }\n    }\n\n    return landmarks;\n}", "CodeBleu_score": 45.38729668369499}, {"code": "#include <vector>\n#include <memory>\n#include <set>\n\nstruct Landmark {\n    // assume some representative properties for Landmark\n    std::string id;\n    std::string name;\n    Landmark(std::string id, std::string name) : id(id), name(name) {}\n};\n\nstruct Signal {\n    std::string id;\n    std::string metadata;\n\n    Signal(std::string id, std::string metadata) : id(id), metadata(metadata) {}\n};\n\nusing SharedPtr = std::shared_ptr<Landmark>;\n\nclass Waypoint {\npublic:\n    std::vector<SharedPtr<Landmark>> GetAllLandmarksInDistance(double distance, bool stop_at_junction) const;\n    std::vector<Signal> GetSignalsInDistance(double distance, bool stop_at_junction) const;\n};\n\nstd::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(double distance, bool stop_at_junction) const {\n    auto signals = GetSignalsInDistance(distance, stop_at_junction);\n    std::set<std::string> uniqueSignalIds;\n    std::vector<SharedPtr<Landmark>> landmarks;\n\n    // Eliminate duplicates by using the signal ID\n    for (const auto& signal : signals) {\n        if (uniqueSignalIds.find(signal.id) == uniqueSignalIds.end()) {\n            uniqueSignalIds.insert(signal.id);\n            \n            // Create new Landmark and add to vector\n            landmarks.push_back(std::make_shared<Landmark>(signal.id, signal.metadata));\n        }\n    }\n\n    return landmarks;\n}\n\nstd::vector<Signal> Waypoint::GetSignalsInDistance(double distance, bool stop_at_junction) const {\n    // Imagine retrieving signals from some datasource or simulation\n    // This is just a mocked example\n    // The actual implementation would depend on system details\n    return {\n        Signal(\"ID001\", \"Landmark A\"),\n        Signal(\"ID002\", \"Landmark B\"),\n        Signal(\"ID001\", \"Landmark A\"), // duplicate\n    };\n}", "CodeBleu_score": 46.35097771039012}, {"code": "#include <vector>\n#include <memory>\n#include <unordered_set>\n#include <iostream>\n\nclass Signal {};\nclass Landmark {\npublic:\n  Landmark(const Waypoint& waypoint, const Signal& signal) {\n    // Initialization with waypoint and signal information\n  }\n  // Other methods and members ...\n};\nclass Waypoint {\n  std::vector<std::shared_ptr<Signal>> GetSignalsInDistance(double distance, bool stop_at_junction) const {\n    // Mock implementation, should replace with actual signal fetching logic\n    return {}; // Return list of signals found\n  }\n\n  public:\n    std::vector<std::shared_ptr<Landmark>> GetAllLandmarksInDistance(double distance, bool stop_at_junction) const {\n      std::vector<std::shared_ptr<Landmark>> result;\n      auto signals = GetSignalsInDistance(distance, stop_at_junction);  // Retrieve signals within the specified distance\n      std::unordered_set<Signal*> unique_signals;\n\n      for (const auto& signal : signals) {\n        if (unique_signals.insert(signal.get()).second) {  // Check if it is a unique signal\n          // Construct a Landmark for each unique signal\n          auto landmark = std::make_shared<Landmark>(*this, *signal);\n          result.push_back(landmark);\n        }\n      }\n\n      return result;\n    }\n\n    // Other methods and members ...\n};\n\nint main() {\n    Waypoint waypoint;\n    auto landmarks = waypoint.GetAllLandmarksInDistance(100.0, false);\n    std::cout << \"Number of landmarks: \" << landmarks.size() << std::endl;\n}", "CodeBleu_score": 43.73994237169595}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "// Assume required headers and namespace declarations are present\n\nuint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout) {\n    // Fallback to networking timeout if the provided timeout is unspecified\n    time_duration effective_timeout = timeout.is_not_a_date_time() ? settings.network_timeout : timeout;\n\n    // Setting the world's timeout for processing\n    this->SetTimeout(effective_timeout);\n\n    // Apply fixed delta time if required\n    if (settings.use_fixed_delta_time) {\n        constexpr int max_attempts = 5;    // Define max attempts to verify the delta time\n        bool delta_time_set_correctly = false;\n\n        for (int attempt = 0; attempt < max_attempts; ++attempt) {\n            this->SetFixedDeltaTime(settings.fixed_delta_time);\n            delta_time_set_correctly = this->VerifyDeltaTime(settings.fixed_delta_time);\n\n            if (delta_time_set_correctly) {\n                break;\n            }\n        }\n\n        if (!delta_time_set_correctly) {\n            // Log a warning if the fixed delta time couldn't be verified correctly\n            std::cerr << \"Warning: Failed to verify fixed delta time after \" \n                      << max_attempts << \" attempts.\" << std::endl;\n        }\n    }\n\n    // Generate a unique identifier for these settings, for instance using a static counter or hash.\n    static uint64_t current_id = 0;   // Simple example for generating unique IDs\n    ++current_id;  // Increment to ensure uniqueness, consider a more robust mechanism in a real world app\n\n    // Logging application of settings\n    std::cout << \"Settings applied with ID: \" << current_id << std::endl;\n\n    return current_id;\n}", "CodeBleu_score": 40.01754264876095}, {"code": "#include <iostream>\n#include <chrono>\n\nclass rpc {\npublic:\n    struct EpisodeSettings {\n        bool fixedDeltaTime;\n        double deltaTimeValue; // in seconds\n        bool useNetworkingTimeout;\n        uint64_t networkingTimeout; // in milliseconds\n    };\n};\n\nclass Logger {\npublic:\n    static void LogWarning(const std::string& message) {\n        std::cout << \"Warning: \" << message << std::endl;\n    }\n};\n\nclass World {\nprivate:\n    uint64_t settingsID;\n    double currentTime;\n    int tickCount;\n    bool deltaTimeFixed;\n\npublic:\n    World() : settingsID(0), currentTime(0), tickCount(0), deltaTimeFixed(false) {}\n\n    uint64_t ApplySettings(const rpc::EpisodeSettings &settings, std::chrono::milliseconds timeout) {\n        std::chrono::milliseconds effectiveTimeout = timeout;\n\n        if (settings.useNetworkingTimeout) {\n            effectiveTimeout = std::chrono::milliseconds(settings.networkingTimeout);\n        }\n\n        // Update world settings\n        deltaTimeFixed = settings.fixedDeltaTime;\n        double deltaTime = settings.deltaTimeValue;\n\n        if (deltaTimeFixed) {\n            // Simulate the application of fixed delta time\n            const int verificationAttempts = 5;\n            double accumulatedTime = 0.0;\n            for (int i = 0; i < verificationAttempts; i++) {\n                accumulatedTime += deltaTime;\n                std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(deltaTime * 1000)));\n                currentTime += deltaTime;\n            }\n\n            // Check if the total time is near what we expect (allow for some floating point error)\n            if (std::abs(accumulatedTime - deltaTime * verificationAttempts) > 0.001) {\n                Logger::LogWarning(\"Fixed delta time setting failed to verify.\");\n            }\n        }\n\n        // Simulate the assignment of a unique settings identifier\n        settingsID += 1;\n\n        // Return the unique identifier of the applied settings\n        return settingsID;\n    }\n};", "CodeBleu_score": 39.331926240254745}, {"code": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <string>\n\nclass rpc {\npublic:\n    struct EpisodeSettings {\n        bool fixedDeltaTime = false;\n        double deltaTime = 0.0;\n        time_duration networkTimeout;\n    };\n};\n\nclass World {\npublic:\n    uint64_t ApplySettings(const rpc::EpisodeSettings& settings, time_duration timeout) {\n        // Use provided timeout or networking timeout from settings if provided\n        time_duration effectiveTimeout = settings.networkTimeout.count() > 0 ? settings.networkTimeout : timeout;\n\n        // Start applying settings\n        if (settings.fixedDeltaTime) {\n            const int attempts = 5;\n            bool setupComplete = false;\n            for (int i = 0; i < attempts; i++) {\n                // Simulate setting the fixed delta time, typically through an API\n                std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Simulating time to apply settings\n\n                // Verification logic could be here\n                if (std::fabs(settings.deltaTime - ExpectedDeltaTime()) < 0.001) { // ExpectedDeltaTime() hypothetical function\n                    setupComplete = true;\n                    break;\n                }\n            }\n\n            if (!setupComplete) {\n                std::cerr << \"Warning: Failed to set fixed delta time accurately after \" << attempts << \" attempts.\\n\";\n            }\n        }\n\n        // Generate a unique identifier for the settings applied -- for now, we simulate this\n        uint64_t settingsIdentifier = std::hash<std::string>{}(\"WorldSettings\" + std::to_string(std::chrono::system_clock::now().time_since_epoch().count()));\n\n        return settingsIdentifier; // Return the unique identifier\n    }\n\nprivate:\n    double ExpectedDeltaTime() {\n        // Placeholder for expected delta time calculation, should ideally check or compute the expected fixed delta time\n        return 0.016; // Assuming 60 FPS, so 1/60 \u2248 0.01666 seconds per frame\n    }\n};\n\nint main() {\n    World myWorld;\n\n    rpc::EpisodeSettings settings;\n    settings.fixedDeltaTime = true;\n    settings.deltaTime = 0.016;\n    settings.networkTimeout = std::chrono::seconds(5);\n\n    time_duration timeout = std::chrono::seconds(3);\n\n    uint64_t id = myWorld.ApplySettings(settings, timeout);\n    std::cout << \"Settings applied with ID: \" << id << std::endl;\n\n    return 0;\n}", "CodeBleu_score": 40.45926982737191}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "#include <utility>\n#include <cmath>\n\nclass Math {\npublic:\n    static std::pair<float, float> DistanceSegmentToPoint(float x1, float y1, float x2, float y2, float px, float py) {\n        // Calculate the vector from the start of the segment to the end of the segment\n        float dx = x2 - x1;\n        float dy = y2 - y1;\n\n        // Squared length of the segment\n        float lengthSquared = dx * dx + dy * dy;\n        \n        // Length of the segment\n        float length = sqrt(lengthSquared);\n\n        // If the segment length is zero, treat this as a single point\n        if (length == 0.0) {\n            float distanceToPoint = sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));\n            return {0.0f, distanceToPoint};\n        }\n\n        // Calculate t, the parameterized position of the projection of the point onto the line\n        float t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;\n        \n        // Clamp t to the range [0, 1] to keep the projection on the segment\n        t = std::max(0.0f, std::min(1.0f, t));\n\n        // Find the closest point on the segment to the point\n        float closestX = x1 + t * dx;\n        float closestY = y1 + t * dy;\n        \n        // Calculate the distance from this point to the given point\n        float distFromProjectionToPoint = sqrt((px - closestX) * (px - closestX) + (py - closestY) * (py - closestY));\n        \n        // Distance along the segment is \\( t \\times \\text{Segment Length} \\)\n        float distanceAlongSegment = t * length;\n\n        return {distanceAlongSegment, distFromProjectionToPoint};\n    }\n};", "CodeBleu_score": 34.67548028797581}, {"code": "#include <cmath>\n#include <utility>\n\nclass Math {\npublic:\n    static std::pair<float, float> DistanceSegmentToPoint(float x1, float y1, float x2, float y2, float px, float py) {\n        // Calculate the vector from the start to the end of the segment\n        float vx = x2 - x1;\n        float vy = y2 - y1;\n\n        // Calculate the vector from the start point of the segment to the point\n        float wx = px - x1;\n        float wy = py - y1;\n\n        // Calculate the square of the length of the segment\n        float c1 = vx * wx + vy * wy;\n        if (c1 <= 0) {\n            // Point projects before the segment start, so distance from the point to the first segment point\n            return {0, std::sqrt(wx * wx + wy * wy)};\n        }\n\n        // Calculate the squared length of the segment\n        float c2 = vx * vx + vy * vy;\n        if (c2 <= c1) {\n            // Point projects after the segment end, so distance from the point to the second segment point\n            float ux = px - x2;\n            float uy = py - y2;\n            return {std::sqrt(c2), std::sqrt(ux * ux + uy * uy)};\n        }\n\n        // Point projects onto the segment, compute the distance to the projection point\n        float b = c1 / c2;\n        float pxProj = x1 + b * vx;\n        float pyProj = y1 + b * vy;\n\n        float dx = px - pxProj;\n        float dy = py - pyProj;\n        return {std::sqrt(c2), std::sqrt(dx * dx + dy * dy)};\n    }\n};", "CodeBleu_score": 33.028431183864015}, {"code": "#include <cmath>\n#include <utility>\n\nclass Math {\npublic:\n    static std::pair<float, float> DistanceSegmentToPoint(float x1, float y1, float x2, float y2, float xp, float yp) {\n        // Vector from start of the segment to the end of the segment\n        float dx = x2 - x1;\n        float dy = y2 - y1;\n        \n        // Vector from start of the segment to the point\n        float dxp = xp - x1;\n        float dyp = yp - y1;\n        \n        // Calculate the squared segment length\n        float segmentLenSq = dx * dx + dy * dy;\n        \n        // Projection of point onto the line\n        float projection;\n        if (segmentLenSq == 0) {\n            // Segment is actually a point, no length\n            projection = 0;\n        } else {\n            // Project point onto the segment, resulting in parameterization of the closest point\n            projection = (dxp * dx + dyp * dy) / segmentLenSq;\n            projection = std::max(0.0f, std::min(1.0f, projection)); // Clamping the value\n        }\n        \n        // Coordinates of the projected point on the segment\n        float closestX = x1 + projection * dx;\n        float closestY = y1 + projection * dy;\n        \n        // Distance from the point to this closest point\n        float distX = xp - closestX;\n        float distY = yp - closestY;\n        float distanceToPoint = sqrt(distX * distX + distY * distY);\n        \n        // Distance along the segment from one endpoint to the projected point\n        float distanceAlongSegment = sqrt(projection * segmentLenSq); \n\n        return { distanceToPoint, distanceAlongSegment };\n    }\n};", "CodeBleu_score": 31.31684731992693}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": "#include <vector>\n#include <cassert>\n\nclass Mesh {\npublic:\n    using vertex_type = int; // Placeholder for actual vertex type\n\nprivate:\n    std::vector<vertex_type> vertices_;\n    std::vector<unsigned int> indices_;\n\npublic:\n    void AddTriangleFan(const std::vector<vertex_type> &vertices) {\n        // Assert to ensure there are at least 3 vertices to form a triangle fan\n        assert(vertices.size() >= 3);\n\n        // Record the initial index, which will be the first vertex in the fan\n        unsigned int initialIndex = vertices_.size();\n\n        // Add all vertices into the mesh's vertices list\n        vertices_.insert(vertices_.end(), vertices.begin(), vertices.end());\n\n        // Iteratively add indices to form triangles; connecting the initial vertex\n        // with each subsequent pair of vertices in the list\n        for (size_t i = 1; i < vertices.size() - 1; ++i) {\n            indices_.push_back(initialIndex);           // Index of the first vertex in the fan\n            indices_.push_back(initialIndex + i);       // Index of the current vertex\n            indices_.push_back(initialIndex + i + 1);   // Index of the next vertex to form a triangle\n        }\n    }\n\n    // Method to output the stored vertices and indices (for debugging purposes)\n    void DebugPrint() const {\n        std::cout << \"Vertices: \";\n        for (const auto& v : vertices_) {\n            std::cout << v << \" \";\n        }\n        std::cout << \"\\nIndices: \";\n        for (const auto& i : indices_) {\n            std::cout << i << \" \";\n        }\n        std::cout << std::endl;\n    }\n};", "CodeBleu_score": 38.24932581095674}, {"code": "void Mesh::AddTriangleFan(const std::vector<vertex_type> &vertices) {\n    // Assert that the vector of vertices has at least three elements to create a fan.\n    assert(vertices.size() >= 3);\n\n    // Get the initial size of indices to later calculate new index positions.\n    int initialIndex = indices.size();\n\n    // Adds all the vertices from the provided list into the vertex list of the mesh.\n    for (const auto& vertex : vertices) {\n        this->vertices.push_back(vertex);\n    }\n\n    // Add indices to form a fan. Starting at initialIndex, create triangles from the first vertex and each consecutive pair of vertices.\n    for (size_t i = 1; i < vertices.size() - 1; ++i) {\n        indices.push_back(initialIndex);       // Always start with the first vertex in the fan.\n        indices.push_back(initialIndex + i);   // Second vertex of the triangle.\n        indices.push_back(initialIndex + i + 1); // Third vertex of the triangle.\n    }\n}", "CodeBleu_score": 37.51066563680287}, {"code": "#include <cassert>\n#include <vector>\n\nclass Mesh {\npublic:\n    using vertex_type = int;  // This is a placeholder. Adjust according to actual vertex type definition in your Mesh class.\n\n    // Assumes a specific definition provided for AddVertex and AddIndex methods,\n    // AddVertex: Adds the vertex to the mesh and returns an index.\n    // AddIndex: Adds the index to index array of the mesh.\nprivate:\n    std::vector<vertex_type> vertex_data; // This holds the vertex data of the mesh\n    std::vector<int> index_data; // This holds the indices for drawing the triangles\n\npublic:\n    // Method to add a vertex to the mesh data \n    int AddVertex(const vertex_type& vertex) {\n        vertex_data.push_back(vertex);\n        return static_cast<int>(vertex_data.size() - 1); // Return new index of the added vertex\n    }\n\n    // Method to add an index to the triangle list\n    void AddIndex(int index) {\n        index_data.push_back(index);\n    }\n\n    // Method to add a triangle fan as described\n    void AddTriangleFan(const std::vector<vertex_type> &vertices) {\n        assert(vertices.size() >= 3); // Ensure there are at least three vertices\n\n        int initialIndex = -1;\n        std::vector<int> indices;\n\n        // Add vertices to the mesh and record their indices\n        for (const auto& vertex : vertices) {\n            int idx = AddVertex(vertex);\n            indices.push_back(idx);\n            if (initialIndex == -1) {\n                initialIndex = idx; // Set the first index as the initial index\n            }\n        }\n\n        // Add indices to form the triangle fan\n        for (size_t i = 1; i < indices.size() - 1; ++i) {\n            AddIndex(initialIndex);          // Add the initial vertex index\n            AddIndex(indices[i]);            // Add the next vertex index\n            AddIndex(indices[i + 1]);        // Add the vertex after that\n        }\n    }\n};\n\n// Example usage or further implementation details would be adjusted based on the actual mesh and vertex handling definitions.", "CodeBleu_score": 35.70469389265812}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "#include <boost/asio.hpp>\n#include <iostream>\n#include <memory>\n\nnamespace carla {\n    namespace streaming {\n        namespace detail {\n            namespace tcp {\n                struct Message {\n                    std::vector<uint8_t> content;\n                };\n            }\n        }\n    }\n}\n\nclass Primary {\nprivate:\n    boost::asio::io_service& io_service;\n    boost::asio::ip::tcp::socket socket;\n    boost::asio::strand<boost::asio::io_service::executor_type> strand;\n\npublic:\n    Primary(boost::asio::io_service& io, boost::asio::ip::tcp::socket sock)\n        : io_service(io), socket(std::move(sock)), strand(boost::asio::make_strand(io)) {}\n\n    void Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n        if (!message) {\n            std::cerr << \"Invalid message provided.\" << std::endl;\n            return;\n        }\n\n        auto self(shared_from_this()); // To keep the instance alive during the async operation\n        strand.post([this, self, message]() {\n            if (!socket.is_open()) {\n                std::cerr << \"Socket is not open.\" << std::endl;\n                return;\n            }\n\n            // Setting a timeout might require additional timer setup depending on your application logic\n            // Example: boost::asio::deadline_timer timer(io_service); (requires using an actual timer to manage deadlines)\n\n            auto handle_sent = [this, self](const boost::system::error_code& ec, std::size_t /* bytes_transferred */) {\n                if (ec) {\n                    std::cerr << \"Write failed: \" << ec.message() << std::endl;\n                    socket.close();\n                } else {\n                    std::cout << \"Message sent successfully.\" << std::endl;\n                }\n            };\n\n            boost::asio::async_write(socket,\n                                     boost::asio::buffer(message->content),\n                                     strand.wrap(handle_sent));\n        });\n    }\n\n    // Make sure class is enable_shared_from_this.\n};\n\n// This class must inherit from std::enable_shared_from_this to use shared_from_this().\nclass Primary : public std::enable_shared_from_this<Primary> {\n    // Class contents here\n};", "CodeBleu_score": 37.98182399370228}, {"code": "#include <iostream>\n#include <boost/asio.hpp>\n#include <boost/bind.hpp>\n#include <memory>\n\nclass Primary {\npublic:\n    boost::asio::io_service io_service;\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::strand<boost::asio::io_context::executor_type> strand_;\n\n    Primary(boost::asio::io_service& io_service)\n        : socket_(io_service),\n          strand_(io_service.get_executor()) {}\n\n    void Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n        if (!message || message->empty()) {\n            std::cerr << \"Error: Attempted to write an empty or null message\" << std::endl;\n            return;\n        }\n\n        auto self(shared_from_this());\n        strand_.post([this, self, message]() {\n            if (!socket_.is_open()) {\n                std::cerr << \"Socket is closed.\" << std::endl;\n                return;\n            }\n\n            // Assuming Message has a data() method that returns data buffer and size() method for the size.\n            boost::asio::async_write(socket_, boost::asio::buffer(message->data(), message->size()),\n                [this, self](const boost::system::error_code& ec, std::size_t bytes_transferred) {\n                    if (ec) {\n                        std::cerr << \"Write error: \" << ec.message() << std::endl;\n                        socket_.close();\n                    } else {\n                        std::cout << \"Successfully sent message of size: \" << bytes_transferred << std::endl;\n                    }\n                });\n        });\n    }\n\n    // Helper function that's presumed to exist in 'carla::streaming::detail::tcp::Message'\n    std::shared_ptr<Primary> shared_from_this() { \n        return std::shared_ptr<Primary>(this);\n    }\n};\n\nnamespace carla {\nnamespace streaming {\nnamespace detail {\nnamespace tcp {\nstruct Message {\n    std::vector<char> data_;\n\n    Message(const std::string& msg) : data_(msg.begin(), msg.end()) {}\n\n    const char* data() const { return data_.data(); }\n    size_t size() const { return data_.size(); }\n\n    bool empty() const { return data_.empty(); }\n};\n}  // namespace tcp\n}  // namespace detail\n}  // namespace streaming\n}  // namespace carla\n\nint main() {\n    boost::asio::io_service service;\n    Primary primary(service);\n    auto message = std::make_shared<carla::streaming::detail::tcp::Message>(\"Hello, world!\");\n    primary.Write(message);\n    service.run();\n\n    return 0;\n}", "CodeBleu_score": 38.446874036939235}, {"code": "#include <iostream>\n#include <boost/asio.hpp>\n#include <memory>\n#include <functional>\n\nnamespace carla {\n    namespace streaming {\n        namespace detail {\n            namespace tcp {\n                class Message {\n                    // Assume Message class has necessary members and methods.\n                };\n            }\n        }\n    }\n}\n\nclass Primary {\nprivate:\n    boost::asio::io_service io_service_;\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::strand<boost::asio::io_context::executor_type> strand_;\n\npublic:\n    Primary(boost::asio::io_service& io_service, boost::asio::ip::tcp::endpoint endpoint)\n        : io_service_(io_service),\n          socket_(io_service),\n          strand_(io_service.get_executor()) {\n        socket_.open(boost::asio::ip::tcp::v4());\n        socket_.connect(endpoint);\n    }\n\n    void Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message) {\n        if (!message) {\n            std::cerr << \"Message is nullptr, cannot send.\" << std::endl;\n            return;\n        }\n\n        // Post a job to the strand to ensure thread-safety.\n        boost::asio::post(strand_, [this, message, self=shared_from_this()] {\n            if (!socket_.is_open()) {\n                std::cerr << \"Socket not open, cannot send message.\" << std::endl;\n                return;\n            }\n\n            // Set timeout for the operation if needed.\n            boost::asio::deadline_timer timer(io_service_);\n            timer.expires_from_now(boost::posix_time::seconds(5)); // timeout of 5 seconds\n            \n            auto handle_timeout = [this](const boost::system::error_code& error) {\n                if (!error) {\n                    // If timer expires, close the socket.\n                    std::cerr << \"Timeout during send operation.\" << std::endl;\n                    socket_.close();\n                }\n            };\n\n            // Asynchronous write operation\n            boost::asio::async_write(socket_, boost::asio::buffer(message->data(), message->size()),\n                boost::asio::bind_executor(strand_, [this, timer](boost::system::error_code ec, std::size_t length) mutable {\n                    timer.cancel();\n                    if (!ec) {\n                        std::cout << \"Message sent successfully.\" << std::endl;\n                    } else {\n                        std::cerr << \"Error sending message: \" << ec.message() << '\\n';\n                        socket_.close();\n                    }\n                })\n            );\n\n            // Start the timer after post\n            timer.async_wait(boost::asio::bind_executor(strand_, handle_timeout));\n        });\n    }\n};\n\n// This code must be used within an appropriate context where io_service and endpoints are managed.", "CodeBleu_score": 37.002306547924555}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "#include <boost/asio.hpp>\n#include <iostream>\n\nclass Primary {\npublic:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::steady_timer timer_;\n    std::function<void()> on_closed;\n\n    Primary(boost::asio::io_context& io_context)\n        : socket_(io_context), timer_(io_context) {\n    }\n\n    void CloseNow(boost::system::error_code ec) {\n        // Cancel the deadline timer first\n        timer_.cancel();\n\n        // Check if no error code is provided and the socket is opened\n        if (!ec && socket_.is_open()) {\n            try {\n                // Attempt to shut down the socket's send and receive operations\n                socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n                \n                // Now close the socket\n                socket_.close();\n\n                // Logging that no error occurred and socket is cleanly shutdown\n                std::cout << \"Socket shutdown and closed cleanly.\" << std::endl;\n            } catch (const std::exception& e) {\n                // Log the exception message\n                std::cerr << \"Exception caught in CloseNow: \" << e.what() << std::endl;\n            }\n        } else if (ec) {\n            // If there's an error, logging the error message and closing the socket\n            socket_.close();  // Close the socket unconditionally to free resources\n            std::cerr << \"Error on close: \" << ec.message() << std::endl;\n        }\n\n        // Trigger the on_closed callback if it is set\n        if (on_closed) {\n            on_closed();\n        }\n\n        // Log that the session is being closed\n        std::cout << \"Session closed.\" << std::endl;\n    }\n};", "CodeBleu_score": 45.397209078288846}, {"code": "#include <boost/asio.hpp>\n#include <iostream>\n\nclass Primary {\npublic:\n    boost::asio::ip::tcp::socket socket_;\n    boost::asio::steady_timer timer_;\n    std::function<void()> on_closed;\n\n    Primary(boost::asio::io_context& io_context)\n        : socket_(io_context), timer_(io_context) {}\n\n    void CloseNow(boost::system::error_code ec) {\n        // Cancel the deadline timer\n        timer_.cancel();\n        \n        // Check if there is no error and the socket is open\n        if (!ec && socket_.is_open()) {\n            // Attempt to shutdown the socket\n            boost::system::error_code shutdown_ec;\n            socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, shutdown_ec);\n            if (shutdown_ec) {\n                std::cerr << \"Shutdown failed: \" << shutdown_ec.message() << std::endl;\n            }\n\n            // Attempt to close the socket\n            boost::system::error_code close_ec;\n            socket_.close(close_ec);\n            if (close_ec) {\n                std::cerr << \"Close failed: \" << close_ec.message() << std::endl;\n            }\n        }\n\n        // Trigger the on_closed callback\n        if (on_closed) {\n            on_closed();\n        }\n\n        // Log that the session has been closed\n        std::cout << \"Session closed\" << std::endl;\n    }\n};", "CodeBleu_score": 42.868908865375964}, {"code": "#include <boost/asio.hpp>\n#include <boost/system/error_code.hpp>\n#include <iostream>\n\nclass Primary {\nprivate:\n    boost::asio::steady_timer timer_;\n    boost::asio::ip::tcp::socket socket_;\n    std::function<void()> on_closed_;\n\npublic:\n    Primary(boost::asio::io_context& io_context) \n        : timer_(io_context), socket_(io_context) {}\n\n    void CloseNow(boost::system::error_code ec) {\n        // Cancel the deadline timer\n        timer_.cancel();\n\n        // Check if there is no error and the socket is open\n        if (!ec && socket_.is_open()) {\n            // Attempt to shut down the socket both read and write operations\n            ec.clear();\n            socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n            \n            // If no error on shutdown, close the socket\n            if (!ec) {\n                socket_.close(ec);\n            }\n        }\n\n        // Trigger the on_closed callback if it exists\n        if (on_closed_) {\n            on_closed_();\n        }\n\n        // Logging the session closure\n        if (ec) {\n            std::cerr << \"Error closing socket: \" << ec.message() << std::endl;\n        } else {\n            std::cout << \"Session has been closed successfully.\" << std::endl;\n        }\n    }\n\n    void set_on_closed_callback(const std::function<void()>& callback) {\n        on_closed_ = callback;\n    }\n};", "CodeBleu_score": 47.365041398366586}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "#include <iostream>\n#include <string>\n\nclass Router {\npublic:\n    void write(const char* message, int command) {\n        // Simulation of sending data to router.\n        std::cout << \"Sending to Router: \" << message << \", Command: \" << command << std::endl;\n    }\n\n    std::string readResponse() {\n        // Simulated response from router.\n        return \"Yes, I'm alive!\";\n    }\n};\n\nclass Logger {\npublic:\n    void log(const std::string& message) {\n        std::cout << \"Log: \" << message << std::endl;\n    }\n};\n\nclass PrimaryCommands {\nprivate:\n    Router router;\n    Logger logger;\npublic:\n    // Enumeration to simulate command types\n    enum Command { YOU_ALIVE = 1 };\n\n    void SendIsAlive() {\n        const char* message = \"Are you alive?\";\n        logger.log(\"Sending IS_ALIVE check.\");\n        \n        // Write the message to the router with a specific command\n        router.write(message, YOU_ALIVE);\n        \n        // Log the response from system\n        std::string response = router.readResponse();\n        logger.log(\"Received response: \" + response);\n    }\n};\n\nint main() {\n    PrimaryCommands commands;\n    commands.SendIsAlive();\n    return 0;\n}", "CodeBleu_score": 41.36248323290892}, {"code": "#include <cstring>     // For strlen\n#include <iostream>    // For std::cout logging as an example; replace with your logging system\n\nclass PrimaryCommands {\npublic:\n    void SendIsAlive();\n\nprivate:\n    void log(const std::string& message);\n    void writeCommand(const char* buffer, size_t size, int command);\n\n    // Example command constants\n    static constexpr int YOU_ALIVE = 1;\n\n    // Network mocking\n    class Network {\n    public:\n        static void write(const char* buffer, size_t size, int command) {\n            std::cout << \"Writing to network. Command: \" << command << \", Message: \" << buffer << std::endl;\n        }\n    };\n\n    // Logger mocking\n    class Logger {\n    public:\n        static void log(const std::string& message) {\n            std::cout << \"Log: \" << message << std::endl;\n        }\n    };\n};\n\nvoid PrimaryCommands::SendIsAlive() {\n    const char* message = \"Are you alive?\";\n    size_t messageLength = strlen(message);\n\n    // Log the send action\n    log(\"Sending 'Are you alive?' message.\");\n\n    // Write the message to the next router with the appropriate command\n    writeCommand(message, messageLength, YOU_ALIVE);\n\n    // For demonstration: assumption of receiving a response (this part is very simplified)\n    char buffer[256]; // Assuming response fits into this buffer\n    // In actual code, you would have network code to receive data into buffer\n    strcpy(buffer, \"Yes, I'm alive.\"); // Mock response\n\n    // Log the received response\n    log(std::string(\"Received response: \") + buffer);\n}\n\nvoid PrimaryCommands::log(const std::string& message) {\n    Logger::log(message);\n}\n\nvoid PrimaryCommands::writeCommand(const char* buffer, size_t size, int command) {\n    Network::write(buffer, size, command);\n}\n\n// Example usage:\nint main() {\n    PrimaryCommands pc;\n    pc.SendIsAlive();\n    return 0;\n}", "CodeBleu_score": 41.31850966124281}, {"code": "#include <iostream>\n#include <cstring>\n\nclass PrimaryCommands {\nprivate:\n    // Placeholder for a router that can send/receive messages\n    class Router {\n    public:\n        void send(const char* message, size_t size) {\n            // Example sending mechanism\n            std::cout << \"Sending message: \" << std::string(message, size) << std::endl;\n        }\n\n        std::string receive() {\n            // Placeholder for response - in real scenarios, should handle actual receipt of messages\n            return \"Yes, I'm alive!\";\n        }\n    };\n\n    Router router;\n\n    void writeLog(const std::string& logMessage) {\n        std::cout << \"Log: \" << logMessage << std::endl;\n    }\n\npublic:\n    void SendIsAlive() {\n        const char* message = \"Are you alive?\";\n        size_t message_length = std::strlen(message);\n        \n        // Log sending message\n        writeLog(\"Sending 'Are you alive?' message\");\n        \n        // Sending message\n        router.send(message, message_length);\n\n        // Log sent\n        writeLog(\"Message sent\");\n        \n        // Wait for and receive response\n        std::string response = router.receive();\n        \n        // Log the received response\n        writeLog(\"Received response: \" + response);\n    }\n};\n\n// For demonstration purposes\nint main() {\n    PrimaryCommands pc;\n    pc.SendIsAlive();\n    return 0;\n}", "CodeBleu_score": 42.807368623120446}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <stdexcept>\n\n// Mock-up classes to simulate function behavior\nclass Router {\npublic:\n    void sendCommand(const std::string& server, const std::string& command, int sensor_id) {\n        std::cout << \"Sending command to \" << server << \": \" << command << \" for sensor \" << sensor_id << std::endl;\n    }\n\n    std::string getResponse() {\n        // Stubbed response from server\n        return \"ACK\";\n    }\n};\n\nclass Logger {\npublic:\n    void logError(const std::string& message) {\n        std::cerr << \"ERROR: \" << message << std::endl;\n    }\n};\n\nclass PrimaryCommands {\n    std::map<int, std::string> sensor_server_map; // Maps sensor IDs to server names\n    Router router;\n    Logger logger;\n\npublic:\n    PrimaryCommands() {\n        // Initialize some fake data\n        sensor_server_map[1] = \"ServerA\";\n        sensor_server_map[2] = \"ServerB\";\n        sensor_server_map[3] = \"ServerC\";\n    }\n\n    void SendEnableForROS(int sensor_id) {\n        // Check if the provided sensor_id exists in the sensor_server_map\n        auto it = sensor_server_map.find(sensor_id);\n        if (it != sensor_server_map.end()) {\n            std::string server = it->second;\n\n            // Create a command buffer and send ENABLE_ROS command\n            std::string command = \"ENABLE_ROS\";\n            router.sendCommand(server, command, sensor_id);\n\n            // Receive response from the server\n            std::string response = router.getResponse();\n            if (response == \"ACK\") {\n                std::cout << \"Response from \" << server << \": \" << response << std::endl;\n            } else {\n                logger.logError(\"Failed to receive ACK from \" + server);\n            }\n        } else {\n            // Log an error if the sensor ID is not found\n            logger.logError(\"Sensor ID \" + std::to_string(sensor_id) + \" not found on any server.\");\n        }\n    }\n};", "CodeBleu_score": 45.869214154630406}, {"code": "#include <iostream>\n#include <vector>\n#include <map>\n\nclass Router {\npublic:\n    void sendCommandToServer(int serverId, const std::string& command) {\n        // Simulate sending command to a server\n        std::cout << \"Command sent to server \" << serverId << \": \" << command << std::endl;\n    }\n\n    std::string receiveResponseFromServer(int serverId) {\n        // Simulate receiving response from a server\n        return \"Response from server \" << serverId;\n    }\n};\n\nclass PrimaryCommands {\nprivate:\n    Router router;\n    std::map<int, int> sensorToServerMap; // Maps sensor IDs to server IDs\n\npublic:\n    // To be configured somewhere else, example server setup\n    void setupServers() {\n        sensorToServerMap[101] = 1; // Sensor ID 101 is on server 1\n        sensorToServerMap[102] = 2; // Sensor ID 102 is on server 2\n    }\n\n    void logError(const std::string& message) {\n        std::cerr << \"Error: \" << message << std::endl;\n    }\n\n    void SendEnableForROS(int sensor_id) {\n        auto it = sensorToServerMap.find(sensor_id);\n        if (it != sensorToServerMap.end()) {\n            int serverId = it->second;\n            std::string command = \"ENABLE_ROS \" + std::to_string(sensor_id);\n\n            // Sends an ENABLE_ROS command to the identified server\n            router.sendCommandToServer(serverId, command);\n\n            // Waiting for response from the server\n            std::string response = router.receiveResponseFromServer(serverId);\n\n            // Process the response\n            std::cout << \"Received response: \" << response << std::endl;\n        } else {\n            // Log error if sensor ID is not found on any server\n            logError(\"Sensor ID \" + std::to_string(sensor_id) + \" not found on any server.\");\n        }\n    }\n};\n\nint main() {\n    PrimaryCommands pc;\n    pc.setupServers();\n    pc.SendEnableForROS(101); // Example use: send enable command for sensor ID 101\n    pc.SendEnableForROS(103); // Example use: attempts to send enable command for sensor ID 103, expects error\n\n    return 0;\n}", "CodeBleu_score": 44.95986187973786}, {"code": "#include <iostream>\n#include <vector>\n#include <string>\n\nclass Router {\npublic:\n    void sendCommandToServer(int serverId, std::string command, int sensorId) {\n        // Placeholder for command sending logic\n        std::cout << \"Sending command to server \" << serverId << \": \" << command << \" for sensor ID \" << sensorId << std::endl;\n    }\n\n    std::string receiveResponseFromServer(int serverId) {\n        // Placeholder for response receiving logic\n        return \"OK\"; // Assume server always responds with \"OK\"\n    }\n};\n\nclass Server {\npublic:\n    bool hasSensorActivated(int sensorId) {\n        return sensorId % 2 == 0;  // Example logic: sensors with even IDs are \"activated\"\n    }\n};\n\nclass PrimaryCommands {\nprivate:\n    Router router;\n    std::vector<Server> servers;\n\n    // Assuming a list of servers are populated elsewhere in the class\npublic:\n    // Constructor to initialize servers\n    PrimaryCommands() {\n        servers.push_back(Server());\n        servers.push_back(Server());\n    }\n\n    void SendEnableForROS(int sensor_id) {\n        bool sensorFound = false;\n        const std::string ENABLE_ROS = \"ENABLE_ROS\";\n\n        // Check all servers for the sensor activation\n        for (int i = 0; i < servers.size(); ++i) {\n            if (servers[i].hasSensorActivated(sensor_id)) {\n                sensorFound = true;\n                // Send ENABLE_ROS command to the router\n                router.sendCommandToServer(i, ENABLE_ROS, sensor_id);\n                // Receive and process response\n                std::string response = router.receiveResponseFromServer(i);\n                std::cout << \"Response from server \" << i << \": \" << response << std::endl;\n                break;\n            }\n        }\n\n        if (!sensorFound) {\n            std::cerr << \"Error: Sensor ID \" << sensor_id << \" not found on any server.\" << std::endl;\n        }\n    }\n};", "CodeBleu_score": 37.421150142430214}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "#include <iostream>\n#include <string>\n#include <map>\n\nclass PrimaryCommands {\npublic:\n    using token_type = std::string;\n    using stream_id = int;\n\nprivate:\n    std::map<stream_id, token_type> activeSensors;\n    std::map<stream_id, bool> sensorActivationStatus;\n\n    token_type requestNewToken(stream_id sensor_id) {\n        // Fabricate a new token (In a real-world scenario, this might involve communication with a server)\n        return \"TOKEN_\" + std::to_string(sensor_id) + \"_\" + std::to_string(rand());\n    }\n    \n    void activateSensorOnServer(stream_id sensor_id) {\n        // Activate the sensor, simulated by setting activation status (In real scenarios, this might involve network operations)\n        sensorActivationStatus[sensor_id] = true;\n        std::cout << \"Sensor \" << sensor_id << \" activated on secondary server.\" << std::endl;\n    }\n\npublic:\n    token_type GetToken(stream_id sensor_id) {\n        auto it = activeSensors.find(sensor_id);\n        if (it != activeSensors.end()) {\n            // Sensor is already activated, return existing token\n            std::cout << \"Returning existing token for sensor \" << sensor_id << std::endl;\n            return it->second;\n        } else {\n            // Sensor is not activated, activate it and generate a new token\n            activateSensorOnServer(sensor_id);  // Activate the sensor on the secondary server\n            token_type newToken = requestNewToken(sensor_id);  // Generate a new token\n            activeSensors[sensor_id] = newToken;  // Save the token\n            std::cout << \"New token \" << newToken << \" generated and stored for sensor \" << sensor_id << std::endl;\n            return newToken;  // Return the new token\n        }\n    }\n};\n\nint main() {\n    PrimaryCommands cmd;\n    auto token1 = cmd.GetToken(101);  // Requesting a token for sensor 101\n    std::cout << \"Token for sensor 101: \" << token1 << std::endl;\n    auto token2 = cmd.GetToken(101);  // Requesting token again should return the same token\n    std::cout << \"Token for sensor 101: \" << token2 << std::endl;\n    auto token3 = cmd.GetToken(102);  // Requesting a token for a different sensor\n    std::cout << \"Token for sensor 102: \" << token3 << std::endl;\n\n    return 0;\n}", "CodeBleu_score": 45.78413948177657}, {"code": "#include <iostream>\n#include <map>\n#include <string>\n\n// Placeholder for the token type.\ntypedef std::string token_type;\n\n// Assuming a class for logging the actions.\nclass Logger {\npublic:\n    void log(const std::string& message) {\n        std::cout << message << std::endl;\n    }\n};\n\n// Assuming a class for managing sensor operations.\nclass SensorManager {\n    std::map<int, token_type> active_sensors;\n    Logger log;\n\npublic:\n    // Checks if sensor is already activated and returns the token if it is.\n    // If not, activates the sensor, stores the new token, logs the action, and returns the token.\n    token_type getToken(int sensor_id) {\n        if (active_sensors.find(sensor_id) != active_sensors.end()) {\n            log.log(\"Sensor \" + std::to_string(sensor_id) + \" is already activated. Using existing token.\");\n            return active_sensors[sensor_id];\n        } else {\n            return enableSensor(sensor_id);\n        }\n    }\n\nprivate:\n    // Simulate activating a sensor and retrieving a token.\n    token_type enableSensor(int sensor_id) {\n        // Simulate generating a new token.\n        token_type new_token = \"token_\" + std::to_string(sensor_id);\n\n        // Update maps (assuming map to store sensor_id and token).\n        active_sensors[sensor_id] = new_token;\n\n        // Log the action.\n        log.log(\"Sensor \" + std::to_string(sensor_id) + \" activated. New token generated and stored.\");\n\n        return new_token;\n    }\n};\n\n// Placeholder for the PrimaryCommands class which uses SensorManager.\nclass PrimaryCommands {\n    SensorManager sensorManager;\n\npublic:\n    token_type GetToken(int sensor_id) {\n        return sensorManager.getToken(sensor_id);\n    }\n};\n\n// Usage example\nint main() {\n    PrimaryCommands cmd;\n    int sensor_id = 101; // Example sensor ID\n    token_type token = cmd.GetToken(sensor_id);\n    std::cout << \"Token for sensor \" << sensor_id << \": \" << token << std::endl;\n    return 0; // Successful execution\n}", "CodeBleu_score": 36.62933107487546}, {"code": "#include <iostream>\n#include <unordered_map>\n#include <string>\n\nclass PrimaryCommands {\n    // Placeholder token type and stream_id definitions, replace with actual types.\n    using token_type = std::string;\n    using stream_id = int;\n\n    // Simulates a secondary server's command to activate sensors and get tokens.\n    struct SecondaryServer {\n        std::unordered_map<stream_id, token_type> sensorTokens;\n\n        // Function to enable sensor and generate a new token.\n        token_type enableSensorAndGetToken(stream_id id) {\n            std::string newToken = \"token_\" + std::to_string(id);\n            sensorTokens[id] = newToken;\n            return newToken;\n        }\n    };\n\n    // Maps to keep track of sensor activations and their tokens.\n    std::unordered_map<stream_id, token_type> activeSensors;\n    SecondaryServer secondaryServer;\n\npublic:\n    // Retrieves or assigns a token for a given sensor id.\n    token_type GetToken(stream_id sensor_id) {\n        // Check if sensor is already activated\n        auto it = activeSensors.find(sensor_id);\n        if (it != activeSensors.end()) {\n            std::cout << \"Sensor \" << sensor_id << \" already active. Token: \" << it->second << std::endl; \n            return it->second;  // Return existing token\n        }\n\n        // Activate the sensor on SecondaryServer and get a new token\n        std::cout << \"Activating sensor \" << sensor_id << \" on secondary server.\" << std::endl;\n        token_type newToken = secondaryServer.enableSensorAndGetToken(sensor_id);\n\n        // Update active sensors map\n        activeSensors[sensor_id] = newToken;\n\n        // Log the action\n        std::cout << \"New token retrieved: \" << newToken << \" for sensor \" << sensor_id << std::endl;\n\n        // Return the new token\n        return newToken;\n    }\n};\n\nint main() {\n    PrimaryCommands cmd;\n    int sensor_id = 101;  // Example sensor ID\n    std::string token = cmd.GetToken(sensor_id);  // Retrieve token\n    std::cout << \"Token for sensor \" << sensor_id << \": \" << token << std::endl;\n\n    // Retrieve token again should retrieve cached token and not activate\n    token = cmd.GetToken(sensor_id);\n    std::cout << \"Token for sensor \" << sensor_id << \": \" << token << std::endl;\n    return 0;\n}", "CodeBleu_score": 47.590571844634965}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "#include <fstream>\n#include <vector>\n\nclass Navigation {\npublic:\n    bool Load(const std::string &filename) {\n        // Open the file in binary mode\n        std::ifstream file(filename, std::ios::binary);\n        \n        // Check if the file was opened successfully\n        if (!file.is_open()) {\n            return false;\n        }\n        \n        // Read the contents of the file into a vector\n        std::vector<char> fileData((std::istreambuf_iterator<char>(file)),\n                                    std::istreambuf_iterator<char>());\n        \n        // Close the file as it's no longer needed\n        file.close();\n        \n        // Call the internal load function with the loaded data\n        return Load(fileData);\n    }\n    \nprivate:\n    bool Load(const std::vector<char> &data) {\n        // Implementation to parse the data\n        // For example, parse navigation data from the content\n        // This is a placeholder for the actual parsing logic\n        return true;\n    }\n};", "CodeBleu_score": 48.584946293699254}, {"code": "#include <fstream>\n#include <vector>\n\nclass Navigation {\npublic:\n    bool Load(const std::string& filename) {\n        // Open the file in binary mode\n        std::ifstream file(filename, std::ios::binary);\n        \n        // Check if the file was opened correctly\n        if (!file.is_open()) {\n            return false;\n        }\n        \n        // Read the contents of the file into a vector\n        std::vector<char> fileData((std::istreambuf_iterator<char>(file)),\n                                    std::istreambuf_iterator<char>());\n        \n        // Close the file after reading\n        file.close();\n        \n        // Parse the content by calling another Load function with the file data\n        return Load(fileData);\n    }\n\nprivate:\n    bool Load(const std::vector<char>& data) {\n        // This should contain the actual parsing logic\n        // For now, let's suppose it always succeeds\n        return true;\n    }\n};", "CodeBleu_score": 48.57242817799411}, {"code": "#include <fstream>\n#include <vector>\n\nclass Navigation {\npublic:\n    bool Load(const std::string &filename);\n    bool Load(const std::vector<char> &data);\n\n    // Implementation details for second Load function\n    bool Load(const std::vector<char> &data) {\n        // Imagine some kind of parsing logic here\n        return true; // Assuming parsing always succeeds for simplicity\n    }\n};\n\nbool Navigation::Load(const std::string &filename) {\n    std::ifstream file(filename, std::ios::binary); // Open file in binary mode\n    if (!file.is_open()) {\n        return false; // Failed to open file\n    }\n\n    // Read all contents of the file into a vector\n    std::vector<char> fileData(\n        (std::istreambuf_iterator<char>(file)), \n        (std::istreambuf_iterator<char>())\n    );\n\n    // Always close the file after reading it\n    file.close();\n\n    // Call the Load function that handles the data parsing\n    return Load(fileData);\n}", "CodeBleu_score": 48.138085999967934}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "{\n    if (!IsSystemReady()) {\n        return false; // Returns false if the system is not ready\n    }\n\n    assert(crowd != nullptr); // Ensures the crowd object is not null\n\n    std::lock_guard<std::mutex> lock(crowd_mutex); // Locks the critical section to safely perform operations\n\n    // Check if the given id exists either in walkers or vehicles\n    auto walkerIt = walker_mapping.find(id);\n    auto vehicleIt = vehicle_mapping.find(id);\n\n    bool isWalker = walkerIt != walker_mapping.end();\n    bool isVehicle = vehicleIt != vehicle_mapping.end();\n\n    if (!isWalker && !isVehicle) {\n        return false; // The agent id does not exist in both mappings\n    }\n\n    if (isWalker) {\n        // Remove the agent from the walker manager\n        walker_manager.RemoveWalker(walkerIt->second);\n        // Update the walker mapping\n        walker_mapping.erase(walkerIt);\n    }\n\n    if (isVehicle) {\n        // Remove the agent from the vehicle manager\n        vehicle_manager.RemoveVehicle(vehicleIt->second);\n        // Update the vehicle mapping\n        vehicle_mapping.erase(vehicleIt);\n    }\n\n    // Finally, remove the agent from the crowd\n    crowd->removeAgent(id);\n\n    return true; // Returns true if removal is successful\n}", "CodeBleu_score": 50.89296182967309}, {"code": "bool Navigation::RemoveAgent(ActorId id) {\n    // Check if the navigation system is ready (assuming there's a function or state for this)\n    if (!this->IsReady()) {\n        return false;\n    }\n\n    // Assert that the crowd object is not null\n    assert(this->crowd != nullptr);\n\n    // Enter critical section to ensure thread safety\n    std::lock_guard<std::mutex> lock(this->navigationMutex);\n\n    // Check if the agent exists in the walker mapping\n    auto walkerIter = this->walkerMapping.find(id);\n    if (walkerIter != this->walkerMapping.end()) {\n        // Remove the agent from the crowd\n        if (!this->crowd->removeAgent(id)) {\n            return false;\n        }\n        // Update walker manager or similar system\n        this->walkerManager->updateAfterRemoval(id);\n\n        // Remove from walker mapping\n        this->walkerMapping.erase(walkerIter);\n        return true;\n    }\n\n    // Check if the agent exists in the vehicle mapping\n    auto vehicleIter = this->vehicleMapping.find(id);\n    if (vehicleIter != this->vehicleMapping.end()) {\n        // Remove the agent from the crowd\n        if (!this->crowd->removeAgent(id)) {\n            return false;\n        }\n        // Update vehicle manager or similar system\n        this->vehicleManager->updateAfterRemoval(id);\n        \n        // Remove from vehicle mapping\n        this->vehicleMapping.erase(vehicleIter);\n        return true;\n    }\n\n    // If the agent was not found in any mappings\n    return false;\n}", "CodeBleu_score": 34.97556650300287}, {"code": "#include <mutex>\n\nbool Navigation::RemoveAgent(ActorId id) {\n    // Check if the navigation system is initialized and ready\n    if (!this->isReady) {\n        return false;\n    }\n\n    // Assert that the crowd object is not null\n    assert(this->crowd != nullptr);\n\n    // Lock the mutex for thread-safe access\n    std::lock_guard<std::mutex> guard(this->navMutex);\n    \n    // Check if the agent ID is in the walker mapping\n    auto walkerIter = this->walkerMap.find(id);\n    if (walkerIter != this->walkerMap.end()) {\n        // Remove the agent from the walker crowd\n        this->crowd->removeAgent(walkerIter->second);\n        // Remove the entry from the walker map\n        this->walkerMap.erase(walkerIter);\n    }\n    // Check if the agent ID is in the vehicle mapping\n    else {\n        auto vehicleIter = this->vehicleMap.find(id);\n        if (vehicleIter != this->vehicleMap.end()) {\n            // Remove the agent from the vehicle manager\n            this->vehicleManager->removeAgent(vehicleIter->second);\n            // Remove the entry from the vehicle map\n            this->vehicleMap.erase(vehicleIter);\n        } else {\n            // The agent ID was not found in either mapping\n            return false;\n        }\n    }\n\n    // Returns true as the agent was successfully removed\n    return true;\n}", "CodeBleu_score": 38.9781266968777}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "#include <map>\n#include <set>\n#include <vector>\n\nclass VehicleCollisionInfo {\npublic:\n    int id;  // Unique identifier for each vehicle\n    // Other state data like position, velocity, etc.\n};\n\nclass Vehicle {\npublic:\n    int id;\n    // Constructor, getters, setters...\n    void update(const VehicleCollisionInfo& info) {\n        // Update vehicle state based on collision info\n    }\n};\n\nclass Navigation {\nprivate:\n    std::map<int, Vehicle> vehicleMap;  // Map of vehicle IDs to Vehicle objects\n\npublic:\n    bool UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles) {\n        std::set<int> updatedIds;\n\n        // Add or update vehicles from the provided list\n        for (const auto& info : vehicles) {\n            vehicleMap[info.id].update(info);\n            updatedIds.insert(info.id);\n        }\n        \n        // Collect IDs of currently mapped vehicles\n        std::vector<int> toRemove;\n        for (const auto& [id, vehicle] : vehicleMap) {\n            if (updatedIds.find(id) == updatedIds.end()) {\n                toRemove.push_back(id);\n            }\n        }\n        \n        // Remove vehicles not present in current frame\n        for (int id : toRemove) {\n            vehicleMap.erase(id);\n        }\n\n        return true;\n    }\n};", "CodeBleu_score": 38.18349122430887}, {"code": "#include <unordered_set>\n\n/*\n * This function, Navigation::UpdateVehicles, updates the state of vehicles based on a provided vector of VehicleCollisionInfo.\n * It first collects the IDs of currently mapped vehicles into a set.\n * Then, it adds or updates vehicles from the provided list, marking them as updated.\n * Vehicles not marked as updated are removed, indicating they do not exist in the current frame.\n * The function returns true upon completion.\n */\nbool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles) {\n    // Collect all unique IDs from the current state of vehicles to determine which ones need to be updated or removed\n    std::unordered_set<int> currentVehicleIDs;\n    for (const auto& vehicle : this->mappedVehicles) {\n        currentVehicleIDs.insert(vehicle.id);\n    }\n\n    // Processing each vehicle from the incoming list\n    std::unordered_set<int> updatedVehicleIDs;\n    for (const auto& vehicleInfo : vehicles) {\n        // If new, add to the map; if already present, update it\n        this->mappedVehicles[vehicleInfo.id] = vehicleInfo;\n        // Mark this vehicle ID as updated or added\n        updatedVehicleIDs.insert(vehicleInfo.id);\n        // Since this vehicle is currently present, remove it from potential removal\n        currentVehicleIDs.erase(vehicleInfo.id);\n    }\n\n    // Remove vehicles that were not updated (those remaining in currentVehicleIDs)\n    for (int id : currentVehicleIDs) {\n        this->mappedVehicles.erase(id);\n    }\n\n    return true;\n}", "CodeBleu_score": 42.64978952240402}, {"code": "#include <unordered_set>\n\nclass Navigation {\npublic:\n    struct VehicleCollisionInfo {\n        int vehicleId;\n        // Additional properties relevant for vehicle state update can be added here\n    };\n  \n    bool UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles) {\n        // Initialize a set to track the current vehicle IDs that are updated\n        std::unordered_set<int> updatedVehicleIds;\n\n        // Go through the list of vehicles and update their state\n        for (const auto& vehicleInfo : vehicles) {\n            // Add or update the vehicle in the map\n            vehicleMap[vehicleInfo.vehicleId] = vehicleInfo; // Assuming vehicleMap is a member of Navigation\n            // Mark this vehicle as updated\n            updatedVehicleIds.insert(vehicleInfo.vehicleId);\n        }\n\n        // Remove any vehicle which is not in the updated list from the last data frame\n        for (auto it = vehicleMap.begin(); it != vehicleMap.end(); ) {\n            if (updatedVehicleIds.find(it->first) == updatedVehicleIds.end()) {\n                // Vehicle ID not found in the updated list; remove it from the map\n                it = vehicleMap.erase(it);\n            } else {\n                ++it;\n            }\n        }\n\n        return true;\n    }\n\nprivate:\n    std::unordered_map<int, VehicleCollisionInfo> vehicleMap; // Map storing vehicles by their ID\n};", "CodeBleu_score": 42.74211036886395}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "#include <mutex>\n#include <cmath>\n\n// Assuming the necessary headers and namespaces are included for Actor, CrowdSystem, and others.\n\nbool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction) {\n    // Assuming `walkers` and `vehicles` are accessible maps from ActorId to Actor* within the Navigation class\n    // Assuming we have a method GetActorLocation(ActorId id) returning carla::geom::Location\n    // Assuming `crowdSystem` is an object that can check for nearby vehicles.\n  \n    std::mutex mtx; // Mutex for thread safety, assuming shared data.\n\n    std::lock_guard<std::mutex> lock(mtx); // Lock during critical section.\n\n    // Check if actor is in the system\n    bool actor_found = (walkers.find(id) != walkers.end()) || (vehicles.find(id) != vehicles.end());\n    if (!actor_found) {\n        // If actor is not found, return false immediately\n        return false;\n    }\n\n    // Get the location of the actor from another part of the system\n    carla::geom::Location actorLocation = GetActorLocation(id);\n  \n    // Calculate target location by applying direction\n    carla::geom::Location targetLocation = {\n        actorLocation.x + direction.x,\n        actorLocation.y + direction.y,\n        actorLocation.z + direction.z\n    };\n\n    // Calculate squared distance for comparison\n    float dx = targetLocation.x - actorLocation.x;\n    float dy = targetLocation.y - actorLocation.y;\n    float dz = targetLocation.z - actorLocation.z;\n    float squaredDistance = dx * dx + dy * dy + dz * dz;\n    float squaredDistanceThreshold = distance * distance;\n\n    // If the target is within the specified squared distance\n    if (squaredDistance <= squaredDistanceThreshold) {\n        // Use the crowd system to determine if a vehicle is within the defined region\n        return crowdSystem.IsVehicleNear(targetLocation, distance);\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 47.10428766855755}, {"code": "#include <mutex>\n#include <cmath>\n\n// Assuming the existence of some global or accessible map for actors\nextern std::map<ActorId, Actor*> g_actors;  // Maps actor IDs to actor objects\nextern std::map<ActorId, Vehicle*> g_vehicles;  // Maps actor IDs to vehicle objects\nextern CrowdSystem crowd_system;  // Manages interactions with crowds, vehicles, could potentially be a singleton or accessed globally\nstd::mutex navigation_mutex;  // Protect critical sections involving shared data in navigation calculations\n\nclass Navigation {\npublic:\n    // This method checks if there is a vehicle near a given actor within a specified distance and direction.\n    bool HasVehicleNear(ActorId id, float distance, carla::geom::Location direction) {\n        std::lock_guard<std::mutex> lock(navigation_mutex);  // Locks for the duration of this scope.\n\n        auto actor_iter = g_actors.find(id);\n        if (actor_iter == g_actors.end()) {\n            return false;  // Actor not found\n        }\n\n        Actor* actor = actor_iter->second;\n        carla::geom::Location actor_location = actor->GetLocation();\n        \n        // Iterate through all vehicles\n        for (const auto& pair : g_vehicles) {\n            Vehicle* vehicle = pair.second;\n            carla::geom::Location vehicle_location = vehicle->GetLocation();\n\n            // Calculate squared distance\n            float dx = vehicle_location.x - actor_location.x;\n            float dy = vehicle_location.y - actor_location.y;\n            float dz = vehicle_location.z - actor_location.z;\n            float squared_distance = dx * dx + dy * dy + dz * dz;\n\n            // Check if it's within the specified distance squared (to avoid sqrt)\n            if (squared_distance <= distance * distance) {\n                // Check if the vehicle is in the specified direction, using dot product\n                carla::geom::Location direction_vector(dx, dy, dz);\n                float dot_product = direction.x * direction_vector.x + direction.y * direction_vector.y + direction.z * direction_vector.z;\n                if (dot_product > 0) {  // Direction vector must be normalised if necessary\n                    // Use crowd system to further check if the vehicle is considered \"near\" in the specified context\n                    if (crowd_system.IsVehicleNear(actor_location, vehicle_location, distance, direction)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;  // No vehicle found within the given parameters\n    }\n};", "CodeBleu_score": 41.413599801236145}, {"code": "#include <cmath>\n\nbool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction) {\n    // Lock for thread safety as we access shared resources (walkers, vehicles)\n    std::lock_guard<std::mutex> guard(_mutex);\n\n    // Check if the actor is a walker or in a vehicle\n    auto walkerIt = walkers.find(id);\n    auto vehicleIt = vehicles.find(id);\n    std::shared_ptr<Actor> actor = nullptr;\n\n    if (walkerIt != walkers.end()) {\n        actor = walkerIt->second;\n    } else if (vehicleIt != vehicles.end()) {\n        actor = vehicleIt->second;\n    }\n\n    // If no actor found with given ID, return false\n    if (!actor) {\n        return false;\n    }\n\n    // Get the location of the actor\n    carla::geom::Location actorLocation = actor->GetLocation();\n\n    // Calculate the squared distance to be compared\n    float squaredDistance = distance * distance;\n\n    // Iterate over all vehicles to find if any is within the specified distance in the specified direction\n    for (const auto& kvp : vehicles) {\n        std::shared_ptr<Actor> otherVehicle = kvp.second;\n        if (!otherVehicle || id == kvp.first) {\n            continue;\n        }\n\n        carla::geom::Location otherLocation = otherVehicle->GetLocation();\n\n        // Check distance and direction\n        float dx = otherLocation.x - actorLocation.x;\n        float dy = otherLocation.y - actorLocation.y;\n        float dz = otherLocation.z - actorLocation.z;\n\n        // Compute actual distance squared from actor to other vehicle\n        float actualDistanceSquared = dx * dx + dy * dy + dz * dz;\n\n        // Compute directional disatance squared projection on 'direction'\n        float directionMagnitudeSquared = direction.x * direction.x + direction.y * direction.y + direction.z * direction.z;\n        float dotProduct = dx * direction.x + dy * direction.y + dz * direction.z;\n        float projectionLengthSquared = (dotProduct * dotProduct) / directionMagnitudeSquared;\n\n        // Check if the other vehicle is within the distance and in the correct direction\n        if (actualDistanceSquared <= squaredDistance && projectionLengthSquared >= actualDistanceSquared) {\n            return true; // A vehicle is found within the distance and approximately in the specified direction\n        }\n    }\n\n    // No vehicle found within the range and direction\n    return false;\n}", "CodeBleu_score": 47.72339967039903}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "#include <boost/variant2/variant.hpp>\n#include <iostream>\n#include <memory>\n#include <vector>\n\n// Assume EventResult, WalkerEventVisitor, and Context are defined elsewhere\nstruct EventResult {\n    bool success;\n    std::string message;\n};\n\nstruct RoutePoint {\n    // Some relevant route point data\n    std::string description;\n    int pointIndex;\n};\n\nstruct WalkerInfo {\n    ActorId id;\n    std::vector<RoutePoint> route;\n    int currentPointIndex;\n\n    RoutePoint getCurrentRoutePoint() const {\n        if(currentPointIndex >= 0 && currentPointIndex < route.size()) {\n            return route[currentPointIndex];\n        }\n        return {}; // Return a default in case of out of bounds\n    }\n};\n\nclass WalkerEventVisitor {\npublic:\n    WalkerEventVisitor(Context& context) : context_(context) {}\n\n    EventResult operator()(RoutePoint& routePoint) {\n        // Sample event handling logic based on RoutePoint:\n        return {true, \"Handled RoutePoint \" + std::to_string(routePoint.pointIndex) + \": \" + routePoint.description};\n    }\n\nprivate:\n    Context& context_;\n};\n\n// Context class definition, as assumed available\nstruct Context {\n    // Some context data to help process the event\n};\n\nclass WalkerManager {\n    std::shared_ptr<Context> context;\n\npublic:\n    WalkerManager(std::shared_ptr<Context> ctx) : context(ctx) {}\n\n    EventResult ExecuteEvent(ActorId id, WalkerInfo &info, double delta) {\n        RoutePoint currentRoutePoint = info.getCurrentRoutePoint();\n        WalkerEventVisitor visitor(*context);\n\n        // Assuming you use boost::variant2 for holding disparate or overloadable data\n        boost::variant2::variant<RoutePoint> eventVariant = currentRoutePoint;\n\n        // Using boost::variant2::visit to execute the appropriate handler for the event\n        return boost::variant2::visit(visitor, eventVariant);\n    }\n};", "CodeBleu_score": 38.182447493937296}, {"code": "#include <iostream>\n#include <boost/variant2/variant.hpp>\n#include \"ActorId.h\"  // Assuming ActorId is defined here.\n#include \"WalkerInfo.h\"  // Assuming WalkerInfo is defined here.\n#include \"EventResult.h\"  // Assuming EventResult is defined here.\n#include \"WalkerEventVisitor.h\" // Assuming WalkerEventVisitor is defined here.\n\nclass WalkerManager {\npublic:\n    EventResult ExecuteEvent(ActorId id, WalkerInfo& info, double delta);\n};\n\nEventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo& info, double delta) {\n    // Retrieving the current route point where the event has to be executed\n    auto& currentRoutePoint = info.getCurrentRoutePoint();\n\n    // Creating a visitor object with the necessary context (not explicitly defined, assuming simple construction)\n    WalkerEventVisitor visitor(id, delta);\n\n    // Using boost::variant2::visit to apply the visitor on the current route point\n    EventResult result = boost::variant2::visit(visitor, currentRoutePoint);\n\n    // Return the resulting EventResult\n    return result;\n}", "CodeBleu_score": 43.440136512192005}, {"code": "#include <boost/variant2/variant.hpp>\n\n// Assuming the declaration of EventResult and ActorId have been defined elsewhere.\n// Also assuming that WalkerEventVisitor and necessary event processing mechanics are defined.\n\nclass WalkerManager {\npublic:\n    EventResult ExecuteEvent(ActorId id, WalkerInfo &info, double delta) {\n        // Retrieve the current route point. Assuming WalkerInfo has a method to retrieve this.\n        auto currentRoutePoint = info.GetCurrentRoutePoint(); // Assuming such a function exists in WalkerInfo\n\n        // Create WalkerEventVisitor with the current context.\n        // WalkerEventVisitor might be structured to take current state/context as construction parameters.\n        WalkerEventVisitor visitor(delta, id);\n\n        // Assuming route points are stored as variants and the event needs to be visited/executed at current route point.\n        // visit applies the visitor to the variant, for handling polymorphism without manual type querying.\n        EventResult result = boost::variant2::visit(visitor, currentRoutePoint);\n        \n        // Return the result of the event execution.\n        return result;\n    }\n};\n\n// Note: The specific implementation details depend on how the WalkerEventVisitor, WalkerInfo, EventResult,\n// and route points are defined structurally and behaviorally. The boost::variant2::visit function\n// necessitates the route point info to be a variant type.", "CodeBleu_score": 40.34582795734302}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "#include <pugixml.hpp>\n#include <carla/road/MapBuilder.h>\n\nclass LaneParser {\npublic:\n    void Parse(const pugi::xml_document &xml, carla::road::MapBuilder &map_builder) {\n        // Assuming the root node is <roads>\n        pugi::xml_node roads = xml.child(\"roads\");\n        \n        // Iterate over all <road> nodes within the <roads> node\n        for (auto road_node : roads.children(\"road\")) {\n            // Get the road ID\n            int road_id = road_node.attribute(\"id\").as_int();\n            \n            // Assume each road has a <lanes> child node\n            pugi::xml_node lanes = road_node.child(\"lanes\");\n            \n            // Iterate over each <laneSection> node within the <lanes> node\n            for (auto lane_section_node : lanes.children(\"laneSection\")) {\n                // Assume there are separate nodes for <left>, <center>, and <right> lanes\n                pugi::xml_node left_lanes = lane_section_node.child(\"left\");\n                pugi::xml_node center_lanes = lane_section_node.child(\"center\");\n                pugi::xml_node right_lanes = lane_section_node.child(\"right\");\n                \n                // Parse the lanes using a helper method which we assume exists\n                ParseLanes(left_lanes, map_builder, road_id, \"left\");\n                ParseLanes(center_lanes, map_builder, road_id, \"center\");\n                ParseLanes(right_lanes, map_builder, road_id, \"right\");\n            }\n        }\n    }\n\nprivate:\n    void ParseLanes(const pugi::xml_node &lanes_node, carla::road::MapBuilder &map_builder, int road_id, const std::string &position) {\n        // Iterate over all <lane> nodes and extract necessary details\n        for (auto lane : lanes_node.children(\"lane\")) {\n            int lane_id = lane.attribute(\"id\").as_int();\n            // Assume other necessary attributes and handling\n            // Example: map_builder.AddLane(road_id, lane_id, position, lane_attribute);\n            \n            // Placeholder to show interaction, this needs actual implementation according to MapBuilder's API.\n            map_builder.AddLane(road_id, lane_id, position, {});\n        }\n    }\n};", "CodeBleu_score": 55.04405485956705}, {"code": "#include <pugi/pugixml.hpp>\n\nclass LaneParser {\npublic:\n    void Parse(const pugi::xml_document &xml, carla::road::MapBuilder &map_builder);\n    void ParseLanes(const pugi::xml_node &lane_node, carla::road::MapBuilder &map_builder);\n};\n\nvoid LaneParser::Parse(const pugi::xml_document &xml, carla::road::MapBuilder &map_builder) {\n    // Assuming the root node is something like <OpenDRIVE>, adjust as necessary\n    pugi::xml_node rootNode = xml.child(\"OpenDRIVE\");\n\n    // loop through each road in the XML\n    for (pugi::xml_node roadNode = rootNode.child(\"road\"); roadNode; roadNode = roadNode.next_sibling(\"road\")) {\n        std::string road_id = roadNode.attribute(\"id\").value();  // Extract road ID\n\n        // Find the lanes node within the road node\n        pugi::xml_node lanesNode = roadNode.child(\"lanes\");\n\n        // Process each lane section within the lanes node\n        for (pugi::xml_node laneSectionNode = lanesNode.child(\"laneSection\"); laneSectionNode; \n             laneSectionNode = laneSectionNode.next_sibling(\"laneSection\")) {\n\n            // Process left, center, and right lanes\n            pugi::xml_node leftLanes = laneSectionNode.child(\"left\");\n            if (leftLanes) {\n                for (pugi::xml_node lane = leftLanes.child(\"lane\"); lane; lane = lane.next_sibling(\"lane\")) {\n                    ParseLanes(lane, map_builder);\n                }\n            }\n\n            pugi::xml_node centerLanes = laneSectionNode.child(\"center\");\n            if (centerLanes) {\n                for (pugi::xml_node lane = centerLanes.child(\"lane\"); lane; lane = lane.next_sibling(\"lane\")) {\n                    ParseLanes(lane, map_builder);\n                }\n            }\n\n            pugi::xml_node rightLanes = laneSectionNode.child(\"right\");\n            if (rightLanes) {\n                for (pugi::xml_node lane = rightLanes.child(\"lane\"); lane; lane = lane.next_sibling(\"lane\")) {\n                    ParseLanes(lane, map_builder);\n                }\n            }\n        }\n    }\n}\n\nvoid LaneParser::ParseLanes(const pugi::xml_node &lane_node, carla::road::MapBuilder &map_builder) {\n    // Assuming some attributes or child nodes to parse...\n    std::string lane_id = lane_node.attribute(\"id\").value();\n\n    // Process each lane node and update map_builder accordingly\n    // The exact method to update map_builder would depend on the methods available in MapBuilder\n    // Assume addLane(lane_id, properties) is such a method\n    map_builder.addLane(lane_id, {/* properties extracted from lane_node */});\n}", "CodeBleu_score": 56.51815711711225}, {"code": "void LaneParser::Parse(const pugi::xml_document &xml, carla::road::MapBuilder &map_builder) {\n    // Access the root node of the XML document\n    pugi::xml_node root = xml.child(\"OpenDRIVE\");\n\n    // Iterate through each \"road\" node within the root\n    for (pugi::xml_node road_node = root.child(\"road\"); road_node; road_node = road_node.next_sibling(\"road\")) {\n        // Retrieve the road ID from the road node\n        int road_id = road_node.attribute(\"id\").as_int();\n\n        // Iterate through each \"lanes\" node within the road node\n        for (pugi::xml_node lanes_node = road_node.child(\"lanes\"); lanes_node; lanes_node = lanes_node.next_sibling(\"lanes\")) {\n            // Parse each \"laneSection\" node\n            for (pugi::xml_node lane_section_node = lanes_node.child(\"laneSection\"); lane_section_node; lane_section_node = lane_section_node.next_sibling(\"laneSection\")) {\n                // Retrieve left, center, and right lane nodes from the lane section\n                pugi::xml_node left_lanes = lane_section_node.child(\"left\");\n                pugi::xml_node center_lanes = lane_section_node.child(\"center\");\n                pugi::xml_node right_lanes = lane_section_node.child(\"right\");\n\n                // Use handles to parse each lane configuration\n                if (left_lanes) {\n                    ParseLanes(left_lanes, road_id, map_builder);\n                }\n                if (center_lanes) {\n                    ParseLanes(center_lanes, road_id, map_builder);\n                }\n                if (right_lanes) {\n                    ParseLanes(right_lanes, road_id, map_builder);\n                }\n            }\n        }\n    }\n}\n\nvoid LaneParser::ParseLanes(const pugi::xml_node &lanes_node, int road_id, carla::road::MapBuilder &map_builder) {\n    // Iterate through each lane node within lanes_node\n    for (pugi::xml_node lane_node = lanes_node.child(\"lane\"); lane_node; lane_node = lane_node.next_sibling(\"lane\")) {\n        // Extract lane properties like id, type, level, etc.\n        int lane_id = lane_node.attribute(\"id\").as_int();\n        std::string lane_type = lane_node.attribute(\"type\").value();\n        bool lane_level = lane_node.attribute(\"level\").as_bool();\n\n        // Construct a Lane object\n        carla::road::Lane lane(lane_id, lane_type, lane_level);\n\n        // Add or update the lane in the map builder\n        map_builder.AddLane(road_id, lane);\n    }\n}", "CodeBleu_score": 61.10712969529097}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "#include <iostream>\n\nclass CarlaListenerImpl {\npublic:\n    // Member variables to manage state\n    int matched_count;\n    bool first_connection_made;\n\n    // Constructor\n    CarlaListenerImpl() : matched_count(0), first_connection_made(false) {}\n\n    // The signature of the function from the docstring\n    void on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info);\n};\n\nvoid CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info) {\n    // Check if the new number of matches is greater than the current count\n    if (info.current_count > matched_count) {\n        // New match detected\n        matched_count = info.current_count;  // Update matched count\n        if (!first_connection_made) {\n            first_connection_made = true;  // Mark first connection\n            std::cout << \"New connection made for the first time.\\n\";\n        }\n\n        std::cout << \"New match detected. Current Count: \" << matched_count << \"\\n\";\n    } else if (info.current_count < matched_count) {\n        // Match was lost\n        matched_count = info.current_count;  // Update matched count\n        std::cout << \"Match lost. Current Count: \" << matched_count << \"\\n\";\n    } else if (info.current_count == matched_count) {\n        // Normal case without change, do nothing\n    } else {\n        // This condition shouldn't typically happen, log an error\n        std::cerr << \"Invalid change in matched count detected!\\n\";\n    }\n}", "CodeBleu_score": 37.66734625669056}, {"code": "#include <iostream>\n\n// Assuming that CarlaListenerImpl class is defined as part of a larger system and relevant headers are included\n\nclass CarlaListenerImpl {\npublic:\n    // Data members of CarlaListenerImpl\n    int matched_count = 0;\n    bool first_connection = false;\n\n    // Function declaration\n    void on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info);\n\n    // A utility method for logging errors\n    void log_error(const std::string& message) const {\n        std::cerr << \"Error: \" << message << std::endl;\n    }\n};\n\nvoid CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info) {\n    // Check the validity of the status change\n    if(info.current_count_change == 0) {\n        this->log_error(\"Invalid count change\");\n        return;\n    }\n\n    // Update the matched count\n    this->matched_count = info.current_count;\n\n    // Determine if a new match has been made or lost based on the count change\n    if(info.current_count_change > 0) {\n        // A new match has been detected\n\n        // If it is the first connection ever\n        if (!this->first_connection) {\n            this->first_connection = true;\n            std::cout << \"A new connection has been established for the first time.\" << std::endl;\n        }\n\n        std::cout << \"New publication match detected. Total matches: \" << this->matched_count << std::endl;\n    } else if(info.current_count_change < 0) {\n        // A match has been lost\n        std::cout << \"Publication match lost. Total matches: \" << this->matched_count << std::endl;\n    }\n}\n\n// Assume main or other usage context to create instances and use the method\nint main() {\n    CarlaListenerImpl listener;\n    efd::PublicationMatchedStatus info{3, 1, 4};  // Example status data\n    efd::DataWriter* writer = nullptr;  // Assume this is managed properly elsewhere\n\n    listener.on_publication_matched(writer, info);\n    return 0;\n}", "CodeBleu_score": 40.605852735408995}, {"code": "#include <iostream>\n\nnamespace efd {\n    class DataWriter {\n        // Placeholder for the DataWriter class\n    };\n\n    struct PublicationMatchedStatus {\n        int current_count;\n        int total_count;\n        // Assuming other necessary fields exist here, adjust accordingly\n    };\n}\n\nclass CarlaListenerImpl {\npublic:\n    CarlaListenerImpl() : first_connection_made(false), matched_count(0) {}\n\n    void on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info) {\n        if (info.current_count > matched_count) {\n            // A new match has been detected\n            matched_count = info.current_count;\n\n            if (!first_connection_made) {\n                first_connection_made = true;\n                std::cout << \"First connection established.\" << std::endl;\n            }\n\n            std::cout << \"New publisher matched. Total matches: \" << matched_count << std::endl;\n        } else if (info.current_count < matched_count) {\n            // A match has been lost\n            matched_count = info.current_count;\n            std::cout << \"Publisher match lost. Total remaining matches: \" << matched_count << std::endl;\n        } else {\n            // No change in count, or invalid count change\n            std::cout << \"Error: Invalid change in publication matched count detected.\" << std::endl;\n        }\n    }\n\nprivate:\n    bool first_connection_made;\n    int matched_count;\n};\n\nint main() {\n    // Example usage\n    CarlaListenerImpl listener;\n    efd::PublicationMatchedStatus status{3, 5}; // Assume this is obtained from somewhere\n\n    listener.on_publication_matched(nullptr, status); // nullptr is used just for demonstration\n    return 0;\n}", "CodeBleu_score": 34.98398985992125}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info) {\n    // Check if the change count is valid\n    if (info.current_count_change <= 0) {\n        // Log the error if the change count is invalid\n        std::cerr << \"Error: Invalid current_count_change in on_subscription_matched: \" << info.current_count_change << std::endl;\n        return;\n    }\n\n    // Update the matched count\n    matched_count_ += info.current_count_change;\n\n    if (info.current_count_change > 0) {\n        // A new subscription has been matched\n        if (!first_connected_) {\n            first_connected_ = true;\n            std::cout << \"First subscriber connected.\" << std::endl;\n        }\n    } else {\n        // A subscription has been unmatched\n        if (matched_count_ <= 0) {\n            // No more matched subscriptions, destroy the subscriber\n            reader->destroy();\n            std::cout << \"No more subscriptions matched. Subscriber destroyed.\" << std::endl;\n        }\n    }\n\n    std::cout << \"Current number of subscriptions matched: \" << matched_count_ << std::endl;\n}", "CodeBleu_score": 46.59077908445925}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info) {\n    // Check for a valid change in the match count\n    if (info.current_count_change == 0) {\n        std::cerr << \"Received invalid count change of zero.\" << std::endl;\n        return;\n    }\n\n    // Update matched count based on current count change\n    matched_count_ = info.current_count;\n\n    if (info.current_count_change > 0) {\n        // If this is the first connection\n        if (!first_connected_) {\n            first_connected_ = true;\n            std::cout << \"First subscriber connected.\" << std::endl;\n            // Perform any additional setup or notifications necessary upon first connection\n        }\n\n        std::cout << \"New subscription matched. Total subscriptions: \" << matched_count_ << std::endl;\n    } else {\n        std::cout << \"Subscription unmatched. Total subscriptions: \" << matched_count_ << std::endl;\n\n        // If no more subscribers are connected, perform cleanup\n        if (matched_count_ == 0) {\n            std::cout << \"No remaining subscriptions. Cleaning up...\" << std::endl;\n            delete this; // or other clean-up logic as needed\n        }\n    }\n}", "CodeBleu_score": 48.73138102269286}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info) {\n    if (!reader) {\n        std::cerr << \"DataReader pointer is null\" << std::endl;\n        return;\n    }\n\n    // Check the change in the count of current subscriptions\n    if (info.current_count_change > 0) {\n        // A new match has occurred\n        matched_count_ += info.current_count_change;\n        first_connected_ = true;\n        std::cout << \"New subscription matched. Current matched count: \" << matched_count_ << std::endl;\n    } else if (info.current_count_change < 0) {\n        // A match was lost/unmatched\n        matched_count_ += info.current_count_change;\n        std::cout << \"Subscription unmatched. Current matched count: \" << matched_count_ << std::endl;\n\n        // If there are no more matched subscriptions, we might consider cleaning up\n        if (matched_count_ <= 0) {\n            matched_count_ = 0; // Ensure the matched count doesn't drop below 0\n            first_connected_ = false;\n            std::cout << \"No more subscriptions matched. Possible clean up or destruction of the subscriber.\" << std::endl;\n            // Assuming there's a mechanism to destroy or deactivate the subscriber, call it here\n            // destroy_subscriber();\n        }\n    } else {\n        // No change in subscription match count or invalid change count\n        std::cerr << \"Invalid subscription match count change: \" << info.current_count_change << std::endl;\n    }\n}", "CodeBleu_score": 44.56898525393454}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "#include <cstring>\n#include <iostream>\n#include \"md5.h\"\n\nclass InstanceHandle_t {\npublic:\n    std::string key;\n};\n\nclass CarlaCollisionEvent {\npublic:\n    std::string getKey() const {\n        // Simulation of the key retrieval for a CarlaCollisionEvent\n        return \"collision_event_key\";\n    }\n};\n\nclass CarlaCollisionEventPubSubType {\npublic:\n    bool getKey(void* data, InstanceHandle_t* handle, bool force_md5) {\n        if (data == nullptr || handle == nullptr) {\n            std::cerr << \"Data or handle is null, cannot retrieve key.\" << std::endl;\n            return false;\n        }\n\n        CarlaCollisionEvent* event = static_cast<CarlaCollisionEvent*>(data);\n        std::string key = event->getKey();\n\n        if (key.empty()) {\n            std::cerr << \"Key retrieval is undefined (key is empty).\" << std::endl;\n            return false;\n        }\n\n        if (force_md5) {\n            // Serialize key and compute MD5 hash\n            MD5 md5;\n            md5.update(reinterpret_cast<const unsigned char*>(key.c_str()), key.length());\n            md5.finalize();\n            handle->key = md5.hexdigest();\n        } else {\n            // Direct copy of the key\n            handle->key = key;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    CarlaCollisionEvent event;\n    InstanceHandle_t handle;\n    CarlaCollisionEventPubSubType pubSubType;\n\n    bool success = pubSubType.getKey(&event, &handle, true);\n    if (success) {\n        std::cout << \"Key retrieved successfully: \" << handle.key << std::endl;\n    } else {\n        std::cout << \"Failed to retrieve the key.\" << std::endl;\n    }\n\n    return 0;\n}", "CodeBleu_score": 41.33521018428659}, {"code": "#include <cstring> // for memcmp, memcpy\n#include <iostream> // for debugging, if needed\n\nbool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5) {\n    // Check if data is valid\n    if (data == nullptr) {\n        std::cerr << \"Null data provided to getKey\" << std::endl;\n        return false;\n    }\n\n    CarlaCollisionEvent* eventData = static_cast<CarlaCollisionEvent*>(data);\n\n    // Check if this type has an implementation of getting a key \n    if (!eventData->hasKey()) {\n        std::cerr << \"Key retrieval not implemented for this event type\" << std::endl;\n        return false;\n    }\n\n    // Serialize key - assuming we have a method to get a serialized key from CarlaCollisionEvent\n    std::string keyString = eventData->serializeKey();\n    \n    if (keyString.empty()) {\n        std::cerr << \"Failed to serialize the key\" << std::endl;\n        return false;\n    }\n\n    if (force_md5 || keyString.length() > 16) {\n        // If we need an MD5 due to key length or forced MD5 requirement\n        unsigned char md5Hash[16];\n        MD5(reinterpret_cast<const unsigned char*>(keyString.data()), keyString.length(), md5Hash); // Assuming MD5 function is available\n        \n        // For MD5, we use only the first 16 bytes as key\n        memcpy(handle->value, md5Hash, 16);\n    } else {\n        // Directly use the key string if it is short enough and no MD5 requested\n        memcpy(handle->value, keyString.data(), keyString.length());\n        // Make sure to clear remaining bytes\n        memset(handle->value + keyString.length(), 0, 16 - keyString.length());\n    }\n    \n    return true;\n}", "CodeBleu_score": 43.18418117333792}, {"code": "#include <cstring>   // for memcpy\n#include <md5.h>     // assuming an implementation of MD5 is available\n\nbool CarlaCollisionEventPubSubType::getKey(void* data, InstanceHandle_t* handle, bool force_md5) {\n    // Check if the 'data' pointer is valid\n    if (!data) {\n        return false;\n    }\n\n    // Assuming CarlaCollisionEvent has a method to serialize the key\n    std::string key;\n    if (!serializeKey(data, key)) {\n        return false;\n    }\n\n    // Clear the handle\n    memset(handle->value, 0, 16); // Assuming InstanceHandle_t::value is an array of 16 bytes\n\n    if (force_md5 || key.length() > 16) {\n        // Compute MD5 hash of the key because it's too long or forced by the user\n        unsigned char digest[16];\n        MD5((unsigned char *)key.c_str(), key.length(), digest); // Assuming MD5 function signature\n        memcpy(handle->value, digest, 16);\n    } else {\n        // If the key is 16 bytes or shorter and MD5 is not forced\n        memcpy(handle->value, key.c_str(), std::min(size_t(16), key.size()));\n    }\n\n    return true;\n}\n\n// Helper function to serialize the key from the data parameter\nbool CarlaCollisionEventPubSubType::serializeKey(void* data, std::string &outKey) {\n    // Assuming CarlaCollisionEvent has an attribute or a way to determine the key\n    CarlaCollisionEvent* event = static_cast<CarlaCollisionEvent*>(data);\n    if (!event) {\n        return false;\n    }\n    \n    // Performing hypothetical serialization based on attributes of CarlaCollisionEvent\n    outKey = std::to_string(event->getId()); // Hypothetically getId() returns a unique identifier for the collision event\n    return true;\n}", "CodeBleu_score": 43.74867968736357}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(void* data, SerializedPayload_t* payload) {\n    // Cast data to CarlaEgoVehicleControl type\n    CarlaEgoVehicleControl* vehicleControl = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Initialize payload using the serialized length\n    payload->max_size = this->getSerializedSize(vehicleControl);\n    payload->data = reinterpret_cast<octet*>(calloc(payload->max_size, sizeof(octet)));\n\n    if (payload->data == nullptr) {\n        return false;\n    }\n\n    // Create a Cdr object for serialization (use eprosima::fastcdr)\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN, eprosima::fastcdr::Cdr::DDS_CDR);\n\n    // Set data representation and endianness\n    // Assuming system is little-endian; if it's not, you'll need to adjust this accordingly.\n    ser.changeEndianness(eprosima::fastcdr::Cdr::LITTLE_ENDIANNESS);\n\n    try {\n        // Serialize the CarlaEgoVehicleControl object\n        ser << *vehicleControl;\n\n        // Update the payload length with the serialized data length\n        payload->length = ser.getSerializedDataLength();\n        \n        // Mark the payload as valid\n        payload->encapsulation = ser.endianness() | CDR_ENCAPSULATION;\n        \n    } catch(std::exception& e) {\n        // Handle exceptions, such as serialization errors\n        free(payload->data);\n        payload->data = nullptr;\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 58.88523230038327}, {"code": "#include <fastcdr/FastBuffer.h>\n#include <fastcdr/Cdr.h>\n\nclass CarlaEgoVehicleControlPubSubType {\npublic:\n    bool serialize(void* data, SerializedPayload_t* payload) {\n        // Assume that data is a pointer to CarlaEgoVehicleControl\n        CarlaEgoVehicleControl* control = static_cast<CarlaEgoVehicleControl*>(data);\n        \n        try {\n            // Create a FastBuffer that wraps around the payload's data pointer with an initial capacity\n            eprosima::fastcdr::FastBuffer buffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n            \n            // Initialize Cdr serialization object\n            eprosima::fastcdr::Cdr ser(buffer);\n            \n            // Set the data encoding encapsulation (choose based on system endianness)\n            ser.encapsulation(eprosima::fastcdr::Cdr::DEFAULT_ENDIAN);\n\n            // Serialize the CarlaEgoVehicleControl object\n            ser << *control;\n\n            // If successful, update the length of the serialized data\n            payload->length = ser.getSerializedDataLength();\n\n            return true;\n        } catch(const std::bad_alloc& e) {\n            // Handle memory allocation failure\n            // Possible logging or other error management\n            return false;\n        } catch(const std::exception& ex) {\n            // Handle other exceptions\n            return false;\n        }\n    }\n};\n\n// You would also need a definition for `CarlaEgoVehicleControl` and `SerializedPayload_t`\nstruct SerializedPayload_t {\n    char* data;\n    uint32_t length;\n    uint32_t max_size;\n};\n\nclass CarlaEgoVehicleControl {\n    // Members of CarlaEgoVehicleControl\n};", "CodeBleu_score": 46.89229225668451}, {"code": "#include \"CarlaEgoVehicleControlPubSubType.h\"\n#include \"fastcdr/FastBuffer.h\"\n#include \"fastcdr/Cdr.h\"\n\nbool CarlaEgoVehicleControlPubSubType::serialize(void* data, SerializedPayload_t* payload) {\n    // Ensure data and payload are not null\n    if (data == nullptr || payload == nullptr) {\n        return false;\n    }\n\n    // Cast data to CarlaEgoVehicleControl\n    CarlaEgoVehicleControl* vehicleControl = static_cast<CarlaEgoVehicleControl*>(data);\n\n    try {\n        // Initialize FastBuffer\n        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n\n        // Initialize CDR serializer with the fast buffer\n        eprosima::fastcdr::Cdr cdr_ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n                                       eprosima::fastcdr::Cdr::DDS_CDR_ENCAPSULATION);\n\n        // Serialize the object\n        cdr_ser << *vehicleControl;\n\n        // Update payload length\n        payload->length = cdr_ser.getSerializedDataLength();\n\n        return true;\n    } catch (std::exception& e) {\n        // Log the exception - Normally you would use logging functionality\n        std::cerr << \"Serialization failed: \" << e.what() << std::endl;\n        return false;\n    }\n}", "CodeBleu_score": 54.025090049396205}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg) {\n    // Check if the target is already set, exit if true\n    if (target_set) {\n        return;\n    }\n\n    // Check if the message type is among those that should be tracked\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n        case MAVLINK_MSG_ID_GPS_RAW_INT:\n        case MAVLINK_MSG_ID_ADSB_VEHICLE:\n            break;  // These message types are relevant to tracking\n        default:\n            return;  // If not a relevant message, immediately exit\n    }\n\n    // Check if the target system ID is not set, and then set it\n    if (target_sysid == 0) {\n        target_sysid = msg.sysid;  // Set the target system ID based on the incoming message\n\n        // Request position and air pressure data streams from the newly set target\n        request_data_stream(target_sysid, MAV_DATA_STREAM_POSITION, REQUEST_RATE_HZ);\n        request_data_stream(target_sysid, MAV_DATA_STREAM_EXTRA2, REQUEST_RATE_HZ);\n    }\n\n    // Flag that the target has been set\n    target_set = true;\n}\n\n// This is just a placeholder function definition\nvoid GCS_MAVLINK_Tracker::request_data_stream(uint8_t sysid, uint8_t stream_id, uint16_t rate_hz) {\n    // Send requests for data streams here\n    // This would likely involve creating and sending a MAVLink message of type MAVLINK_MSG_ID_REQUEST_DATA_STREAM\n}\n\n/**\n * Additional notes:\n * - `target_set` is assumed to be a boolean member variable indicating if the target is set.\n * - `target_sysid` is assumed to be an integer member variable that stores the target system ID.\n * - `REQUEST_RATE_HZ` is assumed to be an appropriate rate at which the data streams are requested.\n */", "CodeBleu_score": 31.931058431748315}, {"code": "#include <iostream>\n\n// Assuming the existence of a MAVLink message library and certain parameters defined elsewhere in your project\n// We'll mimic a simplified version of MAVLink message handling\n\n// Mock MAVLink message struct for illustration\nstruct mavlink_message_t {\n    uint8_t msgid;\n    uint8_t sysid;\n};\n\n// Assuming these ID constants are defined elsewhere in your environment\nconst uint8_t MAVLINK_MSG_ID_TARGET_SET = 1; // Example message ID for \"Set Target\"\n\nclass GCS_MAVLINK_Tracker {\nprivate:\n    bool is_target_set;\n    uint8_t target_sysid;\n\npublic:\n    GCS_MAVLINK_Tracker() : is_target_set(false), target_sysid(0) {}\n\n    // Function to request data streams from the target\n    void request_data_streams(uint8_t sysid) {\n        // Request position and air pressure data streams implementation goes here\n        std::cout << \"Requesting data streams from System ID: \" << int(sysid) << std::endl;\n    }\n\n    // Check if the target has been set for tracking using MAVLink messages\n    void mavlink_check_target(const mavlink_message_t &msg) {\n        // Check if the target is already set\n        if (is_target_set) {\n            std::cout << \"Target is already set. Exiting function.\" << std::endl;\n            return;\n        }\n\n        // Decode the MAVLink message and exit if the message type is not one that should be tracked\n        if (msg.msgid != MAVLINK_MSG_ID_TARGET_SET) {\n            std::cout << \"Received non-target set message. Ignoring.\" << std::endl;\n            return;\n        }\n\n        // If the target system ID is not set, we set the sysid to the target\n        if (target_sysid == 0) {\n            target_sysid = msg.sysid; // Set target system ID\n            request_data_streams(target_sysid); // Request necessary data streams\n        }\n\n        // Flag that the target has been set\n        is_target_set = true;\n        std::cout << \"Target has been successfully set to System ID: \" << int(target_sysid) << std::endl;\n    }\n};\n\nint main() {\n    GCS_MAVLINK_Tracker tracker;\n    mavlink_message_t msg = {MAVLINK_MSG_ID_TARGET_SET, 42}; // Example message\n    tracker.mavlink_check_target(msg);\n\n    // Subsequent call with another message to test if the target setting is persistent\n    mavlink_message_t another_msg = {MAVLINK_MSG_ID_TARGET_SET, 43};\n    tracker.mavlink_check_target(another_msg);\n\n    return 0;\n}", "CodeBleu_score": 29.14846399904121}, {"code": "#include <iostream>\n\nclass GCS_MAVLINK_Tracker {\n    bool target_set;       // Indicates if a target has been set for tracking\n    int target_sysid;      // MAVLink system ID of the target\npublic:\n    GCS_MAVLINK_Tracker() : target_set(false), target_sysid(0) {}\n\n    // Checks if the target has been set for tracking using MAVLink messages\n    void mavlink_check_target(const mavlink_message_t &msg) {\n        // If the target is already set, exit immediately\n        if (target_set) {\n            return;\n        }\n\n        // Decode the MAVLink message and check message type\n        switch (msg.msgid) {\n            case MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT:\n                // Handle position target. For example:\n                break;\n            case MAVLINK_MSG_ID_HIGHRES_IMU:\n                // Handle air pressure from the IMU\n                break;\n            default:\n                // Exit if message type is not one that should be tracked\n                return;\n        }\n        \n        // If the target system ID is not set, set it now\n        if (target_sysid == 0) {\n             target_sysid = msg.sysid;\n             // Request data streams for position & air pressure from the target\n             // You would normally call something to request these streams.\n             // For example: request_data_stream(target_sysid);\n        }\n\n        // Flag that the target has been set\n        target_set = true;\n    }\n\n    // Dummy function to represent request for the target to send specific data streams\n    void request_data_stream(int sysid) {\n        std::cout << \"Requesting data stream from target \" << sysid << std::endl;\n    }\n};\n\n// Dummy structure to simulate the mavlink_message_t for this example\nstruct mavlink_message_t {\n    int msgid;\n    int sysid;\n};\n\n// Definitions for message IDs. These would typically be defined in a MAVLink library.\nconst int MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT = 1;\nconst int MAVLINK_MSG_ID_HIGHRES_IMU = 2;\n\nint main() {\n    GCS_MAVLINK_Tracker tracker;\n    mavlink_message_t msg1 = {MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT, 123};\n    mavlink_message_t msg2 = {MAVLINK_MSG_ID_HIGHRES_IMU, 123};\n\n    tracker.mavlink_check_target(msg1);\n    tracker.mavlink_check_target(msg2);\n\n    return 0;\n}", "CodeBleu_score": 27.191601855982263}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "// Let's assume MAV_RESULT is an enum with at least these values\nenum MAV_RESULT {\n    MAV_RESULT_ACCEPTED,\n    MAV_RESULT_FAILED\n};\n\n// Assumed function for handling the command at the base class level\nMAV_RESULT GCS_MAVLINK::handle_preflight_calibration(const mavlink_message_t &msg) {\n    // Imagine this function somehow processes the message and determines if the calibration was successful\n    return MAV_RESULT_ACCEPTED;  // For demonstration; in reality, the logic might be more complex\n}\n\nclass GCS_MAVLINK_Tracker : public GCS_MAVLINK {\npublic:\n    bool altitude_calibration_needed = false;  // Class member to track if calibration is needed\n\n    MAV_RESULT _handle_command_preflight_calibration_baro(const mavlink_message_t &msg) {\n        // Call the base class handler\n        MAV_RESULT result = handle_preflight_calibration(msg);\n\n        // Check the result and set the flag if accepted\n        if (result == MAV_RESULT_ACCEPTED) {\n            altitude_calibration_needed = true;\n        }\n\n        // Return the result from the base class handler\n        return result;\n    }\n};\n\n// Usage example:\n// Assuming `msg` is defined and correctly initialized elsewhere\nmavlink_message_t msg;\nGCS_MAVLINK_Tracker tracker;\nMAV_RESULT res = tracker._handle_command_preflight_calibration_baro(msg);", "CodeBleu_score": 50.385454759524116}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg) {\n    // Call the base class handler\n    MAV_RESULT result = GCS_MAVLINK_Base::_handle_command_preflight_calibration(msg);\n\n    // Check if the base class accepted the calibration command\n    if (result == MAV_RESULT_ACCEPTED) {\n        // Set flag to indicate altitude calibration is needed\n        need_altitude_calibration = true;\n\n        // Additional implementation specific to barometer calibration can be handled here if necessary\n        // ... (additional code could be here, if needed) ...\n    }\n\n    // Return the result from the base class handler\n    return result;\n}", "CodeBleu_score": 56.91296575831526}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg) {\n    // Call the base class handler\n    MAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration(msg);\n\n    // Check the result of the base class handler\n    if (result == MAV_RESULT_ACCEPTED) {\n        // Set calibration needed flag\n        alt_calibration_needed = true;\n    }\n\n    // Return the result\n    return result;\n}", "CodeBleu_score": 55.579948955902395}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet) {\n    // Extract the arm/disarm parameter from the packet\n    float param1 = packet.param1;\n\n    // Check the parameter value to determine if the action is to arm or disarm\n    if (param1 == 1.0) {\n        // Arm the servos\n        armServos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (param1 == 0.0) {\n        // Disarm the servos\n        disarmServos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        // The command is unsupported for parameter values other than 0 or 1\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}\n\n// Mock-up implementation for arming servos\nvoid GCS_MAVLINK_Tracker::armServos() {\n    // Implement actual servo arming logic here\n    // For example: set servo control register to enable state, send confirmation telemetry, etc.\n    // ...\n}\n\n// Mock-up implementation for disarming servos\nvoid GCS_MAVLINK_Tracker::disarmServos() {\n    // Implement actual servo disarming logic here\n    // For example: set servo control register to disable state, send confirmation telemetry, etc.\n    // ...\n}", "CodeBleu_score": 51.36874174369584}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet) {\n    // Extract the parameter from the command packet.\n    // For simplicity, assume the parameter for arming/disarming is stored in param1 (usually where command parameters are stored).\n    float command_param = packet.param1;\n\n    if (command_param == 1.0) {\n        // Arm the servos\n        arm_servos();  \n        return MAV_RESULT_ACCEPTED;\n    } else if (command_param == 0.0) {\n        // Disarm the servos\n        disarm_servos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        // Parameter value is not supported\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}\n\n// Note: You'll need to define or implement the arm_servos() and disarm_servos() functions.\n// These are likely to interact with specific hardware interfaces or libraries used to control servos,\n// just stubbing with simple informational prints for illustration.\n\nvoid GCS_MAVLINK_Tracker::arm_servos() {\n    // Implement servo arming logic here.\n    std::cout << \"Servos armed.\" << std::endl;\n}\n\nvoid GCS_MAVLINK_Tracker::disarm_servos() {\n    // Implement servo disarming logic here.\n    std::cout << \"Servos disarmed.\" << std::endl;\n}", "CodeBleu_score": 47.8233807909405}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet) {\n    // Extract command parameter from the packet\n    float command_param = packet.param1;\n\n    // Check command parameter to arm/disarm servos\n    if (command_param == 1.0) {\n        // Arm the servos\n        // Assuming there's an `armServos` method to set servo state\n        this->armServos();\n        return MAV_RESULT_ACCEPTED;\n    } else if (command_param == 0.0) {\n        // Disarm the servos\n        // Assuming there's a `disarmServos` method to set servo state\n        this->disarmServos();\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        // The command parameter is not recognized\n        return MAV_RESULT_UNSUPPORTED;\n    }\n}", "CodeBleu_score": 53.325830602449976}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "#include <iostream>\n\nclass GCS_Tracker {\nprivate:\n    struct GCS_Channel {\n        bool has_available_payload_space() const;\n        void send_datastream_request(uint8_t sysid, uint8_t compid, uint8_t stream_type, uint16_t frequency);\n    };\n\n    std::vector<GCS_Channel> channels;\n\npublic:\n    // Adds channels to the tracker, this method needs to be called to populate the channels vector\n    void add_channel(const GCS_Channel& channel) {\n        channels.push_back(channel);\n    }\n\n    // Requests to start streaming position data for a specified system and component ID\n    void request_datastream_position(uint8_t sysid, uint8_t compid) {\n        const uint8_t POSITION_STREAM_TYPE = 0x02;  // assumed message type ID for position data stream\n        const uint16_t UPDATE_RATE_HZ = 10;         // assumed update rate for streaming\n\n        for (auto& channel : channels) {\n            if (channel.has_available_payload_space()) {\n                channel.send_datastream_request(sysid, compid, POSITION_STREAM_TYPE, UPDATE_RATE_HZ);\n                std::cout << \"Data stream request sent for system id: \" << (int)sysid << \", component id: \" << (int)compid << std::endl;\n                break; // Break after successful sending to avoid multiple requests\n            }\n        }\n    }\n\n};\n\nint main() {\n    GCS_Tracker tracker;\n    // Sample initializations and function call\n    GCS_Tracker::GCS_Channel channel;\n\n    // Supposing that add_channel and other methods implemented to manage the GCS channels are available\n    tracker.add_channel(channel);\n    tracker.request_datastream_position(1, 1); // Example system id and component id\n\n    return 0;\n}", "CodeBleu_score": 39.453975992673556}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid) {\n    // Define message type and contents for requesting position data stream\n    // Message ID or code usually depends on specific GCS protocol, e.g., MAVLink\n    const int MSG_ID_REQUEST_DATA_STREAM = 66;  // Example message ID for requesting data streams\n    const int POSITION_DATA_STREAM = 3;         // Typically, IDs for specific data streams can vary\n    const int START = 1;                        // commonly used to start the data stream\n    const int REQ_RATE = 2;                     // example rate/speed of data updates per sec\n\n    // Iterate through all available GCS communication channels\n    for (int i = 0; i < num_channels; ++i) {\n        // Check available payload size to fit our request message\n        if (channels[i].available_payload_size() >= sizeof(MSG_ID_REQUEST_DATA_STREAM)) {\n            // Construct an appropriate message/request packet to send\n            // For simplicity, we assume a function like send_message exists and takes:\n            // channel id, message id, target system id, target component id, data stream id, start/stop flag, request rate\n            channels[i].send_message(MSG_ID_REQUEST_DATA_STREAM, sysid, compid, POSITION_DATA_STREAM, START, REQ_RATE);\n\n            // after sending message, we may log or break depending on the protocol\n            // Uncomment next line to break after first successful send\n            // break;\n        }\n    }\n}", "CodeBleu_score": 41.112813563142346}, {"code": "#include <iostream>\n#include <vector>\n#include <array>\n\nclass GCS_Channel {\npublic:\n    bool has_space() const {\n        // Return true if there's enough space to add more data\n        return true;\n    }\n\n    void send_request(uint8_t sysid, uint8_t compid, int data_stream_type, float rate_hz) {\n        // Implement sending a request with parameters to the GCS\n        std::cout << \"Request sent for sysid: \" << int(sysid) \n                  << \", compid: \" << int(compid) \n                  << \" at rate \" << rate_hz << \"Hz\"\n                  << \" on data stream type \" << data_stream_type << std::endl;\n    }\n};\n\nclass GCS_Tracker {\nprivate:\n    std::array<GCS_Channel, 5> channels;  // an array of channels for example\n\npublic:\n    void request_datastream_position(const uint8_t sysid, const uint8_t compid) {\n        const int position_data_stream_type = 1;  // assuming a type-id for position data streams\n        const float position_update_rate = 10.0;  // frequency in Hz at which position updates are required\n\n        for (GCS_Channel& channel : channels) {\n            if (channel.has_space()) {\n                channel.send_request(sysid, compid, position_data_stream_type, position_update_rate);\n                break;  // Assuming we only want to send the request on the first channel that has space\n            }\n        }\n    }\n};\n\nint main() {\n    GCS_Tracker tracker;\n    tracker.request_datastream_position(1, 1);  // Example usage with dummy system ID and component ID\n\n    return 0;\n}", "CodeBleu_score": 32.85159551975686}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw) {\n    // Retrieve the AHRS instance from the vehicle\n    const AP_AHRS &ahrs = AP::ahrs();\n\n    // Compute cosine of the pitch value\n    float pitch_cos = cosf(pitch);\n\n    // Check if pitch_cos is zero to avoid division by zero\n    if (approx_zero(pitch_cos)) {\n        return false; // If pitch cosine is zero, we must return false to indicate failure\n    }\n\n    // Calculate the transformation from body frame to earth frame\n    // Assuming typical body frame to earth frame conversion for an aircraft,\n    // where rotations are small and we can approximate the nonlinear transformation.\n\n    // Roll, pitch, and yaw in the body frame are needed\n    float roll, bf_roll;\n    float bf_yaw = yaw;\n    float bf_pitch = pitch;\n\n    // Retrieve roll from AHRS\n    roll = ahrs.roll;\n\n    // Conversion formulas\n    // Transform body frame angles (pitch, yaw) into earth frame (ef)\n    //\n    // The trigonometric relations consider small angle approximations usually,\n    // or full transformation considering rotation matrices or quaternion approach for conversion.\n    // Here we use a simple conversion for demonstration assuming small angles:\n    ef_pitch = bf_pitch * cosf(roll) + bf_yaw * sinf(roll);\n    ef_yaw   = bf_yaw * cosf(roll) - bf_pitch * sinf(roll);\n    \n    // Alternatively, for non-small angles, you would need to employ a rotation matrix\n    // or other methods, which would involve more complex calculations such as:\n    // Matrix3f R = ahrs.get_rotation_body_to_ned();\n    // Vector3f bf_angles{bf_yaw, bf_pitch, 0}; // Add roll if necessary\n    // Vector3f ef_angles = R * bf_angles;\n    // ef_pitch = atan2f(ef_angles.y, ef_angles.z);\n    // ef_yaw = atan2f(ef_angles.x, sqrtf(ef_angles.y * ef_angles.y + ef_angles.z * ef_angles.z));\n\n    return true; // Successful conversion\n}", "CodeBleu_score": 46.802647997023286}, {"code": "#include <cmath>  // For trigonometric functions\n\nclass AHRS {\npublic:\n    float get_pitch_cosine() const {\n        // Assuming this function returns the cosine of the aircraft's pitch angle.\n        return std::cos(get_pitch_angle());\n    }\n    \n    float get_pitch_angle() const {\n        // Dummy implementation, should be replaced with actual pitch angle acquisition.\n        return 0.0f;\n    }\n    \n    float get_yaw_angle() const {\n        // Dummy implementation, should be replaced with actual yaw angle acquisition.\n        return 0.0f;\n    }\n};\n\nclass Mode {\n    AHRS ahrs;  // AHRS instance within Mode class\n\npublic:\n    bool convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw);\n};\n\nbool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw) {\n    float pitch_cosine = ahrs.get_pitch_cosine();\n    if (fabs(pitch_cosine) < 1e-6) {  // Check for very small values to avoid division by zero\n        return false;\n    }\n\n    // Calculations for converting body frame angles to earth frame\n    // Assuming pitch and yaw provided are in radians\n\n    // Retrieve the current pitch and yaw of the aircraft from AHRS\n    float ahrs_pitch = ahrs.get_pitch_angle();\n    float ahrs_yaw = ahrs.get_yaw_angle();\n\n    // Convert body frame pitch to earth frame pitch\n    ef_pitch = asin(sin(pitch) * pitch_cosine);\n\n    // Convert body frame yaw to earth frame yaw\n    // We need to adjust for the current yaw angle of the aircraft.\n    ef_yaw = yaw + ahrs_yaw;\n\n    return true;\n}", "CodeBleu_score": 41.458199318373026}, {"code": "#include <cmath>  // Include the cmath library for trigonometric calculations\n\nclass AHRS {\npublic:\n    float getRoll() const;      // Get current AHRS roll angle (in radians)\n    float getPitch() const;     // Get current AHRS pitch angle (in radians)\n    float getYaw() const;       // Get current AHRS yaw angle (in radians)\n};\n\nclass Mode {\nprivate:\n    AHRS* ahrs;                // Pointer to an AHRS object\n\npublic:\n    bool convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw);\n\n    // Constructor and other methods\n    Mode(AHRS* ahrsInstance) : ahrs(ahrsInstance) {}\n};\n\nbool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw) {\n    if (!ahrs) return false;   // Check if the AHRS pointer is valid\n\n    // Retrieve the current angles from AHRS\n    float ahrsRoll = ahrs->getRoll();\n    float ahrsPitch = ahrs->getPitch(); \n    float ahrsYaw = ahrs->getYaw();\n\n    // cosPitch to check for division by zero scenario\n    float cosPitch = std::cos(ahrsPitch);\n\n    if (cosPitch == 0) {\n        // If pitch angle is 90 or -90 degrees (Pitch cosine is zero), return false to indicate calculation cannot be done\n        return false;\n    }\n\n    // Convert body frame pitch and yaw to earth frame\n    // For simplicity, assuming body frame pitches and yaws are small angles and additive:\n    ef_pitch = ahrsPitch + pitch;\n    ef_yaw = ahrsYaw + yaw / cosPitch;\n\n    return true; // Return true to indicate successful conversion\n}\n\n// Usage of this function should be with a properly initialized AHRS and Mode object", "CodeBleu_score": 40.77304514381942}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "#include <cmath> // For trigonometric operations\n\nvoid Mode::update_auto(void) {\n    // Check navigation status and parameters\n    if (!navigation.is_ready() || !parameters.valid()) {\n        return; // Early exit if navigation or parameters are not ready\n    }\n    \n    // Define constants for conversion\n    const float deg_to_cdeg = 100.0; // Degrees to centidegrees conversion factor\n\n    // Calculate target yaw and pitch based on navigation data\n    float target_yaw = navigation.get_target_yaw() * deg_to_cdeg; // Convert to centidegree\n    float target_pitch = navigation.get_target_pitch() * deg_to_cdeg; // Convert to centidegree\n    \n    // Check if the direction is reversed\n    if (parameters.is_direction_reversed()) {\n        target_yaw = -target_yaw; // Reverse yaw\n        target_pitch = -target_pitch; // Reverse pitch\n    }\n\n    // Compute angle error\n    float current_yaw = navigation.get_current_yaw() * deg_to_cdeg;\n    float current_pitch = navigation.get_current_pitch() * deg_to_cdeg;\n    float yaw_error = target_yaw - current_yaw;\n    float pitch_error = target_pitch - current_pitch;\n\n    // Convert errors from earth frame to body frame (assuming a function exists to perform this conversion)\n    std::pair<float, float> body_frame_errors = convert_earth_to_body_frame(yaw_error, pitch_error);\n    float body_yaw_error = body_frame_errors.first;\n    float body_pitch_error = body_frame_errors.second;\n\n    // Update the target distance based on navigation\n    float target_distance = navigation.get_target_distance();\n    \n    // Check if the target distance is valid or no minimum distance is set\n    if (target_distance > parameters.get_min_distance() || parameters.get_min_distance() == 0) {\n        // Update pitch and yaw servos\n        servos.set_yaw(body_yaw_error);\n        servos.set_pitch(body_pitch_error);\n    }\n}\n\n// Note: This function, `convert_earth_to_body_frame`, would likely belong to your Mode class or another utility class.\n// It would handle the trigonometric conversion and coordinate transformation appropriate for your application.\nstd::pair<float, float> Mode::convert_earth_to_body_frame(float yaw, float pitch) {\n    float yaw_body = yaw; // Placeholder for actual body frame conversion logic\n    float pitch_body = pitch; // Placeholder for actual body frame conversion logic\n    return std::make_pair(yaw_body, pitch_body);\n}", "CodeBleu_score": 37.14545020264721}, {"code": "void Mode::update_auto(void) {\n    // Assuming there are member variables that hold current pitch, yaw, navigation state, target distance, etc.\n\n    // Calculate target yaw and pitch based on navigation status.\n    int target_yaw_cdeg, target_pitch_cdeg;\n\n    // Convert navigation targets to centidegrees.\n    // This is a placeholder; calculation depends on actual navigation logic.\n    target_yaw_cdeg = static_cast<int>(navigation_target.yaw * 100);\n    target_pitch_cdeg = static_cast<int>(navigation_target.pitch * 100);\n\n    // Check if direction is reversed and adjust accordingly.\n    if(config.direction_reversed) {\n        target_yaw_cdeg = 36000 - target_yaw_cdeg; // Assuming 360 degrees total, wrap around if reversed.\n    }\n\n    // Compute angle error.\n    int yaw_error_cdeg = current_yaw_cdeg - target_yaw_cdeg;\n    int pitch_error_cdeg = current_pitch_cdeg - target_pitch_cdeg;\n\n    // Normalize the yaw error to be within -18000 to 18000 centidegrees.\n    if (yaw_error_cdeg > 18000) yaw_error_cdeg -= 36000;\n    if (yaw_error_cdeg < -18000) yaw_error_cdeg += 36000;\n\n    // Convert errors from earth frame to body frame, assuming we need some transformation based on the vehicle's orientation.\n    int yaw_error_body_frame = transform_to_body_frame(yaw_error_cdeg, current_orientation);\n    int pitch_error_body_frame = transform_to_body_frame(pitch_error_cdeg, current_orientation);\n\n    // Check if the target distance is valid or no minimum distance is set\n    if (target_distance >= config.min_target_distance || config.min_target_distance <= 0) {\n        // Update servos to correct orientation errors\n        set_yaw_servo_to(yaw_error_body_frame);\n        set_pitch_servo_to(pitch_error_body_frame);\n    }\n\n    // Log status or additional actions could be here\n}\n\nint Mode::transform_to_body_frame(int angle_error_cdeg, int orientation) {\n    // Placeholder for real transformation calculation.\n    return angle_error_cdeg; // Just a pass through for this example.\n}\n\nvoid Mode::set_yaw_servo_to(int yaw_error_cdeg) {\n    // Convert centidegrees error to servo command, then apply\n    int yaw_servo_command = calculate_servo_command(yaw_error_cdeg);\n    yaw_servo.write(yaw_servo_command);\n}\n\nvoid Mode::set_pitch_servo_to(int pitch_error_cdeg) {\n    // Convert centidegrees error to servo command, then apply\n    int pitch_servo_command = calculate_servo_command(pitch_error_cdeg);\n    pitch_servo.write(pitch_servo_command);\n}\n\nint Mode::calculate_servo_command(int error_cdeg) {\n    // Placeholder for correct conversion from error to servo command\n    return static_cast<int>(1500 + error_cdeg * 0.1); // Simple proportional control\n}", "CodeBleu_score": 33.36580185098217}, {"code": "void Mode::update_auto(void) {\n    // Fetch the navigation status and parameters. Assuming these are fetched from member variables or other system status\n    NavigationData nav_data = get_navigation_data();\n    \n    // Assuming target positions and current positions are given in centidegrees\n    int target_yaw_cd = nav_data.target_yaw;\n    int target_pitch_cd = nav_data.target_pitch;\n\n    // Get current position. Again, assuming these are member variables or accessible by getters.\n    int current_yaw_cd = get_current_yaw();\n    int current_pitch_cd = get_current_pitch();\n    \n    // Check if control reversal is required \n    if (should_reverse_direction()) {\n        target_yaw_cd = -target_yaw_cd;\n        target_pitch_cd = -target_pitch_cd;\n    }\n\n    // Calculate yaw and pitch errors in centidegrees\n    int yaw_error_cd = target_yaw_cd - current_yaw_cd;\n    int pitch_error_cd = target_pitch_cd - current_pitch_cd;\n    \n    // Convert errors from earth frame to body frame, if required\n    if (convert_error_to_body_frame()) {\n        yaw_error_cd = convert_yaw_to_body_frame(yaw_error_cd);\n        pitch_error_cd = convert_pitch_to_body_frame(pitch_error_cd);\n    }\n\n    // Check if the target distance is valid and there's no minimal distance set, or the distance is above the minimum\n    if (is_target_distance_valid() && (!is_minimum_distance_set() || is_above_minimum_distance())) {\n        // Update pitch and yaw servos with the errors\n        update_servo(YAW_SERVO, yaw_error_cd);\n        update_servo(PITCH_SERVO, pitch_error_cd);\n    }\n}\n\n// Helper functions assumed to exist\nNavigationData Mode::get_navigation_data() {\n    // Implementation assumed\n    NavigationData data;\n    return data;\n}\n\nbool Mode::should_reverse_direction() {\n    // Implementation assumed\n    return false;\n}\n\nint Mode::get_current_yaw() {\n    // Implementation assumed\n    return 0;\n}\n\nint Mode::get_current_pitch() {\n    // Implementation assumed\n    return 0;\n}\n\nbool Mode::convert_error_to_body_frame() {\n    // Implementation assumed\n    return false;\n}\n\nint Mode::convert_yaw_to_body_frame(int yaw) {\n    // Conversion function assumed\n    return yaw;\n}\n\nint Mode::convert_pitch_to_body_frame(int pitch) {\n    // Conversion function assumed\n    return pitch;\n}\n\nbool Mode::is_target_distance_valid() {\n    // Implementation assumed\n    return true;\n}\n\nbool Mode::is_minimum_distance_set() {\n    // Implementation assumed\n    return false;\n}\n\nbool Mode::is_above_minimum_distance() {\n    // Implementation assumed\n    return true;\n}\n\nvoid Mode::update_servo(int servo, int position) {\n    // Servo update method assumed\n}", "CodeBleu_score": 30.65917009701975}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS() {\n    // Update GPS data\n    gps.update();\n\n    // Check the current GPS status and message time\n    if (gps.last_message_time != last_gps_time && gps.status >= GPS_3D_FIX) {\n        last_gps_time = gps.last_message_time;\n\n        // If countdown is active, decrement it\n        if (ground_start_countdown > 0) {\n            --ground_start_countdown;\n\n            // When countdown reaches 1, we consider setting the home location\n            if (ground_start_countdown == 1) {\n                // Check if the current GPS location is valid\n                if (gps.is_location_valid()) {\n                    set_home_location(gps.location);\n                } else {\n                    // Reset countdown since the location is invalid\n                    ground_start_countdown = GROUND_START_COUNTDOWN_INITIAL;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 42.207081196764896}, {"code": "#include <iostream>\n\nclass GPSData {\npublic:\n    bool isValid;\n    double latitude;\n    double longitude;\n};\n\nclass GPSReceiver {\npublic:\n    // Method to get the current GPS Data\n    GPSData getCurrentData() {\n        // For the implementation, we're assuming it returns a GPSData object\n        GPSData data;\n        data.isValid = true; // Simulated valid data\n        data.latitude = 35.6895;\n        data.longitude = 139.6917;\n        return data;\n    }\n    \n    // Method to get the GPS fix status\n    int getStatus() {\n        // Simulating a GPS with 3D fix status\n        return 3;\n    }\n    \n    // Last time the GPS data was updated\n    long lastMessageTime = 1234567890;\n};\n\nclass Tracker {\n    GPSReceiver gps;\n    GPSData homeLocation;\n    bool homeLocationSet = false;\n    int countdown = 5;\n    long lastProcessedTime = 0;\n\npublic:\n    void update_GPS() {\n        GPSData currentData = gps.getCurrentData();\n        int gpsStatus = gps.getStatus();\n        long currentTime = gps.lastMessageTime;\n\n        // Check if there is a new GPS message and if the GPS has at least a 3D fix\n        if (lastProcessedTime != currentTime && gpsStatus >= 3) {\n            // Update the processed time\n            lastProcessedTime = currentTime;\n\n            // Manage the countdown\n            if (countdown > 1) {\n                countdown--;\n            }\n            else if (countdown == 1) {\n                // Validate current location before setting it as home\n                if (currentData.isValid) {\n                    setHomeLocation(currentData);\n                    countdown = 0; // Stop the countdown\n                } else {\n                    // Reset countdown if the location is invalid\n                    countdown = 5;\n                }\n            }\n        }\n    }\n\n    void setHomeLocation(GPSData &location) {\n        homeLocation = location;\n        homeLocationSet = true;\n        std::cout << \"Home location is set to Lat: \" << location.latitude << \", Long: \" << location.longitude << std::endl;\n    }\n};", "CodeBleu_score": 41.476093091495414}, {"code": "void Tracker::update_GPS(void) {\n    // Fetch latest GPS data\n    gps.update();\n\n    // Check for a valid timestamp and that the GPS has at least a 3D fix\n    if (gps.last_message_time() != last_gps_time && gps.status() >= GPS_FIX_3D) {\n        // Valid new data received, update the last time\n        last_gps_time = gps.last_message_time();\n\n        // We are ready to work with the GPS data\n        if (ground_start_countdown > 0) {\n            // Decrease countdown as GPS data is valid\n            --ground_start_countdown;\n\n            // Check if the countdown has reached 1, which is ready to set home location\n            if (ground_start_countdown == 1) {\n                if (gps.is_location_valid()) {\n                    // Set the home location if the current location is valid\n                    home_location = gps.get_location();\n                    std::cout << \"Home location has been set to: \" << home_location << std::endl;\n                } else {\n                    // Countdown reset if current location data is invalid\n                    std::cout << \"Invalid GPS location. Resetting countdown.\" << std::endl;\n                    ground_start_countdown = INITIAL_COUNTDOWN;\n                }\n            }\n        }\n    } else {\n        // In case of GPS fix being less than 3D or repeated timestamp, handle as needed\n    }\n}", "CodeBleu_score": 51.03514142598494}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_GPS() {\n    // Assume that 'gps' is an accessible member of Tracker and it has methods to interact with GPS data\n    // Also, assume that gps_status, is_ready, last_message_timestamp, ground_countdown are members of Tracker\n\n    // Update GPS data\n    gps.update();\n\n    // Check if the last message time has changed and if the GPS status is at least 3D fix\n    if (gps.last_message_time != last_message_timestamp && gps.status >= GPS_3D_FIX) {\n        // Update last processed time to current one\n        last_message_timestamp = gps.last_message_time;\n\n        // Check GPS fix status and update accordingly\n        if (gps.fix) {\n            if (is_ready && ground_countdown > 0) {\n                // Decrement the countdown as GPS is fixed and ready\n                --ground_countdown;\n\n                // If countdown reaches 1, set the home location\n                if (ground_countdown == 1) {\n                    if (set_home_location()) {\n                        Serial.println(\"Home location is set.\");\n                    } else {\n                        Serial.println(\"Failed to set home location.\");\n                    }\n                    ground_countdown = 0; // Reset countdown whether setting home loc succeeds or fails \n                }\n            }\n        } else {\n            // If not fixed, reset the countdown\n            ground_countdown = INIT_COUNTDOWN; // INIT_COUNTDOWN should be defined appropriately\n            Serial.println(\"Resetting countdown due to poor GPS fix.\");\n        }\n    } else if (gps.status < GPS_3D_FIX) {\n        Serial.println(\"Waiting for 3D GPS fix.\");\n    }\n}\n\nbool Tracker::set_home_location() {\n    if (gps.current_location().is_valid()) {\n        // Logic to set the home location, e.g.:\n        home_location = gps.current_location();\n        return true;\n    }\n    return false;\n}", "CodeBleu_score": 27.370113999023204}, {"code": "#include <iostream>\n\nclass Tracker {\nprivate:\n    float latitude;\n    float longitude;\n    bool homeLocationSet;\n    int lastMessageTime;\n    int gpsStatus;  // 0: No FIX, 1: 2D FIX, 2: 3D FIX\n    int countdown;\n\npublic:\n    Tracker() : latitude(0.0), longitude(0.0), homeLocationSet(false), lastMessageTime(0), gpsStatus(0), countdown(5) {}\n\n    void update_GPS(int currentTime, float newLatitude, float newLongitude, int newGpsStatus) {\n        if (currentTime != lastMessageTime && newGpsStatus >= 2) {  // Checking GPS status is at least 3D FIX\n            latitude = newLatitude;\n            longitude = newLongitude;\n            gpsStatus = newGpsStatus;\n            lastMessageTime = currentTime;\n            \n            if (!homeLocationSet && countdown > 1) {\n                countdown--;\n            }\n            \n            if (countdown == 1 && gpsStatus == 2) {  // Assuming '2' denotes 3D FIX\n                setHomeLocation(latitude, longitude);\n                homeLocationSet = true;\n                countdown = 0; // reset countdown\n            } else if (gpsStatus < 2) {\n                resetCountdown();\n            }\n        }\n    }\n\n    void setHomeLocation(float lat, float lon) {\n        latitude = lat;\n        longitude = lon;\n        std::cout << \"Home location set to Latitude: \" << latitude << \", Longitude: \" << longitude << std::endl;\n    }\n\n    void resetCountdown() {\n        countdown = 5; // reset to initial value\n        std::cout << \"Countdown reset due to invalid location.\" << std::endl;\n    }\n};", "CodeBleu_score": 31.026420889817008}, {"code": "#include <iostream>\n\nclass GPSData {\npublic:\n    int status;\n    float latitude;\n    float longitude;\n    float altitude;\n    unsigned long last_message_time;\n    \n    GPSData()\n    : status(0), latitude(0.0f), longitude(0.0f), altitude(0.0f), last_message_time(0) {}\n\n    bool is_valid() const {\n        return status >= 3 && latitude != 0.0f && longitude != 0.0f; \n    }\n};\n\nclass Tracker {\nprivate:\n    GPSData gps_data;\n    int homeset_countdown;\n    float home_latitude;\n    float home_longitude;\n    float home_altitude;\npublic:\n    Tracker()\n    : homeset_countdown(10), home_latitude(0.0f), home_longitude(0.0f), home_altitude(0.0f) {}\n\n    void update_GPS() {\n        // Simulate receiving data\n        simulate_gps_data();\n\n        // Check if new data has been received\n        static unsigned long previous_message_time = 0;\n        if (gps_data.last_message_time != previous_message_time) {\n            if (gps_data.status >= 3) { // Requires 3D fix\n                if (homeset_countdown > 1) {\n                    --homeset_countdown;\n                } else if (homeset_countdown == 1) {\n                    if (gps_data.is_valid()) {\n                        set_home_location();\n                        homeset_countdown = 0; // Home location is set, countdown not needed anymore\n                    } else {\n                        homeset_countdown = 10; // Reset countdown if current location data is invalid\n                    }\n                }\n            }\n            previous_message_time = gps_data.last_message_time;\n        }\n    }\n    \n    void simulate_gps_data() {\n        // Incrementing time and improving status for the purpose of simulation\n        gps_data.last_message_time++;\n        gps_data.status = (gps_data.status < 4) ? gps_data.status + 1 : gps_data.status;\n        gps_data.latitude = 34.0522f; // Random valid coordinates\n        gps_data.longitude = -118.2437f;\n        gps_data.altitude = 305.0f;\n    }\n\n    void set_home_location() {\n        home_latitude = gps_data.latitude;\n        home_longitude = gps_data.longitude;\n        home_altitude = gps_data.altitude;\n        std::cout << \"Home location set to: \" << home_latitude << \", \" << home_longitude << \", \" << home_altitude << std::endl;\n    }\n};\n\nint main() {\n    Tracker my_tracker;\n    for(int i = 0; i < 15; i++) {\n        my_tracker.update_GPS();\n    }\n    return 0;\n}", "CodeBleu_score": 34.76812266467497}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure) {\n    // Call the base class method first\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // Check if barometer checks are enabled\n    if (arming_checks.enabled(ARMING_CHECK_BARO)) {\n        // Retrieve the barometer altitude\n        float baro_altitude = barometer.get_altitude();\n        // Retrieve the inertial navigation altitude\n        float ins_altitude = inertial_nav.get_altitude();\n\n        // Calculate the disparity\n        float disparity = fabs(baro_altitude - ins_altitude);\n\n        // Define the maximum allowed disparity\n        const float MAX_DISPARITY = 1.0f; // Maximum disparity in meters (example value)\n\n        // Check if the disparity exceeds the maximum allowed limit\n        if (disparity > MAX_DISPARITY) {\n            if (display_failure) {\n                GCS_MAVLINK_Interface& gcs = ap_gcs_mavlink::get_instance();\n                gcs.send_text(MAV_SEVERITY_CRITICAL, \"Barometer/INS altitude disparity too large\");\n            }\n            // Log the failure (assuming a method exists for logging)\n            AP_Logger *logger = AP_Logger::get_singleton();\n            if (logger != nullptr) {\n                logger->write(\"ARMING_FAILURE\", \"Reason\", \"Baro/INS altitude disparity too large\");\n            }\n            return false;\n        }\n    }\n\n    // If all checks are ok, return true\n    return true;\n}", "CodeBleu_score": 46.95007283317442}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure) {\n    // First, call the base class barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // Check if barometer checks are enabled in the arming check bitmask\n    if (checks_to_perform & ARMING_CHECK_BARO) {\n        // Get barometer altitude\n        float baro_altitude = baro->get_altitude();\n        \n        // Get inertial navigation altitude\n        float inav_altitude = inertial_nav.get_altitude();\n        \n        // Calculate the disparity between the barometer altitude and INAV altitude\n        float disparity = fabs(baro_altitude - inav_altitude);\n        \n        // Define a threshold for the maximum allowed disparity\n        const float max_allowed_disparity = 1.0; // meters, as an example\n\n        // Check if disparity exceeds the allowed limit\n        if (disparity > max_allowed_disparity) {\n            // Log failure if required\n            if (display_failure) {\n                AP::logger().Write_Error(Log_ErrorSubsystem::ARMING_CHECK, Log_ErrorCode::ARMING_CHECK_FAILED, \"Excessive altitude disparity in barometer checks\");\n            }\n            return false;\n        }\n    }\n\n    // If all checks pass, return true\n    return true;\n}", "CodeBleu_score": 47.283691779427805}, {"code": "#include <iostream>\n\nclass AP_Arming_Copter {\npublic:\n    // Hypothetical base class function to simulate inheritance\n    bool barometer_checks_base() {\n        // Implement base checks, for now, assume it always returns true for simplicity\n        return true;\n    }\n\n    bool check_arm_baro_enabled() {\n        // This function would typically check a configuration or setting\n        return true;  // Assuming ARMING_CHECK_BARO is always enabled for example\n    }\n\n    float get_barometer_altitude() {\n        // Return a simulated barometer altitude\n        return 100.0; // example altitude in meters\n    }\n\n    float get_inertial_navigation_altitude() {\n        // Return a simulated inertial navigation system altitude\n        return 105.0; // example altitude in meters\n    }\n    \n    void log_failure() {\n        std::cout << \"Barometer and inertial navigation altitude disparity too high!\" << std::endl;\n    }\n\n    bool barometer_checks(bool display_failure) {\n        // Call the base class barometer checks\n        if (!barometer_checks_base()) {\n            return false; // base check failed\n        }\n\n        // Check if ARMING_CHECK_BARO is enabled\n        if (check_arm_baro_enabled()) {\n            float baro_alt = get_barometer_altitude();\n            float ins_alt = get_inertial_navigation_altitude();\n            const float alt_disparity_limit = 10.0; // Predefined limit for altitude disparity in meters\n\n            if (std::abs(baro_alt - ins_alt) > alt_disparity_limit) {\n                if (display_failure) {\n                    log_failure();\n                }\n                return false; // Altitude disparity is too high\n            }\n        }\n\n        return true; // All checks passed\n    }\n};", "CodeBleu_score": 26.982796068939603}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const {\n    // Assuming we have access to a method or property that tells us the source of terrain data.\n    // Let's assume `terrain_source` is an available method, and TERRAIN_SOURCE_DATABASE and\n    // TERRAIN_SOURCE_RANGEFINDER are constants that indicate the source of terrain data.\n    const TerrainSource currentTerrainSource = terrain_source();\n\n    // Check if terrain source is from a rangefinder\n    if (currentTerrainSource == TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n\n    // Assuming there's a method or a property to check RTL altitude type\n    // Let's assume `rtl_altitude_type` is an available method, and ALTITUDE_TYPE_TERRAIN is a constant\n    // indicating that the altitude type is relative to the terrain.\n    const AltitudeType currentRTLAltType = rtl_altitude_type();\n\n    // Check if the terrain source is from a terrain database and RTL altitude type is terrain\n    if (currentTerrainSource == TERRAIN_SOURCE_DATABASE && currentRTLAltType == ALTITUDE_TYPE_TERRAIN) {\n        return true;\n    }\n\n    // Otherwise, defer to the base class implementation.\n    // Assuming `AP_Arming::terrain_database_required()` is the base class method we should defer to.\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 62.6649062618871}, {"code": "bool AP_Arming_Copter::terrain_database_required() const {\n    // Check if the terrain source is from the rangefinder\n    if (_terrain_source == TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n\n    // Check if the RTL altitude type is set to use terrain\n    if (_rtl_altitude_type == RTL_ALTITUDE_TERRAIN) {\n        return true;\n    }\n\n    // Otherwise, defer to the base class\n    return AP_Arming::terrain_database_required();  // Assuming there is a base class method available\n}", "CodeBleu_score": 43.65525221047554}, {"code": "bool AP_Arming_Copter::terrain_database_required() const {\n    // Check if terrain source is from a rangefinder\n    if (terrain_source == TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    \n    // Check if the terrain source is from the terrain database and the RTL (Return to Launch) altitude type is terrain\n    if (terrain_source == TERRAIN_SOURCE_TERRAIN_DATABASE && rtl_altitude_type == RTL_ALTITUDE_TYPE_TERRAIN) {\n        return true;\n    }\n    \n    // Otherwise, defer to the base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 55.70311034454387}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()\n    // Update the timestamp for the current controller execution\n    const uint32_t now = AP_HAL::micros();\n    float dt = (now - last_run_time) / 1000000.0f;  // convert microseconds to seconds\n    last_run_time = now;\n\n    // Ensure that the interval since the last run is reasonable for a rate controller execution\n    if (dt > 0.02f) {   // 20 ms guard, typical loop rates should be faster\n        dt = 0.002f;  // force it to have an assumed delta time, typical for a 500Hz execution rate\n    }\n\n    // Run the attitude control's rate controller \n    // This should only require IMU data and the desired rates set elsewhere in the controller logic\n    attitude_control.rate_controller_run(dt);\n    \n    // Normally, send outputs to the motors or output mixers here;\n    // For example, if we have a MotorControl object we might call:\n    // motor_control.update(dt)\n}", "CodeBleu_score": 44.88756368308246}, {"code": "void Copter::run_rate_controller() {\n    // Get last loop time in seconds\n    float dt = scheduler.get_last_loop_time_s();\n\n    // Update the loop time for attitude control\n    attitude_control.set_dt(dt);\n\n    // Running the rate controller which generally needs IMU data\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 43.526395824229844}, {"code": "void Copter::run_rate_controller() {\n    // Get the last loop time from the scheduler\n    uint32_t now = scheduler.last_loop_time_usec();\n\n    // Ensure that the scheduler has provided a valid last loop time\n    if (now == 0) {\n        return;  // Exit early if the loop time is invalid\n    }\n\n    // Calculate the time delta in seconds since the last update\n    float delta_time = (now - last_run_time) / 1000000.0f;\n\n    // Set the last run time to current time for the next loop\n    last_run_time = now;\n\n    // Run the attitude control rate controller with the computed delta time\n    attitude_control.rate_controller_run(delta_time);\n\n    // Optionally, update other controllers if required\n    // e.g., position_controller.update(delta_time);\n    // e.g., motor_controller.update(delta_time);\n\n    // Implement additional logging or state updates if necessary\n    // e.g., log_controller_state();\n    // e.g., check_controller_health();\n}", "CodeBleu_score": 53.16872423456127}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc) {\n    // Retrieve the next waypoint location\n    Location next_waypoint = get_next_waypoint();\n\n    // Check if the old location matches the waypoint and if the altitude frames of old and new locations are the same\n    if (old_loc != next_waypoint || old_loc.alt_frame != new_loc.alt_frame) {\n        return false;\n    }\n\n    // Set the new location as the target location\n    target_location = new_loc;\n    return true;\n}", "CodeBleu_score": 54.419300534791894}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc) {\n    // Retrieve the next waypoint location (assuming this somehow gets it)\n    Location next_waypoint = get_next_waypoint(); \n\n    // Check if the old location is the same as the next waypoint and check altitude frames\n    if (old_loc == next_waypoint && old_loc.alt_frame == new_loc.alt_frame) {\n        // Conditions are met, update the target location\n        this->target_location = new_loc;\n        return true;\n    } else {\n        // Conditions not met, do not update the target location\n        return false;\n    }\n}", "CodeBleu_score": 54.98559808369914}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc) {\n    // Check if the old location matches the new waypoint location\n    if (old_loc.latitude != new_loc.latitude || old_loc.longitude != new_loc.longitude) {\n        // Locations do not match, return false\n        return false;\n    }\n\n    // Check if the altitude frames match\n    if (old_loc.alt_frame != new_loc.alt_frame) {\n        // Altitude frames do not match, return false\n        return false;\n    }\n\n    // Set new location as the target since all conditions are met\n    target_location = new_loc;\n\n    // Return true as the target location was updated successfully\n    return true;\n}", "CodeBleu_score": 47.06808439795685}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag) {\n    if (ch_flag == HIGH) {\n        // Try to change the mode if the auxiliary switch is in the HIGH position\n        if (!copter.set_mode(mode)) {\n            // Log or handle failure to change mode if necessary\n            gcs().send_text(MAV_SEVERITY_WARNING, \"Failed to change mode via aux switch\");\n        }\n    } else {\n        // If switch is not HIGH and the current mode matches the given mode,\n        // reset the mode switch to allow re-entry into mode via mode switch\n        if (copter.flightmode == mode) {\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 62.59088941211341}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag) {\n    // Check if the switch is in the HIGH position\n    if (ch_flag == HIGH) {\n        // Try to set the mode\n        if (!copter.set_mode(mode)) {\n            // Log an error or handle failure to change mode\n            copter.logging(\"Failed to change mode to \", mode);\n        }\n    } else {\n        // If the switch is not in the HIGH position but is in the position where the current mode matches the given mode\n        if (copter.flight_mode == mode) {\n            // Reset the mode switch\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 63.176730555059194}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag) {\n    // Check if the switch is in the HIGH position\n    if (ch_flag == HIGH) {\n        // Attempt to set the mode if the position is HIGH\n        if (!copter.set_mode(mode)) {\n            // Optionally handle the failure to change mode\n            Serial.print(\"Failed to switch to mode: \");\n            Serial.println(mode);\n        }\n    } else {\n        // If the switch is not in the HIGH position and the mode matches the given one\n        if (copter.flightmode == mode) {\n            // Reset the mode switch\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 62.57861974538144}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim() {\n    // Assuming control inputs of roll and pitch channels come from a method get_control_input()\n    // and AHRS_trim is accessible and modifiable\n\n    // Get the current control input for roll and pitch\n    float roll_input = get_control_input(\"roll\");\n    float pitch_input = get_control_input(\"pitch\");\n\n    // Convert from degrees (assuming control inputs are in degrees) to radians\n    float roll_trim_rad = radians(roll_input);\n    float pitch_trim_rad = radians(pitch_input);\n\n    // Update the AHRS trim values\n    ahrs.add_trim(roll_trim_rad, pitch_trim_rad);\n\n    // Log the event - assuming a log function is available\n    log(\"Trim saved: roll = \" + String(roll_trim_rad) + \" rad, pitch = \" + String(pitch_trim_rad) + \" rad\");\n\n    // Sending a confirmation message - assuming a function send_message is available\n    send_message(\"Trim updated successfully\", MAV_SEVERITY_INFO);\n}", "CodeBleu_score": 43.21805804903829}, {"code": "#include <cmath>\n\nclass Copter {\npublic:\n    void save_trim();\nprivate:\n    float get_control_input(int channel);\n    void log_event(const char* message);\n    void send_confirmation_message(const char* message, int severity);\n    void add_ahrs_trim(float roll_trim_rad, float pitch_trim_rad);\n    constexpr float DEG_TO_RAD(float angle) { return angle * M_PI / 180.0f; }\n    // Dummy example members\n    float roll_channel_input;\n    float pitch_channel_input;\n};\n\nvoid Copter::save_trim(){\n    // Assuming get_control_input fetches the latest control inputs for roll and pitch\n    float roll_input = get_control_input(1); // Assuming 1 is roll channel\n    float pitch_input = get_control_input(2); // Assuming 2 is pitch channel\n    \n    // Converting these inputs which are possibly in degrees to radians\n    float roll_trim_rad = DEG_TO_RAD(roll_input);\n    float pitch_trim_rad = DEG_TO_RAD(pitch_input);\n    \n    // Adding these as trim adjustments in the AHRS (Attitude and Heading Reference System)\n    add_ahrs_trim(roll_trim_rad, pitch_trim_rad);\n    \n    // Logging the event\n    log_event(\"Trim values saved.\");\n    \n    // Sending a confirmation message, assuming MAV_SEVERITY_INFO = 6\n    send_confirmation_message(\"Roll and Pitch trim saved.\", 6);\n}\n\nfloat Copter::get_control_input(int channel) {\n    // Implementation for control input retrieval: this function should interface with the actual hardware or simulation control\n    // Placeholder implementation\n    if (channel == 1) return roll_channel_input;\n    else if (channel == 2) return pitch_channel_input;\n    return 0;\n}\n\nvoid Copter::log_event(const char* message) {\n    // Implementation to log events\n    // Example:\n    std::cout << \"Event log: \" << message << std::endl;\n}\n\nvoid Copter::send_confirmation_message(const char* message, int severity) {\n    // Implementation to send message\n    // Example:\n    std::cout << \"Message: \" << message << \" Severity: \" << severity << std::endl;\n}\n\nvoid Copter::add_ahrs_trim(float roll_trim_rad, float pitch_trim_rad) {\n    // Implementation to adjust AHRS trims\n    // Example:\n    std::cout << \"Updated AHRS with Roll trim: \" << roll_trim_rad << \" rad, Pitch trim: \" << pitch_trim_rad << \" rad\" << std::endl;\n}\n\nint main() {\n    Copter myCopter;\n    myCopter.save_trim();\n    return 0;\n}", "CodeBleu_score": 37.017508724778715}, {"code": "#include <math.h> // For conversion to radians.\n\nvoid Copter::save_trim() {\n    // Assuming get_control_input() is a function which retrieves the current control input for roll and pitch.\n    // Conversion factor for degrees to radians\n    constexpr float DEG_TO_RAD = M_PI / 180.0f; \n    \n    // Retrieve the current control inputs for roll and pitch\n    float roll_input_deg = get_control_input(ROLL_CHANNEL); // Placeholder function\n    float pitch_input_deg = get_control_input(PITCH_CHANNEL); // Placeholder function\n\n    // Convert degrees to radians\n    float roll_trim_rad = roll_input_deg * DEG_TO_RAD;\n    float pitch_trim_rad = pitch_input_deg * DEG_TO_RAD;\n\n    // Update AHRS with new trims\n    ahrs.set_trim(roll_trim_rad, pitch_trim_rad);  // Assuming \u2018ahrs\u2019 is a member variable of \u2018Copter\u2019 and set_trim adjusts the trim values\n\n    // Log the event with the new trim values\n    log_event(\"Trim saved\", roll_trim_rad, pitch_trim_rad);  // log_event needs to be defined elsewhere in the program\n\n    // Send a confirmation message using MAVLink or equivalent communication protocol\n    send_mavlink_message(MAV_SEVERITY_INFO, \"Trim saved successfully.\");\n\n    // For further visualization or debugging.\n    std::cout << \"Roll trim set to: \" << roll_trim_rad << \" radians.\" << std::endl;\n    std::cout << \"Pitch trim set to: \" << pitch_trim_rad << \" radians.\" << std::endl;\n}", "CodeBleu_score": 38.1135754537293}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "#include <cmath> // Include cmath for access to atan2 function\n\n/*\n * Implementation of Mode::AutoYaw::look_ahead_yaw function.\n */\nfloat Mode::AutoYaw::look_ahead_yaw() {\n    // Retrieve the copter's velocity, typically this could be from a data structure or object holding state properties.\n    Vel velocity = copter.get_velocity(); // Assuming method get_velocity() which returns a velocity object with x, y components.\n  \n    // Calculate the squared speed: S^2 = vx^2 + vy^2\n    float speed_squared = velocity.x * velocity.x + velocity.y * velocity.y;\n  \n    // Threshold speed to decide if yaw adjustment is required (this can vary; example value 0.5 m/s)\n    const float min_speed_squared = 0.25; // square of 0.5 m/s\n  \n    // If position is valid and the speed exceeds the minimum threshold, compute the direction using arctangent\n    if (copter.position_is_valid() && speed_squared > min_speed_squared) {\n        float yaw = atan2(velocity.y, velocity.x);\n\n        // Convert radian result from atan2 to degrees if necessary (comment this line if yaw in radians is preferred)\n        // yaw = yaw * 180.0 / M_PI; // Converts from radians to degrees\n\n        return yaw;  // Return", "CodeBleu_score": 46.220479347216695}, {"code": "#include <cmath> // For atan2 and sqrt functions\n\nclass Mode {\npublic:\n    class AutoYaw {\n    public:\n        float look_ahead_yaw() {\n            // Assuming velocity is a struct or class with x and y components\n            Velocity velocity = get_velocity(); // Method to retrieve the copter's velocity\n            float speed_squared = velocity.x * velocity.x + velocity.y * velocity.y;\n            float min_speed_threshold = 1.0; // Define a minimum speed threshold\n\n            if (is_position_valid() && speed_squared > min_speed_threshold * min_speed_threshold) {\n                // Calculate the yaw angle using arctangent of the velocity components\n                float yaw_angle = atan2(velocity.y, velocity.x);\n                return yaw_angle; // Return the computed yaw angle\n            } else {\n                // Return current yaw if the speed is below the threshold or position is invalid\n                return get_current_yaw();\n            }\n        }\n\n    private:\n        struct Velocity {\n            float x, y;\n        };\n\n        Velocity get_velocity() {\n            // Placeholder for actual velocity retrieval logic\n            return {0.0, 0.0}; // Example velocity\n        }\n\n        bool is_position_valid() {\n            // Placeholder for position validation logic\n            return true; // Assume position is always valid\n        }\n\n        float get_current_yaw() {\n            // Placeholder for getting current yaw\n            return 0.0; // Example current yaw\n        }\n    };\n};", "CodeBleu_score": 37.14796552705884}, {"code": "float Mode::AutoYaw::look_ahead_yaw() {\n    // Get the velocity components of the copter (assuming velocities are in meters per second)\n    float vel_x = copter.velocity_x();\n    float vel_y = copter.velocity_y();\n\n    // Calculate the squared speed\n    float speed_squared = vel_x * vel_x + vel_y * vel_y;\n\n    // Minimum speed threshold squared to avoid computational instability with very small velocities\n    const float min_speed_squared = 0.01f; // Adjust the threshold as needed based on unit scale, etc.\n\n    // Variable to hold the calculated yaw angle (in radians)\n    float yaw_angle = 0.0f;\n\n    // Check if the copter's position is valid and if the speed is greater than the threshold\n    if (copter.position_is_valid() && speed_squared > min_speed_squared) {\n        // Use arctan2 to calculate yaw (heading) from the velocity components\n        // arctan2 gives the angle in radians between -pi to pi where positive values are counter-clockwise\n        yaw_angle = atan2(vel_y, vel_x);\n    } else {\n        // If below the speed threshold or position is invalid, might default to current yaw or another logic\n        yaw_angle = copter.get_current_yaw(); // Assume there's a function to get current yaw if movement is too slow/invalid\n    }\n\n    // Return the computed yaw angle\n    return yaw_angle;\n}", "CodeBleu_score": 44.13831917676933}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method) {\n    // Check if the method is RUDDER\n    if (method == AP_Arming::RUDDER) {\n        // Rudder arming disabled case\n        if (!config.rudder_arming_enabled) {\n            return false;\n        }\n        // Throttle not zero case\n        if (plane.get_throttle() != 0) {\n            return false;\n        }\n    }\n\n    // Check if arming checks are disabled or if the watchdog was armed\n    if (config.disable_arming_checks || watchdog.armed) {\n        return true;\n    }\n\n    // Call parent class's arm_checks method and return result\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 51.79040066576492}, {"code": "/*\n * Implementation of AP_Arming_Plane::arm_checks function.\n */\nbool AP_Arming_Plane::arm_checks(AP_Arming::Method method) {\n    // Check if arming method is RUDDER.\n    if (method == AP_Arming::RUDDER) {\n        // Check if rudder arming is disabled.\n        if (!config.enable_rudder_arming) {\n            return false;\n        }\n        // Check if the throttle is not zero.\n        if (plane.get_throttle() > 0) {\n            return false;\n        }\n    }\n\n    // Check if arming checks are disabled or watchdog was armed.\n    if (config.disable_arming_checks || status.watchdog_armed) {\n        return true;\n    }\n\n    // Call the parent class's arm_checks method.\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 54.66109679805186}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method) {\n    // If arming checks are disabled globally or the watchdog mechanism had already armed the system, return true to bypass checks.\n    if (!_enable or _watchdog_armed) {\n        return true;\n    }\n\n    // For RUDDER arming method, two specific conditions will prevent arming.\n    if (method == Method::RUDDER) {\n        if (_rudder_arming_disabled) {\n            // Disable arming if rudder arming is disabled.\n            return false;\n        }\n        if (_throttle != 0) {\n            // Prevent arming if the throttle is not at zero position.\n            return false;\n        }\n    }\n\n    // Call the parent class's arm_checks method and return its result.\n    return AP_Arming::arm_checks(method);\n}", "CodeBleu_score": 39.878003098361724}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks) {\n    // Check if it is already armed\n    if (armed()) {\n        gcs().send_text(MAV_SEVERITY_INFO, \"System already armed\");\n        return false;\n    }\n\n    // Perform arming checks if required\n    if (do_arming_checks && !arming_checks_pass(method)) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arming checks failed\");\n        return false;\n    }\n\n    // Update the home location and set it in the AHRS system\n    if (!update_home_location()) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Failed to update home location\");\n        return false;\n    }\n\n    // Set the current location in the AHRS\n    ahrs.set_current_location();\n\n    // Update the arm state\n    set_armed(true);\n\n    // Set a delay arming flag if needed (e.g., for GPS fix status, or sensor calibrations)\n    if (should_delay_arm()) {\n        set_delay_arming(true);\n        gcs().send_text(MAV_SEVERITY_INFO, \"Delaying arming for checks\");\n        return false;\n    }\n\n    // Send a status text indicating that the throttle is armed\n    gcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n    // If everything is correct return true indicating arming was successful\n    return true;\n}", "CodeBleu_score": 49.825555631185324}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks) {\n    // Check if arming checks should be done or are bypassed\n    if (do_arming_checks) {\n        // Check whether the arming conditions are met\n        if (!arming_checks_pass()) {\n            // Send status text: \"Arming checks failed\"\n            send_status_text(\"Arming checks failed\");\n            return false;\n        }\n    }\n\n    // Assuming arming procedures\n    bool arming_successful = perform_arming_procedure(method);\n    if (!arming_successful) {\n        // Send status text: \"Arming procedure failed\"\n        send_status_text(\"Arming procedure failed\");\n        return false;\n    }\n\n    // Update home location from current GPS data\n    if (!update_home_location()) {\n        // Send status text: \"Failed to update home location\"\n        send_status_text(\"Failed to update home location\");\n        return false;\n    }\n    // Set home location in the AHRS (Attitude and Heading Reference System)\n    set_home_in_AHRS();\n\n    // Update current location\n    update_current_location();\n\n    // Set the arm state to armed\n    set_arm_state(true);\n\n    // Optionally, a delay arming flag could be handled here, if applicable\n    handle_delay_arming();\n\n    // Send status text: \"Throttle armed\"\n    send_status_text(\"Throttle armed\");\n\n    return true;\n}\n\nbool AP_Arming_Plane::arming_checks_pass() {\n    // Check for conditions like battery level, GPS fix, sensor health, etc.\n    return true; // Placeholder, should implement actual checks\n}\n\nbool AP_Arming_Plane::perform_arming_procedure(const AP_Arming::Method method) {\n    switch(method) {\n        case AP_Arming::Method::MANUAL:\n            // Implement manual arming steps\n            break;\n        case AP_Arming::Method::AUTOMATIC:\n            // Implement automatic or assisted arming steps\n            break;\n        default:\n            return false;\n    }\n    return true;\n}\n\nbool AP_Arming_Plane::update_home_location() {\n    // Implementation to fetch and store home location from GPS\n    return true;\n}\n\nvoid AP_Arming_Plane::set_home_in_AHRS() {\n    // Set home location in the AHRS system logic\n}\n\nvoid AP_Arming_Plane::update_current_location() {\n    // Fetch and update current location from GPS or other sensors\n}\n\nvoid AP_Arming_Plane::set_arm_state(bool armed) {\n    // Update internal state, typically a private member variable, to indicate armed status\n}\n\nvoid AP_Arming_Plane::handle_delay_arming() {\n    // Handle delay in arming if necessary based on conditions or configurations\n}\n\nvoid AP_Arming_Plane::send_status_text(const char* status_text) {\n    // Output or log the status text indicating where in the process we are\n}", "CodeBleu_score": 47.65211500265008}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks) {\n    // First, check if arming conditions are met\n    if (do_arming_checks && !arming_checks_passed(method)) {\n        // If arming checks fail, display an error and return false\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arming checks failed\");\n        return false;\n    }\n\n    // Set the home location from the current GPS location\n    if (!ahrs.set_home(current_gps_location())) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Failed to set home location\");\n        return false;\n    }\n\n    // Update the current location in our AHRS system\n    ahrs.update_location();\n\n    // Arm the throttle and other systems, and set the armed flag\n    throttle.enable();\n    armed = true;\n\n    // Set a delay arming flag if applicable (used for safety or other reasons in specific scenarios)\n    if (method == AP_Arming::Method::Delayed) {\n        delay_arming_flag = true;\n    }\n\n    // Send a status text to indicate that the plane is now armed\n    gcs().send_text(MAV_SEVERITY_INFO, \"Throttle armed\");\n\n    // If handling is reached here, arming was successful\n    return true;\n}\n\nbool AP_Arming_Plane::arming_checks_passed(const AP_Arming::Method &method) {\n    // Implement checks for various arming methods. This is a simplified check.\n    // Normally, include checks like GPS lock, sensor health, etc.\n    if (method == AP_Arming::Method::GPSLock) {\n        if (!gps.is_locked()) {\n            gcs().send_text(MAV_SEVERITY_INFO, \"GPS lock required\");\n            return false;\n        }\n    }\n\n    // Additional method-specific checks can be implemented here.\n    return true; \n}\n\nPosition AP_Arming_Plane::current_gps_location() {\n    // Return current location from GPS\n    return gps.location();\n}", "CodeBleu_score": 52.520552423661385}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "// Assuming AP_Arming is a class that has already been defined somewhere else in the project.\n\nbool AP_Arming_Sub::pre_arm_checks(bool display_failure) {\n    // Check if the vehicle is already armed\n    if (this->is_armed()) {\n        return true;\n    }\n    \n    // Check if a disarm button is configured\n    if (!this->disarm_button_configured()) {\n        if (display_failure) {\n            // Display a failure message that disarm button is not configured\n            GCS_SEND_TEXT(MAV_SEVERITY_ERROR, \"Pre-arm check failed: Disarm button not configured\");\n        }\n        return false;\n    }\n    \n    // All local checks passed, perform standard pre-arm checks by calling the parent class method\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 63.27364433691795}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure) {\n    // Check if the vehicle is already armed\n    if (is_armed()) {\n        return true;  // Already armed, no further checks needed\n    }\n\n    // Check for disarm button configuration\n    if (!disarm_button_configured()) {\n        if (display_failure) {\n            // Display the failure message related to disarm button not configured\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Pre-Arm: Disarm button not configured\");\n        }\n        return false;  // Disarm button not configured; cannot arm vehicle\n    }\n\n    // Call the base class method for standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 63.8416879020295}, {"code": "#include <iostream>\nusing namespace std;\n\n// Mock class and method definitions for the purpose of this example.\nclass AP_Arming {\npublic:\n    bool pre_arm_checks() {\n        // Simulated standard pre-arm checks\n        cout << \"Standard pre-arm checks...\" << endl;\n        // Add checks here if needed\n        return true; // Return true for simplicity\n    }\n};\n\nclass AP_Arming_Sub {\nprivate:\n    bool is_armed;\n    bool disarm_button_configured;\n    AP_Arming arming;\n\npublic:\n    AP_Arming_Sub(bool armed, bool disarm_button)\n        : is_armed(armed), disarm_button_configured(disarm_button) {}\n    \n    bool pre_arm_checks(bool display_failure) {\n        if (is_armed) {\n            cout << \"Vehicle is already armed.\" << endl;\n            return true;\n        }\n        \n        if (!disarm_button_configured) {\n            if (display_failure) {\n                cout << \"Failure: Disarm button not configured!\" << endl;\n            }\n            return false;\n        }\n        \n        return arming.pre_arm_checks();\n    }\n};\n\n// Example usage\nint main() {\n    AP_Arming_Sub arming_system(false, true);  // Vehicle is not armed, disarm button is configured\n    bool result = arming_system.pre_arm_checks(true);\n    cout << \"Pre-arm checks result: \" << (result ? \"Success\" : \"Failed\") << endl;\n    return 0;\n}", "CodeBleu_score": 43.62350877389729}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y) {\n    // Assuming yaw is an attribute in the class\n    float yaw = this->yaw; // Replace this if yaw is accessed differently\n\n    // Calculate the cosine and sine of yaw\n    float cos_yaw = cos(yaw);\n    float sin_yaw = sin(yaw);\n\n    // Applying the rotation matrix to x and y\n    // newX = cos(yaw) * x - sin(yaw) * y\n    // newY = sin(yaw) * x + cos(yaw) * y\n    float newX = cos_yaw * x - sin_yaw * y;\n    float newY = sin_yaw * x + cos_yaw * y;\n\n    // Update the original x and y values with the rotated values\n    x = newX;\n    y = newY;\n}", "CodeBleu_score": 40.3473181920542}, {"code": "#include <cmath> // Required for cos and sin functions\n\nvoid Sub::rotate_body_frame_to_NE(float &x, float &y) {\n    // Assuming the yaw variable is named yaw_degrees and is a member of Sub class\n    // Convert yaw from degrees to radians\n    float yaw_radians = yaw_degrees * (M_PI / 180.0);\n\n    // Store original coordinates\n    float original_x = x;\n    float original_y = y;\n\n    // Apply the rotation matrix\n    // new x = cos(yaw) * original_x - sin(yaw) * original_y\n    // new y = sin(yaw) * original_x + cos(yaw) * original_y\n    x = cos(yaw_radians) * original_x - sin(yaw_radians) * original_y;\n    y = sin(yaw_radians) * original_x + cos(yaw_radians) * original_y;\n}", "CodeBleu_score": 32.12656784475135}, {"code": "#include <cmath> // Include cmath for using cos() and sin() functions\n\nclass Sub {\n    float yaw;  // Yaw input from AHRS, assuming yaw is a member of class Sub\n\npublic:\n    void rotate_body_frame_to_NE(float &x, float &y);\n\n    // Function to set the yaw angle for testing\n    void setYaw(float new_yaw) {\n        yaw = new_yaw;\n    }\n\n    // Function to get the yaw angle for validation\n    float getYaw() const {\n        return yaw;\n    }\n};\n\nvoid Sub::rotate_body_frame_to_NE(float &x, float &y) {\n    float new_x = cos(yaw) * x - sin(yaw) * y;\n    float new_y = sin(yaw) * x + cos(yaw) * y;\n\n    // Update the original coordinates\n    x = new_x;\n    y = new_y;\n}", "CodeBleu_score": 38.2263010737257}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "#include <cmath> // For fabs function\n\n// Assuming maximum and minimum yaw angles are constants that should already be defined\n// Adjust below constants according to your needs or system definitions\nconst float MAX_YAW_ANGLE = 360.0f; // Maximum yaw angle in degrees\nconst float MIN_YAW_ANGLE = 0.0f;   // Minimum yaw angle in degrees\n\nMAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet) {\n    // Extract parameters from the command packet\n    float yaw_angle = static_cast<float>(packet.param1); // assuming param1 is the target yaw angle\n    float param4 = static_cast<float>(packet.param4);    // assuming param4 might be some sort of control flag or additional parameter\n\n    // Validate yaw angle within allowable range\n    if (yaw_angle < MIN_YAW_ANGLE || yaw_angle > MAX_YAW_ANGLE) {\n        return MAV_RESULT_DENIED; // Deny request if yaw_angle is out of bounds\n    }\n\n    // Check if param4 meets certain conditions (implement specific check based on system requirements)\n    // Assuming a valid range or condition needs to be checked.\n    // For example, let's consider param4 needs to be zero to proceed.\n    if (param4 != 0.0f) {\n        return MAV_RESULT_DENIED; // Deny request if param4 is not zero\n    }\n\n    // If all parameters are valid, proceed to update the yaw condition\n    // Should have a method to set yaw. As a placeholder:\n    // set_yaw(yaw_angle);\n\n    return MAV_RESULT_ACCEPTED; // If yaw has been successfully updated\n}", "CodeBleu_score": 26.597696012165628}, {"code": "#include <cmath> // For fabs\n\n// Simulated constants for max yaw angle and direction\nconst float MAX_YAW_ANGLE = 360.0;\nconst float MIN_DIRECTION = -1;\nconst float MAX_DIRECTION = 1;\n\n/**\n* Checks the validity of the yaw command parameters.\n* @param yaw_angle The desired yaw angle.\n* @param direction The desired direction to change yaw (-1 for anticlockwise, 1 for clockwise).\n* @return true if valid, false otherwise.\n*/\nbool check_yaw_params(float yaw_angle, float direction) {\n    if (fabs(yaw_angle) > MAX_YAW_ANGLE) {\n        return false;\n    }\n    if (direction < MIN_DIRECTION || direction > MAX_DIRECTION) {\n        return false;\n    }\n    return true;\n}\n\n/**\n* Sets the yaw condition of the vehicle.\n* @param yaw_angle The yaw angle to set.\n* @param direction The direction to set the yaw.\n*/\nvoid set_yaw_condition(float yaw_angle, float direction) {\n    // Placeholder implementation\n    printf(\"Setting yaw to %.2f degrees, direction: %.0f.\\n\", yaw_angle, direction);\n}\n\n/**\n* Processes a MAVLink command to adjust the yaw condition.\n* @param packet The MAVLink command containing yaw adjustment parameters.\n* @return MAV_RESULT_ACCEPTED if the operation succeeded, MAV_RESULT_DENIED otherwise.\n*/\nMAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet) {\n    float yaw_angle = packet.param1; // Get yaw adjustment angle from packet\n    float direction = packet.param4; // Get direction from packet\n\n    if (check_yaw_params(yaw_angle, direction)) {\n        set_yaw_condition(yaw_angle, direction);\n        return MAV_RESULT_ACCEPTED;\n    } else {\n        return MAV_RESULT_DENIED;\n    }\n}", "CodeBleu_score": 24.199490910041373}, {"code": "#include <cmath>   // For math functions\n\n// Assuming that valid yaw ranges and MAV_RESULT enums are defined somewhere globally\nconst float YAW_MIN = 0.0;        // example minimum yaw angle in degrees\nconst float YAW_MAX = 360.0;      // example maximum yaw angle in degrees\nconst float PARAM4_MIN = -1.0;    // minimum valid value for param4 (assuming specific constraint)\nconst float PARAM4_MAX = 1.0;     // maximum valid value for param4 (assuming specific constraint)\n\nenum MAV_RESULT {\n    MAV_RESULT_ACCEPTED,\n    MAV_RESULT_DENIED\n};\n\nclass GCS_MAVLINK_Sub {\npublic:\n    MAV_RESULT handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet) {\n        float yaw = static_cast<float>(packet.param1); // assuming param1 is the yaw in degrees\n        float param4 = static_cast<float>(packet.param4); // assuming param4 holds a specific command or condition value\n        \n        // Validate the yaw angle\n        if (yaw < YAW_MIN || yaw > YAW_MAX) {\n            return MAV_RESULT_DENIED;\n        }\n        \n        // Validate the param4 value\n        if (param4 < PARAM4_MIN || param4 > PARAM4_MAX) {\n            return MAV_RESULT_DENIED;\n        }\n        \n        // Assuming we have a method to set yaw, which is not visible in this snippet\n        setYaw(yaw, param4);\n        \n        return MAV_RESULT_ACCEPTED;\n    }\n\nprivate:\n    void setYaw(float yaw, float param4) {\n        // Set the yaw heading based on the received values\n        // Logic here to adjust yaw of the vehicle/device\n        // Example: possibly adjust the autopilot heading directly or schedule the heading change.\n        // This is dependent on the actual implementation/environment which is not specified here.\n        \n        // Log or confirm successful yaw adjustment\n        printf(\"Yaw adjusted to %f degrees with param4 value %f\\n\", yaw, param4);\n    }\n};\n\n// Example usage (note: this snippet would normally be outside this class file and in some control logic part)\n/*\nGCS_MAVLINK_Sub myGCS;\nmavlink_command_int_t myPacket;\nmyPacket.param1 = 270.0; // Example yaw angle\nmyPacket.param4 = 0.5;   // Example param4 value\nMAV_RESULT result = myGCS.handle_MAV_CMD_CONDITION_YAW(myPacket);\nif (result == MAV_RESULT_ACCEPTED) {\n    printf(\"Command accepted.\\n\");\n} else {\n    printf(\"Command denied.\\n\");\n}\n*/", "CodeBleu_score": 23.454746076231583}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "#include <cstdint>  // for uint8_t\n\nclass GCS_MAVLINK_Sub {\npublic:\n    // Assuming enum or constant definitions for control modes\n    enum ControlMode {AUTO, GUIDED, OTHER};\n\n    uint8_t high_latency_tgt_heading() const {\n        if (control_mode == AUTO || control_mode == GUIDED) {\n            // Normalize waypoint bearing from -18000 to 18000 to 0 to 36000\n            int32_t normalized_bearing = (waypoint_bearing + 36000) % 36000;\n            // Divide by 2 to fit into the high latency message format\n            return uint8_t(normalized_bearing / 2);\n        } else {\n            // Return 0 if the control mode is neither AUTO nor GUIDED\n            return 0;\n        }\n    }\n\nprivate:\n    ControlMode control_mode; // Control mode of the vehicle\n    int32_t waypoint_bearing; // waypoint bearing from -18000 to 18000\n};", "CodeBleu_score": 28.101761506559725}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const {\n    // Check if the current control mode is AUTO or GUIDED\n    if (control_mode == AUTO || control_mode == GUIDED) {\n        // Convert the waypoint bearing from range -18000->18000 to 0->360\n        int16_t adjusted_bearing = (target_bearing + 18000) % 36000;  // Adjust range to 0->36000\n        uint16_t bearing_in_degrees = adjusted_bearing / 100;         // Convert to degrees\n\n        // Return the bearing in degrees divided by 2\n        return bearing_in_degrees / 2;\n    } else {\n        // Not in AUTO or GUIDED mode, return 0\n        return 0;\n    }\n}", "CodeBleu_score": 34.38711794278596}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const {\n    // Check if the control mode is AUTO or GUIDED\n    if (control_mode == AUTO || control_mode == GUIDED) {\n        // Convert the waypoint bearing from -18000->18000 to 0->36000\n        int16_t adjusted_bearing = (waypoint_bearing + 36000) % 36000;\n        // Divide the bearing to get the range from 0->180\n        return static_cast<uint8_t>(adjusted_bearing / 200);\n    } else {\n        // Return 0 if not in AUTO or GUIDED mode\n        return 0;\n    }\n}", "CodeBleu_score": 37.979531834382335}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "#include <iostream>\n#include <chrono>\n#include <mutex>\n\n// Assuming 'LogDataID' is an enum or similar identifier for different log entries.\nenum LogDataID {\n    DATA_TEMPERATURE,\n    DATA_PRESSURE,\n    DATA_HUMIDITY\n};\n\nclass Sub {\nprivate:\n    bool loggingEnabled;\n    std::mutex logMutex;\n\npublic:\n    Sub() : loggingEnabled(true) {}\n\n    void EnableLogging(bool enable) {\n        loggingEnabled = enable;\n    }\n\n    // This function logs a 32-bit integer value if logging is enabled.\n    void Log_Write_Data(LogDataID id, int32_t value) {\n        if (loggingEnabled) {\n            // Locking to ensure thread-safe logging\n            std::lock_guard<std::mutex> guard(logMutex);\n\n            // Getting current time\n            auto now = std::chrono::system_clock::now();\n            auto time = std::chrono::system_clock::to_time_t(now);\n\n            // Simulate creating a log packet\n            // Assume the format of the packet would typically be more complex and involve a real logger\n            \n            // Print to console here as a placeholder for actual log write (e.g., to file, network, etc.)\n            std::cout << \"Log Time: \" << std::ctime(&time) \n                      << \"Data ID: \" << id \n                      << \", Value: \" << value << std::endl;\n        }\n    }\n};\n\n// Example usage\nint main() {\n    Sub subsystem;\n    subsystem.EnableLogging(true);\n    subsystem.Log_Write_Data(DATA_TEMPERATURE, 25);\n    subsystem.EnableLogging(false);\n    subsystem.Log_Write_Data(DATA_PRESSURE, 101325);  // This log will not be written because logging is disabled.\n\n    return 0;\n}", "CodeBleu_score": 31.27531284593963}, {"code": "#include <cstdint>\n#include <ctime>\n\nclass Logger {\npublic:\n    static bool isLoggingEnabled() {\n        // Assume this function checks if logging is enabled.\n        return true;\n    }\n    \n    static void writeCritical(const std::string& message) {\n        // Assume this function writes a critical message to the log.\n        std::cout << \"CRITICAL: \" << message << std::endl;\n    }\n};\n\nenum class LogDataID {\n    // Example data IDs\n    SENSOR_READING,\n    USER_ACTION\n};\n\nclass Sub {\npublic:\n    void Log_Write_Data(LogDataID id, int32_t value) {\n        if (!Logger::isLoggingEnabled()) {\n            return;  // Early exit if logging is disabled.\n        }\n        \n        std::time_t currentTime = std::time(nullptr);\n        char timeStr[20];\n        strftime(timeStr, sizeof(timeStr), \"%Y-%m-%d %H:%M:%S\", std::localtime(&currentTime));\n\n        // Create a log message that includes the current time, the log data ID, and the value.\n        std::ostringstream logPacket;\n        logPacket << \"Time: \" << timeStr << \", ID: \" << static_cast<int>(id) << \", Value: \" << value;\n        \n        // Write the log packet as a critical block.\n        Logger::writeCritical(logPacket.str());\n    }\n};", "CodeBleu_score": 35.41510954596755}, {"code": "#include <chrono>\n#include <iostream>\n#include <mutex>\n\n// Assuming that LogDataID is an enumeration or some sort of identifier for log types.\n// Example definition for LogDataID (you need to define it appropriately based on your usage)\nenum LogDataID {\n    TEMPERATURE,\n    PRESSURE,\n    HUMIDITY\n};\n\nclass Sub {\nprivate:\n    bool logging_enabled;\n    std::mutex log_mutex;\n\npublic:\n    Sub() : logging_enabled(true) {} // Constructor with logging enabled by default\n\n    void EnableLogging(bool enable) {\n        logging_enabled = enable;\n    }\n\n    /*\n     * Logs a 32-bit integer value if logging is enabled.\n     * It creates a log packet with the current time, log data ID, and value,\n     * then writes this packet to the logger as a critical block.\n     */\n    void Log_Write_Data(LogDataID id, int32_t value) {\n        if (!logging_enabled) return; // Return immediately if logging is disabled\n\n        // Lock the mutex to ensure thread safety\n        std::lock_guard<std::mutex> lock(log_mutex);\n\n        // Get the current time for the log entry\n        auto now = std::chrono::system_clock::now();\n        auto time_t_now = std::chrono::system_clock::to_time_t(now);\n\n        // You may need a more sophisticated logging mechanism in reality.\n        // Here, simple console output is used for demonstration purposes.\n        std::cout << \"Time: \" << std::ctime(&time_t_now) << \"ID: \" << id << \", Value: \" << value << std::endl;\n    }\n};\n\n// The implementation of the logging function.\n// In production code, you could replace std::cout with file outputs or other logging facilities.\nint main() {\n    Sub my_subsystem;\n    my_subsystem.EnableLogging(true); // Enable logging\n    my_subsystem.Log_Write_Data(TEMPERATURE, 25);\n    my_subsystem.Log_Write_Data(PRESSURE, 101325);\n    my_subsystem.Log_Write_Data(HUMIDITY, 50);\n    return 0;\n}", "CodeBleu_score": 31.145912872971927}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF() {\n    // Check if the home location is already set. If it is, return immediately.\n    if (home_set) {\n        return;\n    }\n\n    // Check if the motors are armed.\n    if (motors_armed) {\n        // If the motors are armed, set the home location to the current location.\n        set_home_location(current_location);\n        home_set = true; // Mark home as set.\n        return;\n    }\n\n    // If motors are not armed, try setting the home location based on the EKF location.\n    // Note: The initial instructions ask to ignore failure, so we don't handle EKF failure here.\n    if (ekf_ok()) {\n        set_home_location(current_location);\n        home_set = true; // Mark home as set.\n    }\n\n    // If EKF is not okay, we do not set the home location but still return since no action is implied by the docs.\n}", "CodeBleu_score": 25.65630308023098}, {"code": "void Sub::update_home_from_EKF() {\n    // Check if home is already set\n    if (home_is_set) {\n        // If home is already set, no action is required, so exit immediately\n        return;\n    }\n\n    // Check the state of the motors\n    if (motors.are_armed()) {\n        // If motors are armed, set the home to the current location in-flight\n        home_location = current_location;\n        home_is_set = true;\n        std::cout << \"Home location updated in-flight to: \" << home_location << std::endl;\n    } else {\n        // If motors are not armed, set the home to the current EKF location\n        try {\n            home_location = ekf.get_current_location();  // Assuming EKF provides a method to get current location\n            home_is_set = true;\n            std::cout << \"Home location updated to EKF location: \" << home_location << std::endl;\n        } catch (...) {\n            // On failure to get location from EKF, just log and ignore the error\n            std::cout << \"Failed to update home based on EKF. Ignoring as motors are not armed.\" << std::endl;\n        }\n    }\n}", "CodeBleu_score": 24.747305867679806}, {"code": "void Sub::update_home_from_EKF() {\n    // Check if the home location has already been set\n    if (is_home_set()) {\n        // If home is already set, no further action is necessary, exit the function.\n        return;\n    }\n\n    // Get the current location from the EKF\n    Location current_location = get_current_EKF_location();\n\n    // Check if the motors are armed\n    if (are_motors_armed()) {\n        // If the motors are armed, set the home location to the current in-flight location\n        set_home_location(current_location);\n    } else {\n        // If the motors are not armed, attempt to set the home location to the current EKF location\n        // This function does not check for success or failure when setting home location\n        set_home_location(current_location);\n    }\n}", "CodeBleu_score": 26.55636253205384}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run() {\n    // Check if motors are armed\n    if (!copter.motors->armed()) {\n        // Set throttle to zero\n        copter.motors->set_throttle(0);\n\n        // Adjust spool state\n        copter.motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::SHUTDOWN);\n\n        // Relax attitude controllers\n        copter.attitude_control->reset_rate_controller_I_terms();\n        copter.attitude_control->set_rate_targets_to_zero();\n\n        // Exit the function\n        return;\n    }\n\n    // If copter is armed, process inputs and control copter\n    \n    // Set spool state to unlimited throttle\n    copter.motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // Convert pilot's input to desired body frame rates\n    Vector3f desired_rates = copter.input_manager->get_desired_body_rates();\n\n    // Run the attitude controller with desired rates\n    copter.attitude_control->input_rate_bf_roll_pitch_yaw(desired_rates.x, desired_rates.y, desired_rates.z);\n\n    // Output the pilot's throttle input without angle boost\n    float throttle_out = copter.input_manager->get_throttle_input_without_boost();\n    copter.motors->set_throttle(throttle_out);\n\n    // Set the forward and lateral motor inputs based on pilot controls.\n    // Example: map pilot's yaw and lateral inputs directly to specific motor outputs, \n    // This part may heavily depend on your motor mixing and flight dynamics model.\n    float lateral_in = copter.input_manager->get_lateral_input();\n    float forward_in = copter.input_manager->get_forward_input();\n\n    copter.motors->set_forward_and_lateral(lateral_in, forward_in);\n}", "CodeBleu_score": 42.583372669782534}, {"code": "void ModeAcro::run() {\n    // Check if the motors are armed\n    if (!copter.areMotorsArmed()) {\n        // Set throttle to zero\n        copter.setThrottle(0);   \n        // Adjust the spool state to shut down\n        copter.setSpoolState(copter.getSpoolStateEnum().SHUT_DOWN);\n        // Relax attitude controllers\n        copter.relaxAttitudeControllers();\n        // Exit the function\n        return;\n    }\n\n    // If motors are armed, perform the following\n    // Set spool state to full throttle\n    copter.setSpoolState(copter.getSpoolStateEnum().THROTTLE_UNLIMITED);\n\n    // Convert pilot inputs to body frame rates\n    float rollRate, pitchRate, yawRate;\n    std::tie(rollRate, pitchRate, yawRate) = copter.convertPilotInputToRates();\n\n    // Run attitude controller to follow the desired body rates\n    copter.getAttitudeController().runController(rollRate, pitchRate, yawRate);\n\n    // Output pilot's throttle input without angle boost\n    float pilotThrottle = copter.getPilotThrottleInput();\n    copter.outputThrottleWithoutBoost(pilotThrottle);\n\n    // Setting forward and lateral motor inputs based on pilot controls\n    float forwardInput, lateralInput;\n    std::tie(forwardInput, lateralInput) = copter.getPilotForwardAndLateral();\n    copter.setMotorInputs(forwardInput, lateralInput);\n}", "CodeBleu_score": 46.036731589392446}, {"code": "void ModeAcro::run() {\n    if (!motors->armed()) {\n        // Set throttle to zero if motors are not armed\n        motors->set_throttle_zero();\n\n        // Adjust spool state\n        motors->adjust_spool_state();\n\n        // Relax attitude controllers\n        attitude_control->relax();\n\n        // Exit the function as there's nothing more to process\n        return;\n    }\n\n    // Set spool state to allow unlimited throttle when armed\n    motors->set_spool_unlimited();\n\n    // Convert pilot inputs to desired body frame rates\n    float roll_rate, pitch_rate, yaw_rate;\n    get_desired_rate(roll_rate, pitch_rate, yaw_rate);\n\n    // Run the attitude controller with these rates\n    attitude_control->input_euler_rate_roll_pitch_yaw(roll_rate, pitch_rate, yaw_rate);\n\n    // Set the output throttle directly from pilot's input\n    float throttle_output = pilot_input.throttle;\n    motors->set_throttle(throttle_output);\n\n    // Convert pilot input to motor outputs for forward and lateral movements\n    float forward_out, lateral_out;\n    forward_out = pilot_input.yaw;       // Assuming here yaw contributes to lateral movement\n    lateral_out = pilot_input.pitch;     // Assuming here pitch contributes to forward movement\n\n    // It typically might be different depending on the configuration of the vehicle, e.g., roll and pitch might be swapped or inverted.\n    motors->set_forward(forward_out);\n    motors->set_lateral(lateral_out);\n}", "CodeBleu_score": 48.603339586594785}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start() {\n    // Set to position control mode\n    position_control_set_mode(); // assuming function to set the mode\n\n    // Retrieve stopping point location\n    Location stopping_point;\n    retrieve_stopping_point(stopping_point); // assuming function to retrieve the stopping point\n\n    // Set the destination waypoint to the stopping location\n    WaypointController wp_controller; // assuming an object to manage waypoints\n    wp_controller.set_destination(stopping_point);\n\n    // Initialize waypoint controller\n    wp_controller.initialize();\n\n    // Set default yaw behavior\n    set_auto_yaw_mode(YAW_AUTO); // assuming a function to set yaw mode, YAW_AUTO as a predefined constant\n}", "CodeBleu_score": 38.09238491279788}, {"code": "void ModeGuided::guided_pos_control_start() {\n    // First, ensure that the system is set to position control mode.\n    set_mode(POSITION_CONTROL);\n\n    // Retrieve the current stopping point which is the current position of the vehicle\n    Vector3f stopping_point = get_stopping_point();\n\n    // Set the new waypoint destination to the stopping point\n    set_destination(stopping_point);\n\n    // Initialize the waypoint controller to target the stopping point\n    waypoint_controller.init(stopping_point);\n\n    // Initialize yaw to be handled by the default auto yaw mode\n    setup_auto_yaw(DEFAULT_YAW_MODE);\n}", "CodeBleu_score": 31.498070685826114}, {"code": "void ModeGuided::guided_pos_control_start() {\n    // Switch to position control mode\n    set_control_mode(POSITION_CONTROL);\n\n    // Initialize waypoint controller\n    waypoint_controller.init();\n\n    // Retrieve the current stopping point\n    Location stopping_point = get_stopping_point();\n\n    // Set current stopping point as the destination for the waypoint\n    waypoint_controller.set_destination(stopping_point);\n\n    // Initialize yaw to auto yaw mode\n    initialize_auto_yaw(YAW_HOLD);\n\n    // Optionally, one might also want to log or notify that the guided position control has started\n    log_info(\"Guided position control mode started, targeting waypoint at (lat, lon): (%f, %f)\",\n            stopping_point.latitude, stopping_point.longitude);\n}\n\nvoid ModeGuided::set_control_mode(ControlMode mode) {\n    // Set the control mode for the vehicle\n    current_control_mode = mode;\n}\n\nLocation ModeGuided::get_stopping_point() {\n    // Get current location or calculate stopping point\n    // This is a hypothetical function; Implementation would depend on system details\n    return vehicle->get_current_location();\n}\n\nvoid ModeGuided::initialize_auto_yaw(YawMode mode) {\n    // Initialize the yaw mode\n    auto_yaw.set_mode(mode);\n}\n\nvoid ModeGuided::log_info(const char *format, ...) {\n    // Log information to the system logs or console\n    va_list args;\n    va_start(args, format);\n    vprintf(format, args);\n    va_end(args);\n}\n\n// Dummy implementations for placeholder types and enums\nstruct Location {\n    float latitude;\n    float longitude;\n};\n\nclass WaypointController {\npublic:\n    void init() {\n        // Initialize or reset the waypoint controller\n    }\n\n    void set_destination(Location location) {\n        // Set the destination for the waypoint\n    }\n};\n\nenum ControlMode {\n    POSITION_CONTROL\n};\n\nenum YawMode {\n    YAW_HOLD\n};\n\nWaypointController waypoint_controller;\nControlMode current_control_mode;\nAutoYaw auto_yaw;\nVehicle *vehicle;\n\nclass AutoYaw {\npublic:\n    void set_mode(YawMode mode) {\n        // Set the yaw control mode\n        current_yaw_mode = mode;\n    }\nprivate:\n    YawMode current_yaw_mode;\n};", "CodeBleu_score": 26.749764413481426}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start() {\n    // Set the guided mode to use the velocity controller\n    set_mode(GUIDED_VELOCITY_CONTROL);\n\n    // Initialize pilot-defined parameters for maximum vertical speed and acceleration\n    float max_vert_speed = get_pilot_max_vertical_speed();\n    float max_vert_accel = get_pilot_max_vertical_acceleration();\n\n    // Initialize the vertical velocity controller with the max speed and acceleration\n    init_vertical_velocity_controller(max_vert_speed, max_vert_accel);\n\n    // Initialize the horizontal velocity controller\n    init_horizontal_velocity_controller();\n\n    // Set the yaw control mode to automatically hold yaw position\n    set_yaw_control_mode(AUTO_YAW_HOLD);\n\n    // Log or print that the velocity control in guided mode has been started\n    log(\"Guided mode velocity control started with AUTO_YAW_HOLD.\");\n}", "CodeBleu_score": 28.31628903200949}, {"code": "void ModeGuided::guided_vel_control_start() {\n    // Setting the mode to Guided-Velocity control\n    current_mode = GUIDED_VELOCITY_CONTROL;\n\n    // Initialize vertical maximum speeds and acceleration from pilot-defined parameters\n    vertical_speed_max = pilot_params.vertical_speed_max;\n    vertical_acceleration = pilot_params.vertical_acceleration;\n\n    // Initialize the vertical velocity controller\n    vertical_velocity_controller.init(vertical_speed_max, vertical_acceleration);\n\n    // Initialize horizontal velocity controller\n    horizontal_velocity_controller.init(pilot_params.horizontal_speed_max, pilot_params.horizontal_acceleration);\n\n    // Set yaw control mode to AUTO_YAW_HOLD to maintain current yaw angle while allowing pilot input to adjust\n    yaw_control_mode = AUTO_YAW_HOLD;\n\n    // Optionally, log the start of guided velocity control\n    log(\"Guided velocity control started, yaw holding mode enabled.\");\n}", "CodeBleu_score": 42.24859969474748}, {"code": "void ModeGuided::guided_vel_control_start() {\n    // Set the guided mode to velocity controller\n    set_mode(VELOCITY_CONTROL);\n\n    // Initialize vertical maximum speeds and acceleration with pilot-defined parameters\n    vertical_speed_max = pilot_defined_vertical_speed_max;\n    vertical_acceleration = pilot_defined_vertical_acceleration;\n\n    // Initialize the vertical velocity controller with max speed and acceleration\n    init_vertical_velocity_controller(vertical_speed_max, vertical_acceleration);\n    \n    // Initialize horizontal velocity controller\n    init_horizontal_velocity_controller();\n\n    // Set yaw control to automatically hold the current yaw position\n    set_yaw_control_mode(AUTO_YAW_HOLD);\n\n    // Log that the guided velocity control has started\n    log(\"Guided velocity control initiated with max vertical speed: %f, vertical acceleration: %f\", vertical_speed_max, vertical_acceleration);\n}", "CodeBleu_score": 31.301524451329882}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "#include <iostream>\n#include <chrono>\n#include <cmath> // for std::abs\n\nclass ModeGuided {\npublic:\n    ModeGuided() {\n        // Initializing with some default values\n        start_time = std::chrono::system_clock::now();\n        guided_mode_duration_limit = std::chrono::seconds(300); // limiting duration to 5 minutes\n        min_altitude = 10.0; // in meters\n        max_altitude = 500.0; // in meters\n        max_horizontal_distance = 1000.0; // in meters\n        start_point = {0.0, 0.0};\n    }\n\n    void set_current_position(double x, double y, double altitude) {\n        current_position = {x, y};\n        current_altitude = altitude;\n    }\n\n    bool guided_limit_check() {\n        // Check time limit\n        auto current_time = std::chrono::system_clock::now();\n        if (current_time - start_time > guided_mode_duration_limit) {\n            return true;\n        }\n\n        // Check altitude limits\n        if (current_altitude < min_altitude || current_altitude > max_altitude) {\n            return true;\n        }\n\n        // Check horizontal distance limit\n        double distance_moved = sqrt(pow(current_position.first - start_point.first, 2) \n                                     + pow(current_position.second - start_point.second, 2));\n        if (distance_moved > max_horizontal_distance) {\n            return true;\n        }\n\n        return false;\n    }\n\nprivate:\n    std::chrono::time_point<std::chrono::system_clock> start_time;\n    std::chrono::duration<int> guided_mode_duration_limit;\n    double min_altitude, max_altitude, max_horizontal_distance;\n    std::pair<double, double> start_point, current_position;\n    double current_altitude;\n};\n\nint main() {\n    // Example to test the ModeGuided class\n    ModeGuided guide;\n    guide.set_current_position(10.0, 10.0, 20.0);\n\n    if (guide.guided_limit_check()) {\n        std::cout << \"Guided mode should be terminated.\" << std::endl;\n    } else {\n        std::cout << \"Guided mode is safe to continue.\" << std::endl;\n    }\n\n    return 0;\n}", "CodeBleu_score": 34.83081528581873}, {"code": "bool ModeGuided::guided_limit_check() {\n    // Assume that the timeout, minAltitude, maxAltitude, and maxDistance are defined elsewhere within the class\n\n    // Check if timeout has been exceeded\n    if ( currentTime() - startTime() > timeout ) {\n        return true;\n    }\n\n    // Check if altitude is below minimum or above maximum\n    if ( currentAltitude() < minAltitude || currentAltitude() > maxAltitude ) {\n        return true;\n    }\n\n    // Check if the horizontal distance from the start exceeds the maximum allowed distance\n    if ( calculateDistanceFromStart() > maxDistance ) {\n        return true;\n    }\n\n    // If none of the conditions are met, return false\n    return false;\n}", "CodeBleu_score": 17.41959735660219}, {"code": "bool ModeGuided::guided_limit_check() {\n    // Check if the timeout for guided mode has been exceeded\n    if (current_time - start_time > timeout) {\n        return true;\n    }\n\n    // Check if the current altitude is below the minimum threshold or above the maximum threshold\n    if (current_altitude < minimum_altitude || current_altitude > maximum_altitude) {\n        return true;\n    }\n\n    // Calculate the horizontal distance moved from the starting position\n    double distance_moved = sqrt(pow(current_position.x - start_position.x, 2) + pow(current_position.y - start_position.y, 2));\n    \n    // Check if the horizontal distance moved exceeds the specified limit\n    if (distance_moved > max_horizontal_distance) {\n        return true;\n    }\n\n    // If none of the limits are exceeded, return false\n    return false;\n}", "CodeBleu_score": 33.134739814896705}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "#include <iostream>\n#include <chrono>\n\nclass Sub {\nprivate:\n    bool motor_test_enabled;\n    bool system_armed;\n    std::chrono::steady_clock::time_point last_motor_test_request;\n    std::chrono::steady_clock::time_point failure_time;\n    bool pass_flag;\n\npublic:\n    Sub() : motor_test_enabled(false), system_armed(false), pass_flag(true) { }\n\n    // Method to simulate receiving motor test request\n    void receive_motor_test_request() {\n        last_motor_test_request = std::chrono::steady_clock::now();\n        motor_test_enabled = true;\n    }\n\n    // Method to disarm the system\n    void disarm_system() {\n        system_armed = false;\n    }\n\n    // Method to disable motor test\n    void disable_motor_test() {\n        motor_test_enabled = false;\n    }\n\n    // The verify_motor_test function from the docstring\n    bool verify_motor_test() {\n        const int REQUIRED_FREQUENCY_MS = 500; // Requests must be at least every 500 milliseconds (2 Hz)\n        auto now = std::chrono::steady_clock::now();\n        int elapsed_time_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_motor_test_request).count();\n\n        if (elapsed_time_ms > REQUIRED_FREQUENCY_MS) {\n            std::cerr << \"Motor test request timed out.\\n\";\n            pass_flag = false;\n            disable_motor_test();\n            disarm_system();\n            failure_time = std::chrono::steady_clock::now();\n            return false;\n        }\n\n        return true;\n    }\n};\n\n// Example of usage\nint main() {\n    Sub submarine;\n    submarine.receive_motor_test_request(); // Simulating motor test request\n    \n    // Simulate waiting for possibly longer than the 2 Hz requirement\n    std::this_thread::sleep_for(std::chrono::milliseconds(600));\n    \n    // Verify motor test\n    bool result = submarine.verify_motor_test();\n    if (!result) {\n        std::cout << \"Motor test failed.\\n\";\n    } else {\n        std::cout << \"Motor test passed.\\n\";\n    }\n    \n    return 0;\n}", "CodeBleu_score": 39.97047628493349}, {"code": "#include <iostream>\n#include <chrono>\n\nclass Sub {\nprivate:\n    bool motorTestEnabled = true;\n    bool motorTestPass = false;\n    std::chrono::steady_clock::time_point lastMotorTestRequest;\n    const long TIMEOUT_THRESHOLD = 500; // milliseconds\n\npublic:\n    // Call this method to simulate receiving a motor test request\n    void receiveMotorTestRequest() {\n        lastMotorTestRequest = std::chrono::steady_clock::now();\n    }\n\n    // Method to disable the motor test\n    void disableMotorTest() {\n        motorTestEnabled = false;\n    }\n\n    // Method to disarm the system\n    void disarmSystem() {\n        std::cout << \"System disarmed.\" << std::endl;\n    }\n\n    // Record the failure time\n    void recordFailureTime() {\n        auto now = std::chrono::steady_clock::now();\n        auto time_since_epoch = now.time_since_epoch();\n        auto milliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(time_since_epoch).count();\n        std::cout << \"Failure time recorded as \" << milliseconds << \" milliseconds since epoch.\" << std::endl;\n    }\n\n    // Send a timeout message\n    void sendTimeoutMessage() {\n        std::cout << \"Timeout! Motor test requests not received.\" << std::endl;\n    }\n\n    // Check if motor test requests are received at least every 2 Hz\n    bool verify_motor_test() {\n        if (!motorTestEnabled) {\n            std::cout << \"Motor test is disabled.\" << std::endl;\n            return false;\n        }\n\n        auto currentTime = std::chrono::steady_clock::now();\n        auto msSinceLastRequest = std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - lastMotorTestRequest).count();\n\n        // Check if last request was more than 500 ms ago\n        if (msSinceLastRequest > TIMEOUT_THRESHOLD) {\n            sendTimeoutMessage();\n            motorTestPass = false;\n            disableMotorTest();\n            disarmSystem();\n            recordFailureTime();\n            return false;\n        }\n\n        motorTestPass = true;\n        return true;\n    }\n};\n\nint main() {\n    Sub mySub;\n    mySub.receiveMotorTestRequest(); // Simulate a motor test request\n\n    // Delay for demonstration. In a real scenario, this delay could be part of a loop or asynchronous callbacks.\n    std::this_thread::sleep_for(std::chrono::milliseconds(300));\n\n    bool result = mySub.verify_motor_test();\n    std::cout << \"Motor test verification result: \" << (result ? \"Passed\" : \"Failed\") << std::endl;\n    return 0;\n}", "CodeBleu_score": 35.92951895133745}, {"code": "#include <iostream>\n#include <chrono>\n\nclass Sub {\nprivate:\n    bool motorTestEnabled;\n    bool systemArmed;\n    bool passFlag;\n    std::chrono::steady_clock::time_point lastRequestTime;\n    bool isTestRequestReceived();\n\npublic:\n    Sub() : motorTestEnabled(true), systemArmed(true), passFlag(true) {\n        // Initialize lastRequestTime to the current time\n        lastRequestTime = std::chrono::steady_clock::now();\n    }\n\n    void disarmSystem() {\n        systemArmed = false;\n        std::cout << \"System is disarmed.\" << std::endl;\n    }\n\n    void disableMotorTest() {\n        motorTestEnabled = false;\n        std::cout << \"Motor test is disabled.\" << std::endl;\n    }\n\n    void sendTimeoutMessage() {\n        std::cout << \"Timeout: No motor test request received in time.\" << std::endl;\n    }\n\n    void recordFailureTime() {\n        auto now = std::chrono::steady_clock::now();\n        auto timeFailed = std::chrono::duration_cast<std::chrono::seconds>(now - lastRequestTime).count();\n        std::cout << \"Failure recorded at \" << timeFailed << \" seconds since last correct request.\" << std::endl;\n    }\n\n    bool verify_motor_test() {\n        while (motorTestEnabled) {\n            if (isTestRequestReceived()) {\n                auto currentTime = std::chrono::steady_clock::now();\n                auto durationSinceLastRequest = std::chrono::duration_cast<std::chrono::milliseconds>(\n                    currentTime - lastRequestTime\n                ).count();\n\n                // Renew the timer on every received test request\n                lastRequestTime = currentTime;\n\n                // Check interval is less than or equal to 500 ms\n                if (durationSinceLastRequest > 500) {\n                    sendTimeoutMessage();\n                    passFlag = false;\n                    break;\n                }\n            } else {\n                std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Minimal sleep to prevent busy loop\n            }\n        }\n\n        if (!passFlag) {\n            disableMotorTest();\n            disarmSystem();\n            recordFailureTime();\n            return false;\n        }\n\n        return true;\n    }\n};\n\nbool Sub::isTestRequestReceived() {\n    // Simulate checking the receiving of test requests.\n    // This stub should be replaced by actual implementation\n    // This function should return 'true' if a motor test request has been received.\n    return rand() % 2 == 0; // Randomly simulate requests' reception\n}\n\nint main() {\n    Sub submarine;\n    bool testPassed = submarine.verify_motor_test();\n    std::cout << \"Motor test \" << (testPassed ? \"passed\" : \"failed\") << \".\" << std::endl;\n    return 0;\n}", "CodeBleu_score": 44.84760371053545}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "#include <algorithm>  // For std::min and std::max\n\nclass WpNav {\npublic:\n    int get_roll() const;  // Should be implemented somewhere in the system\n    int get_pitch() const; // Should be implemented somewhere in the system\n};\n\nclass Sub {\nprivate:\n    WpNav wp_nav;\n\npublic:\n    void translate_wpnav_rp(float &lateral_out, float &forward_out) {\n        const int max_angle = 4500;  // Maximum angle in centidegrees (\u00b145 degrees)\n        const float to_degrees = 0.01f;  // Conversion factor from centidegrees to degrees\n\n        // Retrieve roll and pitch targets from wp_nav in centidegrees\n        int roll_cd = wp_nav.get_roll();\n        int pitch_cd = wp_nav.get_pitch();\n\n        // Constrain roll and pitch within the maximum angle range\n        roll_cd = std::max(-max_angle, std::min(max_angle, roll_cd));\n        pitch_cd = std::max(-max_angle, std::min(max_angle, pitch_cd));\n\n        // Normalize (already constrained, just convert to degrees here for consistency in units if needed)\n        lateral_out = roll_cd * to_degrees;\n        forward_out = pitch_cd * to_degrees;\n    }\n};", "CodeBleu_score": 40.11574415498201}, {"code": "#include <algorithm>\n#include <cmath>\n\nclass WPNav {\npublic:\n    int get_roll_cd() const {\n        // This method should return the roll target in centidegrees\n        return roll_cd;  // Needs actual implementation\n    }\n    \n    int get_pitch_cd() const {\n        // This method should return the pitch target in centidegrees\n        return pitch_cd;  // Needs actual implementation\n    }\n\nprivate:\n    int roll_cd = 0;  // Example roll target value in centidegrees\n    int pitch_cd = 0;  // Example pitch target value in centidegrees\n};\n\nclass Sub {\npublic:\n    void translate_wpnav_rp(float &lateral_out, float &forward_out);\n\nprivate:\n    WPNav wp_nav;\n};\n\nvoid Sub::translate_wpnav_rp(float &lateral_out, float &forward_out) {\n    // Retrieve roll and pitch targets in centidegrees from wp_nav\n    int roll_target_cd = wp_nav.get_roll_cd();\n    int pitch_target_cd = wp_nav.get_pitch_cd();\n\n    // Constrain angle to the range [-4500, 4500] centidegrees (i.e., \u00b145 degrees)\n    roll_target_cd = std::max(-4500, std::min(4500, roll_target_cd));\n    pitch_target_cd = std::max(-4500, std::min(4500, pitch_target_cd));\n\n    // Normalizing the output to the range [-1.0, 1.0]\n    lateral_out = roll_target_cd / 4500.0f;\n    forward_out = pitch_target_cd / 4500.0f;\n}", "CodeBleu_score": 38.215008082312984}, {"code": "#include <algorithm>  // For std::min and std::max\n\nclass Sub {\nprivate:\n    // Maximum angle constraint in centidegrees\n    const float max_angle_cdeg = 3000; // Hypothetical maximum of 30 degrees expressed in centidegrees\n\n    // Hypothetical functions to mimic retrieval of roll and pitch from wp_nav\n    float get_wp_nav_roll() {\n        return 2700; // Example placeholder value in centidegrees\n    }\n    \n    float get_wp_nav_pitch() {\n        return 3300; // Example placeholder value in centidegrees\n    }\n\npublic:\n    void translate_wpnav_rp(float &lateral_out, float &forward_out) {\n        // Retrieve targets from wp_nav\n        float roll_cdeg = get_wp_nav_roll();\n        float pitch_cdeg = get_wp_nav_pitch();\n\n        // Constrain roll and pitch to the maximum allowable limits\n        roll_cdeg = std::max(std::min(roll_cdeg, max_angle_cdeg), -max_angle_cdeg);\n        pitch_cdeg = std::max(std::min(pitch_cdeg, max_angle_cdeg), -max_angle_cdeg);\n\n        // Normalize the roll and pitch values\n        lateral_out = roll_cdeg / max_angle_cdeg;\n        forward_out = pitch_cdeg / max_angle_cdeg;\n\n        // Ensuring the output is within -1.0 and 1.0\n        lateral_out = std::max(std::min(lateral_out, 1.0f), -1.0f);\n        forward_out = std::max(std::min(forward_out, 1.0f), -1.0f);\n    }\n};", "CodeBleu_score": 35.98765548551223}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "#include <iostream>\n\nclass Sub {\nprivate:\n    double altitude;\n    bool barometerHealth;\n    bool depthSensorPresent;\n    bool depthSensorHealth;\n\npublic:\n    Sub(double alt, bool health, bool sensorPresent)\n        : altitude(alt), barometerHealth(health), depthSensorPresent(sensorPresent), depthSensorHealth(true) {}\n\n    void updateBarometerCalibration() {\n        std::cout << \"Updating barometer calibration for altitude \" << altitude << std::endl;\n        // Implement calibration logic (fake example)\n        barometerHealth = true;\n    }\n    \n    void updateDepthSensorHealth() {\n        if (!barometerHealth) {\n            std::cout << \"Barometer is unhealthy; updating depth sensor health to false.\" << std::endl;\n            depthSensorHealth = false;\n        } else {\n            std::cout << \"Barometer is healthy; no change to depth sensor health.\" << std::endl;\n        }\n    }\n\n    void read_barometer() {\n        std::cout << \"Reading barometer data...\" << std::endl;\n        \n        if (altitude > 0) {\n            updateBarometerCalibration();\n        }\n        \n        if (depthSensorPresent) {\n            updateDepthSensorHealth();\n        }\n    }\n};\n\nint main() {\n    Sub submarine(10, false, true); // Starting with a condition where altitude is 10, barometer is initially unhealthy, depthSensor is present.\n\n    submarine.read_barometer(); // This should trigger updates according to the provided functionality.\n\n    return 0;\n}", "CodeBleu_score": 31.996345383805945}, {"code": "void Sub::read_barometer() {\n    // Simulate obtaining current altitude data from the barometer\n    double altitude = barometer.getAltitude();\n    \n    // If the altitude is above zero, we might be above water or at the surface, calibrate the barometer\n    if (altitude > 0) {\n        barometer.calibrate();\n    }\n\n    // Check if a depth sensor is present\n    if (hasDepthSensor) {\n        // Update the depth sensor's health status based on the barometer's health\n        if (barometer.isHealthy()) {\n            depthSensor.setHealthStatus(true);  // Set the health status to good\n        } else {\n            depthSensor.setHealthStatus(false); // Set the health status to bad if barometer is not healthy\n        }\n    }\n\n    // Log the updated barometer and potentially depth sensor state\n    logger.log(\"Barometer altitude: \" + std::to_string(altitude));\n    if (hasDepthSensor) {\n        logger.log(\"Depth sensor healthy: \" + std::to_string(depthSensor.getHealthStatus()));\n    }\n}", "CodeBleu_score": 43.60975549381074}, {"code": "void Sub::read_barometer() {\n    // Attempt to fetch the latest barometer data\n    BarometerData data = barometer.fetchData();\n\n    // Check if the data is valid\n    if (!data.isValid) {\n        std::cerr << \"Failed to read barometer data.\" << std::endl;\n        // Update barometer's health status as false\n        barometer.setHealth(false);\n        return;\n    }\n\n    // Barometer is healthy\n    barometer.setHealth(true);\n\n    // Update the altitude data\n    altitude = data.altitude;\n\n    // If altitude is above zero, recalibrate the barometer\n    if (altitude > 0.0) {\n        barometer.calibrate();\n    }\n\n    // Check if a depth sensor is present\n    if (hasDepthSensor) {\n        // Update the health status of the depth sensor based on the barometer's health\n        bool barometerHealth = barometer.getHealth();\n        depthSensor.setHealth(barometerHealth);\n    }\n\n    // Optionally, log that barometer reading was successful\n    std::cout << \"Barometer reading updated successfully. Current altitude: \" << altitude << std::endl;\n}", "CodeBleu_score": 42.9820712125788}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok() {\n    // Check if inertial navigation is available.\n    if (!ekf.is_inertial_navigation_available()) {\n        return false;\n    }\n\n    // Check motor armed status.\n    if (motors.are_disarmed()) {\n        // If motors are disarmed, accept a predicted horizontal position.\n        return ekf.is_predicted_horizontal_position_acceptable();\n    } else {\n        // If motors are armed, require a good absolute position.\n        if (!ekf.is_absolute_position_good()) {\n            return false;\n        }\n\n        // Ensure the EKF is not in constant position mode.\n        if (ekf.is_in_constant_position_mode()) {\n            return false;\n        }\n    }\n\n    // If all conditions are satisfied.\n    return true;\n}", "CodeBleu_score": 49.12325378510552}, {"code": "#include <stdbool.h>\n\nclass Sub {\nprivate:\n    bool inertial_navigation_available;\n    bool motors_armed;\n    bool absolute_position_good;\n    bool in_constant_position_mode;\n\npublic:\n    Sub() {\n        // Constructor initialization (example values)\n        inertial_navigation_available = true;\n        motors_armed = false;\n        absolute_position_good = true;\n        in_constant_position_mode = false;\n    }\n\n    bool ekf_position_ok() {\n        // Check if inertial navigation is available\n        if (!inertial_navigation_available) {\n            return false;\n        }\n\n        // Check motor status and apply different conditions based on whether motors are armed or not\n        if (!motors_armed) {\n            // If motors are disarmed, accept predicted horizontal position\n            // Assuming `true` for horizontal position predicted since the criteria aren't fully clear\n            return true;\n        } else {\n            // Motors are armed, require good absolute position\n            if (!absolute_position_good) {\n                return false;\n            }\n            \n            // Also ensure not in constant position mode when motors armed\n            if (in_constant_position_mode) {\n                return false;\n            }\n\n            // If all checks are okay\n            return true;\n        }\n    }\n};\n\nint main() {\n    Sub sub;\n\n    // Output the result of the ekf_position_ok\n    std::cout << \"EKF Position OK: \" << sub.ekf_position_ok() << std::endl;\n\n    return 0;\n}", "CodeBleu_score": 29.805649051663085}, {"code": "bool Sub::ekf_position_ok() {\n    // Check if inertial navigation is available\n    if (!inertial_nav.available()) {\n        return false;\n    }\n\n    // Check the status of the motors\n    if (motors.disarmed()) {\n        // Motors are disarmed, accept predicted horizontal position\n        return ekf.pred_position_horiz_ok();\n    } else {\n        // Motors are armed, require a good absolute position and check EKF mode\n        return ekf.position_ok() && !ekf.const_pos_mode();\n    }\n}", "CodeBleu_score": 42.8177895709626}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure) {\n    // Check if the current control mode requires GPS\n    if (!control_mode_requires_GPS()) {\n        return true;  // If the control mode does not require GPS, pass the check\n    }\n\n    // Call the parent class's GPS check\n    if (!AP_Arming::gps_checks(display_failure)) {\n        // If the parent class's checks fail, log the failure and return false\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"GPS checks failed in parent class\");\n        }\n        return false;\n    }\n\n    // Check if the AHRS is ready (Make sure you have access to the necessary AHRS object)\n    if (!ahrs.is_ready()) {\n        // If AHRS is not ready, log the failure and return false\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"AHRS not ready\");\n        }\n        return false;\n    }\n\n    // Check if the EKF failsafe is active\n    if (ekf_failsafe_active()) {\n        // If EKF failsafe is active, log the error and return false\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"EKF failsafe active\");\n        }\n        return false;\n    }\n\n    // Ensure the GPS position is valid\n    if (!gps.status() >= GPS_OK_FIX_3D) {\n        // If the GPS fix is not good enough, log the failure and return false\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Invalid GPS position\");\n        }\n        return false;\n    }\n\n    // All checks passed\n    return true;\n}", "CodeBleu_score": 48.31668474017846}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure) {\n    // Check if the current control mode requires position or velocity\n    if (!require_gps()) {\n        return true;\n    }\n\n    // Perform the parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // Ensure the AHRS system is healthy\n    if (!ahrs.healthy()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: AHRS not healthy\");\n        }\n        return false;\n    }\n\n    // Check if the EKF failsafe is active\n    if (ekf.failsafe()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: EKF Failsafe\");\n        }\n        return false;\n    }\n\n    // Verify the GPS position estimate is valid\n    if (!ahrs.get_position_estimate().is_valid()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"PreArm: Invalid position estimate\");\n        }\n        return false;\n    }\n\n    // All checks passed\n    return true;\n}", "CodeBleu_score": 53.72871777208059}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure) {\n    // Check if the current control mode requires GPS.\n    if (!control_mode_requires_gps(_rover.control_mode)) {\n        return true;\n    }\n\n    // Call the parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // Check if the AHRS is healthy\n    if (!_rover.ahrs.healthy()) {\n        if (display_failure) {\n            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, \"PreArm: AHRS not healthy\");\n        }\n        return false;\n    }\n\n    // Check if EKF failsafe is active\n    if (_rover.ahrs.nav_filter_status().flags.ekf_bad) {\n        if (display_failure) {\n            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, \"PreArm: EKF Failsafe active\");\n        }\n        return false;\n    }\n\n    // Ensure the position estimate from GPS is valid\n    if (!_rover.ahrs.have_position()) {\n        if (display_failure) {\n            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, \"PreArm: No valid GPS position\");\n        }\n        return false;\n    }\n\n    // If all checks are good, return true.\n    return true;\n}", "CodeBleu_score": 58.349571998069806}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks) {\n    if (do_arming_checks) {\n        if (!this->perform_arming_checks()) {\n            this->log_event(\"arming_failed\");\n            return false; // Arming checks failed\n        }\n    }\n\n    // Attempt to arm the rover\n    bool armed_successfully = this->internal_arm(method);\n    if (!armed_successfully) {\n        this->log_event(\"arming_failed\");\n        return false; // Internal arming procedure failed\n    }\n\n    // If arming succeeded, perform additional setup\n    update_smart_rtl_home_location();\n    initialize_simple_mode_heading();\n    if (is_sail_vehicle()) { // Check if it's a sail vehicle, special handling\n        record_home_heading_for_sail_vehicles();\n    }\n    update_soft_armed_status(true); // Soft armed status is set to true\n    this->send_status_text(\"Armed successfully\");\n\n    return true;\n}\n\nbool AP_Arming_Rover::perform_arming_checks() {\n    // Perform necessary checks before arming\n    // Placeholder for actual implementation.\n    return true; // Assuming checks pass for example purposes\n}\n\nbool AP_Arming_Rover::internal_arm(AP_Arming::Method method) {\n    // Actual arming logic depending on the method\n    // Placeholder implementation; assume success\n    return true;\n}\n\nvoid AP_Arming_Rover::update_smart_rtl_home_location() {\n    // Code to update SmartRTL home location\n}\n\nvoid AP_Arming_Rover::initialize_simple_mode_heading() {\n    // Initial setup for simple mode heading\n}\n\nvoid AP_Arming_Rover::record_home_heading_for_sail_vehicles() {\n    // Record home heading for sail vehicles\n}\n\nvoid AP_Arming_Rover::update_soft_armed_status(bool status) {\n    // Update soft armed status\n}\n\nvoid AP_Arming_Rover::log_event(const std::string& event_name) {\n    // Log an event\n}\n\nvoid AP_Arming_Rover::send_status_text(const std::string& text) {\n    // Send a status update text\n}\n\nbool AP_Arming_Rover::is_sail_vehicle() {\n    // Determine if the vehicle is a sail vehicle\n    return false; // Placeholder; adjust based on actual vehicle check\n}", "CodeBleu_score": 39.764303247572045}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks) {\n    // Step 1: Before arming, run arming checks if required.\n    if (do_arming_checks && !pre_arm_checks()) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arming check failed\");\n        arming_failed_event();\n        return false;\n    }\n\n    // Step 2: Arm the rover.\n    if (!internal_arm(method)) {\n        gcs().send_text(MAV_SEVERITY_CRITICAL, \"Internal arming failed\");\n        arming_failed_event();\n        return false;\n    }\n\n    // Step 3: Additional steps on successful arming.\n    set_smartrtl_home_location();\n    init_simple_mode_heading();\n    record_home_heading_for_sail();\n\n    // Update the soft arm status and notify via GCS.\n    update_soft_armed_status(true);\n    gcs().send_text(MAV_SEVERITY_INFO, \"Vehicle armed successfully\");\n\n    // Return true indicating the arming was successful.\n    return true;\n}\n\nbool AP_Arming_Rover::internal_arm(AP_Arming::Method method) {\n    // Simulate the hardware-specific arming processes.\n    // This will vary depending on the particular rover hardware and arming methods.\n    return true;  // Mocking success for the purpose of example.\n}\n\nbool AP_Arming_Rover::pre_arm_checks() {\n    // Perform necessary checks to ensure it's safe to arm.\n    // These can include sensor checks, calibration validation, and so forth.\n    return true;  // Mocking all checks pass for the purpose of example.\n}\n\nvoid AP_Arming_Rover::arming_failed_event() {\n    // Log or broadcast arming failure event.\n}\n\nvoid AP_Arming_Rover::set_smartrtl_home_location() {\n    // Logic to set SmartRTL home point.\n}\n\nvoid AP_Arming_Rover::init_simple_mode_heading() {\n    // Initialize any necessary orientation/headings for simple control modes.\n}\n\nvoid AP_Arming_Rover::record_home_heading_for_sail() {\n    // Special logic for sail-based vehicles to record the heading when armed.\n}\n\nvoid AP_Arming_Rover::update_soft_armed_status(bool status) {\n    // Update and potentially broadcast the change in soft arm status.\n}", "CodeBleu_score": 43.500316429147624}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, bool do_arming_checks) {\n    if (do_arming_checks && !arming_checks()) {\n        arming_failed_event();\n        return false;\n    }\n\n    // If the specified method passes the checks or no checks are required, proceed to arm the vehicle\n    update_vehicle_state(ARMED);\n\n    // Set SmartRTL home location if SmartRTL is enabled\n    if (smart_rtl_enabled()) {\n        set_smart_rtl_home();\n    }\n\n    // Initialize simple mode heading, if applicable\n    if (simple_mode_enabled()) {\n        initialize_simple_mode_heading();\n    }\n\n    // Record the home heading for sail vehicles, if applicable\n    if (is_sail_vehicle()) {\n        record_sail_home_heading();\n    }\n\n    // The rover is now soft armed\n    update_soft_armed_status(true);\n\n    // Send arm/disarm status text\n    send_arm_disarm_status_text(\"Armed\");\n\n    return true;\n}\n\nbool AP_Arming_Rover::arming_checks() {\n    // Perform all necessary arming checks here\n    return true; // Placeholder, actual checks should return true only if all checks pass\n}\n\nvoid AP_Arming_Rover::arming_failed_event() {\n    // Log the arming failure or take necessary action\n}\n\nvoid AP_Arming_Rover::update_vehicle_state(bool new_state) {\n    // Update vehicle arming state\n    armed = new_state;\n}\n\nbool AP_Arming_Rover::smart_rtl_enabled() {\n    // Return true if SmartRTL is enabled\n    return true; // Placeholder\n}\n\nvoid AP_Arming_Rover::set_smart_rtl_home() {\n    // Logic to set a new SmartRTL home location\n}\n\nbool AP_Arming_Rover::simple_mode_enabled() {\n    // Return true if simple mode is enabled\n    return false; // Placeholder\n}\n\nvoid AP_Arming_Rover::initialize_simple_mode_heading() {\n    // Logic to initialize heading for simple mode\n}\n\nbool AP_Arming_Rover::is_sail_vehicle() {\n    // Check if the vehicle is a sail type\n    return false; // Placeholder\n}\n\nvoid AP_Arming_Rover::record_sail_home_heading() {\n    // Logic to record home heading for sail vehicles\n}\n\nvoid AP_Arming_Rover::update_soft_armed_status(bool status) {\n    // Update the `soft_armed` status of the vehicle\n    soft_armed = status;\n}\n\nvoid AP_Arming_Rover::send_arm_disarm_status_text(const char* text) {\n    // Send a textual status message about arming or disarming\n}", "CodeBleu_score": 39.756717719105296}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "#include <stdio.h>\n#include <time.h> // To use time and clock functions\n\n// Global variable to store the last time charging was disabled\ntime_t lastTimeChargingDisabled = 0;\nconst int RETRY_DELAY_SECONDS = 30; // Charging retry delay of 30 seconds\n\n// Mock functions to demonstrate the principles (actual implementation would depend on specific hardware and requirements)\nint charging_allowed = 1; // Assume this flag is controlled elsewhere in the full system\n\nvoid disableCharging() {\n    printf(\"Charging disabled.\\n\");\n    lastTimeChargingDisabled = time(NULL);\n}\n\nvoid enableCharging() {\n    printf(\"Charging enabled.\\n\");\n}\n\nint conditionsAreMetToEnableCharging() {\n    // Assuming some conditions need to be checked, return 1 (true) if conditions are met, otherwise 0 (false).\n    // For demonstration, let's consider a dummy condition that changes arbitrarily.\n    return charging_allowed; // Here we simply use the charging_allowed for demonstration.\n}\n\nvoid updateChargingEnabled() {\n    if (charging_allowed) {\n        if (!conditionsAreMetToEnableCharging()) {\n            disableCharging();\n        } else {\n            enableCharging();\n        }\n    } else {\n        // Get the current time\n        time_t currentTime = time(NULL);\n        // Check how long it has been since charging was disabled\n        double secondsSinceDisabled = difftime(currentTime, lastTimeChargingDisabled);\n\n        // If the time since last disabled is greater than the retry delay, recheck the conditions to possibly enable charging.\n        if (secondsSinceDisabled >= RETRY_DELAY_SECONDS) {\n            if (conditionsAreMetToEnableCharging()) {\n                enableCharging();\n            }\n        } else {\n            printf(\"Charging is not allowed yet. Please wait...\\n\");\n        }\n    }\n}", "CodeBleu_score": 46.69215594532851}, {"code": "C\n#include <stdbool.h>\n#include <time.h>\n#include <stdio.h>\n\n// Simulated external controls (should be adapted for actual hardware I/O or control functions)\nbool getChargingAllowedStatus() {\n    // Implementation-specific condition; this is a placeholder.\n    return true;  // Just returning true as a mock-up which indicates that charging is allowed.\n}\n\nvoid disableCharging() {\n    printf(\"Charging disabled.\\n\");\n}\n\nvoid enableCharging() {\n    printf(\"Charging enabled.\\n\");\n}\n\n// Global variable to keep track of the last disabled time\ntime_t lastChargingDisabledTime;\n\n// The delay constant in seconds; adjust based on requirements\nconst int CHARGING_RETRY_DELAY = 60;\n\nvoid updateChargingEnabled() {\n    static bool isChargingEnabled = false;   // Keep track of the current charging state.\n\n    bool chargingAllowed = getChargingAllowedStatus();\n\n    if (chargingAllowed) {\n        if (isChargingEnabled) {\n            printf(\"Charging continues to be allowed and enabled.\\n\");\n        } else {\n            enableCharging();\n            isChargingEnabled = true;\n        }\n    } else {\n        if (isChargingEnabled) {\n            disableCharging();\n            lastChargingDisabledTime = time(NULL);\n            isChargingEnabled = false;\n        } else {\n            time_t currentTime = time(NULL);\n            // Check if sufficient time has passed to retry enabling charging\n            if (difftime(currentTime, lastChargingDisabledTime) >= CHARGING_RETRY_DELAY) {\n                printf(\"Retry delay passed. Checking to enable charging...\\n\");\n                // Retry enable condition should be invoked here but assuming same condition\n                enableCharging();\n                isChargingEnabled = true;\n            } else {\n                printf(\"Charging retry delay not yet passed.\\n\");\n            }\n        }\n    }\n}", "CodeBleu_score": 47.052526254132424}, {"code": "#include <iostream>\n#include <chrono>\n\n// Variables to simulate the situation:\nbool chargingAllowed;\nbool isCurrentlyCharging;\nstd::chrono::system_clock::time_point lastDisableTime;\nconst std::chrono::seconds retryDelay(10);  // Retry every 10 seconds\n\nvoid disableCharging() {\n    if (isCurrentlyCharging) {\n        isCurrentlyCharging = false;\n        lastDisableTime = std::chrono::system_clock::now();\n        std::cout << \"Charging disabled.\" << std::endl;\n    }\n}\n\nvoid enableCharging() {\n    if (!isCurrentlyCharging) {\n        isCurrentlyCharging = true;\n        std::cout << \"Charging enabled.\" << std::endl;\n    }\n}\n\nvoid updateChargingEnabled() {\n    if (chargingAllowed) {\n        if (!isCurrentlyCharging) {\n            enableCharging();\n        }\n    } else {\n        auto now = std::chrono::system_clock::now();\n        auto timeSinceLastDisable = std::chrono::duration_cast<std::chrono::seconds>(now - lastDisableTime);\n        if (isCurrentlyCharging || timeSinceLastDisable >= retryDelay) {\n            disableCharging();\n        }\n    }\n}", "CodeBleu_score": 41.355899400298725}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stddef.h>\n\n/* Assuming these external functions are available based on the expected operations */\nextern bool isROSRunning(); // External function to check if ROS is running\nextern uint32_t calculateCRC32(uint8_t *data, size_t length); // External function to calculate CRC32\nextern void packetSerialSend(uint8_t *packet, size_t length); // External function to send packet\n\nvoid sendMessage(void *message, size_t size) {\n    // Minimum size check\n    const size_t minSize = 4;\n\n    if (!isROSRunning()) {\n        printf(\"ROS is not running.\\n\");\n        return;\n    }\n\n    if (size < minSize) {\n        printf(\"Message size is too small. Must be at least 4 bytes.\\n\");\n        return;\n    }\n\n    // Calculate CRC32 of the message\n    uint32_t crc = calculateCRC32((uint8_t *)message, size);\n\n    // Allocate space for message + CRC\n    size_t totalSize = size + sizeof(crc);\n    uint8_t *packet = (uint8_t *) malloc(totalSize);\n    if (packet == NULL) {\n        printf(\"Failed to allocate memory for the packet.\\n\");\n        return;\n    }\n\n    // Copy original message to packet\n    memcpy(packet, message, size);\n\n    // Append CRC to the end of the message\n    memcpy(packet + size, &crc, sizeof(crc));\n\n    // Send the packet\n    packetSerialSend(packet, totalSize);\n\n    // Free the allocated memory\n    free(packet);\n    printf(\"Message sent successfully.\\n\");\n}", "CodeBleu_score": 28.01248991940964}, {"code": "#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\n// Placeholder function to check if ROS is running\nbool isROSRunning() {\n    // Implementation specific to your system\n    return true;\n}\n\n// Placeholder for CRC calculation function\nuint32_t calculateCRC(void *data, size_t size) {\n    uint32_t crc = 0;\n    uint8_t *byte = (uint8_t *)data;\n    for (size_t i = 0; i < size; i++) {\n        crc += byte[i];  // Very simple CRC calculation, replace with a better one\n    }\n    return crc;\n}\n\n// Placeholder function to send data using PacketSerial\nvoid packetSerialSend(void *data, size_t size) {\n    // Actual implementation depends on the specifics of packetSerial\n}\n\nvoid sendMessage(void *message, size_t size) {\n    if (!isROSRunning()) {\n        // ROS is not running, return without sending message\n        return;\n    }\n\n    if (size < 4) {\n        // Message size is too small\n        return;\n    }\n\n    // Calculate CRC\n    uint32_t crc = calculateCRC(message, size);\n\n    // Extend the message with the CRC\n    size_t newSize = size + sizeof(crc);\n    uint8_t *fullMessage = (uint8_t *)malloc(newSize);\n    if (fullMessage == NULL) {\n        // Failed to allocate memory\n        return;\n    }\n\n    // Copy original message\n    memcpy(fullMessage, message, size);\n    // Append CRC at the end\n    memcpy(fullMessage + size, &crc, sizeof(crc));\n\n    // Send the full message\n    packetSerialSend(fullMessage, newSize);\n\n    // Clean up allocated memory\n    free(fullMessage);\n}", "CodeBleu_score": 40.51314710146458}, {"code": "#include <stddef.h>\n\n// Import or define your packet serial communication tools and CRC calculation functions\n#include \"packetSerial.h\"\n#include \"crc.h\"\n\n// Define a function to check if ROS is running (could be based on specific system checks)\nbool isROSRunning() {\n    // Implement based on your specific requirements\n    // This could involve checking service status, inter-process communication, etc.\n    return true; // Assuming it's true for simplicity\n}\n\nvoid sendMessage(void *message, size_t size) {\n    if (!isROSRunning()) {\n        // If ROS is not running, just skip the sending process\n        return;\n    }\n\n    if(size < 4) {\n        // Message too short to be processed\n        return;\n    }\n\n    // Assuming a function exists to calculate CRC\n    unsigned int crc = calculateCRC(message, size);\n\n    // Assuming a packetSerial function exists that can take a buffer with combined data (message + CRC)\n    // Additionally, you'll need a way to append CRC to the message\n    // Ensuring there's enough buffer size to append CRC\n    size_t totalSize = size + sizeof(crc);\n    unsigned char *buffer = (unsigned char *)malloc(totalSize);\n    if (buffer) {\n        // Copy original message to buffer\n        memcpy(buffer, message, size);\n        // Copy CRC right after the message\n        memcpy(buffer + size, &crc, sizeof(crc));\n\n        // Sending the message with the appended CRC\n        packetSerialSend(buffer, totalSize);\n\n        // Free the allocated buffer\n        free(buffer);\n    }\n}", "CodeBleu_score": 38.21317646827222}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "#include <HardwareSerial.h>\n\nbool MP3Sound::begin() {\n    // Initial serial communication setup for the sound module\n    Serial.begin(9600);\n    \n    // Waiting for the serial port to be ready\n    while (!Serial) {\n        ; // Wait here until the serial port is ready\n    }\n\n    // Clear any data from previous communications\n    while (Serial.available() > 0) {\n        Serial.read();\n    }\n\n    // Initialize sound module with initial setup command\n    // Assuming a command function exists to send commands to the module.\n    sendCommand(INITIALIZE_SOUND_MODULE);\n\n    // Wait for the sound module to complete initialization\n    delay(1000); // Adjust according to the module requirements\n\n    // Request the number of sound files on the SD card\n    sendCommand(REQUEST_SOUND_COUNT);\n\n    // Wait for the response from the sound module\n    unsigned long startTime = millis();\n    while (!Serial.available()) {\n        if (millis() - startTime > 5000) { // Super simple timeout of 5 seconds\n            return false; // Initialization failed\n        }\n    }\n\n    // Read the count of sound files\n    int soundFileCount = Serial.read(); // Assuming the count is sent as a single byte\n\n    // Check if there are sound files on the SD card\n    if (soundFileCount > 0) {\n        return true; // Successful initialization\n    }\n\n    return false; // Initialization failed due to no sound files found\n}", "CodeBleu_score": 43.68752316876194}, {"code": "#include <SoftwareSerial.h>\n\n// Assuming a SoftwareSerial object named 'mp3Serial' for communication was declared elsewhere\n// and MP3-related commands are defined (like MP3_PLAY, MP3_STOP, etc.)\n\nbool MP3Sound::begin() {\n  // Start by setting up serial communication at the appropriate baud rate\n  mp3Serial.begin(9600);  // 9600 Bps is a common baud rate for MP3 modules\n  \n  // Clear existing data in the buffer\n  while (mp3Serial.available()) {\n    mp3Serial.read();\n  }\n  \n  // Send command to initialize sound module (assumed command: this might not be necessary depending on the module)\n  // For example, sending a reset or start command:\n  mp3Serial.write(MP3_RESET);  // Let's assume MP3_RESET is the command to reset/init the module\n  \n  // Give some time to the module to initialize\n  delay(1000);  // Wait for 1 second\n\n  // Check if there are sound files on the SD card (depends on how you can retrieve this info from the module)\n  mp3Serial.write(MP3_GET_COUNT);  // Let's assume MP3_GET_COUNT sends a request to get the number of tracks\n  delay(500);  // Wait for the module to respond\n  \n  // Read the response from the sound module\n  if (mp3Serial.available()) {\n    int fileCount = mp3Serial.read();  // Read the number of files (simplistic example)\n    \n    // Apply real logic to parse file count here, based on your sound module's protocol\n    \n    // Return true if one or more files exist\n    return fileCount > 0;\n  }\n\n  // In case no data is available or no files are found\n  return false;\n}", "CodeBleu_score": 46.55056629311306}, {"code": "#include \"MP3Sound.h\"\n\n// Assuming that this part of the MP3Sound class is connected to some hardware serial port, for example, Serial1\n\nbool MP3Sound::begin() {\n    // Initialize serial communication at a common baud rate for MP3 modules\n    Serial1.begin(9600);\n    \n    // Waiting for the serial port to initialize\n    delay(100);\n    \n    // Clear any noise or residual data in the serial buffer\n    while (Serial1.available()) {\n        Serial1.read();\n    }\n\n    // Send command to the sound module to reset it, assuming common MP3 player module command\n    // This is often necessary to ensure the module starts in a known state\n    Serial1.write(0x7E); // Start byte\n    Serial1.write(0xFF); // Version information\n    Serial1.write(0x06); // Length of the command\n    Serial1.write(0x0C); // Command to reset the module\n    Serial1.write(0x00); // Feedback request\n    Serial1.write(0x00); // Parameter filler\n    Serial1.write(0x00); // Parameter filler\n    Serial1.write(0xEF); // End byte\n    delay(500);  // Wait for the module to reset\n\n    // Request number of files in the SD card\n    Serial1.write(0x7E);\n    Serial1.write(0xFF);\n    Serial1.write(0x06);\n    Serial1.write(0x48); // Command to read number of files\n    Serial1.write(0x00);\n    Serial1.write(0x00);\n    Serial1.write(0x00);\n    Serial1.write(0xEF);\n    delay(100);\n\n    // Read response from module. Assume simple response structure: {0x7E, 0xFF, num_files, 0xEF}\n    byte response[10];\n    int index = 0;\n    unsigned long startMillis = millis();\n    while ((millis() - startMillis < 1000) && index < 10) {  // Timeout after 1 second\n        if (Serial1.available()) {\n            response[index++] = Serial1.read();\n        }\n    }\n\n    // Check response validity and extract number of files\n    if (index > 3) {\n        // Assuming the third byte in the response is the number of available files\n        int num_files = response[2];\n        return num_files > 0;\n    } else {\n        // No valid response\n        return false;\n    }\n}\n\n// You need to adjust the commands and perhaps handle different MP3 sound modules differently.\n// This code also assumes the responses from the module are in a certain format which might not be the case.", "CodeBleu_score": 43.70801806239378}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "class MP3Sound {\nprivate:\n    std::list<std::string> activeSounds;   // List to store active sounds\n    bool isMP3Playing;                     // Flag to check if an MP3 is currently playing\n\npublic:\n    // Declare the function within the class, assuming other methods are implemented elsewhere\n    int processSounds();\n\n    // Mock functions to demonstrate functionality\n    void playSound(std::string sound) {\n        std::cout << \"Playing sound: \" << sound << std::endl;\n    }\n\n    void removeSound(std::string sound) {\n        activeSounds.remove(sound);\n        std::cout << \"Sound removed: \" << sound << std::endl;\n    }\n};\n\nint MP3Sound::processSounds() {\n    int numActiveSounds = activeSounds.size();\n\n    // Return the number of active sounds if list is empty or an MP3 is currently playing\n    if (numActiveSounds == 0 || isMP3Playing) {\n        return numActiveSounds;\n    }\n\n    // If there are active sounds and no MP3 playing, process and remove the last sound\n    if (!activeSounds.empty()) {\n        std::string lastSound = activeSounds.back(); // Get the last sound from the list\n        playSound(lastSound);                       // Play the extracted sound\n        removeSound(lastSound);                     // Remove the played sound from the list\n        numActiveSounds = activeSounds.size();      // Update the count after removal\n    }\n\n    return numActiveSounds; // Return the updated number of active sounds\n}", "CodeBleu_score": 42.26493474857719}, {"code": "#include <list>\n#include <iostream>\nusing namespace std;\n\nclass MP3Sound {\npublic:\n    list<string> activeSounds;\n    bool isMP3Playing;\n\n    MP3Sound() : isMP3Playing(false) {}\n\n    // Processes the active sounds according to the rules specified\n    int processSounds() {\n        int count = activeSounds.size();\n        \n        // If there are no sounds or an MP3 is currently playing\n        if (activeSounds.empty() || isMP3Playing) {\n            return count;  // Return the number of active sounds\n        }\n\n        // If an MP3 is not currently playing...\n        if (!isMP3Playing && !activeSounds.empty()) {\n            // Retrieve the last sound\n            string soundToPlay = activeSounds.back();\n            activeSounds.pop_back();   // Remove it from the list\n\n            // Mock playing sound\n            cout << \"Playing sound: \" << soundToPlay << endl;\n\n            // Update the playing status if applicable\n            isMP3Playing = true; // Set MP3 playing to true while sound is being played\n            // Once done, you would set it back to false, potentially after the sound finishes\n        }\n\n        // Return the updated number of active sounds\n        return activeSounds.size();\n    }\n\n    // Adds a sound to the pool of active sounds\n    void addSound(const string& sound) {\n        activeSounds.push_back(sound);\n    }\n\n    // Stops MP3 playback\n    void stopMP3() {\n        isMP3Playing = false;\n    }\n};\n\nint main() {\n    MP3Sound player;\n    player.addSound(\"sound1\");\n    player.addSound(\"sound2\");\n    player.addSound(\"sound3\");\n\n    // Before playing a sound\n    cout << \"Processing sounds...\\n\";\n    int remainingSounds = player.processSounds(); // process and decrease active sounds by one\n    cout << remainingSounds << \" sounds left\\n\";\n\n    // To simulate another state, stop the MP3\n    player.stopMP3();\n\n    // Process again\n    cout << \"Processing sounds...\\n\";\n    remainingSounds = player.processSounds();  // process another sound\n    cout << remainingSounds << \" sounds left\\n\";\n\n    return 0;\n}", "CodeBleu_score": 36.994912466264026}, {"code": "#include <vector>\n#include <string>\n\nclass MP3Sound {\n    std::vector<std::string> activeSounds; // List of active sounds\n    bool isMP3Playing; // Flag to indicate if an MP3 is currently playing\n\npublic:\n    MP3Sound() : isMP3Playing(false) {}\n\n    // Method to simulate MP3 playing\n    void playSound(const std::string& sound) {\n        std::cout << \"Playing sound: \" << sound << std::endl;\n        isMP3Playing = true;\n    }\n\n    // Method to simulate MP3 stopping\n    void stopMP3() {\n        isMP3Playing = false;\n    }\n\n    // Add sound to active list\n    void addSound(const std::string& sound) {\n        activeSounds.push_back(sound);\n    }\n\n    // Process and manage the sounds\n    int processSounds() {\n        // Check if there are active sounds or if an MP3 is already playing\n        if (activeSounds.empty() || isMP3Playing) {\n            return activeSounds.size(); // Return count of active sounds if no more processing is needed\n        }\n\n        // Retrieve and process the last sound from the list\n        std::string soundToPlay = activeSounds.back();\n        activeSounds.pop_back();\n        \n        playSound(soundToPlay);\n        \n        return activeSounds.size(); // Return the updated count of active sounds after one has been played\n    }\n};", "CodeBleu_score": 43.41165611026104}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "#include <stdbool.h> // Including standard boolean library for bool type\n\n// Declaration/Signature of the wb_abstract_camera_handle_command function\nbool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command) {\n    bool command_handled = true;  // Default assumption that command will be handled\n    \n    switch (command) {\n        case C_CAMERA_MEMORY_MAPPED_FILE:\n            {\n                // Assuming the device d has a function to reset its memory-mapped file\n                if (d->memory_mapped_file) {\n                    // Free the existing memory-mapped file\n                    free_memory_mapped_file(d->memory_mapped_file);\n                    d->memory_mapped_file = NULL;\n                }\n                \n                // Now set up a new memory-mapped file based on the request r\n                d->memory_mapped_file = create_memory_mapped_file_from_request(r);\n                \n                // Assuming create_memory_mapped_file_from_request returns NULL if it fails\n                if (d->memory_mapped_file == NULL) {\n                    command_handled = false; // Indicate failure to handle the command if file creation failed\n                }\n            }\n            break;\n        \n        default:\n            command_handled = false;  // Any other command is not handled\n            break;\n    }\n    \n    return command_handled; // Returning whether the command was handled or not\n}", "CodeBleu_score": 63.88390837895539}, {"code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n// Assuming necessary structures and symbolic constants are defined elsewhere\ntypedef struct {\n    // Device structure may have various properties for a camera\n    void *memory_mapped_file;  // Just an example member\n} WbDevice;\n\ntypedef struct {\n    // Request structure might contain necessary information to update a device\n    void *data;  // Data needed for commands, e.g., memory mapped file setup\n} WbRequest;\n\n// Symbolic constant for the camera command to handle memory mapped file actions\n#define C_CAMERA_MEMORY_MAPPED_FILE 1\n\nbool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command) {\n    if (!d || !r) {\n        printf(\"Invalid device or request.\\n\");\n        return false;\n    }\n\n    bool command_handled = true;\n\n    switch (command) {\n        case C_CAMERA_MEMORY_MAPPED_FILE:\n            // Cleanup existing memory-mapped file\n            if (d->memory_mapped_file) {\n                // Presumably deallocates or closes the file; the exact mechanics depend on the system\n                free(d->memory_mapped_file);\n                d->memory_mapped_file = NULL;\n            }\n\n            // Set up a new memory-mapped file\n            // Assuming r->data provides the necessary setup information\n            d->memory_mapped_file = malloc(sizeof(r->data));  // As an example\n            memcpy(d->memory_mapped_file, r->data, sizeof(r->data));  // Assuming this copies adequate info\n\n            printf(\"Memory-mapped file has been set up successfully.\\n\");\n            break;\n\n        default:\n            // If command is not recognized, mark it as not handled\n            command_handled = false;\n            break;\n    }\n\n    return command_handled;\n}", "CodeBleu_score": 62.665679671252015}, {"code": "#include <stdbool.h>\n\n// Define possible command\n#define C_CAMERA_MEMORY_MAPPED_FILE 0x01\n\n// Prototype for helper functions (assumed to exist)\nvoid cleanup_memory_mapped_file(WbDevice *device);\nvoid setup_memory_mapped_file(WbDevice *device, WbRequest *request);\n\nbool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command) {\n    // Flag to track whether the command was successfully handled\n    bool command_handled = false;\n    \n    // Check the type of command\n    if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n        // Clean up existing memory-mapped file\n        cleanup_memory_mapped_file(d);\n        \n        // Setup a new memory-mapped file using the provided request\n        setup_memory_mapped_file(d, r);\n        \n        // Set command to handled\n        command_handled = true;\n    } else {\n        // For all other commands, do not handle and set flag false\n        command_handled = false;\n    }\n    \n    return command_handled;\n}", "CodeBleu_score": 42.78382035419996}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "#include <stdio.h>\n#include <pthread.h>\n\ntypedef struct {\n    pthread_mutex_t mutex;  // Mutex to protect accessing camera data\n    int height;             // Height of the camera\n    int is_available;       // Flag to indicate if camera data is available\n} CameraData;\n\ntypedef struct {\n    CameraData *camera_data;  // Pointer to camera data\n} WbDevice;\n\nint wb_abstract_camera_get_height(WbDevice *d) {\n    if (d == NULL || d->camera_data == NULL) {\n        return -1;  // Return -1 if the device or camera data is not available\n    }\n    \n    int height = -1;\n    \n    pthread_mutex_lock(&d->camera_data->mutex);\n    \n    // Check if the camera data is available\n    if (d->camera_data->is_available) {\n        height = d->camera_data->height;\n    }\n    \n    pthread_mutex_unlock(&d->camera_data->mutex);\n    \n    return height; // Return the height or -1 if the data is not available\n}", "CodeBleu_score": 35.88735232477693}, {"code": "#include <pthread.h>\n\nint wb_abstract_camera_get_height(WbDevice *d) {\n    if (d == NULL) {\n        return -1; // Return -1 if the device pointer is NULL\n    }\n\n    pthread_mutex_lock(&d->mutex); // Lock the mutex of the device before accessing the data\n    \n    if (d->camera == NULL) {\n        pthread_mutex_unlock(&d->mutex); // Unlock the mutex before returning\n        return -1; // Return -1 if there's no camera data associated with the device\n    }\n\n    int height = d->camera->height; // Get the height from the camera data\n\n    pthread_mutex_unlock(&d->mutex); // Unlock the mutex after accessing the data\n\n    return height; // Return the retrieved height\n}", "CodeBleu_score": 34.01612165032744}, {"code": "int wb_abstract_camera_get_height(WbDevice *d) {\n    if (d == NULL || d->type != WB_CAMERA_TYPE) {\n        // Return -1 if device is not set or the device is not a camera type\n        return -1;\n    }\n\n    int height = -1;\n    pthread_mutex_lock(&d->mutex); // Lock mutex before accessing the device data\n\n    if (d->camera && d->camera->is_initialized) {\n        // If the camera is initialized, get the height\n        height = d->camera->height;\n    }\n\n    pthread_mutex_unlock(&d->mutex); // Always unlock mutex after accessing shared data\n\n    return height;\n}", "CodeBleu_score": 38.353635968746325}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "#include <stdio.h>\n#include <pthread.h>\n\n// A mock representation of an accelerometer data structure\ntypedef struct {\n    int samplingPeriod;\n    int isValid;\n} Accelerometer;\n\n// Global map for mock accelerometer data store and mutex for synchronization\n// Assuming that these will be initialized somewhere else in the program\nextern Accelerometer accelerometers[];\nextern pthread_mutex_t mutex;\n\nint wb_accelerometer_get_sampling_period(WbDeviceTag tag) {\n    int period = -1; // Return -1 to denote invalid tag or error scenario\n\n    // First, lock the mutex\n    pthread_mutex_lock(&mutex);\n\n    // Ensure tag is within valid range and device is marked as valid\n    if (tag >= 0 && accelerometers[tag].isValid) {\n        period = accelerometers[tag].samplingPeriod;\n    } else {\n        // Print error message if tag is invalid or device not valid\n        printf(\"Error: Invalid device tag or device is not valid.\\n\");\n    }\n\n    // Unlock the mutex\n    pthread_mutex_unlock(&mutex);\n\n    // Return the sampling period, or -1 if an error occurred\n    return period;\n}", "CodeBleu_score": 40.62801271082822}, {"code": "#include <stdio.h>\n#include <pthread.h>\n\n// Assume these are part of the API environment\ntypedef int WbDeviceTag;\ntypedef struct {\n    int sampling_period;\n    int valid;\n} Accelerometer;\n\n// Placeholder function to lock and unlock mutex\npthread_mutex_t mutex;\n\n// Placeholder database (simulation)\n#define MAX_DEVICES 10\nAccelerometer accelerometers[MAX_DEVICES] = {{0}};\n\nint wb_accelerometer_init() {\n    pthread_mutex_init(&mutex, NULL);\n    for (int i = 0; i < MAX_DEVICES; i++) {\n        accelerometers[i].valid = (i % 2 == 0);  // Simulate some invalid entries\n        accelerometers[i].sampling_period = 100 * (i + 1);\n    }\n    return 0;\n}\n\nint wb_accelerometer_get_sampling_period(WbDeviceTag tag) {\n    int sampling_period = 0;\n    \n    // Lock the mutex to protect the accelerometer data\n    pthread_mutex_lock(&mutex);\n\n    // Check if the tag is a valid index and the device at that index is valid\n    if (tag < 0 || tag >= MAX_DEVICES || accelerometers[tag].valid == 0) {\n        printf(\"Error: Invalid WbDeviceTag provided.\\n\");\n    } else {\n        sampling_period = accelerometers[tag].sampling_period;\n    }\n\n    // Unlock the mutex\n    pthread_mutex_unlock(&mutex);\n\n    return sampling_period;\n}\n\nint main() {\n    wb_accelerometer_init();\n    printf(\"Sampling Period for Device 1: %d\\n\", wb_accelerometer_get_sampling_period(1));\n    printf(\"Sampling Period for Device 3: %d\\n\", wb_accelerometer_get_sampling_period(3));\n    printf(\"Sampling Period for Device 5: %d\\n\", wb_accelerometer_get_sampling_period(5));\n\n    return 0;\n}", "CodeBleu_score": 45.661237208794056}, {"code": "#include <stdio.h>\n#include <pthread.h>\n\n// Assuming certain structures and functions are already defined elsewhere:\ntypedef int WbDeviceTag;\n\n// Mocking a structure for the accelerometer\ntypedef struct {\n    int sampling_period;\n    int is_valid; // Let's add a flag to check validity of device\n} Accelerometer;\n\n// Function to simulate retrieving an accelerometer with a given device tag\nAccelerometer* get_accelerometer(WbDeviceTag tag) {\n    static Accelerometer accelerometer = {100, 1};  // Example accelerometer\n    if (tag == 1)  // Assume tag 1 is valid\n        return &accelerometer;\n    return NULL;\n}\n\n// Mock mutex for thread safety (assuming it's initialized elsewhere in the code)\npthread_mutex_t mutex;\n\nint wb_accelerometer_get_sampling_period(WbDeviceTag tag) {\n    int sampling_period = -1;  // Default invalid sampling period\n    pthread_mutex_lock(&mutex);  // Lock the mutex\n\n    Accelerometer* accelerometer = get_accelerometer(tag);\n    if (accelerometer) {\n        if (accelerometer->is_valid) {\n            sampling_period = accelerometer->sampling_period;\n        } else {\n            printf(\"Error: Accelerometer with tag %d is invalid.\\n\", tag);\n        }\n    } else {\n        printf(\"Error: No accelerometer found with tag %d.\\n\", tag);\n    }\n\n    pthread_mutex_unlock(&mutex);  // Unlock the mutex\n    return sampling_period;\n}", "CodeBleu_score": 46.72000601737737}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "#include <string>\n\nclass GPS {\npublic:\n    std::string convertToDegreesMinutesSeconds(double decimalDegree) {\n        char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n        std::string dmsStr(dms);\n        wb_free_memory(dms);\n        return dmsStr;\n    }\n\nprivate:\n    char* wb_gps_convert_to_degrees_minutes_seconds(double dd) {\n        // This is a simulated internal function for conversion. It should be provided by the actual environment.\n        int degrees = int(dd);\n        double decimalMinutes = (dd - degrees) * 60;\n        int minutes = int(decimalMinutes);\n        double seconds = (decimalMinutes - minutes) * 60;\n\n        int bufferSize = 30;\n        char* buffer = new char[bufferSize];\n        snprintf(buffer, bufferSize, \"%d\u00b0%d\\'%f\\\"\", degrees, minutes, seconds);\n        return buffer;\n    }\n\n    void wb_free_memory(char* ptr) {\n        delete[] ptr;\n    }\n};", "CodeBleu_score": 36.33579611510724}, {"code": "#include <string>\n\n// Assuming the presence of such a function, perhaps from an API\nextern \"C\" char* wb_gps_convert_to_degrees_minutes_seconds(double decimal);\n\nclass GPS {\npublic:\n    std::string convertToDegreesMinutesSeconds(double decimalDegree);\n};\n\nstd::string GPS::convertToDegreesMinutesSeconds(double decimalDegree) {\n    // Call the conversion function\n    char* dms_cstr = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\n    // Convert C-style string to std::string for safer and easier to manage string\n    std::string dms_string(dms_cstr);\n\n    // Memory allocated by wb_gps_convert_to_degrees_minutes_seconds must be freed\n    free(dms_cstr);\n\n    // Return the DMS string\n    return dms_string;\n}", "CodeBleu_score": 46.61841610504594}, {"code": "#include <string>\n#include <webots/GPS.hpp>\n\nusing namespace std;\n\n// Assuming wb_gps_convert_to_degrees_minutes_seconds exists and requires manual memory management\nextern char *wb_gps_convert_to_degrees_minutes_seconds(double decimalDegree);\n\nstring GPS::convertToDegreesMinutesSeconds(double decimalDegree) {\n    // Call the external Webots function to convert the degree\n    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    \n    // Convert the C string to a C++ std::string\n    string dmsString(dms);\n    \n    // Free the allocated C string memory\n    delete [] dms;\n    \n    // Return the DMS string\n    return dmsString;\n}", "CodeBleu_score": 46.70813365534365}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "#include <math.h>\n#include <assert.h>\n\n// Assume the function to check if the ID is for a box geometry\nbool isBox(dGeomID g);\n\n// Function to get box dimensions: half-lengths along x, y, z\nvoid dGeomBoxGetLengths(dGeomID g, dVector3 lengths);\n\n// Function to get the position of the box's geometric center\nvoid dGeomGetPosition(dGeomID g, dVector3 position);\n\nvoid dGeomBoxGetTangentPlane(dGeomID g, dReal x, dReal y, dReal z, dVector4 plane) {\n    assert(isBox(g));  // Ensure that the geometry is a box\n\n    dVector3 center;\n    dVector3 lengths;\n    dGeomGetPosition(g, center);\n    dGeomBoxGetLengths(g, lengths);\n\n    // Calculate the point relative to the box center\n    dReal rx = x - center[0];\n    dReal ry = y - center[1];\n    dReal rz = z - center[2];\n\n    // Determine which face of the box the point is closest to\n    // and assign the appropriate normal and distance\n    dReal nx = 0, ny = 0, nz = 0;\n    dReal distance;\n\n    // Check minimum distance to each face in the box coordinate system\n    dReal minDist = fabs(rx) - lengths[0];\n    nx = rx > 0 ? 1 : -1;\n    ny = 0;\n    nz = 0;\n    distance = minDist;\n    \n    dReal tempDist = fabs(ry) - lengths[1];\n    if (tempDist < minDist) {\n        nx = 0;\n        ny = ry > 0 ? 1 : -1;\n        nz = 0;\n        distance = tempDist;\n        minDist = tempDist;\n    }\n    \n    tempDist = fabs(rz) - lengths[2];\n    if (tempDist < minDist) {\n        nx = 0;\n        ny = 0;\n        nz = rz > 0 ? 1 : -1;\n        distance = tempDist;\n    }\n\n    // Set the resulting plane equation coefficients\n    plane[0] = nx;\n    plane[1] = ny;\n    plane[2] = nz;\n\n    // Compute actual distance to origin: dot product of point with normal minus box face offset\n    plane[3] = nx * x + ny * y + nz * z - (fabs(nx) * lengths[0] + fabs(ny) * lengths[1] + fabs(nz) * lengths[2]);\n}", "CodeBleu_score": 33.692958723284384}, {"code": "void dGeomBoxGetTangentPlane(dGeomID g, dReal x, dReal y, dReal z, dVector4 plane) {\n    // Ensure g represents a box geometry\n    if (dGeomGetClass(g) != dBoxClass) {\n        printf(\"Geometry is not a box.\\n\");\n        return;\n    }\n\n    // Dimensions of the box (half lengths)\n    dReal lengths[3];\n    dGeomBoxGetLengths(g, lengths);\n    dReal lx = lengths[0] / 2.0;\n    dReal ly = lengths[1] / 2.0;\n    dReal lz = lengths[2] / 2.0;\n\n    // Center of the box\n    const dReal* pos = dGeomGetPosition(g);\n    dReal cx = pos[0];\n    dReal cy = pos[1];\n    dReal cz = pos[2];\n\n    // Compute relative position from the center of the box\n    dReal dx = x - cx;\n    dReal dy = y - cy;\n    dReal dz = z - cz;\n\n    // Normalize direction to check proximity\n    dReal abs_dx = fabs(dx);\n    dReal abs_dy = fabs(dy);\n    dReal abs_dz = fabs(dz);\n\n    // Initialize plane normal and distance\n    plane[3] = 0; // distance from the origin\n\n    // Check which side of the box the point lies closest to.\n    // Compare with half extents in each direction, use normalized coordinates (abs_dx, abs_dy, abs_dz) to determine closest face\n    if (abs_dx > abs_dy && abs_dx > abs_dz) {\n        plane[0] = dx > 0 ? 1 : -1; \n        plane[1] = 0;\n        plane[2] = 0;\n        plane[3] = abs_dx - lx; // Distance from the closest face\n    } else if (abs_dy > abs_dx && abs_dy > abs_dz) {\n        plane[0] = 0;\n        plane[1] = dy > 0 ? 1 : -1;\n        plane[2] = 0;\n        plane[3] = abs_dy - ly; // Distance from the closest face\n    } else {\n        plane[0] = 0;\n        plane[1] = 0;\n        plane[2] = dz > 0 ? 1 : -1;\n        plane[3] = abs_dz - lz; // Distance from the closest face\n    }\n\n    // Adjust the plane distance to be in terms of the distance from the surface, not the center\n    plane[3] += (plane[0] * cx + plane[1] * cy + plane[2] * cz);\n}", "CodeBleu_score": 33.68646112987154}, {"code": "#include <math.h>\n#include <assert.h>\n\ntypedef struct dGeomID_t {\n    double length;\n    double width;\n    double height;\n    double posX;\n    double posY;\n    double posZ;\n} *dGeomID;\n\ntypedef double dVector4[4];\n\n/* Returns the absolute value. */\ndouble dAbs(double val) {\n    return val > 0 ? val : -val;\n}\n\n/* Updates the plane equation parameters. */\nvoid updatePlane(dVector4 plane, double a, double b, double c, double d) {\n    plane[0] = a;\n    plane[1] = b;\n    plane[2] = c;\n    plane[3] = d;\n}\n\nvoid dGeomBoxGetTangentPlane(dGeomID g, double x, double y, double z, dVector4 plane) {\n    assert(g != NULL);\n    \n    // Calculate the center of the box\n    double centerX = g->posX;\n    double centerY = g->posY;\n    double centerZ = g->posZ;\n    \n    // Calculate relative coordinates from the center of the box\n    double relX = x - centerX;\n    double relY = y - centerY;\n    double relZ = z - centerZ;\n    \n    // Get half lengths of the box dimensions\n    double halfLength = g->length / 2.0;\n    double halfWidth = g->width / 2.0;\n    double halfHeight = g->height / 2.0;\n    \n    // Calculating minimal distances to each face\n    double distToLength = dAbs(halfLength - dAbs(relX));\n    double distToWidth = dAbs(halfWidth - dAbs(relY));\n    double distToHeight = dAbs(halfHeight - dAbs(relZ));\n    \n    // Determine which face is the closest to the given point\n    if (distToLength <= distToWidth && distToLength <= distToHeight) {\n        // The point is closest to one of the length faces\n        int sign = (relX > 0) ? 1 : -1;\n        updatePlane(plane, sign, 0, 0, sign * (centerX + sign * halfLength));\n    } else if (distToWidth <= distToLength && distToWidth <= distToHeight) {\n        // The point is closest to one of the width faces\n        int sign = (relY > 0) ? 1 : -1;\n        updatePlane(plane, 0, sign, 0, sign * (centerY + sign * halfWidth));\n    } else {\n        // The point is closest to one of the height faces\n        int sign = (relZ > 0) ? 1 : -1;\n        updatePlane(plane, 0, 0, sign, sign * (centerZ + sign * halfHeight));\n    }\n}", "CodeBleu_score": 29.16290487563663}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "/*\n * This function, dImmerseBox, checks the immersion of a dxBox object in a fluid plane.\n * It asserts that the box has a body and the flags are valid.\n * It initializes an sBoxImmersionData object with the box, fluid plane, immersion, and flags.\n * Finally, it performs the immersion checking and returns the result.\n */\nint dImmerseBox(dxBox *box, const dReal *fluidPlane, int flags, dImmersionGeom *immersion) {\n    // Ensure that the provided box is not NULL and it has an associated body\n    if (box == NULL || box->body == NULL) {\n        fprintf(stderr, \"Box or box body is NULL.\\n\");\n        return 0;\n    }\n\n    // Validate the provided flags (assuming specific flags need to be checked)\n    const int VALID_FLAGS_MASK = 0x03; // Example flag mask, adjust based on valid flags\n    if ((flags & VALID_FLAGS_MASK) != flags) {\n        fprintf(stderr, \"Invalid flags provided.\\n\");\n        return 0;\n    }\n\n    // Initialize immersion data\n    sBoxImmersionData immersionData;\n    immersionData.box = box;\n    immersionData.fluidPlane = fluidPlane;\n    immersionData.flags = flags;\n    immersionData.immersion = immersion;\n\n    // Check if the box is immersed by comparing it against the fluid plane\n    // This is a simplified placeholder logic - a real implementation would need actual geometry checks\n    dReal planeHeight = fluidPlane[3];\n    dReal boxBaseHeight = box->pos[2] - box->lengths[2] / 2;\n    if (boxBaseHeight < planeHeight) {\n        immersion->depth = planeHeight - boxBaseHeight;\n        immersion->immersed = true;\n        return 1; // Box is immersed\n    } else {\n        immersion->depth = 0;\n        immersion->immersed = false;\n        return 0; // Box is not immersed\n    }\n}", "CodeBleu_score": 38.579768794797516}, {"code": "#include <assert.h>\n\n/*\n * Assume the following definitions exist based on the context:\n *\n * typedef struct dxBox {\n *   dBody *body;                   // Pointer to the box's body (dynamics)\n *   dReal dimensions[3];           // Dimensions of the box\n * } dxBox;\n *\n * typedef struct {\n *   dReal normal[4];               // Fluid plane definition: normal[0..2] = normal vector, normal[3] = distance\n * } dPlane;\n\n * typedef struct {\n *   dxBox *box;                    // Box being tested for immersion\n *   dPlane *fluidPlane;            // Fluid plane definition\n *   dImmersionGeom *immersion;     // Information about immersion \n *   int flags;                     // Additional flags controlling the operations\n * } sBoxImmersionData;\n *\n * typedef struct {\n *   double depth;                  // The depth of immersion\n * } dImmersionGeom;\n *\n */\n\n// Define a dummy IMMERSION_CHECK_SUCCESS constant\n#define IMMERSION_CHECK_SUCCESS 1\n#define IMMERSION_CHECK_FAIL 0\n\nint boxImmersionChecker(sBoxImmersionData *data) {\n    // A dummy function that performs a quick check.\n    // It should be implemented with actual physics calculations.\n    // Here, we assume a simplified check: if body is non-null and flags are okay, return success.\n    if (data->box && data->box->body) {\n        return IMMERSION_CHECK_SUCCESS;\n    } else {\n        return IMMERSION_CHECK_FAIL;\n    }\n}\n\nint dImmerseBox(dxBox *box, const dReal *fluidPlane, int flags, dImmersionGeom *immersion) {\n    assert(box && \"dxBox instance must not be NULL\");\n    assert(fluidPlane && \"Fluid plane must not be NULL\");\n    assert(box->body && \"dxBox must have associated body\");\n    \n    // Validate flags as a basic check (flags could be used to define behavior but we assume if it's non-zero, it's valid in this example)\n    assert(flags != 0 && \"Flags must be set for the immersion process\");\n    \n    // Prepare data for immersion checking\n    sBoxImmersionData immersionData;\n    immersionData.box = box;\n    immersionData.fluidPlane = (dPlane *)fluidPlane;\n    immersionData.immersion = immersion;\n    immersionData.flags = flags;\n\n    // Perform immersion checking\n    return boxImmersionChecker(&immersionData);\n}", "CodeBleu_score": 39.92277730055721}, {"code": "#include <assert.h>\n\n/*\n * Represents a geometric box that can be immersed into a fluid.\n */\ntypedef struct dxBox {\n    void *body;  // Simplified assumption: the body is represented as a generic pointer.\n} dxBox;\n\n/*\n * Plane equation represented in the form: ax + by + cz + d = 0\n */\ntypedef double dReal;  // Assuming dReal is defined somewhere as a kind of float or double.\n\n/*\n * Flags managing how the immersion is calculated or what specifics to consider.\n */\ntypedef int dImmersionFlags;  // Flags represented as integers for simplicity.\n\n/*\n * Struct holding immersion results (volume, submerged surface area, etc.)\n */\ntypedef struct dImmersionGeom {\n    double volume;  // Simplified assumption: stores the computed volume of immersed part.\n} dImmersionGeom;\n\n/*\n * Checks and calculates the immersion of a box in a fluid where the fluid surface is defined by a plane.\n * The function assumes body and flag validation is critical, and a placeholder for proper flag handling is added.\n */\nint dImmerseBox(dxBox *box, const dReal *fluidPlane, int flags, dImmersionGeom *immersion) {\n    assert(box != NULL);  // Ensure the box is not a NULL pointer.\n    assert(box->body != NULL);  // Ensure the box has an associated body.\n    assert(fluidPlane != NULL);  // Ensure there is a valid plane provided.\n    assert(immersion != NULL);  // Ensure there's storage provided for immersion calculations.\n\n    // Simplified: assuming the flag check is passed or it's a direct accept all flags.\n    // Real-world implementations should check the flags for valid input.\n    \n    // Here, we would define how exactly immersion is calculated but without specification details\n    // or real physics calculations, we would default to a placeholder.\n    \n    // Example simplified calculation (This part should be replaced with an actual immersion calculation):\n    // Assume a fixed volume for this demonstration.\n    immersion->volume = 123.456;  // Placeholder value.\n\n    // Return a success status code. In practice, this might depend on other conditions (e.g., no intersection).\n    return 1;  // Generally, C functions return 0 on error, non-zero for success, so returning 1 suggests success.\n}\n\n// Note: This is a very simplified implementation. Real-world physics calculations for immersion would be more complex and would require detailed information about the physical characteristics of both the box and the fluid, as well as proper handling based on the flags set.", "CodeBleu_score": 36.13241673390348}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "#include <stdbool.h>  // for bool type\n#include <math.h>     // for mathematical operations\n\n// Assuming these types are defined elsewhere in the physics engine\ntypedef struct dxGeom dxGeom;\ntypedef struct dImmersionGeom dImmersionGeom;\n\n// This will determine whether there is a valid intersection.\nbool isBoxCapsuleIntersecting(dxGeom* box, dxGeom* capsule);\n\n// Calculate and set the immersion parameters and plane.\nvoid calculateImmersionParameters(dxGeom* box, dxGeom* capsule, dImmersionGeom* immersion);\n\n// Stub function to process immersion of the box in the fluid.\nvoid dImmerseBox(dxGeom* box, dImmersionGeom* immersion, int flags);\n\n// The function that checks for collisions between a box and a capsule.\nint dImmerseBoxCapsule(dxGeom* o1, dxGeom* o2, int flags, dImmersionGeom* immersion) {\n    // Validate input parameters\n    if (o1 == NULL || o2 == NULL || immersion == NULL) {\n        return 0;  // return error code or false to indicate failure\n    }\n\n    // Check for collision between the box and capsule\n    if (!isBoxCapsuleIntersecting(o1, o2)) {\n        return 0;  // No collision\n    }\n\n    // If there is a collision, compute the immersion parameters and plane\n    calculateImmersionParameters(o1, o2, immersion);\n\n    // Call the immersion function for the box with the calculated parameters\n    dImmerseBox(o1, immersion, flags);\n\n    return 1;  // Return success or true as there was a collision and it was processed\n}\n\nbool isBoxCapsuleIntersecting(dxGeom* box, dxGeom* capsule) {\n    // Placeholder logic for intersection.\n    // Actual function should determine if box and capsule are intersecting.\n\n    // This is a simplified logic and should be replaced with actual intersection test\n    return true;  // Assume they are intersecting for this example\n}\n\nvoid calculateImmersionParameters(dxGeom* box, dxGeom* capsule, dImmersionGeom* immersion) {\n    // Placeholder for calculating immersion parameters\n    immersion->position[0] = 0.0;\n    immersion->position[1] = 0.0;\n    immersion->position[2] = 0.0;\n    immersion->normal[0] = 0.0;\n    immersion->normal[1] = 0.0;\n    immersion->normal[2] = 1.0;  // Example (some assumed direction)\n    immersion->depth = 1.0;\n}\n\nvoid dImmerseBox(dxGeom* box, dImmersionGeom* immersion, int flags) {\n    // Processing of the box in the fluid\n    // This should involve actual physics logic to handle the box immersion\n}", "CodeBleu_score": 34.11039148449076}, {"code": "#include <stdbool.h>  // For bool type.\n\n// Assume the existence of the following structures and functions:\ntypedef struct dxGeom { /* Structure properties must be defined elsewhere */ } dxGeom;\ntypedef struct dImmersionGeom { /* Propertie for collision details */ } dImmersionGeom;\nbool intersectBoxCapsule(dxGeom *box, dxGeom *capsule, dImmersionGeom *immersion);\nvoid computeImmersionPlane(dxGeom *capsule, dImmersionGeom *immersion);\nvoid dImmerseBox(dxGeom *box, dImmersionGeom *immersion);\n\nint dImmerseBoxCapsule(dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion) {\n    if (o1 == NULL || o2 == NULL) {\n        return 0;  // Return an error if either of the objects is NULL.\n    }\n    if (immersion == NULL) {\n        return 0;  // Return an error if immersion result storage is NULL.\n    }\n\n    bool isIntersection = intersectBoxCapsule(o1, o2, immersion);\n\n    // Check if there is an intersection between the box and the capsule.\n    if (isIntersection) {\n        // Compute the immersion plane using the capsule and the computed collision data.\n        computeImmersionPlane(o2, immersion);\n\n        // Proceed to handle the box immersion based on the collision with the capsule.\n        dImmerseBox(o1, immersion);\n\n        return 1;  // Return 1 indicating successful detection and processing of collision.\n    }\n\n    return 0;  // Return 0 indicating no collision was detected.\n}", "CodeBleu_score": 29.6588571914434}, {"code": "#include <iostream>\n#include <cmath>\n\n// Assuming necessary ODE definitions\nstruct dxGeom {\n    int type;                   // For identifying object type\n    float x, y, z;              // Co-ordinates indicating object position\n    float dimension[3];         // Dimensions - used differently depending on object type\n};\n\nstruct dImmersionGeom {\n    float penetration;          // Penetration depth\n    float normal[3];            // Immersion normal\n};\n\n// Simplified types\n#define BOX_TYPE 1\n#define CAPSULE_TYPE 2\n\nint dImmerseBox(dxGeom *box, dxGeom *capsule, int flags, dImmersionGeom *immersion);\n\n// Function to check if a capsule collides with a box \nbool checkCollision(dxGeom *box, dxGeom *capsule) {\n    // Simplified collision detection, you can expand with real logic\n    float distance = std::sqrt(\n        std::pow((capsule->x - box->x), 2) +\n        std::pow((capsule->y - box->y), 2) +\n        std::pow((capsule->z - box->z), 2));\n    return distance < (capsule->dimension[0] + std::max({box->dimension[0], box->dimension[1], box->dimension[2]}));\n}\n\nint dImmerseBoxCapsule(dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion) {\n    // Basic validation of inputs\n    if (o1 == nullptr || o2 == nullptr || immersion == nullptr) {\n        std::cerr << \"Invalid input geometry pointers.\" << std::endl;\n        return -1;\n    }\n\n    // Determine which is the capsule and which is the box\n    dxGeom *box = (o1->type == BOX_TYPE) ? o1 : o2;\n    dxGeom *capsule = (o1->type == CAPSULE_TYPE) ? o1 : o2;\n\n    if (box->type != BOX_TYPE || capsule->type != CAPSULE_TYPE) {\n        std::cerr << \"Invalid geometry types provided.\" << std::endl;\n        return -1;\n    }\n\n    // Collision detection\n    if (!checkCollision(box, capsule)) {\n        return 0; // No collision occurred\n    }\n\n    // Set immersion parameters and compute the immersion plane\n    // These values are fictive, replace with actual calculations as needed\n    immersion->penetration = 0.5f;  // simplified example value\n    immersion->normal[0] = 1.0f;\n    immersion->normal[1] = 0.0f;\n    immersion->normal[2] = 0.0f;\n\n    // Process the immersion of the box in the fluid\n    return dImmerseBox(box, capsule, flags, immersion);\n}\n\nint main() {\n    // Testing the function\n    dxGeom box = {BOX_TYPE, 0, 0, 0, {2, 3, 4}};\n    dxGeom capsule = {CAPSULE_TYPE, 1, 1, 1, {1, 0, 0}};\n    dImmersionGeom immersion;\n    \n    int result = dImmerseBoxCapsule(&box, &capsule, 0, &immersion);\n    std::cout << \"Result: \" << result << std::endl;\n    if (result > 0) {\n        std::cout << \"Immersion penetration: \" << immersion.penetration << std::endl;\n    }\n    return 0;\n}", "CodeBleu_score": 35.53156838354109}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "#include <cmath>\n#include <functional>\n\ntypedef double dReal; // Typically typedefs like this might be defined elsewhere in the codebase.\n\nclass sCapsuleImmersionData {\n    // Placeholder for f(x) used in the integration\n    dReal hemisphereSliceVolume(dReal x) const {\n        // Function to compute hemisphere slice volume at x\n        // Definition needs the actual formula based on problem physics.\n        return std::sin(x); // Temporarily using sin(x) as a placeholder.\n    }\n\npublic:\n    dReal normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const {\n        int n = 100; // number of intervals, should be even\n\n        dReal a = zIOverR; // start point for integration\n        dReal b = tanTheta0; // end point for integration\n        dReal h = (b - a) / n;\n        dReal integral = 0.0;\n\n        // Simpson's formula: h/3 * (f0 + 4f1 + 2f2 + ...)\n        integral += hemisphereSliceVolume(a) + hemisphereSliceVolume(b); // f(a) + f(b)\n\n        for (int i = 1; i < n; i++) {\n            dReal x = a + i * h;\n            integral += (i % 2 == 0 ? 2 : 4) * hemisphereSliceVolume(x); // 4f1, 2f2, 4f3, 2f4, ...\n        }\n\n        integral = integral * h / 3;\n\n        return integral; // Returns the result of the integration, needs normalization if necessary\n    }\n};\n\n// Usage example\nint main() {\n    sCapsuleImmersionData capsule;\n    dReal result = capsule.normalizedImmersedHemisphereVolume(0.0, 1.0, 0.5);\n    std::cout << \"Normalized immersed hemisphere volume: \" << result << std::endl;\n    return 0;\n}", "CodeBleu_score": 38.86115101653292}, {"code": "#include <cmath> // Include the cmath library for mathematical functions\n\nclass sCapsuleImmersionData {\npublic:\n    typedef double dReal; // Assuming dReal is a typedef for double\n\n    dReal normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const {\n        // Constants\n        const int n = 100; // Number of intervals (even number for Simpson's rule)\n        const dReal a = 0; // Start of the integration interval\n        const dReal b = M_PI; // End of the integration interval (half-circle)\n        \n        dReal h = (b - a) / n; // Step size\n        dReal integral = 0.0; // Variable to store the sum of areas\n        dReal x, f_x;\n\n        // Simpson's Rule: Sum over each interval, with special weights on ends and odd-indexed points\n        for (int i = 0; i <= n; i++) {\n            x = a + i * h;\n            f_x = calculateFunction(x, zIOverR, tanTheta0, sinTheta1); // The function to integrate\n            \n            // Weighting according to Simpson's rule\n            if (i == 0 || i == n) {\n                integral += f_x; // Endpoints\n            } else if (i % 2 == 1) {\n                integral += 4 * f_x; // Odd points\n            } else {\n                integral += 2 * f_x; // Even points\n            }\n        }\n\n        integral = integral * h / 3.0; // Scaling the sum according to the rule\n\n        return integral;\n    }\n    \n    // Assume calculateFunction() is defined here, could be more involved\n    dReal calculateFunction(dReal x, dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const {\n        // Hypothetical function:\n        // Example: Volume segment for rotationally symmetric hemisphere about the x-axis\n        // This is just a placeholder and should be replaced with the actual function\n        return sinTheta1 * zIOverR * std::sin(x) - tanTheta0 * std::cos(x); // This is hypothetical!\n    }\n};", "CodeBleu_score": 40.4031385204156}, {"code": "#include <cmath>\n\nclass sCapsuleImmersionData {\npublic:\n    typedef double dReal; \n\n    dReal normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const {\n        auto f = [](dReal theta, dReal zIOverR, dReal tanTheta0) {\n            // Calculate the integrand.\n            dReal sine = sin(theta);\n            dReal cosine = cos(theta);\n            dReal h = tanTheta0 * cosine - zIOverR;\n            return h > 0 ? sine * sine * cosine : 0;\n        };\n\n        int n = 100;  // Number of divisions for Simpson's rule\n        dReal a = asin(sinTheta1);   // lower limit of integral\n        dReal b = M_PI_2;            // upper limit of integral, which is PI/2 since it\u2019s a hemisphere\n        dReal h = (b - a) / n;\n        dReal s = f(a, zIOverR, tanTheta0) + f(b, zIOverR, tanTheta0); // end points\n        dReal x, fx;\n\n        // Simpson's Rule Integration\n        for (int i = 1; i < n; i++) {\n            x = a + i * h;\n            fx = f(x, zIOverR, tanTheta0);\n            if (i % 2 == 0) {\n                s += 2 * fx;\n            } else {\n                s += 4 * fx;\n            }\n        }\n\n        return s * h / 3;\n    }\n};\n\nint main() {\n    sCapsuleImmersionData data;\n    sCapsuleImmersionData::dReal zIOverR = 0.5;\n    sCapsuleImmersionData::dReal tanTheta0 = 1.0;\n    sCapsuleImmersionData::dReal sinTheta1 = 0.86602540378; // sin(60 degrees)\n\n    sCapsuleImmersionData::dReal volume = data.normalizedImmersedHemisphereVolume(zIOverR, tanTheta0, sinTheta1);\n    std::cout << \"Normalized Immersed Hemisphere Volume: \" << volume << std::endl;\n\n    return 0;\n}", "CodeBleu_score": 39.32760940235684}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "#include <cmath>  // For math functions\n\ndReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const {\n    // Constants\n    const int numSteps = 1000;  // Change this based on required precision\n    dReal theta0 = atan(tanTheta0);\n    dReal theta1 = asin(sinTheta1);\n    dReal dTheta = (theta1 - theta0) / numSteps;\n    dReal xCenter = 0.0;\n    \n    // Simpson's rule parameters\n    dReal theta = theta0;\n    dReal sum = 0.0;\n\n    for (int i = 0; i <= numSteps; ++i) {\n        // Calculate the x-position of the element\n        dReal z = cos(theta);        // height from center\n        dReal r = sqrt(1 - z * z);   // radius at height z\n        dReal x = r * cos(theta);    // x due to symmetry\n        \n        // Weighting factor according to Simpson's rule\n        dReal weight = (i == 0 || i == numSteps) ? 1 : (i % 2 == 1 ? 4 : 2);\n        \n        // Add contribution to the integral\n        sum += weight * x * r;  // Simplified form without considering differential area elements\n\n        // Update theta for next step\n        theta += dTheta;\n    }\n\n    // Finalizing the integration\n    xCenter = (dTheta / 3.0) * sum / volume;\n\n    return xCenter;\n}", "CodeBleu_score": 39.45108641790848}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const {\n    // Constants\n    const int n = 100; // Number of intervals; increase for more accuracy.\n    const dReal pi = 3.14159265358979323846;\n    const dReal R = 1.0; // Assuming radius R is 1 for scaled results.\n\n    // Calculate theta_0 and theta_1 from provided tangent and sine values assuming tan for small theta0 and sin for final bound\n    dReal theta0 = atan(tanTheta0); // From tan to angle\n    dReal theta1 = asin(sinTheta1); // From sin to angle\n\n    // Interval size for n intervals\n    dReal h = (theta1 - theta0) / n;\n\n    // Simpson's Rule Integration setup\n    dReal integral = 0.0;\n    for (int i = 0; i <= n; ++i) {\n        dReal theta = theta0 + i * h;\n        dReal x = R * cos(theta); // position along the x-axis\n        dReal functionValue = x * sin(theta); // Function for integration (simplified buoyancy-center calculation)\n\n        // Simpson's Rule weights: 1/3, 4/3, 2/3, ...\n        dReal weight = (i == 0 || i == n) ? 1 : (i % 2 == 1 ? 4 : 2);\n        integral += weight * functionValue;\n    }\n    integral *= (h / 3);\n\n    // Calculate x-coordinate of buoyancy center, scaled and adjusted by volume\n    dReal xBuoyancyCenter = integral / volume;\n\n    return xBuoyancyCenter;\n}", "CodeBleu_score": 43.473921679031506}, {"code": "#include <cmath>\n#include <iostream>\n\nclass sCapsuleImmersionData {\npublic:\n    typedef double dReal;\n\n    dReal immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const {\n        const size_t n = 100;  // number of intervals for Simpson's rule, should be even\n        dReal Theta0 = std::atan(tanTheta0);\n        dReal Theta1 = std::asin(sinTheta1);\n        dReal deltaTheta = (Theta1 - Theta0) / n;\n  \n        dReal integralSum = 0;\n        for (size_t i = 0; i <= n; ++i) {\n            dReal theta = Theta0 + i * deltaTheta;\n            dReal fx = (std::sin(theta) - zIOverR) * std::sin(theta);\n            if (i == 0 || i == n) {\n                integralSum += fx;\n            } else if (i % 2 == 0) {\n                integralSum += 2 * fx;\n            } else {\n                integralSum += 4 * fx;\n            }\n        }\n  \n        integralSum *= deltaTheta / 3;\n        return integralSum * volume;\n    }\n};\n\nint main() {\n    sCapsuleImmersionData capsule;\n    double result = capsule.immersedHemisphereXBuoyancyCenter(0.5, 1.0, 0.866025, 10.0);\n    std::cout << \"Buoyancy center x-coordinate: \" << result << std::endl;\n    return 0;\n}", "CodeBleu_score": 39.22083938687072}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "import numpy as np\n\ndef immersed_hemisphere_x_buoyancy_center(depth_ratio, tan_initial_angle, sin_final_angle, volume):\n    \"\"\"\n    Calculates the x-coordinate of the buoyancy center for an immersed hemisphere.\n    Uses Simpson's rule for numerical integration over the hemisphere's surface.\n    \n    Parameters:\n    - depth_ratio: Immersion depth ratio of the hemisphere.\n    - tan_initial_angle: Tangent of the initial angle of immersion.\n    - sin_final_angle: Sine of the final angle of immersion.\n    - volume: Volume of the hemisphere.\n    \n    Returns:\n    - x-coordinate of the buoyancy center scaled by the radius and adjusted by the volume.\n    \"\"\"\n    \n    def integrand(theta):\n        # Assuming the radius R = 1 for scaling purposes, can be adjusted if necessary\n        return np.cos(theta) * np.sin(theta)\n\n    # Convert angles based on given trigonometric values\n    initial_angle = np.arctan(tan_initial_angle)\n    final_angle = np.arcsin(sin_final_angle)\n\n    # We use Simpson's rule for integration:\n    N = 1000  # Number of intervals (even number)\n    h = (final_angle - initial_angle) / N\n    x = np.linspace(initial_angle, final_angle, N+1)\n    y = integrand(x)\n    \n    # Applying Simpson's Rule\n    S = y[0] + y[-1] + 4 * np.sum(y[1:N:2]) + 2 * np.sum(y[2:N-1:2])\n    integral_result = (h/3) * S\n\n    # Scale this integral result by the provided volume (assuming radius 1, adjust if not)\n    buoyancy_center_x = (3 / (2 * np.pi)) * integral_result * volume\n\n    return buoyancy_center_x\n\n# Example usage\ndepth_ratio = 0.5  # Example values\ntan_initial_angle = np.tan(np.pi/6)  # 30 degrees to radians and then tangent\nsin_final_angle = np.sin(np.pi/3)  # 60 degrees to radians and then sine\nvolume = 2 * np.pi / 3  # For a hemisphere volume formula (2/3)\u03c0r^3 with r = 1\n\nresult = immersed_hemisphere_x_buoyancy_center(depth_ratio, tan_initial_angle, sin_final_angle, volume)\nprint('X-coordinate of the buoyancy center:', result)", "CodeBleu_score": 26.680994807154455}, {"code": "#include <cmath>\n#include <iostream>\n\nclass sCapsuleImmersionData {\npublic:\n    // Calculates the x-coordinate of the buoyancy center for an immersed hemisphere using Simpson's Rule\n    static double immersedHemisphereXBuoyancyCenter(double immersionDepthRatio, double tanInitialAngle, double sinFinalAngle, double volume) {\n        constexpr int n = 1000;  // Number of intervals; must be even\n        double a = tanInitialAngle;\n        double b = sinFinalAngle;\n        double h = (b - a) / n;\n\n        auto integrand = [immersionDepthRatio](double theta) {\n            return std::pow(std::sin(theta), 2) * immersionDepthRatio;\n        };\n\n        // Applying Simpson's rule\n        double integral = integrand(a) + integrand(b);\n        for (int i = 1; i < n; i++) {\n            double x = a + i * h;\n            integral += ((i % 2 == 0) ? 2 : 4) * integrand(x);\n        }\n        integral *= h / 3;\n\n        // Calculate scaled buoyancy center\n        double buoyancyCenterX = integral / volume;\n\n        return buoyancyCenterX;\n    }\n};\n\nint main() {\n    double immersionDepthRatio = 0.75;\n    double tanInitialAngle = 0.0;  // Example: angle at the top of the hemisphere\n    double sinFinalAngle = 1.0;    // Sine of angle at the bottom\n    double volume = 2.0;           // Arbitrary volume value\n\n    double xBuoyancyCenter = sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(immersionDepthRatio, tanInitialAngle, sinFinalAngle, volume);\n    std::cout << \"X-coordinate of the buoyancy center: \" << xBuoyancyCenter << std::endl;\n\n    return 0;\n}", "CodeBleu_score": 31.27084208138494}, {"code": "#include <iostream>\n#include <cmath>\n\n// Assuming these are predefined in the environment\nstruct dxGeom {\n    // Typically contains geometric definitions like positions, orientations etc.\n};\n\nstruct dImmersionGeom {\n    float xBuoyancyCenter; // X-coordinate of the buoyancy center\n};\n\nint dImmerseCapsuleTrimesh(dxGeom *capsule, dxGeom *trimesh, int flags, dImmersionGeom *immersion) {\n    if (!capsule || !trimesh || !immersion) {\n        std::cerr << \"Invalid input to dImmerseCapsuleTrimesh.\" << std::endl;\n        return -1; // Error code for invalid input\n    }\n\n    // Example placeholder calculations to compute x-coordinate of buoyancy center:\n    float immersionDepthRatio = 0.5;  // Assuming some default value\n    float tanInitialAngle = 0.2;      // Assuming an angle in radians convered to tangent\n    float sinFinalAngle = 0.707;      // sin(45 degrees)\n    float volume = 100.0;             // Assuming a default volume of the submerged part\n\n    // Calculate the x-buoyancy center using a simplified method as a placeholder for Simpson's rule integration:\n    float radius = 1.0;  // Assuming a radius for the hemisphere\n    float integratedX = immersionDepthRatio * tanInitialAngle - sinFinalAngle * radius; // Simplified example calculation\n\n    immersion->xBuoyancyCenter = integratedX * radius / volume; // Assign computed value to the immersion data\n\n    return 0; // Return 0 indicating success\n}", "CodeBleu_score": 28.407342117542832}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart() {\n    int sleep_duration_ms; // Declare a variable to store sleep duration\n\n    // Try to retrieve the sleep duration from the input\n    if (!input().getValue(\"sleep_duration_ms\", sleep_duration_ms)) {\n        // If the duration is missing return SUCCESS\n        return NodeStatus::SUCCESS;\n    }\n\n    // Check if the sleep duration is non-positive\n    if (sleep_duration_ms <= 0) {\n        // If the duration is non-positive, also return SUCCESS\n        return NodeStatus::SUCCESS;\n    }\n\n    // If the sleep duration is positive, set the node status to RUNNING\n    setStatus(NodeStatus::RUNNING);\n\n    // Setup the timer to delay the execution\n    timer_waiting_ = true;\n    std::thread([this, sleep_duration_ms]() {\n        std::this_thread::sleep_for(std::chrono::milliseconds(sleep_duration_ms));\n        \n        // Check if the timer should still be waiting (not aborted)\n        if (timer_waiting_) {\n            // Emit a wake-up signal\n            output().sendSignal(\"wake_up\");\n            setStatus(NodeStatus::SUCCESS);\n        }\n        timer_waiting_ = false;\n    }).detach();\n\n    // Return the RUNNING status because the node is now waiting\n    return NodeStatus::RUNNING;\n}", "CodeBleu_score": 55.481347268033986}, {"code": "#include <iostream>\n#include <thread>\n#include <chrono>\n\nenum NodeStatus {\n    SUCCESS,\n    RUNNING,\n    FAILURE\n};\n\nclass SleepNode {\npublic:\n    SleepNode() : timer_waiting_(false) {}\n\n    NodeStatus onStart() {\n        // Assuming `sleep_duration_ms_` to be the member variable storing duration\n        if (sleep_duration_ms_ <= 0) {\n            std::cout << \"No sleep duration provided or duration non-positive. Returning SUCCESS.\" << std::endl;\n            return SUCCESS;\n        }\n\n        // Set node status to RUNNING\n        timer_waiting_ = true;\n        std::cout << \"Node status set to RUNNING. Starting timer...\" << std::endl;\n\n        // Start a timer to simulate delay\n        try {\n            std::thread([this]() {\n                std::this_thread::sleep_for(std::chrono::milliseconds(sleep_duration_ms_));\n                this->wakeUp();\n            }).detach();\n        } catch (...) {\n            std::cerr << \"Failed to start timer.\" << std::endl;\n            timer_waiting_ = false;  // Ensure timer_waiting_ is reset\n            return FAILURE;\n        }\n        \n        return RUNNING;\n    }\n\n    void wakeUp() {\n        std::cout << \"Wake-up signal emitted after \" << sleep_duration_ms_ << \" milliseconds.\" << std::endl;\n        timer_waiting_ = false; // Resetting the flag when timer expires\n    }\n\n    void setSleepDuration(int duration_ms) {\n        sleep_duration_ms_ = duration_ms;\n    }\n\nprivate:\n    bool timer_waiting_;\n    int sleep_duration_ms_;\n};\n\nint main() {\n    SleepNode node;\n    node.setSleepDuration(5000); // Set sleep duration to 5000 milliseconds\n\n    NodeStatus status = node.onStart();\n    if (status == RUNNING) {\n        std::cout << \"The node is running and will complete after the set duration.\" << std::endl;\n    }\n\n    // Just to keep main from exiting immediately if the node is in a RUNNING state\n    std::this_thread::sleep_for(std::chrono::seconds(6));\n    return 0;\n}", "CodeBleu_score": 33.27257735928737}, {"code": "#include <iostream>\n#include <chrono>\n#include <thread>\n#include <functional>\n#include <atomic>\n\nenum NodeStatus {\n    SUCCESS,\n    RUNNING,\n    FAILED // Assuming a FAILED status for unknown states or errors\n};\n\nclass SleepNode {\nprivate:\n    std::atomic<bool> timer_waiting_{false};\n\npublic:\n    // This could be provided elsewhere in the real implementation\n    int getSleepDuration() {\n        int duration;\n        // Assume a function to fetch sleep duration\n        // For now, we'll just simulate with user input\n        std::cout << \"Enter sleep duration in milliseconds: \";\n        std::cin >> duration;\n        return duration;\n    }\n\n    void timerCallback() {\n        std::cout << \"Timer completed. Waking up...\" << std::endl;\n        timer_waiting_ = false;\n        // Other wake-up operations might be needed here\n    }\n\n    NodeStatus onStart() {\n        int duration = getSleepDuration();\n        if (duration <= 0) {\n            return SUCCESS;\n        }\n\n        std::cout << \"Node is running. Sleeping for \" << duration << \" ms\" << std::endl;\n        timer_waiting_ = true;\n\n        // Using a separate thread to emulate asynchronous timer\n        std::thread([this, duration]() {\n            std::this_thread::sleep_for(std::chrono::milliseconds(duration));\n            if (this->timer_waiting_) { // Check if the timer was not aborted\n                this->timerCallback();\n            }\n        }).detach();\n\n        return RUNNING;\n    }\n};", "CodeBleu_score": 35.15005965873178}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick() {\n    // Try to retrieve the entry from the blackboard\n    auto entry = blackboard.getEntry(entryName);  // Assume blackboard is accessible and has getEntry method\n    if (!entry) {\n        // Entry not found\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the mutex for the entry to ensure thread safety.\n    std::lock_guard<std::mutex> lock(entry->mutex);\n\n    // Check if the sequence ID has been updated\n    if (entry->sequenceId != lastSequenceId) {\n        // If the sequence ID has changed, update the stored sequence ID\n        lastSequenceId = entry->sequenceId;\n\n        // Return SUCCESS as the entry has been updated\n        return NodeStatus::SUCCESS;\n    } else {\n        // If the sequence ID has not changed, return FAILURE\n        return NodeStatus::FAILURE;\n    }\n}", "CodeBleu_score": 43.6406187981807}, {"code": "NodeStatus EntryUpdatedAction::tick() {\n    // Assume blackboard is a part of the class and it's accessible here\n    // and that it provides access to entries in a thread-safe manner.\n    \n    if (!blackboard) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the blackboard mutex to ensure thread-safety when accessing shared data.\n    std::lock_guard<std::mutex> lock(blackboard->mutex);\n\n    // Attempt to retrieve the data entry from the blackboard.\n    auto entry = blackboard->getEntry(entryId);\n\n    if (!entry) {\n        // No entry was found for the given identifier.\n        return NodeStatus::FAILURE;\n    }\n\n    // Compare the current sequence ID of the entry with the last known sequence ID.\n    uint32_t currentSeqID = entry->sequenceID;\n    if (currentSeqID != storedSeqID) {\n        // If sequence ID is different, update the stored sequence ID and return success.\n        storedSeqID = currentSeqID;\n        return NodeStatus::SUCCESS;\n    }\n\n    // If sequence IDs are the same, then the entry hasn't been updated since the last check.\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 52.8999322865013}, {"code": "#include <mutex>\n\nenum NodeStatus { SUCCESS, FAILURE };\n\nclass Blackboard {\npublic:\n    bool getEntry(const std::string& key, int& value) {\n        // This function would retrieve an entry by key.\n        // Assuming true is returned if found, and false if not found.\n        // For demonstration, let's just return false.\n        return false;\n    }\n};\n\nclass EntryUpdatedAction {\nprivate:\n    Blackboard& blackboard;\n    std::string entryKey;\n    int lastSequenceId;\n    std::mutex entryMutex;\n\npublic:\n    EntryUpdatedAction(Blackboard& bb, std::string key) \n    : blackboard(bb), entryKey(key), lastSequenceId(-1) {}\n\n    NodeStatus tick() {\n        std::lock_guard<std::mutex> lock(entryMutex);\n        int currentSequenceId;\n\n        if (!blackboard.getEntry(entryKey, currentSequenceId)) {\n            return NodeStatus::FAILURE;\n        }\n\n        if (currentSequenceId != lastSequenceId) {\n            lastSequenceId = currentSequenceId;\n            return NodeStatus::SUCCESS;\n        }\n\n        return NodeStatus::FAILURE;\n    }\n};", "CodeBleu_score": 42.64852243559927}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "#include <cstddef>\n\nclass ParallelNode {\nprivate:\n    int success_threshold;  // Holds the initial success threshold value (could be negative)\n    size_t number_of_children;  // Number of child nodes\n    \npublic:\n    ParallelNode(int threshold, size_t children)\n        : success_threshold(threshold), number_of_children(children) {}\n\n    size_t successThreshold() const {\n        // Check if the success threshold is negative\n        if (success_threshold < 0) {\n            // Calculate non-negative threshold based on number of children\n            // Ensuring that we never go below zero\n            return number_of_children + success_threshold >= 0 ? number_of_children + success_threshold : 0;\n        }\n        // If the success threshold is non-negative, simply return it as size_t\n        return static_cast<size_t>(success_threshold);\n    }\n};", "CodeBleu_score": 31.17514639176997}, {"code": "size_t ParallelNode::successThreshold() const {\n    // Assuming successThreshold_ is a member variable storing the set threshold\n    if (successThreshold_ < 0) {\n        // If the threshold is negative, add the number of child nodes to make it non-negative\n        // childNodes.size() assumed as the method or variable storing total children count.\n        return std::max(0, static_cast<int>(childNodes.size()) + successThreshold_);\n    } else {\n        // If the threshold is non-negative, return it directly\n        return static_cast<size_t>(successThreshold_);\n    }\n}", "CodeBleu_score": 59.273348793932456}, {"code": "/*\n * This function calculates the success threshold for a parallel node.\n * If the success threshold is negative, it adjusts the value based on the number of child nodes, ensuring the result is non-negative.\n * If the success threshold is non-negative, it returns it directly as a size_t.\n */\nsize_t ParallelNode::successThreshold() const {\n    // Assume `success_threshold_` is the variable holding the required threshold which can be negative or non-negative\n    // and `children_count_` holds the number of child nodes.\n\n    if (success_threshold_ < 0) {\n        // Convert negative threshold to a positive value by adding the total number of children\n        // Ensuring the result is always non-negative\n        return static_cast<size_t>(children_count_ + success_threshold_);\n    } else {\n        // Directly return the non-negative value \n        return static_cast<size_t>(success_threshold_);\n    }\n}", "CodeBleu_score": 46.531756909703624}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "#include <chrono>\n#include <thread>\n\nvoid Groot2Publisher::heartbeatLoop() {\n    using namespace std::chrono;\n    auto lastStatus = heartbeatActive;\n\n    // This loop runs indefinitely to check the heartbeat continuously.\n    while (true) {\n        auto now = steady_clock::now();\n\n        // Compute the time difference in milliseconds.\n        auto durationSinceLastHeartbeat = duration_cast<milliseconds>(now - lastHeartbeatTime).count();\n\n        // Check if the heartbeat is still considered active. \n        // Assuming there's a threshold time, e.g., 1000 milliseconds, for an active heartbeat.\n        if (durationSinceLastHeartbeat > 1000) {\n            heartbeatActive = false;\n        } else {\n            heartbeatActive = true;\n        }\n\n        // Check if there's a change in heartbeat status.\n        if (lastStatus != heartbeatActive) {\n            if (heartbeatActive) {\n                // Heartbeat has been restored; enable breakpoints.\n                enableAllBreakpoints();\n            } else {\n                // Heartbeat has stopped; disable breakpoints.\n                disableAllBreakpoints();\n            }\n            // Update the last known status.\n            lastStatus = heartbeatActive;\n        }\n\n        // Sleep for 10 milliseconds before the next check.\n        std::this_thread::sleep_for(milliseconds(10));\n    }\n}\n\n// Assumed member functions used in heartbeatLoop for managing breakpoints.\nvoid Groot2Publisher::enableAllBreakpoints() {\n    // Implmentation should enable all breakpoints.\n}\n\nvoid Groot2Publisher::disableAllBreakpoints() {\n    // Implementation should disable all breakpoints.\n}", "CodeBleu_score": 38.87776012389941}, {"code": "#include <chrono>\n#include <thread>\n\nclass Groot2Publisher {\nprivate:\n    std::chrono::steady_clock::time_point lastHeartbeatTime;\n    bool isActive;\n\n    void enableBreakpoints() {\n        // Implement the method to enable all breakpoints\n    }\n\n    void disableBreakpoints() {\n        // Implement the method to disable all breakpoints\n    }\n\n    bool checkHeartbeat() {\n        auto now = std::chrono::steady_clock::now();\n        // Assuming threshold is 10 seconds for the heartbeat to be considered lost\n        auto duration = std::chrono::duration_cast<std::chrono::seconds>(now - lastHeartbeatTime);\n        return duration.count() < 10;\n    }\n\npublic:\n    void heartbeatLoop() {\n        while (true) {\n            // Sleep for 10 milliseconds\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n            \n            // Check the current heartbeat status\n            bool currentStatus = checkHeartbeat();\n\n            // Compare the current status with the last known status and update if there is any change\n            if (currentStatus != isActive) {\n                if (currentStatus) {\n                    enableBreakpoints();\n                } else {\n                    disableBreakpoints();\n                }\n                isActive = currentStatus;\n            }\n        }\n    }\n};", "CodeBleu_score": 41.81322369237091}, {"code": "#include <chrono>\n#include <thread>\n#include <iostream>\n\nclass Groot2Publisher {\npublic:\n    Groot2Publisher();\n    void heartbeatLoop();\n    void enableBreakpoints();\n    void disableBreakpoints();\n\nprivate:\n    std::chrono::system_clock::time_point lastHeartbeat;\n    bool activeHeartbeat;\n};\n\nGroot2Publisher::Groot2Publisher() : activeHeartbeat(false) {\n    // Initialize the lastHeartbeat variable with the current time\n    lastHeartbeat = std::chrono::system_clock::now();\n}\n\nvoid Groot2Publisher::enableBreakpoints() {\n    std::cout << \"Breakpoints enabled\" << std::endl;\n}\n\nvoid Groot2Publisher::disableBreakpoints() {\n    std::cout << \"Breakpoints disabled\" << std::endl;\n}\n\nvoid Groot2Publisher::heartbeatLoop() {\n    while (true) {\n        // Sleep for 10 milliseconds between heartbeat checks \n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n        // Current system time to compare against the last heartbeat\n        auto now = std::chrono::system_clock::now();\n\n        // Check if more than a certain period has passed without heartbeat\n        const auto timeSinceLastHeartbeat = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastHeartbeat);\n\n        // Here defining the threshold value might be declared elsewhere or need passing to this function\n        const int heartbeatThreshold = 200; // milliseconds\n\n        if (timeSinceLastHeartbeat.count() > heartbeatThreshold) {\n            if (activeHeartbeat) {\n                disableBreakpoints();\n                activeHeartbeat = false;\n                std::cout << \"Heartbeat lost\" << std::endl;\n            }\n        } else {\n            if (!activeHeartbeat) {\n                enableBreakpoints();\n                activeHeartbeat = true;\n                std::cout << \"Heartbeat active\" << std::endl;\n            }\n        }\n\n        // Simulate the receiving of a heartbeat.\n        // This would typically be an external event, and could be handled differently.\n        // The following line is just for demonstration and should be replaced with the actual\n        // mechanism to update `lastHeartbeat`.\n        lastHeartbeat = std::chrono::system_clock::now();\n    }\n}", "CodeBleu_score": 48.869267133121696}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "#include <vector>\n#include <string>\n#include <json/json.h>\n#include <msgpack.hpp>\n\nstd::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list) {\n    // Split the bb_list into individual names\n    std::vector<std::string> bb_names;\n    std::istringstream iss(bb_list);\n    std::string item;\n    while (std::getline(iss, item, ',')) {\n        if (!item.empty()) {\n            bb_names.push_back(item);\n        }\n    }\n\n    // JSON object to hold the entire dump\n    Json::Value json_root;\n\n    // Iterate through blackboard names\n    for (const std::string& name : bb_names) {\n        // Lock the corresponding subtree\n        auto subtree = this->lockSubtree(name);\n        \n        if (subtree) { // Check if we got a valid subtree\n            // Export the blackboard to a JSON object\n            Json::Value json_bb = subtree->exportBlackboardToJson();\n            \n            // Add to the JSON root object\n            json_root[name] = json_bb;\n\n            // Unlock the subtree (simulated here, assuming a function exists)\n            subtree->unlock();\n        }\n    }\n\n    // Convert the JSON root object to a MessagePack object\n    std::stringstream buffer;\n    buffer << json_root;\n\n    msgpack::sbuffer sbuf; // Simple buffer to write serialized data\n    msgpack::pack(sbuf, json_root);\n\n    // Return the MessagePack data as a vector of uint8_t\n    return std::vector<uint8_t>(sbuf.data(), sbuf.data() + sbuf.size());\n}", "CodeBleu_score": 44.13012185592808}, {"code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <nlohmann/json.hpp>\n#include <msgpack.hpp>\n\nclass Groot2Publisher {\npublic:\n    std::vector<uint8_t> generateBlackboardsDump(const std::string& bb_list);\nprivate:\n    bool getSubtree(const std::string& name, nlohmann::json& blackboardData);\n    void lockSubtree(const std::string& name);\n};\n\nstd::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list) {\n    std::istringstream iss(bb_list);\n    std::string blackboardName;\n    nlohmann::json resultJson;\n\n    while (std::getline(iss, blackboardName, ',')) {\n        // Trim spaces from names, in case of \"name1, name2\"\n        blackboardName.erase(remove_if(blackboardName.begin(), blackboardName.end(), isspace), blackboardName.end());\n        \n        nlohmann::json blackboardData;\n        if (getSubtree(blackboardName, blackboardData)) {\n            lockSubtree(blackboardName);\n            resultJson.push_back(blackboardData);\n        }\n    }\n\n    // Convert the JSON object to MessagePack\n    std::vector<uint8_t> msgPackData = msgpack::v5::pack(resultJson);\n\n    return msgPackData;\n}\n\nbool Groot2Publisher::getSubtree(const std::string& name, nlohmann::json& blackboardData) {\n    // Mock function to simulate subtree fetching and JSON export.\n    // Replace this with your actual implementation.\n    blackboardData = {{\"name\", name}, {\"data\", \"some data\"}};\n    return true; // Assume it always returns a valid subtree for simplicity.\n}\n\nvoid Groot2Publisher::lockSubtree(const std::string& name) {\n    // Mock function to simulate locking the subtree.\n    // Replace this with your actual implementation.\n    std::cout << \"Subtree locked for: \" << name << std::endl;\n}\n\n// Usage example (in main or other function):\n// Groot2Publisher publisher;\n// std::vector<uint8_t> dumpData = publisher.generateBlackboardsDump(\"bb1,bb2,bb3\");", "CodeBleu_score": 39.909389603300724}, {"code": "#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <msgpack.hpp>\n#include <nlohmann/json.hpp>\n\nclass Groot2Publisher {\npublic:\n    std::vector<uint8_t> generateBlackboardsDump(const std::string& bb_list);\nprivate:\n    nlohmann::json getBlackboardJson(const std::string& bb_name); // Assume a function to get JSON from BB\n    std::map<std::string, SubTree> blackboard_subtrees;  // Placeholder for subtree structures\n    std::mutex subtree_mutex;  // Mutex for thread safety when managing subtrees\n};\n\nstd::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list) {\n    std::vector<uint8_t> message_pack_data;\n    nlohmann::json json_dump_all;\n\n    std::istringstream iss(bb_list);\n    std::string blackboard_name;\n\n    while (getline(iss, blackboard_name, ',')) {\n        std::lock_guard<std::mutex> lock(subtree_mutex); // Lock during subtree manipulation\n        auto it = blackboard_subtrees.find(blackboard_name);\n        if (it != blackboard_subtrees.end()) {\n            auto& subtree = it->second;\n\n            // Assume SubTree::isValid() method indicates if the subtree is ready to be used\n            if (subtree.isValid()) {\n                nlohmann::json blackboard_json = getBlackboardJson(blackboard_name);\n                json_dump_all[blackboard_name] = blackboard_json;\n            }\n        }\n    }\n\n    message_pack_data = nlohmann::json::to_msgpack(json_dump_all); // Convert JSON to MessagePack format\n    return message_pack_data;\n}\n\nnlohmann::json Groot2Publisher::getBlackboardJson(const std::string& bb_name) {\n    // Mock-up function to simulate fetching and converting a blackboard to JSON format\n    nlohmann::json result;\n    // Example: result[\"data\"] = \"value\"; // Simple key-value for the blackboard\n    return result;\n}", "CodeBleu_score": 39.7756118708756}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "#include <mutex>\n#include <condition_variable>\n#include <utility>\n#include <map>\n#include <thread>\n\nclass Hook {\npublic:\n    std::mutex mtx;\n    std::condition_variable cv;\n    enum Mode { NONE, BREAKPOINT } mode;\n    bool ready = false;\n    bool toRemove;\n\n    Hook() : mode(NONE), toRemove(false) {}\n};\n\nclass Groot2Publisher {\nprivate:\n    std::map<uint16_t, Hook> hooks;\n\npublic:\n    bool unlockBreakpoint(uint16_t node_uid, NodeStatus result, bool remove) {\n        auto it = hooks.find(node_uid);\n        // Check if the node (hook) exists\n        if (it == hooks.end()) {\n            return false;\n        }\n\n        Hook& hook = it->second;\n        std::unique_lock<std::mutex> lock(hook.mtx);\n        \n        // Check if the hook is in BREAKPOINT mode\n        if (hook.mode != Hook::BREAKPOINT) {\n            return false;\n        }\n        \n        // Set the desired status and remove flag\n        hook.ready = true;\n        hook.toRemove = remove;\n\n        // If using NodeStatus results, ensure it's recorded/set here (omitted as NodeStatus impl. detail is unknown)\n        \n        // Notify all\n        hook.cv.notify_all();\n\n        return true;\n    }\n};", "CodeBleu_score": 52.85363765908233}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result, bool remove) {\n    std::lock_guard<std::mutex> lock(mutex_);\n\n    // Search for the node by its UID\n    auto it = std::find_if(nodes_.begin(), nodes_.end(), [node_uid](const NodeInfo& node) {\n        return node.uid == node_uid;\n    });\n\n    // Check if the node is found\n    if (it == nodes_.end()) {\n        return false;\n    }\n\n    // Check if the node has a valid hook\n    if (!it->hook) {\n        return false;\n    }\n\n    // Lock the hook's mutex\n    std::lock_guard<std::mutex> hookLock(it->hook->mutex);\n\n    // Check if the node's hook is in BREAKPOINT mode\n    if (it->hook->mode != HookMode::BREAKPOINT) {\n        return false;\n    }\n\n    // Update the hook's desired status and removal flag\n    it->hook->desiredStatus = result;\n    it->hook->remove = remove;\n\n    // Mark the hook as ready and notify all\n    it->hook->isReady = true;\n    it->hook->condition.notify_all();\n\n    return true;\n}", "CodeBleu_score": 47.00171022397942}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\n{\n    std::lock_guard<std::mutex> lock(mutex_);\n    auto node_iter = nodes_.find(node_uid);\n\n    if (node_iter == nodes_.end()) {\n        return false; // node UID not found\n    }\n\n    Node& node = node_iter->second;\n    if (!node.isValid()) {\n        return false; // node is not valid\n    }\n\n    Hook& hook = node.getHook();\n    std::lock_guard<std::mutex> hook_lock(hook.mutex);\n\n    if (hook.status != HookStatus::BREAKPOINT) {\n        return false; // not in BREAKPOINT mode\n    }\n\n    // Set hook status and other necessary flags\n    hook.result = result;\n    hook.remove = remove;\n\n    if (remove) {\n        hook.status = HookStatus::READY;\n    } else {\n        // Can reset to another specific status if needed\n        hook.status = HookStatus::ACTIVE;\n    }\n\n    hook.condition_variable.notify_all(); // Notify all threads waiting on this hook\n\n    return true;\n}\n", "CodeBleu_score": 47.62604994141718}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "#include <thread>\n#include <iostream>\n#include <future>\n#include <exception>\n\nenum NodeStatus { IDLE, RUNNING, SUCCESS, FAILURE };\n\nclass BT\n{\npublic:\n    class ThreadedAction\n    {\n    private:\n        std::atomic<bool> halt_requested_;\n        std::future<NodeStatus> future_status_;\n        std::exception_ptr stored_exception_ = nullptr;\n\n        NodeStatus tick()\n        {\n            // Simulate work\n            std::this_thread::sleep_for(std::chrono::seconds(1));\n            return SUCCESS; // as an example\n        }\n\n    public:\n        NodeStatus current_status_ = IDLE;\n\n        NodeStatus executeTick()\n        {\n            try\n            {\n                if (current_status_ == IDLE)\n                {\n                    current_status_ = RUNNING;\n                    halt_requested_ = false;\n                    stored_exception_ = nullptr;\n                    \n                    future_status_ = std::async(std::launch::async, [&]()\n                    {\n                        try\n                        {\n                            return tick();\n                        }\n                        catch (...)\n                        {\n                            stored_exception_ = std::current_exception();\n                            return FAILURE;\n                        }\n                    });\n                }\n\n                if (future_status_.valid() && future_status_.wait_for(std::chrono::seconds(0)) == std::future_status::ready)\n                {\n                    try\n                    {\n                        NodeStatus result = future_status_.get();\n                        current_status_ = result;\n                    }\n                    catch (...)\n                    {\n                        stored_exception_ = std::current_exception();\n                        current_status_ = FAILURE;\n                    }\n                }\n\n                if (stored_exception_)\n                {\n                    std::rethrow_exception(stored_exception_);\n                }\n            }\n            catch (const std::exception& e)\n            {\n                std::cerr << \"An error occurred: \" << e.what() << std::endl;\n                current_status_ = FAILURE;\n            }\n            catch (...)\n            {\n                std::cerr << \"An unknown error occurred.\" << std::endl;\n                current_status_ = FAILURE;\n            }\n\n            return current_status_;\n        }\n    };\n};\n\nint main()\n{\n    BT::ThreadedAction action;\n    NodeStatus result = action.executeTick();\n    std::cout << \"Initial call result: \" << result << std::endl;\n\n    // Wait to let the thread complete\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n\n    result = action.executeTick();\n    std::cout << \"Second call result: \" << result << std::endl;\n\n    return 0;\n}", "CodeBleu_score": 38.89161362908596}, {"code": "NodeStatus BT::ThreadedAction::executeTick() {\n    try {\n        if (status_ == NodeStatus::IDLE) {\n            // Set node status to RUNNING\n            status_ = NodeStatus::RUNNING;\n\n            // Reset halt_requested_ flag\n            halt_requested_ = false;\n\n            // Launch tick function in a new thread\n            future_ = std::async(std::launch::async, [this]{\n                try {\n                    return tick(); // Call the user-defined tick function\n                } catch (...) {\n                    // Catch and store any exception from tick() to handle later\n                    exception_ptr_ = std::current_exception();\n                    return NodeStatus::FAILURE;\n                }\n            });\n        }\n\n        if (future_.valid() && future_.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {\n            try {\n                // Get the result of the tick\n                status_ = future_.get();\n\n                // If halt was requested, ensure the node status reflects it\n                if (status_ == NodeStatus::RUNNING && halt_requested_) {\n                    status_ = NodeStatus::FAILURE;\n                }\n\n            } catch (...) {\n                // Handle any exception thrown from future_.get()\n                status_ = NodeStatus::FAILURE;\n                if (exception_ptr_ == nullptr) {\n                    exception_ptr_ = std::current_exception();\n                }\n            }\n        }\n\n        // Check if there is any exception stored and rethrow it\n        if (exception_ptr_ != nullptr) {\n            std::rethrow_exception(exception_ptr_);\n            // Optionally reset exception_ptr_ here if processing is complete\n        }\n    } catch (const std::exception& e) {\n        // Log the error\n        // Assuming logError function exists\n        logError(e.what());\n\n        // Set status to IDLE because of failure or error\n        status_ = NodeStatus::IDLE;\n    }\n\n    return status_;\n}", "CodeBleu_score": 44.183900733077444}, {"code": "#include <thread>\n#include <future>\n#include <exception>\n\nNodeStatus BT::ThreadedAction::executeTick() {\n    // Check the initial state and set RUNNING if needed.\n    if (status_ == NodeStatus::IDLE) {\n        status_ = NodeStatus::RUNNING;\n        halt_requested_ = false;\n\n        // Start a new thread to execute the tick function asynchronously.\n        std::future<void> future = std::async(std::launch::async, [this]() {\n            try {\n                tick();  // Call the user-defined tick function.\n\n                if (!halt_requested_) {\n                    // If halt wasn't requested, update the status.\n                    status_ = NodeStatus::SUCCESS;  // Assuming the tick completes successfully.\n                }\n            } catch (const std::exception& e) {\n                // Log error and revert status if an exception occurs.\n                std::cerr << \"Exception caught in tick function: \" << e.what() << std::endl;\n                status_ = NodeStatus::FAILURE;\n            }\n        });\n\n        try {\n            future.get(); // Wait for the thread to complete or throw any stored exception.\n        } catch (const std::exception& e) {\n            // Log any exceptions caught from the asynchronous operation.\n            std::cerr << \"Exception caught from future: \" << e.what() << std::endl;\n            status_ = NodeStatus::FAILURE;\n        }\n    } \n    \n    // Return the final status of the node.\n    return status_;\n}", "CodeBleu_score": 46.97102764288261}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "#include <iostream>\n#include <string>\n\n// Assuming TreeNode, ControlNode, and DecoratorNode are defined as below with polymorphic behavior.\nstruct TreeNode {\n    virtual void print(std::ostream& stream, int depth) const = 0;\n};\n\nstruct ControlNode : public TreeNode {\n    std::vector<TreeNode*> children;\n    std::string name;\n\n    ControlNode(const std::string& name) : name(name) {}\n    void print(std::ostream& stream, int depth) const override {\n        stream << std::string(depth * 2, ' ') << name << \" (ControlNode)\\n\";\n        for (auto child : children) {\n            child->print(stream, depth + 1);\n        }\n    }\n};\n\nstruct DecoratorNode : public TreeNode {\n    TreeNode* child;\n    std::string name;\n\n    DecoratorNode(const std::string& name, TreeNode* child) : name(name), child(child) {}\n    void print(std::ostream& stream, int depth) const override {\n        stream << std::string(depth * 2, ' ') << name << \" (DecoratorNode)\\n\";\n        if(child != nullptr) {\n            child->print(stream, depth + 1);\n        }\n    }\n};\n\n// Given function implementation.\nvoid printTreeRecursively(const TreeNode* root_node, std::ostream& stream) {\n    if (!root_node) {\n        return;\n    }\n\n    stream << \"--------Start of Tree Structure--------\\n\";\n    \n    auto recursivePrint = [&](const TreeNode* node, auto& ref, int depth = 0) -> void {\n        node->print(stream, depth);\n    };\n\n    recursivePrint(root_node, recursivePrint, 0);\n    \n    stream << \"---------End of Tree Structure---------\\n\";\n}\n\n// Example usage\nint main() {\n    DecoratorNode d1(\"Decorator1\", nullptr);\n    ControlNode c1(\"ControlNode1\");\n    c1.children.push_back(&d1);\n    \n    printTreeRecursively(&c1, std::cout);\n\n    return 0;\n}", "CodeBleu_score": 41.63163098496984}, {"code": "#include <iostream>\n#include <vector>\n#include <string>\n\n// Assuming the TreeNode definition and types of nodes like ControlNode and DecoratorNode\nclass TreeNode {\npublic:\n    std::string name;\n    std::vector<TreeNode*> children;\n    \n    virtual ~TreeNode() {}\n    virtual bool isControlNode() const { return false; }\n    virtual bool isDecoratorNode() const { return false; }\n};\n\nclass ControlNode : public TreeNode {\npublic:\n    bool isControlNode() const override { return true; }\n};\n\nclass DecoratorNode : public TreeNode {\npublic:\n    TreeNode* child;\n    DecoratorNode() : child(nullptr) {}\n    bool isDecoratorNode() const override { return true; }\n};\n\nvoid printTreeRecursively(const TreeNode* root_node, std::ostream& stream) {\n    if (!root_node) return;\n\n    // Lambda function to print the tree recursively\n    std::function<void(const TreeNode*, int)> printNode = [&](const TreeNode* node, int depth) {\n        // Create indentation based on the depth of the node\n        std::string indent(depth * 2, ' ');\n\n        // Print node name with indentation\n        stream << indent << node->name << \"\\n\";\n\n        // Recursively print children if it's a ControlNode\n        if (node->isControlNode()) {\n            for (const auto& child : node->children) {\n                printNode(child, depth + 1);\n            }\n        }\n        // Or the single child if it's a DecoratorNode\n        else if (node->isDecoratorNode()) {\n            const DecoratorNode* decorator = static_cast<const DecoratorNode*>(node);\n            if (decorator->child) {\n                printNode(decorator->child, depth + 1);\n            }\n        }\n    };\n\n    // Start separator\n    stream << \"---------- TREE START ----------\\n\";\n\n    // Initial call to the lambda function with depth 0\n    printNode(root_node, 0);\n\n    // Ending separator\n    stream << \"----------- TREE END -----------\\n\";\n}", "CodeBleu_score": 38.938803841532604}, {"code": "#include <iostream>\n\n// Definition for TreeNode and its derived classes ControlNode and DecoratorNode\nclass TreeNode {\npublic:\n    virtual void printNode(std::ostream& stream, int depth) const = 0;\n};\n\nclass ControlNode : public TreeNode {\npublic:\n    std::vector<TreeNode*> children;\n    \n    ControlNode(std::initializer_list<TreeNode*> node_list) : children(node_list) {}\n\n    void printNode(std::ostream& stream, int depth) const override {\n        for (auto child : children) {\n            child->printNode(stream, depth + 1);\n        }\n    }\n};\n\nclass DecoratorNode : public TreeNode {\npublic:\n    TreeNode* child;\n\n    DecoratorNode(TreeNode* c) : child(c) {}\n    \n    void printNode(std::ostream& stream, int depth) const override {\n        child->printNode(stream, depth + 1);\n    }\n};\n\nclass LeafNode : public TreeNode {\npublic:\n    std::string name;\n    \n    LeafNode(std::string n) : name(n) {}\n    \n    void printNode(std::ostream& stream, int depth) const override {\n        stream << std::string(depth * 4, ' ') << name << \"\\n\";\n    }\n};\n\nvoid printTreeRecursively(const TreeNode* root_node, std::ostream& stream) {\n    // Recursive lambda function to print nodes\n    std::function<void(const TreeNode*, int)> printTree = [&](const TreeNode* node, int depth) {\n        if (!node) return;  // In case of a null node\n        node->printNode(stream, depth);  // Print current node\n    };\n  \n    // Print separator line before starting the tree output\n    stream << \"---- Tree Start ----\\n\";\n  \n    // Start recursion from the root node with depth 0\n    printTree(root_node, 0);\n  \n    // Print separator line after completing the tree output\n    stream << \"---- Tree End ----\\n\";\n}", "CodeBleu_score": 34.07622007614053}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "#include <stdexcept> // for std::logic_error\n#include <functional> // for std::function\n\n// Assuming the tree structure definitions and TreeNode class presence\nclass TreeNode {\npublic:\n    virtual void accept(const std::function<void(const TreeNode*)>& visitor) const = 0; // Accept a visitor\n};\n\nclass ControlNode : public TreeNode {\nprivate:\n    std::vector<TreeNode*> children; // List of children nodes\npublic:\n    const std::vector<TreeNode*>& getChildren() const { return children; }\n    void accept(const std::function<void(const TreeNode*)>& visitor) const override {\n        visitor(this);\n        for (const auto& child : children) {\n            child->accept(visitor); // Recursively visit children\n        }\n    }\n};\n\nclass DecoratorNode : public TreeNode {\nprivate:\n    TreeNode* child; // Single child node\npublic:\n    TreeNode* getChild() const { return child; }\n    void accept(const std::function<void(const TreeNode*)>& visitor) const override {\n        visitor(this);\n        if (child) {\n            child->accept(visitor); // Recursively visit the child\n        }\n    }\n};\n\nvoid applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor) {\n    if (!node) {\n        throw std::logic_error(\"TreeNode cannot be null\");\n    }\n    node->accept(visitor); // leverage polymorphism to handle each type of node\n}", "CodeBleu_score": 31.97737460572584}, {"code": "#include <stdexcept>\n#include <functional>\n\nclass TreeNode {\npublic:\n    virtual ~TreeNode() = default;\n    virtual bool isControlNode() const { return false; }\n    virtual bool isDecoratorNode() const { return false; }\n    virtual const TreeNode* getChild() const { return nullptr; }\n    virtual std::vector<const TreeNode*> getChildren() const { return {}; }\n};\n\nclass ControlNode : public TreeNode {\npublic:\n    bool isControlNode() const override { return true; }\n    std::vector<const TreeNode*> getChildren() const override {\n        // return actual children nodes.\n    }\n};\n\nclass DecoratorNode : public TreeNode {\npublic:\n    bool isDecoratorNode() const override { return true; }\n    const TreeNode* getChild() const override {\n        // return the single child node\n    }\n};\n\nvoid applyRecursiveVisitor(const TreeNode* node, const std::function<void(const TreeNode*)>& visitor) {\n    if (node == nullptr) {\n        throw std::logic_error(\"LogicError: node cannot be null\");\n    }\n\n    visitor(node);\n\n    if (node->isControlNode()) {\n        auto children = static_cast<const ControlNode*>(node)->getChildren();\n        for (const TreeNode* child : children) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (node->isDecoratorNode()) {\n        const TreeNode* child = static_cast<const DecoratorNode*>(node)->getChild();\n        applyRecursiveVisitor(child, visitor);\n    }\n}", "CodeBleu_score": 46.21960162075377}, {"code": "#include <stdexcept>  // Include for std::logic_error\n#include <functional> // Include for std::function\n\n// Assume TreeNode is an existing class and has some way to check the type of node and access children.\nclass TreeNode {\npublic:\n    virtual ~TreeNode() = default;\n    \n    // Assume these methods are defined elsewhere, for checking type and getting children.\n    virtual bool isControlNode() const = 0;\n    virtual bool isDecoratorNode() const = 0;\n    virtual std::vector<TreeNode*> getChildren() const = 0; // For ControlNode\n    virtual TreeNode* getChild() const = 0; // For DecoratorNode\n};\n\n// Actual implementation of applyRecursiveVisitor\nvoid applyRecursiveVisitor(const TreeNode* node, const std::function<void(const TreeNode*)>& visitor) {\n    if (node == nullptr) {\n        throw std::logic_error(\"LogicError: Attempted to visit a null node\");\n    }\n\n    // Visit the node itself\n    visitor(node);\n    \n    // Distinguish behavior based on the type of node\n    if (node->isControlNode()) {\n        // It's a control node, visit each child\n        for (TreeNode* child : node->getChildren()) {\n            applyRecursiveVisitor(child, visitor);\n        }\n    } else if (node->isDecoratorNode()) {\n        // It's a decorator node, visit its single child\n        TreeNode* child = node->getChild();\n        applyRecursiveVisitor(child, visitor);\n    }\n    // If it's not a Control or Decorator node but has other logic to handle further node types, you can extend here\n}", "CodeBleu_score": 41.85043004372309}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "#include <map>\n#include <string>\n#include <stdexcept> // For std::runtime_error\n\n// Assuming defined externally or in associated header files\nclass TreeNodeManifest {\npublic:\n    std::string registrationID; // Placeholder for Manifest's properties\n};\n\nclass NodeBuilder {\n    // Implementation depends on what a builder entails\n};\n\nclass BehaviorTreeException : public std::runtime_error {\npublic:\n    BehaviorTreeException(const std::string& msg) : std::runtime_error(msg) {}\n};\n\nclass BehaviorTreeFactory {\nprivate:\n    std::map<std::string, TreeNodeManifest> manifestMap;\n    std::map<std::string, NodeBuilder> builderMap;\n\npublic:\n    void registerBuilder(const TreeNodeManifest& manifest, const NodeBuilder& builder);\n};\n\n// Method implementation\nvoid BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest, const NodeBuilder& builder) {\n    std::string id = manifest.registrationID;\n\n    // Check if the ID is already used in either map\n    if (manifestMap.find(id) != manifestMap.end() || builderMap.find(id) != builderMap.end()) {\n        throw BehaviorTreeException(\"Registration ID already exists: \" + id);\n    }\n\n    // Insert the manifest and builder into their respective maps\n    manifestMap[id] = manifest;\n    builderMap[id] = builder;\n}", "CodeBleu_score": 33.02202089220822}, {"code": "#include <map>\n#include <string>\n#include <stdexcept>\n\nclass TreeNodeManifest {\n    std::string id;\npublic:\n    const std::string& getId() const { return id; }\n};\n\nclass NodeBuilder {\n    // Implementation details of NodeBuilder\n};\n\nclass BehaviorTreeException : public std::runtime_error {\npublic:\n    BehaviorTreeException(const std::string& message) : std::runtime_error(message) {}\n};\n\nclass BehaviorTreeFactory {\n    std::map<std::string, TreeNodeManifest> manifests;\n    std::map<std::string, NodeBuilder> builders;\n\npublic:\n    void registerBuilder(const TreeNodeManifest& manifest, const NodeBuilder& builder) {\n        std::string id = manifest.getId();\n\n        // Check if the ID already exists in either map\n        if (manifests.find(id) != manifests.end() || builders.find(id) != builders.end()) {\n            throw BehaviorTreeException(\"Builder for node with ID '\" + id + \"' is already registered.\");\n        }\n\n        // Insert the manifest and builder into the maps\n        manifests.insert({id, manifest});\n        builders.insert({id, builder});\n    }\n};", "CodeBleu_score": 40.25309829377613}, {"code": "#include <map>\n#include <string>\n#include <stdexcept>\n\nclass BehaviorTreeException : public std::runtime_error {\npublic:\n    explicit BehaviorTreeException(const std::string& msg) : std::runtime_error(msg) {}\n};\n\nstruct TreeNodeManifest {\n    std::string registrationID;\n    // possibly other fields\n};\n\nstruct NodeBuilder {\n    // Definition depends on what the builder should do\n};\n\nclass BehaviorTreeFactory {\nprivate:\n    std::map<std::string, TreeNodeManifest> manifestMap;\n    std::map<std::string, NodeBuilder> builderMap;\n\npublic:\n    void registerBuilder(const TreeNodeManifest& manifest, const NodeBuilder& builder) {\n        std::string regID = manifest.registrationID;\n\n        // Check if the registration ID already exists in the builder map\n        if (builderMap.find(regID) != builderMap.end()) {\n            throw BehaviorTreeException(\"Builder with this registration ID already exists.\");\n        }\n\n        // Insert the builder and manifest into their respective maps\n        builderMap[regID] = builder;\n        manifestMap[regID] = manifest;\n    }\n\n    // Possibly other methods\n};", "CodeBleu_score": 31.791376306795133}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "#include <functional>\n#include <map>\n#include <string>\n\nclass TreeNodeManifest {\npublic:\n    std::string type;\n    std::string ID;\n    PortsList ports;\n\n    TreeNodeManifest(const std::string& node_type, const std::string& id, PortsList ports_list)\n        : type(node_type), ID(id), ports(std::move(ports_list)) {}\n};\n\nclass SimpleActionNode {\npublic:\n    typedef std::function<BT::NodeStatus()> TickFunctor;\n\n    TickFunctor tick_functor;\n    PortsList ports;\n\n    SimpleActionNode(const TickFunctor& tick, const PortsList& pl)\n        : tick_functor(tick), ports(pl) {}\n\n    BT::NodeStatus tick() {\n        return tick_functor();\n    }\n};\n\nusing NodeBuilder = std::function<SimpleActionNode*(const TreeNodeManifest&)>;\n\nclass BehaviorTreeFactory {\nprivate:\n    std::map<std::string, NodeBuilder> builders;\n\npublic:\n    void registerBuilder(const std::string& ID, const NodeBuilder& builder) {\n        builders[ID] = builder;\n    }\n\n    void registerSimpleAction(const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor, PortsList ports) {\n        // Lambda to create a SimpleActionNode given a TreeNodeManifest\n        NodeBuilder builder = [tick_functor, ports] (const TreeNodeManifest& manifest) {\n            return new SimpleActionNode(tick_functor, ports);\n        };\n\n        // Create a TreeNodeManifest object for this action\n        TreeNodeManifest manifest(\"SimpleActionNode\", ID, ports);\n\n        // Register the builder and manifest\n        registerBuilder(ID, builder);\n    }\n};", "CodeBleu_score": 49.39850270044362}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\n{\n    // Define the NodeBuilder lambda that constructs a SimpleActionNode.\n    auto node_builder = [tick_functor, ports](const std::string& name, const BT::NodeConfiguration& config) -> BT::TreeNode*\n    {\n        // Ensure that the provided configuration matches the ports defined.\n        if (!config.verifyRequiredPorts(ports))\n        {\n            throw BT::RuntimeError(\"Mismatch between the required ports and the provided configuration.\");\n        }\n        \n        // Create a new instance of SimpleActionNode passing the tick functor and the port configuration.\n        return new SimpleActionNode(name, tick_functor, config);\n    };\n\n    // Define a TreeNodeManifest to describe the node.\n    TreeNodeManifest manifest;\n    manifest.type = NodeType::ACTION;\n    manifest.ID = ID;\n    manifest.ports = ports;\n\n    // Register the builder and the manifest with the behavior tree factory.\n    registerBuilder(manifest, node_builder);\n}", "CodeBleu_score": 55.62812770477296}, {"code": "#include \"behavior_tree_factory.h\"\n#include \"simple_action_node.h\"\n#include \"tree_node_manifest.h\"\n\nvoid BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, \n    const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\n{\n    // NodeBuilder is a lambda that takes a blackboard and returns a TreeNode.\n    // It captures ID, tick_functor and ports by value.\n    NodeBuilder builder = [ID, tick_functor, ports](const Blackboard::Ptr& blackboard) -> TreeNode::Ptr {\n        // Create a new SimpleActionNode using the captured tick_functor and blackboard.\n        auto node = std::make_shared<SimpleActionNode>(ID, blackboard, tick_functor);\n        \n        // Initialize the node ports if necessary.\n        node->setPortsList(ports);\n        \n        // Return the node as a TreeNode pointer.\n        return node;\n    };\n\n    // Create a TreeNodeManifest for this action node.\n    TreeNodeManifest manifest;\n    manifest.type = NodeType::ACTION;\n    manifest.ID = ID;\n    \n    // Set the port list in the manifest.\n    manifest.ports = ports;\n\n    // Call registerBuilder to register the manifest and the NodeBuilder.\n    registerBuilder(manifest, builder);\n}", "CodeBleu_score": 57.8733766419306}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "#include <vector>\n#include <memory>  // For std::unique_ptr or std::shared_ptr\n\nclass Blackboard {\npublic:\n    using Ptr = std::shared_ptr<Blackboard>;\n\n    // Assuming a clone method exists that creates a deep copy of the Blackboard\n    Ptr clone() const {\n        // Implement the clone method correctly in the Blackboard class.\n        return std::make_shared<Blackboard>(*this);\n    }\n    \n    // Other relevant functions and data members of Blackboard\n};\n\nclass Tree {\npublic:\n    int getNumberOfSubTrees() const {\n        // Implement this method to return the number of subtrees\n    }\n    \n    const Blackboard& getSubtreeBlackboard(int index) const {\n        // Implement this to fetch the Blackboard for a given subtree by index\n    }\n    \n    // Other relevant functions and data members of Tree\n};\n\nstd::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree) {\n    int numberOfSubTrees = tree.getNumberOfSubTrees();\n    std::vector<Blackboard::Ptr> backups;\n    backups.reserve(numberOfSubTrees);\n\n    for (int i = 0; i < numberOfSubTrees; ++i) {\n        const Blackboard& originalBlackboard = tree.getSubtreeBlackboard(i);\n        Blackboard::Ptr backupBlackboard = originalBlackboard.clone();\n        backups.push_back(backupBlackboard);\n    }\n\n    return backups;\n}", "CodeBleu_score": 39.97113452006048}, {"code": "#include <vector>\n\nclass Blackboard {\npublic:\n    using Ptr = std::shared_ptr<Blackboard>;\n\n    // Suppose there's a method to clone a Blackboard\n    Ptr clone() const {\n        // Create a new Blackboard and copy data from this one\n        auto newBlackboard = std::make_shared<Blackboard>(*this);\n        return newBlackboard;\n    }\n};\n\nclass Tree {\npublic:\n    std::vector<Tree> subtrees;\n    Blackboard::Ptr blackboard;\n\n    // Function to access the subtrees\n    const std::vector<Tree>& getSubtrees() const {\n        return subtrees;\n    }\n\n    // Function to access the blackboard\n    Blackboard::Ptr getBlackboard() const {\n        return blackboard;\n    }\n\n    size_t countSubtrees() const {\n        return subtrees.size();\n    }\n};\n\nstd::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree) {\n    std::vector<Blackboard::Ptr> backups;\n    // Reserve space in the vector based on the number of subtrees\n    backups.reserve(tree.countSubtrees());\n\n    // Backup each subtree's blackboard\n    for (const auto& subtree : tree.getSubtrees()) {\n        // Clone the blackboard\n        Blackboard::Ptr clonedBlackboard = subtree.getBlackboard()->clone();\n        // Store it in the vector\n        backups.push_back(clonedBlackboard);\n    }\n\n    return backups;\n}", "CodeBleu_score": 36.07381380032207}, {"code": "#include <vector>\n#include <memory> // For std::unique_ptr or std::shared_ptr\n\n// Assuming Blackboard is a class with clone functionality and Ptr is a type of smart pointer (e.g., std::shared_ptr).\nclass Blackboard {\npublic:\n    // Assuming a clone function exists that creates a deep copy of the Blackboard.\n    std::shared_ptr<Blackboard> Clone() const {\n        // Implementation of Clone function which should return a new Blackboard instance as a shared_ptr.\n        return std::make_shared<Blackboard>(*this);\n    }\n    // You may need additional member functions or data here.\n};\n\n// Assuming Tree class have a function to get subtrees and access their blackboards.\nclass Tree {\npublic:\n    std::vector<Tree> subtrees;  // Vector of subtrees.\n    std::shared_ptr<Blackboard> blackboard;  // Each tree has a blackboard.\n    \n    size_t GetNumberOfSubtrees() const { return subtrees.size(); }\n    std::shared_ptr<Blackboard> GetSubtreeBlackboard(size_t index) const {\n        if (index >= subtrees.size()) throw std::out_of_range(\"Subtree index is out of range.\");\n        return subtrees[index].blackboard;\n    }\n};\n\nstd::vector<std::shared_ptr<Blackboard>> BlackboardBackup(const Tree& tree) {\n    size_t numSubtrees = tree.GetNumberOfSubtrees();\n    std::vector<std::shared_ptr<Blackboard>> backups;\n    backups.reserve(numSubtrees);\n\n    for (size_t i = 0; i < numSubtrees; ++i) {\n        std::shared_ptr<Blackboard> originalBlackboard = tree.GetSubtreeBlackboard(i);\n        if (originalBlackboard) {\n            // Cloning the blackboard and adding to the backup list.\n            backups.push_back(originalBlackboard->Clone());\n        } else {\n            // Handling the case where a blackboard might not exist.\n            backups.push_back(nullptr);\n        }\n    }\n\n    return backups;\n}", "CodeBleu_score": 33.72326284003162}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "#include <string>\n#include \"BT/Expected.h\"\n#include \"Ast/Environment.h\"\n#include \"Any.h\"\n#include \"ScriptParser.h\"\n\nBT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script) {\n    // Call the ParseScript function to attempt parsing the script into an executable form\n    auto executor = ParseScript(script);\n    \n    // Check if the parsing was successful\n    if (!executor) {\n        // If there was an error during parsing, forward the error using make_unexpected\n        return nonstd::make_unexpected(executor.error());\n    }\n    \n    // If parsing was successful, try to execute the script\n    try {\n        // Execute the script within the provided environment\n        Any result = executor->Execute(env);\n        // Return the result of the script execution\n        return BT::Expected<Any>(result);\n    } catch (const std::exception& e) {\n        // Handle any exceptions that might occur during execution by forwarding an error\n        return nonstd::make_unexpected(std::runtime_error(e.what()));\n    } catch (...) {\n        // A catch-all for any other exceptions\n        return nonstd::make_unexpected(std::runtime_error(\"Unhandled exception during script execution\"));\n    }\n}", "CodeBleu_score": 62.57619843757195}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script) {\n    // First, attempt to parse the script using ParseScript\n    auto parseResult = ParseScript(script);\n    if (!parseResult) {\n        // If parsing fails, forward the error\n        return nonstd::make_unexpected(parseResult.error());\n    }\n\n    // If parsing is successful, retrieve the executor from the parsed result\n    auto& executor = *parseResult;\n\n    try {\n        // Execute the script in the provided environment\n        Any result = executor(env);\n        return result;\n    } catch (const std::exception &e) {\n        // If execution fails, forward the exception as a BT::Error\n        return nonstd::make_unexpected(BT::Error{e.what()});\n    } catch (...) {\n        // Catch any other kinds of exceptions\n        return nonstd::make_unexpected(BT::Error{\"Unknown execution error\"});\n    }\n}", "CodeBleu_score": 54.734888662776726}, {"code": "#include <nonstd/expected.hpp>\n#include \"Ast.h\"\n#include <string>\n#include <iostream>\n\nnamespace BT {\n\n// Placeholder types if they are not defined (to make the example complete)\nstruct Any {};\n\n// Function to interpret and execute the script, assumed signature\nExpected<Any> ParseScript(const std::string& script);\n\nExpected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script) {\n    // Attempt to parse the script\n    Expected<Any> executor = ParseScript(script);\n    \n    // Check if the parsing was successful\n    if (!executor) {\n        // Forward the parsing error\n        return nonstd::make_unexpected(executor.error());\n    }\n\n    // If parsing was successful, execute in environment\n    try {\n        // Assuming executor's value has a callable form for execution\n        // and takes environment as a parameter\n        return executor.value()(env);\n    } catch (const std::exception& e) {\n        // Handle possible exceptions during execution\n        return nonstd::make_unexpected(e.what());\n    }\n}\n\n} // end namespace BT", "CodeBleu_score": 56.768427278766595}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "#include <dlfcn.h>\n#include <mutex>\n#include <stdexcept>\n\nclass SharedLibrary {\npublic:\n    void load(const std::string& path);\n\nprivate:\n    void* handle = nullptr;\n    std::string loadedPath;\n    std::mutex mutex;\n};\n\nvoid SharedLibrary::load(const std::string& path) {\n    std::unique_lock<std::mutex> lock(mutex);  // Acquire lock for thread safety\n\n    // Check if a library has already been loaded\n    if (handle != nullptr) {\n        throw std::runtime_error(\"Library already loaded\");\n    }\n\n    // Try to load the library with RTLD_NOW | RTLD_GLOBAL\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        // If loading failed, obtain the error message from dlerror\n        const char* error = dlerror();\n        std::string errorMsg = \"Failed to load library: \";\n        if (error) {\n            errorMsg += error;\n        } else {\n            errorMsg += \"Unknown error\";\n        }\n        throw std::runtime_error(errorMsg);\n    }\n\n    // Store the path if loaded successfully\n    loadedPath = path;\n}", "CodeBleu_score": 53.40830904270928}, {"code": "#include <dlfcn.h>\n#include <stdexcept>\n#include <string>\n#include <mutex>", "CodeBleu_score": 6.781227504411437e-07}, {"code": "#include <dlfcn.h>\n#include <stdexcept>\n#include <mutex>\n#include <string>\n\nclass SharedLibrary {\nprivate:\n    void* handle = nullptr;\n    std::string library_path;\n    std::mutex mutex;\n\npublic:\n    // Tries to load a shared library from the given path.\n    void load(const std::string& path) {\n        std::unique_lock<std::mutex> lock(mutex); // Ensure thread safety with mutex\n\n        if (handle != nullptr) {\n            throw std::runtime_error(\"Library already loaded\");\n        }\n\n        // Load the library with RTLD_NOW and RTLD_GLOBAL flags\n        handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n        if (!handle) {\n            std::string error_msg = dlerror();\n            throw std::runtime_error(\"Failed to load library: \" + error_msg);\n        }\n\n        // Store the library path if loaded successfully\n        library_path = path;\n    }\n    \n    // Destructor to close the library if it's opened\n    ~SharedLibrary() {\n        if (handle) {\n            dlclose(handle);\n            handle = nullptr;\n        }\n    }\n};", "CodeBleu_score": 49.41150659844061}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "#include <cctype>  // For std::isspace\n\nbool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer) {\n    // Step 1: Check if the string is at least 3 characters long.\n    if (str.length() < 3) {\n        return false;\n    }\n\n    // Step 2: Strip leading and trailing white spaces.\n    size_t start = 0;\n    size_t end = str.length() - 1;\n\n    while (start <= end && std::isspace(str[start])) {\n        ++start;\n    }\n\n    while (end >= start && std::isspace(str[end])) {\n        --end;\n    }\n\n    // Check if any characters are left.\n    if (start > end) {\n        return false;\n    }\n\n    // Step 3: Check if the stripped string starts with '{' and ends with '}'.\n    if (str[start] != '{' || str[end] != '}') {\n        return false;\n    }\n\n    // Assign inner content to stripped_pointer if provided and valid.\n    if (stripped_pointer != nullptr) {\n        // Create a StringView of the inner content without the brackets.\n        *stripped_pointer = StringView(str.data() + start + 1, end - start - 1);\n    }\n\n    // If all conditions are satisfied, the string is a valid blackboard pointer.\n    return true;\n}", "CodeBleu_score": 51.79988413835703}, {"code": "#include <string>\n#include <algorithm>\n\nclass TreeNode {\npublic:\n    bool isBlackboardPointer(const std::string& str, std::string* stripped_pointer = nullptr) {\n        if (str.size() < 3) {\n            return false;\n        }\n\n        // Strip leading and trailing whitespaces\n        auto start = str.find_first_not_of(' ');\n        auto end = str.find_last_not_of(' ');\n\n        if (start == std::string::npos || end == std::string::npos) {\n            return false; // entire string is whitespace\n        }\n\n        std::string trimmed = str.substr(start, (end - start + 1));\n\n        // Check if it starts with '{' and ends with '}'\n        if (trimmed.front() == '{' && trimmed.back() == '}') {\n            if (stripped_pointer != nullptr) {\n                // Assign the inner content to stripped_pointer, without '{' and '}'\n                *stripped_pointer = trimmed.substr(1, trimmed.size() - 2);\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }\n};", "CodeBleu_score": 35.86339434490712}, {"code": "#include <string>\n\nclass TreeNode {\npublic:\n    bool isBlackboardPointer(const std::string& str, std::string* stripped_pointer) {\n        // Step 1: Check the minimum length requirement.\n        if (str.length() < 3) {\n            return false;\n        }\n\n        // Step 2: Strip leading and trailing spaces.\n        std::string trimmed;\n        \n        size_t first = str.find_first_not_of(' ');\n        size_t last = str.find_last_not_of(' ');\n        if (first == std::string::npos || last == std::string::npos) {\n            return false;  // Consists only of spaces\n        }\n\n        trimmed = str.substr(first, (last - first + 1));\n\n        // Step 3: Check if it starts with '{' and ends with '}'.\n        if (trimmed.front() != '{' || trimmed.back() != '}') {\n            return false;\n        }\n\n        // Step 4: If a valid pointer and stripped_pointer is provided, store the inner content.\n        if (stripped_pointer != nullptr) {\n            *stripped_pointer = trimmed.substr(1, trimmed.size() - 2);\n        }\n\n        // Since all checks passed, return true.\n        return true;\n    }\n};", "CodeBleu_score": 37.5919380237888}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "#include <algorithm>\n#include <vector>\n#include <cmath>\n\nclass CostmapModel {\npublic:\n    double lineCost(int x0, int y0, int x1, int y1) const {\n        double line_cost = 0.0; // Initialize line cost\n\n        int dx = abs(x1 - x0); // the change in x\n        int dy = abs(y1 - y0); // the change in y\n        int x = x0; // start x position\n        int y = y0; // start y position\n        int n = 1 + dx + dy; // Number of steps\n        int x_inc = (x1 > x0) ? 1 : -1; // x increment direction\n        int y_inc = (y1 > y0) ? 1 : -1; // y increment direction\n        int error = dx - dy; // calculate initial error\n        dx *= 2; // scale up dx\n        dy *= 2; // scale up dy\n\n        for (; n > 0; --n) {\n            double point_cost = getPointCost(x, y);\n            if (point_cost < 0) {\n                return point_cost; // return immediately if the point cost is negative\n            }\n            if (point_cost > line_cost) {\n                line_cost = point_cost; // update line cost if current point cost is higher\n            }\n            \n            if (error > 0) {\n                x += x_inc; // move in x direction\n                error -= dy; // adjust error\n            } else {\n                y += y_inc; // move in y direction\n                error += dx; // adjust error\n            }\n        }\n\n        return line_cost; // return the total line cost\n    }\n\n    double getPointCost(int x, int y) const {\n        // Placeholder for getting the cost of a point (x, y)\n        // This should interact with the costmap to retrieve specific point costs\n        // In a real implementation, cost retrieval from a costmap array would occur here.\n        return 0; // This is just a placeholder\n    }\n};", "CodeBleu_score": 38.48921675933086}, {"code": "#include <algorithm> // For max function\n\nclass CostmapModel {\npublic:\n    double lineCost(int x0, int y0, int x1, int y1) const {\n        double lineCost = 0.0;\n        \n        // Bresenham's Line Algorithm variables\n        int dx = std::abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n        int dy = -std::abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n        int err = dx + dy, e2; // error value e_xy\n        \n        while (true) {\n            double pointCost = getCost(x0, y0); // Assume getCost function exists to get the cost of a point, e.g., on a cost map\n            if (pointCost < 0) {\n                return pointCost; // Negative cost encountered, return immediately\n            }\n            lineCost = std::max(lineCost, pointCost); // Updating line cost to be the maximum cost found\n            \n            if (x0 == x1 && y0 == y1) break; // Line traversal complete\n            \n            e2 = 2 * err;\n            if (e2 >= dy) {\n                err += dy;\n                x0 += sx;\n            }\n            if (e2 <= dx) {\n                err += dx;\n                y0 += sy;\n            }\n        }\n        \n        return lineCost; // Return the maximum cost found along the line\n    }\n    \n    // Placeholder function for getCost \n    // It should properly interact with the internals of the actual cost map implementation\n    double getCost(int x, int y) const {\n        // Implementation details required: for now, return a constant cost, e.g., 1.0\n        return 1.0;\n    }\n};", "CodeBleu_score": 38.50573411666903}, {"code": "double CostmapModel::lineCost(int x0, int y0, int x1, int y1) const {\n    // Initialize the maximum line cost to zero\n    double line_cost = 0;\n\n    // Create LineIterator from start point (x0, y0) to end point (x1, y1)\n    LineIterator line_iter(x0, y0, x1, y1);\n\n    while (line_iter.isValid()) {  // Iterate through each point on the line\n        int x = line_iter.getX();  // Get x-coordinate of the current point\n        int y = line_iter.getY();  // Get y-coordinate of the current point\n\n        double point_cost = pointCost(x, y); // Calculate the cost of the current point\n        if (point_cost < 0) {\n            return point_cost; // If the point cost is negative, return it immediately\n        }\n        \n        if (point_cost > line_cost) {\n            line_cost = point_cost; // Update the line cost if the point cost is higher\n        }\n\n        line_iter.advance();  // Move to the next point\n    }\n    \n    return line_cost;  // Return the computed line cost\n}", "CodeBleu_score": 53.199371161718744}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "#include <ros/ros.h>\n#include <nav_msgs/Path.h>\n#include <geometry_msgs/PoseStamped.h>\n#include <vector>\n\n/*\n * This function, publishPlan, publishes a given path as a nav_msgs::Path message using a ROS publisher.\n * If the path is empty, it returns without doing anything.\n * It creates a nav_msgs::Path message and initializes its header with the frame_id and timestamp from the first pose in the path.\n * The function then copies each pose from the input path to the path message and publishes it using the provided ROS publisher.\n */\nvoid publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)  {\n    if (path.empty()) {\n        // Return if path is empty as there is nothing to publish.\n        ROS_INFO(\"Received an empty path, nothing to publish.\");\n        return;\n    }\n\n    // Create a Path message\n    nav_msgs::Path path_msg;\n    // Initialize its header using the frame_id and timestamp of the first pose in path\n    path_msg.header.frame_id = path.front().header.frame_id;\n    path_msg.header.stamp = path.front().header.stamp;\n\n    // Copy each pose from the input path to the path message\n    for (const auto& pose : path) {\n        path_msg.poses.push_back(pose);\n    }\n\n    // Use the provided ROS publisher to publish the path\n    pub.publish(path_msg);\n    ROS_INFO(\"Path published with %lu poses.\", path.size());\n}", "CodeBleu_score": 42.451200688914334}, {"code": "// Check if the input path is empty\n    if (path.empty()) {\n        return;\n    }\n\n    // Initialize the message\n    nav_msgs::Path path_msg;\n    \n    // Set the header of the message using the first pose in the path\n    path_msg.header.frame_id = path.front().header.frame_id;\n    path_msg.header.stamp = path.front().header.stamp;\n    \n    // Fill the message with poses from the input path\n    for (const auto& pose : path) {\n        path_msg.poses.push_back(pose);\n    }\n\n    // Publish the Path message\n    pub.publish(path_msg);\n}", "CodeBleu_score": 32.91358397560252}, {"code": "#include <ros/ros.h>\n#include <nav_msgs/Path.h>\n#include <geometry_msgs/PoseStamped.h>\n#include <vector>\n\nvoid publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {\n    if (path.empty()) {\n        ROS_WARN(\"Received an empty path, not publishing.\");\n        return;\n    }\n\n    nav_msgs::Path path_msg;\n    path_msg.header.stamp = path.front().header.stamp; // Assume all timestamps are the same or use the first one\n    path_msg.header.frame_id = path.front().header.frame_id; // Using the frame_id of the first pose\n\n    // Copy all poses from the input to the path message\n    path_msg.poses = path;\n\n    // Publish the path message\n    pub.publish(path_msg);\n\n    ROS_INFO(\"Path published with %lu poses\", path.size());\n}", "CodeBleu_score": 39.18128076613884}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "#include <nav_msgs/Odometry.h>\n\n/*\n * This function checks if a robot has stopped based on its odometry data. It compares the angular\n * and linear velocities from the odometry message to the given thresholds for rotational and\n * translational stopped velocities. If all velocities are below or equal to their respective\n * thresholds, it returns true, indicating that the robot has stopped.\n *\n * @param base_odom The odometry message containing the robot's current velocity.\n * @param rot_stopped_velocity The maximum rotational velocity (in radians per second) to consider\n *        the robot as stopped.\n * @param trans_stopped_velocity The maximum translational velocity (in meters per second) to\n *        consider the robot as stopped.\n * @return true if the robot's velocities are below the thresholds, false otherwise.\n */\nbool stopped(const nav_msgs::Odometry& base_odom, const double& rot_stopped_velocity, const double& trans_stopped_velocity) {\n    // Extract the linear and angular velocity components from the odometry message\n    double linear_x = base_odom.twist.twist.linear.x;\n    double linear_y = base_odom.twist.twist.linear.y;\n    double angular_z = base_odom.twist.twist.angular.z;\n\n    // Compute the magnitude of the translational velocity\n    double trans_velocity_magnitude = sqrt(linear_x * linear_x + linear_y * linear_y);\n\n    // Check if both the translational and rotational velocities are below their respective thresholds\n    if (trans_velocity_magnitude <= trans_stopped_velocity && fabs(angular_z) <= rot_stopped_velocity) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 51.249569829915295}, {"code": "#include <nav_msgs/Odometry.h>\n\n/*\n * Function to determine if a robot has stopped.\n *\n * Parameters:\n *   base_odom - the odometry message containing linear and angular velocities\n *   rot_stopped_velocity - the threshold below which the angular velocity is considered as stopped\n *   trans_stopped_velocity - the threshold below which the linear velocity is considered as stopped\n *\n * Returns:\n *   bool - true if the robot has stopped based on the given thresholds, false otherwise\n */\nbool stopped(const nav_msgs::Odometry& base_odom, \n             const double& rot_stopped_velocity, \n             const double& trans_stopped_velocity) {\n    // Extract linear and angular velocities from the odom message\n    double lin_vel_x = base_odom.twist.twist.linear.x;\n    double lin_vel_y = base_odom.twist.twist.linear.y;\n    double ang_vel_z = base_odom.twist.twist.angular.z;\n    \n    // Calculate the magnitudes of the velocities\n    double linear_velocity = sqrt(lin_vel_x * lin_vel_x + lin_vel_y * lin_vel_y);\n    double angular_velocity = fabs(ang_vel_z);\n    \n    // Compare to personal thresholds and return true if below thresholds\n    if (linear_velocity <= trans_stopped_velocity && angular_velocity <= rot_stopped_velocity) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 49.88090769209392}, {"code": "#include <nav_msgs/Odometry.h>\n\nbool stopped(const nav_msgs::Odometry& base_odom, \n             const double& rot_stopped_velocity, const double& trans_stopped_velocity) {\n    // Access the linear and angular velocities from the odometry message\n    double linear_velocity = sqrt(\n        base_odom.twist.twist.linear.x * base_odom.twist.twist.linear.x +\n        base_odom.twist.twist.linear.y * base_odom.twist.twist.linear.y +\n        base_odom.twist.twist.linear.z * base_odom.twist.twist.linear.z\n    );\n\n    double angular_velocity = sqrt(\n        base_odom.twist.twist.angular.x * base_odom.twist.twist.angular.x +\n        base_odom.twist.twist.angular.y * base_odom.twist.twist.angular.y +\n        base_odom.twist.twist.angular.z * base_odom.twist.twist.angular.z\n    );\n\n    // Compare the retrieved velocities against the thresholds\n    if (linear_velocity <= trans_stopped_velocity && angular_velocity <= rot_stopped_velocity) {\n        return true;  // The robot has stopped\n    } else {\n        return false; // The robot is still moving\n    }\n}", "CodeBleu_score": 44.44122103763054}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults) {\n    // Lock the configuration mutex to prevent other threads from accessing\n    // the configuration while it is being updated.\n    std::lock_guard<std::mutex> lock(configuration_mutex_);\n\n    if (setup_) {\n        // If the setup is already done, check if restoration of defaults is required\n        if (restore_defaults) {\n            // Restore the default settings\n            current_limits_ = default_limits_;\n        } else {\n            // Otherwise, update the current limits with the provided configuration\n            current_limits_ = config;\n        }\n    } else {\n        // If the setup has not been done yet\n        default_limits_ = config;           // Initialize the default limits\n        current_limits_ = config;           // Set the current limits\n        setup_ = true;                      // Mark setup as done\n    }\n}", "CodeBleu_score": 54.420202937416484}, {"code": "#include <mutex>\n#include <iostream>\n\n// Assume that LocalPlannerLimits is a structured data type to keep different planning parameters\nstruct LocalPlannerLimits {\n    double max_speed;\n    double min_speed;\n    double max_acceleration;\n    double min_acceleration;\n    \n    LocalPlannerLimits() : max_speed(0), min_speed(0), max_acceleration(0), min_acceleration(0) {}\n    \n    // Resets parameters to still unknown default values\n    void setDefault() {\n        max_speed = 1.0;\n        min_speed = 0.1;\n        max_acceleration = 0.5;\n        min_acceleration = 0.1;\n    }\n};\n\nclass LocalPlannerUtil {\nprivate:\n    LocalPlannerLimits current_limits;\n    std::mutex config_mutex;\n    bool is_setup_done = false;\n\npublic:\n    void reconfigureCB(LocalPlannerLimits &config, bool restore_defaults);\n};\n\nvoid LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults) {\n    std::lock_guard<std::mutex> lock(config_mutex);\n\n    if (restore_defaults) {\n        if (is_setup_done) { // If setup has already been done, apply default\n            current_limits.setDefault();\n        } else { // If setup is not done yet, initialize to defaults\n            current_limits = config;\n            current_limits.setDefault();\n            is_setup_done = true;\n        }\n    } else {\n        if (!is_setup_done) { // If setup has not been done, initialize and use given config\n            current_limits = config;\n            is_setup_done = true;\n        } else { // If setup is done, just update the limits with new config\n            current_limits = config;\n        }\n    }\n\n    std::cout << \"Current limits updated\" << std::endl;\n    std::cout << \"Max Speed: \" << current_limits.max_speed << \", Min Speed: \" << current_limits.min_speed << std::endl;\n    std::cout << \"Max Acceleration: \" << current_limits.max_acceleration << \", Min Acceleration: \" << current_limits.min_acceleration << std::endl;\n}\n\n// Example use case\nint main() {\n    LocalPlannerUtil planner;\n    LocalPlannerLimits new_config;\n    new_config.max_speed = 2.0;\n    new_config.min_speed = 0.5;\n    new_config.max_acceleration = 1.0;\n    new_config.min_acceleration = 0.2;\n\n    // First run without restoring defaults, initial setup\n    planner.reconfigureCB(new_config, false);\n\n    // Change configuration (simulating a dynamic update)\n    LocalPlannerLimits updated_config;\n    updated_config.max_speed = 1.5;\n    updated_config.min_speed = 0.3;\n    updated_config.max_acceleration = 0.8;\n    updated_config.min_acceleration = 0.15;\n    planner.reconfigureCB(updated_config, false);\n\n    // Restore default configuration\n    planner.reconfigureCB(updated_config, true);\n\n    return 0;\n}", "CodeBleu_score": 43.96967375088055}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults) {\n    // Lock the configuration mutex to prevent data races\n    std::lock_guard<std::mutex> lock(config_mutex_);\n\n    if (setup_) { // Check if the setup has been done\n        if (restore_defaults) {\n            // If restore_defaults flag is true, reset config to default\n            config = default_limits_;\n        } else {\n            // Update current_limits with the values from config\n            current_limits_ = config;\n        }\n    } else {\n        // If setup has not been done, initialize defaults from provided config\n        default_limits_ = config;\n        current_limits_ = config;\n        setup_ = true; // Mark setup as complete\n    }\n\n    // Optionally, you might log the reconfiguration event\n    // std::cout << \"Local Planner reconfigured, setup complete: \" << setup_ << std::endl;\n}", "CodeBleu_score": 58.24706068243187}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "const unsigned char* char_cost = costmap.getCharMap(); // Assuming Costmap2D provides accessibility to the map characters through getCharMap() method.\nunsigned int index = check_cell->x + check_cell->y * costmap.getSizeInCellsX(); // Calculate index for 1D char array map based on 2D x, y coordinates.\n\n// Define maximum obstacle cost\nconst unsigned char MAX_OBSTACLE_COST = 254;\n\n// Fetch cost for the check cell from costmap\nunsigned char cost = char_cost[index];\n\n// Check if the cell is an obstacle or unknown based on its cost value.\nif (cost == costmap_2d::NO_INFORMATION || cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_distance = MAX_OBSTACLE_COST;\n    return false;\n}\n\n// If it's not an obstacle, calculate a new potential target distance. For simplicity, assume some calculation method exists:\ndouble possible_target_distance = current_cell->target_distance + 1; // Hypothetical distance calculation\n\n// If the calculated distance is less than the current distance at the check cell, update it.\nif (possible_target_distance < check_cell->target_distance) {\n    check_cell->target_distance = possible_target_distance;\n}\n\nreturn true;", "CodeBleu_score": 48.042546975649095}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\n  // Retrieve the cost of the cell from the costmap\n  unsigned char cost = costmap.getCost(check_cell->cx, check_cell->cy);\n  \n  // The maximum obstacle cost threshold (typically corresponds to an insurmountable obstacle)\n  const unsigned char obstacle_threshold = costmap_2d::LETHAL_OBSTACLE;\n  const unsigned char NO_INFORMATION = costmap_2d::NO_INFORMATION;\n\n  // Check if the cell is an obstacle or has no information\n  if (cost == obstacle_threshold || cost == NO_INFORMATION) {\n    check_cell->target_dist = obstacle_threshold;  // Set target distance to maximum obstacle cost\n    return false; // Return false as the cell should not be used for pathfinding\n  }\n\n  // If the cell is traversable, compute a new target distance\n  float new_target_dist = current_cell->target_dist + 1; // Example calculation, can be adjusted depending on the movement cost model\n  \n  // Update the cell's target distance if the new distance is shorter\n  if (new_target_dist < check_cell->target_dist) {\n    check_cell->target_dist = new_target_dist;\n    return true;  // Return true as the cell was updated\n  }\n\n  // If no update was made, return false\n  return false;\n}", "CodeBleu_score": 62.90129135240699}, {"code": "// C++ definition of MapGrid::updatePathCell\ninline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n                                    const costmap_2d::Costmap2D& costmap) {\n    // Get the index of the check_cell.\n    unsigned int index = check_cell->index;\n    \n    // Retrieve the cost of the current cell from the costmap.\n    unsigned char cost = costmap.getCost(index);\n    \n    // Check if the cell is an obstacle or no information based on cost values.\n    if (cost == costmap_2d::LETHAL_OBSTACLE || cost == costmap_2d::NO_INFORMATION) {\n        // Cell is either an obstacle or there is no info, set its target distance to max obstacle cost.\n        check_cell->target_dist = costmap_2d::LETHAL_OBSTACLE; // Setting to max obstacle cost.\n        return false; // Since the cell can't be used for path, return false.\n    }\n\n    // Cell is not an obstacle.\n    // Calculate a new potential target distance assuming a straight line move.\n    double new_target_dist = current_cell->target_dist + hypot(current_cell->cx - check_cell->cx, current_cell->cy - check_cell->cy);\n    \n    // If the new calculated distance is shorter, update the check_cell's target distance.\n    if (new_target_dist < check_cell->target_dist) {\n        check_cell->target_dist = new_target_dist;\n    }\n    \n    // Return true since the cell can be used for pathfinding.\n    return true;\n}", "CodeBleu_score": 68.02888817202512}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "#include <iostream>\n#include <vector>\n\nclass Trajectory {\npublic:\n    struct Point {\n        double x, y, theta;\n    };\n\n    std::vector<Point> path;\n    double speed;\n};\n\nclass ObstacleCostFunction {\n    bool sum_scores_;\n    std::vector<Trajectory::Point> footprint_spec_;\n\npublic:\n    ObstacleCostFunction(bool sum_scores)\n    : sum_scores_(sum_scores) {}\n\n    void setFootprintSpecification(const std::vector<Trajectory::Point>& footprint) {\n        footprint_spec_ = footprint;\n    }\n\n    double scoreTrajectory(Trajectory &traj) {\n        double cost = 0.0;\n        double scaling_factor = 1.0 + traj.speed;\n\n        // Check if the footprint specification is empty\n        if (footprint_spec_.empty()) {\n            std::cerr << \"Error: Footprint specification is empty.\" << std::endl;\n            return -9;\n        }\n\n        for (const auto &point : traj.path) {\n            double footprint_cost = calculateFootprintCost(point.x, point.y, point.theta);\n\n            // If the footprint cost is negative, return immediately\n            if (footprint_cost < 0) {\n                return footprint_cost;\n            }\n\n            if (sum_scores_) {\n                cost += footprint_cost;\n            } else {\n                cost = std::max(cost, footprint_cost);\n            }\n        }\n\n        return scaling_factor * cost;\n    }\n\nprivate:\n    double calculateFootprintCost(double x, double y, double theta) {\n        // This function should be implemented to calculate the cost based on the provided point and footprint.\n        // Placeholder implementation:\n        return x + y - theta * 0.1; // This is a dummy function for demonstration purposes.\n    }\n};", "CodeBleu_score": 41.45935985173096}, {"code": "#include <iostream>\n#include <vector>\n#include <algorithm> // for max_element\n\nclass Trajectory {\npublic:\n    std::vector<std::pair<double, double>> points; // Points as pairs of (x, y)\n    double speed;\n};\n\nclass ObstacleCostFunction {\n    bool sum_scores_;\n    std::vector<std::pair<double, double>> footprint_specification;\n\npublic:\n    ObstacleCostFunction(bool sum_scores) : sum_scores_(sum_scores) {}\n\n    void setFootprintSpecification(const std::vector<std::pair<double, double>>& footprint) {\n        footprint_specification = footprint;\n    }\n\n    double footprintCost(const std::pair<double, double>& point) {\n        // Placeholder for computing the cost of landing at a given point\n        // Assuming a simple distance-based cost for the example\n        double cost = sqrt(point.first * point.first + point.second * point.second);\n        return cost > 10 ? -1 : cost; // -1 indicates an obstacle hit\n    }\n\n    double scoreTrajectory(Trajectory &traj) {\n        if (footprint_specification.empty()) {\n            std::cerr << \"Error: Footprint specification is empty.\\n\";\n            return -9;\n        }\n\n        double cost = 0;\n        double initial_scaling_factor = 1.0 + traj.speed / 10.0; // Some scaling based on speed\n\n        std::vector<double> costs;\n        for (auto &point : traj.points) {\n            double point_cost = footprintCost(point) * initial_scaling_factor;\n            if (point_cost < 0) {\n                return point_cost; // negative cost immediately return\n            }\n            costs.push_back(point_cost);\n        }\n\n        if (sum_scores_) {\n            // Sum all the positive costs\n            for (auto &c : costs) {\n                cost += c;\n            }\n        } else {\n            // Take the maximum cost found\n            cost = *std::max_element(costs.begin(), costs.end());\n        }\n\n        return cost;\n    }\n};\n\nint main() {\n    Trajectory traj;\n    traj.speed = 5;\n    traj.points = {{1, 2}, {3, 4}, {5, 5}, {8, 8}};\n\n    ObstacleCostFunction obstacleCost(true);\n    obstacleCost.setFootprintSpecification({{0, 1}, {1, 0}, {1, 1}});\n    \n    double score = obstacleCost.scoreTrajectory(traj);\n    std::cout << \"The score of the trajectory is: \" << score << std::endl;\n\n    return 0;\n}", "CodeBleu_score": 38.874942726502006}, {"code": "#include <vector>\n#include <iostream>\n\nstruct Point {\n    double x;\n    double y;\n};\n\nstruct Trajectory {\n    std::vector<Point> points;\n    double speed;\n};\n\nclass ObstacleCostFunction {\nprivate:\n    std::vector<Point> footprint_;\n    bool sum_scores_;\n\npublic:\n    ObstacleCostFunction(const std::vector<Point>& footprint, bool sum_scores)\n    : footprint_(footprint), sum_scores_(sum_scores) {}\n\n    double footprintCost(const Point& p) {\n        // For simplicity assuming a dummy footprint cost calculation\n        return p.x + p.y; // Replace with an actual computation based on the environment and obstacles\n    }\n\n    double scoreTrajectory(Trajectory &traj) {\n        if (footprint_.empty()) {\n            std::cerr << \"Error: empty footprint specification\\n\";\n            return -9;\n        }\n\n        double cost = 0.0;\n        double scaling_factor = std::max(1.0, traj.speed);\n\n        for (const auto& point : traj.points) {\n            double footprint_cost = footprintCost(point);\n            if (footprint_cost < 0) {\n                return footprint_cost; // return immediately if there is a negative cost\n            }\n            \n            if (sum_scores_) {\n                cost += footprint_cost; // sum the scores\n            }\n            else {\n                cost = std::max(cost, footprint_cost); // take the maximum score\n            }\n        }\n\n        return cost * scaling_factor;\n    }\n};\n\n// Example usage:\n// int main() {\n//     std::vector<Point> footPrint = {{0.0, 2.0}, {1.5, 3.0}};\n//     Trajectory t = { {{0,1}, {1,2}, {2,3}} , 1.2 };\n//     ObstacleCostFunction ocf(footPrint, true);\n//     double cost = ocf.scoreTrajectory(t);\n//     std::cout << \"Total Trajectory Cost: \" << cost << std::endl;\n// }", "CodeBleu_score": 39.88609932280463}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "#include <algorithm>\n#include <vector>\n#include <geometry_msgs/Point.h>\n#include <costmap_2d/Costmap2D.h>\n#include <base_local_planner/world_model.h>\n\ndouble ObstacleCostFunction::footprintCost(\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model) {\n    \n    // Check if the position is off the map\n    if (!costmap->worldToMap(x, y)) {\n        return -7.0;\n    }\n\n    // Scaling the footprint points\n    for (auto& point : footprint_spec) {\n        point.x = point.x * scale;\n        point.y = point.y * scale;\n    }\n\n    // Computing the footprint cost using the world model\n    double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec);\n\n    // If the footprint cost is negative, indicating an obstruction\n    if (footprint_cost < 0.0) {\n        return -6.0;\n    }\n\n    // Getting the cost of the cell at the given (x, y) position\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my)) {\n        return -7.0;  // In case the conversion fails\n    }\n    double cell_cost = static_cast<double>(costmap->getCost(mx, my));\n\n    // Return maximum of the footprint cost or the cell cost\n    return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 57.0520367462763}, {"code": "{\n    // Calculate the scaled footprint\n    std::vector<geometry_msgs::Point> scaled_footprint;\n    for (const auto& point : footprint_spec) {\n        geometry_msgs::Point scaled_point;\n        scaled_point.x = point.x * scale;\n        scaled_point.y = point.y * scale;\n        scaled_footprint.push_back(scaled_point);\n    }\n    \n    // Calculate the position of scaled footprint based on the input orientation (th) and position (x, y)\n    for (auto& point : scaled_footprint) {\n        double temp_x = point.x;\n        double temp_y = point.y;\n        // Rotate the point by 'th' radians and translate it\n        point.x = temp_x * cos(th) - temp_y * sin(th) + x;\n        point.y = temp_x * sin(th) + temp_y * cos(th) + y;\n    }\n    \n    // Check if the footprint is entirely on the map\n    for (const auto& point : scaled_footprint) {\n        unsigned int mx, my;\n        if (!costmap->worldToMap(point.x, point.y, mx, my)) {\n            return -7.0; // Position is off the map\n        }\n    }\n\n    // Calculate the footprint cost using the world model\n    double footprint_cost = world_model->footprintCost(x, y, th, scaled_footprint);\n    \n    if (footprint_cost < 0) {\n        return -6.0; // If the cost is negative, return -6.0 as per the specification\n    } \n\n    // Get the cost of the cell the robot is currently located at\n    unsigned int mx, my;    \n    if (!costmap->worldToMap(x, y, mx, my)) {\n        return -7.0; // If the position is off the map, return -7.0\n    }\n    double cell_cost = static_cast<double>(costmap->getCost(mx, my));\n\n    // Return the maximum of the footprint cost and the cell cost\n    return std::max(footprint_cost, cell_cost);\n}", "CodeBleu_score": 57.6177998301031}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\n    // First, scale the footprint according to the provided scale factor\n    for (auto& point : footprint_spec) {\n        point.x *= scale;\n        point.y *= scale;\n    }\n\n    // Use the world model to calculate the cost of the footprint at the scaled position\n    double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec);\n\n    // Check the return values based on cost calculation outcomes\n    if (footprint_cost < 0.0) {\n        return -6.0; // Negative cost indicates an invalid positioning of the footprint\n    }\n\n    // Check if the position is on the map\n    unsigned int mx, my;\n    if (!costmap->worldToMap(x, y, mx, my)) {\n        return -7.0; // Position is off the map\n    }\n\n    // Get the cell cost at the specified position from the costmap\n    unsigned char cost = costmap->getCost(mx, my);\n    if (footprint_cost < 0.0 || cost == costmap_2d::LETHAL_OBSTACLE) {\n        return -6.0; // Returned -6.0 if any obstacle inside the footprint or the cell is lethal\n    }\n\n    // Calculate the maximum cost encountered in the footprint or at the cell position\n    double max_cost = std::max(static_cast<double>(cost), footprint_cost);\n\n    return max_cost;\n}", "CodeBleu_score": 55.50493569768966}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "#include <ros/ros.h>\n#include <nav_msgs/Odometry.h>\n\nclass OdometryHelperRos {\npublic:\n    OdometryHelperRos(ros::NodeHandle& nh) : nh_(nh), current_odom_topic_(\"\") {}\n    \n    void odomCallback(const nav_msgs::Odometry::ConstPtr& msg) {\n        // Handle odometry message\n        // This can be custom implemented depending on the application needs.\n        ROS_INFO(\"Received odom data from %s\", current_odom_topic_.c_str());\n    }\n\n    void setOdomTopic(const std::string& odom_topic) {\n        if (current_odom_topic_ != odom_topic) {\n            // Unsubscribe from the current topic if it's not the new topic\n            if (!odom_subscriber_.getTopic().empty()) {\n                odom_subscriber_.shutdown();\n                ROS_INFO(\"Unsubscribed from %s\", current_odom_topic_.c_str());\n            }\n\n            current_odom_topic_ = odom_topic;\n\n            if (!odom_topic.empty()) {\n                // Subscribe to the new odometry topic\n                odom_subscriber_ = nh_.subscribe(odom_topic, 1000, &OdometryHelperRos::odomCallback, this);\n                ROS_INFO(\"Subscribed to %s\", odom_topic.c_str());\n            }\n        }\n    }\n    \nprivate:\n    ros::NodeHandle nh_;\n    ros::Subscriber odom_subscriber_;\n    std::string current_odom_topic_;\n};", "CodeBleu_score": 34.55566432765473}, {"code": "#include <ros/ros.h>\n#include <string>\n\nclass OdometryHelperRos {\nprivate:\n    std::string current_odom_topic_; // Stores the current odometry topic\n    ros::Subscriber odom_subscriber_; // ROS subscriber for odometry messages\n    ros::NodeHandle nh_; // Node handle for ROS operations\n\npublic:\n    // Constructor\n    OdometryHelperRos() : current_odom_topic_(\"\") {}\n    \n    // Setter for odometry topic\n    void setOdomTopic(const std::string &odom_topic) {\n        if (odom_topic != current_odom_topic_) {\n            // If there is an active subscription, unsubscribe first\n            if (!current_odom_topic_.empty()) {\n                odom_subscriber_.shutdown();\n                std::cout << \"Unsubscribed from old odometry topic: \" << current_odom_topic_ << std::endl;\n            }\n\n            current_odom_topic_ = odom_topic; // Update the current odometry topic\n\n            if (!current_odom_topic_.empty()) {\n                // Subscribe to the new topic if it's not empty\n                odom_subscriber_ = nh_.subscribe(current_odom_topic_, 1000, &OdometryHelperRos::odomCallback, this);\n                std::cout << \"Subscribed to new odometry topic: \" << current_odom_topic_ << std::endl;\n            }\n        }\n    }\n\n    // Callback for odometry subscriber\n    void odomCallback(const nav_msgs::Odometry::ConstPtr& msg) {\n        // Process the incoming odometry message\n        std::cout << \"Received odometry message from topic: \" << current_odom_topic_ << std::endl;\n    }\n};", "CodeBleu_score": 34.88895713772493}, {"code": "#include <ros/ros.h>\n#include <nav_msgs/Odometry.h>\n\nclass OdometryHelperRos {\nprivate:\n    ros::Subscriber odom_subscriber;\n    std::string current_odom_topic;\n    ros::NodeHandle node_handle;\n\n    void odomCallback(const nav_msgs::Odometry::ConstPtr& msg) {\n        // Process incoming odometry messages here\n        ROS_INFO(\"Received odometry from topic '%s'\", current_odom_topic.c_str());\n    }\n\npublic:\n    // Function to set the odometry topic\n    void setOdomTopic(const std::string& odom_topic) {\n        if (odom_topic != current_odom_topic) {\n            // If there is an active subscription, shut it down\n            if (!current_odom_topic.empty()) {\n                odom_subscriber.shutdown();\n                ROS_INFO(\"Shut down subscriber to old topic '%s'\", current_odom_topic.c_str());\n            }\n            \n            // Update the topic if the new one is not empty\n            if (!odom_topic.empty()) {\n                current_odom_topic = odom_topic;\n                odom_subscriber = node_handle.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n                ROS_INFO(\"Subscribed to new topic '%s'\", odom_topic.c_str());\n            } else {\n                current_odom_topic.clear();\n                ROS_INFO(\"Cleared the current odometry topic. No longer subscribing.\");\n            }\n        } else {\n            ROS_INFO(\"Attempted to set the same odometry topic as already active: '%s'\", odom_topic.c_str());\n        }\n    }\n};", "CodeBleu_score": 34.37082399220314}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "#include <Eigen/Dense>\n#include <cmath>\n\nclass OscillationCostFunction {\nprivate:\n    Eigen::Vector3f last_position_;\n    float x_threshold_sq_;\n    float th_threshold_;\n    bool oscillation_flag_;\n\npublic:\n    OscillationCostFunction(float distance_threshold, float angle_threshold)\n    : x_threshold_sq_(distance_threshold * distance_threshold), th_threshold_(angle_threshold), oscillation_flag_(false) {}\n\n    // Reset oscillation flags if distance or angular threshold is exceeded\n    void resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev) {\n        // Compute squared Euclidean distance in the XY plane\n        float dx = pos.x() - prev.x();\n        float dy = pos.y() - prev.y();\n        float squared_distance = dx * dx + dy * dy;\n\n        // Compute angular difference\n        float dtheta = std::abs(pos.z() - prev.z());\n\n        // Normalize the angular difference to the range of [0, 2*pi]\n        while (dtheta > M_PI) dtheta -= 2.0 * M_PI;\n        while (dtheta < -M_PI) dtheta += 2.0 * M_PI;\n        dtheta = std::abs(dtheta);\n\n        // Reset flags if thresholds are exceeded\n        if (squared_distance > x_threshold_sq_ || dtheta > th_threshold_) {\n            oscillation_flag_ = false;\n            std::cout << \"Oscillation flags reset due to sufficient movement or rotation.\" << std::endl;\n        } else {\n            oscillation_flag_ = true;\n            std::cout << \"Oscillation flags not reset; insufficient movement or rotation.\" << std::endl;\n        }\n    }\n\n    bool isOscillating() const {\n        return oscillation_flag_;\n    }\n};", "CodeBleu_score": 34.34096757979277}, {"code": "#include <Eigen/Dense>\n#include <cmath> // for std::abs and std's trigonometric functions\n\nclass OscillationCostFunction {\nprivate:\n    bool oscillation_x_;\n    bool oscillation_y_;\n    bool oscillation_theta_; // Assuming flags for oscillation along x, y, and rotation angle\n\n    float distance_threshold_ = 1.0f; // Example threshold values for distance\n    float angle_threshold_ = 0.1f; // Example threshold in radians\n\npublic:\n    OscillationCostFunction() : oscillation_x_(false), oscillation_y_(false), oscillation_theta_(false) {}\n\n    void resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev) {\n        // Calculating squared distance in x and y\n        float dx = pos[0] - prev[0];\n        float dy = pos[1] - prev[1];\n        float squared_distance = dx * dx + dy * dy;\n\n        // Calculating angular difference\n        float dtheta = std::abs(pos[2] - prev[2]);\n        \n        // Normalize dtheta to be within the range [0, 2*PI]\n        // Ensuring that the angle difference is always the shortest possible\n        const float PI = 3.14159265358979323846f;\n        dtheta = std::fmod(dtheta + PI, 2 * PI);\n        if (dtheta < 0)\n            dtheta += 2 * PI;\n        dtheta -= PI;\n\n        // Reset flags if conditions are met\n        if (squared_distance > distance_threshold_ * distance_threshold_ || std::abs(dtheta) > angle_threshold_) {\n            oscillation_x_ = false;\n            oscillation_y_ = false;\n            oscillation_theta_ = false;\n        }\n    }\n};", "CodeBleu_score": 51.93080994777455}, {"code": "#include <Eigen/Dense>\n#include <cmath>\n\nclass OscillationCostFunction {\nprivate:\n    static constexpr float DISTANCE_THRESHOLD_SQ = 4.0f;  // Example value for distance squared threshold (2^2)\n    static constexpr float ANGLE_DIFFERENCE_THRESHOLD = 0.5f;  // Example value for angle threshold in radians\n\n    // Assuming these are the oscillation flags we need to reset\n    bool x_oscillation_detected;\n    bool y_oscillation_detected;\n    bool theta_oscillation_detected;\n\npublic:\n    OscillationCostFunction() \n    : x_oscillation_detected(false), y_oscillation_detected(false), theta_oscillation_detected(false) {}\n\n    void resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev) {\n        // Extracting position components\n        float posX = pos[0];\n        float posY = pos[1];\n        float posTheta = pos[2];\n        float prevX = prev[0];\n        float prevY = prev[1];\n        float prevTheta = prev[2];\n\n        // Calculate squared distance between current and previous positions\n        float squaredDistance = (posX - prevX) * (posX - prevX) + (posY - prevY) * (posY - prevY);\n\n        // Calculate angular difference in radians\n        float angleDifference = fabs(posTheta - prevTheta);\n        // Normalize the angle to be within -pi to pi range\n        angleDifference = fmod(angleDifference, 2 * M_PI);\n        if (angleDifference > M_PI) angleDifference -= 2 * M_PI;\n\n        // Check thresholds\n        if (squaredDistance > DISTANCE_THRESHOLD_SQ) {\n            // Reset position flags\n            x_oscillation_detected = false;\n            y_oscillation_detected = false;\n        }\n\n        if (fabs(angleDifference) > ANGLE_DIFFERENCE_THRESHOLD) {\n            // Reset orientation flag\n            theta_oscillation_detected = false;\n        }\n    }\n};", "CodeBleu_score": 42.31617933616071}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "#include <vector>\n#include <cmath>\n\nclass PointGrid {\n    struct Cell {\n        std::vector<geometry_msgs::Point32> points;\n    };\n\n    std::vector<std::vector<Cell>> grid;\n    float cell_size; // Represents physical size of each grid cell\n    int grid_width, grid_height; // Physical dimensions of the grid\n    float min_distance; // Minimum distance allowed between points\n    geometry_msgs::Point32 grid_origin; // Coordinates of the bottom-left corner\n\npublic:\n    PointGrid(float cellSize, int width, int height, float minDist) :\n        cell_size(cellSize),\n        grid_width(width),\n        grid_height(height),\n        min_distance(minDist) {\n        grid.resize(height, std::vector<Cell>(width));\n        grid_origin.x = 0;\n        grid_origin.y = 0;\n    }\n\n    void insert(const geometry_msgs::Point32& pt) {\n        // 1. Calculate grid cell from point coordinates\n        int col = (int)((pt.x - grid_origin.x) / cell_size);\n        int row = (int)((pt.y - grid_origin.y) / cell_size);\n\n        // 2. Check if the coordinates are within grid bounds\n        if (col < 0 || col >= grid_width || row < 0 || row >= grid_height) {\n            return; // Outside grid bounds\n        }\n\n        // 3. Check if the point is too close to any existing point in the cell\n        for (auto& existing_point : grid[row][col].points) {\n            float dist_sq = (existing_point.x - pt.x) * (existing_point.x - pt.x)\n                          + (existing_point.y - pt.y) * (existing_point.y - pt.y);\n            if (dist_sq < min_distance * min_distance) {\n                return; // Too close to an existing point\n            }\n        }\n\n        // 4. Insert the point if all checks pass\n        grid[row][col].points.push_back(pt);\n    }\n};\n\nstruct geometry_msgs {\n    struct Point32 {\n        float x;\n        float y;\n    };\n};", "CodeBleu_score": 31.027671210250013}, {"code": "#include <vector>\n#include <cmath> // for std::sqrt and std::pow\n#include \"geometry_msgs/Point32.h\" // assuming path to the header \n\nclass PointGrid {\npublic:\n    struct Cell {\n        std::vector<geometry_msgs::Point32> points;\n    };\n\n    PointGrid(int width, int height, float resolution, float minDistance)\n    : gridWidth(width), gridHeight(height), cellResolution(resolution), minDist(minDistance) {\n        grid.resize(gridWidth, std::vector<Cell>(gridHeight));\n    }\n    \n    // Converts point coordinates into grid indices\n    bool calculateGridIndex(const geometry_msgs::Point32& pt, int& ix, int& iy) {\n        ix = static_cast<int>(std::floor(pt.x / cellResolution));\n        iy = static_cast<int>(std::floor(pt.y / cellResolution));\n        return ix >= 0 && iy >= 0 && ix < gridWidth && iy < gridHeight;\n    }\n\n    // Insert method according to the docstring\n    void insert(const geometry_msgs::Point32& pt) {\n        int ix, iy;\n        if (!calculateGridIndex(pt, ix, iy)) {\n            // Point is out of the grid bounds\n            return;\n        }\n\n        // Retrieve the cell at calculated indices\n        Cell& cell = grid[ix][iy];\n\n        // Check if point is too close to another point in the same cell\n        for (const auto& existingPoint : cell.points) {\n            float dist = std::sqrt(std::pow(pt.x - existingPoint.x, 2) + std::pow(pt.y - existingPoint.y, 2));\n            if (dist < minDist) {\n                // Too close to an existing point\n                return;\n            }\n        }\n\n        // If valid, insert the point into the cell\n        cell.points.push_back(pt);\n    }\n\nprivate:\n    int gridWidth;\n    int gridHeight;\n    float cellResolution;\n    float minDist;\n    std::vector<std::vector<Cell>> grid;\n};", "CodeBleu_score": 30.959365941531523}, {"code": "#include <cmath>\n#include <vector>\n#include <algorithm>\n\nstruct geometry_msgs {\n    struct Point32 {\n        float x;\n        float y;\n        float z;\n    };\n};\n\nclass PointGrid {\npublic:\n    PointGrid(float width, float height, float cell_size)\n    : width_(width), height_(height), cell_size_(cell_size), min_distance_(cell_size * 0.5f) {\n        int num_cols = static_cast<int>(std::ceil(width_ / cell_size_));\n        int num_rows = static_cast<int>(std::ceil(height_ / cell_size_));\n        grid_.resize(num_rows, std::vector<std::vector<geometry_msgs::Point32>>(num_cols));\n    }\n\n    void insert(const geometry_msgs::Point32& pt) {\n        // Check if the point is outside the bounds of the grid\n        if (pt.x < 0 || pt.y < 0 || pt.x >= width_ || pt.y >= height_) {\n            return; // Point is out of the boundaries\n        }\n\n        // Calculate grid coordinates\n        int col = static_cast<int>(pt.x / cell_size_);\n        int row = static_cast<int>(pt.y / cell_size_);\n\n        // Check the distance with nearest points in the cell and surrounding cells\n        for (int i = std::max(0, row - 1); i <= std::min(row + 1, static_cast<int>(grid_.size()) - 1); ++i) {\n            for (int j = std::max(0, col - 1); j <= std::min(col + 1, static_cast<int>(grid_[i].size()) - 1); ++j) {\n                for (const auto& point : grid_[i][j]) {\n                    float dist = std::sqrt(std::pow(point.x - pt.x, 2) + std::pow(point.y - pt.y, 2));\n                    if (dist < min_distance_) {\n                        return; // Point is too close to an existing point\n                    }\n                }\n            }\n        }\n\n        // Insert the point if all checks are passed\n        grid_[row][col].push_back(pt);\n    }\n\nprivate:\n    float width_;\n    float height_;\n    float cell_size_;\n    float min_distance_;\n    std::vector<std::vector<std::vector<geometry_msgs::Point32>>> grid_;\n};", "CodeBleu_score": 30.191198528364684}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "#include <Eigen/Dense>\n#include <algorithm> // for std::min and std::max\n\nclass SimpleTrajectoryGenerator {\npublic:\n    Eigen::Vector3f computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n                                         const Eigen::Vector3f& vel, \n                                         const Eigen::Vector3f& acclimits, \n                                         double dt) {\n        Eigen::Vector3f new_vel = Eigen::Vector3f::Zero(); // Initialize the new velocity vector to zero\n\n        // Iterate over each component of the velocity vector\n        for (int i = 0; i < 3; ++i) {\n            float velocity_difference = sample_target_vel[i] - vel[i]; // Difference between target and current velocity\n            float max_change = acclimits[i] * dt; // Maximum change in velocity allowed by acceleration limits\n\n            // Calculate how much the velocity needs to change, clamped by the maximum change allowed\n            float velocity_change = std::clamp(velocity_difference, -max_change, max_change);\n\n            // Compute the new velocity for this component\n            new_vel[i] = vel[i] + velocity_change;\n        }\n\n        return new_vel; // Return the newly computed velocity vector\n    }\n};", "CodeBleu_score": 50.416590833476306}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(\n    const Eigen::Vector3f& sample_target_vel, \n    const Eigen::Vector3f& vel, \n    Eigen::Vector3f acclimits, \n    double dt) \n{\n    Eigen::Vector3f new_vel(0.0, 0.0, 0.0);  // Initialize new velocities to zero\n\n    // Compute new velocities for each dimension (x, y, z)\n    for (int i = 0; i < 3; i++) {\n        // Calculate the difference between target and current velocity\n        float velocity_difference = sample_target_vel[i] - vel[i];\n\n        // Calculate the maximum change in velocity allowed, given the acceleration limit\n        float max_velocity_change = acclimits[i] * dt;\n\n        // Calculate the actual change in velocity, which is the smaller value between\n        // the desired change and the maximum allowed change\n        float actual_velocity_change = std::clamp(velocity_difference, -max_velocity_change, max_velocity_change);\n\n        // Update the velocity component\n        new_vel[i] = vel[i] + actual_velocity_change;\n    }\n\n    return new_vel; // Return the newly computed velocities\n}", "CodeBleu_score": 48.91575156338458}, {"code": "#include <Eigen/Dense>\n#include <algorithm> // For std::min and std::max\n\nclass SimpleTrajectoryGenerator {\npublic:\n    Eigen::Vector3f computeNewVelocities(const Eigen::Vector3f& target_velocities,\n                                         const Eigen::Vector3f& current_velocities,\n                                         const Eigen::Vector3f& acceleration_limits,\n                                         double time_delta);\n};\n\nEigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& target_velocities,\n                                                                const Eigen::Vector3f& current_velocities,\n                                                                const Eigen::Vector3f& acceleration_limits,\n                                                                double time_delta) {\n    Eigen::Vector3f new_velocities;\n    \n    // Compute new velocities for each component\n    for (int i = 0; i < 3; ++i) {\n        float velocity_difference = target_velocities[i] - current_velocities[i];\n        float max_change = acceleration_limits[i] * time_delta;\n        \n        // Calculate the change in velocity, ensuring it does not exceed the acceleration limit\n        float change_in_velocity = std::max(std::min(velocity_difference, max_change), -max_change);\n        \n        // Update the velocity component\n        new_velocities[i] = current_velocities[i] + change_in_velocity;\n    }\n\n    return new_velocities;\n}", "CodeBleu_score": 45.67342985500104}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "#include <cmath>\n#include <cfloat> // For DBL_MAX\n\ndouble TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading) {\n    // Assumption: global_plan is an accessible member of TrajectoryPlanner containing path data points\n    // Check if global_plan has data. If empty, return the max double value.\n    if (global_plan.empty()) {\n        return DBL_MAX;\n    }\n\n    // Coordinates for the found path point from the global_plan\n    // Backtrack from the last valid point that has a line of sight to '(cell_x, cell_y)'\n    double goal_x = 0, goal_y = 0;\n    bool point_found = false;\n\n    // Assuming that `global_plan` is some kind of list or vector of points\n    for (auto it = global_plan.rbegin(); it != global_plan.rend(); ++it) {\n        if (hasLineOfSight(cell_x, cell_y, it->x, it->y)) {\n            // Convert from cell to world coordinates if necessary\n            // This step might require more specific transformation based on the system used\n            goal_x = it->x;\n            goal_y = it->y;\n            point_found = true;\n            break;\n        }\n    }\n\n    if (!point_found) {\n        return DBL_MAX;\n    }\n\n    // Calculate direction to the goal point from the current position\n    double dir_x = goal_x - x;\n    double dir_y = goal_y - y;\n    double goal_heading = atan2(dir_y, dir_x);\n\n    // Calculate the difference in heading\n    double heading_difference = goal_heading - heading;\n\n    // Normalize the heading difference to the range [-pi, pi]\n    heading_difference = atan2(sin(heading_difference), cos(heading_difference));\n\n    // Return the absolute value of the heading difference\n    return fabs(heading_difference);\n}\n\n// Sample placeholder implementation for hasLineOfSight function\nbool TrajectoryPlanner::hasLineOfSight(int cell_x, int cell_y, int goal_x, int goal_y) {\n    // Simple direct visibility check (real implementation may involve line drawing algorithms like Bresenham)\n    return true; // Assume direct line of sight for simplification\n}", "CodeBleu_score": 38.20939925491576}, {"code": "#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <float.h> // For DBL_MAX\n\nclass GlobalPlanPoint {\npublic:\n    int x, y;\n};\n\n// Assuming globalPlan is a member of TrajectoryPlanner and is filled with global path points.\nclass TrajectoryPlanner {\nprivate:\n    std::vector<GlobalPlanPoint> globalPlan;\n\npublic:\n    bool hasLineOfSight(int cell_x, int cell_y, int point_x, int point_y);\n    std::pair<double, double> toWorldCoordinates(int x, int y);\n\n    double headingDiff(int cell_x, int cell_y, double x, double y, double heading) {\n        GlobalPlanPoint goalPoint;\n        bool foundPoint = false;\n\n        // Reverse iterate through the global plan\n        for (auto it = globalPlan.rbegin(); it != globalPlan.rend(); ++it) {\n            if (hasLineOfSight(cell_x, cell_y, it->x, it->y)) {\n                goalPoint = *it;\n                foundPoint = true;\n                break;\n            }\n        }\n\n        if (!foundPoint) {\n            return DBL_MAX;\n        }\n\n        // Convert the goal point from cell coordinates to world coordinates\n        auto [goal_x, goal_y] = toWorldCoordinates(goalPoint.x, goalPoint.y);\n\n        // Calculate the angle to the target point\n        double angleToGoal = atan2(goal_y - y, goal_x - x);\n        double headingDiff = fmod(fabs(angleToGoal - heading), 2 * M_PI); // Normalize the angle\n\n        // Compute the shortest path between current heading and goal direction\n        if (headingDiff > M_PI) {\n            headingDiff = 2 * M_PI - headingDiff;\n        }\n        \n        // Return the absolute difference in angles\n        return fabs(headingDiff);\n    }\n};\n\n// Usage of the hypothetical methods which have not been defined in the example\nbool TrajectoryPlanner::hasLineOfSight(int cell_x, int cell_y, int point_x, int point_y) {\n    // Assume implementation or stub\n    return true; \n}\n\nstd::pair<double, double> TrajectoryPlanner::toWorldCoordinates(int x, int y) {\n    // Transform cell coordinates to world coordinates\n    return {x * 0.05, y * 0.05};\n}", "CodeBleu_score": 35.29227877919485}, {"code": "#include <cmath> // for atan2, M_PI, and fmod\n#include <vector> // for path vector\n#include <utility> // for pair\n#include <cfloat> // for DBL_MAX\n\ndouble TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading) {\n    double minAngleDiff = DBL_MAX;\n    std::pair<int, int> farthestPoint;\n    bool validPointFound = false;\n\n    // Reverse iterating through stored global path\n    for (auto it = globalPath.rbegin(); it != globalPath.rend(); ++it) {\n        int targetCellX = it->first;\n        int targetCellY = it->second;\n        \n        // Verify line of sight\n        if (isClearLineOfSight(cell_x, cell_y, targetCellX, targetCellY)) {\n            farthestPoint = *it;\n            validPointFound = true;\n            break;\n        }\n    }\n\n    // Convert the goal point from map coordinates to world coordinates\n    if (validPointFound) {\n        double goalX, goalY;\n        mapToWorld(farthestPoint.first, farthestPoint.second, goalX, goalY);\n\n        // Calculate the angle from current position to the goal position\n        double angleToGoal = atan2(goalY - y, goalX - x);\n\n        // Calculate the shortest angle between current heading and the angle to goal\n        double angleDiff = fmod((angleToGoal - heading + M_PI), 2.0 * M_PI) - M_PI;\n        angleDiff = fabs(angleDiff);  // absolute value of the angle difference\n\n        minAngleDiff = angleDiff;\n    }\n\n    return minAngleDiff;\n}", "CodeBleu_score": 37.251155114480916}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n                                        double vtheta, double vx_samp, double vy_samp, double vtheta_samp) {\n    // Calculate the cost of the trajectory\n    double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta);\n\n    // Check if the cost is valid (non-negative)\n    if (cost >= 0) {\n        return true;\n    } else {\n        // Log a warning since the cost is negative\n        std::cerr << \"Warning: Invalid trajectory with sample velocities (vx_samp: \" << vx_samp\n                  << \", vy_samp: \" << vy_samp << \", vtheta_samp:\" << vtheta_samp\n                  << \") and cost: \" << cost << std::endl;\n\n        return false;\n    }\n}", "CodeBleu_score": 58.22130510166947}, {"code": "#include <iostream>\n\n// Simulated scoring function which calculates the cost of a trajectory.\n// Normally, the implementation would involve complex calculations based\n// on the trajectory's parameters and its predicted outcomes.\ndouble scoreTrajectory(double x, double y, double theta, double vx, double vy,\n                       double vtheta, double vx_samp, double vy_samp, double vtheta_samp) {\n    // Placeholder scoring logic\n    double cost = 1000 - (x + y + theta + vx + vy + vtheta + vx_samp + vy_samp + vtheta_samp);\n    return cost;\n}\n\nclass TrajectoryPlanner {\npublic:\n    bool checkTrajectory(double x, double y, double theta, double vx, double vy,\n                         double vtheta, double vx_samp, double vy_samp, double vtheta_samp) {\n        // Calculate the cost of the trajectory using scoreTrajectory.\n        double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n        // Check if the trajectory cost is non-negative.\n        if (cost >= 0) {\n            return true;  // The trajectory is valid.\n        } else {\n            // Log the warning for negative cost along with the sample velocities and cost.\n            std::cerr << \"Warning: Invalid trajectory with sample velocities (\"\n                      << vx_samp << \", \" << vy_samp << \", \" << vtheta_samp\n                      << \") and cost: \" << cost << std::endl;\n            return false;  // The trajectory is not valid.\n        }\n    }\n};\n\n// Example usage:\nint main() {\n    TrajectoryPlanner planner;\n    bool result = planner.checkTrajectory(10, 20, 0.5, 1, 2, 0.1, 1, 0.5, 0.05);\n    std::cout << \"Trajectory valid: \" << (result ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}", "CodeBleu_score": 61.33939436139951}, {"code": "#include <iostream>\n\nclass TrajectoryPlanner {\npublic:\n    // Method to check the validity of a trajectory\n    bool checkTrajectory(double x, double y, double theta, double vx, double vy,\n                         double vtheta, double vx_samp, double vy_samp, double vtheta_samp) {\n        // Compute the cost of the trajectory using the scoreTrajectory method\n        double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta);\n\n        // Evaluate the trajectory based on the cost\n        if (cost >= 0) {\n            // Cost is non-negative, trajectory is valid\n            return true;\n        } else {\n            // Cost is negative, log a warning and return false\n            std::cerr << \"Warning: Invalid trajectory with sample velocities (\"\n                      << \"vx_samp: \" << vx_samp << \", vy_samp: \" << vy_samp\n                      << \", vtheta_samp: \" << vtheta_samp << \") and cost: \" << cost << std::endl;\n            return false;\n        }\n    }\n\nprivate:\n    // Dummy implementation to represent evaluating the cost of a trajectory\n    double scoreTrajectory(double x, double y, double theta, double vx, double vy, double vtheta) {\n        // Fake implementation: for example, let's assume valid trajectories should have\n        // non-negative velocity components and a bound on the angular component\n        if (vx >= 0 && vy >= 0 && std::abs(vtheta) <= M_PI) {\n            return 100 - (vx + vy + std::abs(vtheta));  // some made-up formula for scoring\n        } else {\n            return -1;  // negative cost indicates invalid trajectory\n        }\n    }\n};", "CodeBleu_score": 51.93481988561048}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "#include <ros/ros.h> // ROS logging and time\n#include <string>\n\nclass ClearCostmapRecovery {\nprivate:\n    bool is_initialized_;\n    std::string *global_costmap_;\n    std::string *local_costmap_;\n    bool invert_area_to_clear_;\n    unsigned int affected_maps_; // Expected to be a bitmask for maps' selection\n    const unsigned int GLOBAL_MAP = 1;\n    const unsigned int LOCAL_MAP = 2;\n\npublic:\n    ClearCostmapRecovery() : \n        is_initialized_(false), global_costmap_(NULL), local_costmap_(NULL), invert_area_to_clear_(false), affected_maps_(0) {}\n\n    void runBehavior() {\n        if (!is_initialized_) {\n            ROS_ERROR(\"ClearCostmapRecovery behavior cannot run because it is not initialized.\");\n            return;\n        }\n\n        if (global_costmap_ == NULL || local_costmap_ == NULL) {\n            ROS_ERROR(\"One or more costmaps are NULL.\");\n            return;\n        }\n\n        ROS_INFO(\"Running ClearCostmapRecovery behavior.\");\n\n        // Log based on the flag for inverting the area to clear\n        if (invert_area_to_clear_) {\n            ROS_WARN(\"Clearing outside the specified area.\");\n        } else {\n            ROS_WARN(\"Clearing inside the specified area.\");\n        }\n\n        ros::WallTime start_time, end_time;\n\n        // Based on the affected_maps_ bitmask, clear the global and/or local costmaps\n        if ((affected_maps_ & GLOBAL_MAP) != 0) {\n            start_time = ros::WallTime::now();\n            clearCostmap(global_costmap_);\n            end_time = ros::WallTime::now();\n            ROS_INFO(\"Cleared global costmap in %f seconds.\", (end_time - start_time).toSec());\n        }\n        if ((affected_maps_ & LOCAL_MAP) != 0) {\n            start_time = ros::WallTime::now();\n            clearCostmap(local_costmap_);\n            end_time = ros::WallTime::now();\n            ROS_INFO(\"Cleared local costmap in %f seconds.\", (end_time - start_time).toSec());\n        }\n    }\n\n    void clearCostmap(std::string *costmap) {\n        if (costmap != NULL) {\n            // Simulated cleanup function - actual implementation would depend on specific system architecture\n            *costmap = \"cleared\";\n            ROS_INFO(\"Costmap cleared.\");\n        }\n    }\n\n    void initialize(bool init, std::string* global_costmap, std::string* local_costmap, bool invert_area, unsigned int affected_maps) {\n        is_initialized_ = init;\n        global_costmap_ = global_costmap;\n        local_costmap_ = local_costmap;\n        invert_area_to_clear_ = invert_area;\n        affected_maps_ = affected_maps;\n    }\n};\n\nint main(int argc, char **argv) {\n    ros::init(argc, argv, \"clear_costmap_recovery_node\");\n    \n    std::string global_map = \"global_costmap\";\n    std::string local_map = \"local_costmap\";\n\n    ClearCostmapRecovery recovery;\n    recovery.initialize(true, &global_map, &local_map, false, 3);\n\n    recovery.runBehavior();\n\n    return 0;\n}", "CodeBleu_score": 43.04102665529704}, {"code": "#include <ros/ros.h>\n#include <chrono>\n\nvoid ClearCostmapRecovery::runBehavior() {\n    // Check if the object is initialized\n    if (!initialized_) {\n        ROS_ERROR(\"ClearCostmapRecovery is not initialized.\");\n        return;\n    }\n\n    // Check if the costmaps are not NULL\n    if (global_costmap_ == nullptr || local_costmap_ == nullptr) {\n        ROS_ERROR(\"Costmap pointers are NULL.\");\n        return;\n    }\n\n    // Log information depending on the invert_area_to_clear_ flag\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"Clearing costmap outside the specified area.\");\n    } else {\n        ROS_WARN(\"Clearing costmap inside the specified area.\");\n    }\n\n    // Start the timer to measure the time taken for clearing costmaps\n    auto start_time = std::chrono::high_resolution_clock::now();\n\n    // Clear global and/or local costmap based on affected_maps_\n    if (affected_maps_ & CLEAR_GLOBAL_COSTMAP) {\n        global_costmap_->resetLayers();\n        if (force_updating_) global_costmap_->updateMap();\n        ROS_INFO(\"Global costmap cleared.\");\n    }\n\n    if (affected_maps_ & CLEAR_LOCAL_COSTMAP) {\n        local_costmap_->resetLayers();\n        if (force_updating_) local_costmap_->updateMap();\n        ROS_INFO(\"Local costmap cleared.\");\n    }\n\n    // Measure the time taken to clear costmaps\n    auto end_time = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> time_taken = end_time - start_time;\n    ROS_INFO(\"Time taken to clear costmaps: %f seconds\", time_taken.count());\n}", "CodeBleu_score": 46.84259260215974}, {"code": "void ClearCostmapRecovery::runBehavior() {\n    if (!initialized_) {\n        ROS_ERROR(\"ClearCostmapRecovery behavior has not been initialized.\");\n        return;\n    }\n    if (local_costmap_ == nullptr || global_costmap_ == nullptr) {\n        ROS_ERROR(\"Costmaps are NULL. Make sure both local and global costmaps are available.\");\n        return;\n    }\n\n    ros::WallTime start_time = ros::WallTime::now();\n\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"Clearing the costmap outside the specified area.\");\n    } else {\n        ROS_WARN(\"Clearing the costmap inside the specified area.\");\n    }\n\n    if (affected_maps_ == \"both\" || affected_maps_ == \"local\") {\n        if (local_costmap_->isCurrent()) {\n            clearCostmap(local_costmap_);\n            if (force_updating_) {\n                local_costmap_->updateMap();\n            }\n        }\n        ros::WallDuration duration = ros::WallTime::now() - start_time;\n        ROS_INFO(\"Local costmap cleared in %f seconds.\", duration.toSec());\n    }\n\n    if (affected_maps_ == \"both\" || affected_maps_ == \"global\") {\n        start_time = ros::WallTime::now(); // Reset start time for global costmap clearing duration\n\n        if (global_costmap_->isCurrent()) {\n            clearCostmap(global_costmap_);\n            if (force_updating_) {\n                global_costmap_->updateMap();\n            }\n        }\n        ros::WallDuration duration = ros::WallTime::now() - start_time;\n        ROS_INFO(\"Global costmap cleared in %f seconds.\", duration.toSec());\n    }\n}\n\nvoid ClearCostmapRecovery::clearCostmap(Costmap2D* costmap) {\n    // Depending on invert_area_to_clear_ either clear inside or outside a designated area\n    if (invert_area_to_clear_) {\n        costmap->clearOutsideWindow(restore_area_x_, restore_area_y_);\n    } else {\n        costmap->clearInsideWindow(restore_area_x_, restore_area_y_);\n    }\n}", "CodeBleu_score": 53.81646796737507}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "#include <vector>\n#include <iostream>\n\nstruct MapLocation {\n    int x, y;\n    MapLocation(int x_, int y_) : x(x_), y(y_) {}\n};\n\nclass Costmap2D {\npublic:\n    void raytraceLine(int x0, int y0, int x1, int y1, std::vector<MapLocation>& cells) {\n        int dx = abs(x1 - x0);\n        int dy = abs(y1 - y0);\n        int x = x0;\n        int y = y0;\n        int n = 1 + dx + dy;\n        int x_inc = (x1 > x0) ? 1 : -1;\n        int y_inc = (y1 > y0) ? 1 : -1;\n        int error = dx - dy;\n        dx *= 2;\n        dy *= 2;\n\n        for (; n > 0; --n) {\n            cells.push_back(MapLocation(x, y));\n\n            if (error > 0) {\n                x += x_inc;\n                error -= dy;\n            } else {\n                y += y_inc;\n                error += dx;\n            }\n        }\n    }\n\n    void polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells) {\n        if (polygon.empty()) return;\n\n        size_t vertex_count = polygon.size();\n        for (size_t i = 0; i < vertex_count; i++) {\n            const MapLocation &current = polygon[i];\n            const MapLocation &next = polygon[(i + 1) % vertex_count];\n            raytraceLine(current.x, current.y, next.x, next.y, polygon_cells);\n        }\n    }\n};\n\nint main() {\n    std::vector<MapLocation> polygon = {{1, 1}, {5, 1}, {5, 5}, {1, 5}};\n    std::vector<MapLocation> outlineCells;\n\n    Costmap2D map;\n    map.polygonOutlineCells(polygon, outlineCells);\n\n    for (const MapLocation& cell : outlineCells) {\n        std::cout << \"(\" << cell.x << \", \" << cell.y << \") \";\n    }\n\n    return 0;\n}", "CodeBleu_score": 38.68715303287216}, {"code": "#include <vector>\n\nclass MapLocation {\npublic:\n    int x;\n    int y;\n    MapLocation(int x, int y) : x(x), y(y) {}\n};\n\nclass Costmap2D {\npublic:\n    void raytraceLine(int x0, int y0, int x1, int y1, std::vector<MapLocation>& cells);\n\n    void polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells) {\n        if (polygon.empty()) return;  // If polygon is empty, there's nothing to do.\n\n        size_t num_vertices = polygon.size();\n        for (size_t i = 0; i < num_vertices; ++i) {\n            const MapLocation& current_vertex = polygon[i];\n            const MapLocation& next_vertex = polygon[(i + 1) % num_vertices];  // Wrap around to start for the last segment\n\n            // Use raytraceLine to fill polygon_cells with the cells that form a line from current_vertex to next_vertex\n            raytraceLine(current_vertex.x, current_vertex.y, next_vertex.x, next_vertex.y, polygon_cells);\n        }\n    }\n    \n    // Dummy implementation for raytraceLine\n    void raytraceLine(int x0, int y0, int x1, int y1, std::vector<MapLocation>& cells) {\n        // Bresenham's line algorithm as a placeholder\n        int dx = std::abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n        int dy = -std::abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n        int err = dx + dy, e2; /* error value e_xy */\n\n        while (true) {\n            cells.emplace_back(x0, y0); // Set the cell at current position\n            if (x0 == x1 && y0 == y1) break;\n            e2 = 2 * err;\n            if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */\n            if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */\n        }\n    }\n};\n\n// Usage\nint main() {\n    Costmap2D costmap2D;\n    std::vector<MapLocation> polygon = { MapLocation(1, 1), MapLocation(5, 1), MapLocation(5, 5), MapLocation(1, 5) };\n    std::vector<MapLocation> outline_cells;\n    costmap2D.polygonOutlineCells(polygon, outline_cells);\n\n    for (const auto& cell : outline_cells) {\n        std::cout << \"Cell at (\" << cell.x << \", \" << cell.y << \")\" << std::endl;\n    }\n\n    return 0;\n}", "CodeBleu_score": 43.54755410101482}, {"code": "#include <vector>\n\nstruct MapLocation {\n    int x;\n    int y;\n};\n\nclass Costmap2D {\npublic:\n    void raytraceLine(int x1, int y1, int x2, int y2, std::vector<MapLocation>& cells);\n    void polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells);\n};\n\nvoid Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells) {\n    size_t num_vertices = polygon.size();\n\n    if (num_vertices == 0) return;  // if the polygon is empty, return immediately\n\n    for (size_t i = 0; i < num_vertices; i++) {\n        int next_index = (i + 1) % num_vertices; // wraps around to the first point to close the polygon\n        MapLocation current = polygon[i];\n        MapLocation next = polygon[next_index];\n        \n        // Gather cells along the line between current vertex and the next\n        raytraceLine(current.x, current.y, next.x, next.y, polygon_cells);\n    }\n}\n\nvoid Costmap2D::raytraceLine(int x1, int y1, int x2, int y2, std::vector<MapLocation>& cells) {\n    // This function should implement the line drawing algorithm (e.g., Bresenham's line algorithm) to find all cells\n    // between two points (x1, y1) and (x2, y2) and push them into cells vector.\n    int dx = abs(x2 - x1), sx = x1 < x2 ? 1 : -1;\n    int dy = -abs(y2 - y1), sy = y1 < y2 ? 1 : -1;\n    int err = dx + dy, e2;\n\n    while (true) {\n        cells.push_back({x1, y1});\n        if (x1 == x2 && y1 == y2) break;\n        e2 = 2 * err;\n        if (e2 >= dy) {\n            err += dy;\n            x1 += sx;\n        }\n        if (e2 <= dx) {\n            err += dx;\n            y1 += sy;\n        }\n    }\n}", "CodeBleu_score": 38.92213168630234}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub) {\n    // Prepare the grid data with the current costmap information\n    prepareGrid();\n\n    // Publish the prepared grid to the new subscriber\n    pub.publish(grid_);\n}", "CodeBleu_score": 95.60359931274196}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub) {\n    // Preparing the grid with necessary data\n    prepareGrid();\n\n    // Publishing the prepared grid to the subscriber\n    pub.publish(grid_);\n}", "CodeBleu_score": 95.60359931274196}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub) {\n    // First, prepare the grid. This function should handle the layout or update of the grid in memory.\n    prepareGrid();\n\n    // Assuming the result of `prepareGrid` would be stored in a member variable (e.g., `costmap_2d_`), which is now up-to-date\n    // Now, publish this updated grid data.\n    if (costmap_2d_ != nullptr) {\n        // When `publish` function is expected to exist within this class which performs the actual publishing.\n        pub.publish(costmap_2d_);\n    } else {\n        ROS_WARN(\"Failed to prepare grid data for publishing.\");\n    }\n}", "CodeBleu_score": 55.3974266851625}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid() {\n    // Lock the costmap mutex to ensure thread safety\n    boost::unique_lock<boost::mutex> lock(*(costmap_->getMutex()));\n\n    // Retrieve the resolution of the costmap\n    double resolution = costmap_->getResolution();\n\n    // Set the grid's header information\n    grid_.header.frame_id = \"map\";\n    grid_.header.stamp = ros::Time::now();\n\n    // Set the grid's resolution, width, and height\n    grid_.info.resolution = resolution;\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    // Convert the map coordinates (0,0) to world coordinates for the origin\n    double wx, wy;\n    costmap_->mapToWorld(0, 0, wx, wy);\n\n    // Set the origin's position (geometry_msgs/Pose)\n    grid_.info.origin.position.x = wx;\n    grid_.info.origin.position.y = wy;\n    grid_.info.origin.position.z = 0.0;\n\n    // Set the origin's orientation to no rotation\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    // Resize the grid data vector\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    // Populate the grid data from the costmap's character map\n    const unsigned char* charMap = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.info.height; i++) {\n        for (unsigned int j = 0; j < grid_.info.width; j++) {\n            unsigned int index = i * grid_.info.width + j;\n            unsigned char cost = charMap[index];\n\n            // Use a translation table for cost values to occupancy data values\n            switch (cost) {\n                case costmap_2d::NO_INFORMATION:\n                    grid_.data[index] = -1;\n                    break;\n                case costmap_2d::LETHAL_OBSTACLE:\n                    grid_.data[index] = 100;\n                    break;\n                case costmap_2d::INSCRIBED_INFLATED_OBSTACLE:\n                    grid_.data[index] = 99;\n                    break;\n                default:\n                    // Translate cost values [0, 252] to [0, 98]\n                    grid_.data[index] = static_cast<int8_t>((static_cast<float>(cost) / 252.0) * 98);\n                    break;\n            }\n        }\n    }\n}", "CodeBleu_score": 66.76587779166016}, {"code": "#include <mutex>\n#include <vector>\n\nclass Costmap2DPublisher {\npublic:\n    void prepareGrid();\n\nprivate:\n    Costmap2D costmap_;  // Hypothetical underlying costmap representation\n    std::mutex costmap_mutex_;  // Mutex for thread-safe access to the costmap\n    nav_msgs::OccupancyGrid grid_;  // ROS occupancy grid message for publishing\n};\n\nvoid Costmap2DPublisher::prepareGrid() {\n    std::lock_guard<std::mutex> lock(costmap_mutex_);  // Safely lock the costmap mutex\n    \n    // Set up the grid metadata\n    grid_.info.resolution = costmap_.getResolution();  // Retrieve the resolution of the costmap\n    grid_.info.width = costmap_.getSizeInCellsX();     // Retrieve the width of the costmap in cells\n    grid_.info.height = costmap_.getSizeInCellsY();    // Retrieve the height of the costmap in cells\n\n    // Calculate the origin in world coordinates\n    double wx, wy;\n    costmap_.mapToWorld(0, 0, wx, wy);  // Convert the bottom-left corner of the map to world coordinates\n    \n    // Set the position and orientation for the origin of the grid\n    grid_.info.origin.position.x = wx;\n    grid_.info.origin.position.y = wy;\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;  // No rotation, quaternion (0,0,0,1)\n\n    // Resize the data vector to fit all cells in the costmap\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    // Populate the occupancy grid data\n    for (int i = 0; i < grid_.info.height; ++i) {\n        for (int j = 0; j < grid_.info.width; ++j) {\n            unsigned char cost = costmap_.getCost(j, i);\n            if (cost == Costmap2D::NO_INFORMATION) {\n                grid_.data[i * grid_.info.width + j] = -1;\n            } else if (cost >= Costmap2D::LETHAL_OBSTACLE) {\n                grid_.data[i * grid_.info.width + j] = 100;\n            } else if (cost > 0) {\n                grid_.data[i * grid_.info.width + j] = (cost * 100) / Costmap2D::LETHAL_OBSTACLE;  // Scale cost to [0, 100]\n            } else {\n                grid_.data[i * grid_.info.width + j] = 0;\n            }\n        }\n    }\n}", "CodeBleu_score": 48.92478590267429}, {"code": "void Costmap2DPublisher::prepareGrid() {\n    // Lock the mutex associated with the costmap\n    boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n    // Retrieve the size and resolution of the costmap\n    double resolution = costmap_->getResolution();\n    unsigned int size_x = costmap_->getSizeInCellsX(), size_y = costmap_->getSizeInCellsY();\n\n    // Prepare the grid message with the necessary header information\n    grid_.header.frame_id = \"map\";\n    grid_.header.stamp = ros::Time::now();\n\n    // Set up the grid dimensions and resolution\n    grid_.info.resolution = resolution;\n    grid_.info.width = size_x;\n    grid_.info.height = size_y;\n\n    // Set up the origin of the grid (position and orientation of the (0,0) cell in the costmap)\n    double wx, wy;\n    costmap_->mapToWorld(0, 0, wx, wy);  // Converts the map coordinates (0,0) to world coordinates (wx, wy)\n    grid_.info.origin.position.x = wx;\n    grid_.info.origin.position.y = wy;\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;  // No rotation, hence orientation is unit quaternion\n\n    // Resize the vector that holds the map data\n    grid_.data.resize(size_x * size_y);\n\n    // Access the underlying map to fill the data of the grid\n    const unsigned char* charmap = costmap_->getCharMap();\n    for (unsigned int i = 0; i < size_x * size_y; ++i) {\n        switch (charmap[i]) {\n            case Costmap2D::NO_INFORMATION:\n                grid_.data[i] = -1;   // Unknown space\n                break;\n            case Costmap2D::LETHAL_OBSTACLE:\n                grid_.data[i] = 100;  // Occupied space (e.g., wall or obstacle)\n                break;\n            case Costmap2D::FREE_SPACE:\n                grid_.data[i] = 0;    // Free space\n                break;\n            default:\n                grid_.data[i] = -1;   // Treat other values as unknown\n                break;\n        }\n    }\n    // Once data fill is done, unlock is implicit with lock going out of scope.\n}", "CodeBleu_score": 58.203770285789716}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "#include <ros/ros.h> // Necessary for logging with ROS\n#include <vector> // Necessary for using std::vector\n#include <string> // Necessary for using std::string\n\nvoid Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config) {\n    // Check if the configuration has not changed\n    if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n        return;\n    }\n    \n    // Check if there is a valid footprint configuration\n    if (!new_config.footprint.empty()) {\n        std::vector<std::vector<float>> new_footprint;\n        if (makeFootprintFromString(new_config.footprint, new_footprint)) {\n            setFootprint(new_footprint);\n        } else {\n            // Log an error if the footprint string is invalid\n            ROS_ERROR(\"Invalid footprint string in configuration.\");\n        }\n    } else {\n        if (new_config.robot_radius > 0) {\n            // Create a circular footprint using the robot radius if no footprint is provided\n            setFootprint(makeCircularFootprint(new_config.robot_radius));\n        } else {\n            // Log an error if no valid robot radius is provided\n            ROS_ERROR(\"No valid footprint string or valid robot radius provided.\");\n        }\n    }\n}", "CodeBleu_score": 71.75173064051144}, {"code": "// Check if the footprint and robot radius have not changed\n    if (new_config.footprint == old_config.footprint && new_config.robot_radius == old_config.robot_radius) {\n        return;\n    }\n\n    // Attempt to process new footprint from the configuration\n    if (!new_config.footprint.empty()) {\n        // Assume parseFootprint parses footprint string to a vector of points, returns true if successful.\n        std::vector<geometry_msgs::Point> new_footprint;\n        bool valid_footprint = parseFootprint(new_config.footprint, new_footprint);\n\n        if (valid_footprint) {\n            setFootprint(new_footprint);  // Assume we have a method that sets the footprint of the robot.\n        } else {\n            ROS_ERROR(\"Invalid footprint string provided in configuration\");\n            setFootprintBasedOnRadius(new_config.robot_radius);\n        }\n    } else {\n        // If no valid footprint string is present, set the footprint based on robot radius\n        setFootprintBasedOnRadius(new_config.robot_radius);\n    }\n}", "CodeBleu_score": 58.252287596371445}, {"code": "#include <vector>\n#include <string>\n#include \"costmap_2d/costmap_2d_ros.h\"\n#include \"costmap_2d/costmap_2d.h\"\n\nvoid Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config) {\n    // Check if the footprint or the robot radius has changed\n    if (new_config.robot_radius == old_config.robot_radius && new_config.footprint == old_config.footprint) {\n        // If nothing has changed, return immediately\n        return;\n    }\n\n    // Convert footprint string to a vector of points\n    std::vector<geometry_msgs::Point> footprint;\n    if (!new_config.footprint.empty()) {\n        if (makeFootprintFromString(new_config.footprint, footprint)) {\n            // If the footprint string is valid, update the footprint\n            setRobotFootprint(footprint);\n            ROS_INFO(\"Updated the robot footprint based on the new configuration.\");\n        } else {\n            // Log error if the footprint string is invalid\n            ROS_ERROR(\"Invalid footprint string in configuration: %s\", new_config.footprint.c_str());\n        }\n    } else if (new_config.robot_radius > 0) {\n        // If no valid footprint string is provided, set the footprint based on the robot radius\n        setRobotFootprint(makeFootprintFromRadius(new_config.robot_radius));\n        ROS_INFO(\"Updated the robot footprint to a circular shape with radius: %f\", new_config.robot_radius);\n    } else {\n        // If no valid footprint and robot radius is zero or less\n        ROS_WARN(\"No valid footprint specified, and robot radius is not set properly (%f).\", new_config.robot_radius);\n    }\n}", "CodeBleu_score": 61.91294859103318}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "#include <ros/ros.h>\n#include <tf/transform_listener.h>\n#include <geometry_msgs/PoseStamped.h>\n\nclass Costmap2DROS {\npublic:\n    Costmap2DROS();  // Assuming constructor exists\n\n    void movementCB(const ros::TimerEvent &event);\n\nprivate:\n    tf::TransformListener tf_listener_;\n    geometry_msgs::PoseStamped new_pose_;\n    ros::Publisher reconfig_cancel_publisher;  // To cancel reconfiguration\n};\n\nvoid Costmap2DROS::movementCB(const ros::TimerEvent &event) {\n    // Frame details and target frame might vary; adjust as needed.\n    std::string robot_base_frame = \"base_link\";\n    std::string global_frame = \"map\";\n\n    // Time and duration for tf listener to wait\n    ros::Time time = ros::Time(0);\n    ros::Duration timeout(1.0);  // 1 second timeout for tf transformation\n\n    try {\n        tf::StampedTransform transform;\n        \n        // Listening for the transform, considering some timeout to ensure it's available\n        tf_listener_.waitForTransform(global_frame, robot_base_frame, time, timeout);\n        tf_listener_.lookupTransform(global_frame, robot_base_frame, time, transform);\n\n        // Convert TF transform to a Geometry message Pose\n        new_pose_.header.stamp = time;\n        new_pose_.header.frame_id = global_frame;\n        tf::poseTFToMsg(transform, new_pose_.pose);\n        \n        ROS_INFO(\"Robot new pose obtained and updated.\");\n\n    } catch (tf::TransformException &ex) {\n        // Log the failure to get pose\n        ROS_WARN(\"Failed to get robot pose: %s\", ex.what());\n\n        // Cancel reconfiguration logic\n        std_msgs::String cancel_msg;\n        cancel_msg.data = \"Cancel reconfiguration due to pose acquisition failure.\";\n        reconfig_cancel_publisher.publish(cancel_msg);\n        \n        ROS_INFO(\"Reconfiguration canceled.\");\n    }\n}", "CodeBleu_score": 40.822530914829215}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent& event) {\n    // Variable to store the new pose of the robot\n    geometry_msgs::PoseStamped new_pose;\n\n    // Attempt to get the current pose of the robot\n    if (!getRobotPose(new_pose)) {\n        // If failed to get the robot pose, log a warning\n        ROS_WARN(\"Failed to get robot pose for the costmap's movement callback\");\n\n        // Cancel any ongoing reconfiguration tasks\n        cancelReconfiguration();  \n        \n        // Optionally, you could add more handling logic here, such as attempts to retry fetching the pose or other fallback procedures.\n    } else {\n        // If the pose was successfully acquired, you can now proceed with any operations that depend on the new pose.\n        // For example, updating internal representations of the robot's position on the costmap\n        updateCostmapPose(new_pose);\n\n        // Log successful acquisition of pose\n        ROS_INFO(\"Successfully updated robot's pose in movement callback\");\n    }\n}", "CodeBleu_score": 60.10115938305436}, {"code": "#include <ros/ros.h>\n\nvoid Costmap2DROS::movementCB(const ros::TimerEvent &event) {\n    geometry_msgs::PoseStamped new_pose;\n\n    // Attempt to get the robot's current pose\n    if (!getRobotPose(new_pose)) {\n        ROS_WARN(\"Failed to get Robot's pose\");\n        \n        // Cancel the ongoing reconfiguration if any\n        if (configuring_) {\n            ROS_WARN(\"Canceling reconfiguration due to pose retrieval failure.\");\n            cancelReconfiguration();\n        }\n        return;\n    }\n\n    // If successful, store the new_pose or perform any subsequent actions\n    current_pose_ = new_pose;\n\n    // Optional: Additional handling after successfully retrieving and setting the pose\n    ROS_INFO_STREAM(\"Successfully updated robot pose: \" << new_pose);\n}", "CodeBleu_score": 57.29142821272901}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start() {\n    // Check if the costmap is stopped\n    if (stopped_) {\n        // Reactivating all the plugins\n        for (auto& plugin : *plugin_loader_) {\n            plugin->activate();\n        }\n\n        // Set the stopped flag to false\n        stopped_ = false;\n\n        // Resubscribe to needed topics\n        // Assumed subscription mechanism. Adjust accordingly if differs.\n        for (auto& subscriber : subscribers_) {\n            subscriber.subscribe();\n        }\n\n        // Set stop_updates_ to false so that the map starts updating\n        stop_updates_ = false;\n    }\n\n    // Wait in a loop until all conditions are met\n    while (ros::ok() && !initialized_ && !map_update_thread_active_) {\n        ros::Duration(0.1).sleep();  // Sleep for 100 milliseconds\n        ros::spinOnce();\n    }\n\n    ROS_INFO(\"Costmap2DROS started successfully.\");\n}", "CodeBleu_score": 44.251538499923065}, {"code": "#include <ros/ros.h>\n\nvoid Costmap2DROS::start() {\n    // Ensure ROS is running\n    if (!ros::ok()) {\n        ROS_WARN(\"ROS is not running. Costmap cannot be started.\");\n        return;\n    }\n\n    // Check if the costmap was stopped\n    if (stopped_) {\n        ROS_INFO(\"Costmap was stopped. Reinitializing plugins and subscriptions.\");\n\n        // Reactivate all previously stopped plugins\n        for (auto& plugin : plugins_) {\n            plugin->activate();\n        }\n\n        stopped_ = false;\n        stop_updates_ = false;\n\n        // Reinitialize any necessary services/subscriptions\n        initializeSubscribers();\n\n        ROS_INFO(\"Costmap plugins activated.\");\n    } else {\n        ROS_INFO(\"Costmap is already active.\");\n    }\n\n    // Wait for initialization and thread activity\n    while(ros::ok() && !initialized_ && !map_update_thread_active_) {\n        ROS_WARN(\"Waiting for costmap to be initialized and map update thread to be active.\");\n        ros::Duration(0.5).sleep();  // Sleep for a brief period before checking again\n    }\n\n    if (ros::ok()) {\n        ROS_INFO(\"Costmap2DROS is fully operational.\");\n    }\n}\n\nvoid Costmap2DROS::initializeSubscribers() {\n    // Method to initialize all necessary subscribers.\n    // You might need to re-subscribe to relevant topics.\n    // For example:\n    // ros::NodeHandle nh;\n    // subscriber_ = nh.subscribe(\"some_topic\", 1, &Costmap2DROS::callbackFunction, this);\n    // Ensure to tailor this function to fit necessary subscribers as per costmap configurations.\n\n    // Example only:\n    ROS_INFO(\"Re-subscribed to all necessary topics.\");\n}", "CodeBleu_score": 41.262541452020216}, {"code": "#include <ros/ros.h>  // To include ROS functionalities\n\nvoid Costmap2DROS::start() {\n    // Check if the costmap is already stopped\n    if(stopped_) {\n        // Reactivate all plugins\n        for (auto& plugin : plugin_list_) {\n            plugin->activate();\n        }\n\n        // Reset flags\n        stopped_ = false;\n        stop_updates_ = false;\n\n        // Ensure that we have ROS running and data is being updated\n        ros::Rate rate(10);  // Loop at 10 Hz\n        while(ros::ok()) {\n            // Check if the map is initialized and the update thread is active\n            if (is_initialized_ && update_thread_) {\n                ROS_INFO(\"Costmap2DROS is started and running.\");\n                break;  // Exit the loop if the required conditions are met\n            }\n            // If conditions are not met, sleep for a bit and check again\n            rate.sleep();\n            ros::spinOnce();  // Handle ROS events and callbacks\n        }\n    } else {\n        ROS_WARN(\"Attempted to start the costmap, but it was not stopped.\");\n    }\n}", "CodeBleu_score": 36.64478647601806}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "#include <list>\n#include <chrono>\n\nclass Observation {\npublic:\n    std::chrono::steady_clock::time_point timestamp;  // Assuming timestamp is of this type\n};\n\nclass ObservationBuffer {\nprivate:\n    std::list<Observation> observations;\n    std::chrono::seconds observation_keep_time_;\n\npublic:\n    // Constructor and other utilities would be here\n    // For example:\n    // ObservationBuffer(std::chrono::seconds keepTime): observation_keep_time_(keepTime) {}\n\n    void purgeStaleObservations() {\n        auto current_time = std::chrono::steady_clock::now();  // Capture the current time\n\n        if (observation_keep_time_.count() == 0) {\n            // If the observation keep time is zero, keep only the most recent.\n            if (!observations.empty()) {\n                Observation most_recent = observations.back();\n                observations.clear();      // Clear all observations\n                observations.push_back(most_recent);  // Keep only the most recent one\n            }\n        } else {\n            for (auto it = observations.begin(); it != observations.end(); /* no increment here */) {\n                // Compute the duration since the observation was made\n                auto duration_since_observation = std::chrono::duration_cast<std::chrono::seconds>(current_time - it->timestamp);\n                \n                if (duration_since_observation > observation_keep_time_) {\n                    // If the observation is older than the keep time, remove it.\n                    it = observations.erase(it);  // erase returns the next iterator\n                } else {\n                    // Once we find an observation that is within the keep time, stop deleting\n                    break;\n                }\n            }\n        }\n    }\n};\n\n// Example usage could be given assuming necessary includes and using namespaces are managed", "CodeBleu_score": 32.51940693107274}, {"code": "#include <list>\n#include <chrono>\n\nclass Observation {\npublic:\n    // Assuming there is a way to get the timestamp from an observation\n    std::chrono::system_clock::time_point timestamp;\n};\n\nclass ObservationBuffer {\nprivate:\n    std::list<Observation> observations;\n    std::chrono::seconds observation_keep_time_;\n\npublic:\n    // Constructor or other member functions to manage observations might be here\n    void purgeStaleObservations() {\n        if (observation_keep_time_.count() == 0) {\n            // Keep only the most recent observation\n            if (!observations.empty()) {\n                Observation recent = observations.back();\n                observations.clear();\n                observations.push_back(recent);\n            }\n        } else {\n            // Current time\n            auto now = std::chrono::system_clock::now();\n            \n            // Remove old observations\n            for(auto it = observations.begin(); it != observations.end();) {\n                // Compute the time difference\n                auto age = std::chrono::duration_cast<std::chrono::seconds>(now - it->timestamp);\n                if (age > observation_keep_time_) {\n                    // If the observation is older than the keep time, remove it\n                    it = observations.erase(it);\n                } else {\n                    // Since the list is assumed to be sorted by time,\n                    // no need to check further if a valid observation is found\n                    break;\n                }\n            }\n        }\n    }\n};", "CodeBleu_score": 41.06547289650516}, {"code": "void ObservationBuffer::purgeStaleObservations() {\n    if (observation_keep_time_ == 0) {\n        // If keeping time is zero, retain only the most recent observation\n        if (!observations_.empty()) {\n            auto mostRecent = observations_.back();\n            observations_.clear();\n            observations_.push_back(mostRecent);\n        }\n    } else {\n        // Current time\n        auto currentTime = std::chrono::system_clock::now();\n\n        // Predicate to determine if an observation is stale\n        auto isStale = [this, currentTime](const Observation& obs) {\n            return std::chrono::duration_cast<std::chrono::seconds>(currentTime - obs.timestamp).count() > observation_keep_time_;\n        };\n\n        // Remove stale observations\n        observations_.remove_if(isStale);\n    }\n}", "CodeBleu_score": 39.46149707055651}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "#include <vector>\n#include <cmath>\n\nclass OrientationFilter \n{\npublic:\n    void interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                    int start_index, int end_index);\n\nprivate:\n    double quaternionToYaw(const geometry_msgs::Quaternion& quaternion);\n    geometry_msgs::Quaternion yawToQuaternion(double yaw);\n};\n\n// Helper function to convert quaternion to yaw angle\ndouble OrientationFilter::quaternionToYaw(const geometry_msgs::Quaternion& quaternion)\n{\n    double siny = +2.0 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y);\n    double cosy = +1.0 - 2.0 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);  \n    return std::atan2(siny, cosy);\n}\n\n// Helper function to create quaternion from yaw angle\ngeometry_msgs::Quaternion OrientationFilter::yawToQuaternion(double yaw)\n{\n    geometry_msgs::Quaternion quaternion;\n    quaternion.x = 0;\n    quaternion.y = 0;\n    quaternion.z = sin(yaw / 2);\n    quaternion.w = cos(yaw / 2);\n    return quaternion;\n}\n\nvoid OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\n{\n    if (start_index < 0 || end_index >= path.size() || start_index >= end_index)\n        return;\n\n    double start_yaw = quaternionToYaw(path[start_index].pose.orientation);\n    double end_yaw = quaternionToYaw(path[end_index].pose.orientation);\n\n    // Calculate the angular distance with direction consideration\n    double angular_diff = atan2(sin(end_yaw - start_yaw), cos(end_yaw - start_yaw));\n    int step_count = end_index - start_index;\n\n    // Interpolate along the shortest angular path\n    for (int i = start_index + 1; i < end_index; ++i)\n    {\n        double fraction = static_cast<double>(i - start_index) / step_count;\n        double interpolated_yaw = start_yaw + fraction * angular_diff;\n        path[i].pose.orientation = yawToQuaternion(interpolated_yaw);\n    }\n}", "CodeBleu_score": 45.19326309446329}, {"code": "#include <vector>\n#include <cmath>\n\nstruct Quaternion {\n    double w, x, y, z;\n};\n\nstruct geometry_msgs {\n    struct Quaternion quaternion;\n    // Placeholder for pose position, which is not used in this operation\n};\n\nstruct PoseStamped {\n    geometry_msgs pose;\n};\n\nclass OrientationFilter {\npublic:\n    void interpolate(std::vector<PoseStamped>& path, int start_index, int end_index) {\n        if (start_index < 0 || end_index >= path.size() || start_index >= end_index) {\n            return; // Invalid index boundaries, just return without processing.\n        }\n\n        // Assuming yaw is extracted from the quaternion representation of orientation.\n        auto quaternion_to_yaw = [](const Quaternion& q) {\n            // Formula to convert quaternion to yaw angle (z-axis rotation)\n            double siny_cosp = 2.0 * (q.w * q.z + q.x * q.y);\n            double cosy_cosp = 1.0 - 2.0 * (q.y * q.y + q.z * q.z);\n            return std::atan2(siny_cosp, cosy_cosp);\n        };\n\n        // Get the yaw angles from the start and end quaternions\n        double start_yaw = quaternion_to_yaw(path[start_index].pose.quaternion);\n        double end_yaw = quaternion_to_yaw(path[end_index].pose.quaternion);\n        \n        // Calculate the shortest angular distance considering circular boundary conditions\n        double d_theta = std::atan2(std::sin(end_yaw - start_yaw), std::cos(end_yaw - start_yaw));\n        \n        // Calculate the increment step\n        int step_count = end_index - start_index;\n        double increment = d_theta / step_count;\n        \n        // Interpolate orientations\n        for (int i = start_index + 1; i <= end_index; ++i) {\n            double new_yaw = start_yaw + increment * (i - start_index);\n            Quaternion q;\n            double cy = cos(new_yaw * 0.5);\n            double sy = sin(new_yaw * 0.5);\n            \n            // We assume the original pitch and roll (x and y rotations) remain the same and are zero\n            q.w = cy;\n            q.x = 0;\n            q.y = 0;\n            q.z = sy;\n            \n            // Update the pose's orientation\n            path[i].pose.quaternion = q;\n        }\n    }\n};", "CodeBleu_score": 47.064419610495214}, {"code": "#include <vector>\n#include <cmath>\n#include <geometry_msgs/PoseStamped.h>\n#include <tf/tf.h>\n\nclass OrientationFilter {\npublic:\n    void interpolate(std::vector<geometry_msgs::PoseStamped>& path, int start_index, int end_index) {\n        if (start_index >= end_index || start_index < 0 || end_index >= path.size())\n            return;  // Invalid indices\n\n        double start_yaw = getYawFromPose(path[start_index].pose);\n        double end_yaw = getYawFromPose(path[end_index].pose);\n\n        double angle_diff = shortestAngularDistance(start_yaw, end_yaw);\n        int num_steps = end_index - start_index;\n\n        for (int i = start_index + 1; i <= end_index; ++i) {\n            double fraction = static_cast<double>(i - start_index) / num_steps;\n            double interp_yaw = start_yaw + fraction * angle_diff;\n            setYawToPose(path[i].pose, interp_yaw);\n        }\n    }\n\nprivate:\n    double getYawFromPose(const geometry_msgs::Pose& pose) {\n        // Extract the yaw from the quaternion\n        tf::Quaternion q;\n        tf::quaternionMsgToTF(pose.orientation, q);\n        double roll, pitch, yaw;\n        tf::Matrix3x3(q).getRPY(roll, pitch, yaw);\n        return yaw;\n    }\n\n    void setYawToPose(geometry_msgs::Pose& pose, double yaw) {\n        // Set the yaw (rotation around z-axis) to the pose\n        tf::Quaternion q;\n        q.setRPY(0, 0, yaw);\n        tf::quaternionTFToMsg(q, pose.orientation);\n    }\n\n    double shortestAngularDistance(double yaw1, double yaw2) {\n        double delta = std::fmod(yaw2 - yaw1 + M_PI, 2 * M_PI);\n        if (delta < 0)\n            delta += 2 * M_PI;\n        delta -= M_PI;\n        return delta;\n    }\n};", "CodeBleu_score": 43.46128150581677}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp) {\n    // Set the frame_id for start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Generate the path by calling the makePlan function\n    std::vector<geometry_msgs::PoseStamped> plan;\n    bool success = makePlan(req.start, req.goal, plan);\n\n    // Update the response with the generated path and success status\n    resp.plan_found = success;\n    if (success) {\n        resp.path.poses = std::move(plan);\n    }\n\n    // Return true to indicate the service was processed\n    return true;\n}", "CodeBleu_score": 77.95520473716293}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp) {\n  // Set the frame_id of start and goal poses to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Generate the plan using the makePlan method\n  std::vector<geometry_msgs::PoseStamped> plan;\n  bool success = makePlan(req.start, req.goal, plan);\n\n  // Update the response with the success status and path\n  resp.plan_found = success;\n  if (success) {\n    resp.path = plan; // Assuming Response's path field is a vector of PoseStamped\n  }\n\n  // Return true to indicate that the service was processed\n  return true;\n}\n\nbool PlannerWithCostmap::makePlan(const geometry_msgs::PoseStamped& start, const geometry_msgs::PoseStamped& goal, std::vector<geometry_msgs::PoseStamped>& plan) {\n  // Implementation of path planning\n  // Example: Adding just the start and goal for simplicity\n  plan.push_back(start);\n  plan.push_back(goal);\n  return true; // Assume path planning always succeeds for this example\n}", "CodeBleu_score": 72.1599453940513}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp) {\n    // Set the frame_id of the start and goal poses to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Vector to store the planned path\n    std::vector<geometry_msgs::PoseStamped> plan;\n\n    // Try to make a plan from start to goal\n    bool success = makePlan(req.start, req.goal, plan);\n\n    // Update response with the status and path\n    resp.plan_found = success;\n    if (success) {\n        resp.path.poses = plan;\n    } else {\n        ROS_WARN(\"Failed to find a valid plan.\");\n    }\n\n    // Always return true to indicate the service has been processed\n    return true;\n}", "CodeBleu_score": 75.15516587722466}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\n    // Initialize the private node handle in the ROS environment\n    ros::NodeHandle private_nh(\"~\");\n\n    // Advertise the service \"make_plan\" using the node handle\n    make_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n    // Subscribe to the \"goal\" topic to receive PoseStamped messages\n    goal_subscriber_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 61.90978990032575}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\n    // Initialize private node handle\n    ros::NodeHandle private_nh(\"~\");\n\n    // Advertise the \"make_plan\" service\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n    // Subscribe to the \"goal\" topic to receive PoseStamped messages\n    goal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}", "CodeBleu_score": 59.248693425490785}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\n{\n    // Initialize the node handle\n    ros::NodeHandle private_nh(\"~\");\n\n    // Advertise a service named \"make_plan\" that will use the makePlan method from this class\n    make_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlan, this);\n\n    // Subscribe to the \"goal\" topic to get goal locations for planning\n    goal_sub_ = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n\n    // Output to confirm initialization\n    ROS_INFO(\"PlannerWithCostmap '%s' initialized with global frame '%s'\", name.c_str(), cmap->getGlobalFrameID().c_str());\n}", "CodeBleu_score": 61.490528804624}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "#include <cmath> // For floor function\n\nclass GlobalPlanner {\nprivate:\n    double origin_x;    // X coordinate of costmap's origin in world coordinates\n    double origin_y;    // Y coordinate of costmap's origin in world coordinates\n    double resolution;  // Costmap resolution\n    unsigned int size_x; // Width of costmap in cells\n    unsigned int size_y; // Height of costmap in cells\n\npublic:\n    GlobalPlanner(double origin_x, double origin_y, double resolution, unsigned int size_x, unsigned int size_y)\n    : origin_x(origin_x), origin_y(origin_y), resolution(resolution), size_x(size_x), size_y(size_y) {}\n\n    bool worldToMap(double wx, double wy, double& mx, double& my) {\n        // Calculate the map coordinates from world coordinates\n        mx = (wx - origin_x) / resolution;\n        my = (wy - origin_y) / resolution;\n\n        // Round down to nearest whole number to get the map cell index\n        unsigned int mx_cell = static_cast<unsigned int>(floor(mx));\n        unsigned int my_cell = static_cast<unsigned int>(floor(my));\n\n        // Check if the calculated map coordinates are within the costmap bounds\n        if (mx_cell >= 0 && mx_cell < size_x && my_cell >= 0 && my_cell < size_y) {\n            mx = mx_cell;\n            my = my_cell;\n            return true;\n        } else {\n            return false; // Coordinates are out of the bounds of the costmap\n        }\n    }\n};\n\n// Example usage:\nint main() {\n    double world_x = 10.5;\n    double world_y = 20.5;\n    double map_x, map_y;\n    GlobalPlanner planner(10.0, 20.0, 0.1, 100, 100);\n\n    bool result = planner.worldToMap(world_x, world_y, map_x, map_y);\n    if (result) {\n        std::cout << \"Map coordinates: (\" << map_x << \", \" << map_y << \")\" << std::endl;\n    } else {\n        std::cout << \"World coordinates are out of the bounds of the map\" << std::endl;\n    }\n\n    return 0;\n}", "CodeBleu_score": 43.128873975766375}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my) {\n    // convert from world coordinates to map coordinates\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    // check if the converted map coordinates are within the bounds of the map\n    if (mx >= 0 && my >= 0 && mx < size_x_ && my < size_y_) {\n        return true;\n    } else {\n        return false;\n    }\n}", "CodeBleu_score": 29.766876456454632}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my) {\n    // Check if world coordinates are within the bounds, considering the costmap's origin\n    if (wx < origin_x_ || wy < origin_y_) {\n        return false;\n    }\n\n    // Convert world coordinates to map coordinates using the resolution and subtracting the origin\n    mx = (wx - origin_x_) / resolution_;\n    my = (wy - origin_y_) / resolution_;\n\n    // Convert mx and my to integer map grid coordinates\n    int mx_int = static_cast<int>(mx);\n    int my_int = static_cast<int>(my);\n\n    // Check if the calculated map coordinates are within the size bounds of the costmap\n    if (mx_int < 0 || mx_int >= size_x_ || my_int < 0 || my_int >= size_y_) {\n        return false;\n    }\n\n    // If the coordinates are valid, return true\n    return true;\n}", "CodeBleu_score": 47.49580203107234}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "#include \"ros/ros.h\"  // ROS header for basic functions\n#include \"nav_msgs/Path.h\"  // ROS message type for Path\n#include \"geometry_msgs/PoseStamped.h\"  // ROS message type for PoseStamped\n\nclass GlobalPlanner {\npublic:\n    GlobalPlanner() : initialized_(false) {}\n\n    void initialize() {\n        initialized_ = true;\n        // Initialization code would typically also initialize publishers, subscribers, etc.\n        ros::NodeHandle nh;\n        plan_pub_ = nh.advertise<nav_msgs::Path>(\"plan\", 50);\n    }\n\n    void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n        if (!initialized_) {\n            ROS_ERROR(\"Global Planner has not been initialized\");\n            return;\n        }\n\n        nav_msgs::Path path_msg;\n        path_msg.header.frame_id = \"map\";\n        path_msg.header.stamp = ros::Time::now();\n\n        // Copying poses from the given path to the ROS Path message\n        for (const auto& pose : path) {\n            path_msg.poses.push_back(pose);\n        }\n\n        // Publishing the path\n        plan_pub_.publish(path_msg);\n    }\n  \nprivate:\n    bool initialized_;\n    ros::Publisher plan_pub_;\n};", "CodeBleu_score": 42.144392340516966}, {"code": "#include <ros/ros.h>\n#include <geometry_msgs/PoseStamped.h>\n#include <nav_msgs/Path.h>\n#include <vector>\n \nclass GlobalPlanner {\npublic:\n    bool initialized_;\n    std::string frame_id_;\n    ros::Publisher plan_pub_;\n\n    GlobalPlanner() : initialized_(false) {}\n\n    void initialize(std::string frame_id, ros::Publisher publisher) {\n        frame_id_ = frame_id;\n        plan_pub_ = publisher;\n        initialized_ = true;\n    }\n\n    void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path);\n};\n\nvoid GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n    if (!initialized_) {\n        ROS_ERROR(\"Global Planner has not been initialized, unable to publish plan.\");\n        return;\n    }\n\n    nav_msgs::Path path_msg;\n    \n    // Set the frame ID and timestamp.\n    path_msg.header.frame_id = frame_id_;\n    path_msg.header.stamp = ros::Time::now();\n    \n    // Copy the poses from the given path.\n    path_msg.poses = std::vector<geometry_msgs::PoseStamped>(path.begin(), path.end());\n    \n    // Publish the path.\n    plan_pub_.publish(path_msg);\n    ROS_INFO(\"Plan published with %d poses\", static_cast<int>(path.size()));\n}", "CodeBleu_score": 41.92611553953562}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {\n    // First, verify that the planner has been initialized\n    if (!initialized_) {\n        ROS_ERROR(\"Attempt to publish a plan when the planner has not been initialized.\");\n        return;\n    }\n\n    // Creating a Path message\n    nav_msgs::Path path_msg;\n    \n    // Setting the header of the path message\n    path_msg.header.frame_id = \"map\";  // Assuming the frame ID is \"map\", change as necessary\n    path_msg.header.stamp = ros::Time::now();\n\n    // Copying the poses from the vector into the Path message\n    path_msg.poses = path;\n\n    // Publishing the path message using the plan publisher\n    plan_pub_.publish(path_msg);\n\n    // Optional, log for debug\n    ROS_INFO(\"Path published with %d poses\", int(path.size()));\n}", "CodeBleu_score": 49.6916322163592}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal) {\n    // Log a debug message that we are processing a new goal\n    ROS_DEBUG(\"Received new navigation goal. Wrapping it in an action message.\");\n\n    // Create a MoveBaseActionGoal message\n    move_base_msgs::MoveBaseActionGoal action_goal_message;\n\n    // Set the timestamp to current time\n    action_goal_message.header.stamp = ros::Time::now();\n    action_goal_message.header.frame_id = goal->header.frame_id;\n\n    // Assign the received PoseStamped goal to the action goal's target_pose\n    action_goal_message.goal.target_pose = *goal;\n\n    // Publishing the MoveBaseActionGoal to a topic\n    action_goal_pub_.publish(action_goal_message);\n\n    ROS_INFO(\"MoveBaseActionGoal published successfully to action_goal_pub_ topic.\");\n}", "CodeBleu_score": 59.63048823806909}, {"code": "#include <ros/ros.h>\n#include <geometry_msgs/PoseStamped.h>\n#include <move_base_msgs/MoveBaseActionGoal.h>\n#include <string>\n\nclass MoveBase {\npublic:\n    MoveBase() {\n        // Constructor sets up the ROS publisher here\n        ros::NodeHandle node_handle;\n        action_goal_pub_ = node_handle.advertise<move_base_msgs::MoveBaseActionGoal>(\"action_goal_pub_\", 10);\n    }\n\n    void goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal) {\n        // Log a debug message\n        ROS_DEBUG(\"Wrapping the received goal into a MoveBaseActionGoal message.\");\n\n        // Create a new MoveBaseActionGoal message\n        move_base_msgs::MoveBaseActionGoal action_goal;\n\n        // Set the header with the current time stamp\n        action_goal.header.stamp = ros::Time::now();\n        action_goal.header.frame_id = goal->header.frame_id; // Set frame to same as goal if req.\n\n        // Assign the received goal to the target_pose\n        action_goal.goal.target_pose = *goal;\n\n        // Publish the wrapped goal as an action goal\n        action_goal_pub_.publish(action_goal);\n\n        ROS_INFO(\"Published action goal to action_goal_pub_.\");\n    }\n\nprivate:\n    ros::Publisher action_goal_pub_;\n};\n\nint main(int argc, char** argv) {\n    ros::init(argc, argv, \"move_base\");\n    MoveBase moveBase;\n    ros::spin();\n    return 0;\n}", "CodeBleu_score": 47.23101547123659}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal) {\n    // Log debug message indicating a new goal is being processed\n    ROS_DEBUG(\"Received new goal. Preparing to send as MoveBaseActionGoal.\");\n\n    // Create a MoveBaseActionGoal message\n    move_base_msgs::MoveBaseActionGoal action_goal;\n\n    // Set the header of the message with the current time and frame\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.header.frame_id = goal->header.frame_id;\n\n    // Assign the received goal to the target_pose in the action goal\n    action_goal.goal.target_pose = *goal;\n\n    // Publish the action goal to the action_goal_pub_ topic\n    action_goal_pub_.publish(action_goal);\n\n    // Log the fact that the action goal has been published\n    ROS_INFO(\"MoveBaseActionGoal has been published to action_goal_pub_.\");\n}", "CodeBleu_score": 66.31698508131302}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "#include <cmath>\n#include <thread>\n#include <iostream>\n\nclass MoveSlowAndClear {\nprivate:\n    double squared_distance_threshold; // This represents the square of the required movement distance\n    double start_position_x;\n    double start_position_y;\n    std::thread* remove_limit_thread = nullptr; // Pointer to the thread that controls the speed limit\n    bool timer_stopped = false; // Flag to track timer state\n\npublic:\n    MoveSlowAndClear(double distance_threshold)\n    : squared_distance_threshold(distance_threshold * distance_threshold),\n      start_position_x(0), // Initialize with dummy values\n      start_position_y(0) {}\n\n   ~MoveSlowAndClear() {\n       if (remove_limit_thread && remove_limit_thread->joinable()) {\n           remove_limit_thread->join();\n           delete remove_limit_thread;\n           remove_limit_thread = nullptr;\n       }\n   }\n\n    void updateStartPosition(double x, double y) {\n        start_position_x = x;\n        start_position_y = y;\n    }\n\n    void removeSpeedLimit() {\n        // Method to remove speed limit:\n        // Replace this with actual implementation as required\n        std::cout << \"Speed limit has been removed.\\n\";\n    }\n\n    void distanceCheck(const ros::TimerEvent& e) {\n        double current_position_x = 0; // Should be set to robot's current X position\n        double current_position_y = 0; // Should be set to robot's current Y position\n\n        // Calculate the squared distance from the start position\n        double dx = current_position_x - start_position_x;\n        double dy = current_position_y - start_position_y;\n        double squared_distance = dx * dx + dy * dy;\n\n        if (squared_distance >= squared_distance_threshold) {\n            std::cout << \"Robot has moved sufficiently far. Stopping distance check and managing speed limit.\\n\";\n\n            if (remove_limit_thread && remove_limit_thread->joinable()) {\n                remove_limit_thread->join(); // Join the existing thread\n                delete remove_limit_thread; // After join, delete it safely\n                remove_limit_thread = nullptr;\n            }\n\n            // Start a new thread to remove the speed limit\n            remove_limit_thread = new std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n            // Stop the timer here\n            timer_stopped = true; // Mock-up; replace with actual ROS timer halt command\n        }\n    }\n};\n\nint main() {\n    MoveSlowAndClear robotMovements(5); // Assume a suitable movement threshold of 5 meters\n    robotMovements.updateStartPosition(0,0); // Starting position of the robot\n\n    // Simulation of timer event call for the sake of this example\n    ros::TimerEvent e; // Assuming we have a suitable event object\n    robotMovements.distanceCheck(e);\n    return 0;\n}", "CodeBleu_score": 37.827661989858164}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e) {\n    // Get the current position of the robot\n    double current_x = pose_.position.x;\n    double current_y = pose_.position.y;\n\n    // Calculate the squared distance from the last known position where speed limit started\n    double distance_squared = (current_x - last_known_x_) * (current_x - last_known_x_) +\n                              (current_y - last_known_y_) * (current_y - last_known_y_);\n\n    // Compare against the squared of the distance limit\n    double distance_limit_squared = distance_limit_ * distance_limit_;\n\n    // Check if the squared current distance is greater than or equal to the squared limited distance\n    if (distance_squared >= distance_limit_squared) {\n        // Log message indicating the robot has moved the required distance\n        ROS_INFO(\"MoveSlowAndClear::distanceCheck: Required distance achieved, removing speed limit.\");\n\n        // If remove_limit_thread_ exists, join and delete it\n        if (remove_limit_thread_ && remove_limit_thread_->joinable()) {\n            remove_limit_thread_->join();\n            delete remove_limit_thread_;\n            remove_limit_thread_ = nullptr;\n        }\n\n        // Creating a new thread to remove the speed limit\n        remove_limit_thread_ = new std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n        // Stop the timer used to check the distance regularly\n        distance_check_timer_.stop();\n    }\n}", "CodeBleu_score": 49.09431523673459}, {"code": "#include <ros/ros.h>\n#include <thread>\n#include <cmath>\n\nclass MoveSlowAndClear {\nprivate:\n    double moveDistanceSquared; // This value represents the threshold distance to cover squared\n    double currentDistanceSquared; // This value represents the current moved distance squared\n    std::thread* removeLimitThread; // Pointer to the thread responsible for removing speed limits\n    ros::Timer distanceCheckTimer; // ROS timer to manage timing of distance checks\n\npublic:\n    MoveSlowAndClear() : removeLimitThread(nullptr), currentDistanceSquared(0.0), moveDistanceSquared(100.0) { // Default desired distance squared\n        // Initialization logic here\n    }\n\n    void startNewRemoveLimitThread() {\n        // Assuming removeLimit is a member function\n        if (removeLimitThread != nullptr && removeLimitThread->joinable()) {\n            removeLimitThread->join();\n            delete removeLimitThread;\n        }\n        // Start new thread\n        removeLimitThread = new std::thread(&MoveSlowAndClear::removeLimit, this);\n    }\n\n    void removeLimit() {\n        // Removing speed limits operation\n        // Logging and actual limit removal handling code here\n    }\n\n    void distanceCheck(const ros::TimerEvent& e) {\n        // Check if sufficient distance has been moved\n        if (currentDistanceSquared >= moveDistanceSquared) {\n            ROS_INFO(\"Sufficient distance moved, proceeding to remove speed limit.\");\n\n            // Stop the distance check timer\n            distanceCheckTimer.stop();\n\n            // Join and delete any existing remove limit thread, then start a new one\n            startNewRemoveLimitThread();\n\n            // Further clean-up or operations can be performed here\n        } else {\n            // If not enough distance, continue waiting or any other required actions\n            ROS_INFO(\"Distance threshold not yet reached. Current: %f, Required: %f\", currentDistanceSquared, moveDistanceSquared);\n        }\n    }\n\n    ~MoveSlowAndClear() {\n        if (removeLimitThread != nullptr) {\n            if (removeLimitThread->joinable()) {\n                removeLimitThread->join();\n            }\n            delete removeLimitThread;\n        }\n    }\n};\n\n// Additional implementations would likely be needed in a full class", "CodeBleu_score": 46.581988767696245}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal) {\n    // Declare variables for the robot's current pose and the path.\n    rm::PoseStamped current_pose;\n    std::vector<rm::PoseStamped> plan;\n\n    // Attempt to retrieve the global pose of the robot.\n    if (!getRobotPose(current_pose)) {\n        // If unable to get the pose, log and return.\n        ROS_ERROR(\"Failed to get robot pose for path planning.\");\n        return;\n    }\n\n    // Generate a path from current pose to the goal pose.\n    if (!makePlan(current_pose, *goal, plan)) {\n        // If unable to perform planning, log and return.\n        ROS_ERROR(\"Failed to generate plan from current pose to goal.\");\n        return;\n    }\n\n    // If we successfully finished planning print the plan length or some other info\n    ROS_INFO(\"Successfully generated a plan with %lu waypoints.\", plan.size());\n}", "CodeBleu_score": 46.45050503887975}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal) {\n    geometry_msgs::PoseStamped current_pose;\n    std::vector<geometry_msgs::PoseStamped> plan;\n\n    // Get the current robot pose\n    if(getRobotPose(current_pose))\n    {\n        // Generate a path from current pose to the goal pose\n        if (makePlan(current_pose, *goal, plan)) \n        {\n            // If plan was generated successfully, process or publish the plan\n            ROS_INFO(\"Successfully generated a plan with %d waypoints.\", (int)plan.size());\n            // For example, you could publish the plan to a topic\n            plan_publisher.publish(plan);\n        } \n        else \n        {\n            ROS_ERROR(\"Failed to generate a plan.\");\n        }\n    } \n    else \n    {\n        ROS_ERROR(\"Failed to retrieve the current pose.\");\n    }\n}", "CodeBleu_score": 48.47875058900644}, {"code": "void NavfnWithCostmap::poseCallback(const geometry_msgs::PoseStamped::ConstPtr& goal) {\n    geometry_msgs::PoseStamped current_pose;\n    \n    if (getRobotPose(current_pose)) {\n        std::vector<geometry_msgs::PoseStamped> plan;\n        \n        // Attempt to make a plan from the current pose to the goal pose\n        if (makePlan(current_pose, *goal, plan)) {\n            ROS_INFO_STREAM(\"Successful in planning from current_pose to goal_pose.\");\n        } else {\n            ROS_WARN_STREAM(\"Failed to make a plan from current_pose to goal_pose.\");\n        }\n    } else {\n        ROS_ERROR_STREAM(\"Failed to retrieve the current robot pose.\");\n    }\n}", "CodeBleu_score": 45.942271319311324}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set) {\n    // Create a ParamSet service request object\n    autopilot_interface::ParamSet srv;\n    \n    // Assign values from the GimbalParamSet structure to the service request fields\n    srv.request.param_id = param_set.param_id;\n    srv.request.value = param_set.value;\n    \n    // Use the param_set_client_ member to make the service call\n    if (param_set_client_.call(srv)) {\n        // Log or handle the response if the call was successful\n        ROS_INFO(\"Gimbal parameter set successfully.\");\n    } else {\n        // Log the failure to set the parameter\n        ROS_ERROR(\"Failed to set gimbal parameter via service.\");\n    }\n}", "CodeBleu_score": 58.186581433446264}, {"code": "void AutonomousLanding::gimbalParamSetServer(const GimbalParamSet& param_set) {\n    // Create a service request object for setting parameters\n    param_set_srv::ParamSet srv;\n  \n    // Set the ID and value from GimbalParamSet structure to the service request\n    srv.request.param_id = param_set.param_id;\n    srv.request.value = param_set.value;\n  \n    // Use the client to send the service request and wait for the server\u2019s response\n    if (param_set_client_.call(srv)) {\n        // Check if the server responded with success\n        if (srv.response.success) {\n            ROS_INFO(\"Parameter set successfully: ID %d, Value %f\", param_set.param_id, param_set.value);\n        } else {\n            ROS_WARN(\"Failed to set parameter: ID %d, Value %f\", param_set.param_id, param_set.value);\n        }\n    } else {\n        ROS_ERROR(\"Service call to set gimbal parameters failed\");\n    }\n}", "CodeBleu_score": 48.957748637506924}, {"code": "#include \"AutonomousLanding.h\"  // Include the appropriate header files\n\nvoid AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set) {\n    // Assuming ParamSetReq is the request type for setting parameters\n    ParamSetReq request;\n\n    // Assign parameter ID and its value from GimbalParamSet\n    request.param_id = param_set.param_id;  \n    request.value = param_set.value;\n\n    // Send the request using the param_set_client_\n    // Assuming an asynchronous send with a callback for simplicity. Adjust accordingly.\n    bool success = param_set_client_.call(request);\n    \n    // Handle the outcome of the service call\n    if (success) {\n        std::cout << \"Gimbal parameter set successfully.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to set gimbal parameter.\" << std::endl;\n    }\n}", "CodeBleu_score": 43.17767693971945}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\nclass CommunicationBridge {\npublic:\n    void serverFun();\nprivate:\n    void processReceivedData(const std::string& data);\n    void publishData(const std::string& data);\n    void logError(const std::string& message);\n};\n\nvoid CommunicationBridge::serverFun() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n    \n    // Attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    \n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(8080);\n    \n    // Bind the socket to the address\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    \n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n    \n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0) {\n            perror(\"accept\");\n            continue;\n        }\n        \n        int valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            logError(\"Received incorrect data or connection error\");\n            close(new_socket);\n            continue;\n        }\n\n        std::string receivedData(buffer, valread);\n        \n        if (!receivedData.empty()) {\n            processReceivedData(receivedData);\n            publishData(receivedData);\n        } else {\n            logError(\"Empty or invalid data received\");\n        }\n\n        close(new_socket);\n    }\n}\n\nvoid CommunicationBridge::processReceivedData(const std::string& data) {\n    // Implementation might involve decoding and validating data\n    std::cout << \"Processing received data: \" << data << std::endl;\n}\n\nvoid CommunicationBridge::publishData(const std::string& data) {\n    // Implementation might involve sending data to another part of the system\n    std::cout << \"Publishing data: \" << data << std::endl;\n}\n\nvoid CommunicationBridge::logError(const std::string& message) {\n    std::cerr << \"Error: \" << message << std::endl;\n}\n\nint main() {\n    CommunicationBridge cb;\n    cb.serverFun();\n    return 0;\n}", "CodeBleu_score": 54.81787430255777}, {"code": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <unistd.h>\n\nclass CommunicationBridge {\npublic:\n    void serverFun();\nprivate:\n    void processReceivedMessage(const std::string& message);\n    void logError(const std::string& error);\n    void publishMessage(const std::string& message);\n};\n\nvoid CommunicationBridge::serverFun() {\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    \n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        logError(\"Socket creation failed\");\n        return;\n    }\n    \n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        logError(\"Setsockopt failed\");\n        return;\n    }\n    \n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(8080);\n    \n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0) {\n        logError(\"Bind failed\");\n        return;\n    }\n    if (listen(server_fd, 3) < 0) {\n        logError(\"Listen failed\");\n        return;\n    }\n    \n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0) {\n            logError(\"Accept failed\");\n            continue;\n        }\n        \n        int valread = read(new_socket, buffer, 1024);\n        if (valread < 0) {\n            logError(\"Read failed\");\n            close(new_socket);\n            continue;\n        } else if (valread == 0) {\n            logError(\"Client disconnected, or no data received\");\n            close(new_socket);\n            continue;\n        }\n        \n        std::string receivedMessage(buffer, valread);\n        processReceivedMessage(receivedMessage);\n        \n        close(new_socket); // Close the connection handle after processing\n    }\n    close(server_fd); // It is usually not hit in a server loop to keep it running indefinitely\n}\n\nvoid CommunicationBridge::processReceivedMessage(const std::string& message) {\n    // Placeholder for message processing logic.\n    publishMessage(message);\n}\n\nvoid CommunicationBridge::logError(const std::string& error) {\n    std::cerr << \"Error: \" << error << std::endl;\n}\n\nvoid CommunicationBridge::publishMessage(const std::string& message) {\n    // Placeholder for publishing logic\n    std::cout << \"Message: \" << message << std::endl;\n}", "CodeBleu_score": 52.32737817074433}, {"code": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <iostream>\n#include <unistd.h>\n#include <string.h>\n\nclass CommunicationBridge {\npublic:\n    void serverFun();\n};\n\nvoid CommunicationBridge::serverFun() {\n    // Define variables\n    int server_fd, new_socket;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n    const int PORT = 8080;\n\n    // Create socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind the socket to the port 8080\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY; // Bind to any address\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Start listening for the connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Accept connections in a loop\n    while (1) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0) {\n            perror(\"accept\");\n            continue;\n        }\n\n        memset(buffer, 0, 1024);\n        int valread = read(new_socket, buffer, 1024);\n        \n        // Check if data is received successfully\n        if (valread > 0) {\n            // Decode the message and publish it\n            std::cout << \"Message received: \" << buffer << std::endl;\n            // Example process, publish, etc. \n        } else {\n            // Log error and close the socket\n            std::cerr << \"Failed to read data or connection closed by client.\" << std::endl;\n            close(new_socket); // Close the current connection\n        }\n    }\n\n    // Close the server socket\n    close(server_fd);\n}\n\nint main() {\n    CommunicationBridge commBridge;\n    commBridge.serverFun();\n    return 0;\n}", "CodeBleu_score": 48.690616459329235}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "#include <map>\n\nclass UAV {\npublic:\n    void sendCommand(const UAVCommand& cmd) {\n        // The code for sending command to the UAV would go here.\n    }\n};\n\nstruct UAVCommand {\n    int id;  // Unique identifier for a UAV in the swarm\n    // Add other command specifics such as velocity, position, etc.\n};\n\nclass CommunicationBridge {\npublic:\n    // Constructors, destructors here if necessary\n\n    void recvData(const UAVCommand& uav_cmd) {\n        // Check simulation mode (assuming isSimulationMode is a boolean member of CommunicationBridge)\n        if (isSimulationMode) {\n            // In simulation mode, find the UAV by ID and send the command\n            auto it = swarm_control_simulation_.find(uav_cmd.id);\n            if (it != swarm_control_simulation_.end()) {\n                it->second.sendCommand(uav_cmd);\n            } else {\n                std::cerr << \"UAV with ID \" << uav_cmd.id << \" not found in simulation.\" << std::endl;\n            }\n        } else {\n            // Not in simulation mode, send command to the single UAV\n            uav_basic_.sendCommand(uav_cmd);\n        }\n    }\n\nprivate:\n    UAV uav_basic_;  // Basic UAV controller for non-simulation mode\n    std::map<int, UAV> swarm_control_simulation_;  // Map of UAV ids to UAV controls in simulation mode\n    bool isSimulationMode;  // Indicates whether currently in simulation mode or not\n};", "CodeBleu_score": 40.44579254958506}, {"code": "#include <iostream>\n#include <map>\n\n// Assume UAVCommand is previously defined somewhere\nstruct UAVCommand {\n    int uav_id;  // UAV unique identifier\n    std::string command;  // command to be sent to the UAV\n};\n\n// Mock classes/structures to simulate function context\nclass UAV {\npublic:\n    void publishCommand(const UAVCommand& cmd) {\n        std::cout << \"Command for UAV \" << cmd.uav_id << \": \" << cmd.command << std::endl;\n    }\n};\n\nclass CommunicationBridge {\npublic:\n    UAV uav_basic_;\n    std::map<int, UAV> swarm_control_simulation_;\n    bool simulation_mode_;\n\n    CommunicationBridge(bool simulation) : simulation_mode_(simulation) {}\n\n    void recvData(UAVCommand uav_cmd);\n};\n\nvoid CommunicationBridge::recvData(UAVCommand uav_cmd) {\n    if (!simulation_mode_) {\n        // Not in simulation mode, send command to the actual UAV\n        uav_basic_.publishCommand(uav_cmd);\n    } else {\n        // In simulation mode, find the UAV by ID and send the command\n        auto uav_it = swarm_control_simulation_.find(uav_cmd.uav_id);\n        if (uav_it != swarm_control_simulation_.end()) {\n            uav_it->second.publishCommand(uav_cmd);\n        } else {\n            std::cerr << \"UAV with ID \" << uav_cmd.uav_id << \" not found in simulation.\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    // Example usage\n    CommunicationBridge cb(true); // true for simulation mode\n\n    // Assuming there are predefined UAVs in simulation mode for IDs 1 and 2\n    cb.swarm_control_simulation_[1] = UAV();\n    cb.swarm_control_simulation_[2] = UAV();\n\n    UAVCommand cmd1 = {1, \"ascend\"};\n    UAVCommand cmd2 = {2, \"descend\"};\n    \n    cb.recvData(cmd1);\n    cb.recvData(cmd2);\n\n    return 0;\n}", "CodeBleu_score": 35.39193660715231}, {"code": "#include <iostream>\n#include <map>\n\n// Define a UAVCommand and UAV structures as examples (you should replace these with real UAV command structures)\nstruct UAVCommand {\n    int uavID;\n    std::string command;\n};\n\n// Simulation of basic UAV class\nclass UAV {\npublic:\n    void publishCommand(std::string cmd) {\n        std::cout << \"Command received: \" << cmd << std::endl;\n    }\n};\n\n// Assuming `uav_basic_` is a UAV object and `swarm_control_simulation_` is a map of UAV ID to UAV objects.\nclass CommunicationBridge {\nprivate:\n    UAV uav_basic_;\n    std::map<int, UAV> swarm_control_simulation_;\n    bool simulation_mode_;\n\npublic:\n    CommunicationBridge(bool simulation_mode) : simulation_mode_(simulation_mode) {\n        // provision some UAVs to the simulation map for demonstration\n        for (int i = 1; i <= 5; ++i) {\n            swarm_control_simulation_[i] = UAV();\n        }\n    }\n\n    void recvData(UAVCommand uav_cmd) {\n        if (!simulation_mode_) {\n            // Not in simulation mode, publish directly to the basic UAV\n            std::cout << \"Publishing to single UAV (non-simulation mode).\" << std::endl;\n            uav_basic_.publishCommand(uav_cmd.command);\n        } else {\n            // In simulation mode, find UAV by ID and publish the command\n            auto uav_itr = swarm_control_simulation_.find(uav_cmd.uavID);\n            if (uav_itr != swarm_control_simulation_.end()) {\n                std::cout << \"Publishing to UAV ID \" << uav_cmd.uavID << \" in simulation mode.\" << std::endl;\n                uav_itr->second.publishCommand(uav_cmd.command);\n            } else {\n                std::cout << \"UAV with ID \" << uav_cmd.uavID << \" not found in simulation.\" << std::endl;\n            }\n        }\n    }\n};\n\n// Example usage\nint main() {\n    CommunicationBridge bridge(true); // true for simulation mode\n    UAVCommand command = {1, \"ASCEND\"};\n    bridge.recvData(command);\n    command = {99, \"DESCEND\"}; // this UAV ID does not exist\n    bridge.recvData(command);  // expected to handle the case when UAV is not found\n    return 0;\n}", "CodeBleu_score": 34.66826592982226}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "struct ModeSelection {\n    enum Mode { REBOOTNX, EXITNX, CREATE, DELETE };\n    Mode mode;\n    bool use_mode; // true for create, false for delete\n};", "CodeBleu_score": 0.12854190075735727}, {"code": "#include <cstdlib> // For system()\n\nstruct ModeSelection {\n    enum Mode { REBOOTNX, EXITNX, CREATE, DELETE };\n    Mode mode;\n    bool use_mode;\n};\n\nclass CommunicationBridge {\npublic:\n    void modeSwitch(ModeSelection mode_selection);\n    void createMode();\n    void deleteMode();\n};\n\nvoid CommunicationBridge::createMode() {\n    // Placeholder for creating a mode\n    std::cout << \"Creating mode...\" << std::endl;\n}\n\nvoid CommunicationBridge::deleteMode() {\n    // Placeholder for deleting a mode\n    std::cout << \"Deleting mode...\" << std::endl;\n}\n\nvoid CommunicationBridge::modeSwitch(ModeSelection mode_selection) {\n    switch (mode_selection.mode) {\n        case ModeSelection::REBOOTNX:\n            // System command to reboot the system (example command)\n            system(\"shutdown -r now\");\n            break;\n        case ModeSelection::EXITNX:\n            // System command to shutdown/exit the system (example command)\n            system(\"shutdown -h now\");\n            break;\n        case ModeSelection::CREATE:\n            if (mode_selection.use_mode) {\n                createMode();\n            }\n            break;\n        case ModeSelection::DELETE:\n            if (mode_selection.use_mode) {\n                deleteMode();\n            }\n            break;\n        default:\n            std::cerr << \"Unknown mode selected.\" << std::endl;\n    }\n}", "CodeBleu_score": 24.701600357427587}, {"code": "#include <iostream>\n#include <cstdlib>\n\nstruct ModeSelection {\n    enum Mode { REBOOTNX, EXITNX, CREATE, DELETE } mode;\n    bool use_mode;\n};\n\nclass CommunicationBridge {\npublic:\n    void modeSwitch(ModeSelection mode_selection);\n\nprivate:\n    void createMode() {\n        std::cout << \"Creating mode...\" << std::endl;\n        // Additional implementation for create mode\n    }\n\n    void deleteMode() {\n        std::cout << \"Deleting mode...\" << std::endl;\n        // Additional implementation for delete mode\n    }\n\n    void rebootSystem() {\n        std::cout << \"Rebooting system...\" << std::endl;\n        system(\"reboot\");\n    }\n\n    void exitSystem() {\n        std::cout << \"Exiting system...\" << std::endl;\n        system(\"exit\");\n    }\n};\n\nvoid CommunicationBridge::modeSwitch(ModeSelection mode_selection) {\n    switch (mode_selection.mode) {\n        case ModeSelection::REBOOTNX:\n            rebootSystem();\n            break;\n        case ModeSelection::EXITNX:\n            exitSystem();\n            break;\n        case ModeSelection::CREATE:\n            if (mode_selection.use_mode) {\n                createMode();\n            }\n            break;\n        case ModeSelection::DELETE:\n            if (mode_selection.use_mode) {\n                deleteMode();\n            }\n            break;\n        default:\n            std::cerr << \"Invalid mode selection.\" << std::endl;\n            break;\n    }\n}\n\n// Usage\nint main() {\n    CommunicationBridge bridge;\n    ModeSelection selection;\n    \n    // Example 1: Reboot the system\n    selection.mode = ModeSelection::REBOOTNX;\n    bridge.modeSwitch(selection);\n\n    // Example 2: Mode creation\n    selection.mode = ModeSelection::CREATE;\n    selection.use_mode = true;\n    bridge.modeSwitch(selection);\n\n    return 0;\n}", "CodeBleu_score": 27.15400053862916}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent& time_event) { \n    static int lastHeartbeatCount = -1; // To store the last heartbeat count\n    static int missedAttempts = 0;      // To track missed attempts\n\n    // Check current heartbeat count (heartbeatCount is assumed to be a member variable or can be obtained through another member function)\n    int currentHeartbeatCount = this->heartbeatCount;\n\n    // Check if the heartbeat count has changed\n    if (currentHeartbeatCount == lastHeartbeatCount) {\n        // Heartbeat count has not changed\n        missedAttempts++;\n    }\n    else {\n        // Heartbeat count has changed, reset missed attempts counter\n        missedAttempts = 0;\n    }\n\n    // Update last heartbeat count to current count\n    lastHeartbeatCount = currentHeartbeatCount;\n\n    // Determine action based on missed attempts\n    if(missedAttempts >= MAX_MISSED_HEARTBEATS) {\n        // Exceeded number of attempts without a new heartbeat, assume disconnect\n        std::cerr << \"Error: Heartbeat not detected for \" << missedAttempts << \" consecutive checks.\" << std::endl;\n        \n        switch(vehicleType) { // vehicleType is assumed to be a member that defines the type of vehicle\n            case SWARM:\n                handleSwarmDisconnect();\n                break;\n            case UAV:\n                handleUAVDisconnect();\n                break;\n            case UGV:\n                handleUGVDisconnect();\n                break;\n            default:\n                std::cerr << \"Unknown vehicle type for disconnect handling.\" << std::endl;\n        }\n\n        // Set the disconnect flag\n        this->disconnect_flag = true; // disconnect_flag is assumed to be a Boolean member variable\n    }\n\n    // Finally, reset the disconnected flag if heartbeat is detected\n    if (missedAttempts == 0 && disconnect_flag) {\n        disconnect_flag = false;\n        std::cout << \"Connectivity restored.\" << std::endl;\n    }\n}", "CodeBleu_score": 51.45247122881729}, {"code": "#include <iostream>\n#include <string>\n\nclass CommunicationBridge {\npublic:\n    enum VehicleType { SWARM, UAV, UGV };\n\nprivate:\n    uint32_t lastHeartbeatCount;\n    uint32_t missedHeartbeatCounter;\n    bool disconnect_flag;\n    VehicleType vehicleType;\n    static const uint32_t maxMissedHeartbeats = 3; // Maximum missed heartbeats before declaring a disconnect\n\npublic:\n    CommunicationBridge(VehicleType type)\n        : lastHeartbeatCount(0), missedHeartbeatCounter(0), disconnect_flag(false), vehicleType(type) {}\n\n    void checkHeartbeatState(const ros::TimerEvent &time_event);\n    void takeActionOnDisconnect();\n};\n\nvoid CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event) {\n    uint32_t currentHeartbeatCount; // This would ideally come from a sensor or a network interface\n\n    // Simulate obtaining the current heartbeat count\n    currentHeartbeatCount = ... ; // Fetch the latest heartbeat count\n\n    if (currentHeartbeatCount == lastHeartbeatCount) {\n        // No new heartbeats\n        missedHeartbeatCounter++;\n        \n        if (missedHeartbeatCounter >= maxMissedHeartbeats) {\n            std::cout << \"Error: No heartbeat received for \" << maxMissedHeartbeats << \" consecutive checks.\" << std::endl;\n            disconnect_flag = true;\n            takeActionOnDisconnect();\n        }\n    } else {\n        // Heartbeat was received\n        missedHeartbeatCounter = 0; // reset the missed heartbeat counter\n    }\n\n    lastHeartbeatCount = currentHeartbeatCount; // Update last heartbeat count\n}\n\nvoid CommunicationBridge::takeActionOnDisconnect() {\n    switch (vehicleType) {\n        case SWARM:\n            std::cerr << \"Swarm communication lost!\" << std::endl;\n            break;\n        case UAV:\n            std::cerr << \"UAV communication lost!\" << std::endl;\n            break;\n        case UGV:\n            std::cerr << \"UGV communication lost!\" << std::endl;\n            break;\n    }\n    \n    // Additional disconnect handling could be implemented here, like: \n    // - Try to re-establish connection\n    // - Switch to a backup communication link\n    // - Notify operators or other systems\n}", "CodeBleu_score": 39.27932590638546}, {"code": "#include <iostream>\n#include <string>\n\nclass CommunicationBridge {\npublic:\n    enum VehicleType { SWARM, UAV, UGV };\n\n    CommunicationBridge() : currentHeartbeatCount(0), previousHeartbeatCount(0), missedAttempts(0), disconnect_flag(false), vehicleType(SWARM) {}\n\n    void checkHeartbeatState(const ros::TimerEvent& time_event);\n\nprivate:\n    int currentHeartbeatCount;  // current count of heartbeats received\n    int previousHeartbeatCount; // heartbeat count from previous check\n    int missedAttempts;         // number of successive checks with no new heartbeat\n    bool disconnect_flag;       // indicates if the vehicle is considered disconnected\n    VehicleType vehicleType;    // type of vehicle\n\n    void triggerAction();\n};\n\nvoid CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event) {\n    // Check if the current heartbeat count is the same as the previous\n    if (currentHeartbeatCount == previousHeartbeatCount) {\n        missedAttempts++;\n    } else {\n        missedAttempts = 0; // reset missed attempts count\n    }\n\n    // Update the previous heartbeat count\n    previousHeartbeatCount = currentHeartbeatCount;\n\n    // Check if missed attempts have reached the threshold\n    const int MAX_MISSED_ATTEMPTS = 3; // You can adjust this threshold based on system requirements\n    if (missedAttempts >= MAX_MISSED_ATTEMPTS) {\n        std::cerr << \"Error: Heartbeat missing for \" << missedAttempts << \" consecutive attempts.\" << std::endl;\n        triggerAction();\n        disconnect_flag = true;\n    }\n}\n\nvoid CommunicationBridge::triggerAction() {\n    switch (vehicleType) {\n        case SWARM:\n            std::cout << \"Trigger swarm recovery protocols.\" << std::endl;\n            break;\n        case UAV:\n            std::cout << \"Trigger UAV emergency landing procedures.\" << std::endl;\n            break;\n        case UGV:\n            std::cout << \"Trigger UGV return-to-base command.\" << std::endl;\n            break;\n        default:\n            std::cerr << \"Unknown vehicle type.\" << std::endl;\n    }\n}\n\n// In production, instead of simple prints, you would likely have more complex interactions with other system components or external alerts.", "CodeBleu_score": 43.868760533478834}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "#include <iostream>\n#include <vector>\n\n// Define Bspline struct for example. This is usually specific to your application.\nstruct Bspline {\n    int drone_id;\n    std::vector<double> knots;\n    std::vector<double> positions;  // Assuming 3D positions (x, y, z).\n    std::vector<double> yaws;\n};\n\nvoid EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg) {\n    std::vector<Bspline> bsplines;\n\n    // Assuming msg->bsplines is a vector of individual Bspline-like structures\n    for (auto &traj : msg->bsplines) {\n        Bspline bspline;\n        // assuming drone_id, knots, positions, yaws are directly accessible in `traj`\n        bspline.drone_id = traj.drone_id;\n        bspline.knots = traj.knots;\n        bspline.positions = traj.positions;\n        bspline.yaws = traj.yaws;\n\n        // You may need to do additional initialization or conversion if necessary\n        initializeBspline(bspline);\n\n        // Store the prepared bspline\n        bsplines.push_back(bspline);\n    }\n\n    // Assume we have a method to encode and send the data via TCP\n    if (!bsplines.empty()) {\n        std::string encodedData = encodeMultiBsplinesData(bsplines);\n        bool sendResult = sendViaTCP(encodedData);\n        if (!sendResult) {\n            std::cerr << \"Failed to send MultiBsplines data via TCP.\" << std::endl;\n        }\n    } else {\n        std::cout << \"No Bspline data to process.\" << std::endl;\n    }\n}\n\nvoid EGOPlannerSwarm::initializeBspline(Bspline &bspline) {\n    // Additional initialization or checks can be performed here\n}\n\nstd::string EGOPlannerSwarm::encodeMultiBsplinesData(const std::vector<Bspline>& bsplines) {\n    // Encode the vector of Bspline into a string (or other formats as needed)\n    // Placeholder for encoding logic\n    return \"encoded_data\";  // This is just a placeholder\n}\n\nbool EGOPlannerSwarm::sendViaTCP(const std::string &data) {\n    // Send data over TCP\n    // Placeholder for sending logic\n    return true;  // Assume it succeeds for now\n}", "CodeBleu_score": 27.389529066297964}, {"code": "#include <vector>\n\n// Definition for a hypothetical Bspline struct.\nstruct Bspline {\n    int drone_id;\n    std::vector<double> knots;\n    std::vector<std::vector<double>> positions; // Assuming 3D positions.\n    std::vector<double> yaws;\n    \n    // A simple method to encode Bspline data into a streamable format (not implemented here).\n    std::string encode() const {\n        // Implement the encoding logic here.\n        return \"\";\n    }\n};\n\n// Method of EGOPlannerSwarm to process and send MultiBsplines message.\nvoid EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg) {\n    std::vector<Bspline> splines;\n\n    // Iterate over each trajectory in the message.\n    for (const auto &traj : msg->trajectories) {\n        Bspline bspline;\n        bspline.drone_id = traj.drone_id;\n        bspline.knots = traj.knots;\n        bspline.positions = traj.positions;\n        bspline.yaws = traj.yaws;\n\n        // Save the Bspline data for this trajectory.\n        splines.push_back(bspline);\n    }\n\n    // Encode and send each Bspline via TCP using the communication module.\n    for (const auto &spline : splines) {\n        std::string encoded_data = spline.encode();\n\n        // Assuming there's a communication module with a method `sendData` to send the data.\n        communicationModule.sendData(encoded_data);\n    }\n}", "CodeBleu_score": 22.69949502464114}, {"code": "#include \"EGOPlannerSwarm.h\"\n#include \"Bspline.h\"\n#include \"CommunicationModule.h\"\n#include <vector>\n\nvoid EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr& msg) {\n    // Process the incoming MultiBsplines message\n    std::vector<Bspline> trajectories;\n\n    for (const auto& traj : msg->trajectories) {\n        Bspline b;\n\n        // Extract drone ID from the message\n        int drone_id = traj.drone_id;\n        b.setDroneId(drone_id);\n\n        // Set trajectory data: positions\n        b.setControlPoints(traj.positions);\n        \n        // Set trajectory data: times (knots)\n        b.setKnots(traj.knots);\n        \n        // Set trajectory data: yaw data, if available\n        b.setYawPoints(traj.yaw);\n        \n        // Initialize additional necessary Bspline struct attributes if needed\n        // b.setSomeOtherAttributes(...);\n\n        // Add the trajectory to the list\n        trajectories.push_back(b);\n    }\n\n    // Here we presume we have a serialize method and a send method, you may need to adjust according to your actual API\n    // Encode the trajectories data\n    std::string encoded_data = serializeTrajectories(trajectories);\n\n    // Send the data via TCP\n    CommunicationModule::sendDataViaTCP(encoded_data);\n}\n\n// Implementation of serializeTrajectories\nstd::string EGOPlannerSwarm::serializeTrajectories(const std::vector<Bspline>& trajectories) {\n    // Here we should convert trajectories data to a string format suitable for TCP transmission\n    // depending on your system's requirements.\n\n    std::string encoded;\n    for (const auto& traj : trajectories) {\n        encoded += traj.toString();  // Assumes that Bspline has a toString method that serializes its data\n        encoded += ';';  // Delimiter for each trajectory\n    }\n    return encoded;\n}", "CodeBleu_score": 24.82000893447259}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "#include <pcl/conversions.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl/compression/octree_pointcloud_compression.h>\n#include <sensor_msgs/PointCloud2.h>\n\nsensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2& msg) {\n    // Convert sensor_msgs::PointCloud2 to pcl::PointCloud<pcl::PointXYZ>\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>());\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Setup the octree compression for PointCloud data\n    pcl::io::OctreePointCloudCompression<pcl::PointXYZ> *compressor;\n    bool showStatistics = true;\n    pcl::io::compression_Profiles_e compressionProfile = pcl::io::LOW_RES_ONLINE_COMPRESSION_WITHOUT_COLOR;\n    compressor = new pcl::io::OctreePointCloudCompression<pcl::PointXYZ>(compressionProfile, showStatistics);\n\n    // Compress the point cloud\n    std::stringstream compressedData;\n    compressor->encodePointCloud(cloud, compressedData);\n\n    // Compress the data into a new sensor_msgs::PointCloud2\n    sensor_msgs::PointCloud2 compressed_msg;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr decompressedCloud(new pcl::PointCloud<pcl::PointXYZ>());\n    compressor->decodePointCloud(compressedData, decompressedCloud);\n    pcl::toROSMsg(*decompressedCloud, compressed_msg);\n\n    // Clean memory from the compressor to avoid memory leaks\n    delete compressor;\n\n    // Return the compressed PointCloud2 data\n    return compressed_msg;\n}", "CodeBleu_score": 43.32668679337858}, {"code": "#include <sensor_msgs/PointCloud2.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/compression/octree_pointcloud_compression.h>\n#include <iostream>\n#include <sstream>\n\nclass ReduceTheFrequency {\npublic:\n    sensor_msgs::PointCloud2 compressed(const sensor_msgs::PointCloud2& msg);\n};\n\nsensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2& msg) {\n    // Initialize point cloud objects\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>());\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloudOut(new pcl::PointCloud<pcl::PointXYZ>());\n\n    // Convert PointCloud2 to pcl::PointCloud\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Initialize the Octree compression object\n    pcl::io::OctreePointCloudCompression<pcl::PointXYZ> *compressor;\n    pcl::io::compression_Profiles_e compressionProfile = pcl::io::MED_RES_ONLINE_COMPRESSION_WITHOUT_COLOR;\n    bool showStatistics = true;\n\n    compressor = new pcl::io::OctreePointCloudCompression<pcl::PointXYZ>(compressionProfile, showStatistics);\n    \n    // Compressed point cloud data\n    std::stringstream compressedData;\n\n    // Compression\n    compressor->encodePointCloud(cloud, compressedData);\n\n    // Decompression (for demonstration, typically you would send compressed data directly)\n    compressor->decodePointCloud(compressedData, cloudOut);\n\n    // Convert pcl::PointCloud back to PointCloud2\n    sensor_msgs::PointCloud2 outputMsg;\n    pcl::toROSMsg(*cloudOut, outputMsg);\n\n    // Clean up\n    delete compressor;\n\n    // Return the compressed message\n    return outputMsg;\n}", "CodeBleu_score": 43.83876954363558}, {"code": "#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/compression/octree_pointcloud_compression.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <sensor_msgs/PointCloud2.h>\n\nclass ReduceTheFrequency {\npublic:\n    sensor_msgs::PointCloud2 compressed(const sensor_msgs::PointCloud2& msg) {\n        try {\n            // Initialize a PCL PointCloud\n            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\n            // Convert PointCloud2 to pcl::PointCloud\n            pcl::fromROSMsg(msg, *cloud);\n\n            // Compressing the point cloud data\n            pcl::io::OctreePointCloudCompression<pcl::PointXYZ>* compressor;\n            std::stringstream compressedData;\n            compressor = new pcl::io::OctreePointCloudCompression<pcl::PointXYZ>(pcl::io::HIGH_RESOLUTION, true);\n            compressor->encodePointCloud(cloud, compressedData);\n\n            // Create a new PointCloud for storing the compressed data\n            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_compressed(new pcl::PointCloud<pcl::PointXYZ>);\n\n            // Decode the compressed data back to PointCloud (optional, only if you want to visualize or check the integrity)\n            compressor->decodePointCloud(compressedData, cloud_compressed);\n\n            // Convert the pcl::PointCloud back to sensor_msgs::PointCloud2\n            sensor_msgs::PointCloud2 output_msg;\n            pcl::toROSMsg(*cloud_compressed, output_msg);\n\n            // Set frame ID and timestamp to match the input message\n            output_msg.header.frame_id = msg.header.frame_id;\n            output_msg.header.stamp = msg.header.stamp;\n\n            // Release the compressor memory\n            delete compressor;\n\n            return output_msg;\n        } catch (const std::exception& e) {\n            std::cerr << \"An error occurred: \" << e.what() << std::endl;\n            // Optionally handle the error more gracefully\n            return msg;\n        }\n    }\n};", "CodeBleu_score": 50.88270736323041}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "#include <vector>\n\n// Assuming the UAVState struct looks something like this\nstruct UAVState {\n    int uav_id;\n    // Other state details can be added here, e.g., position, velocity, etc.\n};\n\nclass SwarmControl {\npublic:\n    // Previous definitions and methods\n\n    void updateAllUAVState(UAVState uav_state) {\n        for (UAVState& state : multi_uav_state_) {\n            if (state.uav_id == uav_state.uav_id) {\n                state = uav_state;\n                break; // Assuming UAV IDs are unique and we found the one to replace\n            }\n        }\n    }\n\nprivate:\n    std::vector<UAVState> multi_uav_state_; // List of all UAV states\n};", "CodeBleu_score": 40.130438840667296}, {"code": "#include <vector>\n\nstruct UAVState {\n    int id;  // Assuming the UAVState includes at least an identifier.\n    // Add other UAV state information fields here\n};\n\nclass SwarmControl {\npublic:\n    void updateAllUAVState(UAVState uav_state);\n\nprivate:\n    std::vector<UAVState> multi_uav_state_;\n};\n\nvoid SwarmControl::updateAllUAVState(UAVState uav_state) {\n    // Iterate through the list of UAV states\n    for (UAVState &state : multi_uav_state_) {\n        // Check if the current state's ID matches the passed UAVState's ID\n        if (state.id == uav_state.id) {\n            // Update the state with new data\n            state = uav_state;  // Assigning new state.\n            break;  // Break the loop once the matching UAV is updated\n        }\n    }\n}", "CodeBleu_score": 37.92213854633955}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state) {\n    // Iterate through the list of UAV states\n    for (UAVState& state : multi_uav_state_) {\n        // Check if the current state's UAV ID matches the one we need to update\n        if (state.uav_id == uav_state.uav_id) {\n            // Update the state with the new uav_state\n            state = uav_state;\n            break;  // Assuming each ID is unique, so we can exit the loop\n        }\n    }\n}", "CodeBleu_score": 45.180939000915785}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "#include \"ros/ros.h\"\n#include \"std_msgs/String.h\"\n#include \"ugv_msgs/MultiUGVState.h\"\n#include \"ugv_msgs/UGVState.h\"\n\nclass SwarmControl {\npublic:\n    ros::Publisher state_pub;\n    ros::NodeHandle nh;\n\n    // Constructor to initialize the ROS publisher\n    SwarmControl() {\n        // Initialize the publisher on the \"ugv_states\" topic\n        state_pub = nh.advertise<ugv_msgs::MultiUGVState>(\"ugv_states\", 1000);\n    }\n\n    // Function to publish the state of all UGVs\n    void allUGVStatePub(struct MultiUGVState m_multi_ugv_state) {\n        // Initialize a MultiUGVState message\n        ugv_msgs::MultiUGVState msg;\n\n        // Loop through each UGV state provided in the input\n        for (const auto& single_ugv_state : m_multi_ugv_state.states) {\n            // Create a UGVState message for each UGV and populate it\n            ugv_msgs::UGVState ugv_state;\n\n            ugv_state.id = single_ugv_state.id;\n            ugv_state.battery = single_ugv_state.battery;\n            ugv_state.position = single_ugv_state.position;\n            ugv_state.velocity = single_ugv_state.velocity;\n            ugv_state.attitude = single_ugv_state.attitude;\n\n            // Add the UGVState to the MultiUGVState message\n            msg.states.push_back(ugv_state);\n        }\n\n        // Set the count of UGVs into the header (optional)\n        msg.header.stamp = ros::Time::now();\n        msg.header.frame_id = \"multi_ugv_frame\";\n        msg.count = m_multi_ugv_state.states.size();\n        \n        // Publish the assembled MultiUGVState message\n        state_pub.publish(msg);\n\n        // Logging output\n        ROS_INFO(\"Published MultiUGVState message with %lu UGVs.\", msg.states.size());\n    }\n};\n\nint main(int argc, char **argv)\n{\n    ros::init(argc, argv, \"swarm_control\");\n    SwarmControl swarmControl;\n\n    ros::spin();\n\n    return 0;\n}", "CodeBleu_score": 33.866282588420454}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\n\u5206\u6790\u5931\u8d25", "CodeBleu_score": 1.0080645161290323}, {"code": "#include <iostream>\n#include \"SwarmControl.h\"\n\nvoid SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state) {\n    // Initialize the message to be published\n    MultiUGVState pub_msg;\n    pub_msg.ugv_count = 0; // Initialize UGV count\n\n    // Iterate through each UGV state provided in the input structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; ++i) {\n        UGVState ugv_state;\n\n        // Populate the UGVState structure\n        ugv_state.id = m_multi_ugv_state.ugvs[i].id;\n        ugv_state.battery = m_multi_ugv_state.ugvs[i].battery;\n        ugv_state.position = m_multi_ugv_state.ugvs[i].position;\n        ugv_state.velocity = m_multi_ugv_state.ugvs[i].velocity;\n        ugv_state.attitude = m_multi_ugv_state.ugvs[i].attitude;\n\n        // Add the UGVState to the publishing message\n        pub_msg.ugvs.push_back(ugv_state);\n        pub_msg.ugv_count++; // Increment the count of UGVs\n    }\n\n    // Now, publish the assembled MultiUGVState message\n    publish(pub_msg);\n}\n\n// Placeholder function to simulate the publishing of a message for demonstration purposes\nvoid SwarmControl::publish(const MultiUGVState& msg) {\n    std::cout << \"Publishing MultiUGVState message with \" << msg.ugv_count << \" UGVs.\" << std::endl;\n}", "CodeBleu_score": 42.98851206926745}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient) {\n    // Initialize cost and gradient\n    cost = 0.0;\n    gradient.setZero(q.rows(), q.cols());\n\n    // Define clearance threshold\n    const double clearanceThreshold = 5.0;  // Example threshold value in appropriate units (e.g., meters)\n\n    // Simulate moving objects and their predicted positions\n    std::vector<Eigen::Vector2d> movingObjects; // Store positions of moving objects\n    std::vector<Eigen::Vector2d> velocities;    // Velocities of moving objects\n\n    // For example purposes, initialize some moving object positions and velocities \n    movingObjects.push_back(Eigen::Vector2d(10, 10));\n    velocities.push_back(Eigen::Vector2d(1, 1));\n\n    movingObjects.push_back(Eigen::Vector2d(20, 30));\n    velocities.push_back(Eigen::Vector2d(0.5, -0.5));\n\n    // Iterate through each control point in the B-spline\n    for (int k = 0; k < q.cols(); k++) {  // Assume q.cols() provides the number of control points\n        Eigen::Vector2d controlPoint = q.col(k).head<2>();  // Assuming 2D control points\n\n        // For every moving object\n        for (size_t i = 0; i < movingObjects.size(); ++i) {\n            // Predict future position of the moving object at time corresponding to control point k\n            Eigen::Vector2d predictedPosition = movingObjects[i] + velocities[i] * k; // Simple linear motion model\n\n            // Calculate the distance between the control point and moving object's predicted position\n            double distance = (controlPoint - predictedPosition).norm();\n\n            // Check if distance is below clearance\n            if (distance < clearanceThreshold) {\n                // Calculate distance error\n                double distanceError = clearanceThreshold - distance;\n\n                // Update cost\n                cost += distanceError * distanceError;  // Quadratic penalty for simplicity\n\n                // Calculate gradient (partial derivatives of cost w.r.t. control point coordinates)\n                // Normalized vector pointing from moving object to the control point\n                Eigen::Vector2d dir = (controlPoint - predictedPosition).normalized();\n                if (distance != 0) {\n                    gradient.col(k).head<2>() += 2.0 * distanceError * dir / distance;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 42.733519774427656}, {"code": "#include <Eigen/Dense>\n#include <vector>\n\nvoid BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient) {\n    int numControlPoints = q.rows();  // Assuming rows of q correspond to control points.\n    double clearance = 2.0;  // Example safe distance\n    double penaltyWeight = 10.0;  // Penalty weight for violation\n    \n    // Initialize cost and gradient\n    cost = 0.0;\n    gradient = Eigen::MatrixXd::Zero(numControlPoints, q.cols());\n\n    // Time parameter corresponding to each control point (assumed uniformly distributed for simplicity)\n    double tMax = 1.0;  // End time of the trajectory\n    double dt = tMax / numControlPoints;  // Time interval between control points\n\n    for (int i = 0; i < numControlPoints; ++i) {\n        double t = i * dt;\n        Eigen::Vector3d controlPoint = q.row(i);\n        Eigen::Vector3d objPosition = objectPositions(t);  // Call to hypothetical function to get object position at time t\n\n        // Calculate Euclidean distance between control point and object position\n        double distance = (controlPoint - objPosition).norm();\n\n        if (distance < clearance) {\n            // Cost calculation based on how much the distance is below the clearance\n            double distanceError = clearance - distance;\n            cost += penaltyWeight * distanceError * distanceError;  // Quadratic penalty\n\n            // Gradient calculation:\n            // Derivative of the cost with respect to the control point\n            Eigen::Vector3d diffVec = controlPoint - objPosition;\n            Eigen::Vector3d gradientContribution = -2.0 * penaltyWeight * distanceError * diffVec.normalized();\n            gradient.row(i) += gradientContribution;\n        }\n    }\n}\n\n// Hypothetical function to predict the position of moving objects.\nEigen::Vector3d BsplineOptimizer::objectPositions(double t) {\n    // This should be replaced by actual logic for predicting moving objects' positions.\n    return Eigen::Vector3d(sin(t), cos(t), t);  // Just a placeholder\n}", "CodeBleu_score": 42.788000308672046}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\n/**\n * In this function, we calculate the cost and gradient of a B-spline trajectory with\n * respect to moving objects. The B-spline is represented by its control points `q`.\n * The `cost` will be a sum of penalties where the B-spline control points\n * are too close to the predicted positions of moving objects.\n * The `gradient` matrix will have partial derivatives relative to each control point coordinate.\n *\n * @param q Matrix of B-spline control points, where each column represents a control point (e.g., in 2D or 3D).\n * @param cost Reference to a double where the total cost will be stored.\n * @param gradient Reference to a Matrix that will store the gradients w.r.t. each control point.\n */\nvoid BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient) {\n    int numControlPoints = q.cols();\n    int dim = q.rows();\n    cost = 0.0;\n    gradient.setZero(q.rows(), q.cols());\n\n    double minClearance = 1.0; // Minimum allowed distance to a moving object\n    double penaltyFactor = 100.0; // Penalty factor for violations\n\n    // Placeholder function for getting moving object positions at a given index\n    auto movingObjectPosition = [](int idx) -> Eigen::VectorXd {\n        // Here you will generate or fetch the predicted position of the moving object at time idx.\n        // Dummy function must be replaced with actual logic for motion prediction\n        return Eigen::VectorXd::Constant(dim, idx * 0.1); // For example purposes\n    };\n\n    for (int i = 0; i < numControlPoints; ++i) {\n        Eigen::VectorXd controlPoint = q.col(i);\n        Eigen::VectorXd movingObjPos = movingObjectPosition(i);\n\n        double distance = (controlPoint - movingObjPos).norm();\n\n        if (distance < minClearance) {\n            double distanceError = minClearance - distance;\n            cost += penaltyFactor * pow(distanceError, 2);\n\n            // Derivative of the cost w.r.t the control point coordinates\n            Eigen::VectorXd gradientVec = -2.0 * penaltyFactor * distanceError * (controlPoint - movingObjPos) / distance;\n            gradient.col(i) += gradientVec;\n        }\n    }\n}\n", "CodeBleu_score": 44.12647373264534}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "#include <Eigen/Dense>\n#include <vector>\n\nclass BsplineOptimizer {\npublic:\n    void calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient) {\n        // Initialising the cost and gradient\n        cost = 0.0;\n        gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n        // Constants for normalization (assumed constants a2, b2; modify per actual application)\n        const double a2 = 1.0;\n        const double b2 = 1.0;\n\n        // Assuming referencePoints and velocityVectors to be predefined or calculated elsewhere\n        Eigen::MatrixXd referencePoints(q.rows(), q.cols()); // Placeholder matrix for reference points\n        Eigen::MatrixXd velocityVectors(q.rows(), q.cols()); // Placeholder matrix for velocity vectors\n        \n        // Compute the positional errors and update cost and gradient\n        for (int i = 0; i < q.cols(); ++i) {\n            Eigen::VectorXd point = q.col(i);\n            Eigen::VectorXd refPoint = referencePoints.col(i);\n            Eigen::VectorXd velocityVec = velocityVectors.col(i);\n            \n            // Positional error vector\n            Eigen::VectorXd errorVec = point - refPoint;\n\n            // Calculation of the cost using 'squared dot product' and 'cross product'\n            double dotProduct = point.transpose() * velocityVec;\n            Eigen::Vector3d crossProduct = point.cross(velocityVec); // Assuming 'q' and velocity are 3D vectors\n\n            cost += a2 * dotProduct * dotProduct + b2 * crossProduct.squaredNorm();\n\n            // Derivatives calculation for gradient (simplified example)\n            Eigen::VectorXd dCost_dPoint = 2 * a2 * dotProduct * velocityVec \n                                           + 2 * b2 * point.cross(crossProduct);\n            \n            gradient.col(i) = dCost_dPoint;\n        }\n    }\n};", "CodeBleu_score": 35.849683575924004}, {"code": "#include <Eigen/Dense>\n\nclass BsplineOptimizer {\n public:\n  void calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient);\n  \n  // Assuming these are for simplification and need to be appropriately defined or extracted from actual usage.\n  static constexpr double a2 = 1.0;  // Example scaling factor for dot product term.\n  static constexpr double b2 = 1.0;  // Example scaling factor for cross product term.\n  Eigen::VectorXd referencePoints;   // Example reference points.\n  Eigen::VectorXd velocities;        // Example velocities associated with each control point.\n};\n\nvoid BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient) {\n    int n = q.rows();  // Assuming number of control points.\n    int d = q.cols();  // Assuming dimensions of each point\n    \n    cost = 0.0;  // Initialize the cost\n    gradient = Eigen::MatrixXd::Zero(n, d);  // Initialize the gradient matrix\n\n    for (int i = 0; i < n; ++i) {\n        Eigen::VectorXd controlPoint = q.row(i);  // Get the i-th control point\n        Eigen::VectorXd refPoint = referencePoints.segment(i * d, d);  // Corresponding reference point\n        Eigen::VectorXd velocity = velocities.segment(i * d, d);  // Corresponding velocity\n        \n        // Compute the positional error vector and velocity error\n        Eigen::VectorXd positionalError = controlPoint - refPoint;\n        Eigen::VectorXd velocityError = velocity;  // Here assuming velocity should match some ideal or is to be minimized\n\n        // Cost calculations\n        double dotProdError = positionalError.dot(velocityError);\n        Eigen::Vector3d crossProdError = positionalError.cross(velocityError);  // Only for 3D\n\n        // Update the cost: we are normalizing the squared magnitude of errors by constants a2 and b2\n        cost += (dotProdError * dotProdError) / a2 + crossProdError.squaredNorm() / b2;\n\n        // Gradient calculations (gradients to be obtained by derivating the cost function w.r.t. the control points)\n        Eigen::VectorXd gradPosError = 2.0 * dotProdError / a2 * velocityError;\n        Eigen::Vector3d gradCrossError = 2.0 / b2 * crossProdError.cross(velocityError);\n\n        // Update the gradient for current control point\n        gradient.row(i) += gradPosError.head(d);  // considering only the first d elements\n        if (d == 3) {\n            gradient.row(i) += gradCrossError;\n        }\n    }\n}", "CodeBleu_score": 35.32173968462218}, {"code": "#include <Eigen/Dense>\n#include <vector>\n\nclass BsplineOptimizer {\npublic:\n    void calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient);\nprivate:\n    std::vector<Eigen::Vector3d> referencePoints; // supplied reference points\n    double a2 = 1.0; // constant for dot product error scaling\n    double b2 = 1.0; // constant for cross product error scaling\n};\n\nvoid BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient) {\n    // Initializations\n    int n = q.rows(); // assuming q rows are control points.\n    int dim = q.cols(); // dimensions of each control point\n    cost = 0.0;\n    gradient = Eigen::MatrixXd::Zero(n, dim); // Assuming gradient is the same size as q\n                \n    // Computing the fitness cost and gradient\n    for (int i = 0; i < n; ++i) {\n        Eigen::Vector3d p = q.row(i); // Current control point\n        Eigen::Vector3d ref = referencePoints[i]; // Corresponding reference point\n        \n        // Calculate positional error\n        Eigen::Vector3d positionalError = ref - p;\n        double dotProductError = positionalError.dot(positionalError);\n        \n        // Velocity error, assuming velocity is change in position (simple difference)\n        Eigen::Vector3d velocityError(0,0,0);\n        if (i < n - 1) {\n            velocityError = q.row(i + 1) - q.row(i);\n        }\n        Eigen::Vector3d crossProductError = velocityError.cross(positionalError);\n\n        // Update cost\n        cost += a2 * dotProductError + b2 * crossProductError.squaredNorm();\n\n        // Update gradient\n        Eigen::Vector3d gradP = 2 * a2 * positionalError;\n        if (i < n - 1) {\n            Eigen::Vector3d gradV = 2 * b2 * crossProductError.cross(velocityError);\n            gradient.row(i) += (-gradP - gradV);\n            gradient.row(i+1) += gradV;\n        } else {\n            gradient.row(i) += (-gradP);\n        }\n    }\n}", "CodeBleu_score": 36.93066301459655}]}
{"instance_id": "265612743518", "generation_result": [{"code": "#include <vector>\n#include <cmath>  // For pow()\n\nclass UniformBspline {\nprivate:\n    std::vector<double> control_points;  // Example control point structure\n    std::vector<double> knot_times;      // Example knot times structure\n\npublic:\n    UniformBspline::UniformBspline();\n\n    // Assuming a function to compute derivatives of any order\n    UniformBspline derivative(int order) const {\n        // Actual implementation to compute and return the spline derivative as another UniformBspline object\n    }\n\n    // Getter for control points; typically more complex involving spline dimensions\n    const std::vector<double>& getControlPoints() const {\n        return control_points;\n    }\n\n    // Getter for knot times\n    const std::vector<double>& getKnotTimes() const {\n        return knot_times;\n    }\n\n    double getJerk();\n};\n\ndouble UniformBspline::getJerk() {\n    // Compute the third derivative (jerk trajectory)\n    UniformBspline jerkTrajectory = this->derivative(3);\n\n    // Get the control points and times of the jerk trajectory\n    const std::vector<double>& jerkControlPoints = jerkTrajectory.getControlPoints();\n    const std::vector<double>& jerkKnots = jerkTrajectory.getKnotTimes();\n\n    if (jerkControlPoints.empty() || jerkKnots.size() < 2) {\n        return 0.0;  // Safety check\n    }\n\n    double totalJerk = 0.0;\n    double timeDiff;\n    // Calculate the total jerk\n    for (size_t i = 1; i < jerkKnots.size(); ++i) {\n        timeDiff = jerkKnots[i] - jerkKnots[i - 1];\n        totalJerk += pow(jerkControlPoints[i], 2) * timeDiff;  // Sum of squared control points multiplied by time differences\n    }\n\n    return totalJerk;\n}", "CodeBleu_score": 37.401045170656374}, {"code": "#include <vector>\n#include <cmath>\n\nclass UniformBspline {\nprivate:\n    std::vector<double> controlPoints; // A flattened list of control points, assuming each point has `d` dimensions\n    std::vector<double> knotTimes;     // Knot vector\n    int order;                         // Order of the B-spline\n    int d;                             // Dimension of the control points\n\npublic:\n    UniformBspline(const std::vector<double>& controlPoints, const std::vector<double>& knotTimes, int order, int d)\n    : controlPoints(controlPoints), knotTimes(knotTimes), order(order), d(d) {}\n\n    double getJerk() {\n        // Validate order (at least 4 for third derivative)\n        if (order < 4) {\n            throw std::runtime_error(\"Spline order must be at least 4 to compute jerk.\");\n        }\n\n        int numCtrlPoints = controlPoints.size() / d;  // Number of control points\n        std::vector<double> jerkControlPoints(numCtrlPoints - 3, 0);\n\n        // Compute third derivatives of control points for jerk (simplified, assuming uniform and no basis computation)\n        for (int i = 0; i < numCtrlPoints - 3; ++i) {\n            for (int dim = 0; dim < d; ++dim) {\n                jerkControlPoints[i * d + dim] = controlPoints[(i + 3) * d + dim] - 3 * controlPoints[(i + 2) * d + dim] +\n                                                 3 * controlPoints[(i + 1) * d + dim] - controlPoints[i * d + dim];\n            }\n        }\n\n        // Compute the jerk value\n        double totalJerk = 0.0;\n        for (int i = 0; i < jerkControlPoints.size(); i += d) {\n            double jerkMagnitudeSquared = 0.0;\n            for (int dim = 0; dim < d; ++dim) {\n                jerkMagnitudeSquared += std::pow(jerkControlPoints[i + dim], 2);\n            }\n            double deltaT = knotTimes[i / d + 4] - knotTimes[i / d]; // Assumes uniform knot spans at intervals\n            totalJerk += jerkMagnitudeSquared * deltaT;\n        }\n\n        return std::sqrt(totalJerk);\n    }\n};\n\n// Example usage:\nint main() {\n    std::vector<double> cps = {0, 0, 1, 1, 2, 2, 3, 3, 4, 4}; // Example control points (5 points, 2D)\n    std::vector<double> knots = {0, 1, 2, 3, 4, 5}; // Example knot times\n    int ord = 4; // Cubic spline\n    int dimensions = 2;\n\n    UniformBspline spline(cps, knots, ord, dimensions);\n    try {\n        double jerk = spline.getJerk();\n        std::cout << \"Jerk: \" << jerk << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}", "CodeBleu_score": 43.84658657037911}, {"code": "#include <vector>\n#include <cmath>\n\nclass UniformBspline {\nprivate:\n    std::vector<double> controlPoints;  // Store control points\n    std::vector<double> knots;          // Store knot times\n    \n    // Example of a derivative operation (third derivative for jerk):\n    UniformBspline derive(int order) {\n        UniformBspline derivedSpline;\n        // Hypothetical implementation for derivative\n        return derivedSpline;\n    }\n\npublic:\n    std::vector<double> getControlPoints() const {\n        return controlPoints;\n    }\n\n    std::vector<double> getKnots() const {\n        return knots;\n    }\n\n    double getJerk() {\n        // Calculate the third derivative to obtain the jerk trajectory\n        UniformBspline jerkSpline = this->derive(3);\n\n        // Retrieve the knot times and control points for the jerk trajectory\n        std::vector<double> jerkControlPoints = jerkSpline.getControlPoints();\n        std::vector<double> jerkKnots = jerkSpline.getKnots();\n\n        // Calculate the total jerk (sum of the square of control points * difference of knot times)\n        double totalJerk = 0.0;\n        double dt;\n        for (size_t i = 1; i < jerkKnots.size(); ++i) {\n            dt = jerkKnots[i] - jerkKnots[i - 1];\n            for (size_t j = 0; j < jerkControlPoints.size(); ++j) {\n                totalJerk += jerkControlPoints[j] * jerkControlPoints[j] * dt;\n            }\n        }\n\n        return totalJerk;\n    }\n};\n\n// This example assumes various methods and class structures which need actual implementations based on your current environment and libraries.", "CodeBleu_score": 42.700282959721235}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \n\u5206\u6790\u5931\u8d25", "CodeBleu_score": 5.921052631578947}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \n\n    // Convert pixel coordinates (u, v) and depth into camera coordinates (x, y, z)\n    double x = (u - cx_) * depth / fx_;\n    double y = (v - cy_) * depth / fy_;\n    double z = depth;\n  \n    // The fourth component of the position vector is generally set to 1 for homogeneous coordinates\n    double w = 1.0;\n\n    // Return this calculated position as a 4D vector\n    return Eigen::Vector4d(x, y, z, w);\n}", "CodeBleu_score": 53.79644710465369}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \n    // Calculate x, y, z camera coordinates from the pixel coordinates and depth\n    double x = (u - cx_) * depth / fx_;\n    double y = (v - cy_) * depth / fy_;\n    double z = depth;\n\n    // Return as a 4D position vector (homogeneous coordinates)\n    return Eigen::Vector4d(x, y, z, 1.0);\n}", "CodeBleu_score": 51.81413447823181}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "#include <string>\n#include <exception>\n#include <iostream>\n\n// Assuming the existence of:\n// nav_msgs::Odometry\n// DroneDetector::rcvDroneOdomCallbackBase(const nav_msgs::Odometry& odom, const std::string& droneID)\n\nvoid DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom) {\n    try {\n        // Assuming 'child_frame_id' field is a formatted string that contains the drone ID.\n        std::string child_frame_id = odom.child_frame_id;\n        \n        // Extract drone ID from child_frame_id. Depending on the format you may need a more complex parsing method.\n        // For example, if child_frame_id is something like \"drone_10_odom\", you need to parse out \"10\".\n        std::size_t idStartPos = child_frame_id.find(\"drone_\") + 6; // 6 is length of \"drone_\"\n        std::size_t idEndPos = child_frame_id.find(\"_odom\", idStartPos);\n        \n        // Extract the substring that contains the drone ID\n        std::string droneID = child_frame_id.substr(idStartPos, idEndPos - idStartPos);\n        \n        // Call the base callback function with the odometry data and the drone ID\n        rcvDroneOdomCallbackBase(odom, droneID);\n    } catch (const std::exception& e) {\n        // Handle exceptions related to string operations or others\n        std::cerr << \"Failed to extract drone ID from child_frame_id: \" << e.what() << std::endl;\n    } catch (...) {\n        // Catch any other exceptions\n        std::cerr << \"An unknown error occurred while processing the odometry message.\" << std::endl;\n    }\n}", "CodeBleu_score": 47.15217406786025}, {"code": "#include <iostream>\n#include <string>\n#include <regex>\n\nvoid DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom) {\n    try {\n        // Extract the drone ID from the child_frame_id field\n        std::string child_frame_id = odom.child_frame_id;\n        std::regex id_regex(\"drone(\\\\d+)\");\n        std::smatch matches;\n\n        if (std::regex_search(child_frame_id, matches, id_regex) && matches.size() > 1) {\n            std::string drone_id = matches.str(1); // The first matched group is the drone ID\n            // Call the base function with the odometry data and drone ID\n            rcvDroneOdomCallbackBase(odom, drone_id);\n        } else {\n            throw std::runtime_error(\"Failed to extract drone ID from child_frame_id\");\n        }\n    } catch (const std::exception& e) {\n        // Catch and print the exception if drone ID extraction fails\n        std::cerr << \"Exception caught in rcvDroneXOdomCallback: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 48.45712916349321}, {"code": "#include <string>\n#include <iostream>\n\nvoid DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom) {\n    try {\n        // Typically, the child_frame_id might be formatted with a prefix followed by the ID\n        std::string child_frame_id = odom.child_frame_id;\n        \n        if (child_frame_id.empty()) {\n            throw std::runtime_error(\"child_frame_id is empty\");\n        }\n\n        // If frame ID conventionally has a prefix before the ID, remove the prefix.\n        // Example: \"drone123\" where \"drone\" is the prefix and \"123\" is the ID.\n        size_t id_start_pos = child_frame_id.find(\"drone\");\n        if (id_start_pos == std::string::npos) {\n            throw std::runtime_error(\"Prefix 'drone' not found in child_frame_id\");\n        }\n\n        // Extract the ID part after the prefix\n        std::string drone_id = child_frame_id.substr(id_start_pos + 5); // Assuming 'drone' is 5 chars long\n\n        if (drone_id.empty()) {\n            throw std::runtime_error(\"No drone ID found after prefix\");\n        }\n\n        // Call the base callback with the extracted ID and odometry data\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception caught while processing drone odometry: \" << e.what() << std::endl;\n    }\n}", "CodeBleu_score": 46.74978784276297}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "#include <Eigen/Dense>\n#include <iostream>\n#include <string>\n\nclass DroneDetector {\npublic:\n    Eigen::Matrix4f cameraToWorldTransform; // Transformation matrix from camera frame to world frame\n\n    void detect(int drone_id, Eigen::Vector2i &true_pixel) {\n        // Step 1: Convert pixel coordinates to pose in the camera frame\n        Eigen::Vector3f drone_pose_camera = getPoseFromPixel(true_pixel);\n\n        // Step 2: Check if the drone is present at the calculated pose\n        bool drone_found = isDronePresent(drone_pose_camera);\n\n        if (drone_found) {\n            // Step 3: Calculate pose error between the camera and world coordinates\n            Eigen::Vector3f pose_error = computePoseError(drone_pose_camera, cameraToWorldTransform);\n\n            // Step 4: Update the debug result\n            updateDebugResult(drone_id, true, \"Drone detected successfully.\");\n\n            // Step 5: Publish the pose error\n            publishPoseError(pose_error);\n        } else {\n            // Update debug result indicating failure\n            updateDebugResult(drone_id, false, \"Drone detection failed.\");\n        }\n    }\n\nprivate:\n    Eigen::Vector3f getPoseFromPixel(Eigen::Vector2i pixel) {\n        // Simulated conversion: This will depend on the specific implementation details\n        return Eigen::Vector3f(pixel[0], pixel[1], 1.0f);  // Note: Simplistic approach\n    }\n\n    bool isDronePresent(Eigen::Vector3f &pose) {\n        // Logic to verify drone existence at the pose\n        return true;  // This example always returns true, actual implementation needed\n    }\n\n    Eigen::Vector3f computePoseError(const Eigen::Vector3f &drone_pose_camera, const Eigen::Matrix4f &transform) {\n        // Convert drone pose in camera frame to world frame\n        Eigen::Vector4f drone_pose_world = transform * Eigen::Vector4f(drone_pose_camera[0], drone_pose_camera[1], drone_pose_camera[2], 1.0f);\n        // Error computation (simplified)\n        return drone_pose_world.head<3>() - drone_pose_camera;\n    }\n\n    void updateDebugResult(int drone_id, bool success, const std::string &message) {\n        // Log or send a debug message\n        std::cout << \"Drone ID: \" << drone_id << \", Success: \" << success << \", Message: \" << message << std::endl;\n    }\n\n    void publishPoseError(const Eigen::Vector3f &pose_error) {\n        // Usually would be a network send or data log\n        std::cout << \"Pose Error: \" << pose_error.transpose() << std::endl;\n    }\n};", "CodeBleu_score": 30.717403184113028}, {"code": "#include <Eigen/Dense>\n#include <iostream>\n#include <string>\n\nclass DroneDetector {\npublic:\n    // Assuming presence of these utility methods\n    Eigen::Matrix4f computeTruePose(Eigen::Vector2i pixel);\n    bool checkDronePresence(Eigen::Matrix4f pose);\n    void updateDebugResults(std::string result);\n    void publishPoseError(Eigen::Matrix4f error);\n\n    // The detect method as described\n    void detect(int drone_id, Eigen::Vector2i &true_pixel) {\n        // Compute the pose in the camera frame based on the pixel data\n        Eigen::Matrix4f truePose = computeTruePose(true_pixel);\n\n        // Check if the drone with the given ID is present at this pose\n        if (checkDronePresence(truePose)) {\n            // Compute the pose error, assuming some world coordinates transformation method\n            Eigen::Matrix4f poseError = computePoseError(truePose); // Definition of computePoseError needs to be provided\n\n            // Update the debug result on successful detection\n            updateDebugResults(\"Drone \" + std::to_string(drone_id) + \" detected successfully.\");\n\n            // Publish the pose error between camera and world coordinates\n            publishPoseError(poseError);\n        } else {\n            // Update the debug result to indicate detection failure\n            updateDebugResults(\"Drone detection failed for drone ID \" + std::to_string(drone_id) + \".\");\n        }\n    }\n};\n\n// Placeholder implementations for assumed methods\nEigen::Matrix4f DroneDetector::computeTruePose(Eigen::Vector2i pixel) {\n    // Placeholder for true pose computation\n    return Eigen::Matrix4f::Identity();  // Just returning an identity matrix as a filler\n}\n\nbool DroneDetector::checkDronePresence(Eigen::Matrix4f pose) {\n    // Placeholder for presence checking logic\n    return true;  // Assumes the drone is always present\n}\n\nvoid DroneDetector::updateDebugResults(std::string result) {\n    // Log or handle debug results\n    std::cout << result << std::endl;\n}\n\nvoid DroneDetector::publishPoseError(Eigen::Matrix4f error) {\n    // Placeholder for publishing the computed error\n    std::cout << \"Publishing error: \" << std::endl << error << std::endl;\n}\n\nEigen::Matrix4f computePoseError(Eigen::Matrix4f truePose) {\n    // Implement actual pose error calculation here\n    return Eigen::Matrix4f::Zero();  // Returning zero matrix as a placeholder\n}\n\n// main function for testing purposes\nint main() {\n    DroneDetector detector;\n    Eigen::Vector2i pixelPos(100, 150);  // Example pixel position\n    detector.detect(1, pixelPos);\n    return 0;\n}", "CodeBleu_score": 27.186577406439184}, {"code": "#include <iostream>\n#include \"Eigen/Dense\"\n\nclass DroneDetector {\npublic:\n    Eigen::Matrix3f camera_matrix; \n    Eigen::Vector3f drone_world_position;\n\n    DroneDetector() {\n        // Initialize the camera matrix (example values).\n        camera_matrix << 525, 0, 320, // fx, 0,  cx\n                          0, 525, 240, // 0,  fy, cy\n                          0,   0,   1; // 0,   0,  1\n\n        // Set the world position of the drone (example values).\n        drone_world_position << 100, 50, 150;\n    }\n\n    void detect(int drone_id, Eigen::Vector2i &true_pixel) {\n        // Assume function to convert pixel to camera frame coordinates\n        Eigen::Vector3f pixel_homogenous(true_pixel.x(), true_pixel.y(), 1);\n        Eigen::Vector3f drone_camera_position = camera_matrix.inverse() * pixel_homogenous;\n\n        // Output the drone coordinates in the camera frame\n        std::cout << \"Drone Camera position: \" << drone_camera_position.transpose() << std::endl;\n\n        // Calculate pose error: distance between projected and actual world position (simplified)\n        Eigen::Vector3f error = drone_camera_position - drone_world_position;\n        \n        if (error.norm() < 50.0f) { // Threshold to check if the drone is within an acceptable range\n            std::cout << \"Drone detected with ID \" << drone_id << \", Pose error: \" << error.transpose() << std::endl;\n            updateDebugResult(true, error);\n        } else {\n            std::cout << \"Drone with ID \" << drone_id << \" not detected.\" << std::endl;\n            updateDebugResult(false, error);\n        }\n\n        // If more details required, e.g., publish the results\n        publishPoseError(error);\n    }\n\nprivate:\n    void updateDebugResult(bool detect_success, Eigen::Vector3f &pose_error) {\n        if (detect_success) {\n            std::cout << \"Detection success, pose error: \" << pose_error.transpose() << std::endl;\n        }\n        else {\n            std::cout << \"Detection failed, checking further.\" << std::endl;\n        }\n    }\n\n    void publishPoseError(Eigen::Vector3f &error) {\n        std::cout << \"Publishing pose error: \" << error.transpose() << std::endl;\n        // Implement the actual publish to a system or a logger here\n    }\n};", "CodeBleu_score": 30.657796851848733}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "#include <vector>\n#include <algorithm> // for std::reverse\n\nusing namespace std;\n\nclass GridNode; // Assume GridNode class definition is elsewhere\ntypedef GridNode* GridNodePtr; // Assuming GridNodePtr is a pointer to GridNode\n\nclass AStar {\n    map<GridNodePtr, GridNodePtr> cameFrom; // Tracks each node's parent in the path\n\npublic:\n    vector<GridNodePtr> retrievePath(GridNodePtr current) {\n        vector<GridNodePtr> path;\n\n        // Start with the end node\n        GridNodePtr node = current;\n\n        // Trace back from the end node to the start node\n        while (node != nullptr) {\n            path.push_back(node);\n            node = cameFrom[node];  // Move to the parent node\n        }\n\n        // Reverse to get the path from start to end\n        reverse(path.begin(), path.end());\n        return path;\n    }\n};", "CodeBleu_score": 40.56930170496656}, {"code": "#include <vector>\n#include <algorithm>  // For std::reverse\n\n// Assuming GridNode is a struct or class that represents nodes in the grid.\nclass GridNode {\npublic:\n    // Each node might contain a pointer to its parent in the optimal path\n    GridNodePtr parent;  \n    // Additional members (like coordinates, etc.) might be here\n};\n\nclass AStar {\npublic:\n    // Assuming GridNodePtr is defined, for example as follows:\n    // typedef GridNode* GridNodePtr;  // or std::shared_ptr<GridNode>\n    \n    vector<GridNodePtr> retrievePath(GridNodePtr current) {\n        vector<GridNodePtr> path;\n\n        // Start with the current node, trace back to the start node\n        while (current != nullptr) {  // or another condition to verify start node\n            path.push_back(current);  // Add the node to the path\n            current = current->parent;  // Move to the parent node\n        }\n        \n        // The path is in reverse order, from goal to start, so reverse it\n        std::reverse(path.begin(), path.end());\n        \n        return path;  // Return the correctly ordered path\n    }\n};", "CodeBleu_score": 52.204331026900086}, {"code": "#include <vector>\n#include <algorithm>  // for std::reverse\n\nclass GridNode;  // Forward declaration of GridNode class\ntypedef std::shared_ptr<GridNode> GridNodePtr;  // Assuming GridNodePtr is a typedef for shared_ptr of GridNode\n\nclass AStar {\npublic:\n    std::vector<GridNodePtr> retrievePath(GridNodePtr current);\n};\n\n// Assuming GridNode has a member named 'cameFrom' which is also a GridNodePtr\nclass GridNode {\npublic:\n    GridNodePtr cameFrom;\n\n    // Add any other necessary members and methods here\n};\n\nstd::vector<GridNodePtr> AStar::retrievePath(GridNodePtr current) {\n    std::vector<GridNodePtr> path;\n\n    while (current != nullptr) {  // Assuming that the start node's cameFrom is nullptr\n        path.push_back(current);\n        current = current->cameFrom;  // Move to the previous node in the path\n    }\n\n    std::reverse(path.begin(), path.end());  // Reverse the path to start from the starting node\n    return path;\n}", "CodeBleu_score": 52.658370701814604}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx) {\n    // Convert 3D coordinates to grid indices\n    start_idx = this->CoordinateToIndex(start_pt);\n    end_idx = this->CoordinateToIndex(end_pt);\n\n    // Check if the initial indices are inside obstacles\n    if (IsPointInObstacle(start_idx)) {\n        if (!AdjustPoint(start_idx, end_idx)) {\n            return false; // Failed to adjust start index out of obstacle\n        }\n    }\n    \n    if (IsPointInObstacle(end_idx)) {\n        if (!AdjustPoint(end_idx, start_idx)) {\n            return false; // Failed to adjust end index out of obstacle\n        }\n    }\n    \n    return true;\n}\n\n// Helper function to check if the index is inside an obstacle\nbool AStar::IsPointInObstacle(const Vector3i &index) const {\n    // Assume the existence of a map grid where true means the cell is an obstacle\n    return grid[index.x][index.y][index.z];\n}\n\n// Helper function to adjust the index in case it is inside an obstacle\nbool AStar::AdjustPoint(Vector3i &idx, const Vector3i &other_idx) {\n    // Implement some logic to move idx away from other_idx until it is not in an obstacle\n    const int MAX_ATTEMPTS = 10;\n    Vector3i direction = other_idx - idx;\n    Normalize(direction); // Assume a helper function that normalizes the direction vector\n    \n    for (int attempts = 0; attempts < MAX_ATTEMPTS && IsPointInObstacle(idx); ++attempts) {\n        idx -= direction; // Move idx in the opposite direction to other_idx\n        if (!IsValidIndex(idx)) {\n            return false; // Out of grid bounds\n        }\n    }\n    \n    return !IsPointInObstacle(idx);\n}\n\n// Normalizes the direction vector\nvoid AStar::Normalize(Vector3i &vector) {\n    // Normalization to ensure every component is either -1, 0, or 1\n    vector.x = (vector.x != 0) ? (vector.x / abs(vector.x)) : 0;\n    vector.y = (vector.y != 0) ? (vector.y / abs(vector.y)) : 0;\n    vector.z = (vector.z != 0) ? (vector.z / abs(vector.z)) : 0;\n}\n\n// Helper function to convert 3D coordinates to grid indices\nVector3i AStar::CoordinateToIndex(const Vector3d &coordinate) {\n    // Example conversion, assumes grid starts at origin and has uniform cell sizes\n    return Vector3i(static_cast<int>(floor(coordinate.x / cell_size)),\n                    static_cast<int>(floor(coordinate.y / cell_size)),\n                    static_cast<int>(floor(coordinate.z / cell_size)));\n}\n\n// Checks if the index is within grid bounds\nbool AStar::IsValidIndex(const Vector3i &index) const {\n    return index.x >= 0 && index.x < grid.size() && \n           index.y >= 0 && index.y < grid[0].size() && \n           index.z >= 0 && index.z < grid[0][0].size();\n}", "CodeBleu_score": 38.98934648502801}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx) {\n    // Convert starting and ending points from 3D coordinates to grid indices\n    start_idx = this->CoordinateToIndex(start_pt);\n    end_idx = this->CoordinateToIndex(end_pt);\n    \n    // Check if conversion was successful\n    if (start_idx == Vector3i(-1, -1, -1) || end_idx == Vector3i(-1, -1, -1)) {\n        return false; // Conversion failed\n    }\n\n    // Adjust starting point if it is inside an obstacle\n    if (this->IsInsideObstacle(start_idx)) {\n        if (!AdjustPointPosition(start_idx, end_idx)) {\n            return false; // Adjustment failed\n        }\n    }\n\n    // Adjust ending point if it is inside an obstacle\n    if (this->IsInsideObstacle(end_idx)) {\n        if (!AdjustPointPosition(end_idx, start_idx)) {\n            return false; // Adjustment failed\n        }\n    }\n\n    return true; // Both points are properly adjusted\n}\n\nbool AStar::AdjustPointPosition(Vector3i &point_idx, const Vector3i &other_idx) {\n    const int max_attempts = 100;\n    int attempts = 0;\n    \n    while (this->IsInsideObstacle(point_idx) && attempts < max_attempts) {\n        // Apply a simple adjustment\n        Vector3i direction = point_idx - other_idx;\n        Normalize(direction); // Ensures direction is not too steep\n        point_idx += direction; // Attempt to move away from the other point\n\n        // Ensure indices remain within valid ranges\n        ClampIndices(point_idx);\n\n        attempts++;\n    }\n\n    return !this->IsInsideObstacle(point_idx);\n}\n\nvoid AStar::Normalize(Vector3i &vec) {\n    int mag = sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);\n    if (mag > 0) {\n        vec.x /= mag;\n        vec.y /= mag;\n        vec.z /= mag;\n    }\n}\n\nvoid AStar::ClampIndices(Vector3i &idx) {\n    idx.x = max(0, min(idx.x, this->grid_size.x - 1));\n    idx.y = max(0, min(idx.y, this->grid_size.y - 1));\n    idx.z = max(0, min(idx.z, this->grid_size.z - 1));\n}\n\nbool AStar::IsInsideObstacle(Vector3i idx) {\n    // Check if the index corresponds to an obstacle in the grid\n    return this->grid[idx.x][idx.y][idx.z] == OBSTACLE;\n}", "CodeBleu_score": 39.25136385800151}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx) {\n    // Convert start and end points to grid indices\n    Vector3i tempStartIdx = convertToIndex(start_pt);\n    Vector3i tempEndIdx = convertToIndex(end_pt);\n\n    if (!tempStartIdx.isValid() || !tempEndIdx.isValid()) {\n        // Conversion failed; Return false\n        return false;\n    }\n    \n    // Adjust start index if it is inside an obstacle\n    while (isInsideObstacle(tempStartIdx)) {\n        if (moveIndexAwayFromObstacle(tempStartIdx, end_pt) == false) {\n            return false; // Unable to adjust the starting index without hitting boundaries\n        }\n    }\n\n    // Adjust end index if it is inside an obstacle\n    while (isInsideObstacle(tempEndIdx)) {\n        if (moveIndexAwayFromObstacle(tempEndIdx, start_pt) == false) {\n            return false; // Unable to adjust the ending index without hitting boundaries\n        }\n    }\n\n    // Set the indices if all checks and adjustments are successful\n    start_idx = tempStartIdx;\n    end_idx = tempEndIdx;\n\n    return true;\n}\n\nVector3i AStar::convertToIndex(Vector3d point) {\n    // Placeholder conversion: Replace with actual logic\n    int x = static_cast<int>(round(point.x / gridResolution));\n    int y = static_cast<int>(round(point.y / gridResolution));\n    int z = static_cast<int>(round(point.z / gridResolution));\n    return Vector3i(x, y, z);\n}\n\nbool AStar::isInsideObstacle(Vector3i index) {\n    // Check if the converted index lies inside an obstacle\n    // Placeholder condition\n    return obstacleMap.contains(index);\n}\n\nbool AStar::moveIndexAwayFromObstacle(Vector3i &index, Vector3d otherPoint) {\n    // Try to move the index away from the obstacle\n    // Placeholder logic: Needs real implementation based on environmental analysis\n    Vector3i direction = convertToIndex(otherPoint) - index;\n    direction.normalize(); // Normalize to ensure single step movement\n    Vector3i possibleNewIndex = index - direction; // Move opposite the direction of the other point\n\n    if (isInsideObstacle(possibleNewIndex)) {\n        return false; // If still inside an obstacle, return false\n    }\n\n    index = possibleNewIndex;\n    return true;\n}", "CodeBleu_score": 35.97733145366183}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "#include <Eigen/Dense>\n\nclass GridMap {\nprivate:\n    int sizeX, sizeY, sizeZ; // Dimensions of the grid\n    std::vector<std::vector<std::vector<int>>> occupancy_buffer_inflate_; // 3D buffer grid\n    \npublic:\n\n    GridMap(int sizeX, int sizeY, int sizeZ): sizeX(sizeX), sizeY(sizeY), sizeZ(sizeZ) {\n        occupancy_buffer_inflate_.resize(sizeX);\n        for (int i = 0; i < sizeX; i++) {\n            occupancy_buffer_inflate_[i].resize(sizeY);\n            for (int j = 0; j < sizeY; j++) {\n                occupancy_buffer_inflate_[i][j].resize(sizeZ, 0);\n            }\n        }\n    }\n\n    // Converts position in 3D space to grid indices\n    Eigen::Vector3i posToIndex(Eigen::Vector3d pos) {\n        // This conversion depends on the grid resolution and origin\n        // Placeholder conversion assuming unit resolution and zero-origin\n        return Eigen::Vector3i(static_cast<int>(round(pos.x())),\n                               static_cast<int>(round(pos.y())),\n                               static_cast<int>(round(pos.z())));\n    }\n\n    void resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos) {\n        // Convert positions to grid indices\n        Eigen::Vector3i min_id = posToIndex(min_pos);\n        Eigen::Vector3i max_id = posToIndex(max_pos);\n        \n        // Iterate through the specified region and reset the values\n        for (int x = min_id.x(); x <= max_id.x(); ++x) {\n            for (int y = min_id.y(); y <= max_id.y(); ++y) {\n                for (int z = min_id.z(); z <= max_id.z(); ++z) {\n                    if (x >= 0 && x < sizeX && y >= 0 && y < sizeY && z >= 0 && z < sizeZ) {\n                        occupancy_buffer_inflate_[x][y][z] = 0; // Reset occupancy to zero\n                    }\n                }\n            }\n        }\n    }\n};", "CodeBleu_score": 42.34267616026361}, {"code": "#include <Eigen/Dense>\n\nclass GridMap {\npublic:\n    // Example grid buffer, replace with actual data member.\n    std::vector<std::vector<std::vector<double>>> occupancy_buffer_inflate_;\n\n    // Assuming these are plausible grid size dimensions.\n    const int grid_size_x_;\n    const int grid_size_y_;\n    const int grid_size_z_;\n\n    GridMap(int x, int y, int z) \n        : grid_size_x_(x), grid_size_y_(y), grid_size_z_(z), \n          occupancy_buffer_inflate_(x, std::vector<std::vector<double>>(y, std::vector<double>(z))) {}\n\n    // Convert world position to grid index (assuming such a function is necessary and exists)\n    Eigen::Vector3i worldToGridIndex(const Eigen::Vector3d& pos) {\n        // This is an example conversion, replace with actual logic\n        return Eigen::Vector3i(\n            static_cast<int>(floor(pos(0))),\n            static_cast<int>(floor(pos(1))),\n            static_cast<int>(floor(pos(2)))\n        );\n    }\n\n    // Reset the buffer in a specific 3D grid region\n    void resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos) {\n        // Convert from world positions to grid indices\n        Eigen::Vector3i min_id = worldToGridIndex(min_pos);\n        Eigen::Vector3i max_id = worldToGridIndex(max_pos);\n\n        // Iterate through the specified region and reset values\n        for (int x = min_id.x(); x <= max_id.x() && x < grid_size_x_; x++) {\n            for (int y = min_id.y(); y <= max_id.y() && y < grid_size_y_; y++) {\n                for (int z = min_id.z(); z <= max_id.z() && z < grid_size_z_; z++) {\n                    occupancy_buffer_inflate_[x][y][z] = 0;\n                }\n            }\n        }\n    }\n};", "CodeBleu_score": 48.07667148968509}, {"code": "#include <Eigen/Dense>\n#include <iostream>\n\nclass GridMap {\nprivate:\n    const int grid_size_x = 100;\n    const int grid_size_y = 100;\n    const int grid_size_z = 100;\n    double resolution = 0.1; // Map resolution: space between points on the grid, in meters\n    unsigned char ***occupancy_buffer_inflate_;\n\npublic:\n    GridMap() {\n        occupancy_buffer_inflate_ = new unsigned char**[grid_size_x];\n        for (int i = 0; i < grid_size_x; ++i) {\n            occupancy_buffer_inflate_[i] = new unsigned char*[grid_size_y];\n            for (int j = 0; j < grid_size_y; ++j) {\n                occupancy_buffer_inflate_[i][j] = new unsigned char[grid_size_z]();\n            }\n        }\n    }\n\n    ~GridMap() {\n        for (int i = 0; i < grid_size_x; ++i) {\n            for (int j = 0; j < grid_size_y; ++j)\n                delete[] occupancy_buffer_inflate_[i][j];\n            delete[] occupancy_buffer_inflate_[i];\n        }\n        delete[] occupancy_buffer_inflate_;\n    }\n\n    // Convert world coordinates to grid coordinates\n    Eigen::Vector3i worldToGrid(const Eigen::Vector3d &world) const {\n        return {(int)(world[0] / resolution),\n                (int)(world[1] / resolution),\n                (int)(world[2] / resolution)};\n    }\n\n    // Function to reset buffers within a specified region\n    void resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos) {\n        // Convert minimum and maximum positions from world to grid coordinates\n        Eigen::Vector3i min_id = worldToGrid(min_pos);\n        Eigen::Vector3i max_id = worldToGrid(max_pos);\n\n        // Clamp the values to be within the grid dimensions\n        min_id = min_id.cwiseMax(Eigen::Vector3i(0, 0, 0)).cwiseMin(Eigen::Vector3i(grid_size_x - 1, grid_size_y - 1, grid_size_z - 1));\n        max_id = max_id.cwiseMax(Eigen::Vector3i(0, 0, 0)).cwiseMin(Eigen::Vector3i(grid_size_x - 1, grid_size_y - 1, grid_size_z - 1));\n\n        for (int x = min_id[0]; x <= max_id[0]; ++x) {\n            for (int y = min_id[1]; y <= max_id[1]; ++y) {\n                for (int z = min_id[2]; z <= max_id[2]; ++z) {\n                    occupancy_buffer_inflate_[x][y][z] = 0;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    GridMap map;\n    map.resetBuffer(Eigen::Vector3d(1.1, 1.2, 1.3), Eigen::Vector3d(3.4, 5.6, 2.2));\n    std::cout << \"Buffer reset completed.\" << std::endl;\n    return 0;\n}", "CodeBleu_score": 39.842108233852095}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\n{\n    // Calculate difference vector from the camera point to the point\n    Eigen::Vector3d dir = pt - camera_pt;\n\n    // Determine initial coefficients (scaling factors) for adjusting the position\n    double coefficient_x_min, coefficient_x_max, coefficient_y_min, coefficient_y_max, coefficient_z_min, coefficient_z_max;\n\n    // Check boundaries along X-axis\n    if (dir.x() != 0) {\n        coefficient_x_min = (min_x_ - camera_pt.x()) / dir.x();\n        coefficient_x_max = (max_x_ - camera_pt.x()) / dir.x();\n    } else {\n        coefficient_x_min = coefficient_x_max = std::numeric_limits<double>::infinity();\n    }\n\n    // Check boundaries along Y-axis\n    if (dir.y() != 0) {\n        coefficient_y_min = (min_y_ - camera_pt.y()) / dir.y();\n        coefficient_y_max = (max_y_ - camera_pt.y()) / dir.y();\n    } else {\n        coefficient_y_min = coefficient_y_max = std::numeric_limits<double>::infinity();\n    }\n\n    // Check boundaries along Z-axis\n    if (dir.z() != 0) {\n        coefficient_z_min = (min_z_ - camera_pt.z()) / dir.z();\n        coefficient_z_max = (max_z_ - camera_pt.z()) / dir.z();\n    } else {\n        coefficient_z_min = coefficient_z_max = std::numeric_limits<double>::infinity();\n    }\n\n    // Determine the minimum positive coefficients\n    double min_positive_coefficient = std::numeric_limits<double>::infinity();\n\n    // Evaluate and find the minimum valid positive coefficient for each axis\n    std::vector<double> coeffs = { coefficient_x_min, coefficient_x_max, coefficient_y_min, coefficient_y_max, coefficient_z_min, coefficient_z_max };\n\n    for (double coeff : coeffs) {\n        if (coeff > 0 && coeff < min_positive_coefficient) {\n            min_positive_coefficient = coeff;\n        }\n    }\n\n    // Compute the closest boundary point using the minimum coefficient found\n    Eigen::Vector3d closest_point = camera_pt + min_positive_coefficient * dir;\n\n    return closest_point;\n}", "CodeBleu_score": 39.74182918833726}, {"code": "#include <Eigen/Core>\n\nclass GridMap {\npublic:\n    Eigen::Vector3d min_bounds; // Minimum bounds of the grid map\n    Eigen::Vector3d max_bounds; // Maximum bounds of the grid map\n\n    Eigen::Vector3d closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt) {\n\n        // Create a difference vector from the camera point to the given point\n        Eigen::Vector3d dir = pt - camera_pt;\n\n        // Handle the case where dir vector might be exactly zero\n        if (dir.isZero()) {\n            dir = Eigen::Vector3d(1, 0, 0); // Default direction if input points are the same\n        }\n\n        // Variables to store possible scaling factors along each axis to stay within map bounds\n        double scaleX = std::numeric_limits<double>::max();\n        double scaleY = std::numeric_limits<double>::max();\n        double scaleZ = std::numeric_limits<double>::max();\n\n        // Calculate positive scaling factors for each axis that would place the point back within the bounds\n        if (dir.x() != 0) {\n            if (dir.x() > 0) { // Moving towards max bound\n                scaleX = (max_bounds.x() - camera_pt.x()) / dir.x();\n            } else { // dir.x() < 0, Moving towards min bound\n                scaleX = (min_bounds.x() - camera_pt.x()) / dir.x();\n            }\n        }\n\n        if (dir.y() != 0) {\n            if (dir.y() > 0) {\n                scaleY = (max_bounds.y() - camera_pt.y()) / dir.y();\n            } else {\n                scaleY = (min_bounds.y() - camera_pt.y()) / dir.y();\n            }\n        }\n\n        if (dir.z() != 0) {\n            if (dir.z() > 0) {\n                scaleZ = (max_bounds.z() - camera_pt.z()) / dir.z();\n            } else {\n                scaleZ = (min_bounds.z() - camera_pt.z()) / dir.z();\n            }\n        }\n\n        // The smallest positive scaling factor to keep the point within map boundaries\n        double minScale = std::min({scaleX, scaleY, scaleZ});\n        \n        // If minScale is infinity, the line never intersects the bounds (edge case)\n        if (std::isinf(minScale)) {\n            minScale = 1.0; // fallback to the original point if no interaction with bounds\n        }\n\n        // Calculate the closest valid point on the map boundaries\n        Eigen::Vector3d closestPoint = camera_pt + minScale * dir;\n\n        // Ensure the scaled point does not exceed map boundaries due to floating point precision\n        for (int i = 0; i < 3; ++i) {\n            closestPoint[i] = std::max(min_bounds[i], closestPoint[i]);\n            closestPoint[i] = std::min(max_bounds[i], closestPoint[i]);\n        }\n\n        return closestPoint;\n    }\n};", "CodeBleu_score": 44.31527324928184}, {"code": "#include <Eigen/Dense>\n#include <algorithm>  // std::max, std::min\n\nclass GridMap {\nprivate:\n    Eigen::Vector3d min_boundary_; // Minimum boundary of the grid map\n    Eigen::Vector3d max_boundary_; // Maximum boundary of the grid map\n\npublic:\n    // Constructor setting the boundaries for the map\n    GridMap(const Eigen::Vector3d& min_boundary, const Eigen::Vector3d& max_boundary) \n        : min_boundary_(min_boundary), max_boundary_(max_boundary) {}\n\n    // Function to compute the closest point in the map boundaries\n    Eigen::Vector3d closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt) {\n        // Validate map boundaries\n        if ((max_boundary_.array() < min_boundary_.array()).any()) {\n            throw std::invalid_argument(\"Maximum boundary must be greater than or equal to minimum boundary.\");\n        }\n\n        Eigen::Vector3d direction = pt - camera_pt; // Compute difference vector between target point and camera\n        Eigen::Vector3d t_min, t_max; // Variables to store the minimum and maximum translation coefficients\n\n        // If the direction vector component is zero, handle potential division by zero\n        // Else calculate intersection points of rays with the boundaries\n        for (int i = 0; i < 3; ++i) {\n            if (direction[i] == 0.0) {\n                t_min[i] = std::numeric_limits<double>::lowest(); // Set t_min to very low if direction is 0\n                t_max[i] = std::numeric_limits<double>::max();    // Set t_max to very high if direction is 0\n            } else {\n                t_min[i] = (min_boundary_[i] - camera_pt[i]) / direction[i];\n                t_max[i] = (max_boundary_[i] - camera_pt[i]) / direction[i];\n\n                if (t_min[i] > t_max[i]) {\n                    std::swap(t_min[i], t_max[i]); // Swap if t_min is greater than t_max\n                }\n            }\n        }\n\n        // Finding the minimum positive t that keeps the point within the map boundaries\n        double t_enter = std::max({ t_min[0], t_min[1], t_min[2], 0.0 }); // Largest t_min, but not less than 0\n        double t_exit = std::min({ t_max[0], t_max[1], t_max[2] });\n\n        if (t_enter > t_exit) { // If no valid t is found, throw an error\n            throw std::runtime_error(\"No valid intersection: point outside of boundaries\");\n        }\n\n        // Calculate the point using the minimum positive t\n        Eigen::Vector3d closest_point = camera_pt + t_enter * direction;\n        return closest_point;\n    }\n};", "CodeBleu_score": 44.31441140696861}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent& /*event*/)\n{\n    // Update the last occupancy update time\n    last_occupancy_update_time_ = ros::Time::now();\n\n    // Check if an update is needed based on sensor data freshness\n    if (!sensorDataIsFresh()) {\n        ROS_WARN(\"Sensor data is not fresh\");\n        return;\n    }\n\n    // Project depth image into points\n    if (depthImageAvailable()) {\n        std::vector<Point> projected_points = projectDepthToPoints();\n        \n        // Process points with raycasting\n        for (const auto& point : projected_points) {\n            updateOccupancyGridWithRaycasting(sensor_position_, point);\n        }\n    } else {\n        ROS_WARN(\"Depth image is not available\");\n    }\n\n    // Check if local map has been updated and needs to be cleared/inflated\n    if (localMapUpdated()) {\n        clearLocalMap();\n        inflateLocalMap();\n        ROS_INFO(\"Local map updated and modified\");\n    }\n\n    // Handle timeout errors for odometry\n    if (odometryTimeout()) {\n        ROS_ERROR(\"Odometry data timeout\");\n        setOdometryTimeoutFlag(true);\n    }\n\n    // Handle timeout errors for depth data\n    if (depthDataTimeout()) {\n        ROS_ERROR(\"Depth data timeout\");\n        setDepthDataTimeoutFlag(true);\n    }\n}", "CodeBleu_score": 31.978706182305817}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/) {\n    // Update the last occupancy update time\n    last_occupancy_update_time_ = ros::Time::now();\n\n    // Check if update is needed\n    if (needToUpdate()) {\n        try {\n            // Project the depth image into points\n            std::vector<Point> points = projectDepthImage();\n\n            // Process points with raycasting to update occupancy grid\n            for (const auto &point : points) {\n                raycastUpdate(point);\n            }\n\n            // If local map is updated, clear and inflate the map\n            if (local_map_updated_) {\n                clearLocalMap();\n                inflateLocalMap();\n            }\n        } catch (const std::exception &ex) {\n            ROS_ERROR(\"Exception caught during occupancy update: %s\", ex.what());\n            return;\n        }\n    } else {\n        ROS_INFO(\"No update needed at this time.\");\n    }\n\n    // Handle timeout errors for odometry or depth data\n    if (!odomDataReceived()) {\n        ROS_WARN(\"Odometry data timeout\");\n        odometry_timeout_flag_ = true;\n    } else {\n        odometry_timeout_flag_ = false;\n    }\n\n    if (!depthDataReceived()) {\n        ROS_WARN(\"Depth data timeout\");\n        depth_timeout_flag_ = true;\n    } else {\n        depth_timeout_flag_ = false;\n    }\n}", "CodeBleu_score": 36.4794461018017}, {"code": "#include <ros/ros.h>\n#include <sensor_msgs/Image.h>\n\nclass GridMap {\npublic:\n    ros::Time last_update_time;\n    bool depth_timeout_flag;\n    bool odom_timeout_flag;\n\n    void updateOccupancyCallback(const ros::TimerEvent &event);\n    void raycastPoints();\n    void processDepthImage();\n    bool checkForDepthDataTimeout();\n    bool checkForOdometryDataTimeout();\n    void clearAndInflateMap();\n};\n\nvoid GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/) {\n    // Update the last occupancy update time\n    last_update_time = ros::Time::now();\n\n    // We assume `needUpdate` is a function or a result of a set of conditions to determine if an update is needed\n    bool update_needed = true; // Placeholder for actual update condition\n    if (update_needed) {\n        // Process the depth image into points\n        processDepthImage();\n        \n        // Raycast points to update occupancy\n        raycastPoints();\n\n        // Check if local map has been updated and then clear and inflate the map\n        bool local_map_updated = true; // Placeholder for map update condition\n        if (local_map_updated) {\n            clearAndInflateMap();\n        }\n    }\n\n    // Check for timeout errors for odometry and depth data\n    if (checkForOdometryDataTimeout()) {\n        odom_timeout_flag = true;\n        ROS_WARN(\"Odometry data timeout occurred.\");\n    } else {\n        odom_timeout_flag = false;\n    }\n\n    if (checkForDepthDataTimeout()) {\n        depth_timeout_flag = true;\n        ROS_WARN(\"Depth data timeout occurred.\");\n    } else {\n        depth_timeout_flag = false;\n    }\n}\n\nvoid GridMap::processDepthImage() {\n    // Actual implementation to handle the depth image and convert to point cloud or points\n}\n\nvoid GridMap::raycastPoints() {\n    // Actual implementation for raycasting into the map\n}\n\nbool GridMap::checkForDepthDataTimeout() {\n    // Implement timeout checking logic specific to depth data\n    return false;  // Placeholder value\n}\n\nbool GridMap::checkForOdometryDataTimeout() {\n    // Implement timeout checking logic specific to odometry data\n    return false;  // Placeholder value\n}\n\nvoid GridMap::clearAndInflateMap() {\n    // Actual implementation to clear obstacles and inflate map according to robot dimensions and safety margins\n}", "CodeBleu_score": 29.348601305457255}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "#include <vector>\n#include <string>\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace std;\nusing namespace cv;\n\nfloat computeFMeasure(const vector<RotatedRect>& gtEllipses, const vector<RotatedRect>& detectedEllipses, bool radians);\n\nfloat _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians) {\n    if (image_fns.size() != gt_fns.size() || gt_fns.size() != dt_fns.size()) {\n        cerr << \"Error: File vectors must be of the same size.\" << endl;\n        return 0.0;\n    }\n    \n    int numImages = image_fns.size();\n    float totalFMeasure = 0.0;\n    \n    for (int i = 0; i < numImages; ++i) {\n        // Load image (assuming grayscale)\n        Mat image = imread(image_fns[i], IMREAD_GRAYSCALE);\n        if (image.empty()) {\n            cerr << \"Failed to load image: \" << image_fns[i] << endl;\n            continue;\n        }\n        \n        // Load ground truth ellipses\n        vector<RotatedRect> gtEllipses;\n        // Assuming a function available to load ellipses from file\n        bool loadedGT = loadEllipsesFromFile(gt_fns[i], gtEllipses, gt_angle_radians);\n        if (!loadedGT) {\n            cerr << \"Failed to load ground truth ellipses from \" << gt_fns[i] << endl;\n            continue;\n        }\n        \n        // Load detected ellipses\n        vector<RotatedRect> detectedEllipses;\n        // Assuming a function available to load ellipses from file\n        bool loadedDT = loadEllipsesFromFile(dt_fns[i], detectedEllipses, false);\n        if (!loadedDT) {\n            cerr << \"Failed to load detected ellipses from \" << dt_fns[i] << endl;\n            continue;\n        }\n        \n        // Evaluate F-measure for this image\n        float fMeasure = computeFMeasure(gtEllipses, detectedEllipses, gt_angle_radians);\n        totalFMeasure += fMeasure;\n    }\n\n    return (numImages > 0) ? totalFMeasure / numImages : 0.0;\n}", "CodeBleu_score": 48.39870088193079}, {"code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <opencv2/opencv.hpp>\n\nusing namespace std;\nusing namespace cv;\n\n// Pseudocode to load image\nMat loadImage(const string& filename) {\n    return imread(filename, IMREAD_COLOR);\n}\n\n// Placeholder to load ground truth ellipses (list of ellipses perhaps with parameters: x_center, y_center, major_axis, minor_axis, angle)\nvector<Rect> loadGroundTruth(const string& filename, bool radians) {\n    // Implementation depends on file format\n    vector<Rect> groundTruths;\n    // Populate groundTruths based on the file\n    return groundTruths;\n}\n\n// Placeholder to load detected ellipses\nvector<Rect> loadDetected(const string& filename) {\n    vector<Rect> detections;\n    // Implementation depends on file format\n    return detections;\n}\n\n// Placeholder to calculate F-measure\nfloat calculateFMeasure(const vector<Rect>& groundTruths, const vector<Rect>& detections) {\n    // Some detection performance measure\n    // Assume there is an implementation to calculate F-measure based on provided detections and ground truths\n    return 0.9f; // returning dummy value\n}\n\nfloat _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians) {\n    float total_fmeasure = 0.0f;\n    int total_images = image_fns.size();\n\n    for (int i = 0; i < total_images; ++i) {\n        Mat image = loadImage(image_fns[i]);\n        vector<Rect> groundTruths = loadGroundTruth(gt_fns[i], gt_angle_radians);\n        vector<Rect> detections = loadDetected(dt_fns[i]);\n        \n        float fmeasure = calculateFMeasure(groundTruths, detections);\n        total_fmeasure += fmeasure;\n    }\n\n    float average_fmeasure = (total_images > 0) ? total_fmeasure / total_images : 0.0f;\n    return average_fmeasure;\n}", "CodeBleu_score": 48.762373954995944}, {"code": "#include <vector>\n#include <string>\n#include <opencv2/opencv.hpp>\n\n// Declaration of helper function to calculate F-measure per one image.\n// Not implemented here, assumed to already exist.\nfloat f_measure(const cv::Mat& image, const cv::Mat& gt, const cv::Mat& dt, bool gt_angle_radians);\n\nfloat _ellipse_evaluate(std::vector<std::string>& image_fns, std::vector<std::string>& gt_fns, std::vector<std::string>& dt_fns, bool gt_angle_radians) {\n    if (image_fns.size() != gt_fns.size() || gt_fns.size() != dt_fns.size()) {\n        throw std::runtime_error(\"Input vectors must have the same size.\");\n    }\n\n    float totalFMeasure = 0.0;\n    int numImages = image_fns.size();\n\n    for (int i = 0; i < numImages; i++) {\n        // Load the image\n        cv::Mat image = cv::imread(image_fns[i], cv::IMREAD_COLOR);\n        if (image.empty()) {\n            throw std::runtime_error(\"Could not open or find the image: \" + image_fns[i]);\n        }\n        \n        // Load ground truth data\n        cv::Mat groundTruth = cv::imread(gt_fns[i], cv::IMREAD_COLOR); // Assume ground truth data is in an image format\n        if (groundTruth.empty()) {\n            throw std::runtime_error(\"Could not open or find the ground truth image: \" + gt_fns[i]);\n        }\n        \n        // Load detected ellipses data\n        cv::Mat detected = cv::imread(dt_fns[i], cv::IMREAD_COLOR);  // Assume detected data is in an image format\n        if (detected.empty()) {\n            throw std::runtime_error(\"Could not open or find the detected data image: \" + dt_fns[i]);\n        }\n\n        // Calculate F-measure for current image\n        float fMeasure = f_measure(image, groundTruth, detected, gt_angle_radians);\n        totalFMeasure += fMeasure;\n    }\n\n    // Calculate average F-measure\n    float averageFMeasure = totalFMeasure / numImages;\n\n    return averageFMeasure;\n}", "CodeBleu_score": 39.98179897186171}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nfloat _ellipse_normal_angle(float x, float y, float *foci) {\n    if (!foci) {\n        fprintf(stderr, \"Foci pointer is NULL.\\n\");\n        return NAN;  // Or handle the error according to the application's needs\n    }\n\n    // Assuming foci inputs are [focus1_x, focus1_y, focus2_x, focus2_y]\n    float focus1_x = foci[0];\n    float focus1_y = foci[1];\n    float focus2_x = foci[2];\n    float focus2_y = foci[3];\n\n    // Calculate the angles from the point (x, y) to each focus\n    float angle_to_focus1 = atan2(focus1_y - y, focus1_x - x);\n    float angle_to_focus2 = atan2(focus2_y - y, focus2_x - x);\n\n    // The normal angle of the ellipse at (x, y) is halfway between these angles\n    float normal_angle = (angle_to_focus1 + angle_to_focus2) / 2;\n\n    // Adjusting to lie within the range [-\u03c0, \u03c0]\n    if (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    } else if (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    }\n\n    return normal_angle;\n}\n\nint main() {\n    float foci[] = {1.0, 0.0, -1.0, 0.0}; // Example foci\n    float x = 0.5, y = 0.0;\n    float angle = _ellipse_normal_angle(x, y, foci);\n\n    if (!isnan(angle)) {\n        printf(\"Normal Angle at (%.2f, %.2f): %.4f radians\\n\", x, y, angle);\n    }\n\n    return 0;\n}", "CodeBleu_score": 33.90495105152004}, {"code": "#include <math.h>\n#include <stddef.h>\n\nfloat _ellipse_normal_angle(float x, float y, float *foci) {\n    if (!foci) {\n        // Handle error if foci pointer is NULL\n        return 0.0;  // or some default value indicating error\n    }\n\n    // Extract foci points\n    float x1 = foci[0];\n    float y1 = foci[1];\n    float x2 = foci[2];\n    float y2 = foci[3];\n    \n    // Calculate angle to each focus from (x, y)\n    float angle1 = atan2(y - y1, x - x1);\n    float angle2 = atan2(y - y2, x - x2);\n    \n    // Calculate the normal angle, which is the average of the two angles (angle bisector)\n    float normal_angle = (angle1 + angle2) / 2.0;\n    \n    // Ensure the angle is within the range [-\u03c0, \u03c0]\n    // Normalize angle to be within [-\u03c0, \u03c0]\n    while (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    }\n    while (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    }\n\n    return normal_angle;\n}", "CodeBleu_score": 36.95072436362503}, {"code": "#include <math.h>\n\nfloat _ellipse_normal_angle(float x, float y, float *foci) {\n    // Check if the 'foci' pointer is valid\n    if (foci == NULL) {\n        return NAN;  // Not a Number (error condition)\n    }\n\n    // Extract coordinates of the foci\n    float fx1 = foci[0];\n    float fy1 = foci[1];\n    float fx2 = foci[2];\n    float fy2 = foci[3];\n\n    // Calculate the angles from the point (x, y) to each of the foci\n    float angle1 = atan2(fy1 - y, fx1 - x);\n    float angle2 = atan2(fy2 - y, fx2 - x);\n\n    // Compute the angle of the normal\n    float normal_angle = (angle1 + angle2) / 2 + M_PI / 2; // Adding \u03c0 / 2 to convert tangent to normal\n\n    // Normalize the angle to be within [-\u03c0, \u03c0]\n    if (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    }\n    else if (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    }\n\n    return normal_angle;\n}", "CodeBleu_score": 38.43246231426409}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "#include <algorithm>\n\nstruct Point {\n    double x, y;\n};\n\n// Alias VP as vector of Points\nusing VP = std::vector<Point>;\n\nbool concave_check(const VP& vp1, int start, int end) {\n    if (start < 0 || end >= vp1.size() || start > end) {\n        return false; // Return false in cases of invalid index\n    }\n    \n    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n\n    for (int i = start + 1; i <= end; ++i) {\n        min_x = std::min(min_x, vp1[i].x);\n        max_x = std::max(max_x, vp1[i].x);\n        min_y = std::min(min_y, vp1[i].y);\n        max_y = std::max(max_y, vp1[i].y);\n    }\n\n    double integral_above = 0.0;\n    double integral_below = 0.0;\n\n    for (int i = start; i <= end; ++i) {\n        int next_i = i == end ? start : i + 1;\n        Point current = vp1[i];\n        Point next = vp1[next_i];\n\n        // Calculate the area above and below using the trapezoidal rule\n        if (current.y <= next.y) {\n            // Traverse upward or flat\n            integral_below += (next.y - current.y) * (next.x + current.x) / 2;\n            integral_above += (max_y - next.y) * (next.x - current.x);\n        } else {\n            // Traverse downward\n            integral_below += (current.y - next.y) * (next.x + current.x) / 2;\n            integral_above += (max_y - current.y) * (current.x - next.x);\n        }\n    }\n\n    // If integral above is less than integral below, it is convex\n    return integral_above >= integral_below;\n}", "CodeBleu_score": 40.08529549697295}, {"code": "#include <vector>\n\ntypedef std::pair<int, int> Point;\ntypedef std::vector<Point> VP;\n\nbool inline concave_check(VP& vp1, int start, int end) {\n    // Calculate the signed area of the polygon section\n    double area = 0.0;\n    for (int i = start; i < end; ++i) {\n        Point p1 = vp1[i];\n        Point p2 = vp1[(i + 1) % vp1.size()]; // wrap around at the last index\n        area += (p1.first * p2.second) - (p2.first * p1.second);\n    }\n    // Close the polygon section\n    Point p_start = vp1[start];\n    Point p_end = vp1[end % vp1.size()];\n    area += (p_end.first * p_start.second) - (p_start.first * p_end.second);\n\n    area *= 0.5; // Half the computed value to get the actual area\n\n    // Determine concavity: Negative area suggests right-hand (clockwise) turn\n    return area < 0;\n}", "CodeBleu_score": 35.218799340886996}, {"code": "#include <vector>\n#include <cmath>\n\nstruct Point {\n    double x;\n    double y;\n};\n\ntypedef std::vector<Point> VP;\n\nbool inline concave_check(VP& vp1, int start, int end) {\n    // Variable to store the total area signed\n    double area = 0.0;\n\n    // Calculate the signed area of the polygon between indices 'start' and 'end'\n    for (int i = start; i < end; i++) {\n        int j = (i + 1) % vp1.size(); // Wrap around using modulo to connect end to start if needed\n        area += vp1[i].x * vp1[j].y - vp1[j].x * vp1[i].y;\n    }\n\n    // Close the polygon segment by connecting the last point to the first\n    area += vp1[end].x * vp1[start].y - vp1[start].x * vp1[end].y;\n\n    // The area needs to be divided by 2 to get the correct signed area, but we only need the sign\n    area *= 0.5;\n\n    // In convex sections (integral above less than below), the area will be positive\n    return area < 0; // if area is negative, it's concave\n}", "CodeBleu_score": 30.396534180003115}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "#include \"prometheus_msgs/MultiDetectionInfo.h\"\n\n// Constants\nconst int VISION_THRES = 5; // Threshold to decide detected state change\n\n// Global variables\nint num_regain = 0;\nint num_lost = 0;\nbool is_detected = false;\n\nstruct EllipseDetection {\n    float sight_angle1;\n    float sight_angle2;\n    // Potentially more fields related to the detection\n};\n\nEllipseDetection ellipse_det;\n\n\nvoid ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg) {\n    for (const auto& detection : msg->detection_infos) {\n        if (detection.object_name == \"T\") {\n            num_regain++;\n            num_lost = 0;\n        } else {\n            num_lost++;\n            num_regain = 0;\n        }\n\n        // Check detection thresholds and set the is_detected flag accordingly\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        }\n        if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n    }\n\n    // Swap the sight angles in ellipse_det\n    std::swap(ellipse_det.sight_angle1, ellipse_det.sight_angle2);\n}", "CodeBleu_score": 65.7294513454871}, {"code": "#include <prometheus_msgs/MultiDetectionInfo.h>\n\n// Assume these variables are defined in an appropriate scope as global or class members\nbool is_detected = false;\nint num_regain = 0;\nint num_lost = 0;\n// Define VISION_THRES according to the threshold requirements, e.g., 5\nconst int VISION_THRES = 5;\n\nvoid ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg) {\n    bool target_found = false;\n\n    // Iterate through detections\n    for (const auto& detection : msg->detection_infos) {\n        if (detection.object_name == \"T\") {\n            target_found = true;\n            break;  // If target \"T\" found, no need to check further\n        }\n    }\n\n    // Update variables based on whether the target \"T\" was found or not\n    if (target_found) {\n        num_regain++;\n        num_lost = 0;\n    } else {\n        num_regain = 0;\n        num_lost++;\n    }\n\n    // Update is_detected based on threshold numbers\n    if (num_lost > VISION_THRES) {\n        is_detected = false;\n    }\n    if (num_regain > VISION_THRES) {\n        is_detected = true;\n    }\n\n    // Swap the sight_angle values of ellipse_det, assuming ellipse_det is defined elsewhere\n    // Example swap operation: std::swap(ellipse_det.sight_angle1, ellipse_det.sight_angle2);\n}", "CodeBleu_score": 65.34516685362244}, {"code": "#include <prometheus_msgs/MultiDetectionInfo.h>\n\n// Assuming global variables or part of a class\nstruct EllipseDet {\n    int sight_angle1;\n    int sight_angle2;\n};\n\n// Constants\nconst int VISION_THRES = 3;\n\n// Globals or class members\nEllipseDet ellipse_det;\nint num_regain = 0;\nint num_lost = 0;\nbool is_detected = false;\n\nvoid ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg) {\n    // Loop through each DetectionInfo in the MultiDetectionInfo message\n    for (const auto& detection : msg->detections) {\n        if (detection.object_name == \"T\") {\n            // Increment num_regain and reset num_lost\n            num_regain++;\n            num_lost = 0;\n        } else {\n            // Reset num_regain and increment num_lost\n            num_regain = 0;\n            num_lost++;\n        }\n        \n        // Check if num_lost or num_regain exceeds the threshold\n        if (num_lost > VISION_THRES) {\n            is_detected = false;\n        } else if (num_regain > VISION_THRES) {\n            is_detected = true;\n        }\n    }\n\n    // Swap the sight_angle values of ellipse_det\n    std::swap(ellipse_det.sight_angle1, ellipse_det.sight_angle2);\n}", "CodeBleu_score": 65.34195601438489}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance) {\n    // This assumes there is an accessible method in Occupy_map_ptr that checks \n    // for the presence of obstacles or unsafe regions within a given radius around a point.\n    // Let's assume such a method is named checkRadius and returns true if unsafe and false if safe.\n    if (this->Occupy_map_ptr->checkRadius(cur_pos, safe_distance)) {\n        return false;  // Indicates the area is not safe\n    }\n    return true;  // Indicates the area is safe\n}", "CodeBleu_score": 31.83268268410908}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance) {\n    // Check if the occupy map pointer is initialized\n    if (Occupy_map_ptr == nullptr) {\n        // Occupy map pointer is not set up properly, return false for safety\n        return false;\n    }\n    \n    // Use the occupy map pointer to check for safety around the given position\n    return Occupy_map_ptr->is_safe(cur_pos, safe_distance);\n}", "CodeBleu_score": 44.754947249294766}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\n    // Check safety by ensuring the given position is beyond the safe distance from any obstacles as per the occupancy map.\n    // The Occupy_map_ptr points to an occupancy grid/map, which should have methods to check proximity of obstacles.\n    \n    if (Occupy_map_ptr == nullptr) {\n        throw std::invalid_argument(\"Occupy map pointer is not initialized.\");\n    }\n\n    // Assuming Occupy_map_ptr has a method called isPositionSafe which takes as arguments the position and the safety distance\n    return Occupy_map_ptr->isPositionSafe(cur_pos, safe_distance);\n}", "CodeBleu_score": 40.561203325009686}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "#include <vector>\n#include <algorithm>\n\nclass Node {\npublic:\n    int x;  // Node's x coordinate\n    int y;  // Node's y coordinate\n    Node* parent;  // Pointer to the parent node in the path\n\n    Node(int x, int y) : x(x), y(y), parent(nullptr) {}\n};\n\nclass Astar {\n    std::vector<Node*> path_nodes_;  // This will store the path from start node to end node\n\npublic:\n    // Assuming NodePtr is defined as a pointer to a Node\n    using NodePtr = Node*;\n\n    void retrievePath(NodePtr end_node) {\n        if (!end_node) return;  // Return immediately if the end_node is nullptr\n\n        NodePtr current = end_node;\n        // Follow the parent pointers to trace the path back to the start node\n        while (current != nullptr) {\n            path_nodes_.push_back(current);  // Store each node in the path\n            current = current->parent;  // Move up to the parent of the current node\n        }\n\n        // Reverse the order of nodes stored in path_nodes_ since we collected nodes from end to start\n        std::reverse(path_nodes_.begin(), path_nodes_.end());\n    }\n};", "CodeBleu_score": 43.15574269849461}, {"code": "void Astar::retrievePath(NodePtr end_node) {\n    // Clears the path_nodes_ vector that will hold the nodes of the path\n    path_nodes_.clear();\n    \n    // Start from the end node and work backwards to the start node\n    NodePtr current = end_node;\n    while (current != nullptr) {\n        // Add the current node to the path list\n        path_nodes_.push_back(current);\n        \n        // Move to the parent node\n        current = current->parent;\n    }\n    \n    // Reverse path_nodes_ since we traced the path from end to start, but need it from start to end\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}", "CodeBleu_score": 56.146661728725924}, {"code": "#include <vector>\n#include <algorithm>\n\n// Assuming Node is defined somewhere in your code with a parent pointer.\n// For demonstration, I'll assume that NodePtr is a type alias for Node*.\nstruct Node {\n    Node* parent = nullptr;\n    // other members such as position, cost, etc., may be here as needed\n};\n\nclass Astar {\npublic:\n    // Function to retrieve path from start to end node using A* search's parent linkage\n    void retrievePath(Node* end_node);\n\nprivate:\n    std::vector<Node*> path_nodes_; // This vector holds the path nodes from start to end.\n};\n\nvoid Astar::retrievePath(Node* end_node) {\n    // Clear existing path\n    path_nodes_.clear();\n\n    // Temporary node pointer starting from the end node\n    Node* current_node = end_node;\n\n    // Trace back from the end node to the start node via parent pointers\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node); // Add the current node to the path\n        current_node = current_node->parent; // Move to the parent\n    }\n\n    // Since we traced the path from end to start, we need to reverse it to start to end\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n\n// You might also want to include other relevant declarations and logic here", "CodeBleu_score": 47.98307648549677}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "#include <math.h> // for sqrt and pow functions\n\nvoid GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n    // Check the max number of neighbors\n    if (id >= max_nei) {\n        ROS_WARN(\"Received id %d exceeds max neighbors index\", id);\n        return;\n    }\n\n    // Extract the position from the odometry message\n    double posX = odom->pose.pose.position.x;\n    double posY = odom->pose.pose.position.y;\n    double posZ = odom->pose.pose.position.z;\n\n    // Assign position to the state_nei array for the respective UGV identified by id\n    state_nei[id][0] = posX;\n    state_nei[id][1] = posY;\n    state_nei[id][2] = posZ;\n\n    if (sim_mode) {\n        // Calculate the distance from the starting position\n        double distance = sqrt(pow(posX - start_posX, 2) + pow(posY - start_posY, 2));\n\n        // Check if the distance exceeds 5 meters\n        if (distance > 5.0) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    } else {\n        // In real mode, always set get_nei_state flag to true\n        get_nei_state[id] = true;\n    }\n\n    // Optionally, log the updated position\n    ROS_INFO(\"UGV %d position updated: x=%f, y=%f, z=%f, get_nei_state=%s\", \n             id, posX, posY, posZ, get_nei_state[id] ? \"True\" : \"False\");\n}", "CodeBleu_score": 55.04352921464341}, {"code": "#include <math.h> // For pow and sqrt functions\n\nvoid GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n    // Check if the UGV identifier (id) is valid\n    if (id < 0 || id >= state_nei.size()) {\n        ROS_ERROR(\"Invalid UGV ID: %d\", id);\n        return;\n    }\n\n    // Extract position and orientation data from the Odometry message\n    double x = odom->pose.pose.position.x;\n    double y = odom->pose.pose.position.y;\n    double z = odom->pose.pose.position.z;\n\n    // Update neighboring UGV's state information with the current odometry data\n    state_nei[id].x = x;\n    state_nei[id].y = y;\n    state_nei[id].z = z;\n\n    double distance;\n\n    if (simulation_mode) {\n        // Calculate the Euclidean distance from the start position\n        double start_x = start_position[id].x;\n        double start_y = start_position[id].y;\n\n        distance = sqrt(pow(x - start_x, 2) + pow(y - start_y, 2));\n\n        // Set the get_nei_state flag based on the calculated distance\n        if (distance > 5.0) {\n            get_nei_state[id] = false;\n        } else {\n            get_nei_state[id] = true;\n        }\n    } else {\n        // In non-simulation mode, always try to get the neighboring UGV's state\n        get_nei_state[id] = true;\n    }\n\n    ROS_INFO(\"Neighboring UGV %d - Updated position: (%.2f, %.2f, %.2f), Distance from start: %.2f m, State flag: %s\",\n             id, x, y, z, distance, get_nei_state[id] ? \"true\" : \"false\");\n}", "CodeBleu_score": 50.122009160664604}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) {\n    // Assigning position (x,y) and height (z) from odometry message to the state_nei array for the UGV with provided id\n    state_nei[id][0] = odom->pose.pose.position.x;\n    state_nei[id][1] = odom->pose.pose.position.y;\n    state_nei[id][2] = odom->pose.pose.position.z;\n\n    if (simulation_mode) {\n        // Calculate the distance from the starting position (assumed to be stored in start_position[])\n        double dx = state_nei[id][0] - start_position[id][0];\n        double dy = state_nei[id][1] - start_position[id][1];\n        double dz = state_nei[id][2] - start_position[id][2];\n        double distance = sqrt(dx * dx + dy * dy + dz * dz);\n\n        // Check distance and set the get_nei_state flag\n        if (distance > 5.0) {\n            // If the distance is greater than 5 meters, set the flag to false\n            get_nei_state[id] = false;\n        } else {\n            // Otherwise, set the flag to true\n            get_nei_state[id] = true;\n        }\n    } else {\n        // In non-simulation mode, always set the get_nei_state flag to true\n        get_nei_state[id] = true;\n    }\n}", "CodeBleu_score": 58.73286330511288}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg) {\n    // Check if odometry is ready; if not, return immediately.\n    if (!odometry_ready) {\n        return;\n    }\n\n    // Since odometry is ready, set sensor_ready flag to true.\n    sensor_ready = true;\n\n    // Increment the point cloud update counter.\n    update_counter++;\n\n    // Every fifth update, update the Astar map with the new point cloud data.\n    if (update_counter % 5 == 0) {\n        // Update the Astar map with the new point cloud data.\n        updateAstarMap(msg);\n\n        // Reset the update counter after updating the Astar map.\n        update_counter = 0;\n    }\n}\n\n// Placeholder function for updating the Astar map.\n// This should be properly implemented according to the actual map updating logic.\nvoid GlobalPlannerUGV::updateAstarMap(const sensor_msgs::PointCloud2ConstPtr &msg) {\n    // implementation for updating the A* (Astar) navigation map\n}", "CodeBleu_score": 56.3123144864743}, {"code": "#include <sensor_msgs/PointCloud2.h>\n\nclass GlobalPlannerUGV {\nprivate:\n    bool odometryReady = false;\n    bool sensor_ready = false;\n    int update_counter = 0;\n\npublic:\n    // Function to process incoming point cloud data for the UGV\n    void Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg) {\n        // Check if odometry is ready. If not, return immediately\n        if (!odometryReady) {\n            return;\n        }\n\n        // Set sensor_ready flag to true\n        sensor_ready = true;\n\n        // Increment the update counter\n        update_counter++;\n\n        // Check if update_counter has reached 5\n        if (update_counter >= 5) {\n            // Update the Astar map with the new point cloud data\n            updateAstarMap(msg);\n\n            // Reset the update counter\n            update_counter = 0;\n        }\n    }\n\n    // Dummy function to demonstrate updating the Astar map, implement accordingly\n    void updateAstarMap(const sensor_msgs::PointCloud2ConstPtr &msg) {\n        // Assuming there's some implementation to update a map using point cloud data\n        // Actual code would depend on the details of Astar map implementation\n        std::cout << \"Updating AStar map with new point cloud data.\" << std::endl;\n    }\n\n    // Setter function for odometry readiness, for demonstrating purpose\n    void setOdometryReady(bool value) {\n        odometryReady = value;\n    }\n};", "CodeBleu_score": 50.78612429854436}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg) {\n    // Check if odometry is ready\n    if (!odometry_ready) {\n        return; // Return immediately if odometry is not ready\n    }\n    \n    // Set the sensor_ready flag to true once odometry is ready\n    sensor_ready = true;\n\n    // Increment the update counter each time this function is called with odometry being ready\n    update_counter++;\n\n    // Check if update counter reaches 5\n    if (update_counter == 5) {\n        // Update the A* map with the new point cloud data\n        updateAStarMap(msg);\n\n        // Reset the update counter\n        update_counter = 0;\n    }\n}", "CodeBleu_score": 59.68499560391432}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "#include <sensor_msgs/PointCloud2.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl_conversions/pcl_conversions.h>\n\nvoid Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr& global_point) {\n    // Check the get_gpcl flag to see if the global map has already been updated\n    if (!get_gpcl) {\n        // Set the flag to true indicating that the global map is being updated\n        get_gpcl = true;\n\n        // Declare a new PointCloud object from PCL to hold the converted data\n        pcl::PointCloud<pcl::PointXYZ> cloud;\n\n        // Convert the PointCloud2 data to pcl::PointCloud<pcl::PointXYZ>\n        pcl::fromROSMsg(*global_point, cloud);\n\n        // Update the map with this new point cloud data\n        for (const auto& point : cloud.points) {\n            // Perform a hypothetical function to store or update the point to the map\n            update_global_map(point.x, point.y, point.z);\n        }\n\n        // Inflate the point cloud to account for different object sizes, margins, or safety distances\n        inflate_point_cloud(cloud);\n\n        // Optionally, after processing is done, reset get_gpcl flag if it needs to be updated periodically\n        // get_gpcl = false; // Uncomment if updates need to continue after more data comes in\n    }\n    else {\n        std::cout << \"Map update with global_point skipped, as get_gpcl flag is already set.\" << std::endl;\n    }\n}\n\nvoid Occupy_map::update_global_map(float x, float y, float z) {\n    // Implementation depends on how the global map is structured and stored\n    // For example, integrating the point into an occupancy grid or updating a 3D model\n}\n\nvoid Occupy_map::inflate_point_cloud(pcl::PointCloud<pcl::PointXYZ>& cloud) {\n    // Implement point cloud inflation logic\n    // This could involve increasing the size of each point to cover a larger area\n    // due to robot safety bounds, or the size of obstacles\n}", "CodeBleu_score": 46.54366470700495}, {"code": "#include <sensor_msgs/PointCloud2.h>\n#include <pcl_ros/point_cloud.h>\n#include <pcl_ros/transforms.h>\n#include <pcl/point_types.h>\n#include <pcl/conversions.h>\n#include <mutex>\n\nclass Occupy_map {\npublic:\n    void map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr &global_point);\n\nprivate:\n    bool get_gpcl = false;\n    pcl::PointCloud<pcl::PointXYZ> map_cloud;\n    std::mutex mtx;  // Mutex to protect access to get_gpcl and map_cloud\n};\n\nvoid Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr &global_point) {\n    std::lock_guard<std::mutex> lock(mtx); // Ensure thread-safety over get_gpcl and map_cloud\n\n    // Check if the map has already been updated with the global point cloud\n    if (!get_gpcl) {\n        // Set the flag indicating that the global point cloud has been parsed\n        get_gpcl = true;\n\n        // Convert sensor_msgs/PointCloud2 to pcl::PointCloud<pcl::PointXYZ>\n        pcl::PointCloud<pcl::PointXYZ> temp_cloud;\n        pcl::fromROSMsg(*global_point, temp_cloud);\n\n        // Store the converted point cloud into the class member map_cloud\n        map_cloud = temp_cloud;\n\n        // Optionally, inflate the point cloud for better visualization or processing\n        // Inflation could be simulating a thicker layer for each point.\n        for (auto& point : map_cloud.points) {\n            point.z += 0.1; // Example of inflating the z coordinate\n        }\n        \n        // Further processing can be added here, like updating the map visualization\n\n        // Log the update for debugging\n        std::cout << \"Global map updated with point cloud data.\\n\";\n    } else {\n        // Log if the map is already updated\n        std::cout << \"Global map already updated with point cloud data.\\n\";\n    }\n}", "CodeBleu_score": 45.962368380661985}, {"code": "#include <sensor_msgs/PointCloud2.h>\n#include <pcl_ros/transforms.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl_conversions/pcl_conversions.h>\n\nvoid Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr &global_point) {\n    if (!get_gpcl) {\n        get_gpcl = true;  // Set the flag to indicate the global map has been updated\n\n        // Convert sensor_msgs/PointCloud2 to pcl::PointCloud<pcl::PointXYZ>\n        pcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n        pcl::fromROSMsg(*global_point, pcl_cloud);\n\n        // Store the converted point cloud locally\n        global_map = pcl_cloud;\n\n        // Perform inflation, e.g., expand points in global_map to simulate a buffer around obstacles\n        // This is just a sample; details will depend on specific requirements\n        const float inflation_radius = 0.5;  // meters\n        for (auto& point : global_map.points) {\n            // Inflate each point (simple example, would typically be more complex)\n            point.x += inflation_radius;\n            point.y += inflation_radius;\n        }\n\n        // Additional operations could include updating visualizations, notifying other components, etc.\n        // Example: update global map visualization (pseudo code)\n        // updateMapVisualization(global_map);\n    } else {\n        // If the map has already been updated, handle this case (e.g., logging, ignoring, etc.)\n        return; \n    }\n}", "CodeBleu_score": 51.8043604719547}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "#include <pcl_ros/transforms.h>          // To transform the PointCloud using odometry\n#include <sensor_msgs/PointCloud2.h>     // ROS PointCloud2 message\n#include <laser_geometry/laser_geometry.h>// To convert LaserScan to PointCloud\n#include <pcl/point_types.h>             // The PCL point types\n#include <pcl/conversions.h>             // Conversion between different point cloud types\n#include <pcl/common/transforms.h>       // Provides transformation functions\n\nvoid Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr &local_point, const nav_msgs::Odometry &odom) {\n    // Convert LaserScan to PointCloud2\n    sensor_msgs::PointCloud2 laser_cloud;\n    laser_geometry::LaserProjection projector;\n    projector.projectLaser(*local_point, laser_cloud);\n\n    // Now convert PointCloud2 to pcl::PointCloud<pcl::PointXYZ>\n    pcl::PointCloud<pcl::PointXYZ> pcl_cloud;\n    pcl::fromROSMsg(laser_cloud, pcl_cloud);\n\n    // Transform the PointCloud based on the odometry data if we're not in simulation mode.\n    if (!this->simulation_mode) {\n        Eigen::Matrix4f transform = Eigen::Matrix4f::Identity();\n        \n        // Extract rotation and translation parts from the odometry message\n        double roll, pitch, yaw;\n        tf::Quaternion q(odom.pose.pose.orientation.x,\n                         odom.pose.pose.orientation.y,\n                         odom.pose.pose.orientation.z,\n                         odom.pose.pose.orientation.w);\n        tf::Matrix3x3(q).getRPY(roll, pitch, yaw);\n        \n        // Set the translation\n        transform(0,3) = odom.pose.pose.position.x;\n        transform(1,3) = odom.pose.pose.position.y;\n        transform(2,3) = odom.pose.pose.position.z;\n\n        // Set the rotation\n        transform(0,0) = std::cos(yaw);\n        transform(0,1) = -std::sin(yaw);\n        transform(1,0) = std::sin(yaw);\n        transform(1,1) = std::cos(yaw);\n\n        // Perform the transformation\n        pcl::transformPointCloud(pcl_cloud, pcl_cloud, transform);\n    }\n\n    // Now you can integrate the pcl_cloud into your occupancy map data structure.\n    integratePointCloud(pcl_cloud);\n}", "CodeBleu_score": 47.795365081720355}, {"code": "#include <sensor_msgs/PointCloud2.h>\n#include <laser_geometry/laser_geometry.h>\n#include <pcl_ros/transforms.h>\n#include <pcl/point_types.h>\n#include <pcl/conversions.h>\n#include <tf/transform_listener.h>\n\nvoid Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr &local_point, const nav_msgs::Odometry &odom) {\n    // Step 1: Project the LaserScan to a PointCloud2 using laser_geometry::LaserProjection.\n    laser_geometry::LaserProjection projector;\n    sensor_msgs::PointCloud2 cloud2;\n    projector.projectLaser(*local_point, cloud2);\n\n    // Step 2: Convert PointCloud2 to pcl::PointCloud<pcl::PointXYZ>.\n    pcl::PointCloud<pcl::PointXYZ> cloud;\n    pcl::fromROSMsg(cloud2, cloud);\n\n    // Step 3: Apply transformation based on odometry, if not in simulation mode.\n    if (!is_simulation_mode) {\n        tf::Pose pose;\n        tf::poseMsgToTF(odom.pose.pose, pose);\n\n        // Prepare the transformation matrix.\n        Eigen::Matrix4f transform;\n        pcl_ros::transformAsMatrix(pose, transform);\n\n        // Apply the transformation to the cloud.\n        pcl::PointCloud<pcl::PointXYZ> transformed_cloud;\n        pcl::transformPointCloud(cloud, transformed_cloud, transform);\n\n        // Step 4: Merge the transformed point cloud into the local map.\n        mergeIntoLocalMap(transformed_cloud);\n    } else {\n        // If in simulation mode, use the raw projected cloud.\n        mergeIntoLocalMap(cloud);\n    }\n}\n\nvoid Occupy_map::mergeIntoLocalMap(const pcl::PointCloud<pcl::PointXYZ>& cloud) {\n    // This method should implement the logic to merge the given point cloud into the occupancy map.\n    // Possible implementation includes updating the occupancy values of the cells based on the points in the cloud.\n}", "CodeBleu_score": 50.69052011341928}, {"code": "#include <pcl_ros/transforms.h>\n#include <pcl/conversions.h>\n#include <sensor_msgs/PointCloud2.h>\n#include <laser_geometry/laser_geometry.h>\n#include <tf/tf.h>\n\nvoid Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom) {\n    // Instance of a laser_geometry projector to transform laser scans into PointCloud2\n    laser_geometry::LaserProjection projector;\n    sensor_msgs::PointCloud2 laser_cloud;\n\n    // Project the laser scan to a PointCloud2\n    projector.projectLaser(*local_point, laser_cloud);\n\n    // Convert from PointCloud2 to pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(laser_cloud, *cloud);\n\n    if (!sim_mode_) {\n        // We are not in simulation mode\n        // Extract the odometry data to get the robot's pose\n        auto pose = odom.pose.pose;\n\n        // Construct the transformation matrix from the odometry data\n        Eigen::Matrix4f transformation_matrix = Eigen::Matrix4f::Identity();\n        transformation_matrix(0, 3) = pose.position.x;\n        transformation_matrix(1, 3) = pose.position.y;\n        transformation_matrix(2, 3) = pose.position.z;\n\n        // Rotate the transformation matrix according to the robot's orientation\n        Eigen::Quaternionf quat(pose.orientation.w,\n                                pose.orientation.x,\n                                pose.orientation.y,\n                                pose.orientation.z);\n        transformation_matrix.block<3,3>(0,0) = quat.toRotationMatrix();\n\n        // Transform the point cloud according to the robot's position and orientation\n        pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::transformPointCloud(*cloud, *transformed_cloud, transformation_matrix);\n\n        // Merge the transformed point cloud with the global occupancy map\n        mergePointCloud(transformed_cloud);\n    } else {\n        // Simulation mode: we simply move forward with updating the map with the current cloud\n        mergePointCloud(cloud);\n    }\n}\n\n// This function merges the provided point cloud with the existing occupancy map\nvoid Occupy_map::mergePointCloud(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud) {\n    // Example merging mechanism; the actual implementation would depend on your mapping strategy\n    // Here we simply add the points to our map.\n    for (auto & point : *cloud) {\n        addPointToMap(point.x, point.y, point.z);\n    }\n}\n\n// Example function (which should be implemented) that adds each point to your map\nvoid Occupy_map::addPointToMap(float x, float y, float z) {\n    // Actual point adding mechanism depends on the structure of your occupancy map\n}", "CodeBleu_score": 52.69503540146376}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e) {\n    // Ensure global point cloud map and inflated point cloud are available.\n    if (!global_point_cloud_map || !inflated_point_cloud) {\n        ROS_WARN(\"Point cloud maps are not available.\");\n        return;\n    }\n\n    // Convert the global point cloud map to a ROS point cloud message.\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(*global_point_cloud_map, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n    global_pcl_msg.header.stamp = ros::Time::now();\n\n    // Publish the global point cloud map.\n    global_pcl_pub.publish(global_pcl_msg);\n    ROS_INFO(\"Published global point cloud map.\");\n\n    // Convert the inflated point cloud to a ROS point cloud message.\n    sensor_msgs::PointCloud2 inflated_pcl_msg;\n    pcl::toROSMsg(*inflated_point_cloud, inflated_pcl_msg);\n    inflated_pcl_msg.header.frame_id = \"world\";\n    inflated_pcl_msg.header.stamp = ros::Time::now();\n\n    // Publish the inflated point cloud.\n    inflate_pcl_pub.publish(inflated_pcl_msg);\n    ROS_INFO(\"Published inflated point cloud.\");\n}", "CodeBleu_score": 55.94070645775351}, {"code": "#include <sensor_msgs/PointCloud2.h>\n#include <pcl_ros/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl_conversions/pcl_conversions.h>\n\nclass Occupy_map {\npublic:\n    void pub_pcl_cb(const ros::TimerEvent& e);\nprivate:\n    pcl::PointCloud<pcl::PointXYZ> global_point_cloud;\n    pcl::PointCloud<pcl::PointXYZ> inflated_point_cloud;\n    ros::Publisher global_pcl_pub;\n    ros::Publisher inflate_pcl_pub;\n};\n\nvoid Occupy_map::pub_pcl_cb(const ros::TimerEvent& e) {\n    // Convert the global point cloud to a ROS message\n    sensor_msgs::PointCloud2 global_ros_message;\n    pcl::toROSMsg(global_point_cloud, global_ros_message);\n    global_ros_message.header.frame_id = \"world\";\n    global_ros_message.header.stamp = ros::Time::now();\n\n    // Publish the global point cloud\n    global_pcl_pub.publish(global_ros_message);\n\n    // Convert the inflated point cloud to a ROS message\n    sensor_msgs::PointCloud2 inflated_ros_message;\n    pcl::toROSMsg(inflated_point_cloud, inflated_ros_message);\n    inflated_ros_message.header.frame_id = \"world\";\n    inflated_ros_message.header.stamp = ros::Time::now();\n\n    // Publish the inflated point cloud\n    inflate_pcl_pub.publish(inflated_ros_message);\n}", "CodeBleu_score": 43.28517693176758}, {"code": "#include <sensor_msgs/PointCloud2.h>\n#include \"pcl_ros/transforms.h\"\n#include \"pcl_conversions/pcl_conversions.h\"\n\nvoid Occupy_map::pub_pcl_cb(const ros::TimerEvent& e) {\n    // Ensuring the publishers are properly initialized\n    if (!global_pcl_pub || !inflate_pcl_pub) {\n        ROS_WARN(\"Publisher has not been initialized.\");\n        return;\n    }\n\n    // Check if the cloud map data is ready\n    if (global_cloud.empty() || inflated_cloud.empty()) {\n        ROS_WARN(\"Point cloud data is empty.\");\n        return;\n    }\n\n    // Convert the global cloud to a ROS message\n    sensor_msgs::PointCloud2 global_cloud_msg;\n    pcl::toROSMsg(global_cloud, global_cloud_msg);\n    global_cloud_msg.header.frame_id = \"world\";\n    global_cloud_msg.header.stamp = ros::Time::now();\n\n    // Publish the global cloud\n    global_pcl_pub.publish(global_cloud_msg);\n    ROS_INFO(\"Published global point cloud.\");\n\n    // Convert the inflated cloud to a ROS message\n    sensor_msgs::PointCloud2 inflated_cloud_msg;\n    pcl::toROSMsg(inflated_cloud, inflated_cloud_msg);\n    inflated_cloud_msg.header.frame_id = \"world\";\n    inflated_cloud_msg.header.stamp = ros::Time::now();\n\n    // Publish the inflated cloud\n    inflate_pcl_pub.publish(inflated_cloud_msg);\n    ROS_INFO(\"Published inflated point cloud.\");\n}", "CodeBleu_score": 43.74201346869396}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "#include <sensor_msgs/PointCloud2.h>\n#include <pcl_ros/point_cloud.h>\n#include <pcl/point_types.h>\n#include <pcl_conversions/pcl_conversions.h>\n\nvoid GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg) {\n    if (!odom_ready_) {\n        ROS_INFO(\"Odometry not ready, cannot process point cloud.\");\n        return;\n    }\n\n    // Set the sensor_ready flag to true since odometry is ready.\n    sensor_ready_ = true;\n\n    // Convert the ROS point cloud message to PCL point cloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n\n    // Lock the map mutex during update\n    std::lock_guard<std::mutex> lock(map_mutex_);\n\n    // Update the internal map representation using the point cloud and the current UAV odometry\n    updateMap(cloud, current_odom_);\n\n    // Optionally, update the A* algorithm's map\n    updateAStarMap();\n\n    // Trigger path planning or any other subsequent processing\n    triggerPathPlanning();\n}\n\nvoid GlobalPlanner::updateMap(const pcl::PointCloud<pcl::PointXYZ>::Ptr& cloud, const nav_msgs::Odometry& odom) {\n    // Implementation to update the map based on the point cloud and current odometry.\n    // This is usually specific to the application and map structure being used.\n    // Example:\n    for (const auto& point : cloud->points) {\n        // Transform points based on odometry and add to the map\n    }\n}\n\nvoid GlobalPlanner::updateAStarMap() {\n    // Refresh the A* algorithm's map based on the updated internal map.\n}\n\nvoid GlobalPlanner::triggerPathPlanning() {\n    // Initiate or notify the path planning system that new data is available.\n}", "CodeBleu_score": 46.65248707725597}, {"code": "#include <sensor_msgs/PointCloud2.h>\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n#include <mutex>\n\nclass GlobalPlanner {\npublic:\n    void Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg);\n\nprivate:\n    void updateMapWithPointCloud(const pcl::PointCloud<pcl::PointXYZ>::Ptr &cloud);\n    void updateOdometry();  // Example function that might be needed to update odometry\n    bool odometryReady = false;\n    bool sensor_ready = false;\n    std::mutex mtx;  // Mutex for thread safety in a multi-threaded environment\n};\n\nvoid GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg) {\n    std::lock_guard<std::mutex> guard(mtx);  // Ensure thread safety with a mutex lock\n\n    std::cout << \"Received new point cloud message.\\n\";\n    \n    // Convert PointCloud2 message to PCL point cloud object\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n\n    if (!odometryReady) {\n        // If odometry is not ready, you might have to do something to make it ready.\n        // For this example, we just print a message.\n        std::cout << \"Odometry not ready. Please check the odometry state.\\n\";\n    } else {\n        // Set sensor ready flag\n        sensor_ready = true;\n        std::cout << \"Odometry is ready, processing point cloud.\\n\";\n\n        // Update A* or other path-finding / mapping algorithm's map\n        updateMapWithPointCloud(cloud);\n\n        // You might also need update the path based on the new map data\n        // UpdatePath();  // Assuming a function that updates the navigation path\n    }\n}\n\nvoid GlobalPlanner::updateMapWithPointCloud(const pcl::PointCloud<pcl::PointXYZ>::Ptr &cloud) {\n    // Update the internal map representation with new data from the point cloud\n    std::cout << \"Updating map with new point cloud data.\\n\";\n    \n    // Actual map updating logic goes here...\n    // This may include integrating the point cloud into a voxel grid, octomap, etc.\n}\n\nint main(int argc, char** argv) {\n    ros::init(argc, argv, \"global_planner_node\");\n    GlobalPlanner planner;\n\n    ros::NodeHandle node_handle;\n    ros::Subscriber sub = node_handle.subscribe<sensor_msgs::PointCloud2>(\"input_pointcloud\", 1, &GlobalPlanner::Lpointcloud_cb, &planner);\n    \n    ros::spin();\n    return 0;\n}", "CodeBleu_score": 42.742035419792366}, {"code": "#include <sensor_msgs/PointCloud2.h>\n#include <nav_msgs/Odometry.h>\n\nclass GlobalPlanner {\npublic:\n    void Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg);\n    bool updateMapWithPointCloud(const sensor_msgs::PointCloud2ConstPtr &cloud, const nav_msgs::Odometry &odom);\n    bool isOdometryReady();\n    void setSensorReady(bool ready);\n\nprivate:\n    bool odometryReady;\n    bool sensorReady;\n    nav_msgs::Odometry currentOdometry;\n};\n\nvoid GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg) {\n    if (isOdometryReady()) {\n        setSensorReady(true);\n        if (!updateMapWithPointCloud(msg, currentOdometry)) {\n            ROS_ERROR(\"Failed to update map with point cloud data.\");\n        }\n    } else {\n        ROS_INFO(\"Waiting for odometry to be ready.\");\n    }\n}\n\nbool GlobalPlanner::isOdometryReady() {\n    // Implement this method to check if odom data is ready.\n    // For example, you might check if some flag is set or odom data is non-zero or updated lately.\n    return odometryReady;  // depending on actual logic for determining readiness\n}\n\nvoid GlobalPlanner::setSensorReady(bool ready) {\n    sensorReady = ready;\n}\n\nbool GlobalPlanner::updateMapWithPointCloud(const sensor_msgs::PointCloud2ConstPtr &cloud, const nav_msgs::Odometry &odom) {\n    // Here you would perform the necessary point cloud processing and map update\n    // This could involve transforming the point cloud according to the odometry,\n    // possibly filtering the cloud, and then integrating it into your map representation.\n\n    // Returning true if successful, false otherwise (e.g., if transformations fail)\n    return true;  // Placeholder\n}", "CodeBleu_score": 38.89276802187279}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "#include <Eigen/Dense> // Common for handling vectors and matrices in robotics\n// Assumed extra necessary includes like ROS and potentially moveit or custom inverse kinematics solver\n\nvoid QuadrupedController::controlLoop_(const ros::TimerEvent& event) {\n    // 1. Get the current or desired pose of the robot body\n    Eigen::Vector3d body_pose = getCurrentBodyPose();\n\n    // 2. Calculate target foot positions from the desired body pose\n    std::array<Eigen::Vector3d, 4> foot_positions = bodyController_.calculateTargetFootPositions(body_pose);\n\n    // 3. Compute velocity commands for each of the legs\n    std::array<Eigen::Vector3d, 4> foot_velocities = calculateFootVelocities(foot_positions);\n\n    // 4. Use inverse kinematics to find the joint angles/positions for each leg\n    std::array<Eigen::VectorXd, 4> joint_positions;\n    for (int i = 0; i < 4; ++i) {\n        joint_positions[i] = calculateInverseKinematics(foot_positions[i]);\n    }\n\n    // 5. Send the computed joint positions to the robotic actuators or motors\n    sendJointCommands(joint_positions);\n\n    // 6. Publish foot contact and joint position information, potentially using a ROS publisher\n    publishFootContacts();\n    publishJointPositions(joint_positions);\n}\n\nEigen::Vector3d QuadrupedController::getCurrentBodyPose() {\n    // Placeholder function to retrieve current pose\n    return Eigen::Vector3d(0, 0, 0); // Zero pose for simplified example\n}\n\nstd::array<Eigen::Vector3d, 4> QuadrupedController::calculateFootVelocities(const std::array<Eigen::Vector3d, 4>& target_positions) {\n    std::array<Eigen::Vector3d, 4> velocities;\n    for (int i = 0; i < 4; ++i) {\n        // Placeholder velocity computation\n        velocities[i] = target_positions[i] - lastFootPositions_[i];\n        lastFootPositions_[i] = target_positions[i];\n    }\n    return velocities;\n}\n\nEigen::VectorXd QuadrupedController::calculateInverseKinematics(const Eigen::Vector3d& foot_pos) {\n    // Placeholder inverse kinematics calculation\n    Eigen::VectorXd joint_angles(3);\n    // Simple dummy formula: consider each component corresponds to an angular joint displacement\n    joint_angles << foot_pos[0], foot_pos[1], foot_pos[2];\n    return joint_angles;\n}\n\nvoid QuadrupedController::publishFootContacts() {\n    // Implementation depends on how this is defined, potentially notifying if feet are touching the ground\n}\n\nvoid QuadrupedController::publishJointPositions(const std::array<Eigen::VectorXd, 4>& joint_positions) {\n    // Publishing logic using ROS publishers\n    for (int i = 0; i < 4; ++i) {\n        // Assuming a publisher has been set up elsewhere in the class:\n        // jointPositionPublishers[i].publish(joint_positions[i]);\n    }\n}\n\nvoid QuadrupedController::sendJointCommands(const std::array<Eigen::VectorXd, 4>& joint_positions) {\n    // Send joint commands to actuators, which might involve using the ROS control system or another controller\n}", "CodeBleu_score": 33.54333865700326}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event) {\n    // Ensure that the necessary resources are available and locked\n    std::lock_guard<std::mutex> guard(control_mutex_);\n\n    // Retrieve the current pose of the robot\n    Pose currentPose = body_controller_->getCurrentPose();\n\n    // Calculate the desired positions for each foot\n    std::vector<Vector3> foot_positions = body_controller_->calculateTargetFootPositions(currentPose);\n\n    // Update leg controllers with target positions\n    for (int i = 0; i < legs_.size(); ++i) {\n        legs_[i]->setTargetPosition(foot_positions[i]);\n    }\n\n    // Compute velocity commands for each leg\n    std::vector<Vector3> leg_velocities = body_controller_->calculateLegVelocities(currentPose, foot_positions);\n\n    // Perform inverse kinematics to get the joint positions for each leg\n    std::vector<std::vector<double>> joint_positions;\n    for (int i = 0; i < legs_.size(); ++i) {\n        std::vector<double> joints = legs_[i]->calculateInverseKinematics(leg_velocities[i]);\n        joint_positions.push_back(joints);\n    }\n\n    // Publish foot contact information\n    std::map<int, bool> foot_contacts = body_controller_->checkFootContacts(foot_positions);\n    foot_contact_publisher_.publish(foot_contacts);\n\n    // Publish the calculated joint positions to the appropriate topic\n    for (int i = 0; i < legs_.size(); ++i) {\n        joint_position_publishers_[i].publish(joint_positions[i]);\n    }\n\n    // Provide feedback about the control loop such as timing and any possible errors\n    ROS_INFO(\"Control loop executed successfully\");\n}", "CodeBleu_score": 44.45042608439936}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event) {\n    // Get current pose and velocity of the robot\n    Pose3D current_pose = bodyController_.getCurrentPose();\n    Velocity current_velocity = bodyController_.getCurrentVelocity();\n\n    // Calculate target foot positions based on the current pose\n    std::vector<Point3D> target_foot_positions = legController_.calculateFootPositions(current_pose);\n\n    // Compute velocity commands for the legs\n    std::vector<Velocity> leg_velocities = legController_.calculateLegVelocities(current_pose, current_velocity);\n\n    // Perform inverse kinematics to determine target joint positions\n    std::vector<std::vector<double>> joint_positions;\n    for (int i = 0; i < target_foot_positions.size(); i++) {\n        std::vector<double> positions = legController_.inverseKinematics(target_foot_positions[i], i);\n        joint_positions.push_back(positions);\n    }\n\n    // Update the joint controllers with the computed positions\n    for (int i = 0; i < jointControllers_.size(); i++) {\n        jointControllers_[i].setTargetPositions(joint_positions[i]);\n    }\n\n    // Publish foot contact information\n    bodyController_.publishFootContacts();\n\n    // Publish joint positions to the actuators\n    for (auto& jc : jointControllers_) {\n        jc.publishPositions();\n    }\n}", "CodeBleu_score": 42.475906272176736}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "#include <ros/ros.h>\n#include <quad_common/ContactsStamped.h>\n\nvoid QuadrupedController::publishFootContacts_(bool foot_contacts[4]) {\n    // Check if foot contact publishing is enabled and if the robot is not in Gazebo simulation.\n    if (publish_foot_contacts_ && !in_gazebo_) {\n        // Create a ContactsStamped message.\n        quad_common::ContactsStamped msg;\n\n        // Populate the message with the current timestamp.\n        msg.header.stamp = ros::Time::now();\n\n        // Populate the foot contact states for each leg\n        for (int i = 0; i < 4; ++i) {\n            msg.contacts[i] = foot_contacts[i];\n        }\n\n        // Publish the message using the foot contact publisher.\n        foot_contacts_publisher_.publish(msg);\n\n        // Optionally add logging for debugging\n        ROS_INFO(\"Published foot contacts: FL: %d, FR: %d, RL: %d, RR: %d\", \n                 static_cast<int>(foot_contacts[0]), static_cast<int>(foot_contacts[1]),\n                 static_cast<int>(foot_contacts[2]), static_cast<int>(foot_contacts[3]));\n    } else {\n        // Optionally add logging when not publishing\n        ROS_DEBUG(\"Foot contact publishing is disabled or running in Gazebo.\");\n    }\n}", "CodeBleu_score": 58.43478563812398}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]) {\n    if (publish_foot_contacts_enabled_ && !in_gazebo_) {\n        // Preparing the ContactsStamped message\n        quadruped_control::ContactsStamped contacts_msg;\n        contacts_msg.header.stamp = ros::Time::now();\n        \n        // Each foot has its own state, populate them\n        for (int i = 0; i < 4; i++) {\n            quadruped_control::ContactStamped contact;\n            contact.contact = foot_contacts[i];\n            contact.phase = getCurrentGaitPhase(i); // Assuming a function that returns current gait phase for the leg\n            contacts_msg.contacts.push_back(contact);\n        }\n        \n        // Publish the message\n        foot_contacts_publisher_.publish(contacts_msg);\n    }\n}", "CodeBleu_score": 59.020814953651815}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4]) {\n    // Check if the foot contact publishing is enabled and if the robot is not in a simulation environment such as Gazebo.\n    if (enable_contact_publishing_ && !in_gazebo_) {\n        // Create a ContactsStamped message (assuming such a message type exists, else define accordingly)\n        ContactsStamped contact_msg;\n        contact_msg.header.stamp = ros::Time::now(); // Setting the timestamp\n        contact_msg.header.frame_id = \"base_link\"; // Or the appropriate frame id according to your TF configuration\n\n        // Populate the message with the foot contact states and gait phase information\n        for (int i = 0; i < 4; ++i) {\n            ContactState state;\n            state.leg_name = getLegName(i); // Assumes a function exists to map leg index to name\n            state.contact = foot_contacts[i];\n            state.phase = getCurrentGaitPhase(i); // Assumes a function exists to get the current phase of the gait\n\n            contact_msg.contacts.push_back(state);\n        }\n\n        // Publish the message\n        foot_contacts_publisher_.publish(contact_msg);\n    }\n}\n\n// Helper function to get the name of the leg by its index\nconst std::string QuadrupedController::getLegName(int index) {\n    static const std::vector<std::string> leg_names = {\"front_left\", \"front_right\", \"rear_left\", \"rear_right\"};\n    return leg_names[index];\n}\n\n// Helper function to get the current gait phase of a leg (simplified example, replace with actual implementation)\nfloat QuadrupedController::getCurrentGaitPhase(int index) {\n    // Dummy phase calculation, should actually be retrieved from a gait controller or similar component\n    return 0.25 * index; // Just a placeholder value\n}", "CodeBleu_score": 48.240656854287614}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "import rospy\nfrom std_msgs.msg import Float64MultiArray\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n\nclass RobotArmController:\n    def __init__(self):\n        # Assuming the node has already been initialized in another part of the program\n        self.joint_pub = rospy.Publisher(\"minimal_joint_states\", Float64MultiArray, queue_size=10)\n        self.trajectory_pub = rospy.Publisher(\"joint_trajectory\", JointTrajectory, queue_size=10)\n        \n    def joints_cmd_callback(self, joints):\n        # Publish minimal joint states\n        joint_msg = Float64MultiArray()\n        # Use only the first 12 joints or all joints if there are less than 12\n        joint_msg.data = joints[:12]\n        self.joint_pub.publish(joint_msg)\n\n        # Create and publish the joint trajectory message\n        traj_msg = JointTrajectory()\n        point = JointTrajectoryPoint()\n        point.positions = joints[:12]\n        # You will need to specify a duration; here I set 1.0 second.\n        point.time_from_start = rospy.Duration(1.0)\n        traj_msg.points.append(point)\n        self.trajectory_pub.publish(traj_msg)\n\n# Example usage\n# Assuming rospy.init_node() is called in the main routine if needed\n# robot_controller = RobotArmController()\n# rospy.spin()  # Typically in a ROS based program to continuously process callbacks", "CodeBleu_score": 41.37494724268497}, {"code": "class RobotArmController:\n    def __init__(self):\n        # Assuming publishers are set up in an __init__ function\n        # self.joint_publisher - for minimal joint messages\n        # self.trajectory_publisher - for trajectory messages\n        pass\n\n    def joints_cmd_callback(self, joints):\n        \"\"\"\n        Processes incoming joints commands by:\n        - Extracting the first 12 joint positions\n        - Publishing them as a minimal joint message\n        - Constructing and publishing a joint trajectory message with a specified duration\n        \"\"\"\n        # Extract the first 12 joint positions (assuming 'joints' is a list or compatible)\n        first_twelve_positions = joints[:12]\n\n        # Create a simple joint message and publish it\n        minimal_joint_message = {'positions': first_twelve_positions}\n        self.joint_publisher.publish(minimal_joint_message)\n\n        # Create a joint trajectory message\n        joint_trajectory_message = {\n            'trajectories': [{'positions': pos, 'duration': 1.0} for pos in first_twelve_positions]\n        }\n        self.trajectory_publisher.publish(joint_trajectory_message)\n\n    # Assuming publishers are named and set up in a realistic manner within the framework being used\n    def joint_publisher(self, message):\n        # Method to 'publish' a message - typically just a placeholder for this concept.\n        pass\n\n    def trajectory_publisher(self, message):\n        # Method to 'publish' a trajectory message - also a placeholder\n        pass\n\n# Create an instance and simulate a callback event\nrobot_arm = RobotArmController()\nrobot_arm.joints_cmd_callback([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])", "CodeBleu_score": 35.24243828359231}, {"code": "def joints_cmd_callback(self, joints):\n    # Imports that might be necessary depending on the broader context.\n    # from some_robotics_library import MinimalJointsMessage, JointTrajectoryMessage, SomePublisher\n  \n    # Assuming joints is a list or similar iterable containing joint positions.\n    \n    # Create and publish a minimal joints message with the first 12 joint positions.\n    if len(joints) >= 12:\n        minimal_joint_positions = joints[:12]\n    else:\n        minimal_joint_positions = joints + [0]*(12 - len(joints))  # Pad with zeros if there are less than 12 joints\n\n    minimal_joints_msg = MinimalJointsMessage(positions=minimal_joint_positions)\n    self.minimal_joints_publisher.publish(minimal_joints_msg)\n    print(\"Published minimal joints message:\", minimal_joints_msg)\n\n    # Create and publish a joint trajectory message with the same positions and a specified duration\n    duration = 2  # Duration for the trajectory message in seconds, assumed\n    joint_trajectory_msg = JointTrajectoryMessage(positions=minimal_joint_positions, duration=duration)\n    self.joint_trajectory_publisher.publish(joint_trajectory_msg)\n    print(\"Published joint trajectory message:\", joint_trajectory_msg)\n\n    # Assuming that the publishers are properly set up somewhere within the class:\n    # self.minimal_joints_publisher = SomePublisher(minimal_topic_name)\n    # self.joint_trajectory_publisher = SomePublisher(joint_trajectory_topic_name)", "CodeBleu_score": 30.135842121469036}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "#include <iostream>\n#include <vector>\n#include <set>\n\n// Assume the necessary headers and namespaces from Gazebo are included as:\n// #include <gazebo/gazebo.hh>\n// #include <gazebo/msgs/msgs.hh>\n// using namespace gazebo;\n\n// Also, assume some predefined set containing names of the foot links\nstd::set<std::string> footLinkNames = {\"left_foot\", \"right_foot\"};\n\n// Mock classes to represent the data structures used for illustrating the solution\nclass Contact {\npublic:\n    std::string collision1;\n    std::string collision2;\n};\n\nclass ContactsMessage {\npublic:\n    std::vector<Contact> contacts;\n};\n\n// Let's assume we define foot contact states as a simple dictionary (or map in C++ standard)\nstd::map<std::string, bool> footContactStates{\n    {\"left_foot\", false},\n    {\"right_foot\", false}\n};\n\nvoid resetFootContactStates() {\n    for (auto& state : footContactStates) {\n        state.second = false;\n    }\n}\n\nvoid gazeboCallback_(const ContactsMessage& _msg) {\n    // Reset foot contact states\n    resetFootContactStates();\n\n    // Process each contact in the message\n    for (const auto& contact : _msg.contacts) {\n        // Extract collision names involved in the contact\n        std::string colName1 = contact.collision1;\n        std::string colName2 = contact.collision2;\n\n        // Check if either collision name is one of the foot links\n        if (footLinkNames.find(colName1) != footLinkNames.end()) {\n            footContactStates[colName1] = true;\n        }\n        if (footLinkNames.find(colName2) != footLinkNames.end()) {\n            footContactStates[colName2] = true;\n        }\n    }\n\n    // Just for verification, let's print the state of foot contacts\n    for (const auto& state : footContactStates) {\n        std::cout << state.first << \": \" << (state.second ? \"Contact\" : \"No Contact\") << std::endl;\n    }\n}", "CodeBleu_score": 34.047477626851574}, {"code": "#include <iostream>\n#include <string>\n#include <vector>\n\n// Assuming a simplified version of Gazebo and ROS headers\n// #include <gazebo_msgs/ContactsState.h>\n\nstruct Contact {\n    std::string collision1;\n    std::string collision2;\n};\n\nstruct Contacts {\n    std::vector<Contact> contact_array;\n};\n\nusing ConstContactsPtr = std::shared_ptr<Contacts>;\n\nclass RobotController {\npublic:\n    RobotController() : left_foot_contact(false), right_foot_contact(false) {};\n\n    void gazeboCallback_(ConstContactsPtr &_msg) {\n        // Initialize foot contact states to false\n        left_foot_contact = false;\n        right_foot_contact = false;\n\n        // Assume _msg is already a populated message of contacts\n        for (const auto& contact : _msg->contact_array) {\n            // Splitting collision name; assuming foot link names \"left_foot\" and \"right_foot\"\n            if (contact.collision1.find(\"left_foot\") != std::string::npos || \n                contact.collision2.find(\"left_foot\") != std::string::npos) {\n                left_foot_contact = true;\n            }\n\n            if (contact.collision1.find(\"right_foot\") != std::string::npos || \n                contact.collision2.find(\"right_foot\") != std::string::npos) {\n                right_foot_contact = true;\n            }\n        }\n\n        // For debugging, you might want to print out the contact results:\n        std::cout << \"Left foot in contact: \" << (left_foot_contact ? \"Yes\" : \"No\") << std::endl;\n        std::cout << \"Right foot in contact: \" << (right_foot_contact ? \"Yes\" : \"No\") << std::endl;\n    }\n\nprivate:\n    bool left_foot_contact;\n    bool right_foot_contact;\n};\n\nint main() {\n    // Creating a hypothetical scenario for testing\n    RobotController robot;\n\n    // Manually setting up a contacts message\n    Contact c1{\"robot::left_foot::collision\", \"ground::floor::collision\"};\n    Contact c2{\"robot::right_foot::collision\", \"ground::floor::collision\"};\n    Contacts contacts;\n    contacts.contact_array.push_back(c1);\n    contacts.contact_array.push_back(c2);\n    \n    ConstContactsPtr contacts_ptr = std::make_shared<Contacts>(contacts);\n\n    // Processing contacts\n    robot.gazeboCallback_(contacts_ptr);\n\n    return 0;\n}", "CodeBleu_score": 22.58273620962472}, {"code": "#include <gazebo/msgs/msgs.hh>\n#include <gazebo/transport/transport.hh>\n\n#include <unordered_map>\n#include <string>\n\n// Global or class-level declaration of foot contact states\nstd::unordered_map<std::string, bool> foot_contacts = {\n    {\"left_foot\", false},\n    {\"right_foot\", false}\n};\n\nvoid resetFootContacts() {\n    for (auto &contact : foot_contacts) {\n        contact.second = false;\n    }\n}\n\nvoid gazeboCallback_(ConstContactsPtr &_msg) {\n    // Start by resetting the foot contact states for each new message\n    resetFootContacts();\n\n    // Processing each contact in the contacts message\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        const gazebo::msgs::Contact &contact = _msg->contact(i);\n        \n        // We will check both the collision1 and collision2 names as contact can be reported either way\n        std::string collision1_name = contact.collision1();\n        std::string collision2_name = contact.collision2();\n        \n        for (auto &foot : foot_contacts) {\n            // Check if either collision1 or collision2 matches the foot link\n            if (collision1_name.find(foot.first) != std::string::npos || collision2_name.find(foot.first) != std::string::npos) {\n                foot.second = true; // Set contact state to true if the foot is in contact\n                break; // You can stop the search for this contact since the match is found\n            }\n        }\n    }\n\n    // Debugging or Logging the contact statuses\n    for (const auto &foot : foot_contacts) {\n        std::cout << \"Contact state for \" << foot.first << \": \" << (foot.second ? \"In Contact\" : \"No Contact\") << std::endl;\n    }\n}", "CodeBleu_score": 37.16079124572226}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "#include <Eigen/Dense>\n#include <vector>\n#include <algorithm>\n\nclass LeePositionController {\nprivate:\n    bool isActive;\n    Eigen::MatrixXd controlMatrix;   // Predefined matrix to compute velocities\n    double maxRotorVelocity;         // Maximum allowable rotor velocity\n\npublic:\n    // Constructor to initialize controller\n    LeePositionController(bool active, Eigen::MatrixXd& matrix, double maxVel)\n        : isActive(active), controlMatrix(matrix), maxRotorVelocity(maxVel) {}\n\n    // Calculate Rotor Velocities method\n    void CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const {\n        if (!isActive || rotor_velocities == nullptr) {\n            // Set all rotor velocities to zero if the controller is inactive\n            *rotor_velocities = Eigen::VectorXd::Zero(controlMatrix.rows());\n            return;\n        }\n\n        // Compute the desired acceleration and angular acceleration (example placeholder implementation)\n        Eigen::VectorXd desiredAcceleration(3);\n        Eigen::VectorXd angularAcceleration(3);\n        // Initialize with some arbitrary values for the sake of this example\n        desiredAcceleration << 0.1, 0.1, 10.0;  // Strong thrust in z-axis to lift\n        angularAcceleration << 0.01, 0.01, 0.01;  // Small rotation\n\n        // Project thrust onto the body z-axis (third component)\n        double thrustZ = desiredAcceleration[2];\n\n        // Combine angular acceleration and thrust into a single vector\n        Eigen::VectorXd combinedVector(6);\n        combinedVector << angularAcceleration, Eigen::VectorXd::Unit(3, 2) * thrustZ;\n\n        // Compute rotor velocities by multiplying the combined vector with the control matrix\n        Eigen::VectorXd rawVelocities = controlMatrix * combinedVector;\n\n        // Ensure non-negative values and compute square root\n        for (int i = 0; i < rawVelocities.size(); ++i) {\n            rawVelocities[i] = std::max(0.0, rawVelocities[i]); // Ensure non-negative\n            rawVelocities[i] = std::sqrt(rawVelocities[i]);     // Square root\n            rawVelocities[i] = std::min(rawVelocities[i], maxRotorVelocity);  // Limit the maximum rotor velocity\n        }\n\n        // Assign computed velocities back to the parameter\n        *rotor_velocities = rawVelocities;\n    }\n};", "CodeBleu_score": 36.61200163426043}, {"code": "#include <Eigen/Dense>\n#include <algorithm>  // For std::max\n\nvoid LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const {\n    if (!isActive) {\n        // Set all rotor velocities to zero if the controller is not active\n        rotor_velocities->setZero();\n        return;\n    }\n\n    // Following steps would calculate desired accelerations and combine values as per the given description (assuming methods exist)\n    Eigen::Vector3d desired_acceleration = CalculateDesiredAcceleration();\n    Eigen::Vector3d desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\n    // Project thrust onto the body z-axis\n    double thrust_z = thrust.dot(Eigen::Vector3d(0, 0, 1));\n    \n    // Combine angular acceleration and thrust into a single vector, assuming thrust is properly aligned and scaled\n    Eigen::VectorXd combined_vector(6);\n    combined_vector.head<3>() = desired_acceleration;\n    combined_vector(3) = desired_angular_acceleration.x();\n    combined_vector(4) = desired_angular_acceleration.y();\n    combined_vector(5) = thrust_z;\n\n    // Define the transformation matrix which is predefined\n    Eigen::MatrixXd transformation_matrix(4, 6); // The size and values should be set based on actual system requirements\n    // transformation_matrix << (values based on your system design)\n\n    // Calculate the raw rotor velocities\n    Eigen::VectorXd raw_rotor_velocities = transformation_matrix * combined_vector;\n\n    // Ensure non-negative and compute square root of each component\n    for (int i = 0; i < raw_rotor_velocities.size(); ++i) {\n        double val = std::max(0.0, raw_rotor_velocities(i));\n        (*rotor_velocities)(i) = sqrt(val);\n    }\n}", "CodeBleu_score": 43.831692579972184}, {"code": "#include <Eigen/Dense>\n#include <cmath>\n#include <algorithm>\n\nclass LeePositionController {\nprivate:\n    Eigen::Matrix4d controlMatrix;  // Control matrix for the rotor velocities calculation\n    bool isActive;                  // Controller active state\n    Eigen::Vector3d desiredAcceleration; // Desired linear acceleration\n    Eigen::Vector3d desiredAngularAcceleration; // Desired angular acceleration\npublic:\n    LeePositionController() {\n        isActive = false;\n        controlMatrix.setZero();\n        desiredAcceleration.setZero();\n        desiredAngularAcceleration.setZero();\n    }\n\n    void activateController(bool state) {\n        isActive = state;\n    }\n    \n    void setControlMatrix(const Eigen::Matrix4d& matrix) {\n        controlMatrix = matrix;\n    }\n\n    void setDesiredAcceleration(const Eigen::Vector3d& acceleration) {\n        desiredAcceleration = acceleration;\n    }\n\n    void setDesiredAngularAcceleration(const Eigen::Vector3d& angularAcceleration) {\n        desiredAngularAcceleration = angularAcceleration;\n    }\n\n    void CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const {\n        // Check if the controller is active and the input is valid\n        if (!isActive || rotor_velocities == nullptr) {\n            if (rotor_velocities != nullptr) {\n                rotor_velocities->setZero();\n            }\n            return;\n        }\n        \n        // Calculate the desired thrust projection\n        Eigen::Vector3d thrustProjection(0, 0, desiredAcceleration.norm());\n        \n        // Combine angular acceleration and thrust into a single vector\n        Eigen::VectorXd combinedVector(4);\n        combinedVector << desiredAngularAcceleration, thrustProjection.z();\n        \n        // Compute rotor velocities by multiplying with the control matrix\n        *rotor_velocities = controlMatrix * combinedVector;\n        \n        // Ensure non-negative values and calculate the square root\n        for (int i = 0; i < rotor_velocities->size(); ++i) {\n            (*rotor_velocities)[i] = std::sqrt(std::max(0.0, (*rotor_velocities)[i]));\n        }\n    }\n};", "CodeBleu_score": 34.59332543340131}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "#include <Eigen/Dense>\n\nclass LeePositionController {\npublic:\n    void ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const;\n\nprivate:\n    Eigen::Vector3d position_command_; // Commanded position from the trajectory\n    Eigen::Vector3d velocity_command_; // Commanded velocity from the trajectory\n    Eigen::Vector3d current_position_; // Current position from odometry\n    Eigen::Vector3d current_velocity_; // Current velocity from odometry\n    double vehicle_mass_; // Mass of the vehicle\n    double gravity_; // Gravity constant\n    \n    Eigen::Vector3d position_gain_; // Proportional gain for position control\n    Eigen::Vector3d velocity_gain_; // Proportional gain for velocity control\n};\n\nvoid LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const {\n    if (!acceleration) {\n        return;\n    }\n    \n    // Compute the position error\n    Eigen::Vector3d position_error = position_command_ - current_position_;\n    \n    // Compute the velocity error (transform current velocity to world frame if necessary)\n    // Assuming current_velocity_ is already in the world frame\n    Eigen::Vector3d velocity_error = velocity_command_ - current_velocity_;\n    \n    // Compute the desired acceleration using proportional control law\n    // F = m * (acc_desired + g) => acc_desired = F/m - g\n    //                  where F is the force vector computed from control gains\n    Eigen::Vector3d force = position_gain_.asDiagonal() * position_error + velocity_gain_.asDiagonal() * velocity_error;\n    Eigen::Vector3d acc_desired = (force / vehicle_mass_) - Eigen::Vector3d(0, 0, gravity_);\n    \n    // Set the computed acceleration\n    *acceleration = acc_desired;\n}", "CodeBleu_score": 31.115150832619005}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const {\n    // Assuming position and velocity are part of the class member data.\n    // current_odometry_ and command_trajectory_ should be member variables containing the current state and desired state.\n\n    // Carve out the necessary data from the trajectory command.\n    Eigen::Vector3d desired_position = command_trajectory_.position;\n    Eigen::Vector3d desired_velocity = command_trajectory_.velocity;\n    Eigen::Vector3d desired_acceleration = command_trajectory_.acceleration;\n\n    // Calculate position error (desired - current)\n    Eigen::Vector3d position_error = desired_position - current_odometry_.position;\n\n    // Velocity needs to be expressed in the world frame.\n    // Assuming current_odometry_.orientation is a quaternion describing the vehicle orientation.\n    Eigen::Vector3d current_velocity_world = current_odometry_.orientation * current_odometry_.velocity;\n    Eigen::Vector3d velocity_error = desired_velocity - current_velocity_world;\n\n    // Position and velocity error gains. kp_pos and kp_vel should be configured for tuning the controller response.\n    Eigen::Vector3d kp_pos(1.0, 1.0, 1.0); // Position gain\n    Eigen::Vector3d kp_vel(1.0, 1.0, 1.0); // Velocity gain\n\n    // Compute desired acceleration combining all components.\n    // Assumption: The vehicle mass and gravity are accounted for in the calculation to tune response properly.\n    // We need mass (m) and gravitational acceleration (g) for a more accurate model.\n    double mass = 1.0; // Example mass of the vehicle\n    Eigen::Vector3d gravity(0.0, 0.0, -9.81); // Gravity vector pointing downwards\n    \n    // Formulate the control input (PID form with feedforward from desired acceleration).\n    *acceleration = desired_acceleration\n                    + kp_pos.cwiseProduct(position_error)\n                    + kp_vel.cwiseProduct(velocity_error)\n                    - gravity; // Compensate for gravity explicitly if not inherently handled\n\n    // The output acceleration is in world frame and can be used to compute force or torque inputs for the vehicle.\n}", "CodeBleu_score": 46.65550730566532}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const {\n    // Retrieve current position and velocity from odometry\n    const Eigen::Vector3d& current_position = odometry_.position;\n    const Eigen::Vector3d& current_velocity = odometry_.velocity;\n\n    // Retrieve commanded position, velocity, and acceleration from trajectory\n    const Eigen::Vector3d& commanded_position = command_trajectory_.position;\n    const Eigen::Vector3d& commanded_velocity = command_trajectory_.velocity;\n    const Eigen::Vector3d& commanded_acceleration = command_trajectory_.acceleration;\n    \n    // Calculate position error (commanded - current)\n    Eigen::Vector3d position_error = commanded_position - current_position;\n    \n    // Calculate velocity error\n    // Note: Assuming world frame for velocity computation simplifies representation,\n    // otherwise a transformation of current_velocity to the world frame would be needed.\n    Eigen::Vector3d velocity_error = commanded_velocity - current_velocity;\n\n    // Compute desired acceleration using proportional-derivative controller (PD controller)\n    // gain_position_ and gain_velocity_ are the proportional (Kp) and derivative (Kv) gains respectively\n    *acceleration = gain_position_ * position_error + gain_velocity_ * velocity_error + commanded_acceleration;\n\n    // Consider the effect of gravity if vertical dynamics is to be included\n    // This would be important especially for aerial vehicles like drones\n    // Gravity compensation (if applying this controller to vertical dynamics)\n    if(include_gravity_compensation_) {\n        const Eigen::Vector3d gravity(0, 0, -9.81); // Assuming the gravity vector points in the negative Z direction in world frame\n        *acceleration -= gravity;\n    }\n\n    // Here vehicle mass can also be used to normalize force into acceleration if force is being directly controlled\n    // Commenting out since it's not provided in this snippet\n    // *acceleration /= vehicle_mass_;\n\n    // Debug/logging details\n    std::cout << \"Position Error: \" << position_error.transpose() << \" Velocity Error: \" << velocity_error.transpose() << \" Commanded Acceleration: \" << commanded_acceleration.transpose() << \" Resulting Acceleration: \" << acceleration->transpose() << std::endl;\n}", "CodeBleu_score": 42.77553889287374}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "#include <Eigen/Dense>\n#include <algorithm>\n#include <cmath>\n\nclass AttitudeControllerSamy {\npublic:\n    void CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const {\n        // Check if the input is valid\n        if (rotor_velocities == nullptr) {\n            throw std::invalid_argument(\"Rotor velocities pointer cannot be nullptr\");\n        }\n\n        // Assuming numberOfRotors is a class member that indicates how many rotors the vehicle has\n        int numberOfRotors = 4;  // This should be dynamically set from actual vehicle configuration\n        rotor_velocities->resize(numberOfRotors);\n        \n        // Setup mock parameters needed for calculation (to be actually derived from class members/state)\n        Eigen::VectorXd thrust_reference = Eigen::VectorXd::Constant(numberOfRotors, 10.0);  // Some constant thrust reference\n        Eigen::VectorXd desired_angular_acceleration = Eigen::VectorXd::Ones(numberOfRotors);  // Some desired angular acceleration\n\n        // Combine thrust and angular acceleration into single command vector\n        Eigen::VectorXd command_vector = thrust_reference + desired_angular_acceleration;\n\n        // Define a fixed transformation matrix, assuming numberOfRotors x numberOfRotors (mock example)\n        Eigen::MatrixXd transformationMatrix = Eigen::MatrixXd::Identity(numberOfRotors, numberOfRotors);  // Just an identity for simplification\n\n        // Calculate rotor velocities squared\n        Eigen::VectorXd rotor_velocities_squared = transformationMatrix * command_vector;\n\n        // Ensure all velocities are at least 1 (squared values must be >= 1)\n        for (int i = 0; i < rotor_velocities_squared.size(); ++i) {\n            rotor_velocities_squared[i] = std::max(1.0, rotor_velocities_squared[i]);\n        }\n\n        // Take square root to get actual velocities\n        for (int i = 0; i < rotor_velocities->size(); ++i) {\n            (*rotor_velocities)[i] = std::sqrt(rotor_velocities_squared[i]);\n        }\n    }\n};", "CodeBleu_score": 34.06003990246268}, {"code": "#include <Eigen/Dense>\n#include <algorithm>\n#include <cmath>\n\n// Function CalculateRotorVelocities\n// Calculates the rotor velocities for a flying vehicle based on thrust and attitude control.\nvoid AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const {\n    if (!rotor_velocities) {\n        // Handle the case where rotor_velocities is a nullptr\n        throw std::invalid_argument(\"Null pointer provided for rotor velocities\");\n    }\n    \n    // Assume num_rotors_ is defined elsewhere in the class, representing the number of rotors\n    int num_rotors = num_rotors_;\n\n    // Resize the vector to hold the velocities for each rotor\n    rotor_velocities->resize(num_rotors);\n    \n    // Assume thrust_reference_ and desired_angular_acceleration_ are defined elsewhere in the class\n    // Combining thrust and angular accelerations into a control input vector\n    Eigen::VectorXd control_input(num_rotors);\n    control_input << thrust_reference_, desired_angular_acceleration_;\n\n    // Assume allocation_matrix_ is defined elsewhere in the class and used for mixing control inputs to rotor speeds\n    // Calculate raw rotor velocities squared (control inputs are mixed using a predefined matrix)\n    Eigen::VectorXd raw_rotor_velocities_squared = allocation_matrix_ * control_input;\n\n    // Ensure all raw rotor velocities are at least 1 (squared value), to avoid negative square root\n    for (int i = 0; i < num_rotors; ++i) {\n        if (raw_rotor_velocities_squared[i] < 1.0) {\n            raw_rotor_velocities_squared[i] = 1.0;\n        }\n    }\n\n    // Taking the square root of each rotor velocity component to find actual rotor velocities\n    for (int i = 0; i < num_rotors; ++i) {\n        (*rotor_velocities)[i] = std::sqrt(raw_rotor_velocities_squared[i]);\n    }\n}", "CodeBleu_score": 39.21293528464375}, {"code": "#include <Eigen/Dense>\n#include <cmath>\n#include <stdexcept>\n#include <algorithm>\n\nclass AttitudeControllerSamy {\npublic:\n    // Set a predefined matrix for rotor calculations.\n    Eigen::MatrixXd control_matrix;\n    int num_rotors;\n    double min_rotor_velocity;\n\n    AttitudeControllerSamy(int num_rotors) : num_rotors(num_rotors), min_rotor_velocity(1.0) {\n        control_matrix = Eigen::MatrixXd::Random(num_rotors, 4); // Example control matrix, should be configured properly in real case.\n    }\n\n    void CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities, const Eigen::VectorXd& thrust_reference, const Eigen::VectorXd& angular_acceleration) const {\n        // Check if input pointers are not nullptr\n        if (rotor_velocities == nullptr) {\n            throw std::invalid_argument(\"rotor_velocities pointer cannot be null\");\n        }\n\n        // Ensure the reference and acceleration vectors have proper dimensions\n        if (thrust_reference.size() != 3 || angular_acceleration.size() != 3) {\n            throw std::invalid_argument(\"thrust_reference and angular_acceleration vectors must be of size 3\");\n        }\n\n        // Combine thrust reference and angular acceleration into a single vector\n        Eigen::VectorXd combined_input(6);\n        combined_input << thrust_reference, angular_acceleration;\n\n        // Ensure the control matrix is correctly sized\n        if (control_matrix.rows() != num_rotors || control_matrix.cols() != 6) {\n            throw std::runtime_error(\"The size of the control matrix is incorrect\");\n        }\n\n        // Calculate rotor velocities\n        Eigen::VectorXd raw_velocities = control_matrix * combined_input;\n\n        // Ensure rotor velocities are above minimum rotor velocity and calculate square root\n        rotor_velocities->resize(num_rotors);\n        for (int i = 0; i < num_rotors; i++) {\n            (*rotor_velocities)[i] = std::sqrt(std::max(raw_velocities[i], min_rotor_velocity));\n        }\n    }\n};", "CodeBleu_score": 40.09829510813693}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "import copy\n\nclass TimeSeriesData:\n    def __init__(self, timestamps, data):\n        # Assuming `timestamps` is a list of time values and `data` is also a list of data that corresponds with these timestamps\n        self.timestamps = timestamps\n        self.data = data\n\n    def find_index(self, time_point):\n        # A simple function to find the closest index for a given time_point\n        # This function can be more complex based on how precise and accurate the index needs to be found\n        # Here, it simply finds the first occurrence where the time_point is less than or equal to the timestamp\n        for index, time in enumerate(self.timestamps):\n            if time >= time_point:\n                return index\n        return len(self.timestamps) - 1  # Return last index if the time point is beyond all timestamps\n\n    def slice(self, start_time, end_time):\n        # Find indices\n        start_index = self.find_index(start_time)\n        end_index = self.find_index(end_time)\n\n        # Copy the object\n        new_object = copy.deepcopy(self)\n\n        # Slice the attributes\n        new_object.timestamps = self.timestamps[start_index:end_index + 1]\n        new_object.data = self.data[start_index:end_index + 1]\n\n        # Return the newly copied and sliced object\n        return new_object", "CodeBleu_score": 35.32913525480519}, {"code": "import copy\n\nclass TimeSeries:\n    def __init__(self, data):\n        self.data = data\n    \n    def time_to_index(self, time):\n        # Placeholder: Actual implementation needed\n        # It should convert time to an appropriate index of the data\n        pass\n    \n    def slice(self, start_time, end_time):\n        \"\"\"This function, slice, creates a copy of the object and slices its attributes between the specified start_time and end_time.\n        It finds the corresponding indices for the start and end times, makes a deep copy of the object, and updates each attribute of the copied object to contain only the sliced data.\n        Finally, it returns the copied and sliced object.\"\"\"\n        \n        # Create a deep copy of the object to ensure that no references are shared with the original\n        sliced_object = copy.deepcopy(self)\n        \n        # Convert start_time and end_time to indices\n        start_index = self.time_to_index(start_time)\n        end_index = self.time_to_index(end_time)\n        \n        # Slice each attribute in the data dictionary\n        if self.data and isinstance(self.data, dict):\n            for key in self.data:\n                sliced_object.data[key] = self.data[key][start_index:end_index]\n        \n        return sliced_object\n\n# just a simple example of usage\ntime_series = TimeSeries({\n    'temperature': [20, 21, 22, 23, 24, 25],\n    'humidity': [30, 31, 32, 33, 34, 35]\n})\n\n# Assume hypothetical time indices corresponding to the positions in the lists\n# time_to_index would be a method mapping times to these indices e.g., 0, 1, 2, etc.\n\n# This example won't execute correctly since the time_to_index function\n# and the real scenario for time and indices mapping are not implemented.", "CodeBleu_score": 40.64719883034951}, {"code": "import copy\nimport bisect\n\nclass TimeSeriesData:\n    def __init__(self, timestamps, data1, data2):\n        self.timestamps = timestamps\n        self.data1 = data1\n        self.data2 = data2\n    \n    def slice(self, start_time, end_time):\n        \"\"\"\n        This function, slice, creates a copy of the object and slices its attributes between the specified start_time and end_time.\n        It finds the corresponding indices for the start and end times, makes a deep copy of the object,\n        and updates each attribute of the copied object to contain only the sliced data.\n        Finally, it returns the copied and sliced object.\n        \"\"\"\n        # Use bisect to find the indices for slicing the data\n        start_index = bisect.bisect_left(self.timestamps, start_time)\n        end_index = bisect.bisect_right(self.timestamps, end_time)\n        \n        # Deep copy the full object\n        sliced_object = copy.deepcopy(self)  # Deep copy to ensure there are no shared references\n        \n        # Update the attributes in the copy with the sliced data\n        sliced_object.timestamps = sliced_object.timestamps[start_index:end_index]\n        sliced_object.data1 = sliced_object.data1[start_index:end_index]\n        sliced_object.data2 = sliced_object.data2[start_index:end_index]\n        \n        return sliced_object\n\n# Example usage:\ntimes = [1, 2, 3, 4, 5]\ndata1 = [10, 20, 30, 40, 50]\ndata2 = ['a', 'b', 'c', 'd', 'e']\n\nts = TimeSeriesData(times, data1, data2)\nsliced_ts = ts.slice(2, 4)\nprint(sliced_ts.timestamps)  # [2, 3, 4]\nprint(sliced_ts.data1)      # [20, 30, 40]\nprint(sliced_ts.data2)      # ['b', 'c', 'd']", "CodeBleu_score": 36.525319705903634}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "import numpy as np\n\nclass WaypointHandler:\n    def __init__(self):\n        self.points = []\n        self.yaw_angles = []\n        self.msg_times = []\n        self.bag_times = []\n        self.last_point = None\n        self.last_yaw = None\n\n    def append_waypoint(self, waypoint_msg, msg_time, bag_time):\n        \"\"\"This function, append_waypoint, appends data from a waypoint message to its corresponding arrays.\n        It extracts the position and rotation, converts the rotation to Euler angles, and creates a Point object.\n        It checks if the current waypoint is different from the last one by comparing position and yaw values.\n        If the waypoint is different, it appends the new point, yaw, and corresponding times to their respective arrays.\"\"\"\n\n        # Extract position and orientation from waypoint_msg\n        position = waypoint_msg.pose.position  # Assume `position` has x, y, z\n        orientation = waypoint_msg.pose.orientation  # Assume `orientation` has x, y, z, w\n\n        # Convert quaternion to Euler angles, assuming yaw is the rotation around the z-axis\n        euler_angles = self.quaternion_to_euler(orientation)\n        yaw = euler_angles[2]  # yaw is typically the third component in Euler angles\n\n        # Create Point object from position\n        point = (position.x, position.y, position.z)\n\n        # Compare with the last waypoint\n        if self.last_point is None or self.last_point != point or self.last_yaw != yaw:\n            self.points.append(point)\n            self.yaw_angles.append(yaw)\n            self.msg_times.append(msg_time)\n            self.bag_times.append(bag_time)\n\n            # Update last point and yaw\n            self.last_point = point\n            self.last_yaw = yaw\n\n    def quaternion_to_euler(self, quaternion):\n        \"\"\"Convert quaternion (x, y, z, w) to Euler angles.\"\"\"\n        x, y, z, w = quaternion.x, quaternion.y, quaternion.z, quaternion.w\n        # formulas for conversion from quaternion to Euler angles (roll, pitch, yaw)\n        t0 = +2.0 * (w * x + y * z)\n        t1 = +1.0 - 2.0 * (x * x + y * y)\n        roll = np.arctan2(t0, t1)\n\n        t2 = +2.0 * (w * y - z * x)\n        t2 = +1.0 if t2 > +1.0 else t2\n        t2 = -1.0 if t2 < -1.0 else t2\n        pitch = np.arcsin(t2)\n\n        t3 = +2.0 * (w * z + x * y)\n        t4 = +1.0 - 2.0 * (y * y + z * z)\n        yaw = np.arctan2(t3, t4)\n\n        return roll, pitch, yaw", "CodeBleu_score": 31.51797898397214}, {"code": "import numpy as np\nfrom scipy.spatial.transform import Rotation as R\n\nclass WaypointHandler:\n    def __init__(self):\n        self.points = []\n        self.yaws = []\n        self.timestamps = []\n\n    def append_waypoint(self, waypoint_msg, msg_time, bag_time):\n        \"\"\"\n        This function, append_waypoint, appends data from a waypoint message to its corresponding arrays.\n        It extracts the position and rotation, converts the rotation to Euler angles, and creates a Point object.\n        It checks if the current waypoint is different from the last one by comparing position and yaw values.\n        If the waypoint is different, it appends the new point, yaw, and corresponding times to their respective arrays.\n        \n        Args:\n        waypoint_msg (object): Waypoint message object containing position and orientation.\n        msg_time (float): The time the message was received.\n        bag_time (float): The time recorded in the bag file.\n        \"\"\"\n        # Assume waypoint_msg has attributes position and orientation.\n        # position has x, y, z and orientation has x, y, z, w (quaternion).\n        \n        # Extracting position\n        x = waypoint_msg.position.x\n        y = waypoint_msg.position.y\n        z = waypoint_msg.position.z\n        \n        # Creating a Point object (could be a namedtuple or simple class)\n        Point = np.array([x, y, z])\n        \n        # Extracting orientation and converting quaternion to Euler angles\n        orientation_q = [waypoint_msg.orientation.x, waypoint_msg.orientation.y, \n                         waypoint_msg.orientation.z, waypoint_msg.orientation.w]\n        r = R.from_quat(orientation_q)\n        euler_angles = r.as_euler('xyz', degrees=False)  # Assumed radians; change to 'deg' if degrees are required\n        \n        yaw = euler_angles[2]  # Assuming yaw is the rotation around z-axis in XYZ convention\n        \n        if not self.points:  \n            append_new = True\n        else:\n            # Compare current Point and yaw with the last element in the lists\n            last_point = self.points[-1]\n            last_yaw = self.yaws[-1]\n            \n            position_difference = np.linalg.norm(last_point - Point)\n            yaw_difference = abs(last_yaw - yaw)\n            \n            # Append new waypoint if significant difference is observed\n            # A threshold for comparing if two positions/yaw differ could be defined as needed\n            append_new = position_difference > 1e-6 or yaw_difference > 1e-6  # Example threshold values\n        \n        # Append to the arrays if determined to be a new waypoint\n        if append_new:\n            self.points.append(Point)\n            self.yaws.append(yaw)\n            self.timestamps.append((msg_time, bag_time))\n\n# Example usage\n# Initialize handler\nwaypoint_handler = WaypointHandler()\n# Append waypoint assuming 'WaypointMsg' and such structures are defined appropriately\n# waypoint_handler.append_waypoint(waypoint_msg, msg_time, bag_time)", "CodeBleu_score": 35.73482338745676}, {"code": "import numpy as np\nfrom math import atan2, asin\n\nclass WaypointProcessor:\n    def __init__(self):\n        self.points = []\n        self.yaws = []\n        self.msg_times = []\n        self.bag_times = []\n\n    def append_waypoint(self, waypoint_msg, msg_time, bag_time):\n        \"\"\"\n        Appends data from a waypoint message to its corresponding arrays.\n        Extracts the position and rotation, converts the rotation to Euler angles (focus on yaw),\n        and checks if the current waypoint is different from the last one by comparing position and yaw values.\n        If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays.\n        \"\"\"\n        # Extract position and quaternion\n        x, y, z = waypoint_msg['position']\n        qx, qy, qz, qw = waypoint_msg['rotation']\n        \n        # Convert quaternion to Euler angles (focusing on yaw)\n        # Formula used: yaw (z-axis rotation)\n        yaw = atan2(2.0 * (qw * qz + qx * qy), 1.0 - 2.0 * (qy * qy + qz * qz))\n        \n        # Create a point object (using numpy for simplicity)\n        point = np.array([x, y, z])\n        \n        # Check if this is the first point or if the point is different from the last one\n        if len(self.points) == 0 or (np.any(self.points[-1] != point) or self.yaws[-1] != yaw):\n            # Append data to arrays\n            self.points.append(point)\n            self.yaws.append(yaw)\n            self.msg_times.append(msg_time)\n            self.bag_times.append(bag_time)\n\n# Example usage:\nprocessor = WaypointProcessor()\nprocessor.append_waypoint({'position': (1, 2, 3), 'rotation': (0, 0, 0, 1)}, 1234567890, 1234567890)", "CodeBleu_score": 31.84885646544005}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "class IMUDataCollector:\n    def __init__(self):\n        self.accel_x = []\n        self.accel_y = []\n        self.accel_z = []\n        self.time_msgs = []\n        self.bag_times = []\n\n    def extract_imu_topics(self, topic, msg, bag_time):\n        \"\"\"\n        This function, extract_imu_topics, appends IMU topic message content to acceleration attributes.\n        It converts the message timestamp to seconds.\n        For each IMU topic, if the topic matches, it appends the linear acceleration data to the corresponding x, y, and z attributes.\n        It also appends the message time and bag time to the time attributes.\n\n        :param topic: String, the topic name to check\n        :param msg: Message object, expected to have linear_acceleration attribute with x, y, z\n        :param bag_time: Float, the time stamp from the bag\n        \"\"\"\n        \n        # Check if the provided message matches the IMU data structure\n        if hasattr(msg, 'linear_acceleration'):\n            # Append data to the corresponding attributes\n            self.accel_x.append(msg.linear_acceleration.x)\n            self.accel_y.append(msg.linear_acceleration.y)\n            self.accel_z.append(msg.linear_acceleration.z)\n\n            # Convert ROS Time to seconds (if using ROS)\n            time_in_sec = msg.header.stamp.to_sec() if hasattr(msg.header.stamp, 'to_sec') else msg.header.stamp\n\n            # Append times to the lists\n            self.time_msgs.append(time_in_sec)\n            self.bag_times.append(bag_time)\n\n# Example usage:\n# Assuming msg is an object with a .linear_acceleration attribute (with x, y, z) and .header.stamp (timestamp)\n# imu_collector = IMUDataCollector()\n# imu_collector.extract_imu_topics('/imu', imu_message, 1234567890.123)", "CodeBleu_score": 26.79343198927795}, {"code": "class IMUDataProcessor:\n    def __init__(self):\n        # Initialize lists to store acceleration data and times\n        self.x_acc = []\n        self.y_acc = []\n        self.z_acc = []\n        self.msg_times = []\n        self.bag_times = []\n\n    def extract_imu_topics(self, topic, msg, bag_time):\n        \"\"\"\n        This function, extract_imu_topics, appends IMU topic message content to acceleration attributes.\n        It converts the message timestamp to seconds.\n        For each IMU topic, if the topic matches, it appends the linear acceleration data to the corresponding x, y, and z attributes.\n        It also appends the message time converted to seconds and bag time to the time attributes.\n\n        :param topic: The topic of the message.\n        :param msg: The message object containing fields like linear acceleration.\n        :param bag_time: The timestamp when the message was recorded in the bag file.\n        \"\"\"\n        expected_imu_topic = '/imu/data'\n        if topic == expected_imu_topic:\n            # Extracting accelerations from the message assuming it has linear_acceleration attributes\n            acc = msg.linear_acceleration\n            self.x_acc.append(acc.x)\n            self.y_acc.append(acc.y)\n            self.z_acc.append(acc.z)\n\n            # Assuming 'msg.header.stamp' provides the ROS time which needs to be converted to seconds\n            # msg.header.stamp might typically be in a format like rospy.Time or similar\n            msg_time_sec = msg.header.stamp.to_sec()  # Converts timestamp to seconds\n\n            # Appending the converted message time and bag time to the lists\n            self.msg_times.append(msg_time_sec)\n            self.bag_times.append(bag_time)", "CodeBleu_score": 29.607348322633726}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n\u5206\u6790\u5931\u8d25", "CodeBleu_score": 3.103277060575968}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "import matplotlib.pyplot as plt\n\nclass AccelerationPlotter:\n    def __init__(self, acceleration_data, save_plots=False, output_directory='plots', plot_prefix='acceleration'):\n        \"\"\"\n        Initializes the AccelerationPlotter with acceleration data and configuration for saving plots.\n\n        :param acceleration_data: A dictionary containing 'time' and 'x', 'y', 'z' components.\n        :param save_plots: Boolean to indicate whether to save plots to files.\n        :param output_directory: Directory path where plots will be saved.\n        :param plot_prefix: The prefix to use for filenames when saving plots.\n        \"\"\"\n        self.acceleration_data = acceleration_data\n        self.save_plots = save_plots\n        self.output_directory = output_directory\n        self.plot_prefix = plot_prefix\n    \n    def plot_accelerations(self, plot_suffix=None):\n        \"\"\"\n        Generates and saves a plot of acceleration data.\n        Creates a figure with a title and a subplot for accelerations.\n        Plots the x, y, and z components over time with different colors and labels.\n        Adds labels for the x and y axes and includes a legend.\n        If saving plots is enabled, constructs a filename based on a prefix and optional suffix and saves the plot as a PNG file.\n        \"\"\"\n        plt.figure(figsize=(10, 6))\n        plt.title('Acceleration Data Over Time')\n        plt.plot(self.acceleration_data['time'], self.acceleration_data['x'], label='X Component', color='r')\n        plt.plot(self.acceleration_data['time'], self.acceleration_data['y'], label='Y Component', color='g')\n        plt.plot(self.acceleration_data['time'], self.acceleration_data['z'], label='Z Component', color='b')\n        plt.xlabel('Time (s)')\n        plt.ylabel('Acceleration (m/s^2)')\n        plt.legend()\n\n        if self.save_plots:\n            filename = f'{self.plot_prefix}_{\"acceleration\" + (\"_\" + plot_suffix if plot_prefix else \"\")}.png'\n            filepath = f'{self.output_directory}/{filename}'\n            plt.savefig(filepath)\n            print(f\"Plot saved as {filepath}\")\n\n        plt.show()", "CodeBleu_score": 29.797901770975965}, {"code": "import matplotlib.pyplot as plt\n\nclass AccelerationPlotter:\n    def __init__(self, acceleration_data, save_plots=False, save_path='plots/'):\n        \"\"\"\n        :param acceleration_data: A dictionary with keys 'time', 'x', 'y', 'z' for time series data of accelerations.\n        :param save_plots: Boolean indicating whether plots should be saved to file.\n        :param save_path: Path where plots should be saved.\n        \"\"\"\n        self.acceleration_data = acceleration_data\n        self.save_plots = save_plots\n        self.save_path = save_path\n\n    def plot_accelerations(self, plot_suffix=None):\n        \"\"\"Generates and saves a plot of acceleration data.\"\"\"\n        # Create a plot\n        plt.figure()\n        plt.title('Acceleration Data Over Time')\n        plt.xlabel('Time (s)')\n        plt.ylabel('Acceleration (m/s\u00b2)')\n\n        # Plot x, y, z accelerations with different colors and labels\n        colors = {'x': 'r', 'y': 'g', 'z': 'b'}\n        for component in ['x', 'y', 'z']:\n            plt.plot(self.acceleration_data['time'], self.acceleration_data[component], \n                     color=colors[component], label=f'{component}-axis')\n\n        # Add a legend\n        plt.legend()\n\n        # If enabled, save the plot to a file\n        if self.save_plots:\n            filename = f'acc_plot{plot_suffix if plot_suffix is not None else \"\"}.png'\n            complete_path = self.save_path + filename\n            plt.savefig(complete_path)\n            print(f'Plot saved to {complete_path}')\n\n        # Show the plot\n        plt.show()\n\n# Example usage:\naccel_data = {\n    'time': [0, 1, 2, 3, 4],\n    'x': [0.0, 1.2, 2.3, 3.4, 4.5],\n    'y': [0.1, 1.1, 2.1, 3.1, 4.1],\n    'z': [0.2, 1.0, 2.0, 3.0, 4.0]\n}\nplotter = AccelerationPlotter(accel_data, save_plots=True)\nplotter.plot_accelerations('_example')", "CodeBleu_score": 28.08832857689068}, {"code": "import matplotlib.pyplot as plt\n\nclass AccelerationDataPlotter:\n    def __init__(self, data, save_plots=False, plot_prefix='accel_plot'):\n        \"\"\"\n        :param data: A dictionary with keys 'time', 'x', 'y', and 'z' representing the respective data components.\n        :param save_plots: A boolean flag to determine whether plots should be saved.\n        :param plot_prefix: A string representing the prefix to use in saved plot filenames.\n        \"\"\"\n        self.data = data\n        self.save_plots = save_plots\n        self.plot_prefix = plot_prefix\n\n    def plot_accelerations(self, plot_suffix=None):\n        \"\"\"Plot and possibly save a plot of acceleration data.\"\"\"\n        plt.figure()\n        plt.title(\"Acceleration Data Over Time\")\n        plt.plot(self.data['time'], self.data['x'], label='X acceleration', color='r')\n        plt.plot(self.data['time'], self.data['y'], label='Y acceleration', color='g')\n        plt.plot(self.data['time'], self.data['z'], label='Z acceleration', color='b')\n\n        plt.xlabel(\"Time (s)\")\n        plt.ylabel(\"Acceleration (m/s^2)\")\n        plt.legend()\n\n        if self.save_plots:\n            filename = f\"{self.plot_prefix}\"\n            if plot_suffix:\n                filename += f\"_{plot_suffix}\"\n            filename += \".png\"\n            plt.savefig(filename)\n            print(f\"Plot saved as {filename}\")\n\n        plt.show()\n\n# Example usage:\n# accel_data = {'time': [0, 1, 2], 'x': [0, 0.5, 1.0], 'y': [0, -0.3, -0.6], 'z': [0, 0.1, 0.2]}\n# plotter = AccelerationDataPlotter(accel_data, save_plots=True)\n# plotter.plot_accelerations(\"test_suffix\")", "CodeBleu_score": 30.383802590396776}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indices):\n    \"\"\"This function, compare_positions, compares the positions of multiple poses based on their indices.\n    It requires at least two pose indices to perform comparisons.\n    For each pose index, it compares the position with all subsequent pose indices using the compare_two_xyz function.\"\"\"\n\n    if len(pose_indices) < 2:\n        raise ValueError(\"At least two pose indices are required for comparison.\")\n\n    # Loop over each pose index\n    for i in range(len(pose_indices)):\n        # Compare with each subsequent pose index\n        for j in range(i + 1, len(pose_indices)):\n            # Assume compare_two_xyz is a method of the class that compares two poses by their indices.\n            comparison_result = self.compare_two_xyz(pose_indices[i], pose_indices[j])\n            # You can modify this part as necessary, e.g., store results or print them.\n            print(f\"Comparison between poses at index {pose_indices[i]} and {pose_indices[j]}: {comparison_result}\")", "CodeBleu_score": 35.47012728675596}, {"code": "def compare_positions(self, pose_indices):\n    \"\"\"This function, compare_positions, compares the positions of multiple poses based on their indices.\n    It requires at least two pose indices to perform comparisons.\n    For each pose index, it compares the position with all subsequent pose indices using the compare_two_xyz function.\n\n    Parameters:\n    pose_indices (list): A list of indices representing the poses to compare.\n\n    Returns:\n    list of tuples: Each tuple contains the pair of indices compared and the result of their comparison.\n    \"\"\"\n    if len(pose_indices) < 2:\n        raise ValueError(\"At least two indices are required to perform comparisons.\")\n\n    comparison_results = []\n    for i in range(len(pose_indices)):\n        for j in range(i + 1, len(pose_indices)):\n            pose1_index = pose_indices[i]\n            pose2_index = pose_indices[j]\n            # Assume get_pose_by_index is a method that retrieves a pose given its index\n            pose1 = self.get_pose_by_index(pose1_index)\n            pose2 = self.get_pose_by_index(pose2_index)\n            # Assume compare_two_xyz compares the positions of two poses and returns some form of comparison result\n            result = self.compare_two_xyz(pose1, pose2)\n            comparison_results.append((pose1_index, pose2_index, result))\n    \n    return comparison_results", "CodeBleu_score": 31.90962601645791}, {"code": "class Robot:\n    def __init__(self):\n        # Example of some poses each denoted by its x, y, z coordinates.\n        self.poses = [\n            {'x': 0, 'y': 0, 'z': 0},\n            {'x': 1, 'y': 1, 'z': 1},\n            {'x': 2, 'y': 2, 'z': 2},\n            {'x': 3, 'y': 3, 'z': 3}\n        ]\n\n    def compare_two_xyz(self, pose_a, pose_b):\n        \"\"\"Compare two poses based on their coordinates.\n\n        Args:\n            pose_a (dict): First pose with x, y, and z coordinates.\n            pose_b (dict): Second pose with x, y, and z coordinates.\n\n        Returns:\n            float: Distance or some metric of comparison between the two poses.\n        \"\"\"\n        # Example comparison metric (Euclidean distance)\n        return ((pose_a['x'] - pose_b['x'])**2 + (pose_a['y'] - pose_b['y'])**2 + (pose_a['z'] - pose_b['z'])**2) ** 0.5\n\n    def compare_positions(self, pose_indeces):\n        \"\"\"This function, compare_positions, compares the positions of multiple poses based on their indices.\n        It requires at least two pose indices to perform comparisons.\n        For each pose index, it compares the position with all subsequent pose indices using the compare_two_xyz function.\n\n        Args:\n            pose_indeces (list of int): List of indices referring to self.poses that should be compared.\n\n        Returns:\n            dict: A dictionary with tuple keys of pose index pairs and values or their comparison results.\n        \"\"\"\n        if len(pose_indeces) < 2:\n            raise ValueError(\"At least two pose indices are required\")\n\n        comparison_results = {}\n        for i in range(len(pose_indeces)):\n            for j in range(i + 1, len(pose_indeces)):\n                idx1, idx2 = pose_indeces[i], pose_indeces[j]\n                pose1, pose2 = self.poses[idx1], self.poses[idx2]\n                result = self.compare_two_xyz(pose1, pose2)\n                comparison_results[(idx1, idx2)] = result\n\n        return comparison_results", "CodeBleu_score": 31.741491060141453}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "class CollisionDetector:\n    def __init__(self, wrench):\n        \"\"\"\n        Initialize the CollisionDetector with a list of collision events.\n        Each event in wrench is expected to be a dictionary containing a 'time' key among other possible keys.\n        \"\"\"\n        self.wrench = wrench\n\n    def get_collisions(self, start_time=None, end_time=None):\n        \"\"\"\n        Retrieves collision times within a specified time range.\n\n        Args:\n        start_time (float or None): The start of the time range. If None, it defaults to negative infinity.\n        end_time (float or None): The end of the time range. If None, it defaults to positive infinity.\n\n        Returns:\n        list of float: A list containing the times of collisions that occurred within the specified time range.\n        \"\"\"\n        # Initialize an empty list for collision times.\n        collision_times = []\n\n        # Set default values for start_time and end_time if they are None.\n        if start_time is None:\n            start_time = float('-inf')\n        if end_time is None:\n            end_time = float('inf')\n\n        # Iterate through each collision's time\n        for event in self.wrench:\n            # Assume each event in wrench has a 'time' key.\n            if start_time <= event['time'] <= end_time:\n                # If the time is within the range, append it to the list\n                collision_times.append(event['time'])\n\n        # Return the list of collision times\n        return collision_times", "CodeBleu_score": 30.79176877995974}, {"code": "def get_collisions(self, start_time=None, end_time=None):\n    \"\"\"\n    This function retrieves collision times within a specified time range.\n    It initializes an empty list for collision times.\n    It iterates through each collision's time in self.wrench, and if the time is within\n    the start_time and end_time range, it appends the time to the collision_times list.\n    Finally, it returns the list of collision times.\n\n    Args:\n    start_time (float, optional): The start time for filtering collision times. Defaults to None.\n    end_time (float, optional): The end time for filtering collision times. Defaults to None.\n\n    Returns:\n    list: A list of collision times within the specified time range.\n    \"\"\"\n\n    collision_times = []\n\n    # Assuming self.wrench contains elements with attribute 'time' that holds the relevant collision times\n    for collision in self.wrench:\n        if collision.time is not None and (start_time is None or collision.time >= start_time) and (end_time is None or collision.time <= end_time):\n            collision_times.append(collision.time)\n\n    return collision_times", "CodeBleu_score": 55.30495878285955}, {"code": "class CollisionDetector:\n    def __init__(self, wrench):\n        self.wrench = wrench\n\n    def get_collisions(self, start_time=None, end_time=None):\n        \"\"\"\n        Retrieves collision times within a specified time range.\n        \n        Args:\n            start_time (Optional[int/float]): The start of the time range.\n            end_time (Optional[int/float]): The end of the time range.\n            \n        Returns:\n            list: A list of times where collisions occurred within the specified range.\n        \"\"\"\n        collision_times = []\n        \n        # Iterate over each collision in wrench\n        for collision in self.wrench:\n            # Extract the time of the collision\n            collision_time = collision['time']\n            \n            # Check if the start_time and end_time conditions are met\n            if (start_time is None or collision_time >= start_time) and (end_time is None or collision_time <= end_time):\n                collision_times.append(collision_time)\n        \n        return collision_times", "CodeBleu_score": 42.163519054089264}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time, x_range, plot_suffix):\n    \"\"\"\n    This function, plot_angular_velocities, plots angular velocities over a specified time range.\n    It calculates the absolute settling time by adding the settling time to the start time.\n    Then, it calls analyze_bag.plot_angular_velocities with the specified start time, end time, \n    settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5].\n\n    Arguments:\n    analyze_bag -- object responsible for data analysis and plotting functions\n    start_time -- float, starting time (in seconds) for the data plot\n    end_time -- float, ending time (in seconds) for the data plot\n    settling_time -- float, additional time that adds to the start time (in seconds)\n    x_range -- tuple, the range of values to display on the x-axis\n    plot_suffix -- str, suffix to append to the plot title or filename\n\n    Returns:\n    None, results in a plotted graph via analyze_bag.plot method.\n    \"\"\"\n    # Calculate the absolute settling time (start_time + settling_time)\n    absolute_settling_time = start_time + settling_time\n    \n    # Set the y-axis range\n    y_range = [-1.5, 1.5]\n    \n    # Call the plotting function of analyze_bag with the computed and given parameters\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, y_range, plot_suffix)", "CodeBleu_score": 37.49990476886714}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time, x_range, plot_suffix):\n    \"\"\"\n    This function, plot_angular_velocities, plots angular velocities over a specified time range.\n    It calculates the absolute settling time by adding the settling time to the start time.\n    Then, it calls analyze_bag.plot_angular_velocities with the specified start time, end time,\n    settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5].\n    \"\"\"\n    # Calculate absolute settling time by adding settling time to the start time\n    absolute_settling_time = start_time + settling_time\n    \n    # Define the y-axis range\n    y_range = [-1.5, 1.5]\n    \n    # Call the plot_angular_velocities method with the calculated values and fixed y-axis range\n    analyze_bag.plot_angular_velocities(start_time=start_time, \n                                        end_time=end_time,\n                                        settling_time=absolute_settling_time, \n                                        x_range=x_range, \n                                        plot_suffix=plot_suffix,\n                                        y_range=y_range)", "CodeBleu_score": 46.61348840099537}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time, x_range, plot_suffix):\n    \"\"\"\n    This function, plot_angular_velocities, plots angular velocities over a specified time range.\n    It calculates the absolute settling time by adding the settling time to the start time.\n    Then, it calls analyze_bag.plot_angular_velocities with the specified start time, end time, \n    settling time, x-axis range, plot suffix, and a fixed y-axis range of [-1.5, 1.5].\n\n    Parameters:\n        analyze_bag: Object that possesses the method plot_angular_velocities for plotting.\n        start_time: float or datetime, representing the starting time for the data to plot.\n        end_time: float or datetime, representing the ending time for the data to plot.\n        settling_time: float, an additional time added to start_time to allow the system to stabilize.\n        x_range: tuple or list with 2 elements, defining the visible range of x-axis on the plot.\n        plot_suffix: str, a suffix to distinguish the plot or use in naming the plot file.\n\n    Returns:\n        None. However, it produces a plot of the angular velocities.\n    \"\"\"\n\n    # Calculate absolute settling time by adding settling time to the start time\n    absolute_settling_time = start_time + settling_time\n\n    # Define the y-axis range\n    y_range = [-1.5, 1.5]\n\n    # Call the plot method with all required parameters\n    analyze_bag.plot_angular_velocities(start_time=start_time, \n                                        settling_time=absolute_settling_time,\n                                        end_time=end_time, \n                                        x_range=x_range,\n                                        y_range=y_range,\n                                        plot_suffix=plot_suffix)", "CodeBleu_score": 48.94413827524301}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "#include <Eigen/Dense>\n#include <iostream>\n#include <random>\n\nclass D435DepthNoiseModel {\npublic:\n    float plane_fit_error = 0.001f;  // Example parameter\n    float depth_scale = 0.001f;      // Example parameter\n    float bad_point = std::numeric_limits<float>::quiet_NaN();\n\n    void ApplyNoise(const uint32_t width,\n                    const uint32_t height, float *data) {\n\n        if (data == nullptr) {\n            std::cerr << \"Data pointer is null. Exiting function.\" << std::endl;\n            return;\n        }\n\n        // Calculate the noise multiplier\n        float multiplier = plane_fit_error / (depth_scale * depth_scale);\n\n        // Mapping the data to an Eigen vector\n        Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> depthMap(data, height, width);\n\n        // Calculate RMS noise based on imaging conditions\n        float rms_noise = 0.001f; // placeholder for actual computation\n\n        // Random number generation for noise application\n        std::default_random_engine generator;\n        std::normal_distribution<float> distribution(0.0f, rms_noise);\n\n        // Apply noise\n        for (int i = 0; i < height; ++i) {\n            for (int j = 0; j < width; ++j) {\n                float noise = distribution(generator);\n                float pixelValue = depthMap(i, j);\n\n                if (pixelValue > 0) { // Check if the pixel value is within valid range\n                    depthMap(i, j) += noise;\n                } else {\n                    // If outside range, set to bad point value\n                    depthMap(i, j) = bad_point;\n                }\n            }\n        }\n    }\n};\n\n// Example usage\nint main() {\n    const uint32_t width = 640;\n    const uint32_t height = 480;\n    float* depthData = new float[width * height];\n    \n    // Initialize with some example data\n    for (uint32_t i = 0; i < height*width; ++i)\n        depthData[i] = ((i % 100) / 100.0f) * depth_scale;\n\n    D435DepthNoiseModel noiseModel;\n    noiseModel.ApplyNoise(width, height, depthData);\n\n    delete[] depthData;\n    return 0;\n}", "CodeBleu_score": 45.08279985964825}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width, const uint32_t height, float *data) {\n    // Check if the data pointer is null\n    if (!data) {\n        return;\n    }\n\n    // Define some camera parameters (these values are placeholders and should be adjusted based on actual camera parameters)\n    const float depthScale = 0.001f; // typically depth cameras have a scale in mm to meters\n    const float noiseAmplitude = 0.005f; // amplitude of noise, may need to be adjusted\n    float badPointValue = 0.f; // setting to 0 as typically used for invalid depth value\n\n    // Looping through all pixels\n    for (uint32_t j = 0; j < height; ++j) {\n        for (uint32_t i = 0; i < width; ++i) {\n            // Calculating index in 1D array for given (i, j)\n            uint32_t index = j * width + i;\n            \n            // Get the original depth value\n            float originalDepth = data[index];\n\n            // Check if the current depth value is valid \n            if (originalDepth <= 0) {\n                data[index] = badPointValue;\n            } else {\n                // Combine noise parameters and image constraints to produce reasonable noise\n                float depthInMeters = originalDepth * depthScale; // Convert depth to meters\n                float rmsNoise = noiseAmplitude * sqrt(depthInMeters); // Calculate noise based on depth\n                float noise = rmsNoise * ((rand() % 2000 - 1000) / 1000.0f); // Generate random noise\n\n                // Add noise to original depth\n                float noisyDepth = originalDepth + noise / depthScale; // Convert noise back to original scale and apply\n\n                // Check if noisy pixel is out of valid range after noise addition and correct it\n                if (noisyDepth < 0) {\n                    data[index] = badPointValue;\n                } else {\n                    data[index] = noisyDepth;\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 36.31678703668661}, {"code": "#include <iostream>\n#include <Eigen/Dense>\n#include <random>\n\nclass D435DepthNoiseModel {\npublic:\n    // Assuming some typical camera parameters as private members for the model\n    float depth_scale_ = 0.001f;    // Assumed scale to convert depth units\n    float noise_factor_ = 0.05f;    // Noise amplification factor\n    float bad_point_value_ = 0.0f;  // Value to denote invalid or out of range depth\n\n    void ApplyNoise(const uint32_t width, const uint32_t height, float *data) {\n        if (data == nullptr) {\n            std::cerr << \"Data pointer is null.\" << std::endl;\n            return;\n        }\n\n        // Calculating noise multiplier based on depth scale\n        float multiplier = depth_scale_ * noise_factor_;\n\n        // Mapping the data to an Eigen vector for easier manipulation\n        Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> depth_map(data, height, width);\n        \n        // Create a random number generator for noise\n        std::default_random_engine generator;\n        std::normal_distribution<float> distribution(0.0, 1.0);\n\n        // Compute the RMS noise and apply noise based on the normal distribution\n        float rms_noise = 0.0f;\n\n        for (int row = 0; row < depth_map.rows(); ++row) {\n            for (int col = 0; col < depth_map.cols(); ++col) {\n                float raw_depth = depth_map(row, col);\n\n                // Check pixel range and add noise\n                if (raw_depth > 0) {\n                    float noise = distribution(generator) * multiplier;\n                    float noisy_depth = raw_depth + noise;\n\n                    // Check if the noisy depth is out of valid range, if so, mark as bad point\n                    if (noisy_depth < 0 || noisy_depth > 10) {  // Assuming 10m as the range limit for depth\n                        depth_map(row, col) = bad_point_value_;\n                    } else {\n                        depth_map(row, col) = noisy_depth;\n                        rms_noise += noise * noise;  // Summing squares of noise for RMS calculation\n                    }\n                } else {\n                    depth_map(row, col) = bad_point_value_;  // Marking invalid depths directly\n                }\n            }\n        }\n\n        rms_noise = sqrt(rms_noise / (width * height));  // Final RMS noise calculation\n        std::cout << \"Applied RMS Noise: \" << rms_noise << \" units\" << std::endl;\n    }\n};\n\n// Example usage\nint main() {\n    const uint32_t width = 640;\n    const uint32_t height = 480;\n    float *depthData = new float[width * height] {1.2f, 0.5f, 0.6f}; // Example depth data initialization\n\n    D435DepthNoiseModel model;\n    model.ApplyNoise(width, height, depthData);\n    \n    delete[] depthData;  // Clean up the allocated memory\n    return 0;\n}", "CodeBleu_score": 40.60152346429562}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "#include \"ros/ros.h\"\n#include \"trajectory_msgs/MultiDOFJointTrajectory.h\"\n#include \"rosbag/bag.h\"\n#include <gazebo/common/Time.hh>\n#include <gazebo/physics/physics.hh>\n\nclass GazeboBagPlugin {\npublic:\n    GazeboBagPlugin() : bag(\"trajectory.bag\", rosbag::bagmode::Write) {}\n\n    ~GazeboBagPlugin() {\n        bag.close();\n    }\n\n    void WaypointCallback(const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg) {\n        // Step 1: Get Current simulation time from Gazebo\n        gazebo::common::Time sim_time = gazebo::physics::get_world()->SimTime();\n\n        // Step 2: Convert Gazebo simulation time to ROS time\n        ros::Time ros_time(sim_time.sec, sim_time.nsec);\n\n        // Step 3: Write the trajectory message to the bag file\n        bag.write(\"/waypoint_topic\", ros_time, *trajectory_msg);\n    }\n\nprivate:\n    rosbag::Bag bag;\n};", "CodeBleu_score": 43.84770438373186}, {"code": "#include <ros/ros.h>\n#include <gazebo/common/Time.hh>\n#include <gazebo/physics/World.hh>\n\nvoid GazeboBagPlugin::WaypointCallback(const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg) {\n    // Get the current simulation time from Gazebo\n    gazebo::common::Time curr_sim_time = world_->SimTime();\n\n    // Convert Gazebo simulation time to ROS time\n    ros::Time current_time_ros(curr_sim_time.sec, curr_sim_time.nsec);\n\n    // Assume class has members for storing the ROS bag and the necessary topic details\n    std::string full_topic_name = namespace_ + \"/\" + waypoint_topic_;\n\n    // Write the trajectory message to the ROS bag, with timestamp\n    if (rosbag) {\n        // Ensure the bag is opened for writing\n        rosbag->write(full_topic_name, current_time_ros, trajectory_msg);\n    } else {\n        ROS_ERROR(\"ROS Bag file is not open for writing. Failed to log trajectory message.\");\n    }\n    \n    // Debug or info printing to ROS logs\n    ROS_INFO(\"Recorded waypoint to %s at time %d.%d\",  \n             full_topic_name.c_str(), current_time_ros.sec, current_time_ros.nsec);\n}", "CodeBleu_score": 49.563565127718405}, {"code": "#include <ros/ros.h>\n#include <rosbag/bag.h>\n#include <trajectory_msgs/MultiDOFJointTrajectory.h>\n#include <gazebo/common/Time.hh>\n#include <gazebo/msgs/msgs.hh>\n\nnamespace gazebo {\n\nclass GazeboBagPlugin {\npublic:\n    GazeboBagPlugin(const std::string &bag_filename, const std::string &waypoint_topic) \n    : bag_filename_(bag_filename), waypoint_topic_(waypoint_topic) {\n        bag_.open(bag_filename_, rosbag::bagmode::Write);\n    }\n\n    ~GazeboBagPlugin() {\n        if (bag_.isOpen()) {\n            bag_.close();\n        }\n    }\n\n    // Callback function\n    void WaypointCallback(const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg) {\n        // Retrieve current simulation time\n        gazebo::common::Time sim_time = gazebo::msgs::Convert(_msg->sim_time());\n\n        // Convert Gazebo simulation time to ROS time\n        ros::Time ros_time(sim_time.sec, sim_time.nsec);\n\n        // Write the trajectory message to a bag file\n        try {\n            bag_.write(waypoint_topic_, ros_time, trajectory_msg);\n            ROS_INFO(\"Successfully logged waypoint data to topic: %s\", waypoint_topic_.c_str());\n        } catch (const rosbag::BagException& e) {\n            ROS_ERROR(\"Failed to write to bag file: %s\", e.what());\n        }\n    }\n\nprivate:\n    rosbag::Bag bag_;\n    std::string bag_filename_;\n    std::string waypoint_topic_;\n};\n\n} // namespace gazebo", "CodeBleu_score": 37.8753765049362}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now) {\n    // Convert the simulation time to ROS time\n    ros::Time current_time(now.sec, now.nsec);\n\n    // Prepare the ActuatorVelocity message\n    custom_msgs::ActuatorVelocities velocity_msg;\n    velocity_msg.header.stamp = current_time;\n\n    // Assuming that we have a vector of pointers to Joint objects called motorJoints\n    for (size_t i = 0; i < this->motorJoints.size(); ++i) {\n        // Get the current motor joint\n        physics::JointPtr joint = this->motorJoints[i];\n\n        // Get the rotational velocity of the joint, reduced by a factor (e.g., for visualisation or processing)\n        double slowed_velocity = joint->GetVelocity(0) * 0.1;\n\n        // Add this velocity to our message\n        velocity_msg.velocities.push_back(slowed_velocity);\n    }\n\n    // Set the name of the bag file, the namespace, and the topic for the motor velocities\n    std::string bag_namespace = \"robot_simulation\";\n    std::string topic = \"motor_velocities\";\n\n    // Write the message to the bag file\n    if (!this->rosbag.is_open()) {\n        this->rosbag.open(bag_namespace + \".bag\", rosbag::bagmode::Write);\n    }\n    this->rosbag.write(bag_namespace + \"/\" + topic, current_time, velocity_msg);\n\n    // Optionally, print to log or console\n    ROS_INFO(\"Logged motor velocities at time %f\", now.Double());\n}", "CodeBleu_score": 45.16875697022101}, {"code": "#include <ros/ros.h>\n#include <rosbag/bag.h>\n#include <std_msgs/Float64MultiArray.h>\n\nvoid GazeboBagPlugin::LogMotorVelocities(const common::Time now) {\n    // Ensure ROS node handle is initialized\n    if (!ros::ok()) {\n        ROS_INFO(\"ROS is not properly initialized.\");\n        return;\n    }\n\n    // Create a message for actuator velocities\n    std_msgs::Float64MultiArray velocity_msg;\n\n    // Convert Gazebo simulation time to ROS time\n    ros::Time current_time(now.sec, now.nsec);\n\n    // Initialize the array to store velocities\n    velocity_msg.data.clear();\n\n    // Iterate through the motor joints to log their velocities\n    for (auto& joint : motorJoints) {\n        // Get the current velocity of the joint, apply a certain factor if needed\n        double velocity = joint->GetVelocity(0);  // assuming single axis joint\n        double slowed_velocity = velocity * 0.5;  // applying a slowing factor for demonstration\n\n        // Add slowed down velocity to the message\n        velocity_msg.data.push_back(slowed_velocity);\n    }\n\n    // Set the timestamp for the message\n    velocity_msg.header.stamp = current_time;\n\n    // Ensure the bag is open and ready to write\n    if (!bag.isOpen()) {\n        ROS_WARN(\"Bag is not open for writing.\");\n        return;\n    }\n\n    // Construct the topic string using namespace and motor topic\n    std::string velocity_topic = rosNamespace + \"/motor_velocities\";\n\n    // Write the velocity message to the bag file\n    bag.write(velocity_topic, current_time, velocity_msg);\n\n    ROS_INFO(\"Motor velocities logged to bag file.\");\n}", "CodeBleu_score": 40.90756529643448}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now) {\n    // Convert simulation time (Gazebo common::Time) to ROS time\n    ros::Time current_time(now.sec, now.nsec);\n\n    // Prepare ROS message for actuator velocities\n    std_msgs::Float32MultiArray velocity_msg;\n    velocity_msg.data.clear();\n\n    // Iterate over motor joints to get their current velocities\n    for (auto &joint : this->motorJoints) {\n        // Obtain the current rotational velocity of the joint\n        double velocity = joint->GetVelocity(0);\n\n        // Factor in any simulation-specific modifications to the velocity\n        double slowed_velocity = velocity * this->velocityScaleFactor;\n\n        // Append slowed-down velocity to the message data\n        velocity_msg.data.push_back(slowed_velocity);\n    }\n\n    // Set timestamp for the velocity message\n    velocity_msg.layout.dim.push_back(std_msgs::MultiArrayDimension());\n    velocity_msg.layout.dim[0].label = \"velocity\";\n    velocity_msg.layout.dim[0].size = velocity_msg.data.size();\n    velocity_msg.layout.dim[0].stride = 1;\n\n    // Log the velocities to a Rosbag file\n    this->bag.write(this->motorTopic, current_time, velocity_msg);\n\n    // Optionally, log to ROS topic for real-time monitoring\n    this->velocityPublisher.publish(velocity_msg);\n\n    ROS_INFO_STREAM(\"Logged motor velocities at simulation time \" << now.sec << \".\" << now.nsec);\n}", "CodeBleu_score": 44.03620930592298}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg) {\n    \n    // If debug printing is enabled, log the callback invocation\n    if (this->debug_) {\n        gzdbg << \"RollPitchYawrateThrustCallback() was called.\" << std::endl;\n    }\n\n    // Retrieve values from the message\n    double roll_input = roll_pitch_yawrate_thrust_msg->roll();\n    double pitch_input = roll_pitch_yawrate_thrust_msg->pitch();\n    double yawrate_input = roll_pitch_yawrate_thrust_msg->yaw_rate();\n    double thrust_input = roll_pitch_yawrate_thrust_msg->thrust();\n\n    // Convert normalized inputs (-1 to 1) to control surface angles in radians\n    double max_aileron_angle = 0.5;  // Maximum aileron deflection angle in radians\n    double max_elevator_angle = 0.5; // Maximum elevator deflection angle in radians\n    double max_rudder_angle = 0.3;   // Maximum rudder deflection angle in radians\n\n    double aileron_angle = roll_input * max_aileron_angle;\n    double elevator_angle = pitch_input * max_elevator_angle;\n    double rudder_angle = yawrate_input * max_rudder_angle;\n\n    // Set the control surface angles\n    this->model_->SetAileron(aileron_angle);\n    this->model_->SetElevator(elevator_angle);\n    this->model_->SetRudder(rudder_angle);\n\n    // Set the throttle value\n    this->model_->SetThrottle(thrust_input);\n    \n    // Optional debugging output of set values\n    if (this->debug_) {\n        gzdbg << \"Aileron angle set to: \" << aileron_angle << \" rad\" << std::endl;\n        gzdbg << \"Elevator angle set to: \" << elevator_angle << \" rad\" << std::endl;\n        gzdbg << \"Rudder angle set to: \" << rudder_angle << \" rad\" << std::endl;\n        gzdbg << \"Throttle set to: \" << thrust_input << std::endl;\n    }\n}", "CodeBleu_score": 46.316455908398545}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg) {\n    // Check if debugging is enabled and log callback if true\n    if (debug_) {\n        gzdbg << \"RollPitchYawrateThrustCallback called\\n\";\n    }\n\n    // Extract message data\n    double roll = roll_pitch_yawrate_thrust_msg->roll();\n    double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n    double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n    double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n    // Normalize input values and convert to control surface angles in radians\n    double aileron_angle = max_aileron_angle_ * roll; // Assuming these are normalized [-1, 1]\n    double elevator_angle = max_elevator_angle_ * pitch;\n    double rudder_angle = max_rudder_angle_ * yaw_rate;\n\n    // Set control surface angles\n    this->SetControlSurfaceAngles(aileron_angle, elevator_angle, rudder_angle);\n\n    // Set thrust value\n    this->SetThrottle(thrust);\n\n    // Possibly additional operational logging or diagnostics\n    if (debug_) {\n        gzdbg << \"Processed controls: Aileron [\" << aileron_angle \n              << \"] Elevator [\" << elevator_angle \n              << \"] Rudder [\" << rudder_angle \n              << \"] Throttle [\" << thrust << \"]\\n\";\n    }\n}", "CodeBleu_score": 40.47419413847285}, {"code": "#include <iostream>\n\nvoid GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg) {\n    // Check if the debug printing is enabled\n    if (debug_enabled_) {\n        std::cout << \"RollPitchYawrateThrustCallback called.\" << std::endl;\n    }\n\n    // Receive the message and extract values\n    double roll = roll_pitch_yawrate_thrust_msg->roll();\n    double pitch = roll_pitch_yawrate_thrust_msg->pitch();\n    double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate();\n    double thrust = roll_pitch_yawrate_thrust_msg->thrust();\n\n    // Convert roll, pitch and yaw_rate to corresponding angle values for control surfaces\n    double aileron = CalculateAileronAngle(roll);      // function to compute aileron angle based on roll\n    double elevator = CalculateElevatorAngle(pitch);   // function to compute elevator angle based on pitch\n    double rudder = CalculateRudderAngle(yaw_rate);    // function to compute rudder angle based on yaw rate\n\n    // Set throttle based on thrust value\n    double throttle = CalculateThrottleValue(thrust);  // function to compute throttle based on thrust\n\n    // Assigning the computed values back to the simulated control surfaces\n    SetAileron(aileron);\n    SetElevator(elevator);\n    SetRudder(rudder);\n    SetThrottle(throttle);\n\n    // Optionally print the set values if debug mode is enabled\n    if (debug_enabled_) {\n        std::cout << \"Control Surface Angles:\" << std::endl;\n        std::cout << \"Aileron: \" << aileron << \" | Elevator: \" << elevator << \" | Rudder: \" << rudder << std::endl;\n        std::cout << \"Throttle: \" << throttle << std::endl;\n    }\n}\n\n// These function stubs need to be defined to handle the transformation of control inputs to control surface angles and throttle\ndouble CalculateAileronAngle(double roll) {\n    return roll * MAX_AILERON_ANGLE;  // Assuming MAX_AILERON_ANGLE is defined somewhere\n}\ndouble CalculateElevatorAngle(double pitch) {\n    return pitch * MAX_ELEVATOR_ANGLE;  // Assuming MAX_ELEVATOR_ANGLE is defined somewhere\n}\ndouble CalculateRudderAngle(double yaw_rate) {\n    return yaw_rate * MAX_RUDDER_ANGLE;  // Assuming MAX_RUDDER_ANGLE is defined somewhere\n}\ndouble CalculateThrottleValue(double thrust) {\n    return thrust * MAX_THROTTLE;  // Assuming MAX_THROTTLE is defined somewhere\n}\n\nvoid SetAileron(double angle) {\n    // Implementation for setting aileron angle on your vehicle\n}\nvoid SetElevator(double angle) {\n    // Implementation for setting elevator angle on your vehicle\n}\nvoid SetRudder(double angle) {\n    // Implementation for setting rudder angle on your vehicle\n}\nvoid SetThrottle(double value) {\n    // Implementation for setting the throttle on your vehicle\n}", "CodeBleu_score": 40.188195517945694}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "#include <poll.h>\n#include <sys/time.h>\n#include <unistd.h>\n\nvoid GazeboMavlinkInterface::pollForMAVLinkMessages(double _dt, uint32_t _timeoutMs) {\n    // Create a pollfd structure for the file descriptor\n    struct pollfd fds[1];\n    fds[0].fd = fd;        // assuming 'fd' is the file descriptor for the MAVLink connection\n    fds[0].events = POLLIN;\n\n    // Convert _timeoutMs (milliseconds) to a timeval struct\n    struct timeval tv;\n    tv.tv_sec = _timeoutMs / 1000;\n    tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n    // Conduct the poll operation with the timeout\n    int ret = poll(fds, 1, _timeoutMs);\n\n    if (ret == -1) {\n        perror(\"poll\");\n    } else if (ret == 0) {\n        std::cout << \"Timeout occurred! No data within \" << _timeoutMs << \" milliseconds.\" << std::endl;\n    } else {\n        if (fds[0].revents & POLLIN) {\n            // Buffer to store incoming data\n            uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n            ssize_t recsize = recv(fds[0].fd, buffer, sizeof(buffer), 0);\n            \n            if (recsize > 0) {\n                // Process each possible MAVLink message from the buffer\n                mavlink_message_t msg;\n                mavlink_status_t status;\n                for (int i = 0; i < recsize; ++i) {\n                    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n                        // Handle the parsed MAVLink message\n                        handleMAVLinkMessage(msg);\n                    }\n                }\n            } else {\n                perror(\"recv\");\n            }\n        }\n    }\n}\n\nvoid GazeboMavlinkInterface::handleMAVLinkMessage(const mavlink_message_t &msg) {\n    // Implement handling of different MAVLink messages. This is just a placeholder function.\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_HEARTBEAT: {\n            std::cout << \"Received MAVLink heartbeat message\" << std::endl;\n            break;\n        }\n        // Add cases for other relevant message IDs\n    }\n}", "CodeBleu_score": 54.7483533480045}, {"code": "#include <poll.h>\n#include <unistd.h>\n\nvoid GazeboMavlinkInterface::pollForMAVLinkMessages(double _dt, uint32_t _timeoutMs) {\n    struct pollfd fds[1];\n    \n    // Assuming 'fd' is the file descriptor for which we are polling\n    // for incoming MAVLink messages.\n    fds[0].fd = fd;\n    fds[0].events = POLLIN;\n    \n    // Set the timeout for poll()\n    int ret = poll(fds, 1, _timeoutMs);\n\n    if (ret > 0) {\n        if (fds[0].revents & POLLIN) {\n            uint8_t buffer[MAVLINK_MAX_PACKET_LEN];\n            ssize_t nread = read(fd, buffer, sizeof(buffer));\n\n            if (nread > 0) {\n                // Parse the received MAVLink messages\n                mavlink_message_t msg;\n                mavlink_status_t status;\n\n                for (int i = 0; i < nread; ++i) {\n                    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n                        // Handle received message\n                        handleMAVLinkMessage(msg);\n\n                        // Optionally, forward the message to a serial connection\n                        if (serial_enabled) {\n                            write(serial_fd, buffer, nread);\n                        }\n                    }\n                }\n            }\n        }\n    } else if (ret == 0) {\n        // Timeout occurred, no data to read\n        printf(\"No MAVLink message received within timeout.\\n\");\n    } else {\n        // Error occurred during poll\n        perror(\"poll\");\n    }\n}\n\nvoid GazeboMavlinkInterface::handleMAVLinkMessage(const mavlink_message_t& msg) {\n    // Handle the specific MAVLink message based on its type.\n    // This might involve different actions based on message types like COMMAND_ACK, PARAM_VALUE, etc.\n    switch (msg.msgid) {\n        case MAVLINK_MSG_ID_HEARTBEAT:\n            // Process heartbeat message\n            printf(\"Received Heartbeat from MAVLink System %d\\n\", msg.sysid);\n            break;\n        // Add other message handlers as needed\n        default:\n            printf(\"Received MAVLink message with id: %d\\n\", msg.msgid);\n    }\n}", "CodeBleu_score": 48.60773772803586}, {"code": "#include <sys/select.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <errno.h>\n#include <cstring>\n#include <iostream>\n\n#include <mavlink/v2.0/common/mavlink.h>\n\nvoid GazeboMavlinkInterface::pollForMAVLinkMessages(double _dt, uint32_t _timeoutMs) {\n    // Convert timeout in milliseconds to timeval struct\n    struct timeval timeout;\n    timeout.tv_sec = _timeoutMs / 1000;\n    timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n    // File descriptor set\n    fd_set readfds;\n    FD_ZERO(&readfds);\n    FD_SET(fd_, &readfds); // Assuming fd_ is the file descriptor for the MAVLink connection\n\n    // Poll on the file descriptor for incoming data\n    int ret = select(fd_ + 1, &readfds, nullptr, nullptr, &timeout);\n    if (ret == -1) {\n        std::cerr << \"Select error: \" << strerror(errno) << std::endl;\n    } else if (ret > 0) {\n        if (FD_ISSET(fd_, &readfds)) {\n            // We have data to read\n            uint8_t buffer[2048];\n            ssize_t received_len = read(fd_, buffer, sizeof(buffer));\n            if (received_len > 0) {\n                // Process the received data and extract MAVLink messages\n                mavlink_message_t msg;\n                mavlink_status_t status;\n\n                for (int i = 0; i < received_len; ++i) {\n                    if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n                        // Successfully parsed a message\n                        handleMavlinkMessage(msg);\n                        // Optionally forward message\n                        if (fd_serial_ > 0) forwardMessageToSerial(msg);\n                    }\n                }\n            } else {\n                std::cerr << \"Read error or connection closed.\" << std::endl;\n            }\n        }\n    } else {\n        // Timeout with no data\n        std::cout << \"No MAVLink data within timeout interval.\" << std::endl;\n    }\n}\n\n// Handler function for parsed MAVLink messages\nvoid GazeboMavlinkInterface::handleMavlinkMessage(const mavlink_message_t& msg) {\n    // Handling logic here\n}\n\n// Function to forward message to a serial connection\nvoid GazeboMavlinkInterface::forwardMessageToSerial(const mavlink_message_t& msg) {\n    // Forwarding logic here\n}", "CodeBleu_score": 51.94413510317888}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() {\n    // Lock the mutex to ensure thread safety\n    std::lock_guard<std::mutex> lock(mutex_);\n\n    // Check if the interface is currently open\n    if (io_service_ && serial_dev_.is_open()) {\n        // Stop all asynchronous operations\n        io_service_->stop();\n\n        // Close the serial device\n        serial_dev_.close();\n\n        // If the I/O thread is running and joinable, join it to clean up resources\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n\n        // Optionally, reset io_service_ for future reuse\n        io_service_.reset();\n    }\n}", "CodeBleu_score": 58.93225965780449}, {"code": "// Implementation of GazeboMavlinkInterface::close\nvoid GazeboMavlinkInterface::close() {\n    // Locking the mutex to ensure thread safety during the close operation\n    std::lock_guard<std::mutex> lock(mutex_);\n\n    // Check if the interface is open\n    if (is_open_) {\n        // Stop the I/O service to prevent further operations\n        io_service_.stop();\n\n        // Attempt to close the serial device if it's open\n        if (serial_device_.is_open()) {\n            serial_device_.close();\n        }\n\n        // Flag the interface as closed\n        is_open_ = false;\n\n        // Join the I/O thread if it is joinable to ensure clean resource deallocation\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n    }\n}", "CodeBleu_score": 54.41372427944701}, {"code": "#include <iostream>\n#include <mutex>\n#include <thread>\n#include <boost/asio.hpp>\n\nclass SerialDevice {\npublic:\n    void close() {\n        // Implementation to close the hardware connection\n        std::cout << \"Serial device closed.\" << std::endl;\n    }\n};\n\nclass GazeboMavlinkInterface {\nprivate:\n    std::mutex mutex_;\n    std::thread io_thread_;\n    boost::asio::io_service io_service_;\n    boost::asio::serial_port serial_device_;\n    bool is_open_ = false;\n\npublic:\n    GazeboMavlinkInterface() : serial_device_(io_service_) {\n        // Assume initialization here\n    }\n\n    // Simulate an open function\n    void open() {\n        is_open_ = true;\n        // Mock setup\n        io_thread_ = std::thread([this](){\n            io_service_.run();\n        });\n    }\n\n    void close() {  \n        // Lock mutex to ensure thread safety\n        std::lock_guard<std::mutex> lock(mutex_);\n\n        // Check if the interface is already open\n        if (is_open_) {\n            // Stop I/O service\n            io_service_.stop();\n\n            // Close the serial device if open\n            if (serial_device_.is_open()) {\n                serial_device_.close();\n            }\n\n            // If the I/O thread is joinable, join it\n            if (io_thread_.joinable()) {\n                io_thread_.join();\n            }\n\n            // Mark the interface as closed\n            is_open_ = false;\n            std::cout << \"Interface closed safely.\" << std::endl;\n        }\n    }\n\n    ~GazeboMavlinkInterface() {\n        close(); // Ensure cleanup on destruction\n    }\n};\n\nint main() {\n    // Example usage:\n    GazeboMavlinkInterface interface;\n    interface.open();  // Opening the interface\n    interface.close(); // Closing the interface\n    return 0;\n}", "CodeBleu_score": 47.07554479192992}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "#include <ignition/math/Vector3d.hh>\n\nclass GazeboWindPlugin {\npublic:\n    // Function for interpolating between two vectors at a specific fractional position.\n    static ignition::math::Vector3d LinearInterpolation(\n        const ignition::math::Vector3d& start,\n        const ignition::math::Vector3d& end,\n        double fraction\n    ) {\n        // Interpolate each component of the vector separately\n        double x = start.X() + fraction * (end.X() - start.X());\n        double y = start.Y() + fraction * (end.Y() - start.Y());\n        double z = start.Z() + fraction * (end.Z() - start.Z());\n\n        // Create a new Vector3d from these interpolated components\n        return ignition::math::Vector3d(x, y, z);\n    }\n};\n\n// Example usage:\n// Assuming GazeboWindPlugin is defined elsewhere appropriately.\n// ignition::math::Vector3d interpolatedValue = GazeboWindPlugin::LinearInterpolation(vectorA, vectorB, 0.5);", "CodeBleu_score": 38.47736673835542}, {"code": "/*\n * Given two points (x0, y0, z0) and (x1, y1, z1) along with their corresponding values at these points (v0 and v1)\n * and a target position x, this function computes the interpolated vector value at position x using\n * linear interpolation formula: v = v0 + (x - x0) * ((v1 - v0) / (x1 - x0)).\n */\nignition::math::Vector3d GazeboWindPlugin::LinearInterpolation(\n    double x0, double y0, double z0, \n    double x1, double y1, double z1, \n    const ignition::math::Vector3d& v0, \n    const ignition::math::Vector3d& v1, \n    double x, double y, double z)\n{\n    // Calculate the distances between the target and each of the two points\n    double dx = x1 - x0;\n    double dy = y1 - y0;\n    double dz = z1 - z0;\n\n    // Ensure there is no division by zero\n    if (dx == 0 || dy == 0 || dz == 0) {\n        std::cerr << \"Error: Division by zero in linear interpolation computation.\" << std::endl;\n        return ignition::math::Vector3d(0, 0, 0);\n    }\n\n    // Calculate the interpolation ratios\n    double rx = (x - x0) / dx;\n    double ry = (y - y0) / dy;\n    double rz = (z - z0) / dz;\n\n    // Linearly interpolate for each component\n    double vx = v0.X() + rx * (v1.X() - v0.X());\n    double vy = v0.Y() + ry * (v1.Y() - v0.Y());\n    double vz = v0.Z() + rz * (v1.Z() - v0.Z());\n\n    return ignition::math::Vector3d(vx, vy, vz);\n}", "CodeBleu_score": 29.983597554445563}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation(\n    const ignition::math::Vector3d& pointA, \n    const ignition::math::Vector3d& valueA, \n    const ignition::math::Vector3d& pointB, \n    const ignition::math::Vector3d& valueB, \n    const ignition::math::Vector3d& currentPosition) \n{\n    // Vector from pointA to pointB\n    ignition::math::Vector3d vectorAB = pointB - pointA;\n\n    // Vector from pointA to currentPosition\n    ignition::math::Vector3d vectorAC = currentPosition - pointA;\n\n    // Calculate the projection length of vectorAC onto vectorAB\n    // This uses the formula: projection = (a.b) / (b.b) where a is vectorAC and b is vectorAB.\n    double projection = vectorAC.Dot(vectorAB) / vectorAB.Dot(vectorAB);\n\n    // Ensure projection doesn't exceed the limits [0, 1] to remain between pointA and pointB\n    projection = std::max(0.0, std::min(1.0, projection));\n\n    // Interpolated value using the calculated projection\n    // Lerp formula: value = start + projection * (end - start)\n    ignition::math::Vector3d interpolatedValue = valueA + projection * (valueB - valueA);\n\n    return interpolatedValue;\n}", "CodeBleu_score": 31.9110454110503}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "#include <algorithm> // for std::min and std::max\n\nclass Animation {\nprivate:\n    double currentTime;    // Current position in the animation in units of time\n    double animationLength; // Total length of the animation in units of time\n    bool loopingEnabled;    // Whether the animation should loop after reaching the end\n\npublic:\n    // Constructor, assuming an initialized length and loop status\n    Animation(double length, bool loop = false)\n        : currentTime(0.0), animationLength(length), loopingEnabled(loop) {}\n\n    // Setter for the animation time position\n    void SetTime(double _time) {\n        if (_time == currentTime) {\n            return; // If time is the same, no need to update\n        }\n\n        if (loopingEnabled) {\n            // If looping is enabled, wrap the time within the animation length\n            // Adjust time to be in the range of [0, animationLength)\n            if (_time < 0 || _time >= animationLength) {\n                _time = fmod(_time, animationLength);\n                _time = _time < 0 ? _time + animationLength : _time;\n            }\n        } else {\n            // If looping is disabled, clamp the _time to the range [0, animationLength]\n            _time = std::max(0.0, std::min(_time, animationLength));\n        }\n\n        // Set the current time to the adjusted time\n        currentTime = _time;\n    }\n\n    // Function to get the current time for testing\n    double GetCurrentTime() const {\n        return currentTime;\n    }\n};", "CodeBleu_score": 24.821738828895516}, {"code": "void Animation::SetTime(double _time) {\n    // Check if the specified time is already the current time\n    if (_time == currentTime) {\n        return;  // No update needed if the time is the same\n    }\n\n    // If looping is enabled, wrap the time within the animation length\n    if (isLooping) {\n        // Use fmod to ensure time wraps around animation length\n        currentTime = fmod(_time, animationLength);\n        if (currentTime < 0) {\n            currentTime += animationLength;  // Adjust if negative value from fmod\n        }\n    } else {\n        // If looping is disabled, clamp the time between 0 and the animation length\n        if (_time < 0) {\n            currentTime = 0;\n        } else if (_time > animationLength) {\n            currentTime = animationLength;\n        } else {\n            currentTime = _time;\n        }\n    }\n\n    // Additional logic to handle the new time could be added here\n    // For example, update animation properties, notify observers, etc.\n}", "CodeBleu_score": 40.364452787767384}, {"code": "#include <algorithm> // For std::min and std::max\n\nclass Animation {\npublic:\n    Animation(double length, bool looping) : currentTime(0.0), length(length), looping(looping) {}\n\n    void SetTime(double _time) {\n        if (currentTime != _time) { // Check if the new time is different from the current time\n            if (looping) {\n                // If looping is enabled, wrap the time within the animation length\n                currentTime = fmod(_time, length);\n                if (currentTime < 0) {\n                    currentTime += length; // Correct for negative values passed to SetTime\n                }\n            } else {\n                // If looping is disabled, clamp the time between 0 and the animation length\n                currentTime = std::max(0.0, std::min(_time, length));\n            }\n        }\n    }\n\n    double GetCurrentTime() const {\n        return currentTime;\n    }\n\nprivate:\n    double currentTime; // Current time position of the animation\n    double length;      // Total length of the animation\n    bool looping;       // Whether the animation should loop or not\n};", "CodeBleu_score": 33.613794076282836}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "class Vehicle:\n    def __init__(self, vehicle_type, vehicle_id, position, yaw):\n        self.vehicle_type = vehicle_type\n        self.vehicle_id = vehicle_id\n        self.coordinate_frame = None\n        self.motion_type = None\n        self.position = position\n        self.yaw = yaw\n        self.flight_mode = \"normal\"\n\n    def hover(self):\n        \"\"\"This function, hover, sets the vehicle's coordinate frame to 1 and motion type to 0.\n        It constructs a target motion using the current position and yaw.\n        Finally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n        # Set the coordinate frame to 1\n        self.coordinate_frame = 1\n        \n        # Set the motion type to 0 which might indicate hover/stationary mode\n        self.motion_type = 0\n        \n        # Construct the target motion using the current position and yaw (for simplicity, we consider this part as a simple reassignment)\n        target_motion = {\n            'position': self.position,\n            'yaw': self.yaw\n        }\n        \n        # Set the flight mode to 'hover'\n        self.flight_mode = 'hover'\n        \n        # Print vehicle details and flight mode\n        print(f\"Vehicle Type: {self.vehicle_type}\")\n        print(f\"Vehicle ID: {self.vehicle_id}\")\n        print(f\"Flight Mode: {self.flight_mode}\")\n\n# Example usage:\nvehicle = Vehicle(vehicle_type=\"Drone\", vehicle_id=1234, position=(100, 200, 300), yaw=90)\nvehicle.hover()", "CodeBleu_score": 38.712601079591536}, {"code": "class Vehicle:\n    def __init__(self, vehicle_type, vehicle_id):\n        self.vehicle_type = vehicle_type\n        self.vehicle_id = vehicle_id\n        self.flight_mode = None\n        self.coordinate_frame = None\n        self.motion_type = None\n        self.position = (0, 0, 0)  # Assuming 3D position (x, y, z)\n        self.yaw = 0.0\n\n    def set_coordinate_frame(self, frame):\n        self.coordinate_frame = frame\n\n    def set_motion_type(self, type):\n        self.motion_type = type\n    \n    def get_current_position_and_yaw(self):\n        return self.position, self.yaw\n\n    def construct_target_motion(self, position, yaw):\n        # Implementation details would depend on what 'target motion' entails.\n        print(f\"Target position set to {position} with yaw {yaw}.\")\n\n    def hover(self):\n        \"\"\"This function, hover, sets the vehicle's coordinate frame to 1 and motion type to 0.\n        It constructs a target motion using the current position and yaw.\n        Finally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n        self.set_coordinate_frame(1)\n        self.set_motion_type(0)\n        current_position, current_yaw = self.get_current_position_and_yaw()\n        self.construct_target_motion(current_position, current_yaw)\n        self.flight_mode = \"HOVER\"  # Assume that setting the flight mode as HOVER\n        print(f\"Vehicle Type: {self.vehicle_type}\")\n        print(f\"Vehicle ID: {self.vehicle_id}\")\n        print(f\"Flight Mode: {self.flight_mode}\")\n\n# Example usage:\nvehicle = Vehicle(\"Drone\", \"1234ABCD\")\nvehicle.hover()", "CodeBleu_score": 24.248159370243684}, {"code": "class Vehicle:\n    def __init__(self, vehicle_type, vehicle_id, position=(0,0,0), yaw=0):\n        self.vehicle_type = vehicle_type\n        self.vehicle_id = vehicle_id\n        self.position = position\n        self.yaw = yaw\n        self.coordinate_frame = None\n        self.motion_type = None\n        self.flight_mode = 'Manual'  # Assuming default flight mode\n\n    def set_motion_target(self, position, yaw):\n        \"\"\"Simulated method to set the vehicle's motion target.\"\"\"\n        print(f\"Setting motion target to position: {position} and yaw: {yaw}\")\n\n    def hover(self):\n        \"\"\"Sets the vehicle's coordinate frame to 1 and motion type to 0.\n        It constructs a target motion using the current position and yaw.\n        Finally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n        self.coordinate_frame = 1\n        self.motion_type = 0\n        self.set_motion_target(self.position, self.yaw)\n        print(f\"Vehicle Type: {self.vehicle_type}\")\n        print(f\"Vehicle ID: {self.vehicle_id}\")\n        print(f\"Flight Mode: Hover\")\n\n# Example usage:\nvehicle = Vehicle('Drone', 'D123', (100, 200, 300), 45)\nvehicle.hover()", "CodeBleu_score": 38.07085462732562}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "class Vehicle:\n    def __init__(self):\n        self.flight_mode = \"HOVER\"  # Example initial flight_mode\n        self.hover_flag = 0\n        \n    def hover(self):\n        print(\"Vehicle is now hovering.\")\n\n    def flightModeService(self, mode):\n        # This is a mock service method that changes the flight mode.\n        # We assumme a 90% chance of success for changing modes.\n        import random\n        return random.random() < 0.9\n\n    def flight_mode_switch(self):\n        \"\"\"\n        This function, flight_mode_switch, changes the flight mode of a vehicle.\n        If the flight mode is 'HOVER', it sets the hover flag to 1 and calls the hover method.\n        For other modes, it attempts to switch modes using flightModeService.\n        It prints a success message if the mode switch is successful, and a failure message otherwise.\n        The function returns True if the mode switch succeeds, and False if it fails.\n        \"\"\"\n        if self.flight_mode == \"HOVER\":\n            self.hover_flag = 1\n            self.hover()\n            print(\"Switched to HOVER mode successfully.\")\n            return True\n        else:\n            # Attempt to switch the flight mode, assume the desired mode is different and given or stored.\n            desired_mode = \"CRUISE\"  # Assume some desired alternative mode\n            success = self.flightModeService(desired_mode)\n            if success:\n                self.flight_mode = desired_mode\n                print(f\"Flight mode switched to {desired_mode} successfully.\")\n            else:\n                print(f\"Failed to switch to {desired_mode} mode.\")\n            return success", "CodeBleu_score": 34.37507139452942}, {"code": "class Vehicle:\n    def __init__(self):\n        self.flight_mode = None  # current flight mode of the vehicle\n        self.hover_flag = 0  # flag to indicate hover mode\n\n    def hover(self):\n        \"\"\"\n        This method simulates entering hover mode.\n        Could be more complex in a real situation.\n        \"\"\"\n        print(\"Vehicle is now hovering.\")\n\n    def flightModeService(self, mode):\n        \"\"\"\n        This method simulates changing the flight mode of the vehicle.\n        Returns True if the mode change is possible, otherwise False.\n        \"\"\"\n        # Simulate switching logic, considering some modes might not be available\n        if mode in [\"CRUISE\", \"HOVER\", \"ASCEND\", \"DESCEND\"]:\n            self.flight_mode = mode\n            return True\n        else:\n            return False\n\n    def flight_mode_switch(self):\n        \"\"\"\n        This function, flight_mode_switch, changes the flight mode of a vehicle.\n        If the flight mode is 'HOVER', it sets the hover flag to 1 and calls the hover method.\n        For other modes, it attempts to switch modes using flightModeService.\n        It prints a success message if the mode switch is successful, and a failure message otherwise.\n        The function returns True if the mode switch succeeds, and False if it fails.\n        \"\"\"\n        if self.flight_mode == 'HOVER':\n            self.hover_flag = 1\n            self.hover()\n            print(\"Successfully switched to HOVER mode.\")\n            return True\n        else:\n            if self.flightModeService(self.flight_mode):\n                print(f\"Successfully switched to {self.flight_mode} mode.\")\n                return True\n            else:\n                print(f\"Failed to switch to {self.flight_mode} mode.\")\n                return False", "CodeBleu_score": 40.712484790123526}, {"code": "class Vehicle:\n    def __init__(self):\n        self.flight_mode = \"NORMAL\"  # Default flight mode\n        self.hover_flag = 0  # Represents whether the vehicle is set to hover\n\n    def hover(self):\n        print(\"Hovering now...\")\n        # Additional hover implementation here\n\n    def flightModeService(self, new_mode):\n        # This is a stub for the flight mode changing service. Normally this would interact with flight control.\n        # Let's simulate a positive response for the sake of example.\n        print(f\"Switching to {new_mode} mode...\")\n        return True  # Simulating a successful switch\n\n    def flight_mode_switch(self):\n        if self.flight_mode == 'HOVER':\n            self.hover_flag = 1\n            self.hover()\n            print(\"Successfully switched to hover mode.\")\n            return True\n        else:\n            success = self.flightModeService(self.flight_mode)\n            if success:\n                print(f\"Successfully switched to {self.flight_mode} mode.\")\n                return True\n            else:\n                print(f\"Failed to switch to {self.flight_mode} mode.\")\n                return False\n\n# Example usage:\nvehicle = Vehicle()\nvehicle.flight_mode = \"HOVER\"\nresult = vehicle.flight_mode_switch()  # Expected to successfully switch to hover\n\nvehicle.flight_mode = \"CRUISE\"\nresult = vehicle.flight_mode_switch()  # Simulation is set to always succeed, so this should also be successful", "CodeBleu_score": 41.53687607988973}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "class MyController:\n    def __init__(self):\n        self._hover_flag = False\n        self._hold_flag = False\n        self.coordinate_frame = None\n        self.motion_type = None\n\n    def cmd_vel_enu_callback(self, msg):\n        \"\"\"\n        Processes velocity commands in the ENU frame.\n        - Calls hover_state_transition with the linear and angular components of the message.\n        - If the hover_flag is not set, calls hold_state_transition with the same components and the `enu` frame.\n        - If both hover_flag and hold_flag are not set, sets the coordinate_frame and motion_type to 1, and constructs the target motion using the message components.\n        \n        Args:\n        msg (object): An object expected to have linear and angular velocity components.\n                      Example: msg.linear.x, msg.angular.z\n        \"\"\"\n        \n        # Assume that msg has attributes linear and angular, each with x, y, and z components\n        # First call hover_state_transition\n        self.hover_state_transition(msg.linear, msg.angular)\n        \n        # Check if hover_flag is not set\n        if not self._hover_flag:\n            # If hover_flag is not set, call hold_state_transition with `enu` frame\n            self.hold_state_transition(msg.linear, msg.angular, frame='enu')\n        \n        # If both hover_flag and hold_flag are not set\n        if not self._hold_flag and not self._hover_flag:\n            # Sets the coordinate_frame and motion_type to 1\n            self.coordinate_frame = 1\n            self.motion_type = 1\n            \n            # Constructs the target motion using the message components\n            # Assuming target_motion is structured as follows: {'linear': ..., 'angular': ...}\n            self.target_motion = {\n                'linear': {'x': msg.linear.x, 'y': msg.linear.y, 'z': msg.linear.z},\n                'angular': {'x': msg.angular.x, 'y': msg.angular.y, 'z': msg.angular.z}\n            }\n\n    def hover_state_transition(self, linear, angular):\n        \"\"\" Placeholder method for hover state transition logic \"\"\"\n        print(\"Transition to hover state with linear\", linear, \"and angular\", angular)\n\n    def hold_state_transition(self, linear, angular, frame):\n        \"\"\" Placeholder method for hold state transition logic with a specific frame \"\"\"\n        print(\"Transition to hold state with linear\", linear, \"and angular\", angular, \"in frame\", frame)", "CodeBleu_score": 43.00539485732178}, {"code": "def cmd_vel_enu_callback(self, msg):\n    \"\"\"\n    This function processes velocity commands in the ENU (East-North-Up) frame.\n\n    1. Calls hover_state_transition with the linear and angular components of the message.\n    2. If the hover_flag is not set, calls hold_state_transition with the same components and the 'enu' frame.\n    3. If neither hover_flag nor hold_flag are set, sets coordinate_frame and motion_type to 1, and constructs the target motion using the message components.\n\n    Args:\n    msg (MessageType): A message object containing 'linear' and 'angular' velocity components.\n    \"\"\"\n    # Step 1: Transition to hover state with msg components\n    self.hover_state_transition(msg.linear, msg.angular)\n\n    # Step 2: Considering the hover_flag might tell us if we're in hover state\n    if not self.hover_flag:\n        # Transition to hold state in the 'enu' frame\n        self.hold_state_transition(msg.linear, msg.angular, 'enu')\n\n    # Step 3: Handling neither hover nor hold states being activated\n    if not (self.hover_flag or self.hold_flag):\n        # Set the coordinate frame and motion type for general motion\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        # Constructing the target motion might mean formatting or setting the motion values\n        self.target_motion = {\"linear\": msg.linear, \"angular\": msg.angular}\n\n    # Assuming there could be some common finalizing or update tasks\n    self.update_motion_settings()", "CodeBleu_score": 36.99523152176657}, {"code": "def cmd_vel_enu_callback(self, msg):\n    \"\"\"\n    This function, cmd_vel_enu_callback, processes velocity commands in the ENU frame.\n    It first calls hover_state_transition with the linear and angular components of the message.\n    If the hover_flag is not set, it calls hold_state_transition with the same components and the 'enu' frame.\n    If both hover_flag and hold_flag are not set, it sets the coordinate_frame and motion_type to 1, and constructs the target motion using the message components.\n    \"\"\"\n    # Assuming hover_state_transition and hold_state_transition are methods of the class\n    # and hover_flag and hold_flag are attributes of the class\n    # msg is expected to have linear and angular components\n\n    self.hover_state_transition(msg.linear, msg.angular)\n\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear, msg.angular, 'enu')\n\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        # Construct target motion (this is a placeholder, actual implementation needed based on system design)\n        self.target_motion = {\n            'linear': msg.linear,\n            'angular': msg.angular\n        }", "CodeBleu_score": 37.69791303307169}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w):\n    \"\"\"\n    This function, hover_state_transition, transitions the drone's flight mode based on positional and rotational thresholds.\n    If any of the x, y, z values exceed 0.02 or w exceeds 0.005, it sets hover_flag to 0 and changes the flight mode to 'OFFBOARD'.\n    If the values do not exceed the thresholds and the current flight mode is not \"HOVER\", \n    it sets hover_flag to 1, changes the flight mode to 'HOVER', and initiates the hover action.\n    \n    Parameters:\n        x (float): The position difference in the x-axis.\n        y (float): The position difference in the y-axis.\n        z (float): The position difference in the z-axis.\n        w (float): The rotation difference around the vertical axis.\n    \"\"\"\n    threshold_position = 0.02\n    threshold_rotation = 0.005\n    \n    # Check if any positional or rotational thresholds are exceeded\n    if abs(x) > threshold_position or abs(y) > threshold_position or abs(z) > threshold_position or abs(w) > threshold_rotation:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n    elif self.flight_mode != 'HOVER':\n        # Position and rotation are within allowable limits and flight mode is not already HOVER\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.initiate_hover_action()", "CodeBleu_score": 55.291846508519896}, {"code": "def hover_state_transition(self, x, y, z, w):\n    \"\"\"\n    This function, hover_state_transition, transitions the drone's flight mode based \n    on positional (x, y, z) and rotational (w) thresholds.\n    \n    Args:\n    x (float): Position along the x-axis.\n    y (float): Position along the y-axis.\n    z (float): Position along the z-axis.\n    w (float): Rotation about some axis.\n    \n    If any of the x, y, z values exceed 0.02 or w exceeds 0.005:\n    - Sets hover_flag to 0.\n    - Changes the flight mode to 'OFFBOARD'.\n    Else if the flight mode is not \"HOVER\" and the conditions for hovering are met:\n    - Sets hover_flag to 1,\n    - Changes the flight mode to 'HOVER',\n    - Initiates the hover action by calling a hypothetical `initiate_hover` method.\n    \"\"\"\n    \n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n    elif self.flight_mode != 'HOVER' and abs(x) <= 0.02 and abs(y) <= 0.02 and abs(z) <= 0.02 and abs(w) <= 0.005:\n        self.hover_flag = 1\n        self.flight_mode = 'HOVER'\n        self.initiate_hover()\n        \ndef initiate_hover(self):\n    \"\"\" Initiates hover action. This method needs to be defined to properly manage the hover behavior.\"\"\"\n    print(\"Hovering initiated.\")  # Simplified for example purposes", "CodeBleu_score": 81.1747775577156}, {"code": "def hover_state_transition(self, x, y, z, w):\n    \"\"\"\n    This function, hover_state_transition, transitions the drone's flight mode based on positional and rotational thresholds.\n    If any of the x, y, z values exceed 0.02 or w exceeds 0.005, it sets hover_flag to 0 and changes the flight mode to 'OFFBOARD'.\n    If the flight mode is not \"HOVER\" and the conditions are met, it sets hover_flag to 1, changes the flight mode to 'HOVER',\n    and initiates the hover action.\n    \"\"\"\n    # Check if any thresholds are exceeded\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005:\n        # Set hover flag to 0 and change flight mode to 'OFFBOARD'\n        self.hover_flag = 0\n        self.flight_mode = 'OFFBOARD'\n    else:\n        # Check if current flight mode is not 'HOVER'\n        if self.flight_mode != 'HOVER':\n            # Set hover flag to 1, change flight mode to 'HOVER', and initiate hover action\n            self.hover_flag = 1\n            self.flight_mode = 'HOVER'\n            self.initiate_hover_action()", "CodeBleu_score": 86.45252312213316}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "from math import atan2\n\nclass Quaternion:\n    def __init__(self, w, x, y, z):\n        self.w = w\n        self.x = x\n        self.y = y\n        self.z = z\n\ndef q2yaw(self, q):\n    \"\"\"This function, q2yaw, calculates the yaw rotation in radians from a quaternion.\n    It checks if the input is an instance of Quaternion.\n    If it is, it extracts the yaw component directly.\n    Otherwise, it creates a Quaternion from the input components and then extracts the yaw component.\n    The function returns the yaw rotation in radians.\"\"\"\n\n    if not isinstance(q, Quaternion):\n        raise ValueError(\"Input must be an instance of Quaternion or convertible to it.\")\n    \n    # Compute the yaw (psi) from the quaternion\n    # Formula to extract the yaw angle: psi = atan2(2*(w*z + x*y), 1 - 2*(y^2 + z^2))\n    w, x, y, z = q.w, q.x, q.y, q.z\n    yaw = atan2(2 * (w*z + x*y), 1 - 2 * (y**2 + z**2))\n    return yaw", "CodeBleu_score": 29.903766117327415}, {"code": "import math\n\nclass Quaternion:\n    def __init__(self, w, x, y, z):\n        self.w = w\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def to_euler(self):\n        # Convert quaternion to Euler angles (specifically focusing on yaw)\n        # Using the convention where yaw (\u03c8) is around z-axis\n        siny_cosp = 2 * (self.w * self.z + self.x * self.y)\n        cosy_cosp = 1 - 2 * (self.y**2 + self.z**2)\n        yaw = math.atan2(siny_cosp, cosy_cosp)\n        return yaw\n\nclass MyClass:\n    def q2yaw(self, q):\n        \"\"\"\n        This function, q2yaw, calculates the yaw rotation in radians from a quaternion.\n        It checks if the input is an instance of Quaternion.\n        If it is, it extracts the yaw component directly.\n        Otherwise, it creates a Quaternion from the input components and then extracts the yaw component.\n        The function returns the yaw rotation in radians.\n        \"\"\"\n        if isinstance(q, Quaternion):\n            quaternion = q\n        elif isinstance(q, (list, tuple)) and len(q) == 4:\n            quaternion = Quaternion(*q)\n        else:\n            raise ValueError(\"Input must be either a Quaternion instance or a list/tuple of four elements.\")\n\n        yaw = quaternion.to_euler()\n        return yaw\n\n# Example of usage:\nmy_class = MyClass()\nquaternion = Quaternion(1, 0, 0, 0)\nprint(\"Yaw:\", my_class.q2yaw(quaternion))  # Should print Yaw: 0.0 with a quaternion representing no rotation\nprint(\"Yaw with tuple:\", my_class.q2yaw((1, 0, 0, 0)))  # Should also print Yaw: 0.0", "CodeBleu_score": 25.879870540461418}, {"code": "import math\nfrom dataclasses import dataclass\n\n@dataclass\nclass Quaternion:\n    w: float\n    x: float\n    y: float\n    z: float\n    \n    def to_yaw(self):\n        # Compute yaw (psi) using the 3D conversion formula for quaternions:\n        return math.atan2(2 * (self.x * self.y + self.w * self.z), 1 - 2 * (self.x**2 + self.y**2))\n\ndef q2yaw(q):\n    \"\"\"This function, q2yaw, calculates the yaw rotation in radians from a quaternion.\n    It checks if the input is an instance of Quaternion.\n    If it is, it extracts the yaw component directly.\n    Otherwise, it creates a Quaternion from the input components and then extracts the yaw component.\n    The function returns the yaw rotation in radians.\n    \n    Parameters:\n    - q: A Quaternion instance or an iterable with four elements (w, x, y, z)\n    \n    Returns:\n    - float: The yaw rotation in radians.\n    \"\"\"\n    \n    if isinstance(q, Quaternion):\n        # Input q is already a Quaternion instance\n        yaw = q.to_yaw()\n    elif hasattr(q, '__iter__') and len(q) == 4:\n        # q is a tuple or list with four elements representing (w, x, y, z)\n        quaternion = Quaternion(*q)\n        yaw = quaternion.to_yaw()\n    else:\n        raise ValueError(\"Input must be either a Quaternion instance or an iterable with four float elements (w, x, y, z)\")\n    \n    return yaw\n\n# Example usage cases\nif __name__ == \"__main__\":\n    q_tuple = (1.0, 0.0, 0.0, 0.0)\n    print(\"Yaw from tuple:\", q2yaw(q_tuple))  # Should print zero, no rotation about Y-axis for a neutral quaternion\n\n    q_instance = Quaternion(1.0, 0.0, 0.0, 0.0)\n    print(\"Yaw from Quaternion instance:\", q2yaw(q_instance))  # Should print zero", "CodeBleu_score": 29.231657773994158}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "class Vehicle:\n    def __init__(self, vehicle_id, vehicle_type, position, yaw):\n        self.vehicle_id = vehicle_id\n        self.vehicle_type = vehicle_type\n        self.position = position\n        self.yaw = yaw\n        self.flight_mode = 'normal'\n\n    def update_frame_coordination(self):\n        # Example action to change the coordinate frame\n        pass\n\n    def set_motion_type(self, motion):\n        # Example action to change the motion type\n        self.motion = motion\n\n    def hover(self):\n        \"\"\"This function, hover, sets the vehicle to hover mode.\n        It updates the coordinate frame and motion type.\n        It constructs a target motion using the current position and yaw values.\n        Finally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n\n        # Update coordinate frame for hovering\n        self.update_frame_coordination()\n\n        # Set motion type to hover, assuming that 'hover' is a valid motion type\n        self.set_motion_type('hover')\n        \n        # Construct target motion\n        target_motion = f\"Position: {self.position}, Yaw: {self.yaw}\"\n        \n        # Update flight mode to hover\n        self.flight_mode = 'hover'\n        \n        # Print vehicle details and hover state\n        print(f\"Vehicle Type: {self.vehicle_type}, Vehicle ID: {self.vehicle_id}, Flight Mode: {self.flight_mode}\")\n\n# Example of usage\nvehicle = Vehicle(\"12345\", \"Drone\", (0,0,0), 90)\nvehicle.hover()", "CodeBleu_score": 25.750995263302517}, {"code": "class Vehicle:\n    def __init__(self, vehicle_type, vehicle_id, position, yaw):\n        self.vehicle_type = vehicle_type\n        self.vehicle_id = vehicle_id\n        self.position = position  # Position assumed to be a tuple (x, y, z)\n        self.yaw = yaw\n        self.flight_mode = \"normal\"\n    \n    def update_coordinate_frame(self):\n        \"\"\"Simulate updating the coordinate frame for hovering.\"\"\"\n        print(\"Coordinate frame updated for hovering.\")\n\n    def set_motion_type(self):\n        \"\"\"Set the motion type to hover.\"\"\"\n        print(\"Motion type set to hover.\")\n\n    def construct_target_motion(self):\n        \"\"\"Construct the target motion based on current position and yaw.\"\"\"\n        target_motion = {'position': self.position, 'yaw': self.yaw}\n        print(f\"Target motion set to position {self.position} and yaw {self.yaw}\")\n        return target_motion\n    \n    def hover(self):\n        \"\"\"This function, hover, sets the vehicle to hover mode.\n        It updates the coordinate frame and motion type.\n        It constructs a target motion using the current position and yaw values.\n        Finally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n        \n        # Update the vehicle to hover mode\n        self.update_coordinate_frame()\n        self.set_motion_type()\n        \n        # Construct target motion from current status\n        self.construct_target_motion()\n        \n        # Set flight mode to hover\n        self.flight_mode = \"hover\"\n        \n        # Print vehicle details and current mode\n        print(f\"Vehicle Type: {self.vehicle_type}\")\n        print(f\"Vehicle ID: {self.vehicle_id}\")\n        print(f\"Flight Mode: {self.flight_mode}\")\n\n# Example usage:\nvehicle = Vehicle(\"drone\", \"123ABC\", (50, 75, 100), 30)\nvehicle.hover()", "CodeBleu_score": 26.93140867006426}, {"code": "class Vehicle:\n    def __init__(self, vehicle_id, vehicle_type, position, yaw):\n        self.vehicle_id = vehicle_id\n        self.vehicle_type = vehicle_type\n        self.position = position  # Assuming position is a tuple (x, y, z)\n        self.yaw = yaw\n        self.flight_mode = None\n\n    def hover(self):\n        \"\"\"This function, hover, sets the vehicle to hover mode.\n        It updates the coordinate frame and motion type.\n        It constructs a target motion using the current position and yaw values.\n        Finally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n\n        # Setting flight mode to hover\n        self.flight_mode = 'Hover'\n\n        # Since detailed specifics of `coordinate frame` and `motion type` updating are not provided, we mention them generically.\n        # In a live implementation, these would likely involve more complex operations dealing with object state.\n        print(\"Updating coordinate frame and motion type for hover mode.\")\n\n        # Constructing target motion - In a real example, this might involve controls or state changes in the vehicle\n        target_motion = {\n            'position': self.position,  # Preserving current position\n            'yaw': self.yaw\n        }\n        \n        # Output to show what the hover action involves\n        print(f\"Vehicle Type: {self.vehicle_type}\")\n        print(f\"Vehicle ID: {self.vehicle_id}\")\n        print(f\"Flight Mode: {self.flight_mode}\")\n        print(f\"Target Motion: Position: {target_motion['position']}, Yaw: {target_motion['yaw']}\")\n\n# Example usage\nvehicle = Vehicle(vehicle_id='V001', vehicle_type='Drone', position=(0,0,10), yaw=0)\nvehicle.hover()", "CodeBleu_score": 26.577263049313483}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "class Vehicle:\n    def __init__(self):\n        self.flight_mode = \"NORMAL\"  # Default flight mode\n        self.hover_flag = False\n    \n    def hover(self):\n        print(\"Vehicle is now hovering.\")\n    \n    def flight_mode_switch(self):\n        \"\"\"\n        This function, flight_mode_switch, switches the flight mode of a vehicle.\n        If the flight mode is 'HOVER', it sets the hover flag and calls the hover method.\n        Otherwise, it attempts to switch the flight mode using flightModeService.\n        If successful, it prints the new flight mode and returns True.\n        If unsuccessful, it prints a failure message and returns False.\n        \"\"\"\n        if self.flight_mode == \"HOVER\":\n            self.hover_flag = True\n            self.hover()\n            return True\n        else:\n            try:\n                # Assuming flightModeService is a method that returns a tuple (bool, str)\n                # Where the bool indicates success, and str is the new flight mode or an error message\n                success, result = self.flightModeService()\n                if success:\n                    self.flight_mode = result\n                    print(f\"Flight mode changed successfully to {self.flight_mode}\")\n                    return True\n                else:\n                    print(f\"Failed to change flight mode: {result}\")\n                    return False\n            except Exception as e:\n                print(f\"Error changing flight mode: {e}\")\n                return False\n    \n    def flightModeService(self):\n        # Placeholder for service logic, needs proper implementation\n        # Simulating a scenario where changing the flight mode is successful\n        return True, \"CRUISE\"", "CodeBleu_score": 33.0127261955261}, {"code": "def flight_mode_switch(self)\n\u5206\u6790\u5931\u8d25", "CodeBleu_score": 0.4716981132075472}, {"code": "class Vehicle:\n    def __init__(self):\n        self.flight_mode = None\n        # Assuming this service is initialized somewhere in the actual implementation.\n        self.flightModeService = FlightModeService()\n\n    def set_hover_flag(self):\n        \"\"\"Set the hover flag for the vehicle (implementation depends on system specifications).\"\"\"\n        # Example flag action; actual implementation would depend on system design.\n        self.is_hovering = True\n\n    def hover(self):\n        \"\"\"Enable hover mode for the vehicle.\"\"\"\n        print(\"Hovering now!\")\n\n    def flight_mode_switch(self):\n        \"\"\"Switches the flight mode of the vehicle.\"\"\"\n        if self.flight_mode == 'HOVER':\n            self.set_hover_flag()\n            self.hover()\n            print(\"Flight mode set to HOVER\")\n            return True\n        else:\n            # Assuming a new flight mode to switch to is defined somewhere,\n            # here just switching to a generic \"CRUISE\" for demonstration.\n            new_mode = \"CRUISE\"\n            # Simulate the returning result of flight mode changing attempt\n            success = self.flightModeService.change_flight_mode(new_mode)\n            \n            if success:\n                self.flight_mode = new_mode\n                print(f\"Flight mode changed successfully to {self.flight_mode}\")\n                return True\n            else:\n                print(\"Failed to change flight mode\")\n                return False\n\nclass FlightModeService:\n    def change_flight_mode(self, mode):\n        \"\"\"Simulate changing the flight mode of the vehicle to the given 'mode'. \n        Returns True if successful, False otherwise.\"\"\"\n        # Simulating a successful mode change:\n        return True", "CodeBleu_score": 34.761892045706304}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "class Simulation:\n    def __init__(self, visualize=False):\n        # Optional parameter to control visualization\n        self.visualize = visualize\n\n    def run(self, assignment, algorithm, play, rond):\n        \"\"\"\n        This function, run, sets the assignment, algorithm, play, and rond attributes.\n        It then calls get_total_reward to calculate the total reward.\n        If visualization is enabled, it calls the visualize method.\n        \n        Parameters:\n            assignment: The assigned task or resource.\n            algorithm: The algorithm used for processing.\n            play: Specific gameplay or simulation characteristics.\n            rond: A specific round, loop, or iteration identifier.\n        \"\"\"\n        # Set attributes\n        self.assignment = assignment\n        self.algorithm = algorithm\n        self.play = play\n        self.rond = rond\n\n        # Calculate total reward\n        total_reward = self.get_total_reward()\n\n        # Optionally visualize the process/results\n        if self.visualize:\n            self.visualize_method()\n\n    def get_total_reward(self):\n        \"\"\" Dummy implementation of getting total reward based on the algorithm and assignment.\"\"\"\n        # Example based on a simple case, can be expanded based on actual logic\n        return len(self.assignment) + len(self.algorithm) + self.play + self.rond\n\n    def visualize_method(self):\n        \"\"\" Dummy implementation of a visualization method.\"\"\"\n        print(f\"Visualizing: Assignment={self.assignment}, Algorithm={self.algorithm}, Play={self.play}, Rond={self.rond}\")", "CodeBleu_score": 53.79778952287393}, {"code": "class SomeClass:\n    def __init__(self, enable_visualization=False):\n        self.enable_visualization = enable_visualization\n        self.assignment = None\n        self.algorithm = None\n        self.play = None\n        self.rond = None\n        self.total_reward = None\n\n    def run(self, assignment, algorithm, play, rond):\n        \"\"\"\n        This function, run, sets the assignment, algorithm, play, and rond attributes.\n        It then calls get_total_reward to calculate the total reward.\n        If visualization is enabled, it calls the visualize method.\n\n        Parameters:\n        assignment -- data or settings related to the assignment.\n        algorithm -- the algorithm to process the data.\n        play -- specifics about the play that should be executed.\n        rond -- information about the round of processing or execution.\n        \"\"\"\n        self.assignment = assignment\n        self.algorithm = algorithm\n        self.play = play\n        self.rond = rond\n\n        self.get_total_reward()\n\n        if self.enable_visualization:\n            self.visualize()\n\n    def get_total_reward(self):\n        \"\"\"Calculates the total reward based on the current settings.\"\"\"\n        # Placeholder: simulate reward calculation\n        self.total_reward = sum(range(5))  # example calculation\n\n    def visualize(self):\n        \"\"\"Visualizes the current state of the object.\"\"\"\n        print(\"Visualizing:\")\n        print(f\"Assignment: {self.assignment}\")\n        print(f\"Algorithm: {self.algorithm}\")\n        print(f\"Play: {self.play}\")\n        print(f\"Rond: {self.rond}\")\n        print(f\"Total Reward: {self.total_reward}\")", "CodeBleu_score": 54.86121224351801}, {"code": "class GameScenario:\n    def __init__(self, visualization=False):\n        self.visualization = visualization\n\n    def run(self, assignment, algorithm, play, rond):\n        \"\"\"This function, run, sets the assignment, algorithm, play, and rond attributes.\n        It then calls get_total_reward to calculate the total reward.\n        If visualization is enabled, it calls the visualize method.\n\n        Args:\n        assignment: A specific setting or configuration for the game scenario.\n        algorithm: The algorithm used to process or drive the game logic.\n        play: Details about the play strategy or execution.\n        rond: The current round or iteration of the game.\n\n        Returns:\n        None\n        \"\"\"\n        self.assignment = assignment\n        self.algorithm = algorithm\n        self.play = play\n        self.rond = rond\n        \n        total_reward = self.get_total_reward()\n\n        if self.visualization:\n            self.visualize()\n\n    def get_total_reward(self):\n        \"\"\"Calculate and return the total reward for the current game configuration.\"\"\"\n        # Sample implementation - replace with specific logic as needed\n        return 100  # Placeholder reward calculation\n\n    def visualize(self):\n        \"\"\"Visualize the output based on the current game state.\"\"\"\n        print(f\"Visualizing game: Assignment={self.assignment}, Algorithm={self.algorithm}, Play={self.play}, Round={self.rond}\")", "CodeBleu_score": 54.34296154249382}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i):\n    \"\"\"\n    This function, local_pose_callback, updates the UAV's local and global pose based on incoming messages.\n    If the message index matches the UAV ID, it sets the local_pose to the message.\n    Depending on the ground control station (GCS) command, it updates the takeoff_target_pose and\n    hover_target_pose. It also updates the global_pose for the UAV, applying a bias to the position coordinates.\n\n    Args:\n    - msg: The incoming message containing, presumably, position and possibly other data.\n    - i: The index or ID used to match against the UAV ID. \n\n    Attributes (presumed to exist in the class):\n    - UAV_ID: The ID of this specific UAV, to be matched with `i`.\n    - local_pose: Current local position and orientation of the UAV.\n    - global_pose: Current global position and orientation of the UAV, which is adjusted by a predefined bias.\n    - takeoff_target_pose: The target pose for takeoff operations.\n    - hover_target_pose: The target pose for hovering operations.\n    - position_bias: The predefined bias to be added to the global_pose.\n\n    Note: Since the docstring isn't clear on the method to communicate with GCS, it's assumed that necessary parts of \n    `msg` include fields for a potential command and required position data.\n    \"\"\"\n    # Check if message index matches the UAV ID\n    if i == self.UAV_ID:\n        # Update local pose\n        self.local_pose = msg.pose  # assuming msg has a 'pose' attribute\n        \n        # Simulated GCS commands handling\n        if msg.command == \"takeoff\":\n            self.takeoff_target_pose = msg.takeoff_pose  # takeoff_pose must be part of the msg structure\n        elif msg.command == \"hover\":\n            self.hover_target_pose = msg.hover_pose  # hover_pose must be part of the msg structure\n\n        # Update global pose with a bias\n        self.global_pose = {\n            'x': msg.pose['x'] + self.position_bias['x'], \n            'y': msg.pose['y'] + self.position_bias['y'],\n            'z': msg.pose['z'] + self.position_bias['z']\n        }", "CodeBleu_score": 25.657856198860905}, {"code": "def local_pose_callback(self, msg, i):\n    \"\"\"\n    This function, local_pose_callback, updates the UAV's local and global pose based on incoming messages.\n    If the message index matches the UAV ID, it sets the local_pose to the message.\n    Depending on the ground control station (GCS) command, it updates the takeoff_target_pose and hover_target_pose.\n    It also updates the global_pose for the UAV, applying a bias to the position coordinates.\n    \n    Args:\n        msg: An object containing the UAV's current pose and possibly other metadata.\n        i: An index identifying the specific UAV in question.\n    \"\"\"\n    \n    # Check if the message index matches the UAV ID.\n    if msg.uav_id == i:\n        # Update the local pose with the data from the message\n        self.uavs[i].local_pose = msg.pose\n        \n        # Depending on GCS command, update specific target poses\n        if self.gcs_command == \"takeoff\":\n            self.uavs[i].takeoff_target_pose = msg.pose  # Set to current pose or could be adjusted\n        elif self.gcs_command == \"hover\":\n            self.uavs[i].hover_target_pose = msg.pose  # Set to current pose or could be adjusted\n        \n        # Update the global pose, applying a positional bias\n        bias_x, bias_y, bias_z = 0.5, 0.5, 0.1  # Example biases\n        self.uavs[i].global_pose = (\n            msg.pose[0] + bias_x,\n            msg.pose[1] + bias_y,\n            msg.pose[2] + bias_z\n        )\n\n# Note: The code requires an existing class (context) where this function is part of, and where `self.uavs`, `self.gcs_command`, etc., are defined.", "CodeBleu_score": 21.837932759746337}, {"code": "def local_pose_callback(self, msg, i):\n    \"\"\"\n    This function, local_pose_callback, updates the UAV's local and global pose based on incoming messages.\n    If the message index matches the UAV ID, it sets the local_pose to the message.\n    Depending on the ground control station (GCS) command, it updates the takeoff_target_pose and hover_target_pose.\n    It also updates the global_pose for the UAV, applying a bias to the position coordinates.\n\n    Args:\n    - msg: a message object that contains at least attributes `index`, `pose` (itself with attributes x, y, z),\n           and `command` describing the GCS command.\n    - i: the ID of the UAV that should correspond to msg.index for the pose update to proceed.\n    \"\"\"\n    if msg.index == i:\n        self.local_pose = msg.pose  # Assuming msg.pose is an object with attributes x, y, z\n\n        # Check GCS command to update target poses\n        if msg.command == \"takeoff\":\n            self.takeoff_target_pose = msg.pose  # Assume the new takeoff target is given by the incoming message\n        elif msg.command == \"hover\":\n            self.hover_target_pose = msg.pose  # Assume hovering target should also be updated with the message\n\n        # Update global pose with a bias (assuming this too is a pose object)\n        bias_x, bias_y, bias_z = 1.0, 1.0, 1.0  # Specify the bias values; these could also be attributes of self\n        self.global_pose = type(self.local_pose)(\n            x=self.local_pose.x + bias_x,\n            y=self.local_pose.y + bias_y,\n            z=self.local_pose.z + bias_z\n        )", "CodeBleu_score": 21.814212021295532}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "class Drone:\n    def __init__(self, altitude = 0, arm_state = False):\n        self.altitude = altitude\n        self.arm_state = arm_state\n\n    def takeoff_detection(self):\n        \"\"\"\n        This function, takeoff_detection, checks if a UAV has taken off.\n        It returns True if the UAV's altitude is greater than 0.2 meters and the arm_state is active.\n        Otherwise, it returns False.\n        \"\"\"\n        if self.altitude > 0.2 and self.arm_state:\n            return True\n        else:\n            return False\n\n# Example Usage\ndrone = Drone(0.3, True)\nprint(drone.takeoff_detection())  # Expected output: True, since altitude is 0.3 and arm_state is True.", "CodeBleu_score": 61.81207027048969}, {"code": "class UAV:\n    def __init__(self, altitude=0.0, arm_state=False):\n        self.altitude = altitude\n        self.arm_state = arm_state\n\n    def takeoff_detection(self):\n        \"\"\"\n        This function checks if a UAV has taken off.\n        It returns True if the UAV's altitude is greater than 0.2 meters and the arm_state is active.\n        Otherwise, it returns False.\n        \"\"\"\n        if self.altitude > 0.2 and self.arm_state:\n            return True\n        else:\n            return False", "CodeBleu_score": 65.00091320587293}, {"code": "class UAV:\n    def __init__(self, altitude=0.0, arm_state=False):\n        self.altitude = altitude\n        self.arm_state = arm_state\n\n    def takeoff_detection(self):\n        \"\"\"\n        This function, takeoff_detection, checks if a UAV has taken off.\n        It returns True if the UAV's altitude is greater than 0.2 meters and the arm_state is active.\n        Otherwise, it returns False.\n        \"\"\"\n        return self.altitude > 0.2 and self.arm_state", "CodeBleu_score": 41.19844258794282}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "import numpy as np\n\ndef build_graph(self, orig_formation, change_formation):\n    \"\"\"\n    Constructs a distance matrix for UAV formations.\n    Calculates the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\n    The distances are adjusted by subtracting them from 50 and converted to integers.\n    The resulting distance matrix is returned.\n\n    Parameters:\n    - orig_formation: List of tuples, where each tuple contains the coordinates (x, y, z) of UAVs in the original formation.\n    - change_formation: List of tuples, where each tuple contains the coordinates (x, y, z) of UAVs in the changed formation.\n\n    Returns:\n    - List of lists (matrix) where each element [i][j] is the adjusted, integer distance between UAV i from orig_formation and UAV j from change_formation.\n    \"\"\"\n\n    # Initializing the distance matrix\n    distance_matrix = []\n\n    # Loop through each UAV in the original formation\n    for orig_uav in orig_formation:\n        # For each UAV in original, calculate distance to each UAV in changed formation\n        dist_row = []\n        for change_uav in change_formation:\n            # Calculate Euclidean distance\n            dist = np.linalg.norm(np.subtract(orig_uav, change_uav))\n            # Adjust distance and convert to int\n            adjusted_dist = int(50 - dist)\n            # Append to the row in matrix\n            dist_row.append(adjusted_dist)\n        # Append row to the distance matrix\n        distance_matrix.append(dist_row)\n\n    return distance_matrix", "CodeBleu_score": 21.51753980452816}, {"code": "import numpy as np\n\ndef build_graph(self, orig_formation, change_formation):\n    \"\"\"This function, build_graph, constructs a distance matrix for UAV formations.\n       It calculates the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\n       The distances are adjusted by subtracting them from 50 and converted to integers.\n       The resulting distance matrix is returned.\"\"\"\n\n    # Ensure both formations have the same number of UAVs\n    assert len(orig_formation) == len(change_formation), \"Both formations must contain the same number of UAVs\"\n\n    # Number of UAVs\n    n = len(orig_formation)\n\n    # Initialize the distance matrix\n    distance_matrix = np.zeros((n, n), dtype=int)\n\n    # Calculate adjusted pairwise distances\n    for i in range(n):\n        for j in range(n):\n            # Compute the Euclidean distance\n            dist = np.linalg.norm(np.array(orig_formation[i]) - np.array(change_formation[j]))\n            # Adjust the distance by subtracting from 50 and convert to integer\n            adjusted_dist = int(50 - dist)\n            # Store in the matrix\n            distance_matrix[i][j] = adjusted_dist\n\n    return distance_matrix", "CodeBleu_score": 26.098421900088315}, {"code": "import numpy as np\n\ndef build_graph(self, orig_formation, change_formation):\n    \"\"\"\n    Construct a distance matrix for UAV formations.\n    It calculates the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\n    The distances are adjusted by subtracting them from 50 and converted to integers.\n    The resulting distance matrix is returned.\n\n    Parameters:\n        orig_formation (list of tuple/list): A list where each element is a position of a UAV in the original formation.\n        change_formation (list of tuple/list): A list where each element is a position of a UAV in the changed formation.\n\n    Returns:\n        np.ndarray: A matrix of integers representing the adjusted pairwise distances.\n    \"\"\"\n\n    # Check if both formations have the same number of UAVs\n    if len(orig_formation) != len(change_formation):\n        raise ValueError(\"Both formations must contain the same number of UAVs.\")\n    \n    # Number of UAVs\n    num_uavs = len(orig_formation)\n\n    # Initialize a distance matrix with zeros\n    distance_matrix = np.zeros((num_uavs, num_uavs), dtype=int)\n\n    # Calculate pairwise distance adjustments\n    for i in range(num_uavs):\n        for j in range(num_uavs):\n            # Calculate Euclidean distance for each pair\n            distance = np.linalg.norm(np.array(orig_formation[i]) - np.array(change_formation[j]))\n            # Adjust distance\n            adjusted_distance = 50 - distance\n            # Store adjusted distance as int in the matrix\n            distance_matrix[i, j] = int(adjusted_distance)\n    \n    return distance_matrix", "CodeBleu_score": 24.136024413766606}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "class BipartiteMatcher:\n    def __init__(self, n_left, n_right):\n        # Initialize the part sizes and matches\n        self.n_left = n_left\n        self.n_right = n_right\n        self.left_match = [-1] * n_left\n        self.right_match = [-1] * n_right\n        self.left_labels = [0] * n_left\n        self.right_labels = [0] * n_right\n        self.adjacency_list = [[] for _ in range(n_left)]\n        self.visited = [False] * n_left\n        self.slack = [float('inf')] * n_right\n\n    def add_edge(self, u, v):\n        # Adds an edge from left vertex u to right vertex v\n        self.adjacency_list[u].append(v)\n\n    def find_path(self, i):\n        \"\"\"This function, find_path, attempts to find an augmenting path in a bipartite graph for matching purposes.\n        It marks the left vertex as visited and iterates through adjacent right vertices.\n        If a right vertex is already visited, it continues.\n        It calculates the gap between labels and match weight.\n        If the gap is zero, it marks the right vertex as visited and checks if it can either find a path or update the match.\n        If the gap is not zero, it updates the slack value for the right vertex.\n        The function returns True if a path is found, otherwise False.\n        \"\"\"\n        # Mark this node as visited\n        self.visited[i] = True\n        \n        for v in self.adjacency_list[i]:\n            # Calculate the gap\n            gap = self.left_labels[i] + self.right_labels[v] - 1  # Assuming weight of all edges is 1\n            \n            # If the right vertex has been matched but not visited\n            if gap == 0:\n                if self.right_match[v] == -1 or (not self.visited[self.right_match[v]] and self.find_path(self.right_match[v])):\n                    # Update the matches as we found an augmenting path\n                    self.left_match[i] = v\n                    self.right_match[v] = i\n                    return True\n            else:\n                # Update the slack\n                self.slack[v] = min(self.slack[v], gap)\n        \n        return False\n    \n    def reset_visits(self):\n        self.visited = [False] * self.n_left\n\n    def execute_matching(self):\n        # Repeatedly finding paths and updating matches \n        matching_size = 0\n        while True:\n            self.reset_visits()\n            path_found = False\n            for i in range(self.n_left):\n                if self.left_match[i] == -1:\n                    if self.find_path(i):\n                        matching_size += 1\n                        path_found = True\n            if not path_found:\n                break\n        return matching_size", "CodeBleu_score": 33.35264473287635}, {"code": "def find_path(self, i)\ndef find_path(self, i):\n    \"\"\"\n    This function, find_path, attempts to find an augmenting path in a bipartite graph for matching purposes.\n    It marks the left vertex as visited and iterates through adjacent right vertices.\n    If a right vertex is already visited, it continues.\n    It calculates the gap between labels and match weight.\n    If the gap is zero, it marks the right vertex as visited and checks if it can either find a path or update the match.\n    If the gap is not zero, it updates the slack value for the right vertex.\n    The function returns True if a path is found, otherwise False.\n    \"\"\"\n\n    # Marking the left vertex 'i' as visited\n    self.visited[i] = True\n\n    for j in range(self.n):  # Assuming self.n is the number of nodes in the right vertex set\n        if self.used[j]:\n            continue\n        \n        gap = self.left_label[i] + self.right_label[j] - self.weight[i][j]\n        \n        if gap == 0:\n            self.used[j] = True\n            if self.matchR[j] == -1 or self.find_path(self.matchR[j]):\n                self.matchR[j] = i\n                return True\n        else:\n            self.slack[j] = min(self.slack[j], gap)\n    \n    return False\n\n# Note: This implementation assumes there are member variables `visited`, `used`, `left_label`, `right_label`, `weight`, `matchR`, and `slack` within the class.\n# `n` is assumed to be the number of vertices in the right set.\n# `find_path` is a method in a class handling this bipartite matching, which might be a part of a larger algorithm like the Hungarian algorithm or another labeling/matching methodology.\n# This function is typically used in the Hungarian algorithm, a label-correcting approach, or in finding an augmenting path in the Ford-Fulkerson method adapted for bipartite matching.", "CodeBleu_score": 44.3473919495518}, {"code": "def find_path(self, i):\n    # Mark this left vertex as visited\n    self.visited_left[i] = True\n\n    # Loop through all vertices adjacent to the left vertex i\n    for j in self.adj[i]:\n        # If this right vertex is already visited, move to the next one\n        if self.visited_right[j]:\n            continue\n\n        # Calculate the gap between the labels and the match weight\n        gap = self.label_left[i] + self.label_right[j] - self.weight[i][j]\n        \n        if gap == 0:\n            # Mark the right vertex as visited\n            self.visited_right[j] = True\n\n            # If the right vertex j is free or find_path from its match\n            if self.matchR[j] == -1 or self.find_path(self.matchR[j]):\n                # Update the match\n                self.matchR[j] = i\n                return True\n        else:\n            # If gap is not zero, update the slack\n            self.slack[j] = min(self.slack[j], gap)\n\n    return False", "CodeBleu_score": 58.38237969737283}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "class KuhnMunkresAlgorithm:\n    def __init__(self, cost_matrix):\n        self.cost_matrix = cost_matrix\n        self.n = len(cost_matrix)\n        self.max_match = 0\n        self.lx = [0] * self.n\n        self.ly = [0] * self.n\n        self.matching = [-1] * self.n\n        self.slack = [float('inf')] * self.n\n        self.slackx = [0] * self.n\n        self.prev = [-1] * self.n\n        self.S = [False] * self.n\n        self.T = [False] * self.n\n\n    def improve_labels(self, delta):\n        for i in range(self.n):\n            if self.S[i]:\n                self.lx[i] -= delta\n            if self.T[i]:\n                self.ly[i] += delta\n            if not self.T[i]:\n                self.slack[i] -= delta\n\n    def add_to_tree(self, x, prevx):\n        self.S[x] = True\n        self.prev[x] = prevx\n\n        for y in range(self.n):\n            if self.lx[x] + self.ly[y] - self.cost_matrix[x][y] < self.slack[y]:\n                self.slack[y] = self.lx[x] + self.ly[y] - self.cost_matrix[x][y]\n                self.slackx[y] = x\n\n    def update_matching(self, x):\n        while x != -1:\n            y = self.slackx[x]\n            prevx = self.matching[y]\n            self.matching[y] = x\n            x = prevx\n\n    def find_augmenting_path(self, root):\n        self.S = [False] * self.n\n        self.T = [False] * self.n\n        self.prev = [-1] * self.n\n        self.slack = [float('inf')] * self.n\n        self.slackx = [0] * self.n\n        \n        self.q = [root]\n        while self.q:\n            x = self.q.pop(0)\n            self.S[x] = True\n            for y in range(self.n):\n                if self.lx[x] + self.ly[y] == self.cost_matrix[x][y] and not self.T[y]:\n                    if self.matching[y] == -1:\n                        self.update_matching(x)\n                        return True\n                    self.T[y] = True\n                    self.q.append(self.matching[y])\n                    self.add_to_tree(self.matching[y], x)\n            self.improve_labels(min(self.slack[y] for y in range(self.n) if not self.T[y]))\n        return False\n\n    def KM(self):\n        self.lx = [max(self.cost_matrix[i]) for i in range(self.n)]\n        for x in range(self.n):\n            while not self.find_augmenting_path(x):\n                continue\n            if self.max_match == self.n:\n                break\n        return self.matching\n\n# Example usage with a cost matrix\ncost_matrix = [\n    [10, 19, 8, 15],\n    [10, 18, 7, 17],\n    [13, 16, 9, 14],\n    [12, 19, 8, 18],\n    [14, 17, 10, 19]\n]\nkm_algorithm = KuhnMunkresAlgorithm(cost_matrix)\nmatch_result = km_algorithm.KM()\nprint(\"Match Result:\", match_result)", "CodeBleu_score": 25.384058182693504}, {"code": "class BipartiteMatcher:\n    def __init__(self, left_size, right_size, weights):\n        self.left_size = left_size\n        self.right_size = right_size\n        self.weights = weights\n        self.left_match = [-1] * left_size\n        self.right_match = [-1] * right_size\n        self.left_label = [max(row) for row in weights]\n        self.right_label = [0] * right_size\n        self.slack = [float('inf')] * right_size\n\n    def KM(self):\n        for u in range(self.left_size):\n            self.slack = [float('inf')] * self.right_size\n            while True:\n                visited_left = [False] * self.left_size\n                visited_right = [False] * self.right_size\n                if self.augment_path(u, visited_left, visited_right):\n                    break\n                self.update_labels(visited_left, visited_right)\n\n        return self.right_match\n    \n    def augment_path(self, u, visited_left, visited_right):\n        visited_left[u] = True\n        for v in range(self.right_size):\n            if visited_right[v]:\n                continue\n            gap = self.left_label[u] + self.right_label[v] - self.weights[u][v]\n            if gap == 0:\n                visited_right[v] = True\n                if self.right_match[v] == -1 or self.augment_path(self.right_match[v], visited_left, visited_right):\n                    self.right_match[v] = u\n                    self.left_match[u] = v\n                    return True\n            else:\n                self.slack[v] = min(self.slack[v], gap)\n        return False\n\n    def update_labels(self, visited_left, visited_right):\n        delta = float('inf')\n        for v in range(self.right_size):\n            if not visited_right[v]:\n                delta = min(delta, self.slack[v])\n        for u in range(self.left_size):\n            if visited_left[u]:\n                self.left_label[u] -= delta\n        for v in range(self.right_size):\n            if visited_right[v]:\n                self.right_label[v] += delta\n            else:\n                self.slack[v] -= delta", "CodeBleu_score": 24.278504975664458}, {"code": "class BipartiteMatcher:\n    def __init__(self, cost_matrix):\n        self.cost_matrix = cost_matrix\n        self.n = len(cost_matrix)  # Number of rows (UAVs)\n        self.m = len(cost_matrix[0]) if self.n > 0 else 0  # Number of columns (Tasks)\n        self.u = [0] * self.n  # Potential for UAVs\n        self.v = [0] * self.m  # Potential for tasks\n        self.pair_u = [-1] * self.n  # Matching pairs for UAVs\n        self.pair_v = [-1] * self.m  # Matching pairs for tasks\n        self.dist = [float('inf')] * self.m\n        self.visited_u = [False] * self.n\n        self.visited_v = [False] * self.m\n    \n    def KM(self):\n        for u in range(self.n):  # iterating over each UAV\n            self.dist = [float('inf')] * self.m\n            self.visited_u = [False] * self.n\n            self.visited_v = [False] * self.m\n            \n            while True:\n                self.visited_u[u] = True\n                path_found = False\n                delta = float('inf')\n\n                # Find the closest task\n                for v in range(self.m):\n                    if not self.visited_v[v]:\n                        cur_dist = self.cost_matrix[u][v] - self.u[u] - self.v[v]\n                        if cur_dist <= self.dist[v]:\n                            self.dist[v] = cur_dist\n                        if self.dist[v] == 0:\n                            self.visited_v[v] = True\n                            if self.pair_v[v] == -1 or not self.visited_u[self.pair_v[v]]:\n                                path_found = self._dfs(v)\n                                if path_found:\n                                    break\n                \n                if path_found:\n                    break\n            \n                # Update potential\n                for i in range(self.m):\n                    if not self.visited_v[i]:\n                        delta = min(delta, self.dist[i])\n                \n                for j in range(self.n):\n                    if self.visited_u[j]:\n                        self.u[j] += delta\n                for j in range(self.m):\n                    if self.visited_v[j]:\n                        self.v[j] -= delta\n                    else:\n                        self.dist[j] -= delta\n                        \n            u = 0  # Reset u to continue for the next UAV\n        \n        return self.pair_v  # Return matching results for tasks\n    \n    def _dfs(self, v):\n        self.visited_v[v] = True\n        if self.pair_v[v] == -1 or not self.visited_u[self.pair_v[v]] and self._dfs(self.pair_v[v]):\n            self.pair_v[v] = v\n            return True\n        return False", "CodeBleu_score": 26.582301793603403}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "import cv2\nimport numpy as np\n\ndef yellow_detection(image):\n    \"\"\"\n    This function, yellow_detection, detects yellow color in an image.\n    It converts the image to HSV color space and creates a mask for yellow color using specified \n    lower and upper HSV bounds.\n    The function then applies the mask to the original image using bitwise_and and returns the result.\n\n    Args:\n    image (numpy.ndarray): A BGR image array as read by OpenCV.\n\n    Returns:\n    numpy.ndarray: An image array with only the yellow components visible.\n    \"\"\"\n    \n    # Convert image from BGR (OpenCV default) to HSV\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define range of yellow color in HSV\n    # These thresholds can be changed according to specific needs\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    \n    # Create a mask for yellow color\n    yellow_mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    \n    # Apply the mask on the original image\n    yellow_output = cv2.bitwise_and(image, image, mask=yellow_mask)\n    \n    return yellow_output", "CodeBleu_score": 62.42336789853413}, {"code": "import cv2\nimport numpy as np\n\ndef yellow_detection(image):\n    \"\"\"\n    This function, yellow_detection, detects yellow color in an image.\n    It converts the image to HSV color space and creates a mask for yellow color using specified lower and upper HSV bounds.\n    The function then applies the mask to the original image using bitwise_and and returns the result.\n\n    :param image: numpy.ndarray, An image in BGR format (as read by cv2.imread)\n    :return: numpy.ndarray, The image with only the yellow components visible\n    \"\"\"\n    # Convert the input image to HSV color-space\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the range of yellow color in HSV\n    lower_yellow = np.array([22, 93, 0])  # Lower bound of yellow\n    upper_yellow = np.array([45, 255, 255])  # Upper bound of yellow\n\n    # Create a binary mask where yellow colors are white and the rest are black\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise AND\n    yellow_detection = cv2.bitwise_and(image, image, mask=mask)\n\n    return yellow_detection", "CodeBleu_score": 57.36130276833341}, {"code": "bash\npip install opencv-python", "CodeBleu_score": 1.1435267414197854e-55}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "#include <iostream>\n#include <string>\n#include <map>\n#include <optional>\n\nclass TagDetector {\nprivate:\n    std::map<int, std::string> standalone_tag_descriptions_;\n\npublic:\n    TagDetector() {\n        // Example set of descriptions\n        standalone_tag_descriptions_[1] = \"First tag description\";\n        standalone_tag_descriptions_[2] = \"Second tag description\";\n        standalone_tag_descriptions_[3] = \"Third tag description\";\n    }\n\n    bool findStandaloneTagDescription(int tagID, std::string& descriptionContainer, bool printWarning = false) {\n        auto it = standalone_tag_descriptions_.find(tagID);\n\n        if (it != standalone_tag_descriptions_.end()) {\n            descriptionContainer = it->second;\n            return true;\n        } else {\n            if (printWarning) {\n                std::cerr << \"Warning: Tag ID \" << tagID << \" not found.\" << std::endl;\n            }\n            return false;\n        }\n    }\n};\n\nint main() {\n    TagDetector detector;\n    std::string description;\n    bool found;\n\n    found = detector.findStandaloneTagDescription(1, description);\n    if (found) {\n        std::cout << \"Tag 1: \" << description << \"\\n\";\n    } else {\n        std::cout << \"Tag 1 not found.\\n\";\n    }\n\n    found = detector.findStandaloneTagDescription(4, description, true);\n    if (found) {\n        std::cout << \"Tag 4: \" << description << \"\\n\";\n    } else {\n        std::cout << \"Tag 4 not found.\\n\";\n    }\n\n    return 0;\n}", "CodeBleu_score": 44.30838343364171}, {"code": "#include <map>\n#include <string>\n#include <iostream>\n\nclass TagDetector {\nprivate:\n    std::map<int, std::string> standalone_tag_descriptions_;\n\npublic:\n    TagDetector() {\n        // Example initializations; in a real system, these might come from a file or database.\n        standalone_tag_descriptions_[1] = \"Description for tag 1\";\n        standalone_tag_descriptions_[2] = \"Description for tag 2\";\n        standalone_tag_descriptions_[3] = \"Description for tag 3\";\n    }\n\n    bool findStandaloneTagDescription(int tagID, std::string& descriptionContainer, bool printWarning) {\n        auto it = standalone_tag_descriptions_.find(tagID);\n        if (it != standalone_tag_descriptions_.end()) {\n            descriptionContainer = it->second;\n            return true;\n        } else {\n            if (printWarning) {\n                std::cerr << \"Warning: No description found for tag with ID \" << tagID << std::endl;\n            }\n            return false;\n        }\n    }\n};\n\nint main() {\n    TagDetector detector;\n\n    std::string description;\n    if (detector.findStandaloneTagDescription(1, description, true)) {\n        std::cout << \"Description: \" << description << std::endl;\n    }\n    \n    if (!detector.findStandaloneTagDescription(100, description, true)) {\n        std::cout << \"Description not found.\" << std::endl;\n    }\n\n    return 0;\n}", "CodeBleu_score": 46.537770074798935}, {"code": "bool TagDetector::findStandaloneTagDescription\n(int tagID, bool printWarning, std::string &descriptionContainer) {\n    // Check if the tag ID is present in the map\n    auto it = standalone_tag_descriptions_.find(tagID);\n    \n    if (it != standalone_tag_descriptions_.end()) {\n        // If the tag description is found, set the output parameter and return true\n        descriptionContainer = it->second;\n        return true;\n    } else {\n        // If the tag description is not found\n        if (printWarning) {\n            // If printWarning is true, print a warning message\n            std::cerr << \"Warning: No description found for tag with ID \" << tagID << \".\" << std::endl;\n        }\n        return false;\n    }\n}", "CodeBleu_score": 53.81709274876854}]}
