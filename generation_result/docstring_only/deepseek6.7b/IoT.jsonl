{"instance_id": "37c223ece5db", "generation_result": [{"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_conf_desc_t UDC_DESC_STORAGE *p = desc;\n\twhile (p->bLength) {\n\t\tif (p->bDescriptorType == desc_id)\n\t\t\treturn p;\n\t\tp = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *)p\n\t\t\t\t+ p->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 21.874732180131435}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tuint8_t *desc_ptr = (uint8_t *) desc;\n\tuint8_t desc_length = desc->bLength;\n\n\twhile (desc_length > 0) {\n\t\tif (desc_ptr[1] == desc_id)\n\t\t\treturn (usb_conf_desc_t UDC_DESC_STORAGE *) desc_ptr;\n\n\t\tdesc_length = desc_ptr[0];\n\t\tdesc_ptr += desc_length;\n\t}\n\n\treturn NULL;\n}\n", "CodeBleu_score": 27.419945331567103}, {"code": "static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t\n\t\tUDC_DESC_STORAGE * desc, uint8_t desc_id)\tusb_conf_desc_t UDC_DESC_STORAGE * next_desc = desc;\n\twhile (next_desc->bLength > 0) {\n\t\tif (next_desc->bDescriptorType == desc_id) {\n\t\t\treturn next_desc;\n\t\t}\n\t\tnext_desc = (usb_conf_desc_t UDC_DESC_STORAGE *)((uint8_t UDC_DESC_STORAGE *) next_desc + next_desc->bLength);\n\t}\n\treturn NULL;\n}\n", "CodeBleu_score": 25.36427214551206}]}
{"instance_id": "4feb3728e1a8", "generation_result": [{"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)    uint8_t *desc = usb_config_desc;\n    uint8_t desc_len = *desc++;\n    uint8_t desc_type = *desc++;\n    uint16_t desc_len_total = *desc++;\n    desc_len_total = (desc_len_total << 8) | *desc++;\n\n    if (desc_type != USB_DESC_TYPE_CONFIGURATION) {\n        return false;\n    }\n    if (desc_len_total != desc_len_total) {\n        return false;\n    }\n    if (iface_num >= desc_len_total) {\n        return false;\n    }\n\n    while (desc_len_total > 0) {\n        desc_len = *desc++;\n        desc_type = *desc++;\n        desc_len_total -= desc_len;\n        desc_len_total -= 2;\n\n        if (desc_len_total < 0) {\n            return false;\n        }\n\n        if (desc_type == USB_DESC_TYPE_INTERFACE) {\n            uint8_t iface_num_tmp = *desc++;\n            uint8_t alt_setting_num = *desc++;\n            uint8_t iface_class = *desc++;\n            uint8_t iface_subclass = *desc++;\n            uint8_t iface_protocol = *desc++;\n            uint8_t iface_endpoint_num = *desc++;\n\n            if (iface_num_tmp == iface_num && alt_setting_num == setting_num) {\n                return true;\n            }\n        }\n\n        desc += desc_len;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 36.285551646462324}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)    struct usb_desc_config *config;\n    struct usb_desc_iface *iface;\n    uint16_t i;\n\n    /* Check if the current configuration is valid */\n    if (!udc_get_config()) {\n        return false;\n    }\n\n    /* Check if the interface number is within bounds */\n    if (iface_num >= udc_get_config()->num_ifaces) {\n        return false;\n    }\n\n    /* Get the configuration descriptor */\n    config = udc_get_config()->desc;\n\n    /* Iterate through the interface descriptors */\n    for (i = 0; i < config->desc_len; i += iface->desc_len) {\n        /* Get the interface descriptor */\n        iface = (struct usb_desc_iface *) &config->desc[i];\n\n        /* Check if the interface number and setting number match */\n        if (iface->iface_num == iface_num && iface->setting_num == setting_num) {\n            return true;\n        }\n    }\n\n    /* No matching interface descriptor found */\n    return false;\n}", "CodeBleu_score": 36.52363404412135}, {"code": "static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)  bool ret = false;\n  uint8_t *desc_ptr = (uint8_t *) &udc_config_desc;\n  uint8_t desc_len = udc_config_desc.wTotalLength;\n  uint8_t desc_type;\n  uint8_t desc_len_remaining;\n\n  if (iface_num >= udc_config_desc.bNumInterfaces) {\n    return false;\n  }\n\n  while (desc_len) {\n    desc_type = *desc_ptr++;\n    desc_len_remaining = *desc_ptr++;\n    desc_len -= 2;\n    desc_len -= desc_len_remaining;\n\n    if (desc_type == USB_DESC_TYPE_INTERFACE) {\n      if (desc_len_remaining < 9) {\n        break;\n      }\n\n      if (desc_ptr[0] == iface_num && desc_ptr[7] == setting_num) {\n        ret = true;\n        break;\n      }\n    }\n  }\n\n  return ret;\n}\n", "CodeBleu_score": 37.23195139409698}]}
{"instance_id": "4e3b5aff2b43", "generation_result": [{"code": "static bool udc_req_std_ep_get_status(void)  uint8_t *p_data;\n  uint8_t status;\n\n  /* Check if the request length matches the size of the endpoint status variable. */\n  if (req_length != sizeof(status)) {\n    return false;\n  }\n\n  /* Determine the status of the specified endpoint. */\n  if (ep_halted[req_ep]) {\n    status = USB_ENDPOINT_STATUS_HALTED;\n  } else {\n    status = 0;\n  }\n\n  /* Set up the response payload with the endpoint status. */\n  p_data = (uint8_t *)&status;\n  udc_setup_response(p_data, req_length);\n\n  return true;\n}\n", "CodeBleu_score": 32.19774497421975}, {"code": "static bool udc_req_std_ep_get_status(void)    uint8_t *buf = udc_get_setup_buf();\n    uint8_t *ep_status;\n    uint8_t ep_num;\n\n    if (buf[1] != sizeof(uint8_t)) {\n        return false;\n    }\n\n    ep_num = buf[2];\n    ep_status = &udc_ep_status[ep_num];\n\n    if (*ep_status & UDC_EP_ST_HALT) {\n        *ep_status = UDC_EP_ST_HALT;\n    } else {\n        *ep_status = 0;\n    }\n\n    udc_set_response_data(ep_status, sizeof(uint8_t));\n\n    return true;\n}", "CodeBleu_score": 38.289344068069035}, {"code": "static bool udc_req_std_ep_get_status(void)    /* Check if the request length matches the size of the endpoint status variable. */\n    if (req.wLength != sizeof(uint8_t)) {\n        return false;\n    }\n\n    /* Determine the status of the specified endpoint. */\n    uint8_t status = 0;\n    if (ep_halted[req.wIndex]) {\n        status = 1;\n    }\n\n    /* Set up the response payload with the endpoint status. */\n    memcpy(resp.buf, &status, sizeof(uint8_t));\n\n    return true;\n}\n", "CodeBleu_score": 34.06124879554848}]}
{"instance_id": "0d705073305d", "generation_result": [{"code": "static bool udc_req_iface(void)    // Check if the device is in a configured state\n    if (udc_state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n\n    // Check if the requested interface number is valid\n    if (setup_packet.wIndex >= udc_config.num_ifaces) {\n        return false;\n    }\n\n    // Update the interface descriptor to the default setting\n    if (!udc_update_iface_desc(setup_packet.wIndex, 0)) {\n        return false;\n    }\n\n    // Update the interface descriptor to the current alternate setting\n    if (!udc_update_iface_desc(setup_packet.wIndex, udc_config.iface_alt_setting[setup_packet.wIndex])) {\n        return false;\n    }\n\n    // Forward the SETUP request to the corresponding USB Device Interface (UDI) handler\n    return udi_iface[setup_packet.wIndex]->setup(setup_packet.bRequest, setup_packet.wValue, setup_packet.wIndex, setup_packet.wLength, setup_packet.data);\n}\n", "CodeBleu_score": 52.95168570352216}, {"code": "static bool udc_req_iface(void)    /* Check if the device is in a configured state */\n    if (g_udc.state != UDC_STATE_CONFIGURED) {\n        return false;\n    }\n\n    /* Check if the requested interface number is valid */\n    if (g_udc.req.wIndex >= g_udc.num_ifaces) {\n        return false;\n    }\n\n    /* Update the interface descriptor to the default setting */\n    if (!udc_set_iface_desc(g_udc.req.wIndex, 0)) {\n        return false;\n    }\n\n    /* Update the interface descriptor to the current alternate setting */\n    if (!udc_set_iface_desc(g_udc.req.wIndex, g_udc.alt_settings[g_udc.req.wIndex])) {\n        return false;\n    }\n\n    /* Forward the SETUP request to the corresponding USB Device Interface (UDI) handler */\n    if (g_udc.ifaces[g_udc.req.wIndex].udi_handler != NULL) {\n        return g_udc.ifaces[g_udc.req.wIndex].udi_handler->setup(g_udc.req.bmRequestType, g_udc.req.bRequest, g_udc.req.wValue, g_udc.req.wIndex, g_udc.req.wLength, g_udc.req.data);\n    }\n\n    /* Return true if the request was successfully processed */\n    return true;\n}", "CodeBleu_score": 51.26522270185354}, {"code": "static bool udc_req_iface(void)    bool ret;\n    uint8_t iface;\n\n    if (!udc_is_configured()) {\n        return false;\n    }\n\n    iface = udc_get_iface_num();\n    if (iface >= udc_get_num_ifaces()) {\n        return false;\n    }\n\n    if (!udc_iface_set_alt_setting(iface, 0)) {\n        return false;\n    }\n\n    if (!udc_iface_set_alt_setting(iface, udc_get_iface_alt_setting(iface))) {\n        return false;\n    }\n\n    ret = udc_iface_req_setup(iface);\n\n    return ret;\n}\n", "CodeBleu_score": 49.71905326297901}]}
{"instance_id": "cfe149164a72", "generation_result": [{"code": "bool udi_msc_enable(void)    // Initialize and enable the MSC interface\n    udi_msc_init();\n    udi_msc_enable_ext(0);\n\n    // Get the number of LUNs\n    uint8_t lun_count = udi_msc_get_lun_count();\n\n    // Check if there are any LUNs available\n    if (lun_count == 0) {\n        return false;\n    }\n\n    // Unload the medium on each LUN\n    for (uint8_t lun = 0; lun < lun_count; lun++) {\n        udi_msc_unload_medium(lun);\n    }\n\n    // Start the MSC process\n    while (1) {\n        // Wait for a CBW reception\n        while (!udi_msc_get_cbw()) {\n            // Do something else\n        }\n\n        // Process the CBW\n        udi_msc_process_cbw();\n    }\n\n    return true;\n}\n", "CodeBleu_score": 43.86795369928333}, {"code": "bool udi_msc_enable(void)    // Initialize the MSC interface\n    udi_msc_init();\n\n    // Enable the MSC interface\n    udi_msc_enable_external();\n\n    // Get the number of LUNs\n    uint8_t lun_count = udi_msc_get_lun_count();\n\n    // Check if there are any LUNs available\n    if (lun_count == 0) {\n        return false;\n    }\n\n    // Unload the medium on each LUN\n    for (uint8_t lun = 0; lun < lun_count; lun++) {\n        udi_msc_unload_medium(lun);\n    }\n\n    // Start the MSC process by waiting for a CBW reception\n    while (!udi_msc_cbw_received) {\n        // Wait for a CBW reception\n    }\n\n    return true;\n}", "CodeBleu_score": 40.656694969386976}, {"code": "bool udi_msc_enable(void)  uint8_t lun_count;\n  bool ret = false;\n\n  /* Initialize the MSC interface */\n  udi_msc_init();\n\n  /* Retrieve the number of LUNs */\n  lun_count = udi_msc_get_lun_count();\n\n  /* Check if there are any LUNs available */\n  if (lun_count) {\n    /* Unload the medium on each LUN */\n    for (uint8_t i = 0; i < lun_count; i++) {\n      udi_msc_unload_medium(i);\n    }\n\n    /* Start the MSC process */\n    udi_msc_process();\n    ret = true;\n  }\n\n  return ret;\n}\n", "CodeBleu_score": 37.0926420907049}]}
{"instance_id": "87967e204674", "generation_result": [{"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)  udi_msc_t *msc = &udi_msc;\n  udi_msc_cbw_t *cbw = &msc->cbw;\n  udi_msc_csw_t *csw = &msc->csw;\n  udi_msc_sense_t *sense = &msc->sense;\n  udi_msc_ep_t *ep_data = &msc->ep[ep];\n  udi_msc_ep_t *ep_in = &msc->ep[MSC_EP_IN];\n  udi_msc_ep_t *ep_out = &msc->ep[MSC_EP_OUT];\n\n  if (status != UDD_EP_STATUS_OK) {\n    if (ep_data->state == UDI_MSC_EP_STATE_DATA_IN) {\n      ep_data->state = UDI_MSC_EP_STATE_DATA_IN_ERROR;\n    } else {\n      ep_data->state = UDI_MSC_EP_STATE_DATA_OUT_ERROR;\n    }\n    ep_data->error = status;\n    ep_data->nb_sent = 0;\n    ep_data->nb_received = 0;\n    ep_data->nb_to_send = 0;\n    ep_data->nb_to_receive = 0;\n\n    /*\n     * If the transfer is not successful, the MSC setup reset is triggered to\n     * restart CBW reception.\n     */\n    udi_msc_setup_reset();\n\n    return;\n  }\n\n  /*\n   * If the transfer is successful, the sense data is updated and the CSW is\n   * updated by the amount of data sent.\n   */\n  if (ep_data->state == UDI_MSC_EP_STATE_DATA_IN) {\n    ep_data->state = UDI_MSC_EP_STATE_DATA_IN_OK;\n    ep_data->nb_sent += nb_sent;\n    ep_data->nb_received += n", "CodeBleu_score": 45.659897266040474}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)    if (status != UDD_EP_STATUS_SUCCESS) {\n        /*\n         * If the transfer is not successful, wait for a MSC setup reset to restart CBW reception.\n         */\n        udi_msc_reset();\n    } else {\n        /*\n         * If the transfer is successful, update the sense data, decrease the data residue in the CSW by the amount of data sent, and process the updated CSW.\n         */\n        udi_msc_sense_data[3] = (uint8_t)(nb_sent & 0xFF);\n        udi_msc_sense_data[4] = (uint8_t)((nb_sent >> 8) & 0xFF);\n        udi_msc_sense_data[5] = (uint8_t)((nb_sent >> 16) & 0xFF);\n        udi_msc_sense_data[6] = (uint8_t)((nb_sent >> 24) & 0xFF);\n        udi_msc_csw.data_residue -= nb_sent;\n        udi_msc_process_csw();\n    }\n}\n", "CodeBleu_score": 47.00785864409337}, {"code": "static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,\n    udd_ep_id_t ep)  /* Check the status of the transfer. */\n  if (status != UDD_EP_STATUS_OK) {\n    /* If the transfer is not successful, wait for a MSC setup reset to\n       restart CBW reception. */\n    udi_msc_reset_cbw();\n    return;\n  }\n\n  /* Update the sense data. */\n  udi_msc_update_sense_data(nb_sent);\n\n  /* Decrease the data residue in the Command Status Wrapper (CSW) by the\n     amount of data sent. */\n  udi_msc_csw.data_residue -= nb_sent;\n\n  /* Process the updated CSW. */\n  udi_msc_process_csw();\n}\n", "CodeBleu_score": 57.81146522950959}]}
{"instance_id": "223e49dddfc0", "generation_result": [{"code": "static void udi_msc_csw_process(void)  if (udi_msc_cbw_data_residue) {\n    udi_msc_cbw_data_residue = 0;\n    if (udi_msc_cbw_direction == USB_MSC_CBW_IN) {\n      udi_msc_cbw_out_stall();\n    } else {\n      udi_msc_cbw_in_stall();\n    }\n  }\n\n  udi_msc_csw_tag = udi_msc_cbw_tag;\n  udi_msc_csw_data_residue = htole32(udi_msc_cbw_data_residue);\n}\n", "CodeBleu_score": 41.26077312764268}, {"code": "static void udi_msc_csw_process(void)  /*\n   * The \"udi_msc_cbw_data_residue\" variable is used to store the data residue from the Command Block Wrapper (CBW).\\nThe data residue is the amount of data that remains to be transferred in the current request.\\nIt is used to determine whether the USB host should stall the next request on the appropriate endpoint based on the direction of the CBW.\\nThe data residue is also used to prepare the CSW.\n   */\n  uint32_t udi_msc_cbw_data_residue;\n\n  /*\n   * The \"udi_msc_cbw_direction\" variable is used to store the direction of the Command Block Wrapper (CBW).\\nThe direction is used to determine whether the USB host should stall the next request on the appropriate endpoint based on the direction of the CBW.\\nThe direction is also used to determine the direction of the CSW.\n   */\n  uint8_t udi_msc_cbw_direction;\n\n  /*\n   * The \"udi_msc_cbw_length\" variable is used to store the length of the Command Block Wrapper (CBW).\\nThe length is used to determine whether the USB host should stall the next request on the appropriate endpoint based on the direction of the CBW.\\nThe length is also used to determine the length of the CSW.\n   */\n  uint32_t udi_msc_cbw_length;\n\n  /*\n   * The \"udi_msc_cbw_tag\" variable is used to store the tag of the Command Block Wrapper (CBW).\\nThe tag is used to prepare the Command Status Wrapper (CSW).\n   */\n  uint32_t udi_msc_cbw_tag;\n\n  /*\n   * The \"udi_msc_csw_data_residue\" variable is used to store the data residue from the Command Status Wrapper (CSW).\\nThe data residue is the amount of data that remains to be transferred in the current request.\\nIt is used to determine whether the USB host should stall the next request on the appropriate endpoint based on the direction of the CBW.\\nThe", "CodeBleu_score": 26.87161814522616}, {"code": "static void udi_msc_csw_process(void)  uint8_t csw[13];\n  uint32_t data_residue;\n  uint8_t endpoint;\n  uint8_t dir;\n  uint32_t tag;\n\n  /* Get the data residue and the endpoint number from the CBW */\n  data_residue = udi_msc_cbw_get_data_residue();\n  endpoint = udi_msc_cbw_get_endpoint();\n  dir = udi_msc_cbw_get_direction();\n\n  /* If there is a non-zero data residue, stall the next request from the USB host on the appropriate endpoint */\n  if (data_residue) {\n    if (dir == USB_DIR_OUT) {\n      udi_msc_ep_stall(endpoint);\n    } else {\n      udi_msc_ep_stall(endpoint | 0x80);\n    }\n  }\n\n  /* Prepare the CSW */\n  tag = udi_msc_cbw_get_tag();\n  csw[0] = (uint8_t)(tag & 0xFF);\n  csw[1] = (uint8_t)((tag >> 8) & 0xFF);\n  csw[2] = (uint8_t)((tag >> 16) & 0xFF);\n  csw[3] = (uint8_t)((tag >> 24) & 0xFF);\n  csw[4] = 0;\n  csw[5] = 0;\n  csw[6] = 0;\n  csw[7] = 0;\n  csw[8] = 0;\n  csw[9] = 0;\n  csw[10] = data_residue & 0xFF;\n  csw[11] = (data_residue >> 8) & 0xFF;\n  csw[12] = (data_residue >> 16) & 0xFF;\n\n  /* Send the CSW */\n  udi_msc_ep_write(endpoint,", "CodeBleu_score": 34.18800302786555}]}
{"instance_id": "839b7d837327", "generation_result": [{"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)    if (b_enable) {\n        usb_cdc_dtr_status[port] = true;\n        if (usb_cdc_dtr_rate[port] == USB_CDC_DTR_RATE_1200) {\n            if (reset_status == RESET_STATUS_NONE) {\n                reset_status = RESET_STATUS_SCHEDULED;\n                reset_scheduled_time = system_time_get() + RESET_SCHEDULED_DELAY;\n                reset_scheduled_port = port;\n            }\n        } else {\n            reset_status = RESET_STATUS_NONE;\n        }\n    } else {\n        usb_cdc_dtr_status[port] = false;\n        if (reset_status == RESET_STATUS_SCHEDULED) {\n            if (reset_scheduled_port == port) {\n                reset_status = RESET_STATUS_NONE;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 38.56991060016879}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)  if (port >= USB_PORT_COUNT) {\n    return;\n  }\n\n  const uint8_t port_index = port;\n  const uint8_t port_index_mask = (1 << port_index);\n\n  if (b_enable) {\n    g_usb_port_dtr_status[port_index] = true;\n    if (g_usb_port_dtr_rate[port_index] == 1200) {\n      if (!g_usb_port_reset_scheduled[port_index]) {\n        g_usb_port_reset_scheduled[port_index] = true;\n        g_usb_port_reset_scheduled_time[port_index] = millis() + USB_PORT_RESET_DELAY_MS;\n        initiateReset(port_index);\n      }\n    }\n  } else {\n    g_usb_port_dtr_status[port_index] = false;\n    if (g_usb_port_dtr_rate[port_index] == 1200) {\n      if (g_usb_port_reset_scheduled[port_index]) {\n        g_usb_port_reset_scheduled[port_index] = false;\n        cancelReset(port_index);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 39.63475370484485}, {"code": "void usb_task_cdc_set_dtr(const uint8_t port, const bool b_enable)    if (b_enable) {\n        usb_task_cdc_dtr_status[port] = true;\n        usb_task_cdc_dtr_rate[port] = 0;\n        usb_task_cdc_dtr_rate_counter[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port] = 0;\n        usb_task_cdc_dtr_rate_counter_delay_max[port]", "CodeBleu_score": 32.35472223133502}]}
{"instance_id": "1583927e29c8", "generation_result": [{"code": "bool usb_task_other_requests(void)    if (usb_setup_request_type == USB_SETUP_TYPE_VENDOR && usb_setup_request == USB_SETUP_REQUEST_OTHER) {\n        switch (usb_setup_request_index) {\n            case USB_SETUP_REQUEST_INDEX_ID_DESCRIPTOR:\n                usb_descriptor_id_size = sizeof(usb_descriptor_id);\n                usb_descriptor_id_ptr = (uint8_t *)&usb_descriptor_id;\n                usb_descriptor_id_ptr += usb_setup_request_value;\n                usb_descriptor_id_size -= usb_setup_request_value;\n                usb_setup_request_size = usb_descriptor_id_size;\n                usb_setup_request_size += usb_setup_request_size % 4;\n                break;\n            case USB_SETUP_REQUEST_INDEX_EXTENDED_PROPERTIES_DESCRIPTOR:\n                usb_descriptor_extended_properties_size = sizeof(usb_descriptor_extended_properties);\n                usb_descriptor_extended_properties_ptr = (uint8_t *)&usb_descriptor_extended_properties;\n                usb_descriptor_extended_properties_ptr += usb_setup_request_value;\n                usb_descriptor_extended_properties_size -= usb_setup_request_value;\n                usb_setup_request_size = usb_descriptor_extended_properties_size;\n                usb_setup_request_size += usb_setup_request_size % 4;\n                break;\n            default:\n                return false;\n        }\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 31.893704813510617}, {"code": "bool usb_task_other_requests(void)    uint8_t *p = (uint8_t *)&usb_setup_packet;\n    uint8_t *q = (uint8_t *)&usb_setup_packet.wValue;\n    uint16_t *w = (uint16_t *)&usb_setup_packet.wLength;\n    uint8_t *r = (uint8_t *)&usb_setup_packet.wIndex;\n\n    switch (usb_setup_packet.bRequest) {\n        case 0x04:\n            if (usb_setup_packet.wLength >= 4) {\n                usb_setup_packet.wLength = 4;\n                usb_setup_packet.wIndex = 0;\n                usb_setup_packet.wValue = 0;\n                usb_setup_packet.bRequest = 0;\n                return true;\n            }\n            break;\n        case 0x05:\n            if (usb_setup_packet.wLength >= 4) {\n                usb_setup_packet.wLength = 4;\n                usb_setup_packet.wIndex = 0;\n                usb_setup_packet.wValue = 0;\n                usb_setup_packet.bRequest = 0;\n                return true;\n            }\n            break;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 24.143955509642566}, {"code": "bool usb_task_other_requests(void)    uint8_t *p_descriptor = NULL;\n    uint16_t descriptor_size = 0;\n\n    if (usb_request_type == USB_REQUEST_TYPE_VENDOR) {\n        switch (usb_request_index) {\n            case 0x04:\n                p_descriptor = (uint8_t *)&usb_device_descriptor;\n                descriptor_size = sizeof(usb_device_descriptor);\n                break;\n            case 0x05:\n                p_descriptor = (uint8_t *)&usb_configuration_descriptor;\n                descriptor_size = sizeof(usb_configuration_descriptor);\n                break;\n            default:\n                break;\n        }\n\n        if (p_descriptor != NULL) {\n            usb_request_payload_size = descriptor_size;\n            usb_request_payload = p_descriptor;\n            usb_request_status = USB_REQUEST_STATUS_SUCCESS;\n            return true;\n        }\n    }\n\n    return false;\n}\n", "CodeBleu_score": 29.71557041154158}]}
{"instance_id": "6deb4a0512e1", "generation_result": [{"code": "void spiRead(uint8_t *buf, uint16_t nbyte)  uint16_t i;\n\n  if (!nbyte) return;\n  for (i = 0; i < nbyte; i++) {\n    buf[i] = spiRec();\n  }\n}\n", "CodeBleu_score": 44.20587703066657}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)  if (nbyte == 0) return;\n  uint8_t dummy = 0x00;\n  for (uint16_t i = 0; i < nbyte; i++) {\n    SPDR = dummy;\n    while(!(SPSR & (1<<SPIF)))\n      ;\n    buf[i] = SPDR;\n  }\n  spiRec();\n  buf[nbyte-1] = SPDR;\n}", "CodeBleu_score": 53.049455971401095}, {"code": "void spiRead(uint8_t *buf, uint16_t nbyte)  if (!nbyte)\n    return;\n  for (uint16_t i = 0; i < nbyte - 1; i++) {\n    spiSend(0x00);\n    buf[i] = spiRec();\n  }\n  buf[nbyte - 1] = spiRec();\n}\n", "CodeBleu_score": 57.442625331845676}]}
{"instance_id": "6f07faaace16", "generation_result": [{"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)\tuint32_t *vectorTable = (uint32_t *)SCB->VTOR;\n\tuint32_t *vectorTableOffset = vectorTable + irq;\n\tuint32_t currentHandler = *vectorTableOffset;\n\tuint32_t newHandlerWithAttribute = (uint32_t)newHandler | (1 << (8 - 1));\n\t__disable_irq();\n\t*vectorTableOffset = (uint32_t)newHandlerWithAttribute;\n\t__enable_irq();\n\treturn (pfnISR_Handler)currentHandler;\n}\n", "CodeBleu_score": 37.353621827736674}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    pfnISR_Handler originalHandler;\n    uint32_t *pISR = (uint32_t *)&NVIC_ISER0;\n    uint32_t irq_mask = 1 << (irq & 0x1F);\n\n    // Disable global interrupts\n    __disable_irq();\n\n    // Get the current handler for the specified IRQ\n    originalHandler = (pfnISR_Handler)pISR[irq >> 5];\n\n    // Replace the handler for the specified IRQ with the new handler\n    pISR[irq >> 5] = (uint32_t)newHandler;\n\n    // Enable the IRQ\n    NVIC_ISER0 = irq_mask;\n\n    // Re-enable global interrupts\n    __enable_irq();\n\n    // Return the original handler\n    return originalHandler;\n}", "CodeBleu_score": 51.37543395674835}, {"code": "pfnISR_Handler install_isr(IRQn_Type irq, pfnISR_Handler newHandler)    // Get the address of the relocated interrupt vector table\n    uint32_t *pISR = (uint32_t *)NVIC_BASE;\n\n    // Disable global interrupts to ensure atomic operation\n    uint32_t primask = __get_PRIMASK();\n    __disable_irq();\n\n    // Retrieve the current handler for the specified IRQ\n    pfnISR_Handler oldHandler = (pfnISR_Handler)pISR[irq];\n\n    // Replace the handler with the new handler\n    pISR[irq] = (uint32_t)newHandler;\n\n    // Re-enable global interrupts\n    __set_PRIMASK(primask);\n\n    // Return the original ISR handler\n    return oldHandler;\n}\n", "CodeBleu_score": 48.35194378836075}]}
{"instance_id": "34133faca84a", "generation_result": [{"code": "int MarlinSerialUSB::peek()  if (!_usb_enabled || !_usb_configured) return -1;\n  if (usb_serial_available()) {\n    int c = usb_serial_getchar();\n    if (_emergency_parser_enabled && _emergency_parser_parser) {\n      _emergency_parser_parser->parse(c);\n    }\n    return c;\n  }\n  return -1;\n}\n", "CodeBleu_score": 33.71863746254622}, {"code": "int MarlinSerialUSB::peek()  if (!_usb_enabled || !_usb_configured || !_usb_connected)\n    return -1;\n  if (usb_serial_available()) {\n    uint8_t c = usb_serial_getchar();\n    if (_emergency_parser_enabled)\n      emergency_parser_process(c);\n    return c;\n  }\n  return -1;\n}\n", "CodeBleu_score": 33.055123462082555}, {"code": "int MarlinSerialUSB::peek()  int c = -1;\n  if (usb_serial) {\n    if (usb_serial->available()) {\n      c = usb_serial->read();\n      if (emergency_parser_enabled) {\n        emergency_parser.parse(c);\n      }\n    }\n  }\n  return c;\n}\n", "CodeBleu_score": 32.05025555133278}]}
{"instance_id": "1bfec0523f11", "generation_result": [{"code": "int MarlinSerialUSB::read()  if (rx_buffer_head != rx_buffer_tail) {\n    // if we have characters in the rx buffer, return the first one\n    unsigned char c = rx_buffer[rx_buffer_tail];\n    rx_buffer_tail = (rx_buffer_tail + 1) & RX_BUFFER_MASK;\n    return c;\n  }\n\n  if (!usb_cdc_enabled || !usb_cdc_configured) return -1;\n\n  // check if there are any bytes available to read from the PC\n  if (!CDC_Device_available(&usb_serial)) return -1;\n\n  // read the byte\n  unsigned char c = CDC_Device_read_u8(&usb_serial);\n\n  // update the emergency parser if enabled\n  if (emergency_parser_enabled) emergency_parser.parse(c);\n\n  return c;\n}\n", "CodeBleu_score": 39.723713432338506}, {"code": "int MarlinSerialUSB::read()  if (emergency_parser_enabled) {\n    int c = emergency_parser.read();\n    if (c != -1) {\n      return c;\n    }\n  }\n\n  if (!usb_enabled) {\n    return -1;\n  }\n\n  if (!cdc_enabled) {\n    return -1;\n  }\n\n  if (!cdc_configured) {\n    return -1;\n  }\n\n  if (usb_serial.available() <= 0) {\n    return -1;\n  }\n\n  int c = usb_serial.read();\n  if (emergency_parser_enabled) {\n    emergency_parser.parse(c);\n  }\n  return c;\n}\n", "CodeBleu_score": 42.695450737708164}, {"code": "int MarlinSerialUSB::read()  // If there is a pending character, return it\n  if (pending_char != -1) {\n    int ret = pending_char;\n    pending_char = -1;\n    return ret;\n  }\n\n  // If the USB CDC is not enabled or configured, return -1\n  if (!cdc_enabled || !cdc_configured) {\n    return -1;\n  }\n\n  // If there are no bytes available to read, return -1\n  if (!cdc_available()) {\n    return -1;\n  }\n\n  // Read the byte\n  int c = cdc_read();\n\n  // Update the emergency parser if enabled\n  if (emergency_parser_enabled) {\n    emergency_parser.parse(c);\n  }\n\n  return c;\n}\n", "CodeBleu_score": 66.46073330882241}]}
{"instance_id": "46e286175a69", "generation_result": [{"code": "int MarlinSerialUSB::available()  if (usb_serial) {\n    return usb_serial->available();\n  }\n  return 0;\n}\n", "CodeBleu_score": 29.53385283797012}, {"code": "int MarlinSerialUSB::available()  if (serial_buffer_count) {\n    return serial_buffer_count;\n  }\n  if (cdc_enabled && cdc_ready) {\n    return 1;\n  }\n  return 0;\n}\n", "CodeBleu_score": 15.396182853392649}, {"code": "int MarlinSerialUSB::available()  if (usb_serial_enabled) {\n    return usb_serial->available();\n  }\n  return 0;\n}\n", "CodeBleu_score": 30.580532403215148}]}
{"instance_id": "684c979e79a3", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)  if (size) {\n    if (pos >= capacity) {\n      return false;\n    }\n    const size_t available = capacity - pos;\n    const size_t to_read = std::min(available, size);\n\n    if (writing) {\n      for (size_t i = 0; i < to_read; i++) {\n        value[i] = read_byte(pos++);\n      }\n    }\n    else {\n      for (size_t i = 0; i < to_read; i++) {\n        value[i] = read_byte(pos++);\n      }\n    }\n\n    if (crc) {\n      for (size_t i = 0; i < to_read; i++) {\n        *crc = crc16_update(*crc, value[i]);\n      }\n    }\n  }\n  return true;\n}\n", "CodeBleu_score": 41.658275298308325}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)    if (pos < 0) {\n        return false;\n    }\n    if (size <= 0) {\n        return true;\n    }\n    uint16_t crc16 = crc ? *crc : 0;\n    uint8_t data;\n    for (size_t i = 0; i < size; i++) {\n        if (!read_data(pos, data)) {\n            return false;\n        }\n        if (value) {\n            value[i] = data;\n        }\n        if (crc) {\n            crc16 = crc16_update(crc16, data);\n        }\n    }\n    if (crc) {\n        *crc = crc16;\n    }\n    return true;\n}\n", "CodeBleu_score": 42.91409820298306}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, size_t size, uint16_t *crc, const bool writing/*=true*/)  for (size_t i = 0; i < size; i++) {\n    uint8_t b;\n    if (!read(pos, &b))\n      return false;\n    if (writing)\n      *value++ = b;\n    if (crc)\n      *crc = update_crc(*crc, b);\n    pos++;\n  }\n  return true;\n}\n", "CodeBleu_score": 49.362486208872355}]}
{"instance_id": "b6348e44f615", "generation_result": [{"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  if (pin >= PIN_COUNT) return;\n\n  if (res > 16) return;\n\n  if (freq < 1) freq = 1;\n  if (freq > 20000000) freq = 20000000;\n\n  if (res > 8) {\n    if (freq < 125000) freq = 125000;\n    if (freq > 20000000) freq = 20000000;\n  }\n\n  if (res > 16) {\n    if (freq < 62500) freq = 62500;\n    if (freq > 20000000) freq = 20000000;\n  }\n\n  if (res > 32) {\n    if (freq < 31250) freq = 31250;\n    if (freq > 20000000) freq = 20000000;\n  }\n\n  if (res > 64) {\n    if (freq < 15625) freq = 15625;\n    if (freq > 20000000) freq = 20000000;\n  }\n\n  if (res > 128) {\n    if (freq < 7812) freq = 7812;\n    if (freq > 20000000) freq = 20000000;\n  }\n\n  if (res > 256) {\n    if (freq < 3906) freq = 3906;\n    if (freq > 20000000) freq = 20000000;\n  }\n\n  if (res > 512) {\n    if (freq < 1953) freq = 1953;\n    if (freq > 20000000) freq = 20000000;\n ", "CodeBleu_score": 19.07663680357225}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  // Check if the pin supports hardware PWM\n  if (pin >= LEDC_CHANNEL_MAX) {\n    return;\n  }\n  // Check if the pin is already used for PWM\n  if (pwm_state[pin].used) {\n    // Update the PWM value\n    ledc_channel_config_t channel = {\n      .gpio_num = pin,\n      .speed_mode = LEDC_HIGH_SPEED_MODE,\n      .channel = pwm_state[pin].channel,\n      .intr_type = LEDC_INTR_DISABLE,\n      .timer_sel = LEDC_TIMER_0,\n      .duty = value,\n      .hpoint = 0\n    };\n    ledc_channel_config(&channel);\n    return;\n  }\n  // Allocate a new PWM slot\n  pwm_state[pin].used = true;\n  pwm_state[pin].channel = pwm_state[pin].used_channels;\n  pwm_state[pin].timer = pwm_state[pin].used_timers;\n  pwm_state[pin].freq = freq;\n  pwm_state[pin].res = res;\n  // Start the timer if this is the first PWM pin used\n  if (pwm_state[pin].used_timers == 0) {\n    ledc_timer_config_t timer = {\n      .speed_mode = LEDC_HIGH_SPEED_MODE,\n      .duty_resolution = LEDC_TIMER_13_BIT,\n      .timer_num = LEDC_TIMER_0,\n      .freq_hz = freq,\n      .clk_cfg = LEDC_AUTO_CLK\n    };\n    ledc_timer_config(&timer);\n  }\n  // Increment the used PWM channels and timers\n  pwm_state[pin].used_channels++;\n  pwm_state[pin].used_timers++;\n  // Set the PWM value\n  ledc_channel_config_t channel = {\n    .gpio", "CodeBleu_score": 34.884802382143725}, {"code": "void analogWrite(const pin_t pin, const uint16_t value, const uint32_t freq/*=PWM_FREQUENCY*/, const uint16_t res/*=8*/)  if (pin >= PIN_COUNT) return;\n  if (value == 0) {\n    digitalWrite(pin, LOW);\n    return;\n  }\n  if (value == UINT16_MAX) {\n    digitalWrite(pin, HIGH);\n    return;\n  }\n  uint8_t channel = LEDC_CHANNEL_MAX;\n  if (pin < LEDC_CHANNEL_COUNT) {\n    channel = pin;\n  } else {\n    for (uint8_t i = 0; i < LEDC_CHANNEL_COUNT; i++) {\n      if (pwm_state[i].pin == pin) {\n        channel = i;\n        break;\n      }\n    }\n  }\n  if (channel != LEDC_CHANNEL_MAX) {\n    if (pwm_state[channel].freq != freq) {\n      ledcSetup(channel, freq, res);\n      pwm_state[channel].freq = freq;\n    }\n    ledcWrite(channel, value);\n    return;\n  }\n  if (pwm_count == PWM_COUNT_MAX) return;\n  channel = pwm_count;\n  pwm_state[channel].pin = pin;\n  pwm_state[channel].freq = freq;\n  pwm_count++;\n  if (pwm_count == 1) {\n    ledcSetup(channel, freq, res);\n    ledcAttachPin(pin, channel);\n    ledcWrite(channel, value);\n    return;\n  }\n  ledcWrite(channel, value);\n}\n", "CodeBleu_score": 54.13265364423218}]}
{"instance_id": "8d30ff0014ff", "generation_result": [{"code": "void Servo::move(const int value)    static_assert(sizeof(servo_delay) / sizeof(int) == NUM_SERVO_CHANNELS, \"Servo delay array length must match the number of servo channels\");\n\n    if (attached) {\n        write(value);\n        delay(servo_delay[channel]);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            detach();\n        }\n    }\n}\n", "CodeBleu_score": 49.26387198004179}, {"code": "void Servo::move(const int value)    static_assert(sizeof(servo_delay) / sizeof(int) == NUM_SERVOS, \"The servo_delay array length is not equal to the number of servos.\");\n\n    if (this->attach(this->pin)) {\n        this->write(value);\n        delay(servo_delay[this->channel]);\n        if (DEACTIVATE_SERVOS_AFTER_MOVE) {\n            this->detach();\n        }\n    }\n}\n", "CodeBleu_score": 41.32228024239145}, {"code": "void Servo::move(const int value)  static_assert(sizeof(servo_delay) / sizeof(servo_delay[0]) == SERVO_COUNT, \"servo_delay array length does not match the number of servos\");\n\n  if (attach(servo_pin[channel])) {\n    write(value);\n    delay(servo_delay[channel]);\n\n    #if DEACTIVATE_SERVOS_AFTER_MOVE\n      detach();\n    #endif\n  }\n}\n", "CodeBleu_score": 54.32657109715906}]}
{"instance_id": "9397f207ddf5", "generation_result": [{"code": "void i2s_push_sample()    // Loop through all pins\n    for (uint8_t i = 0; i < NUM_PINS; i++) {\n        // Check if the pin has active PWM\n        if (pwm_states[i].duty_cycle > 0) {\n            // Decrement the PWM tick count\n            pwm_states[i].tick_count--;\n\n            // If the tick count reaches zero, toggle the pin state\n            if (pwm_states[i].tick_count == 0) {\n                // Set the tick count for the next transition\n                pwm_states[i].tick_count = pwm_states[i].period;\n\n                // Toggle the pin state\n                if (pwm_states[i].state) {\n                    pwm_states[i].state = 0;\n                } else {\n                    pwm_states[i].state = 1;\n                }\n            }\n        }\n\n        // Store the updated pin state into the current position of the DMA buffer\n        if (pwm_states[i].state) {\n            // Set the corresponding bit in the port data\n            port_data |= (1 << i);\n        } else {\n            // Clear the corresponding bit in the port data\n            port_data &= ~(1 << i);\n        }\n    }\n\n    // Write the port data to the DMA buffer\n    *(dma_buffer + dma_buffer_pos) = port_data;\n\n    // Increment the buffer position\n    dma_buffer_pos++;\n\n    // Reset the port data\n    port_data = 0;\n}\n", "CodeBleu_score": 43.450172759599624}, {"code": "void i2s_push_sample()    uint32_t i;\n    uint32_t pin;\n    uint32_t port_data = 0;\n    uint32_t port_mask = 0;\n    uint32_t port_state = 0;\n    uint32_t pin_mask;\n    uint32_t pin_state;\n    uint32_t pin_tick;\n    uint32_t pin_duty;\n    uint32_t pin_level;\n    uint32_t pin_count;\n    uint32_t pin_value;\n    uint32_t pin_index;\n    uint32_t pin_state_index;\n    uint32_t pin_tick_index;\n    uint32_t pin_duty_index;\n    uint32_t pin_level_index;\n    uint32_t pin_count_index;\n    uint32_t pin_value_index;\n    uint32_t pin_index_index;\n    uint32_t pin_state_index_index;\n    uint32_t pin_tick_index_index;\n    uint32_t pin_duty_index_index;\n    uint32_t pin_level_index_index;\n    uint32_t pin_count_index_index;\n    uint32_t pin_value_index_index;\n    uint32_t pin_index_index_index;\n    uint32_t pin_state_index_index_index;\n    uint32_t pin_tick_index_index_index;\n    uint32_t pin_duty_index_index_index;\n    uint32_t pin_level_index_index_index;\n    uint32_t pin_count_index_index_index;\n    uint32_t pin_value_index_index_index;\n    uint32_t pin_index_index_index_index;\n    uint32_t pin_state_index_index_index_index;\n    uint32_t pin_tick_index_index_index_index;\n    uint32_", "CodeBleu_score": 5.890955545183586}, {"code": "void i2s_push_sample()    // Iterate through each pin\n    for (int i = 0; i < NUM_PINS; i++) {\n        // Check if the pin has active PWM\n        if (pins[i].duty_cycle > 0) {\n            // Check if the PWM tick count has reached zero\n            if (pins[i].tick_count == 0) {\n                // Toggle the pin state between high and low based on its current state\n                if (pins[i].state == HIGH) {\n                    pins[i].state = LOW;\n                } else {\n                    pins[i].state = HIGH;\n                }\n\n                // Set the tick count for the next transition\n                pins[i].tick_count = pins[i].duty_cycle;\n            } else {\n                // Decrement the tick count\n                pins[i].tick_count--;\n            }\n\n            // Store the updated pin state into the current position of the DMA buffer\n            if (pins[i].state == HIGH) {\n                *((uint32_t*)i2s_dma_buffer + i2s_dma_buffer_pos) |= (1 << i);\n            } else {\n                *((uint32_t*)i2s_dma_buffer + i2s_dma_buffer_pos) &= ~(1 << i);\n            }\n        }\n    }\n\n    // Increment the buffer position\n    i2s_dma_buffer_pos++;\n\n    // Check if the buffer position has reached the end of the buffer\n    if (i2s_dma_buffer_pos == I2S_DMA_BUFFER_SIZE) {\n        // Reset the buffer position\n        i2s_dma_buffer_pos = 0;\n    }\n}\n", "CodeBleu_score": 42.38809502019463}]}
{"instance_id": "3c122bba57b7", "generation_result": [{"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)  if (timer_num >= TIMER_COUNT) {\n    return 0;\n  }\n\n  return timer_config[timer_num].count;\n}\n", "CodeBleu_score": 21.381379112249952}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)  if (timer_num >= HAL_TIMER_COUNT) {\n    return 0;\n  }\n\n  return (hal_timer_t)timer_config[timer_num].counter;\n}\n", "CodeBleu_score": 23.033311386745524}, {"code": "hal_timer_t HAL_timer_get_count(const uint8_t timer_num)    if (timer_num >= TIMER_NUM) {\n        return 0;\n    }\n\n    timer_t *timer = &timer_config[timer_num];\n    return timer->get_count();\n}\n", "CodeBleu_score": 34.79213512167665}]}
{"instance_id": "d20484e3d16c", "generation_result": [{"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  for (size_t i = 0; i < size; i++) {\n    uint8_t b = eeprom_read_byte((uint8_t *) (pos + i));\n    if (writing) {\n      value[i] = b;\n    }\n    *crc = update_crc(*crc, b);\n  }\n  pos += size;\n  return false;\n}\n", "CodeBleu_score": 71.67700936518143}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  for (size_t i = 0; i < size; i++) {\n    if (read_byte(pos, value[i], crc)) {\n      return true;\n    }\n    if (writing) {\n      write_byte(pos, value[i], crc);\n    }\n  }\n  return false;\n}\n", "CodeBleu_score": 57.61287715840804}, {"code": "bool PersistentStore::read_data(int &pos, uint8_t *value, const size_t size, uint16_t *crc, const bool writing /*=true*/)  uint8_t data;\n  for (size_t i = 0; i < size; i++) {\n    data = EEPROM.read(pos);\n    if (writing)\n      value[i] = data;\n    *crc = update_crc(*crc, data);\n    pos++;\n  }\n  return false;\n}\n", "CodeBleu_score": 65.37406955945602}]}
{"instance_id": "3ca886f0fcd1", "generation_result": [{"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)  if (SDIO_Handle == NULL || src == NULL) {\n    return false;\n  }\n\n  uint32_t retries = 0;\n  while (retries < SDIO_MAX_RETRIES) {\n    if (SDIO_WriteBlock_Internal(block, src) == true) {\n      return true;\n    }\n\n    retries++;\n  }\n\n  printf(\"SDIO_WriteBlock: Failed after %d retries\\n\", SDIO_MAX_RETRIES);\n  return false;\n}\n", "CodeBleu_score": 33.16086059020429}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    // Check that the SDIO handle and source pointer are not null\n    if (sdio_handle == NULL || src == NULL) {\n        return false;\n    }\n\n    // Try to write the block, retrying up to a defined number of times if the write operation fails\n    for (int i = 0; i < SDIO_MAX_RETRIES; i++) {\n        // Send the command to write a block\n        SDIO_WriteBlock_Cmd(block);\n\n        // Send the block data\n        SDIO_WriteBlock_Data(src);\n\n        // Wait for the write to complete\n        SDIO_WriteBlock_Wait();\n\n        // Check the response\n        uint8_t response = SDIO_ReadStatus();\n        if (response == SDIO_RESPONSE_ACCEPTED) {\n            // The write was successful\n            return true;\n        } else if (response == SDIO_RESPONSE_CRC_ERROR) {\n            // The write failed due to a CRC error\n            printf(\"SDIO_WriteBlock: CRC error\\n\");\n            return false;\n        } else if (response == SDIO_RESPONSE_WRITE_ERROR) {\n            // The write failed due to a write error\n            printf(\"SDIO_WriteBlock: Write error\\n\");\n            return false;\n        }\n    }\n\n    // The write operation failed after all retries\n    printf(\"SDIO_WriteBlock: Max retries exceeded\\n\");\n    return false;\n}\n", "CodeBleu_score": 34.688868917082274}, {"code": "bool SDIO_WriteBlock(uint32_t block, const uint8_t *src)    if (!sdio_handle || !src) {\n        return false;\n    }\n\n    for (int i = 0; i < SDIO_RETRY_COUNT; i++) {\n        if (sdio_write_block(sdio_handle, block, src) == SDIO_OK) {\n            return true;\n        }\n    }\n\n    printf(\"Error: SDIO write block failed\\n\");\n    return false;\n}\n", "CodeBleu_score": 29.576032985698465}]}
{"instance_id": "6064dcb222f7", "generation_result": [{"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)    if (timer_num == TEMPERATURE_TIMER) {\n        /* Start the timer with the given frequency and temperature timer prescale */\n        TIMER_Start(TEMPERATURE_TIMER_BASE, temperature_timer_prescale, frequency);\n\n        /* Set the callback priority for temperature */\n        NVIC_SetPriority(TEMPERATURE_TIMER_IRQn, TEMPERATURE_TIMER_IRQ_PRIORITY);\n    } else if (timer_num == STEPPER_TIMER) {\n        /* Start the timer with the given frequency and stepper timer prescale */\n        TIMER_Start(STEPPER_TIMER_BASE, stepper_timer_prescale, frequency);\n\n        /* Set the callback priority for stepper */\n        NVIC_SetPriority(STEPPER_TIMER_IRQn, STEPPER_TIMER_IRQ_PRIORITY);\n    } else {\n        /* Invalid timer channel */\n        assert(false);\n    }\n}\n", "CodeBleu_score": 37.679096646890194}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)    switch (timer_num) {\n        case TIMER_CHANNEL_TEMPERATURE:\n            timer_start(TEMPERATURE_TIMER, frequency, TEMPERATURE_TIMER_PRESCALE, TEMPERATURE_TIMER_CALLBACK_PRIORITY);\n            break;\n        case TIMER_CHANNEL_STEPPER:\n            timer_start(STEPPER_TIMER, frequency, STEPPER_TIMER_PRESCALE, STEPPER_TIMER_CALLBACK_PRIORITY);\n            break;\n        default:\n            assert_always_msg(ASSERT_CONTINUE, \"Invalid timer channel\");\n            break;\n    }\n}\n", "CodeBleu_score": 22.30094304376325}, {"code": "void HAL_timer_start(const timer_channel_t timer_num, const uint32_t frequency)    switch (timer_num) {\n        case TEMP_TIMER:\n            /* Start the timer with the given frequency and temperature timer prescale */\n            timer_start(TEMP_TIMER_CHANNEL, frequency, temperature_timer_prescale);\n            /* Set the callback priority for temperature */\n            timer_set_callback_priority(TEMP_TIMER_CHANNEL, TEMP_TIMER_CALLBACK_PRIORITY);\n            break;\n        case STEP_TIMER:\n            /* Start the timer with the given frequency and stepper timer prescale */\n            timer_start(STEP_TIMER_CHANNEL, frequency, stepper_timer_prescale);\n            /* Set the callback priority for stepper */\n            timer_set_callback_priority(STEP_TIMER_CHANNEL, STEP_TIMER_CALLBACK_PRIORITY);\n            break;\n        default:\n            /* Trigger an assertion failure if the timer channel is invalid */\n            assert(false);\n            break;\n    }\n}\n", "CodeBleu_score": 30.592836820800084}]}
{"instance_id": "6ab8b797a670", "generation_result": [{"code": "bool PersistentStore::access_start()    if (access_file.open(file_name, O_RDWR | O_CREAT) == false) {\n        return false;\n    }\n\n    if (access_file.size() < EEPROM_SIZE) {\n        memset(buffer, EEPROM_ERASE_VALUE, EEPROM_SIZE);\n    }\n\n    access_file.read(buffer, EEPROM_SIZE);\n    access_file.close();\n\n    return true;\n}\n", "CodeBleu_score": 19.81047684352904}, {"code": "bool PersistentStore::access_start()  if (EEPROM.begin(EEPROM_SIZE)) {\n    for (uint16_t i = 0; i < EEPROM_SIZE; i++) {\n      if (EEPROM.read(i) == EEPROM_ERASE_VALUE) {\n        _buffer[i] = 0;\n      } else {\n        _buffer[i] = EEPROM.read(i);\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n", "CodeBleu_score": 21.35936329540004}, {"code": "bool PersistentStore::access_start()  if (file == NULL) {\n    file = fopen(filename, \"r+\");\n  }\n  if (file == NULL) {\n    // file does not exist, so create it\n    file = fopen(filename, \"w+\");\n    if (file == NULL) {\n      return false;\n    }\n    // fill the new file with the default erase value\n    for (size_t i = 0; i < EEPROM_SIZE; i++) {\n      fputc(EEPROM_ERASE_VALUE, file);\n    }\n    // reset file pointer\n    rewind(file);\n  }\n  // read the file into the buffer\n  size_t bytes_read = fread(buffer, 1, EEPROM_SIZE, file);\n  if (bytes_read != EEPROM_SIZE) {\n    // file is not of sufficient size\n    return false;\n  }\n  return true;\n}\n", "CodeBleu_score": 35.98923641246924}]}
{"instance_id": "c583d63e258f", "generation_result": [{"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)    uint8_t i;\n    uint8_t a = 0;\n    for (i = 0; i < 8; i++) {\n        HAL_GPIO_WritePin(SPI_MOSI_PORT, SPI_MOSI_PIN, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_SCK_PORT, SPI_SCK_PIN, GPIO_PIN_RESET);\n        HAL_GPIO_WritePin(SPI_SCK_PORT, SPI_SCK_PIN, GPIO_PIN_SET);\n        a <<= 1;\n        if (HAL_GPIO_ReadPin(SPI_MISO_PORT, SPI_MISO_PIN)) a |= 1;\n    }\n    HAL_Delay(1);\n    return a;\n}\n", "CodeBleu_score": 40.85530795782534}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)  uint8_t r = 0;\n  for (uint8_t i = 0; i < 8; i++) {\n    HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_SCLK_GPIO_Port, SPI_SCLK_Pin, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_MOSI_GPIO_Port, SPI_MOSI_Pin, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_SCLK_GPIO_Port, SPI_SCLK_Pin, GPIO_PIN_SET);\n    r <<= 1;\n    r |= HAL_GPIO_ReadPin(SPI_MISO_GPIO_Port, SPI_MISO_Pin) ? 1 : 0;\n    b <<= 1;\n    HAL_GPIO_WritePin(SPI_SCLK_GPIO_Port, SPI_SCLK_Pin, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET);\n  }\n  HAL_Delay(1);\n  return r;\n}", "CodeBleu_score": 39.25020670610115}, {"code": "uint8_t HAL_SPI_STM32_SpiTransfer_Mode_3(uint8_t b)  uint8_t i;\n  uint8_t r = 0;\n  for (i = 0; i < 8; i++) {\n    HAL_GPIO_WritePin(SPI_PORT, SPI_SCK_PIN, GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_PORT, SPI_MOSI_PIN, (b & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n    HAL_GPIO_WritePin(SPI_PORT, SPI_SCK_PIN, GPIO_PIN_SET);\n    r = (r << 1) | HAL_GPIO_ReadPin(SPI_PORT, SPI_MISO_PIN);\n    b <<= 1;\n  }\n  HAL_Delay(1);\n  return r;\n}\n", "CodeBleu_score": 42.6067681884655}]}
{"instance_id": "c17acede1672", "generation_result": [{"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)  if (NewState != DISABLE) {\n    RCC->AHBENR |= RCC_AHBPeriph;\n  } else {\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n  }\n}\n", "CodeBleu_score": 48.558842541785694}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)  if (NewState != DISABLE)\n    RCC->AHBENR |= RCC_AHBPeriph;\n  else\n    RCC->AHBENR &= ~RCC_AHBPeriph;\n}\n", "CodeBleu_score": 58.66849269310087}, {"code": "void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)\tif (NewState == ENABLE) {\n\t\tRCC->AHBENR |= RCC_AHBPeriph;\n\t} else {\n\t\tRCC->AHBENR &= ~RCC_AHBPeriph;\n\t}\n}\n", "CodeBleu_score": 42.30618695191759}]}
{"instance_id": "07c84ed22693", "generation_result": [{"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  if (obj->flags & SERIAL_FLAG_PARITY_ERROR) return;\n\n  // If we have space in the buffer, store the byte\n  if (obj->rx_buffer_idx < SERIAL_RX_BUFFER_SIZE) {\n    obj->rx_buffer[obj->rx_buffer_idx++] = obj->rx_byte;\n  }\n\n  // Update the head index\n  obj->rx_head_idx = (obj->rx_head_idx + 1) % SERIAL_RX_BUFFER_SIZE;\n\n  // If enabled, update the emergency parser\n  if (obj->flags & SERIAL_FLAG_EMERGENCY_PARSER) {\n    obj->emergency_parser.put(obj->rx_byte);\n  }\n}\n", "CodeBleu_score": 37.717690538570245}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  // If there is space in the buffer, store the received byte\n  if (obj->rx_buffer_head < obj->rx_buffer_tail + SERIAL_RX_BUFFER_SIZE) {\n    obj->rx_buffer[obj->rx_buffer_head & SERIAL_RX_BUFFER_MASK] = obj->rx_byte;\n    obj->rx_buffer_head++;\n  }\n\n  // Update the next buffer index\n  obj->rx_buffer_head &= SERIAL_RX_BUFFER_MASK;\n\n  // Update the emergency parser\n  if (obj->emergency_parser_enabled) {\n    obj->emergency_parser.process(obj->rx_byte);\n  }\n}", "CodeBleu_score": 34.929566597763625}, {"code": "void MarlinSerial::_rx_complete_irq(serial_t *obj)  if (obj->parity_error) {\n    // parity error, discard the byte\n    obj->parity_error = false;\n    return;\n  }\n  uint8_t byte = obj->read_reg;\n  // store the byte in the receive buffer\n  uint8_t index = obj->rx_buffer_index;\n  obj->rx_buffer[index] = byte;\n  // update the buffer index\n  index++;\n  if (index >= SERIAL_RX_BUFFER_SIZE)\n    index = 0;\n  obj->rx_buffer_index = index;\n  // update the head pointer\n  obj->rx_buffer_head = index;\n  // update the emergency parser with the received byte\n  if (obj->emergency_parser)\n    obj->emergency_parser->rx_complete_irq(byte);\n}\n", "CodeBleu_score": 42.072958947409674}]}
{"instance_id": "1a4209a2e1f1", "generation_result": [{"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)    if (timer_num == MF_TIMER_STEP) {\n        attachInterrupt(digitalPinToInterrupt(MF_TIMER_STEP_PIN), Step_Handler, CHANGE);\n    } else if (timer_num == MF_TIMER_TEMP) {\n        attachInterrupt(digitalPinToInterrupt(MF_TIMER_TEMP_PIN), Temp_Handler, CHANGE);\n    }\n}\n", "CodeBleu_score": 30.812308752978996}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)    if (timer_num == MF_TIMER_STEP) {\n        TIMER_STEP_REG->INTCTRL = TIMER_INT_MODE_COMPARE_MATCH_INTERRUPT;\n        NVIC_EnableIRQ(TIMER_STEP_IRQn);\n    } else if (timer_num == MF_TIMER_TEMP) {\n        TIMER_TEMP_REG->INTCTRL = TIMER_INT_MODE_COMPARE_MATCH_INTERRUPT;\n        NVIC_EnableIRQ(TIMER_TEMP_IRQn);\n    }\n}\n", "CodeBleu_score": 28.06420008389447}, {"code": "void HAL_timer_enable_interrupt(const uint8_t timer_num)    if (timer_num == MF_TIMER_STEP) {\n        if (timer_step_init_flag == MF_TRUE) {\n            if (timer_step_interrupt_flag == MF_FALSE) {\n                timer_step_interrupt_flag = MF_TRUE;\n                attachInterrupt(digitalPinToInterrupt(MF_TIMER_STEP_PIN), Step_Handler, RISING);\n            }\n        }\n    } else if (timer_num == MF_TIMER_TEMP) {\n        if (timer_temp_init_flag == MF_TRUE) {\n            if (timer_temp_interrupt_flag == MF_FALSE) {\n                timer_temp_interrupt_flag = MF_TRUE;\n                attachInterrupt(digitalPinToInterrupt(MF_TIMER_TEMP_PIN), Temp_Handler, RISING);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 32.2144102453161}]}
{"instance_id": "e7f70295bd11", "generation_result": [{"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\thsep := Hash(sep)\n\tn := len(s)\n\tm := len(sep)\n\tif m > n {\n\t\treturn -1\n\t}\n\tvar h uint64\n\tfor i := 0; i < m; i++ {\n\t\th = (h*256 + uint64(s[n-m+i])) % prime\n\t}\n\tif h == hsep && s[n-m:n] == sep {\n\t\treturn n - m\n\t}\n\th2 := pow[m-1]\n\tfor i := n - m; i > 0; i-- {\n\t\th = (h*256 + uint64(s[i-1])) % prime\n\t\th = (h - h2*uint64(s[i+m-1])) % prime\n\t\tif h == hsep && s[i-1:i+m-1] == sep {\n\t\t\treturn i - 1\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 42.17102577318298}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\thashSep := Hash(sep)\n\thash := 0\n\tpow := 1\n\tn := len(s)\n\tm := len(sep)\n\tif n < m {\n\t\treturn -1\n\t}\n\tfor i := 0; i < m; i++ {\n\t\thash = hash*base + int(s[n-1-i])\n\t\tpow *= base\n\t}\n\tif hash == hashSep && s[n-m:n] == sep {\n\t\treturn n - m\n\t}\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\thash = hash*base - int(s[i+m])*pow + int(s[i])\n\t\tif hash == hashSep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n", "CodeBleu_score": 44.58330585821354}, {"code": "func LastIndexRabinKarp[T string | []byte](s, sep T) int\tvar (\n\t\thashSep, hash, pow, hashBase uint64\n\t\tn, m                        int\n\t)\n\n\tn = len(s)\n\tm = len(sep)\n\tif m == 0 || m > n {\n\t\treturn -1\n\t}\n\n\thashBase = uint64(1)\n\tfor i := 0; i < m; i++ {\n\t\thashBase *= primeRK\n\t}\n\n\tpow = uint64(1)\n\tfor i := 0; i < m; i++ {\n\t\tpow *= primeRK\n\t}\n\n\tfor i := 0; i < m; i++ {\n\t\thashSep = hashSep*primeRK + uint64(s[i])\n\t\thash = hash*primeRK + uint64(s[n-m+i])\n\t}\n\n\tif hash == hashSep && s[n-m:n] == sep {\n\t\treturn n - m\n\t}\n\n\tfor i := n - m - 1; i >= 0; i-- {\n\t\thash = hash*primeRK + uint64(s[i]) - pow*uint64(s[i+m])\n\t\tif hash == hashSep && s[i:i+m] == sep {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n", "CodeBleu_score": 41.178050015340375}]}
{"instance_id": "5090d25de8b9", "generation_result": [{"code": "func (usbcdc *USBCDC) Flush()\tinterrupts.Disable()\n\tif usbcdc.waitTxc {\n\t\tusbcdc.waitTxc = false\n\t\tif usbcdc.tx_count > 0 {\n\t\t\tusbcdc.SendUSBInPacket()\n\t\t}\n\t}\n\tinterrupts.Enable()\n}\n", "CodeBleu_score": 30.80073220508582}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.txc.DisableInterrupts()\n\tif usbcdc.txc.GetStatus().Txc {\n\t\tusbcdc.SendUSBInPacket(usbcdc.txc.GetData())\n\t}\n\tusbcdc.waitTxc = false\n\tusbcdc.txc.EnableInterrupts()\n}\n", "CodeBleu_score": 31.40913379348121}, {"code": "func (usbcdc *USBCDC) Flush()\tusbcdc.waitTxc = false\n\tinterrupts.Disable()\n\ttxc := usbcdc.txc\n\tif txc != 0 {\n\t\tusbcdc.SendUSBInPacket(txc)\n\t}\n\tinterrupts.Enable()\n}\n", "CodeBleu_score": 39.79026679115301}]}
{"instance_id": "54d6ec2ef3cb", "generation_result": [{"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.control.Set(I2C_CONTROL_START)\n\ti2c.waitForInterrupt(I2C_CONTROL_START)\n\ti2c.write(address | (write ? 0 : 1))\n}\n", "CodeBleu_score": 27.580082385332794}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.ctrl.Set(I2C_CTRL_START)\n\ti2c.waitForInterrupt(I2C_CTRL_START)\n\ti2c.write(address << 1)\n\tif write {\n\t\ti2c.ctrl.Set(I2C_CTRL_WRITE)\n\t}\n}\n", "CodeBleu_score": 30.19488949369648}, {"code": "func (i2c *I2C) start(address uint8, write bool)\ti2c.control.Set(i2c.control.Load())\n\ti2c.control.Set(i2c.control.Load() | i2c.control.Start())\n\tfor i2c.control.Get()&i2c.control.Interrupt() == 0 {\n\t}\n\ti2c.bus.Set(address << 1)\n\tif write {\n\t\ti2c.control.Set(i2c.control.Load() | i2c.control.Write())\n\t} else {\n\t\ti2c.control.Set(i2c.control.Load() | i2c.control.Read())\n\t}\n}\n", "CodeBleu_score": 28.51927523044509}]}
{"instance_id": "57a792477dc8", "generation_result": [{"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tstartAddr := start * f.blockSize\n\tf.configureForErasing()\n\tfor i := int64(0); i < len; i++ {\n\t\taddr := startAddr + i*f.blockSize\n\t\tif err := f.waitForBusy(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := f.eraseBlock(addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tf.configureForReading()\n\treturn nil\n}\n", "CodeBleu_score": 30.90874898491922}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\taddr := f.blockSize * start\n\tif err := f.waitBusy(); err != nil {\n\t\treturn err\n\t}\n\tf.flash.EraseBlocks(addr, len)\n\tfor i := int64(0); i < len; i++ {\n\t\tif err := f.waitBusy(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tf.flash.ReadMode()\n\treturn nil\n}\n", "CodeBleu_score": 34.869350828227795}, {"code": "func (f flashBlockDevice) EraseBlocks(start, len int64) error\tstartAddr := start * f.blockSize\n\tendAddr := startAddr + len*f.blockSize\n\n\t// Wait for any ongoing flash operations to complete.\n\tf.waitForFlash()\n\n\t// Configure the flash for erasing.\n\tf.flash.Erase(startAddr, endAddr)\n\n\t// Wait for each block to be erased.\n\tfor addr := startAddr; addr < endAddr; addr += f.blockSize {\n\t\t// Wait until the flash is no longer busy.\n\t\tf.waitForFlash()\n\t}\n\n\t// Set the flash back to read mode.\n\tf.flash.Read()\n\n\treturn nil\n}\n", "CodeBleu_score": 29.795276660721655}]}
{"instance_id": "0d13f2ab7097", "generation_result": [{"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 || off+int64(len(p)) > int64(f.size) {\n\t\treturn 0, ErrInvalidOffset\n\t}\n\n\tstart := int(off)\n\tend := start + len(p)\n\n\t// Pad the input data to the write block size.\n\tpad := f.writeBlockSize - len(p)%f.writeBlockSize\n\tif pad != f.writeBlockSize {\n\t\tq := make([]byte, len(p)+pad)\n\t\tcopy(q, p)\n\t\tp = q\n\t}\n\n\t// Enable write mode.\n\tf.writeEnable()\n\n\t// Write the data in blocks.\n\tfor start < end {\n\t\tblock := start / f.writeBlockSize\n\t\toffset := start % f.writeBlockSize\n\t\tsize := f.writeBlockSize - offset\n\t\tif size > end-start {\n\t\t\tsize = end - start\n\t\t}\n\n\t\tif err := f.writeBlock(block, p[start:start+size]); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tstart += size\n\t}\n\n\t// Wait for the flash memory to be ready.\n\tif err := f.waitReady(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn len(p), nil\n}\n", "CodeBleu_score": 29.20750509062312}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\tif off < 0 || int64(len(p)) > f.Size()-off {\n\t\treturn 0, &Error{Code: ErrInvalidOffset}\n\t}\n\tstart := int(off)\n\tend := start + len(p)\n\twriteBlockSize := f.WriteBlockSize()\n\twriteBlockSizeMask := writeBlockSize - 1\n\twriteBlockSizeBytes := writeBlockSize / 8\n\twriteBlockSizeBits := writeBlockSize - writeBlockSizeBytes*8\n\twriteBlockSizeMaskBytes := writeBlockSizeMask / 8\n\twriteBlockSizeMaskBits := writeBlockSizeMask - writeBlockSizeMaskBytes*8\n\twriteBlockSizeMaskBitsMask := (1 << writeBlockSizeMaskBits) - 1\n\twriteBlockSizeMaskBytesMask := (1 << writeBlockSizeMaskBytes) - 1\n\twriteBlockSizeMaskBytesMask <<= writeBlockSizeMaskBits\n\twriteBlockSizeMaskBytesMask >>= writeBlockSizeMaskBits\n\twriteBlockSizeMaskBytesMask |= 1 << (writeBlockSizeMaskBits - 1)\n\twriteBlockSizeMaskBytesMask <<= writeBlockSizeMaskBytes\n\twriteBlockSizeMaskBytesMask >>= writeBlockSizeMaskBytes\n\twriteBlockSizeMaskBytesMask |= 1 << (writeBlockSizeMaskBytes - 1)\n\twriteBlockSizeMaskBytesMask <<= writeBlockSizeMaskBits\n\twriteBlockSizeMaskBytesMask >>= writeBlockSizeMaskBits\n\twriteBlockSizeMaskBytesMask |= 1 << (writeBlockSizeMaskBits - 1)\n\twriteBlockSizeMaskBytesMask <<= writeBlockSizeMaskBytes\n\twriteBlockSizeMaskBytesMask >>= writeBlockSizeMaskBytes\n\twriteBlockSizeMaskBytesMask |= 1 << (writeBlockSizeMaskBytes - 1)\n\twriteBlockSizeMaskBytesMask <<= writeBlockSizeMaskBits\n\twriteBlockSizeMaskBytesMask >>= writeBlockSizeMaskBits\n\twriteBlockSizeMaskBytesMask |= 1 << (writeBlockSizeMaskBits - 1)\n\twriteBlockSizeMaskBytesMask <<= writeBlockSizeMaskBytes\n\twriteBlockSizeMaskBytesMask >>= writeBlockSizeMaskBytes\n\twriteBlockSizeMaskBytesMask |= 1 <<", "CodeBleu_score": 24.359334788193802}, {"code": "func (f flashBlockDevice) WriteAt(p []byte, off int64) (n int, err error)\t// Check if the write operation exceeds the flash memory bounds\n\tif off < 0 || int64(len(p))+off > f.size {\n\t\treturn 0, ErrInvalidWriteOffset\n\t}\n\n\t// Calculate the start address for writing\n\tstartAddr := uint32(off)\n\n\t// Pad the byte slice to fit the write block size\n\tblockSize := f.writeBlockSize\n\tpadSize := blockSize - (uint32(len(p)) % blockSize)\n\tif padSize < blockSize {\n\t\tp = append(p, make([]byte, padSize)...)\n\t}\n\n\t// Enable write mode on the flash memory controller\n\tf.enableWriteMode()\n\n\t// Write the data in blocks\n\tfor len(p) > 0 {\n\t\t// Calculate the block address and size\n\t\tblockAddr := startAddr & ^(blockSize - 1)\n\t\tblockSize := uint32(math.Min(float64(len(p)), float64(blockSize)))\n\n\t\t// Write the block of data\n\t\terr = f.writeBlock(blockAddr, p[:blockSize])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// Wait for the flash memory to be ready\n\t\terr = f.waitForReady()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// Update the offset and remaining data\n\t\tstartAddr += blockSize\n\t\tp = p[blockSize:]\n\t}\n\n\t// Return the number of bytes written\n\treturn int(startAddr - uint32(off)), nil\n}\n", "CodeBleu_score": 31.82910544807001}]}
{"instance_id": "57d59e8091c3", "generation_result": [{"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tdupFd, err := syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err := syscall.Fdopendir(dupFd)\n\t\tif err == nil {\n\t\t\treturn uintptr(dupFd), \"\", nil\n\t\t}\n\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(dupFd)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n}\n", "CodeBleu_score": 61.6257836027957}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tvar err error\n\tvar dir uintptr\n\tvar nfd syscallFd\n\n\t// Duplicate the file descriptor\n\tnfd, err = syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, err.Error(), err\n\t}\n\n\t// Open the directory using Fdopendir\n\tfor {\n\t\tdir, err = syscall.Fdopendir(nfd)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err != syscall.EINTR {\n\t\t\tsyscall.Close(nfd)\n\t\t\treturn 0, err.Error(), err\n\t\t}\n\t}\n\n\treturn dir, \"\", nil\n}", "CodeBleu_score": 54.57593940111185}, {"code": "func darwinOpenDir(fd syscallFd) (uintptr, string, error)\tvar err error\n\tvar dir *syscall.Dirent\n\tvar fd2 syscallFd\n\n\tfd2, err = syscall.Dup(fd)\n\tif err != nil {\n\t\treturn 0, \"\", err\n\t}\n\n\tfor {\n\t\tdir, err = syscall.Fdopendir(fd2)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif err.(syscall.Errno) != syscall.EINTR {\n\t\t\tsyscall.Close(fd2)\n\t\t\treturn 0, \"\", err\n\t\t}\n\t}\n\n\treturn uintptr(dir.Fd()), \"\", nil\n}", "CodeBleu_score": 53.61594256851119}]}
{"instance_id": "c77b4c3328e4", "generation_result": [{"code": "static uint32_t sketchSize(sketchSize_t response)  uint32_t size = 0;\n  if (response == sketchSize_t::FREE) {\n    size = ESP.getFreeSketchSpace();\n  } else {\n    size = ESP.getSketchSize();\n  }\n  return size;\n}\n", "CodeBleu_score": 22.359662641759414}, {"code": "static uint32_t sketchSize(sketchSize_t response)  uint32_t size = 0;\n  if (response == sketchSize_t::free) {\n    size = (uint32_t)ESP.getFreeSketchSpace();\n  } else if (response == sketchSize_t::actual) {\n    size = (uint32_t)ESP.getSketchSize();\n  }\n  return size;\n}\n", "CodeBleu_score": 23.71111347084685}, {"code": "static uint32_t sketchSize(sketchSize_t response)    uint32_t size = 0;\n    if (response == sketchSize_t::FREE_SPACE) {\n        size = ESP.getFreeSketchSpace();\n    } else if (response == sketchSize_t::ACTUAL_SIZE) {\n        size = ESP.getSketchSize();\n    }\n    return size;\n}\n", "CodeBleu_score": 24.104064828597544}]}
{"instance_id": "61ae55ab6772", "generation_result": [{"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)  uint32_t disk_sectors = (uint32_t) (1024 * 1024 / 512);\n  uint8_t *disk_buffer = (uint8_t *) malloc(disk_sectors * 512);\n  if (disk_buffer == NULL) {\n    log_error(\"Failed to allocate memory for RAM disk\");\n    return false;\n  }\n\n  msc_update_setup_boot_sector(disk_buffer, volume_label, serial_number);\n  msc_update_setup_fat(disk_buffer, disk_sectors);\n\n  if (partition_running()) {\n    msc_update_setup_root_dir_entry(disk_buffer, disk_sectors);\n  }\n\n  return true;\n}\n", "CodeBleu_score": 26.147793313524183}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)  uint32_t disk_sectors = (uint32_t) ((256 * 1024) / 512);\n  uint8_t *disk_buffer = (uint8_t *) malloc(disk_sectors * 512);\n\n  if (!disk_buffer) {\n    log_error(\"Failed to allocate memory for disk buffer\");\n    return false;\n  }\n\n  msc_update_setup_boot_sector(disk_buffer, volume_label, serial_number);\n  msc_update_setup_fat(disk_buffer);\n\n  if (msc_update_running_partition) {\n    msc_update_setup_root_dir(disk_buffer, msc_update_running_partition);\n  }\n\n  return true;\n}\n", "CodeBleu_score": 29.622524965340347}, {"code": "static bool msc_update_setup_disk(const char *volume_label, uint32_t serial_number)  // Calculate required disk sectors\n  uint32_t disk_sectors = MSC_DISK_SIZE / MSC_SECTOR_SIZE;\n\n  // Allocate memory for RAM disk\n  if (!ramdisk_alloc(disk_sectors)) {\n    LOG_ERROR(\"Failed to allocate RAM disk\");\n    return false;\n  }\n\n  // Set up boot sector\n  msc_update_setup_boot_sector(volume_label, serial_number);\n\n  // Set up FAT\n  msc_update_setup_fat();\n\n  // Add root directory entry for firmware file if a partition is running\n  if (running_partition != NULL) {\n    msc_update_add_root_dir_entry(running_partition);\n  }\n\n  return true;\n}\n", "CodeBleu_score": 22.82935740336789}]}
{"instance_id": "ab9a1d1944f3", "generation_result": [{"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    esp_err_t err;\n    uint32_t sector_size = esp_partition_get_sector_size(partition);\n    uint32_t sector_offset = offset % sector_size;\n    uint32_t sector_addr = offset - sector_offset;\n\n    if (sector_offset != 0) {\n        ESP_LOGW(TAG, \"Update write not aligned with flash sector size, erasing sector at 0x%08x\", sector_addr);\n        err = esp_partition_erase_range(partition, sector_addr, sector_size);\n        if (err != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to erase sector at 0x%08x, error: %s\", sector_addr, esp_err_to_name(err));\n            return err;\n        }\n    }\n\n    err = esp_partition_write(partition, offset, data, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to write data to partition at 0x%08x, error: %s\", offset, esp_err_to_name(err));\n    }\n\n    return err;\n}\n", "CodeBleu_score": 53.84200939582586}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)  ESP_LOGD(TAG, \"msc_update_write: offset=%d, size=%d\", offset, size);\n\n  // Check if the offset is aligned with the flash sector size\n  if (offset % ESP_PARTITION_SEC_SIZE != 0) {\n    ESP_LOGE(TAG, \"msc_update_write: offset not aligned with flash sector size\");\n    return ESP_FAIL;\n  }\n\n  // Erase the corresponding sector if needed\n  if (offset != partition->address) {\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n      ESP_LOGE(TAG, \"msc_update_write: failed to erase sector at offset %d, err=%d\", offset, err);\n      return err;\n    }\n  }\n\n  // Write the data to the specified offset\n  esp_err_t err = esp_partition_write(partition, offset, data, size);\n  if (err != ESP_OK) {\n    ESP_LOGE(TAG, \"msc_update_write: failed to write data to offset %d, err=%d\", offset, err);\n  }\n  return err;\n}\n", "CodeBleu_score": 54.208099028717484}, {"code": "static esp_err_t msc_update_write(const esp_partition_t *partition, uint32_t offset, void *data, size_t size)    if (offset % partition->flash_size != 0) {\n        ESP_LOGW(TAG, \"Update write offset not aligned with flash sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    if (partition->flash_size != size) {\n        ESP_LOGW(TAG, \"Update write size not equal to flash sector size\");\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    esp_err_t err = esp_partition_erase_range(partition, offset, size);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"Failed to erase flash sector at offset 0x%08x: %s\", offset, esp_err_to_name(err));\n        return err;\n    }\n\n    return esp_partition_write(partition, offset, data, size);\n}", "CodeBleu_score": 53.256402884283816}]}
{"instance_id": "b1e6dde12189", "generation_result": [{"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t i = 0;\n    size_t j = 0;\n    while (in[i] && j < maxlen) {\n        if (in[i] >= '0' && in[i] <= '9') {\n            out[j] = (in[i] - '0') << 4;\n        } else if (in[i] >= 'a' && in[i] <= 'f') {\n            out[j] = (in[i] - 'a' + 10) << 4;\n        } else if (in[i] >= 'A' && in[i] <= 'F') {\n            out[j] = (in[i] - 'A' + 10) << 4;\n        } else {\n            i++;\n            continue;\n        }\n        i++;\n        if (in[i] >= '0' && in[i] <= '9') {\n            out[j] |= in[i] - '0';\n        } else if (in[i] >= 'a' && in[i] <= 'f') {\n            out[j] |= in[i] - 'a' + 10;\n        } else if (in[i] >= 'A' && in[i] <= 'F') {\n            out[j] |= in[i] - 'A' + 10;\n        } else {\n            i++;\n            continue;\n        }\n        i++;\n        j++;\n    }\n    return j;\n}\n", "CodeBleu_score": 38.25154013447976}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t i = 0;\n    while (i < maxlen && in[0] && in[1]) {\n        unsigned char c1 = *in++;\n        unsigned char c2 = *in++;\n        if (c1 >= '0' && c1 <= '9')\n            c1 -= '0';\n        else if (c1 >= 'a' && c1 <= 'f')\n            c1 -= 'a' - 10;\n        else if (c1 >= 'A' && c1 <= 'F')\n            c1 -= 'A' - 10;\n        else\n            continue;\n        if (c2 >= '0' && c2 <= '9')\n            c2 -= '0';\n        else if (c2 >= 'a' && c2 <= 'f')\n            c2 -= 'a' - 10;\n        else if (c2 >= 'A' && c2 <= 'F')\n            c2 -= 'A' - 10;\n        else\n            continue;\n        out[i++] = (c1 << 4) | c2;\n    }\n    return i;\n}\n", "CodeBleu_score": 35.3960248939882}, {"code": "size_t HEXBuilder::hex2bytes(unsigned char *out, size_t maxlen, const char *in)    size_t outlen = 0;\n    while (*in && outlen < maxlen) {\n        unsigned char c = *in++;\n        if (c >= '0' && c <= '9') {\n            c -= '0';\n        } else if (c >= 'A' && c <= 'F') {\n            c -= 'A' - 10;\n        } else if (c >= 'a' && c <= 'f') {\n            c -= 'a' - 10;\n        } else {\n            continue;\n        }\n        if (outlen & 1) {\n            *out++ = (c << 4);\n        } else {\n            *out |= c;\n            out++;\n        }\n        outlen++;\n    }\n    return outlen;\n}\n", "CodeBleu_score": 45.65923089143741}]}
{"instance_id": "728a0972efb0", "generation_result": [{"code": "int HWCDC::availableForWrite(void)    int freeSize = 0;\n    if (txRingBuffer != NULL && txLock != NULL) {\n        if (xSemaphoreTake(txLock, TX_LOCK_TIMEOUT) == pdTRUE) {\n            freeSize = xRingbufferSpaceAvailable(txRingBuffer);\n            xSemaphoreGive(txLock);\n        }\n    }\n    return freeSize;\n}\n", "CodeBleu_score": 47.942752840754835}, {"code": "int HWCDC::availableForWrite(void)  if (!transmit_ring_buffer || !transmit_ring_buffer_lock) {\n    return 0;\n  }\n\n  if (xSemaphoreTake(transmit_ring_buffer_lock, 1000 / portTICK_PERIOD_MS) != pdTRUE) {\n    return 0;\n  }\n\n  int free_size = transmit_ring_buffer->availableForWrite();\n\n  xSemaphoreGive(transmit_ring_buffer_lock);\n\n  return free_size;\n}\n", "CodeBleu_score": 53.09334871783005}, {"code": "int HWCDC::availableForWrite(void)  int free_space;\n  if (tx_ring_buffer == NULL || tx_lock == NULL) {\n    return 0;\n  }\n  if (xSemaphoreTake(tx_lock, 1000) == pdTRUE) {\n    free_space = (tx_ring_buffer->capacity - tx_ring_buffer->used);\n    xSemaphoreGive(tx_lock);\n    return free_space;\n  } else {\n    return 0;\n  }\n}\n", "CodeBleu_score": 69.83165060673365}]}
{"instance_id": "77c2e955d3c0", "generation_result": [{"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    lock();\n    _onReceiveCB = function;\n    if (function) {\n        if (_rxTimeout > 0) {\n            _onlyOnTimeout = onlyOnTimeout;\n        }\n        if (!_eventTask) {\n            _eventTask = xTaskGetCurrentTaskHandle();\n            xTaskCreate(serialEventTaskCode, \"SerialEventTask\", 256, this, 1, NULL);\n        }\n        uart_set_fifo_full_threshold(getUart(), UART_FIFO_FULL_8BITS, 128);\n    }\n    unlock();\n}\n", "CodeBleu_score": 40.62198412916436}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)  lock();\n  _onReceiveCB = function;\n  if (_onReceiveCB) {\n    _fifo.setThreshold(1);\n    if (!_rxTask) {\n      _rxTask = xTaskGetCurrentTaskHandle();\n      xTaskCreatePinnedToCore(\n          HardwareSerial::rxTask, \"SerialRx\", 2048, this, 1, NULL, 0);\n    }\n  }\n  if (onlyOnTimeout) {\n    _rxTimeout = millis() + _rxTimeout;\n  }\n  unlock();\n}\n", "CodeBleu_score": 47.76960814340791}, {"code": "void HardwareSerial::onReceive(OnReceiveCb function, bool onlyOnTimeout)    _onReceiveCB = function;\n    if (_onReceiveCB) {\n        _rxTimeout = onlyOnTimeout;\n        _serialMutex.lock();\n        _serial->setRxFifoFullThreshold(1);\n        if (!_onReceiveTask) {\n            _onReceiveTask = xTaskGetCurrentTaskHandle();\n            xTaskCreate(HardwareSerial::onReceiveTask, \"SerialRxTask\", 128, this, 1, &_onReceiveTask);\n        }\n        _serialMutex.unlock();\n    }\n}\n", "CodeBleu_score": 46.695063073724256}]}
{"instance_id": "e30adf227199", "generation_result": [{"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)  if (length < 1)\n    return 0;\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0)\n      break;\n    *buffer++ = c;\n    index++;\n    if (c == terminator)\n      break;\n  }\n  *buffer = 0;\n  return index;\n}\n", "CodeBleu_score": 71.59326227038233}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)  if (length < 1)\n    return 0;\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0)\n      break;\n    *buffer++ = c;\n    index++;\n    if (c == terminator)\n      break;\n  }\n  *buffer = 0;\n  return index;\n}\n", "CodeBleu_score": 71.59326227038233}, {"code": "size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)  if (length < 1)\n    return 0;\n\n  size_t index = 0;\n  while (index < length) {\n    int c = timedRead();\n    if (c < 0)\n      break;\n    *buffer++ = c;\n    index++;\n    if (c == terminator)\n      break;\n  }\n  return index; // e.g., index - 1\n}\n", "CodeBleu_score": 73.79339408321228}]}
{"instance_id": "986f26ededba", "generation_result": [{"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)    Serial.print(\"tone(\");\n    Serial.print(pin);\n    Serial.print(\", \");\n    Serial.print(frequency);\n    Serial.print(\", \");\n    Serial.print(duration);\n    Serial.println(\")\");\n\n    if (pin == PIN_NOT_AVAILABLE) {\n        Serial.println(\"Pin not available\");\n        return;\n    }\n\n    if (pins[pin].is_used) {\n        Serial.print(\"Pin \");\n        Serial.print(pin);\n        Serial.println(\" is already in use\");\n        return;\n    }\n\n    pins[pin].is_used = true;\n    pins[pin].frequency = frequency;\n    pins[pin].duration = duration;\n    pins[pin].start_time = millis();\n\n    queue.push(new ToneCommand(pin, frequency, duration));\n}\n", "CodeBleu_score": 42.99322807465241}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  Serial.print(\"tone(\");\n  Serial.print(pin);\n  Serial.print(\", \");\n  Serial.print(frequency);\n  Serial.print(\", \");\n  Serial.print(duration);\n  Serial.println(\")\");\n\n  if (pin < 0 || pin >= NUM_DIGITAL_PINS) {\n    Serial.print(\"tone(): pin \");\n    Serial.print(pin);\n    Serial.println(\" is not available\");\n    return;\n  }\n\n  if (digitalPins[pin].state == PIN_IN_USE) {\n    Serial.print(\"tone(): pin \");\n    Serial.print(pin);\n    Serial.println(\" is already in use\");\n    return;\n  }\n\n  digitalPins[pin].state = PIN_IN_USE;\n  digitalPins[pin].toneFrequency = frequency;\n  digitalPins[pin].toneDuration = duration;\n\n  toneQueue.push(pin);\n}\n", "CodeBleu_score": 38.923247729072706}, {"code": "void tone(uint8_t pin, unsigned int frequency, unsigned long duration)  Serial.print(\"Tone on pin \");\n  Serial.print(pin);\n  Serial.print(\" at \");\n  Serial.print(frequency);\n  Serial.print(\" Hz for \");\n  Serial.print(duration);\n  Serial.println(\" ms\");\n\n  if (isPinAvailable(pin)) {\n    toneQueue.push(ToneCommand(pin, frequency, duration));\n    toneQueue.push(ToneCommand(pin, 0, 0));\n  } else {\n    Serial.print(\"Pin \");\n    Serial.print(pin);\n    Serial.println(\" is already in use\");\n  }\n}\n", "CodeBleu_score": 36.41239068164681}]}
{"instance_id": "93f686ae4d18", "generation_result": [{"code": "bool ESPUSB::webUSB(bool enabled)  if (!_started) {\n    _webUSB = enabled;\n    if (enabled) {\n      if (_version < 0x0210) {\n        _version = 0x0210;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 58.55299047674754}, {"code": "bool ESPUSB::webUSB(bool enabled)    if (usb_started) {\n        return false;\n    }\n    webusb_enabled = enabled;\n    if (enabled) {\n        usb_version = max(usb_version, 0x0210);\n    }\n    return true;\n}\n", "CodeBleu_score": 47.59149132612785}, {"code": "bool ESPUSB::webUSB(bool enabled)    if (!_usbStarted) {\n        _webUSB = enabled;\n        if (enabled && _usbVersion < 0x0210) {\n            _usbVersion = 0x0210;\n        }\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 59.420535945150355}]}
{"instance_id": "bd49c13e135e", "generation_result": [{"code": "void USBCDC::_onRX()  int bytesRead = _cdc.read(_rxBuffer, sizeof(_rxBuffer));\n  if (bytesRead > 0) {\n    for (int i = 0; i < bytesRead; i++) {\n      if (xQueueSendToBack(_rxQueue, &_rxBuffer[i], 0) == pdFALSE) {\n        _onOverflow(bytesRead - i);\n        break;\n      }\n    }\n    _onReceive(bytesRead);\n  }\n}\n", "CodeBleu_score": 20.091044342599364}, {"code": "void USBCDC::_onRX()    uint8_t buf[64];\n    int len = _cdc.read(buf, sizeof(buf));\n    if (len > 0) {\n        if (len > _rx_queue.available()) {\n            _overflow_event.post(len - _rx_queue.available());\n            _logger.error(\"RX queue overflow, %d bytes dropped\", len - _rx_queue.available());\n        }\n        for (int i = 0; i < len; i++) {\n            _rx_queue.push(buf[i]);\n        }\n        _rx_event.post(len);\n    }\n}\n", "CodeBleu_score": 25.109045338948}, {"code": "void USBCDC::_onRX()    if (cdc_line_coding.dwDTERate != baudRate) {\n        baudRate = cdc_line_coding.dwDTERate;\n        Serial.begin(baudRate);\n    }\n    uint8_t data[64];\n    uint8_t len = USB_CDC.read(data, sizeof(data));\n    if (len > 0) {\n        if (rx_queue.availableForStore() < len) {\n            rx_overflow_event.post(len);\n            USB_CDC.flush();\n            return;\n        }\n        for (uint8_t i = 0; i < len; i++) {\n            rx_queue.store_char(data[i]);\n        }\n        rx_event.post(len);\n    }\n}\n", "CodeBleu_score": 30.941163156530248}]}
{"instance_id": "658ef3c9dd4f", "generation_result": [{"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"name\"]\n\n\trobot, err := a.db.GetRobotByName(robotName)\n\tif err != nil {\n\t\ta.respond(res, req, http.StatusNotFound, &response{\n\t\t\tError: fmt.Sprintf(\"No robot found with name %s\", robotName),\n\t\t})\n\t\treturn\n\t}\n\n\tdevices, err := a.db.GetDevicesByRobotID(robot.ID)\n\tif err != nil {\n\t\ta.respond(res, req, http.StatusInternalServerError, &response{\n\t\t\tError: fmt.Sprintf(\"Error retrieving devices for robot %s: %s\", robotName, err.Error()),\n\t\t})\n\t\treturn\n\t}\n\n\ta.respond(res, req, http.StatusOK, &response{\n\t\tData: devices,\n\t})\n}\n", "CodeBleu_score": 38.55446124763068}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robotName\"]\n\n\trobot, err := a.db.GetRobot(robotName)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\": \\\"no robot found with name %s\\\"}\", robotName)))\n\t\treturn\n\t}\n\n\tdevices, err := a.db.GetDevices(robot.ID)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(fmt.Sprintf(\"{\\\"error\\\": \\\"%s\\\"}\", err)))\n\t\treturn\n\t}\n\n\tres.WriteHeader(http.StatusOK)\n\tres.Write([]byte(fmt.Sprintf(\"{\\\"devices\\\": %s}\", devices)))\n}\n", "CodeBleu_score": 30.964250169516305}, {"code": "func (a *API) robotDevices(res http.ResponseWriter, req *http.Request)\tvars := mux.Vars(req)\n\trobotName := vars[\"robot\"]\n\trobot, err := a.robot(robotName)\n\tif err != nil {\n\t\ta.respond(res, req, http.StatusNotFound, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\tdevices, err := robot.Devices()\n\tif err != nil {\n\t\ta.respond(res, req, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\ta.respond(res, req, http.StatusOK, devices)\n}\n", "CodeBleu_score": 34.761189689230335}]}
{"instance_id": "bc8258b7482d", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/v1/robot/\")\n\trobot, err := a.robot(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tconnections, err := a.robotConnections(robot)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 31.13159824777496}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := mux.Vars(req)[\"robot\"]\n\n\trobot, err := a.robots.Get(robotName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 23.46450532419555}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := strings.TrimPrefix(req.URL.Path, \"/robot/\")\n\trobot, ok := a.robots[robotName]\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tres.Write([]byte(\"No robot with name \" + robotName + \" found\"))\n\t\treturn\n\t}\n\tconnections, err := json.Marshal(robot.Connections())\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tres.Write([]byte(\"Error marshaling connections: \" + err.Error()))\n\t\treturn\n\t}\n\tres.Write(connections)\n}", "CodeBleu_score": 30.858891699689334}]}
{"instance_id": "b9456640d4c7", "generation_result": [{"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\tdevice, err := a.getDevice(robotName, deviceName)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tcommandFunc, ok := device.Commands[command]\n\tif !ok {\n\t\thttp.Error(res, fmt.Sprintf(\"command %s not found on device %s\", command, deviceName), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tcommandFunc()\n\n\tres.WriteHeader(http.StatusOK)\n}\n", "CodeBleu_score": 49.37875984603774}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\n\tdevice, err := a.getDevice(robotName, deviceName)\n\tif err != nil {\n\t\ta.respondWithError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\tcommand := req.URL.Query().Get(\"command\")\n\targs := req.URL.Query().Get(\"args\")\n\n\terr = device.Command(command, args)\n\tif err != nil {\n\t\ta.respondWithError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\ta.respondWithJSON(res, http.StatusOK, \"Command executed successfully\")\n}\n", "CodeBleu_score": 51.947459045582455}, {"code": "func (a *API) executeRobotDeviceCommand(res http.ResponseWriter, req *http.Request)\trobotName := req.URL.Query().Get(\"robot\")\n\tdeviceName := req.URL.Query().Get(\"device\")\n\tcommand := req.URL.Query().Get(\"command\")\n\n\trobot, err := a.robotManager.GetRobot(robotName)\n\tif err != nil {\n\t\ta.respondWithError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\tdevice, err := robot.GetDevice(deviceName)\n\tif err != nil {\n\t\ta.respondWithError(res, http.StatusNotFound, err.Error())\n\t\treturn\n\t}\n\n\terr = device.ExecuteCommand(command)\n\tif err != nil {\n\t\ta.respondWithError(res, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\ta.respondWithJSON(res, http.StatusOK, map[string]string{\"message\": \"Command executed successfully\"})\n}\n", "CodeBleu_score": 50.33437170956915}]}
{"instance_id": "b27af1ddb67b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif pair[0] != username || pair[1] != password {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n}", "CodeBleu_score": 48.48354234163007}, {"code": "func BasicAuth(username, password string) http.HandlerFunc    return func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n        // Get the credentials from the request\n        user, pass, ok := r.BasicAuth()\n        if !ok {\n            http.Error(w, \"Not authorized\", http.StatusUnauthorized)\n            return\n        }\n\n        // Compare the credentials with the expected values\n        if user != username || pass != password {\n            http.Error(w, \"Not authorized\", http.StatusUnauthorized)\n            return\n        }\n\n        // If the credentials are correct, the request is allowed to proceed\n        next.ServeHTTP(w, r)\n    }\n}\n", "CodeBleu_score": 50.01745779377341}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif pair[0] != username || pair[1] != password {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tr.SetBasicAuth(username, password)\n\t}\n}\n", "CodeBleu_score": 48.48886455646538}]}
{"instance_id": "44daf24485fb", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\t// Lock the sensor for reading.\n\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\t// Check if the sensor supports analog reading.\n\tif !a.supportsAnalogReading {\n\t\treturn 0, 0, fmt.Errorf(\"sensor does not support analog reading\")\n\t}\n\n\t// Retrieve the raw sensor value.\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"failed to read sensor: %v\", err)\n\t}\n\n\t// Scale the raw value according to the sensor's configuration.\n\tscaled := float64(raw) * a.scale\n\n\t// Update the last read values.\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 46.01617565981433}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tif !a.connection.supportsAnalogReading {\n\t\treturn 0, 0, fmt.Errorf(\"sensor %s does not support analog reading\", a.name)\n\t}\n\n\traw, err := a.connection.analogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scaledValue(raw)\n\n\ta.lastReadRaw = raw\n\ta.lastReadScaled = scaled\n\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 48.19485914649952}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.lock.Lock()\n\tdefer a.lock.Unlock()\n\n\tif !a.connection.SupportsAnalogReading() {\n\t\treturn 0, 0, fmt.Errorf(\"connection does not support analog reading\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tscaled := a.scale(raw)\n\ta.lastRaw = raw\n\ta.lastScaled = scaled\n\treturn raw, scaled, nil\n}\n", "CodeBleu_score": 46.47758653682919}]}
{"instance_id": "f0d7bf48c40b", "generation_result": [{"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tg := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"GroveSoundSensor\",\n\t}\n\n\tg.AddEventDetectors(g.SoundDetected)\n\n\treturn g\n}\n", "CodeBleu_score": 41.340229823100515}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver    d := &GroveSoundSensorDriver{\n        name:       \"GroveSoundSensor\",\n        pin:        pin,\n        AnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n    }\n    return d\n}\n", "CodeBleu_score": 44.61286910738891}, {"code": "func NewGroveSoundSensorDriver(a AnalogReader, pin string, opts ...interface{}) *GroveSoundSensorDriver\tgs := &GroveSoundSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"Grove Sound Sensor\",\n\t}\n\tgs.SetName(gs.name)\n\treturn gs\n}\n", "CodeBleu_score": 42.401223937653256}]}
{"instance_id": "e9605540ecaf", "generation_result": [{"code": "func (d *MFRC522Common) softReset() error\td.writeReg(0x01, 0x0F)\n\ttime.Sleep(150 * time.Millisecond)\n\tstatus, err := d.readReg(0x01)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif (status & 0x0F) != 0x0F {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 43.80739876431278}, {"code": "func (d *MFRC522Common) softReset() error\t// Write the command SoftReset\n\td.write(CommandReg, SoftReset)\n\n\t// Wait for 25ms\n\ttime.Sleep(25 * time.Millisecond)\n\n\t// Read the command register\n\tcommand, err := d.read(CommandReg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the power-down bit is still set\n\tif command&0x01 != 0 {\n\t\treturn errors.New(\"initialization took too long\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 52.808028158140715}, {"code": "func (d *MFRC522Common) softReset() error\td.writeRegister(0x01, 0x0F)\n\ttime.Sleep(150 * time.Millisecond)\n\tstatus, err := d.readRegister(0x01)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif (status & 0x0F) != 0x0F {\n\t\treturn errors.New(\"soft reset failed\")\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 44.11814803275303}]}
{"instance_id": "7c10ca38153c", "generation_result": [{"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\td.writeReg(0x00, 0x00)\n\td.writeReg(0x01, 0x00)\n\n\tlen := d.readReg(0x02)\n\tif len != uint8(len(backData)) {\n\t\treturn 0, errors.New(\"backData len error\")\n\t}\n\n\tfor i := 0; i < len; i++ {\n\t\tbackData[i] = d.readReg(0x09)\n\t}\n\n\treturn d.readReg(0x04), nil\n}\n", "CodeBleu_score": 25.18145226617849}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tn, err := d.readRegister(FIFOLevelReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != uint8(len(backData)) {\n\t\treturn 0, fmt.Errorf(\"FIFO data size mismatch: %d != %d\", n, len(backData))\n\t}\n\n\t_, err = d.readRegister(FIFODataReg, backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tcontrol, err := d.readRegister(ControlReg)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn control & 0x07, nil\n}\n", "CodeBleu_score": 51.20291215038926}, {"code": "func (d *MFRC522Common) readFifo(backData []byte) (uint8, error)\tbuf := make([]byte, 1)\n\tn, err := d.dev.Read(buf)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != 1 {\n\t\treturn 0, errors.New(\"unexpected number of bytes read\")\n\t}\n\tlength := buf[0]\n\tif length != uint8(len(backData)) {\n\t\treturn 0, errors.New(\"length of data does not match expected length\")\n\t}\n\tn, err = d.dev.Read(backData)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != len(backData) {\n\t\treturn 0, errors.New(\"unexpected number of bytes read\")\n\t}\n\tbuf = make([]byte, 1)\n\tn, err = d.dev.Read(buf)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif n != 1 {\n\t\treturn 0, errors.New(\"unexpected number of bytes read\")\n\t}\n\treturn buf[0], nil\n}\n", "CodeBleu_score": 49.281136716981756}]}
{"instance_id": "a2ef62668705", "generation_result": [{"code": "func (d *MFRC522Common) piccHalt() error\tif d.debug {\n\t\td.debugPrint(\"Halting PICC...\")\n\t}\n\n\t// Create the command, CRC and send it to the PICC\n\tcmd := []byte{0x50, 0x00, 0x00, 0x00, 0x00}\n\td.crc(cmd)\n\t_, err := d.dev.Write(cmd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the PICC to respond\n\tres, err := d.dev.Read(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the PICC responded with an error\n\tif res[0] != 0x05 {\n\t\treturn fmt.Errorf(\"PICC did not respond with an error\")\n\t}\n\n\tif d.debug {\n\t\td.debugPrint(\"PICC halted successfully\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 37.61058235084933}, {"code": "func (d *MFRC522Common) piccHalt() error\t// Check if debugging is enabled\n\tif d.Debug {\n\t\td.log.Println(\"Halting communication with PICC...\")\n\t}\n\n\t// Create a halt command\n\tcmd := []byte{0x50, 0x00, 0x00, 0x00}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calcCRC(cmd)\n\n\t// Append the CRC result to the command\n\tcmd = append(cmd, crc...)\n\n\t// Send the halt command to the PICC\n\t_, err := d.spi.Write(cmd)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send halt command: %v\", err)\n\t}\n\n\t// Expect an error to indicate successful halting\n\tresp, err := d.spi.Read(4)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read response from PICC: %v\", err)\n\t}\n\n\t// Check if the response is an error\n\tif resp[0] != 0x90 || resp[1] != 0x00 {\n\t\treturn fmt.Errorf(\"failed to halt communication with PICC: %v\", resp)\n\t}\n\n\t// Log a debug message if debugging is enabled\n\tif d.Debug {\n\t\td.log.Println(\"Communication with PICC halted successfully\")\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 43.2112843178486}, {"code": "func (d *MFRC522Common) piccHalt() error\t// Log debug message if debugging is enabled\n\td.logDebug(\"Halting communication with PICC...\")\n\n\t// Create a halt command\n\tcommand := []byte{0x50, 0x00, 0x00, 0x00}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calculateCRC(command)\n\n\t// Append the CRC result to the command\n\tcommand = append(command, crc...)\n\n\t// Send the halt command to the PICC\n\t_, err := d.spi.Write(command)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Expect an error to indicate successful halting\n\tresponse, err := d.spi.Read(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the response indicates successful halting\n\tif response[0] != 0x90 {\n\t\treturn fmt.Errorf(\"failed to halt communication with PICC\")\n\t}\n\n\t// Return nil if the halt is successful\n\treturn nil\n}\n", "CodeBleu_score": 44.96300602227022}]}
{"instance_id": "04841011faf7", "generation_result": [{"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tcmd := []byte{0xFF, 0xB0, 0x00, 0x00, 0x00}\n\tcmd[2] = block\n\n\tcrc := d.calcCRC(cmd[0:4])\n\tcmd = append(cmd, crc[0:2]...)\n\n\tres, err := d.transceive(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif res[0] != 0x90 || res[1] != 0x00 {\n\t\treturn nil, errors.New(\"piccRead failed\")\n\t}\n\n\treturn res[6 : 6+16], nil\n}\n", "CodeBleu_score": 31.0419590112397}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\t// Construct the command\n\tcmd := []byte{0xFF, 0xB0, 0x00, block}\n\n\t// Calculate the CRC for the command\n\tcrc := d.calcCRC(cmd)\n\n\t// Append the CRC to the command\n\tcmd = append(cmd, crc...)\n\n\t// Communicate with the RFID card using the command\n\tdata, err := d.communicate(cmd)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check the response from the RFID card\n\tif data[0] != 0x00 || data[1] != 0x00 || data[2] != 0x00 {\n\t\treturn nil, fmt.Errorf(\"invalid response from RFID card\")\n\t}\n\n\t// Return the data from the specified block\n\treturn data[3:], nil\n}\n", "CodeBleu_score": 40.88141070992231}, {"code": "func (d *MFRC522Common) piccRead(block uint8) ([]byte, error)\tcommand := []byte{0x30, block}\n\tcrc := d.calcCRC(command)\n\tcommand = append(command, crc...)\n\n\tresp, err := d.transceive(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(resp) < 18 {\n\t\treturn nil, fmt.Errorf(\"invalid response length: %d\", len(resp))\n\t}\n\n\tdata := resp[6:16]\n\tdata = append(data, resp[16:18]...)\n\n\treturn data, nil\n}\n", "CodeBleu_score": 41.07798487466937}]}
{"instance_id": "70dc02692db5", "generation_result": [{"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\t// Prepare MFRC522\n\td.write(REG_BIT_FRAMING, 0x00) //TxLastBists = BitFramingReg[2..0]\n\td.write(REG_COMM_IEN, 0x00)    //Disable all interrupt\n\td.write(REG_COMM_IRQ, 0x7F)    //Clear all interrupt\n\td.write(REG_FIFO_LEVEL, 0x80)  //FlushBuffer = 1, FIFO initialization\n\n\t// Transmit the request\n\td.write(REG_COMM_IRQ, 0x00) //Clear all interrupt\n\td.write(REG_COMM_IEN, 0x01) //Enable interrupt\n\td.write(REG_COMM_IFS, 0x00) //Clear all interrupt\n\td.write(REG_COMM_IRQ, 0x00) //Clear all interrupt\n\n\t// Communicate with the PICC\n\td.write(REG_COMM_IRQ, 0x00) //Clear all interrupt\n\td.write(REG_COMM_IEN, 0x01) //Enable interrupt\n\td.write(REG_COMM_IFS, 0x00) //Clear all interrupt\n\td.write(REG_COMM_IRQ, 0x00) //Clear all interrupt\n\n\t// Wait for the answer\n\td.write(REG_COMM_IRQ, 0x00) //Clear all interrupt\n\td.write(REG_COMM_IEN, 0x01) //Enable interrupt\n\td.write(REG_COMM_IFS, 0x00) //Clear all interrupt\n\td.write(REG_COMM_IRQ, 0x00) //Clear all interrupt\n\n\t// Stop the timer\n\td.write(REG_COMM_IRQ, 0x00) //Clear all interrupt\n\td.write(REG_COMM_IEN, 0x01) //Enable interrupt\n\td.write(REG_COMM_IFS, 0x00) //Clear all interrupt\n\td.write(REG_COMM_IRQ, 0", "CodeBleu_score": 26.543951353781488}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\td.clearBitMask(0x90, 0x88)\n\td.setBitMask(0x90, 0x40)\n\td.setBitMask(0x90, 0x80)\n\td.setBitMask(0x90, 0x10)\n\td.setBitMask(0x90, 0x08)\n\td.setBitMask(0x90, 0x04)\n\td.setBitMask(0x90, 0x02)\n\td.setBitMask(0x90, 0x01)\n\n\td.setBitMask(0x93, 0x80)\n\td.setBitMask(0x93, 0x40)\n\td.setBitMask(0x93, 0x20)\n\td.setBitMask(0x93, 0x10)\n\td.setBitMask(0x93, 0x08)\n\td.setBitMask(0x93, 0x04)\n\td.setBitMask(0x93, 0x02)\n\td.setBitMask(0x93, 0x01)\n\n\td.setBitMask(0x92, 0x80)\n\td.setBitMask(0x92, 0x40)\n\td.setBitMask(0x92, 0x20)\n\td.setBitMask(0x92, 0x10)\n\td.setBitMask(0x92, 0x08)\n\td.setBitMask(0x92, 0x04)\n\td.setBitMask(0x92, 0x02)\n\td.setBitMask(0x92, 0x01)\n\n\td.setBitMask(0x91, 0x80)\n\td.setBitMask(0x91, 0x40)\n\td.setBitMask(0x91, 0x", "CodeBleu_score": 13.549609063760071}, {"code": "func (d *MFRC522Common) piccRequest(reqMode uint8, answer []byte) error\tif len(answer) < 2 {\n\t\treturn errors.New(\"answer buffer too small\")\n\t}\n\n\td.collReg = 0x80\n\n\tswitch reqMode {\n\tcase REQA:\n\t\td.setRegBitMask(0x0D, 0x07)\n\t\td.setRegBitMask(0x09, 0x03)\n\tcase WUPA:\n\t\td.setRegBitMask(0x0D, 0x07)\n\t\td.setRegBitMask(0x09, 0x03)\n\tdefault:\n\t\td.clearRegBitMask(0x0D, 0x07)\n\t\td.setRegBitMask(0x09, 0x03)\n\t}\n\n\td.writeRegister(0x01, 0x00)\n\n\tirqEn, err := d.getInterruptRequest()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tirqEn &= 0x12\n\n\td.writeRegister(0x02, irqEn|0x01)\n\n\td.writeRegister(0x0D, 0x01)\n\n\t_, err = d.transceive(answer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\td.writeRegister(0x02, irqEn)\n\n\td.writeRegister(0x0D, 0x00)\n\n\treturn nil\n}\n", "CodeBleu_score": 43.230198564417925}]}
{"instance_id": "18bf5f10ea02", "generation_result": [{"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\t// Trigger a valid step\n\terr := d.stepPin.Write(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.stepPin.Write(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Increment or decrement the step number\n\tif d.direction == DirectionCW {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 64.12802594115388}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.direction == d.directionUp {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\terr := d.stepPin.DigitalWrite(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.stepPin.DigitalWrite(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 52.90449349063594}, {"code": "func (d *EasyDriver) onePinStepping() error\td.valueMutex.Lock()\n\tdefer d.valueMutex.Unlock()\n\n\tif d.stepPin == nil {\n\t\treturn fmt.Errorf(\"step pin not set\")\n\t}\n\n\terr := d.stepPin.DigitalWrite(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttime.Sleep(d.stepDelay)\n\n\terr = d.stepPin.DigitalWrite(1)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif d.direction == 1 {\n\t\td.stepNumber++\n\t} else {\n\t\td.stepNumber--\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 61.37959584713195}]}
{"instance_id": "6d68988a836a", "generation_result": [{"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.distanceMonitorRunning {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\n\td.distanceMonitorStopChan = make(chan struct{})\n\td.distanceMonitorWg.Add(1)\n\tgo d.distanceMonitor()\n\td.distanceMonitorRunning = true\n\treturn nil\n}\n", "CodeBleu_score": 28.311509707999548}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\tif d.stop != nil {\n\t\treturn ErrMonitorAlreadyRunning\n\t}\n\n\td.stop = make(chan struct{})\n\td.wg = &sync.WaitGroup{}\n\n\td.wg.Add(1)\n\tgo d.monitor()\n\n\treturn nil\n}\n", "CodeBleu_score": 36.64926916910216}, {"code": "func (d *HCSR04Driver) StartDistanceMonitor() error\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\tif d.monitor != nil {\n\t\treturn errors.New(\"distance monitor already running\")\n\t}\n\td.monitor = &distanceMonitor{\n\t\tstop: make(chan struct{}),\n\t\twg:   &sync.WaitGroup{},\n\t}\n\td.monitor.wg.Add(1)\n\tgo func() {\n\t\tdefer d.monitor.wg.Done()\n\t\tticker := time.NewTicker(d.monitorInterval)\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-d.monitor.stop:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tdistance, err := d.Distance()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"Error measuring distance:\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\td.mu.Lock()\n\t\t\t\td.distance = distance\n\t\t\t\td.mu.Unlock()\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}\n", "CodeBleu_score": 47.36868717780626}]}
{"instance_id": "e081f93e0d95", "generation_result": [{"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\treturn func(pin int, duration time.Duration, edge string, value uint32, timestamp uint32) {\n\t\tif edge == \"rising\" {\n\t\t\td.startTimestamp = timestamp\n\t\t} else if edge == \"falling\" {\n\t\t\td.channel <- duration\n\t\t}\n\t}\n}\n", "CodeBleu_score": 30.930226391502437}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\tstartTimestamp := time.Now()\n\treturn func(pin int, duration time.Duration, eventName string, timestamp uint32, value uint32) {\n\t\tswitch eventName {\n\t\tcase \"rising\":\n\t\t\tstartTimestamp = time.Now()\n\t\tcase \"falling\":\n\t\t\tduration := time.Since(startTimestamp)\n\t\t\td.durationChan <- duration\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.369886131703154}, {"code": "func (d *HCSR04Driver) createEventHandler() func(int, time.Duration, string, uint32, uint32)\treturn func(pin int, duration time.Duration, event string, sequenceNumber uint32, value uint32) {\n\t\tif event == \"rising\" {\n\t\t\td.start = time.Now()\n\t\t} else if event == \"falling\" {\n\t\t\td.ch <- time.Now().Sub(d.start)\n\t\t}\n\t}\n}\n", "CodeBleu_score": 31.944756812845526}]}
{"instance_id": "3e6e58865196", "generation_result": [{"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\t// Trigger the measurement by sending a pulse of 10 microseconds to the trigger pin\n\terr := d.triggerPin.Write(gpio.High)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(10 * time.Microsecond)\n\terr = d.triggerPin.Write(gpio.Low)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the echo pin to go high\n\ttimeout := time.Now().Add(1000 * time.Millisecond)\n\tfor {\n\t\tlevel, err := d.echoPin.Read()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif level == gpio.High {\n\t\t\tbreak\n\t\t}\n\t\tif time.Now().After(timeout) {\n\t\t\treturn errors.New(\"timeout waiting for echo pin to go high\")\n\t\t}\n\t}\n\n\t// Wait for the echo pin to go low\n\tstart := time.Now()\n\tfor {\n\t\tlevel, err := d.echoPin.Read()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif level == gpio.Low {\n\t\t\tbreak\n\t\t}\n\t}\n\td.distance = time.Since(start)\n\n\treturn nil\n}\n", "CodeBleu_score": 55.81271970777559}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.mutex.Lock()\n\tdefer d.mutex.Unlock()\n\n\td.triggerPin.High()\n\ttime.Sleep(time.Microsecond * 10)\n\td.triggerPin.Low()\n\n\tstart := time.Now()\n\ttimeout := start.Add(time.Millisecond * 200)\n\n\tfor {\n\t\tif d.echoPin.Read() == gpio.High {\n\t\t\tbreak\n\t\t}\n\t\tif time.Now().After(timeout) {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\tstart = time.Now()\n\ttimeout = start.Add(time.Millisecond * 200)\n\n\tfor {\n\t\tif d.echoPin.Read() == gpio.Low {\n\t\t\tbreak\n\t\t}\n\t\tif time.Now().After(timeout) {\n\t\t\treturn fmt.Errorf(\"timeout waiting for echo\")\n\t\t}\n\t}\n\n\td.distance = time.Since(start).Microseconds()\n\n\treturn nil\n}\n", "CodeBleu_score": 49.700487819464435}, {"code": "func (d *HCSR04Driver) measureDistance() error\td.measurementMutex.Lock()\n\tdefer d.measurementMutex.Unlock()\n\n\t// Trigger the sensor to start the measurement\n\tif err := d.triggerPin.Write(gpio.High); err != nil {\n\t\treturn err\n\t}\n\ttime.Sleep(10 * time.Microsecond)\n\tif err := d.triggerPin.Write(gpio.Low); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for the measurement to complete or for a timeout to occur\n\ttimeout := time.Now().Add(500 * time.Millisecond)\n\tfor {\n\t\tif d.echoPin.Read() == gpio.High {\n\t\t\tbreak\n\t\t}\n\t\tif time.Now().After(timeout) {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t\ttime.Sleep(10 * time.Microsecond)\n\t}\n\n\t// Measure the time between the trigger and the echo\n\tstart := time.Now()\n\tfor {\n\t\tif d.echoPin.Read() == gpio.Low {\n\t\t\tbreak\n\t\t}\n\t\tif time.Now().After(timeout) {\n\t\t\treturn errors.New(\"timeout\")\n\t\t}\n\t\ttime.Sleep(10 * time.Microsecond)\n\t}\n\td.measuredTime = time.Since(start)\n\treturn nil\n}\n", "CodeBleu_score": 55.8689274530208}]}
{"instance_id": "2e67109ea5b2", "generation_result": [{"code": "def fetch_authentication_token(self)\n    access_token = os.getenv('ACCESS_TOKEN')\n    if not access_token:\n        access_token, expiration_time = self.fetch_access_token_from_state()\n        if not access_token:\n            access_token, expiration_time = self.fetch_access_token_from_refresh_token()\n            if not access_token:\n                raise AccountNotAuthorized()\n    return access_token\n", "CodeBleu_score": 15.401724131323407}, {"code": "def fetch_authentication_token(self)\n    access_token = os.getenv(\"ACCESS_TOKEN\")\n    if access_token:\n        return access_token\n\n    access_token = self.state.get(\"access_token\")\n    if access_token:\n        expiration_time = self.state.get(\"expiration_time\")\n        if expiration_time and expiration_time > time.time():\n            return access_token\n\n    refresh_token = self.state.get(\"refresh_token\")\n    if refresh_token:\n        try:\n            new_access_token = self.fetch_access_token(refresh_token)\n            self.state[\"access_token\"] = new_access_token\n            self.state[\"expiration_time\"] = time.time() + (3599 - 60)\n            return new_access_token\n        except Exception as e:\n            raise AccountNotAuthorized(e)\n\n    raise AccountNotAuthorized(\"No authentication token found.\")", "CodeBleu_score": 37.88079996186926}, {"code": "def fetch_authentication_token(self)\n    token = os.environ.get(\"AUTHENTICATION_TOKEN\")\n    if token:\n        return token\n    access_token = self.state.get(\"access_token\")\n    if access_token and not self.is_access_token_expired():\n        return access_token\n    refresh_token = self.state.get(\"refresh_token\")\n    if refresh_token:\n        try:\n            self.fetch_access_token(refresh_token)\n            return self.state[\"access_token\"]\n        except AccountNotAuthorized:\n            pass\n    raise AccountNotAuthorized(\"No authentication token found\")", "CodeBleu_score": 29.11991862415292}]}
{"instance_id": "791802ce1fb5", "generation_result": [{"code": "def logout(self)\n    refresh_token = self.refresh_token\n    self.delete_session()\n    try:\n        self.request(\"POST\", \"/v1/logout\", data={\"refresh_token\": refresh_token})\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 46.768903791934356}, {"code": "def logout(self)\n    refresh_token = self.refresh_token\n    self.delete_local_session()\n    try:\n        self.api.post(\n            \"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n            headers={\"Content-Type\": \"application/json\"},\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 51.19616929642451}, {"code": "def logout(self)\n    refresh_token = self.get_refresh_token()\n    self.delete_local_session()\n    try:\n        self.post(\n            \"/v1/logout\",\n            data={\"refresh_token\": refresh_token},\n            headers={\"Content-Type\": \"application/json\"},\n        )\n    except AccountError:\n        pass\n    return True", "CodeBleu_score": 55.619699223216976}]}
{"instance_id": "6384129c9ae6", "generation_result": [{"code": "def dump_used_packages(self)\n    result = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        metadata = package.metadata\n        if metadata.external:\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                    \"source\": metadata.source,\n                }\n            )\n        else:\n            result.append(\n                {\n                    \"name\": package.name,\n                    \"version\": package.version,\n                }\n            )\n    return result", "CodeBleu_score": 25.644536895398}, {"code": "def dump_used_packages(self)\n    used_packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        package_data = {\n            \"name\": package.name,\n            \"version\": package.version,\n            \"source_url\": package.source_url,\n        }\n        if package.source_url:\n            package_data[\"source_url\"] = package.source_url\n        used_packages.append(package_data)\n    return used_packages\n\n", "CodeBleu_score": 28.75051200150477}, {"code": "def dump_used_packages(self)\n    used_packages = []\n    for package in self.packages:\n        if package.optional:\n            continue\n        metadata = package.get_metadata()\n        if metadata.external:\n            used_packages.append({\"name\": package.name, \"version\": package.version, \"source\": metadata.source})\n        else:\n            used_packages.append({\"name\": package.name, \"version\": package.version})\n    return used_packages", "CodeBleu_score": 27.290308678408813}]}
{"instance_id": "fb6e9b1c15cd", "generation_result": [{"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    platform = cls.config.get_platform(env)\n    if not platform:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(platform, autoinstall=autoinstall)\n    instance.project_env = env\n    instance.configure_packages(targets)\n    return instance", "CodeBleu_score": 25.522889171517033}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    platform_spec = cls.project.config.get_env_platform(env)\n    if platform_spec is None:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    cls.project.env = instance\n    cls.project.configure_packages(targets=targets)\n    return instance\n\n", "CodeBleu_score": 26.7966747831062}, {"code": "def from_env(cls, env, targets=None, autoinstall=False)\n    platform_spec = cls.project.config.get_platform_spec(env)\n    if platform_spec is None:\n        raise UndefinedEnvPlatformError(env)\n    instance = cls(platform_spec, autoinstall=autoinstall)\n    cls.project.set_env(env)\n    instance.configure_packages(targets=targets)\n    return instance", "CodeBleu_score": 26.648311355614666}]}
{"instance_id": "437d8520b195", "generation_result": [{"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(AXP192_I2C_ADDR);\n  Wire.write(Addr);\n  Wire.endTransmission();\n\n  Wire.requestFrom(AXP192_I2C_ADDR, Size);\n  uint8_t i = 0;\n  while (Wire.available()) {\n    Buff[i] = Wire.read();\n    i++;\n  }\n}\n", "CodeBleu_score": 50.865029948577224}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)    Wire.beginTransmission(AXP192_ADDRESS);\n    Wire.write(Addr);\n    Wire.endTransmission();\n    Wire.requestFrom(AXP192_ADDRESS, Size);\n    while (Wire.available() != Size);\n    for (uint8_t i = 0; i < Size; i++) {\n        Buff[i] = Wire.read();\n    }\n}\n", "CodeBleu_score": 62.03337160808281}, {"code": "void AXP192::ReadBuff(uint8_t Addr, uint8_t Size, uint8_t *Buff)  Wire.beginTransmission(AXP192_I2C_ADDRESS);\n  Wire.write(Addr);\n  Wire.endTransmission();\n\n  Wire.requestFrom(AXP192_I2C_ADDRESS, Size);\n  while (Wire.available() < Size);\n  for (uint8_t i = 0; i < Size; i++) {\n    Buff[i] = Wire.read();\n  }\n}\n", "CodeBleu_score": 61.00510150795636}]}
{"instance_id": "256a5084bf22", "generation_result": [{"code": "void AXP192::DeepSleep(uint64_t time_in_us)    SetSleep(time_in_us);\n    if (time_in_us) {\n        // Enable timer wakeup source\n        writeRegister(AXP192_TIMER_CONTROL1, 0x01);\n    } else {\n        // Disable timer wakeup source\n        writeRegister(AXP192_TIMER_CONTROL1, 0x00);\n    }\n    // Initiate deep sleep\n    writeRegister(AXP192_DEEP_SLEEP_CTRL, 0x01);\n}\n", "CodeBleu_score": 37.23277749177176}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)  SetSleep(time_in_us);\n  if (time_in_us == 0) {\n    // Disable timer wakeup source\n    Write8(0x32, 0x00);\n  } else {\n    // Enable timer wakeup source\n    Write8(0x32, 0x80);\n    // Set timer wakeup time\n    uint64_t time_in_ms = time_in_us / 1000;\n    uint8_t msb = time_in_ms >> 8;\n    uint8_t lsb = time_in_ms & 0xFF;\n    Write8(0x33, msb);\n    Write8(0x34, lsb);\n  }\n  // Initiate deep sleep\n  Write8(0x35, 0x02);\n}\n", "CodeBleu_score": 45.235183991064545}, {"code": "void AXP192::DeepSleep(uint64_t time_in_us)    SetSleep();\n    if (time_in_us > 0) {\n        uint32_t time_in_ms = time_in_us / 1000;\n        uint32_t time_in_s = time_in_ms / 1000;\n        uint32_t time_in_min = time_in_s / 60;\n        uint32_t time_in_h = time_in_min / 60;\n        uint32_t time_in_d = time_in_h / 24;\n        uint32_t time_in_y = time_in_d / 365;\n        uint32_t time_in_ms_remainder = time_in_ms % 1000;\n        uint32_t time_in_s_remainder = time_in_s % 60;\n        uint32_t time_in_min_remainder = time_in_min % 60;\n        uint32_t time_in_h_remainder = time_in_h % 24;\n        uint32_t time_in_d_remainder = time_in_d % 365;\n        uint32_t time_in_y_remainder = time_in_y;\n        if (time_in_y_remainder > 0) {\n            axp192_write(AXP192_TIMER_YEAR, time_in_y_remainder);\n        }\n        if (time_in_d_remainder > 0) {\n            axp192_write(AXP192_TIMER_DAY, time_in_d_remainder);\n        }\n        if (time_in_h_remainder > 0) {\n            axp192_write(AXP192_TIMER_HOUR, time_in_h_remainder);\n        }\n        if (time_in_min_remainder > 0) {\n            axp192_write(AXP1", "CodeBleu_score": 34.817503198061736}]}
{"instance_id": "00a628ed69af", "generation_result": [{"code": "int Display::scroll_line(uint32_t color)    int y = start_y;\n    start_y = (start_y + tteBar) % (height - 2);\n    if (start_y < 0) {\n        start_y += height - 2;\n    }\n    fill_rect(0, y, width, 1, color);\n    return y;\n}\n", "CodeBleu_score": 14.479635823139592}, {"code": "int Display::scroll_line(uint32_t color)    int y_coord = this->scroll_address;\n    int new_y_coord = y_coord + this->line_height;\n    if (new_y_coord >= this->display_height - this->bottom_fixed_area) {\n        new_y_coord = this->top_fixed_area;\n    }\n    this->fill_rectangle(y_coord, this->display_width, this->line_height, color);\n    this->scroll_address = new_y_coord;\n    return y_coord;\n}\n", "CodeBleu_score": 11.027423511760173}, {"code": "int Display::scroll_line(uint32_t color)    int prev_y = y;\n    int y_start = y;\n    int y_end = y + text_line_height;\n    int y_wrap = y_start + display_height - text_line_height - bottom_fixed_area_height;\n    if (tteBar) {\n        y_wrap = y_start + display_height - text_line_height - top_fixed_area_height;\n    }\n    if (y_end >= display_height) {\n        y = y_start;\n        y_end = y + text_line_height;\n    }\n    if (y_wrap >= display_height) {\n        y_wrap = y_start;\n    }\n    tft.fillRect(0, y_start, display_width, y_end - y_start, color);\n    if (y_end >= display_height) {\n        tft.fillRect(0, y_start, display_width, y_end - display_height, color);\n    }\n    if (y_wrap >= display_height) {\n        tft.fillRect(0, y_start, display_width, y_wrap - display_height, color);\n    }\n    y = y_end;\n    if (y >= display_height) {\n        y -= display_height;\n    }\n    return prev_y;\n}\n", "CodeBleu_score": 37.18668821519353}]}
{"instance_id": "b2af25a9f3e8", "generation_result": [{"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)\n  // Setup Access Points\n  if (!setup_access_points(access_points)) {\n    return false;\n  }\n\n  // Setup HTML\n  if (!setup_html(ssids)) {\n    return false;\n  }\n\n  // Start Portal\n  if (!start_portal()) {\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 56.923939225977804}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if (!_access_points_setup(access_points)) {\n    return false;\n  }\n  if (!_html_content_setup()) {\n    return false;\n  }\n  _ssids = ssids;\n  return true;\n}\n", "CodeBleu_score": 57.37299181789566}, {"code": "bool EvilPortal::begin(LinkedList<ssid>* ssids, LinkedList<AccessPoint>* access_points)  if (ssids != NULL) {\n    this->ssids = ssids;\n  }\n  if (access_points != NULL) {\n    this->access_points = access_points;\n  }\n\n  if (this->ssids->size() == 0) {\n    Serial.println(\"No SSIDs to connect to\");\n    return false;\n  }\n\n  if (this->access_points->size() == 0) {\n    Serial.println(\"No Access Points to connect to\");\n    return false;\n  }\n\n  if (!this->setup_access_points()) {\n    Serial.println(\"Failed to setup access points\");\n    return false;\n  }\n\n  if (!this->setup_html_content()) {\n    Serial.println(\"Failed to setup HTML content\");\n    return false;\n  }\n\n  if (!this->start_portal()) {\n    Serial.println(\"Failed to start portal\");\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 49.46138737443465}]}
{"instance_id": "9ad8e092bdd8", "generation_result": [{"code": "void GpsInterface::enable_queue()  if (queue_enabled_flag) {\n    if (text_in != NULL) {\n      free(text_in);\n    }\n    text_in = (char *) malloc(sizeof(char) * 100);\n    if (text != NULL) {\n      free(text);\n    }\n    text = (char *) malloc(sizeof(char) * 100);\n  } else {\n    if (text_in != NULL) {\n      free(text_in);\n    }\n    if (text != NULL) {\n      free(text);\n    }\n    text_in = (char *) malloc(sizeof(char) * 100);\n    text = (char *) malloc(sizeof(char) * 100);\n    queue_enabled_flag = true;\n  }\n}\n", "CodeBleu_score": 10.892794842875816}, {"code": "void GpsInterface::enable_queue()    if (!queue_enabled_flag) {\n        queue_enabled_flag = true;\n        queue = xQueueCreate(queue_length, queue_item_size);\n        text = (char*)malloc(text_length);\n        text_in = (char*)malloc(text_length);\n    }\n}\n", "CodeBleu_score": 12.146064563524842}, {"code": "void GpsInterface::enable_queue()    if (queue_enabled_flag) {\n        if (!queue_initialized) {\n            queue = xQueueCreate(1, sizeof(GpsData));\n            queue_initialized = true;\n        }\n        if (!text_initialized) {\n            text = (char *)malloc(GPS_MAX_TEXT_LENGTH);\n            text_initialized = true;\n        }\n        if (!text_in_initialized) {\n            text_in = (char *)malloc(GPS_MAX_TEXT_LENGTH);\n            text_in_initialized = true;\n        }\n    } else {\n        xQueueReset(queue);\n        queue_enabled_flag = true;\n    }\n}\n", "CodeBleu_score": 10.58769609604493}]}
{"instance_id": "607c4ad31e75", "generation_result": [{"code": "void GpsInterface::flush_queue_nmea()  if (queue_nmea.size() > 0) {\n    queue_nmea.clear();\n    queue_nmea = {};\n  }\n}\n", "CodeBleu_score": 31.859722305578035}, {"code": "void GpsInterface::flush_queue_nmea()    if (queue_nmea_ != NULL) {\n        if (queue_nmea_->size() > 0) {\n            delete queue_nmea_;\n            queue_nmea_ = new std::queue<std::string>;\n        }\n    } else {\n        queue_nmea_ = new std::queue<std::string>;\n    }\n}\n", "CodeBleu_score": 41.45761591143545}, {"code": "void GpsInterface::flush_queue_nmea()  if (this->queue_nmea) {\n    if (this->queue_nmea->size()) {\n      this->queue_nmea->clear();\n      delete this->queue_nmea;\n    }\n    this->queue_nmea = new Queue<String>(10);\n  } else {\n    this->queue_nmea = new Queue<String>(10);\n  }\n}\n", "CodeBleu_score": 25.92877046605311}]}
{"instance_id": "8cbba9bbe0f4", "generation_result": [{"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    // Start a write transaction\n    lv_disp_flush_trans_t trans;\n    lv_disp_flush_trans_begin(&trans, disp, area);\n\n    // Set the address window to the specified area\n    lv_disp_flush_trans_set_area(&trans, area);\n\n    // Iterate through each pixel in the area\n    for (int y = area->y1; y <= area->y2; y++) {\n        for (int x = area->x1; x <= area->x2; x++) {\n            // Get the color for the current pixel\n            lv_color_t color = color_p[y * disp->hor_res + x];\n\n            // Write the color to the display\n            lv_disp_flush_trans_set_color(&trans, &color);\n        }\n    }\n\n    // End the write transaction\n    lv_disp_flush_trans_end(&trans);\n\n    // Notify that the display flush is complete\n    lv_disp_flush_ready(disp);\n}", "CodeBleu_score": 55.94061844457345}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    uint16_t x, y;\n    uint32_t width = (area->x2 - area->x1 + 1);\n    uint32_t height = (area->y2 - area->y1 + 1);\n\n    // Start write transaction\n    ILI9341_WriteReg(ILI9341_CMD_WRITE_MEMORY_START);\n\n    // Set address window\n    ILI9341_WriteReg(ILI9341_CMD_SET_COLUMN_ADDRESS);\n    ILI9341_WriteData(area->x1);\n    ILI9341_WriteData(area->x2);\n\n    ILI9341_WriteReg(ILI9341_CMD_SET_PAGE_ADDRESS);\n    ILI9341_WriteData(area->y1);\n    ILI9341_WriteData(area->y2);\n\n    // Iterate through each pixel in the area\n    for (y = area->y1; y <= area->y2; y++) {\n        for (x = area->x1; x <= area->x2; x++) {\n            // Get the color for the current pixel\n            lv_color_t color = color_p[y * width + x];\n\n            // Convert the color to RGB565 format\n            uint16_t rgb565 = ((color.red & 0xF8) << 8) | ((color.green & 0xFC) << 3) | ((color.blue & 0xF8) >> 3);\n\n            // Write the color to the display\n            ILI9341_WriteData(rgb565 >> 8);\n            ILI9341_WriteData(rgb565 & 0xFF);\n        }\n    }\n\n    // End write transaction\n    ILI9341_WriteReg(ILI9341_CMD_WRITE_MEMORY_END);\n\n    // Notify that the display flush is complete\n    lv_disp", "CodeBleu_score": 47.61298061409889}, {"code": "  void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)    lv_disp_flush_ready(disp);\n    uint32_t x, y;\n    uint32_t x_end = area->x2 + 1;\n    uint32_t y_end = area->y2 + 1;\n\n    // Start the write transaction\n    my_disp_write_start();\n\n    // Set the address window\n    my_disp_set_window(area->x1, area->y1, x_end, y_end);\n\n    // Iterate through each pixel in the area\n    for (y = area->y1; y < y_end; y++) {\n        for (x = area->x1; x < x_end; x++) {\n            // Write the color for the current pixel\n            my_disp_write_color(*color_p++);\n        }\n    }\n\n    // End the write transaction\n    my_disp_write_end();\n\n    // Notify that the display flush is complete\n    lv_disp_flush_done(disp);\n}\n", "CodeBleu_score": 47.301079929409866}]}
{"instance_id": "86c372c99d86", "generation_result": [{"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    for (int i = 0; i < menu->getMenuSize(); i++) {\n        for (int j = 0; j < layer; j++) {\n            cout << \"    \";\n        }\n        cout << menu->getMenuNode(i)->getName() << endl;\n    }\n    cout << endl;\n}\n", "CodeBleu_score": 51.87568422978117}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    for (int i = 0; i < menu->getMenuNodes().size(); i++) {\n        for (int j = 0; j < layer; j++) {\n            cout << \"  \";\n        }\n        cout << menu->getMenuNodes()[i]->getName() << endl;\n    }\n    cout << endl;\n}\n", "CodeBleu_score": 51.52194213394734}, {"code": "void MenuFunctions::showMenuList(Menu * menu, int layer)    for (auto node : menu->getNodes()) {\n        for (int i = 0; i < layer; i++) {\n            cout << \"  \";\n        }\n        cout << node->getName() << endl;\n    }\n    cout << endl;\n}\n", "CodeBleu_score": 43.99825127120972}]}
{"instance_id": "fa401d949f3c", "generation_result": [{"code": "int WiFiScan::generateSSIDs(int count)  int ssidCount = 0;\n  for (int i = 0; i < count; i++) {\n    String ssid = \"\";\n    for (int j = 0; j < 6; j++) {\n      ssid += char(rand() % 26 + 'a');\n    }\n    int channel = rand() % 13 + 1;\n    String mac = \"\";\n    for (int j = 0; j < 6; j++) {\n      mac += String(rand() % 256, HEX);\n      if (j < 5) {\n        mac += \":\";\n      }\n    }\n    ssidList.push_back(SSID(ssid, channel, mac));\n    Serial.println(ssid + \" \" + String(channel) + \" \" + mac);\n    ssidCount++;\n  }\n  return ssidCount;\n}\n", "CodeBleu_score": 42.60769042590503}, {"code": "int WiFiScan::generateSSIDs(int count)    int generatedCount = 0;\n    for (int i = 0; i < count; i++) {\n        String ssid = \"\";\n        for (int j = 0; j < 6; j++) {\n            ssid += (char) (random(0, 26) + 'A');\n        }\n        ssid += \" \" + String(i);\n        int channel = random(1, 14);\n        String mac = \"\";\n        for (int j = 0; j < 6; j++) {\n            mac += String(random(0, 16), HEX);\n            if (j < 5) {\n                mac += \":\";\n            }\n        }\n        WiFi.softAP(ssid.c_str(), NULL, channel, 0, 1);\n        WiFi.softAPmacAddress(mac);\n        Serial.print(\"Generated SSID: \");\n        Serial.print(ssid);\n        Serial.print(\" on channel \");\n        Serial.print(channel);\n        Serial.print(\" with MAC address \");\n        Serial.println(mac);\n        generatedCount++;\n    }\n    return generatedCount;\n}\n", "CodeBleu_score": 41.385794907071144}, {"code": "int WiFiScan::generateSSIDs(int count)  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int a = 0;\n  int b = 0;\n  int c = 0;\n  int d = 0;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int a = 0;\n  int b = 0;\n  int c = 0;\n  int d = 0;\n  int e = 0;\n  int f = 0;\n  int g = 0;\n  int h = 0;\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int a = 0;\n  int b = 0;\n  int c = 0;\n ", "CodeBleu_score": 25.279458342938426}]}
{"instance_id": "4a06857e3120", "generation_result": [{"code": "def create_topic(project_id, topic_name)\n    from google.cloud import pubsub_v1\n\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n\n    topic = publisher_client.create_topic(request={\"name\": topic_path})\n\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 58.49894371395572}, {"code": "def create_topic(project_id, topic_name)\n    from google.cloud import pubsub_v1\n\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n\n    topic = publisher_client.create_topic(request={\"name\": topic_path})\n\n    print(f\"Created topic: {topic.name}\")\n", "CodeBleu_score": 58.49894371395572}, {"code": "def create_topic(project_id, topic_name)\n    from google.cloud import pubsub_v1\n\n    publisher_client = pubsub_v1.PublisherClient()\n    topic_path = publisher_client.topic_path(project_id, topic_name)\n\n    topic = publisher_client.create_topic(request={\"name\": topic_path})\n\n    print(f\"Created topic: {topic.name}\")\n\n", "CodeBleu_score": 58.49894371395572}]}
{"instance_id": "0986206a5cb5", "generation_result": [{"code": "def create_jwt(project_id, private_key_file, algorithm)\n    from datetime import datetime, timedelta\n    from google.oauth2 import service_account\n    import jwt\n\n    # Set the issued time (iat) to the current UTC time\n    iat = datetime.utcnow()\n\n    # Set the expiration time (exp) to one hour later\n    exp = iat + timedelta(hours=1)\n\n    # Set the audience (aud) field to the provided GCP project ID\n    aud = project_id\n\n    # Read the private key from the specified file\n    with open(private_key_file, 'rb') as f:\n        private_key = f.read()\n\n    # Create the JWT payload\n    payload = {\n        'iat': iat,\n        'exp': exp,\n        'aud': aud\n    }\n\n    # Create the JWT using the specified algorithm\n    encoded_jwt = jwt.encode(payload, private_key, algorithm=algorithm)\n\n    # Return the encoded JWT\n    return encoded_jwt\n\n", "CodeBleu_score": 49.654482444637274}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n    from datetime import datetime, timedelta\n    from google.oauth2 import service_account\n\n    now = datetime.utcnow()\n    claims = {\n        'iss': service_account.Credentials.from_service_account_file(private_key_file).service_account_email,\n        'aud': project_id,\n        'iat': now,\n        'exp': now + timedelta(hours=1)\n    }\n\n    additional_headers = {\n        'kid': private_key_file.split('/')[-1].replace('.json', '')\n    }\n\n    signed_jwt = service_account.Credentials.from_service_account_file(private_key_file).sign_jwt(claims, additional_headers=additional_headers, algorithm=algorithm)\n\n    return signed_jwt\n\n", "CodeBleu_score": 37.036553324247244}, {"code": "def create_jwt(project_id, private_key_file, algorithm)\n    from datetime import datetime, timedelta\n    from google.oauth2 import service_account\n    from google.auth.transport.requests import Request\n    from google.oauth2.credentials import Credentials\n    from google.auth.transport.requests import Request\n\n    # Set the issued time (iat) to the current UTC time\n    iat = datetime.utcnow()\n\n    # Set the expiration time (exp) to one hour later\n    exp = iat + timedelta(hours=1)\n\n    # Set the audience (aud) field to the provided GCP project ID\n    aud = project_id\n\n    # Read the private key from the specified file\n    with open(private_key_file, \"r\") as f:\n        private_key = f.read()\n\n    # Create the JWT using the specified algorithm\n    payload = {\n        \"iat\": iat,\n        \"exp\": exp,\n        \"aud\": aud\n    }\n    credentials = service_account.Credentials.from_service_account_info(\n        {\n            \"token_uri\": \"https://oauth2.googleapis.com/token\",\n            \"private_key\": private_key,\n            \"client_email\": \"<your-client-email>\",\n            \"project_id\": project_id\n        },\n        scopes=[\"https://www.googleapis.com/auth/cloud-platform\"],\n    )\n    credentials.refresh(Request())\n    jwt = credentials.token\n\n    return jwt", "CodeBleu_score": 41.81535421036094}]}
{"instance_id": "9ae28498f034", "generation_result": [{"code": "def on_message(unused_client, unused_userdata, message)\n    print(\"Received message from topic:\", message.topic)\n    print(\"QoS:\", message.qos)\n    print(\"Payload:\", message.payload.decode(\"utf-8\"))\n    if message.payload.decode(\"utf-8\") == \"on\":\n        # Capture a preview image and upload it to a specified bucket\n        import cv2\n        import boto3\n        import os\n        import paho.mqtt.client as mqtt\n        import uuid\n        import time\n        import json\n        import base64\n        import numpy as np\n        import io\n        import time\n        import datetime\n        import pytz\n        import paho.mqtt.client as mqtt\n        import os\n        import json\n        import base64\n        import cv2\n        import numpy as np\n        import io\n        import time\n        import datetime\n        import pytz\n        import paho.mqtt.client as mqtt\n        import os\n        import json\n        import base64\n        import cv2\n        import numpy as np\n        import io\n        import time\n        import datetime\n        import pytz\n        import paho.mqtt.client as mqtt\n        import os\n        import json\n        import base64\n        import cv2\n        import numpy as np\n        import io\n        import time\n        import datetime\n        import pytz\n        import paho.mqtt.client as mqtt\n        import os\n        import json\n        import base64\n        import cv2\n        import numpy as np\n        import io\n        import time\n        import datetime\n        import pytz\n        import paho.mqtt.client as mqtt\n        import os\n        import json\n        import base64\n        import cv2\n        import numpy as np\n        import io\n        import time\n        import datetime\n        import pytz\n        import paho.mqtt.client as mqtt\n        import os\n        import json\n        import base64\n        import cv2\n        import numpy as np\n        import io\n        import time\n        import datetime\n        import pytz\n        import", "CodeBleu_score": 23.313307230844092}, {"code": "def on_message(unused_client, unused_userdata, message)\n    print(\"Received message from topic: \", message.topic)\n    print(\"Message QoS: \", message.qos)\n    print(\"Message payload: \", message.payload.decode())\n    if message.payload.decode() == \"on\":\n        capture_preview_image()\n        upload_file_to_bucket()\n        publish_file_url()\n    elif message.payload.decode() == \"off\":\n        print(\"off\")\n", "CodeBleu_score": 21.86919743840447}, {"code": "def on_message(unused_client, unused_userdata, message)\n    print(\"Received message from topic: \", message.topic)\n    print(\"QoS: \", message.qos)\n    print(\"Payload: \", message.payload.decode())\n    if message.payload.decode() == \"on\":\n        # Capture a preview image\n        cap = cv2.VideoCapture(0)\n        ret, frame = cap.read()\n        if ret:\n            cv2.imwrite('preview.jpg', frame)\n            cap.release()\n            # Upload the file to a specified bucket\n            s3 = boto3.client('s3')\n            s3.upload_file('preview.jpg', 'my-bucket', 'preview.jpg')\n            # Publish the file's URL to an MQTT event topic\n            client.publish(\"my-topic\", \"https://my-bucket.s3.amazonaws.com/preview.jpg\")\n    else:\n        print(\"off\")\n", "CodeBleu_score": 36.20678072171246}]}
{"instance_id": "8a50b742d703", "generation_result": [{"code": "def parse_command_line_args()\n    import argparse\n    import os\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection code.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name.')\n    parser.add_argument(\n        '--subscription_name',\n        required=True,\n        help='Cloud Pub/Sub subscription name.')\n    parser.add_argument(\n        '--algorithm',\n        default='RS256',\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='GCP cloud region')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help='CA root from https://pki.google.com/roots.pem')\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to retrieve.')\n    parser.add_argument(\n        '--registry_id',\n        default='home-iot-registry',\n        help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--device_id',\n        default='home-iot-device',\n        help='Cloud IoT Core device id')\n    parser.add_argument(\n        '--private_key_file',\n        default='rsa_private.pem',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--client_email',\n        default='home-iot-device@home-iot-project.iam.gserviceaccount.com',\n        help='Service account email associated with the device.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n        default=20,\n        type=int,\n       ", "CodeBleu_score": 64.8689952185656}, {"code": "def parse_command_line_args()\n    import argparse\n    import os\n    parser = argparse.ArgumentParser(description='Google Cloud IoT MQTT device connection code.')\n    parser.add_argument('--project_id', required=False, default=os.environ.get('GOOGLE_CLOUD_PROJECT'), help='GCP cloud project name')\n    parser.add_argument('--subscription_name', required=True, help='Cloud Pub/Sub subscription name')\n    parser.add_argument('--registry_id', required=True, help='Cloud IoT registry id')\n    parser.add_argument('--device_id', required=True, help='Cloud IoT device id')\n    parser.add_argument('--private_key_file', required=True, help='Path to private key file.')\n    parser.add_argument('--algorithm', choices=('RS256', 'ES256'), required=True, help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument('--ca_certs', required=True, help='Path to root CA certificate.')\n    parser.add_argument('--cloud_region', default='us-central1', help='GCP cloud region')\n    parser.add_argument('--num_messages', type=int, default=100, help='Number of messages to receive')\n    parser.add_argument('--qos', choices=('0', '1', '2'), default='0', help='Cloud Pub/Sub subscription QoS (0, 1, or 2)')\n    parser.add_argument('--use_jwt', default=False, action='store_true', help='Use JWT (signed JWT and specified algorithm) instead of using OAuth2.0 token for authentication.')\n    args = parser.parse_args()\n    return args", "CodeBleu_score": 58.825517575085996}, {"code": "def parse_command_line_args()\n    import argparse\n    import os\n    parser = argparse.ArgumentParser(\n        description='Example Google Cloud IoT MQTT device connection code.')\n    parser.add_argument(\n        '--project_id',\n        default=os.environ.get('GOOGLE_CLOUD_PROJECT'),\n        required=True,\n        help='GCP cloud project name')\n    parser.add_argument(\n        '--subscription',\n        default='cloud-iot-core-sub',\n        required=True,\n        help='Cloud IoT Core subscription')\n    parser.add_argument(\n        '--algorithm',\n        choices=('RS256', 'ES256'),\n        required=True,\n        help='Which encryption algorithm to use to generate the JWT.')\n    parser.add_argument(\n        '--ca_certs',\n        default='roots.pem',\n        help=('CA root from https://pki.google.com/roots.pem'))\n    parser.add_argument(\n        '--num_messages',\n        type=int,\n        default=100,\n        help='Number of messages to receive')\n    parser.add_argument(\n        '--cloud_region',\n        default='us-central1',\n        help='GCP cloud region')\n    parser.add_argument(\n        '--registry_id',\n        default='my-registry',\n        help='Cloud IoT Core registry id')\n    parser.add_argument(\n        '--device_id',\n        default='my-device',\n        help='Cloud IoT Core device id')\n    parser.add_argument(\n        '--private_key_file',\n        default='rsa_private.pem',\n        help='Path to private key file.')\n    parser.add_argument(\n        '--client_email',\n        default='cloud-iot@PROJECT_ID.iam.gserviceaccount.com',\n        help='Service account email associated with the device.')\n    parser.add_argument(\n        '--jwt_expires_minutes',\n", "CodeBleu_score": 63.383049318060195}]}
{"instance_id": "f1fedfdf8267", "generation_result": [{"code": "def get_client(service_account_json)\n    import google.auth\n    from googleapiclient import discovery\n    from oauth2client.service_account import ServiceAccountCredentials\n    import httplib2\n\n    # The scope for the OAuth2 request.\n    scope = 'https://www.googleapis.com/auth/cloud-platform'\n    # The URL to which to connect for the OAuth2.0 device flow.\n    device_url = 'https://cloudiotdevice.googleapis.com/v1/projects/{}/locations/{}/registries/{}/devices/{}'.format(\n        service_account_json['project_id'], service_account_json['cloud_region'], service_account_json['registry_id'], service_account_json['device_id'])\n    # The URL to which to connect for the OAuth2.0 service flow.\n    service_url = 'https://cloudiot.googleapis.com/v1/projects/{}/locations/{}/registries/{}'.format(\n        service_account_json['project_id'], service_account_json['cloud_region'], service_account_json['registry_id'])\n    # The API version to use for the device service.\n    api_version = 'v1'\n    # The API discovery URL to use for the device service.\n    discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest?version={}'.format(\n        api_version)\n    # The list of API scopes to be included in the OAuth2.0 request.\n    # This is used to identify the permissions that the application\n    # requests from the user.\n    scopes = [scope]\n\n    # Create the OAuth2.0 credentials for the device and service accounts.\n    credentials = ServiceAccountCredentials.from_json_keyfile_name(\n        service_account_json['private_key_file'], scopes=scopes)\n    # Build the service object for interacting with the Cloud IoT Core service,\n    # which includes the device and service accounts.\n    service = discovery.build(\n        'cloudiot',\n        api_version,\n        credentials=credentials,\n        discoveryServiceUrl=discovery_url,\n        http=htt", "CodeBleu_score": 38.48905185514416}, {"code": "def get_client(service_account_json)\n    import googleapiclient.discovery\n    import google.auth\n\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    discovery_api = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    credentials, project_id = google.auth.default(scopes=api_scopes)\n    client = googleapiclient.discovery.build(\n        'cloudiot',\n        api_version,\n        credentials=credentials,\n        discoveryServiceUrl=discovery_api,\n        cache_discovery=False)\n\n    return client\n\n", "CodeBleu_score": 53.791087328462254}, {"code": "def get_client(service_account_json)\n    import google.auth\n    from google.oauth2 import service_account\n    from googleapiclient import discovery\n\n    # Define the necessary API scopes, version, and discovery URL\n    api_scopes = ['https://www.googleapis.com/auth/cloud-platform']\n    api_version = 'v1'\n    api_discovery_url = 'https://cloudiot.googleapis.com/$discovery/rest'\n\n    # Load the service account credentials\n    credentials = service_account.Credentials.from_service_account_file(service_account_json)\n\n    # Scope the credentials appropriately\n    scoped_credentials = credentials.with_scopes(api_scopes)\n\n    # Build the client for the Cloud IoT Core service using the discovery API URL\n    client = discovery.build(\n        'cloudiot',\n        api_version,\n        credentials=scoped_credentials,\n        discoveryServiceUrl=api_discovery_url,\n    )\n\n    return client\n\n", "CodeBleu_score": 64.18020640747922}]}
{"instance_id": "bfd7b4fdff6a", "generation_result": [{"code": "def sign_hash(hash_value, priv_key, hash_method)\n    # Retrieve the ASN1 code for the hash method\n    if hash_method == 'sha256':\n        asn1_code = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n    elif hash_method == 'sha384':\n        asn1_code = b'\\x30\\x41\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x02\\x05\\x00\\x04\\x30'\n    elif hash_method == 'sha512':\n        asn1_code = b'\\x30\\x51\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x03\\x05\\x00\\x04\\x40'\n    else:\n        raise ValueError('Invalid hash method')\n\n    # Concatenate the ASN1 code with the hash value\n    hash_value_with_code = asn1_code + hash_value\n\n    # Pad the result for signing\n    padded_hash_value = hash_value_with_code + b'\\x00' * (len(hash_value_with_code) % 16)\n\n    # Encrypt the padded hash using the private key\n    encrypted_signature = priv_key.encrypt(padded_hash_value)\n\n    return encrypted_signature\n", "CodeBleu_score": 29.344315014077395}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    from cryptography.hazmat.primitives import hashes\n    from cryptography.hazmat.primitives.asymmetric import padding\n    from cryptography.hazmat.primitives.asymmetric import utils\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.serialization import load_pem_private_key\n    from cryptography.hazmat.primitives.serialization import Encoding\n    from cryptography.hazmat.primitives.serialization import NoEncryption\n    from cryptography.hazmat.primitives.serialization import PrivateFormat\n    from cryptography.exceptions import InvalidSignature\n    from cryptography.hazmat.primitives.asymmetric import ec\n    from cryptography.hazmat.primitives.asymmetric import ed25519\n    from cryptography.hazmat.primitives.asymmetric import ed448\n    from cryptography.hazmat.primitives.asymmetric import x25519\n    from cryptography.hazmat.primitives.asymmetric import x448\n    from cryptography.hazmat.primitives.asymmetric import dsa\n    from cryptography.hazmat.primitives.asymmetric import dh\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n    from cryptography.hazmat.primitives.asymmetric import rsa\n   ", "CodeBleu_score": 7.222070322577945}, {"code": "def sign_hash(hash_value, priv_key, hash_method)\n    from Crypto.Hash import SHA1, SHA224, SHA256, SHA384, SHA512\n    from Crypto.Signature import PKCS1_v1_5\n    from Crypto.PublicKey import RSA\n    from Crypto.Util.asn1 import DerSequence\n    from Crypto.Util.number import bytes_to_long\n\n    if hash_method == \"sha1\":\n        hash_obj = SHA1.new(hash_value)\n        hash_code = hash_obj.digest()\n        asn1_code = DerSequence([DerSequence([DerSequence([DerSequence([]), DerSequence([])])]), DerSequence([DerSequence([DerSequence([]), DerSequence([])])])])\n    elif hash_method == \"sha224\":\n        hash_obj = SHA224.new(hash_value)\n        hash_code = hash_obj.digest()\n        asn1_code = DerSequence([DerSequence([DerSequence([DerSequence([]), DerSequence([])])]), DerSequence([DerSequence([DerSequence([]), DerSequence([])])])])\n    elif hash_method == \"sha256\":\n        hash_obj = SHA256.new(hash_value)\n        hash_code = hash_obj.digest()\n        asn1_code = DerSequence([DerSequence([DerSequence([DerSequence([]), DerSequence([])])]), DerSequence([DerSequence([DerSequence([]), DerSequence([])])])])\n    elif hash_method == \"sha384\":\n        hash_obj = SHA384.new(hash_value)\n        hash_code = hash_obj.digest()\n        asn1_code = DerSequence([DerSequence([DerSequence([DerSequence([]), DerSequence([])])]), DerSequence([DerSequence([DerSequence([]), DerSequence([])])])])\n    elif hash_method == \"sha512\":\n        hash_obj = SHA512.new(hash_value)\n        hash_code = hash_obj.digest()\n        as", "CodeBleu_score": 29.812558663569266}]}
{"instance_id": "70487729fb7a", "generation_result": [{"code": "def verify(message, signature, pub_key)\n    from Crypto.Hash import SHA256\n    from Crypto.Hash import SHA384\n    from Crypto.Hash import SHA512\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_384\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import BLAKE2b\n    from Crypto.Hash import BLAKE2s\n    from Crypto.Hash import MD5\n    from Crypto.Hash import SHA1\n    from Crypto.Hash import RIPEMD\n    from Crypto.Hash import SHA224\n    from Crypto.Hash import SHA3_224\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_384\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import BLAKE2b\n    from Crypto.Hash import BLAKE2s\n    from Crypto.Hash import MD5\n    from Crypto.Hash import SHA1\n    from Crypto.Hash import RIPEMD\n    from Crypto.Hash import SHA224\n    from Crypto.Hash import SHA3_224\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_384\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import BLAKE2b\n    from Crypto.Hash import BLAKE2s\n    from Crypto.Hash import MD5\n    from Crypto.Hash import SHA1\n    from Crypto.Hash import RIPEMD\n    from Crypto.Hash import SHA224\n    from Crypto.Hash import SHA3_224\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_384\n    from Crypto.Hash import SHA3", "CodeBleu_score": 8.083972656765834}, {"code": "def verify(message, signature, pub_key)\n    from cryptography.exceptions import InvalidSignature\n    from cryptography.hazmat.primitives.asymmetric import ec\n    from cryptography.hazmat.primitives.asymmetric.utils import (\n        decode_dss_signature,\n    )\n    from cryptography.hazmat.primitives import hashes\n    from cryptography.hazmat.primitives.serialization import (\n        load_pem_public_key,\n    )\n    from cryptography.hazmat.primitives.asymmetric import padding\n    from cryptography.exceptions import UnsupportedAlgorithm\n\n    try:\n        # Convert the signature to an integer\n        r, s = decode_dss_signature(signature)\n        # Decrypt the signature to obtain the clear signature\n        clear_signature = ec.ECDSA(hashes.SHA256()).signer(\n            pub_key, ec.ECDSA(hashes.SHA256())\n        ).verify(signature, message)\n        # Determine the hash method used\n        hash_method = hashes.SHA256()\n        # Compute the hash of the message\n        message_hash = hash_method.hash(message)\n        # Reconstruct the expected padded hash\n        expected_padded_hash = hash_method.bind()\n        expected_padded_hash.update(message)\n        expected_padded_hash = expected_padded_hash.finalize()\n        # Check if the expected padded hash matches the clear signature\n        if expected_padded_hash == clear_signature:\n            return \"SHA256\"\n        else:\n            raise InvalidSignature\n    except UnsupportedAlgorithm:\n        return \"SHA384\"\n    except InvalidSignature:\n        return \"SHA512\"\n\n", "CodeBleu_score": 33.546197270032394}, {"code": "def verify(message, signature, pub_key)\n    from Crypto.Hash import SHA256\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import SHA512\n    from Crypto.Hash import keccak\n    from Crypto.Hash import BLAKE2s\n    from Crypto.Hash import BLAKE2b\n    from Crypto.Hash import BLAKE2bp\n    from Crypto.Hash import RIPEMD\n    from Crypto.Hash import SHA3_384\n    from Crypto.Hash import SHA3_224\n    from Crypto.Hash import SHAKE128\n    from Crypto.Hash import SHAKE256\n    from Crypto.Hash import SHAKE128\n    from Crypto.Hash import SHAKE256\n    from Crypto.Hash import SHA3_224\n    from Crypto.Hash import SHA3_384\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA224\n    from Crypto.Hash import SHA512_224\n    from Crypto.Hash import SHA512_256\n    from Crypto.Hash import SHA384\n    from Crypto.Hash import SHA256\n    from Crypto.Hash import SHA512\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import SHA3_256\n    from Crypto.Hash import SHA3_512\n    from Crypto.Hash import", "CodeBleu_score": 7.484663514211006}]}
{"instance_id": "e64d5c267dd4", "generation_result": [{"code": "static void connectMQTT()  // Get current time\n  struct tm *tm;\n  time_t t;\n  time(&t);\n  tm = localtime(&t);\n\n  // Update JWT\n  if (tm != NULL) {\n    char *jwt = generateJWT(tm);\n    if (jwt != NULL) {\n      // Set JWT\n      if (mqttClient.setJWT(jwt) != 0) {\n        log_e(\"Error setting JWT\");\n      }\n    }\n  }\n\n  // Connect to MQTT client\n  if (mqttClient.connect() != 0) {\n    log_e(\"MQTT connection failed\");\n  }\n\n  // Set flag to send SUBSCRIBE packet after connection is established\n  mqttClient.setSubscribeFlag();\n\n  // Print debug message\n  log_d(\"MQTT connection attempt\");\n}\n", "CodeBleu_score": 40.61280927433014}, {"code": "static void connectMQTT()  time_t now = time(NULL);\n  if (now > 0) {\n    char time_str[32];\n    strftime(time_str, sizeof(time_str), \"%Y-%m-%dT%H:%M:%SZ\", gmtime(&now));\n    char jwt[512];\n    snprintf(jwt, sizeof(jwt), \"{\\\"iat\\\":%s,\\\"exp\\\":%s}\", time_str, time_str);\n    updateJWT(jwt);\n  }\n  mqtt_client_connect(mqtt_client);\n  mqtt_client_set_connected_handler(mqtt_client, mqtt_client_connected);\n  mqtt_client_set_disconnected_handler(mqtt_client, mqtt_client_disconnected);\n  mqtt_client_set_publish_handler(mqtt_client, mqtt_client_publish);\n  mqtt_client_set_subscribe_handler(mqtt_client, mqtt_client_subscribe);\n  mqtt_client_set_unsubscribe_handler(mqtt_client, mqtt_client_unsubscribe);\n  mqtt_client_set_message_handler(mqtt_client, mqtt_client_message);\n  mqtt_client_set_log_handler(mqtt_client, mqtt_client_log);\n  mqtt_client_set_error_handler(mqtt_client, mqtt_client_error);\n  mqtt_client_set_connected_handler(mqtt_client, mqtt_client_connected);\n  mqtt_client_set_disconnected_handler(mqtt_client, mqtt_client_disconnected);\n  mqtt_client_set_publish_handler(mqtt_client, mqtt_client_publish);\n  mqtt_client_set_subscribe_handler(mqtt_client, mqtt_client_subscribe);\n  mqtt_client_set_unsubscribe_handler(mqtt_", "CodeBleu_score": 36.36362261359151}, {"code": "static void connectMQTT()    time_t now;\n    struct tm timeinfo;\n    if (!getLocalTime(&timeinfo)) {\n        Serial.println(\"Failed to obtain time\");\n        return;\n    }\n    now = mktime(&timeinfo);\n    if (now > 0) {\n        updateJWT(now);\n        mqttClient.connect();\n        mqttClient.setWill(mqttTopic, 1, true, \"offline\");\n        mqttClient.setCallback(mqttCallback);\n        mqttSubscribe = true;\n    }\n    Serial.println(\"MQTT: Attempting to connect...\");\n}\n", "CodeBleu_score": 42.86120851610874}]}
{"instance_id": "999f49cc1296", "generation_result": [{"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t result = 0;\n    int i;\n    for (i = 0; i < width; i++) {\n        if (str[i] < '0' || str[i] > '9') {\n            return str;\n        }\n        result = result * 10 + (str[i] - '0');\n        if (result > UINT32_MAX) {\n            return str;\n        }\n    }\n    *num = result;\n    return str + width;\n}\n", "CodeBleu_score": 25.768117517787342}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)  uint32_t val = 0;\n  int i;\n  for (i = 0; i < width; i++) {\n    if (str[i] < '0' || str[i] > '9') {\n      return str;\n    }\n    val = val * 10 + (str[i] - '0');\n  }\n  *num = val;\n  return str + i;\n}\n", "CodeBleu_score": 21.72665792925132}, {"code": "static const uint8_t* str_to_uint(const uint8_t* str, int width, uint32_t* num)    uint32_t val = 0;\n    while (width--) {\n        if (!isdigit(*str))\n            return str;\n        val = val * 10 + (*str++ - '0');\n    }\n    *num = val;\n    return str;\n}\n", "CodeBleu_score": 16.77133262420717}]}
{"instance_id": "a50e95e53b3a", "generation_result": [{"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)    atcacert_cert_t* cert = build_state->cert;\n    atcacert_cert_t* ca_cert = build_state->ca_cert;\n    atcacert_cert_t* issuer_cert = build_state->issuer_cert;\n    atcacert_cert_t* issuer_ca_cert = build_state->issuer_ca_cert;\n    atcacert_cert_t* intermediate_cert = build_state->intermediate_cert;\n    atcacert_cert_t* intermediate_ca_cert = build_state->intermediate_ca_cert;\n    atcacert_cert_t* root_cert = build_state->root_cert;\n    atcacert_cert_t* root_ca_cert = build_state->root_ca_cert;\n    atcacert_cert_t* intermediate_ca_cert_chain = build_state->intermediate_ca_cert_chain;\n    atcacert_cert_t* root_ca_cert_chain = build_state->root_ca_cert_chain;\n    atcacert_cert_t* intermediate_cert_chain = build_state->intermediate_cert_chain;\n    atcacert_cert_t* root_cert_chain = build_state->root_cert_chain;\n    atcacert_cert_t* intermediate_ca_cert_chain_2 = build_state->intermediate_ca_cert_chain_2;\n    atcacert_cert_t* root_ca_cert_chain_2 = build_state->root_ca_cert_chain_2;\n    atcacert_cert_t* intermediate_cert_chain_2 = build_state->intermediate_cert_chain_2;\n    atcacert_cert_t* root_cert_chain_2 = build_state->root_cert_chain_2;\n    atcacert_cert_t* intermediate_ca_cert_chain_3 = build_state->intermediate_ca_cert_chain_3;\n    atcacert_cert_t", "CodeBleu_score": 12.814844158422762}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)  int ret = ATCACERT_OK;\n  atcacert_cert_t* cert = &build_state->cert;\n  atcacert_cert_t* issuer = &build_state->issuer;\n  atcacert_cert_t* issuer_ca = &build_state->issuer_ca;\n  atcacert_cert_t* issuer_ca_ca = &build_state->issuer_ca_ca;\n  atcacert_cert_t* issuer_ca_ca_ca = &build_state->issuer_ca_ca_ca;\n  atcacert_cert_t* issuer_ca_ca_ca_ca = &build_state->issuer_ca_ca_ca_ca;\n  atcacert_cert_t* issuer_ca_ca_ca_ca_ca = &build_state->issuer_ca_ca_ca_ca_ca;\n  atcacert_cert_t* issuer_ca_ca_ca_ca_ca_ca = &build_state->issuer_ca_ca_ca_ca_ca_ca;\n  atcacert_cert_t* issuer_ca_ca_ca_ca_ca_ca_ca = &build_state->issuer_ca_ca_ca_ca_ca_ca_ca;\n  atcacert_cert_t* issuer_ca_ca_ca_ca_ca_ca_ca_ca = &build_state->issuer_ca_ca_ca_ca_ca_ca_ca_ca;\n  atcacert_cert_t* issuer_ca_ca_ca_ca_ca_ca_ca_ca_ca = &build_state->issuer_ca_ca_ca_ca_ca_ca_ca_ca_ca;\n  atcacert_cert_t* issuer_ca_ca_ca_ca_ca_ca_ca_ca_ca_ca = &build_state->issuer_ca_ca_ca_ca_ca_ca_ca_ca_ca_ca;\n  atcacert_", "CodeBleu_score": 14.18552497965761}, {"code": "int atcacert_cert_build_finish(atcacert_build_state_t* build_state)  int ret = 0;\n  atcacert_cert_t* cert = &build_state->cert;\n  atcacert_cert_t* ca_cert = &build_state->ca_cert;\n  atcacert_cert_t* issuer_cert = &build_state->issuer_cert;\n  atcacert_cert_t* subject_cert = &build_state->subject_cert;\n  atcacert_cert_t* intermediate_cert = &build_state->intermediate_cert;\n  atcacert_cert_t* intermediate2_cert = &build_state->intermediate2_cert;\n  atcacert_cert_t* intermediate3_cert = &build_state->intermediate3_cert;\n  atcacert_cert_t* intermediate4_cert = &build_state->intermediate4_cert;\n  atcacert_cert_t* intermediate5_cert = &build_state->intermediate5_cert;\n  atcacert_cert_t* intermediate6_cert = &build_state->intermediate6_cert;\n  atcacert_cert_t* intermediate7_cert = &build_state->intermediate7_cert;\n  atcacert_cert_t* intermediate8_cert = &build_state->intermediate8_cert;\n  atcacert_cert_t* intermediate9_cert = &build_state->intermediate9_cert;\n  atcacert_cert_t* intermediate10_cert = &build_state->intermediate10_cert;\n  atcacert_cert_t* intermediate11_cert = &build_state->intermediate11_cert;\n  atcacert_cert_t* intermediate12_cert = &build_state->intermediate12_cert;\n  atcacert_cert_t* intermediate13_cert = &build_state->intermediate13_cert;\n  atcacert_cert_t* intermediate14_cert = &build_state->intermediate14_cert;\n  atcacert_cert", "CodeBleu_score": 14.097172456768265}]}
{"instance_id": "b8549b57b762", "generation_result": [{"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])  if (!cert_def || !cert || !ca_public_key) {\n    return ATCACERT_ERROR_BAD_PARAM;\n  }\n\n  // Retrieve the digest of the certificate's to-be-signed (TBS) portion\n  uint8_t tbs_digest[32];\n  if (atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest) != ATCACERT_SUCCESS) {\n    return ATCACERT_ERROR_BAD_PARAM;\n  }\n\n  // Retrieve the certificate's signature\n  uint8_t signature[64];\n  if (atcacert_get_signature(cert_def, cert, cert_size, signature) != ATCACERT_SUCCESS) {\n    return ATCACERT_ERROR_BAD_PARAM;\n  }\n\n  // Verify the TBS digest against the signature using the CA public key\n  int result = atcacert_verify_signature(ca_public_key, tbs_digest, signature);\n\n  return result;\n}", "CodeBleu_score": 40.346310953460495}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_ERR_INVALID_PARAMETER;\n    }\n\n    uint8_t tbs_digest[32];\n    uint8_t signature[64];\n\n    atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    atcacert_get_signature(cert_def, cert, cert_size, signature);\n\n    int result = atcab_verify_cert_hw(tbs_digest, signature, ca_public_key);\n    if (result == ATCA_SUCCESS) {\n        return ATCACERT_SUCCESS;\n    } else {\n        return ATCACERT_ERR_VERIFICATION_FAILED;\n    }\n}", "CodeBleu_score": 50.93451453528124}, {"code": "int atcacert_verify_cert_hw(const atcacert_def_t* cert_def,\n                            const uint8_t*        cert,\n                            size_t                cert_size,\n                            const uint8_t         ca_public_key[64])    if (cert_def == NULL || cert == NULL || ca_public_key == NULL) {\n        return ATCACERT_ERROR_INVALID_PARAMETER;\n    }\n\n    uint8_t tbs_digest[32];\n    int     ret = atcacert_get_tbs_digest(cert_def, cert, cert_size, tbs_digest);\n    if (ret != ATCACERT_SUCCESS) {\n        return ret;\n    }\n\n    uint8_t signature[64];\n    ret = atcacert_get_signature(cert_def, cert, cert_size, signature);\n    if (ret != ATCACERT_SUCCESS) {\n        return ret;\n    }\n\n    int result = atcacert_verify_signature_hw(tbs_digest, signature, ca_public_key);\n    if (result != ATCACERT_SUCCESS) {\n        return ATCACERT_ERROR_VERIFICATION_FAILED;\n    }\n\n    return ATCACERT_SUCCESS;\n}", "CodeBleu_score": 64.49876432468966}]}
{"instance_id": "55aabdebc164", "generation_result": [{"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{    timerStruct_t * volatile *next = &list;\n    while (*next)\n    {\n        if (*next == timer)\n        {\n            *next = timer->next;\n            return true;\n        }\n        next = &(*next)->next;\n    }\n    return false;\n}\n}", "CodeBleu_score": 19.31326342187742}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{    timerStruct_t * volatile *prev = list;\n    timerStruct_t * volatile *curr = *prev;\n    while (curr != NULL) {\n        if (curr == timer) {\n            *prev = *curr;\n            return true;\n        }\n        prev = curr;\n        curr = *curr;\n    }\n    return false;\n}\n", "CodeBleu_score": 24.264606940506532}, {"code": "bool __attribute__((optimize(0))) timeout_deleteHelper(timerStruct_t * volatile *list, timerStruct_t *timer)\n{    timerStruct_t *prev = NULL;\n    timerStruct_t *curr = *list;\n    while (curr != NULL && curr != timer) {\n        prev = curr;\n        curr = curr->next;\n    }\n    if (curr == NULL) {\n        return false;\n    }\n    if (prev == NULL) {\n        *list = curr->next;\n    } else {\n        prev->next = curr->next;\n    }\n    free(curr);\n    return true;\n}\n}\n", "CodeBleu_score": 31.309851453276057}]}
{"instance_id": "4ce116b8459c", "generation_result": [{"code": "int BSD_close(int socket)    // Get the socket information\n    struct socket_info *sock_info = &sockets[socket];\n\n    // Check if the socket exists\n    if (sock_info->state != SOCKET_OPEN) {\n        errno = EBADF;\n        return BSD_ERROR;\n    }\n\n    // Set the socket state to \"NOT_A_SOCKET\"\n    sock_info->state = NOT_A_SOCKET;\n\n    // Call the close function\n    int ret = close(socket);\n\n    // Check for errors\n    if (ret < 0) {\n        // Set the appropriate error number based on the error type\n        if (errno == EBADF) {\n            errno = EBADF;\n        } else if (errno == EINVAL) {\n            errno = EINVAL;\n        } else if (errno == EIO) {\n            errno = EIO;\n        } else {\n            errno = EIO;\n        }\n\n        // Return \"BSD_ERROR\"\n        return BSD_ERROR;\n    }\n\n    // Return \"BSD_SUCCESS\"\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 46.71117423323507}, {"code": "int BSD_close(int socket)    struct socket_info *sock_info = get_socket_info(socket);\n    if (sock_info == NULL) {\n        return BSD_ERROR;\n    }\n    sock_info->state = NOT_A_SOCKET;\n    int ret = close(socket);\n    if (ret == -1) {\n        if (errno == EBADF) {\n            errno = ENOTSOCK;\n        }\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 35.281800457225785}, {"code": "int BSD_close(int socket)    if (socket < 0 || socket >= MAX_SOCKETS) {\n        return BSD_ERROR;\n    }\n\n    if (sockets[socket].state == NOT_A_SOCKET) {\n        return BSD_ERROR;\n    }\n\n    sockets[socket].state = NOT_A_SOCKET;\n\n    int ret = close(sockets[socket].socket);\n    if (ret < 0) {\n        if (errno == EBADF) {\n            errno = ENOTSOCK;\n        }\n        return BSD_ERROR;\n    }\n\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 40.70623387784259}]}
{"instance_id": "f7f432a3cd7b", "generation_result": [{"code": "int BSD_listen(int socket, int backlog)  int response;\n  response = listen(socket, backlog);\n  if (response == -1) {\n    BSD_set_error(BSD_ERROR_LISTEN);\n    return BSD_ERROR;\n  }\n  return BSD_SUCCESS;\n}", "CodeBleu_score": 17.654199231595964}, {"code": "int BSD_listen(int socket, int backlog)    int response = listen(socket, backlog);\n    if (response == -1) {\n        BSD_set_error_number(BSD_ERROR_LISTEN);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}", "CodeBleu_score": 18.08960374858171}, {"code": "int BSD_listen(int socket, int backlog)    int response = listen(socket, backlog);\n    if (response == -1) {\n        BSD_set_error(BSD_ERROR_LISTEN);\n        return BSD_ERROR;\n    }\n    return BSD_SUCCESS;\n}\n", "CodeBleu_score": 17.839096107788933}]}
{"instance_id": "e816de0747b8", "generation_result": [{"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)    struct sockaddr_storage storage;\n    socklen_t len = sizeof(storage);\n    int ret = accept(socket, (struct sockaddr *) &storage, &len);\n    if (ret < 0) {\n        switch (socket) {\n            case BSD_SOCKET_INET:\n                errno = EAFNOSUPPORT;\n                break;\n            case BSD_SOCKET_INET6:\n                errno = EAFNOSUPPORT;\n                break;\n            case BSD_SOCKET_UNIX:\n                errno = EAFNOSUPPORT;\n                break;\n            default:\n                errno = EINVAL;\n                break;\n        }\n        return -1;\n    }\n    if (addr != NULL) {\n        if (addrlen != NULL) {\n            *addrlen = len;\n        }\n        if (convert_sockaddr(storage, addr) != 0) {\n            errno = EINVAL;\n            return -1;\n        }\n    }\n    return ret;\n}", "CodeBleu_score": 35.45961009530172}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)  int ret;\n  struct sockaddr_storage addr_storage;\n  socklen_t addr_storage_len = sizeof(addr_storage);\n  struct sockaddr * addr_ptr = (struct sockaddr *) & addr_storage;\n  ret = accept(socket, addr_ptr, & addr_storage_len);\n  if (ret == - 1) {\n    if (errno == EAGAIN) {\n      errno = EWOULDBLOCK;\n    }\n    return - 1;\n  }\n  if (addr != NULL) {\n    switch (addr_storage.ss_family) {\n    case AF_INET:\n      addr -> family = AF_INET;\n      addr -> addr.ipv4 = ((struct sockaddr_in *) addr_ptr) -> sin_addr.s_addr;\n      addr -> port = ntohs(((struct sockaddr_in *) addr_ptr) -> sin_port);\n      break;\n    case AF_INET6:\n      addr -> family = AF_INET6;\n      memcpy(& addr -> addr.ipv6, & ((struct sockaddr_in6 *) addr_ptr) -> sin6_addr, sizeof(struct in6_addr));\n      addr -> port = ntohs(((struct sockaddr_in6 *) addr_ptr) -> sin6_port);\n      break;\n    default:\n      errno = EAFNOSUPPORT;\n      return - 1;\n    }\n  }\n  if (addrlen != NULL) {\n    * addrlen = addr_storage_len;\n  }\n  return ret;\n}", "CodeBleu_score": 42.65379291812288}, {"code": "int BSD_accept(int socket, struct bsd_sockaddr * addr, socklen_t * addrlen)    struct sockaddr_storage ss;\n    socklen_t len = sizeof(ss);\n    int rc = accept(socket, (struct sockaddr *)&ss, &len);\n    if (rc == -1) {\n        switch (socket) {\n            case BSD_SOCK_STREAM:\n                errno = ENOTSOCK;\n                break;\n            case BSD_SOCK_DGRAM:\n                errno = EPROTOTYPE;\n                break;\n            case BSD_SOCK_SEQPACKET:\n                errno = EOPNOTSUPP;\n                break;\n            case BSD_SOCK_RAW:\n                errno = EPROTONOSUPPORT;\n                break;\n            default:\n                errno = EINVAL;\n                break;\n        }\n        return -1;\n    }\n    if (addr != NULL && addrlen != NULL) {\n        if (len > *addrlen) {\n            errno = EINVAL;\n            return -1;\n        }\n        *addrlen = len;\n        switch (ss.ss_family) {\n            case AF_INET:\n                addr->family = BSD_AF_INET;\n                addr->addr.ipv4.sin_addr = ((struct sockaddr_in *)&ss)->sin_addr;\n                addr->addr.ipv4.sin_port = ((struct sockaddr_in *)&ss)->sin_port;\n                break;\n            case AF_INET6:\n                addr->family = BSD_AF_INET6;\n                addr->addr.ipv6.sin6_addr = ((struct sockaddr_in6 *)&ss)->sin6_addr;\n                addr->addr.ipv6.sin6_port = ((struct sockaddr_in6 *)&ss)->sin6_port;\n                break;\n            case AF_UNIX:\n                addr->family = BSD_AF_UNIX;\n                addr->addr.unix.sun_path = ((struct sockaddr_un *)&ss)->sun_path;\n                break;\n", "CodeBleu_score": 37.57212031662358}]}
{"instance_id": "96143957b80a", "generation_result": [{"code": "static void connectMQTT()  int time_offset = get_current_time_offset();\n  if (time_offset != -1) {\n    update_jwt_time_offset(time_offset);\n    if (mqtt_client_init(mqtt_client, mqtt_config) != ESP_OK) {\n      ESP_LOGE(TAG, \"MQTT client init failed\");\n    } else {\n      ESP_LOGI(TAG, \"MQTT client init success\");\n      mqtt_client_start(mqtt_client);\n      mqtt_subscribe_flag = true;\n    }\n  } else {\n    ESP_LOGE(TAG, \"Failed to get time offset\");\n  }\n}\n", "CodeBleu_score": 39.893247847904}, {"code": "static void connectMQTT()  time_t now = time(NULL);\n  if (now > 0) {\n    time_offset = now - time(NULL);\n    jwt_update_iat(jwt);\n    mqtt_init_connect(&mqtt, jwt, strlen(jwt), MQTT_HOST, MQTT_PORT, MQTT_KEEP_ALIVE, MQTT_CLEAN_SESSION, NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0);\n    debug_printf(\"MQTT connecting to %s:%d\\n\", MQTT_HOST, MQTT_PORT);\n    mqtt_set_send_subscribe(&mqtt, 1);\n  }\n}\n", "CodeBleu_score": 40.923215991710585}, {"code": "static void connectMQTT()  long now = millis();\n  if (now - lastReconnectAttempt > 5000) {\n    lastReconnectAttempt = now;\n\n    // Attempt to reconnect\n    if (mqttClient.connect(deviceName, deviceName, deviceName)) {\n      Serial.println(\"MQTT connected\");\n      mqttClient.publish(\"debug\", \"MQTT connected\");\n      mqttClient.subscribe(\"debug\");\n      mqttClient.subscribe(\"reboot\");\n      mqttClient.subscribe(\"reset\");\n      mqttClient.subscribe(\"settime\");\n      mqttClient.subscribe(\"settimezone\");\n      mqttClient.subscribe(\"setwifi\");\n      mqttClient.subscribe(\"setmqtt\");\n      mqttClient.subscribe(\"setntp\");\n      mqttClient.subscribe(\"setmqtt_user\");\n      mqttClient.subscribe(\"setmqtt_password\");\n      mqttClient.subscribe(\"setmqtt_server\");\n      mqttClient.subscribe(\"setmqtt_port\");\n      mqttClient.subscribe(\"setmqtt_client_id\");\n      mqttClient.subscribe(\"setmqtt_topic\");\n      mqttClient.subscribe(\"setmqtt_qos\");\n      mqttClient.subscribe(\"setmqtt_retain\");\n      mqttClient.subscribe(\"setmqtt_reconnect\");\n      mqttClient.subscribe(\"setmqtt_reconnect_delay\");\n      mqttClient.subscribe(\"setmqtt_reconnect_max_delay\");\n      mqttClient.subscribe(\"setmqtt_reconnect_backoff\");\n      mqttClient.subscribe(\"setmqtt_reconnect_backoff_delay\");\n      mqttClient.subscribe(\"setmqtt_reconnect_backoff_max_delay\");\n      mqttClient.subscribe(\"setmqtt_reconnect_backoff_factor\");\n      mqttClient.subscribe(\"setmqtt_reconnect_backoff_jitter\");\n      mqttClient.subscribe(\"setmqtt_reconnect_backoff_", "CodeBleu_score": 33.36966425051257}]}
{"instance_id": "0819d0a91a22", "generation_result": [{"code": "void CLOUD_disconnect(void)    if (MQTT_getConnectionState() == MQTT_CONNECTED) {\n        MQTT_disconnect();\n        LOG_debug(\"Disconnected from cloud service\");\n    }\n}\n", "CodeBleu_score": 54.969064267457036}, {"code": "void CLOUD_disconnect(void)  if (mqtt_client.state == MQTT_CONNECTED) {\n    CLOUD_log(LOG_LEVEL_DEBUG, \"Disconnecting from cloud service...\");\n    mqtt_client_get_connection_info(&mqtt_client, &client_info);\n    mqtt_client_disconnect(&mqtt_client);\n  }\n}\n", "CodeBleu_score": 39.301254989719816}, {"code": "void CLOUD_disconnect(void)\n  if (MQTT_get_connection_state() == MQTT_CONNECTED) {\n    MQTT_client_info_t client_info;\n    MQTT_get_client_info(&client_info);\n    LOG_debug(\"Disconnecting from cloud service: %s\", client_info.host_name);\n    MQTT_disconnect();\n  }\n}\n", "CodeBleu_score": 46.476750924892514}]}
{"instance_id": "c4cebfea2663", "generation_result": [{"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)    // Check if the WiFi credentials are valid\n    if (passed_wifi_creds == WIFI_CREDS_VALID) {\n        // Connect to the access point using the provided credentials\n        WiFi.begin(WIFI_SSID, WIFI_PASS);\n    } else {\n        // Connect to the access point using the default credentials\n        WiFi.begin();\n    }\n\n    // Wait for the connection to complete\n    uint8_t connection_status = WL_IDLE_STATUS;\n    while (connection_status != WL_CONNECTED) {\n        delay(500);\n        connection_status = WiFi.status();\n    }\n\n    // Check if the connection was successful\n    if (connection_status == WL_CONNECTED) {\n        // Update the networking error status\n        networking_error_status = NETWORKING_ERROR_NONE;\n        return true;\n    } else {\n        // Log an error message and update the networking error status\n        Serial.println(\"Error: Failed to connect to Wi-Fi access point\");\n        networking_error_status = NETWORKING_ERROR_WIFI_CONNECTION;\n        return false;\n    }\n}", "CodeBleu_score": 39.46597546644526}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  if (passed_wifi_creds == 1) {\n    // Use the default Wi-Fi settings\n    WiFi.begin();\n  } else {\n    // Use the specified SSID, authentication type, and password\n    WiFi.begin(ssid, authType, password);\n  }\n\n  // Wait for the Wi-Fi connection to be established\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(100);\n  }\n\n  // Check if the connection was successful\n  if (WiFi.status() == WL_CONNECTED) {\n    return true;\n  } else {\n    // Connection failed, log an error message and update the networking error status\n    Serial.println(\"Failed to connect to Wi-Fi\");\n    networking_error = 1;\n    return false;\n  }\n}\n", "CodeBleu_score": 44.06107512074578}, {"code": "bool wifi_connectToAp(uint8_t passed_wifi_creds)  // If passed_wifi_creds is 0, use default credentials\n  if (passed_wifi_creds == 0) {\n    // Connect to the default Wi-Fi network\n    WiFi.begin();\n    // Wait for the connection to complete\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(100);\n    }\n    // If the connection succeeded, return true\n    if (WiFi.status() == WL_CONNECTED) {\n      return true;\n    }\n    // If the connection failed, log an error message and update the networking error status\n    Serial.println(\"WiFi connection failed\");\n    networking_error_status = 1;\n    return false;\n  }\n  // If passed_wifi_creds is not 0, use the provided credentials\n  else {\n    // Connect to the Wi-Fi network using the provided SSID, authentication type, and password\n    WiFi.begin(wifi_ssid, wifi_auth_type, wifi_password);\n    // Wait for the connection to complete\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(100);\n    }\n    // If the connection succeeded, return true\n    if (WiFi.status() == WL_CONNECTED) {\n      return true;\n    }\n    // If the connection failed, log an error message and update the networking error status\n    Serial.println(\"WiFi connection failed\");\n    networking_error_status = 1;\n    return false;\n  }\n}\n", "CodeBleu_score": 36.06717662907693}]}
{"instance_id": "d94ebb9143a1", "generation_result": [{"code": "async function DisplaySensors(map)  // Create a new client\n  const client = new GraphQLClient(API_URL, {\n    headers: {\n      authorization: `Bearer ${API_KEY}`,\n    },\n  });\n\n  // Send a GraphQL query to fetch sensor data\n  const { data } = await client.request(`\n    query {\n      sensors {\n        id\n        name\n        location {\n          lat\n          lng\n        }\n      }\n    }\n  `);\n\n  // Log the API response\n  console.log(data);\n\n  // Log the retrieval of sensors\n  console.log(\"Retrieving sensors...\");\n\n  // Iterate through each sensor to create a marker\n  data.sensors.forEach((sensor) => {\n    // Create a new marker\n    const marker = new google.maps.Marker({\n      position: {\n        lat: sensor.location.lat,\n        lng: sensor.location.lng,\n      },\n      map,\n      title: sensor.name,\n    });\n\n    // Add a click listener to the marker\n    marker.addListener(\"click\", () => {\n      // Log the name of the clicked sensor\n      console.log(`Clicked on ${sensor.name}`);\n    });\n  });\n}\n", "CodeBleu_score": 35.92456677786034}, {"code": "async function DisplaySensors(map)  // Create a new client\n  const client = new GraphQLClient(\"https://api.graph.cool/simple/v1/cjw194b2l087n0195q1j77y01\");\n\n  // Send a GraphQL query to fetch sensor data\n  const query = `\n    query {\n      allSensors {\n        id\n        lat\n        long\n        name\n        type\n      }\n    }\n  `;\n\n  // Log the API response\n  const response = await client.request(query);\n  console.log(response);\n\n  // Log the retrieval of sensors\n  console.log(\"Retrieving sensors...\");\n\n  // Iterate through each sensor to create a marker\n  response.allSensors.forEach((sensor) => {\n    // Create a new marker\n    const marker = new google.maps.Marker({\n      position: { lat: sensor.lat, lng: sensor.long },\n      map: map,\n      title: sensor.name,\n    });\n\n    // Add a click listener to the marker\n    marker.addListener(\"click\", () => {\n      // Display the sensor's information in the info window\n      const infoWindow = new google.maps.InfoWindow({\n        content: `\n          <h3>${sensor.name}</h3>\n          <p>Type: ${sensor.type}</p>\n          <p>Latitude: ${sensor.lat}</p>\n          <p>Longitude: ${sensor.long}</p>\n        `,\n      });\n      infoWindow.open(map, marker);\n    });\n  });\n}\n", "CodeBleu_score": 38.283860097368496}, {"code": "async function DisplaySensors(map)    const client = new GraphQLClient(\"https://api.graphql.jobs/\", {\n        headers: {\n            authorization: \"Bearer \" + API_KEY,\n        },\n    });\n\n    const query = gql`\n        query {\n            sensors {\n                id\n                name\n                location {\n                    lat\n                    lon\n                }\n            }\n        }\n    `;\n\n    const response = await client.request(query);\n    console.log(response);\n    console.log(\"Retrieving sensors...\");\n\n    response.sensors.forEach((sensor) => {\n        const marker = new google.maps.Marker({\n            position: {\n                lat: sensor.location.lat,\n                lng: sensor.location.lon,\n            },\n            map: map,\n            title: sensor.name,\n        });\n    });\n}\n", "CodeBleu_score": 38.80428805899123}]}
{"instance_id": "c59402c8583d", "generation_result": [{"code": "const CreateSensorMarker = (sensor) =>    const sensorMarker = document.createElement('div');\n    sensorMarker.id = `sensor-marker-${sensor.id}`;\n    sensorMarker.className = 'sensor-marker';\n    sensorMarker.style.backgroundColor = '#007bff';\n    sensorMarker.style.border = '2px solid #007bff';\n    sensorMarker.style.borderRadius = '50%';\n    sensorMarker.style.height = '10px';\n    sensorMarker.style.width = '10px';\n    sensorMarker.style.position = 'absolute';\n    sensorMarker.style.top = '50%';\n    sensorMarker.style.left = '50%';\n    sensorMarker.style.transform = 'translate(-50%, -50%)';\n    return sensorMarker;\n};\n", "CodeBleu_score": 28.094982666263235}, {"code": "const CreateSensorMarker = (sensor) =>  const marker = document.createElement(\"div\");\n  marker.id = sensor.id;\n  marker.className = \"sensor-marker\";\n  marker.style.backgroundColor = \"#000000\";\n  marker.style.border = \"2px solid #000000\";\n  return marker;\n};\n", "CodeBleu_score": 33.52900874197224}, {"code": "const CreateSensorMarker = (sensor) =>  const marker = document.createElement('div');\n  marker.id = sensor.id;\n  marker.className = 'sensor-marker';\n  marker.style.backgroundColor = '#000000';\n  marker.style.border = '1px solid #000000';\n  return marker;\n};\n", "CodeBleu_score": 33.18302919366262}]}
{"instance_id": "b11889b4f484", "generation_result": [{"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"custom_components.{module_name}\"\n    try:\n        module = importlib.import_module(module_path)\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import MFA module %s: %s\", module_path, err)\n        raise\n    if hasattr(module, \"REQUIREMENTS\"):\n        if not skip_pip:\n            requirements = module.REQUIREMENTS\n            if not requirements_processed.get(module_name):\n                _LOGGER.info(\"Processing MFA module %s requirements\", module_name)\n                for requirement in requirements:\n                    _LOGGER.info(\"Installing requirement %s\", requirement)\n                    try:\n                        subprocess.check_call(\n                            [sys.executable, \"-m\", \"pip\", \"install\", requirement]\n                        )\n                    except subprocess.CalledProcessError as err:\n                        _LOGGER.error(\n                            \"Failed to install requirement %s: %s\", requirement, err\n                        )\n                        raise\n                requirements_processed[module_name] = True\n    return module\n\n", "CodeBleu_score": 40.03650937055466}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"custom_components.{module_name}\"\n    module = importlib.import_module(module_path)\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n    if module.REQUIREMENTS:\n        if module_name not in hass.data.get(\"custom_components\", {}):\n            hass.data[\"custom_components\"][module_name] = {}\n        if \"requirements\" in hass.data[\"custom_components\"][module_name]:\n            return module\n        hass.data[\"custom_components\"][module_name][\"requirements\"] = True\n        try:\n            if not hass.config.skip_pip:\n                await hass.hassio.install_addon_pip_requirements(\n                    module_name, module.REQUIREMENTS\n                )\n        except HomeAssistantError as err:\n            _LOGGER.error(\n                \"Error installing requirements for %s: %s\", module_name, err\n            )\n    return module\n\n", "CodeBleu_score": 38.15745627020813}, {"code": "async def _load_mfa_module(hass: HomeAssistant, module_name: str) -> types.ModuleType\n    module_path = f\"custom_components.{module_name}\"\n    module = importlib.import_module(module_path)\n    requirements = getattr(module, \"REQUIREMENTS\", [])\n    if requirements and not hass.config.skip_pip:\n        if module_name not in hass.data.get(\"custom_mfa_modules\", []):\n            hass.data[\"custom_mfa_modules\"].append(module_name)\n            for requirement in requirements:\n                if not await hass.helpers.pip_install.async_install(requirement, target=\"custom_components\"):\n                    raise ValueError(f\"Failed to install requirement {requirement} for module {module_name}\")\n    return module", "CodeBleu_score": 26.87415602773808}]}
{"instance_id": "06cb8df1ac97", "generation_result": [{"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data[CONF_PIN]\n    if user_id in self._data:\n        self._data[user_id] = pin\n        self._data.save()\n    else:\n        self._data[user_id] = pin\n        self._data.save()\n    return True\n\n", "CodeBleu_score": 33.132632745883825}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data.get(CONF_PIN)\n    if not pin:\n        raise InvalidAuth(\"PIN is required\")\n    if len(pin) != PIN_LENGTH:\n        raise InvalidAuth(f\"PIN must be {PIN_LENGTH} characters long\")\n\n    if self.data.get(user_id):\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n\n    self.async_write_ha_config()\n    return True\n\n", "CodeBleu_score": 33.99226227445307}, {"code": "async def async_setup_user(self, user_id: str, setup_data: Any) -> Any\n    pin = setup_data[\"pin\"]\n    if self.data.get(user_id):\n        self.data[user_id][\"pin\"] = pin\n    else:\n        self.data[user_id] = {\"pin\": pin}\n    return True", "CodeBleu_score": 37.061285289286076}]}
{"instance_id": "f1ff44afdbcc", "generation_result": [{"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._user_settings is None:\n            user_data = await self._user_store.async_load()\n            if user_data is None:\n                self._user_settings = {}\n            else:\n                self._user_settings = {\n                    user_id: NotifySetting(\n                        **{\n                            key: value\n                            for key, value in user_data[user_id].items()\n                            if key in NotifySetting.fields()\n                        }\n                    )\n                    for user_id in user_data\n                }\n\n", "CodeBleu_score": 37.16494042953909}, {"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._user_settings is None:\n            user_store = await self._user_store.async_load()\n            if not user_store:\n                user_store = {}\n            self._user_settings = {\n                user: NotifySetting(\n                    user,\n                    user_store.get(user, {}).get(\"enabled\", True),\n                    user_store.get(user, {}).get(\"title\", \"\"),\n                    user_store.get(user, {}).get(\"message\", \"\"),\n                    user_store.get(user, {}).get(\"data\", {}),\n                )\n                for user in self._users\n            }\n\n", "CodeBleu_score": 39.39299762967126}, {"code": "async def _async_load(self) -> None\n    async with self._init_lock:\n        if self._user_settings is not None:\n            return\n        self._user_settings = {}\n        user_store = self._user_store\n        if user_store is None:\n            return\n        data = await user_store.async_load()\n        if data is None:\n            return\n        for user_id, user_data in data.items():\n            self._user_settings[user_id] = NotifySetting(\n                user_id,\n                user_data.get(CONF_TITLE, DEFAULT_TITLE),\n                user_data.get(CONF_MESSAGE, DEFAULT_MESSAGE),\n                user_data.get(CONF_TARGET, DEFAULT_TARGET),\n            )\n\n", "CodeBleu_score": 38.446948750655665}]}
{"instance_id": "434ec0293b96", "generation_result": [{"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    # Load user settings\n    await self._async_load_user_settings(user_id)\n\n    # Retrieve notification settings for the user\n    settings = self._user_settings.get(user_id)\n    if not settings:\n        return False\n\n    # Validate the user input by verifying the OTP using an executor job\n    return await self._hass.async_add_executor_job(\n        self._validate_otp, user_id, user_input\n    )", "CodeBleu_score": 43.721735121518414}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    # Ensure user settings are loaded\n    await self.async_load_user_settings(user_id)\n\n    # Retrieve notification settings for the specified user\n    settings = self.user_settings.get(user_id)\n    if not settings:\n        return False\n\n    # Validate the user input by verifying the OTP using an executor job\n    return await self.hass.async_add_executor_job(self.verify_otp, settings, user_input[CONF_OTP])\n", "CodeBleu_score": 42.90784134582808}, {"code": "async def async_validate(self, user_id: str, user_input: dict[str, Any]) -> bool\n    if not await self.async_load_user_settings(user_id):\n        return False\n\n    settings = self.user_settings[user_id]\n    if not settings.get(CONF_NOTIFICATIONS):\n        return False\n\n    # Validate OTP\n    return await self.hass.async_add_executor_job(\n        self.validate_otp, settings[CONF_OTP], user_input[CONF_OTP]\n    )\n\n", "CodeBleu_score": 46.09596872403859}]}
{"instance_id": "551ba99a6968", "generation_result": [{"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity_entry = perm_lookup.entity_lookup.get(entity_id)\n    if not entity_entry:\n        return None\n\n    device_entry = perm_lookup.device_lookup.get(entity_entry.device_id)\n    if not device_entry:\n        return None\n\n    area_id = device_entry.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)", "CodeBleu_score": 57.09467606489742}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.entity_lookup.get(entity_id)\n    if not entity:\n        return None\n    device = perm_lookup.device_lookup.get(entity.device_id)\n    if not device:\n        return None\n    area_id = device.area_id\n    if not area_id:\n        return None\n    return area_dict.get(area_id)\n\n", "CodeBleu_score": 51.69904699933527}, {"code": "def _lookup_area(\n    perm_lookup: PermissionLookup, area_dict: SubCategoryDict, entity_id: str\n) -> ValueType | None\n    entity = perm_lookup.entities.get(entity_id)\n    if not entity:\n        return None\n\n    device = perm_lookup.devices.get(entity.device_id)\n    if not device:\n        return None\n\n    area_id = device.area_id\n    if not area_id:\n        return None\n\n    return area_dict.get(area_id)", "CodeBleu_score": 51.39876178007634}]}
{"instance_id": "8e394c61e20c", "generation_result": [{"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy = {}\n    seen_categories = set()\n\n    for policy in policies:\n        for category, categories in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = [\n                    category for policy in policies for category in policy.get(category, [])\n                ]\n\n    return cast(PolicyType, merged_policy)\n\n", "CodeBleu_score": 46.59679269693001}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy = {}\n    seen_categories = set()\n    for policy in policies:\n        for category, category_policies in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = [\n                    policy_value\n                    for policy_value in category_policies\n                    for policy in policies\n                    if category in policy\n                ]\n    return cast(PolicyType, merged_policy)", "CodeBleu_score": 43.5110467427908}, {"code": "def merge_policies(policies: list[PolicyType]) -> PolicyType\n    merged_policy: PolicyType = {}\n    seen_categories: set[str] = set()\n    for policy in policies:\n        for category, rules in policy.items():\n            if category not in seen_categories:\n                seen_categories.add(category)\n                merged_policy[category] = [\n                    rule\n                    for policy in policies\n                    for rule in policy.get(category, [])\n                ]\n    return cast(PolicyType, merged_policy)", "CodeBleu_score": 51.41070216961059}]}
{"instance_id": "3d78fbe0bdc3", "generation_result": [{"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    try:\n        module = importlib.import_module(f\".{provider}\", __name__)\n    except ImportError as err:\n        _LOGGER.error(\"Failed to import %s auth provider module: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Error while loading {provider} auth provider module\"\n        ) from err\n\n    if not hasattr(module, \"REQUIREMENTS\"):\n        return module\n\n    if not hass.config.skip_pip:\n        try:\n            _LOGGER.debug(\"Processing %s auth provider module requirements\", provider)\n            await _process_requirements(hass, module.REQUIREMENTS)\n        except (\n            PipError,\n            HomeAssistantError,\n            ValueError,\n            OSError,\n            asyncio.TimeoutError,\n        ) as err:\n            _LOGGER.error(\n                \"Error processing %s auth provider module requirements: %s\", provider, err\n            )\n            raise HomeAssistantError(\n                f\"Error while processing {provider} auth provider module requirements\"\n            ) from err\n\n    return module\n\n", "CodeBleu_score": 44.27121406060886}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    if provider in _PROCESSED_REQUIREMENTS:\n        return _PROCESSED_REQUIREMENTS[provider]\n\n    try:\n        module = importlib.import_module(f\"auth_provider.{provider}\")\n    except ImportError as err:\n        _LOGGER.error(\"Error loading auth provider module %s: %s\", provider, err)\n        raise HomeAssistantError(\n            f\"Error loading auth provider module {provider}: {err}\"\n        ) from err\n\n    requirements = getattr(module, \"REQUIREMENTS\", [])\n    if not requirements:\n        _PROCESSED_REQUIREMENTS[provider] = module\n        return module\n\n    # Process requirements\n    async def _process_requirement(req: str) -> None:\n        if req in _PROCESSED_REQUIREMENTS:\n            return\n\n        if req.startswith(\"git+\"):\n            # GitHub requirements are installed directly from the repo\n            _LOGGER.debug(\"Installing %s from GitHub\", req)\n            await _hassio_supervisor.install_github_requirement(req)\n            return\n\n        if req.startswith(\"git+https://\"):\n            # GitHub requirements are installed directly from the repo\n            _LOGGER.debug(\"Installing %s from GitHub\", req)\n            await _hassio_supervisor.install_github_requirement(req)\n            return\n\n        if req.startswith(\"git+ssh://\"):\n            # GitHub requirements are installed directly from the repo\n            _LOGGER.debug(\"Installing %s from GitHub\", req)\n            await _hassio_supervisor.install_github_requirement(req)\n            return\n\n        if req.startswith(\"git+git://\"):\n            # GitHub requirements are installed directly from the repo\n            _LOGGER.debug(\"Installing %s from GitHub\", req)\n            await _hassio_supervisor.install_github_requirement(req)\n            return\n\n        if req.startswith(\"git+file://\"):\n            # GitHub requirements are installed directly from the repo", "CodeBleu_score": 40.981991736028164}, {"code": "async def load_auth_provider_module(\n    hass: HomeAssistant, provider: str\n) -> types.ModuleType\n    if provider in _processed_requirements:\n        return _processed_requirements[provider]\n    try:\n        module = importlib.import_module(f\"homeassistant.auth.{provider}\")\n    except ImportError:\n        _LOGGER.exception(\"Error loading auth provider %s\", provider)\n        raise HomeAssistantError(\n            f\"Error loading auth provider {provider}. \"\n            \"Did you install the required python package?\"\n        ) from None\n    if not hasattr(module, \"REQUIREMENTS\"):\n        _processed_requirements[provider] = module\n        return module\n    requirements = getattr(module, \"REQUIREMENTS\")\n    if not requirements:\n        _processed_requirements[provider] = module\n        return module\n    if not hass.config.skip_pip:\n        try:\n            async with async_timeout.timeout(10):\n                await asyncio.gather(\n                    *(\n                        hass.hassio.async_addon_pip_install(\n                            addon, requirement\n                        )\n                        for addon, requirement in requirements\n                    )\n                )\n        except (asyncio.TimeoutError, aiohttp.ClientError) as err:\n            _LOGGER.warning(\n                \"Error installing pip dependencies for %s: %s\",\n                provider,\n                err,\n            )\n    _processed_requirements[provider] = module\n    return module", "CodeBleu_score": 38.25244598192047}]}
{"instance_id": "5747687b7c1f", "generation_result": [{"code": "async def async_load(self) -> None\n    try:\n        self.data = await self.store.async_load()\n    except FileNotFoundError:\n        self.data = []\n\n    self.normalized_usernames = set()\n    for user in self.data:\n        if user[\"username\"] != user[\"normalized_username\"]:\n            self.normalized_usernames.add(user[\"normalized_username\"])\n\n", "CodeBleu_score": 28.480480029153497}, {"code": "async def async_load(self) -> None\n    self._data = await self._store.async_load()\n    if self._data is None:\n        self._data = {}\n    self._normalized_usernames = {\n        username.lower(): username for username in self._data.keys()\n    }\n\n", "CodeBleu_score": 33.97915164147292}, {"code": "async def async_load(self) -> None\n    try:\n        self.users = await self.store.async_load()\n    except FileNotFoundError:\n        self.users = []\n    if self.users:\n        self.users = {\n            user[\"username\"]: user\n            for user in self.users\n            if \"username\" in user and user[\"username\"]\n        }\n    else:\n        self.users = {}\n", "CodeBleu_score": 27.80996249877451}]}
{"instance_id": "2b24a182d218", "generation_result": [{"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower().strip()\n    dummy_hash = bcrypt.hashpw(b\"\", bcrypt.gensalt())\n    for user in self.users:\n        if user.username == username:\n            if bcrypt.checkpw(password.encode(), user.password_hash):\n                return user\n            else:\n                raise InvalidAuth()\n    raise InvalidAuth()\n", "CodeBleu_score": 30.925342833896618}, {"code": "def validate_login(self, username: str, password: str) -> None\n    normalized_username = self.normalize_username(username)\n    dummy_hash = bcrypt.gensalt()\n    for user in self.users:\n        if user[\"username\"] == normalized_username:\n            stored_password_hash = user[\"password_hash\"]\n            if bcrypt.checkpw(password.encode(\"utf-8\"), stored_password_hash):\n                return\n            else:\n                raise InvalidAuth(\"Invalid username or password\")\n    bcrypt.checkpw(password.encode(\"utf-8\"), dummy_hash)\n    raise InvalidAuth(\"Invalid username or password\")\n\n", "CodeBleu_score": 37.8263820418484}, {"code": "def validate_login(self, username: str, password: str) -> None\n    username = username.lower()\n    dummy_hash = bcrypt.hashpw(b\"dummy\", bcrypt.gensalt())\n    user = self.db.get_user(username)\n    if user is None:\n        if bcrypt.checkpw(password.encode(), dummy_hash):\n            raise InvalidAuth()\n        else:\n            raise InvalidAuth()\n    else:\n        if not bcrypt.checkpw(password.encode(), user[\"password_hash\"]):\n            raise InvalidAuth()\n\n", "CodeBleu_score": 34.7874951727768}]}
{"instance_id": "f37f02097efa", "generation_result": [{"code": "def async_remove_auth(self, username: str) -> None\n    normalized_username = await self._async_normalize_username(username)\n    if normalized_username not in self._users:\n        raise InvalidUser(f\"user_not_found: {username}\")\n    del self._users[normalized_username]\n    self.async_write_config()\n", "CodeBleu_score": 23.856229413904906}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = username.lower()\n    user = next((user for user in self.users if user.username == username), None)\n    if user is not None:\n        self.users.remove(user)\n    else:\n        raise InvalidUser(\"user_not_found\")", "CodeBleu_score": 28.2490061002932}, {"code": "def async_remove_auth(self, username: str) -> None\n    username = username.lower()\n    for user in self._users:\n        if user.username == username:\n            self._users.remove(user)\n            return\n    raise InvalidUser(\"user_not_found\")\n\n", "CodeBleu_score": 26.046456973713372}]}
{"instance_id": "5f7a570175ef", "generation_result": [{"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if not self.data:\n        await self.async_initialize()\n    try:\n        await self.async_remove_user(credentials.username)\n    except ValueError:\n        _LOGGER.warning(\"User %s not found\", credentials.username)\n    self.data.save()\n", "CodeBleu_score": 50.0382476128749}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if self.data is None:\n        await self.async_initialize_data()\n    try:\n        await self.async_remove_user(credentials.username)\n    except InvalidUser:\n        pass\n", "CodeBleu_score": 50.00022338063819}, {"code": "async def async_will_remove_credentials(self, credentials: Credentials) -> None\n    if self._auth is None:\n        await self.async_initialize_auth()\n    try:\n        await self._auth.async_remove_credentials(credentials)\n    except InvalidUser:\n        _LOGGER.debug(\"Invalid user, ignoring\")\n", "CodeBleu_score": 45.30612238441114}]}
{"instance_id": "bf55dbe212cb", "generation_result": [{"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined_threads = set()\n    for thread in threads:\n        if thread.is_alive() and thread.identifier:\n            thread.join(timeout)\n            if thread.is_alive():\n                if log:\n                    logger.warning(\n                        f\"Thread {thread.identifier} still running after {timeout} seconds\"\n                    )\n                thread.raise_exception(SystemExit)\n            else:\n                joined_threads.add(thread)\n        else:\n            joined_threads.add(thread)\n    return joined_threads", "CodeBleu_score": 40.07454468695174}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    # Calculate the timeout for each thread\n    thread_timeouts = {thread: timeout / len(threads) for thread in threads}\n\n    # Join the threads within the specified timeout\n    joined_threads = set()\n    for thread in threads:\n        thread.join(thread_timeouts[thread])\n        if not thread.is_alive() or not thread.identifier:\n            joined_threads.add(thread)\n\n    # Log the remaining threads if logging is enabled\n    if log:\n        remaining_threads = threads - joined_threads\n        if remaining_threads:\n            print(f\"The following threads are still running: {remaining_threads}\")\n\n    # Raise a SystemExit exception in any remaining threads\n    for thread in threads - joined_threads:\n        thread.raise_exception()\n\n    # Return the set of successfully joined threads\n    return joined_threads", "CodeBleu_score": 46.10260808261043}, {"code": "def join_or_interrupt_threads(\n    threads: set[Thread], timeout: float, log: bool\n) -> set[Thread]\n    joined_threads: set[Thread] = set()\n    for thread in threads:\n        if thread.is_alive():\n            thread.join(timeout)\n        if not thread.is_alive() or not thread.ident:\n            joined_threads.add(thread)\n    if log:\n        for thread in threads:\n            if thread.is_alive():\n                print(f\"Thread {thread.ident} is still running\")\n    for thread in threads:\n        if thread.is_alive():\n            thread.raise_exception(SystemExit)\n    return joined_threads\n\n", "CodeBleu_score": 43.78317906139675}]}
{"instance_id": "107e0d377449", "generation_result": [{"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import time\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.info(\"Shutting down\")\n    threads = threading.enumerate()\n    threads = [thread for thread in threads if thread != threading.main_thread() and not thread.isDaemon() and thread.is_alive()]\n    timeout = threading.main_thread().join_timeout / len(threads)\n    for thread in threads:\n        thread.join(timeout=timeout)\n        if not thread.is_alive():\n            logger.info(\"Thread %s joined successfully\", thread.name)\n        else:\n            logger.warning(\"Thread %s failed to join within %s seconds\", thread.name, timeout)\n    logger.info(\"Shutdown complete\")", "CodeBleu_score": 31.82420457659457}, {"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import time\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.info(\"Shutting down...\")\n    threads = threading.enumerate()\n    threads = [t for t in threads if t is not threading.main_thread() and not t.daemon]\n    logger.info(f\"Found {len(threads)} non-main, non-daemon, alive threads\")\n    if len(threads) > 0:\n        total_timeout = 10\n        for t in threads:\n            t.join(timeout=total_timeout / len(threads))\n            if t.is_alive():\n                logger.warning(f\"Thread {t.name} failed to join within {total_timeout / len(threads)} seconds\")\n    logger.info(\"Shutdown complete\")\n", "CodeBleu_score": 38.49045786561224}, {"code": "def deadlock_safe_shutdown() -> None\n    import threading\n    import time\n    import logging\n    logger = logging.getLogger(__name__)\n    logger.info(\"Shutting down...\")\n    remaining_threads = [t for t in threading.enumerate() if t is not threading.main_thread() and not t.isDaemon() and t.is_alive()]\n    logger.info(f\"Found {len(remaining_threads)} remaining threads: {remaining_threads}\")\n    total_timeout = 30\n    for t in remaining_threads:\n        timeout = total_timeout / len(remaining_threads)\n        logger.info(f\"Joining thread {t.name} with timeout {timeout}\")\n        t.join(timeout)\n        if t.is_alive():\n            logger.warning(f\"Thread {t.name} did not shut down in time. Forcing shutdown.\")\n            t.join()\n    logger.info(\"Shutdown complete.\")\n", "CodeBleu_score": 38.39390961780816}]}
{"instance_id": "ea3b3f2eca2b", "generation_result": [{"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if self._remaining_setups or self._previous_state:\n        self._internal_dispatcher.dispatch(\n            InternalDispatcherSignal.SETUP_STARTED, remaining_with_setup_started\n        )\n        self._remaining_setups = remaining_with_setup_started\n        self._previous_state = True\n    else:\n        self._previous_state = False\n\n", "CodeBleu_score": 40.49908421322797}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started or self._remaining_with_setup_started:\n        self._remaining_with_setup_started = remaining_with_setup_started\n        self._internal_dispatcher.dispatch(\n            \"remaining_with_setup_started\", remaining_with_setup_started\n        )\n\n", "CodeBleu_score": 41.69364895830489}, {"code": " def _async_dispatch(self, remaining_with_setup_started: dict[str, float]) -> None\n    if remaining_with_setup_started or self._internal_flag_remaining_setups:\n        self._internal_flag_remaining_setups = True\n        self._internal_dispatcher.dispatch(\n            \"setup_started\", remaining_with_setup_started\n        )\n\n", "CodeBleu_score": 45.654303444068866}]}
{"instance_id": "a77eabd01ec1", "generation_result": [{"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    if not config.validate_bluetooth_integrations:\n        return\n\n    # Generate the expected content for bluetooth.py\n    expected_content = generate_bluetooth_content(integrations)\n\n    # Read the current content of bluetooth.py\n    try:\n        with open(\"bluetooth.py\", \"r\") as f:\n            current_content = f.read()\n    except FileNotFoundError:\n        current_content = \"\"\n\n    # Compare the expected content with the current content\n    if expected_content != current_content:\n        # Add an error to the configuration indicating that bluetooth.py is not up to date\n        config.errors.append(\"bluetooth.py is not up to date\")\n\n        # Provide a fixable suggestion to update bluetooth.py\n        config.fixes.append(Fix(\n            \"Update bluetooth.py\",\n            \"Update the content of bluetooth.py to match the expected content\",\n            \"Update bluetooth.py with the following content:\\n\\n\" + expected_content\n        ))\n", "CodeBleu_score": 42.41812188662485}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # Generate the Bluetooth content based on the provided integrations\n    bluetooth_content = generate_bluetooth_content(integrations)\n\n    # Read the current content of bluetooth.py\n    current_content = read_bluetooth_content()\n\n    # Compare the generated content with the current content\n    if bluetooth_content != current_content:\n        # Add an error to the configuration indicating that bluetooth.py is not up to date\n        config.add_error(\n            \"bluetooth.py is not up to date\",\n            \"Fixable suggestion: Update bluetooth.py to the latest version.\",\n        )\n\n        # Provide a fixable suggestion to update bluetooth.py\n        config.add_fixable_suggestion(\n            \"Update bluetooth.py to the latest version\",\n            \"Update the content of bluetooth.py to match the latest version of the file.\",\n        )", "CodeBleu_score": 36.015457747161236}, {"code": "def validate(integrations: dict[str, Integration], config: Config) -> None:\n    # Generate the expected content for bluetooth.py\n    expected_content = generate_bluetooth_py_content(integrations, config)\n\n    # Check if bluetooth.py exists\n    if not os.path.exists(config.bluetooth_py_path):\n        # If bluetooth.py does not exist, add an error to the configuration and return\n        config.add_error(\n            \"bluetooth_py_not_found\",\n            \"bluetooth.py file not found\",\n            \"The bluetooth.py file is not found in the specified path. Please create it and add the required content.\",\n            fixable=True,\n            fix=lambda: create_bluetooth_py_file(expected_content, config),\n        )\n        return\n\n    # Read the current content of bluetooth.py\n    with open(config.bluetooth_py_path, \"r\") as file:\n        current_content = file.read()\n\n    # Compare the current content with the expected content\n    if current_content != expected_content:\n        # If the contents differ, add an error to the configuration and return\n        config.add_error(\n            \"bluetooth_py_outdated\",\n            \"bluetooth.py is outdated\",\n            \"The bluetooth.py file is outdated. Please update it with the latest content.\",\n            fixable=True,\n            fix=lambda: update_bluetooth_py_file(expected_content, config),\n        )\n", "CodeBleu_score": 34.51261774818418}]}
{"instance_id": "f39bd31b6e07", "generation_result": [{"code": "func (d *Dropbox) refreshToken() error\tlog.Println(\"Refreshing token\")\n\tbody := url.Values{}\n\tbody.Set(\"grant_type\", \"refresh_token\")\n\tbody.Set(\"refresh_token\", d.refreshToken)\n\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", strings.NewReader(body.Encode()))\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.appKey+\":\"+d.appSecret)))\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tb, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"Failed to refresh token: %s\", string(b))\n\t}\n\tvar tokenResponse struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tif err := json.Unmarshal(b, &tokenResponse); err != nil {\n\t\treturn err\n\t}\n\td.accessToken = tokenResponse.AccessToken\n\tlog.Println(\"Token refreshed\")\n\treturn nil\n}\n", "CodeBleu_score": 49.03217501242326}, {"code": "func (d *Dropbox) refreshToken() error\treq, err := http.NewRequest(\"POST\", \"https://api.dropboxapi.com/oauth2/token\", nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(d.appKey+\":\"+d.appSecret)))\n\tq := req.URL.Query()\n\tq.Add(\"grant_type\", \"refresh_token\")\n\tq.Add(\"refresh_token\", d.refreshToken)\n\treq.URL.RawQuery = q.Encode()\n\tresp, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn fmt.Errorf(\"dropbox: refresh token failed: %s\", body)\n\t}\n\tvar r struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\tif err := json.Unmarshal(body, &r); err != nil {\n\t\treturn err\n\t}\n\td.accessToken = r.AccessToken\n\treturn nil\n}\n", "CodeBleu_score": 49.47327911398457}, {"code": "func (d *Dropbox) refreshToken() error\turl := \"https://api.dropboxapi.com/oauth2/token\"\n\tpayload := strings.NewReader(fmt.Sprintf(\"{\\\"grant_type\\\": \\\"refresh_token\\\", \\\"refresh_token\\\": \\\"%s\\\"}\", d.RefreshToken))\n\treq, err := http.NewRequest(\"POST\", url, payload)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.Header.Add(\"Authorization\", fmt.Sprintf(\"Basic %s\", base64.StdEncoding.EncodeToString([]byte(d.AppKey+\":\"+d.AppSecret))))\n\treq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tres, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif res.StatusCode != 200 {\n\t\treturn fmt.Errorf(\"error refreshing token: %s\", string(body))\n\t}\n\tvar response struct {\n\t\tAccessToken string `json:\"access_token\"`\n\t}\n\terr = json.Unmarshal(body, &response)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.AccessToken = response.AccessToken\n\treturn nil\n}\n", "CodeBleu_score": 50.68318577845348}]}
{"instance_id": "ab2306bd1c96", "generation_result": [{"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Drive-API-Version\", \"3\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tres, err := http.DefaultClient.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp != nil {\n\t\terr = json.NewDecoder(res.Body).Decode(resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif res.StatusCode != 200 {\n\t\tdefer res.Body.Close()\n\n\t\tbody, err := ioutil.ReadAll(res.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn nil, fmt.Errorf(\"error %d: %s\", res.StatusCode, string(body))\n\t}\n\n\tdefer res.Body.Close()\n\treturn ioutil.ReadAll(res.Body)\n}\n", "CodeBleu_score": 54.816725723198964}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Accept\", \"application/json\")\n\treq.Header.Set(\"Drive-API-Version\", \"3\")\n\treq.Header.Set(\"X-Goog-Drive-Use-Restricted-User-Agent\", \"true\")\n\treq.Header.Set(\"X-Goog-Drive-Shared-With-Me-Team-Drives\", \"true\")\n\treq.Header.Set(\"X-Goog-Drive-Team-Drive-Id\", \"true\")\n\treq.Header.Set(\"X-Goog-Drive-Shared-With-Me\", \"true\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\tres, err := d.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode != http.StatusOK {\n\t\tif res.StatusCode == http.StatusUnauthorized {\n\t\t\td.token, err = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn d.request(url, method, callback, resp)\n\t\t}\n\t\tbody, _ := ioutil.ReadAll(res.Body)\n\t\treturn nil, errors.New(string(body))\n\t}\n\n\tif resp != nil {\n\t\terr = json.NewDecoder(res.Body).Decode(resp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn body, nil\n}\n", "CodeBleu_score": 57.29754901272255}, {"code": "func (d *GoogleDrive) request(url string, method string, callback base.ReqCallback, resp interface{}) ([]byte, error)\treq, err := http.NewRequest(method, url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\treq.Header.Add(\"Content-Type\", \"application/json\")\n\treq.Header.Add(\"Accept\", \"application/json\")\n\treq.Header.Add(\"Drive-API-Version\", \"3\")\n\treq.Header.Add(\"X-Goog-Drive-Use-Restricted-User-Agent\", \"true\")\n\n\tif callback != nil {\n\t\tcallback(req)\n\t}\n\n\trespBody, err := d.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif respBody.StatusCode != 200 {\n\t\tif respBody.StatusCode == 401 {\n\t\t\td.token, err = d.refreshToken()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treq.Header.Set(\"Authorization\", \"Bearer \"+d.token.AccessToken)\n\n\t\t\trespBody, err = d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif respBody.StatusCode == 429 {\n\t\t\tretryAfter, err := strconv.Atoi(respBody.Header.Get(\"Retry-After\"))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\ttime.Sleep(time.Duration(retryAfter) * time.Second)\n\n\t\t\trespBody, err = d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif respBody.StatusCode >= 500 {\n\t\t\ttime.Sleep(5 * time.Second)\n\n\t\t\trespBody, err = d.client.Do(req)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif respBody.StatusCode >= 400 {\n\t\t\tbody, err := io", "CodeBleu_score": 54.599426824770156}]}
{"instance_id": "394e47fa9726", "generation_result": [{"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\tchunkSize := 1024 * 1024 * 10 // 10 MB\n\tchunk := make([]byte, chunkSize)\n\tuploaded := 0\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tn, err := stream.Read(chunk)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\treq, err := http.NewRequest(http.MethodPut, url, bytes.NewReader(chunk[:n]))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", uploaded, uploaded+n-1, stream.Size()))\n\n\t\tresp, err := d.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusNoContent {\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t\t}\n\n\t\tuploaded += n\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 41.83676069503775}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\t// Calculate the chunk size\n\tchunkSize := d.getChunkSize(stream.Size())\n\n\t// Create a buffer for the chunk\n\tbuf := make([]byte, chunkSize)\n\n\t// Initialize the upload session\n\tuploadSession, err := d.initiateUploadSession(ctx, url)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Upload the file in chunks\n\tchunkStart := int64(0)\n\tchunkEnd := chunkSize\n\tfor chunkStart < stream.Size() {\n\t\t// Check for context cancellation\n\t\tif err := ctx.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Read the next chunk\n\t\tn, err := stream.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\n\t\t// Upload the chunk\n\t\tif err := d.uploadChunk(ctx, buf[:n], chunkStart, chunkEnd, uploadSession); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Update the chunk boundaries\n\t\tchunkStart += int64(n)\n\t\tchunkEnd += int64(n)\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 38.70103814017995}, {"code": "func (d *GoogleDrive) chunkUpload(ctx context.Context, stream model.FileStreamer, url string) error\tchunkSize := int64(1024 * 1024 * 10) // 10 MB\n\tchunkCount := int64(math.Ceil(float64(stream.Size()) / float64(chunkSize)))\n\tchunkNumber := int64(0)\n\n\tfor {\n\t\tchunkNumber++\n\n\t\tif chunkNumber > chunkCount {\n\t\t\tbreak\n\t\t}\n\n\t\tchunkStart := chunkSize * (chunkNumber - 1)\n\t\tchunkEnd := chunkSize * chunkNumber\n\n\t\tif chunkEnd > stream.Size() {\n\t\t\tchunkEnd = stream.Size()\n\t\t}\n\n\t\tchunkSize := chunkEnd - chunkStart\n\n\t\tchunk, err := stream.Read(chunkStart, chunkSize)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq, err := http.NewRequestWithContext(ctx, http.MethodPut, url, bytes.NewReader(chunk))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\treq.Header.Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", chunkStart, chunkEnd-1, stream.Size()))\n\n\t\tresp, err := d.httpClient.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent {\n\t\t\treturn fmt.Errorf(\"unexpected status code: %d\", resp.StatusCode)\n\t\t}\n\n\t\tif chunkNumber == chunkCount {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 43.57994462104378}]}
{"instance_id": "09f7ab396d35", "generation_result": [{"code": "func UmountStorage(ctx echo.Context) error    // Bind JSON data from the request context\n    var data struct {\n        MountPoint string `json:\"mount_point\"`\n    }\n    if err := ctx.Bind(&data); err != nil {\n        return ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n            \"error\": err.Error(),\n        })\n    }\n\n    // Check if the mount point is empty\n    if data.MountPoint == \"\" {\n        return ctx.JSON(http.StatusBadRequest, map[string]interface{}{\n            \"error\": \"mount_point is required\",\n        })\n    }\n\n    // Attempt to unmount the storage at the specified mount point\n    if err := UnmountStorage(data.MountPoint); err != nil {\n        return ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n            \"error\": err.Error(),\n        })\n    }\n\n    // Delete the corresponding configuration\n    if err := DeleteConfig(data.MountPoint); err != nil {\n        return ctx.JSON(http.StatusInternalServerError, map[string]interface{}{\n            \"error\": err.Error(),\n        })\n    }\n\n    // Return a success response\n    return ctx.JSON(http.StatusOK, map[string]interface{}{\n        \"message\": \"Storage unmounted successfully\",\n    })\n}\n", "CodeBleu_score": 33.02026636898837}, {"code": "func UmountStorage(ctx echo.Context) error\t// Bind the JSON data from the request context\n\tvar data struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}\n\tif err := ctx.Bind(&data); err != nil {\n\t\treturn ctx.JSON(http.StatusBadRequest, err.Error())\n\t}\n\n\t// Check if the mount point is empty\n\tif data.MountPoint == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, \"Mount point is empty\")\n\t}\n\n\t// Unmount the storage at the specified mount point\n\tif err := unmountStorage(data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Delete the corresponding configuration\n\tif err := deleteConfig(data.MountPoint); err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, err.Error())\n\t}\n\n\t// Return a success response\n\treturn ctx.JSON(http.StatusOK, \"Storage unmounted successfully\")\n}\n", "CodeBleu_score": 32.237352273084944}, {"code": "func UmountStorage(ctx echo.Context) error\tdata := &struct {\n\t\tMountPoint string `json:\"mount_point\"`\n\t}{}\n\tif err := ctx.Bind(data); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\n\tif data.MountPoint == \"\" {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"mount_point is required\")\n\t}\n\n\tif err := unmountStorage(data.MountPoint); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\tif err := deleteStorageConfig(data.MountPoint); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"message\": \"Storage unmounted successfully\"})\n}\n", "CodeBleu_score": 34.31818390855462}]}
{"instance_id": "f91b4efa4a7f", "generation_result": [{"code": "func GetLocalFile(ctx echo.Context) error\t// Get the file path from the query parameters\n\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"Missing file path\",\n\t\t})\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": \"File not found\",\n\t\t})\n\t}\n\n\t// Open the file\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusInternalServerError, map[string]string{\n\t\t\t\"error\": \"Failed to open file\",\n\t\t})\n\t}\n\tdefer file.Close()\n\n\t// Set the Content-Type header based on the file extension\n\tcontentType := mime.TypeByExtension(filepath.Ext(filePath))\n\tctx.Response().Header().Set(\"Content-Type\", contentType)\n\n\t// Return the file to the client\n\treturn ctx.Stream(http.StatusOK, contentType, file)\n}\n", "CodeBleu_score": 36.918408949810704}, {"code": "func GetLocalFile(ctx echo.Context) error\tfilePath := ctx.QueryParam(\"file\")\n\tif filePath == \"\" {\n\t\treturn ctx.JSON(http.StatusBadRequest, map[string]string{\n\t\t\t\"error\": \"file path is missing\",\n\t\t})\n\t}\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn ctx.JSON(http.StatusNotFound, map[string]string{\n\t\t\t\"error\": fmt.Sprintf(\"file not found: %s\", err.Error()),\n\t\t})\n\t}\n\tdefer file.Close()\n\n\treturn ctx.Stream(http.StatusOK, \"application/octet-stream\", file)\n}\n", "CodeBleu_score": 32.418868210099156}, {"code": "func GetLocalFile(ctx echo.Context) error    // Extract the file path from the query parameters\n    filePath := ctx.QueryParam(\"filepath\")\n\n    // Check if the file path is provided\n    if filePath == \"\" {\n        return ctx.JSON(http.StatusBadRequest, map[string]string{\n            \"error\": \"File path is missing\",\n        })\n    }\n\n    // Check if the file exists\n    if _, err := os.Stat(filePath); os.IsNotExist(err) {\n        return ctx.JSON(http.StatusNotFound, map[string]string{\n            \"error\": \"File not found\",\n        })\n    }\n\n    // Return the file to the client\n    return ctx.File(filePath)\n}\n\n\n", "CodeBleu_score": 36.994369632400456}]}
{"instance_id": "129591f07d9b", "generation_result": [{"code": "func PostNotifyMessage(ctx echo.Context) error\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\n\tname := ctx.Param(\"name\")\n\n\tif err := notify.Send(name, message); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\n\treturn ctx.String(http.StatusOK, \"Notification sent successfully\")\n}\n", "CodeBleu_score": 47.68656468873693}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, err.Error())\n\t}\n\tgo func() {\n\t\tnotify.Send(name, message)\n\t}()\n\treturn ctx.JSON(http.StatusOK, echo.Map{\"status\": \"ok\"})\n}\n", "CodeBleu_score": 44.195884471755875}, {"code": "func PostNotifyMessage(ctx echo.Context) error\tname := ctx.Param(\"name\")\n\tvar message map[string]interface{}\n\tif err := ctx.Bind(&message); err != nil {\n\t\treturn ctx.String(http.StatusBadRequest, err.Error())\n\t}\n\tif err := notify.Send(name, message); err != nil {\n\t\treturn ctx.String(http.StatusInternalServerError, err.Error())\n\t}\n\treturn ctx.String(http.StatusOK, \"Notification sent successfully\")\n}\n\n", "CodeBleu_score": 47.68656468873693}]}
{"instance_id": "587524e838a4", "generation_result": [{"code": "func NotifyWS(ctx echo.Context) error    // Upgrade the HTTP GET request to a WebSocket connection\n    ws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n    if err != nil {\n        return err\n    }\n    // Add the new WebSocket connection to the list of connections\n    connections = append(connections, ws)\n    // Start the message sending service if it's not running\n    if !messageSendingServiceRunning {\n        messageSendingServiceRunning = true\n        go sendMessages()\n    }\n    // Enter a loop to continuously read messages from the WebSocket connection\n    for {\n        // Read the next message from the WebSocket connection\n        _, message, err := ws.ReadMessage()\n        if err != nil {\n            // If there's an error, remove the WebSocket connection from the list of connections\n            removeConnection(ws)\n            // If there are no more connections, stop the message sending service\n            if len(connections) == 0 {\n                messageSendingServiceRunning = false\n            }\n            // Return the error\n            return err\n        }\n        // Print the message type, message, and any errors\n        fmt.Printf(\"Message type: %s\\nMessage: %s\\nError: %v\\n\", message.Type, message.Data, message.Error)\n    }\n}\n", "CodeBleu_score": 43.60293536813178}, {"code": "func NotifyWS(ctx echo.Context) error\t// Upgrade the HTTP connection to a WebSocket connection\n\tws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Add the new WebSocket connection to the list of connections\n\tconnections = append(connections, ws)\n\n\t// Start the message sending service if it's not already running\n\tif !messageSendingServiceRunning {\n\t\tmessageSendingServiceRunning = true\n\t\tgo sendMessages()\n\t}\n\n\t// Continuously read messages from the WebSocket connection and print the message type, message, and any errors\n\tfor {\n\t\tmt, message, err := ws.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"read:\", err)\n\t\t\tbreak\n\t\t}\n\t\tlog.Printf(\"recv: %s\", message)\n\t\terr = ws.WriteMessage(mt, message)\n\t\tif err != nil {\n\t\t\tlog.Println(\"write:\", err)\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Remove the WebSocket connection from the list of connections\n\tfor i, c := range connections {\n\t\tif c == ws {\n\t\t\tconnections = append(connections[:i], connections[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 50.2008903544355}, {"code": "func NotifyWS(ctx echo.Context) error    ws, err := upgrader.Upgrade(ctx.Response(), ctx.Request(), nil)\n    if err != nil {\n        return err\n    }\n    connections = append(connections, ws)\n    if !running {\n        running = true\n        go sendMessages()\n    }\n    for {\n        var msg Message\n        err := ws.ReadJSON(&msg)\n        if err != nil {\n            break\n        }\n        fmt.Printf(\"Message type: %s, Message: %s, Error: %v\\n\", msg.Type, msg.Message, err)\n    }\n    return nil\n}\n", "CodeBleu_score": 45.40786368947959}]}
{"instance_id": "1397bcfe7eaf", "generation_result": [{"code": "func GetSystemHardwareInfo(ctx echo.Context) error\tdriveModel := GetDriveModel()\n\tarchitecture := GetArchitecture()\n\tcpuInfo := GetCPUInfo()\n\n\tif cpuInfo != nil {\n\t\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\t\"success\":      true,\n\t\t\t\"driveModel\":   driveModel,\n\t\t\t\"architecture\": architecture,\n\t\t\t\"cpuInfo\":      cpuInfo,\n\t\t})\n\t}\n\n\treturn ctx.JSON(http.StatusOK, map[string]interface{}{\n\t\t\"success\":      true,\n\t\t\"driveModel\":   driveModel,\n\t\t\"architecture\": architecture,\n\t\t\"cpuInfo\":      nil,\n\t})\n}\n", "CodeBleu_score": 21.222612382215612}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error    // Get the system hardware information\n    systemHardwareInfo := GetHardwareInfo()\n\n    // If CPU information is available, return it with a success message\n    if systemHardwareInfo.Cpu != nil {\n        return ctx.JSON(http.StatusOK, map[string]interface{}{\n            \"success\": true,\n            \"data\":    systemHardwareInfo,\n        })\n    }\n\n    // If CPU information is not available, return \"nil\" with a success message\n    return ctx.JSON(http.StatusOK, map[string]interface{}{\n        \"success\": true,\n        \"data\":    nil,\n    })\n}\n", "CodeBleu_score": 19.903507908346395}, {"code": "func GetSystemHardwareInfo(ctx echo.Context) error    // Get the drive model and architecture\n    driveModel := GetDriveModel()\n    architecture := GetArchitecture()\n\n    // Get CPU information\n    cpuInfo := GetCpuInfo()\n\n    // Create the JSON response\n    response := map[string]interface{}{\n        \"success\": true,\n        \"data\": map[string]interface{}{\n            \"drive_model\": driveModel,\n            \"architecture\": architecture,\n            \"cpu_info\": cpuInfo,\n        },\n    }\n\n    return ctx.JSON(http.StatusOK, response)\n}\n", "CodeBleu_score": 19.37091115753497}]}
{"instance_id": "73bd9f483ea9", "generation_result": [{"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunningServices := make([]string, 0)\n\tnotRunningServices := make([]string, 0)\n\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tstatus, err := s.systemctl.Status(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif status.ActiveState == \"active\" {\n\t\t\t\trunningServices = append(runningServices, service)\n\t\t\t} else {\n\t\t\t\tnotRunningServices = append(notRunningServices, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &runningServices,\n\t\tfalse: &notRunningServices,\n\t}, nil\n}\n", "CodeBleu_score": 55.45915076582102}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trunning := []string{}\n\tnotRunning := []string{}\n\tfor _, service := range services {\n\t\tif strings.Contains(service, \"casaos\") {\n\t\t\tstatus, err := s.systemctl.Status(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif status == \"active\" {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}\n", "CodeBleu_score": 62.42964687880159}, {"code": "func (s *service) Services() (map[bool]*[]string, error)\tservices, err := s.systemctl.ListServices()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trunning := []string{}\n\tnotRunning := []string{}\n\n\tfor _, service := range services {\n\t\tif strings.HasPrefix(service, \"casaos\") {\n\t\t\tstatus, err := s.systemctl.Status(service)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif status.IsActive {\n\t\t\t\trunning = append(running, service)\n\t\t\t} else {\n\t\t\t\tnotRunning = append(notRunning, service)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn map[bool]*[]string{\n\t\ttrue:  &running,\n\t\tfalse: &notRunning,\n\t}, nil\n}\n", "CodeBleu_score": 62.47884851175234}]}
{"instance_id": "ea1dadc1c92f", "generation_result": [{"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tmessageJson, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to serialize message: %v\", err)\n\t\treturn\n\t}\n\n\tresponse, err := i.publisher.Publish(context.Background(), &pb.PublishRequest{\n\t\tTopic:   name,\n\t\tMessage: messageJson,\n\t})\n\tif err != nil {\n\t\tlog.Printf(\"Failed to publish message: %v\", err)\n\t\treturn\n\t}\n\n\tif response.GetStatus().GetCode() != pb.Status_OK {\n\t\tlog.Printf(\"Failed to publish message: %v\", response.GetStatus().GetDetails())\n\t}\n}\n", "CodeBleu_score": 36.308294801134004}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tmessageJson, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to serialize message to JSON: %v\", err)\n\t\treturn\n\t}\n\n\tresponse, err := i.messageBus.Publish(name, messageJson)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to publish message: %v\", err)\n\t\treturn\n\t}\n\n\tif response.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"Failed to publish message: %v\", response.Details)\n\t}\n}\n", "CodeBleu_score": 30.578182573432827}, {"code": "func (i *notifyServer) SendNotify(name string, message map[string]interface{})\tctx := context.Background()\n\tjsonMessage, err := json.Marshal(message)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to marshal message: %v\", err)\n\t\treturn\n\t}\n\n\tevent := &events.Event{\n\t\tName: name,\n\t\tData: string(jsonMessage),\n\t}\n\n\tresp, err := i.client.Publish(ctx, event)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to publish event: %v\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tlog.Printf(\"Failed to publish event: %v\", resp.Details)\n\t}\n}\n", "CodeBleu_score": 35.680388549473214}]}
{"instance_id": "2e85f66d0860", "generation_result": [{"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient, err := message_bus.NewClientWithResponses(c.runtimePath)\n\tif err != nil {\n\t\tlog.Printf(\"Error creating message bus client: %v\", err)\n\t\tclient, _ = message_bus.NewClientWithResponses(message_bus.ServerError)\n\t}\n\treturn client\n}\n", "CodeBleu_score": 39.01425406417604}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\truntimePath := c.runtimePath\n\tclient := message_bus.NewClientWithResponses(runtimePath, message_bus.WithHTTPClient(c.httpClient))\n\n\taddress, err := c.getAddress(runtimePath)\n\tif err != nil {\n\t\tclient.WithServer(message_bus.Server{URL: \"http://localhost:8080\"})\n\t} else {\n\t\tclient.WithServer(message_bus.Server{URL: address})\n\t}\n\n\treturn client\n}\n", "CodeBleu_score": 39.87841408805741}, {"code": "func (c *store) MessageBus() *message_bus.ClientWithResponses\tclient, err := message_bus.NewClientWithResponses(c.runtimePath)\n\tif err != nil {\n\t\tclient.Server = \"Error: Failed to retrieve message bus address.\"\n\t}\n\treturn client\n}\n", "CodeBleu_score": 31.66486678394631}]}
{"instance_id": "b5b9e246990a", "generation_result": [{"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip != \"\" {\n\t\tip = strings.Split(ip, \",\")[0]\n\t} else {\n\t\tip = request.RemoteAddr\n\t}\n\n\tif ip == \"::1\" || ip == \"::ffff:127.0.0.1\" {\n\t\tip = \"127.0.0.1\"\n\t}\n\n\treturn ip\n}\n", "CodeBleu_score": 69.20030639400296}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\tif strings.HasPrefix(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t}\n\tif strings.HasPrefix(ip, \"::ffff:\") {\n\t\tip = strings.Replace(ip, \"::ffff:\", \"\", 1)\n\t}\n\treturn ip\n}\n", "CodeBleu_score": 55.58457975832365}, {"code": "func GetIP(request *http.Request) string\tip := request.Header.Get(\"x-forwarded-for\")\n\tif ip == \"\" {\n\t\tip = request.RemoteAddr\n\t}\n\n\tif strings.Contains(ip, \"::1\") {\n\t\tip = \"127.0.0.1\"\n\t} else if strings.Contains(ip, \"::ffff:\") {\n\t\tip = strings.Replace(ip, \"::ffff:\", \"\", 1)\n\t}\n\n\treturn ip\n}\n", "CodeBleu_score": 56.500231894279416}]}
{"instance_id": "095b4e6024be", "generation_result": [{"code": "func (c *systemService) GenreateSystemEntry()\tmodulesDir := filepath.Join(c.dir, \"modules\")\n\tentryFilePath := filepath.Join(c.dir, \"entry.json\")\n\n\tentries := []map[string]interface{}{}\n\n\t// Read each module directory for entry.json files\n\tmoduleDirs, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\tlog.Println(\"Error reading module directories:\", err)\n\t\treturn\n\t}\n\n\tfor _, moduleDir := range moduleDirs {\n\t\tmoduleDirPath := filepath.Join(modulesDir, moduleDir.Name())\n\n\t\tentryFilePath := filepath.Join(moduleDirPath, \"entry.json\")\n\t\tentryFile, err := os.Open(entryFilePath)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error opening entry file:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tdefer entryFile.Close()\n\n\t\tvar entry map[string]interface{}\n\t\terr = json.NewDecoder(entryFile).Decode(&entry)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error decoding entry file:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, entry)\n\t}\n\n\t// Write the consolidated entries to the entry file\n\tentryFile, err := os.Create(entryFilePath)\n\tif err != nil {\n\t\tlog.Println(\"Error creating entry file:\", err)\n\t\treturn\n\t}\n\n\tdefer entryFile.Close()\n\n\terr = json.NewEncoder(entryFile).Encode(entries)\n\tif err != nil {\n\t\tlog.Println(\"Error encoding entries:\", err)\n\t\treturn\n\t}\n}\n", "CodeBleu_score": 48.93049003886052}, {"code": "func (c *systemService) GenreateSystemEntry()\t// Get the modules directory path\n\tmodulesDir := c.config.GetString(\"modules.dir\")\n\n\t// Get the entry file path\n\tentryFile := c.config.GetString(\"modules.entry\")\n\n\t// Check if the entry file exists\n\tif _, err := os.Stat(entryFile); os.IsNotExist(err) {\n\t\t// If the entry file does not exist, create it\n\t\tfile, err := os.Create(entryFile)\n\t\tif err != nil {\n\t\t\t// Log the error\n\t\t\tc.logger.Error(err)\n\t\t\treturn\n\t\t}\n\t\tdefer file.Close()\n\n\t\t// Write an empty JSON array to the entry file\n\t\t_, err = file.WriteString(\"[]\")\n\t\tif err != nil {\n\t\t\t// Log the error\n\t\t\tc.logger.Error(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Read the entry file\n\tdata, err := os.ReadFile(entryFile)\n\tif err != nil {\n\t\t// Log the error\n\t\tc.logger.Error(err)\n\t\treturn\n\t}\n\n\t// Unmarshal the JSON array from the entry file\n\tvar entry []map[string]interface{}\n\terr = json.Unmarshal(data, &entry)\n\tif err != nil {\n\t\t// Log the error\n\t\tc.logger.Error(err)\n\t\treturn\n\t}\n\n\t// Read each module directory\n\tmoduleDirs, err := os.ReadDir(modulesDir)\n\tif err != nil {\n\t\t// Log the error\n\t\tc.logger.Error(err)\n\t\treturn\n\t}\n\n\t// Iterate through each module directory\n\tfor _, moduleDir := range moduleDirs {\n\t\t// Check if the directory is a module directory\n\t\tif moduleDir.IsDir() {\n\t\t\t// Get the path to the module directory\n\t\t\tmodulePath := filepath.Join(modulesDir, moduleDir.Name())\n\n\t\t\t// Read the entry.json file in the module directory\n\t\t\tmoduleEntryFile := filepath.Join(modulePath, \"entry.json\")\n\t\t\tmoduleData, err := os.ReadFile(moduleEntryFile)\n\t\t\tif err != nil {\n\t\t\t\t// Log the error\n", "CodeBleu_score": 46.880410208994725}, {"code": "func (c *systemService) GenreateSystemEntry()\tmodulesDirectory := \"./modules\"\n\tentryFilePath := \"./modules/entry.json\"\n\n\tentryFile, err := os.Create(entryFilePath)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to create entry file: %v\", err)\n\t\treturn\n\t}\n\tdefer entryFile.Close()\n\n\tentries := []string{}\n\n\tmoduleDirs, err := os.ReadDir(modulesDirectory)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to read module directory: %v\", err)\n\t\treturn\n\t}\n\n\tfor _, moduleDir := range moduleDirs {\n\t\tif !moduleDir.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tmoduleEntryPath := filepath.Join(modulesDirectory, moduleDir.Name(), \"entry.json\")\n\t\tmoduleEntry, err := os.ReadFile(moduleEntryPath)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to read module entry file: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tentries = append(entries, string(moduleEntry))\n\t}\n\n\tentriesJSON := []byte(\"[\" + strings.Join(entries, \",\") + \"]\")\n\n\tif err := os.WriteFile(entryFilePath, entriesJSON, 0644); err != nil {\n\t\tlog.Printf(\"Failed to write entry file: %v\", err)\n\t\treturn\n\t}\n\n\tlog.Println(\"Entry file generated successfully\")\n}\n", "CodeBleu_score": 43.17937853189917}]}
{"instance_id": "d2b7079478d1", "generation_result": [{"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.SystemService.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, networkName := range networkNames {\n\t\tfor _, iface := range interfaces {\n\t\t\tif iface.Name == networkName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"no matching interface found\")\n}\n", "CodeBleu_score": 64.50102807790532}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetworkNames, err := c.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, networkName := range networkNames {\n\t\t\tif iface.Name == networkName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"no matching interface found\")\n}\n", "CodeBleu_score": 65.07577370207385}, {"code": "func (c *systemService) GetMacAddress() (string, error) \tinterfaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tnetNames, err := c.systemService.NetworkService.GetNetworkNames()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, iface := range interfaces {\n\t\tfor _, netName := range netNames {\n\t\t\tif iface.Name == netName {\n\t\t\t\treturn iface.HardwareAddr.String(), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"no matching interface found\")\n}\n", "CodeBleu_score": 65.1310845955694}]}
{"instance_id": "9333855fecb1", "generation_result": [{"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)  int32_t retVal = SUCCESS;\n\n  if (pRequest == NULL) {\n    retVal = ERROR_NULL_POINTER;\n  } else {\n    pRequest->pTscObj = pTscObj;\n    pTscObj->pRequest = pRequest;\n    pTscObj->requestCount++;\n    if (pTscObj->pAppInfo != NULL) {\n      pTscObj->pAppInfo->totalRequestCount++;\n      pTscObj->pAppInfo->currentRequestCount++;\n    }\n    LOG_DEBUG(\"Registering request %p for TSC %p\", pRequest, pTscObj);\n  }\n\n  return retVal;\n}\n", "CodeBleu_score": 36.71035214504676}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)  int32_t retVal = SUCCESS;\n  SRequestObj *pRequestObj = NULL;\n  SAppInfo *pAppInfo = NULL;\n  SAppInfo *pAppInfo2 = NULL;\n  SAppInfo *pAppInfo3 = NULL;\n  SAppInfo *pAppInfo4 = NULL;\n  SAppInfo *pAppInfo5 = NULL;\n  SAppInfo *pAppInfo6 = NULL;\n  SAppInfo *pAppInfo7 = NULL;\n  SAppInfo *pAppInfo8 = NULL;\n  SAppInfo *pAppInfo9 = NULL;\n  SAppInfo *pAppInfo10 = NULL;\n  SAppInfo *pAppInfo11 = NULL;\n  SAppInfo *pAppInfo12 = NULL;\n  SAppInfo *pAppInfo13 = NULL;\n  SAppInfo *pAppInfo14 = NULL;\n  SAppInfo *pAppInfo15 = NULL;\n  SAppInfo *pAppInfo16 = NULL;\n  SAppInfo *pAppInfo17 = NULL;\n  SAppInfo *pAppInfo18 = NULL;\n  SAppInfo *pAppInfo19 = NULL;\n  SAppInfo *pAppInfo20 = NULL;\n  SAppInfo *pAppInfo21 = NULL;\n  SAppInfo *pAppInfo22 = NULL;\n  SAppInfo *pAppInfo23 = NULL;\n  SAppInfo *pAppInfo24 = NULL;\n  SAppInfo *pAppInfo25 = NULL;\n  SAppInfo *pAppInfo26 = NULL;\n  SAppInfo *pAppInfo27 = NULL;\n  SAppInfo *pAppInfo28 = NULL;\n  SAppInfo *pAppInfo29 = NULL;\n  SAppInfo *pAppInfo30 = NULL;\n  SAppInfo *pAppInfo31 = NULL;\n  SAppInfo *pAppInfo32 = NULL;\n  SAppInfo *pAppInfo33 = NULL;\n  SAppInfo *pAppInfo34 = NULL;\n  SAppInfo *pAppInfo35 = NULL;\n  SAppInfo *p", "CodeBleu_score": 5.224513379348569}, {"code": "static int32_t registerRequest(SRequestObj *pRequest, STscObj *pTscObj)  int32_t retVal = SUCCESS;\n\n  if (pRequest != NULL && pTscObj != NULL) {\n    pRequest->pTscObj = pTscObj;\n    pTscObj->requestCount++;\n\n    if (pTscObj->appInfo != NULL) {\n      pTscObj->appInfo->currReqCount++;\n      pTscObj->appInfo->totalReqCount++;\n    }\n\n    if (pTscObj->debugLevel & TSC_DEBUG_LEVEL_2) {\n      tscLog(pTscObj, TSC_LOG_LEVEL_DEBUG, \"registerRequest: Request registered. Request count: %d\", pTscObj->requestCount);\n    }\n  } else {\n    retVal = ERR_INVALID_PARAM;\n  }\n\n  return retVal;\n}\n", "CodeBleu_score": 40.28855284552769}]}
{"instance_id": "3120013c53c3", "generation_result": [{"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    char *pPrimaryDb = pRequest->pPrimaryDb;\n    char *pDb = pRequest->pDb;\n    char *pSchema = pRequest->pSchema;\n    char *pDb2 = pRequest->pDb2;\n    char *pSchema2 = pRequest->pSchema2;\n    char *pDb3 = pRequest->pDb3;\n    char *pSchema3 = pRequest->pSchema3;\n    char *pDb4 = pRequest->pDb4;\n    char *pSchema4 = pRequest->pSchema4;\n    char *pDb5 = pRequest->pDb5;\n    char *pSchema5 = pRequest->pSchema5;\n    char *pDb6 = pRequest->pDb6;\n    char *pSchema6 = pRequest->pSchema6;\n    char *pDb7 = pRequest->pDb7;\n    char *pSchema7 = pRequest->pSchema7;\n    char *pDb8 = pRequest->pDb8;\n    char *pSchema8 = pRequest->pSchema8;\n    char *pDb9 = pRequest->pDb9;\n    char *pSchema9 = pRequest->pSchema9;\n    char *pDb10 = pRequest->pDb10;\n    char *pSchema10 = pRequest->pSchema10;\n    char *pDb11 = pRequest->pDb11;\n    char *pSchema11 = pRequest->pSchema11;\n    char *pDb12 = pRequest->pDb12;\n    char *pSchema12 = pRequest->pSchema12;\n    char *pDb13 = pRequest->pDb13;\n    char *pSchema13 = pRequest->pSchema13;\n    char *pDb14 = pRequest->pDb14;\n    char *pSchema14 = pRequest->pSchema14;\n    char *pDb15 = pRequest->pDb15;\n    char *pSchema15 = pRequest->pSchema", "CodeBleu_score": 8.13807708568396}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)    char* db = pRequest->pPrimaryDb;\n    if (db == NULL) {\n        return true;\n    }\n    if (strcmp(db, exceptDb) != 0) {\n        return true;\n    }\n    if (pRequest->pDbList == NULL) {\n        return true;\n    }\n    for (int i = 0; i < pRequest->dbListLen; i++) {\n        char* db = pRequest->pDbList[i];\n        if (db == NULL) {\n            continue;\n        }\n        if (strcmp(db, exceptDb) != 0) {\n            return true;\n        }\n    }\n    return false;\n}\n", "CodeBleu_score": 47.05626123524859}, {"code": "static bool checkSlowLogExceptDb(SRequestObj *pRequest, char* exceptDb)  char* pDb = pRequest->pDb;\n  if (pDb) {\n    if (strcmp(pDb, exceptDb) != 0) {\n      return false;\n    }\n  }\n  for (int i = 0; i < pRequest->numDb; i++) {\n    char* pDb = pRequest->pDb[i];\n    if (pDb) {\n      if (strcmp(pDb, exceptDb) != 0) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n", "CodeBleu_score": 45.31433727013792}]}
{"instance_id": "7558fd043790", "generation_result": [{"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    return (code == RPC_REDIRECT_ERROR) && (msgType != MSG_TYPE_RPC_REDIRECT_RESPONSE) && (msgType != MSG_TYPE_RPC_REDIRECT_RESPONSE_ACK);\n}\n", "CodeBleu_score": 10.228042972731902}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    if (code == -1 && (msgType == TMSG_RPC_REQ || msgType == TMSG_RPC_REQ_REPLY || msgType == TMSG_RPC_REQ_REPLY_ERR)) {\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 31.058409323667824}, {"code": "static bool clientRpcRfp(int32_t code, tmsg_t msgType)    if (code == RPC_ERR_REDIRECT && msgType != MSG_TYPE_RPC_REQ && msgType != MSG_TYPE_RPC_RESP && msgType != MSG_TYPE_RPC_RESP_ACK && msgType != MSG_TYPE_RPC_RESP_NACK) {\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 41.89400048710121}]}
{"instance_id": "1ed1f4a17f8c", "generation_result": [{"code": "void stopAllRequests(SHashObj *pRequests)    if (pRequests == NULL) {\n        return;\n    }\n\n    int i;\n    for (i = 0; i < pRequests->tableSize; i++) {\n        if (pRequests->table[i] != NULL) {\n            RequestObj *pRequest = pRequests->table[i];\n            while (pRequest != NULL) {\n                QueryObj *pQuery = pRequest->pQuery;\n                if (pQuery != NULL && pQuery->isRunning) {\n                    stopQuery(pQuery);\n                }\n                RequestObj *pNext = pRequest->pNext;\n                releaseRequest(pRequest);\n                pRequest = pNext;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 40.13561960051458}, {"code": "void stopAllRequests(SHashObj *pRequests)    int i;\n    Request *pRequest;\n\n    for (i = 0; i < HASH_TABLE_SIZE; i++) {\n        if (pRequests->pRequests[i] != NULL) {\n            pRequest = pRequests->pRequests[i];\n            while (pRequest != NULL) {\n                if (pRequest->pQuery != NULL) {\n                    stopQuery(pRequest->pQuery);\n                }\n                releaseRequest(pRequest);\n                pRequest = pRequest->pNext;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 39.63403322912472}, {"code": "void stopAllRequests(SHashObj *pRequests)    int i;\n    for (i = 0; i < pRequests->size; i++) {\n        int j;\n        for (j = 0; j < pRequests->table[i]->size; j++) {\n            Request *pRequest = pRequests->table[i]->table[j];\n            if (pRequest != NULL) {\n                Query *pQuery = pRequest->query;\n                if (pQuery != NULL) {\n                    stopQuery(pQuery);\n                }\n                free(pRequest);\n            }\n        }\n        free(pRequests->table[i]);\n    }\n    free(pRequests);\n}\n", "CodeBleu_score": 38.363606583875054}]}
{"instance_id": "0dd1380011aa", "generation_result": [{"code": "void tscStopCrashReport()  if (!tscIsCrashReportEnabled()) {\n    return;\n  }\n  if (!atomic_compare_exchange_strong(&clientStop, &clientStop, 1)) {\n    tscLog(\"Crash report thread is already stopped\");\n    return;\n  }\n  while (atomic_load(&clientStop)) {\n    // wait for thread to stop\n  }\n}", "CodeBleu_score": 61.95325503097491}, {"code": "void tscStopCrashReport()    if (!g_crashReportEnabled)\n        return;\n    if (!atomic_compare_exchange_strong(&g_clientStop, &g_clientStop, 1)) {\n        LOG_INFO(\"Crash report thread is already stopped\");\n        return;\n    }\n    while (atomic_load(&g_clientStop))\n        ;\n}", "CodeBleu_score": 57.901349219128704}, {"code": "void tscStopCrashReport()    if (!g_crashReportEnabled)\n        return;\n\n    if (!atomic_compare_exchange_strong(&g_clientStop, &g_clientStop, 1)) {\n        LOG_INFO(\"Crash report thread is already stopped\");\n        return;\n    }\n\n    while (g_clientStop) {\n        usleep(100000);\n    }\n}", "CodeBleu_score": 59.86593766870689}]}
{"instance_id": "ede524f8cfd7", "generation_result": [{"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)    int32_t rc = RC_OK;\n    int32_t i = 0;\n    int32_t j = 0;\n    int32_t nViews = 0;\n    int32_t nCols = 0;\n    struct SViewInfo *pViewInfo = NULL;\n    struct SViewInfo *pViewInfoTmp = NULL;\n    struct SViewInfo *pViewInfoTmpNext = NULL;\n    struct SViewInfo *pViewInfoTmpPrev = NULL;\n    struct SViewInfo *pViewInfoTmpFirst = NULL;\n    struct SViewInfo *pViewInfoTmpLast = NULL;\n    struct SViewInfo *pViewInfoTmpLastPrev = NULL;\n    struct SViewInfo *pViewInfoTmpLastNext = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNext = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextPrev = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextPrev = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNext = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextPrev = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNext = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextPrev = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextNext = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextNextPrev = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextNextNext = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextNextNextPrev = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextNextNextNext = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextNextNextNextPrev = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextNextNextNextNext = NULL;\n    struct SViewInfo *pViewInfoTmpLastNextNextNextNextNextNextNextNextPrev = NULL;\n    struct SViewInfo", "CodeBleu_score": 7.804390783893944}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)    int32_t i;\n    int32_t iRet = 0;\n    int32_t iNumViews;\n    int32_t iNumColumns;\n    int32_t iNumRows;\n    int32_t iNumBytes;\n    int32_t iNumBytes2;\n    int32_t iNumBytes3;\n    int32_t iNumBytes4;\n    int32_t iNumBytes5;\n    int32_t iNumBytes6;\n    int32_t iNumBytes7;\n    int32_t iNumBytes8;\n    int32_t iNumBytes9;\n    int32_t iNumBytes10;\n    int32_t iNumBytes11;\n    int32_t iNumBytes12;\n    int32_t iNumBytes13;\n    int32_t iNumBytes14;\n    int32_t iNumBytes15;\n    int32_t iNumBytes16;\n    int32_t iNumBytes17;\n    int32_t iNumBytes18;\n    int32_t iNumBytes19;\n    int32_t iNumBytes20;\n    int32_t iNumBytes21;\n    int32_t iNumBytes22;\n    int32_t iNumBytes23;\n    int32_t iNumBytes24;\n    int32_t iNumBytes25;\n    int32_t iNumBytes26;\n    int32_t iNumBytes27;\n    int32_t iNumBytes28;\n    int32_t iNumBytes29;\n    int32_t iNumBytes30;\n    int32_t iNumBytes31;\n    int32_t iNumBytes32;\n    int32_t iNumBytes33;\n    int32_t iNumBytes34;\n    int32_t iNumBytes35;\n    int32_t iNumBytes36;", "CodeBleu_score": 6.578078639101875}, {"code": "static int32_t hbProcessViewInfoRsp(void *value, int32_t valueLen, struct SCatalog *pCatalog)  int32_t rc = 0;\n  int32_t i = 0;\n  int32_t viewIdx = 0;\n  int32_t viewId = 0;\n  int32_t viewColCnt = 0;\n  int32_t viewColIdx = 0;\n  int32_t colIdx = 0;\n  int32_t colId = 0;\n  int32_t colType = 0;\n  int32_t colTypeIdx = 0;\n  int32_t colTypeId = 0;\n  int32_t colTypeLen = 0;\n  int32_t colTypeLenIdx = 0;\n  int32_t colTypeLenId = 0;\n  int32_t colTypeLenLen = 0;\n  int32_t colTypeLenLenIdx = 0;\n  int32_t colTypeLenLenId = 0;\n  int32_t colTypeLenLenLen = 0;\n  int32_t colTypeLenLenLenIdx = 0;\n  int32_t colTypeLenLenLenId = 0;\n  int32_t colTypeLenLenLenLen = 0;\n  int32_t colTypeLenLenLenLenIdx = 0;\n  int32_t colTypeLenLenLenLenId = 0;\n  int32_t colTypeLenLenLenLenLen = 0;\n  int32_t colTypeLenLenLenLenLenIdx = 0;\n  int32_t colTypeLenLenLenLenLenId = 0;\n  int32_t colTypeLenLenLenLenLenLen = 0;\n  int32_t colTypeLenLenLenLenLenLenIdx = 0;\n  int32_t colTypeLenLenLenLenLenLenId = 0;\n  int32_t colTypeLenLenLenLenLenLenLen = 0;\n  int32_t colTypeLenLenLenLenLenLenLenIdx = 0;\n  int32_t colTypeLenLenLenLenLenLenLenId = 0;\n  int32_t colTypeLenLenLenLenLenLenLen", "CodeBleu_score": 7.39276737829988}]}
{"instance_id": "f87670226f65", "generation_result": [{"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    if (properties) {\n        S3ContentLength *contentLength = (S3ContentLength *) callbackData;\n        if (properties->contentLength > 0) {\n            contentLength->value = properties->contentLength;\n        } else {\n            contentLength->value = 0;\n        }\n    }\n    return S3StatusOK;\n}\n", "CodeBleu_score": 71.74905875675921}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    S3Status status = S3StatusOK;\n    S3ResponseProperties *responseProperties = (S3ResponseProperties *) callbackData;\n\n    if (properties->contentLength > 0) {\n        responseProperties->contentLength = properties->contentLength;\n    }\n\n    return status;\n}\n", "CodeBleu_score": 61.44632219469237}, {"code": "static S3Status responsePropertiesCallback(const S3ResponseProperties *properties, void *callbackData)    if (properties->responseHeader.contentLength > 0) {\n        *(size_t *) callbackData = properties->responseHeader.contentLength;\n    } else {\n        *(size_t *) callbackData = 0;\n    }\n\n    return S3StatusOK;\n}\n", "CodeBleu_score": 60.26894005594945}]}
{"instance_id": "32f7325bef8b", "generation_result": [{"code": "void startRsync()    char *checkpoint_backup_dir = \"/var/lib/postgresql/checkpoint_backup\";\n    char *rsync_config_file = \"/etc/rsyncd.conf\";\n    char *rsync_command = \"rsync --daemon --config=/etc/rsyncd.conf\";\n    char *rsync_log_file = \"/var/log/rsyncd.log\";\n    char *rsync_pid_file = \"/var/run/rsyncd.pid\";\n    char *rsync_port = \"873\";\n    char *rsync_user = \"postgres\";\n    char *rsync_group = \"postgres\";\n    char *rsync_log_level = \"info\";\n    char *rsync_log_format = \"default\";\n    char *rsync_timeout = \"300\";\n    char *rsync_pid_file_timeout = \"300\";\n    char *rsync_max_connections = \"10\";\n    char *rsync_max_load = \"100%\";\n    char *rsync_uid = \"postgres\";\n    char *rsync_gid = \"postgres\";\n    char *rsync_hosts_allow = \"127.0.0.1\";\n    char *rsync_hosts_deny = \"0.0.0.0/0\";\n    char *rsync_secrets_file = \"/etc/rsyncd.secrets\";\n    char *rsync_transfer_logging = \"yes\";\n    char *rsync_ignore_nonreadable = \"yes\";\n    char *rsync_ignore_errors = \"yes\";\n    char *rsync_ignore_existing = \"yes\";\n    char *rsync_ignore_missing_args = \"yes\";\n    char *rsync_dont_compress = \"*.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2\";\n    char *rsync_modules = \"write2log,rexec,notify,version,auth,syslog,xattrs,acl,vfs\";\n    char *rsync_strict_paths =", "CodeBleu_score": 7.615520901993467}, {"code": "void startRsync()  // Create the checkpoint backup directory if it doesn't exist\n  if (mkdir(CHECKPOINT_DIR, 0700) == -1 && errno != EEXIST) {\n    log_error(\"Failed to create checkpoint backup directory: %s\", strerror(errno));\n    return;\n  }\n\n  // Remove empty directories\n  removeEmptyDirs(CHECKPOINT_DIR);\n\n  // Generate the Rsync configuration file\n  char rsync_conf_path[PATH_MAX];\n  snprintf(rsync_conf_path, sizeof(rsync_conf_path), \"%s/%s\", CHECKPOINT_DIR, RSYNC_CONF_FILE);\n  FILE *rsync_conf_file = fopen(rsync_conf_path, \"w\");\n  if (rsync_conf_file == NULL) {\n    log_error(\"Failed to create Rsync configuration file: %s\", strerror(errno));\n    return;\n  }\n\n  fprintf(rsync_conf_file, \"port=%d\\n\", RSYNC_PORT);\n  fprintf(rsync_conf_file, \"pid file=%s/%s\\n\", CHECKPOINT_DIR, RSYNC_PID_FILE);\n  fprintf(rsync_conf_file, \"log file=%s/%s\\n\", CHECKPOINT_DIR, RSYNC_LOG_FILE);\n  fprintf(rsync_conf_file, \"secrets file=%s/%s\\n\", CHECKPOINT_DIR, RSYNC_SECRETS_FILE);\n  fprintf(rsync_conf_file, \"lock file=%s/%s\\n\", CHECKPOINT_DIR, RSYNC_LOCK_FILE);\n  fprintf(rsync_conf_file, \"motd file=%s/%s\\n\", CHECKPOINT_DIR, RSYNC_MOTD_FILE);\n  fprintf(rsync_conf_file, \"timeout=%d\\n\", RSYNC_TIMEOUT);\n  fprintf(rsync_conf_file, \"use chroot=no\\n\");\n  fprintf(rsync_", "CodeBleu_score": 31.86931852716677}, {"code": "void startRsync()  // Create the checkpoint backup directory if it doesn't exist\n  if (mkdir(CHECKPOINT_BACKUP_DIR, 0755) == -1 && errno != EEXIST) {\n    logError(\"Failed to create checkpoint backup directory: %s\", strerror(errno));\n    return;\n  }\n\n  // Remove empty directories\n  removeEmptyDirectories(CHECKPOINT_BACKUP_DIR);\n\n  // Generate the Rsync configuration file\n  char configFilePath[PATH_MAX];\n  snprintf(configFilePath, sizeof(configFilePath), \"%s/%s\", CHECKPOINT_BACKUP_DIR, \"rsyncd.conf\");\n  FILE* configFile = fopen(configFilePath, \"w\");\n  if (configFile == NULL) {\n    logError(\"Failed to create Rsync configuration file: %s\", strerror(errno));\n    return;\n  }\n\n  fprintf(configFile, \"port=%d\\n\", RSYNC_PORT);\n  fprintf(configFile, \"pid file=%s/%s\\n\", CHECKPOINT_BACKUP_DIR, \"rsyncd.pid\");\n  fprintf(configFile, \"lock file=%s/%s\\n\", CHECKPOINT_BACKUP_DIR, \"rsyncd.lock\");\n  fprintf(configFile, \"log file=%s/%s\\n\", CHECKPOINT_BACKUP_DIR, \"rsyncd.log\");\n  fprintf(configFile, \"max connections=%d\\n\", MAX_CONNECTIONS);\n  fprintf(configFile, \"timeout=%d\\n\", TIMEOUT);\n  fprintf(configFile, \"uid=%d\\n\", getuid());\n  fprintf(configFile, \"gid=%d\\n\", getgid());\n  fprintf(configFile, \"hosts deny=*\");\n\n  fclose(configFile);\n\n  // Construct and execute the Rsync command\n  char command[2048];\n  snprintf(command, sizeof(command), \"rsync --daemon --config=%s\", configFilePath);\n  int ret = system(command);\n", "CodeBleu_score": 36.241988983728746}]}
{"instance_id": "ca24c06528d5", "generation_result": [{"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher != null) {\n        dispatcher.getExecutor().shutdownNow();\n        dispatchers.remove(dispatcherId);\n    } else {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" is not registered.\");\n    }\n}\n", "CodeBleu_score": 70.51331440423823}, {"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.get(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered\");\n    }\n    dispatcher.shutdown();\n    dispatchers.remove(dispatcherId);\n}", "CodeBleu_score": 61.742163846104226}, {"code": "public void destroyDispatcher(String dispatcherId)    Dispatcher dispatcher = dispatchers.remove(dispatcherId);\n    if (dispatcher == null) {\n        throw new RuntimeException(\"Dispatcher with ID \" + dispatcherId + \" not registered\");\n    }\n    dispatcher.executor.shutdownNow();\n}", "CodeBleu_score": 63.64209873910105}]}
{"instance_id": "f9259705d3ba", "generation_result": [{"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    for (TbActorId child : getChildren(parent).stream().filter(childFilter).collect(Collectors.toList())) {\n        if (!getActor(child).isRegistered()) {\n            LOG.warn(\"{} is not registered\", child);\n            continue;\n        }\n        if (highPriority) {\n            getActor(child).send(msg, true);\n        } else {\n            getActor(child).send(msg);\n        }\n    }\n}", "CodeBleu_score": 44.53744618618319}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    // Get the children of the parent actor from the map\n    List<TbActorId> children = childrenMap.get(parent);\n    if (children == null) {\n        // The parent actor has no children\n        return;\n    }\n    // Filter the children based on the provided predicate\n    List<TbActorId> filteredChildren = children.stream().filter(childFilter).collect(Collectors.toList());\n    // Send the message to each filtered child actor\n    for (TbActorId child : filteredChildren) {\n        if (actorRegistry.getActor(child) == null) {\n            // The child actor is not registered\n            logger.warn(\"Child actor {} is not registered\", child);\n            continue;\n        }\n        // Attempt to send the message with an optional high priority\n        if (highPriority) {\n            actorRegistry.getActor(child).tell(msg, self());\n        } else {\n            actorRegistry.getActor(child).tell(msg);\n        }\n    }\n}", "CodeBleu_score": 47.05379828929055}, {"code": " private void broadcastToChildren(TbActorId parent, Predicate<TbActorId> childFilter, TbActorMsg msg, boolean highPriority)    for (TbActorId child : children.get(parent)) {\n        if (childFilter.test(child)) {\n            if (highPriority) {\n                if (tbActorRegistry.get(child) != null) {\n                    tbActorRegistry.get(child).send(msg, true);\n                } else {\n                    LOG.warn(\"Child actor {} is not registered\", child);\n                }\n            } else {\n                if (tbActorRegistry.get(child) != null) {\n                    tbActorRegistry.get(child).send(msg, false);\n                } else {\n                    LOG.warn(\"Child actor {} is not registered\", child);\n                }\n            }\n        }\n    }\n}", "CodeBleu_score": 38.932500242501675}]}
{"instance_id": "3e09fe4efcf0", "generation_result": [{"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (!isDestroying()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    } else {\n        if (msg.getType() == RULE_NODE_UPDATED_MSG) {\n            if (failedToInitialize) {\n                reinitialize();\n            }\n        } else {\n            msg.setActorStopped(true);\n        }\n    }\n}", "CodeBleu_score": 48.326896967032106}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (isDestructionInProgress()) {\n        if (highPriority && msg.getType() == RULE_NODE_UPDATED_MSG) {\n            if (initializeActor()) {\n                return;\n            }\n        }\n        msg.setActorStopped(true);\n    } else {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    }\n}", "CodeBleu_score": 50.637471443899805}, {"code": "private void enqueue(TbActorMsg msg, boolean highPriority)    if (!actor.isDestructionInProgress()) {\n        if (highPriority) {\n            highPriorityMsgs.add(msg);\n        } else {\n            normalPriorityMsgs.add(msg);\n        }\n        processQueue();\n    } else if (msg instanceof RuleNodeUpdatedMsg) {\n        if (actor.isFailed()) {\n            actor.reinitialize();\n        }\n    } else {\n        msg.setActorStopped();\n    }\n}", "CodeBleu_score": 39.924867855473394}]}
{"instance_id": "c7eeae2fcef2", "generation_result": [{"code": "private void processMailbox()    try {\n        if (mailbox.isEmpty()) {\n            status = MailboxStatus.FREE;\n            scheduleQueueProcessingAttempt();\n        } else {\n            if (mailbox.hasHighPriorityMessages()) {\n                processHighPriorityMessages();\n            }\n            if (mailbox.hasNormalPriorityMessages()) {\n                processNormalPriorityMessages();\n            }\n        }\n    } catch (Exception e) {\n        if (e instanceof InitializationException) {\n            setStopReason(e);\n            destroy();\n        } else {\n            log.error(\"Failed to process mailbox\", e);\n            processFailureStrategy.apply(this);\n        }\n    }\n}\n", "CodeBleu_score": 18.648786245964523}, {"code": "private void processMailbox()    try {\n        // Iterate through the queues, attempting to process each message\n        for (int i = 0; i < queues.length; i++) {\n            Message message = queues[i].poll();\n            if (message != null) {\n                process(message);\n                // If the throughput limit is reached, stop processing\n                if (throughputLimitReached()) {\n                    break;\n                }\n            }\n        }\n        // If there are no more messages, set the actor's status to free and schedule a queue processing attempt\n        if (allQueuesEmpty()) {\n            setStatus(ActorStatus.FREE);\n            scheduleQueueProcessingAttempt();\n        }\n    } catch (InitializationException e) {\n        // If an initialization failure occurs, set a stop reason and destroy the actor\n        setStopReason(e);\n        destroy();\n    } catch (Exception e) {\n        // For other exceptions, log the failure and apply the actor's process failure strategy\n        log.error(\"Error processing message\", e);\n        processFailureStrategy(e);\n    }\n}\n\n", "CodeBleu_score": 24.16739935904854}, {"code": "private void processMailbox()    if (stopReason != null) {\n        destroy();\n        return;\n    }\n    if (mailbox.isEmpty()) {\n        status = Status.FREE;\n        scheduleQueueProcessingAttempt();\n        return;\n    }\n    Message message = mailbox.remove();\n    try {\n        process(message);\n    } catch (InitializationException e) {\n        stopReason = e;\n        destroy();\n        return;\n    } catch (Exception e) {\n        log.error(\"Failed to process message\", e);\n        processFailureStrategy.apply(e);\n    }\n    if (stopReason != null) {\n        destroy();\n        return;\n    }\n    processMailbox();\n}", "CodeBleu_score": 20.535532431964594}]}
{"instance_id": "c77f1760a734", "generation_result": [{"code": "public void destroy(Throwable cause)    if (stopped) {\n        return;\n    }\n    if (stopReason == null) {\n        stopReason = new StopReason(cause);\n    }\n    stopped = true;\n    dispatcher.executor().execute(() -> {\n        try {\n            if (isReady()) {\n                setNotReady();\n            }\n            if (destroyMethod != null) {\n                destroyMethod.invoke(this, stopReason, cause);\n            }\n            notifyStopped();\n        } catch (Exception e) {\n            log.warning(\"Exception while destroying actor \" + this + \": \" + e.getMessage());\n        }\n    });\n}", "CodeBleu_score": 39.05207109684125}, {"code": "public void destroy(Throwable cause)    if (stopReason == null)\n        stopReason = cause;\n    if (isDestroying())\n        return;\n    isDestroying.set(true);\n    dispatcher.executor().execute(() -> {\n        try {\n            if (!isDestroyed())\n                actor.destroy(stopReason, cause);\n        } catch (Exception e) {\n            log.warn(\"Exception during actor destruction\", e);\n        }\n        isDestroyed.set(true);\n        isDestroying.set(false);\n        notifyMessages();\n    });\n}", "CodeBleu_score": 33.465730695208634}, {"code": "public void destroy(Throwable cause)    if (stopReason != null)\n        return;\n    stopReason = cause;\n    setDestroyed();\n    getDispatcher().executor().execute(() -> {\n        try {\n            setNotReady();\n            destroy(cause);\n            notifyQueuedMessages();\n        } catch (Throwable t) {\n            logger.warn(\"Error during destroy\", t);\n        }\n    });\n}", "CodeBleu_score": 27.61563774548869}]}
{"instance_id": "faa557453384", "generation_result": [{"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.isSystemTenant()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileService.getTenantProfile(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfig rateLimitConfig = tenantProfile.getRateLimitConfig();\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitConfig.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    if (rateLimit.isExceeded(level)) {\n        rateLimitConfig.processRateLimitNotification(api);\n        return false;\n    } else {\n        rateLimit.increment(level);\n        return true;\n    }\n}", "CodeBleu_score": 53.29208686274824}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.equals(SystemTenant.TENANT_ID)) {\n        return true;\n    }\n    try {\n        TenantProfile tenantProfile = tenantProfileService.getTenantProfile(tenantId);\n        if (tenantProfile == null) {\n            if (ignoreTenantNotFound) {\n                return true;\n            } else {\n                throw new TenantProfileNotFoundException(tenantId);\n            }\n        }\n        RateLimitConfiguration rateLimitConfiguration = tenantProfile.getRateLimitConfiguration();\n        if (rateLimitConfiguration != null) {\n            RateLimit rateLimit = rateLimitConfiguration.getRateLimit(api);\n            if (rateLimit != null) {\n                if (rateLimit.isExceeded(level)) {\n                    if (rateLimitConfiguration.getRateLimitNotification() != null) {\n                        rateLimitConfiguration.getRateLimitNotification().notify(tenantId, api, level);\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    } catch (TenantProfileNotFoundException e) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw e;\n        }\n    }\n}\n", "CodeBleu_score": 51.77523872535449}, {"code": "public boolean checkRateLimit(LimitedApi api, TenantId tenantId, Object level, boolean ignoreTenantNotFound)    if (tenantId.isSystemTenant()) {\n        return true;\n    }\n    TenantProfile tenantProfile = tenantProfileService.getTenantProfile(tenantId);\n    if (tenantProfile == null) {\n        if (ignoreTenantNotFound) {\n            return true;\n        } else {\n            throw new TenantProfileNotFoundException(tenantId);\n        }\n    }\n    RateLimitConfig rateLimitConfig = tenantProfile.getRateLimitConfig();\n    if (rateLimitConfig == null) {\n        return true;\n    }\n    RateLimit rateLimit = rateLimitConfig.getRateLimit(api);\n    if (rateLimit == null) {\n        return true;\n    }\n    RateLimitStatus rateLimitStatus = rateLimit.getStatus(level);\n    if (rateLimitStatus == null) {\n        return true;\n    }\n    if (rateLimitStatus.isExceeded()) {\n        if (rateLimitStatus.isNotificationSent()) {\n            return false;\n        } else {\n            rateLimitStatus.setNotificationSent(true);\n            rateLimitConfig.updateRateLimit(api, rateLimit);\n            rateLimitConfigService.update(tenantProfile.getTenantId(), rateLimitConfig);\n            rateLimitNotificationService.sendNotification(tenantProfile.getTenantId(), api, level);\n            return false;\n        }\n    } else {\n        rateLimitStatus.setCount(rateLimitStatus.getCount() + 1);\n        rateLimitStatus.setLastAccessTime(System.currentTimeMillis());\n        rateLimit.updateStatus(level, rateLimitStatus);\n        rateLimitConfig.updateRateLimit(api, rateLimit);\n        rateLimitConfigService.update(tenantProfile.getTenantId(), rateLimitConfig);\n        return true;\n    }\n}", "CodeBleu_score": 51.6772469967072}]}
{"instance_id": "86dc1ef3798b", "generation_result": [{"code": "public void evictTimeoutSessions()    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<DtlsSessionId, DtlsSession> entry : dtlsSessions.entrySet()) {\n        DtlsSession session = entry.getValue();\n        if (session.getLastActivityTime() < expirationTime) {\n            dtlsSessions.remove(entry.getKey());\n            logger.debug(\"DTLS session evicted: {}\", entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 50.42870327441569}, {"code": "public void evictTimeoutSessions()    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<Long, DtlsSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().getLastActivityTime() < expirationTime) {\n            LOG.info(\"Evicting DTLS session with id: {}\", entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 54.78170901900654}, {"code": "public void evictTimeoutSessions()    long expirationTime = System.currentTimeMillis() - inactivityTimeout;\n    for (Map.Entry<String, DTLSClientSession> entry : dtlsSessions.entrySet()) {\n        if (entry.getValue().lastActivityTime < expirationTime) {\n            logger.info(\"Removing DTLS session with id: \" + entry.getKey());\n            dtlsSessions.remove(entry.getKey());\n        }\n    }\n}", "CodeBleu_score": 48.441258380784205}]}
{"instance_id": "b79b5af90fe1", "generation_result": [{"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    return timeseries.entrySet().stream().flatMap(e -> e.getValue().stream().map(v -> new TsKvEntry(e.getKey(), v.asDouble()))).collect(Collectors.toList());\n}", "CodeBleu_score": 18.29028749403753}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    return timeseries.entrySet().stream().flatMap(entry -> {\n        final String key = entry.getKey();\n        final List<JsonNode> values = entry.getValue();\n        return values.stream().map(value -> {\n            final JsonNode timestamp = value.get(\"timestamp\");\n            final JsonNode valueNode = value.get(\"value\");\n            return new TsKvEntry(key, timestamp.asLong(), valueNode.asDouble());\n        });\n    }).collect(Collectors.toList());\n}", "CodeBleu_score": 40.30945538682617}, {"code": "public static List<TsKvEntry> toTimeseries(Map<String, List<JsonNode>> timeseries)    if (timeseries.isEmpty()) {\n        return Collections.emptyList();\n    }\n    List<TsKvEntry> tsKvEntries = new ArrayList<>();\n    for (Map.Entry<String, List<JsonNode>> entry : timeseries.entrySet()) {\n        String key = entry.getKey();\n        List<JsonNode> values = entry.getValue();\n        for (JsonNode value : values) {\n            tsKvEntries.add(new TsKvEntry(key, value));\n        }\n    }\n    return tsKvEntries;\n}", "CodeBleu_score": 36.49462122254876}]}
{"instance_id": "5515923bb5f5", "generation_result": [{"code": "public void refreshToken()    Map<String, String> request = new HashMap<>();\n    request.put(\"refresh_token\", refreshToken);\n    try {\n        ResponseEntity<TokenResponse> response = restTemplate.postForEntity(authUrl, request, TokenResponse.class);\n        if (response.getStatusCode() == HttpStatus.OK) {\n            TokenResponse tokenResponse = response.getBody();\n            accessToken = tokenResponse.getAccessToken();\n            refreshToken = tokenResponse.getRefreshToken();\n            expirationTime = System.currentTimeMillis() + tokenResponse.getExpiresIn() * 1000;\n        }\n    } catch (RestClientException e) {\n        logger.error(\"Error refreshing token: \" + e.getMessage());\n    }\n}", "CodeBleu_score": 48.0188432188957}, {"code": "public void refreshToken()    Map<String, String> requestMap = new HashMap<>();\n    requestMap.put(\"refreshToken\", refreshToken);\n    HttpResponse<String> response = Unirest.post(AUTHENTICATION_ENDPOINT).header(\"Content-Type\", \"application/json\").body(requestMap).asString();\n    if (response.getStatus() != 200) {\n        throw new RuntimeException(\"Failed to refresh token\");\n    }\n    tokenInfo.setTimestamp(System.currentTimeMillis());\n    tokenInfo.setToken(response.getBody());\n}", "CodeBleu_score": 50.79226285896823}, {"code": "public void refreshToken()    Map<String, String> request = new HashMap<>();\n    request.put(\"refresh_token\", this.refreshToken);\n    ResponseEntity<String> response = restTemplate.postForEntity(this.authUrl, request, String.class);\n    if (response.getStatusCode() == HttpStatus.OK) {\n        JSONObject jsonObject = new JSONObject(response.getBody());\n        this.token = jsonObject.getString(\"token\");\n        this.refreshToken = jsonObject.getString(\"refresh_token\");\n        this.tokenTimestamp = System.currentTimeMillis();\n    } else {\n        throw new RuntimeException(\"Failed to refresh token\");\n    }\n}", "CodeBleu_score": 47.1444960356457}]}
{"instance_id": "2e481513bbc1", "generation_result": [{"code": " private void doLogin()    long now = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    loginRequest.put(\"grant_type\", \"password\");\n    loginRequest.put(\"client_id\", \"client_id\");\n    loginRequest.put(\"client_secret\", \"client_secret\");\n    loginRequest.put(\"scope\", \"read write\");\n\n    try {\n        ResponseEntity<Map> response = restTemplate.postForEntity(authEndpoint, loginRequest, Map.class);\n        tokenInfo.setToken((String) response.getBody().get(\"access_token\"));\n        tokenInfo.setRefreshToken((String) response.getBody().get(\"refresh_token\"));\n        tokenInfo.setExpirationTime(now + (Long) response.getBody().get(\"expires_in\") * 1000);\n        tokenInfo.setScope((String) response.getBody().get(\"scope\"));\n        tokenInfo.setTokenType((String) response.getBody().get(\"token_type\"));\n        tokenInfo.setJti((String) response.getBody().get(\"jti\"));\n    } catch (HttpClientErrorException e) {\n        log.error(\"Error while logging in: {}\", e.getMessage());\n        throw new AuthenticationException(\"Error while logging in: \" + e.getMessage());\n    }\n}\n", "CodeBleu_score": 59.50102337086965}, {"code": " private void doLogin()    long timestamp = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n\n    Call<TokenInfo> call = authApi.login(loginRequest);\n    call.enqueue(new Callback<TokenInfo>() {\n        @Override\n        public void onResponse(Call<TokenInfo> call, Response<TokenInfo> response) {\n            if (response.isSuccessful()) {\n                TokenInfo tokenInfo = response.body();\n                tokenInfo.setTimestamp(timestamp);\n                tokenInfo.setUsername(username);\n                tokenInfo.setPassword(password);\n                tokenInfo.setToken(response.headers().get(\"Authorization\"));\n                tokenInfo.setRefreshToken(response.headers().get(\"Refresh-Token\"));\n                tokenInfo.setExpiration(response.headers().get(\"Expiration\"));\n                tokenInfo.setUserId(response.headers().get(\"User-Id\"));\n                tokenInfo.setRole(response.headers().get(\"Role\"));\n                tokenInfo.setFirstName(response.headers().get(\"First-Name\"));\n                tokenInfo.setLastName(response.headers().get(\"Last-Name\"));\n                tokenInfo.setEmail(response.headers().get(\"Email\"));\n                tokenInfo.setPhone(response.headers().get(\"Phone\"));\n                tokenInfo.setAddress(response.headers().get(\"Address\"));\n                tokenInfo.setCity(response.headers().get(\"City\"));\n                tokenInfo.setState(response.headers().get(\"State\"));\n                tokenInfo.setZip(response.headers().get(\"Zip\"));\n                tokenInfo.setCountry(response.headers().get(\"Country\"));\n                tokenInfo.setBirthday(response.headers().get(\"Birthday\"));\n                tokenInfo.setGender(response.headers().get(\"Gender\"));\n                tokenInfo.setPreferences(response.headers().get(\"Preferences\"));\n                tokenInfo.setProfilePicture(response.headers().get(\"Profile-Picture\"));\n                tokenInfo.setStatus(response.headers().get(\"Status\"));\n                tokenInfo.setCreatedAt(response.headers().", "CodeBleu_score": 55.5232350912545}, {"code": " private void doLogin()    long timestamp = System.currentTimeMillis();\n    Map<String, String> loginRequest = new HashMap<>();\n    loginRequest.put(\"username\", username);\n    loginRequest.put(\"password\", password);\n    loginRequest.put(\"timestamp\", String.valueOf(timestamp));\n    loginRequest.put(\"nonce\", getNonce());\n    loginRequest.put(\"signature\", getSignature(timestamp));\n\n    try {\n        ResponseEntity<Map<String, String>> response = restTemplate.postForEntity(\"/api/auth/login\", loginRequest, Map.class);\n        if (response.getStatusCode() == HttpStatus.OK) {\n            Map<String, String> responseData = response.getBody();\n            tokenInfo.setToken(responseData.get(\"token\"));\n            tokenInfo.setRefreshToken(responseData.get(\"refreshToken\"));\n            tokenInfo.setTimestamp(timestamp);\n        } else {\n            throw new RuntimeException(\"Login failed with status code: \" + response.getStatusCode());\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Login failed\", e);\n    }\n}\n", "CodeBleu_score": 60.40594586942274}]}
{"instance_id": "47f8466c5067", "generation_result": [{"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        return Optional.ofNullable(restTemplate.getForObject(getDeviceUrl(deviceId), Device.class));\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (HttpStatusCodeException e) {\n        throw e;\n    }\n}", "CodeBleu_score": 31.83536717739761}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        return Optional.of(restTemplate.getForObject(\"/api/device/{deviceId}\", Device.class, deviceId.getId()));\n    } catch (HttpClientErrorException.NotFound e) {\n        return Optional.empty();\n    } catch (HttpStatusCodeException e) {\n        throw new RuntimeException(e);\n    }\n}", "CodeBleu_score": 32.737345944801554}, {"code": "public Optional<Device> getDeviceById(DeviceId deviceId)    try {\n        return Optional.of(restTemplate.getForObject(deviceUrl + \"/{deviceId}\", Device.class, deviceId));\n    } catch (HttpClientErrorException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 41.18499586637213}]}
{"instance_id": "20f3aaf882c2", "generation_result": [{"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        HttpRequest request = HttpRequest.POST(\"/api/device-with-credentials\", device, credentials);\n        return Optional.of(request.send(Device.class));\n    } catch (HttpException e) {\n        if (e.getStatusCode() == 404) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 41.235745562249484}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        HttpEntity<DeviceWithCredentials> request = new HttpEntity<>(new DeviceWithCredentials(device, credentials));\n        ResponseEntity<Device> response = restTemplate.exchange(url + \"/api/device-with-credentials\", HttpMethod.POST, request, Device.class);\n        return Optional.of(response.getBody());\n    } catch (HttpStatusCodeException e) {\n        if (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n            return Optional.empty();\n        }\n        throw e;\n    }\n}", "CodeBleu_score": 60.42265813329271}, {"code": "public Optional<Device> saveDeviceWithCredentials(Device device, DeviceCredentials credentials)    try {\n        HttpRequest request = HttpRequest.POST(\"/api/device-with-credentials\", device, credentials);\n        Device savedDevice = request.send(Device.class);\n        return Optional.of(savedDevice);\n    } catch (HttpErrorResponseException e) {\n        if (e.getStatusCode() == 404) {\n            return Optional.empty();\n        } else {\n            throw e;\n        }\n    }\n}", "CodeBleu_score": 48.901605643615184}]}
{"instance_id": "f9af0a32ce24", "generation_result": [{"code": "brightness(addr, val)    this.setBrightness(addr, val);\n    return this;\n}\n", "CodeBleu_score": 20.674432852133528}, {"code": "brightness(addr, val)    if (arguments.length === 1) {\n        this.setBrightness(addr, val);\n    } else {\n        this.setBrightness(addr, Math.round((val / 100) * 15));\n    }\n    return this;\n}\n", "CodeBleu_score": 47.08709579999943}, {"code": "brightness(addr, val)    if (arguments.length === 1) {\n        this.send(0x01, [addr, val]);\n    } else if (arguments.length === 2) {\n        this.send(0x01, [addr, Math.round(val * 15 / 100)]);\n    }\n    return this;\n}\n", "CodeBleu_score": 43.58781895727272}]}
{"instance_id": "b5d7fcf10695", "generation_result": [{"code": "device(addr)  return Object.keys(LedControl.prototype).reduce((obj, key) => {\n    if (Object.prototype.hasOwnProperty.call(this, key)) {\n      obj[key] = this[key].bind(this, addr);\n    }\n    return obj;\n  }, {});\n}\n", "CodeBleu_score": 30.44245342655617}, {"code": "device(addr)    let obj = Object.create(LedControl.prototype);\n    obj.address = addr;\n    Object.keys(LedControl.prototype).forEach(key => {\n        obj[key] = obj[key].bind(obj);\n    });\n    Object.keys(obj).forEach(key => {\n        obj[key] = obj[key].bind(obj);\n    });\n    return obj;\n}\n", "CodeBleu_score": 32.94768989231079}, {"code": "device(addr)    const { LedControl } = require('./LedControl');\n\n    let device = Object.create(LedControl.prototype);\n\n    for (let key in LedControl.prototype) {\n        if (LedControl.prototype.hasOwnProperty(key)) {\n            device[key] = LedControl.prototype[key].bind(null, addr);\n        }\n    }\n\n    return device;\n}", "CodeBleu_score": 24.101268586198966}]}
{"instance_id": "7eeebfcd0176", "generation_result": [{"code": "Collection.installCallbackReconciliation = (target, methods) =>     for (const method of methods) {\n        target[method] = (duration = 1000, callback) => {\n            const promises = [];\n            const targetCollection = this;\n            for (const element of targetCollection) {\n                promises.push(new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                        element[method]();\n                        resolve();\n                    }, duration);\n                }));\n            }\n            Promise.all(promises).then(() => {\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            });\n        };\n    }\n};\n", "CodeBleu_score": 35.44284722636652}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>     methods.forEach(method => {\n        target[method] = (duration = 1000, callback = () => {}) => {\n            if (typeof callback !== 'function') {\n                throw new Error('Callback must be a function');\n            }\n\n            const promises = [];\n            this.forEach(element => {\n                promises.push(new Promise(resolve => {\n                    setTimeout(() => {\n                        element[method]();\n                        resolve();\n                    }, duration);\n                }));\n            });\n\n            Promise.all(promises).then(() => {\n                callback();\n            });\n        };\n    });\n};\n", "CodeBleu_score": 33.70607294045019}, {"code": "Collection.installCallbackReconciliation = (target, methods) =>   methods.forEach(method => {\n    target[method] = (duration = 1000, callback) => {\n      if (typeof callback !== 'function') {\n        throw new Error(`Callback for method ${method} is not a function`);\n      }\n\n      const promises = [];\n      this.forEach(element => {\n        promises.push(new Promise(resolve => {\n          setTimeout(() => {\n            element[method]();\n            resolve();\n          }, duration);\n        }));\n      });\n\n      Promise.all(promises).then(() => {\n        callback();\n      });\n    };\n  });\n};\n", "CodeBleu_score": 35.90941270987583}]}
{"instance_id": "f290c33a08e9", "generation_result": [{"code": "listen()    let input = \"\";\n    let incompleteSentence = \"\";\n    while (true) {\n        let data = this.serialPort.read();\n        if (data) {\n            input += data;\n            let sentences = input.split(\"\\r\\n\");\n            if (sentences.length > 1) {\n                incompleteSentence = sentences.pop();\n                input = sentences.join(\"\\r\\n\");\n            }\n            for (let sentence of sentences) {\n                this.parseNmeaSentence(sentence);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 38.377532946366465}, {"code": "listen()    let input = \"\";\n    let self = this;\n    self.serialport.on(\"data\", function(data) {\n        input += data;\n        let sentences = input.split(\"\\r\\n\");\n        input = sentences.pop();\n        for (let sentence of sentences) {\n            self.parseNmeaSentence(sentence);\n        }\n    });\n}\n", "CodeBleu_score": 31.11306430260093}, {"code": "listen()    let input = \"\";\n    let self = this;\n    this.serialPort.on(\"data\", function (data) {\n        input += data;\n        let sentences = input.split(\"\\r\\n\");\n        input = sentences.pop();\n        for (let sentence of sentences) {\n            self.parseNmeaSentence(sentence);\n        }\n    });\n}\n", "CodeBleu_score": 32.65417587876386}]}
{"instance_id": "ec7b00323130", "generation_result": [{"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tuint32_t buffer_size;\n\tuint8_t nb_channels;\n\n\tif (sequence->options & ADC_OPTION_CHANNEL_MASK) {\n\t\tnb_channels = sequence->options & ADC_OPTION_CHANNEL_MASK;\n\t} else {\n\t\tnb_channels = data->nb_channels;\n\t}\n\n\tbuffer_size = nb_channels * sequence->resolution;\n\n\tif (buffer_size > sequence->buffer_size) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 55.35311016962371}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tstruct adc_ad559x_data *data = dev->data;\n\tsize_t size = sequence->buffer_size;\n\tuint8_t num_channels = sequence->channels_mask;\n\tuint8_t num_active_channels = 0;\n\n\tfor (uint8_t i = 0; i < data->num_channels; i++) {\n\t\tif (num_channels & (1 << i)) {\n\t\t\tnum_active_channels++;\n\t\t}\n\t}\n\n\tif (size < num_active_channels * sizeof(uint16_t)) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 43.45392497575643}, {"code": "static int adc_ad559x_validate_buffer_size(const struct device *dev,\n\t\t\t\t\t   const struct adc_sequence *sequence)\tstruct ad559x_data *data = dev->data;\n\tuint8_t num_channels;\n\tuint8_t buffer_size;\n\n\tnum_channels = adc_ad559x_get_num_channels(dev, sequence);\n\tbuffer_size = adc_ad559x_get_buffer_size(dev, sequence);\n\n\tif (num_channels > AD559X_MAX_CHANNELS) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (buffer_size < num_channels * sizeof(uint16_t)) {\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 57.17067815245582}]}
{"instance_id": "ef1d8bcd8c32", "generation_result": [{"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)  struct adc_ad559x_data *data = dev->data;\n  uint8_t resolution = adc_ad559x_get_resolution(dev);\n  uint8_t channels = adc_ad559x_get_channels(dev);\n  uint8_t buffer_size = adc_ad559x_get_buffer_size(dev);\n\n  if (sequence->resolution != resolution) {\n    LOG_ERR(\"Invalid resolution: %d\", sequence->resolution);\n    return -EINVAL;\n  }\n\n  if (sequence->channels != channels) {\n    LOG_ERR(\"Invalid channels: %d\", sequence->channels);\n    return -EINVAL;\n  }\n\n  if (sequence->buffer_size < buffer_size) {\n    LOG_ERR(\"Insufficient buffer size: %d\", sequence->buffer_size);\n    return -EINVAL;\n  }\n\n  data->buffer = sequence->buffer;\n  data->buffer_size = buffer_size;\n\n  adc_ad559x_start_read_context(dev);\n\n  return adc_ad559x_wait_for_read(dev);\n}\n", "CodeBleu_score": 61.6324598971614}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)  struct adc_ad559x_data *data = dev->data;\n  struct adc_ad559x_config *config = dev->config;\n  struct adc_ad559x_ctx *ctx = data->ctx;\n  uint16_t *buffer = sequence->buffer;\n  uint16_t channels = sequence->channels;\n  uint16_t resolution = sequence->resolution;\n  uint16_t buffer_size = sequence->buffer_size;\n  uint16_t sample_size = sequence->resolution / 8;\n  uint16_t channel_mask = (1 << config->channel_count) - 1;\n\n  /* Check if the resolution of the ADC sequence matches the expected resolution. */\n  if (resolution != config->resolution) {\n    LOG_ERR(\"Invalid resolution: %d\", resolution);\n    return -EINVAL;\n  }\n\n  /* Check if the specified channels are valid. */\n  if ((channels & ~channel_mask) != 0) {\n    LOG_ERR(\"Invalid channels: %d\", channels);\n    return -EINVAL;\n  }\n\n  /* Check if the buffer size is sufficient for the ADC read. */\n  if (buffer_size < (channels * sample_size)) {\n    LOG_ERR(\"Insufficient buffer size: %d\", buffer_size);\n    return -EINVAL;\n  }\n\n  /* Set the buffer and start the ADC read context. */\n  ctx->buffer = buffer;\n  ctx->channels = channels;\n  ctx->sample_size = sample_size;\n  ctx->buffer_size = buffer_size;\n  ctx->state = ADC_AD559X_STATE_READING;\n  ctx->ctx.type = OS_CONTEXT_TYPE_ADC_AD559X;\n  ctx->ctx.device = dev;\n  ctx->ctx.callback = adc_ad559x_read_callback;\n  os_context_start(&ctx->ctx);\n\n  /* Wait for the read operation to complete. */\n  os_eventq", "CodeBleu_score": 51.08419889787908}, {"code": "static int adc_ad559x_start_read(const struct device *dev, const struct adc_sequence *sequence)    struct adc_ad559x_data *data = dev->data;\n    int ret;\n\n    /* Check if the resolution of the ADC sequence matches the expected resolution */\n    if (sequence->resolution != data->resolution) {\n        LOG_ERR(\"Invalid resolution %d\", sequence->resolution);\n        return -EINVAL;\n    }\n\n    /* Check if the specified channels are valid */\n    for (int i = 0; i < sequence->length; i++) {\n        if (sequence->channels[i] >= data->num_channels) {\n            LOG_ERR(\"Invalid channel %d\", sequence->channels[i]);\n            return -EINVAL;\n        }\n    }\n\n    /* Validate the buffer size for the ADC read */\n    if (sequence->buffer_size < sequence->length * sizeof(uint16_t)) {\n        LOG_ERR(\"Insufficient buffer size\");\n        return -ENOMEM;\n    }\n\n    /* Set the buffer and start the ADC read context */\n    data->buffer = sequence->buffer;\n    ret = adc_ad559x_start_read_context(data);\n    if (ret) {\n        return ret;\n    }\n\n    /* Wait for the read operation to complete */\n    k_sem_take(&data->read_sem, K_FOREVER);\n    return 0;\n}\n", "CodeBleu_score": 62.643828206242745}]}
{"instance_id": "340abb79f057", "generation_result": [{"code": "static void adc_context_start_sampling(struct adc_context *ctx)    struct adc_data *data = ctx->data;\n    uint32_t channels = ctx->channels;\n\n    // Set the channels to be sampled\n    adc_set_channels(data, channels);\n\n    // Initialize the repeat buffer with the data buffer\n    adc_init_repeat_buffer(data, ctx->buffer, ctx->buffer_size);\n\n    // Release the semaphore to signal the start of sampling\n    sem_release(ctx->semaphore);\n}\n", "CodeBleu_score": 40.09775243453074}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)    struct adc_data *data = ctx->data;\n    adc_set_channels(data, ctx->channels, ctx->num_channels);\n    adc_repeat_buffer_init(data, ctx->buffer, ctx->buffer_size);\n    xSemaphoreGive(ctx->semaphore);\n}\n", "CodeBleu_score": 40.17024588152616}, {"code": "static void adc_context_start_sampling(struct adc_context *ctx)    struct adc_data *data = ctx->data;\n    struct adc_repeat_buffer *buffer = &ctx->buffer;\n    int i;\n\n    /* Set the channels to be sampled */\n    adc_set_channels(data, data->channels);\n\n    /* Initialize the repeat buffer */\n    buffer->num_samples = data->num_samples;\n    buffer->num_channels = data->num_channels;\n    buffer->num_samples_left = data->num_samples;\n    buffer->buffer = data->buffer;\n    buffer->buffer_size = data->buffer_size;\n    buffer->buffer_index = 0;\n\n    /* Release the semaphore to signal the start of sampling */\n    xSemaphoreGive(ctx->semaphore);\n}\n", "CodeBleu_score": 46.081793755612274}]}
{"instance_id": "448704e208e1", "generation_result": [{"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    if (repeat_sampling) {\n        ctx->adc_data->buffer_pointer = ctx->adc_data->repeat_buffer;\n    }\n}\n", "CodeBleu_score": 48.90213727992737}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    struct adc_data_container *data_container = ctx->data_container;\n    if (repeat_sampling) {\n        data_container->buffer_pointer = data_container->repeat_buffer;\n    }\n}\n", "CodeBleu_score": 40.71473404366676}, {"code": "static void adc_context_update_buffer_pointer(struct adc_context *ctx, bool repeat_sampling)    if (repeat_sampling) {\n        ctx->adc_data->buffer_pointer = ctx->adc_data->repeat_buffer;\n    } else {\n        ctx->adc_data->buffer_pointer = ctx->adc_data->buffer;\n    }\n}\n", "CodeBleu_score": 49.42940663613155}]}
{"instance_id": "d2f0366c9355", "generation_result": [{"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)  // Initialize the semaphore\n  sem_init(&data->sem, 0, 0);\n\n  // Continuously acquire data in a loop\n  while (true) {\n    // Wait for the semaphore to be released\n    sem_wait(&data->sem);\n\n    // Iterate through the active channels\n    for (int i = 0; i < data->num_channels; i++) {\n      if (data->channels[i].active) {\n        // Read the ADC value\n        int16_t value;\n        if (adc_ad559x_read_adc_value(data, data->channels[i].channel, &value) != 0) {\n          // Log an error and mark the ADC context as complete\n          dev_err(&data->client->dev, \"Failed to read ADC value for channel %d\\n\", data->channels[i].channel);\n          data->complete = true;\n          break;\n        }\n\n        // Store the result in the buffer\n        data->buffer[data->buffer_index++] = value;\n      }\n    }\n\n    // Signal that the sampling is done\n    data->sampling_done = true;\n  }\n}\n", "CodeBleu_score": 32.560138278218616}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)    while (true) {\n        /* Wait for semaphore to be released */\n        k_sem_take(&data->sem, K_FOREVER);\n\n        /* Iterate through active channels */\n        for (int i = 0; i < data->num_channels; i++) {\n            if (data->active_channels[i]) {\n                /* Read ADC value */\n                uint16_t adc_value;\n                int err = adc_ad559x_read_adc(data, i, &adc_value);\n                if (err) {\n                    LOG_ERR(\"Failed to read ADC value for channel %d: %d\", i, err);\n                    data->complete = true;\n                    break;\n                }\n\n                /* Store ADC value in buffer */\n                data->adc_buffer[i] = adc_value;\n            }\n        }\n\n        /* Signal that the sampling is done */\n        k_sem_give(&data->sem);\n    }\n}", "CodeBleu_score": 36.222360695493045}, {"code": "static void adc_ad559x_acquisition_thread(struct adc_ad559x_data *data)  struct adc_ad559x_channel *channel;\n  int ret;\n\n  while (1) {\n    // Wait for a semaphore to be released\n    k_sem_take(&data->sem, K_FOREVER);\n\n    // Iterate through the active channels\n    for (int i = 0; i < data->channels_num; i++) {\n      channel = &data->channels[i];\n\n      // Read the ADC value for the channel\n      ret = adc_ad559x_read(data, channel);\n      if (ret) {\n        LOG_ERR(\"Failed to read ADC value for channel %d\", channel->channel_id);\n        data->complete = 1;\n        break;\n      }\n    }\n\n    // Signal that the sampling is done\n    k_sem_give(&data->sem);\n  }\n}", "CodeBleu_score": 40.19355476218208}]}
{"instance_id": "f1cb41e44045", "generation_result": [{"code": "static int ads1112_wait_data_ready(const struct device *dev)    k_sleep(K_MSEC(ADS1112_READY_TIME_MS));\n\n    uint16_t reg_val;\n    int err = ads1112_read_register(dev, ADS1112_REG_CONFIG, &reg_val);\n    if (err) {\n        return err;\n    }\n\n    if (reg_val & ADS1112_REG_CONFIG_OS) {\n        return 0;\n    }\n\n    while (1) {\n        k_sleep(K_USEC(100));\n\n        err = ads1112_read_register(dev, ADS1112_REG_CONFIG, &reg_val);\n        if (err) {\n            return err;\n        }\n\n        if (reg_val & ADS1112_REG_CONFIG_OS) {\n            return 0;\n        }\n    }\n}\n", "CodeBleu_score": 43.214161737758495}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    k_sleep(K_MSEC(ADS1112_DEVICE_READY_TIME));\n\n    uint8_t config_reg;\n    int err = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config_reg);\n    if (err) {\n        return err;\n    }\n\n    while (!(config_reg & ADS1112_CONFIG_DR)) {\n        k_sleep(K_USEC(100));\n\n        err = ads1112_read_register(dev, ADS1112_REG_CONFIG, &config_reg);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 45.58089420733001}, {"code": "static int ads1112_wait_data_ready(const struct device *dev)    int err;\n    uint8_t reg;\n    struct ads1112_data *data = dev->data;\n\n    k_sleep(data->ready_time);\n    err = i2c_reg_read_byte_dt(&data->i2c, ADS1112_REG_CONFIG, &reg);\n    if (err) {\n        return err;\n    }\n\n    while (!(reg & ADS1112_REG_CONFIG_RDY)) {\n        k_sleep(100);\n        err = i2c_reg_read_byte_dt(&data->i2c, ADS1112_REG_CONFIG, &reg);\n        if (err) {\n            return err;\n        }\n    }\n\n    return 0;\n}\n", "CodeBleu_score": 54.60619268731127}]}
{"instance_id": "01f9112959db", "generation_result": [{"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)  // Calculate the required buffer size based on the number of samplings\n  uint16_t required_buffer_size = sequence->length * sequence->resolution / 8;\n\n  // Check if the buffer size is sufficient\n  if (sequence->buffer_size < required_buffer_size) {\n    LOG_ERR(\"Insufficient buffer size for %d samplings\", sequence->length);\n    return -ENOMEM;\n  }\n\n  return 0;\n}", "CodeBleu_score": 37.43655785722467}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)    int buffer_size;\n    int required_buffer_size;\n    int extra_samplings;\n    int extra_samplings_multiplier;\n\n    /* Calculate the required buffer size based on the number of samplings */\n    required_buffer_size = sequence->length * 2;\n\n    /* Calculate the number of extra samplings */\n    extra_samplings = sequence->options & ADC_SEQUENCE_OPT_CONTINUOUS;\n\n    /* Calculate the multiplier for the extra samplings */\n    extra_samplings_multiplier = extra_samplings ? 2 : 1;\n\n    /* Calculate the buffer size based on the required buffer size and the multiplier for the extra samplings */\n    buffer_size = required_buffer_size * extra_samplings_multiplier;\n\n    /* Check if the buffer size is sufficient */\n    if (buffer_size > sequence->buffer_size) {\n        /* Log an error message */\n        LOG_ERR(\"Buffer size %d is too small for %d samplings\",\n                sequence->buffer_size, required_buffer_size);\n\n        /* Return an error code */\n        return -ENOMEM;\n    }\n\n    /* Return 0 indicating the buffer size is sufficient */\n    return 0;\n}", "CodeBleu_score": 46.33192332304175}, {"code": "static int ads1112_validate_buffer_size(const struct adc_sequence *sequence)  int buffer_size = sequence->length * 2;\n  int extra_samplings = sequence->options & ADS1112_SEQ_OPT_EXTRA_SAMPLINGS;\n\n  if (buffer_size < extra_samplings) {\n    LOG_ERR(\"Buffer size is too small for %d samplings\", sequence->length);\n    return -EINVAL;\n  }\n\n  return 0;\n}", "CodeBleu_score": 33.62842792269407}]}
{"instance_id": "9cda505dbdf6", "generation_result": [{"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tint ret;\n\n\tif (sequence->options & ADC_OPTION_CYCLE_TIME) {\n\t\tLOG_ERR(\"ADC cycle time not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_CONTINUOUS) {\n\t\tLOG_ERR(\"Continuous mode not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_SCAN_ERROR) {\n\t\tLOG_ERR(\"Scan error not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_STOP_ON_FIRST_ERROR) {\n\t\tLOG_ERR(\"Stop on first error not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_STOP_ON_SECOND_ERROR) {\n\t\tLOG_ERR(\"Stop on second error not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_STOP_ON_THIRD_ERROR) {\n\t\tLOG_ERR(\"Stop on third error not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_STOP_ON_ERROR) {\n\t\tLOG_ERR(\"Stop on error not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_START_ON_PREV_CONVST) {\n\t\tLOG_ERR(\"Start on previous convst not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_START_ON_PREV_SAMPLE) {\n\t\tLOG_ERR(\"Start on previous sample not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_START_ON_PREV_CH) {\n\t\tLOG_ERR(\"Start on previous channel not supported\");\n\t\treturn -ENOTSUP;\n\t}\n\n\tif (sequence->options & ADC_OPTION_START_ON_FIRST_CONV", "CodeBleu_score": 30.22847004218893}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tint ret = 0;\n\tuint8_t sequence_buffer[ADS1112_SEQUENCE_BUFFER_SIZE];\n\tuint8_t sequence_buffer_size = ADS1112_SEQUENCE_BUFFER_SIZE;\n\n\tret = ads1112_validate_sequence(dev, sequence, &sequence_buffer, &sequence_buffer_size);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = ads1112_set_data(dev, sequence_buffer, sequence_buffer_size);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tret = ads1112_start_read(dev);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tif (wait) {\n\t\tret = ads1112_wait_for_read(dev);\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 47.10046529683608}, {"code": "static int ads1112_adc_start_read(const struct device *dev, const struct adc_sequence *sequence,\n\t\t\t\t  bool wait)\tint ret;\n\n\tret = ads1112_validate_sequence(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = ads1112_set_data(dev, sequence);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tret = ads1112_start_read(dev, wait);\n\tif (ret < 0) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 42.96323259517204}]}
{"instance_id": "3a203b1c5978", "generation_result": [{"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])\tint ret;\n\tstruct audio_codec_device *dev;\n\n\tif (argc != 2) {\n\t\tshell_error(sh, \"Usage: apply_prop <codec_id>\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tdev = audio_codec_get_device(argv[1]);\n\tif (!dev) {\n\t\tshell_error(sh, \"Device not found\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tret = audio_codec_apply_properties(dev);\n\tif (ret) {\n\t\tshell_error(sh, \"Failed to apply properties\");\n\t}\n\n\treturn ret;\n}\n", "CodeBleu_score": 57.081496168058386}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])    struct device *dev;\n    int err;\n\n    if (argc < 2) {\n        shell_error(sh, \"Usage: %s <device>\", argv[0]);\n        return -ENOEXEC;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device not found: %s\", argv[1]);\n        return -ENOEXEC;\n    }\n\n    err = audio_codec_apply_properties(dev);\n    if (err) {\n        shell_error(sh, \"Failed to apply properties: %d\", err);\n        return err;\n    }\n\n    shell_print(sh, \"Properties applied successfully\");\n    return 0;\n}\n", "CodeBleu_score": 53.96139117171679}, {"code": "static int cmd_apply_prop(const struct shell *sh, size_t argc, char *argv[])    struct device *dev;\n    int ret;\n    struct audio_codec_property_value prop_value;\n\n    if (argc < 3) {\n        shell_error(sh, \"Missing argument\");\n        return -ENOENT;\n    }\n\n    dev = device_get_binding(argv[1]);\n    if (!dev) {\n        shell_error(sh, \"Device not found: %s\", argv[1]);\n        return -ENODEV;\n    }\n\n    ret = audio_codec_apply_property(dev, argv[2], &prop_value);\n    if (ret) {\n        shell_error(sh, \"Failed to apply property: %s\", argv[2]);\n        return ret;\n    }\n\n    shell_print(sh, \"Property applied successfully\");\n    return 0;\n}", "CodeBleu_score": 53.14389611994832}]}
{"instance_id": "b295ed6b5753", "generation_result": [{"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)    struct mpxxdtyy_dev_data *dev_data = dev->data;\n    int ret;\n\n    if (cmd == DMIC_TRIGGER_START) {\n        if (dev_data->state == MPXXDTYY_STATE_CONFIGURED) {\n            /* Send the I2S command to start the device */\n            ret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_I2S_START);\n            if (ret == 0) {\n                dev_data->state = MPXXDTYY_STATE_ACTIVE;\n            } else {\n                LOG_ERR(\"Failed to start device (%d)\", ret);\n            }\n        } else {\n            LOG_ERR(\"Device is not in configured state\");\n            ret = -EINVAL;\n        }\n    } else if (cmd == DMIC_TRIGGER_STOP) {\n        if (dev_data->state == MPXXDTYY_STATE_ACTIVE) {\n            /* Send the I2S command to stop the device */\n            ret = mpxxdtyy_i2s_send_command(dev, MPXXDTYY_I2S_STOP);\n            if (ret == 0) {\n                dev_data->state = MPXXDTYY_STATE_CONFIGURED;\n            } else {\n                LOG_ERR(\"Failed to stop device (%d)\", ret);\n            }\n        } else {\n            LOG_ERR(\"Device is not in active state\");\n            ret = -EINVAL;\n        }\n    } else {\n        LOG_ERR(\"Invalid trigger command\");\n        ret = -EINVAL;\n    }\n\n    return ret;\n}", "CodeBleu_score": 33.93897385504421}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)  struct mpxxdtyy_data *data = dev->data;\n  int ret;\n\n  switch (cmd) {\n    case DMIC_TRIGGER_START:\n      if (data->state == MPXXDYY_STATE_CONFIGURED) {\n        ret = mpxxdtyy_i2s_send_cmd(data, MPXXDYY_I2S_CMD_START);\n        if (ret == 0) {\n          data->state = MPXXDYY_STATE_ACTIVE;\n        } else {\n          LOG_ERR(\"Failed to send start command (%d)\", ret);\n        }\n      } else {\n        LOG_ERR(\"Invalid state transition (%d -> %d)\", data->state, MPXXDYY_STATE_ACTIVE);\n        ret = -EINVAL;\n      }\n      break;\n\n    case DMIC_TRIGGER_STOP:\n      if (data->state == MPXXDYY_STATE_ACTIVE) {\n        ret = mpxxdtyy_i2s_send_cmd(data, MPXXDYY_I2S_CMD_STOP);\n        if (ret == 0) {\n          data->state = MPXXDYY_STATE_CONFIGURED;\n        } else {\n          LOG_ERR(\"Failed to send stop command (%d)\", ret);\n        }\n      } else {\n        LOG_ERR(\"Invalid state transition (%d -> %d)\", data->state, MPXXDYY_STATE_CONFIGURED);\n        ret = -EINVAL;\n      }\n      break;\n\n    default:\n      LOG_ERR(\"Unsupported command (%d)\", cmd);\n      ret = -EINVAL;\n      break;\n  }\n\n  return ret;\n}\n", "CodeBleu_score": 53.65460281916805}, {"code": "int mpxxdtyy_i2s_trigger(const struct device *dev, enum dmic_trigger cmd)  struct mpxxdtyy_data *data = dev->data;\n  int ret;\n  uint8_t i2s_cmd;\n\n  /* Check if the device is in the configured state */\n  if (data->state != MPXXDYY_STATE_CONFIGURED) {\n    LOG_ERR(\"Device not in configured state\");\n    return -EINVAL;\n  }\n\n  /* Set the I2S command based on the DMIC trigger command */\n  switch (cmd) {\n    case DMIC_TRIGGER_START:\n      i2s_cmd = MPXXDYY_I2S_CMD_START;\n      break;\n    case DMIC_TRIGGER_STOP:\n      i2s_cmd = MPXXDYY_I2S_CMD_STOP;\n      break;\n    default:\n      LOG_ERR(\"Invalid DMIC trigger command\");\n      return -EINVAL;\n  }\n\n  /* Send the I2S command */\n  ret = mpxxdtyy_i2s_cmd(data, i2s_cmd);\n  if (ret < 0) {\n    LOG_ERR(\"Failed to send I2S command\");\n    return ret;\n  }\n\n  /* Update the device state */\n  data->state = MPXXDYY_STATE_ACTIVE;\n\n  return 0;\n}", "CodeBleu_score": 50.42927060136086}]}
{"instance_id": "eee6d909504a", "generation_result": [{"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)    const struct auxdisplay_hd44780_config *config = dev->config;\n    struct auxdisplay_hd44780_data *data = dev->data;\n\n    uint8_t command = config->display_mode_command;\n\n    if (data->cursor_enabled) {\n        command |= config->display_mode_cursor_on;\n    }\n\n    if (data->blink_enabled) {\n        command |= config->display_mode_blink_on;\n    }\n\n    if (enabled) {\n        command |= config->display_mode_display_on;\n    }\n\n    data->command = command;\n    data->display_enabled = enabled;\n\n    auxdisplay_hd44780_send_command(dev);\n}\n", "CodeBleu_score": 56.14260979333123}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)    struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t command = 0;\n\n    /* Retrieve the current configuration */\n    auxdisplay_hd44780_read_configuration(dev, &data->config);\n\n    /* Set the display mode command */\n    command |= data->config.display_mode;\n    if (enabled) {\n        command |= HD44780_DISPLAY_ON;\n    }\n\n    /* Set the cursor and blink settings */\n    if (data->config.cursor_enabled) {\n        command |= HD44780_CURSOR_ON;\n    }\n    if (data->config.blink_enabled) {\n        command |= HD44780_BLINK_ON;\n    }\n\n    /* Send the command to the device */\n    auxdisplay_hd44780_write_command(dev, command);\n}\n", "CodeBleu_score": 54.717234625097}, {"code": "static void auxdisplay_hd44780_set_display_mode(const struct device *dev, bool enabled)    const struct auxdisplay_hd44780_data *data = dev->data;\n    uint8_t command = 0;\n\n    if (enabled) {\n        command |= data->config->display_mode;\n    }\n\n    if (data->config->cursor_enabled) {\n        command |= data->config->cursor_blink_mode;\n    }\n\n    if (data->config->cursor_enabled && data->config->cursor_blink_mode) {\n        command |= data->config->cursor_position_mode;\n    }\n\n    data->config->display_mode_command = command;\n\n    auxdisplay_hd44780_send_command(dev, data->config->display_mode_command);\n}\n", "CodeBleu_score": 41.688728077947054}]}
{"instance_id": "dd0550888382", "generation_result": [{"code": "static int auxdisplay_itron_is_busy(const struct device *dev)    const struct auxdisplay_itron_config *config = dev->config;\n    int ret = 0;\n\n    if (!config->busy_gpio_port) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to get busy GPIO pin status (%d)\", ret);\n        return ret;\n    }\n\n    return ret;\n}\n", "CodeBleu_score": 59.217650193293345}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)    const struct auxdisplay_itron_config *cfg = dev->config;\n    int ret;\n\n    if (cfg->busy_gpio_port == NULL) {\n        return -ENOTSUP;\n    }\n\n    ret = gpio_pin_get(cfg->busy_gpio_port, cfg->busy_gpio_pin);\n    if (ret < 0) {\n        LOG_ERR(\"Failed to read busy GPIO pin (%d)\", ret);\n        return ret;\n    }\n\n    return ret;\n}\n", "CodeBleu_score": 59.3723552284839}, {"code": "static int auxdisplay_itron_is_busy(const struct device *dev)    const struct auxdisplay_itron_config *config = dev->config;\n\n    if (!config->busy_gpio_port) {\n        return -ENOTSUP;\n    }\n\n    return gpio_pin_get(config->busy_gpio_port, config->busy_gpio_pin);\n}\n", "CodeBleu_score": 38.61042898158201}]}
{"instance_id": "002c18770a96", "generation_result": [{"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tconst struct auxdisplay_serlcd_config *cfg = dev->config;\n\tuint8_t buf[2];\n\n\tbuf[0] = cfg->special_command_prefix;\n\tbuf[1] = command;\n\n\treturn i2c_write(dev->config->i2c_dev, buf, sizeof(buf), cfg->i2c_addr);\n}\n", "CodeBleu_score": 51.70430301774369}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\n  struct auxdisplay_serlcd_config *config = dev->config;\n\n  uint8_t buffer[2] = {config->special_command_prefix, command};\n\n  int err = i2c_write_blocking(config->i2c, config->address, buffer, sizeof(buffer), false);\n\n  if (err < 0) {\n    LOG_ERR(\"i2c_write_blocking failed with error %d\", err);\n    return err;\n  }\n\n  k_sleep(K_MSEC(config->delay_after_special_command));\n\n  return 0;\n}\n", "CodeBleu_score": 48.0148755384503}, {"code": "static int\nauxdisplay_serlcd_send_special_command(const struct device *dev,\n\t\t\t\t       const enum auxdisplay_serlcd_special_command command)\tint err;\n\tuint8_t buffer[2];\n\n\tbuffer[0] = AUXDISPLAY_SERLCD_SPECIAL_COMMAND_PREFIX;\n\tbuffer[1] = command;\n\n\terr = i2c_write(dev, buffer, sizeof(buffer), AUXDISPLAY_SERLCD_SPECIAL_COMMAND_DELAY);\n\n\treturn err;\n}\n", "CodeBleu_score": 44.849873342087875}]}
{"instance_id": "2ca0632c091f", "generation_result": [{"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\n\t/* Check if the requested read size is valid */\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the read operation does not exceed the memory bounds */\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the read operation does not involve invalid memory */\n\tif (offset + size < offset) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tmemcpy(data, &bbram_emul_mem[offset], size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 40.4204642795786}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)\t/* Check if the requested read size is valid */\n\tif (size == 0 || size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation does not exceed the memory bounds */\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the read operation involves invalid memory */\n\tif (offset + size < offset) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Copy the data from the specified offset in the device's memory to the provided buffer */\n\tmemcpy(data, &bbram_emul_memory[offset], size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 40.62355580711032}, {"code": "static int bbram_emul_read(const struct device *dev, size_t offset, size_t size,\n\t\t\t   uint8_t *data)    const struct bbram_emul_cfg *cfg = dev->config;\n\n    if (offset + size > cfg->size) {\n        return -EINVAL;\n    }\n\n    if (data == NULL) {\n        return -EINVAL;\n    }\n\n    memcpy(data, cfg->mem + offset, size);\n\n    return 0;\n}\n", "CodeBleu_score": 52.031614509758704}]}
{"instance_id": "3b60b1b563c7", "generation_result": [{"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\n\t/* Check if the write size is valid */\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is in an invalid state */\n\tif (bbram_emul_is_invalid(dev)) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tmemcpy(bbram_emul_get_mem(dev) + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 54.71172786953379}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\t/* Check if the write size is valid */\n\tif (size == 0 || size > BBRAM_EMUL_MAX_WRITE_SIZE) {\n\t\tLOG_ERR(\"Invalid write size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\tLOG_ERR(\"Write operation out of bounds\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is in an invalid state */\n\tif (bbram_emul_state == BBRAM_EMUL_STATE_INVALID) {\n\t\tLOG_ERR(\"BBRAM in invalid state\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tmemcpy(bbram_emul_memory + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 49.660286142534694}, {"code": "static int bbram_emul_write(const struct device *dev, size_t offset, size_t size,\n\t\t\t    const uint8_t *data)\t/* Check if the write size is valid */\n\tif (size == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the write operation stays within the bounds of the BBRAM */\n\tif (offset + size > BBRAM_EMUL_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check if the BBRAM is in an invalid state */\n\tstruct bbram_emul_data *bbram_data = dev->data;\n\tif (bbram_data->state == BBRAM_EMUL_STATE_INVALID) {\n\t\treturn -EIO;\n\t}\n\n\t/* Copy the data to the specified offset within the device's memory */\n\tmemcpy(bbram_data->mem + offset, data, size);\n\n\treturn 0;\n}\n", "CodeBleu_score": 61.25110453121248}]}
{"instance_id": "95c2cd7f3153", "generation_result": [{"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tif (argc != 2) {\n\t\tshell_error(sh, \"Missing argument for BBRAM device\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device %s not found\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 76.3276555557}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tint err;\n\n\tif (argc < 2) {\n\t\tshell_error(sh, \"Missing device name\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tshell_error(sh, \"Device not found: %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = device_get_binding_int(*bbram_dev, \"bbram\", bbram_dev);\n\tif (err) {\n\t\tshell_error(sh, \"Device is not a BBRAM device: %s\", argv[1]);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 69.22452601790539}, {"code": "static inline int parse_device(const struct shell *sh, size_t argc, char *argv[],\n\t\t\t       const struct device **bbram_dev)\tint err;\n\n\tif (argc < 2) {\n\t\tLOG_ERR(\"Missing device argument\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bbram_dev = device_get_binding(argv[1]);\n\tif (*bbram_dev == NULL) {\n\t\tLOG_ERR(\"Device not found: %s\", argv[1]);\n\t\treturn -ENODEV;\n\t}\n\n\terr = device_get_binding_int(*bbram_dev, \"bbram\", bbram_dev);\n\tif (err) {\n\t\tLOG_ERR(\"Device does not support BBRAM: %s\", argv[1]);\n\t\treturn -ENOTSUP;\n\t}\n\n\treturn 0;\n}\n", "CodeBleu_score": 61.69817604070222}]}
{"instance_id": "6cdfd96fdf39", "generation_result": [{"code": "static void h4_read_hdr(const struct device *dev)    uint8_t *hdr = h4_get_hdr_buf();\n    uint8_t hdr_len = h4_get_hdr_len();\n    uint8_t *hdr_end = hdr + hdr_len;\n    uint8_t *hdr_ptr = hdr;\n    uint16_t rx_len = h4_get_rx_len();\n    uint16_t rx_len_rem = rx_len - hdr_len;\n\n    while (hdr_ptr < hdr_end) {\n        int rc = uart_fifo_read(dev, hdr_ptr, hdr_end - hdr_ptr);\n        if (rc < 0) {\n            printk(\"h4_read_hdr: uart_fifo_read failed (%d)\\n\", rc);\n            return;\n        }\n        hdr_ptr += rc;\n    }\n\n    h4_set_rx_len_rem(rx_len_rem - (hdr_ptr - hdr));\n}\n", "CodeBleu_score": 25.945636598833392}, {"code": "static void h4_read_hdr(const struct device *dev)    uint32_t read_bytes = 0;\n    uint32_t bytes_to_read = sizeof(struct h4_hdr);\n\n    while (read_bytes < bytes_to_read) {\n        int ret = uart_fifo_read(dev, &hdr_buf[read_bytes], bytes_to_read - read_bytes);\n        if (ret < 0) {\n            LOG_ERR(\"Failed to read header data from UART device\");\n            return;\n        }\n        read_bytes += ret;\n    }\n\n    bytes_to_read -= read_bytes;\n    hdr_buf_len += read_bytes;\n}\n", "CodeBleu_score": 30.05472430183835}, {"code": "static void h4_read_hdr(const struct device *dev)    // Calculate the number of bytes already read\n    int read_bytes = h4_hdr_len - h4_hdr_read;\n\n    // Attempt to read the remaining bytes from the UART FIFO into the header buffer\n    int ret = uart_fifo_read(dev, &h4_hdr[h4_hdr_read], read_bytes);\n\n    // If the read operation fails, log an error message\n    if (ret < 0) {\n        printk(\"uart_fifo_read failed: %d\\n\", ret);\n        return;\n    }\n\n    // Update the remaining byte count based on the number of bytes successfully read\n    h4_hdr_read += ret;\n}\n", "CodeBleu_score": 22.134842659633662}]}
{"instance_id": "8a01405af8b4", "generation_result": [{"code": "static size_t h4_discard(const struct device *uart, size_t len)    uint8_t buf[33];\n    size_t n = uart_fifo_read(uart, buf, len);\n    if (n != len) {\n        LOG_ERR(\"failed to discard %zu bytes from UART\", len);\n    }\n    return n;\n}", "CodeBleu_score": 39.90245383914095}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)    uint8_t buf[33];\n    int rc;\n    size_t n = 0;\n\n    while (len > 0) {\n        size_t nr = len > 32 ? 32 : len;\n\n        rc = uart_fifo_read(uart, buf, nr);\n        if (rc < 0) {\n            LOG_ERR(\"Failed to read from UART: %d\", rc);\n            return 0;\n        }\n\n        n += rc;\n        len -= rc;\n    }\n\n    return n;\n}", "CodeBleu_score": 37.01815033116505}, {"code": "static size_t h4_discard(const struct device *uart, size_t len)    uint8_t buf[33];\n    size_t ret = 0;\n\n    while (len > 0) {\n        size_t to_read = len;\n\n        if (to_read > sizeof(buf)) {\n            to_read = sizeof(buf);\n        }\n\n        size_t r = uart_fifo_read(uart, buf, to_read);\n        if (r == 0) {\n            LOG_ERR(\"Failed to read from UART\");\n            return 0;\n        }\n\n        len -= r;\n        ret += r;\n    }\n\n    return ret;\n}\n", "CodeBleu_score": 33.10460599316482}]}
{"instance_id": "7b511ed0717b", "generation_result": [{"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    struct zbus_channel_data *data = chan->data;\n    struct zbus_channel_observer *obs = data->observers;\n    struct zbus_channel_observer *hop = obs;\n\n    pthread_mutex_lock(&data->lock);\n\n    while (obs) {\n        if (obs->priority < hop->priority && obs->enabled) {\n            hop = obs;\n        }\n        obs = obs->next;\n    }\n\n    data->hop = hop;\n\n    pthread_mutex_unlock(&data->lock);\n}\n", "CodeBleu_score": 22.02660126547482}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)\tuint8_t highest = UINT8_MAX;\n\n\tzbus_chan_lock(chan);\n\tfor (size_t i = 0; i < chan->observers_count; i++) {\n\t\tconst struct zbus_observer *observer = &chan->observers[i];\n\t\tif (observer->priority < highest && observer->enabled)\n\t\t\thighest = observer->priority;\n\t}\n\tzbus_chan_unlock(chan);\n\n\tchan->highest_observer_priority = highest;\n}\n", "CodeBleu_score": 20.937976575581736}, {"code": "static inline void chan_update_hop(const struct zbus_channel *chan)    struct zbus_channel_data *data = chan->data;\n    struct zbus_observer *observer;\n    struct zbus_observer *highest_observer = NULL;\n    uint32_t highest_priority = UINT32_MAX;\n\n    pthread_mutex_lock(&data->mutex);\n\n    zlist_foreach(data->observers, observer) {\n        if (!observer->enabled) {\n            continue;\n        }\n\n        if (observer->priority < highest_priority) {\n            highest_priority = observer->priority;\n            highest_observer = observer;\n        }\n    }\n\n    data->hop = highest_observer;\n\n    pthread_mutex_unlock(&data->mutex);\n}\n", "CodeBleu_score": 24.720721916365523}]}
{"instance_id": "30e09ece8d6e", "generation_result": [{"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct zbus_channel_observation *obs_iter;\n    zbus_channel_observations_foreach(obs_iter) {\n        if (obs_iter->observer == obs) {\n            update_channel_hop(obs_iter->channel);\n        }\n    }\n}\n", "CodeBleu_score": 24.921225437480896}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)  struct zbus_channel *ch;\n  zbus_foreach_channel(ch) {\n    if (zbus_channel_is_observed_by(ch, obs))\n      update_channel_hop(ch);\n  }\n}\n", "CodeBleu_score": 19.564716842144076}, {"code": "static inline void update_all_channels_hop(const struct zbus_observer *obs)    struct channel_observation *cobs;\n    struct channel_observation *next;\n    for (cobs = channel_observations; cobs != NULL; cobs = next) {\n        next = cobs->next;\n        if (cobs->observer == obs) {\n            update_channel_hop(cobs);\n        }\n    }\n}\n", "CodeBleu_score": 19.570959490465338}]}
{"instance_id": "5de039f79429", "generation_result": [{"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)  assert(obs != NULL);\n  assert(obs->thread == NULL);\n  zbus_lock();\n  obs->priority = zbus_get_min_thread_priority();\n  zbus_unlock();\n  return 0;\n}", "CodeBleu_score": 14.006073107227726}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)  assert(!zbus_is_isr());\n  assert(obs);\n\n  zbus_lock();\n  obs->priority = zbus_thread_min_priority();\n  for (size_t i = 0; i < obs->channels_count; i++) {\n    struct zbus_channel *ch = obs->channels[i];\n    ch->observers_count++;\n    if (ch->observers_count == 1) {\n      ch->observers[0] = obs;\n    }\n  }\n  zbus_unlock();\n\n  return 0;\n}", "CodeBleu_score": 33.848229404841184}, {"code": "int zbus_obs_attach_to_thread(const struct zbus_observer *obs)    assert(obs != NULL);\n    assert(!zbus_in_isr());\n    zbus_lock();\n    obs->priority = zbus_get_min_thread_priority();\n    for (int i = 0; i < obs->channel_count; i++) {\n        zbus_channel_update(obs->channels[i]);\n    }\n    zbus_unlock();\n    return 0;\n}", "CodeBleu_score": 35.894005140503786}]}
{"instance_id": "b8019727be92", "generation_result": [{"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)  assert(chan != NULL);\n  if (timeout == K_FOREVER) {\n    timeout = K_FOREVER;\n  } else {\n    if (timeout == 0) {\n      timeout = 1;\n    }\n    timeout += k_uptime_get();\n  }\n  k_mutex_lock(&chan->mutex, K_FOREVER);\n  int err = zbus_chan_notify_locked(chan, timeout);\n  k_mutex_unlock(&chan->mutex);\n  return err;\n}\n", "CodeBleu_score": 40.54628556559455}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)  assert(chan != NULL);\n  if (timeout == K_FOREVER) {\n    timeout = K_FOREVER;\n  } else if (timeout == 0) {\n    timeout = K_NO_WAIT;\n  } else {\n    timeout = k_uptime_get() + timeout;\n  }\n  int err;\n  if (chan->ctx.base.is_isr) {\n    timeout = K_FOREVER;\n  }\n  k_mutex_lock(&chan->lock, timeout);\n  err = zbus_chan_notify_locked(chan);\n  k_mutex_unlock(&chan->lock);\n  return err;\n}\n", "CodeBleu_score": 44.254547770738064}, {"code": "int zbus_chan_notify(const struct zbus_channel *chan, k_timeout_t timeout)  int err;\n  k_timeout_t end_time;\n  struct zbus_channel_ctx *ctx;\n\n  if (chan == NULL) {\n    return -EINVAL;\n  }\n\n  if (in_isr()) {\n    timeout = k_us_to_ticks_ceil32(timeout);\n  }\n\n  end_time = k_uptime_get() + timeout;\n  ctx = &chan->ctx;\n\n  k_mutex_lock(&ctx->lock, K_FOREVER);\n\n  err = zbus_chan_notify_locked(chan, end_time);\n\n  k_mutex_unlock(&ctx->lock);\n\n  return err;\n}\n", "CodeBleu_score": 35.778440285403256}]}
{"instance_id": "e7a90af304f1", "generation_result": [{"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)  uint32_t tmp;\n\n  /* Check the parameters */\n  assert_param(IS_ETH_INT_OK(Int));\n\n  /* Configure the Ethernet interrupt */\n  if (enable != DISABLE) {\n    /* Enable the Ethernet interrupt */\n    tmp = ETH->IMR;\n    tmp |= Int;\n    ETH->IMR = tmp;\n\n    /* Check if the interrupt is normal or abnormal */\n    if (Int & ETH_IT_NIS) {\n      /* Enable the normal interrupt */\n      tmp = ETH->NISER;\n      tmp |= Int;\n      ETH->NISER = tmp;\n    } else {\n      /* Enable the abnormal interrupt */\n      tmp = ETH->AISER;\n      tmp |= Int;\n      ETH->AISER = tmp;\n    }\n  } else {\n    /* Disable the Ethernet interrupt */\n    tmp = ETH->IMR;\n    tmp &= ~Int;\n    ETH->IMR = tmp;\n\n    /* Check if the interrupt is normal or abnormal */\n    if (Int & ETH_IT_NIS) {\n      /* Disable the normal interrupt */\n      tmp = ETH->NISER;\n      tmp &= ~Int;\n      ETH->NISER = tmp;\n    } else {\n      /* Disable the abnormal interrupt */\n      tmp = ETH->AISER;\n      tmp &= ~Int;\n      ETH->AISER = tmp;\n    }\n\n    /* Check if any other interrupts are enabled */\n    if ((ETH->IMR & ETH_IT_NIS) || (ETH->AISER)) {\n      /* Disable the abnormal interrupt */\n      tmp = ETH->AISER;\n      tmp &= ~ETH_IT_NIS;\n      ETH->AISER = tmp;\n    } else if ((ETH->IMR & ETH_IT_NIS) || (ETH->NISER)) {\n      /* Disable the normal interrupt */\n      tmp = ETH->NISER;\n      tmp &= ", "CodeBleu_score": 40.919661494690395}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)\tuint32_t temp;\n\n\t/* Check the parameters */\n\tassert_param(IS_ETH_INT_OK(Int));\n\n\tif (enable != DISABLE) {\n\t\t/* Enable the Ethernet interrupt */\n\t\ttemp = ETH->IMR;\n\t\tif (Int == ETH_INT_FRAME) {\n\t\t\t/* Frame interrupt */\n\t\t\ttemp |= ETH_IMR_FRAMEIM;\n\t\t} else if (Int == ETH_INT_TXE) {\n\t\t\t/* Transmit buffer empty interrupt */\n\t\t\ttemp |= ETH_IMR_TXEIM;\n\t\t} else if (Int == ETH_INT_RXF) {\n\t\t\t/* Receive buffer full interrupt */\n\t\t\ttemp |= ETH_IMR_RXFIM;\n\t\t} else if (Int == ETH_INT_TXFE) {\n\t\t\t/* Transmit FIFO empty interrupt */\n\t\t\ttemp |= ETH_IMR_TXFEIM;\n\t\t} else if (Int == ETH_INT_RXFF) {\n\t\t\t/* Receive FIFO full interrupt */\n\t\t\ttemp |= ETH_IMR_RXFFIM;\n\t\t} else if (Int == ETH_INT_TXW) {\n\t\t\t/* Transmit watermark interrupt */\n\t\t\ttemp |= ETH_IMR_TXWIM;\n\t\t} else if (Int == ETH_INT_RXW) {\n\t\t\t/* Receive watermark interrupt */\n\t\t\ttemp |= ETH_IMR_RXWIM;\n\t\t} else if (Int == ETH_INT_TXA) {\n\t\t\t/* Transmit abort interrupt */\n\t\t\ttemp |= ETH_IMR_TXAIM;\n\t\t} else if (Int == ETH_INT_RXA) {\n\t\t\t/* Receive abort interrupt */\n\t\t\ttemp |= ETH_IMR_RXAIM;\n\t\t} else if (Int == ETH_INT_TXD) {\n\t\t\t/* Transmit done interrupt */\n\t\t\ttemp |= ETH_IMR_TXDIM;\n\t\t} else if (Int == ETH_INT_RXD) {\n\t\t\t/* Receive done interrupt */\n\t\t\ttemp |= ETH_IM", "CodeBleu_score": 29.794632811334516}, {"code": "void ETH_ITConfig(uint32_t Int, BOOL enable)  uint32_t it_enable_reg;\n\n  /* Check the parameters */\n  assert_param(IS_ETH_INT_SOURCE(Int));\n\n  /* Get the IT enable register */\n  it_enable_reg = ETH->ITEN;\n\n  /* Check if the interrupt is enabled or disabled */\n  if (enable) {\n    /* Check if the interrupt is normal or abnormal */\n    if (Int == ETH_IT_NIE) {\n      /* Enable the normal interrupt */\n      it_enable_reg |= ETH_IT_NIE_MASK;\n    } else {\n      /* Enable the abnormal interrupt */\n      it_enable_reg |= ETH_IT_AIE_MASK;\n    }\n  } else {\n    /* Disable the specified interrupt */\n    if (Int == ETH_IT_NIE) {\n      /* Clear the normal interrupt */\n      it_enable_reg &= ~ETH_IT_NIE_MASK;\n    } else {\n      /* Clear the abnormal interrupt */\n      it_enable_reg &= ~ETH_IT_AIE_MASK;\n    }\n\n    /* Update the normal and abnormal interrupt enable bits */\n    if ((it_enable_reg & ETH_IT_NIE_MASK) == 0) {\n      /* Disable the normal interrupt enable bit */\n      it_enable_reg &= ~ETH_IT_NIE_MASK;\n    }\n\n    if ((it_enable_reg & ETH_IT_AIE_MASK) == 0) {\n      /* Disable the abnormal interrupt enable bit */\n      it_enable_reg &= ~ETH_IT_AIE_MASK;\n    }\n  }\n\n  /* Set the IT enable register */\n  ETH->ITEN = it_enable_reg;\n}\n", "CodeBleu_score": 37.845221782752375}]}
{"instance_id": "39b1f303c655", "generation_result": [{"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)  ETH_TX_DESC *tx_desc;\n  uint32_t tx_desc_addr = ETH->TX_DESC_ADDR;\n  uint32_t tx_desc_addr_next;\n  uint32_t i;\n\n  for (i = 0; i < ETH_TX_DESC_NUM; i++) {\n    tx_desc_addr_next = (tx_desc_addr + 1) & ETH_TX_DESC_MASK;\n    tx_desc = (ETH_TX_DESC *)tx_desc_addr;\n    if (tx_desc->OWN == 0) {\n      return tx_desc;\n    }\n    tx_desc_addr = tx_desc_addr_next;\n  }\n\n  return 0;\n}\n", "CodeBleu_score": 36.148939728965125}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)    uint32_t tx_desc_addr;\n    ETH_TX_DESC *tx_desc;\n\n    tx_desc_addr = ETH_TX_DESC_ADDR;\n    tx_desc = (ETH_TX_DESC *)tx_desc_addr;\n\n    while (tx_desc->next_desc_addr != tx_desc_addr) {\n        if (tx_desc->desc_status == ETH_TX_DESC_STATUS_OWNED) {\n            tx_desc_addr = tx_desc->next_desc_addr;\n            tx_desc = (ETH_TX_DESC *)tx_desc_addr;\n        } else {\n            return tx_desc;\n        }\n    }\n\n    return 0;\n}", "CodeBleu_score": 48.45669919605992}, {"code": "ETH_TX_DESC *ETH_AcquireFreeTxDesc(void)  ETH_TX_DESC *tx_desc = (ETH_TX_DESC *)ETH_TX_DESC_ADDR;\n  ETH_TX_DESC *tx_desc_end = (ETH_TX_DESC *)ETH_TX_DESC_END_ADDR;\n\n  while (tx_desc < tx_desc_end) {\n    if (tx_desc->status & ETH_TX_DESC_OWN) {\n      tx_desc++;\n    } else {\n      return tx_desc;\n    }\n  }\n\n  return 0;\n}", "CodeBleu_score": 37.579655813703276}]}
{"instance_id": "7367af8d29f1", "generation_result": [{"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    RT_ASSERT(device != RT_NULL);\n    RT_ASSERT(value != RT_NULL);\n\n    cy_csdidaq_dac_t *dac = (cy_csdidaq_dac_t *)device->user_data;\n    cy_csdidaq_dac_channel_t dac_channel = (cy_csdidaq_dac_channel_t)channel;\n\n    RT_ASSERT(dac != RT_NULL);\n    RT_ASSERT(dac_channel < CY_CSDIDAC_NUM_CHANNELS);\n\n    rt_err_t result = RT_EOK;\n\n    cy_rslt_t rslt = Cy_CSDIDAC_OutputEnable(dac, dac_channel, *value);\n    if (rslt != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"CSDIDAC output enable failed: %d\", rslt);\n        result = -RT_ERROR;\n    }\n\n    return result;\n}\n", "CodeBleu_score": 50.75408355775147}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    CY_ASSERT(device);\n    CY_ASSERT(value);\n\n    cy_stc_csd_dac_t dac_config = {0};\n    dac_config.dacChannel = channel;\n    dac_config.dacValue = *value;\n\n    cy_en_csd_status_t status = Cy_CSDIDAC_OutputEnable(device->config.dac, &dac_config);\n    if (status != CY_CSDIDAC_SUCCESS) {\n        rt_kprintf(\"Failed to initialize DAC channel %d for device %s\\n\", channel, device->config.name);\n        return -RT_ERROR;\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 52.66426417952379}, {"code": "static rt_err_t cyp_adc_convert(struct rt_dac_device *device, rt_uint32_t channel, rt_uint32_t *value)    RT_ASSERT(device != RT_NULL);\n\n    /* Get the DAC channel */\n    cy_stc_csd_dac_channel_config_t dac_channel_config = {0};\n    CY_CSDIDAC_GetChannelConfig(device->config.dac_base, channel, &dac_channel_config);\n\n    /* Enable the DAC output */\n    if (CY_CSDIDAC_OutputEnable(device->config.dac_base, channel, *value) != CY_CSDIDAC_SUCCESS) {\n        LOG_E(\"Failed to enable DAC output for channel %u\", channel);\n        return RT_ERROR;\n    }\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 51.67464000335601}]}
{"instance_id": "3beae49110b9", "generation_result": [{"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)  rt_uint32_t i;\n  rt_uint32_t end_addr = addr + size;\n\n  if (end_addr > FLASH_END_ADDR) {\n    rt_kprintf(\"flash read error, addr: 0x%x, size: 0x%x\\n\", addr, size);\n    return -1;\n  }\n\n  for (i = 0; i < size; i++) {\n    buf[i] = *((rt_uint8_t *)(addr + i));\n  }\n\n  return size;\n}\n", "CodeBleu_score": 45.05716303681642}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)    if ((addr + size) > FLASH_END_ADDR) {\n        rt_kprintf(\"flash read error, addr:%x, size:%d\\n\", addr, size);\n        return -1;\n    }\n\n    for (rt_uint32_t i = 0; i < size; i++) {\n        buf[i] = *(rt_uint8_t *)(addr + i);\n    }\n\n    return size;\n}\n", "CodeBleu_score": 51.346000205576104}, {"code": "int ifx_flash_read_32k(rt_uint32_t addr, rt_uint8_t *buf, rt_uint32_t size)  if (addr + size > FLASH_END_ADDR) {\n    LOG_E(\"flash read addr out of range\");\n    return -EINVAL;\n  }\n\n  for (rt_uint32_t i = 0; i < size; i++) {\n    buf[i] = *(rt_uint8_t *)(addr + i);\n  }\n  return size;\n}\n", "CodeBleu_score": 44.444618667398814}]}
{"instance_id": "b83f53e604b7", "generation_result": [{"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)  RT_ASSERT(timer != NULL);\n\n  cyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->user_data;\n  rt_uint32_t count;\n\n  count = cyhal_timer_read(timer_obj);\n\n  return count;\n}\n", "CodeBleu_score": 60.56710947750794}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)  RT_ASSERT(timer != NULL);\n\n  cyhal_timer_t *timer_obj = (cyhal_timer_t *)timer->user_data;\n  return cyhal_timer_read(timer_obj);\n}\n", "CodeBleu_score": 24.86247359132316}, {"code": "static rt_uint32_t timer_counter_get(rt_hwtimer_t *timer)  RT_ASSERT(timer != NULL);\n\n  cyhal_timer_t *obj = (cyhal_timer_t *)timer->user_data;\n  return cyhal_timer_read(obj);\n}\n", "CodeBleu_score": 23.400719830049923}]}
{"instance_id": "05824ffa38b7", "generation_result": [{"code": "void dfs_lock(void)    while (!__sync_bool_compare_and_swap(&dfs_mutex, 0, 1)) {\n        assert(0);\n    }\n}\n", "CodeBleu_score": 9.449098592637231}, {"code": "void dfs_lock(void)    while (1) {\n        if (mutex_trylock(&dfs_mutex))\n            return;\n        assert(0);\n    }\n}\n", "CodeBleu_score": 12.679616701840251}, {"code": "void dfs_lock(void)    int rc;\n    do {\n        rc = pthread_mutex_lock(&dfs_mutex);\n    } while (rc == EBUSY);\n    assert(rc == 0);\n}\n", "CodeBleu_score": 18.217183554221133}]}
{"instance_id": "5480b7f59af4", "generation_result": [{"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int i;\n    int nr_fds = fdt->fd_max - fdt->fd_min;\n    int fd;\n    struct dfs_fd *fd_entry;\n    struct dfs_file *filp;\n\n    /*\n     * If the specified startfd is within the range of the fd table,\n     * we start searching from that index. Otherwise, we start from\n     * the minimum fd index.\n     */\n    if (startfd >= fdt->fd_min && startfd < fdt->fd_max)\n        fd = startfd;\n    else\n        fd = fdt->fd_min;\n\n    /*\n     * Search for an empty slot starting from the specified index.\n     * If no empty slot is found, we return -1.\n     */\n    for (i = 0; i < nr_fds; i++) {\n        fd_entry = &fdt->fd_array[fd];\n        filp = fd_entry->filp;\n        if (filp == NULL)\n            return fd;\n        fd = (fd + 1) % fdt->fd_max;\n    }\n\n    /*\n     * If no empty slot is found, we attempt to expand the fd table.\n     * We return -1 if expansion fails.\n     */\n    if (!fd_expand(fdt))\n        return -1;\n\n    /*\n     * If expansion succeeds, we search for an empty slot starting from\n     * the index after the last allocated slot.\n     */\n    fd = (fd + 1) % fdt->fd_max;\n    for (i = 0; i < nr_fds; i++) {\n        fd_entry = &fdt->fd_array[fd];\n        filp = fd_entry->filp;\n        if (filp == NULL)\n            return fd;\n        fd = (fd + 1) % fdt->fd_max;\n    }\n\n    /*\n     * If no empty slot is found after expansion, we return -1.\n     */\n    return -1;\n}", "CodeBleu_score": 40.857577121367186}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int i;\n    int fd = -1;\n\n    for (i = startfd; i < fdt->max_fds; i++) {\n        if (fdt->fd[i] == NULL) {\n            fd = i;\n            break;\n        }\n    }\n\n    if (fd == -1) {\n        fd = fd_table_expand(fdt);\n    }\n\n    return fd;\n}\n", "CodeBleu_score": 34.007593272313386}, {"code": "static int fd_slot_alloc(struct dfs_fdtable *fdt, int startfd)    int i, fd;\n    struct dfs_fd *fd_entry;\n\n    for (i = startfd; i < fdt->fd_max; i++) {\n        fd_entry = &fdt->fd_table[i];\n        if (fd_entry->fd_inode == NULL) {\n            fd = i;\n            break;\n        }\n    }\n\n    if (i == fdt->fd_max) {\n        /* Expand the fd table */\n        if (fd_table_expand(fdt) == -1) {\n            return -1;\n        }\n        fd = fd_slot_alloc(fdt, startfd);\n    }\n\n    return fd;\n}\n", "CodeBleu_score": 44.55375967597275}]}
{"instance_id": "22549fe9d853", "generation_result": [{"code": "const char *rt_strerror(rt_err_t error)    if (error < 0) {\n        error = -error;\n    }\n    for (int i = 0; i < sizeof(rt_err_str) / sizeof(rt_err_str[0]); i++) {\n        if (error == rt_err_str[i].err) {\n            return rt_err_str[i].str;\n        }\n    }\n    return \"EUNKNOW\";\n}\n", "CodeBleu_score": 63.89464585134411}, {"code": "const char *rt_strerror(rt_err_t error)    if (error < 0)\n        error = -error;\n\n    for (size_t i = 0; i < sizeof(error_strings) / sizeof(error_strings[0]); i++) {\n        if (error_strings[i].error == error)\n            return error_strings[i].string;\n    }\n\n    return \"EUNKNOW\";\n}\n", "CodeBleu_score": 63.217032948604945}, {"code": "const char *rt_strerror(rt_err_t error)    if (error < 0) {\n        error = -error;\n    }\n\n    static const struct {\n        rt_err_t error;\n        const char *str;\n    } errors[] = {\n        {RT_EOK, \"OK\"},\n        {RT_ERROR, \"ERROR\"},\n        {RT_ETIMEOUT, \"TIMEOUT\"},\n        {RT_EFULL, \"FULL\"},\n        {RT_EEMPTY, \"EMPTY\"},\n        {RT_ENOMEM, \"NOMEM\"},\n        {RT_ENOSYS, \"NOSYS\"},\n        {RT_EBUSY, \"BUSY\"},\n        {RT_EIO, \"IO\"},\n        {RT_EINTR, \"INTR\"},\n        {RT_EINVAL, \"INVAL\"},\n        {RT_ENOTSUP, \"NOTSUP\"},\n        {RT_EISDIR, \"ISDIR\"},\n        {RT_ENOTDIR, \"NOTDIR\"},\n        {RT_EINVAL, \"INVAL\"},\n        {RT_EPERM, \"PERM\"},\n        {RT_EOVERFLOW, \"OVERFLOW\"},\n        {RT_EUNKNOWN, \"UNKNOWN\"},\n        {RT_ENOSYS, \"NOSYS\"},\n        {RT_EBUSY, \"BUSY\"},\n        {RT_EINTR, \"INTR\"},\n        {RT_EINVAL, \"INVAL\"},\n        {RT_ENOTSUP, \"NOTSUP\"},\n        {RT_EISDIR, \"ISDIR\"},\n        {RT_ENOTDIR, \"NOTDIR\"},\n        {RT_EINVAL, \"INVAL\"},\n        {RT_EPERM, \"PERM\"},\n        {RT_EOVERFLOW, \"OVERFLOW\"},\n        {RT_EUNKNOWN, \"UNKNOWN\"},\n        {RT_ENOSYS, \"NOSYS\"},\n        {RT_EBUSY, \"BUSY\"},\n        {RT_EINTR, \"INTR\"},\n        {RT_EINVAL, \"INVAL\"},\n        {RT_ENOTSUP, \"", "CodeBleu_score": 30.085490995916032}]}
{"instance_id": "21987673f31c", "generation_result": [{"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_err_t result;\n    rt_base_t index;\n    rt_list_t *idle_hook_list;\n\n    /* lock the spinlock */\n    rt_spin_lock(&rt_thread_idle_spinlock);\n\n    /* get the idle hook list */\n    idle_hook_list = &rt_thread_idle_hook_list;\n\n    /* iterate through the idle hook list to find an empty slot */\n    for (index = 0; index < RT_THREAD_IDLE_HOOK_NUM; index++) {\n        if (idle_hook_list[index].next == RT_NULL) {\n            /* assign the hook to that slot */\n            idle_hook_list[index].next = (rt_list_t *)hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* if no empty slot is available, return an error code */\n    if (index == RT_THREAD_IDLE_HOOK_NUM) {\n        result = -RT_EFULL;\n    }\n\n    /* release the spinlock */\n    rt_spin_unlock(&rt_thread_idle_spinlock);\n\n    /* return the result */\n    return result;\n}", "CodeBleu_score": 52.203120620990774}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_base_t result;\n    rt_base_t index;\n    rt_base_t *list;\n    rt_base_t *list_end;\n\n    /* lock the spinlock */\n    rt_thread_spin_lock(&rt_thread_idle_lock);\n\n    /* find an empty slot in the idle hook list */\n    list = rt_thread_idle_hooks;\n    list_end = list + RT_THREAD_IDLE_HOOK_NUM;\n    for (index = 0; list < list_end; list++, index++) {\n        if (*list == NULL) {\n            break;\n        }\n    }\n\n    /* check if an empty slot was found */\n    if (list >= list_end) {\n        result = -RT_EFULL;\n    } else {\n        *list = (rt_base_t)hook;\n        result = RT_EOK;\n    }\n\n    /* unlock the spinlock */\n    rt_thread_spin_unlock(&rt_thread_idle_lock);\n\n    /* return the result */\n    return result;\n}", "CodeBleu_score": 46.34997688825118}, {"code": "rt_err_t rt_thread_idle_sethook(void (*hook)(void))    rt_err_t result;\n    rt_base_t i;\n    rt_thread_idle_t *idle;\n    rt_base_t level;\n\n    RT_ASSERT(hook != RT_NULL);\n\n    idle = rt_thread_idle_get_ptr();\n    level = rt_hw_interrupt_disable();\n\n    for (i = 0; i < RT_THREAD_IDLE_HOOK_MAX_NUM; i++) {\n        if (idle->hooks[i] == RT_NULL) {\n            idle->hooks[i] = hook;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    rt_hw_interrupt_enable(level);\n\n    return result;\n}\n", "CodeBleu_score": 57.21764673231024}]}
{"instance_id": "4cbc6d4f6171", "generation_result": [{"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_err_t result;\n    rt_base_t index;\n    rt_list_t *list;\n    rt_list_node_t *node;\n\n    /* lock spinlock */\n    rt_hw_spin_lock(&rt_thread_idle_lock);\n\n    /* find the specified hook in the idle hook list */\n    list = &rt_thread_idle_hook_list;\n    for (index = 0; index < list->size; index++) {\n        node = rt_list_next(list, node);\n        if (node->value == hook) {\n            rt_list_remove(node);\n            result = RT_EOK;\n            goto exit;\n        }\n    }\n\n    /* if the hook is not found, return an error code */\n    result = RT_ERROR;\n", "CodeBleu_score": 42.426523626822124}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_err_t result;\n    rt_base_t index;\n\n    if (hook == NULL) {\n        return RT_EINVAL;\n    }\n\n    rt_spin_lock(&rt_thread_idle_lock);\n    for (index = 0; index < RT_THREAD_IDLE_MAX_HOOKS; index++) {\n        if (rt_thread_idle_hooks[index] == hook) {\n            rt_thread_idle_hooks[index] = NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n    rt_spin_unlock(&rt_thread_idle_lock);\n\n    return result;\n}", "CodeBleu_score": 52.68779772379083}, {"code": "rt_err_t rt_thread_idle_delhook(void (*hook)(void))    rt_err_t result;\n    rt_base_t index;\n    rt_base_t *p_idle_hook_list;\n\n    /* lock the spinlock */\n    rt_spin_lock(&rt_thread_idle_spinlock);\n\n    /* get the idle hook list */\n    p_idle_hook_list = rt_thread_idle_hook_list;\n\n    /* iterate through the idle hook list */\n    for (index = 0; index < RT_THREAD_IDLE_MAX_HOOK_NUM; index++) {\n        /* if the hook is found, set the corresponding entry to null and return a success code */\n        if (p_idle_hook_list[index] == hook) {\n            p_idle_hook_list[index] = NULL;\n            result = RT_EOK;\n            break;\n        }\n    }\n\n    /* if the hook is not found, return an error code indicating that the operation is not supported */\n    if (index == RT_THREAD_IDLE_MAX_HOOK_NUM) {\n        result = -RT_ERROR;\n    }\n\n    /* unlock the spinlock */\n    rt_spin_unlock(&rt_thread_idle_spinlock);\n\n    /* return the result */\n    return result;\n}", "CodeBleu_score": 53.31407407567206}]}
{"instance_id": "19847f2b22b0", "generation_result": [{"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_err_t result = RT_EOK;\n    rt_base_t key;\n    rt_thread_t *thread;\n\n    /* check parameter */\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* lock the scheduler */\n    key = rt_hw_interrupt_disable();\n\n    /* dequeue and resume all suspended threads in the list */\n    while (rt_list_isempty(susp_list) == RT_FALSE) {\n        /* get the suspended thread */\n        thread = (rt_thread_t *)rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /* remove the thread from the list */\n        rt_list_remove(&(thread->tlist));\n\n        /* set thread error */\n        thread->error = thread_error;\n\n        /* wake up the thread */\n        rt_thread_resume(thread);\n    }\n\n    /* unlock the scheduler */\n    rt_hw_interrupt_enable(key);\n\n    return result;\n}", "CodeBleu_score": 29.40309672546077}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_thread_t *thread;\n\n    /* check parameter */\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* lock scheduler */\n    rt_enter_critical();\n\n    /* resume all suspended threads in the list */\n    while (!rt_list_isempty(susp_list)) {\n        thread = (rt_thread_t *)rt_list_entry(susp_list->next, struct rt_thread, tlist);\n\n        /* set error code */\n        thread->error = thread_error;\n\n        /* remove thread from the list */\n        rt_list_remove(&thread->tlist);\n\n        /* wake up the thread */\n        rt_thread_resume(thread);\n    }\n\n    /* unlock scheduler */\n    rt_exit_critical();\n\n    return RT_EOK;\n}", "CodeBleu_score": 32.14856878385477}, {"code": "rt_err_t rt_susp_list_resume_all(rt_list_t *susp_list, rt_err_t thread_error)    rt_base_t level;\n    rt_thread_t thread;\n\n    RT_ASSERT(susp_list != RT_NULL);\n\n    /* lock the scheduler */\n    level = rt_hw_interrupt_disable();\n\n    /* dequeue and resume each suspended thread */\n    while (rt_list_entry(susp_list->next) != susp_list) {\n        thread = rt_list_entry(susp_list->next, rt_thread_t, tlist);\n        rt_list_remove(&(thread->tlist));\n        rt_thread_resume(thread);\n    }\n\n    /* unlock the scheduler */\n    rt_hw_interrupt_enable(level);\n\n    return RT_EOK;\n}", "CodeBleu_score": 31.36414054506963}]}
{"instance_id": "49cd9de412be", "generation_result": [{"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t dev, old_dev;\n    rt_err_t result;\n\n    /* save current console device */\n    old_dev = rt_console_get_device();\n\n    /* find the new device by its name */\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        rt_kprintf(\"console: %s not found\\n\", name);\n        return old_dev;\n    }\n\n    /* check if it is the same as the current device */\n    if (dev == old_dev) {\n        return old_dev;\n    }\n\n    /* close the current console device if it exists */\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    /* open the new console device with read/write and stream flags */\n    result = rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);\n    if (result != RT_EOK) {\n        rt_kprintf(\"console: %s open failed\\n\", name);\n        return old_dev;\n    }\n\n    /* set it as the new console device */\n    rt_console_set_device(dev);\n\n    return old_dev;\n}", "CodeBleu_score": 57.792888030534485}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t dev;\n    rt_device_t old_dev;\n\n    old_dev = rt_console_get_device();\n    if (old_dev == RT_NULL) {\n        rt_kprintf(\"set console device %s\\n\", name);\n    }\n\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        rt_kprintf(\"can't find console device %s\\n\", name);\n        return RT_NULL;\n    }\n\n    if (old_dev == dev) {\n        rt_kprintf(\"console device %s already exists\\n\", name);\n        return RT_NULL;\n    }\n\n    if (old_dev != RT_NULL) {\n        rt_device_close(old_dev);\n    }\n\n    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        rt_kprintf(\"open console device %s failed\\n\", name);\n        return RT_NULL;\n    }\n\n    rt_console_set_device(dev);\n\n    return old_dev;\n}\n", "CodeBleu_score": 55.57704228116762}, {"code": "rt_device_t rt_console_set_device(const char *name)    rt_device_t dev;\n    rt_device_t old;\n\n    old = rt_console_get_device();\n\n    if (old != RT_NULL) {\n        if (strcmp(name, old->user_data) == 0) {\n            return old;\n        }\n\n        rt_device_close(old);\n    }\n\n    dev = rt_device_find(name);\n    if (dev == RT_NULL) {\n        return RT_NULL;\n    }\n\n    if (rt_device_open(dev, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM) != RT_EOK) {\n        return RT_NULL;\n    }\n\n    rt_console_set_device(dev);\n\n    return old;\n}", "CodeBleu_score": 51.714762604744}]}
{"instance_id": "8530e7eb6cc8", "generation_result": [{"code": "int rt_object_get_length(enum rt_object_class_type type)  struct rt_object_class *class = rt_object_get_class(type);\n  int length;\n\n  if (class == NULL) {\n    return 0;\n  }\n\n  rt_spinlock_lock(&class->lock);\n  length = 0;\n\n  struct rt_object_list *list = class->list;\n  while (list != NULL) {\n    length++;\n    list = list->next;\n  }\n\n  rt_spinlock_unlock(&class->lock);\n  return length;\n}\n", "CodeBleu_score": 31.247490806121945}, {"code": "int rt_object_get_length(enum rt_object_class_type type)  struct rt_object_class *class = rt_object_class_get(type);\n  int count = 0;\n  if (class) {\n    rt_spinlock_lock(&class->lock);\n    struct rt_object *object;\n    for (object = class->object_list; object; object = object->next) {\n      count++;\n    }\n    rt_spinlock_unlock(&class->lock);\n  }\n  return count;\n}\n", "CodeBleu_score": 34.00403997703385}, {"code": "int rt_object_get_length(enum rt_object_class_type type)    int count = 0;\n    struct rt_object *obj;\n    rt_spinlock_t *lock = &rt_object_class_locks[type];\n\n    rt_spinlock_lock(lock);\n    for (obj = rt_object_class[type]; obj; obj = obj->next) {\n        count++;\n    }\n    rt_spinlock_unlock(lock);\n\n    return count;\n}", "CodeBleu_score": 31.078072672990338}]}
{"instance_id": "9c88db151352", "generation_result": [{"code": "void rt_object_detach(rt_object_t object)    rt_base_t level;\n    rt_object_info_t *object_info;\n\n    /* check the parameter */\n    RT_ASSERT(object != RT_NULL);\n\n    /* get the object's information */\n    object_info = (rt_object_info_t *)object;\n\n    /* lock the object's spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* remove the object from its list */\n    rt_list_remove(&(object_info->list));\n\n    /* unlock the object's spinlock */\n    rt_hw_interrupt_enable(level);\n\n    /* set the object's type to zero */\n    object_info->type = 0;\n}", "CodeBleu_score": 25.37614789811181}, {"code": "void rt_object_detach(rt_object_t object)    if (object != RT_NULL) {\n        rt_object_hook_t hook = object->hook;\n\n        if (hook != RT_NULL) {\n            rt_base_t level;\n            rt_object_info_t *info = object->info;\n\n            rt_base_t_get_and_set_interrupt_state(level);\n            if (info->list != RT_NULL) {\n                rt_list_remove(&(info->list));\n            }\n            rt_base_t_set_interrupt_state(level);\n\n            hook->dettach(object);\n        }\n\n        object->type = 0;\n    }\n}", "CodeBleu_score": 49.886718749957474}, {"code": "void rt_object_detach(rt_object_t object)    rt_base_t level;\n    rt_object_info_t *info;\n\n    RT_ASSERT(object != RT_NULL);\n\n    /* call the hook function */\n    rt_object_on_detach(object);\n\n    /* get the object's information structure */\n    info = (rt_object_info_t *)object;\n\n    /* lock the spinlock */\n    level = rt_hw_interrupt_disable();\n\n    /* remove the object from the list */\n    rt_list_remove(&(info->list));\n\n    /* unlock the spinlock */\n    rt_hw_interrupt_enable(level);\n\n    /* set the object's type to zero */\n    info->type = 0;\n}", "CodeBleu_score": 25.872032280153455}]}
{"instance_id": "7c244d78ebb0", "generation_result": [{"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t err = RT_ERR_NOT_FOUND;\n    rt_object_t *object = (rt_object_t *)obj;\n    if (object != NULL && object->type == RT_OBJECT_CUSTOM) {\n        rt_custom_object_t *custom_object = (rt_custom_object_t *)object;\n        if (custom_object->destroy != NULL) {\n            err = custom_object->destroy(custom_object);\n        }\n        free(custom_object);\n    }\n    return err;\n}", "CodeBleu_score": 42.85272998935467}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t err = RT_ERR_NONE;\n    rt_custom_object_t *custom_obj = (rt_custom_object_t *)obj;\n    if (custom_obj && custom_obj->destroy) {\n        err = custom_obj->destroy(obj);\n    }\n    if (err == RT_ERR_NONE) {\n        free(custom_obj);\n    }\n    return err;\n}\n", "CodeBleu_score": 42.81811709041717}, {"code": "rt_err_t rt_custom_object_destroy(rt_object_t obj)    rt_err_t err = RT_ERR_OK;\n    rt_custom_object_t custom_obj = (rt_custom_object_t)obj;\n\n    if (custom_obj == NULL) {\n        err = RT_ERR_INVALID_OBJECT;\n    } else if (custom_obj->class_type != RT_CLASS_TYPE_CUSTOM) {\n        err = RT_ERR_INVALID_OBJECT;\n    } else if (custom_obj->destroy != NULL) {\n        err = custom_obj->destroy(custom_obj);\n    }\n\n    if (err == RT_ERR_OK) {\n        free(custom_obj);\n    }\n\n    return err;\n}\n", "CodeBleu_score": 45.10889670076702}]}
{"instance_id": "8502151cda65", "generation_result": [{"code": "static void _thread_exit(void)  thread_t *current = thread_current();\n  intr_disable();\n  list_insert_back(&defunct_threads, &current->elem);\n  intr_enable();\n  sched_switch();\n}\n", "CodeBleu_score": 13.725184951385211}, {"code": "static void _thread_exit(void)    thread_t *current_thread = get_current_thread();\n    enter_critical_section();\n    close_thread(current_thread);\n    add_defunct_thread(current_thread);\n    exit_critical_section();\n    scheduler();\n}\n", "CodeBleu_score": 53.37773689327159}, {"code": "static void _thread_exit(void)\tthread_t *current = thread_current();\n\n\tlock_acquire(&thread_lock);\n\n\tcurrent->status = THREAD_TERMINATED;\n\tlist_push_back(&defunct_threads, &current->elem);\n\n\tlock_release(&thread_lock);\n\n\tscheduler_run();\n}\n", "CodeBleu_score": 39.91717701817174}]}
{"instance_id": "e0f1dd5a29a1", "generation_result": [{"code": "static void _thread_timeout(void *parameter)    struct thread *thread = parameter;\n\n    ASSERT(thread != NULL);\n    ASSERT(thread->state == THREAD_SUSPENDED);\n\n    lock_acquire(&scheduler_lock);\n    thread->error = THREAD_TIMED_OUT;\n    list_remove(&thread->wait_list_elem);\n    list_push_back(&ready_list, &thread->ready_list_elem);\n    lock_release(&scheduler_lock);\n}\n", "CodeBleu_score": 31.78097355216087}, {"code": "static void _thread_timeout(void *parameter)  thread_t *thread = (thread_t *) parameter;\n  if (thread == NULL) {\n    return;\n  }\n  if (thread->state != THREAD_SUSPENDED) {\n    return;\n  }\n  thread->error = THREAD_TIMEOUT;\n  scheduler_lock();\n  if (thread->state != THREAD_SUSPENDED) {\n    scheduler_unlock();\n    return;\n  }\n  list_remove(&thread->suspend_list_node);\n  list_insert(&thread->ready_list_node);\n  scheduler_unlock();\n  scheduler_reschedule();\n}\n", "CodeBleu_score": 36.56115445406836}, {"code": "static void _thread_timeout(void *parameter)    thread_t *thread = (thread_t *)parameter;\n    if (thread == NULL) {\n        return;\n    }\n    scheduler_lock();\n    if (thread->state == THREAD_SUSPENDED) {\n        thread->error = ETIME;\n        scheduler_remove_from_suspended_list(thread);\n        scheduler_insert_to_ready_list(thread);\n    }\n    scheduler_unlock();\n}\n", "CodeBleu_score": 35.419663757283296}]}
{"instance_id": "2af96ff4a75a", "generation_result": [{"code": "static void _thread_detach_from_mutex(rt_thread_t thread)    rt_thread_t current_thread;\n    rt_mutex_t mutex;\n    rt_base_t key;\n\n    /* Lock the spinlock of the thread */\n    key = rt_hw_spin_lock();\n\n    /* Check if the thread is waiting on a mutex */\n    if (thread->wait_mutex) {\n        /* Remove the thread from the mutex's waiting list */\n        mutex = thread->wait_mutex;\n        rt_mutex_wait_list_remove(mutex, thread);\n\n        /* Clear the pending object */\n        mutex->pending_obj = RT_NULL;\n    }\n\n    /* Release all mutexes the thread has taken */\n    current_thread = rt_thread_self();\n    while (thread->taken_mutex) {\n        mutex = thread->taken_mutex;\n        rt_mutex_taken_list_remove(mutex, thread);\n\n        /* If the mutex is recursive and the thread has taken it more than once, release it */\n        if (mutex->recursive && thread->taken_mutex_count > 1) {\n            rt_mutex_release(mutex);\n            thread->taken_mutex_count--;\n        } else {\n            /* Otherwise, set the mutex's pending object to the thread */\n            mutex->pending_obj = thread;\n        }\n    }\n\n    /* Restore the spinlock state */\n    rt_hw_spin_unlock(key);\n}", "CodeBleu_score": 47.13175369032665}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)  rt_base_t level;\n  rt_thread_t current_thread;\n  rt_mutex_t mutex;\n\n  /* Lock the spinlock */\n  level = rt_hw_interrupt_disable();\n\n  /* Get the current thread */\n  current_thread = rt_thread_self();\n\n  /* Check if the thread is waiting on a mutex */\n  if (current_thread->state == RT_THREAD_MUTEX_WAITING) {\n    /* Get the mutex the thread is waiting on */\n    mutex = current_thread->mutex;\n\n    /* Remove the thread from the mutex's waiting list */\n    _rt_mutex_remove_waiting_thread(mutex, current_thread);\n\n    /* Clear the pending object */\n    mutex->pending_object = RT_NULL;\n\n    /* Set the thread's state to ready */\n    current_thread->state = RT_THREAD_READY;\n  }\n\n  /* Release all mutexes the thread has taken */\n  _rt_mutex_release_all(current_thread);\n\n  /* Restore the spinlock state */\n  rt_hw_interrupt_enable(level);\n}", "CodeBleu_score": 29.61947824655683}, {"code": "static void _thread_detach_from_mutex(rt_thread_t thread)    rt_base_t level;\n    rt_thread_t next;\n    rt_thread_t prev;\n    rt_thread_t current;\n    rt_thread_t temp;\n    rt_thread_t owner;\n    rt_thread_t thread_id;\n    rt_base_t i;\n    rt_mutex_t mutex;\n    rt_base_t status;\n    rt_base_t thread_state;\n    rt_base_t thread_priority;\n    rt_base_t thread_priority_max;\n    rt_base_t thread_priority_min;\n    rt_base_t thread_priority_max_id;\n    rt_base_t thread_priority_min_id;\n    rt_base_t thread_priority_max_id_prev;\n    rt_base_t thread_priority_min_id_prev;\n    rt_base_t thread_priority_max_id_next;\n    rt_base_t thread_priority_min_id_next;\n    rt_base_t thread_priority_max_id_next_prev;\n    rt_base_t thread_priority_min_id_next_prev;\n    rt_base_t thread_priority_max_id_next_next;\n    rt_base_t thread_priority_min_id_next_next;\n    rt_base_t thread_priority_max_id_next_next_prev;\n    rt_base_t thread_priority_min_id_next_next_prev;\n    rt_base_t thread_priority_max_id_next_next_next;\n    rt_base_t thread_priority_min_id_next_next_next;\n    rt_base_t thread_priority_max_id_next_next_next_prev;\n    rt_base_t thread_priority_min_id_next_next_next_prev;\n    rt_base_t thread_priority_max_id_next", "CodeBleu_score": 7.350029844302392}]}
{"instance_id": "a54791eb73ca", "generation_result": [{"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    RT_ASSERT(thread != RT_NULL);\n\n    if (thread->state == RT_THREAD_INIT) {\n        RT_LOGI(\"thread:%s start up.\\n\", thread->name);\n\n        /* calculate priority attributes */\n        thread->priority_attr.period = thread->period;\n        thread->priority_attr.wcet = thread->wcet;\n        thread->priority_attr.deadline = thread->deadline;\n\n        /* reset state to suspended */\n        thread->state = RT_THREAD_SUSPEND;\n\n        /* resume the thread */\n        rt_thread_resume(thread);\n\n        /* trigger a scheduler if available */\n        if (rt_system_scheduler_get_cur() != RT_NULL) {\n            rt_system_scheduler_schedule();\n        }\n\n        return RT_EOK;\n    } else {\n        RT_LOGE(\"thread:%s is not in initialization state.\\n\", thread->name);\n        return -RT_ERROR;\n    }\n}\n", "CodeBleu_score": 44.337962586021895}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)  RT_ASSERT(thread != RT_NULL);\n  RT_ASSERT(thread->state == RT_THREAD_INIT);\n  RT_ASSERT(thread->type == RT_THREAD_TYPE_NORMAL);\n\n  rt_kprintf(\"[%s] thread start, prio:%d, stack:%d, ticks:%d\\n\",\n             thread->name, thread->init_prio, thread->init_stack_size,\n             thread->init_ticks);\n\n  thread->prio = thread->init_prio;\n  thread->cur_prio = thread->init_prio;\n  thread->state = RT_THREAD_SUSPEND;\n  thread->delay_ticks = thread->init_ticks;\n  thread->delay_time = thread->init_ticks * RT_TICK_PER_SECOND / 1000;\n\n  rt_thread_resume(thread);\n\n  if (rt_system_scheduler_startup() == RT_EOK) {\n    rt_system_scheduler_start();\n  }\n\n  return RT_EOK;\n}\n", "CodeBleu_score": 37.71210539435681}, {"code": "rt_err_t rt_thread_startup(rt_thread_t thread)    rt_err_t result = RT_EOK;\n\n    if (thread != RT_NULL) {\n        if (thread->state == RT_THREAD_INIT) {\n            if (thread->type == RT_THREAD_TYPE_NORMAL) {\n                rt_kprintf(\"thread %s start, prio = %d\\n\", thread->name, thread->current_priority);\n                thread->priority_attribute = rt_thread_get_priority_attribute(thread->current_priority);\n                thread->state = RT_THREAD_SUSPEND;\n                rt_thread_resume(thread);\n                if (rt_system_scheduler_startup() == RT_EOK) {\n                    rt_system_scheduler_request_rescheduling();\n                }\n            } else {\n                result = RT_EINVAL;\n            }\n        } else {\n            result = RT_EINVAL;\n        }\n    } else {\n        result = RT_EINVAL;\n    }\n\n    return result;\n}\n", "CodeBleu_score": 40.782998837637706}]}
{"instance_id": "bfda287b2d91", "generation_result": [{"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_list_t *timer_entry;\n    rt_list_t *timer_list_head;\n    rt_tick_t timeout;\n    rt_uint32_t level;\n\n    /* find the first non-empty timer list */\n    for (level = 0; level < RT_TIMER_MAX_LEVEL; level++) {\n        timer_list_head = timer_list[level].next;\n        if (timer_list_head != &(timer_list[level])) {\n            break;\n        }\n    }\n\n    /* no timer list is not empty */\n    if (level == RT_TIMER_MAX_LEVEL) {\n        return -RT_ETIMEOUT;\n    }\n\n    /* get the first timer entry */\n    timer_entry = timer_list_head->next;\n\n    /* get the timeout value of the timer */\n    timeout = timer_entry->timer.timeout;\n\n    /* set the timeout tick */\n    *timeout_tick = timeout;\n\n    return RT_EOK;\n}\n", "CodeBleu_score": 35.4232857136539}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_timer_t *timer;\n    rt_err_t result;\n    rt_uint32_t level;\n    rt_list_t *list;\n\n    /* get the highest level of the timer skip list */\n    level = _timer_skip_list_highest_level();\n\n    /* check if the highest level of the timer skip list is not empty */\n    if (level == 0) {\n        /* the highest level of the timer skip list is empty, return an error code */\n        return RT_ETIMEOUT;\n    }\n\n    /* get the first timer entry in the highest level of the timer skip list */\n    list = &timer_list[level];\n    timer = rt_list_entry(list->next, struct rt_timer, list);\n\n    /* set the provided timeout tick to the timer's timeout value */\n    *timeout_tick = timer->timeout;\n\n    /* return RT_EOK */\n    return RT_EOK;\n}\n", "CodeBleu_score": 47.37308537307674}, {"code": "static rt_err_t _timer_list_next_timeout(rt_list_t timer_list[], rt_tick_t *timeout_tick)    rt_uint32_t level;\n    rt_list_t *list;\n    rt_timer_t *timer;\n    rt_err_t result;\n\n    /* find the first non-empty list */\n    for (level = 0; level < RT_TIMER_MAX_LEVEL; level++) {\n        list = &timer_list[level];\n\n        if (!rt_list_isempty(list)) {\n            break;\n        }\n    }\n\n    /* the list is empty */\n    if (level == RT_TIMER_MAX_LEVEL) {\n        *timeout_tick = RT_TICK_MAX;\n        return RT_EOK;\n    }\n\n    /* get the timer */\n    list = rt_list_entry(list->next, rt_list_t, next);\n    timer = rt_container_of(list, rt_timer_t, list[level]);\n\n    /* set the timeout tick */\n    *timeout_tick = timer->timeout;\n\n    /* return the result */\n    result = RT_EOK;\n    return result;\n}\n", "CodeBleu_score": 35.54924851619709}]}
{"instance_id": "7cb3a2404f73", "generation_result": [{"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)  rt_timer_t timer;\n  rt_err_t   result;\n\n  /* check the arguments */\n  RT_ASSERT(timeout != RT_NULL);\n  RT_ASSERT(time <= RT_TICK_MAX);\n\n  /* create timer object */\n  timer = rt_malloc(sizeof(struct rt_timer));\n  if (timer != RT_NULL) {\n    /* initialize timer object */\n    rt_memset(timer, 0, sizeof(struct rt_timer));\n    timer->name = name;\n    timer->timeout = timeout;\n    timer->parameter = parameter;\n    timer->time.time = time;\n    timer->flag = flag;\n\n    /* insert timer object into the timer list */\n    result = rt_timer_insert(timer);\n    if (result != RT_EOK) {\n      rt_free(timer);\n      timer = RT_NULL;\n    }\n  }\n\n  return timer;\n}\n", "CodeBleu_score": 52.12570447979103}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)    RT_ASSERT(timeout);\n    RT_ASSERT(time <= RT_TICK_MAX);\n\n    rt_timer_t timer;\n\n    timer = (rt_timer_t)rt_malloc(sizeof(struct rt_timer));\n    if (timer != RT_NULL) {\n        rt_list_init(&timer->list);\n        timer->name = name;\n        timer->timeout = timeout;\n        timer->parameter = parameter;\n        timer->time = time;\n        timer->flag = flag;\n    }\n\n    return timer;\n}\n", "CodeBleu_score": 49.27719121289479}, {"code": "rt_timer_t rt_timer_create(const char *name,\n                           void (*timeout)(void *parameter),\n                           void       *parameter,\n                           rt_tick_t   time,\n                           rt_uint8_t  flag)  rt_timer_t timer;\n\n  /* check the arguments */\n  RT_ASSERT(name != RT_NULL);\n  RT_ASSERT(timeout != RT_NULL);\n\n  /* check the time */\n  if (time < RT_TICK_MAX) {\n    /* create the timer object */\n    timer = rt_object_create(RT_Object_Class_Timer, name);\n    if (timer != RT_NULL) {\n      /* initialize the timer object */\n      timer->timeout = timeout;\n      timer->parameter = parameter;\n      timer->time = time;\n      timer->flag = flag;\n    }\n  } else {\n    /* the specified time is invalid */\n    timer = RT_NULL;\n  }\n\n  return timer;\n}\n", "CodeBleu_score": 51.0184054928073}]}
{"instance_id": "dede8c248766", "generation_result": [{"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Println(\"[Panic]\", r)\n\t\t}\n\t}()\n\n\t// Create a new response recorder\n\trec := httptest.NewRecorder()\n\n\t// Loop through each handler and capture the response\n\tfor _, handler := range a.handlers {\n\t\t// Call the handler and capture the response\n\t\thandler.ServeHTTP(rec, req)\n\n\t\t// If the response status is unauthorized, send a \"Not Authorized\" error response and stop processing\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Copy the response headers to the original response\n\t\tfor k, v := range rec.Header() {\n\t\t\tres.Header()[k] = v\n\t\t}\n\t}\n\n\t// If all handlers pass, forward the request to the router for further handling\n\ta.router.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 62.69980245641277}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\trec := httptest.NewRecorder()\n\tfor _, handler := range a.middleware {\n\t\thandler.ServeHTTP(rec, req)\n\t\tcopyHeaders(res, rec)\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\tres.WriteHeader(http.StatusUnauthorized)\n\t\t\tres.Write([]byte(\"Not Authorized\"))\n\t\t\treturn\n\t\t}\n\t}\n\ta.router.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 49.06644703211938}, {"code": "func (a *API) ServeHTTP(res http.ResponseWriter, req *http.Request)\t// Create a new recorder to capture the response\n\trec := httptest.NewRecorder()\n\n\t// Process the request through the middleware chain\n\tfor _, handler := range a.middleware {\n\t\thandler(rec, req)\n\n\t\t// If the response was unauthorized, send an error and stop processing\n\t\tif rec.Code == http.StatusUnauthorized {\n\t\t\thttp.Error(res, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// Copy the captured response headers to the original response\n\t\tfor key, values := range rec.Header() {\n\t\t\tfor _, value := range values {\n\t\t\t\tres.Header().Add(key, value)\n\t\t\t}\n\t\t}\n\n\t\t// If the response was not successful, stop processing\n\t\tif rec.Code != http.StatusOK {\n\t\t\treturn\n\t\t}\n\n\t\t// Reset the recorder for the next handler\n\t\trec.Flush()\n\t\trec.Body.Reset()\n\t\trec.HeaderMap.Del(\"Content-Type\")\n\t\trec.HeaderMap.Del(\"Content-Length\")\n\t}\n\n\t// If the request was not handled by the middleware chain, forward it to the router\n\ta.router.ServeHTTP(res, req)\n}\n", "CodeBleu_score": 58.414106796124635}]}
{"instance_id": "314b5f1c1ddc", "generation_result": [{"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tasset, err := a.fs.Open(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\tdefer asset.Close()\n\n\tcontentType := mime.TypeByExtension(filepath.Ext(path))\n\tres.Header().Set(\"Content-Type\", contentType)\n\n\tio.Copy(res, asset)\n}", "CodeBleu_score": 42.150380038962524}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tif path == \"/\" {\n\t\tpath = \"/index.html\"\n\t}\n\tpath = \"./static\" + path\n\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tres.WriteHeader(404)\n\t\tres.Write([]byte(\"404 Not Found\"))\n\t\treturn\n\t}\n\n\tif strings.HasSuffix(path, \".js\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/javascript\")\n\t} else if strings.HasSuffix(path, \".css\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/css\")\n\t} else if strings.HasSuffix(path, \".html\") {\n\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t}\n\n\tres.Write(data)\n}\n", "CodeBleu_score": 41.1286191345074}, {"code": "func (a *API) robeaux(res http.ResponseWriter, req *http.Request) \tpath := req.URL.Path\n\tasset, err := a.assets.Get(path)\n\tif err != nil {\n\t\thttp.Error(res, err.Error(), http.StatusNotFound)\n\t\treturn\n\t}\n\n\tcontentType := mime.TypeByExtension(filepath.Ext(path))\n\tif contentType == \"\" {\n\t\tcontentType = \"application/octet-stream\"\n\t}\n\n\tres.Header().Set(\"Content-Type\", contentType)\n\tres.Write(asset)\n}\n", "CodeBleu_score": 46.391228063264556}]}
{"instance_id": "8ac41dfcacc9", "generation_result": [{"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\tname := strings.TrimPrefix(req.URL.Path, \"/robot/\")\n\trobot, err := a.master.GetRobot(name)\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot with this name was found\"})\n\t\treturn\n\t}\n\tconnections, err := robot.Connections()\n\tif err != nil {\n\t\ta.writeJSON(res, http.StatusInternalServerError, map[string]string{\"error\": err.Error()})\n\t\treturn\n\t}\n\ta.writeJSON(res, http.StatusOK, connections)\n}\n", "CodeBleu_score": 33.54696110106568}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := strings.TrimPrefix(req.URL.Path, \"/api/robots/\")\n\trobot, ok := a.master.Robot(robotName)\n\tif !ok {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t\tjson.NewEncoder(res).Encode(map[string]string{\"error\": \"no robot found with that name\"})\n\t\treturn\n\t}\n\n\tconnections := robot.Connections()\n\n\tres.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(res).Encode(connections)\n}\n", "CodeBleu_score": 30.43611690656337}, {"code": "func (a *API) robotConnections(res http.ResponseWriter, req *http.Request)\trobotName := mux.Vars(req)[\"robotName\"]\n\trobot := a.master.GetRobot(robotName)\n\tif robot == nil {\n\t\ta.writeJSON(res, http.StatusNotFound, map[string]string{\"error\": \"no robot found with name \" + robotName})\n\t\treturn\n\t}\n\tconnections := robot.Connections()\n\ta.writeJSON(res, http.StatusOK, connections)\n}\n", "CodeBleu_score": 30.052928489032965}]}
{"instance_id": "16a20222e69b", "generation_result": [{"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"Restricted\\\"\")\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\tif !strings.EqualFold(parts[0], \"Basic\") {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tpayload, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tparts = strings.SplitN(string(payload), \":\", 2)\n\t\tif !strings.EqualFold(parts[0], username) || !strings.EqualFold(parts[1], password) {\n\t\t\thttp.Error(w, \"Not Authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 51.86356827112628}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\tif !(len(parts) == 2 && parts[0] == \"Basic\") {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpayload, err := base64.StdEncoding.DecodeString(parts[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(payload), \":\", 2)\n\t\tif !(len(pair) == 2 && pair[0] == username && pair[1] == password) {\n\t\t\thttp.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.65520662576916}, {"code": "func BasicAuth(username, password string) http.HandlerFunc\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"Restricted\"`)\n\n\t\ts := strings.SplitN(r.Header.Get(\"Authorization\"), \" \", 2)\n\t\tif len(s) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tb, err := base64.StdEncoding.DecodeString(s[1])\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tpair := strings.SplitN(string(b), \":\", 2)\n\t\tif len(pair) != 2 {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tif pair[0] != username || pair[1] != password {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n}\n", "CodeBleu_score": 49.530259947863264}]}
{"instance_id": "c6b3dd5d10f7", "generation_result": [{"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\n\tslope := toRange / fromRange\n\tintercept := toMin - slope*fromMin\n\n\treturn func(input float64) (value int) {\n\t\tvalue = int(slope*input + intercept)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}\n", "CodeBleu_score": 50.21342343512043}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tslope := float64(toRange) / fromRange\n\tintercept := float64(toMin) - slope*fromMin\n\treturn func(input float64) (value int) {\n\t\tvalue = int(math.Round(slope*input + intercept))\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}\n", "CodeBleu_score": 52.72664398087711}, {"code": "func AnalogActuatorLinearScaler(fromMin, fromMax float64, toMin, toMax int) func(input float64) (value int) \tscale := (toMax - toMin) / (fromMax - fromMin)\n\toffset := toMin - fromMin * scale\n\treturn func(input float64) (value int) {\n\t\tvalue = int(input * scale + offset)\n\t\tif value < toMin {\n\t\t\tvalue = toMin\n\t\t} else if value > toMax {\n\t\t\tvalue = toMax\n\t\t}\n\t\treturn value\n\t}\n}\n", "CodeBleu_score": 54.43568607491505}]}
{"instance_id": "973e7f360ae8", "generation_result": [{"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.Valid() {\n\t\treturn 0, 0, errors.New(\"Invalid connection\")\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 46.440435561147595}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tif !a.connection.IsValid() {\n\t\treturn 0, 0, ErrConnectionInvalid\n\t}\n\n\traw, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\ta.lastRaw = raw\n\ta.lastScaled = a.scale(raw)\n\n\treturn raw, a.lastScaled, nil\n}\n", "CodeBleu_score": 46.74676175816869}, {"code": "func (a *AnalogSensorDriver) analogSensorRead() (int, float64, error)\ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tif !a.connection.IsValid() {\n\t\treturn 0, 0, fmt.Errorf(\"connection is not valid\")\n\t}\n\n\trawValue, err := a.connection.AnalogRead(a.pin)\n\tif err != nil {\n\t\treturn 0, 0, fmt.Errorf(\"failed to read analog value: %v\", err)\n\t}\n\n\tscaledValue := float64(rawValue) * a.scaleFactor\n\n\ta.lastRawValue = rawValue\n\ta.lastScaledValue = scaledValue\n\n\treturn rawValue, scaledValue, nil\n}\n", "CodeBleu_score": 48.973741981965816}]}
{"instance_id": "6defa4c6d37d", "generation_result": [{"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \treturn func(fromValue int) float64 {\n\t\t// Calculate the slope (m) and intercept (n) for the linear transformation\n\t\tm := (toMax - toMin) / (fromMax - fromMin)\n\t\tn := toMin - m*fromMin\n\n\t\t// Scale the input value to the desired output range\n\t\treturn m*float64(fromValue) + n\n\t}\n}\n", "CodeBleu_score": 41.24432359205251}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tdeltaFrom := fromMax - fromMin\n\tdeltaTo := toMax - toMin\n\n\tm := deltaTo / float64(deltaFrom)\n\tn := toMin - m*float64(fromMin)\n\n\treturn func(from int) float64 {\n\t\treturn m*float64(from) + n\n\t}\n}\n", "CodeBleu_score": 56.35642639892529}, {"code": "func AnalogSensorLinearScaler(fromMin, fromMax int, toMin, toMax float64) func(int) float64 \tfromRange := fromMax - fromMin\n\ttoRange := toMax - toMin\n\tslope := toRange / float64(fromRange)\n\tintercept := toMin - (slope * float64(fromMin))\n\n\treturn func(value int) float64 {\n\t\treturn slope*float64(value) + intercept\n\t}\n}\n", "CodeBleu_score": 50.56918417984435}]}
{"instance_id": "4c1015cd0618", "generation_result": [{"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\td := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"Grove Piezo Vibration Sensor\",\n\t}\n\n\td.AddEvent(Vibration)\n\n\td.AddEventHandler(d.handleVibrationEvent, Vibration)\n\n\treturn d\n}\n", "CodeBleu_score": 32.98577336591547}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\td := &GrovePiezoVibrationSensorDriver{}\n\td.SensorDriver = NewAnalogSensorDriver(a, pin, d, opts...)\n\td.SetName(\"Grove Piezo Vibration Sensor\")\n\n\td.AddEvent(Vibration)\n\n\tif err := d.SetDataTransformer(NewAnalogToDigital(1000)); err != nil {\n\t\tpanic(err)\n\t}\n\n\td.AddEvent(Vibration)\n\n\td.On(Data, func(data interface{}) {\n\t\tvibration := data.(int)\n\t\tif vibration > 1000 {\n\t\t\td.Publish(Vibration, 1)\n\t\t} else {\n\t\t\td.Publish(Vibration, 0)\n\t\t}\n\t})\n\n\treturn d\n}\n", "CodeBleu_score": 51.80379108831453}, {"code": "func NewGrovePiezoVibrationSensorDriver(\n\ta AnalogReader,\n\tpin string,\n\topts ...interface{},\n) *GrovePiezoVibrationSensorDriver\tg := &GrovePiezoVibrationSensorDriver{\n\t\tAnalogSensorDriver: NewAnalogSensorDriver(a, pin, opts...),\n\t\tname:               \"GrovePiezoVibrationSensor\",\n\t}\n\n\tg.AddEvent(VibrationEvent)\n\n\tg.AnalogSensorDriver.\n\t\tOn(Data, g.processData)\n\n\tif err := g.AnalogSensorDriver.OnData(func(data interface{}) {\n\t\tg.Publish(VibrationEvent, data)\n\t}); err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn g\n}\n", "CodeBleu_score": 46.96883257915456}]}
{"instance_id": "350571fc3b1f", "generation_result": [{"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\t// Calculate the tone period based on the frequency and the tempo\n\tperiod := (60.0 / d.bpm) * 1000.0 / hz\n\n\t// Calculate the number of times the tone should be played based on the duration\n\ttimes := duration / (period / 1000.0)\n\n\t// Toggle the buzzer on and off at intervals determined by the tone period\n\tfor i := 0; i < int(times); i++ {\n\t\td.buzzer.High()\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond / 2)\n\t\td.buzzer.Low()\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond / 2)\n\t}\n\n\treturn nil\n}\n", "CodeBleu_score": 39.558745827889815}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tperiod := time.Duration(float64(time.Second) / hz)\n\tbeatsPerMinute := float64(time.Second) / period\n\ttempo := beatsPerMinute * (duration / float64(time.Second))\n\tduration = float64(time.Second) / tempo\n\n\tfor i := 0; i < int(tempo); i++ {\n\t\td.Pin.High()\n\t\ttime.Sleep(duration / 2)\n\t\td.Pin.Low()\n\t\ttime.Sleep(duration / 2)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 32.147516250165296}, {"code": "func (d *BuzzerDriver) Tone(hz, duration float64) error\tperiod := (60 / d.BPM) * 1000\n\tdur := int(duration * 1000)\n\n\tfor i := 0; i < dur; i += int(period) {\n\t\terr := d.Pin.High()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond)\n\t\terr = d.Pin.Low()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttime.Sleep(time.Duration(period) * time.Millisecond)\n\t}\n\treturn nil\n}\n", "CodeBleu_score": 54.035883523334306}]}
{"instance_id": "1fea4ec469d8", "generation_result": [{"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif !d.sleepPin.IsSet() {\n\t\treturn fmt.Errorf(\"sleep pin is not set\")\n\t}\n\n\td.stop()\n\n\td.sleepPin.Set(false)\n\n\td.isSleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 27.066605427580527}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin not configured\")\n\t}\n\n\td.Stop()\n\n\tif err := d.sleepPin.Set(false); err != nil {\n\t\treturn err\n\t}\n\n\td.sleeping = true\n\n\treturn nil\n}\n", "CodeBleu_score": 45.255890850687905}, {"code": "func (d *EasyDriver) sleepWithSleepPin() error\tif d.sleepPin == nil {\n\t\treturn errors.New(\"sleep pin is not configured\")\n\t}\n\n\td.stop()\n\td.sleepPin.Low()\n\td.sleeping = true\n\treturn nil\n}\n", "CodeBleu_score": 29.827549574632318}]}
{"instance_id": "850129d49bbe", "generation_result": [{"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins map is not initialized\")\n\t}\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\tpin, err := a.initAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 48.001831752327874}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Analog pins map is not initialized\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpin, err := a.initAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 48.2604426709847}, {"code": "func (a *AnalogPinsAdaptor) analogPin(id string) (gobot.AnalogPinner, error)\tif a.pins == nil {\n\t\treturn nil, errors.New(\"Pins map is not initialized\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\treturn p, nil\n\t}\n\n\tpin, err := a.initAnalogPin(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = pin\n\treturn pin, nil\n}\n", "CodeBleu_score": 48.001831752327874}]}
{"instance_id": "773651aede82", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error     a.mutex.Lock()\n    defer a.mutex.Unlock()\n    pin, ok := a.digitalPins[id]\n    if !ok {\n        return errors.New(\"Pin with id \" + id + \" not found\")\n    }\n    if pin.Mode != \"output\" {\n        return errors.New(\"Pin with id \" + id + \" is not an output\")\n    }\n    if val != 0 && val != 1 {\n        return errors.New(\"Invalid value for digital write\")\n    }\n    err := a.pinWrite(pin.Pin, val)\n    return err\n}\n", "CodeBleu_score": 47.48548954430931}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mutex.Lock()\n\tdefer a.mutex.Unlock()\n\n\tpin, err := a.pin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpin.Write(val)\n\treturn nil\n}\n", "CodeBleu_score": 61.641602077347216}, {"code": "func (a *DigitalPinsAdaptor) DigitalWrite(id string, val byte) error \ta.mu.Lock()\n\tdefer a.mu.Unlock()\n\n\tpin, err := a.getPin(id)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif pin.Mode != gpio.Output {\n\t\treturn fmt.Errorf(\"pin %s is not in output mode\", id)\n\t}\n\n\tpin.Write(gpio.Level(val))\n\treturn nil\n}\n", "CodeBleu_score": 60.51798236129736}]}
{"instance_id": "2ab8ed2bd953", "generation_result": [{"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif !a.connected {\n\t\treturn nil, errors.New(\"Adaptor must be connected to pins\")\n\t}\n\n\tif p, ok := a.pins[id]; ok {\n\t\ta.applyOptions(p, opts...)\n\t\treturn p, nil\n\t}\n\n\tchip, line, err := a.pinIDToChipAndLine(id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp, err := a.gpio.DigitalPin(chip, line, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ta.pins[id] = p\n\n\treturn p, nil\n}\n", "CodeBleu_score": 49.10287685336938}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tif a.digitalPins == nil {\n\t\treturn nil, errors.New(\"digital pins adaptor is not connected to any pins\")\n\t}\n\n\tpin, ok := a.digitalPins[id]\n\tif !ok {\n\t\tchip, line, err := a.translatePin(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = gpio.NewDigitalPin(a.adaptor, chip, line)\n\t\tpin.SetName(id)\n\t\ta.digitalPins[id] = pin\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(pin); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 54.40117181513857}, {"code": "func (a *DigitalPinsAdaptor) digitalPin(\n\tid string,\n\topts ...func(gobot.DigitalPinOptioner) bool,\n) (gobot.DigitalPinner, error)\tpin, ok := a.digitalPins[id]\n\tif !ok {\n\t\tchip, line, err := a.translateID(id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpin = gpio.NewDigitalPin(a.connection, chip, line)\n\t\ta.digitalPins[id] = pin\n\n\t\tif err := pin.Init(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tif err := pin.ApplyOptions(opts...); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn pin, nil\n}\n", "CodeBleu_score": 57.75236809230043}]}
