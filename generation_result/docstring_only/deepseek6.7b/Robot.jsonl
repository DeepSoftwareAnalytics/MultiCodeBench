{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> files;\n    for (const auto &file : folder_files[folder]) {\n        if (download && !FileExists(file)) {\n            RequestFile(file);\n            Logger::Log(\"Downloading \" + file);\n        } else {\n            Logger::Log(\"Found \" + file + \" in cache\");\n        }\n        files.push_back(file);\n    }\n    return files;\n}\n", "CodeBleu_score": 50.59045080399772}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> files;\n    for (const auto &file : folder_files[folder]) {\n        if (download) {\n            if (!FileExists(file)) {\n                Logger::Log(\"Downloading \" + file);\n                RequestFile(file);\n            } else {\n                Logger::Log(\"Found \" + file + \" in cache\");\n            }\n        }\n        files.push_back(file);\n    }\n    return files;\n}\n", "CodeBleu_score": 52.51139469309882}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const    std::vector<std::string> files;\n\n    for (const auto &file : folder_files.at(folder)) {\n        files.push_back(file);\n        if (download) {\n            if (!FileExists(file)) {\n                RequestFile(file);\n                Logger::Log(\"Downloading file: \" + file);\n            } else {\n                Logger::Log(\"File found in cache: \" + file);\n            }\n        }\n    }\n\n    return files;\n}\n", "CodeBleu_score": 54.32589270116037}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    if (transform.translation.x != 0.0 || transform.translation.y != 0.0) {\n      LOG(WARNING) << \"SpringArm attachment type only supports z-axis \"\n                      \"translation, ignoring translation\";\n    }\n  }\n\n  rpc::Actor actor = SpawnActor(description, transform);\n  if (parent == kNullActorId) {\n    return actor;\n  }\n\n  return SpawnActorWithParentInternal(actor, parent, attachment_type,\n                                      socket_name);\n}\n", "CodeBleu_score": 44.85867066269553}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  // Check if the attachment type is SpringArm or SpringArmGhost and the\n  // translation is only in the 'z' axis.\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis.\n    if (transform.translation.x != 0.0 || transform.translation.y != 0.0) {\n      // Issue a warning if the translation is not in the 'z' axis.\n      LOG_WARNING(\"SpringArm attachment type requires the translation to be \"\n                  \"only in the 'z' axis. The translation will be ignored.\");\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process.\n  return SpawnActorWithParentInternal(description, transform, parent,\n                                      attachment_type, socket_name);\n}\n", "CodeBleu_score": 42.4916440300285}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)  // Check if the attachment type is SpringArm or SpringArmGhost.\n  if (attachment_type == rpc::AttachmentType::SpringArm ||\n      attachment_type == rpc::AttachmentType::SpringArmGhost) {\n    // Check if the translation is only in the 'z' axis.\n    if (transform.translation().x() == 0 && transform.translation().y() == 0 &&\n        transform.translation().z() != 0) {\n      // Issue a warning.\n      LOG(WARNING) << \"Attempting to spawn actor with SpringArm attachment type \"\n                      \"with translation only in the 'z' axis. This may lead to \"\n                      \"ill-formed transformations.\";\n    }\n  }\n\n  // Call the internal function to complete the actor spawning process.\n  return SpawnActorWithParentInternal(description, transform, parent,\n                                      attachment_type, socket_name);\n}\n", "CodeBleu_score": 45.20266063854789}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)  // Create a GBufferSubscription object\n  GBufferSubscription subscription;\n  subscription.ActorId = ActorId;\n  subscription.GBufferId = GBufferId;\n  subscription.Callback = callback;\n\n  // Add the subscription to the client's list of subscriptions\n  subscriptions_.push_back(subscription);\n\n  // Create a GBufferSubscriptionRequest message\n  rpc::GBufferSubscriptionRequest request;\n  request.set_actor_id(ActorId);\n  request.set_gbuffer_id(GBufferId);\n\n  // Send the request to the server\n  auto future = stub_->GBufferSubscription(&context_, request);\n\n  // Retrieve the token data from the response\n  auto response = future.get();\n  auto token = response.token();\n\n  // Copy the token data to the subscription\n  subscription.Token = token;\n\n  // Subscribe to the streaming client using the provided callback function\n  subscription.StreamingClient =\n      std::make_unique<rpc::GBufferSubscription::Stub>(\n          grpc::CreateCustomChannel(\n              \"localhost:50051\",\n              grpc::InsecureChannelCredentials(),\n              rpc::GBufferSubscription::NewStub));\n  subscription.StreamingClient->Subscribe(\n      &context_,\n      subscription.Token,\n      [&subscription](grpc::ClientContext* context,\n                      rpc::GBufferUpdate* update) {\n        // Call the callback function with the G-buffer data\n        subscription.Callback(update->gbuffer());\n        return grpc::Status::OK;\n      });\n}\n", "CodeBleu_score": 39.140791047028024}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\n  // Retrieve the token for the G-buffer\n  rpc::Token token = GetToken(ActorId, GBufferId);\n\n  // Copy the token data\n  Buffer token_data;\n  token_data.resize(token.ByteSizeLong());\n  token.SerializeToArray(token_data.data(), token_data.size());\n\n  // Subscribe to the streaming client using the provided callback function\n  SubscribeToStreamingClient(\n      ActorId,\n      GBufferId,\n      [this, callback](Buffer data) {\n        // Deserialize the G-buffer data\n        rpc::GBuffer gbuffer;\n        gbuffer.ParseFromArray(data.data(), data.size());\n\n        // Call the callback function with the G-buffer data\n        callback(gbuffer.data());\n      });\n}\n", "CodeBleu_score": 45.87331419231209}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)  /*\n   * The function first retrieves a token for the G-buffer using the provided ActorId and GBufferId.\n   * It then copies the token data into a Buffer object.\n   * Finally, the function subscribes to the streaming client using the provided callback function.\n   */\n  rpc::Token token = GetToken(ActorId, GBufferId);\n  Buffer buffer;\n  buffer.CopyFrom(token.data());\n  Subscribe(buffer, callback);\n}\n", "CodeBleu_score": 33.9503177175258}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()  if (!navigation) {\n    navigation = std::make_shared<WalkerNavigation>();\n    if (!navigation->SetEpisode(this)) {\n      navigation.reset();\n    }\n  }\n  return navigation;\n}\n", "CodeBleu_score": 32.15572561527926}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()  if (navigation_ == nullptr) {\n    navigation_ = std::make_shared<WalkerNavigation>(this);\n  }\n  return navigation_;\n}\n", "CodeBleu_score": 25.070452232599692}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()  if (navigation == nullptr) {\n    navigation = std::make_shared<WalkerNavigation>(this);\n  }\n  return navigation;\n}\n", "CodeBleu_score": 24.84225738665236}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)    // Check if the given frame is less than the current frame of the episode state.\n    if (frame < episode.frame) {\n        // If so, return false.\n        return false;\n    }\n\n    // Calculate the end time for the synchronization.\n    auto end = std::chrono::steady_clock::now() + timeout;\n\n    // Continuously check if the current frame of the episode state is less than the given frame.\n    while (frame > episode.frame) {\n        // If the current time is greater than the end time, return false.\n        if (std::chrono::steady_clock::now() > end) {\n            return false;\n        }\n\n        // Yield control for a short duration.\n        std::this_thread::yield();\n    }\n\n    // Trigger a tick in the TrafficManager.\n    TrafficManager::Tick();\n\n    // Return true if synchronization is successful.\n    return true;\n}\n", "CodeBleu_score": 40.548711263216134}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)  const auto start = std::chrono::high_resolution_clock::now();\n  while (episode.GetFrame() < frame) {\n    if (std::chrono::high_resolution_clock::now() - start > timeout) {\n      return false;\n    }\n    std::this_thread::yield();\n  }\n  TrafficManager::GetInstance().Tick();\n  return true;\n}", "CodeBleu_score": 38.65205172667859}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)    uint64_t current_frame = episode.GetFrame();\n    time_point start_time = std::chrono::steady_clock::now();\n    while (current_frame < frame) {\n        if (std::chrono::steady_clock::now() - start_time > timeout) {\n            return false;\n        }\n        current_frame = episode.GetFrame();\n        std::this_thread::yield();\n    }\n    TrafficManager::GetInstance().Tick();\n    return true;\n}\n", "CodeBleu_score": 43.15574800745048}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)    // If the episode is already loaded, unload it first\n    if (episode_id_ != -1) {\n        UnloadEpisode();\n    }\n\n    // Load the new episode\n    episode_id_ = rpc::LoadEpisode(map_name, reset_settings, map_layers);\n\n    // Wait for the episode to be connected\n    int attempts = 0;\n    while (attempts < kMaxAttempts && episode_id_ == -1) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(kAttemptIntervalMs));\n        episode_id_ = rpc::LoadEpisode(map_name, reset_settings, map_layers);\n        attempts++;\n    }\n\n    // If the episode was not connected within the allowed attempts, throw an exception\n    if (episode_id_ == -1) {\n        throw std::runtime_error(\"Failed to connect to the episode within the allowed attempts\");\n    }\n\n    // Return the episode object\n    return EpisodeProxy(episode_id_);\n}\n", "CodeBleu_score": 34.97471490209312}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)    // Create a new episode object\n    EpisodeProxy episode;\n\n    // Load the new episode\n    episode.Load(map_name, reset_settings, map_layers);\n\n    // Attempt to connect to the new episode\n    bool connected = false;\n    int attempts = 0;\n    while (!connected && attempts < MAX_ATTEMPTS) {\n        try {\n            // Connect to the new episode\n            episode.Connect();\n\n            // If the connection was successful, set the connected flag to true and break out of the loop\n            connected = true;\n        } catch (const std::runtime_error& e) {\n            // If the connection failed, wait for a short period and try again\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\n            attempts++;\n        }\n    }\n\n    // If the connection was not successful after MAX_ATTEMPTS attempts, throw an exception\n    if (!connected) {\n        throw std::runtime_error(\"Failed to connect to the new episode after \" + std::to_string(MAX_ATTEMPTS) + \" attempts.\");\n    }\n\n    // Return the episode object\n    return episode;\n}\n", "CodeBleu_score": 39.827991466920146}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)  // Check if the episode is already loaded\n  if (episode_proxy_.valid()) {\n    throw std::runtime_error(\"Cannot load a new episode while an episode is already loaded.\");\n  }\n\n  // Load the new episode\n  episode_proxy_ = client_.LoadEpisode(map_name, reset_settings, map_layers);\n\n  // Wait for the episode to be ready\n  int attempts = 0;\n  while (attempts < 10) {\n    if (episode_proxy_.valid() && episode_proxy_.GetEpisodeID() != \"\") {\n      break;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    attempts++;\n  }\n  if (attempts >= 10) {\n    throw std::runtime_error(\"Failed to connect to the new episode within the allowed attempts.\");\n  }\n\n  // Return the episode object\n  return episode_proxy_;\n}\n", "CodeBleu_score": 41.53406045392226}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  // Retrieve the walker associated with the controller\n  WalkerPtr walker = GetWalker(controller.GetID());\n  if (!walker) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n\n  // Assert that the episode is not null\n  assert(episode_ != nullptr);\n\n  // Create navigation if it is missing\n  if (!episode_->GetNavigation()) {\n    episode_->SetNavigation(std::make_shared<Navigation>());\n  }\n\n  // Register the walker with the controller's ID\n  episode_->GetNavigation()->RegisterAIController(walker, controller.GetID());\n}\n", "CodeBleu_score": 48.78037452409531}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  // Get the walker\n  WalkerPtr walker = GetWalker(controller.GetId());\n  if (walker == nullptr) {\n    throw std::runtime_error(\"Could not find walker with ID: \" + controller.GetId());\n  }\n\n  // Assert that the episode is not null\n  assert(episode_ != nullptr);\n\n  // Create navigation if it is missing\n  if (walker->GetNavigation() == nullptr) {\n    walker->SetNavigation(std::make_shared<WalkerNavigation>(walker));\n  }\n\n  // Register the walker with the controller's ID\n  walker->GetNavigation()->RegisterAIController(controller);\n}\n", "CodeBleu_score": 49.45088290558125}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)  // Get the walker associated with the controller\n  auto walker = controller.GetWalker();\n\n  // Throw an exception if the walker is not found\n  if (!walker) {\n    throw std::runtime_error(\"Walker not found\");\n  }\n\n  // Assert that the episode is not null\n  assert(episode);\n\n  // Create navigation if it is missing\n  if (!episode->GetNavigation()) {\n    episode->SetNavigation(std::make_shared<Navigation>());\n  }\n\n  // Register the walker with the controller's ID\n  episode->GetNavigation()->RegisterAIController(controller.GetID(), walker);\n}\n", "CodeBleu_score": 49.627944282246496}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  // Create the actor.\n  auto actor = std::make_shared<Actor>(blueprint, transform, parent,\n                                       attachment_type, socket_name);\n\n  // Register the actor with the simulation.\n  RegisterActor(actor, gc);\n\n  // Log the creation details.\n  LOG(INFO) << \"Spawned actor \" << actor->GetId() << \" of type \"\n            << actor->GetType() << \" at \" << actor->GetTransform().GetOrigin();\n\n  return actor;\n}\n", "CodeBleu_score": 30.96478643625966}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  // Create the actor\n  SharedPtr<Actor> actor = std::make_shared<Actor>(blueprint, transform);\n\n  // Set the parent\n  if (parent) {\n    actor->SetParent(parent);\n  }\n\n  // Set the attachment type and socket name\n  if (attachment_type != rpc::AttachmentType::NONE) {\n    actor->SetAttachment(attachment_type, socket_name);\n  }\n\n  // Register the actor\n  RegisterActor(actor, gc);\n\n  // Log the creation details\n  LOG_INFO(\"Spawned actor: \" + actor->GetName());\n\n  return actor;\n}\n", "CodeBleu_score": 32.515272995949346}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)  return SpawnActor(blueprint, transform, parent, attachment_type, gc, socket_name, false);\n}\n", "CodeBleu_score": 18.11164797720453}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (episode_ == nullptr) {\n    throw std::runtime_error(\n        \"Cannot subscribe to sensor before episode is started.\");\n  }\n  client_->SubscribeToStream(\n      sensor.id,\n      [this, sensor, callback](const std::string &data) {\n        auto sensor_data = sensor.data_spec.ParseFromString(data);\n        sensor_data->set_episode_id(episode_->id());\n        sensor_data->set_episode_step(episode_->step());\n        callback(sensor_data);\n      },\n      [this, sensor](const std::string &error) {\n        std::cerr << \"Error subscribing to sensor \" << sensor.id << \": \"\n                  << error << std::endl;\n      });\n}\n", "CodeBleu_score": 40.719961189227725}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (!episode_) {\n    throw std::runtime_error(\n        \"Cannot subscribe to sensor: episode is not valid\");\n  }\n  auto request = sensor.MakeSubscribeRequest(episode_->id());\n  client_->SubscribeToStream(request, [=](const grpc::Status &status,\n                                          const SensorData &data) {\n    if (!status.ok()) {\n      throw std::runtime_error(\n          \"Error subscribing to sensor: \" + status.error_message());\n    }\n    auto sensor_data = sensor.Deserialize(data);\n    sensor_data->set_episode_id(episode_->id());\n    callback(sensor_data);\n  });\n}\n", "CodeBleu_score": 45.59652379685036}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)  if (!IsEpisodeValid()) {\n    return;\n  }\n  client_->SubscribeToStream(\n      sensor,\n      [this, callback](const SharedPtr<sensor::SensorData> &data) {\n        data->episode_id = episode_id_;\n        callback(data);\n      });\n}\n", "CodeBleu_score": 31.35917330862812}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    auto walkers = episode->GetWalkers();\n    if (walkers.size() == 0) {\n        return;\n    }\n\n    auto state = episode->GetState();\n    for (auto it = walkers.begin(); it != walkers.end();) {\n        if (!state->ContainsWalker(*it)) {\n            it = walkers.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    std::vector<std::shared_ptr<Walker>> batch;\n    std::vector<std::shared_ptr<Walker>> removed;\n    for (auto walker : walkers) {\n        auto transform = walker->GetTransform();\n        auto speed = walker->GetSpeed();\n        batch.push_back(walker);\n        if (transform.position.x < -5000 || transform.position.x > 5000 ||\n            transform.position.y < -5000 || transform.position.y > 5000 ||\n            transform.position.z < -5000 || transform.position.z > 5000) {\n            removed.push_back(walker);\n        }\n    }\n\n    if (batch.size() > 0) {\n        auto vehicle_states = std::make_shared<VehicleStates>(batch.size());\n        for (int i = 0; i < batch.size(); ++i) {\n            auto walker = batch[i];\n            auto transform = walker->GetTransform();\n            auto speed = walker->GetSpeed();\n            auto rotation = walker->GetRotation();\n            vehicle_states->positions[i] = transform.position;\n            vehicle_states->rotations[i] = rotation;\n            vehicle_states->velocities[i] = speed;\n        }\n        episode->GetNavigation()->UpdateVehicles(vehicle_states);\n    }\n\n    if (removed.size() > 0) {\n        for (auto walker : removed) {\n            walker->GetController()->Kill();\n        }\n    }\n}\n", "CodeBleu_score": 46.93762501751115}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    // Load current walkers\n    std::vector<std::shared_ptr<Walker>> walkers = episode->GetWalkers();\n    if (walkers.empty()) {\n        return;\n    }\n\n    // Retrieve current state of episode\n    std::shared_ptr<State> state = episode->GetState();\n    std::vector<std::shared_ptr<Walker>> walkers_to_remove;\n    for (auto walker : walkers) {\n        if (!state->IsWalkerAlive(walker)) {\n            walkers_to_remove.push_back(walker);\n        }\n    }\n    for (auto walker : walkers_to_remove) {\n        walkers.erase(std::remove(walkers.begin(), walkers.end(), walker), walkers.end());\n    }\n\n    // Update vehicles in crowd and crowd itself in navigation module\n    std::vector<std::shared_ptr<Vehicle>> vehicles;\n    for (auto walker : walkers) {\n        vehicles.push_back(walker->GetVehicle());\n    }\n    navigation_->UpdateVehicles(vehicles);\n\n    // Update walkers in simulator\n    std::vector<Transform> transforms;\n    std::vector<float> speeds;\n    for (auto walker : walkers) {\n        transforms.push_back(walker->GetTransform());\n        speeds.push_back(walker->GetSpeed());\n    }\n    simulator_->SetWalkers(transforms, speeds);\n\n    // Check if any walker has been killed\n    for (auto walker : walkers) {\n        if (!state->IsWalkerAlive(walker)) {\n            // Remove walker from crowd\n            walker->GetVehicle()->Remove();\n\n            // Destroy walker's controller if it is dead\n            if (walker->GetController() != nullptr) {\n                walker->GetController()->Destroy();\n            }\n        }\n    }\n}", "CodeBleu_score": 41.32865473813277}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)    // Get the walkers from the episode\n    std::vector<std::shared_ptr<Walker>> walkers = episode->GetWalkers();\n\n    // Check if there are no walkers in the episode\n    if (walkers.empty()) {\n        return;\n    }\n\n    // Get the current state of the episode\n    std::shared_ptr<State> state = episode->GetState();\n\n    // Remove any walkers that no longer exist\n    walkers.erase(std::remove_if(walkers.begin(), walkers.end(), [&](const std::shared_ptr<Walker>& walker) {\n        return !state->GetEntity(walker->GetID());\n    }), walkers.end());\n\n    // Update the vehicles in the crowd and the crowd itself in the navigation module\n    for (const std::shared_ptr<Walker>& walker : walkers) {\n        // Get the transform and speed of the walker\n        Transform transform = walker->GetTransform();\n        Vector3 speed = walker->GetSpeed();\n\n        // Apply the transform and speed to the simulator\n        state->GetEntity(walker->GetID())->SetTransform(transform);\n        state->GetEntity(walker->GetID())->SetSpeed(speed);\n    }\n\n    // Check if any walker has been killed\n    for (const std::shared_ptr<Walker>& walker : walkers) {\n        if (walker->IsDead()) {\n            // Remove the walker from the crowd and destroy their controller\n            state->RemoveEntity(walker->GetID());\n            walker->GetController()->Destroy();\n        }\n    }\n}\n", "CodeBleu_score": 35.67918881976493}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.set_uid(uid);\n  description.set_id(id);\n  description.mutable_attributes()->Reserve(attributes.size());\n  for (const auto& attribute : attributes) {\n    auto* desc_attribute = description.add_attributes();\n    desc_attribute->set_name(attribute.first);\n    desc_attribute->set_value(attribute.second);\n  }\n  return description;\n}\n", "CodeBleu_score": 57.271941676295704}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const    rpc::ActorDescription description;\n    description.set_uid(uid);\n    description.set_id(id);\n    description.mutable_attributes()->Reserve(attributes.size());\n    for (const auto& attribute : attributes) {\n        *description.add_attributes() = attribute;\n    }\n    return description;\n}\n", "CodeBleu_score": 61.248192887026285}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const  rpc::ActorDescription description;\n  description.set_uid(uid_);\n  description.set_id(id_);\n\n  description.mutable_attributes()->Reserve(attributes_.size());\n  for (const auto& attribute : attributes_) {\n    description.mutable_attributes()->Add()->CopyFrom(attribute);\n  }\n\n  return description;\n}\n", "CodeBleu_score": 60.816487311989675}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n  for (const auto &blueprint : blueprints_) {\n    if (blueprint->HasAttribute(name)) {\n      const std::string &attr_value = blueprint->GetAttribute(name);\n      if (attr_value == value) {\n        result->AddBlueprint(blueprint);\n      }\n    }\n  }\n\n  return result;\n}\n", "CodeBleu_score": 37.17341356439052}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n  for (const auto &blueprint : blueprints_) {\n    if (blueprint->HasAttribute(name)) {\n      if (blueprint->GetAttribute(name) == value) {\n        result->AddBlueprint(blueprint);\n      }\n    }\n  }\n  return result;\n}\n", "CodeBleu_score": 31.714897099498224}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const  SharedPtr<BlueprintLibrary> result = MakeShared<BlueprintLibrary>();\n\n  for (const auto &blueprint : blueprints_) {\n    if (blueprint->HasAttribute(name)) {\n      if (blueprint->GetAttribute(name) == value ||\n          blueprint->GetAttribute(name + \"_recommended\") == value) {\n        result->AddBlueprint(blueprint);\n      }\n    }\n  }\n\n  return result;\n}\n", "CodeBleu_score": 36.12773160619587}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)  // Construct the full file path using the base folder and version information\n  std::string filePath = baseFolder + path + \"/\" + version + \".bin\";\n\n  // Validate the file path\n  if (!ValidateFilePath(filePath)) {\n    return false;\n  }\n\n  // Open the file in binary mode to truncate its contents\n  std::ofstream file(filePath, std::ios::binary | std::ios::trunc);\n\n  // Check if the file was successfully opened\n  if (!file.is_open()) {\n    return false;\n  }\n\n  // Write the content to the file\n  file.write(reinterpret_cast<const char*>(content.data()), content.size());\n\n  // Close the file\n  file.close();\n\n  return true;\n}\n", "CodeBleu_score": 46.382358907409795}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string fullPath = baseFolder + path + version;\n    if (!ValidateFilePath(fullPath)) {\n        return false;\n    }\n    std::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n    if (file.is_open()) {\n        file.write(reinterpret_cast<const char*>(&content[0]), content.size());\n        file.close();\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 45.93045288460972}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)    std::string file_path = base_folder + path + version;\n    if (!ValidatePath(file_path)) {\n        return false;\n    }\n\n    std::ofstream file(file_path, std::ios::binary | std::ios::trunc);\n    if (!file) {\n        return false;\n    }\n\n    file.write(reinterpret_cast<const char*>(&content[0]), content.size());\n    file.close();\n    return true;\n}\n", "CodeBleu_score": 45.21713082314231}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  // Compute the location of the bounding box\n  const geom::Vector3f location = transform.location + parent_bounds_->location;\n\n  // Compute the extents of the bounding box\n  const geom::Vector3f extents = parent_bounds_->extents;\n\n  // Compute the yaw angle of the bounding box\n  const float yaw = transform.rotation.yaw();\n\n  // Compute the corners of the bounding box\n  const geom::Vector3f corner0 = location + extents.Rotate(yaw, 0.0f, 0.0f);\n  const geom::Vector3f corner1 = location + extents.Rotate(yaw, 0.0f, 1.0f);\n  const geom::Vector3f corner2 = location + extents.Rotate(yaw, 1.0f, 1.0f);\n  const geom::Vector3f corner3 = location + extents.Rotate(yaw, 1.0f, 0.0f);\n\n  // Create a new Bounds object and return a shared pointer to it\n  return std::make_shared<const Bounds>(frame, corner0, corner1, corner2, corner3);\n}\n", "CodeBleu_score": 46.36211730842078}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  // Get the parent's bounding box\n  const auto &parent_bounds = parent_bounds_[frame];\n\n  // Compute the location of the bounding box\n  const geom::Vector3 location =\n      transform.location + parent_bounds.location;\n\n  // Compute the four corners of the bounding box\n  const geom::Vector3 extents = parent_bounds.extents;\n  const float yaw = transform.rotation.yaw;\n  const geom::Vector3 forward = geom::Vector3::ForwardVector();\n  const geom::Vector3 right = geom::Vector3::RightVector();\n  const geom::Vector3 up = geom::Vector3::UpVector();\n  const geom::Vector3 corner0 =\n      location + forward * extents.x + right * extents.y + up * extents.z;\n  const geom::Vector3 corner1 =\n      location + forward * extents.x + right * extents.y - up * extents.z;\n  const geom::Vector3 corner2 =\n      location + forward * extents.x - right * extents.y + up * extents.z;\n  const geom::Vector3 corner3 =\n      location + forward * extents.x - right * extents.y - up * extents.z;\n  const geom::Vector3 corner4 =\n      location - forward * extents.x + right * extents.y + up * extents.z;\n  const geom::Vector3 corner5 =\n      location - forward * extents.x + right * extents.y - up * extents.z;\n  const geom::Vector3 corner6 =\n      location - forward * extents.x - right * extents.y + up * extents.z;\n  const geom::Vector3 corner7 =\n      location - forward * extents.x - right * extents.y - up * extents.z;\n\n  // Return a shared pointer to a Bounds object containing the frame number and\n  // the calculated corners\n  return std::make_shared<const Bounds>(\n      frame,\n      std::vector<geom::Vector3>{", "CodeBleu_score": 40.99261865855424}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const  // Create a bounding box based on the extents of the object\n  geom::Vector3<double> extents = transform.Extents();\n  geom::Pose<double> pose = transform.GetAsPose();\n  geom::Pose<double> parent_pose = transform.GetParentPose();\n  geom::Pose<double> pose_in_parent = pose.GetAsPoseInParent();\n\n  // Compute the four corners of the bounding box\n  geom::Vector3<double> top_left = pose_in_parent.ShiftPoint(\n      geom::Vector3<double>(-extents.x(), extents.y(), 0.0));\n  geom::Vector3<double> top_right = pose_in_parent.ShiftPoint(\n      geom::Vector3<double>(extents.x(), extents.y(), 0.0));\n  geom::Vector3<double> bottom_right = pose_in_parent.ShiftPoint(\n      geom::Vector3<double>(extents.x(), -extents.y(), 0.0));\n  geom::Vector3<double> bottom_left = pose_in_parent.ShiftPoint(\n      geom::Vector3<double>(-extents.x(), -extents.y(), 0.0));\n\n  // Create a Bounds object and return a shared pointer to it\n  auto bounds = std::make_shared<Bounds>();\n  bounds->frame = frame;\n  bounds->corners = {top_left, top_right, bottom_right, bottom_left};\n  return bounds;\n}\n", "CodeBleu_score": 36.54058237692339}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()    std::lock_guard<std::mutex> lock(m_mutex);\n\n    // Query the server for the current state of all lights\n    std::vector<LightState> lightStates = m_server.QueryLightStates();\n\n    // Update the local light states\n    for (const auto& lightState : lightStates) {\n        // If the light already exists in the map, update its state\n        auto it = m_lights.find(lightState.id);\n        if (it != m_lights.end()) {\n            it->second->UpdateState(lightState);\n        }\n        // Otherwise, create a new light object and add it to the map\n        else {\n            m_lights[lightState.id] = std::make_shared<Light>(lightState);\n        }\n    }\n}\n", "CodeBleu_score": 36.98731915754278}, {"code": "void LightManager::QueryLightsStateToServer()    std::lock_guard<std::mutex> lock(_mutex);\n    auto lightStates = _server->GetLightStates();\n    for (auto& lightState : lightStates) {\n        auto light = _lights.find(lightState.id);\n        if (light == _lights.end()) {\n            _lights[lightState.id] = std::make_shared<Light>(lightState.id, lightState.name, lightState.type, lightState.position, lightState.direction, lightState.color, lightState.intensity, lightState.range, lightState.innerAngle, lightState.outerAngle, lightState.on, lightState.isShadowCaster);\n        } else {\n            light->second->SetState(lightState);\n        }\n    }\n}\n", "CodeBleu_score": 37.558211662937495}, {"code": "void LightManager::QueryLightsStateToServer()  std::lock_guard<std::mutex> lock(mutex);\n  std::vector<LightState> lightStates = server->GetLightsState();\n  for (const auto& lightState : lightStates) {\n    if (_lights.find(lightState.id) == _lights.end()) {\n      _lights[lightState.id] = std::make_shared<Light>(lightState.id, server);\n    }\n    _lights[lightState.id]->SetState(lightState);\n  }\n}\n", "CodeBleu_score": 34.57925314002}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)    std::lock_guard<std::mutex> lock(mutex_);\n    if (dirty_) {\n        dirty_ = false;\n\n        // Create a message with the updated light states\n        std::shared_ptr<Message> message = std::make_shared<Message>(MessageType::LIGHT_UPDATE);\n        message->SetData(light_states_);\n\n        // Send the message to the server\n        if (discard_client) {\n            server_->SendMessageToServer(message);\n        } else {\n            server_->SendMessageToClient(message);\n        }\n    }\n}\n", "CodeBleu_score": 26.535623192424957}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)    std::lock_guard<std::mutex> lock(light_mutex);\n    if (dirty) {\n        std::vector<uint8_t> message;\n        message.push_back(static_cast<uint8_t>(MessageType::LightUpdate));\n        message.push_back(static_cast<uint8_t>(lights.size()));\n        for (const auto& light : lights) {\n            message.push_back(light.first);\n            message.push_back(static_cast<uint8_t>(light.second.state));\n            message.push_back(static_cast<uint8_t>(light.second.color.r));\n            message.push_back(static_cast<uint8_t>(light.second.color.g));\n            message.push_back(static_cast<uint8_t>(light.second.color.b));\n        }\n        if (discard_client) {\n            server->SendMessageToAllClients(message);\n        } else {\n            server->SendMessageToAllClientsExcept(message, client_id);\n        }\n        dirty = false;\n    }\n}\n", "CodeBleu_score": 45.895092708857874}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)    std::lock_guard<std::mutex> lock(mutex);\n    if (dirty) {\n        std::vector<LightState> new_light_states;\n        for (auto& light_state : light_states) {\n            new_light_states.push_back(light_state);\n        }\n        dirty = false;\n        if (discard_client) {\n            new_light_states.clear();\n        }\n        std::shared_ptr<Message> message = std::make_shared<Message>(Message::MessageType::LIGHT_STATE_UPDATE, new_light_states);\n        server->SendMessageToServer(message);\n    }\n}\n", "CodeBleu_score": 35.66016858521089}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)  if (sensor_id_ != \"sensor.other.v2x_custom\") {\n    LOG_WARNING << \"Sensor ID does not match: \" << sensor_id_;\n    return;\n  }\n\n  // Send message to episode\n  context_->Send(message);\n}", "CodeBleu_score": 39.25163108349798}, {"code": "void ServerSideSensor::Send(std::string message)  if (sensor_id_ != \"sensor.other.v2x_custom\") {\n    LOG(WARNING) << \"ServerSideSensor: Send called with sensor ID \"\n                 << sensor_id_ << \" instead of sensor.other.v2x_custom\";\n    return;\n  }\n  episode_->Send(message);\n}", "CodeBleu_score": 43.70702405325981}, {"code": "void ServerSideSensor::Send(std::string message)  // Check if the sensor's ID matches \"sensor.other.v2x_custom\"\n  if (id_ != \"sensor.other.v2x_custom\") {\n    // Log a warning message\n    LOG(WARNING) << \"Sensor ID does not match 'sensor.other.v2x_custom'\";\n    return;\n  }\n\n  // Send the message to the episode using the sensor's context\n  context_->Send(message);\n}\n", "CodeBleu_score": 41.90089695506746}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)  // Check if the vehicle is already registered with the traffic manager\n  if (autopilot_enabled && tm_port == traffic_manager_port) {\n    // If the vehicle is already registered, do nothing\n    return;\n  }\n\n  // If the vehicle is not already registered, register or unregister it\n  if (enabled) {\n    // Register the vehicle with the traffic manager\n    RegisterWithTrafficManager(tm_port);\n  } else {\n    // Unregister the vehicle from the traffic manager\n    UnregisterFromTrafficManager();\n  }\n}\n", "CodeBleu_score": 36.90982165590542}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)  if (enabled) {\n    // Register the vehicle with the traffic manager\n    // Create a traffic manager message\n    MavlinkCommands::CommandLong tm_cmd;\n    tm_cmd.command = MAV_CMD_DO_SET_MODE;\n    tm_cmd.param1 = MAV_MODE_PREFLIGHT;\n    tm_cmd.param2 = MAV_MODE_GUIDED_ENABLED;\n    tm_cmd.param3 = 0;\n    tm_cmd.param4 = 0;\n    tm_cmd.param5 = 0;\n    tm_cmd.param6 = 0;\n    tm_cmd.param7 = 0;\n    tm_cmd.target_system = GetSystemID();\n    tm_cmd.target_component = MAV_COMP_ID_ALL;\n    tm_cmd.confirmation = false;\n\n    // Send the traffic manager message\n    mavlink_message_t msg;\n    mavlink_msg_command_long_encode(GetSystemID(), MAV_COMP_ID_ALL, &msg, &tm_cmd);\n    SendMessage(msg, tm_port);\n  } else {\n    // Unregister the vehicle from the traffic manager\n    // Create a traffic manager message\n    MavlinkCommands::CommandLong tm_cmd;\n    tm_cmd.command = MAV_CMD_DO_SET_MODE;\n    tm_cmd.param1 = MAV_MODE_PREFLIGHT;\n    tm_cmd.param2 = MAV_MODE_GUIDED_ENABLED;\n    tm_cmd.param3 = 0;\n    tm_cmd.param4 = 0;\n    tm_cmd.param5 = 0;\n    tm_cmd.param6 = 0;\n    tm_cmd.param7 = 0;\n    tm_cmd.target_system = GetSystemID();\n    tm_cmd.target_component = MAV_COMP_ID_ALL;\n    tm_cmd.confirmation = false;\n\n    // Send the traffic manager message\n    mavlink_message_t msg;\n    mavlink", "CodeBleu_score": 35.587162275445316}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)    if (enabled) {\n        // Register the vehicle with the traffic manager\n        std::stringstream ss;\n        ss << \"vehicle_register --tm_port_=\" << tm_port << \" --vehicle_name_=\" << name_ << \" --start_=true\";\n        std::string cmd = ss.str();\n        system(cmd.c_str());\n    } else {\n        // Unregister the vehicle from the traffic manager\n        std::stringstream ss;\n        ss << \"vehicle_register --tm_port_=\" << tm_port << \" --vehicle_name_=\" << name_ << \" --start_=false\";\n        std::string cmd = ss.str();\n        system(cmd.c_str());\n    }\n}\n", "CodeBleu_score": 40.81583682898341}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()\tSuper::Start();\n\n\tAWalker* Walker = Cast<AWalker>(GetPawn());\n\tif (Walker) {\n\t\tUNavigationSystemV1* NavigationSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n\t\tif (NavigationSystem) {\n\t\t\tNavigationSystem->RegisterOnNavigationBoundsUpdatedDelegate(Walker, FNavigationBoundsUpdatedDelegate::CreateUObject(this, &WalkerAIController::OnNavigationBoundsUpdated));\n\t\t}\n\t\tWalker->GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToAllChannels(ECR_Ignore);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Pawn, ECR_Overlap);\n\t\tWalker->GetCapsuleComponent()->SetCollisionResponseToChannel(ECC_Visibility, ECR_Block);\n\t}\n}\n", "CodeBleu_score": 35.46228872493178}, {"code": "void WalkerAIController::Start()    // Retrieve the walker actor and add it to the navigation system\n    WalkerActor = GetOwner();\n    WalkerActor->GetNavigationSystem()->AddActor(WalkerActor, WalkerActor->GetActorLocation());\n\n    // Disable physics simulation and collisions for the walker actor\n    WalkerActor->SetActorEnableCollision(false);\n    WalkerActor->SetActorHiddenInGame(false);\n    WalkerActor->SetActorTickEnabled(false);\n}\n", "CodeBleu_score": 25.873568515317746}, {"code": "void WalkerAIController::Start()    // Get the walker actor\n    walker = GetOwner()->GetComponent<Walker>();\n    if (!walker) {\n        UE_LOG(LogTemp, Error, TEXT(\"WalkerAIController: Walker component not found on actor %s\"), *GetOwner()->GetName());\n        return;\n    }\n\n    // Add the walker actor to the navigation system\n    NavigationSystem = UNavigationSystemV1::GetCurrent(GetWorld());\n    NavigationSystem->RegisterNavigationInvoker(walker);\n    NavigationSystem->Build(*walker);\n\n    // Disable the physics simulation and collisions for the walker actor\n    walker->GetOwner()->SetActorEnableCollision(false);\n    walker->GetOwner()->SetActorHiddenInGame(false);\n}\n", "CodeBleu_score": 44.96240543543969}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  // Get the navigation instance from the current episode\n  auto* nav_instance = GetEpisode().GetNavMesh();\n  if (!nav_instance) {\n    LOG(WARNING) << \"Could not get navigation instance\";\n    return;\n  }\n\n  // Get the parent walker\n  auto* walker = GetParent();\n  if (!walker) {\n    LOG(WARNING) << \"Could not get parent walker\";\n    return;\n  }\n\n  // Set the maximum speed using the navigation instance\n  if (!nav_instance->SetMaxSpeed(walker, max_speed)) {\n    LOG(WARNING) << \"Could not set maximum speed\";\n  }\n}", "CodeBleu_score": 46.62029397900913}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  // Get the navigation instance from the current episode\n  auto navigation_instance = GetNavigationInstance();\n  if (!navigation_instance) {\n    // Log a warning if the navigation instance is not found\n    LOG_WARNING(\"Navigation instance not found for walker %d\", GetWalkerId());\n    return;\n  }\n\n  // Get the parent walker\n  auto parent_walker = navigation_instance->GetParentWalker();\n  if (!parent_walker) {\n    // Log a warning if the parent walker is not found\n    LOG_WARNING(\"Parent walker not found for walker %d\", GetWalkerId());\n    return;\n  }\n\n  // Attempt to set the maximum speed for the walker\n  if (!parent_walker->SetMaxSpeed(max_speed)) {\n    // Log a warning if setting the speed fails\n    LOG_WARNING(\"Failed to set maximum speed for walker %d\", GetWalkerId());\n  }\n}\n", "CodeBleu_score": 43.30754931900298}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)  // Get the navigation instance from the current episode\n  auto* navigation = GetEpisode()->GetNavigation();\n  if (!navigation) {\n    LOG_WARNING(\"Navigation instance is not found.\");\n    return;\n  }\n\n  // Get the parent walker\n  auto* walker = GetParent();\n  if (!walker) {\n    LOG_WARNING(\"Walker is not found.\");\n    return;\n  }\n\n  // Set the maximum speed using the navigation instance\n  if (!navigation->SetMaxSpeed(walker, max_speed)) {\n    LOG_WARNING(\"Failed to set the maximum speed.\");\n  }\n}", "CodeBleu_score": 51.45602477409214}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const    // Get the previous waypoints from the parent map\n    std::vector<SharedPtr<Waypoint>> previous_waypoints = parent_map_->GetPrevious(this, distance);\n\n    // Create a new vector to store the result\n    std::vector<SharedPtr<Waypoint>> result;\n\n    // Loop through the previous waypoints and create a new Waypoint object for each one\n    for (auto& waypoint : previous_waypoints) {\n        // Create a new Waypoint object\n        SharedPtr<Waypoint> new_waypoint = make_shared<Waypoint>(waypoint->GetPosition(), waypoint->GetID(), waypoint->GetParentMap());\n\n        // Add the new Waypoint object to the result vector\n        result.push_back(new_waypoint);\n    }\n\n    // Return the result vector\n    return result;\n}\n", "CodeBleu_score": 56.86008317257269}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const  std::vector<SharedPtr<Waypoint>> result;\n  std::vector<SharedPtr<Waypoint>> prev_waypoints = map_->GetPrevious(id_, distance);\n  for (auto& waypoint : prev_waypoints) {\n    result.push_back(std::make_shared<Waypoint>(waypoint->id_, waypoint->map_));\n  }\n  return result;\n}\n", "CodeBleu_score": 56.97500225461467}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const    std::vector<SharedPtr<Waypoint>> result;\n    std::vector<SharedPtr<Waypoint>> waypoints = map_->GetPreviousWaypoints(id_, distance);\n    for (auto& waypoint : waypoints) {\n        result.push_back(make_shared<Waypoint>(waypoint));\n    }\n    return result;\n}\n", "CodeBleu_score": 49.76908292079483}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> landmarks;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n  for (auto signal : signals) {\n    bool found = false;\n    for (auto landmark : landmarks) {\n      if (landmark->GetSignal() == signal) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      landmarks.push_back(MakeShared<Landmark>(signal, GetPosition()));\n    }\n  }\n  return landmarks;\n}\n", "CodeBleu_score": 41.147905399360326}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Landmark>> result;\n  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::unordered_set<SharedPtr<Signal>> unique_signals;\n  for (const auto& signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      result.push_back(std::make_shared<Landmark>(signal, distance));\n    }\n  }\n  if (stop_at_junction) {\n    std::vector<SharedPtr<Signal>> junction_signals =\n        GetJunctionSignalsInDistance(distance);\n    for (const auto& signal : junction_signals) {\n      if (unique_signals.find(signal) == unique_signals.end()) {\n        unique_signals.insert(signal);\n        result.push_back(std::make_shared<Landmark>(signal, distance));\n      }\n    }\n  }\n  return result;\n}\n", "CodeBleu_score": 47.520164383095}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const  std::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n  std::vector<SharedPtr<Landmark>> landmarks;\n  std::unordered_set<SharedPtr<Signal>> unique_signals;\n\n  for (auto& signal : signals) {\n    if (unique_signals.find(signal) == unique_signals.end()) {\n      unique_signals.insert(signal);\n      landmarks.push_back(SharedPtr<Landmark>(new Landmark(signal)));\n    }\n  }\n\n  return landmarks;\n}\n", "CodeBleu_score": 35.65356905237179}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  // Set the timeout\n  if (timeout == time_duration()) {\n    timeout = settings.network_timeout();\n  }\n  timeout_ = timeout;\n\n  // Set the fixed delta time\n  if (settings.fixed_delta_time() != 0) {\n    fixed_delta_time_ = settings.fixed_delta_time();\n    fixed_delta_time_verified_ = VerifyFixedDeltaTime();\n  }\n\n  // Set the settings\n  settings_ = settings;\n  return settings_.id();\n}\n", "CodeBleu_score": 18.988633643628845}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)  // Set local timeout based on provided timeout or episode's timeout\n  time_duration local_timeout = timeout;\n  if (local_timeout == time_duration()) {\n    local_timeout = time_duration(std::chrono::seconds(settings.timeout()));\n  }\n\n  // Verify delta time if provided\n  if (settings.has_fixed_delta_time()) {\n    // Set fixed delta time\n    if (!SetFixedDeltaTime(settings.fixed_delta_time())) {\n      LOG(WARNING) << \"Failed to set fixed delta time\";\n    }\n\n    // Verify accuracy of fixed delta time over a series of ticks\n    const int kNumTicks = 10;\n    const double kDeltaTimeTolerance = 1e-5;\n    for (int i = 0; i < kNumTicks; ++i) {\n      time_duration delta_time = GetFixedDeltaTime();\n      if (std::abs(delta_time.count() - settings.fixed_delta_time()) > kDeltaTimeTolerance) {\n        LOG(WARNING) << \"Fixed delta time is not accurate after \" << i << \" ticks\";\n        break;\n      }\n      Step(false);\n    }\n  }\n\n  // Set the local timeout\n  SetLocalTimeout(local_timeout);\n\n  // Return the identifier of the applied settings\n  return GetSettingsIdentifier();\n}\n", "CodeBleu_score": 45.625052028175475}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)    // Set the local timeout based on the provided timeout or the episode's networking timeout\n    time_duration local_timeout = timeout == time_duration::zero() ? m_networking_timeout : timeout;\n\n    // Apply the provided episode settings\n    m_settings = settings;\n\n    // If the settings include a fixed delta time, verify the accuracy of this setting over a series of ticks\n    if (settings.has_fixed_delta_time()) {\n        // Attempt to verify the accuracy of the fixed delta time over a series of ticks\n        for (int i = 0; i < 10; i++) {\n            // Sleep for the fixed delta time\n            std::this_thread::sleep_for(settings.fixed_delta_time());\n\n            // Verify that the fixed delta time was applied correctly\n            if (m_fixed_delta_time != settings.fixed_delta_time()) {\n                // Log a warning if the fixed delta time was not applied correctly\n                LOG_WARNING(\"Failed to apply fixed delta time: {}\", m_fixed_delta_time);\n\n                // Set the fixed delta time to the provided value\n                m_fixed_delta_time = settings.fixed_delta_time();\n            }\n        }\n    }\n\n    // Return a unique identifier for the applied settings\n    return m_settings.GetHash();\n}\n", "CodeBleu_score": 31.501174130445452}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint    const Vector2f& point,\n    const Vector2f& start,\n    const Vector2f& end\n} {\n    Vector2f direction = end - start;\n    float lengthSq = direction.LengthSquared();\n    float length = std::sqrt(lengthSq);\n    if (lengthSq == 0.0f) {\n        return std::make_pair(0.0f, (point - start).Length());\n    }\n\n    float t = std::max(0.0f, std::min(1.0f, direction.Dot(point - start) / lengthSq));\n    Vector2f projection = start + t * direction;\n    return std::make_pair(t * length, (point - projection).Length());\n}", "CodeBleu_score": 46.54226682950071}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint    const glm::vec2& p1,\n    const glm::vec2& p2,\n    const glm::vec2& p\n} {\n    glm::vec2 v = p2 - p1;\n    glm::vec2 w = p - p1;\n    float c1 = glm::dot(w, v);\n    if (c1 <= 0)\n        return std::make_pair(glm::length(p1 - p), 0.f);\n    float c2 = glm::dot(v, v);\n    if (c2 <= c1)\n        return std::make_pair(glm::length(p2 - p), 0.f);\n    float b = c1 / c2;\n    glm::vec2 pb = p1 + b * v;\n    return std::make_pair(glm::length(pb - p), glm::length(pb - p));\n}\n", "CodeBleu_score": 42.9457244993268}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint    const Vector2f& segmentStart,\n    const Vector2f& segmentEnd,\n    const Vector2f& point,\n    float* outSegmentDistance = nullptr,\n    float* outPointDistance = nullptr\n} {\n    Vector2f segment = segmentEnd - segmentStart;\n    float segmentLengthSquared = segment.LengthSquared();\n    float segmentLength = std::sqrt(segmentLengthSquared);\n    if (segmentLength == 0.0f) {\n        if (outSegmentDistance) {\n            *outSegmentDistance = 0.0f;\n        }\n        if (outPointDistance) {\n            *outPointDistance = (segmentStart - point).Length();\n        }\n        return std::make_pair(0.0f, (segmentStart - point).Length());\n    }\n\n    float t = (point - segmentStart).Dot(segment) / segmentLengthSquared;\n    t = std::max(0.0f, std::min(1.0f, t));\n\n    Vector2f projection = segmentStart + t * segment;\n    float segmentDistance = (projection - point).Length();\n    float pointDistance = (projection - segmentStart).Length();\n\n    if (outSegmentDistance) {\n        *outSegmentDistance = segmentDistance;\n    }\n    if (outPointDistance) {\n        *outPointDistance = pointDistance;\n    }\n    return std::make_pair(segmentDistance, pointDistance);\n}\n", "CodeBleu_score": 37.78081334222122}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n    index_type initial_index = mesh_vertices.size();\n    for (const auto &vertex : vertices) {\n        mesh_vertices.push_back(vertex);\n    }\n    for (index_type i = 1; i < vertices.size() - 1; ++i) {\n        mesh_indices.push_back(initial_index);\n        mesh_indices.push_back(initial_index + i);\n        mesh_indices.push_back(initial_index + i + 1);\n    }\n}\n", "CodeBleu_score": 42.01678336325278}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n    unsigned int initialIndex = m_vertices.size();\n    m_vertices.insert(m_vertices.end(), vertices.begin(), vertices.end());\n    for (unsigned int i = 2; i < vertices.size(); i++) {\n        m_indices.push_back(initialIndex);\n        m_indices.push_back(initialIndex + i - 1);\n        m_indices.push_back(initialIndex + i);\n    }\n}", "CodeBleu_score": 48.19048951565279}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)    assert(vertices.size() >= 3);\n    size_t initial_index = m_vertices.size();\n    m_vertices.insert(m_vertices.end(), vertices.begin(), vertices.end());\n    for (size_t i = 2; i < vertices.size(); ++i) {\n        m_indices.push_back(initial_index);\n        m_indices.push_back(initial_index + i - 1);\n        m_indices.push_back(initial_index + i);\n    }\n}\n", "CodeBleu_score": 49.77260600359196}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (message->IsValid()) {\n    _strand.post([this, message]() {\n      if (_socket.is_open()) {\n        boost::asio::deadline_timer timer(_socket.get_executor());\n        timer.expires_after(std::chrono::milliseconds(100));\n        timer.async_wait([this, message](const boost::system::error_code &error) {\n          if (!error) {\n            boost::asio::async_write(_socket, boost::asio::buffer(message->GetBuffer()),\n                                     [this, message](const boost::system::error_code &error, std::size_t) {\n                                       handle_sent(message, error);\n                                     });\n          } else {\n            handle_sent(message, error);\n          }\n        });\n      } else {\n        handle_sent(message, boost::system::errc::make_error_code(boost::system::errc::not_connected));\n      }\n    });\n  } else {\n    log_error(\"Invalid message\");\n  }\n}\n", "CodeBleu_score": 37.3033973069475}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)  if (message == nullptr) {\n    return;\n  }\n  auto self = shared_from_this();\n  _strand.post([self, message]() {\n    if (self->_socket.is_open()) {\n      self->_socket.set_option(boost::asio::ip::tcp::no_delay(true));\n      self->_socket.set_option(boost::asio::socket_base::send_buffer_size(1024 * 1024));\n      self->_socket.set_option(boost::asio::socket_base::receive_buffer_size(1024 * 1024));\n      self->_socket.set_option(boost::asio::socket_base::keep_alive(true));\n      self->_socket.set_option(boost::asio::socket_base::do_not_route(true));\n      self->_socket.set_option(boost::asio::socket_base::linger(true, 0));\n      self->_socket.set_option(boost::asio::ip::tcp::no_delay(true));\n      self->_socket.set_option(boost::asio::socket_base::reuse_address(true));\n      self->_socket.set_option(boost::asio::socket_base::keep_alive(true));\n      self->_socket.set_option(boost::asio::socket_base::do_not_route(true));\n      self->_socket.set_option(boost::asio::socket_base::linger(true, 0));\n      self->_socket.set_option(boost::asio::ip::tcp::no_delay(true));\n      self->_socket.set_option(boost::asio::socket_base::reuse_address(true));\n      self->_socket.set_option(boost::asio::socket_base::keep_alive(true));\n      self->_socket.set_option(boost::asio::socket_base::do_not_route(true));\n      self->_socket.set_option(boost::", "CodeBleu_score": 34.18492459524858}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)    if (message == nullptr) {\n        throw std::invalid_argument(\"message is null\");\n    }\n    if (!message->IsValid()) {\n        throw std::invalid_argument(\"message is not valid\");\n    }\n    _strand.post([this, message]() {\n        if (_socket.is_open()) {\n            boost::asio::deadline_timer timer(_socket.get_executor());\n            timer.expires_after(std::chrono::milliseconds(1000));\n            timer.async_wait([this, message](const boost::system::error_code &error) {\n                if (!error) {\n                    boost::asio::async_write(_socket, boost::asio::buffer(message->GetData()),\n                                             [this, message](const boost::system::error_code &error, std::size_t) {\n                                                 HandleSent(error, message);\n                                             });\n                } else {\n                    HandleSent(error, message);\n                }\n            });\n        } else {\n            HandleSent(boost::asio::error::not_connected, message);\n        }\n    });\n}\n", "CodeBleu_score": 40.0029551102609}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)    if (!ec) {\n        // Make the deadline always equal to the end of this handler's time\n        // slice, so we can time out if the connection has been idle.\n        deadline.expires_at(deadline.expires_at() + deadline_timer_interval);\n\n        // Cancel the timer.\n        deadline.cancel();\n\n        // Perform the socket shutdown.\n        boost::system::error_code ignored_ec;\n        socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n    }\n\n    // At this point the client is closed gracefully\n    if (on_closed) {\n        on_closed(ec);\n    }\n\n    if (ec) {\n        Logger::log(Logger::Level::Error, \"Session closed with error: \" + ec.message());\n    } else {\n        Logger::log(Logger::Level::Info, \"Session closed\");\n    }\n}\n", "CodeBleu_score": 52.99899957563517}, {"code": "void Primary::CloseNow(boost::system::error_code ec)  if (ec) {\n    // If an error code was provided to the close request, log it\n    Logger::Log(ec, \"Error closing socket\");\n  }\n\n  if (ec != boost::asio::error::operation_aborted) {\n    // If the deadline handler did not trigger an abort, shut down and close the socket\n    if (socket.is_open()) {\n      boost::system::error_code ignored_ec;\n      socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n      socket.close(ignored_ec);\n    }\n\n    // Trigger the on_closed callback\n    on_closed();\n\n    // Log that the session has been closed\n    Logger::Log(\"Session closed\");\n  }\n}\n", "CodeBleu_score": 51.15160644245319}, {"code": "void Primary::CloseNow(boost::system::error_code ec)  if (!ec) {\n    // Make the deadline expire now.\n    deadline_.cancel();\n\n    // Perform the socket shutdown.\n    boost::system::error_code ignored_ec;\n    socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n  }\n\n  // No matter what, close the socket.\n  socket_.close();\n\n  // Trigger the on_closed callback.\n  on_closed();\n\n  // Log the session closing.\n  LOG_INFO(logger, \"Session closed\");\n}\n", "CodeBleu_score": 53.406587706933784}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()    std::string message = \"Are you alive?\";\n    char buffer[100];\n    strcpy(buffer, message.c_str());\n    std::cout << \"Sending message: \" << message << std::endl;\n    int command = YOU_ALIVE;\n    int length = strlen(buffer);\n    int total_length = length + sizeof(command);\n    char *buffer_to_send = new char[total_length];\n    memcpy(buffer_to_send, &command, sizeof(command));\n    memcpy(buffer_to_send + sizeof(command), buffer, length);\n    int bytes_sent = sendto(sockfd, buffer_to_send, total_length, 0, (struct sockaddr *)&server_address, sizeof(server_address));\n    if (bytes_sent == -1) {\n        std::cout << \"Error sending message\" << std::endl;\n    }\n    std::cout << \"Message sent successfully\" << std::endl;\n    delete[] buffer_to_send;\n    char recv_buffer[1024];\n    socklen_t addr_len = sizeof(server_address);\n    int bytes_received = recvfrom(sockfd, recv_buffer, sizeof(recv_buffer), 0, (struct sockaddr *)&server_address, &addr_len);\n    if (bytes_received == -1) {\n        std::cout << \"Error receiving message\" << std::endl;\n    }\n    std::cout << \"Message received successfully\" << std::endl;\n    std::cout << \"Message received: \" << recv_buffer << std::endl;\n}\n", "CodeBleu_score": 38.86892800776057}, {"code": "void PrimaryCommands::SendIsAlive()    char buffer[256];\n    strcpy(buffer, \"Are you alive?\");\n    Logger::Log(\"Sending message: \" + std::string(buffer) + \" to next router.\");\n    write(nextRouter, buffer, strlen(buffer) + 1);\n    char response[256];\n    read(nextRouter, response, sizeof(response));\n    Logger::Log(\"Received response: \" + std::string(response));\n}", "CodeBleu_score": 41.355532129630845}, {"code": "void PrimaryCommands::SendIsAlive()    // Create a buffer from the message\n    char* buffer = new char[strlen(IS_ALIVE_MESSAGE) + 1];\n    strcpy(buffer, IS_ALIVE_MESSAGE);\n\n    // Log the sending action\n    Logger::Log(\"Sending message: \" + std::string(buffer));\n\n    // Write the buffer to the next router with the command YOU_ALIVE\n    Socket::Write(buffer, strlen(buffer) + 1, Socket::GetNextRouter());\n\n    // Wait for and log the response from the system\n    char* response = Socket::Read(Socket::GetNextRouter());\n    Logger::Log(\"Received response: \" + std::string(response));\n\n    // Free the memory allocated for the buffer and response\n    delete[] buffer;\n    delete[] response;\n}\n", "CodeBleu_score": 38.32216953737068}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if sensor is found on secondary server\n    bool found = false;\n    for (auto &server : secondary_servers) {\n        if (server.second.find(sensor_id) != server.second.end()) {\n            found = true;\n            break;\n        }\n    }\n\n    // If sensor is found on secondary server, send ENABLE_ROS command to server\n    if (found) {\n        // Create buffer with sensor ID\n        std::stringstream ss;\n        ss << sensor_id;\n        std::string sensor_id_str = ss.str();\n\n        // Send ENABLE_ROS command to server\n        std::string command = \"ENABLE_ROS \" + sensor_id_str;\n        router.send_to_server(command, server_id);\n\n        // Wait for and process server's response\n        std::string response = router.recv_from_server(server_id);\n        if (response == \"ACK\") {\n            // Sensor is enabled for ROS\n            std::cout << \"Sensor \" << sensor_id << \" is enabled for ROS\" << std::endl;\n        } else {\n            // Error handling\n            std::cerr << \"Error: \" << response << std::endl;\n        }\n    } else {\n        // Error handling\n        std::cerr << \"Error: Sensor \" << sensor_id << \" not found on any server\" << std::endl;\n    }\n}\n", "CodeBleu_score": 47.27599591814592}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)    // Check if the sensor is activated on any secondary server\n    bool found = false;\n    for (auto& secondary : secondary_servers) {\n        if (secondary->IsSensorActivated(sensor_id)) {\n            found = true;\n            break;\n        }\n    }\n\n    // If the sensor is not found on any server, log an error message\n    if (!found) {\n        std::cerr << \"Error: Sensor \" << sensor_id << \" is not activated on any secondary server.\" << std::endl;\n        return;\n    }\n\n    // Create a buffer with the sensor ID and send an ENABLE_ROS command to the server using the router\n    std::vector<uint8_t> buffer(sizeof(sensor_id) + 1);\n    buffer[0] = ENABLE_ROS;\n    memcpy(&buffer[1], &sensor_id, sizeof(sensor_id));\n    router->SendCommand(buffer);\n\n    // Wait for and process the server's response\n    std::vector<uint8_t> response = router->ReceiveCommand();\n    if (response[0] == ENABLE_ROS_ACK) {\n        std::cout << \"Sensor \" << sensor_id << \" enabled for ROS.\" << std::endl;\n    } else if (response[0] == ENABLE_ROS_NACK) {\n        std::cerr << \"Error: Failed to enable sensor \" << sensor_id << \" for ROS.\" << std::endl;\n    } else {\n        std::cerr << \"Error: Unexpected response from server.\" << std::endl;\n    }\n}\n", "CodeBleu_score": 43.82698932819636}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)  // Create a buffer for the message\n  char* buffer = (char*) malloc(sizeof(char) * (2 + sizeof(stream_id)));\n  // Add the command ID to the buffer\n  buffer[0] = ENABLE_ROS;\n  // Add the sensor ID to the buffer\n  memcpy(&buffer[1], &sensor_id, sizeof(stream_id));\n  // Send the buffer to the router\n  router->SendBuffer(buffer, 2 + sizeof(stream_id));\n  // Wait for a response from the router\n  int response_size = router->WaitForResponse();\n  // Check if the response is valid\n  if (response_size > 0) {\n    // Get the response from the router\n    char* response = router->GetResponse();\n    // Check if the response is a success message\n    if (response[0] == SUCCESS) {\n      // Log a success message\n      printf(\"Sensor enabled for ROS\\n\");\n    } else if (response[0] == FAILURE) {\n      // Log a failure message\n      printf(\"Sensor not found\\n\");\n    }\n  } else {\n    // Log a failure message\n    printf(\"No response from router\\n\");\n  }\n  // Free the buffer\n  free(buffer);\n}\n", "CodeBleu_score": 42.550673746146295}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)  // Check if the sensor is already activated\n  if (activated_sensors.find(sensor_id) != activated_sensors.end()) {\n    // Return the existing token\n    std::cout << \"GetToken: \" << sensor_id << \" already activated, returning existing token\" << std::endl;\n    return activated_sensors[sensor_id];\n  }\n\n  // Enable the sensor on a secondary server\n  token_type token = enable_sensor(sensor_id);\n\n  // Update the maps\n  activated_sensors[sensor_id] = token;\n  sensor_tokens[token] = sensor_id;\n\n  // Log the action\n  std::cout << \"GetToken: \" << sensor_id << \" activated, new token: \" << token << std::endl;\n\n  // Return the new token\n  return token;\n}\n", "CodeBleu_score": 45.91838430675449}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)  if (sensor_id == -1) {\n    return -1;\n  }\n  if (activated_sensors.find(sensor_id) != activated_sensors.end()) {\n    // sensor is already activated\n    return activated_sensors[sensor_id];\n  }\n  // sensor is not activated\n  // enable sensor on secondary server\n  std::string secondary_server_url = \"http://\" + secondary_server_ip + \":\" + secondary_server_port + \"/enable\";\n  std::string request_body = \"{\\\"sensor_id\\\": \" + std::to_string(sensor_id) + \"}\";\n  std::string response = http_post_request(secondary_server_url, request_body);\n  if (response == \"\") {\n    return -1;\n  }\n  // parse response\n  json response_json = json::parse(response);\n  if (response_json[\"status\"] != \"success\") {\n    return -1;\n  }\n  // retrieve token\n  token_type token = response_json[\"token\"];\n  // update maps\n  activated_sensors[sensor_id] = token;\n  tokens[token] = sensor_id;\n  // log action\n  std::string log_message = \"GetToken: \" + std::to_string(sensor_id) + \" \" + std::to_string(token);\n  Logger::Log(log_message);\n  return token;\n}\n", "CodeBleu_score": 44.19547849990919}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)  token_type token;\n  if (activated_sensors.find(sensor_id) != activated_sensors.end()) {\n    token = activated_sensors[sensor_id];\n    Logger::log(Logger::PRIMARY, \"GetToken\", \"Activated sensor \" + std::to_string(sensor_id) + \" already has token \" + std::to_string(token));\n  } else {\n    token = secondary_server->EnableSensor(sensor_id);\n    activated_sensors[sensor_id] = token;\n    Logger::log(Logger::PRIMARY, \"GetToken\", \"Activated sensor \" + std::to_string(sensor_id) + \" with token \" + std::to_string(token));\n  }\n  return token;\n}\n", "CodeBleu_score": 47.48197823796078}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (!file) {\n        return false;\n    }\n    std::vector<char> data((std::istreambuf_iterator<char>(file)),\n                           std::istreambuf_iterator<char>());\n    return Load(data);\n}\n", "CodeBleu_score": 51.30994279181782}, {"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (!file) {\n        return false;\n    }\n\n    file.seekg(0, std::ios::end);\n    std::streampos file_size = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n    std::vector<char> file_data(file_size);\n    file.read(file_data.data(), file_size);\n\n    file.close();\n\n    return Load(file_data);\n}\n", "CodeBleu_score": 51.97961946601024}, {"code": "bool Navigation::Load(const std::string &filename)    std::ifstream file(filename, std::ios::binary);\n    if (!file) {\n        return false;\n    }\n\n    file.seekg(0, std::ios::end);\n    size_t size = file.tellg();\n    file.seekg(0, std::ios::beg);\n\n    std::vector<char> data(size);\n    file.read(data.data(), size);\n\n    file.close();\n\n    return Load(data);\n}\n", "CodeBleu_score": 53.03768480886557}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)    // Check if the system is ready\n    if (!IsReady()) {\n        return false;\n    }\n\n    // Assert the crowd object is not null\n    assert(m_crowd != nullptr);\n\n    // Search for the agent id in the walker and vehicle mappings\n    auto walkerIt = m_walkerIdToActorId.find(id);\n    auto vehicleIt = m_vehicleIdToActorId.find(id);\n\n    // If the agent id is found in either mapping, remove it from the crowd\n    if (walkerIt != m_walkerIdToActorId.end() || vehicleIt != m_vehicleIdToActorId.end()) {\n        // Enter a critical section to safely remove the agent from the crowd\n        std::lock_guard<std::mutex> lock(m_mutex);\n\n        // If the agent id is found in the walker mapping, remove the agent from the walker manager\n        if (walkerIt != m_walkerIdToActorId.end()) {\n            m_crowd->removeWalker(walkerIt->second);\n            m_walkerIdToActorId.erase(walkerIt);\n        }\n\n        // If the agent id is found in the vehicle mapping, remove the agent from the vehicle manager\n        if (vehicleIt != m_vehicleIdToActorId.end()) {\n            m_crowd->removeVehicle(vehicleIt->second);\n            m_vehicleIdToActorId.erase(vehicleIt);\n        }\n\n        // Return true to indicate the agent was successfully removed\n        return true;\n    }\n\n    // Return false to indicate the agent was not found\n    return false;\n}\n", "CodeBleu_score": 56.76396644160484}, {"code": "bool Navigation::RemoveAgent(ActorId id)  // Check if the system is ready\n  if (!ready) {\n    return false;\n  }\n\n  // Assert the crowd object is not null\n  if (crowd == nullptr) {\n    return false;\n  }\n\n  // Search for the agent id in the walker and vehicle mappings\n  auto walker_it = walker_map.find(id);\n  auto vehicle_it = vehicle_map.find(id);\n\n  // If found, enter a critical section to safely remove the agent from the crowd, update the walker or vehicle manager, and remove the id from the mappings\n  if (walker_it != walker_map.end()) {\n    std::unique_lock<std::mutex> lock(mutex);\n    crowd->removeWalker(walker_it->second);\n    walker_map.erase(walker_it);\n    return true;\n  } else if (vehicle_it != vehicle_map.end()) {\n    std::unique_lock<std::mutex> lock(mutex);\n    crowd->removeVehicle(vehicle_it->second);\n    vehicle_map.erase(vehicle_it);\n    return true;\n  }\n\n  // If the agent id was not found in either mapping, return false\n  return false;\n}\n", "CodeBleu_score": 59.81786301260842}, {"code": "bool Navigation::RemoveAgent(ActorId id)  // Check if the system is ready and assert the crowd object is not null\n  if (!ready || !crowd) {\n    return false;\n  }\n\n  // Search for the agent id in the walker and vehicle mappings\n  auto walker_it = walkers.find(id);\n  auto vehicle_it = vehicles.find(id);\n\n  // If found, enter a critical section to safely remove the agent from the crowd, update the walker or vehicle manager, and remove the id from the mappings\n  if (walker_it != walkers.end()) {\n    std::unique_lock<std::mutex> lock(mutex);\n    crowd->removeWalker(walker_it->second);\n    walkers.erase(walker_it);\n    return true;\n  } else if (vehicle_it != vehicles.end()) {\n    std::unique_lock<std::mutex> lock(mutex);\n    crowd->removeVehicle(vehicle_it->second);\n    vehicles.erase(vehicle_it);\n    return true;\n  }\n\n  // If the agent id is not found, return false\n  return false;\n}", "CodeBleu_score": 57.60507968115125}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    std::set<int> currentVehicles;\n    for (auto vehicle : m_vehicles) {\n        currentVehicles.insert(vehicle.first);\n    }\n\n    for (auto vehicle : vehicles) {\n        if (m_vehicles.find(vehicle.id) == m_vehicles.end()) {\n            m_vehicles[vehicle.id] = Vehicle(vehicle.id, vehicle.position, vehicle.velocity);\n        }\n        m_vehicles[vehicle.id].Update(vehicle.position, vehicle.velocity);\n    }\n\n    for (auto vehicle : currentVehicles) {\n        if (m_vehicles[vehicle].IsUpdated() == false) {\n            m_vehicles.erase(vehicle);\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 48.98842130124686}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    // Collect the IDs of currently mapped vehicles into a set\n    std::set<int> current_vehicle_ids;\n    for (auto vehicle : vehicles_) {\n        current_vehicle_ids.insert(vehicle.first);\n    }\n\n    // Add or update vehicles from the provided list, marking them as updated\n    for (auto vehicle : vehicles) {\n        int id = vehicle.id;\n        if (vehicles_.find(id) == vehicles_.end()) {\n            // Add a new vehicle\n            vehicles_[id] = vehicle;\n        } else {\n            // Update an existing vehicle\n            vehicles_[id] = vehicle;\n        }\n        vehicles_[id].updated = true;\n    }\n\n    // Remove vehicles not marked as updated, indicating they do not exist in the current frame\n    for (auto it = vehicles_.begin(); it != vehicles_.end(); ) {\n        if (!it->second.updated) {\n            it = vehicles_.erase(it);\n        } else {\n            ++it;\n        }\n    }\n\n    // Return true upon completion\n    return true;\n}\n", "CodeBleu_score": 44.149434328665684}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)    std::unordered_set<int> vehicle_ids;\n    for (auto vehicle : vehicles) {\n        vehicle_ids.insert(vehicle.id);\n    }\n\n    for (auto it = vehicles_map_.begin(); it != vehicles_map_.end();) {\n        if (vehicle_ids.find(it->first) == vehicle_ids.end()) {\n            it = vehicles_map_.erase(it);\n        } else {\n            it->second.updated = true;\n            ++it;\n        }\n    }\n\n    for (auto vehicle : vehicles) {\n        if (vehicles_map_.find(vehicle.id) == vehicles_map_.end()) {\n            vehicles_map_.insert({vehicle.id, VehicleState(vehicle)});\n        } else {\n            vehicles_map_.at(vehicle.id).Update(vehicle);\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 51.38669037778296}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  bool result = false;\n  {\n    std::lock_guard<std::mutex> lock(_mutex);\n    auto actor = _actor_map.find(id);\n    if (actor != _actor_map.end()) {\n      const auto &actor_location = actor->second->GetLocation();\n      const auto &actor_transform = actor->second->GetTransform();\n      const auto &actor_bounding_box = actor->second->GetBoundingBox();\n      const auto &actor_bounding_box_extent = actor->second->GetBoundingBoxExtent();\n      const auto &actor_bounding_box_location = actor->second->GetBoundingBoxLocation();\n      const auto &actor_bounding_box_rotation = actor->second->GetBoundingBoxRotation();\n      const auto &actor_bounding_box_scale = actor->second->GetBoundingBoxScale();\n      const auto &actor_bounding_box_transform = actor->second->GetBoundingBoxTransform();\n      const auto &actor_bounding_box_transform_matrix = actor->second->GetBoundingBoxTransformMatrix();\n      const auto &actor_bounding_box_transform_matrix_inverse = actor->second->GetBoundingBoxTransformMatrixInverse();\n      const auto &actor_bounding_box_transform_matrix_inverse_transpose = actor->second->GetBoundingBoxTransformMatrixInverseTranspose();\n      const auto &actor_bounding_box_transform_matrix_transpose = actor->second->GetBoundingBoxTransformMatrixTranspose();\n      const auto &actor_bounding_box_transform_matrix_transpose_inverse = actor->second->GetBoundingBoxTransformMatrixTransposeInverse();\n      const auto &actor_bounding_box_transform_matrix_transpose_inverse_transpose = actor->second->GetBoundingBoxTransformMatrixTransposeInverseTranspose();\n      const auto &actor_bounding_box_transform_matrix_transpose_transpose = actor->second->GetBoundingBoxTransformMatrixTransposeTranspose();\n      const auto &", "CodeBleu_score": 27.347047378283644}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  std::lock_guard<std::mutex> lock(mutex);\n  auto actor = world.GetActor(id);\n  if (actor == nullptr) {\n    return false;\n  }\n  auto walker = actor->As<Walker>();\n  if (walker != nullptr) {\n    return false;\n  }\n  auto vehicle = actor->As<Vehicle>();\n  if (vehicle != nullptr) {\n    return false;\n  }\n  auto location = actor->GetTransform().location;\n  auto squared_distance = distance * distance;\n  auto actor_location = actor->GetTransform().location;\n  auto actor_direction = actor_location - location;\n  actor_direction.Normalize();\n  auto dot = actor_direction.Dot(direction);\n  if (dot < 0.0f) {\n    return false;\n  }\n  return dot < squared_distance;\n}\n", "CodeBleu_score": 48.48308923610753}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)  bool result = false;\n  {\n    std::lock_guard<std::mutex> lock(_mutex);\n    auto actor = _map.find(id);\n    if (actor != _map.end()) {\n      auto vehicle = boost::get<carla::client::Vehicle>(&*actor->second);\n      if (vehicle != nullptr) {\n        result = true;\n      } else {\n        auto walker = boost::get<carla::client::Walker>(&*actor->second);\n        if (walker != nullptr) {\n          auto location = walker->GetLocation();\n          auto squared_distance = carla::geom::Math::DistanceSquared(location, location + direction * distance);\n          result = _crowd.IsVehicleNear(location, squared_distance);\n        }\n      }\n    }\n  }\n  return result;\n}", "CodeBleu_score": 49.52390329434186}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)    auto routePoint = info.GetRoutePoint();\n    WalkerEventVisitor visitor(info.GetContext(), delta);\n    return boost::variant2::visit(visitor, routePoint);\n}\n", "CodeBleu_score": 50.98931856101132}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tauto &route = info.route;\n\tif (route.empty()) {\n\t\treturn EventResult::NoEvent;\n\t}\n\tauto &current = route.front();\n\tauto visitor = WalkerEventVisitor(info.context, info.actor, info.actor->GetPosition(), current, delta);\n\tauto result = boost::variant2::visit(visitor, current);\n\treturn result;\n}\n", "CodeBleu_score": 45.588654420835034}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tauto &route = info.route;\n\tauto &current = info.current;\n\tauto &context = info.context;\n\n\tif (route.empty()) {\n\t\treturn EventResult::Finished;\n\t}\n\n\tauto &point = route[current];\n\n\tauto visitor = WalkerEventVisitor(context, delta);\n\n\tauto result = boost::variant2::visit(visitor, point);\n\n\tif (result == EventResult::Finished) {\n\t\tcurrent++;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 44.121702583384426}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  auto lanes = xml.child(\"lanes\");\n  for (auto &road : lanes.children(\"road\")) {\n    auto road_id = road.attribute(\"id\").as_ullong();\n    for (auto &lane_section : road.children(\"laneSection\")) {\n      auto left_lanes = lane_section.child(\"left\");\n      auto center_lanes = lane_section.child(\"center\");\n      auto right_lanes = lane_section.child(\"right\");\n      ParseLanes(left_lanes, road_id, carla::road::Lane::Type::Left, map_builder);\n      ParseLanes(center_lanes, road_id, carla::road::Lane::Type::Center, map_builder);\n      ParseLanes(right_lanes, road_id, carla::road::Lane::Type::Right, map_builder);\n    }\n  }\n}\n", "CodeBleu_score": 46.19271708182491}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  // Iterate through each road node\n  for (pugi::xml_node road_node : xml.child(\"OpenDRIVE\").children(\"road\")) {\n    // Extract the road ID\n    auto road_id = std::stoul(road_node.attribute(\"id\").value());\n\n    // Iterate through each lane section within the lanes node\n    for (pugi::xml_node lane_section_node :\n         road_node.child(\"lanes\").children(\"laneSection\")) {\n      // Retrieve the left, center, and right lane nodes\n      pugi::xml_node left_lanes_node = lane_section_node.child(\"left\");\n      pugi::xml_node center_lanes_node = lane_section_node.child(\"center\");\n      pugi::xml_node right_lanes_node = lane_section_node.child(\"right\");\n\n      // Process the left lanes\n      ParseLanes(left_lanes_node, road_id, map_builder);\n\n      // Process the center lanes\n      ParseLanes(center_lanes_node, road_id, map_builder);\n\n      // Process the right lanes\n      ParseLanes(right_lanes_node, road_id, map_builder);\n    }\n  }\n}\n", "CodeBleu_score": 52.314570380644675}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)  auto roads = xml.child(\"OpenDRIVE\").child(\"Road\");\n  for (auto road : roads) {\n    auto road_id = road.attribute(\"id\").as_ullong();\n    auto lane_sections = road.child(\"Lanes\").children(\"LaneSection\");\n    for (auto lane_section : lane_sections) {\n      auto left_lanes = lane_section.child(\"Left\");\n      auto center_lanes = lane_section.child(\"Center\");\n      auto right_lanes = lane_section.child(\"Right\");\n      ParseLanes(left_lanes, road_id, carla::road::Lane::LaneType::Left,\n                 map_builder);\n      ParseLanes(center_lanes, road_id, carla::road::Lane::LaneType::Center,\n                 map_builder);\n      ParseLanes(right_lanes, road_id, carla::road::Lane::LaneType::Right,\n                 map_builder);\n    }\n  }\n}\n", "CodeBleu_score": 51.129868775561036}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)    if (info.total_count_change == 1) {\n        matched_ = true;\n    } else if (info.total_count_change == -1) {\n        matched_ = false;\n    } else {\n        // No action needed.\n    }\n}", "CodeBleu_score": 40.16723392183536}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)  if (info.total_count_change == 0)\n    return;\n\n  if (info.total_count > matched_count_) {\n    if (matched_count_ == 0)\n      first_connection_ = true;\n\n    matched_count_ = info.total_count;\n    std::cout << \"Matched publication \" << writer->get_instance_handle() << \" with subscriber \" << info.last_subscription_handle << std::endl;\n  } else {\n    matched_count_ = info.total_count;\n    std::cout << \"Unmatched publication \" << writer->get_instance_handle() << \" with subscriber \" << info.last_subscription_handle << std::endl;\n  }\n\n  if (matched_count_ == 0) {\n    std::cout << \"Matched count is zero. Waiting for a while...\" << std::endl;\n  }\n}\n", "CodeBleu_score": 45.43281307844551}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)  if (info.total_count_change == 0) {\n    return;\n  }\n\n  if (info.total_count > matched_) {\n    if (matched_ == 0) {\n      first_match_ = true;\n    }\n    matched_ = info.total_count;\n    log_info(\"Matched publication %s with %d remote writers\",\n             writer->get_name(),\n             matched_);\n  } else {\n    matched_ = info.total_count;\n    log_info(\"Matched publication %s with %d remote writers\",\n             writer->get_name(),\n             matched_);\n  }\n}", "CodeBleu_score": 45.105969948155845}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)    // Check if the change count is valid\n    if (info.currentCountChange == 0) {\n        // Invalid change count\n        std::cerr << \"Invalid change count\" << std::endl;\n        return;\n    }\n\n    // Update the matched count\n    matched_count_ += info.currentCountChange;\n\n    // Check if this is the first connection\n    if (info.currentCountChange > 0 && !first_connected_) {\n        first_connected_ = true;\n    }\n\n    // Check if there are no remaining matches\n    if (matched_count_ == 0) {\n        // Destroy the subscriber\n        destroy_subscriber();\n    }\n}\n", "CodeBleu_score": 49.35779921238189}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)  std::lock_guard<std::mutex> lock(mutex_);\n  if (info.current_count_change == 1) {\n    matched_count_++;\n    if (matched_count_ == 1) {\n      first_connected_ = true;\n    }\n  } else if (info.current_count_change == -1) {\n    matched_count_--;\n    if (matched_count_ == 0) {\n      if (subscriber_) {\n        subscriber_->destroy();\n        subscriber_ = nullptr;\n      }\n    }\n  } else {\n    std::cerr << \"Invalid subscription change count: \" << info.current_count_change << std::endl;\n  }\n}\n", "CodeBleu_score": 61.03474823081429}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)  if (info.current_count_change == 1) {\n    // New match\n    matched_count_++;\n    first_connected_ = true;\n  } else if (info.current_count_change == -1) {\n    // Unmatched\n    matched_count_--;\n    if (matched_count_ == 0) {\n      // Destroy the subscriber\n      destroy_subscriber();\n    }\n  } else {\n    // Invalid change count\n    log_error(\"Invalid change count: \" << info.current_count_change);\n  }\n}\n", "CodeBleu_score": 55.74492432891107}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    if (!m_isGetKeyDefined) {\n        return false;\n    }\n    CarlaCollisionEvent* p_sample = (CarlaCollisionEvent*) data;\n    //@@{\n    (void)p_sample;\n    //@@{\n    // Compute MD5 hash.\n    const char* key_md5 = \"d064106139344c827b54612e66521710\";\n    DDS::OctetSeq md5_seq;\n    md5_seq.length(MD5_DIGEST_LENGTH);\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i) {\n        md5_seq[i] = key_md5[i];\n    }\n    if (force_md5 || DDS_Utils::compute_md5(p_sample, md5_seq)) {\n        DDS_SampleInfo* info = (DDS_SampleInfo*) handle;\n        info->valid_data = true;\n        DDS_INFINITE_SECURE_COPY(md5_seq, info->key.value, DDS_Octet_t);\n        info->key.length = (DDS_Octet_t) MD5_DIGEST_LENGTH;\n    } else {\n        // Directly copy the handle\n        DDS_SampleInfo* info = (DDS_SampleInfo*) handle;\n        DDS_INFINITE_SECURE_COPY(p_sample, info->key.value, DDS_Octet_t);\n        info->key.length = (DDS_Octet_t) m_sampleSize;\n    }\n    return true;\n}", "CodeBleu_score": 47.93333542307423}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    CarlaCollisionEvent* myData = (CarlaCollisionEvent*) data;\n    if (!CarlaCollisionEventPubSubType::m_md5) {\n        return false;\n    }\n    DDS_Octet keyBuffer[CarlaCollisionEventPubSubType::KEY_SIZE_DIGITS];\n    long long int key = 0;\n    memcpy(keyBuffer, &key, sizeof(long long int));\n    DDS_Octet* p_md5 = NULL;\n    DDS_Octet* p_keyBuffer = &keyBuffer[0];\n    u_long hash = 5381;\n    for (u_long i = 0; i < sizeof(long long int); i++) {\n        hash = hash * 33 + p_keyBuffer[i];\n    }\n    if (force_md5 || CarlaCollisionEventPubSubType::m_md5) {\n        MUTEX_LOCK(&CarlaCollisionEventPubSubType::m_hashMutex);\n        if (CarlaCollisionEventPubSubType::m_md5) {\n            p_md5 = &CarlaCollisionEventPubSubType::m_md5[0];\n        } else {\n            p_md5 = (DDS_Octet*)\n                    &CarlaCollisionEventPubSubType::m_md5_default[0];\n        }\n        MUTEX_UNLOCK(&CarlaCollisionEventPubSubType::m_hashMutex);\n        for (u_long j = 0; j < 16; j++) {\n            hash = hash * 33 + p_md5[j];\n        }\n    } else {\n        for (u_long k = 0; k < sizeof(long long int); k++) {\n            hash = hash * 33 + p_keyBuffer[k];\n        }\n    }\n    sprintf(\n        keyBuffer,\n        \"%08llx\",\n        (unsigned long long) hash);\n    DDS_OctetSeq_set_length(&handle->keyBuffer, KEY_SIZE_DIGITS);\n    memcpy(\n        handle->keyBuffer.buffer,\n", "CodeBleu_score": 40.22284729824772}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)    CarlaCollisionEvent* p_sample = (CarlaCollisionEvent*) data;\n    (void)p_sample;\n    (void)handle;\n    (void)force_md5;\n    return false;\n}\n", "CodeBleu_score": 10.261519397530265}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = static_cast<CarlaEgoVehicleControl*>(data);\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n                               eprosima::fastcdr::Cdr::DDS_CDR);\n    // Serialize the object.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n    payload->encapsulation = ser.serialize(*p_type) ? CDR_BE : CDR_LE;\n    // Get the serialized length\n    payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());\n    return true;\n}\n", "CodeBleu_score": 79.04353970353355}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n\n    // Object that manages the raw buffer.\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n\n    // Object that serializes the data.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n\n    // Serialize encapsulation.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;\n\n    try {\n        // Serialize the object.\n        p_type->serialize(ser);\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n\n    // Get the serialized length\n    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}\n", "CodeBleu_score": 78.83625430155001}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)    CarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*) data;\n    eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.\n    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.\n    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE :\n    CDR_LE;\n    // Serialize encapsulation\n    ser.serialize_encapsulation();\n    try {\n        p_type->serialize(ser); // Serialize the object:\n    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {\n        return false;\n    }\n    payload->length = (uint32_t) ser.getSerializedDataLength(); //Get the serialized length\n    return true;\n}\n", "CodeBleu_score": 80.18700378860866}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    if (target_set) {\n        return;\n    }\n\n    // Decode the message\n    mavlink_msg_to_send_buffer(mavlink_buffer, &msg);\n    mavlink_msg_common_decode(mavlink_buffer, &mavlink_msg);\n\n    // Exit if the message type is not one that should be tracked\n    if (mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_MISSION &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_RELATIVE_PYTHON &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_RELATIVE_PYTHON_MISSION &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_SETPOINT &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_SETPOINT_MISSION &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_RELATIVE_PYTHON_SETPOINT &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_RELATIVE_PYTHON_SETPOINT_MISSION &&\n        mavlink_msg.msgid != MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT_SETPOINT_SETPOINT &&\n        mavlink_msg", "CodeBleu_score": 29.62208612448392}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)  // Exit immediately if the target has already been set\n  if (target_set) {\n    return;\n  }\n\n  // Decode the MAVLink message\n  mavlink_status_t status;\n  mavlink_message_t msg_decoded;\n  mavlink_msg_message_decode(&msg_decoded, &status, &msg);\n\n  // Exit if the message type is not one that should be tracked\n  if (msg_decoded.msgid != MAVLINK_MSG_ID_GPS_RAW_INT && msg_decoded.msgid != MAVLINK_MSG_ID_GPS_RAW_INT && msg_decoded.msgid != MAVLINK_MSG_ID_ATTITUDE) {\n    return;\n  }\n\n  // Set the sysid to the target if it is not set\n  if (sysid == 0) {\n    sysid = msg_decoded.sysid;\n    request_streams();\n  }\n\n  // Flag that the target has been set\n  target_set = true;\n}\n", "CodeBleu_score": 38.670012136372854}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)    if (target_set) {\n        return;\n    }\n\n    if (msg.msgid != MAVLINK_MSG_ID_HEARTBEAT) {\n        return;\n    }\n\n    mavlink_heartbeat_t heartbeat;\n    mavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\n    if (heartbeat.type != MAV_TYPE_GCS) {\n        return;\n    }\n\n    if (target_sysid == 0) {\n        target_sysid = heartbeat.system_id;\n        mavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_COMM_0, MAV_DATA_STREAM_POSITION, 10, 1);\n        mavlink_msg_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_COMM_0, MAV_DATA_STREAM_EXTENDED_STATUS, 10, 1);\n    }\n\n    target_set = true;\n}\n", "CodeBleu_score": 45.25342762638656}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT res = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (res == MAV_RESULT_ACCEPTED) {\n        AP_Notify::flags.baro_calibration_needed = true;\n    }\n    return res;\n}\n", "CodeBleu_score": 67.57510730956446}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        _baro_calibration_needed = true;\n    }\n    return result;\n}", "CodeBleu_score": 67.82192314164335}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)    MAV_RESULT result = GCS_MAVLINK::_handle_command_preflight_calibration_baro(msg);\n    if (result == MAV_RESULT_ACCEPTED) {\n        AP_Notify::flags.baro_calibration_needed = true;\n    }\n    return result;\n}\n", "CodeBleu_score": 67.83160610106358}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    MAV_RESULT ret = MAV_RESULT_FAILED;\n    switch (packet.param1) {\n        case 1.0f:\n            if (control_mode == GCS_MAVLINK_Tracker::MODE_AUTO) {\n                // if we were in auto, disarm it\n                set_mode(GCS_MAVLINK_Tracker::MODE_STABILIZE);\n            }\n            if (control_mode == GCS_MAVLINK_Tracker::MODE_STABILIZE) {\n                // if we were in stabilize, disarm it\n                set_mode(GCS_MAVLINK_Tracker::MODE_ACRO);\n            }\n            if (control_mode == GCS_MAVLINK_Tracker::MODE_ACRO) {\n                // if we were in acro, disarm it\n                set_mode(GCS_MAVLINK_Tracker::MODE_ALT_HOLD);\n            }\n            if (control_mode == GCS_MAVLINK_Tracker::MODE_ALT_HOLD) {\n                // if we were in alt_hold, disarm it\n                set_mode(GCS_MAVLINK_Tracker::MODE_GUIDED);\n            }\n            if (control_mode == GCS_MAVLINK_Tracker::MODE_GUIDED) {\n                // if we were in guided, disarm it\n                set_mode(GCS_MAVLINK_Tracker::MODE_AUTO);\n            }\n            ret = MAV_RESULT_ACCEPTED;\n            break;\n        case 0.0f:\n            if (control_mode == GCS_MAVLINK_Tracker::MODE_AUTO) {\n                // if we were in auto, disarm it\n                set_mode(GCS_MAVLINK_Tracker::MODE_STABILIZE);\n            }\n            if (control_mode == GCS_MAVLINK_Tracker::MODE_STABILIZE) {\n                // if we were in stabilize, disarm it\n                set_mode(GCS_MAVLINK_Tracker", "CodeBleu_score": 33.704348344944215}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)    if (packet.target_component != MAV_COMP_ID_ALL) {\n        return MAV_RESULT_UNSUPPORTED;\n    }\n\n    if (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n        switch ((int)packet.param1) {\n            case 1:\n                arm_servos();\n                return MAV_RESULT_ACCEPTED;\n\n            case 0:\n                disarm_servos();\n                return MAV_RESULT_ACCEPTED;\n\n            default:\n                return MAV_RESULT_UNSUPPORTED;\n        }\n    }\n\n    return MAV_RESULT_UNSUPPORTED;\n}\n", "CodeBleu_score": 53.068074101436245}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\n    // Check if this is a request to arm or disarm the servos.\n    if (packet.command == MAV_CMD_COMPONENT_ARM_DISARM) {\n\n        // Check if the command parameter is 1.0 or 0.0.\n        if (packet.param1 == 1.0) {\n\n            // Arm the servos.\n            _servos.arm();\n\n            // Return MAV_RESULT_ACCEPTED.\n            return MAV_RESULT_ACCEPTED;\n\n        } else if (packet.param1 == 0.0) {\n\n            // Disarm the servos.\n            _servos.disarm();\n\n            // Return MAV_RESULT_ACCEPTED.\n            return MAV_RESULT_ACCEPTED;\n\n        } else {\n\n            // Return MAV_RESULT_UNSUPPORTED.\n            return MAV_RESULT_UNSUPPORTED;\n\n        }\n\n    } else {\n\n        // Return MAV_RESULT_UNSUPPORTED.\n        return MAV_RESULT_UNSUPPORTED;\n\n    }\n\n}\n", "CodeBleu_score": 58.28254868192384}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    for (uint8_t i = 0; i < GCS_MAVLINK_STREAM_MAX_INSTANCES; i++) {\n        if (gcs().chan(i) != nullptr) {\n            if (gcs().chan(i)->get_datatype() == MAVLINK_MSG_ID_GLOBAL_POSITION_INT) {\n                if (gcs().chan(i)->get_stream_mode() == MAV_STREAM_MODE_NEW) {\n                    gcs().chan(i)->set_update_rate(1000 / GCS_UPDATE_RATE_MS);\n                    gcs().chan(i)->set_datatype(MAVLINK_MSG_ID_GLOBAL_POSITION_INT);\n                    gcs().chan(i)->set_system_id(sysid);\n                    gcs().chan(i)->set_component_id(compid);\n                    gcs().chan(i)->set_stream_mode(MAV_STREAM_MODE_NEW);\n                    gcs().chan(i)->start_new_instance();\n                    break;\n                }\n            }\n        }\n    }\n}\n", "CodeBleu_score": 46.842581249282766}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    uint8_t channels[MAX_GCS_CHANNELS];\n    uint8_t num_channels = 0;\n\n    // Find available channels\n    for (uint8_t i = 0; i < MAX_GCS_CHANNELS; i++) {\n        if (gcs_channels[i].available()) {\n            channels[num_channels++] = i;\n        }\n    }\n\n    // Send request to start streaming position data on available channels\n    for (uint8_t i = 0; i < num_channels; i++) {\n        mavlink_message_t msg;\n        mavlink_msg_request_data_stream_pack(\n            mavlink_system.sysid,\n            mavlink_system.compid,\n            &msg,\n            sysid,\n            compid,\n            MAV_DATA_STREAM_POSITION,\n            1000,\n            1,\n            channels[i]\n        );\n        send_message(msg);\n    }\n}\n", "CodeBleu_score": 45.4362444807993}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)    // Iterate over available channels\n    for (uint8_t i = 0; i < GCS_MAVLINK_COMM_NUM_BUFFERS; i++) {\n        if (mavlink_get_channel_status(i)->flags & MAVLINK_STATUS_FLAG_OUT_MAVLINK1) {\n            continue;\n        }\n\n        // Check if there is enough payload space for the message\n        if (mavlink_msg_request_data_stream_pack(mavlink_system.sysid, mavlink_system.compid,\n                                                 &mavlink_msg_request_data_stream, i, sysid, compid,\n                                                 MAV_DATA_STREAM_POSITION, 100, 1) >\n            MAVLINK_MAX_PACKET_LEN) {\n            continue;\n        }\n\n        // Send the request to start streaming position data\n        mavlink_msg_request_data_stream_send(i, sysid, compid, MAV_DATA_STREAM_POSITION, 100, 1);\n        break;\n    }\n}\n", "CodeBleu_score": 49.25724324643951}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    if (ahrs.pitch_cosine() != 0.0f) {\n        // convert to earth frame\n        ef_pitch = -pitch;\n        ef_yaw = yaw;\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 34.23808474330768}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    // Retrieve the AHRS instance\n    AHRS* ahrs = AP_AHRS::get_singleton();\n\n    // Check for a zero pitch cosine to avoid division by zero\n    if (is_zero(ahrs->cos_pitch())) {\n        return false;\n    }\n\n    // Calculate the earth frame pitch and yaw using trigonometric conversions\n    ef_pitch = -asinf(ahrs->cos_roll() * ahrs->sin_pitch() / ahrs->cos_pitch());\n    ef_yaw = wrap_PI(ahrs->yaw + atan2f(ahrs->sin_roll() / ahrs->cos_pitch(), ahrs->cos_roll() / ahrs->cos_pitch()));\n\n    return true;\n}\n", "CodeBleu_score": 48.91740341857721}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)    if (ahrs.pitch_cosine() == 0.0f) {\n        return false;\n    }\n    ef_pitch = wrap_PI(ahrs.roll + pitch);\n    ef_yaw = wrap_2PI(ahrs.yaw + yaw);\n    return true;\n}\n", "CodeBleu_score": 43.991077537494476}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)    // update yaw and pitch to target\n    float yaw_cd, pitch_cd;\n    float yaw_error_cd, pitch_error_cd;\n\n    // calculate yaw and pitch in centidegrees\n    if (g.auto_yaw_mode == AUTO_YAW_HOLD) {\n        // roll & pitch to yaw\n        yaw_cd = get_pitch_yaw_roll_cd().yaw;\n    } else {\n        // roll & pitch to yaw\n        yaw_cd = get_pitch_yaw_roll_cd().yaw;\n\n        // calculate yaw error in centidegrees\n        yaw_error_cd = wrap_180_cd(ahrs.yaw_sensor - yaw_cd);\n    }\n\n    // check if direction reversed\n    if (g.reverse_direction) {\n        yaw_cd = -yaw_cd;\n        yaw_error_cd = -yaw_error_cd;\n    }\n\n    // calculate pitch error in centidegrees\n    pitch_error_cd = wrap_180_cd(ahrs.pitch_sensor - g.pitch_trim_cd);\n\n    // convert errors from earth frame to body frame\n    yaw_error_cd = constrain_float(yaw_error_cd * ahrs.cos_roll, -ACRO_LIMIT_YAW, ACRO_LIMIT_YAW);\n    pitch_error_cd = constrain_float(pitch_error_cd * ahrs.cos_pitch, -ACRO_LIMIT_PITCH, ACRO_LIMIT_PITCH);\n\n    // update target yaw and pitch\n    if (g.auto_yaw_mode == AUTO_YAW_HOLD) {\n        // hold yaw\n        yaw_cd = g.acro_yaw_p * yaw_error_cd;\n    } else if (g.auto_yaw_mode == AUTO_YAW_LOOK_AT_NEXT_WP) {\n        // look at next waypoint\n        yaw_cd = g.acro_", "CodeBleu_score": 38.20848743957399}, {"code": "void Mode::update_auto(void)    // get navigation data\n    Location loc;\n    float target_yaw, target_pitch;\n    float yaw_error, pitch_error;\n    float yaw_rate, pitch_rate;\n    float yaw_angle_error, pitch_angle_error;\n    float yaw_angle_error_rate, pitch_angle_error_rate;\n    float yaw_angle_error_rate_max, pitch_angle_error_rate_max;\n    float yaw_angle_error_rate_min, pitch_angle_error_rate_min;\n    float yaw_angle_error_rate_increment, pitch_angle_error_rate_increment;\n    float yaw_angle_error_rate_decrement, pitch_angle_error_rate_decrement;\n    float yaw_angle_error_rate_deceleration, pitch_angle_error_rate_deceleration;\n    float yaw_angle_error_rate_acceleration, pitch_angle_error_rate_acceleration;\n    float yaw_angle_error_rate_max_accel, pitch_angle_error_rate_max_accel;\n    float yaw_angle_error_rate_max_decel, pitch_angle_error_rate_max_decel;\n    float yaw_angle_error_rate_max_increment, pitch_angle_error_rate_max_increment;\n    float yaw_angle_error_rate_max_decrement, pitch_angle_error_rate_max_decrement;\n    float yaw_angle_error_rate_max_increment_accel, pitch_angle_error_rate_max_increment_accel;\n    float yaw_angle_error_rate_max_decrement_accel, pitch_angle_error_rate_max_decrement_accel;\n    float yaw_angle_error_rate_max_increment_decel, pitch_angle_error_rate_max_increment_decel;\n    float yaw_angle_error_rate_max_decrement_decel, pitch_angle_error_rate_max_decrement_", "CodeBleu_score": 6.752246296873264}, {"code": "void Mode::update_auto(void)    // calculate yaw and pitch in centidegrees\n    float yaw_cd = (int32_t)ahrs.yaw_sensor * 100;\n    float pitch_cd = (int32_t)ahrs.pitch_sensor * 100;\n\n    // check if direction is reversed\n    if (is_negative(ahrs.yaw_sensor)) {\n        yaw_cd = -yaw_cd;\n    }\n    if (is_negative(ahrs.pitch_sensor)) {\n        pitch_cd = -pitch_cd;\n    }\n\n    // compute angle error\n    float angle_error_yaw = wrap_180_cd(ahrs.yaw_sensor - target_yaw_cd) * 100;\n    float angle_error_pitch = wrap_180_cd(ahrs.pitch_sensor - target_pitch_cd) * 100;\n\n    // convert errors from earth frame to body frame\n    float angle_error_yaw_bf = angle_error_yaw * ahrs.cos_roll - angle_error_pitch * ahrs.sin_roll;\n    float angle_error_pitch_bf = angle_error_yaw * ahrs.sin_roll + angle_error_pitch * ahrs.cos_roll;\n\n    // update pitch and yaw servos if target distance is valid or no minimum distance is set\n    if (target_distance_valid || !params.nav_min_distance) {\n        // update pitch servo\n        if (is_positive(angle_error_pitch_bf)) {\n            servo_pitch.set_range(params.servo_max);\n        } else {\n            servo_pitch.set_range(params.servo_min);\n        }\n        servo_pitch.set_angle(pitch_cd);\n\n        // update yaw servo\n        if (is_positive(angle_error_yaw_bf)) {\n            servo_yaw.set_range(params.servo_max);\n        } else {\n            servo_y", "CodeBleu_score": 36.28253239150474}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)  // If the GPS is not connected, return\n  if (!gps.location.isValid()) {\n    return;\n  }\n\n  // Update the GPS data\n  gps.update();\n\n  // Check if the last message time has changed\n  if (gps.charsProcessed() == last_message_time) {\n    return;\n  }\n\n  // Check if the GPS status is at least 3D fix\n  if (gps.location.isValid() && gps.location.is3D()) {\n    // If the home location is not set, set it\n    if (!home_set) {\n      home_set = true;\n      home_lat = gps.location.lat();\n      home_lon = gps.location.lng();\n      home_alt = gps.altitude.meters();\n    }\n\n    // Update the GPS data\n    gps_lat = gps.location.lat();\n    gps_lon = gps.location.lng();\n    gps_alt = gps.altitude.meters();\n    gps_speed = gps.speed.mps();\n    gps_course = gps.course.deg();\n    gps_fix = gps.fix;\n    gps_satellites = gps.satellites.value();\n    gps_hdop = gps.hdop.value();\n    gps_vdop = gps.vdop.value();\n    gps_pdop = gps.pdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps.hdop.value();\n    gps_hdop = gps", "CodeBleu_score": 35.23612972550835}, {"code": "void Tracker::update_GPS(void)    // Update GPS data\n    gps.update();\n\n    // Check if the last message time has changed and if the GPS status is at least 3D fix\n    if (gps.last_message_time() != last_message_time || gps.status() < 3) {\n        // Reset the countdown\n        ground_start_countdown = 0;\n    }\n\n    // If the countdown is greater than 0\n    if (ground_start_countdown > 0) {\n        // Decrement the countdown\n        ground_start_countdown--;\n        // If the countdown reaches one\n        if (ground_start_countdown == 1) {\n            // If the current location is valid\n            if (gps.location.is_valid()) {\n                // Set the home location\n                home_location = gps.location;\n                // Set the home altitude\n                home_altitude = gps.altitude;\n                // Set the home speed\n                home_speed = gps.speed;\n                // Set the home course\n                home_course = gps.course;\n                // Set the home fix time\n                home_fix_time = gps.fix_time;\n                // Set the home HDOP\n                home_hdop = gps.hdop;\n                // Set the home VDOP\n                home_vdop = gps.vdop;\n                // Set the home PDOP\n                home_pdop = gps.pdop;\n                // Set the home HAcc\n                home_hacc = gps.hacc;\n                // Set the home VAcc\n                home_vacc = gps.vacc;\n                // Set the home PAcc\n                home_pacc = gps.pacc;\n                // Set the home age\n                home_age = gps.age;\n                // Set the home SIV\n                home_siv = gps.siv;\n                // Set the home HDOP\n                home_hdop = gps.hdop;\n                // Set the home VDOP\n                home_vdop = gps.vdop;\n                // Set the home PDOP\n                home_pdop = gps.pdop;\n               ", "CodeBleu_score": 42.92016647842435}, {"code": "void Tracker::update_GPS(void)    // Update GPS\n    gps.update();\n    // Check if last message time has changed\n    if (gps.lastMessageTime() != last_gps_message_time) {\n        last_gps_message_time = gps.lastMessageTime();\n        // Check if GPS status is at least 3D fix\n        if (gps.fixType() >= 3) {\n            // Update the GPS data\n            gps_data.latitude = gps.latitude();\n            gps_data.longitude = gps.longitude();\n            gps_data.altitude = gps.altitude();\n            gps_data.speed = gps.speed();\n            gps_data.course = gps.course();\n            gps_data.fix_quality = gps.fixType();\n            gps_data.satellites = gps.satellites();\n            gps_data.hdop = gps.hdop();\n            gps_data.vdop = gps.vdop();\n            gps_data.tdop = gps.tdop();\n            gps_data.age = gps.age();\n            gps_data.valid = true;\n            // Check if the current location is valid\n            if (gps_data.valid) {\n                // Check if the ground start countdown has reached one\n                if (ground_start_countdown == 1) {\n                    // Set the home location\n                    home_location.latitude = gps_data.latitude;\n                    home_location.longitude = gps_data.longitude;\n                    home_location.altitude = gps_data.altitude;\n                    home_location.valid = true;\n                    // Set the ground start flag\n                    ground_start = true;\n                    // Reset the ground start countdown\n                    ground_start_countdown = 0;\n                }\n                // Increment the ground start countdown\n                ground_start_countdown++;\n            } else {\n                // Reset the ground start countdown\n                ground_start_countdown = 0;\n            }\n        }\n    }\n}\n", "CodeBleu_score": 50.86136297277666}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const  if (pitch > 180) {\n    pitch = 180;\n  }\n  if (pitch < 0) {\n    pitch = 0;\n  }\n  if (pitch < 90) {\n    servo_on();\n    servo_write(pitch);\n  } else {\n    servo_off();\n  }\n}\n", "CodeBleu_score": 10.94736862351606}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    if (pitch > 180) {\n        pitch = 180;\n    }\n    if (pitch < 0) {\n        pitch = 0;\n    }\n    if (pitch > 120) {\n        pitch = 120;\n    }\n    if (pitch < 60) {\n        pitch = 60;\n    }\n    servo_pitch.write(pitch);\n}\n", "CodeBleu_score": 14.829565030909697}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const    if (pitch < 0) {\n        pitch = 0;\n    }\n    if (pitch > 180) {\n        pitch = 180;\n    }\n    if (pitch == 0) {\n        servo_pitch.write(1500);\n    } else if (pitch == 180) {\n        servo_pitch.write(2500);\n    } else {\n        servo_pitch.write(1500 + (pitch * 10));\n    }\n}\n", "CodeBleu_score": 20.03355807400326}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    // call the base class's barometer_checks function\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check if barometer reference is valid\n    if (!AP::baro().get_reference(barometer_reference)) {\n        if (display_failure) {\n            AP_Notify::flags.baro_bad = true;\n        }\n        return false;\n    }\n\n    // check if barometer altitude is within 100cm of the inertial navigation altitude\n    if (fabsf(inertial_nav.get_altitude() - barometer_reference) > 100.0f) {\n        if (display_failure) {\n            AP_Notify::flags.baro_bad = true;\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 38.93351266263925}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check barometer reference\n    if (hal.util->get_soft_armed()) {\n        if (AP_Arming::pre_arm_checks(display_failure)) {\n            // if the barometer is bad, flag an error\n            if (!AP_Baro::get_last_update().getLastUpdate() ||\n                AP_Baro::get_last_update().getLastUpdate().get_last_sensor_timestamp() > millis()) {\n                if (display_failure) {\n                    AP_Notify::flags.baro_bad = true;\n                }\n                return false;\n            }\n        }\n    }\n\n    // check baro altitude\n    if (g.arm_check_baro_alt) {\n        float baro_alt = barometer.get_altitude();\n        float nav_alt = inertial_nav.get_altitude();\n        if (isnan(baro_alt) || isnan(nav_alt)) {\n            if (display_failure) {\n                AP_Notify::flags.baro_bad = true;\n            }\n            return false;\n        }\n        if (fabsf(baro_alt - nav_alt) > g.arm_alt_max) {\n            if (display_failure) {\n                AP_Notify::flags.baro_bad = true;\n            }\n            return false;\n        }\n    }\n\n    return true;\n}", "CodeBleu_score": 49.36553925579478}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)    // call base class's barometer checks\n    if (!AP_Arming::barometer_checks(display_failure)) {\n        return false;\n    }\n\n    // check if barometer reference is valid\n    if (!AP::baro()->get_reference(baro_reference)) {\n        if (display_failure) {\n            AP_Notify::flags.baro_glitching = true;\n        }\n        return false;\n    }\n\n    // check baro is connected\n    if (!AP::baro()->get_update()) {\n        if (display_failure) {\n            AP_Notify::flags.baro_not_connected = true;\n        }\n        return false;\n    }\n\n    // check baro is healthy\n    if (!AP::baro()->healthy(display_failure)) {\n        return false;\n    }\n\n    // check barometer disparity\n    if (is_positive(inertial_nav.get_altitude() - baro_reference)) {\n        if (display_failure) {\n            AP_Notify::flags.baro_high_disparity = true;\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 43.888592777418204}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const    if (copter.g2.terrain_source == TERRAIN_SOURCE_RANGEFINDER) {\n        return false;\n    }\n    if (copter.g2.terrain_source == TERRAIN_SOURCE_TERRAIN && copter.g2.rtl_alt_type == RTL_ALT_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 64.51589713571049}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    // if the terrain source is from a rangefinder, we don't need a terrain database\n    if (copter.rangefinder_state.source == RangeFinder::SOURCE_RANGEFINDER) {\n        return false;\n    }\n    // if the terrain source is from the terrain database and the RTL altitude type is terrain, we need a terrain database\n    if ((copter.rangefinder_state.source == RangeFinder::SOURCE_TERRAIN) &&\n        (copter.g.terrain_source == TERRAIN_SOURCE_TERRAIN)) {\n        return true;\n    }\n    // otherwise defer to the base class implementation\n    return AP_Arming::terrain_database_required();\n}", "CodeBleu_score": 65.33119874565583}, {"code": "bool AP_Arming_Copter::terrain_database_required() const    if (copter.rangefinder != nullptr && copter.rangefinder->has_orientation()) {\n        return false;\n    }\n    if (copter.ap.terrain_source == AP_TERRAIN_SOURCE_TERRAIN_DB && copter.ap.terrain_alt_source == AP_TERRAIN_ALT_SOURCE_TERRAIN) {\n        return true;\n    }\n    return AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 66.49286548437038}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()    // call rate controllers\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 10.870404201852502}, {"code": "void Copter::run_rate_controller()    // run low level rate controllers\n    attitude_control.rate_controller_run();\n}", "CodeBleu_score": 11.332070826791794}, {"code": "void Copter::run_rate_controller()\n    // run the rate controllers\n    attitude_control.rate_controller_run();\n\n    // run the position controller, if enabled\n    if (position_ok()) {\n        pos_control.update_set_pos_and_vel();\n    }\n\n    // run the vertical position controller\n    if (ap.land_complete && (ap.land_target_alt > 0)) {\n        pos_control.set_pos_target_z_from_climb_rate_cm();\n    }\n\n    // run the horizontal position controller\n    if (ap.land_complete || !ap.land_init || !motors.have_skid_steering()) {\n        pos_control.update_xy_controller();\n    }\n\n    // run the horizontal velocity controller\n    if (ap.land_complete || !ap.land_init) {\n        pos_control.update_z_controller();\n    }\n\n    // run the attitude controller\n    if (ap.land_complete || !ap.land_init || !motors.have_skid_steering()) {\n        attitude_control.angle_boost = false;\n        attitude_control.input_thrust_vector_rate_heading();\n    }\n\n    // run the loiter controller\n    if (ap.land_complete || !ap.land_init) {\n        loiter_nav.update();\n    }\n\n    // run the navigation controller\n    if (ap.land_complete || !ap.land_init) {\n        ac_attitude_control_run();\n    }\n\n    // run the land controller\n    if (ap.land_complete || !ap.land_init) {\n        land_run();\n    }\n\n    // run the failsafe controller\n    failsafe_run();\n\n    // run the glitch detector to keep track of continuous glitches\n    gnd_effect_detect.update();\n\n    // run the dynamic pressure and other related controllers\n    update_airspeed();\n\n    // run the wind estimation\n    wind_estimation.update();\n\n    // run the gyro calibration\n    gyro_calibrate();\n\n    // run the gyro temperature sensor calibration\n   ", "CodeBleu_score": 33.71991085647137}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    if (old_loc.lat == new_loc.lat && old_loc.lng == new_loc.lng && old_loc.alt == new_loc.alt && old_loc.relative_alt == new_loc.relative_alt && old_loc.terrain_alt == new_loc.terrain_alt && old_loc.terrain_alt_valid == new_loc.terrain_alt_valid && old_loc.frame == new_loc.frame) {\n        return false;\n    }\n    target_location = new_loc;\n    return true;\n}", "CodeBleu_score": 41.030263537980495}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    if (!old_loc.same_latlon(new_loc) || old_loc.alt != new_loc.alt) {\n        // if we have reached a new waypoint, set it as the target location\n        set_target_location(new_loc);\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 45.63828734266602}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)    // check if the new location is the same as the current waypoint\n    if (old_loc.same_latlon(new_loc)) {\n        // check if the altitude frames are the same\n        if (old_loc.relative_alt && new_loc.relative_alt) {\n            // if the altitude frames are the same, set the new location as the target\n            set_target_altitude_current();\n            return true;\n        } else if (!old_loc.relative_alt && !new_loc.relative_alt) {\n            // if the altitude frames are the same, set the new location as the target\n            set_target_altitude_absolute(new_loc.alt);\n            return true;\n        }\n    }\n    // if the new location is not the same as the current waypoint or the altitude frames are not the same, return false\n    return false;\n}\n", "CodeBleu_score": 42.60000209639012}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    // if the switch is in the HIGH position, attempt to set the mode\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        // attempt to set the mode\n        copter.set_mode(mode, ModeReason::RC_COMMAND);\n    } else if (copter.mode_has_manual_throttle(mode)) {\n        // if the switch is not in the HIGH position and the current flight mode matches the given mode, reset the mode switch\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 61.08788101444156}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (mode == Mode::Number::NONE) {\n        return;\n    }\n\n    if (ch_flag == AuxSwitchPos::HIGH) {\n        // switch is in the HIGH position, set the mode\n        if (copter.set_mode(mode, ModeReason::RC_COMMAND)) {\n            // if the mode was successfully set, reset the mode switch\n            rc().reset_mode_switch();\n        }\n    } else {\n        // switch is in the LOW position, check if the mode is the same as the aux function\n        if (copter.mode_number() == mode) {\n            // if the mode is the same as the aux function, reset the mode switch\n            rc().reset_mode_switch();\n        }\n    }\n}", "CodeBleu_score": 63.946598252885614}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)    if (mode == Mode::Number::None) {\n        // no valid mode specified\n        return;\n    }\n\n    // check if the mode is active\n    if (copter.mode_from_commander->mode() != mode) {\n        // not active - set it\n        copter.set_mode(mode, ch_flag);\n    } else {\n        // active - reset the mode switch\n        rc().reset_mode_switch();\n    }\n}", "CodeBleu_score": 59.89169189890624}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()    float roll_trim_rad = (g.rc_3.get_control_in() - 1500) / 500.0f * RAD_MAX;\n    float pitch_trim_rad = (g.rc_4.get_control_in() - 1500) / 500.0f * RAD_MAX;\n\n    ahrs.set_trim(Vector3f(roll_trim_rad, pitch_trim_rad, 0));\n\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"RC_CH#3: %d, RC_CH#4: %d\",\n                      g.rc_3.get_control_in(), g.rc_4.get_control_in());\n    gcs_send_text_fmt(MAV_SEVERITY_INFO, \"Saved roll and pitch trim: %.1f, %.1f\",\n                      degrees(roll_trim_rad), degrees(pitch_trim_rad));\n}\n", "CodeBleu_score": 39.9440494383733}, {"code": "void Copter::save_trim()    float roll_in = channel_roll->control_in;\n    float pitch_in = channel_pitch->control_in;\n\n    // convert to radians\n    float roll_rad = radians(roll_in);\n    float pitch_rad = radians(pitch_in);\n\n    // add to the AHRS's trim\n    ahrs.trim_roll(roll_rad);\n    ahrs.trim_pitch(pitch_rad);\n\n    // log event\n    Log_Write_Event(DATA_SAVE_TRIM);\n\n    // send message\n    send_message(MSG_SAVE_TRIM);\n}", "CodeBleu_score": 43.11221193345837}, {"code": "void Copter::save_trim()    // get roll trim\n    float roll_trim = (float)channel_roll->get_control_in() / 4500.0f;\n\n    // get pitch trim\n    float pitch_trim = (float)channel_pitch->get_control_in() / 4500.0f;\n\n    // add to ahrs\n    ahrs.add_trim(Vector3f(roll_trim, pitch_trim, 0));\n\n    // log and send message\n    Log_Write_Event(DATA_SAVE_TRIM);\n    send_message(MSG_SAVE_TRIM);\n}", "CodeBleu_score": 46.70831001521796}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()    float yaw_angle = 0;\n    float speed_xy = copter.inertial_nav.get_velocity_xy();\n    if (speed_xy > 0.001f) {\n        float speed_z = fabsf(copter.inertial_nav.get_velocity_z());\n        float speed_sq = speed_xy * speed_xy + speed_z * speed_z;\n        if (copter.inertial_nav.get_position_ok() && speed_sq > MIN_SPEED_XY_SQ_FOR_YAW) {\n            yaw_angle = atan2f(copter.inertial_nav.get_velocity_y(), copter.inertial_nav.get_velocity_x());\n        }\n    }\n    return yaw_angle;\n}\n", "CodeBleu_score": 42.339924570412435}, {"code": "float Mode::AutoYaw::look_ahead_yaw()    float yaw = 0.0f;\n\n    // get velocity vector\n    const Vector3f &vel = inertial_nav.get_velocity();\n\n    // get velocity vector length and limit minimum speed\n    float speed = vel.length();\n    if (speed < 0.1f) {\n        // don't change heading if we're not moving\n        return yaw;\n    }\n\n    // work out the yaw we would need to have to face this direction\n    yaw = degrees(atan2f(vel.y, vel.x)) * 100.0f;\n\n    // ensure yaw is between 0 and 360 degrees\n    yaw = wrap_360(yaw);\n\n    // ensure yaw is within the desired limits\n    yaw = constrain_float(yaw, _yaw_limit_min, _yaw_limit_max);\n\n    return yaw;\n}", "CodeBleu_score": 42.61959081368551}, {"code": "float Mode::AutoYaw::look_ahead_yaw()    float yaw_angle = 0.0f;\n    Vector2f vel = inertial_nav.get_velocity();\n    float speed_sq = vel.length_squared();\n    if (ahrs.have_inertial_nav() && speed_sq > 0.01f) {\n        yaw_angle = -atan2f(vel.x, vel.y);\n    }\n    return yaw_angle;\n}\n", "CodeBleu_score": 37.52614724818187}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    if (arming_checks_disabled) {\n        return true;\n    }\n\n    if (watchdog_armed) {\n        return true;\n    }\n\n    if (method == AP_Arming::Method::RUDDER) {\n        if (rudder_arming_disabled) {\n            return false;\n        }\n\n        if (channel_throttle->get_control_in() > 0) {\n            return false;\n        }\n    }\n\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 49.97222462327795}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    // exit immediately if arming checks are disabled\n    if (checks_to_perform == 0) {\n        return true;\n    }\n\n    // exit immediately if the watchdog is armed\n    if (watchdog.is_armed()) {\n        return true;\n    }\n\n    switch (method) {\n    case AP_Arming::Method::ANGLE_OF_ATTACK:\n    case AP_Arming::Method::ANGLE_OF_SIDE_SLIP:\n        // these methods are not supported by plane\n        return true;\n\n    case AP_Arming::Method::RUDDER:\n        // rudder arming is disabled\n        if (!rudder_arming_enabled) {\n            return true;\n        }\n\n        // rudder arming requires throttle to be zero\n        if (plane.channel_throttle->get_control_in() != 0) {\n            return false;\n        }\n\n        return true;\n\n    case AP_Arming::Method::THROTTLE_UNLIMITED:\n        // throttle arming requires throttle to be zero\n        if (plane.channel_throttle->get_control_in() != 0) {\n            return false;\n        }\n\n        return true;\n\n    case AP_Arming::Method::THROTTLE_HOLD:\n        // throttle hold arming requires throttle to be non-zero\n        if (plane.channel_throttle->get_control_in() == 0) {\n            return false;\n        }\n\n        return true;\n\n    case AP_Arming::Method::ANGLE_BOX:\n        // angle box arming requires throttle to be non-zero\n        if (plane.channel_throttle->get_control_in() == 0) {\n            return false;\n        }\n\n        return true;\n\n    case AP_Arming::Method::ANGLE_DSHOT:\n    case AP_Arming::Method::ANGLE_MAVLINK:\n        // these methods are not supported by plane\n        return true;\n    }\n\n    // call parent class's", "CodeBleu_score": 46.619946405003276}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)    // if arming checks are disabled, we always pass\n    if (arming_checks_disabled()) {\n        return true;\n    }\n\n    // if the watchdog was armed, we always pass\n    if (watchdog_armed()) {\n        return true;\n    }\n\n    // if the arming method is RUDDER, we need to check rudder arming is disabled or throttle is zero\n    if (method == AP_Arming::Method::RUDDER) {\n        // check if rudder arming is disabled\n        if (rudder_arming_disabled()) {\n            return false;\n        }\n\n        // check if throttle is zero\n        if (plane.channel_throttle->get_control_in() > 0) {\n            return false;\n        }\n    }\n\n    // call parent class's arm_checks method\n    return AP_Arming::arm_checks(method);\n}\n", "CodeBleu_score": 53.58623970627654}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    // check if arming checks should be skipped\n    if (do_arming_checks) {\n        // run the arming checks\n        if (!arming_checks(method)) {\n            return false;\n        }\n    }\n\n    // set the arming method\n    arming_method = method;\n\n    // update home location\n    if (method == AP_Arming::Method::HOME) {\n        // set the home position to the current location\n        if (!AP::ahrs().set_home(AP::ahrs().get_position())) {\n            // if this fails, it's probably because the EKF hasn't had a chance to\n            // initialise.  In this case, we want to retry the arm, so return false\n            // here.\n            return false;\n        }\n    }\n\n    // set the current location as home\n    if (method == AP_Arming::Method::AUTO) {\n        // set the home position to the current location\n        if (!AP::ahrs().set_home(AP::ahrs().get_position())) {\n            // if this fails, it's probably because the EKF hasn't had a chance to\n            // initialise.  In this case, we want to retry the arm, so return false\n            // here.\n            return false;\n        }\n    }\n\n    // update arming status\n    arming_check_status.flags.set_armed_method(method);\n\n    // set delay arming flag\n    delay_arming = true;\n\n    // send text message\n    AP_Notify::flags.armed = true;\n\n    // return success\n    return true;\n}\n", "CodeBleu_score": 37.1197270479305}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)    // exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // exit immediately if vehicle is not in a landed state\n    if (copter.ap.land_complete != AP_LandingGear::Landed_Approached) {\n        return false;\n    }\n\n    // exit immediately if vehicle is in a crash state\n    if (copter.ap.crash_state.is_crashed) {\n        return false;\n    }\n\n    // exit immediately if vehicle is not in a landed state\n    if (copter.ap.land_complete != AP_LandingGear::Landed_Approached) {\n        return false;\n    }\n\n    // check if arming checks should be performed\n    if (do_arming_checks) {\n        // run through the arming checks\n        if (!check_pre_arm()) {\n            return false;\n        }\n    }\n\n    // set the arming method\n    arming_method = method;\n\n    // set the arming state\n    arming_state = AP_Arming::ARMING_CHECK_RUNNING;\n\n    // send the pre-arm status message\n    AP_Notify::flags.pre_arm_check = true;\n\n    // start the arming timer\n    arming_start_time_ms = millis();\n\n    // return success\n    return true;\n}\n", "CodeBleu_score": 46.58785461483165}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\n    // exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // exit immediately if vehicle is not in a landed state\n    if (!AP::landing().is_disarmed_and_landed()) {\n        return false;\n    }\n\n    // check if arming checks should be performed\n    if (do_arming_checks) {\n        if (!arming_checks()) {\n            return false;\n        }\n    }\n\n    // set arming method\n    arming_method = method;\n\n    // set arming state\n    arming_state = AP_Arming::ARMING_CHECK_PRE_ARM;\n\n    // update home location\n    if (!AP::ahrs().home_is_set()) {\n        AP::ahrs().set_home(AP::ahrs().get_position());\n    }\n\n    // set home location in AHRS\n    AP::ahrs().set_home(AP::ahrs().get_position());\n\n    // update current location\n    current_loc = AP::ahrs().get_position();\n\n    // change arm state\n    set_armed_home(true);\n\n    // set delay arming flag\n    delay_arming = true;\n\n    // send status text\n    AP_Notify::flags.armed = true;\n\n    // return success\n    return true;\n}", "CodeBleu_score": 42.13103364045959}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    // if we are already armed, return true\n    if (armed()) {\n        return true;\n    }\n\n    // if disarm_button is not configured, return false\n    if (disarm_button == -1) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_check = true;\n            AP_Notify::flags.armed_state = false;\n            AP_Notify::flags.pre_arm_gcs_check = false;\n        }\n        return false;\n    }\n\n    // otherwise, proceed with standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 58.28423934225368}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    // if already armed, return true\n    if (arming.is_armed()) {\n        return true;\n    }\n\n    // if no disarm button is configured, display failure message and return false\n    if (!arming.disarm_button_function()) {\n        if (display_failure) {\n            AP_Notify::flags.pre_arm_check = true;\n            AP_Notify::flags.pre_arm_check_failed = true;\n        }\n        return false;\n    }\n\n    // perform standard pre-arm checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}\n", "CodeBleu_score": 61.162481452819975}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)    if (armed) {\n        return true;\n    }\n\n    // check if a disarm button is configured\n    if (!hal.util->get_soft_armed()) {\n        if (display_failure) {\n            gcs().send_text(MAV_SEVERITY_CRITICAL, \"Arming failed: DISARM button not configured\");\n        }\n        return false;\n    }\n\n    // if we get here it means that the disarm button is configured\n    // so we can call the standard arming checks\n    return AP_Arming::pre_arm_checks(display_failure);\n}", "CodeBleu_score": 68.2455136021068}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    // Calculate the rotation matrix\n    float rotation_matrix[2][2] = {\n        {cosf(ahrs.yaw_rad), -sinf(ahrs.yaw_rad)},\n        {sinf(ahrs.yaw_rad), cosf(ahrs.yaw_rad)}\n    };\n\n    // Apply the rotation matrix to the x and y coordinates\n    float ne_x = rotation_matrix[0][0] * x + rotation_matrix[0][1] * y;\n    float ne_y = rotation_matrix[1][0] * x + rotation_matrix[1][1] * y;\n\n    // Update x and y with the new coordinates\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 50.281674182133784}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    float ne_x, ne_y;\n    float yaw = ahrs.yaw;\n\n    // Apply the rotation matrix to the x and y coordinates\n    ne_x = x * cos(yaw) + y * sin(yaw);\n    ne_y = -x * sin(yaw) + y * cos(yaw);\n\n    // Update the x and y coordinates with the new values\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 57.46666024168292}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)    // Calculate the rotation matrix\n    float R[2][2];\n    R[0][0] = cosf(ahrs.yaw);\n    R[0][1] = -sinf(ahrs.yaw);\n    R[1][0] = sinf(ahrs.yaw);\n    R[1][1] = cosf(ahrs.yaw);\n\n    // Apply the rotation matrix to the input coordinates\n    float ne_x = R[0][0] * x + R[0][1] * y;\n    float ne_y = R[1][0] * x + R[1][1] * y;\n\n    // Update the input coordinates with the new values\n    x = ne_x;\n    y = ne_y;\n}\n", "CodeBleu_score": 51.498664250788565}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    MAV_RESULT res = MAV_RESULT_FAILED;\n\n    // check if the yaw angle and param4 values are within acceptable ranges\n    if (is_zero(packet.param4)) {\n        // if param4 is zero, yaw angle is relative to current heading\n        if (is_zero(packet.param1)) {\n            // if param1 is also zero, yaw angle is relative to current heading\n            if (is_zero(packet.param2)) {\n                // if param2 is also zero, yaw angle is relative to current heading\n                if (is_zero(packet.param3)) {\n                    // if param3 is also zero, yaw angle is relative to current heading\n                    res = MAV_RESULT_ACCEPTED;\n                } else {\n                    // if param3 is not zero, yaw angle is relative to current heading\n                    res = MAV_RESULT_DENIED;\n                }\n            } else {\n                // if param2 is not zero, yaw angle is relative to current heading\n                res = MAV_RESULT_DENIED;\n            }\n        } else {\n            // if param1 is not zero, yaw angle is relative to current heading\n            res = MAV_RESULT_DENIED;\n        }\n    } else {\n        // if param4 is not zero, yaw angle is relative to current heading\n        res = MAV_RESULT_DENIED;\n    }\n\n    // set the yaw heading using the provided parameters\n    if (res == MAV_RESULT_ACCEPTED) {\n        // set the yaw heading using the provided parameters\n        // ...\n    }\n\n    return res;\n}\n", "CodeBleu_score": 34.66400759332321}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    // check if vehicle is in guided mode\n    if (control_mode != GUIDED) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check for valid input arguments\n    if (packet.param1 > radians(90)) {\n        return MAV_RESULT_FAILED;\n    }\n    if (packet.param2 > radians(90)) {\n        return MAV_RESULT_FAILED;\n    }\n    if (packet.param3 > radians(90)) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // check for valid param4 value\n    if (packet.param4 != 0 && packet.param4 != 1) {\n        return MAV_RESULT_FAILED;\n    }\n\n    // set yaw mode\n    if (packet.param4 == 0) {\n        // absolute angle\n        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, packet.param1);\n    } else {\n        // relative angle\n        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, g.compass_enabled ? ahrs.yaw_sensor : ahrs.yaw, packet.param1);\n    }\n\n    // set yaw rate\n    if (packet.param2 > 0) {\n        attitude_control->input_euler_rate_yaw(packet.param2);\n    } else {\n        attitude_control->input_euler_rate_yaw(0);\n    }\n\n    // set turn rate\n    if (packet.param3 > 0) {\n        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, 0, packet.param3);\n    } else {\n        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, 0, 0);\n    }\n\n    return M", "CodeBleu_score": 43.124730421994414}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)    MAV_RESULT res = MAV_RESULT_FAILED;\n    float yaw_angle_cd = packet.param1;\n    float yaw_rate_cds = packet.param2;\n\n    // check if yaw_angle_cd is within acceptable range\n    if (is_zero(yaw_angle_cd)) {\n        // if yaw_angle_cd is 0, set yaw_angle_cd to current heading\n        yaw_angle_cd = ahrs.yaw_sensor;\n    }\n\n    // check if yaw_rate_cds is within acceptable range\n    if (is_zero(yaw_rate_cds)) {\n        // if yaw_rate_cds is 0, set yaw_rate_cds to default value\n        yaw_rate_cds = DEFAULT_YAW_RATE_CDS;\n    }\n\n    // check if yaw_angle_cd and yaw_rate_cds are within acceptable ranges\n    if (is_positive(yaw_angle_cd) && is_positive(yaw_rate_cds)) {\n        // set yaw heading using provided parameters\n        if (set_yaw_heading(yaw_angle_cd, yaw_rate_cds, packet.param3)) {\n            res = MAV_RESULT_ACCEPTED;\n        }\n    }\n\n    return res;\n}\n", "CodeBleu_score": 32.281553680152435}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if (control_mode == AUTO || control_mode == GUIDED) {\n        return (int16_t)(wp_bearing / 2);\n    }\n    return 0;\n}\n", "CodeBleu_score": 38.457746481216105}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if ((control_mode == AUTO || control_mode == GUIDED) && !failsafe.auto_fb) {\n        return (wp_bearing / 2) % 360;\n    }\n    return 0;\n}", "CodeBleu_score": 42.521256188276034}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const    if (control_mode == AUTO || control_mode == GUIDED) {\n        return (uint8_t)((g2.wp_nav.get_bearing_cd()/2)%360);\n    } else {\n        return 0;\n    }\n}\n", "CodeBleu_score": 44.56484851488549}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (!log_enabled)\n        return;\n\n    LogPacket packet;\n    packet.time = HAL_GetTick();\n    packet.id = id;\n    packet.value = value;\n\n    logger.Write(packet, Logger::BLOCK_CRITICAL);\n}\n", "CodeBleu_score": 36.5025125018528}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (log_enabled) {\n        LogPacket log_packet = {\n            .time = millis(),\n            .id = id,\n            .value = value\n        };\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n        log_buffer.push(log_packet);\n", "CodeBleu_score": 35.605740308957635}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)    if (loggingEnabled) {\n        LogPacket packet = {\n            .time = millis(),\n            .id = id,\n            .value = value\n        };\n        logger.logCriticalBlock(packet);\n    }\n}\n", "CodeBleu_score": 39.16555980761226}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()    // if we've already set home, exit immediately\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if motors are armed, set home to current location\n    if (motors.armed()) {\n        if (ahrs.set_home(gps.location())) {\n            Log_Write_Event(data_log, LOG_HOME_SET_FROM_EKF_EVENT);\n        }\n        return;\n    }\n\n    // if motors are not armed, attempt to set home to EKF location\n    if (ahrs.set_home(ahrs.get_position())) {\n        Log_Write_Event(data_log, LOG_HOME_SET_FROM_EKF_EVENT);\n    }\n}\n", "CodeBleu_score": 32.613090944238685}, {"code": "void Sub::update_home_from_EKF()    // exit immediately if home is already set\n    if (ahrs.home_is_set()) {\n        return;\n    }\n\n    // if motors are armed, set home to current location\n    if (motors.armed()) {\n        set_home_to_current_location(false);\n        return;\n    }\n\n    // if motors are disarmed, attempt to set home to EKF location\n    set_home_to_current_location(true);\n}\n", "CodeBleu_score": 41.058679943256024}, {"code": "void Sub::update_home_from_EKF()    if (home_is_set()) {\n        return;\n    }\n\n    if (motors->armed()) {\n        // if we've landed, set home to current location\n        if (in_landed_state()) {\n            set_home_to_current_location();\n            return;\n        }\n\n        // if we're in-flight, set home to current location\n        set_home_to_current_location();\n        return;\n    }\n\n    // if we're not armed, try to set home to current EKF location\n    set_home_to_current_location(false);\n}\n", "CodeBleu_score": 35.41573623790037}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()    // if not armed set throttle to zero and exit immediately\n    if (!motors->armed()) {\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    float target_roll, target_pitch;\n    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, aparm.angle_max);\n\n    // run attitude controller\n    attitude_control->input_euler_angle_roll_pitch_rate_yaw(target_roll, target_pitch, 0);\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // output pilot's throttle without angle boost\n    motors->set_throttle(channel_throttle->norm_input());\n\n    // convert pilot input to forward / backward and left / right\n    float target_forward, target_right;\n    get_pilot_desired_forward_right(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_forward, target_right);\n\n    // send output to motors\n    motors->set_forward(target_forward);\n    motors->set_lateral(target_right);\n}", "CodeBleu_score": 56.25973102302814}, {"code": "void ModeAcro::run()    // if not armed set throttle to zero and exit immediately\n    if (!motors->armed()) {\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->input_euler_angle_roll_pitch_yaw(0, 0, 0, get_smoothing_gain());\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert the input to the desired body frame rate\n    float target_roll, target_pitch, target_yaw;\n    get_pilot_desired_angles_acro(target_roll, target_pitch, target_yaw, copter.aparm.angle_max);\n\n    // send the attitude controller the rate of change of each angle\n    attitude_control->input_euler_angle_roll_pitch_yaw(target_roll, target_pitch, target_yaw, get_smoothing_gain());\n\n    // get pilot's desired yaw rate\n    float target_yaw_rate = copter.get_pilot_desired_yaw_rate(channel_yaw->get_control_in());\n\n    // send the heading controller the yaw rate\n    if (copter.is_boat()) {\n        // boats do not stabilize roll/pitch/yaw\n        attitude_control->input_head_yaw_rate(target_yaw_rate);\n    } else {\n        // stabilize roll/pitch/yaw\n        attitude_control->input_euler_rate_yaw(0, 0, target_yaw_rate);\n    }\n\n    // get hold of current rate\n    float roll_rate, pitch_rate, yaw_rate;\n    attitude_control->get_att_target_euler_rates_cds(roll_rate, pitch_rate, yaw_", "CodeBleu_score": 57.08884389036159}, {"code": "void ModeAcro::run()    float target_roll, target_pitch, target_yawrate;\n\n    // if not armed set throttle to zero and exit immediately\n    if (!motors->armed()) {\n        motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::GROUND_IDLE);\n        attitude_control->relax_attitude_controllers();\n        return;\n    }\n\n    // set motors to full range\n    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);\n\n    // convert pilot input to lean angles\n    // To-Do: convert to desired body frame rate\n    // To-Do: convert roll input to desired body roll rate\n    // To-Do: convert pitch input to desired body pitch rate\n    // To-Do: convert yaw input to desired body yaw rate\n    // To-Do: convert throttle to desired body throttle\n    // To-Do: convert flaps input to desired collective pitch up\n    target_roll = channel_roll->norm_input();\n    target_pitch = channel_pitch->norm_input();\n    target_yawrate = channel_yaw->norm_input();\n\n    // call attitude controller\n    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yawrate);\n\n    // output pilot's throttle without angle boost\n    motors->set_throttle(channel_throttle->norm_input());\n\n    // convert pilot input to forward and lateral outputs\n    // To-Do: convert roll input to forward output\n    // To-Do: convert pitch input to lateral output\n    motors->set_forward(channel_roll->norm_input());\n    motors->set_lateral(channel_pitch->norm_input());\n}", "CodeBleu_score": 62.45006832737884}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()    // set guided mode's control mode to position\n    set_control_mode(Mode::Number::POSITION);\n\n    // set the destination to the stopping point\n    pos_control->set_destination(pos_control->get_stopping_point());\n\n    // initialise yaw\n    auto_yaw.set_mode(AUTO_YAW_MODE::DEFAULT_BEHAVIOUR);\n}\n", "CodeBleu_score": 20.458096008284016}, {"code": "void ModeGuided::guided_pos_control_start()    // set guided_pos_control_active\n    guided_pos_control_active = true;\n\n    // set guided_pos_control_timeout_ms\n    guided_pos_control_timeout_ms = AP_GPS::get_GPS().get_last_GPS_fix_time_ms() + 1000;\n\n    // set guided_pos_control_start_time_ms\n    guided_pos_control_start_time_ms = millis();\n\n    // set guided_pos_control_yaw_start\n    guided_pos_control_yaw_start = ahrs.yaw;\n\n    // set guided_pos_control_yaw_input\n    guided_pos_control_yaw_input = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint\n    guided_pos_control_yaw_setpoint = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint_prev\n    guided_pos_control_yaw_setpoint_prev = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint_prev\n    guided_pos_control_yaw_setpoint_prev = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint_prev\n    guided_pos_control_yaw_setpoint_prev = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint_prev\n    guided_pos_control_yaw_setpoint_prev = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint_prev\n    guided_pos_control_yaw_setpoint_prev = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint_prev\n    guided_pos_control_yaw_setpoint_prev = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint_prev\n    guided_pos_control_yaw_setpoint_prev = ahrs.yaw;\n\n    // set guided_pos_control_yaw_setpoint_prev", "CodeBleu_score": 33.76595329284706}, {"code": "void ModeGuided::guided_pos_control_start()    // set position target to stopping point\n    pos_control->set_pos_target_z_from_climb_rate(inertial_nav->get_altitude(), G_Dt);\n    pos_control->init_z_controller();\n\n    // initialise yaw\n    guided_yaw_state.slew_yaw_to(get_yaw_target_to_accelerate());\n\n    // initialise waypoint controller\n    wp_nav->init_z_controller();\n    wp_nav->init_speed_controller();\n\n    // set mode to RTL for minimum height\n    mode = Mode::Number::RTL;\n}\n", "CodeBleu_score": 27.204382393736093}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()    // set vertical speed and acceleration limits\n    pos_control->set_max_speed_accel_z(-get_pilot_speed_dn(), g2.guided_speed_up, g2.guided_accel_up);\n\n    // initialise velocity controller\n    Vector3f vel_target_cms;\n    vel_target_cms.x = pos_control->get_vel_target_cms().x;\n    vel_target_cms.y = pos_control->get_vel_target_cms().y;\n    vel_target_cms.z = -get_pilot_speed_dn();\n    pos_control->set_vel_target_cms(vel_target_cms);\n\n    // initialise horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_default_accel_xy());\n\n    // initialise yaw\n    // set yaw controller to use LEVEL mode with pilot's yaw input\n    yaw_control->set_mode(YAW_CONTROL_MODE_LEVEL);\n    yaw_control->set_input_filter_all(0.0f);\n}\n", "CodeBleu_score": 39.77086529037242}, {"code": "void ModeGuided::guided_vel_control_start()    // initialise vertical speed and acceleration\n    pos_control->set_max_speed_accel_z(-pilot_vel_max_down, pilot_vel_max_up, pilot_vel_accel_z);\n\n    // initialise horizontal speed and acceleration\n    pos_control->set_max_speed_accel_xy(pilot_vel_max_horiz, pilot_vel_max_horiz, pilot_vel_accel_xy);\n\n    // initialise vertical position controller\n    pos_control->init_z_controller();\n\n    // initialise horizontal position controller\n    pos_control->init_xy_controller();\n\n    // set yaw state\n    attitude_control->set_yaw_mode(ANGLE_YAW_HOLD);\n}\n", "CodeBleu_score": 41.0818555495178}, {"code": "void ModeGuided::guided_vel_control_start()    // initialize vertical speeds and acceleration\n    pos_control->set_max_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n    pos_control->set_correction_speed_accel_z(wp_nav->get_default_speed_down(), wp_nav->get_default_speed_up(), wp_nav->get_accel_z());\n\n    // initialise horizontal speeds\n    pos_control->set_max_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_default_speed_xy(), wp_nav->get_accel_xy());\n    pos_control->set_correction_speed_accel_xy(wp_nav->get_default_speed_xy(), wp_nav->get_default_speed_xy(), wp_nav->get_accel_xy());\n\n    // initialise yaw\n    pos_control->init_z_controller();\n    pos_control->init_vel_controller_xy();\n    pos_control->init_vel_controller_z();\n\n    // initialise terrain follow state\n    pos_control->init_terrain_follow();\n\n    // initialise the vertical position controller\n    pos_control->init_z_controller();\n\n    // initialise the horizontal position controller\n    pos_control->init_vel_controller_xy();\n\n    // initialise the horizontal velocity controller\n    pos_control->init_vel_controller_z();\n\n    // initialise the terrain controller\n    pos_control->init_terrain_follow();\n\n    // set the yaw controller to use the yaw heading of the waypoint\n    set_yaw_mode(AUTO_YAW_HOLD);\n}\n", "CodeBleu_score": 39.3347831612873}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()    // check timeout\n    if (millis() - guided_start_time > GUIDED_TIMEOUT_MS) {\n        gcs_send_text_P(MAV_SEVERITY_WARNING, PSTR(\"Guided timed out\"));\n        return true;\n    }\n\n    // check if we've reached the desired location\n    if (current_loc.lat == target_loc.lat && current_loc.lng == target_loc.lng) {\n        gcs_send_text_P(MAV_SEVERITY_WARNING, PSTR(\"Guided reached target location\"));\n        return true;\n    }\n\n    // check if we've reached the desired altitude\n    if (current_loc.alt >= target_loc.alt) {\n        gcs_send_text_P(MAV_SEVERITY_WARNING, PSTR(\"Guided reached target altitude\"));\n        return true;\n    }\n\n    // check if we've reached the desired horizontal distance\n    if (get_horizontal_distance_cm(current_loc, target_loc) <= guided_horizontal_distance_cm) {\n        gcs_send_text_P(MAV_SEVERITY_WARNING, PSTR(\"Guided reached horizontal distance\"));\n        return true;\n    }\n\n    return false;\n}", "CodeBleu_score": 41.57412635017207}, {"code": "bool ModeGuided::guided_limit_check()    // check if we've been flying for too long\n    if (millis() - guided_start_time > GUIDED_MAX_TIME) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Time limit reached\");\n        return true;\n    }\n\n    // check if we've been flying too high or low\n    if (current_loc.alt > GUIDED_MAX_ALT || current_loc.alt < GUIDED_MIN_ALT) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Altitude limit reached\");\n        return true;\n    }\n\n    // check if we've moved too far\n    if (current_loc.get_distance(guided_start_loc) > GUIDED_MAX_DISTANCE) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Distance limit reached\");\n        return true;\n    }\n\n    // check if we've been in a bad state for too long\n    if (millis() - guided_last_good_time > GUIDED_MAX_BAD_TIME) {\n        gcs().send_text(MAV_SEVERITY_WARNING, \"Guided: Bad state limit reached\");\n        return true;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 37.51809059441346}, {"code": "bool ModeGuided::guided_limit_check()    // check for timeout\n    if (should_exit()) {\n        return true;\n    }\n\n    // check if we've reached the desired location\n    if (reached_destination()) {\n        return true;\n    }\n\n    // check if we've reached the desired altitude\n    if (!pos_control->get_alt_hold_state()) {\n        // altitude is not being held\n        return true;\n    }\n    if (!pos_control->get_pos_hold_state_xy()) {\n        // we are not holding the horizontal position\n        return true;\n    }\n\n    // check if we've reached the desired horizontal distance\n    if (Vector2f(guided_state.target - pos_control->get_pos_target_cm()).length() < guided_state.horizontal_distance) {\n        return true;\n    }\n\n    // none of the above conditions have been met, so we continue with guided mode\n    return false;\n}", "CodeBleu_score": 33.69777481276132}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()  // Check if the motor test request has been received at least every 2 Hz\n  if (ros::Time::now().toSec() - motor_test_request_time.toSec() < 0.5) {\n    // If the motor test request has been received at least every 2 Hz, return true\n    return true;\n  }\n  // If the motor test request has not been received at least every 2 Hz, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n  else {\n    ROS_ERROR(\"Motor test request timed out\");\n    pass = false;\n    motor_test_request_time = ros::Time::now();\n    motor_test_request_received = false;\n    motor_test_enabled = false;\n    system_armed = false;\n    system_disarmed = true;\n    system_failure_time = ros::Time::now();\n    return false;\n  }\n}\n", "CodeBleu_score": 47.197113714737}, {"code": "bool Sub::verify_motor_test()    // This function checks if the motor test passed or failed\n    // If the motor test passed, return true\n    // If the motor test failed, return false\n    // If the motor test is not enabled, return true\n    // If the motor test is enabled, check if the motor test requests are received at least every 2 Hz\n    // If the motor test requests are not received at least every 2 Hz, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n    // If the motor test requests are received at least every 2 Hz, return true\n    // If the motor test is not enabled, return true\n    // If the motor test is enabled, check if the motor test requests are received at least every 2 Hz\n    // If the motor test requests are not received at least every 2 Hz, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n    // If the motor test requests are received at least every 2 Hz, return true\n    // If the motor test is not enabled, return true\n    // If the motor test is enabled, check if the motor test requests are received at least every 2 Hz\n    // If the motor test requests are not received at least every 2 Hz, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n    // If the motor test requests are received at least every 2 Hz, return true\n    // If the motor test is not enabled, return true\n    // If the motor test is enabled, check if the motor test requests are received at least every 2 Hz\n    // If the motor test requests are not received at least every 2 Hz, send a timeout message, set the pass flag to false, disable the motor test, disarm the system, record the failure time, and return false\n    // If the motor test requests are received at least every 2 Hz, return true\n    // If the motor test is not enabled, return true\n    // If the motor test is enabled, check if the motor test requests are received at least every 2 Hz\n    // If the motor test requests are not received at least every 2 Hz, send a timeout message, set the", "CodeBleu_score": 7.021219000747822}, {"code": "bool Sub::verify_motor_test()    ros::Rate rate(2.0);\n    bool pass = true;\n    int i = 0;\n    while (ros::ok() && pass) {\n        ros::spinOnce();\n        if (motor_test_request.data) {\n            motor_test_request.data = false;\n            i = 0;\n        } else {\n            i++;\n            if (i > 10) {\n                pass = false;\n            }\n        }\n        rate.sleep();\n    }\n    if (!pass) {\n        ROS_ERROR(\"MOTOR TEST TIMEOUT\");\n        mavros_msgs::CommandBool arm_cmd;\n        arm_cmd.request.value = false;\n        arming_client.call(arm_cmd);\n        mavros_msgs::SetMode set_mode;\n        set_mode.request.custom_mode = \"MANUAL\";\n        set_mode_client.call(set_mode);\n        ros::Time failure_time = ros::Time::now();\n        record_failure(failure_time, \"motor_test\");\n    }\n    return pass;\n}", "CodeBleu_score": 46.84433623692383}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)    // get the current position of the vehicle\n    Location current_location;\n    current_location = inertial_nav.get_position();\n\n    // get the current velocity of the vehicle\n    Vector3f current_velocity;\n    current_velocity = inertial_nav.get_velocity();\n\n    // get the current position of the next waypoint\n    Location next_waypoint_location;\n    next_waypoint_location = wp_nav.get_wp_destination();\n\n    // calculate the distance to the next waypoint\n    float distance_to_waypoint = current_location.get_distance(next_waypoint_location);\n\n    // get the current bearing to the next waypoint\n    float bearing_to_waypoint = current_location.get_bearing_to(next_waypoint_location);\n\n    // get the current altitude\n    float current_altitude = current_location.get_alt();\n\n    // calculate the desired roll and pitch angles\n    float desired_roll_angle = get_desired_roll_angle(distance_to_waypoint, current_altitude, current_velocity.z);\n    float desired_pitch_angle = get_desired_pitch_angle(distance_to_waypoint, current_altitude, current_velocity.z);\n\n    // constrain the desired roll and pitch angles\n    desired_roll_angle = constrain_float(desired_roll_angle, -roll_limit, roll_limit);\n    desired_pitch_angle = constrain_float(desired_pitch_angle, -pitch_limit, pitch_limit);\n\n    // normalize the desired roll and pitch angles\n    desired_roll_angle = normalize_angle_positive(desired_roll_angle);\n    desired_pitch_angle = normalize_angle_positive(desired_pitch_angle);\n\n    // assign the normalized roll and pitch angles to lateral_out and forward_out\n    lateral_out = desired_roll_angle;\n    forward_out = desired_pitch_angle;\n}\n", "CodeBleu_score": 37.028207999093965}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)    float rp_roll_target_cd, rp_pitch_target_cd;\n    float rp_roll_target_cd_norm, rp_pitch_target_cd_norm;\n    float rp_roll_error_cd, rp_pitch_error_cd;\n    float rp_roll_error_cd_norm, rp_pitch_error_cd_norm;\n    float rp_roll_input, rp_pitch_input;\n    float rp_roll_input_norm, rp_pitch_input_norm;\n\n    // get roll and pitch targets from wp_nav\n    wp_nav.get_roll_pitch(rp_roll_target_cd, rp_pitch_target_cd);\n\n    // constrain roll and pitch targets to the maximum angle range\n    rp_roll_target_cd = constrain_float(rp_roll_target_cd, -MAX_ROLL_ANGLE_CD, MAX_ROLL_ANGLE_CD);\n    rp_pitch_target_cd = constrain_float(rp_pitch_target_cd, -MAX_PITCH_ANGLE_CD, MAX_PITCH_ANGLE_CD);\n\n    // normalize roll and pitch targets to the range [-1, 1]\n    rp_roll_target_cd_norm = rp_roll_target_cd / MAX_ROLL_ANGLE_CD;\n    rp_pitch_target_cd_norm = rp_pitch_target_cd / MAX_PITCH_ANGLE_CD;\n\n    // get roll and pitch errors\n    rp_roll_error_cd = rp_roll_target_cd - ahrs.roll_sensor;\n    rp_pitch_error_cd = rp_pitch_target_cd - ahrs.pitch_sensor;\n\n    // normalize roll and pitch errors to the range [-1, 1]\n    rp_roll_error_cd_norm = rp_roll_error_cd / MAX_ROLL_ANGLE_CD;\n    rp_pitch_error_cd_norm = rp_", "CodeBleu_score": 28.735179034725082}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)  // get roll and pitch targets from wp_nav\n  float roll_target = wp_nav.get_roll_cd();\n  float pitch_target = wp_nav.get_pitch_cd();\n\n  // apply roll and pitch limits\n  roll_target = constrain_float(roll_target, -roll_limit_cd, roll_limit_cd);\n  pitch_target = constrain_float(pitch_target, -pitch_limit_cd, pitch_limit_cd);\n\n  // normalize roll and pitch targets\n  float roll_out = norm_to_scalar(roll_target, roll_limit_cd);\n  float pitch_out = norm_to_scalar(pitch_target, pitch_limit_cd);\n\n  // apply lateral and forward limits\n  lateral_out = constrain_float(roll_out, -lateral_limit_cd, lateral_limit_cd);\n  forward_out = constrain_float(pitch_out, -forward_limit_cd, forward_limit_cd);\n}\n", "CodeBleu_score": 41.26916700124275}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()    // read the barometer\n    barometer.read();\n\n    // if we are in a flight mode that uses the barometer, update the barometer calibration\n    if (flight_mode == FlightMode::ALT_HOLD || flight_mode == FlightMode::POSHOLD || flight_mode == FlightMode::AUTO || flight_mode == FlightMode::AUTO_TAKEOFF) {\n        barometer_calibration.update();\n    }\n\n    // if a depth sensor is present, update the sensor health status based on the barometer's health\n    if (depth_sensor.present()) {\n        if (barometer.healthy()) {\n            depth_sensor.healthy(true);\n        } else {\n            depth_sensor.healthy(false);\n        }\n    }\n}\n", "CodeBleu_score": 35.8557681385943}, {"code": "void Sub::read_barometer()    // read the barometer\n    barometer.read();\n\n    // update the barometer calibration\n    if (barometer.get_altitude() > 0) {\n        barometer.update_calibration();\n    }\n\n    // update the sensor health status based on the barometer's health\n    if (depth_sensor_healthy()) {\n        set_sensor_health(Sensor_barometer, barometer.healthy());\n    }\n}\n", "CodeBleu_score": 68.14655481615127}, {"code": "void Sub::read_barometer()    // update barometer health\n    barometer.update_health();\n\n    // update barometer calibration\n    if (barometer.get_altitude() > 0.0f) {\n        barometer.update_calibration();\n    }\n\n    // update depth sensor health\n    if (depth.healthy()) {\n        depth.update_health();\n    }\n}", "CodeBleu_score": 56.92752864324688}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()    // if we are in inertial navigation mode, then we must have a good inertial measurement\n    if (control_mode == ControlMode::INERTIAL_NAVIGATION) {\n        if (!inertial_nav.get_hil_state().flags.gps) {\n            return false;\n        }\n    }\n\n    // if we are in an absolute position control mode, we require a good absolute position\n    if (control_mode >= ControlMode::ABSOLUTE_POSITION_CONTROL) {\n        // if we are in absolute position control mode, we require a good absolute position\n        if (!failsafe.gps && !inertial_nav.get_hil_state().flags.gps) {\n            return false;\n        }\n        if (!failsafe.terrain && !inertial_nav.get_hil_state().flags.terrain) {\n            return false;\n        }\n        if (!inertial_nav.get_hil_state().flags.home) {\n            return false;\n        }\n    }\n\n    // if we are in a position control mode, we require a good absolute position and ensure the EKF is not in constant position mode\n    if (control_mode >= ControlMode::POSITION_CONTROL) {\n        // if we are in position control mode, we require a good absolute position\n        if (!failsafe.gps && !inertial_nav.get_hil_state().flags.gps) {\n            return false;\n        }\n        if (!failsafe.terrain && !inertial_nav.get_hil_state().flags.terrain) {\n            return false;\n        }\n        if (!inertial_nav.get_hil_state().flags.home) {\n            return false;\n        }\n\n        // ensure the EKF is not in constant position mode\n        if (ekf_bad()) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "CodeBleu_score": 33.625483904875374}, {"code": "bool Sub::ekf_position_ok()    // if we are inertially navigating, we must be okay\n    if (ahrs.inertial_nav_ok()) {\n        return true;\n    }\n\n    // if motors are disarmed, we must have a good absolute position\n    if (!motors.armed()) {\n        // if we don't have a good absolute position, we must not be okay\n        if (!inertial_nav.get_filter_status().flags.gps &&\n            !inertial_nav.get_filter_status().flags.evo &&\n            !inertial_nav.get_filter_status().flags.vision) {\n            return false;\n        }\n\n        // if we have a good absolute position, we must not be in constant position mode\n        if (inertial_nav.get_control_mode() == INAV_POSCTL) {\n            return false;\n        }\n\n        // if we have a good absolute position, we must be okay\n        return true;\n    }\n\n    // if motors are armed, we must have a good absolute position and be okay\n    return false;\n}", "CodeBleu_score": 47.799405105341606}, {"code": "bool Sub::ekf_position_ok()    // check if we are inertially navigating\n    if (!ahrs.inertial_nav_ok()) {\n        return false;\n    }\n\n    // check if motors are armed\n    if (!motors.armed()) {\n        // if motors are not armed, check if we have a GPS fix\n        if (!failsafe.gps) {\n            // if we don't have a GPS fix, we don't know where we are\n            return false;\n        }\n\n        // if we have a GPS fix, we can use it to predict our position\n        return true;\n    }\n\n    // motors are armed, so we need to check if we have a good absolute position\n    if (!failsafe.position_ok) {\n        // if we don't have a good absolute position, we can't use it\n        return false;\n    }\n\n    // if we have a good absolute position, we need to check if the EKF is in constant position mode\n    if (ekf_bad()) {\n        // if the EKF is in constant position mode, we can't use it\n        return false;\n    }\n\n    // if we have a good absolute position and the EKF is not in constant position mode, we can use it\n    return true;\n}\n", "CodeBleu_score": 38.06175624632957}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    // call the parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the AHRS system is ready\n    if (!AP::ahrs().prearm_check(display_failure)) {\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (AP::ahrs().in_failure_mode(AP_AHRS::FAILURE_EKF_GPS)) {\n        if (display_failure) {\n            failure_to_arm_string(ARMING_CHECK_EKF_GPS);\n        }\n        return false;\n    }\n\n    // ensure the position estimate is valid\n    if (!AP::ahrs().prearm_check_position(display_failure)) {\n        return false;\n    }\n\n    // all checks passed\n    return true;\n}\n", "CodeBleu_score": 39.49186047108918}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    // call the parent class's GPS checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the AHRS system is ready\n    if (!AP::ahrs().prearm_healthy(display_failure)) {\n        return false;\n    }\n\n    // check if the EKF failsafe is active\n    if (AP::ahrs().in_hil_mode() && AP::ahrs().get_failsafe_status() == AP_AHRS_FAILSAFE_EKF) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    // ensure the position estimate is valid\n    if (!AP::ahrs().prearm_position_ok(display_failure)) {\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 41.207966294042755}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)    // call parent class's gps checks\n    if (!AP_Arming::gps_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the ahrs system is ready\n    if (!ahrs.prearm_checks(display_failure)) {\n        return false;\n    }\n\n    // check if the ekf failsafe is active\n    if (ahrs.in_failure_mode(AHRS_FAILURE_EKF_GPS)) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    // ensure the position estimate is valid\n    if (!ahrs.get_position(current_loc)) {\n        if (display_failure) {\n            AP_Notify::flags.ekf_bad = true;\n        }\n        return false;\n    }\n\n    return true;\n}", "CodeBleu_score": 42.6923615939751}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    if (!AP_Arming::arm(method, do_arming_checks)) {\n        return false;\n    }\n\n    // if we're using the compass, we need to wait for it to initialise\n    if (AP_Arming::use_compass()) {\n        if (!hal.util->get_soft_armed()) {\n            // we're not armed, so we're not waiting for the compass\n            return true;\n        }\n        if (!AP_Arming::compass_ready()) {\n            // compass not initialised\n            return true;\n        }\n    }\n\n    // if we're using a fence, we need to wait for it to initialise\n    if (AP_Arming::use_fence()) {\n        if (!AP_Arming::fence_ready()) {\n            // fence not initialised\n            return true;\n        }\n    }\n\n    // if we're using a landing detector, we need to wait for it to initialise\n    if (AP_Arming::use_landing_detector()) {\n        if (!AP_Arming::landing_detector_ready()) {\n            // landing detector not initialised\n            return true;\n        }\n    }\n\n    // if we're using a proximity sensor, we need to wait for it to initialise\n    if (AP_Arming::use_proximity()) {\n        if (!AP_Arming::proximity_ready()) {\n            // proximity sensor not initialised\n            return true;\n        }\n    }\n\n    // if we're using a wind vane, we need to wait for it to initialise\n    if (AP_Arming::use_wind_vane()) {\n        if (!AP_Arming::wind_vane_ready()) {\n            // wind vane not initialised\n            return true;\n        }\n    }\n\n    // if we're using a gps, we need to wait for it to initialise\n    if (AP_Arming::use_gps()) {\n        if (!AP_Arming::gps_ready()) {\n            // GPS not initialised\n            return true;\n        }\n    }\n\n    // if we're using", "CodeBleu_score": 42.08991701471025}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)    if (method == AP_Arming::Method::AUTO) {\n        // if the vehicle is armed and we're disarming, revert to the last arming method\n        if (armed() && !ap.initial_armed_state) {\n            method = last_arming_method;\n        }\n\n        // if the vehicle is armed and we're arming, revert to manual arming\n        if (armed() && ap.initial_armed_state) {\n            method = AP_Arming::Method::MANUAL;\n        }\n\n        // if the vehicle is disarmed and we're disarming, revert to manual arming\n        if (!armed() && !ap.initial_armed_state) {\n            method = AP_Arming::Method::MANUAL;\n        }\n    }\n\n    // record the arming method\n    last_arming_method = method;\n\n    // set arming_in_progress flag\n    arming_in_progress = true;\n\n    // if we're arming, set the arming_from_gcs flag\n    if (method == AP_Arming::Method::MANUAL) {\n        arming_from_gcs = true;\n    }\n\n    // if arming from GCS, send an event to the GCS\n    if (arming_from_gcs) {\n        AP_Notify::flags.arming_gcs_request = true;\n    }\n\n    // if arming from GCS, send an event to the GCS\n    if (arming_from_gcs) {\n        AP_Notify::flags.arming_gcs_request = true;\n    }\n\n    // set arming_from_gcs flag\n    arming_from_gcs = true;\n\n    // if arming from GCS, send an event to the GCS\n    if (arming_from_gcs) {\n        AP_Notify::flags.arming_gcs_request = true;\n    }\n\n    // if arming from GCS, send an event to the GCS\n    if (arming_from_gcs) {\n        AP_Notify::flags.arming_gcs_request = true;\n    }\n", "CodeBleu_score": 38.374591086039814}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\n    // exit immediately if already armed\n    if (is_armed()) {\n        return true;\n    }\n\n    // if no arming checks are required, arm immediately\n    if (!do_arming_checks) {\n        return arm_impl(method);\n    }\n\n    // arm checks\n    if (!pre_arm_checks(method)) {\n        return false;\n    }\n\n    // arm motors\n    if (!arm_impl(method)) {\n        return false;\n    }\n\n    // set home to current location\n    set_home_to_current_location(false);\n\n    // send text message\n    AP_Notify::flags.armed = true;\n\n    // return success\n    return true;\n}\n", "CodeBleu_score": 40.77466443283756}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()    if (charging_allowed && !charging_enabled) {\n        charging_enabled = true;\n        charging_enabled_time = millis();\n    } else if (!charging_allowed && charging_enabled) {\n        charging_enabled = false;\n        charging_disabled_time = millis();\n    }\n\n    if (charging_enabled && !charging_allowed) {\n        charging_enabled = false;\n        charging_disabled_time = millis();\n    } else if (!charging_enabled && charging_allowed) {\n        charging_enabled = true;\n        charging_enabled_time = millis();\n    }\n}\n", "CodeBleu_score": 46.43592406999214}, {"code": "void updateChargingEnabled()  if (charging_allowed && !charging_enabled) {\n    // If charging is allowed but should not continue, disable charging and record the time\n    disableCharging();\n    charging_disabled_time = millis();\n  } else if (!charging_allowed && charging_enabled) {\n    // If charging is not allowed, retry enabling charging after a specified delay\n    if (millis() - charging_disabled_time >= charging_delay) {\n      enableCharging();\n    }\n  }\n}\n", "CodeBleu_score": 27.50122707240772}, {"code": "void updateChargingEnabled()  if (charging_allowed) {\n    if (charging_enabled) {\n      // If charging is enabled and charging_allowed is true, do nothing\n    } else {\n      // If charging is disabled and charging_allowed is true, enable charging\n      enableCharging();\n    }\n  } else {\n    if (charging_enabled) {\n      // If charging is enabled and charging_allowed is false, disable charging and record the time\n      disableCharging();\n      charging_disabled_time = millis();\n    } else {\n      // If charging is disabled and charging_allowed is false, check if it's time to re-enable charging\n      if (millis() - charging_disabled_time >= reenable_charging_delay) {\n        // If it's time to re-enable charging, enable charging and reset the charging_disabled_time\n        enableCharging();\n        charging_disabled_time = 0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 38.67560017126258}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)  if (ros_running && size >= 4) {\n    uint16_t crc = crc16((uint8_t *)message, size - 2);\n    ((uint16_t *)message)[1] = crc;\n    packetSerial.sendMessage(message, size);\n  }\n}\n", "CodeBleu_score": 37.566704632089156}, {"code": "void sendMessage(void *message, size_t size)  if (ros_running && size >= 4) {\n    uint16_t crc = crc16(message, size - 2);\n    uint16_t *crc_ptr = (uint16_t *)message + size - 2;\n    *crc_ptr = crc;\n    packetSerial.write(message, size);\n  }\n}\n", "CodeBleu_score": 41.53422058084928}, {"code": "void sendMessage(void *message, size_t size)  if (ros_running && size >= 4) {\n    uint8_t *msg = (uint8_t *) message;\n    uint16_t crc = crc16(msg, size - 2);\n    msg[size - 2] = crc >> 8;\n    msg[size - 1] = crc;\n    packetSerial.write(msg, size);\n  }\n}\n", "CodeBleu_score": 53.42499427293791}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()  Serial.begin(9600);\n  delay(1000);\n  Serial.println(\"Initializing sound module...\");\n  Serial.println(\"Resetting sound module...\");\n  delay(1000);\n  Serial.println(\"Reset complete.\");\n  delay(1000);\n  Serial.println(\"Initializing sound module...\");\n  delay(1000);\n  Serial.println(\"Initialization complete.\");\n  delay(1000);\n  Serial.println(\"Retrieving number of sound files...\");\n  delay(1000);\n  Serial.println(\"Number of sound files: \" + String(getSoundCount()));\n  delay(1000);\n  return getSoundCount() > 0;\n}\n", "CodeBleu_score": 39.7082828473161}, {"code": "bool MP3Sound::begin()  Serial.begin(9600);\n  delay(1000);\n  Serial.println(\"$PWMP3,0\");\n  delay(1000);\n  Serial.println(\"$PWMP3,1\");\n  delay(1000);\n  Serial.println(\"$PWMP3,2\");\n  delay(1000);\n  Serial.println(\"$PWMP3,3\");\n  delay(1000);\n  Serial.println(\"$PWMP3,4\");\n  delay(1000);\n  Serial.println(\"$PWMP3,5\");\n  delay(1000);\n  Serial.println(\"$PWMP3,6\");\n  delay(1000);\n  Serial.println(\"$PWMP3,7\");\n  delay(1000);\n  Serial.println(\"$PWMP3,8\");\n  delay(1000);\n  Serial.println(\"$PWMP3,9\");\n  delay(1000);\n  Serial.println(\"$PWMP3,10\");\n  delay(1000);\n  Serial.println(\"$PWMP3,11\");\n  delay(1000);\n  Serial.println(\"$PWMP3,12\");\n  delay(1000);\n  Serial.println(\"$PWMP3,13\");\n  delay(1000);\n  Serial.println(\"$PWMP3,14\");\n  delay(1000);\n  Serial.println(\"$PWMP3,15\");\n  delay(1000);\n  Serial.println(\"$PWMP3,16\");\n  delay(1000);\n  Serial.println(\"$PWMP3,17\");\n  delay(1000);\n  Serial.println(\"$PWMP3,18\");\n  delay(1000);\n  Serial.println(\"$PWMP3,19\");\n  delay(1000);\n  Serial.println(\"$PWMP3,20\");\n  delay(1000", "CodeBleu_score": 34.08284028028733}, {"code": "bool MP3Sound::begin()    Serial.begin(115200);\n    Serial.println(\"MP3Sound begin\");\n    delay(100);\n    clearBuffer();\n    if (sendCommand(F(\"AT+IPL\"))) {\n        if (sendCommand(F(\"AT+IPL=1\"))) {\n            if (sendCommand(F(\"AT+IPL=2\"))) {\n                if (sendCommand(F(\"AT+IPL=3\"))) {\n                    if (sendCommand(F(\"AT+IPL=4\"))) {\n                        if (sendCommand(F(\"AT+IPL=5\"))) {\n                            if (sendCommand(F(\"AT+IPL=6\"))) {\n                                if (sendCommand(F(\"AT+IPL=7\"))) {\n                                    if (sendCommand(F(\"AT+IPL=8\"))) {\n                                        if (sendCommand(F(\"AT+IPL=9\"))) {\n                                            if (sendCommand(F(\"AT+IPL=10\"))) {\n                                                if (sendCommand(F(\"AT+IPL=11\"))) {\n                                                    if (sendCommand(F(\"AT+IPL=12\"))) {\n                                                        if (sendCommand(F(\"AT+IPL=13\"))) {\n                                                            if (sendCommand(F(\"AT+IPL=14\"))) {\n                                                                if (sendCommand(F(\"AT+IPL=15\"))) {\n                                                                    if (sendCommand(F(\"AT+IPL=16\"))) {\n                                                                        if (sendCommand(F(\"AT+IPL=17\"))) {\n                                                                            if (sendCommand(F(\"AT+IPL=18\"))) {\n                                                                                if (sendCommand(F(\"AT+IPL=19\"))) {\n                                                                                    if (sendCommand(F(\"AT+IPL=20\"))) {\n                                                                                        if (sendCommand(F(\"AT+IPL=21\"))) {\n                                                                                            if (sendCommand(F(\"AT+IPL=22\"))) {\n                                                                                                if (sendCommand(F(\"AT+IPL=23\"))) {\n                                                                                                    if (sendCommand(F(\"AT+IPL=24\"))) {", "CodeBleu_score": 25.87599489153325}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()    int numSounds = getNumActiveSounds();\n    if (numSounds == 0 || isPlaying()) {\n        return numSounds;\n    }\n    Sound *sound = getLastActiveSound();\n    playSound(sound);\n    removeLastActiveSound();\n    return getNumActiveSounds();\n}", "CodeBleu_score": 31.89729604393713}, {"code": "int MP3Sound::processSounds()    if (this->activeSounds.size() == 0 || this->playingMP3) {\n        return this->activeSounds.size();\n    }\n    this->playingMP3 = true;\n    this->playingMP3 = this->playMP3(this->activeSounds.back());\n    this->activeSounds.pop_back();\n    return this->activeSounds.size();\n}\n", "CodeBleu_score": 16.914653049867177}, {"code": "int MP3Sound::processSounds()  if (activeSounds.size() == 0) {\n    return 0;\n  }\n  if (mp3_is_playing()) {\n    return activeSounds.size();\n  }\n  playSound(activeSounds.front());\n  activeSounds.pop_front();\n  return activeSounds.size();\n}\n", "CodeBleu_score": 35.02977217052914}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    if (d->camera_memory_mapped_file)\n      wb_unmap_memory(d->camera_memory_mapped_file);\n    d->camera_memory_mapped_file = wb_map_memory(r->data[0], r->data[1], r->data[2]);\n    if (d->camera_memory_mapped_file) {\n      d->camera_memory_mapped_file_size = r->data[1];\n      d->camera_memory_mapped_file_offset = r->data[2];\n      d->camera_memory_mapped_file_width = r->data[3];\n      d->camera_memory_mapped_file_height = r->data[4];\n      d->camera_memory_mapped_file_depth = r->data[5];\n      d->camera_memory_mapped_file_channels = r->data[6];\n      d->camera_memory_mapped_file_pixel_size = r->data[7];\n      d->camera_memory_mapped_file_format = r->data[8];\n      d->camera_memory_mapped_file_is_compressed = r->data[9];\n      d->camera_memory_mapped_file_compression_type = r->data[10];\n      d->camera_memory_mapped_file_compression_quality = r->data[11];\n      d->camera_memory_mapped_file_compression_width = r->data[12];\n      d->camera_memory_mapped_file_compression_height = r->data[13];\n      d->camera_memory_mapped_file_compression_depth = r->data[14];\n      d->camera_memory_mapped_file_compression_channels = r->data[", "CodeBleu_score": 35.50862974798268}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    wb_abstract_camera_cleanup_memory_mapped_file(d);\n    wb_abstract_camera_setup_memory_mapped_file(d, r);\n    return true;\n  } else {\n    d->command_handled = false;\n    return false;\n  }\n}\n", "CodeBleu_score": 37.4638880575914}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    wb_abstract_camera_cleanup_mmap(d);\n    wb_abstract_camera_setup_mmap(d, r);\n    return true;\n  }\n  d->command_handled = false;\n  return false;\n}\n", "CodeBleu_score": 30.26870038235991}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)  wb_mutex_lock(d->mutex);\n  int height = -1;\n  if (d->camera_data)\n    height = d->camera_data->height;\n  wb_mutex_unlock(d->mutex);\n  return height;\n}", "CodeBleu_score": 43.37304728996473}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  return wb_abstract_camera_get_height_or_null(d) ? wb_abstract_camera_get_height_or_null(d)->height : -1;\n}\n", "CodeBleu_score": 32.09696825732111}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)  WbAbstractCamera *c = wb_abstract_camera_get_camera(d);\n  if (!c)\n    return -1;\n  return c->height;\n}", "CodeBleu_score": 12.459211141724502}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  wb_mutex_lock(g_mutex);\n  WbAccelerometer *accelerometer = (WbAccelerometer *)wb_robot_get_device(tag);\n  if (accelerometer) {\n    int sampling_period = accelerometer->sampling_period;\n    wb_mutex_unlock(g_mutex);\n    return sampling_period;\n  } else {\n    wb_mutex_unlock(g_mutex);\n    fprintf(stderr, \"Error in wb_accelerometer_get_sampling_period: invalid device tag \\\"%d\\\"\\n\", tag);\n    exit(EXIT_FAILURE);\n  }\n}\n", "CodeBleu_score": 37.05043082174583}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  wb_lock();\n  WbAccelerometer *accelerometer = wb_robot_get_device(tag);\n  if (accelerometer == NULL) {\n    wb_unlock();\n    wb_error(\"invalid device tag (%d)\", tag);\n    return -1;\n  }\n  int sampling_period = accelerometer->sampling_period;\n  wb_unlock();\n  return sampling_period;\n}\n", "CodeBleu_score": 54.05614244402892}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)  wb_lock(tag);\n  WbAccelerometer *accelerometer = (WbAccelerometer *)tag;\n  if (accelerometer->mutex)\n    pthread_mutex_lock(accelerometer->mutex);\n  int sampling_period = accelerometer->sampling_period;\n  if (accelerometer->mutex)\n    pthread_mutex_unlock(accelerometer->mutex);\n  wb_unlock(tag);\n  return sampling_period;\n}", "CodeBleu_score": 45.601365549579626}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result = dms;\n    free(dms);\n    return result;\n}", "CodeBleu_score": 43.04459493877022}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char *dmsString = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string result = dmsString;\n    free(dmsString);\n    return result;\n}\n", "CodeBleu_score": 45.66778716018508}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)    char *dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n    string dmsString = dms;\n    free(dms);\n    return dmsString;\n}\n", "CodeBleu_score": 44.48218558457228}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\n\tdReal xc, yc, zc;\n\tdReal xr, yr, zr;\n\tdReal xs, ys, zs;\n\tdReal xd, yd, zd;\n\tdReal xm, ym, zm;\n\tdReal xp, yp, zp;\n\n\tdReal dx, dy, dz;\n\tdReal d, dmin;\n\tdReal nx, ny, nz;\n\n\tdGeomBoxGetLengths (g, &xs, &ys, &zs);\n\tdGeomGetOffsetPosition (g, &xc, &yc, &zc);\n\n\txr = x - xc;\n\tyr = y - yc;\n\tzr = z - zc;\n\n\td = fabs (xr);\n\tnx = xr;\n\tdmin = d;\n\n\td = fabs (yr);\n\tif (d < dmin) {\n\t\tdmin = d;\n\t\tny = yr;\n\t}\n\n\td = fabs (zr);\n\tif (d < dmin) {\n\t\tdmin = d;\n\t\tnz = zr;\n\t}\n\n\tdx = fabs (xr);\n\tdy = fabs (yr);\n\tdz = fabs (zr);\n\n\tif (dx > dmin) {\n\t\tdx = xs;\n\t\tnx = -xr;\n\t}\n\n\tif (dy > dmin) {\n\t\tdy = ys;\n\t\tny = -yr;\n\t}\n\n\tif (dz > dmin) {\n\t\tdz = zs;\n\t\tnz = -zr;\n\t}\n\n\td = dx * dx + dy * dy + dz * dz;\n\n\tdmin = d;\n\txm = xr;\n\tym = yr;\n\tzm = zr;\n\n\txp = xr + xs;\n\typ = yr + ys;\n\tzp = zr + zs;\n\n\td = xp * xp + yp * yp + zp * zp;\n\n\tif", "CodeBleu_score": 23.504865871939064}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\n\t/* get the box dimensions */\n\tdReal lx, ly, lz;\n\tdGeomBoxGetLengths (g, &lx, &ly, &lz);\n\n\t/* get the box center */\n\tdReal cx, cy, cz;\n\tdGeomGetOffsetPosition (g, &cx, &cy, &cz);\n\n\t/* calculate the relative position of the point to the box center */\n\tdReal dx = x - cx;\n\tdReal dy = y - cy;\n\tdReal dz = z - cz;\n\n\t/* check each axis for proximity to the box's surface */\n\tif (fabs (dx) > lx) {\n\t\t/* point is closest to the x-axis surface */\n\t\tplane[0] = (dx > 0) ? 1 : -1;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t\tplane[3] = (dx > 0) ? cx + lx : cx - lx;\n\t} else if (fabs (dy) > ly) {\n\t\t/* point is closest to the y-axis surface */\n\t\tplane[0] = 0;\n\t\tplane[1] = (dy > 0) ? 1 : -1;\n\t\tplane[2] = 0;\n\t\tplane[3] = (dy > 0) ? cy + ly : cy - ly;\n\t} else if (fabs (dz) > lz) {\n\t\t/* point is closest to the z-axis surface */\n\t\tplane[0] = 0;\n\t\tplane[1] = 0;\n\t\tplane[2] = (dz > 0) ? 1 : -1;\n\t\tplane[3] = (dz > 0) ? cz + lz : cz - lz;\n\t} else {\n\t\t/* point is closest to the box center */\n\t\tplane[0] = 0;\n\t\tplane[1] = 0;\n\t\tplane[2] = 0;\n\t\tplane[3] = 0;\n\t}\n}", "CodeBleu_score": 32.22426211632891}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)    dReal xc, yc, zc, dx, dy, dz;\n    dReal xs, ys, zs;\n    dReal xd, yd, zd;\n    dReal xp, yp, zp;\n    dReal xm, ym, zm;\n    dReal xe, ye, ze;\n    dReal xn, yn, zn;\n    dReal xs1, ys1, zs1;\n    dReal xs2, ys2, zs2;\n    dReal xs3, ys3, zs3;\n    dReal xs4, ys4, zs4;\n    dReal xs5, ys5, zs5;\n    dReal xs6, ys6, zs6;\n    dReal xs7, ys7, zs7;\n    dReal xs8, ys8, zs8;\n    dReal xs9, ys9, zs9;\n    dReal xs10, ys10, zs10;\n    dReal xs11, ys11, zs11;\n    dReal xs12, ys12, zs12;\n    dReal xs13, ys13, zs13;\n    dReal xs14, ys14, zs14;\n    dReal xs15, ys15, zs15;\n    dReal xs16, ys16, zs16;\n    dReal xs17, ys17, zs17;\n    dReal xs18, ys18, zs18;\n    dReal xs19, ys19, zs19;\n    dReal xs20, ys20, zs20;\n    dReal xs21, ys21, zs21;\n    dReal xs22, ys22, zs22;\n    dReal xs23, ys23, zs23;\n    dReal xs2", "CodeBleu_score": 7.754609710947813}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  dImmersionData *immData;\n  int result;\n\n  assert (box->body);\n  assert (flags & (dImmersionFlags_All | dImmersionFlags_None));\n\n  immData = (dImmersionData *) dAlloc (sizeof (dImmersionData));\n  immData->box = box;\n  immData->flags = flags;\n  immData->immersion = immersion;\n  immData->plane = fluidPlane;\n\n  result = dImmersionBox (immData);\n  dFree (immData);\n\n  return result;\n}", "CodeBleu_score": 43.03879308381078}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  dImmersionGeom immersionData;\n  int result;\n  assert (box->body != NULL);\n  assert (flags == DIMMERSE_ALL || flags == DIMMERSE_NONE ||\n      flags == DIMMERSE_MINIMUM || flags == DIMMERSE_MAXIMUM);\n  immersionData.box = box;\n  immersionData.fluidPlane = fluidPlane;\n  immersionData.flags = flags;\n  immersionData.immersion = immersion;\n  result = dImmerseBoxInternal (&immersionData);\n  *immersion = immersionData.immersion;\n  return result;\n}\n", "CodeBleu_score": 41.45453702775224}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)  dImmersionGeom immersionData;\n\n  assert (box && box->body);\n  assert (flags & (dImmersionFlags_CheckAll | dImmersionFlags_CheckFront |\n                   dImmersionFlags_CheckBack | dImmersionFlags_CheckSide |\n                   dImmersionFlags_CheckTop | dImmersionFlags_CheckBottom));\n\n  immersionData.box = box;\n  immersionData.fluidPlane = fluidPlane;\n  immersionData.immersion = immersion;\n  immersionData.flags = flags;\n\n  return dImmerseBoxInternal (&immersionData);\n}", "CodeBleu_score": 41.16973089769749}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dReal *pos1, *pos2, *pos3, *pos4, *pos5, *pos6, *pos7, *pos8, *pos9;\n  dReal *axis1, *axis2, *axis3, *axis4, *axis5, *axis6, *axis7, *axis8, *axis9;\n  dReal *radius1, *radius2, *radius3, *radius4, *radius5, *radius6, *radius7, *radius8, *radius9;\n  dReal *length1, *length2, *length3, *length4, *length5, *length6, *length7, *length8, *length9;\n  dReal *pos, *axis, *radius, *length;\n  dReal *box_pos, *box_axis, *box_length, *box_radius;\n  dReal *capsule_pos, *capsule_axis, *capsule_radius, *capsule_length;\n  dReal *immersion_pos, *immersion_axis;\n  dReal *immersion_pos2, *immersion_axis2;\n  dReal *immersion_pos3, *immersion_axis3;\n  dReal *immersion_pos4, *immersion_axis4;\n  dReal *immersion_pos5, *immersion_axis5;\n  dReal *immersion_pos6, *immersion_axis6;\n  dReal *immersion_pos7, *immersion_axis7;\n  dReal *immersion_pos8, *immersion_axis8;\n  dReal *immersion_pos9, *immersion_axis9;\n  dReal *immersion_pos10, *immersion_axis10;\n  dReal *immersion_pos11, *immersion_axis11;\n  dReal *immersion_pos12, *immersion_axis12;\n  dReal *immersion_pos13, *immersion_axis13;\n  dReal *immersion_pos14, *immersion_axis14;\n  dReal *immersion_pos15, *immersion_axis15;\n", "CodeBleu_score": 6.598596661262454}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  dImmersionGeom *imm = immersion;\n  dGeomID geom1 = o1;\n  dGeomID geom2 = o2;\n  dReal *pos1, *pos2, *dir1, *dir2;\n  dReal *pos, *dir;\n  dReal *p1, *p2;\n  dReal *p3, *p4;\n  dReal *p5, *p6;\n  dReal *p7, *p8;\n  dReal *p9, *p10;\n  dReal *p11, *p12;\n  dReal *p13, *p14;\n  dReal *p15, *p16;\n  dReal *p17, *p18;\n  dReal *p19, *p20;\n  dReal *p21, *p22;\n  dReal *p23, *p24;\n  dReal *p25, *p26;\n  dReal *p27, *p28;\n  dReal *p29, *p30;\n  dReal *p31, *p32;\n  dReal *p33, *p34;\n  dReal *p35, *p36;\n  dReal *p37, *p38;\n  dReal *p39, *p40;\n  dReal *p41, *p42;\n  dReal *p43, *p44;\n  dReal *p45, *p46;\n  dReal *p47, *p48;\n  dReal *p49, *p50;\n  dReal *p51, *p52;\n  dReal *p53, *p54;\n  dReal *p55, *p56;\n  dReal *p57, *p58;\n  dReal *p59, *p60;\n  dReal *p61, *p62;\n  dReal *p63, *p64;\n  dReal", "CodeBleu_score": 12.516371111071194}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    dReal *p1, *p2, *p3, *p4, *p5, *p6;\n    dReal *q1, *q2, *q3, *q4, *q5, *q6;\n    dReal *a, *b, *c, *d, *e, *f;\n    dReal *n, *p, *q, *r, *s, *t;\n    dReal *v1, *v2, *v3, *v4, *v5, *v6;\n    dReal *w1, *w2, *w3, *w4, *w5, *w6;\n    dReal *u1, *u2, *u3, *u4, *u5, *u6;\n    dReal *p0, *q0, *r0, *s0, *t0, *u0;\n    dReal *p10, *q10, *r10, *s10, *t10, *u10;\n    dReal *p20, *q20, *r20, *s20, *t20, *u20;\n    dReal *p30, *q30, *r30, *s30, *t30, *u30;\n    dReal *p40, *q40, *r40, *s40, *t40, *u40;\n    dReal *p50, *q50, *r50, *s50, *t50, *u50;\n    dReal *p60, *q60, *r60, *s60, *t60, *u60;\n    dReal *p70, *q70, *r70, *s70, *t70, *u70;\n    dReal *p80, *q80, *r80, *s80, *t80, *u80;\n    dReal *p90, *q90, *r90, *s90, *t90,", "CodeBleu_score": 5.874783381173483}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const  const dReal zIOverR2 = zIOverR * zIOverR;\n  const dReal tanTheta02 = tanTheta0 * tanTheta0;\n  const dReal tanTheta03 = tanTheta02 * tanTheta0;\n  const dReal tanTheta04 = tanTheta02 * tanTheta02;\n  const dReal sinTheta12 = sinTheta1 * sinTheta1;\n  const dReal sinTheta13 = sinTheta12 * sinTheta1;\n  const dReal sinTheta14 = sinTheta12 * sinTheta12;\n  const dReal tanTheta05 = tanTheta03 * tanTheta02;\n  const dReal sinTheta15 = sinTheta13 * sinTheta12;\n  const dReal tanTheta06 = tanTheta04 * tanTheta02;\n  const dReal sinTheta16 = sinTheta14 * sinTheta12;\n  const dReal tanTheta07 = tanTheta05 * tanTheta02;\n  const dReal sinTheta17 = sinTheta15 * sinTheta12;\n  const dReal tanTheta08 = tanTheta06 * tanTheta02;\n  const dReal sinTheta18 = sinTheta16 * sinTheta12;\n  const dReal tanTheta09 = tanTheta07 * tanTheta02;\n  const dReal sinTheta19 = sinTheta17 * sinTheta12;\n  const dReal tanTheta10 = tanTheta08 * tanTheta02;\n  const dReal sinTheta110 = sinTheta18 * sinTheta12;\n  const dReal tanTheta11 = tanTheta09 * tanTheta02;\n  const dReal sinTheta111 = sinTheta19 * sinTheta12;\n  const dReal tanTheta12 = tanTheta10 * tanTheta02;\n  const dReal sinTheta112 = sinTheta110 * sinTheta12;\n  const dReal tanTheta13 = tanTheta11 * tanTheta02;\n  const dReal sinTheta113 = sinTheta111 * sinTheta12;\n  const dReal tanTheta14 = tanTheta", "CodeBleu_score": 35.00360701121666}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const    dReal zIOverRSquared = zIOverR * zIOverR;\n    dReal tanTheta0Squared = tanTheta0 * tanTheta0;\n\n    // Calculate the volume of the immersed hemisphere using Simpson's rule\n    dReal volume = 0.0;\n    dReal deltaZIOverR = (zIOverR - zIOverRSquared) / 3.0;\n    dReal deltaTheta = (tanTheta0 - tanTheta0Squared) / 3.0;\n    dReal zIOverRPlusDeltaZIOverR = zIOverR + deltaZIOverR;\n    dReal tanTheta0PlusDeltaTheta = tanTheta0 + deltaTheta;\n    dReal zIOverRPlusDeltaZIOverRPlusDeltaZIOverR = zIOverRPlusDeltaZIOverR + deltaZIOverR;\n    dReal tanTheta0PlusDeltaThetaPlusDeltaTheta = tanTheta0PlusDeltaTheta + deltaTheta;\n    volume += (1.0 / 3.0) * (zIOverRSquared * deltaZIOverR * deltaTheta * (1.0 + tanTheta0Squared)) +\n              (1.0 / 3.0) * (zIOverRPlusDeltaZIOverR * deltaZIOverR * deltaTheta * (1.0 + tanTheta0Squared)) +\n              (1.0 / 3.0) * (zIOverRPlusDeltaZIOverRPlusDeltaZIOverR * deltaZIOverR * deltaTheta * (1.0 + tanTheta0Squared)) +\n              (1.0 / 3.0) * (zIOverRPlusDeltaZIOverRPlusDeltaZIOverRPlusDeltaZIOverR * deltaZIOverR * deltaTheta * (1.0 + tanTheta0Squared)) +\n              (1.0 / 3.0) * (zIOverRPlusDeltaZIOverRPlusDeltaZIOverRPlusDeltaZIOverR * deltaZIOverR * deltaTheta * (1.0 + tanTheta0Squared)) +\n              (1.0 / 3.0) * (z", "CodeBleu_score": 38.17065933425285}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const    // Calculate the number of intervals for the integration\n    const int nIntervals = 100;\n\n    // Calculate the step size for the integration\n    const dReal stepSize = (tanTheta0 - tanTheta0) / nIntervals;\n\n    // Initialize the result to zero\n    dReal result = 0.0;\n\n    // Calculate the first half of the integration\n    dReal x = tanTheta0;\n    for (int i = 0; i < nIntervals / 2; ++i) {\n        // Calculate the value of the integrand at the current point\n        dReal integrand = immersedHemisphereIntegrand(zIOverR, x, sinTheta1);\n\n        // Add the value to the result\n        result += integrand;\n\n        // Move to the next point\n        x += stepSize;\n    }\n\n    // Calculate the second half of the integration\n    x = tanTheta0 + stepSize / 2;\n    for (int i = nIntervals / 2; i < nIntervals; ++i) {\n        // Calculate the value of the integrand at the current point\n        dReal integrand = immersedHemisphereIntegrand(zIOverR, x, sinTheta1);\n\n        // Add the value to the result\n        result += integrand;\n\n        // Move to the next point\n        x += stepSize;\n    }\n\n    // Multiply the result by the step size and return it\n    return result * stepSize;\n}\n", "CodeBleu_score": 42.05716974492273}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const    dReal xBuoyancyCenter = 0.0;\n\n    // Integrate the function using Simpson's rule\n    for (int i = 0; i < nSteps; i++) {\n        dReal theta = (i + 0.5) * dTheta;\n        dReal z = zIOverR * cos(theta);\n        dReal r = zIOverR * sin(theta);\n        dReal x = r * (1.0 - tanTheta0 * z);\n        dReal y = r * sin(theta);\n        dReal rSquared = x * x + y * y;\n        dReal rCubed = rSquared * r;\n        dReal rFifth = rCubed * rSquared;\n        dReal rSeventh = rFifth * rCubed;\n        dReal rNinth = rSeventh * rCubed;\n        dReal rEleventh = rNinth * rCubed;\n        dReal rThirteenth = rEleventh * rCubed;\n        dReal rFifteenth = rThirteenth * rCubed;\n        dReal rSeventeenth = rFifteenth * rCubed;\n        dReal rNineteenth = rSeventeenth * rCubed;\n        dReal rTwentyThird = rNineteenth * rCubed;\n        dReal rTwentyFifth = rTwentyThird * rCubed;\n        dReal rTwentySeventh = rTwentyFifth * rCubed;\n        dReal rTwentyNinth = rTwentySeventh * rCubed;\n        dReal rThirtyThird = rTwentyNinth * rCubed;\n        dReal rThirtyFifth = rThirtyThird * rCubed;\n        dReal rThirtySeventh = rThirtyFifth * rCubed;\n        dReal rThirtyNinth = rThirtySeventh * rCubed;\n        dReal rFortyThird = rThirtyNinth * rCubed;\n        dReal rFortyFifth = rFort", "CodeBleu_score": 35.92994613280867}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\n    // Set the number of intervals for the integration\n    const int intervals = 100;\n\n    // Set the step size for the integration\n    const dReal stepSize = M_PI / intervals;\n\n    // Set the initial sum of the integrand values\n    dReal sum = 0;\n\n    // Loop over the intervals\n    for (int i = 0; i < intervals; i++) {\n\n        // Calculate the current angle\n        dReal theta = i * stepSize;\n\n        // Calculate the tangent of the current angle\n        dReal tanTheta = tanTheta0 * (sinTheta1 / sin(theta));\n\n        // Calculate the integrand value\n        dReal integrand = (1 - zIOverR * tanTheta) * tanTheta * (1 - zIOverR * tanTheta);\n\n        // Add the integrand value to the sum\n        sum += integrand;\n    }\n\n    // Multiply the sum by the step size and the radius\n    dReal xBuoyancyCenter = sum * stepSize * radius;\n\n    // Adjust the x-coordinate by the volume\n    xBuoyancyCenter *= volume;\n\n    // Return the scaled x-coordinate of the buoyancy center\n    return xBuoyancyCenter;\n}\n", "CodeBleu_score": 41.693439382434036}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal xBuoyancyCenter = 0;\n\tdReal zOverR = sqrt(1 - zIOverR * zIOverR);\n\tdReal z = zOverR * radius;\n\tdReal zSquared = z * z;\n\tdReal sinTheta0 = sqrt(1 - zIOverR * zIOverR);\n\tdReal cosTheta0 = sqrt(1 - sinTheta0 * sinTheta0);\n\tdReal tanTheta1 = tanTheta0 * sinTheta1 / cosTheta0;\n\tdReal sinTheta1 = sqrt(1 - tanTheta1 * tanTheta1);\n\tdReal cosTheta1 = sqrt(1 - sinTheta1 * sinTheta1);\n\tdReal tanTheta = tanTheta1 * tanTheta0;\n\tdReal sinTheta = sqrt(1 - tanTheta * tanTheta);\n\tdReal cosTheta = sqrt(1 - sinTheta * sinTheta);\n\tdReal dTheta = atan2(sinTheta, cosTheta);\n\tdReal dThetaSquared = dTheta * dTheta;\n\tdReal dThetaCubed = dThetaSquared * dTheta;\n\tdReal dThetaToTheFifth = dThetaSquared * dThetaSquared;\n\tdReal dThetaToTheSeventh = dThetaToTheFifth * dThetaSquared;\n\tdReal dThetaToTheNinth = dThetaToTheSeventh * dThetaSquared;\n\tdReal dThetaToTheEleventh = dThetaToTheNinth * dThetaSquared;\n\tdReal dThetaToTheThirteenth = dThetaToTheEleventh * dThetaSquared;\n\tdReal dThetaToTheFifteenth = dThetaToTheThirteenth * dThetaSquared;\n\tdReal dThetaToTheSeventeenth = dThetaToTheFifteenth * dThetaSquared;\n\tdReal dThetaToTheNineteenth = dThetaToTheSeventeenth * dThetaSquared;\n\tdReal dThetaToTheTwentyFirst = dThetaToTheNineteenth * dThetaSquared;\n\tdReal dThetaToTheTwentyThird = d", "CodeBleu_score": 35.876459966308595}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)  // Get the radius of the immersed object\n  float radius = immersion->radius;\n  // Get the volume of the immersed object\n  float volume = immersion->volume;\n  // Get the initial angle of the immersed object\n  float initialAngle = immersion->initialAngle;\n  // Get the final angle of the immersed object\n  float finalAngle = immersion->finalAngle;\n  // Get the tangent of the initial angle\n  float tanInitialAngle = tanf(initialAngle);\n  // Get the sine of the final angle\n  float sinFinalAngle = sinf(finalAngle);\n  // Get the depth ratio of the immersed object\n  float depthRatio = immersion->depthRatio;\n  // Get the initial height of the immersed object\n  float initialHeight = immersion->initialHeight;\n  // Get the final height of the immersed object\n  float finalHeight = immersion->finalHeight;\n  // Get the initial radius of the immersed object\n  float initialRadius = immersion->initialRadius;\n  // Get the final radius of the immersed object\n  float finalRadius = immersion->finalRadius;\n  // Get the initial volume of the immersed object\n  float initialVolume = immersion->initialVolume;\n  // Get the final volume of the immersed object\n  float finalVolume = immersion->finalVolume;\n  // Get the initial mass of the immersed object\n  float initialMass = immersion->initialMass;\n  // Get the final mass of the immersed object\n  float finalMass = immersion->finalMass;\n  // Get the initial buoyancy center of the immersed object\n  float initialBuoyancyCenter = immersion->initialBuoyancyCenter;\n  // Get the final buoyancy center of the immersed object\n  float finalBuoyancyCenter = immersion->finalBuoyancyCenter;\n  // Get the initial buoyancy center of the immersed object\n  float initialBuoyancyCenterX = immersion->initialBuoyancyCenterX;\n  // Get the final buoyancy center of the imm", "CodeBleu_score": 28.54618008057287}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    dImmersedGeom *immersed1 = (dImmersedGeom *)o1->data;\n    dImmersedGeom *immersed2 = (dImmersedGeom *)o2->data;\n    dGeomID g1 = o1->g;\n    dGeomID g2 = o2->g;\n    dReal *p1 = dGeomGetPosition(g1);\n    dReal *p2 = dGeomGetPosition(g2);\n    dReal *R1 = dGeomGetRotation(g1);\n    dReal *R2 = dGeomGetRotation(g2);\n    dReal *v1 = dGeomGetLinearVel(g1);\n    dReal *v2 = dGeomGetLinearVel(g2);\n    dReal *w1 = dGeomGetAngularVel(g1);\n    dReal *w2 = dGeomGetAngularVel(g2);\n    dReal *r1 = immersed1->radius;\n    dReal *r2 = immersed2->radius;\n    dReal *p1_ = immersed1->position;\n    dReal *p2_ = immersed2->position;\n    dReal *R1_ = immersed1->rotation;\n    dReal *R2_ = immersed2->rotation;\n    dReal *v1_ = immersed1->linearVelocity;\n    dReal *v2_ = immersed2->linearVelocity;\n    dReal *w1_ = immersed1->angularVelocity;\n    dReal *w2_ = immersed2->angularVelocity;\n    dReal *m1 = immersed1->mass;\n    dReal *m2 = immersed2->mass;\n    dReal *I1 = immersed1->inertia;\n    dReal *I2 = immersed2->inertia;\n    dReal *I1_ = immersed1->inertiaWorld;\n    dReal *I2_ =", "CodeBleu_score": 30.365715073360004}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)    if (immersion->type == IMMERSE_CAPSULE_TRIMESH) {\n        if (immersion->immersedHemisphereXBuoyancyCenter == NULL) {\n            immersion->immersedHemisphereXBuoyancyCenter = (double*) malloc(sizeof(double));\n        }\n        dReal *o1Data = (dReal*) dGeomGetData(o1);\n        dReal *o2Data = (dReal*) dGeomGetData(o2);\n        sCapsuleImmersionData *immersionData = (sCapsuleImmersionData*) o2Data[0];\n        dReal depthRatio = immersionData->depthRatio;\n        dReal tangentOfInitialAngle = immersionData->tangentOfInitialAngle;\n        dReal sineOfFinalAngle = immersionData->sineOfFinalAngle;\n        dReal volume = immersionData->volume;\n        dReal *immersedHemisphereXBuoyancyCenter = immersion->immersedHemisphereXBuoyancyCenter;\n        *immersedHemisphereXBuoyancyCenter = immersionData->radius * (depthRatio * sineOfFinalAngle / (depthRatio * sineOfFinalAngle + tangentOfInitialAngle) * volume);\n        return 1;\n    }\n    return 0;\n}\n", "CodeBleu_score": 30.233360443829397}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()    // Retrieve the sleep duration in milliseconds from the input\n    double sleep_duration_ms;\n    if (!getInput(\"duration\", sleep_duration_ms)) {\n        // If the duration is missing or non-positive, return SUCCESS\n        return NodeStatus::SUCCESS;\n    }\n\n    // Set the node status to RUNNING\n    setStatus(NodeStatus::RUNNING);\n\n    // Start a timer\n    timer_ = std::make_unique<ros::Timer>(nh_.createTimer(ros::Duration(sleep_duration_ms / 1000.0),\n                                                          &SleepNode::timerCallback, this, true, false));\n\n    // Set a callback to emit a wake-up signal when the timer expires\n    timer_->setCallback(std::bind(&SleepNode::timerExpired, this));\n\n    // Set the timer_waiting_ flag to true\n    timer_waiting_ = true;\n\n    // Return SUCCESS\n    return NodeStatus::SUCCESS;\n}\n", "CodeBleu_score": 39.77500016464946}, {"code": "NodeStatus SleepNode::onStart()  // Get the sleep duration from the input\n  double duration;\n  if (!getInput(\"duration\", duration)) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Check if the duration is non-positive\n  if (duration <= 0) {\n    return NodeStatus::SUCCESS;\n  }\n\n  // Set the node status to RUNNING\n  setStatus(NodeStatus::RUNNING);\n\n  // Start a timer\n  timer_ = std::make_unique<ros::Timer>(\n      nh_.createTimer(ros::Duration(duration / 1000.0),\n                      &SleepNode::timerCallback, this, false, false));\n  timer_waiting_ = true;\n\n  // Set a callback to emit a wake-up signal when the timer expires\n  timer_->start();\n\n  return NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 53.404822429891816}, {"code": "NodeStatus SleepNode::onStart()    // Get the sleep duration from the input\n    double duration;\n    if (!getInput(\"duration\", duration)) {\n        return SUCCESS;\n    }\n\n    // Check if the duration is positive\n    if (duration <= 0.0) {\n        return SUCCESS;\n    }\n\n    // Set the node status to RUNNING\n    setStatus(RUNNING);\n\n    // Start a timer with the specified duration\n    timer_waiting_ = true;\n    timer_.expires_from_now(boost::posix_time::milliseconds(static_cast<int>(duration)));\n    timer_.async_wait(boost::bind(&SleepNode::onTimer, this, boost::asio::placeholders::error));\n\n    return RUNNING;\n}\n", "CodeBleu_score": 45.08549096987566}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()  // Get the entry from the blackboard\n  auto entry = blackboard->get<Entry>(entry_name);\n\n  // Check if the entry exists\n  if (!entry) {\n    return NodeStatus::FAILURE;\n  }\n\n  // Lock the entry's mutex\n  std::lock_guard<std::mutex> lock(entry->mutex);\n\n  // Check if the sequence ID has changed\n  if (entry->sequence_id != sequence_id) {\n    // Update the stored sequence ID\n    sequence_id = entry->sequence_id;\n    return NodeStatus::SUCCESS;\n  }\n\n  // The sequence ID has not changed\n  return NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 41.51842598073602}, {"code": "NodeStatus EntryUpdatedAction::tick()    // Get the entry from the blackboard\n    Entry* entry = blackboard->get<Entry>(\"entry\");\n\n    // Check if the entry is valid\n    if (entry == nullptr) {\n        return NodeStatus::FAILURE;\n    }\n\n    // Lock the entry's mutex\n    std::unique_lock<std::mutex> lock(entry->mutex);\n\n    // Check if the entry's sequence ID has changed\n    if (entry->sequenceID != sequenceID) {\n        // Update the stored sequence ID\n        sequenceID = entry->sequenceID;\n        // Return success\n        return NodeStatus::SUCCESS;\n    }\n\n    // Return failure\n    return NodeStatus::FAILURE;\n}", "CodeBleu_score": 39.41990002143094}, {"code": "NodeStatus EntryUpdatedAction::tick()  // Retrieve the entry from the blackboard\n  auto entry = blackboard->getEntry<Entry>(entry_name);\n  if (!entry) {\n    return NodeStatus::FAILURE;\n  }\n\n  // Lock the entry's mutex\n  std::unique_lock<std::mutex> lock(entry->mutex);\n\n  // Check if the sequence ID has changed\n  if (entry->sequence_id != sequence_id) {\n    // Update the sequence ID\n    sequence_id = entry->sequence_id;\n    return NodeStatus::SUCCESS;\n  }\n\n  // The sequence ID has not changed\n  return NodeStatus::FAILURE;\n}", "CodeBleu_score": 42.16696303230546}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const    if (m_successThreshold < 0) {\n        return std::max(size_t(-m_successThreshold), size_t(1));\n    }\n    return m_successThreshold;\n}\n", "CodeBleu_score": 47.857811663907135}, {"code": "size_t ParallelNode::successThreshold() const    if (success_threshold < 0) {\n        return std::max(size_t(0), size_t(-success_threshold * child_nodes.size()));\n    } else {\n        return success_threshold;\n    }\n}\n", "CodeBleu_score": 59.38913484369819}, {"code": "size_t ParallelNode::successThreshold() const    if (success_threshold < 0) {\n        return std::max<size_t>(0, children.size() + success_threshold);\n    } else {\n        return success_threshold;\n    }\n}\n", "CodeBleu_score": 58.022181683807375}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        if (m_heartbeat_status != m_last_heartbeat_status) {\n            if (m_heartbeat_status == true) {\n                enable_all_breakpoints();\n            } else {\n                disable_all_breakpoints();\n            }\n            m_last_heartbeat_status = m_heartbeat_status;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}", "CodeBleu_score": 31.575064333596153}, {"code": "void Groot2Publisher::heartbeatLoop()  while (true) {\n    if (server_heartbeat_active) {\n      if (last_heartbeat_time + heartbeat_interval < millis()) {\n        server_heartbeat_active = false;\n        disableBreakpoints();\n      }\n    }\n    delay(10);\n  }\n}\n", "CodeBleu_score": 15.491295251915583}, {"code": "void Groot2Publisher::heartbeatLoop()    while (true) {\n        if (heartbeat_status) {\n            if (heartbeat_status != last_heartbeat_status) {\n                if (heartbeat_status) {\n                    enable_all_breakpoints();\n                } else {\n                    disable_all_breakpoints();\n                }\n            }\n            last_heartbeat_status = heartbeat_status;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n", "CodeBleu_score": 32.2155997199941}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    // Split the input string into a vector of blackboard names\n    std::vector<std::string> bb_names = splitString(bb_list, ',');\n\n    // Create a JSON object to hold the blackboard data\n    json j;\n\n    // Iterate through the blackboard names\n    for (const auto& bb_name : bb_names) {\n        // Find the corresponding subtree\n        const auto& subtree = blackboard_manager_->getSubtree(bb_name);\n\n        // If the subtree is valid, export the blackboard to JSON and add it to the JSON object\n        if (subtree) {\n            // Lock the subtree to ensure that no other thread is modifying it\n            subtree->lock();\n\n            // Export the blackboard to JSON\n            json bb_json = subtree->toJSON();\n\n            // Add the blackboard data to the JSON object\n            j[bb_name] = bb_json;\n\n            // Unlock the subtree\n            subtree->unlock();\n        }\n    }\n\n    // Convert the JSON object to MessagePack format\n    std::vector<uint8_t> msgpack_data = json::to_msgpack(j);\n\n    return msgpack_data;\n}\n", "CodeBleu_score": 47.068836622859926}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    std::vector<uint8_t> msgpack_data;\n    Json::Value root;\n\n    std::vector<std::string> bb_names = split(bb_list, ',');\n    for (const auto& bb_name : bb_names) {\n        const auto subtree = blackboard->openSubtree(bb_name);\n        if (subtree) {\n            Json::Value bb_json;\n            if (subtree->toJson(bb_json)) {\n                root[bb_name] = bb_json;\n            }\n        }\n    }\n\n    if (!root.empty()) {\n        Json::StreamWriterBuilder builder;\n        builder[\"indentation\"] = \"\";\n        const auto json_str = Json::writeString(builder, root);\n        msgpack_data = msgpack::unpack(json_str.c_str()).get().as<std::vector<uint8_t>>();\n    }\n\n    return msgpack_data;\n}\n", "CodeBleu_score": 44.73406569814866}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)    // Split the input string into a vector of blackboard names\n    std::vector<std::string> bb_names = splitString(bb_list, ',');\n\n    // Create a JSON object to store the blackboards\n    json json_obj;\n\n    // Iterate through the blackboard names\n    for (const auto& bb_name : bb_names) {\n        // Find the corresponding subtree\n        Subtree* subtree = subtree_manager_->getSubtree(bb_name);\n        if (subtree == nullptr) {\n            std::cerr << \"Error: Subtree with name '\" << bb_name << \"' not found\" << std::endl;\n            continue;\n        }\n\n        // Lock the subtree\n        subtree->lock();\n\n        // Export the blackboard to JSON\n        json bb_json = subtree->exportBlackboard();\n\n        // Add the blackboard to the JSON object\n        json_obj[bb_name] = bb_json;\n\n        // Unlock the subtree\n        subtree->unlock();\n    }\n\n    // Convert the JSON object to MessagePack format\n    std::vector<uint8_t> msgpack_data = json::to_msgpack(json_obj);\n\n    return msgpack_data;\n}\n", "CodeBleu_score": 44.59295435067185}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  std::lock_guard<std::mutex> lock(hooks_mutex_);\n  auto it = hooks_.find(pos);\n  if (it == hooks_.end()) {\n    return false;\n  }\n  Groot2Hook &hook = it->second;\n  if (hook.node_uid != node_uid) {\n    return false;\n  }\n  if (hook.status != BREAKPOINT) {\n    return false;\n  }\n  hook.status = result;\n  hook.remove = remove;\n  hook.ready = true;\n  hook.cv.notify_all();\n  return true;\n}\n", "CodeBleu_score": 48.48925430546193}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  // Search for the node\n  Node* node = nullptr;\n  for (auto& n : nodes) {\n    if (n.getUID() == node_uid) {\n      node = &n;\n      break;\n    }\n  }\n\n  // Check if the node exists and is valid\n  if (node == nullptr || !node->isValid()) {\n    return false;\n  }\n\n  // Retrieve the associated hook\n  Hook* hook = node->getHook();\n\n  // Lock the hook's mutex\n  std::lock_guard<std::mutex> lock(hook->mutex);\n\n  // Check if the hook is in BREAKPOINT mode\n  if (hook->mode != Hook::Mode::BREAKPOINT) {\n    return false;\n  }\n\n  // Set the desired status and removal flag\n  hook->status = result;\n  hook->remove = remove;\n\n  // Mark the hook as ready and notify all waiting threads\n  hook->ready = true;\n  hook->cond.notify_all();\n\n  return true;\n}\n", "CodeBleu_score": 49.01426819443173}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)  std::lock_guard<std::mutex> lock(this->hook_mutex);\n\n  // search for the hook\n  auto hook = this->hooks.find(pos);\n\n  // check if the hook exists\n  if (hook == this->hooks.end()) {\n    return false;\n  }\n\n  // check if the hook is valid\n  if (!hook->second.valid) {\n    return false;\n  }\n\n  // check if the hook is in BREAKPOINT mode\n  if (hook->second.mode != Hook::BREAKPOINT) {\n    return false;\n  }\n\n  // check if the node exists\n  auto node = hook->second.nodes.find(node_uid);\n  if (node == hook->second.nodes.end()) {\n    return false;\n  }\n\n  // check if the node is valid\n  if (!node->second.valid) {\n    return false;\n  }\n\n  // lock the hook's mutex\n  std::lock_guard<std::mutex> hook_lock(hook->second.mutex);\n\n  // set the desired status and removal flag\n  node->second.status = result;\n  node->second.remove = remove;\n\n  // mark the hook as ready\n  hook->second.ready = true;\n\n  // notify all waiting threads\n  hook->second.cond.notify_all();\n\n  return true;\n}\n", "CodeBleu_score": 45.91741241104949}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()  if (status_ == NodeStatus::IDLE) {\n    status_ = NodeStatus::RUNNING;\n    halt_requested_ = false;\n    thread_ = std::thread([this]() {\n      try {\n        tick();\n      } catch (const std::exception & e) {\n        status_ = NodeStatus::FAILURE;\n        exception_ = std::make_shared<std::exception>(e);\n        RCLCPP_ERROR(get_logger(), \"Exception in thread: %s\", e.what());\n      }\n    });\n  }\n\n  if (status_ == NodeStatus::RUNNING && halt_requested_) {\n    status_ = NodeStatus::IDLE;\n  }\n\n  if (exception_) {\n    std::rethrow_exception(exception_);\n  }\n\n  return status_;\n}\n", "CodeBleu_score": 41.25934626995921}, {"code": "NodeStatus BT::ThreadedAction::executeTick()  if (status_ == NodeStatus::IDLE) {\n    status_ = NodeStatus::RUNNING;\n    halt_requested_ = false;\n    thread_ = std::thread([this]() {\n      try {\n        tick();\n      } catch (const std::exception & ex) {\n        RCLCPP_ERROR(\n          get_logger(), \"Exception thrown from tick(): %s\", ex.what());\n      }\n      if (!halt_requested_) {\n        status_ = NodeStatus::SUCCESS;\n      }\n    });\n  }\n\n  if (exception_) {\n    std::exception_ptr ex = std::move(exception_);\n    exception_ = nullptr;\n    std::rethrow_exception(ex);\n  }\n\n  return status_;\n}\n", "CodeBleu_score": 36.38500535216296}, {"code": "NodeStatus BT::ThreadedAction::executeTick()    if (status_ == NodeStatus::IDLE) {\n        status_ = NodeStatus::RUNNING;\n        halt_requested_ = false;\n        std::thread t(&ThreadedAction::threadFunc, this);\n        t.detach();\n    }\n\n    if (halt_requested_) {\n        status_ = NodeStatus::IDLE;\n    }\n\n    if (exception_) {\n        try {\n            std::rethrow_exception(exception_);\n        } catch (const std::exception& ex) {\n            ROS_ERROR(\"[%s] Exception: %s\", name_.c_str(), ex.what());\n            status_ = NodeStatus::IDLE;\n        }\n    }\n\n    if (exception_storage_) {\n        exception_ = exception_storage_;\n        exception_storage_ = nullptr;\n    }\n\n    return status_;\n}\n", "CodeBleu_score": 42.479121580710874}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    stream << \"---------------------\\n\";\n    std::function<void(const TreeNode*, int)> print_node = [&](const TreeNode* node, int depth) {\n        for (int i = 0; i < depth; ++i) {\n            stream << \"  \";\n        }\n        stream << node->name << \"\\n\";\n        if (const auto control_node = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : control_node->children) {\n                print_node(child, depth + 1);\n            }\n        } else if (const auto decorator_node = dynamic_cast<const DecoratorNode*>(node)) {\n            print_node(decorator_node->child, depth + 1);\n        }\n    };\n    print_node(root_node, 0);\n    stream << \"---------------------\\n\";\n}\n", "CodeBleu_score": 46.19779709299202}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    stream << \"=============\" << std::endl;\n    std::function<void(const TreeNode*, int)> printNode = [&](const TreeNode* node, int depth) {\n        for (int i = 0; i < depth; ++i) {\n            stream << \"  \";\n        }\n        stream << node->name() << std::endl;\n        if (const auto* controlNode = dynamic_cast<const ControlNode*>(node)) {\n            for (const auto& child : controlNode->children()) {\n                printNode(child.get(), depth + 1);\n            }\n        } else if (const auto* decoratorNode = dynamic_cast<const DecoratorNode*>(node)) {\n            printNode(decoratorNode->child().get(), depth + 1);\n        }\n    };\n    printNode(root_node, 0);\n    stream << \"=============\" << std::endl;\n}\n", "CodeBleu_score": 53.01728466757947}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)    // Define a lambda function to print the tree recursively\n    std::function<void(const TreeNode*, int)> printTree = [&](const TreeNode* node, int depth) {\n        // Indent the output based on the node's depth\n        for (int i = 0; i < depth; ++i) {\n            stream << \"  \";\n        }\n\n        // Print the node's name\n        stream << node->name << std::endl;\n\n        // Recursively print the children for ControlNode or the child for DecoratorNode\n        if (node->type == TreeNodeType::Control) {\n            for (const auto& child : node->children) {\n                printTree(child.get(), depth + 1);\n            }\n        } else if (node->type == TreeNodeType::Decorator) {\n            printTree(node->child.get(), depth + 1);\n        }\n    };\n\n    // Print the separator line\n    stream << \"--------------------------\" << std::endl;\n\n    // Print the tree recursively\n    printTree(root_node, 0);\n\n    // Print the separator line\n    stream << \"--------------------------\" << std::endl;\n}", "CodeBleu_score": 46.75391239867365}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr) {\n    throw LogicError(\"The node is null.\");\n  }\n  visitor(node);\n  if (const auto* controlNode = dynamic_cast<const ControlNode*>(node)) {\n    for (const auto& child : controlNode->getChildren()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (const auto* decoratorNode = dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decoratorNode->getChild(), visitor);\n  }\n}\n", "CodeBleu_score": 61.84004960993899}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)    if (node == nullptr) {\n        throw LogicError(\"Node is null\");\n    }\n    visitor(node);\n    if (node->getType() == TreeNodeType::CONTROL) {\n        const ControlNode* controlNode = static_cast<const ControlNode*>(node);\n        for (const auto& child : controlNode->getChildren()) {\n            applyRecursiveVisitor(child.get(), visitor);\n        }\n    } else if (node->getType() == TreeNodeType::DECORATOR) {\n        const DecoratorNode* decoratorNode = static_cast<const DecoratorNode*>(node);\n        applyRecursiveVisitor(decoratorNode->getChild(), visitor);\n    }\n}\n", "CodeBleu_score": 59.161228827560606}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)  if (node == nullptr) {\n    throw LogicError(\"applyRecursiveVisitor: node is null\");\n  }\n\n  visitor(node);\n\n  if (const ControlNode* controlNode = dynamic_cast<const ControlNode*>(node)) {\n    for (const TreeNode* child : controlNode->getChildren()) {\n      applyRecursiveVisitor(child, visitor);\n    }\n  } else if (const DecoratorNode* decoratorNode =\n                 dynamic_cast<const DecoratorNode*>(node)) {\n    applyRecursiveVisitor(decoratorNode->getChild(), visitor);\n  }\n}\n", "CodeBleu_score": 61.33158111715351}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    auto it = m_builders.find(manifest.registrationID);\n    if (it != m_builders.end()) {\n        throw BehaviorTreeException(\n            \"BehaviorTreeFactory::registerBuilder(): ID already registered: \" +\n            manifest.registrationID);\n    }\n\n    m_builders.insert(std::make_pair(manifest.registrationID, builder));\n    m_manifests.insert(std::make_pair(manifest.registrationID, manifest));\n}\n", "CodeBleu_score": 51.95988707964002}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)    if (builders.find(manifest.registrationID) != builders.end()) {\n        throw BehaviorTreeException(\"BehaviorTreeFactory::registerBuilder(): \"\n                                    \"registration ID already exists: \" +\n                                    manifest.registrationID);\n    }\n    builders[manifest.registrationID] = builder;\n    manifests[manifest.registrationID] = manifest;\n}\n", "CodeBleu_score": 43.39389741265233}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)  if (m_builders.find(manifest.id) != m_builders.end()) {\n    throw BehaviorTreeException(\n        \"BehaviorTreeFactory::registerBuilder(): ID already registered: \" +\n        manifest.id);\n  }\n\n  m_builders[manifest.id] = builder;\n  m_manifests[manifest.id] = manifest;\n}\n", "CodeBleu_score": 42.907231506026456}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  const auto builder = [tick_functor, ports](const std::string& name,\n                                             const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(\n        name, tick_functor, ports, config.blackboard);\n  };\n\n  const auto manifest = TreeNodeManifest{\n      .type = TreeNodeType::ACTION,\n      .description = \"SimpleActionNode\",\n      .ports = ports,\n      .id = ID,\n  };\n\n  registerBuilder(manifest, builder);\n}\n", "CodeBleu_score": 60.843627193560636}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  NodeBuilder builder = [tick_functor, ports](const std::string& name,\n                                              const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(name, tick_functor, ports);\n  };\n\n  TreeNodeManifest manifest;\n  manifest.node_type = NodeType::ACTION;\n  manifest.node_id = ID;\n  manifest.ports = ports;\n\n  registerBuilder(manifest, builder);\n}\n", "CodeBleu_score": 67.4242565069217}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)  NodeBuilder builder = [tick_functor, ports](const std::string& name,\n                                              const NodeConfiguration& config) {\n    return std::make_unique<SimpleActionNode>(\n        name, tick_functor, ports, config.blackboard);\n  };\n\n  TreeNodeManifest manifest = {ID, builder};\n  registerBuilder(manifest);\n}\n", "CodeBleu_score": 66.3533172617404}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.GetSubtrees().size());\n\n    for (const auto& subtree : tree.GetSubtrees()) {\n        auto blackboard = std::make_shared<Blackboard>();\n        blackboard->Clone(subtree->GetBlackboard());\n        blackboard_backups.push_back(blackboard);\n    }\n\n    return blackboard_backups;\n}\n", "CodeBleu_score": 49.5736118473151}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> blackboard_backups;\n    blackboard_backups.reserve(tree.subtrees.size());\n\n    for (const auto& subtree : tree.subtrees) {\n        Blackboard::Ptr backup = std::make_shared<Blackboard>();\n        subtree->blackboard->Clone(backup);\n        blackboard_backups.push_back(backup);\n    }\n\n    return blackboard_backups;\n}\n", "CodeBleu_score": 54.440739037543906}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)    std::vector<Blackboard::Ptr> blackboards;\n    blackboards.reserve(tree.subtrees.size());\n    for (const auto& subtree : tree.subtrees) {\n        auto backup = std::make_shared<Blackboard>();\n        backup->Clone(subtree->blackboard);\n        blackboards.push_back(backup);\n    }\n    return blackboards;\n}\n", "CodeBleu_score": 55.704145689672856}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n    return executor.value().Execute(env);\n}\n", "CodeBleu_score": 72.31213763699671}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)  auto executor = ParseScript(script);\n  if (!executor) {\n    return nonstd::make_unexpected(executor.error());\n  }\n  return executor.value()->Execute(env);\n}\n", "CodeBleu_score": 70.68161261008473}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)    auto executor = ParseScript(script);\n    if (!executor) {\n        return nonstd::make_unexpected(executor.error());\n    }\n\n    return executor.value()(env);\n}\n", "CodeBleu_score": 74.82725087139599}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)  std::lock_guard<std::mutex> lock(mutex);\n  if (handle) {\n    throw RuntimeError(\"Library already loaded\");\n  }\n  handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle) {\n    throw RuntimeError(dlerror());\n  }\n  this->path = path;\n}\n", "CodeBleu_score": 50.94831721827953}, {"code": "void SharedLibrary::load(const std::string& path, int)    std::lock_guard<std::mutex> lock(mutex);\n    if (isLoaded()) {\n        throw RuntimeError(\"Library is already loaded\");\n    }\n    dlerror();\n    handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!handle) {\n        throw RuntimeError(dlerror());\n    }\n    this->path = path;\n}\n", "CodeBleu_score": 53.374904474564445}, {"code": "void SharedLibrary::load(const std::string& path, int)  std::unique_lock<std::mutex> lock(mutex_);\n\n  if (is_loaded_) {\n    throw RuntimeError(\"Library is already loaded\");\n  }\n\n  void* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n  if (!handle) {\n    throw RuntimeError(dlerror());\n  }\n\n  path_ = path;\n  is_loaded_ = true;\n}\n", "CodeBleu_score": 51.75860791767442}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)  if (str.size() < 3) {\n    return false;\n  }\n\n  str.strip();\n\n  if (stripped_pointer != nullptr) {\n    *stripped_pointer = str.substr(1, str.size() - 2);\n  }\n\n  return str[0] == '{' && str[str.size() - 1] == '}';\n}\n", "CodeBleu_score": 22.812180667079396}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    // Ensure the string is at least 3 characters long\n    if (str.length() < 3) {\n        return false;\n    }\n\n    // Strip leading and trailing spaces\n    str = str.trim();\n\n    // Check if the stripped string starts with '{' and ends with '}'\n    if (str.startsWith(\"{\") && str.endsWith(\"}\")) {\n        if (stripped_pointer != nullptr) {\n            *stripped_pointer = str.substr(1, str.length() - 2);\n        }\n        return true;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 23.942204133271844}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)    if (str.length() < 3) {\n        return false;\n    }\n    str.strip();\n    if (str.startsWith('{') && str.endsWith('}')) {\n        if (stripped_pointer) {\n            *stripped_pointer = str.substring(1, str.length() - 1);\n        }\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 22.622763988003026}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  double line_cost = 0.0;\n  LineIterator line(x0, y0, x1, y1);\n  for (int i = 0; i < line.num_pts; ++i) {\n    double point_cost = pointCost(line.x[i], line.y[i]);\n    if (point_cost < 0) {\n      return point_cost;\n    }\n    line_cost = std::max(line_cost, point_cost);\n  }\n  return line_cost;\n}\n", "CodeBleu_score": 56.320484132602964}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const  double line_cost = 0.0;\n  double point_cost = 0.0;\n\n  // Iterate through each point on the line\n  for (LineIterator line(x0, y0, x1, y1); line.isValid(); line.advance()) {\n    // Get the point cost\n    point_cost = pointCost(line.getX(), line.getY());\n\n    // If the point cost is negative, return it immediately\n    if (point_cost < 0.0) {\n      return point_cost;\n    }\n\n    // Update the line cost if the point cost is higher\n    if (point_cost > line_cost) {\n      line_cost = point_cost;\n    }\n  }\n\n  return line_cost;\n}\n", "CodeBleu_score": 75.76648413596133}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const    double line_cost = 0.0;\n    double point_cost;\n\n    // Initialize the line iterator\n    LineIterator line(x0, y0, x1, y1);\n\n    // Iterate through each point on the line\n    for (int i = 0; i < line.num_pts; ++i) {\n        // Get the point cost\n        point_cost = pointCost(line.x, line.y);\n\n        // If the point cost is negative, return it immediately\n        if (point_cost < 0.0) {\n            return point_cost;\n        }\n\n        // Update the line cost if the point cost is higher\n        line_cost = std::max(line_cost, point_cost);\n\n        // Move to the next point on the line\n        line.advance();\n    }\n\n    // Return the total line cost\n    return line_cost;\n}\n", "CodeBleu_score": 66.22147752243023}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)     if (path.empty()) {\n        return;\n    }\n\n    nav_msgs::Path path_msg;\n    path_msg.header.frame_id = path[0].header.frame_id;\n    path_msg.header.stamp = path[0].header.stamp;\n\n    for (const auto& pose : path) {\n        path_msg.poses.push_back(pose);\n    }\n\n    pub.publish(path_msg);\n}\n", "CodeBleu_score": 51.672703642905795}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   if (path.empty())\n    return;\n\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = path[0].header.frame_id;\n  gui_path.header.stamp = path[0].header.stamp;\n\n  // Extract the poses from the path\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  pub.publish(gui_path);\n}", "CodeBleu_score": 88.47812017850748}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub)   // Check if the path is empty\n  if (path.empty()) {\n    return;\n  }\n\n  // Create a nav_msgs::Path message and initialize its header with the frame_id and timestamp from the first pose in the path\n  nav_msgs::Path path_msg;\n  path_msg.header.frame_id = path[0].header.frame_id;\n  path_msg.header.stamp = path[0].header.stamp;\n\n  // Copy each pose from the input path to the path message\n  for (const auto& pose : path) {\n    path_msg.poses.push_back(pose);\n  }\n\n  // Publish the path message\n  pub.publish(path_msg);\n}", "CodeBleu_score": 51.87304985840802}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)    if (std::abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n        std::abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity) {\n        return true;\n    }\n    return false;\n}\n", "CodeBleu_score": 55.58993947460753}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\n    // Get the linear and angular velocities from the odometry message\n    double linear_velocity = sqrt(pow(base_odom.twist.twist.linear.x, 2) + pow(base_odom.twist.twist.linear.y, 2));\n    double angular_velocity = base_odom.twist.twist.angular.z;\n\n    // Check if the linear and angular velocities are below or equal to the thresholds\n    if (linear_velocity <= trans_stopped_velocity && angular_velocity <= rot_stopped_velocity) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "CodeBleu_score": 51.17449001291533}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)  return (std::abs(base_odom.twist.twist.angular.z) <= rot_stopped_velocity &&\n          std::abs(base_odom.twist.twist.linear.x) <= trans_stopped_velocity &&\n          std::abs(base_odom.twist.twist.linear.y) <= trans_stopped_velocity);\n}\n", "CodeBleu_score": 66.7384863683634}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  // If setup is not yet done, initialize the default limits with the provided configuration and set up the flag.\n  if (!setup_) {\n    default_limits_ = config;\n    setup_ = true;\n  }\n\n  // If restore_defaults is requested, reset the configuration to default limits.\n  if (restore_defaults) {\n    config = default_limits_;\n  }\n\n  // Lock the configuration mutex and update the current limits with the new configuration.\n  boost::unique_lock<boost::mutex> lock(configuration_mutex_);\n  limits_ = config;\n}\n", "CodeBleu_score": 64.56054256875596}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  // If setup is not done, initialize the default limits with the provided configuration\n  if (!setup) {\n    default_limits = config;\n    setup = true;\n  }\n\n  // If restore_defaults is requested, reset the configuration to default limits\n  if (restore_defaults) {\n    config = default_limits;\n  }\n\n  // Lock the configuration mutex and update the current limits with the new configuration\n  boost::mutex::scoped_lock lock(configuration_mutex);\n  current_limits = config;\n}\n", "CodeBleu_score": 57.45481619683327}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)  // If the setup flag is true and restore_defaults is requested, reset the configuration to default limits\n  if (setup_ && restore_defaults) {\n    // Set the current limits to default limits\n    current_limits_ = default_limits_;\n    // Set the configuration to default limits\n    config = default_limits_;\n    // Set the setup flag to false\n    setup_ = false;\n    // Unlock the configuration mutex\n    config_mutex_.unlock();\n    // Return\n    return;\n  }\n\n  // If the setup flag is false, initialize the default limits with the provided configuration and set up the flag\n  if (!setup_) {\n    // Set the default limits to the provided configuration\n    default_limits_ = config;\n    // Set the current limits to the provided configuration\n    current_limits_ = config;\n    // Set the setup flag to true\n    setup_ = true;\n  }\n\n  // Lock the configuration mutex\n  config_mutex_.lock();\n  // Set the current limits to the provided configuration\n  current_limits_ = config;\n  // Unlock the configuration mutex\n  config_mutex_.unlock();\n}\n", "CodeBleu_score": 55.78178203204585}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  unsigned char cost = costmap.getCost(check_cell->getX(), check_cell->getY());\n  if (cost == costmap_2d::NO_INFORMATION) {\n    return false;\n  }\n  if (cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->setTargetDistance(costmap_2d::INSCRIBED_INFLATED_OBSTACLE);\n    return false;\n  }\n  double new_target_distance = current_cell->getTargetDistance() +\n      costmap_2d::getCostToProbability(cost);\n  if (new_target_distance < check_cell->getTargetDistance()) {\n    check_cell->setTargetDistance(new_target_distance);\n    return true;\n  }\n  return false;\n}\n", "CodeBleu_score": 55.02621929507798}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)  unsigned int check_index = check_cell->index;\n  unsigned int check_cost = costmap.getCost(check_index);\n\n  // If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost\n  if (check_cost == costmap_2d::NO_INFORMATION) {\n    check_cell->target_distance = std::numeric_limits<double>::max();\n    return false;\n  }\n\n  if (check_cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_distance = std::numeric_limits<double>::max();\n    return false;\n  }\n\n  // Calculate the new target distance\n  double new_distance = current_cell->target_distance +\n      costmap.getCost(check_index) * costmap.getResolution();\n\n  // Update the target distance if the new distance is shorter\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n    check_cell->parent = current_cell;\n    return true;\n  }\n\n  return false;\n}\n", "CodeBleu_score": 54.150777738596844}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\n  // check if the cell is an obstacle or has no information\n  if (check_cell->cost >= costmap_2d::INSCRIBED_INFLATED_OBSTACLE) {\n    check_cell->target_distance = costmap_2d::INSCRIBED_INFLATED_OBSTACLE;\n    return false;\n  }\n\n  // calculate the new target distance\n  float new_distance = current_cell->target_distance +\n                       costmap.getDefaultCost(check_cell->x, check_cell->y);\n\n  // update the target distance if the new distance is shorter\n  if (new_distance < check_cell->target_distance) {\n    check_cell->target_distance = new_distance;\n    return true;\n  }\n\n  return false;\n}\n", "CodeBleu_score": 51.60670957459773}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0.0;\n  double scaling_factor = 1.0;\n\n  // Initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (traj.getVelocity() < 0.0) {\n    // Backwards trajectories are not allowed\n    return -9.0;\n  } else if (traj.getVelocity() > max_vel_) {\n    // Scale the trajectory to the maximum velocity\n    scaling_factor = max_vel_ / traj.getVelocity();\n  }\n\n  // Check if the footprint specification is empty\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint specification is empty.\");\n    return -9.0;\n  }\n\n  // Calculate the cost for each point in the trajectory\n  for (auto point : traj.getTrajectory()) {\n    double footprint_cost = scoreFootprint(point);\n\n    // If the footprint cost is negative, return the cost immediately\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n\n    // Sum the scores or take the maximum score based on the sum_scores_ flag\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  // Return the total cost\n  return cost * scaling_factor;\n}\n", "CodeBleu_score": 50.54508781900745}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0.0;\n  double scaling_factor = 1.0;\n  if (footprint_spec_.size() == 0) {\n    ROS_ERROR(\"Footprint specification is empty.\");\n    return -9.0;\n  }\n  for (unsigned int i = 0; i < traj.getPointsSize(); i++) {\n    double footprint_cost = scoreFootprint(traj.getX(i), traj.getY(i),\n                                           traj.getYaw(i));\n    if (footprint_cost < 0.0)\n      return footprint_cost;\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      if (footprint_cost > cost)\n        cost = footprint_cost;\n    }\n  }\n  return cost * scaling_factor;\n}\n", "CodeBleu_score": 51.69150501835287}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)  double cost = 0.0;\n  double scaling_factor = 1.0;\n  double footprint_cost = 0.0;\n\n  // Initialize the cost and scaling factor based on the trajectory and speed parameters\n  if (traj.getPointsSize() > 0) {\n    scaling_factor = traj.getSpeed() / traj.getPoints().front().getSpeed();\n  }\n  if (traj.getPointsSize() > 1) {\n    scaling_factor = std::min(scaling_factor, traj.getSpeed() / traj.getPoints().back().getSpeed());\n  }\n  if (traj.getPointsSize() > 0) {\n    cost = traj.getPoints().front().getCost();\n  }\n\n  // Get the footprint specification\n  const std::vector<geometry_msgs::Point> &footprint = *(traj.getRobotFootprint());\n  if (footprint.size() == 0) {\n    ROS_ERROR(\"Robot footprint specified as empty. Obstacle cost function disabled.\");\n    return -9.0;\n  }\n\n  // Iterate over the trajectory points and calculate the footprint cost\n  for (const auto &pt : traj.getPoints()) {\n    footprint_cost = scoreFootprint(pt, footprint);\n    if (footprint_cost < 0.0) {\n      return footprint_cost;\n    }\n    if (sum_scores_) {\n      cost += footprint_cost;\n    } else {\n      cost = std::max(cost, footprint_cost);\n    }\n  }\n\n  // Return the total cost\n  return cost * scaling_factor;\n}\n", "CodeBleu_score": 43.80396813777578}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)  //check to make sure the footprint is not empty\n  if (footprint_spec.size () == 0) {\n    ROS_ERROR (\"Footprint model is empty, can't cost anything.\");\n    return -1.0;\n  }\n\n  //check to make sure the footprint is oriented correctly\n  double footprint_cost = 0.0;\n  double footprint_scaled_cost = 0.0;\n  double footprint_scaled_cost_world = 0.0;\n  double footprint_scaled_cost_map = 0.0;\n  double footprint_scaled_cost_combined = 0.0;\n  double footprint_scaled_cost_combined_world = 0.0;\n  double footprint_scaled_cost_combined_map = 0.0;\n  double footprint_scaled_cost_combined_map_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world_world_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world_world_world_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world_world_world_world_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world_world_world_world_world_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world_world_world_world_world_world_world_world = 0.0;\n  double footprint_scaled_cost_combined_map_world_world_world_world_world_world_world_world_", "CodeBleu_score": 19.413317719963644}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)  // Check if the footprint is off the map\n  if (!costmap->worldToMapNoBounds(x, y, footprint_cx_, footprint_cy_)) {\n    return -7.0;\n  }\n\n  // Scale the footprint\n  scaleFootprint(footprint_spec, scale, footprint_spec_);\n\n  // Calculate the footprint cost\n  unsigned int num_points = footprint_spec_.size();\n  double footprint_cost = 0.0;\n  for (unsigned int i = 0; i < num_points; ++i) {\n    double px = footprint_cx_ + footprint_spec_[i].x;\n    double py = footprint_cy_ + footprint_spec_[i].y;\n    unsigned int mx, my;\n    if (costmap->worldToMap(px, py, mx, my)) {\n      footprint_cost = std::max(footprint_cost, (double)costmap->getCost(mx, my));\n    } else {\n      // the footprint is off the map\n      return -6.0;\n    }\n  }\n\n  // Calculate the cell cost\n  double cell_cost = costmap->getCost(footprint_cx_, footprint_cy_);\n\n  // Return the maximum cost\n  return std::max(cell_cost, footprint_cost);\n}\n", "CodeBleu_score": 58.0283171982121}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)  //check to make sure the footprint is not empty\n  if (footprint_spec.size() == 0) {\n    ROS_ERROR(\"Attempting to create cost for a footprint with no points\");\n    return -6.0;\n  }\n\n  //check to make sure the footprint is not off the map\n  if (!costmap->worldToMap(x, y, footprint_x_, footprint_y_)) {\n    ROS_ERROR(\"Attempting to create cost for a footprint at an off-map point\");\n    return -7.0;\n  }\n\n  //scale the footprint\n  scaleFootprint(footprint_x_, footprint_y_, footprint_spec, scale);\n\n  //calculate the footprint cost\n  double footprint_cost = world_model->footprintCost(x, y, th, footprint_spec);\n\n  //if the footprint cost is negative, return -6.0\n  if (footprint_cost < 0) {\n    return -6.0;\n  }\n\n  //get the cost of the cell at the given position\n  unsigned int mx, my;\n  if (!costmap->worldToMap(x, y, mx, my)) {\n    ROS_ERROR(\"Attempting to create cost for a footprint at an off-map point\");\n    return -7.0;\n  }\n  unsigned char cell_cost = costmap->getCost(mx, my);\n\n  //return the maximum cost between the footprint cost and the cell cost\n  return std::max(cell_cost, (unsigned char) (100 * footprint_cost));\n}\n", "CodeBleu_score": 55.288843453302135}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic != odom_topic_) {\n\t\tif (!odom_topic.empty()) {\n\t\t\todom_topic_ = odom_topic;\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 10, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_sub_.shutdown();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.855088076699026}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  if (odom_topic != odom_topic_) {\n    if (!odom_topic.empty()) {\n      odom_topic_ = odom_topic;\n      odom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}\n", "CodeBleu_score": 46.893838024446}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)  if (odom_topic != odom_topic_) {\n    odom_topic_ = odom_topic;\n    if (odom_topic_ != \"\") {\n      odom_sub_ = nh_.subscribe(odom_topic_, 1000, &OdometryHelperRos::odomCallback, this);\n    } else {\n      odom_sub_.shutdown();\n    }\n  }\n}\n", "CodeBleu_score": 50.60830210696198}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)    float squaredDistance = (pos - prev).squaredNorm();\n    float angle = acos(pos.normalized().dot(prev.normalized()));\n    if (squaredDistance > squaredDistanceThreshold || angle > angleThreshold) {\n        resetOscillationFlags();\n    }\n}\n", "CodeBleu_score": 30.613060372923634}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)  float distance = (pos - prev).norm();\n  float angle = std::abs(std::atan2(prev.y(), prev.x()) - std::atan2(pos.y(), pos.x()));\n  if (distance > distance_threshold || angle > angle_threshold) {\n    resetOscillationFlags();\n  }\n}\n", "CodeBleu_score": 35.732732444109836}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)  if (pos.squaredNorm() > params_.max_squared_distance_to_reset_oscillation_flags ||\n      std::abs(angles::shortest_angular_distance(angles::normalize_angle_positive(angles::angle_between_vectors(pos, prev)), 0.f)) > params_.max_angle_to_reset_oscillation_flags) {\n    resetOscillationFlags();\n  }\n}\n", "CodeBleu_score": 27.351052007232745}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)    // Get the grid coordinates of the point\n    int x = static_cast<int>(floor(pt.x / cell_size_));\n    int y = static_cast<int>(floor(pt.y / cell_size_));\n    int z = static_cast<int>(floor(pt.z / cell_size_));\n\n    // Check if the point is within the grid bounds\n    if (x < 0 || x >= grid_size_ || y < 0 || y >= grid_size_ || z < 0 || z >= grid_size_) {\n        return;\n    }\n\n    // Calculate the grid index\n    int index = x + y * grid_size_ + z * grid_size_ * grid_size_;\n\n    // Insert the point into the corresponding cell\n    grid_[index].push_back(pt);\n}\n", "CodeBleu_score": 42.51533942441922}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)  // Check if point is within the grid bounds\n  if (pt.x < grid_min_x_ || pt.x > grid_max_x_ || pt.y < grid_min_y_ || pt.y > grid_max_y_) {\n    return;\n  }\n\n  // Calculate grid coordinates\n  int grid_x = static_cast<int>((pt.x - grid_min_x_) / grid_resolution_);\n  int grid_y = static_cast<int>((pt.y - grid_min_y_) / grid_resolution_);\n\n  // Check if point is too close to its nearest neighbor\n  int grid_index = grid_x + grid_y * grid_width_;\n  if (grid_[grid_index].size() > 0) {\n    double min_dist = std::numeric_limits<double>::max();\n    for (const auto& neighbor : grid_[grid_index]) {\n      double dist = std::sqrt(std::pow(pt.x - neighbor.x, 2) + std::pow(pt.y - neighbor.y, 2));\n      if (dist < min_dist) {\n        min_dist = dist;\n      }\n    }\n    if (min_dist < min_dist_threshold_) {\n      return;\n    }\n  }\n\n  // Insert point into grid\n  grid_[grid_index].push_back(pt);\n}\n", "CodeBleu_score": 36.75127230543006}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)  // Get the grid coordinates of the point\n  int x = static_cast<int>((pt.x - min_x_) / cell_size_);\n  int y = static_cast<int>((pt.y - min_y_) / cell_size_);\n  int z = static_cast<int>((pt.z - min_z_) / cell_size_);\n\n  // Check if the point is outside the grid bounds\n  if (x < 0 || x >= num_cells_x_ || y < 0 || y >= num_cells_y_ || z < 0 || z >= num_cells_z_) {\n    return;\n  }\n\n  // Calculate the grid index\n  int index = x + y * num_cells_x_ + z * num_cells_x_ * num_cells_y_;\n\n  // Insert the point into the corresponding cell\n  cells_[index].insert(pt);\n}\n", "CodeBleu_score": 37.4720880141093}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    if (sample_target_vel[i] > vel[i]) {\n      new_vel[i] = std::min(sample_target_vel[i], vel[i] + acclimits[i] * dt);\n    } else {\n      new_vel[i] = std::max(sample_target_vel[i], vel[i] - acclimits[i] * dt);\n    }\n  }\n  return new_vel;\n}\n", "CodeBleu_score": 83.18353960739765}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)  Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n  for (int i = 0; i < 3; i++) {\n    float delta_vel = sample_target_vel(i) - vel(i);\n    float acc = delta_vel / dt;\n    if (acc > acclimits(i)) {\n      acc = acclimits(i);\n    } else if (acc < -acclimits(i)) {\n      acc = -acclimits(i);\n    }\n    new_vel(i) = vel(i) + acc * dt;\n  }\n  return new_vel;\n}\n", "CodeBleu_score": 54.48042882398689}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)    Eigen::Vector3f new_vel = Eigen::Vector3f::Zero();\n    for (int i = 0; i < 3; i++) {\n        float vel_diff = sample_target_vel[i] - vel[i];\n        if (std::abs(vel_diff) < acclimits[i] * dt) {\n            new_vel[i] = sample_target_vel[i];\n        } else {\n            new_vel[i] = vel[i] + (vel_diff > 0 ? acclimits[i] : -acclimits[i]) * dt;\n        }\n    }\n    return new_vel;\n}\n", "CodeBleu_score": 70.04575472091723}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)  double min_dist = DBL_MAX;\n  int goal_cell_x = 0;\n  int goal_cell_y = 0;\n  double goal_x = 0.0;\n  double goal_y = 0.0;\n  double dist = 0.0;\n  double dx = 0.0;\n  double dy = 0.0;\n  double angle = 0.0;\n  double angle_diff = 0.0;\n  double angle_diff_abs = 0.0;\n  double angle_diff_abs_min = DBL_MAX;\n  double angle_diff_abs_min_prev = DBL_MAX;\n\n  for (int i = global_plan_.size() - 1; i >= 0; i--) {\n    goal_cell_x = global_plan_[i].x;\n    goal_cell_y = global_plan_[i].y;\n    if (cell_x == goal_cell_x && cell_y == goal_cell_y) {\n      continue;\n    }\n    if (!map_->isOccupied(goal_cell_x, goal_cell_y)) {\n      goal_x = map_->getWorldX(goal_cell_x);\n      goal_y = map_->getWorldY(goal_cell_y);\n      dx = goal_x - x;\n      dy = goal_y - y;\n      dist = sqrt(dx * dx + dy * dy);\n      if (dist < min_dist) {\n        min_dist = dist;\n        angle = atan2(dy, dx);\n        angle_diff = angle - heading;\n        angle_diff_abs = fabs(angle_diff);\n        if (angle_diff_abs < angle_diff_abs_min_prev) {\n          angle_diff_abs_min = angle_diff_abs;\n          angle_diff_abs_min_prev = angle_diff_abs;\n        }\n      }\n    }\n  }\n\n  return angle_diff_abs_min;\n}\n", "CodeBleu_score": 48.589675761217}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)    // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the robot's current cell\n    for (int i = global_plan_.size() - 1; i >= 0; i--) {\n        int plan_x = global_plan_[i].x;\n        int plan_y = global_plan_[i].y;\n        // Check if the plan point is in the same cell as the robot's current position\n        if (plan_x == cell_x && plan_y == cell_y) {\n            // Check if the plan point is in the same cell as the robot's current position\n            if (plan_x == cell_x && plan_y == cell_y) {\n                // Convert the plan point to world coordinates\n                double plan_x = plan_x * costmap_->getResolution() + costmap_->getOriginX();\n                double plan_y = plan_y * costmap_->getResolution() + costmap_->getOriginY();\n                // Calculate the shortest angular distance between the current heading and the direction to the plan point\n                double diff = angles::shortest_angular_distance(heading, atan2(plan_y - y, plan_x - x));\n                // Return the absolute value of the shortest angular distance\n                return fabs(diff);\n            }\n        }\n    }\n    // If no valid point is found, return DBL_MAX\n    return DBL_MAX;\n}", "CodeBleu_score": 52.33462150394197}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)  double dx, dy, goal_x, goal_y, min_dist, dist, heading_diff;\n  bool found = false;\n  int i;\n\n  // Iterate through the global plan in reverse to find the farthest point with a clear line of sight from the current cell\n  for (i = global_plan.size() - 1; i >= 0; i--) {\n    dx = global_plan[i].x - cell_x;\n    dy = global_plan[i].y - cell_y;\n    dist = sqrt(dx * dx + dy * dy);\n\n    // If the point is within the robot's range and has a clear line of sight, it is a valid goal point\n    if (dist <= range && lineOfSight(cell_x, cell_y, global_plan[i].x, global_plan[i].y)) {\n      found = true;\n      break;\n    }\n  }\n\n  // If a valid goal point is found, calculate the absolute value of the shortest angular distance between the current heading and the direction to the goal point\n  if (found) {\n    goal_x = global_plan[i].x;\n    goal_y = global_plan[i].y;\n    heading_diff = atan2(goal_y - y, goal_x - x) - heading;\n    heading_diff = fabs(atan2(sin(heading_diff), cos(heading_diff)));\n  } else {\n    // If no valid goal point is found, return DBL_MAX\n    heading_diff = DBL_MAX;\n  }\n\n  return heading_diff;\n}\n", "CodeBleu_score": 47.887802440477515}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  // Compute the cost of the trajectory\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\n  // Check if the trajectory is valid\n  if (cost < 0) {\n    // Log a warning with the sample velocities and cost\n    ROS_WARN_STREAM(\"Trajectory is not valid: \" << \"vx_samp = \" << vx_samp << \", \"\n      << \"vy_samp = \" << vy_samp << \", \" << \"vtheta_samp = \" << vtheta_samp << \", \"\n      << \"cost = \" << cost);\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 67.32718504473614}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if (cost >= 0) {\n    return true;\n  } else {\n    ROS_WARN(\"TrajectoryPlanner::checkTrajectory: trajectory is not valid (cost %f, vx %f, vy %f, vtheta %f)\", cost, vx_samp, vy_samp, vtheta_samp);\n    return false;\n  }\n}\n", "CodeBleu_score": 77.70835874480831}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\n    // Compute the trajectory\n    Trajectory trajectory = computeTrajectory(x, y, theta, vx, vy, vtheta);\n\n    // Evaluate the trajectory using scoreTrajectory\n    double cost = scoreTrajectory(trajectory, vx_samp, vy_samp, vtheta_samp);\n\n    // If the cost is non-negative, the trajectory is considered valid\n    if (cost >= 0) {\n        return true;\n    }\n\n    // If the cost is negative, it logs a warning with the sample velocities and cost\n    ROS_WARN_STREAM(\"Trajectory with sample velocities (\" << vx_samp << \", \" << vy_samp << \", \" << vtheta_samp << \") has cost \" << cost);\n\n    return false;\n}", "CodeBleu_score": 63.452215621791495}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()  // Check if the object is initialized and if the costmaps are not NULL\n  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n  if (global_planner_ == NULL) {\n    ROS_ERROR(\"The global planner pointer is NULL\");\n    return;\n  }\n  if (local_planner_ == NULL) {\n    ROS_ERROR(\"The local planner pointer is NULL\");\n    return;\n  }\n\n  // Log a warning about clearing inside or outside a specified area\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Clearing inside area\");\n  } else {\n    ROS_WARN(\"Clearing outside area\");\n  }\n\n  // Clear the global and/or local costmap based on the affected_maps_ setting\n  if (affected_maps_ & clearing_robot_local_costs_) {\n    ROS_INFO(\"Clearing local costmap\");\n    std::vector<geometry_msgs::Point> clear_poly;\n    geometry_msgs::Point32 point;\n    point.x = xmin_;\n    point.y = ymin_;\n    clear_poly.push_back(point);\n    point.x = xmax_;\n    point.y = ymin_;\n    clear_poly.push_back(point);\n    point.x = xmax_;\n    point.y = ymax_;\n    clear_poly.push_back(point);\n    point.x = xmin_;\n    point.y = ymax_;\n    clear_poly.push_back(point);\n    clear_poly.push_back(point);\n\n    // Clear the local costmap\n    std::vector<geometry_msgs::Point> clear_poly_local;\n    for (unsigned int i = 0; i < clear_poly.size(); ++i) {\n      point.x = clear_poly[i].x - xmin_;\n      point.y = clear_poly[i].y - ymin_;\n      clear_poly_local.push_back(point);\n    }\n    local_planner_->clearRobotFoot", "CodeBleu_score": 47.69942681267578}, {"code": "void ClearCostmapRecovery::runBehavior()  // Check if the object is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n    return;\n  }\n\n  // Check if the costmaps are not NULL\n  if (global_costmap_ == NULL || local_costmap_ == NULL) {\n    ROS_ERROR(\"The costmap passed to the ClearCostmapRecovery object is NULL\");\n    return;\n  }\n\n  // Log a warning about clearing inside or outside a specified area\n  if (invert_area_to_clear_) {\n    ROS_WARN(\"Inverting area to clear\");\n  }\n\n  // Clear the global and/or local costmap based on the affected_maps_ setting\n  if (affected_maps_ & clearing_robot_local_costmap_) {\n    // Clear the local costmap\n    if (clear_local_costmap_) {\n      // Force an update\n      local_costmap_->updateMap(nh_, map_update_frequency_);\n      // Clear the costmap\n      local_costmap_->clear();\n      // Log the time taken for the operation\n      ROS_INFO(\"Clearing local costmap\");\n    }\n  }\n  if (affected_maps_ & clearing_global_costmap_) {\n    // Clear the global costmap\n    if (clear_global_costmap_) {\n      // Force an update\n      global_costmap_->updateMap(nh_, map_update_frequency_);\n      // Clear the costmap\n      global_costmap_->clear();\n      // Log the time taken for the operation\n      ROS_INFO(\"Clearing global costmap\");\n    }\n  }\n}", "CodeBleu_score": 40.22559532213702}, {"code": "void ClearCostmapRecovery::runBehavior()    // Check if the object is initialized\n    if (!initialized_) {\n        ROS_ERROR(\"This object must be initialized before runBehavior is called\");\n        return;\n    }\n\n    // Check if the costmaps are not NULL\n    if (global_costmap_ == NULL || (local_costmap_ != NULL && !local_only_)) {\n        ROS_ERROR(\"The costmaps passed to the ClearCostmapRecovery object are not initialized\");\n        return;\n    }\n\n    // Log a warning about clearing inside or outside a specified area\n    if (invert_area_to_clear_) {\n        ROS_WARN(\"Clearing inside the area, not outside\");\n    } else {\n        ROS_WARN(\"Clearing outside the area, not inside\");\n    }\n\n    // Clear the global and/or local costmap based on the affected_maps_ setting\n    ros::WallTime start = ros::WallTime::now();\n    if (affected_maps_ & clearing_robot_local_costmap_) {\n        clearLocalCostmap();\n    }\n    if (affected_maps_ & clearing_global_costmap_) {\n        clearGlobalCostmap();\n    }\n    ros::WallTime end = ros::WallTime::now();\n\n    // Log the time taken for each operation\n    ROS_INFO_STREAM(\"Time taken to clear costmaps: \" << (end - start).toSec() << \" seconds\");\n}\n", "CodeBleu_score": 38.4486616338849}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  // Initialize the PolygonOutlineCells object\n  PolygonOutlineCells outline_cells;\n\n  // Iterate through the polygon vertices\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    // Get the current and next points\n    const MapLocation& p0 = polygon[i];\n    const MapLocation& p1 = polygon[(i + 1) % polygon.size()];\n\n    // Use raytraceLine to gather cells between the current and next points\n    outline_cells.addCellsBetween(p0, p1);\n  }\n\n  // If the polygon is not empty, close it by connecting the last point to the first\n  if (polygon.size() > 0) {\n    outline_cells.addCellsBetween(polygon.back(), polygon.front());\n  }\n\n  // Copy the collected cells to the output vector\n  polygon_cells = outline_cells.getCells();\n}\n", "CodeBleu_score": 49.50439443230548}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  // If the polygon is empty, we have no work to do.\n  if (polygon.empty()) {\n    return;\n  }\n\n  // We'll use this struct to store the cells we find.\n  struct PolygonOutlineCells {\n    // The cells that have been found so far.\n    std::vector<MapLocation> cells;\n\n    // The current cell that we're in.\n    MapLocation current_cell;\n\n    // The current cell's index in the cells vector.\n    int current_cell_index;\n  };\n\n  // This is the struct we'll use to store the cells we find.\n  PolygonOutlineCells outline_cells;\n\n  // The index of the first point in the polygon.\n  int first_point_index = 0;\n\n  // The index of the last point in the polygon.\n  int last_point_index = static_cast<int>(polygon.size()) - 1;\n\n  // The index of the current point in the polygon.\n  int current_point_index = first_point_index;\n\n  // The index of the next point in the polygon.\n  int next_point_index = current_point_index + 1;\n\n  // If the polygon is not closed, we need to add the last point to the first point.\n  if (next_point_index > last_point_index) {\n    next_point_index = first_point_index;\n  }\n\n  // We'll use this function to add the cells that we find to the outline_cells struct.\n  auto add_cells = [&](const MapLocation& start, const MapLocation& end) {\n    // If the start and end points are the same, we don't need to do anything.\n    if (start == end) {\n      return;\n    }\n\n    // We'll use this function to add a cell to the outline_cells struct.\n    auto add_cell = [&](const MapLocation& cell) {\n      // If the cell is the same as the current cell, we don't need to do anything.\n      if (cell == outline_cells.current_cell) {\n        return;", "CodeBleu_score": 28.281657561883613}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)  // Initialize the PolygonOutlineCells object\n  PolygonOutlineCells outline_cells(this);\n\n  // Iterate through the polygon vertices\n  for (unsigned int i = 0; i < polygon.size(); ++i) {\n    // Get the current point and the next point\n    const MapLocation& point = polygon[i];\n    const MapLocation& next_point = polygon[(i + 1) % polygon.size()];\n\n    // Raytrace between the current point and the next point\n    outline_cells.raytraceLine(point, next_point);\n  }\n\n  // If the polygon is not empty, close it by connecting the last point to the first\n  if (polygon.size() > 1) {\n    const MapLocation& point = polygon[0];\n    const MapLocation& next_point = polygon[polygon.size() - 1];\n    outline_cells.raytraceLine(point, next_point);\n  }\n\n  // Copy the collected cells to the output vector\n  polygon_cells = outline_cells.getCells();\n}\n", "CodeBleu_score": 51.65782992056614}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  prepareGrid();\n  pub.publish(grid);\n}\n", "CodeBleu_score": 69.47546917136665}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  prepareGrid();\n  pub.publish(grid_msg_);\n}\n", "CodeBleu_score": 70.03176000268684}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)  // Prepare the grid data\n  prepareGrid();\n\n  // Publish the prepared grid\n  pub.publish(grid_msg_);\n}\n", "CodeBleu_score": 61.77059532293906}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()    std::lock_guard<std::mutex> lock(costmap_mutex_);\n    double resolution = costmap_->getResolution();\n    grid_.header.stamp = ros::Time::now();\n    grid_.header.frame_id = costmap_->getGlobalFrameID();\n    grid_.info.resolution = resolution;\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n    grid_.info.origin.position.x = costmap_->getOriginX();\n    grid_.info.origin.position.y = costmap_->getOriginY();\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n    origin_x_ = grid_.info.origin.position.x;\n    origin_y_ = grid_.info.origin.position.y;\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n}\n", "CodeBleu_score": 53.20184508425473}, {"code": "void Costmap2DPublisher::prepareGrid()    // Lock the costmap mutex\n    boost::unique_lock<Costmap2D::mutex_t> lock(*costmap_->getMutex());\n\n    // Retrieve the resolution\n    double resolution = costmap_->getResolution();\n\n    // Set the grid's header\n    grid_.header.frame_id = costmap_->getBaseFrameID();\n    grid_.header.stamp = ros::Time::now();\n\n    // Set the grid's resolution\n    grid_.info.resolution = resolution;\n\n    // Set the grid's width and height\n    grid_.info.width = costmap_->getSizeInCellsX();\n    grid_.info.height = costmap_->getSizeInCellsY();\n\n    // Convert the map coordinates to world coordinates for the origin\n    double origin_x, origin_y;\n    costmap_->mapToWorld(0, 0, origin_x, origin_y);\n\n    // Set the origin's position and orientation\n    grid_.info.origin.position.x = origin_x;\n    grid_.info.origin.position.y = origin_y;\n    grid_.info.origin.position.z = 0.0;\n    grid_.info.origin.orientation.x = 0.0;\n    grid_.info.origin.orientation.y = 0.0;\n    grid_.info.origin.orientation.z = 0.0;\n    grid_.info.origin.orientation.w = 1.0;\n\n    // Save the origin coordinates\n    origin_x_ = origin_x;\n    origin_y_ = origin_y;\n\n    // Resize the grid data vector\n    grid_.data.resize(grid_.info.width * grid_.info.height);\n\n    // Populate the grid data from the costmap's character map using a translation table\n    const char* costmap = costmap_->getCharMap();\n    for (unsigned int i = 0; i < grid_.data.size(); ++i) {\n        grid_.data[i] = costmap2grid_[costmap[i]];\n    }\n}\n", "CodeBleu_score": 71.98521080313434}, {"code": "void Costmap2DPublisher::prepareGrid()  boost::unique_lock<Costmap2D::mutex_t> lock(*(costmap->getMutex()));\n\n  // Set the grid's header\n  grid.header.stamp = ros::Time::now();\n  grid.header.frame_id = costmap->getBaseFrameID();\n\n  // Set the grid's resolution\n  grid.info.resolution = costmap->getResolution();\n\n  // Set the grid's width and height\n  grid.info.width = costmap->getSizeInCellsX();\n  grid.info.height = costmap->getSizeInCellsY();\n\n  // Set the grid's origin\n  grid.info.origin.position.x = costmap->getOriginX();\n  grid.info.origin.position.y = costmap->getOriginY();\n  grid.info.origin.position.z = 0.0;\n  grid.info.origin.orientation.x = 0.0;\n  grid.info.origin.orientation.y = 0.0;\n  grid.info.origin.orientation.z = 0.0;\n  grid.info.origin.orientation.w = 1.0;\n\n  // Save the origin coordinates\n  origin_x = costmap->getOriginX();\n  origin_y = costmap->getOriginY();\n\n  // Resize the grid data vector\n  grid.data.resize(grid.info.width * grid.info.height);\n\n  // Populate the grid data from the costmap's character map using a translation table\n  unsigned char* costmap_data = costmap->getCharMap();\n  for (unsigned int i = 0; i < grid.data.size(); ++i) {\n    grid.data[i] = costmap_translation_table[costmap_data[i]];\n  }\n}\n", "CodeBleu_score": 53.78143001132989}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  if (new_config.robot_radius == old_config.robot_radius &&\n      new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  // If a footprint string was provided, convert it to a polygon\n  if (!new_config.footprint.empty()) {\n    std::vector<geometry_msgs::Point> footprint_spec;\n    if (!Costmap2DROS::makeFootprintFromString(new_config.footprint, footprint_spec)) {\n      ROS_ERROR(\"Error parsing footprint string\");\n    } else {\n      // Check that the footprint is not empty\n      if (footprint_spec.empty()) {\n        ROS_ERROR(\"Robot footprint is empty\");\n      } else {\n        // Set the footprint\n        setFootprint(footprint_spec);\n      }\n    }\n  } else {\n    // If no footprint string was provided, set the footprint based on the robot radius\n    setFootprintFromRadius(new_config.robot_radius);\n  }\n}", "CodeBleu_score": 64.70577727901257}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  // Check if the footprint and robot radius in the new and old configurations are the same\n  if (new_config.robot_radius == old_config.robot_radius &&\n      new_config.footprint == old_config.footprint) {\n    return;\n  }\n\n  // Convert the footprint string to a footprint if it is valid\n  std::vector<geometry_msgs::Point> footprint;\n  if (!costmap_2d::makeFootprintFromString(new_config.footprint, footprint)) {\n    ROS_ERROR(\"Invalid footprint string: %s\", new_config.footprint.c_str());\n    return;\n  }\n\n  // Set the footprint if it is valid\n  setFootprint(footprint);\n}", "CodeBleu_score": 49.648035713641114}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)  if (new_config.footprint.size() > 0) {\n    // check if footprint and radius are the same\n    if (new_config.footprint == old_config.footprint &&\n        new_config.robot_radius == old_config.robot_radius) {\n      return;\n    }\n\n    // check if footprint string is valid\n    std::vector<geometry_msgs::Point> footprint_spec;\n    if (!Costmap2DROS::makeFootprintFromString(new_config.footprint, footprint_spec)) {\n      ROS_ERROR(\"The footprint string is not valid. Check that the string is not empty and that all values are valid numbers.\");\n      return;\n    }\n\n    // set the footprint\n    setFootprint(footprint_spec);\n  } else {\n    // set the footprint based on the robot radius\n    setFootprintBasedOnRobotRadius(new_config.robot_radius);\n  }\n}", "CodeBleu_score": 63.74745593791167}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Could not get robot pose\");\n    return;\n  }\n\n  /*\n   * This function, Costmap2DROS::updateMap, is used to update the costmap and publish it to the topic specified by the parameter \"costmap_topic\".\\nIt takes the current time as input and uses it to calculate the time elapsed since the last update.\\nThe function then updates the costmap using the new pose and time elapsed.\n   */\n  updateMap(ros::Time::now());\n  publishCostmap();\n}", "CodeBleu_score": 66.128019322587}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  geometry_msgs::PoseStamped new_pose;\n  if (!getRobotPose(new_pose)) {\n    ROS_WARN(\"Failed to get robot pose, canceling reconfiguration\");\n    return;\n  }\n\n  // check if the robot has moved far enough to trigger a reconfiguration\n  if (new_pose.header.frame_id != last_pose_.header.frame_id) {\n    ROS_WARN(\"The robot pose changed frames, canceling reconfiguration\");\n    return;\n  }\n\n  if (new_pose.header.stamp < last_pose_.header.stamp) {\n    ROS_WARN(\"The robot pose is in the past, canceling reconfiguration\");\n    return;\n  }\n\n  if (new_pose.header.stamp - last_pose_.header.stamp > ros::Duration(0.5)) {\n    ROS_WARN(\"The robot pose is too old, canceling reconfiguration\");\n    return;\n  }\n\n  if (new_pose.pose.position.x != last_pose_.pose.position.x ||\n      new_pose.pose.position.y != last_pose_.pose.position.y ||\n      new_pose.pose.position.z != last_pose_.pose.position.z ||\n      new_pose.pose.orientation.x != last_pose_.pose.orientation.x ||\n      new_pose.pose.orientation.y != last_pose_.pose.orientation.y ||\n      new_pose.pose.orientation.z != last_pose_.pose.orientation.z ||\n      new_pose.pose.orientation.w != last_pose_.pose.orientation.w) {\n    ROS_INFO(\"Robot moved, reconfiguring costmap\");\n    last_pose_ = new_pose;\n    reconfigure();\n  }\n}", "CodeBleu_score": 52.41387111533483}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)  // get the robot's pose\n  geometry_msgs::PoseStamped new_pose;\n  if (!costmap_2d_->getRobotPose(new_pose)) {\n    ROS_WARN(\"Could not get robot pose\");\n    return;\n  }\n\n  // if the robot has moved, update the costmap\n  if (new_pose.header.frame_id != last_pose_.header.frame_id ||\n      new_pose.header.stamp != last_pose_.header.stamp ||\n      new_pose.pose.position.x != last_pose_.pose.position.x ||\n      new_pose.pose.position.y != last_pose_.pose.position.y ||\n      new_pose.pose.position.z != last_pose_.pose.position.z ||\n      new_pose.pose.orientation.x != last_pose_.pose.orientation.x ||\n      new_pose.pose.orientation.y != last_pose_.pose.orientation.y ||\n      new_pose.pose.orientation.z != last_pose_.pose.orientation.z ||\n      new_pose.pose.orientation.w != last_pose_.pose.orientation.w) {\n    costmap_2d_->setRobotPose(new_pose);\n    last_pose_ = new_pose;\n  }\n}\n", "CodeBleu_score": 44.48798487806505}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()  // check if costmap was stopped\n  if (stopped_) {\n    // re-subscribe to topics\n    for (auto& plugin : plugins_) {\n      plugin->activate();\n    }\n    stopped_ = false;\n  }\n  // set stop_updates_ to false\n  stop_updates_ = false;\n  // wait until ROS is running\n  while (!ros::isInitialized()) {\n    ros::Duration(0.1).sleep();\n  }\n  // wait until costmap is initialized\n  while (!initialized_) {\n    ros::Duration(0.1).sleep();\n  }\n  // wait until map update thread is active\n  while (!map_update_thread_) {\n    ros::Duration(0.1).sleep();\n  }\n}\n", "CodeBleu_score": 38.3132368161941}, {"code": "void Costmap2DROS::start()  std::vector<boost::shared_ptr<Layer> >* plugins;\n  plugins = layered_costmap_->getPlugins();\n  if (stopped_) {\n    for (unsigned int i = 0; i < plugins->size(); i++) {\n      (*plugins)[i]->activate();\n    }\n    stopped_ = false;\n  }\n  stop_updates_ = false;\n  while (!ros::isInitialized() || !initialized_ || !update_thread_) {\n    usleep(100000);\n  }\n}\n", "CodeBleu_score": 60.69870945785877}, {"code": "void Costmap2DROS::start()    std::vector<std::string> plugin_names;\n    if (!nh_.getParam(\"plugins\", plugin_names)) {\n        ROS_ERROR(\"Could not retrieve list of plugins\");\n        return;\n    }\n    if (stopped_) {\n        ROS_INFO(\"Reactivating plugins\");\n        for (std::vector<std::string>::iterator it = plugin_names.begin(); it != plugin_names.end(); ++it) {\n            ROS_INFO(\"Reactivating plugin %s\", it->c_str());\n            if (activatePlugin(*it)) {\n                ROS_INFO(\"Activated plugin %s\", it->c_str());\n            } else {\n                ROS_ERROR(\"Failed to activate plugin %s\", it->c_str());\n            }\n        }\n        stopped_ = false;\n    }\n    stop_updates_ = false;\n    ROS_INFO(\"Waiting for ROS to start\");\n    while (!ros::master::check() && ros::ok()) {\n        ros::WallDuration(0.1).sleep();\n    }\n    ROS_INFO(\"ROS started\");\n    ROS_INFO(\"Waiting for costmap to become initialized\");\n    while (!initialized_ && ros::ok()) {\n        ros::WallDuration(0.1).sleep();\n    }\n    ROS_INFO(\"Costmap initialized\");\n    ROS_INFO(\"Waiting for map update thread to become active\");\n    while (!map_update_thread_.isActive() && ros::ok()) {\n        ros::WallDuration(0.1).sleep();\n    }\n    ROS_INFO(\"Map update thread active\");\n}\n", "CodeBleu_score": 43.33483873345454}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()  // If we are keeping all observations, there is nothing to do.\n  if (observation_keep_time_ == 0)\n    return;\n\n  // If there are no observations, there is nothing to do.\n  if (observations_.empty())\n    return;\n\n  // Iterate through the list of observations, removing those that are too old.\n  while (observations_.size() > 1) {\n    // Get the oldest observation.\n    const Observation& oldest_observation = observations_.front();\n\n    // Get the current time.\n    ros::Time current_time = ros::Time::now();\n\n    // If the observation is too old, we can stop.\n    if (current_time - oldest_observation.time > observation_keep_time_)\n      break;\n\n    // Otherwise, we remove the observation.\n    observations_.pop_front();\n  }\n}\n", "CodeBleu_score": 35.5042132113456}, {"code": "void ObservationBuffer::purgeStaleObservations()    if (observation_keep_time_ > 0) {\n        // Iterate through the list and remove observations that are older than the specified keep time.\n        // Stop once we find a valid observation.\n        for (auto it = observations_.begin(); it != observations_.end(); ++it) {\n            if (it->second.valid) {\n                break;\n            }\n            observations_.erase(it);\n        }\n    } else {\n        // Keep only the most recent observation.\n        for (auto it = observations_.begin(); it != observations_.end(); ++it) {\n            if (it != observations_.begin()) {\n                observations_.erase(it);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 44.60140705827496}, {"code": "void ObservationBuffer::purgeStaleObservations()  // If the observation_keep_time_ is zero, keep only the most recent observation\n  if (observation_keep_time_ == 0) {\n    // If there is only one observation, keep it\n    if (observations_.size() <= 1) {\n      return;\n    }\n\n    // Otherwise, remove all but the most recent observation\n    observations_.erase(observations_.begin(), observations_.end() - 1);\n    return;\n  }\n\n  // Otherwise, iterate through the list and remove observations that are older than the specified keep time\n  while (observations_.size() > 1) {\n    // If the first observation is not stale, stop\n    if (ros::Time::now() - observations_.front().header.stamp < ros::Duration(observation_keep_time_)) {\n      return;\n    }\n\n    // Otherwise, remove the first observation\n    observations_.erase(observations_.begin());\n  }\n}\n", "CodeBleu_score": 36.41174017823131}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)  // Get the yaw angles of the start and end poses\n  double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end yaw angles\n  double angular_distance = std::fmod(end_yaw - start_yaw + M_PI, 2.0 * M_PI) - M_PI;\n\n  // Calculate the incremental change in angle for each pose in the range\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the range\n  for (int i = start_index + 1; i <= end_index; ++i) {\n    double yaw = start_yaw + increment * (i - start_index);\n    tf::Quaternion q;\n    q.setRPY(0, 0, yaw);\n    path[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n  }\n}\n", "CodeBleu_score": 59.04047853826747}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)    // Get the yaw angles at the start and end indices\n    double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n    double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n    // Determine the shortest angular distance between the start and end angles\n    double angular_distance = std::abs(end_yaw - start_yaw);\n    if (angular_distance > M_PI) {\n        angular_distance = 2 * M_PI - angular_distance;\n    }\n\n    // Compute the incremental change in angle for each pose in the range\n    int num_poses = end_index - start_index + 1;\n    double increment = angular_distance / (num_poses - 1);\n\n    // Update the orientation of each pose in the range\n    for (int i = start_index; i <= end_index; ++i) {\n        double yaw = start_yaw + increment * (i - start_index);\n        tf::Quaternion quat;\n        quat.setRPY(0, 0, yaw);\n        path[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n    }\n}\n", "CodeBleu_score": 56.42355851373434}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)  // Get the yaw angles at the start and end indices\n  double start_yaw = tf::getYaw(path[start_index].pose.orientation);\n  double end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n  // Determine the shortest angular distance between the start and end yaw angles\n  double angular_distance = std::min(std::abs(end_yaw - start_yaw), 2 * M_PI - std::abs(end_yaw - start_yaw));\n\n  // Compute the incremental change in angle\n  double increment = angular_distance / (end_index - start_index);\n\n  // Update the orientation of each pose in the specified range\n  for (int i = start_index + 1; i < end_index; i++) {\n    // Get the current yaw angle\n    double yaw = tf::getYaw(path[i].pose.orientation);\n\n    // Update the yaw angle\n    yaw += increment;\n\n    // Wrap the yaw angle to [-pi, pi]\n    yaw = std::fmod(yaw, 2 * M_PI);\n    if (yaw > M_PI) {\n      yaw -= 2 * M_PI;\n    }\n    else if (yaw < -M_PI) {\n      yaw += 2 * M_PI;\n    }\n\n    // Set the new orientation\n    tf::Quaternion q;\n    q.setRPY(0, 0, yaw);\n    path[i].pose.orientation = tf::createQuaternionMsgFromYaw(yaw);\n  }\n}\n", "CodeBleu_score": 54.631388248702784}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)    // Set the frame_id of the start and goal to \"map\"\n    req.start.header.frame_id = \"map\";\n    req.goal.header.frame_id = \"map\";\n\n    // Call makePlan to generate a path\n    bool success = makePlan(req.start, req.goal, resp.plan);\n\n    // Update the response with the success status and the generated path if a plan is found\n    resp.plan.header.frame_id = \"map\";\n    resp.plan.header.stamp = ros::Time::now();\n    resp.success = success;\n\n    // Return true to indicate that the service was processed\n    return true;\n}\n", "CodeBleu_score": 62.99460354946661}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  bool found_plan = makePlan(req.start, req.goal, resp.plan.poses);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.header.stamp = ros::Time::now();\n  resp.success = found_plan;\n\n  // Return true to indicate that the service was processed\n  return true;\n}\n", "CodeBleu_score": 57.23497204614014}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)  ROS_INFO(\"PlannerWithCostmap::makePlanService\");\n\n  // Set the frame_id of the start and goal to \"map\"\n  req.start.header.frame_id = \"map\";\n  req.goal.header.frame_id = \"map\";\n\n  // Call makePlan to generate a path\n  bool success = makePlan(req.start, req.goal, resp.plan);\n\n  // Update the response with the success status and the generated path if a plan is found\n  resp.plan.header.frame_id = \"map\";\n  resp.plan.header.stamp = ros::Time::now();\n  resp.success = success;\n\n  // Return true to indicate that the service was processed\n  return true;\n}\n", "CodeBleu_score": 61.95546884804314}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    make_plan_service = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_subscriber = private_nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}\n", "CodeBleu_score": 58.55176226318019}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle private_nh(\"~/\" + name);\n    ros::NodeHandle nh;\n\n    private_nh.param(\"tolerance\", _tolerance, 0.05);\n    private_nh.param(\"max_plan_length\", _max_plan_length, 1000.0);\n\n    _plan_pub = private_nh.advertise<nav_msgs::Path>(\"plan\", 1);\n\n    _make_plan_srv = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    _goal_sub = nh.subscribe(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}\n", "CodeBleu_score": 54.52202184332842}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())    ros::NodeHandle nh;\n    make_plan_srv = nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n    goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}\n", "CodeBleu_score": 56.913175610927006}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)    if (wx < costmap->getOriginX() || wy < costmap->getOriginY()) {\n        return false;\n    }\n\n    mx = (wx - costmap->getOriginX()) / costmap->getResolution();\n    my = (wy - costmap->getOriginY()) / costmap->getResolution();\n\n    if (mx < costmap->getSizeInCellsX() && my < costmap->getSizeInCellsY()) {\n        return true;\n    }\n\n    return false;\n}\n", "CodeBleu_score": 47.87640064097209}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)    // Check if the world coordinates are within the bounds of the costmap's origin\n    if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n        return false;\n    }\n\n    // Calculate the map coordinates using the costmap's resolution and an offset\n    mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n    my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n    // Check if the map coordinates are within the costmap's size limits\n    if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n        return false;\n    }\n\n    return true;\n}\n", "CodeBleu_score": 47.653114925970954}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)  // Check if the world coordinates are within the bounds of the costmap's origin\n  if (wx < costmap_->getOriginX() || wy < costmap_->getOriginY()) {\n    return false;\n  }\n\n  // Calculate the map coordinates using the costmap's resolution and an offset\n  mx = (wx - costmap_->getOriginX()) / costmap_->getResolution();\n  my = (wy - costmap_->getOriginY()) / costmap_->getResolution();\n\n  // Check if the map coordinates are within the costmap's size limits\n  if (mx < 0 || my < 0 || mx >= costmap_->getSizeInCellsX() || my >= costmap_->getSizeInCellsY()) {\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 48.346466682750346}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   // Check if the planner is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // Create a Path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Copy the poses from the input path\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // Publish the Path message\n  plan_pub_.publish(gui_path);\n}", "CodeBleu_score": 95.78790042237738}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   // First check if the planner is initialized\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  // Create a Path message\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  gui_path.header.frame_id = frame_id_;\n  gui_path.header.stamp = ros::Time::now();\n\n  // Copy the poses from the input path\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  // Publish the Path message\n  plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 96.02516716057173}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path)   //ROS_INFO(\"Publishing plan with %zu points\", path.size());\n  if (!initialized_) {\n    ROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n    return;\n  }\n\n  //create a message for the plan\n  nav_msgs::Path gui_path;\n  gui_path.poses.resize(path.size());\n\n  if (!path.empty()) {\n    gui_path.header.frame_id = path[0].header.frame_id;\n    gui_path.header.stamp = path[0].header.stamp;\n  }\n  // Extract the plan in world co-ordinates, we assume the path is all in the same frame\n  for (unsigned int i = 0; i < path.size(); i++) {\n    gui_path.poses[i] = path[i];\n  }\n\n  plan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 87.19837830738527}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)    ROS_DEBUG(\"wrapping received PoseStamped goal in an action goal\");\n    MoveBaseActionGoal action_goal;\n    action_goal.header.stamp = ros::Time::now();\n    action_goal.goal.target_pose = *goal;\n    action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 69.12988737665957}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)    ROS_DEBUG(\"got new goal\");\n\n    // create the action message and fill in data\n    move_base_msgs::MoveBaseGoal action_goal;\n    action_goal.target_pose = *goal;\n    action_goal.target_pose.header.stamp = ros::Time::now();\n\n    // publish the goal\n    action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 53.9984338639778}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)  ROS_DEBUG(\"wrapping received goal in an action\");\n  move_base_msgs::MoveBaseGoal action_goal;\n  action_goal.target_pose = *goal;\n  action_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 44.67192141817632}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  // Check if the robot has moved far enough\n  if (sqrt(pow(current_x - previous_x, 2) + pow(current_y - previous_y, 2)) > distance) {\n    // Log a message\n    ROS_INFO(\"Moving %.2f meters\", distance);\n\n    // Join and delete any existing remove limit thread\n    if (remove_limit_thread.joinable()) {\n      remove_limit_thread.join();\n    }\n\n    // Start a new thread to remove the speed limit\n    remove_limit_thread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n\n    // Stop the distance check timer\n    distance_check_timer.stop();\n  }\n}\n", "CodeBleu_score": 46.633744957659395}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  double distance = sqrt(pow(current_x - initial_x, 2) + pow(current_y - initial_y, 2));\n  if (distance > distance_limit) {\n    ROS_INFO(\"Moving %f meters\", distance);\n    remove_limit_thread.join();\n    remove_limit_thread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    distance_check_timer.stop();\n  }\n}\n", "CodeBleu_score": 44.89185672480262}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)  // Check if the robot has moved far enough\n  if (squaredDistance(current_x, current_y, last_x, last_y) >= (distance_to_move * distance_to_move)) {\n    // Log a message\n    ROS_INFO(\"Robot has moved far enough, stopping distance check timer\");\n    // Join and delete any existing remove limit thread\n    if (remove_limit_thread.joinable()) {\n      remove_limit_thread.join();\n    }\n    // Start a new thread to remove the speed limit\n    remove_limit_thread = std::thread(&MoveSlowAndClear::removeSpeedLimit, this);\n    // Stop the distance check timer\n    distance_check_timer.stop();\n  }\n}\n", "CodeBleu_score": 52.5866684223917}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)    geometry_msgs::PoseStamped global_pose;\n    if (!costmap_->getRobotPose(global_pose)) {\n        return;\n    }\n    std::vector<geometry_msgs::PoseStamped> plan;\n    if (!makePlan(global_pose, *goal, plan)) {\n        return;\n    }\n    // Publish the plan as a Path message\n    publishPlan(plan);\n}\n", "CodeBleu_score": 55.09965760295821}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)    // Get the current global pose of the robot\n    rm::PoseStamped global_pose;\n    if (!costmap_ros_->getRobotPose(global_pose)) {\n        ROS_WARN(\"Could not get robot pose\");\n        return;\n    }\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> plan;\n    if (!makePlan(global_pose, *goal, plan)) {\n        ROS_WARN(\"Could not generate path\");\n        return;\n    }\n\n    // Publish the path as a Path message\n    rm::Path path_msg;\n    path_msg.header.stamp = ros::Time::now();\n    path_msg.header.frame_id = costmap_ros_->getGlobalFrameID();\n    path_msg.poses.resize(plan.size());\n    for (size_t i = 0; i < plan.size(); ++i) {\n        path_msg.poses[i].header = plan[i].header;\n        path_msg.poses[i].pose = plan[i].pose;\n    }\n    path_pub_.publish(path_msg);\n}", "CodeBleu_score": 47.364731562264204}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)    // Get the current global pose of the robot\n    geometry_msgs::PoseStamped current_pose;\n    if (!costmap_ros_->getRobotPose(current_pose)) {\n        ROS_WARN(\"Could not get current pose\");\n        return;\n    }\n\n    // Generate a path from the current pose to the goal pose\n    std::vector<geometry_msgs::PoseStamped> plan;\n    if (!makePlan(current_pose, goal->pose, plan)) {\n        ROS_WARN(\"Could not generate path\");\n        return;\n    }\n\n    // Publish the path\n    nav_msgs::Path path;\n    path.header.frame_id = costmap_ros_->getGlobalFrameID();\n    path.header.stamp = ros::Time::now();\n    path.poses = plan;\n    path_pub_.publish(path);\n}", "CodeBleu_score": 44.90049445241141}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)    param_set_client_.request.param_id = param_set.param_id;\n    param_set_client_.request.param_value = param_set.param_value;\n    param_set_client_.call(param_set_client_);\n}\n", "CodeBleu_score": 54.399124563540916}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)    std::string param_id = param_set.param_id;\n    int param_value = param_set.param_value;\n\n    param_set_client_.request.param_id = param_id;\n    param_set_client_.request.param_value = param_value;\n\n    if (param_set_client_.call(param_set_client_.request, param_set_client_.response)) {\n        ROS_INFO(\"Gimbal Param Set Server: %s\", param_set_client_.response.status_message.c_str());\n    } else {\n        ROS_ERROR(\"Failed to call Gimbal Param Set Server\");\n    }\n}\n", "CodeBleu_score": 45.15371804534115}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)    // Create the ParamSet service request\n    param_set_client_->request.param_id = param_set.param_id;\n    param_set_client_->request.value = param_set.value;\n\n    // Call the param_set_client_ to send the request\n    param_set_client_->call(param_set_client_);\n}\n", "CodeBleu_score": 52.08375911961759}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverSocket < 0) {\n        ROS_ERROR(\"Failed to create server socket\");\n        return;\n    }\n\n    struct sockaddr_in serverAddress;\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_addr.s_addr = INADDR_ANY;\n    serverAddress.sin_port = htons(serverPort);\n\n    if (bind(serverSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {\n        ROS_ERROR(\"Failed to bind server socket\");\n        return;\n    }\n\n    if (listen(serverSocket, 5) < 0) {\n        ROS_ERROR(\"Failed to listen on server socket\");\n        return;\n    }\n\n    ROS_INFO(\"Server listening on port %d\", serverPort);\n\n    while (ros::ok()) {\n        struct sockaddr_in clientAddress;\n        socklen_t clientAddressLength = sizeof(clientAddress);\n        int clientSocket = accept(serverSocket, (struct sockaddr *)&clientAddress, &clientAddressLength);\n        if (clientSocket < 0) {\n            ROS_ERROR(\"Failed to accept client connection\");\n            continue;\n        }\n\n        ROS_INFO(\"Accepted connection from %s:%d\", inet_ntoa(clientAddress.sin_addr), ntohs(clientAddress.sin_port));\n\n        while (ros::ok()) {\n            char buffer[1024];\n            int bytesRead = recv(clientSocket, buffer, sizeof(buffer), 0);\n            if (bytesRead <= 0) {\n                ROS_ERROR(\"Failed to receive data from client\");\n                break;\n            }\n\n            std::string message(buffer, bytesRead);\n            ROS_INFO(\"Received message: %s\", message.c_str());\n\n            if (message.length() <= 0) {\n                ROS_ERROR(\"Received empty message\");\n                break;\n            }\n\n            // Process the message here\n            // For example, you can parse it as JSON and extract the", "CodeBleu_score": 45.08729711346909}, {"code": "void CommunicationBridge::serverFun()    // Create a socket\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        ROS_ERROR(\"Failed to create socket\");\n        return;\n    }\n\n    // Bind the socket to a specific address and port\n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_addr.s_addr = INADDR_ANY;\n    server_address.sin_port = htons(server_port_);\n    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {\n        ROS_ERROR(\"Failed to bind socket\");\n        return;\n    }\n\n    // Listen for incoming connections\n    if (listen(server_socket, 1) == -1) {\n        ROS_ERROR(\"Failed to listen on socket\");\n        return;\n    }\n\n    ROS_INFO(\"Waiting for connection on port %d\", server_port_);\n\n    // Accept incoming connections\n    struct sockaddr_in client_address;\n    socklen_t client_address_len = sizeof(client_address);\n    int client_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_len);\n    if (client_socket == -1) {\n        ROS_ERROR(\"Failed to accept connection\");\n        return;\n    }\n\n    ROS_INFO(\"Connected to ground station\");\n\n    // Receive data from the ground station\n    char buffer[1024];\n    int bytes_received;\n    while (ros::ok()) {\n        bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            ROS_ERROR(\"Failed to receive data\");\n            break;\n        }\n\n        // Process the received data\n        std::string message(buffer, bytes_received);\n        ROS_INFO(\"Received message: %s\", message.c_str());\n\n        // Decode the message and", "CodeBleu_score": 43.413918022049444}, {"code": "void CommunicationBridge::serverFun()    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int opt = 1;\n    int addrlen = sizeof(address);\n    char buffer[1024] = {0};\n\n    // Creating socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Forcefully attaching socket to the port 8080\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(8080);\n\n    // Forcefully attaching socket to the port 8080\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Accepting incoming connections\n    while (true) {\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0) {\n            perror(\"accept\");\n            exit(EXIT_FAILURE);\n        }\n\n        // Receiving data from the client\n        valread = read(new_socket, buffer, 1024);\n        if (valread <= 0) {\n            // If no data is received, close the socket and continue to accept connections\n            close(new_socket);\n            continue;\n        }\n\n        // Decoding the message and publishing it\n        std::string message(buffer", "CodeBleu_score": 55.904255392836674}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)    // If in simulation mode, find the corresponding UAV by ID\n    if (simulation_mode_) {\n        // Find the UAV in the swarm\n        int uav_index = -1;\n        for (int i = 0; i < swarm_control_simulation_->uavs.size(); i++) {\n            if (uav_cmd.uav_id == swarm_control_simulation_->uavs[i].id) {\n                uav_index = i;\n                break;\n            }\n        }\n\n        // If the UAV was found, publish the command to it\n        if (uav_index != -1) {\n            swarm_control_simulation_->uavs[uav_index].cmd = uav_cmd;\n        }\n    } else {\n        // Publish the command to the UAV\n        uav_basic_.uav_cmd = uav_cmd;\n        uav_basic_.publish();\n    }\n}\n", "CodeBleu_score": 46.070923720584645}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)  if (!simulation_mode_) {\n    uav_basic_.publish(uav_cmd);\n  } else {\n    int uav_id = uav_cmd.uav_id;\n    if (uav_id < 0 || uav_id > swarm_control_simulation_->uav_list_.size()) {\n      ROS_WARN(\"[CommunicationBridge] Invalid UAV ID %d\", uav_id);\n      return;\n    }\n    uav_basic_.publish(uav_cmd);\n  }\n}\n", "CodeBleu_score": 34.37390768201328}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)  if (!simulation_mode_) {\n    uav_basic_.publish(uav_cmd);\n  } else {\n    for (int i = 0; i < swarm_control_simulation_.uavs.size(); i++) {\n      if (uav_cmd.id == swarm_control_simulation_.uavs[i].id) {\n        uav_basic_.publish(uav_cmd);\n        break;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 34.3630680247169}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.mode == MODE_REBOOTNX) {\n        system(\"rebootnx\");\n    }\n    else if (mode_selection.mode == MODE_EXITNX) {\n        system(\"exitnx\");\n    }\n    else {\n        if (mode_selection.use_mode) {\n            createMode(mode_selection.mode);\n        }\n        else {\n            deleteMode(mode_selection.mode);\n        }\n    }\n}\n", "CodeBleu_score": 48.78336386295605}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.mode == MODE_REBOOTNX) {\n        system(\"rebootnx\");\n    } else if (mode_selection.mode == MODE_EXITNX) {\n        system(\"exitnx\");\n    } else if (mode_selection.use_mode) {\n        createMode(mode_selection);\n    } else {\n        deleteMode(mode_selection);\n    }\n}\n", "CodeBleu_score": 57.21051322675152}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)    if (mode_selection.mode == Mode::REBOOTNX) {\n        system(\"rebootnx\");\n    }\n    else if (mode_selection.mode == Mode::EXITNX) {\n        system(\"exitnx\");\n    }\n    else if (mode_selection.use_mode) {\n        createMode(mode_selection);\n    }\n    else {\n        deleteMode(mode_selection);\n    }\n}\n", "CodeBleu_score": 58.8841321459043}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    if (heartbeat_status == false) {\n        heartbeat_count++;\n        if (heartbeat_count >= heartbeat_max_count) {\n            ROS_ERROR(\"Heartbeat lost. Disconnecting from the vehicle.\");\n            disconnect_flag = true;\n            if (vehicle_type == \"swarm\") {\n                // Disconnect from the vehicle\n            } else if (vehicle_type == \"UAV\") {\n                // Disconnect from the vehicle\n            } else if (vehicle_type == \"UGV\") {\n                // Disconnect from the vehicle\n            }\n        }\n    } else {\n        heartbeat_count = 0;\n    }\n}\n", "CodeBleu_score": 24.23514224014039}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    // Increment the heartbeat count\n    heartbeat_count++;\n\n    // If the heartbeat count exceeds the threshold, print an error message and trigger appropriate actions\n    if (heartbeat_count > heartbeat_threshold) {\n        ROS_ERROR(\"Heartbeat lost, attempting to reconnect\");\n        heartbeat_count = 0;\n        if (vehicle_type == \"swarm\") {\n            // Code to handle swarm vehicle disconnection\n        } else if (vehicle_type == \"UAV\") {\n            // Code to handle UAV disconnection\n        } else if (vehicle_type == \"UGV\") {\n            // Code to handle UGV disconnection\n        }\n    }\n\n    // Reset the heartbeat count if a heartbeat is received\n    if (heartbeat_received) {\n        heartbeat_count = 0;\n        heartbeat_received = false;\n    }\n}", "CodeBleu_score": 31.469639513202562}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)    if (heartbeat_count_ == heartbeat_threshold_) {\n        if (vehicle_type_ == VehicleType::UGV) {\n            ROS_ERROR(\"[CommunicationBridge] Lost connection to UGV. Disconnecting...\");\n            disconnect_flag_ = true;\n        } else if (vehicle_type_ == VehicleType::UAV) {\n            ROS_ERROR(\"[CommunicationBridge] Lost connection to UAV. Disconnecting...\");\n            disconnect_flag_ = true;\n        } else if (vehicle_type_ == VehicleType::Swarm) {\n            ROS_ERROR(\"[CommunicationBridge] Lost connection to swarm. Disconnecting...\");\n            disconnect_flag_ = true;\n        }\n    }\n    heartbeat_count_++;\n}\n", "CodeBleu_score": 32.25204080984202}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    std::cout << \"MultiBsplines received\" << std::endl;\n    // Loop through the MultiBsplines message\n    for (int i = 0; i < msg->bsplines.size(); i++) {\n        // Extract the drone ID from the message\n        std::string drone_id = msg->bsplines[i].drone_id;\n        // Initialize a Bspline struct\n        Bspline bspline;\n        // Set the attributes of the Bspline struct\n        bspline.drone_id = drone_id;\n        bspline.num_knots = msg->bsplines[i].num_knots;\n        bspline.num_points = msg->bsplines[i].num_points;\n        bspline.num_yaw_points = msg->bsplines[i].num_yaw_points;\n        bspline.knots = msg->bsplines[i].knots;\n        bspline.points = msg->bsplines[i].points;\n        bspline.yaw_points = msg->bsplines[i].yaw_points;\n        // Populate the knots, position points, and yaw points of the Bspline struct\n        bspline.knots.resize(bspline.num_knots);\n        bspline.points.resize(bspline.num_points);\n        bspline.yaw_points.resize(bspline.num_yaw_points);\n        for (int j = 0; j < bspline.num_knots; j++) {\n            bspline.knots[j] = msg->bsplines[i].knots[j];\n        }\n        for (int j = 0; j < bspline.num_points; j++) {\n            bspline.points[j].x = msg->bsplines[i].points[j].x;\n            bspline.points[j].y = msg->bsplines[i].points[j].y;\n            bspline.points[j", "CodeBleu_score": 53.72849608650924}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    // Extract the drone ID from the message\n    int drone_id = msg->drone_id;\n\n    // Initialize a Bspline struct for each trajectory in the message\n    std::vector<Bspline> bsplines;\n    for (int i = 0; i < msg->trajectories.size(); i++) {\n        Bspline bspline;\n        bspline.drone_id = drone_id;\n        bspline.trajectory_id = i;\n        bspline.knots = msg->trajectories[i].knots;\n        bspline.pos_pts = msg->trajectories[i].pos_pts;\n        bspline.yaw_pts = msg->trajectories[i].yaw_pts;\n        bspline.start_time = msg->trajectories[i].start_time;\n        bspline.end_time = msg->trajectories[i].end_time;\n        bsplines.push_back(bspline);\n    }\n\n    // Encode the MultiBsplines data and send it via TCP using the communication module\n    std::string encoded_data = encodeMultiBsplines(bsplines);\n    comm_->sendTcp(encoded_data);\n}\n", "CodeBleu_score": 41.373396620145854}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)    // Extract drone ID from message\n    int drone_id = msg->drone_id;\n    // Initialize Bspline struct for this drone\n    Bspline bspline;\n    // Set Bspline attributes\n    bspline.drone_id = drone_id;\n    bspline.knot_num = msg->knot_num;\n    bspline.knots = msg->knots;\n    bspline.pos_pts = msg->pos_pts;\n    bspline.yaw_pts = msg->yaw_pts;\n    // Populate Bspline struct with trajectory data\n    // Encode MultiBsplines data\n    // Send MultiBsplines data via TCP using communication module\n}\n", "CodeBleu_score": 12.613880267160878}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.01);\n    octree.setInputCloud(cloud);\n    octree.defineCompressionOctree(cloud);\n    std::vector<int> pointIdxVector;\n    octree.getOccupiedVoxelCenters(pointIdxVector);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr compressed_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::copyPointCloud(*cloud, pointIdxVector, *compressed_cloud);\n    sensor_msgs::PointCloud2 compressed_msg;\n    pcl::toROSMsg(*compressed_cloud, compressed_msg);\n    compressed_msg.header = msg.header;\n    return compressed_msg;\n}\n", "CodeBleu_score": 40.709313928164384}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.1);\n    octree.setInputCloud(cloud);\n    octree.defineRegions(1000);\n\n    std::vector<int> pointIdxVector;\n    octree.getOccupiedVoxelCenters(pointIdxVector);\n\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::copyPointCloud(*cloud, pointIdxVector, *cloud_filtered);\n\n    sensor_msgs::PointCloud2 output;\n    pcl::toROSMsg(*cloud_filtered, output);\n    output.header = msg.header;\n    output.height = 1;\n    output.width = cloud_filtered->size();\n    output.is_bigendian = false;\n    output.is_dense = true;\n    return output;\n}\n", "CodeBleu_score": 43.81552119066169}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)    // Convert the PointCloud2 message to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(msg, *cloud);\n\n    // Compress the point cloud using an octree compression technique\n    pcl::octree::OctreePointCloudCompression<pcl::PointXYZ> octree(0.01);\n    octree.setInputCloud(cloud);\n    octree.addPointsFromInputCloud();\n    octree.switchBuffers();\n    std::vector<int> pointIdxVec;\n    octree.getOccupiedVoxelCenters(pointIdxVec);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr compressedCloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::copyPointCloud(*cloud, pointIdxVec, *compressedCloud);\n\n    // Convert the compressed point cloud back to a PointCloud2 message\n    sensor_msgs::PointCloud2 compressedMsg;\n    pcl::toROSMsg(*compressedCloud, compressedMsg);\n\n    // Release dynamically allocated memory\n    cloud.reset();\n    compressedCloud.reset();\n\n    return compressedMsg;\n}\n", "CodeBleu_score": 41.0414050956453}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)  for (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n      multi_uav_state_[i] = uav_state;\n      break;\n    }\n  }\n}\n", "CodeBleu_score": 60.25900866277198}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)  for (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n      multi_uav_state_[i] = uav_state;\n    }\n  }\n}\n", "CodeBleu_score": 54.66880153663588}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)  for (int i = 0; i < multi_uav_state_.size(); i++) {\n    if (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n      multi_uav_state_[i] = uav_state;\n      return;\n    }\n  }\n}\n", "CodeBleu_score": 55.868086373013725}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    MultiUGVState m_multi_ugv_state_msg;\n    m_multi_ugv_state_msg.header.stamp = ros::Time::now();\n    m_multi_ugv_state_msg.header.frame_id = \"world\";\n    m_multi_ugv_state_msg.header.seq = m_multi_ugv_state_msg.header.seq + 1;\n    m_multi_ugv_state_msg.num_ugvs = m_multi_ugv_state.num_ugvs;\n\n    for (int i = 0; i < m_multi_ugv_state.num_ugvs; i++) {\n        UGVState ugv_state_msg;\n        ugv_state_msg.id = m_multi_ugv_state.ugv_state[i].id;\n        ugv_state_msg.battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state_msg.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        ugv_state_msg.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        ugv_state_msg.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        ugv_state_msg.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        ugv_state_msg.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        ugv_state_msg.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        ugv_state_msg.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        ugv_state_msg.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n        ugv_", "CodeBleu_score": 44.05290066710978}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    // Initialize the message\n    ugv_swarm_msgs::MultiUGVState msg;\n    msg.header.stamp = ros::Time::now();\n    msg.header.frame_id = \"world\";\n    msg.header.seq = seq_count;\n    msg.ugv_count = m_multi_ugv_state.ugv_count;\n\n    // Iterate through each UGV state in the structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n        ugv_swarm_msgs::UGVState ugv_state;\n        ugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n        ugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state.position = m_multi_ugv_state.ugv_state[i].position;\n        ugv_state.velocity = m_multi_ugv_state.ugv_state[i].velocity;\n        ugv_state.attitude = m_multi_ugv_state.ugv_state[i].attitude;\n        msg.ugv_state.push_back(ugv_state);\n    }\n\n    // Publish the message\n    all_ugv_state_pub.publish(msg);\n}\n", "CodeBleu_score": 44.975094053772686}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)    // Initialize the MultiUGVState message\n    swarm_msgs::MultiUGVState ugv_state_msg;\n    ugv_state_msg.header.stamp = ros::Time::now();\n\n    // Iterate through each UGV state in the provided MultiUGVState structure\n    for (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n        // Initialize the UGVState message for the current UGV\n        swarm_msgs::UGVState ugv_state;\n        ugv_state.header.stamp = ros::Time::now();\n        ugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n        ugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n        ugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n        ugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n        ugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n        ugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n        ugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n        ugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n        ugv_state.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n        ugv_state.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n        ugv_state.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n        ugv_state.attitude.", "CodeBleu_score": 44.741259368386196}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    cost = 0;\n    gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n    for (int i = 0; i < q.rows(); i++) {\n        Eigen::Vector3d q_i = q.row(i);\n        Eigen::Vector3d q_i_pred = Eigen::Vector3d::Zero();\n        double q_i_pred_t = i * _time_step;\n        for (int j = 0; j < _moving_obj_traj.size(); j++) {\n            q_i_pred += _moving_obj_traj[j]->evaluate(q_i_pred_t);\n        }\n        double dist = (q_i - q_i_pred).norm();\n        if (dist < _moving_obj_clearance) {\n            double cost_i = std::pow(dist - _moving_obj_clearance, 2);\n            cost += cost_i;\n            Eigen::Vector3d grad_i = q_i - q_i_pred;\n            gradient.row(i) += grad_i;\n        }\n    }\n}\n", "CodeBleu_score": 42.74758974646729}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  cost = 0.0;\n  gradient.setZero();\n\n  // Iterate through control points\n  for (int i = 0; i < q.rows(); i++) {\n    // Compute predicted positions of moving objects\n    Eigen::Vector3d q_pred = q.row(i).transpose();\n    Eigen::Vector3d q_pred_obj1 = q_pred + obj1_vel * i * dt;\n    Eigen::Vector3d q_pred_obj2 = q_pred + obj2_vel * i * dt;\n\n    // Evaluate distance between control point and predicted positions of moving objects\n    double dist_obj1 = (q_pred_obj1 - q.row(i).transpose()).norm();\n    double dist_obj2 = (q_pred_obj2 - q.row(i).transpose()).norm();\n\n    // Update cost and gradient based on distance error\n    if (dist_obj1 < clearance) {\n      cost += (clearance - dist_obj1) * (clearance - dist_obj1);\n      gradient.row(i) += 2 * (clearance - dist_obj1) * (q_pred_obj1 - q.row(i).transpose());\n    }\n    if (dist_obj2 < clearance) {\n      cost += (clearance - dist_obj2) * (clearance - dist_obj2);\n      gradient.row(i) += 2 * (clearance - dist_obj2) * (q_pred_obj2 - q.row(i).transpose());\n    }\n  }\n}\n", "CodeBleu_score": 38.42908106773284}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    // TODO: implement this\n    // cost = 0;\n    // gradient = Eigen::MatrixXd::Zero(num_joints_, num_control_points_);\n    // std::cout << \"calcMovingObjCost\" << std::endl;\n    // std::cout << \"q.rows: \" << q.rows() << std::endl;\n    // std::cout << \"q.cols: \" << q.cols() << std::endl;\n    // std::cout << \"q: \" << q << std::endl;\n    // std::cout << \"num_joints_: \" << num_joints_ << std::endl;\n    // std::cout << \"num_control_points_: \" << num_control_points_ << std::endl;\n    // std::cout << \"control_points_: \" << control_points_ << std::endl;\n    // std::cout << \"moving_objects_: \" << moving_objects_ << std::endl;\n    // std::cout << \"clearance_: \" << clearance_ << std::endl;\n    // std::cout << \"weight_moving_object_: \" << weight_moving_object_ << std::endl;\n    // std::cout << \"weight_moving_object_der_: \" << weight_moving_object_der_ << std::endl;\n    // std::cout << \"weight_moving_object_der2_: \" << weight_moving_object_der2_ << std::endl;\n    // std::cout << \"weight_moving_object_der3_: \" << weight_moving_object_der3_ << std::endl;\n    // std::cout << \"weight_moving_object_der4_: \" << weight_moving_object_der4_ << std::endl;\n    // std::cout << \"weight_moving_object_der5_: \" << weight_moving_object_der5_ << std::endl;\n    // std::cout << \"weight_moving_object_der6_: \" << weight_moving_object_der6_ << std::endl", "CodeBleu_score": 3.6171778135476935}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)  cost = 0.0;\n  gradient.setZero();\n  for (int i = 0; i < q.cols(); i++) {\n    // Compute the error vector and velocity vector\n    Eigen::Vector3d error = q.col(i) - reference_points_.col(i);\n    Eigen::Vector3d velocity = (i == 0) ? Eigen::Vector3d::Zero() : (q.col(i) - q.col(i - 1));\n\n    // Compute the squared dot product of the error and velocity vectors\n    double dot_product = error.dot(velocity);\n    double dot_product_cost = dot_product * dot_product;\n\n    // Compute the squared cross product of the error and velocity vectors\n    Eigen::Vector3d cross_product = error.cross(velocity);\n    double cross_product_cost = cross_product.dot(cross_product);\n\n    // Compute the cost and gradient\n    double point_cost = a2_ * dot_product_cost + b2_ * cross_product_cost;\n    cost += point_cost;\n\n    Eigen::Vector3d point_gradient = 2.0 * a2_ * dot_product * error + 4.0 * b2_ * cross_product_cost * cross_product;\n    gradient.col(i) = point_gradient;\n  }\n}\n", "CodeBleu_score": 38.6270736660718}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    cost = 0;\n    gradient.setZero();\n\n    for (int i = 0; i < q.rows(); i++) {\n        double a2 = pow(a, 2);\n        double b2 = pow(b, 2);\n\n        // Compute positional error relative to reference points\n        Eigen::Vector3d e = q.row(i).transpose() - q_ref.row(i).transpose();\n\n        // Compute velocity vector\n        Eigen::Vector3d v = (i < q.rows() - 1) ? (q.row(i + 1).transpose() - q.row(i).transpose()) : (q.row(i).transpose() - q.row(i - 1).transpose());\n\n        // Compute squared dot product and cross product\n        double dot_product = e.dot(v);\n        Eigen::Vector3d cross_product = e.cross(v);\n\n        // Update cost and gradient\n        cost += a2 * pow(dot_product, 2) + b2 * pow(cross_product.norm(), 2);\n        gradient.row(i) += a2 * 2 * dot_product * v.transpose() + 2 * b2 * cross_product.dot(e) / cross_product.norm() * cross_product.transpose();\n    }\n}\n", "CodeBleu_score": 38.03906733055847}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)    // Initialize cost and gradient to zero\n    cost = 0.0;\n    gradient.setZero();\n\n    // Iterate through control points of trajectory\n    for (int i = 0; i < q.rows(); i++) {\n        // Compute positional error relative to reference points\n        Eigen::Vector3d pos_error = q.row(i) - ref_points_.row(i);\n\n        // Compute velocity vector\n        Eigen::Vector3d vel = (i == 0) ? (q.row(1) - q.row(0)) : (q.row(i + 1) - q.row(i - 1));\n\n        // Compute squared dot product of positional error and velocity\n        double dot_prod = pos_error.dot(vel);\n        double dot_prod_sq = dot_prod * dot_prod;\n\n        // Compute squared cross product of positional error and velocity\n        Eigen::Vector3d cross_prod = pos_error.cross(vel);\n        double cross_prod_sq = cross_prod.squaredNorm();\n\n        // Compute cost and gradient\n        double a2 = 0.001;\n        double b2 = 0.001;\n        double c2 = 0.001;\n        double d2 = 0.001;\n        double e2 = 0.001;\n        double f2 = 0.001;\n        double g2 = 0.001;\n        double h2 = 0.001;\n        double i2 = 0.001;\n        double j2 = 0.001;\n        double k2 = 0.001;\n        double l2 = 0.001;\n        double m2 = 0.001;\n        double n2 = 0.001;\n        double o2 = 0.001;\n        double p2 = 0.001;\n        double q2 = 0.001;\n        double r2 = 0.001;\n        double s2 = 0.001;\n        double t2 = 0.001;\n        double u2 = 0.001", "CodeBleu_score": 28.473290239769085}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()    // Compute the third derivative of the spline to obtain the jerk trajectory\n    UniformBspline jerkSpline = this->getThirdDerivative();\n\n    // Get the knot times and control points of the jerk trajectory\n    std::vector<double> knotTimes = jerkSpline.getKnotTimes();\n    std::vector<std::vector<double>> controlPoints = jerkSpline.getControlPoints();\n\n    // Initialize the total jerk value to 0\n    double totalJerk = 0;\n\n    // Iterate through the control points and dimensions\n    for (int i = 0; i < controlPoints.size(); i++) {\n        for (int j = 0; j < controlPoints[i].size(); j++) {\n            // Sum the squared control point values multiplied by the differences in knot times\n            totalJerk += controlPoints[i][j] * controlPoints[i][j] * (knotTimes[i+1] - knotTimes[i]);\n        }\n    }\n\n    // Return the total jerk value\n    return totalJerk;\n}\n", "CodeBleu_score": 42.37315280113339}, {"code": "double UniformBspline::getJerk()    double jerk = 0;\n    for (int i = 0; i < this->getNumControlPoints(); i++) {\n        for (int j = 0; j < this->getDimension(); j++) {\n            jerk += pow(this->getControlPoint(i, j), 2) * (this->getKnotTime(i + 3) - this->getKnotTime(i));\n        }\n    }\n    return jerk;\n}\n", "CodeBleu_score": 32.96546060316763}, {"code": "double UniformBspline::getJerk()    double jerk = 0;\n    double knot_time = 0;\n    double knot_time_diff = 0;\n    double knot_time_diff_sq = 0;\n    double knot_time_diff_cub = 0;\n    double knot_time_diff_qua = 0;\n    double knot_time_diff_qui = 0;\n    double knot_time_diff_sex = 0;\n    double knot_time_diff_sep = 0;\n    double knot_time_diff_oct = 0;\n    double knot_time_diff_non = 0;\n    double knot_time_diff_dec = 0;\n    double knot_time_diff_undec = 0;\n    double knot_time_diff_duodec = 0;\n    double knot_time_diff_tredec = 0;\n    double knot_time_diff_quattuordec = 0;\n    double knot_time_diff_sexdec = 0;\n    double knot_time_diff_septendec = 0;\n    double knot_time_diff_octodec = 0;\n    double knot_time_diff_novendec = 0;\n    double knot_time_diff_vigintioctodec = 0;\n    double knot_time_diff_trigintioctodec = 0;\n    double knot_time_diff_quadragintioctodec = 0;\n    double knot_time_diff_quinquagintioctodec = 0;\n    double knot_time_diff_sexagintioctodec = 0;\n    double knot_time_diff_septuagintioctodec = 0;\n    double knot_time_diff_octogintioctodec = 0;\n    double knot_time_diff_nonagintioctodec = 0;\n    double knot_time_diff_duodecagintioctodec = 0;\n    double knot_time_diff_tredecagintioctodec = 0;\n    double knot_time_diff_quattuordecagintioctodec = 0;\n    double knot_time_diff_sexdecagintioctodec = 0;\n    double", "CodeBleu_score": 8.02794991225645}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)     Eigen::Vector4d p;\n    p << (u - cx_) / fx_ * depth, (v - cy_) / fy_ * depth, depth, 1;\n    return p;\n}\n", "CodeBleu_score": 40.68005475486449}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)     Eigen::Vector4d pos;\n    pos(0) = (u - cx_) * depth / fx_;\n    pos(1) = (v - cy_) * depth / fy_;\n    pos(2) = depth;\n    pos(3) = 1.0;\n    return pos;\n}\n", "CodeBleu_score": 75.88734546841431}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth)   Eigen::Vector4d pos;\n  pos[0] = (u - cx_) * depth / fx_;\n  pos[1] = (v - cy_) * depth / fy_;\n  pos[2] = depth;\n  pos[3] = 1.0;\n  return pos;\n}\n", "CodeBleu_score": 63.80648078928135}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)    try {\n        rcvDroneOdomCallbackBase(odom.pose.pose, odom.child_frame_id);\n    } catch (const std::exception& e) {\n        ROS_ERROR_STREAM(\"Error in DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n    }\n}\n", "CodeBleu_score": 41.35844615749843}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)    try {\n        int drone_id = std::stoi(odom.child_frame_id.substr(1, odom.child_frame_id.size()));\n        rcvDroneOdomCallbackBase(odom, drone_id);\n    } catch (const std::exception& e) {\n        ROS_ERROR(\"Error: %s\", e.what());\n    }\n}\n", "CodeBleu_score": 56.7228338255414}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)    try {\n        int droneID = stoi(odom.child_frame_id.substr(1));\n        rcvDroneOdomCallbackBase(odom, droneID);\n    } catch (const std::invalid_argument& ia) {\n        ROS_ERROR(\"Invalid argument: %s\", ia.what());\n    }\n}\n", "CodeBleu_score": 50.80942412493783}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // Find the true pose of the drone in the camera frame\n    Eigen::Vector3d true_pose;\n    if (!find_true_pose(drone_id, true_pixel, true_pose)) {\n        // If the drone is not found, update the debug result and return\n        debug_result_.drone_found = false;\n        return;\n    }\n\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = true_pose - camera_pose_;\n\n    // Update the debug result with the pose error\n    debug_result_.drone_found = true;\n    debug_result_.pose_error = pose_error;\n\n    // Publish the pose error\n    publish_pose_error(pose_error);\n}\n", "CodeBleu_score": 26.98735072296994}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)    // Compute the true position of the drone in the camera frame\n    Eigen::Vector3f true_position = camera_model_.pixelToCamera(true_pixel, 1.0);\n\n    // Check if the drone is in the camera frame\n    if (true_position(2) < 0) {\n        // Drone is behind the camera, so it is not visible\n        debug_result_.found = false;\n        debug_result_.error = Eigen::Vector3f::Zero();\n        return;\n    }\n\n    // Compute the true pose of the drone in the world frame\n    Eigen::Vector3f true_drone_position = drone_model_.getPosition(drone_id);\n    Eigen::Quaternionf true_drone_orientation = drone_model_.getOrientation(drone_id);\n    Eigen::Vector3f true_drone_position_world = camera_model_.cameraToWorld(true_drone_position, true_drone_orientation);\n\n    // Compute the error between the true pose and the estimated pose\n    Eigen::Vector3f error = true_drone_position_world - debug_result_.estimated_drone_position;\n\n    // Update the debug result\n    debug_result_.found = true;\n    debug_result_.error = error;\n\n    // Publish the pose error\n    pose_error_pub_.publish(error);\n}\n", "CodeBleu_score": 32.059819191568465}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)  // Compute the true pose of the drone in the camera frame\n  Eigen::Vector3d true_pose = camera_model.pixelToCameraRay(true_pixel);\n\n  // Check if the drone is in the camera frame\n  if (true_pose(2) > 0) {\n    // Compute the pose error between the camera and world coordinates\n    Eigen::Vector3d pose_error = true_pose - drone_poses[drone_id];\n\n    // Update the debug result\n    debug_result.drone_id = drone_id;\n    debug_result.true_pixel = true_pixel;\n    debug_result.true_pose = true_pose;\n    debug_result.pose_error = pose_error;\n    debug_result.found = true;\n\n    // Publish the pose error\n    pose_error_pub.publish(pose_error);\n  } else {\n    // Update the debug result to indicate failure\n    debug_result.found = false;\n  }\n}\n", "CodeBleu_score": 36.742733308127804}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        path.push_back(current->cameFrom);\n        current = current->cameFrom;\n    }\n    return path;\n}\n", "CodeBleu_score": 81.56250944056094}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->cameFrom != nullptr) {\n        current = current->cameFrom;\n        path.push_back(current);\n    }\n    return path;\n}", "CodeBleu_score": 90.00937038904927}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)    vector<GridNodePtr> path;\n    path.push_back(current);\n    while (current->parent != nullptr) {\n        current = current->parent;\n        path.push_back(current);\n    }\n    return path;\n}\n", "CodeBleu_score": 79.750598820814}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)  // Convert the start and end points to indices\n  start_idx = ConvertToIndex(start_pt);\n  end_idx = ConvertToIndex(end_pt);\n\n  // Check if the start or end point is inside an obstacle\n  if (IsInsideObstacle(start_idx) || IsInsideObstacle(end_idx)) {\n    // Adjust the start or end point if it is inside an obstacle\n    if (IsInsideObstacle(start_idx)) {\n      // Adjust the start point by moving it away from the end point\n      while (IsInsideObstacle(start_idx)) {\n        start_idx = start_idx - (end_idx - start_idx).normalized();\n      }\n    } else {\n      // Adjust the end point by moving it away from the start point\n      while (IsInsideObstacle(end_idx)) {\n        end_idx = end_idx - (start_idx - end_idx).normalized();\n      }\n    }\n  }\n\n  // Check if the adjusted start or end point is still inside an obstacle\n  if (IsInsideObstacle(start_idx) || IsInsideObstacle(end_idx)) {\n    // If so, the conversion or adjustment failed\n    return false;\n  }\n\n  // If the adjusted start and end points are not inside obstacles, the conversion or adjustment was successful\n  return true;\n}\n", "CodeBleu_score": 38.22169118233929}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)  // Convert start and end points to indices\n  start_idx = GridIndex(start_pt, params_.resolution);\n  end_idx = GridIndex(end_pt, params_.resolution);\n\n  // Check if the start and end points are inside obstacles\n  if (IsOccupied(start_idx) || IsOccupied(end_idx)) {\n    // If so, adjust the start and end points until they are no longer inside obstacles\n    while (IsOccupied(start_idx) || IsOccupied(end_idx)) {\n      // Move the start point away from the end point\n      start_idx = AdjustStart(start_idx, end_idx);\n      // Move the end point away from the start point\n      end_idx = AdjustEnd(end_idx, start_idx);\n    }\n  }\n\n  // Check if the start and end points are still inside obstacles\n  if (IsOccupied(start_idx) || IsOccupied(end_idx)) {\n    // If so, the conversion or adjustment failed\n    return false;\n  }\n\n  return true;\n}\n", "CodeBleu_score": 35.15710048979884}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)  // Convert start and end points to grid indices\n  start_idx = Vector3i(floor(start_pt.x() / m_res), floor(start_pt.y() / m_res), floor(start_pt.z() / m_res));\n  end_idx = Vector3i(floor(end_pt.x() / m_res), floor(end_pt.y() / m_res), floor(end_pt.z() / m_res));\n\n  // Check if start or end point is inside an obstacle\n  if (m_obstacles.find(start_idx) != m_obstacles.end() || m_obstacles.find(end_idx) != m_obstacles.end()) {\n    // If so, adjust the point by moving it away from the other point until it is no longer in an obstacle\n    Vector3d adjusted_start_pt = start_pt;\n    Vector3d adjusted_end_pt = end_pt;\n    while (m_obstacles.find(Vector3i(floor(adjusted_start_pt.x() / m_res), floor(adjusted_start_pt.y() / m_res), floor(adjusted_start_pt.z() / m_res))) != m_obstacles.end() ||\n           m_obstacles.find(Vector3i(floor(adjusted_end_pt.x() / m_res), floor(adjusted_end_pt.y() / m_res), floor(adjusted_end_pt.z() / m_res))) != m_obstacles.end()) {\n      if (m_obstacles.find(Vector3i(floor(adjusted_start_pt.x() / m_res), floor(adjusted_start_pt.y() / m_res), floor(adjusted_start_pt.z() / m_res))) != m_obstacles.end()) {\n        adjusted_start_pt = adjusted_start_pt + (end_pt - start_pt).normalized() * m_res;\n      }\n      if (m_obstacles.find(Vector3i(floor", "CodeBleu_score": 38.530610873224646}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  // Convert the minimum and maximum positions to grid indices\n  int min_id_x = static_cast<int>((min_pos.x() - origin_.x()) / resolution_);\n  int min_id_y = static_cast<int>((min_pos.y() - origin_.y()) / resolution_);\n  int min_id_z = static_cast<int>((min_pos.z() - origin_.z()) / resolution_);\n  int max_id_x = static_cast<int>((max_pos.x() - origin_.x()) / resolution_);\n  int max_id_y = static_cast<int>((max_pos.y() - origin_.y()) / resolution_);\n  int max_id_z = static_cast<int>((max_pos.z() - origin_.z()) / resolution_);\n\n  // Iterate over the grid coordinates and reset the occupancy and distance buffers\n  for (int id_x = min_id_x; id_x <= max_id_x; id_x++) {\n    for (int id_y = min_id_y; id_y <= max_id_y; id_y++) {\n      for (int id_z = min_id_z; id_z <= max_id_z; id_z++) {\n        int index = getIndex(id_x, id_y, id_z);\n        occupancy_buffer_inflate_(index) = 0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 38.13368782954684}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  int min_x = std::floor(min_pos.x() / grid_resolution_);\n  int min_y = std::floor(min_pos.y() / grid_resolution_);\n  int min_z = std::floor(min_pos.z() / grid_resolution_);\n  int max_x = std::ceil(max_pos.x() / grid_resolution_);\n  int max_y = std::ceil(max_pos.y() / grid_resolution_);\n  int max_z = std::ceil(max_pos.z() / grid_resolution_);\n  for (int x = min_x; x < max_x; x++) {\n    for (int y = min_y; y < max_y; y++) {\n      for (int z = min_z; z < max_z; z++) {\n        int id = getIndex(x, y, z);\n        occupancy_buffer_inflate_[id] = 0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 43.093871542261596}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)  // Get the indices of the min and max position\n  Eigen::Vector3i min_id = getGridIndex(min_pos);\n  Eigen::Vector3i max_id = getGridIndex(max_pos);\n\n  // Iterate over the grid indices and reset the occupancy buffer\n  for (int i = min_id.x(); i <= max_id.x(); i++) {\n    for (int j = min_id.y(); j <= max_id.y(); j++) {\n      for (int k = min_id.z(); k <= max_id.z(); k++) {\n        occupancy_buffer_inflate_(i, j, k) = 0;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 39.0600197012102}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)  Eigen::Vector3d pt_in_map;\n  Eigen::Vector3d diff = pt - camera_pt;\n  double min_x_scale = 1.0;\n  double min_y_scale = 1.0;\n  double min_z_scale = 1.0;\n  if (diff[0] > 0) {\n    min_x_scale = (map_size_[0] - camera_pt[0]) / diff[0];\n  } else if (diff[0] < 0) {\n    min_x_scale = -camera_pt[0] / diff[0];\n  }\n  if (diff[1] > 0) {\n    min_y_scale = (map_size_[1] - camera_pt[1]) / diff[1];\n  } else if (diff[1] < 0) {\n    min_y_scale = -camera_pt[1] / diff[1];\n  }\n  if (diff[2] > 0) {\n    min_z_scale = (map_size_[2] - camera_pt[2]) / diff[2];\n  } else if (diff[2] < 0) {\n    min_z_scale = -camera_pt[2] / diff[2];\n  }\n  double min_scale = std::min(std::min(min_x_scale, min_y_scale), min_z_scale);\n  pt_in_map = pt + min_scale * diff;\n  return pt_in_map;\n}\n", "CodeBleu_score": 37.4606863007528}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)    Eigen::Vector3d diff = pt - camera_pt;\n    Eigen::Vector3d closest_pt = pt;\n    double min_scale_x = (diff.x() > 0) ? (map_size_x - camera_pt.x()) / diff.x() : 0;\n    double max_scale_x = (diff.x() < 0) ? (-camera_pt.x()) / diff.x() : 1;\n    double min_scale_y = (diff.y() > 0) ? (map_size_y - camera_pt.y()) / diff.y() : 0;\n    double max_scale_y = (diff.y() < 0) ? (-camera_pt.y()) / diff.y() : 1;\n    double min_scale_z = (diff.z() > 0) ? (map_size_z - camera_pt.z()) / diff.z() : 0;\n    double max_scale_z = (diff.z() < 0) ? (-camera_pt.z()) / diff.z() : 1;\n    double min_scale = std::min(min_scale_x, min_scale_y);\n    min_scale = std::min(min_scale, min_scale_z);\n    double max_scale = std::max(max_scale_x, max_scale_y);\n    max_scale = std::max(max_scale, max_scale_z);\n    if (min_scale < 1 && max_scale > 0) {\n        double scale = min_scale;\n        if (scale > max_scale) {\n            scale = max_scale;\n        }\n        closest_pt = camera_pt + scale * diff;\n    }\n    return closest_pt;\n}\n", "CodeBleu_score": 37.883074714759445}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)  Eigen::Vector3d pt_adjusted = pt;\n  Eigen::Vector3d diff = pt - camera_pt;\n  double min_scale_x = diff.x() > 0 ? std::ceil(diff.x()) : std::floor(diff.x());\n  double min_scale_y = diff.y() > 0 ? std::ceil(diff.y()) : std::floor(diff.y());\n  double min_scale_z = diff.z() > 0 ? std::ceil(diff.z()) : std::floor(diff.z());\n  double max_scale_x = diff.x() > 0 ? std::floor(diff.x()) : std::ceil(diff.x());\n  double max_scale_y = diff.y() > 0 ? std::floor(diff.y()) : std::ceil(diff.y());\n  double max_scale_z = diff.z() > 0 ? std::floor(diff.z()) : std::ceil(diff.z());\n  if (std::abs(min_scale_x) < std::abs(max_scale_x)) {\n    pt_adjusted.x() += min_scale_x;\n  } else {\n    pt_adjusted.x() += max_scale_x;\n  }\n  if (std::abs(min_scale_y) < std::abs(max_scale_y)) {\n    pt_adjusted.y() += min_scale_y;\n  } else {\n    pt_adjusted.y() += max_scale_y;\n  }\n  if (std::abs(min_scale_z) < std::abs(max_scale_z)) {\n    pt_adjusted.z() += min_scale_z;\n  } else {\n    pt_adjusted.z() += max_scale_z;\n  }\n  return pt_adjusted;\n}\n", "CodeBleu_score": 34.91079520594227}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  // Update the last occupancy update time\n  last_occupancy_update_ = ros::Time::now();\n\n  // If an update is needed, project the depth image into points and process them with raycasting\n  if (need_update_) {\n    need_update_ = false;\n\n    // If the local map has been updated, clear and inflate it\n    if (local_map_updated_) {\n      local_map_updated_ = false;\n      clearLocalMap();\n      inflateLocalMap();\n    }\n\n    // Handle timeout errors for odometry or depth data and set relevant flags\n    if (odom_timeout_ || depth_timeout_) {\n      // If either timeout error has occurred, set the corresponding flag\n      if (odom_timeout_) {\n        odom_timeout_ = false;\n        odom_timeout_flag_ = true;\n      }\n      if (depth_timeout_) {\n        depth_timeout_ = false;\n        depth_timeout_flag_ = true;\n      }\n\n      // If both timeout errors have occurred, set the corresponding flag\n      if (odom_timeout_flag_ && depth_timeout_flag_) {\n        odom_timeout_flag_ = false;\n        depth_timeout_flag_ = false;\n        timeout_flag_ = true;\n      }\n    }\n  }\n}\n", "CodeBleu_score": 34.216543542974584}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  // Update the last occupancy update time\n  last_occupancy_update_time_ = ros::Time::now();\n\n  // If an update is needed, project the depth image into points and process them with raycasting\n  if (need_update_) {\n    // Project the depth image into points\n    projectDepthImage();\n\n    // Process the points with raycasting\n    raycastPoints();\n\n    // If the local map has been updated, clear and inflate the local map\n    if (local_map_updated_) {\n      local_map_.clear();\n      local_map_updated_ = false;\n    }\n\n    // Handle timeout errors for odometry or depth data and set relevant flags\n    if (odom_timeout_error_) {\n      ROS_WARN(\"Odometry timeout error\");\n      odom_timeout_error_ = false;\n      need_update_ = false;\n    } else if (depth_timeout_error_) {\n      ROS_WARN(\"Depth timeout error\");\n      depth_timeout_error_ = false;\n      need_update_ = false;\n    }\n  }\n}\n", "CodeBleu_score": 38.28598919050108}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)  // Update the last occupancy update time\n  lastOccupancyUpdateTime_ = ros::Time::now();\n\n  // If an update is needed, project the depth image into points and process them with raycasting\n  if (needUpdate_) {\n    // Project the depth image into points\n    projectDepthImage(depthImage_, depthImagePoints_);\n\n    // Process the points with raycasting\n    raycastPoints(depthImagePoints_, occupancyGrid_);\n\n    // If the local map has been updated, clear and inflate the local map\n    if (mapUpdated_) {\n      // Clear the local map\n      clearMap(localMap_);\n\n      // Inflate the local map\n      inflateMap(localMap_, localMapInflationRadius_, localMapInflationIterations_);\n\n      // Reset the mapUpdated flag\n      mapUpdated_ = false;\n    }\n\n    // Reset the needUpdate flag\n    needUpdate_ = false;\n  }\n\n  // Handle timeout errors for odometry and depth data\n  if (ros::Time::now() - lastOdometryUpdateTime_ > odometryTimeout_) {\n    ROS_WARN(\"Odometry timeout\");\n    odometryTimeout_ = true;\n  }\n  if (ros::Time::now() - lastDepthUpdateTime_ > depthTimeout_) {\n    ROS_WARN(\"Depth timeout\");\n    depthTimeout_ = true;\n  }\n}\n", "CodeBleu_score": 35.326115916696445}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)    float f_measure = 0;\n    int n_images = image_fns.size();\n    for (int i = 0; i < n_images; i++) {\n        Mat image = imread(image_fns[i], IMREAD_COLOR);\n        Mat gt = imread(gt_fns[i], IMREAD_GRAYSCALE);\n        Mat dt = imread(dt_fns[i], IMREAD_GRAYSCALE);\n        f_measure += _ellipse_evaluate_image(image, gt, dt, gt_angle_radians);\n    }\n    return f_measure / n_images;\n}\n", "CodeBleu_score": 54.91739651405605}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)    float f_measure = 0;\n    for (int i = 0; i < image_fns.size(); i++) {\n        vector<Ellipse> gt_ellipses = read_ellipses_from_file(gt_fns[i]);\n        vector<Ellipse> dt_ellipses = read_ellipses_from_file(dt_fns[i]);\n        f_measure += ellipse_evaluate(image_fns[i], gt_ellipses, dt_ellipses, gt_angle_radians);\n    }\n    return f_measure / image_fns.size();\n}\n", "CodeBleu_score": 60.23880095204716}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\n    float fmeasure_sum = 0.0;\n    int num_images = image_fns.size();\n\n    for (int i = 0; i < num_images; i++) {\n        Mat image = imread(image_fns[i]);\n        Mat gt_ellipses = load_ellipses_from_file(gt_fns[i], gt_angle_radians);\n        Mat dt_ellipses = load_ellipses_from_file(dt_fns[i], gt_angle_radians);\n\n        float fmeasure = evaluate_ellipse_detection(image, gt_ellipses, dt_ellipses);\n        fmeasure_sum += fmeasure;\n    }\n\n    float fmeasure_avg = fmeasure_sum / num_images;\n    return fmeasure_avg;\n}\n", "CodeBleu_score": 57.310249132554766}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float a = atan2(foci[1] - y, foci[0] - x);\n    float b = atan2(foci[3] - y, foci[2] - x);\n    float angle = a - b;\n    if (angle > M_PI) {\n        angle -= 2 * M_PI;\n    } else if (angle < -M_PI) {\n        angle += 2 * M_PI;\n    }\n    return angle;\n}\n", "CodeBleu_score": 35.55505871861284}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    if (foci == NULL) {\n        return 0.0;\n    }\n\n    float angle1 = atan2(y - foci[1], x - foci[0]);\n    float angle2 = atan2(y - foci[3], x - foci[2]);\n\n    float normal_angle = angle2 - angle1;\n\n    if (normal_angle < -M_PI) {\n        normal_angle += 2.0 * M_PI;\n    } else if (normal_angle > M_PI) {\n        normal_angle -= 2.0 * M_PI;\n    }\n\n    return normal_angle;\n}\n", "CodeBleu_score": 51.67258797827622}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)    float a = foci[0];\n    float b = foci[1];\n    float c = foci[2];\n    float d = foci[3];\n\n    float x1 = a;\n    float y1 = b;\n    float x2 = c;\n    float y2 = d;\n\n    float angle1 = atan2(y - y1, x - x1);\n    float angle2 = atan2(y - y2, x - x2);\n\n    float normal_angle = angle2 - angle1;\n\n    if (normal_angle > M_PI) {\n        normal_angle -= 2 * M_PI;\n    } else if (normal_angle < -M_PI) {\n        normal_angle += 2 * M_PI;\n    }\n\n    return normal_angle;\n}\n", "CodeBleu_score": 38.09751111507109}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)    double min_x = DBL_MAX;\n    double max_x = -DBL_MAX;\n    double min_y = DBL_MAX;\n    double max_y = -DBL_MAX;\n\n    for (int i = start; i <= end; i++) {\n        min_x = std::min(min_x, vp1[i].x);\n        max_x = std::max(max_x, vp1[i].x);\n        min_y = std::min(min_y, vp1[i].y);\n        max_y = std::max(max_y, vp1[i].y);\n    }\n\n    double integral_above = 0.0;\n    double integral_below = 0.0;\n\n    for (int i = start; i <= end; i++) {\n        double x1 = vp1[i].x;\n        double y1 = vp1[i].y;\n        double x2 = vp1[(i + 1) % vp1.size()].x;\n        double y2 = vp1[(i + 1) % vp1.size()].y;\n\n        double x_intersection = (x2 - x1) * (min_y - y1) / (y2 - y1) + x1;\n\n        if (x_intersection < min_x || x_intersection > max_x) {\n            continue;\n        }\n\n        integral_above += (x_intersection - min_x) * (max_y - min_y) / 2.0;\n        integral_below += (max_x - x_intersection) * (max_y - min_y) / 2.0;\n    }\n\n    return integral_above < integral_below;\n}\n", "CodeBleu_score": 43.8616776085866}, {"code": "bool inline concave_check(VP& vp1, int start, int end)    int n = end - start;\n    if (n < 3) {\n        return false;\n    }\n\n    double min_x = vp1[start].x;\n    double max_x = vp1[start].x;\n    double min_y = vp1[start].y;\n    double max_y = vp1[start].y;\n    for (int i = start + 1; i < end; i++) {\n        if (vp1[i].x < min_x) {\n            min_x = vp1[i].x;\n        } else if (vp1[i].x > max_x) {\n            max_x = vp1[i].x;\n        }\n        if (vp1[i].y < min_y) {\n            min_y = vp1[i].y;\n        } else if (vp1[i].y > max_y) {\n            max_y = vp1[i].y;\n        }\n    }\n\n    double integral_above = 0.0;\n    double integral_below = 0.0;\n    for (int i = start; i < end; i++) {\n        int j = (i + 1) % n;\n        double x1 = vp1[i].x;\n        double y1 = vp1[i].y;\n        double x2 = vp1[j].x;\n        double y2 = vp1[j].y;\n        double x3 = min_x;\n        double y3 = min_y;\n        double x4 = max_x;\n        double y4 = max_y;\n        double area = (x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y4 - x4 * y3 + x4 * y1 - x1 * y4) / 2.0;\n        if (area > 0.0) {\n            integral_above += area;\n        } else {\n            integral_below -= area;\n        }\n    }\n\n    return integral_above < integral_below;\n}", "CodeBleu_score": 38.84317540067469}, {"code": "bool inline concave_check(VP& vp1, int start, int end)  double min_x = DBL_MAX, max_x = -DBL_MAX;\n  double min_y = DBL_MAX, max_y = -DBL_MAX;\n  for (int i = start; i <= end; i++) {\n    if (vp1[i].x < min_x) min_x = vp1[i].x;\n    if (vp1[i].x > max_x) max_x = vp1[i].x;\n    if (vp1[i].y < min_y) min_y = vp1[i].y;\n    if (vp1[i].y > max_y) max_y = vp1[i].y;\n  }\n  double integral_above = 0.0, integral_below = 0.0;\n  for (int i = start; i <= end; i++) {\n    double x = vp1[i].x;\n    double y = vp1[i].y;\n    if (x < min_x || x > max_x || y < min_y || y > max_y) continue;\n    double x1 = vp1[(i + 1) % vp1.size()].x;\n    double y1 = vp1[(i + 1) % vp1.size()].y;\n    double x2 = vp1[(i + 2) % vp1.size()].x;\n    double y2 = vp1[(i + 2) % vp1.size()].y;\n    double x3 = vp1[(i + 3) % vp1.size()].x;\n    double y3 = vp1[(i + 3) % vp1.size()].y;\n    double x4 = vp1[(i + 4) % vp1.size()].x;\n    double y4 = vp1[(i + 4) % vp1.size()].y;\n    double x5 = vp1[(i + 5) % vp1.size()].x;\n    double y5 = vp1[(i + 5) % vp1.size()].y;\n    double x6", "CodeBleu_score": 44.581540114009755}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)  // Iterate through each detection info\n  for (int i = 0; i < msg->detections.size(); i++) {\n    // Check if the object is named \"T\"\n    if (msg->detections[i].name == \"T\") {\n      // Increment the num_regain counter and reset num_lost\n      num_regain++;\n      num_lost = 0;\n      // Set is_detected to true\n      is_detected = true;\n    } else {\n      // Reset num_regain and increment num_lost\n      num_regain = 0;\n      num_lost++;\n      // If num_lost exceeds VISION_THRES, set is_detected to false\n      if (num_lost > VISION_THRES) {\n        is_detected = false;\n      }\n    }\n  }\n  // Swap the sight_angle values of ellipse_det\n  ellipse_det.sight_angle_1 = msg->detections[0].sight_angle_2;\n  ellipse_det.sight_angle_2 = msg->detections[0].sight_angle_1;\n}\n", "CodeBleu_score": 58.27342752656938}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)  // Check if the message is empty\n  if (msg->detections.size() == 0) {\n    return;\n  }\n\n  // Iterate through each detection\n  for (int i = 0; i < msg->detections.size(); i++) {\n    prometheus_msgs::DetectionInfo det = msg->detections[i];\n\n    // Check if the detection is a T\n    if (det.name == \"T\") {\n      // Increment the num_regain counter\n      num_regain++;\n      // Reset the num_lost counter\n      num_lost = 0;\n    } else {\n      // Reset the num_regain counter\n      num_regain = 0;\n      // Increment the num_lost counter\n      num_lost++;\n    }\n\n    // Check if the num_lost counter has exceeded the threshold\n    if (num_lost > VISION_THRES) {\n      // Set the is_detected flag to false\n      is_detected = false;\n    }\n\n    // Check if the num_regain counter has exceeded the threshold\n    if (num_regain > VISION_THRES) {\n      // Set the is_detected flag to true\n      is_detected = true;\n    }\n\n    // Update the ellipse_det variable\n    ellipse_det = det;\n  }\n\n  // Swap the sight_angle values of ellipse_det\n  double temp = ellipse_det.sight_angle[0];\n  ellipse_det.sight_angle[0] = ellipse_det.sight_angle[1];\n  ellipse_det.sight_angle[1] = temp;\n}\n", "CodeBleu_score": 73.02999776255497}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)  // Iterate through each detection info\n  for (int i = 0; i < msg->detection_infos.size(); i++) {\n    prometheus_msgs::DetectionInfo det = msg->detection_infos[i];\n    // Update ellipse_det\n    if (det.name == \"T\") {\n      // Increment num_regain and reset num_lost\n      num_regain++;\n      num_lost = 0;\n    } else {\n      // Reset num_regain and increment num_lost\n      num_regain = 0;\n      num_lost++;\n    }\n    // Check if num_lost exceeds VISION_THRES\n    if (num_lost > VISION_THRES) {\n      is_detected = false;\n    }\n    // Check if num_regain exceeds VISION_THRES\n    if (num_regain > VISION_THRES) {\n      is_detected = true;\n    }\n    // Swap sight_angle values\n    ellipse_det.sight_angle[0] = det.sight_angle[1];\n    ellipse_det.sight_angle[1] = det.sight_angle[0];\n  }\n}\n", "CodeBleu_score": 73.56615061465182}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  // Check if the position is within the safety distance of the obstacle\n  if (Occupy_map_ptr->get_occupy_map(cur_pos) < safe_distance) {\n    return false;\n  }\n  return true;\n}\n", "CodeBleu_score": 31.429622072037986}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)  if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n", "CodeBleu_score": 47.66280367924164}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)    if (Occupy_map_ptr->check_safety(cur_pos, safe_distance)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n", "CodeBleu_score": 45.928073538545966}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)    NodePtr current_node = end_node;\n    while (current_node != nullptr) {\n        path_nodes_.push_back(current_node);\n        current_node = current_node->parent;\n    }\n    std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 56.16733381689725}, {"code": "void Astar::retrievePath(NodePtr end_node)  NodePtr current_node = end_node;\n  path_nodes_.push_back(current_node);\n  while (current_node->parent_ != nullptr) {\n    path_nodes_.push_back(current_node->parent_);\n    current_node = current_node->parent_;\n  }\n  std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 63.70378619491106}, {"code": "void Astar::retrievePath(NodePtr end_node)  // Retrieve the path from end_node to start_node\n  NodePtr current_node = end_node;\n  path_nodes_.push_back(current_node);\n  while (current_node->parent_ != nullptr) {\n    path_nodes_.push_back(current_node->parent_);\n    current_node = current_node->parent_;\n  }\n  std::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 65.76544213286742}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     // check if the id of the neighbor is in the list of neighbors\n    if (std::find(neighbors.begin(), neighbors.end(), id) != neighbors.end()) {\n        // update the state of the neighbor\n        state_nei[id].x = odom->pose.pose.position.x;\n        state_nei[id].y = odom->pose.pose.position.y;\n        state_nei[id].z = odom->pose.pose.position.z;\n        state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n        state_nei[id].vx = odom->twist.twist.linear.x;\n        state_nei[id].vy = odom->twist.twist.linear.y;\n        state_nei[id].vz = odom->twist.twist.linear.z;\n        state_nei[id].wz = odom->twist.twist.angular.z;\n\n        // check if the neighbor is in simulation mode\n        if (simulation_mode) {\n            // check if the distance from the start position is less than 5 meters\n            if (sqrt(pow(state_nei[id].x - state_nei[0].x, 2) + pow(state_nei[id].y - state_nei[0].y, 2)) > 5.0) {\n                // set the get_nei_state flag to false\n                get_nei_state = false;\n            } else {\n                // set the get_nei_state flag to true\n                get_nei_state = true;\n            }\n        } else {\n            // set the get_nei_state flag to true\n            get_nei_state = true;\n        }\n    }\n}\n", "CodeBleu_score": 50.37116173135392}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \n    if(simulation_mode){\n        double dist = sqrt(pow(odom->pose.pose.position.x - start_x, 2) + pow(odom->pose.pose.position.y - start_y, 2));\n        if(dist > 5){\n            get_nei_state = false;\n        }\n        else{\n            get_nei_state = true;\n        }\n    }\n    else{\n        get_nei_state = true;\n    }\n\n    if(get_nei_state){\n        state_nei[id].x = odom->pose.pose.position.x;\n        state_nei[id].y = odom->pose.pose.position.y;\n        state_nei[id].z = odom->pose.pose.position.z;\n        state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n        state_nei[id].v = odom->twist.twist.linear.x;\n        state_nei[id].w = odom->twist.twist.angular.z;\n    }\n}\n", "CodeBleu_score": 46.47092540566933}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id)     // update state_nei array\n    state_nei[id].x = odom->pose.pose.position.x;\n    state_nei[id].y = odom->pose.pose.position.y;\n    state_nei[id].z = odom->pose.pose.position.z;\n    state_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\n    // check if the UGV is in simulation mode\n    if (simulation_mode) {\n        // calculate the distance from the start position\n        double distance = sqrt(pow(state_nei[id].x - start_x, 2) + pow(state_nei[id].y - start_y, 2));\n\n        // if the distance exceeds 5 meters, set the get_nei_state flag to false\n        if (distance > 5) {\n            get_nei_state = false;\n        } else {\n            get_nei_state = true;\n        }\n    } else {\n        get_nei_state = true;\n    }\n}\n", "CodeBleu_score": 46.45628240640538}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (!odom_ready)\n    return;\n\n  if (sensor_ready) {\n    if (update_count % 5 == 0) {\n      update_count = 0;\n      sensor_ready = false;\n      astar_map.update_map_with_pointcloud(msg, robot_pose);\n    } else {\n      update_count++;\n    }\n  } else {\n    sensor_ready = true;\n  }\n}\n", "CodeBleu_score": 48.58037537713948}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    if (!odom_ready)\n        return;\n\n    sensor_msgs::PointCloud2ConstPtr msg_in = msg;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg_in, *cloud);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_rotated(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_downsampled_rotated_transformed(new pcl::PointCloud<pcl::PointXYZ>);\n\n    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;\n    voxel_grid.setInputCloud(cloud);\n    voxel_grid.setLeafSize(0.1, 0.1, 0.1);\n    voxel_grid.filter(*cloud_filtered);\n\n    pcl::octree::OctreePointCloudSearch<pcl::PointXYZ> octree(0.1);\n    octree.setInputCloud(cloud_filtered);\n    octree.addPointsFromInputCloud();\n\n    pcl::PointXYZ min_pcl;\n    pcl::PointXYZ max_pcl;\n    pcl::getMinMax3D(*cloud_filtered, min_pcl, max_pcl);\n\n    pcl::PointXYZ min_pcl_rotated;\n    pcl::PointXYZ max_pcl_rotated;\n    pcl::getMinMax3D(*cloud_filtered_downsampled_rotated, min_pcl_rotated, max_pcl_rotated);\n\n", "CodeBleu_score": 29.138403318035888}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (!odom_ready)\n    return;\n  sensor_ready = true;\n  update_count++;\n  if (update_count >= 5) {\n    update_count = 0;\n    ROS_INFO(\"Updating Astar map with new point cloud data\");\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*msg, *cloud);\n    for (size_t i = 0; i < cloud->points.size(); i++) {\n      pcl::PointXYZ point = cloud->points[i];\n      if (point.z > 0.05)\n        continue;\n      astar_map->setObstacle(point.x, point.y);\n    }\n  }\n}", "CodeBleu_score": 47.45177074088147}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)    if(!get_gpcl){\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud (new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*global_point, *global_point_cloud);\n        global_point_cloud_ptr = global_point_cloud;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud_inflate (new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::copyPointCloud(*global_point_cloud_ptr, *global_point_cloud_inflate);\n        pcl::PointCloud<pcl::PointXYZ>::Ptr global_point_cloud_inflate_ptr (new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::copyPointCloud(*global_point_cloud_inflate, *global_point_cloud_inflate_ptr);\n        inflate_point_cloud(global_point_cloud_inflate_ptr);\n        global_point_cloud_inflate_ptr->header.frame_id = \"map\";\n        global_point_cloud_inflate_ptr->header.stamp = ros::Time::now();\n        global_point_cloud_inflate_ptr->width = global_point_cloud_inflate_ptr->points.size();\n        global_point_cloud_inflate_ptr->height = 1;\n        global_point_cloud_inflate_ptr->is_dense = false;\n        global_point_cloud_inflate_ptr->points.resize(global_point_cloud_inflate_ptr->width * global_point_cloud_inflate_ptr->height);\n        global_point_cloud_inflate_ptr->is_dense = false;\n        global_point_cloud_inflate_ptr->sensor_origin_ = Eigen::Vector4f(0,0,0,0);\n        global_point_cloud_inflate_ptr->sensor_orientation", "CodeBleu_score": 47.88094666196711}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)    if (!get_gpcl) {\n        get_gpcl = true;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr temp_cloud(new pcl::PointCloud<pcl::PointXYZ>());\n        pcl::fromROSMsg(*global_point, *temp_cloud);\n        global_cloud = temp_cloud;\n        pcl::PointCloud<pcl::PointXYZ>::Ptr inflated_cloud(new pcl::PointCloud<pcl::PointXYZ>());\n        inflate_cloud(global_cloud, inflated_cloud);\n        global_cloud = inflated_cloud;\n    }\n}\n", "CodeBleu_score": 55.51492772655254}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)  if (get_gpcl == false) {\n    get_gpcl = true;\n    pcl::PointCloud<pcl::PointXYZ>::Ptr temp_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    pcl::fromROSMsg(*global_point, *temp_cloud);\n    global_cloud = *temp_cloud;\n    inflate_cloud();\n  }\n}\n", "CodeBleu_score": 57.530283709210075}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)  // If not in simulation mode, update the map\n  if (!simulation_mode) {\n    // Convert the laser scan to a PointCloud2\n    sensor_msgs::PointCloud2 point_cloud2;\n    projector_.projectLaser(*local_point, point_cloud2);\n\n    // Convert the PointCloud2 to a pcl::PointCloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr point_cloud(new pcl::PointCloud<pcl::PointXYZ>());\n    pcl::fromROSMsg(point_cloud2, *point_cloud);\n\n    // Update the map\n    map_update(point_cloud, odom);\n  }\n}\n", "CodeBleu_score": 53.0446044490084}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)  // Convert laser scan to point cloud\n  sensor_msgs::PointCloud2 laser_cloud;\n  projector_.projectLaser(*local_point, laser_cloud);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::fromROSMsg(laser_cloud, *laser_cloud_ptr);\n\n  // Convert odometry to transformation matrix\n  Eigen::Matrix4f odom_matrix = Eigen::Matrix4f::Identity();\n  odom_matrix.block<3,3>(0,0) = Eigen::Quaternionf(odom.pose.pose.orientation.w, odom.pose.pose.orientation.x, odom.pose.pose.orientation.y, odom.pose.pose.orientation.z).toRotationMatrix();\n  odom_matrix(0,3) = odom.pose.pose.position.x;\n  odom_matrix(1,3) = odom.pose.pose.position.y;\n  odom_matrix(2,3) = odom.pose.pose.position.z;\n\n  // Transform point cloud using odometry\n  pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::transformPointCloud(*laser_cloud_ptr, *transformed_cloud_ptr, odom_matrix);\n\n  // Update occupancy map\n  if (!simulation_mode_) {\n    // Merge transformed point cloud with local map\n    pcl::PointCloud<pcl::PointXYZ>::Ptr merged_cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n    *merged_cloud_ptr = *transformed_cloud_ptr + *local_map_ptr_;\n\n    // Update local map\n    local_map_ptr_ = merged_cloud_ptr;\n  }\n}\n", "CodeBleu_score": 46.81820570644981}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)    if (!simulation_mode) {\n        // if not in simulation mode, update the map with the odometry data\n        // update the pose of the robot\n        pose.x = odom.pose.pose.position.x;\n        pose.y = odom.pose.pose.position.y;\n        pose.theta = tf::getYaw(odom.pose.pose.orientation);\n        // update the velocity of the robot\n        vel.x = odom.twist.twist.linear.x;\n        vel.y = odom.twist.twist.linear.y;\n        vel.theta = odom.twist.twist.angular.z;\n    }\n    // convert the laser scan to a point cloud\n    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n    projectLaser(*local_point, *cloud);\n    // update the map with the point cloud\n    updateMap(cloud);\n    // publish the map\n    publishMap();\n}\n", "CodeBleu_score": 47.21228929636118}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)    // Convert the global point cloud map to a ROS message\n    sensor_msgs::PointCloud2 global_pcl_msg;\n    pcl::toROSMsg(global_pcl, global_pcl_msg);\n    global_pcl_msg.header.frame_id = \"world\";\n\n    // Publish the global point cloud message\n    global_pcl_pub.publish(global_pcl_msg);\n\n    // Convert and publish the inflated point cloud\n    sensor_msgs::PointCloud2 inflate_pcl_msg;\n    pcl::toROSMsg(inflate_pcl, inflate_pcl_msg);\n    inflate_pcl_msg.header.frame_id = \"world\";\n    inflate_pcl_pub.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 62.420184032027805}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)  // Convert the global point cloud map to a ROS message\n  sensor_msgs::PointCloud2 global_pcl_msg;\n  pcl::toROSMsg(global_pcl_map, global_pcl_msg);\n  global_pcl_msg.header.frame_id = \"world\";\n\n  // Publish the global point cloud message\n  global_pcl_pub.publish(global_pcl_msg);\n\n  // Convert the inflated point cloud to a ROS message\n  sensor_msgs::PointCloud2 inflated_pcl_msg;\n  pcl::toROSMsg(inflated_pcl, inflated_pcl_msg);\n  inflated_pcl_msg.header.frame_id = \"world\";\n\n  // Publish the inflated point cloud message\n  inflate_pcl_pub.publish(inflated_pcl_msg);\n}", "CodeBleu_score": 61.30806132605795}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)  pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr inflated_pcl_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_ptr_tmp(new pcl::PointCloud<pcl::PointXYZ>);\n  pcl::PointCloud<pcl::PointXYZ>::Ptr inflated_pcl_ptr_tmp(new pcl::PointCloud<pcl::PointXYZ>);\n\n  // convert global map to pcl\n  for (int i = 0; i < grid_map_ptr->getSizeX(); i++) {\n    for (int j = 0; j < grid_map_ptr->getSizeY(); j++) {\n      if (grid_map_ptr->getData(i, j) == -1) {\n        continue;\n      }\n      pcl::PointXYZ p;\n      p.x = i;\n      p.y = j;\n      p.z = grid_map_ptr->getData(i, j);\n      pcl_ptr->push_back(p);\n    }\n  }\n\n  // convert inflated map to pcl\n  for (int i = 0; i < inflated_grid_map_ptr->getSizeX(); i++) {\n    for (int j = 0; j < inflated_grid_map_ptr->getSizeY(); j++) {\n      if (inflated_grid_map_ptr->getData(i, j) == -1) {\n        continue;\n      }\n      pcl::PointXYZ p;\n      p.x = i;\n      p.y = j;\n      p.z = inflated_grid_map_ptr->getData(i, j);\n      inflated_pcl_ptr->push_back(p);\n    }\n  }\n\n  // convert global map to pcl (for rviz)\n  for (int i", "CodeBleu_score": 39.758178475828274}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)  if (sensor_ready) {\n    // Update the map using the new point cloud data and current UAV odometry\n    update_map(msg, odom_msg);\n  }\n}\n", "CodeBleu_score": 36.398242162365996}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");\n    //ROS_INFO(\"Lpointcloud_cb\");\n    //ROS_INFO(\"pointcloud_cb\");", "CodeBleu_score": 11.207987567190283}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)    //ROS_INFO(\"Lpointcloud_cb\");\n    if (sensor_ready) {\n        //ROS_INFO(\"Lpointcloud_cb: sensor_ready\");\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n        pcl::fromROSMsg(*msg, *cloud);\n        //ROS_INFO(\"Lpointcloud_cb: pcl::fromROSMsg\");\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n        //ROS_INFO(\"Lpointcloud_cb: pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\");\n        pcl::VoxelGrid<pcl::PointXYZ> sor;\n        sor.setInputCloud(cloud);\n        sor.setLeafSize(0.1f, 0.1f, 0.1f);\n        sor.filter(*cloud_filtered);\n        //ROS_INFO(\"Lpointcloud_cb: pcl::VoxelGrid<pcl::PointXYZ> sor;\");\n        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_roi(new pcl::PointCloud<pcl::PointXYZ>);\n        //ROS_INFO(\"Lpointcloud_cb: pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_roi(new pcl::PointCloud<pcl::PointXYZ>);\");\n        pcl::CropBox<pcl::PointXYZ> crop;\n        crop.setInputCloud(cloud_filtered);\n        crop.setMin(Eigen::Vector4f(-10, -10, -10, 1));\n        crop.setMax(Eigen::Vector4f(10, 10, 10, 1));\n        crop.filter(*cloud_filtered_roi);\n        //ROS_INFO(\"Lpointcloud_cb: pcl::CropBox<", "CodeBleu_score": 38.45137560883275}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Check if the robot is standing\n  if (robot_standing_) {\n    // Calculate target foot positions based on the desired pose using the body controller\n    Eigen::Vector3d target_pos_x = body_controller_.getTargetPositionX();\n    Eigen::Vector3d target_pos_y = body_controller_.getTargetPositionY();\n    Eigen::Vector3d target_pos_z = body_controller_.getTargetPositionZ();\n\n    // Compute velocity commands for the legs\n    Eigen::Vector3d vel_x = body_controller_.getTargetVelocityX();\n    Eigen::Vector3d vel_y = body_controller_.getTargetVelocityY();\n    Eigen::Vector3d vel_z = body_controller_.getTargetVelocityZ();\n\n    // Perform inverse kinematics to determine target joint positions\n    Eigen::VectorXd target_joints = inverseKinematics(target_pos_x, target_pos_y, target_pos_z, vel_x, vel_y, vel_z);\n\n    // Publish foot contact information and joint positions\n    publishFootContactInfo(target_joints);\n    publishJointPositions(target_joints);\n  }\n}\n", "CodeBleu_score": 43.92522640995468}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Get the current time\n  const ros::Time time = ros::Time::now();\n\n  // Get the current state of the robot\n  const QuadrupedState& state = state_buffer_.getMostRecent();\n\n  // Check if the robot is in a valid state\n  if (!state.isValid()) {\n    // If not, return without doing anything\n    return;\n  }\n\n  // Get the desired pose from the body controller\n  const Eigen::Vector3d& desired_position = body_controller_.getDesiredPosition();\n  const Eigen::Quaterniond& desired_orientation = body_controller_.getDesiredOrientation();\n\n  // Calculate the target foot positions based on the desired pose\n  Eigen::Vector3d target_positions[4];\n  for (int i = 0; i < 4; i++) {\n    target_positions[i] = desired_position + desired_orientation * foot_positions_[i];\n  }\n\n  // Compute velocity commands for the legs\n  Eigen::Vector3d leg_velocities[4];\n  for (int i = 0; i < 4; i++) {\n    leg_velocities[i] = (target_positions[i] - state.foot_positions[i]) / dt_;\n  }\n\n  // Perform inverse kinematics to determine target joint positions\n  Eigen::VectorXd target_joint_positions[4];\n  for (int i = 0; i < 4; i++) {\n    target_joint_positions[i] = leg_ik_.inverse(target_positions[i], state.foot_positions[i]);\n  }\n\n  // Publish foot contact information\n  publishFootContact(state.foot_contacts);\n\n  // Publish joint positions\n  publishJointPositions(target_joint_positions);\n}\n", "CodeBleu_score": 43.57938078474377}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)  // Get current time\n  ros::Time current_time = ros::Time::now();\n\n  // Get current pose\n  Pose current_pose;\n  if (!getPose(current_pose)) {\n    ROS_WARN_STREAM(\"Failed to get current pose\");\n    return;\n  }\n\n  // Get current joint positions\n  std::vector<double> current_joint_positions;\n  if (!getJointPositions(current_joint_positions)) {\n    ROS_WARN_STREAM(\"Failed to get current joint positions\");\n    return;\n  }\n\n  // Get current foot positions\n  std::vector<Pose> current_foot_positions;\n  if (!getFootPositions(current_foot_positions)) {\n    ROS_WARN_STREAM(\"Failed to get current foot positions\");\n    return;\n  }\n\n  // Calculate target foot positions based on desired pose\n  std::vector<Pose> target_foot_positions;\n  if (!calculateTargetFootPositions(current_foot_positions, current_pose, target_foot_positions)) {\n    ROS_WARN_STREAM(\"Failed to calculate target foot positions\");\n    return;\n  }\n\n  // Calculate target joint positions based on target foot positions\n  std::vector<std::vector<double>> target_joint_positions;\n  if (!calculateTargetJointPositions(target_foot_positions, target_joint_positions)) {\n    ROS_WARN_STREAM(\"Failed to calculate target joint positions\");\n    return;\n  }\n\n  // Publish foot contact information\n  publishFootContactInformation(current_foot_positions);\n\n  // Publish target joint positions\n  publishTargetJointPositions(target_joint_positions);\n\n  // Publish current joint positions\n  publishCurrentJointPositions(current_joint_positions);\n}\n", "CodeBleu_score": 44.104419926507965}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])  if (!foot_contacts_publisher_.getNumSubscribers()) {\n    return;\n  }\n\n  if (!publish_foot_contacts_) {\n    return;\n  }\n\n  if (!is_in_gazebo_) {\n    ContactsStamped contacts_stamped;\n    contacts_stamped.header.stamp = ros::Time::now();\n    contacts_stamped.header.frame_id = \"world\";\n\n    for (int i = 0; i < 4; i++) {\n      contacts_stamped.contacts[i].foot_state = foot_contacts[i] ? 1 : 0;\n      contacts_stamped.contacts[i].phase = gait_phase_[i];\n    }\n\n    foot_contacts_publisher_.publish(contacts_stamped);\n  }\n}\n", "CodeBleu_score": 48.10105850089642}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])  if (foot_contacts_publisher_.getNumSubscribers() > 0) {\n    if (!contacts_stamped_msg_) {\n      contacts_stamped_msg_ = std::make_shared<ContactsStamped>();\n      contacts_stamped_msg_->header.frame_id = \"base_link\";\n      contacts_stamped_msg_->contacts.resize(4);\n    }\n    for (int i = 0; i < 4; i++) {\n      contacts_stamped_msg_->contacts[i].name = foot_names_[i];\n      contacts_stamped_msg_->contacts[i].state = foot_contacts[i];\n      contacts_stamped_msg_->contacts[i].phase = foot_contact_phases_[i];\n    }\n    contacts_stamped_msg_->header.stamp = ros::Time::now();\n    foot_contacts_publisher_.publish(contacts_stamped_msg_);\n  }\n}\n", "CodeBleu_score": 47.61173593862165}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])    if (foot_contacts_publisher_ != nullptr) {\n        if (foot_contacts_publisher_->getNumSubscribers() > 0) {\n            if (foot_contacts_publisher_->getTopic() != \"\") {\n                contacts_msg_.header.stamp = ros::Time::now();\n                contacts_msg_.header.frame_id = \"base_link\";\n                contacts_msg_.phase = gait_phase_;\n                for (int i = 0; i < 4; i++) {\n                    contacts_msg_.contacts[i] = foot_contacts[i];\n                }\n                foot_contacts_publisher_->publish(contacts_msg_);\n            }\n        }\n    }\n}\n", "CodeBleu_score": 51.80515619917772}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)  joints_msg = JointState()\n  joints_msg.position = joints.position[0:12]\n  self.joint_pub.publish(joints_msg)\n\n  trajectory_msg = JointTrajectory()\n  trajectory_msg.joint_names = joints.name\n  trajectory_msg.points = [JointTrajectoryPoint(positions=joints.position[0:12], time_from_start=Duration(secs=1))]\n  self.trajectory_pub.publish(trajectory_msg)\n}\n", "CodeBleu_score": 38.87173321606498}, {"code": "def joints_cmd_callback(self, joints)  # Create a minimal joints message with the first 12 joint positions\n  joints_msg = JointState()\n  joints_msg.position = joints.position[0:12]\n  self.publish(self.joints_pub, joints_msg)\n\n  # Create a joint trajectory message with the same positions and a specified duration\n  traj_msg = JointTrajectory()\n  traj_msg.joint_names = joints.name[0:12]\n  traj_msg.points = [JointTrajectoryPoint(positions=joints.position[0:12], time_from_start=Duration(secs=10))]\n  self.publish(self.traj_pub, traj_msg)\n}\n", "CodeBleu_score": 39.13526402386979}, {"code": "def joints_cmd_callback(self, joints)  # Create a minimal joints message\n  joints_msg = JointState()\n  joints_msg.position = joints.position[0:12]\n  joints_msg.velocity = joints.velocity[0:12]\n  joints_msg.effort = joints.effort[0:12]\n  joints_msg.header.stamp = rospy.Time.now()\n  joints_msg.name = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n  self.joints_pub.publish(joints_msg)\n\n  # Create a joint trajectory message\n  traj_msg = JointTrajectory()\n  traj_msg.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6', 'joint_7', 'joint_8', 'joint_9', 'joint_10', 'joint_11', 'joint_12']\n  traj_msg.points = [JointTrajectoryPoint(positions=joints.position[0:12], time_from_start=rospy.Duration(1.0))]\n  self.traj_pub.publish(traj_msg)\n}\n", "CodeBleu_score": 44.216310564402036}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Reset foot contact states\n  for (int i = 0; i < 4; i++) {\n    footContactStates_[i] = false;\n  }\n\n  // Process each contact\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Get collision string\n    std::string collision = _msg->contact(i).collision1();\n\n    // Get foot link name\n    std::string footLinkName = \"foot_link_\";\n    if (collision.find(footLinkName) != std::string::npos) {\n      // Get foot number\n      int footNumber = std::stoi(collision.substr(footLinkName.length()));\n\n      // Set foot contact state\n      footContactStates_[footNumber - 1] = true;\n    }\n  }\n}", "CodeBleu_score": 57.1543205071559}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)    // Initialize foot contact states to false\n    left_foot_contact_ = false;\n    right_foot_contact_ = false;\n\n    // For each contact in the message\n    for (int i = 0; i < _msg->contact_size(); i++) {\n        // Split the collision string to identify the contact link\n        std::string collision1 = _msg->contact(i).collision1();\n        std::string collision2 = _msg->contact(i).collision2();\n        std::string link1 = collision1.substr(0, collision1.find(\"::\"));\n        std::string link2 = collision2.substr(0, collision2.find(\"::\"));\n\n        // If a contact matches one of the foot links, set the corresponding foot contact state to true\n        if (link1 == \"left_foot_link\" || link2 == \"left_foot_link\") {\n            left_foot_contact_ = true;\n        } else if (link1 == \"right_foot_link\" || link2 == \"right_foot_link\") {\n            right_foot_contact_ = true;\n        }\n    }\n}\n", "CodeBleu_score": 40.01120336172067}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)  // Initialize foot contact states to false\n  foot_contact_states_[0] = false;\n  foot_contact_states_[1] = false;\n  foot_contact_states_[2] = false;\n  foot_contact_states_[3] = false;\n\n  // Iterate over contacts in message\n  for (int i = 0; i < _msg->contact_size(); i++) {\n    // Get collision string\n    std::string collision = _msg->contact(i).collision1();\n\n    // Split collision string to identify contact link\n    std::vector<std::string> split_collision = split(collision, '_');\n    std::string link = split_collision[1];\n\n    // Set corresponding foot contact state to true if link matches a foot link\n    if (link == \"left_sole_link\") {\n      foot_contact_states_[0] = true;\n    } else if (link == \"right_sole_link\") {\n      foot_contact_states_[1] = true;\n    } else if (link == \"left_foot_link\") {\n      foot_contact_states_[2] = true;\n    } else if (link == \"right_foot_link\") {\n      foot_contact_states_[3] = true;\n    }\n  }\n}\n", "CodeBleu_score": 45.742904120822445}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const    if (!active_) {\n        rotor_velocities->setZero();\n        return;\n    }\n\n    // Calculate desired acceleration\n    Eigen::Vector3d desired_acceleration = desired_position_ - position_;\n    desired_acceleration.normalize();\n    desired_acceleration *= kDesiredAcceleration;\n\n    // Calculate desired angular acceleration\n    Eigen::Vector3d desired_angular_acceleration = desired_orientation_.inverse() * desired_acceleration;\n\n    // Project thrust onto the body z-axis\n    double thrust = desired_acceleration.z() * kMass;\n\n    // Combine angular acceleration and thrust into a single vector\n    Eigen::Vector3d desired_acceleration_body = desired_angular_acceleration;\n    desired_acceleration_body.z() = thrust;\n\n    // Compute rotor velocities\n    *rotor_velocities = kRotorVelocityMatrix * desired_acceleration_body;\n\n    // Ensure non-negative values\n    rotor_velocities->cwiseMax(0.0);\n\n    // Take the square root of each component\n    rotor_velocities->array() = rotor_velocities->array().sqrt();\n}\n", "CodeBleu_score": 37.78439051094151}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Check if the input and parameters are valid.\n  if (rotor_velocities == nullptr) {\n    std::cerr << \"Error: rotor_velocities is a nullptr.\" << std::endl;\n    return;\n  }\n  if (rotor_velocities->size() != kNumRotors) {\n    std::cerr << \"Error: rotor_velocities has the wrong size.\" << std::endl;\n    return;\n  }\n  if (kNumRotors != kNumRotorVelocities) {\n    std::cerr << \"Error: kNumRotors and kNumRotorVelocities are not equal.\" << std::endl;\n    return;\n  }\n  if (kNumRotorVelocities != kNumRotorVelocityComponents) {\n    std::cerr << \"Error: kNumRotorVelocities and kNumRotorVelocityComponents are not equal.\" << std::endl;\n    return;\n  }\n  if (kNumRotorVelocityComponents != kNumRotorVelocityComponents) {\n    std::cerr << \"Error: kNumRotorVelocityComponents and kNumRotorVelocityComponents are not equal.\" << std::endl;\n    return;\n  }\n\n  // If the controller is not active, set all rotor velocities to zero.\n  if (!is_active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Calculate the desired acceleration and angular acceleration.\n  Eigen::Vector3d desired_acceleration = CalculateDesiredAcceleration();\n  Eigen::Vector3d angular_acceleration = CalculateAngularAcceleration();\n\n  // Project thrust onto the body z-axis and combine with angular acceleration.\n  Eigen::Vector3d thrust_vector = CalculateThrustVector();\n  Eigen::Vector3d acceleration = thrust_vector + angular_acceleration;\n\n  // Compute the rotor velocities by multiplying with the rotation matrix.\n  *rotor_velocities = kRot", "CodeBleu_score": 37.8902935421324}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Check for valid input and parameters\n  if (rotor_velocities == nullptr || !active_) {\n    rotor_velocities->setZero();\n    return;\n  }\n\n  // Compute desired acceleration and angular acceleration\n  Eigen::Vector3d desired_acceleration = ComputeDesiredAcceleration();\n  Eigen::Vector3d angular_acceleration = ComputeAngularAcceleration(desired_acceleration);\n\n  // Project thrust onto the body z-axis\n  double thrust = desired_acceleration.z();\n  desired_acceleration.z() = 0.0;\n\n  // Combine angular acceleration and thrust into a single vector\n  Eigen::Vector3d acceleration = desired_acceleration + thrust * angular_acceleration;\n\n  // Compute rotor velocities\n  *rotor_velocities = rotor_velocity_matrix_ * acceleration.cwiseSqrt();\n\n  // Ensure non-negative values\n  *rotor_velocities = rotor_velocities->cwiseMax(0.0);\n}\n", "CodeBleu_score": 34.36632035976129}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  // Compute the position error\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // Transform the velocity to the world frame\n  Eigen::Vector3d velocity_world = odometry_.orientation * odometry_.velocity;\n\n  // Compute the velocity error\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity - velocity_world;\n\n  // Compute the desired acceleration\n  *acceleration = position_gains_.c * position_error + velocity_gains_.c * velocity_error;\n\n  // Adjust for vehicle mass, gravity, and commanded acceleration\n  *acceleration += vehicle_mass_ * gravity_ + command_trajectory_.acceleration;\n}", "CodeBleu_score": 38.83632789944162}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity - odometry_.velocity;\n\n  Eigen::Vector3d world_velocity_error = odometry_.orientation.transpose() * velocity_error;\n\n  Eigen::Vector3d acceleration_error =\n      kp_position_ * position_error + kp_velocity_ * world_velocity_error;\n\n  *acceleration = odometry_.orientation * (acceleration_error - odometry_.velocity * kd_velocity_);\n  *acceleration -= odometry_.mass * gravity_;\n  *acceleration -= command_trajectory_.acceleration;\n}\n", "CodeBleu_score": 44.5501740823281}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const  // Compute the position error\n  Eigen::Vector3d position_error = command_trajectory_.position - odometry_.position;\n\n  // Compute the velocity error\n  Eigen::Vector3d velocity_error = command_trajectory_.velocity - odometry_.velocity;\n\n  // Compute the acceleration\n  *acceleration = position_error.cwiseProduct(position_gains_) +\n                  velocity_error.cwiseProduct(velocity_gains_) +\n                  (Eigen::Vector3d::Zero() - odometry_.acceleration) * mass_ -\n                  gravity_ * Eigen::Vector3d::UnitZ() +\n                  command_trajectory_.acceleration;\n}", "CodeBleu_score": 37.922429164973195}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Ensure input and parameters are valid.\n  if (rotor_velocities == nullptr) {\n    std::cout << \"Error: AttitudeControllerSamy::CalculateRotorVelocities: \"\n              << \"Input rotor_velocities is nullptr.\" << std::endl;\n    return;\n  }\n\n  if (parameters_ == nullptr) {\n    std::cout << \"Error: AttitudeControllerSamy::CalculateRotorVelocities: \"\n              << \"Parameters are not set.\" << std::endl;\n    return;\n  }\n\n  if (parameters_->rotor_velocities_matrix.rows() != 3 ||\n      parameters_->rotor_velocities_matrix.cols() != 3) {\n    std::cout << \"Error: AttitudeControllerSamy::CalculateRotorVelocities: \"\n              << \"Rotor velocities matrix is not 3x3.\" << std::endl;\n    return;\n  }\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(parameters_->rotor_velocities_matrix.rows());\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration = parameters_->rotor_velocities_matrix * (parameters_->thrust_reference - parameters_->mass * parameters_->gravity);\n\n  // Combine the desired angular acceleration and thrust reference into a single vector.\n  Eigen::VectorXd rotor_velocities_vector(6);\n  rotor_velocities_vector << angular_acceleration, parameters_->thrust_reference;\n\n  // Compute the rotor velocities by multiplying with a predefined matrix, ensuring they are at least one, and taking the square root of each component.\n  *rotor_velocities = parameters_->rotor_velocities_matrix * rotor_velocities_vector.cwiseMax(1).cwiseSqrt();\n}\n", "CodeBleu_score": 36.08884066673495}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  assert(rotor_velocities);\n  assert(rotor_velocities->size() == kNumRotors);\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(kNumRotors);\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration_desired =\n      kGain * (angular_velocity_desired_ - angular_velocity_);\n\n  // Combine the desired angular acceleration with the thrust reference into a\n  // single vector.\n  Eigen::Vector4d rotor_velocity_command;\n  rotor_velocity_command << thrust_reference_, angular_acceleration_desired;\n\n  // Compute the rotor velocities by multiplying with a predefined matrix.\n  *rotor_velocities = kRotorVelocityMatrix * rotor_velocity_command;\n\n  // Ensure the rotor velocities are at least one.\n  for (int i = 0; i < kNumRotors; ++i) {\n    if ((*rotor_velocities)[i] < 1.0) {\n      (*rotor_velocities)[i] = 1.0;\n    }\n  }\n\n  // Take the square root of each component.\n  *rotor_velocities = rotor_velocities->cwiseSqrt();\n}\n", "CodeBleu_score": 54.95037670285038}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const  // Check that the input is valid.\n  if (rotor_velocities == nullptr) {\n    throw std::invalid_argument(\"The rotor velocities pointer is null.\");\n  }\n  if (rotor_velocities->size() != rotor_velocities_reference_.size()) {\n    throw std::invalid_argument(\"The rotor velocities vector is not the correct size.\");\n  }\n\n  // Resize the rotor velocities vector to match the number of rotors.\n  rotor_velocities->resize(rotor_velocities_reference_.size());\n\n  // Calculate the desired angular acceleration.\n  Eigen::Vector3d angular_acceleration = angular_acceleration_reference_ - angular_acceleration_feedforward_;\n\n  // Combine the thrust reference and angular acceleration into a single vector.\n  Eigen::VectorXd thrust_and_angular_acceleration(rotor_velocities_reference_.size() + 3);\n  thrust_and_angular_acceleration << thrust_reference_, angular_acceleration;\n\n  // Compute the rotor velocities by multiplying with a predefined matrix, ensuring they are at least one, and taking the square root of each component.\n  *rotor_velocities = rotor_velocities_matrix_ * thrust_and_angular_acceleration;\n  for (int i = 0; i < rotor_velocities->size(); i++) {\n    (*rotor_velocities)(i) = std::max(1.0, (*rotor_velocities)(i));\n    (*rotor_velocities)(i) = std::sqrt((*rotor_velocities)(i));\n  }\n}", "CodeBleu_score": 46.646685405887645}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    start_index = self.time.index(start_time)\n    end_index = self.time.index(end_time)\n    sliced_object = copy.deepcopy(self)\n    sliced_object.time = sliced_object.time[start_index:end_index+1]\n    sliced_object.data = sliced_object.data[start_index:end_index+1]\n    return sliced_object", "CodeBleu_score": 24.60545875753382}, {"code": "def slice(self, start_time, end_time)\n    # Find the indices of the start and end times\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n\n    # Make a deep copy of the object\n    sliced_object = copy.deepcopy(self)\n\n    # Update each attribute of the copied object to contain only the sliced data\n    for attr in dir(sliced_object):\n        if not attr.startswith('_'):\n            sliced_object.__setattr__(attr, getattr(self, attr)[start_index:end_index])\n\n    return sliced_object", "CodeBleu_score": 33.52417808080128}, {"code": "def slice(self, start_time, end_time)\n    start_index = self.find_index(start_time)\n    end_index = self.find_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    for attr in sliced_object.__dict__:\n        if attr == \"time\":\n            sliced_object.__dict__[attr] = sliced_object.__dict__[attr][start_index:end_index]\n        elif attr == \"data\":\n            sliced_object.__dict__[attr] = sliced_object.__dict__[attr][start_index:end_index, :]\n    return sliced_object\n\n", "CodeBleu_score": 34.46727298775479}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n\n    # Convert rotation to Euler angles\n    (roll, pitch, yaw) = self.euler_from_quaternion(rotation)\n\n    # Create a Point object with the extracted position and yaw\n    point = Point(position.x, position.y, position.z, yaw)\n\n    # Check if the current waypoint is different from the last one\n    if self.current_waypoint != point:\n        # If the waypoint is different, append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.waypoints_x.append(position.x)\n        self.waypoints_y.append(position.y)\n        self.waypoints_z.append(position.z)\n        self.waypoints_yaw.append(yaw)\n        self.waypoints_time.append(bag_time)\n        self.waypoints_msg_time.append(msg_time)\n        self.current_waypoint = point\n", "CodeBleu_score": 17.434163349783223}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.position\n    rotation = waypoint_msg.pose.orientation\n    # Convert rotation to Euler angles\n    roll, pitch, yaw = self.euler_from_quaternion(rotation)\n    # Create Point object with position and yaw\n    point = Point(position.x, position.y, position.z, yaw)\n    # Check if the current waypoint is different from the last one\n    if self.last_point is None or not self.points_equal(self.last_point, point):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.points.append(point)\n        self.yaws.append(yaw)\n        self.times.append(msg_time)\n        self.bag_times.append(bag_time)\n        # Update the last point\n        self.last_point = point\n", "CodeBleu_score": 21.360457907005088}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation from waypoint message\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    (roll, pitch, yaw) = self.euler_from_quaternion(rotation)\n\n    # Create a Point object\n    point = Point(position.x, position.y, position.z)\n\n    # Check if the current waypoint is different from the last one\n    if (self.last_waypoint_position is None or\n            self.last_waypoint_position != point or\n            self.last_waypoint_yaw != yaw):\n        # Append the new point, yaw, and corresponding times to their respective arrays\n        self.waypoints.append(point)\n        self.waypoints_yaw.append(yaw)\n        self.waypoints_time.append(msg_time)\n        self.waypoints_bag_time.append(bag_time)\n        self.last_waypoint_position = point\n        self.last_waypoint_yaw = yaw\n", "CodeBleu_score": 26.77836032628054}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == self.imu_topic:\n        self.imu_accel_x.append(msg.linear_acceleration.x)\n        self.imu_accel_y.append(msg.linear_acceleration.y)\n        self.imu_accel_z.append(msg.linear_acceleration.z)\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.bag_time.append(bag_time)\n", "CodeBleu_score": 32.00098225737562}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu/data\":\n        self.imu_data.x.append(msg.linear_acceleration.x)\n        self.imu_data.y.append(msg.linear_acceleration.y)\n        self.imu_data.z.append(msg.linear_acceleration.z)\n        self.imu_data.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_data.bag_time.append(bag_time)\n\n    elif topic == \"/imu/data_raw\":\n        self.imu_data_raw.x.append(msg.linear_acceleration.x)\n        self.imu_data_raw.y.append(msg.linear_acceleration.y)\n        self.imu_data_raw.z.append(msg.linear_acceleration.z)\n        self.imu_data_raw.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_data_raw.bag_time.append(bag_time)\n\n    elif topic == \"/imu/mag\":\n        self.imu_mag.x.append(msg.magnetic_field.x)\n        self.imu_mag.y.append(msg.magnetic_field.y)\n        self.imu_mag.z.append(msg.magnetic_field.z)\n        self.imu_mag.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_mag.bag_time.append(bag_time)\n\n    elif topic == \"/imu/gyro\":\n        self.imu_gyro.x.append(msg.angular_velocity.x)\n        self.imu_gyro.y.append(msg.angular_velocity.y)\n        self.imu_gyro.z.append(msg.angular_vel", "CodeBleu_score": 32.32953066870038}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == \"/imu/data\":\n        self.imu_data.x.append(msg.linear_acceleration.x)\n        self.imu_data.y.append(msg.linear_acceleration.y)\n        self.imu_data.z.append(msg.linear_acceleration.z)\n        self.imu_data.time.append(msg.header.stamp.secs + msg.header.stamp.nsecs * 1e-9)\n        self.imu_data.bag_time.append(bag_time)\n", "CodeBleu_score": 32.20244223374205}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n    # Create a figure with a title\n    fig = plt.figure()\n    fig.suptitle('Acceleration Data')\n\n    # Create a subplot for accelerations\n    ax = fig.add_subplot(111)\n\n    # Plot the x, y, and z components of each acceleration dataset\n    for i, acc_data in enumerate(self.accelerations):\n        ax.plot(acc_data[:, 0], acc_data[:, 1], label=f'Acceleration {i+1}')\n        ax.plot(acc_data[:, 0], acc_data[:, 2], label=f'Acceleration {i+1}')\n        ax.plot(acc_data[:, 0], acc_data[:, 3], label=f'Acceleration {i+1}')\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename and save the plot\n    if self.save_plots:\n        filename = f'accelerations{plot_suffix}.png'\n        plt.savefig(filename)\n\n    # Show the plot\n    plt.show()", "CodeBleu_score": 33.73171011447219}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    # Create a figure with a title and a subplot for accelerations\n    fig, ax = plt.subplots()\n    fig.suptitle('Accelerations')\n\n    # Plot the x, y, and z components of each acceleration dataset with different colors and labels\n    for i, acc_data in enumerate(self.accelerations):\n        ax.plot(acc_data[:, 0], acc_data[:, 1], color='red', label=f'Acceleration {i+1} - X')\n        ax.plot(acc_data[:, 0], acc_data[:, 2], color='green', label=f'Acceleration {i+1} - Y')\n        ax.plot(acc_data[:, 0], acc_data[:, 3], color='blue', label=f'Acceleration {i+1} - Z')\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        filename = f'{self.plot_prefix}_accelerations'\n        if plot_suffix:\n            filename += f'_{plot_suffix}'\n        filename += '.png'\n        plt.savefig(filename)\n\n    # Show the plot\n    plt.show()", "CodeBleu_score": 33.32573549103124}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    # Create a figure with a title and a subplot for accelerations\n    fig, ax = plt.subplots()\n    fig.suptitle('Acceleration Data')\n\n    # Plot the x, y, and z components of each acceleration dataset with different colors and labels\n    for i, accel_data in enumerate(self.accelerations):\n        ax.plot(accel_data[:, 0], accel_data[:, 1], color='blue', label='x')\n        ax.plot(accel_data[:, 0], accel_data[:, 2], color='green', label='y')\n        ax.plot(accel_data[:, 0], accel_data[:, 3], color='red', label='z')\n\n    # Add labels for the x and y axes\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n\n    # Include a legend\n    ax.legend()\n\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file\n    if self.save_plots:\n        if plot_suffix is None:\n            plot_suffix = ''\n        plot_filename = f'accelerations{plot_suffix}.png'\n        fig.savefig(plot_filename)", "CodeBleu_score": 32.15679906697795}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n", "CodeBleu_score": 33.928874702442826}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        raise ValueError(\"At least two pose indices are required for comparison.\")\n\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])", "CodeBleu_score": 39.76931562692286}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n        print(\"Please provide at least two pose indices.\")\n        return\n    for i in range(len(pose_indeces)):\n        for j in range(i + 1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n", "CodeBleu_score": 40.05528919851491}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n        elif start_time is not None:\n            if start_time <= collision.time:\n                collision_times.append(collision.time)\n        elif end_time is not None:\n            if collision.time <= end_time:\n                collision_times.append(collision.time)\n        else:\n            collision_times.append(collision.time)\n    return collision_times\n\n", "CodeBleu_score": 39.56249004507008}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for collision in self.wrench:\n        if start_time is None or end_time is None:\n            collision_times.append(collision.time)\n        else:\n            if start_time <= collision.time <= end_time:\n                collision_times.append(collision.time)\n    return collision_times\n", "CodeBleu_score": 44.834855687571064}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n        if start_time is not None and end_time is not None:\n            if start_time <= time <= end_time:\n                collision_times.append(time)\n        elif start_time is not None:\n            if start_time <= time:\n                collision_times.append(time)\n        elif end_time is not None:\n            if time <= end_time:\n                collision_times.append(time)\n        else:\n            collision_times.append(time)\n    return collision_times", "CodeBleu_score": 38.215054985044276}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    # Calculate the absolute settling time by adding the settling time to the start time\n    absolute_settling_time = start_time + settling_time\n\n    # Call the analyze_bag.plot_angular_velocities function with the specified start time, end time, settling time, x-axis range, plot suffix, and y-axis range of [-1.5, 1.5]\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 30.087936187511037}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    # Calculate the absolute settling time by adding the settling time to the start time\n    absolute_settling_time = start_time + settling_time\n\n    # Plot the angular velocities over the specified time range\n    analyze_bag.plot_angular_velocities(start_time, end_time, absolute_settling_time, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 32.10207328495848}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    settling_time_end = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time_end, x_range, plot_suffix, y_range=[-1.5, 1.5])\n\n", "CodeBleu_score": 30.50199424237684}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n  const float multiplier =\n      (float)sqrt(width * height) / (float)(width * height);\n  Eigen::Map<Eigen::VectorXf> data_vector(data, width * height);\n  const float rms_noise =\n      multiplier *\n      sqrt(this->rms_noise_ * this->rms_noise_ / (width * height));\n  Eigen::VectorXf noise_values =\n      Eigen::VectorXf::Random(width * height) * rms_noise;\n  for (int i = 0; i < width * height; i++) {\n    if (data_vector(i) < this->bad_point_value_) {\n      data_vector(i) += noise_values(i);\n    } else {\n      data_vector(i) = this->bad_point_value_;\n    }\n  }\n}\n", "CodeBleu_score": 58.883024842200946}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n\n  // Calculate multiplier based on camera parameters\n  float multiplier =\n      (float)sqrt(static_cast<double>(width * height)) /\n      (float)sqrt(static_cast<double>(width * height - num_bad_points_));\n\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n\n  // Compute RMS noise\n  float rms_noise = (float)sqrt(static_cast<double>(rms_noise_));\n\n  // Compute noise values\n  Eigen::VectorXf noise_values = rms_noise * Eigen::VectorXf::Random(width * height);\n\n  // Add noise to data\n  for (int i = 0; i < width * height; i++) {\n    if (depth_data[i] != bad_point_value_) {\n      depth_data[i] += multiplier * noise_values[i];\n    }\n  }\n}\n", "CodeBleu_score": 51.4579853221798}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)  if (data == nullptr) {\n    return;\n  }\n  // Calculate multiplier based on camera parameters\n  const float multiplier =\n      static_cast<float>(sqrt(1000.0f / (width * height)));\n  // Map data to Eigen vector\n  Eigen::Map<Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic,\n                           Eigen::RowMajor>>\n      data_eigen(data, height, width);\n  // Compute RMS noise\n  const float rms_noise =\n      static_cast<float>(sqrt(1000.0f / (width * height)) *\n                         rng_.Gaussian(rms_noise_std_dev_));\n  // Compute noise values\n  Eigen::VectorXf noise_values =\n      Eigen::VectorXf::NullaryExpr(width * height, [&]() {\n        return static_cast<float>(rng_.Gaussian(rms_noise));\n      });\n  // Add noise to data\n  data_eigen = data_eigen.array() + noise_values.array();\n  // Set bad points\n  for (uint32_t i = 0; i < width * height; ++i) {\n    if (data[i] < min_range_ || data[i] > max_range_) {\n      data[i] = bad_point_value_;\n    }\n  }\n}", "CodeBleu_score": 48.781628826638624}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  ros::Time ros_time = ros::Time::now();\n  ros::Time sim_time = this->world_->SimTime();\n  ros::Duration sim_time_duration(sim_time.sec, sim_time.nsec);\n  ros::Time ros_time_trajectory = ros_time - sim_time_duration;\n\n  this->bag_writer_->write(this->waypoint_topic_, ros_time_trajectory,\n                           *trajectory_msg);\n}\n", "CodeBleu_score": 42.84827588052451}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  ros::Time ros_time = ros::Time::now();\n  ros::Time sim_time = this->world_->SimTime();\n  ros::Duration sim_time_diff = sim_time - this->last_sim_time_;\n  ros::Duration ros_time_diff = ros_time - this->last_ros_time_;\n  if (sim_time_diff.toSec() > 0) {\n    this->bag_writer_.write(\n        this->namespace_ + \"/waypoint\", ros_time, *trajectory_msg);\n  }\n  this->last_sim_time_ = sim_time;\n  this->last_ros_time_ = ros_time;\n}\n", "CodeBleu_score": 45.31283900193374}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)  // Get the current simulation time\n  common::Time current_time = world_->GetSimTime();\n\n  // Convert the simulation time to ROS time\n  ros::Time ros_time = ros::Time::fromSec(current_time.Double());\n\n  // Write the trajectory message to the bag file\n  bag_writer_.write(\"/trajectory\", ros_time, *trajectory_msg);\n}", "CodeBleu_score": 48.21516960060567}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\n  // Convert the simulation time to ROS time\n  ros::Time ros_now = ros::Time::fromBoost(now.toSimTime());\n\n  // Prepare the message\n  motor_velocities_msg.header.stamp = ros_now;\n  motor_velocities_msg.header.frame_id = \"base_link\";\n  motor_velocities_msg.velocities.clear();\n\n  // Iterate through the motor joints\n  for (int i = 0; i < motor_joints.size(); i++) {\n\n    // Get the joint velocity and convert it to radians per second\n    double joint_velocity = motor_joints[i]->GetVelocity(0);\n    double rotational_velocity = joint_velocity * motor_joints[i]->GetParent()->GetAngle(0).Radian();\n\n    // Calculate the slowed-down rotational velocity\n    double slowed_down_rotational_velocity = rotational_velocity * slowdown_factor;\n\n    // Assign the slowed-down rotational velocity to the message\n    motor_velocities_msg.velocities.push_back(slowed_down_rotational_velocity);\n  }\n\n  // Set the message timestamp and write it to the bag file\n  motor_velocities_msg.header.stamp = ros_now;\n  motor_velocities_bag.write(motor_topic, ros_now, motor_velocities_msg);\n}\n", "CodeBleu_score": 47.48151448152324}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)  // Convert simulation time to ROS time.\n  ros::Time ros_time = ros::Time::now();\n  // Prepare message for actuator velocities.\n  sensor_msgs::JointState msg;\n  msg.name.resize(motor_joints_.size());\n  msg.position.resize(motor_joints_.size());\n  msg.velocity.resize(motor_joints_.size());\n  msg.effort.resize(motor_joints_.size());\n  msg.header.stamp = ros_time;\n  // Iterate through motor joints.\n  for (size_t i = 0; i < motor_joints_.size(); ++i) {\n    // Get joint name.\n    msg.name[i] = motor_joints_[i]->GetName();\n    // Get joint position.\n    msg.position[i] = motor_joints_[i]->GetAngle(0).Radian();\n    // Get joint velocity.\n    msg.velocity[i] = motor_joints_[i]->GetVelocity(0);\n    // Get joint effort.\n    msg.effort[i] = motor_joints_[i]->GetForce(0);\n  }\n  // Write message to bag file.\n  bag_.write(namespace_ + motor_topic_, ros_time, msg);\n}\n", "CodeBleu_score": 46.71472569830233}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)    // Convert simulation time to ROS time\n    ros::Time ros_time = ros::Time::fromSec(now.Double());\n\n    // Prepare message\n    actuator_msgs::ActuatorVelocities msg;\n    msg.header.stamp = ros_time;\n\n    // Iterate through motor joints\n    for (auto joint : motor_joints_) {\n        // Get joint name\n        std::string joint_name = joint->GetName();\n\n        // Get joint velocity\n        double joint_velocity = joint->GetVelocity(0);\n\n        // Calculate slowed-down rotational velocity\n        double rotational_velocity = joint_velocity * motor_velocity_ratio_;\n\n        // Assign rotational velocity to message\n        msg.velocities[joint_name] = rotational_velocity;\n    }\n\n    // Write message to bag file\n    motor_bag_writer_.write(ros_time, msg);\n}\n", "CodeBleu_score": 40.29161318909538}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_print_) {\n    ROS_INFO(\"RollPitchYawrateThrustCallback() called.\");\n  }\n  double roll = roll_pitch_yawrate_thrust_msg->roll;\n  double pitch = roll_pitch_yawrate_thrust_msg->pitch;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate;\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Calculate control surface angles from normalized input values\n  double aileron_angle = roll * aileron_max_angle_;\n  double elevator_angle = pitch * elevator_max_angle_;\n  double rudder_angle = yaw_rate * rudder_max_angle_;\n\n  // Set control surface angles\n  SetControlSurfaceAngles(aileron_angle, elevator_angle, rudder_angle);\n\n  // Set throttle\n  SetThrottle(thrust);\n}\n", "CodeBleu_score": 40.20419442410633}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  // If debug printing is enabled, log that the callback was called\n  if (debug_printing_) {\n    std::cout << \"RollPitchYawrateThrustCallback called\" << std::endl;\n  }\n\n  // Convert the normalized input values for roll, pitch, and yaw rate to\n  // control surface angles for ailerons, elevator, and rudder respectively\n  double roll_angle = roll_pitch_yawrate_thrust_msg->roll * max_aileron_angle_;\n  double pitch_angle = roll_pitch_yawrate_thrust_msg->pitch * max_elevator_angle_;\n  double yaw_rate = roll_pitch_yawrate_thrust_msg->yaw_rate * max_rudder_angle_;\n\n  // Set the throttle value from the thrust message\n  double thrust = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // If debug printing is enabled, log the control surface angles and throttle\n  // value\n  if (debug_printing_) {\n    std::cout << \"Roll angle: \" << roll_angle << std::endl;\n    std::cout << \"Pitch angle: \" << pitch_angle << std::endl;\n    std::cout << \"Yaw rate: \" << yaw_rate << std::endl;\n    std::cout << \"Thrust: \" << thrust << std::endl;\n  }\n\n  // Publish the control surface angles and throttle value to the topic\n  // \"roll_pitch_yawrate_thrust\"\n  roll_pitch_yawrate_thrust_msg->header.stamp = gazebo_node_->GetSimTime();\n  roll_pitch_yawrate_thrust_publisher_.publish(roll_pitch_yawrate_thrust_msg);\n}\n", "CodeBleu_score": 48.59163491213746}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)  if (debug_printing_) {\n    ROS_INFO_STREAM(\"RollPitchYawrateThrustCallback called\");\n  }\n\n  // Normalized roll, pitch, and yaw rate\n  double roll_normalized = roll_pitch_yawrate_thrust_msg->roll;\n  double pitch_normalized = roll_pitch_yawrate_thrust_msg->pitch;\n  double yaw_rate_normalized = roll_pitch_yawrate_thrust_msg->yaw_rate;\n\n  // Control surface angles\n  double aileron_angle = roll_normalized * aileron_max_angle_;\n  double elevator_angle = pitch_normalized * elevator_max_angle_;\n  double rudder_angle = yaw_rate_normalized * rudder_max_angle_;\n\n  // Throttle value\n  double throttle = roll_pitch_yawrate_thrust_msg->thrust;\n\n  // Set control surface angles\n  SetControlSurfaceAngles(aileron_angle, elevator_angle, rudder_angle);\n\n  // Set throttle value\n  SetThrottle(throttle);\n}\n", "CodeBleu_score": 37.54681361474553}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // Convert the timeout to a timeval structure\n  struct timeval tv;\n  tv.tv_sec = _timeoutMs / 1000;\n  tv.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Perform a poll operation on file descriptors\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(this->serial_fd, &readfds);\n  int retval = select(this->serial_fd + 1, &readfds, NULL, NULL, &tv);\n\n  // If data is available, receive and parse MAVLink messages\n  if (retval > 0) {\n    // Receive data from the serial port\n    uint8_t buf[1024];\n    int len = read(this->serial_fd, buf, sizeof(buf));\n\n    // Parse MAVLink messages from the buffer\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (int i = 0; i < len; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n        // Forward the message to the serial connection\n        this->sendMAVLinkMessage(msg);\n\n        // Handle the message based on its type\n        switch (msg.msgid) {\n        case MAVLINK_MSG_ID_HEARTBEAT:\n          // Handle heartbeat message\n          this->handleHeartbeatMessage(msg);\n          break;\n        case MAVLINK_MSG_ID_ATTITUDE:\n          // Handle attitude message\n          this->handleAttitudeMessage(msg);\n          break;\n        case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n          // Handle global position message\n          this->handleGlobalPositionIntMessage(msg);\n          break;\n        case MAVLINK_MSG_ID_LOCAL_POSITION_NED:\n          // Handle local position message\n          this->handleLocalPositionNEDMessage", "CodeBleu_score": 52.842674478968796}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // Convert timeout to timeval structure\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Perform poll operation on file descriptors\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serialPortFD, &readfds);\n  int retval = select(serialPortFD + 1, &readfds, NULL, NULL, &timeout);\n\n  // If data is available, receive and parse MAVLink messages\n  if (retval > 0) {\n    // Receive data from serial port\n    uint8_t buf[1024];\n    int bytesRead = read(serialPortFD, buf, sizeof(buf));\n    if (bytesRead <= 0) {\n      std::cerr << \"Error reading from serial port\" << std::endl;\n      return;\n    }\n\n    // Parse MAVLink messages from buffer\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (int i = 0; i < bytesRead; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buf[i], &msg, &status)) {\n        // Handle message\n        handleMAVLinkMessage(msg);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 57.513938514275665}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)  // Create a timeval structure for the timeout\n  struct timeval timeout;\n  timeout.tv_sec = _timeoutMs / 1000;\n  timeout.tv_usec = (_timeoutMs % 1000) * 1000;\n\n  // Create a fd_set structure for the file descriptors\n  fd_set readfds;\n  FD_ZERO(&readfds);\n  FD_SET(serialPort_->getFileDescriptor(), &readfds);\n\n  // Perform the poll operation\n  int retval = select(serialPort_->getFileDescriptor() + 1, &readfds, NULL,\n                      NULL, &timeout);\n\n  // If data is available, receive and parse the data\n  if (retval > 0) {\n    // Receive data from the serial port\n    uint8_t buffer[1024];\n    int bytesRead = serialPort_->read(buffer, sizeof(buffer));\n\n    // Parse the MAVLink messages from the buffer\n    mavlink_message_t msg;\n    mavlink_status_t status;\n    for (int i = 0; i < bytesRead; i++) {\n      if (mavlink_parse_char(MAVLINK_COMM_0, buffer[i], &msg, &status)) {\n        // Handle the message\n        handleMAVLinkMessage(msg);\n      }\n    }\n  }\n}\n", "CodeBleu_score": 57.45284636721553}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close()     if (isOpen()) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        io_service_.stop();\n        serial_port_.close();\n        if (io_thread_.joinable()) {\n            io_thread_.join();\n        }\n    }\n}\n", "CodeBleu_score": 59.750990363771784}, {"code": "void GazeboMavlinkInterface::close()     std::lock_guard<std::mutex> lock(mutex);\n    if (isOpen) {\n        ioService.stop();\n        serialDevice.close();\n        if (ioThread.joinable()) {\n            ioThread.join();\n        }\n        isOpen = false;\n    }\n}\n", "CodeBleu_score": 53.76239446134783}, {"code": "void GazeboMavlinkInterface::close()     boost::mutex::scoped_lock lock(mutex);\n\n    if (open) {\n        io_service.stop();\n        serial_device.close();\n        if (io_thread.joinable()) {\n            io_thread.join();\n        }\n        open = false;\n    }\n}\n", "CodeBleu_score": 54.91578318893951}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    double x, double y, double z, double x1, double y1, double z1, double x2, double y2, double z2, double x3, double y3, double z3\n} {\n    double a1 = (y2 - y1) / (x2 - x1);\n    double b1 = (z2 - z1) / (x2 - x1);\n    double c1 = (y3 - y2) / (x3 - x2);\n    double d1 = (z3 - z2) / (x3 - x2);\n\n    double a = y - y1;\n    double b = z - z1;\n    double c = y2 - y;\n    double d = z2 - z;\n\n    double e = (a1 * b - b1 * a) / (c1 * d1 - d1 * c1);\n    double f = (a - c * e) / d1;\n\n    double x_interpolated = x;\n    double y_interpolated = y + e;\n    double z_interpolated = z + f;\n\n    return ignition::math::Vector3d(x_interpolated, y_interpolated, z_interpolated);\n}", "CodeBleu_score": 29.34937527061092}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation    ignition::math::Vector3d p0, ignition::math::Vector3d p1, ignition::math::Vector3d v0, ignition::math::Vector3d v1, double t\n} {\n    return (1 - t) * v0 + t * v1;\n}\n", "CodeBleu_score": 34.524132074228305}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation  ignition::math::Vector3d point1, point2, values1, values2;\n  double x = position.X();\n  double y = position.Y();\n  double z = position.Z();\n  if (x >= point1.X() && x <= point2.X()) {\n    double slope = (values2.X() - values1.X()) / (point2.X() - point1.X());\n    double y_intercept = values1.X() - slope * point1.X();\n    double interpolated_value = slope * x + y_intercept;\n    return ignition::math::Vector3d(interpolated_value, 0, 0);\n  }\n  else if (y >= point1.Y() && y <= point2.Y()) {\n    double slope = (values2.Y() - values1.Y()) / (point2.Y() - point1.Y());\n    double y_intercept = values1.Y() - slope * point1.Y();\n    double interpolated_value = slope * y + y_intercept;\n    return ignition::math::Vector3d(0, interpolated_value, 0);\n  }\n  else if (z >= point1.Z() && z <= point2.Z()) {\n    double slope = (values2.Z() - values1.Z()) / (point2.Z() - point1.Z());\n    double y_intercept = values1.Z() - slope * point1.Z();\n    double interpolated_value = slope * z + y_intercept;\n    return ignition::math::Vector3d(0, 0, interpolated_value);\n  }\n  else {\n    return ignition::math::Vector3d(0, 0, 0);\n  }\n}\n", "CodeBleu_score": 33.60880139633257}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)\tif (_time != time) {\n\t\ttime = _time;\n\t\tUpdate();\n\t}\n}\n", "CodeBleu_score": 27.565980489148632}, {"code": "void Animation::SetTime(double _time)    if (_time != time) {\n        time = _time;\n        if (looping) {\n            time = fmod(time, length);\n            if (time < 0) {\n                time += length;\n            }\n        } else {\n            time = std::min(length, std::max(0.0, time));\n        }\n        Update();\n    }\n}\n", "CodeBleu_score": 39.33159782029448}, {"code": "void Animation::SetTime(double _time)\ttime = _time;\n\ttime = fmod(time, length);\n\tif (time < 0) time += length;\n}\n", "CodeBleu_score": 19.444064448030137}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.simple_takeoff(10)\n    while True:\n        print(\"Vehicle type: %s\" % self.vehicle._vehicle_type)\n        print(\"Vehicle ID: %s\" % self.vehicle.id)\n        print(\"Flight mode: %s\" % self.vehicle.mode.name)\n        if self.vehicle.mode.name == \"GUIDED\":\n            break\n        time.sleep(1)\n    self.vehicle.coordinate_frame = 1\n    self.vehicle.motion_type = 0\n    self.vehicle.simple_takeoff(10)\n    while True:\n        print(\"Vehicle type: %s\" % self.vehicle._vehicle_type)\n        print(\"Vehicle ID: %s\" % self.vehicle.id)\n        print(\"Flight mode: %s\" % self.vehicle.mode.name)\n        if self.vehicle.mode.name == \"GUIDED\":\n            break\n        time.sleep(1)\n    self.vehicle.coordinate_frame = 1\n    self.vehicle.motion_type = 0\n    self.vehicle.simple_takeoff(10)\n    while True:\n        print(\"Vehicle type: %s\" % self.vehicle._vehicle_type)\n        print(\"Vehicle ID: %s\" % self.vehicle.id)\n        print(\"Flight mode: %s\" % self.vehicle.mode.name)\n        if self.vehicle.mode.name == \"GUIDED\":\n            break\n        time.sleep(1)\n    self.vehicle.coordinate_frame = 1\n    self.vehicle.motion_type = 0\n    self.vehicle.simple_takeoff(10)\n    while True:\n        print(\"Vehicle type: %s\" % self.vehicle._vehicle_", "CodeBleu_score": 21.775933423121472}, {"code": "def hover(self)\n    self.cf = 1\n    self.mt = 0\n    self.target_motion = np.array([self.px, self.py, self.pz, self.vx, self.vy, self.vz, self.yaw, self.yaw_rate, self.ax, self.ay, self.az, self.roll, self.pitch, self.yaw, self.roll_rate, self.pitch_rate, self.yaw_rate])\n    print(\"Vehicle Type:\", self.vehicle_type)\n    print(\"Vehicle ID:\", self.vehicle_id)\n    print(\"Flight Mode:\", self.flight_mode)\n", "CodeBleu_score": 45.60119031182092}, {"code": "def hover(self)\n    self.cf.param_set(\"coordinate_frame\", 1)\n    self.cf.param_set(\"motion_type\", 0)\n    target_pos = self.cf.global_position_int\n    target_yaw = self.cf.yaw\n    self.hover_target = [target_pos.latitude, target_pos.longitude, target_pos.altitude, target_yaw]\n    print(\"Vehicle type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight mode: %s\" % self.cf.flight_mode)\n", "CodeBleu_score": 22.88722069032627}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover_flag = 1\n        self.hover()\n        print(\"Hover mode enabled\")\n        return True\n    else:\n        try:\n            self.flight_mode_service.set_flight_mode(self.flight_mode)\n            print(f\"Flight mode switched to {self.flight_mode}\")\n            return True\n        except Exception as e:\n            print(f\"Failed to switch flight mode: {e}\")\n            return False", "CodeBleu_score": 52.780566287156674}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover()\n        print('Successfully switched to HOVER mode')\n        return True\n    else:\n        try:\n            self.flight_mode_service.set_flight_mode(self.flight_mode)\n            print('Successfully switched to {} mode'.format(self.flight_mode))\n            return True\n        except:\n            print('Failed to switch to {} mode'.format(self.flight_mode))\n            return False\n", "CodeBleu_score": 54.40279925171163}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == \"HOVER\":\n        self.hover = 1\n        self.hover_mode()\n        print(\"Hover mode enabled\")\n        return True\n    else:\n        try:\n            self.vehicle.mode = self.flight_mode\n            print(\"Flight mode switched to: \", self.flight_mode)\n            return True\n        except:\n            print(\"Flight mode switch failed\")\n            return False", "CodeBleu_score": 38.60994803243351}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = Motion(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n", "CodeBleu_score": 37.27892540582455}, {"code": "def cmd_vel_enu_callback(self, msg)\n    # Get the linear and angular components of the message\n    linear_x = msg.linear.x\n    linear_y = msg.linear.y\n    linear_z = msg.linear.z\n    angular_x = msg.angular.x\n    angular_y = msg.angular.y\n    angular_z = msg.angular.z\n\n    # Call the hover_state_transition function with the linear and angular components\n    self.hover_state_transition(linear_x, linear_y, linear_z, angular_x, angular_y, angular_z)\n\n    # If the hover_flag is not set, call the hold_state_transition function with the same components and the 'enu' frame\n    if not self.hover_flag:\n        self.hold_state_transition(linear_x, linear_y, linear_z, angular_x, angular_y, angular_z, 'enu')\n\n    # If both hover_flag and hold_flag are not set, set the coordinate_frame and motion_type to 1, and construct the target motion using the message components\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [linear_x, linear_y, linear_z, angular_x, angular_y, angular_z]", "CodeBleu_score": 29.416104377650893}, {"code": "def cmd_vel_enu_callback(self, msg)\n    # TODO: implement\n    # self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    # if not self.hover_flag:\n    #     self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    # else:\n    #     self.coordinate_frame = 1\n    #     self.motion_type = 1\n    #     self.target_motion = msg\n", "CodeBleu_score": 1.031650641025641}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 1\n            self.hover_mode_change()\n    elif self.hover_flag == 1:\n        if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n            self.hover_flag = 0\n            self.hover_mode_change()\n", "CodeBleu_score": 41.24073356694993}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.hover_flag == 0:\n        if x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005:\n            self.hover_flag = 0\n            self.set_mode(\"OFFBOARD\")\n    elif self.hover_flag == 1:\n        if x < 0.02 and y < 0.02 and z < 0.02 and w < 0.005:\n            self.hover_flag = 0\n            self.set_mode(\"OFFBOARD\")\n        else:\n            self.hover_flag = 1\n            self.set_mode(\"HOVER\")\n            self.hover()\n", "CodeBleu_score": 40.78624836682071}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if self.hover_flag == 0:\n        if (x > 0.02 or x < -0.02 or y > 0.02 or y < -0.02 or z > 0.02 or z < -0.02 or w > 0.005):\n            self.hover_flag = 0\n            self.change_mode(\"OFFBOARD\")\n    elif self.hover_flag == 1:\n        if (x > 0.02 or x < -0.02 or y > 0.02 or y < -0.02 or z > 0.02 or z < -0.02 or w > 0.005):\n            self.hover_flag = 0\n            self.change_mode(\"OFFBOARD\")\n        elif (x < 0.02 and x > -0.02 and y < 0.02 and y > -0.02 and z < 0.02 and z > -0.02 and w < 0.005):\n            self.hover_flag = 1\n            self.change_mode(\"HOVER\")\n            self.hover_action()\n", "CodeBleu_score": 32.692175496408915}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n", "CodeBleu_score": 24.26411761619382}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        yaw = q.yaw\n    else:\n        q = Quaternion(q)\n        yaw = q.yaw\n    return yaw\n", "CodeBleu_score": 27.52863807726429}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    self.coordinate_frame = \"BODY\"\n    self.motion_type = \"hover\"\n    self.target_motion = Motion(self.position, self.yaw)\n    print(f\"Vehicle type: {self.vehicle_type}\\nVehicle ID: {self.vehicle_id}\\nFlight mode: {self.motion_type}\")\n", "CodeBleu_score": 13.385091324925877}, {"code": "def hover(self)\n    self.coord_frame = \"BODY_FRAME\"\n    self.motion_type = \"position\"\n    self.target_motion = [self.position[0], self.position[1], self.position[2], self.yaw]\n    print(f\"{self.vehicle_type} {self.vehicle_id} is in HOVER mode\")\n\n", "CodeBleu_score": 22.73734428988296}, {"code": "def hover(self)\n    self.coordinate_frame = CoordinateFrame.BODY_FRAME\n    self.motion_type = MotionType.TARGET_POSITION_YAW\n    self.target_motion = Motion(\n        self.position,\n        self.yaw,\n        self.position_gain,\n        self.yaw_gain,\n        self.position_deadband,\n        self.yaw_deadband,\n        self.position_rate_gain,\n        self.yaw_rate_gain,\n        self.position_rate_deadband,\n        self.yaw_rate_deadband,\n    )\n    print(f\"Vehicle Type: {self.vehicle_type}\")\n    print(f\"Vehicle ID: {self.vehicle_id}\")\n    print(f\"Flight Mode: {self.flight_mode}\")\n\n", "CodeBleu_score": 19.782485612084148}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        self.hover_flag = False\n        try:\n            self.flightModeService.set_flight_mode(self.flight_mode)\n            self.flight_mode = self.flightModeService.get_flight_mode()\n            print('Flight mode switched to: {}'.format(self.flight_mode))\n            return True\n        except Exception as e:\n            print('Failed to switch flight mode: {}'.format(e))\n            return False", "CodeBleu_score": 45.58261110335147}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover = True\n        self.hover_mode()\n        return True\n    else:\n        try:\n            self.flightModeService.set_flight_mode(self.flight_mode)\n            print(f\"Flight mode set to {self.flight_mode}\")\n            return True\n        except Exception as e:\n            print(f\"Failed to set flight mode: {e}\")\n            return False\n", "CodeBleu_score": 46.36716701559348}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = True\n        self.hover()\n        return True\n    else:\n        try:\n            self.flight_mode_service.set_flight_mode(self.flight_mode)\n            print(f\"Flight mode set to {self.flight_mode}\")\n            return True\n        except Exception as e:\n            print(f\"Failed to set flight mode: {e}\")\n            return False\n", "CodeBleu_score": 48.234823748005574}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 51.10360294045804}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 51.10360294045804}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n        self.visualize()\n", "CodeBleu_score": 51.10360294045804}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n    if msg.id == i:\n        self.local_pose = msg.pose\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = self.local_pose\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = self.local_pose\n        self.global_pose.position.x = self.local_pose.position.x + self.bias_x\n        self.global_pose.position.y = self.local_pose.position.y + self.bias_y\n        self.global_pose.position.z = self.local_pose.position.z + self.bias_z\n        self.global_pose.orientation = self.local_pose.orientation\n", "CodeBleu_score": 27.90278688427621}, {"code": "def local_pose_callback(self, msg, i)\n\n    # If the message index matches the UAV ID, update the local pose\n    if msg.id == self.uav_id:\n        self.local_pose = msg.pose\n\n        # If the GCS command is takeoff, update the takeoff target pose\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = self.local_pose\n            self.takeoff_target_pose.position.z += 1.0\n\n        # If the GCS command is hover, update the hover target pose\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = self.local_pose\n\n        # Update the global pose for the UAV, applying a bias to the position coordinates\n        self.global_pose = self.local_pose\n        self.global_pose.position.x += 0.1 * i\n        self.global_pose.position.y += 0.1 * i\n\n        # Publish the global pose for the UAV\n        self.global_pose_pub.publish(self.global_pose)\n\n    # If the message index does not match the UAV ID, do nothing\n    else:\n        pass", "CodeBleu_score": 26.14199772000813}, {"code": "def local_pose_callback(self, msg, i)\n    if msg.id == self.id:\n        self.local_pose = msg.pose\n        if self.gcs_command == \"takeoff\":\n            self.takeoff_target_pose = msg.pose\n        elif self.gcs_command == \"hover\":\n            self.hover_target_pose = msg.pose\n        self.global_pose = msg.pose\n        self.global_pose.position.x += self.bias[i][0]\n        self.global_pose.position.y += self.bias[i][1]\n        self.global_pose.position.z += self.bias[i][2]\n\n", "CodeBleu_score": 29.544865765543076}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state:\n        return True\n    else:\n        return False\n", "CodeBleu_score": 70.13649723325177}, {"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == \"ACTIVE\":\n        return True\n    else:\n        return False\n", "CodeBleu_score": 62.71503411199135}, {"code": "def takeoff_detection(self)\n    if self.arm_state == \"active\" and self.altitude > 0.2:\n        return True\n    else:\n        return False", "CodeBleu_score": 60.617887392028216}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    # Calculate pairwise distances between UAVs in the original and changed formations\n    orig_distances = np.linalg.norm(orig_formation - orig_formation[:, None], axis=-1)\n    change_distances = np.linalg.norm(change_formation - change_formation[:, None], axis=-1)\n\n    # Adjust the distances by subtracting them from 50 and converting to integers\n    orig_distances = (50 - orig_distances).astype(int)\n    change_distances = (50 - change_distances).astype(int)\n\n    # Create a distance matrix from the adjusted distances\n    distance_matrix = np.zeros((orig_formation.shape[0], change_formation.shape[0]))\n    for i in range(orig_formation.shape[0]):\n        for j in range(change_formation.shape[0]):\n            distance_matrix[i, j] = orig_distances[i, j]\n\n    return distance_matrix", "CodeBleu_score": 18.47674602764994}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # Initialize the distance matrix with zeros\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    # Loop through the original and changed formations\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            # Calculate the Euclidean norm between the UAVs\n            distance = np.linalg.norm(orig_formation[i] - change_formation[j])\n            # Adjust the distance by subtracting it from 50 and converting to integer\n            distance_matrix[i][j] = int(50 - distance)\n    # Return the distance matrix\n    return distance_matrix\n", "CodeBleu_score": 30.56046682145438}, {"code": "def build_graph(self, orig_formation, change_formation)\n    dist_mat = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n        for j in range(len(change_formation)):\n            dist_mat[i][j] = int(np.linalg.norm(orig_formation[i] - change_formation[j])) - 50\n    return dist_mat\n", "CodeBleu_score": 24.473707912645974}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in range(len(self.graph[i])):\n        if self.visited[self.graph[i][j]]:\n            continue\n        gap = self.labels[i] + self.labels[self.graph[i][j]] - self.match[self.graph[i][j]]\n        if gap == 0:\n            self.visited[self.graph[i][j]] = True\n            if self.match[self.graph[i][j]] == -1 or self.find_path(self.match[self.graph[i][j]]):\n                self.match[self.graph[i][j]] = i\n                return True\n        else:\n            self.slack[self.graph[i][j]] = min(self.slack[self.graph[i][j]], gap)\n    return False", "CodeBleu_score": 42.01313109994782}, {"code": "def find_path(self, i)\n    self.visited[i] = True\n    for j in range(self.n):\n        if not self.visited[j]:\n            gap = self.labels[i] + self.labels[j] - self.graph[i][j]\n            if gap == 0:\n                self.visited[j] = True\n                if self.match[j] == -1 or self.find_path(self.match[j]):\n                    self.match[j] = i\n                    return True\n            elif self.slack[j] > gap:\n                self.slack[j] = gap\n    return False\n", "CodeBleu_score": 45.282652142161886}, {"code": "def find_path(self, i)\n    if self.visited[i]:\n        return False\n    self.visited[i] = True\n    for j in self.adj[i]:\n        if self.match[j] == -1 or find_path(self, self.match[j]):\n            self.match[j] = i\n            return True\n    return False", "CodeBleu_score": 24.053800444928967}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n    self.matching = [-1] * self.n\n    self.slack = [float(\"inf\")] * self.n\n    self.visited = [False] * self.n\n    self.visited_right = [False] * self.n\n    for i in range(self.n):\n        while True:\n            self.visited = [False] * self.n\n            if self.find_path(i):\n                break\n            self.adjust_labels()\n    return self.matching\n", "CodeBleu_score": 17.565813960941274}, {"code": "def KM(self)\n    # Initialize variables\n    UAVs = self.UAVs\n    UAV_num = len(UAVs)\n    UAV_visit = [False] * UAV_num\n    UAV_slack = [float('inf')] * UAV_num\n    UAV_match = [-1] * UAV_num\n    UAV_path = [-1] * UAV_num\n\n    # Iterate over UAVs\n    for uav_idx in range(UAV_num):\n        # Initialize variables for this UAV\n        UAV_visit = [False] * UAV_num\n        UAV_slack = [float('inf')] * UAV_num\n        UAV_match = [-1] * UAV_num\n        UAV_path = [-1] * UAV_num\n\n        # Find a path for this UAV\n        while True:\n            # Find an unvisited UAV\n            UAV_visit[uav_idx] = True\n            # Initialize variables for this UAV\n            UAV_slack = [float('inf')] * UAV_num\n            UAV_match = [-1] * UAV_num\n            UAV_path = [-1] * UAV_num\n\n            # Find a path for this UAV\n            if self.find_path(uav_idx, UAV_visit, UAV_slack, UAV_match, UAV_path):\n                break\n\n            # Adjust labels based on minimum slack value\n            delta = float('inf')\n            for i in range(UAV_num):\n                if not UAV_visit[i] and UAV_slack[i] < delta:\n                    delta = UAV_slack[i]\n            for i in range(UAV_num):\n                if UAV_visit[i]:\n                    UAV_slack[i] -= delta\n                else:\n                    UAV_slack[i] += delta\n\n    # Return match results for right side of bipartite graph\n    return UAV_match", "CodeBleu_score": 25.864147088350787}, {"code": "def KM(self)\n    # Initialize the match results and the label of the right side\n    match_results = [-1] * len(self.UAVs)\n    label_right = [0] * len(self.UAVs)\n    # Iterate over UAVs\n    for i in range(len(self.UAVs)):\n        # Initialize slack variables and visit arrays\n        slack = [float('inf')] * len(self.UAVs)\n        visited_left = [False] * len(self.UAVs)\n        visited_right = [False] * len(self.UAVs)\n        # Find a path from UAV i to the right side\n        while True:\n            visited_left[i] = True\n            j = self.UAVs[i].get_index()\n            delta = label_right[j] - slack[j]\n            if delta == 0:\n                # If delta is 0, we found a path\n                match_results[j] = i\n                break\n            elif delta > 0:\n                # If delta is positive, we need to adjust the labels\n                for k in range(len(self.UAVs)):\n                    if visited_left[k]:\n                        slack[k] = min(slack[k], label_right[k] - label_right[j] + delta)\n                    elif self.UAVs[k].get_index() == j:\n                        slack[k] = min(slack[k], delta)\n            # Find the next node in the path\n            j = -1\n            min_slack = float('inf')\n            for k in range(len(self.UAVs)):\n                if not visited_left[k] and slack[k] < min_slack:\n                    min_slack = slack[k]\n                    j = k\n            if j == -1:\n                # If no node was found, we need to adjust the labels\n                for k in range(len(self.UAVs)):\n                    if visited_left[k]:\n                        label_right[k] += min_slack\n                    if visited_right[k]:\n                        label_right[k] -= min", "CodeBleu_score": 28.31509319057413}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n    import cv2\n    import numpy as np\n    # Convert the image to HSV color space\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper HSV bounds for yellow color\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n", "CodeBleu_score": 63.710682088072865}, {"code": "def yellow_dectection(image)\n    # Convert the image to HSV color space\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n    # Define the lower and upper bounds for yellow color in HSV color space\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n\n    # Create a mask for yellow color\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n\n    # Apply the mask to the original image using bitwise_and\n    result = cv2.bitwise_and(image, image, mask=mask)\n\n    return result\n", "CodeBleu_score": 27.09532694324272}, {"code": "def yellow_dectection(image)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100], dtype=np.uint8)\n    upper_yellow = np.array([30, 255, 255], dtype=np.uint8)\n    mask_yellow = cv2.inRange(hsv, lower_yellow, upper_yellow)\n    masked_yellow = cv2.bitwise_and(image, image, mask=mask_yellow)\n    return masked_yellow\n", "CodeBleu_score": 26.48830460110866}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription    if (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n        descriptionContainer = standalone_tag_descriptions_[id];\n        return true;\n    } else {\n        if (printWarning) {\n            ROS_WARN(\"Could not find standalone tag description with ID %d\", id);\n        }\n        return false;\n    }\n}\n", "CodeBleu_score": 34.32305309001458}, {"code": "bool TagDetector::findStandaloneTagDescription    // Check if the tag description is in the map\n    if (standalone_tag_descriptions_.find(id) != standalone_tag_descriptions_.end()) {\n        // Set the descriptionContainer to the tag's description\n        descriptionContainer = standalone_tag_descriptions_[id];\n        return true;\n    }\n\n    // If printWarning is true, log a warning message\n    if (printWarning) {\n        ROS_WARN_STREAM(\"TagDetector: Could not find standalone tag description for ID \" << id);\n    }\n\n    // Return false if the tag description is not found\n    return false;\n}\n", "CodeBleu_score": 33.50056104451724}, {"code": "bool TagDetector::findStandaloneTagDescription  if (standalone_tag_descriptions_.count(id)) {\n    descriptionContainer = standalone_tag_descriptions_[id];\n    return true;\n  } else if (printWarning) {\n    LOG(WARNING) << \"Standalone tag description with ID \" << id << \" not found.\";\n  }\n  return false;\n}\n", "CodeBleu_score": 27.780644783829256}]}
