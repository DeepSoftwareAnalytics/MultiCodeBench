{"instance_id": "24fd3857dd7d", "generation_result": [{"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> requiredFiles;\n\tstd::vector<std::string> files = GetFiles(folder);\n\tfor (auto file : files) {\n\t\tif (download) {\n\t\t\tif (!FileExists(folder + \"/\" + file)) {\n\t\t\t\trequiredFiles.push_back(file);\n\t\t\t\tLogDownload(file);\n\t\t\t} else {\n\t\t\t\tLogFound(file);\n\t\t\t}\n\t\t} else {\n\t\t\trequiredFiles.push_back(file);\n\t\t}\n\t}\n\treturn requiredFiles;\n}\n", "CodeBleu_score": 47.22583585641347}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> files;\n\tstd::vector<std::string> files_in_folder = GetFilesInFolder(folder);\n\tfor (const std::string &file : files_in_folder) {\n\t\tif (download) {\n\t\t\tif (FileExists(file)) {\n\t\t\t\tLog(\"Found file: \" + file);\n\t\t\t} else {\n\t\t\t\tLog(\"Requesting file: \" + file);\n\t\t\t\tRequestFile(file);\n\t\t\t}\n\t\t}\n\t\tfiles.push_back(file);\n\t}\n\treturn files;\n}\n", "CodeBleu_score": 41.85617379326894}, {"code": "std::vector<std::string> Client::GetRequiredFiles(const std::string &folder, const bool download) const\tstd::vector<std::string> required_files;\n\tstd::string path = folder + \"/\";\n\tstd::vector<std::string> files = GetFiles(path);\n\tfor (auto &file : files) {\n\t\tif (file.find(\".txt\")!= std::string::npos) {\n\t\t\trequired_files.push_back(file);\n\t\t}\n\t}\n\tif (download) {\n\t\tfor (auto &file : required_files) {\n\t\t\tif (!FileExists(path + file)) {\n\t\t\t\tstd::cout << \"Downloading \" << file << std::endl;\n\t\t\t\tDownloadFile(path + file);\n\t\t\t} else {\n\t\t\t\tstd::cout << \"Found \" << file << \" in cache\" << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn required_files;\n}\n", "CodeBleu_score": 51.477504333384694}]}
{"instance_id": "6b9f65da12c7", "generation_result": [{"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)\treturn SpawnActorWithParent(description, transform, parent, attachment_type, socket_name, {});\n}\n", "CodeBleu_score": 23.116627801768693}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)\treturn rpc::Actor(m_client->SpawnActorWithParent(description, transform, parent, attachment_type, socket_name));\n}\n", "CodeBleu_score": 23.456505127277925}, {"code": "rpc::Actor Client::SpawnActorWithParent(\n      const rpc::ActorDescription &description,\n      const geom::Transform &transform,\n      rpc::ActorId parent,\n      rpc::AttachmentType attachment_type,\n      const std::string& socket_name)\trpc::Actor actor;\n\tactor.set_id(rpc::ActorId::INVALID);\n\tactor.set_parent_id(parent);\n\tactor.set_description(description);\n\tactor.set_attachment_type(attachment_type);\n\tactor.set_socket_name(socket_name);\n\tactor.set_transform(transform);\n\tactor.set_is_local(false);\n\n\tif (attachment_type == rpc::AttachmentType::SPRINGARM || attachment_type == rpc::AttachmentType::SPRINGARM_GHOST) {\n\t\tif (transform.translation.x == 0 && transform.translation.y == 0 && transform.translation.z!= 0) {\n\t\t\tstd::cout << \"WARNING: Actor spawning with SpringArm or SpringArmGhost attachment type and translation only in 'z' axis. \" << std::endl;\n\t\t}\n\t}\n\n\trpc::SpawnActorWithParentRequest request;\n\trequest.set_parent(parent);\n\trequest.set_attachment_type(attachment_type);\n\trequest.set_socket_name(socket_name);\n\trequest.set_transform(transform);\n\trequest.set_description(description);\n\trequest.set_is_local(false);\n\trpc::SpawnActorWithParentResponse response;\n\trpc::Status status = rpc::Status::OK;\n\tif (rpc::Status::OK!= send_rpc(request, response, status)) {\n\t\treturn actor;\n\t}\n\tif (rpc::Status::OK!= status) {\n\t\treturn actor;\n\t}\n\tactor.set_id(response.id());\n\tactor.set_is_local(false);\n\tactor.set_is_spawned(true);\n\treturn actor;\n}\n", "CodeBleu_score": 47.55216565909557}]}
{"instance_id": "cdd344751245", "generation_result": [{"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\tstd::string token;\n\tGetGBufferToken(ActorId, GBufferId, token);\n\tstd::vector<uint8_t> token_data(token.begin(), token.end());\n\tSubscribeToGBuffer(token_data, callback);\n}\n", "CodeBleu_score": 40.844020732714014}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\tauto token = m_GBufferTokens.Get(ActorId, GBufferId);\n\tif (token == nullptr) {\n\t\tstd::cout << \"No token found for \" << ActorId << \" \" << GBufferId << std::endl;\n\t\treturn;\n\t}\n\n\tauto buffer = std::make_shared<Buffer>();\n\tbuffer->Resize(token->Width(), token->Height());\n\n\tauto data = buffer->GetData();\n\tauto size = buffer->GetSize();\n\tauto result = m_Client->SubscribeToGBuffer(token->Token(), data, size);\n\tif (result.IsSuccess()) {\n\t\tcallback(buffer);\n\t}\n}\n", "CodeBleu_score": 42.32731715758088}, {"code": "void Client::SubscribeToGBuffer(\n      rpc::ActorId ActorId,\n      uint32_t GBufferId,\n      std::function<void(Buffer)> callback)\tauto token = std::make_shared<GBufferToken>(ActorId, GBufferId);\n\tauto tokenData = std::make_shared<GBufferTokenData>(token);\n\tauto tokenDataCopy = std::make_shared<GBufferTokenData>(*tokenData);\n\tauto tokenCopy = std::make_shared<GBufferToken>(*token);\n\n\t// Copy the token data to the client's buffer\n\tstd::memcpy(tokenDataCopy->GetData(), tokenData->GetData(), sizeof(GBufferTokenData));\n\n\t// Subscribe to the streaming client\n\tSubscribeToStreamingClient(tokenCopy, tokenDataCopy, callback);\n}\n", "CodeBleu_score": 45.1396149067833}]}
{"instance_id": "01180aa289fa", "generation_result": [{"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (this->Navigation == nullptr) {\n\t\tthis->Navigation = std::make_shared<WalkerNavigation>();\n\t\tthis->Navigation->SetEpisode(this);\n\t}\n\treturn this->Navigation;\n}\n", "CodeBleu_score": 16.57716210257029}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>();\n\t\tnavigation->SetEpisode(shared_from_this());\n\t}\n\treturn navigation;\n}\n", "CodeBleu_score": 30.366377859678884}, {"code": "std::shared_ptr<WalkerNavigation> Episode::CreateNavigationIfMissing()\tif (navigation == nullptr) {\n\t\tnavigation = std::make_shared<WalkerNavigation>(this);\n\t\tif (!navigation->Set()) {\n\t\t\tnavigation = nullptr;\n\t\t}\n\t}\n\treturn navigation;\n}\n", "CodeBleu_score": 34.404707869503426}]}
{"instance_id": "3f2aef3641f8", "generation_result": [{"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tauto start = Clock::now();\n\twhile (episode.Frame() < frame) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t\tif (Clock::now() - start > timeout)\n\t\t\treturn false;\n\t}\n\tTick();\n\treturn true;\n}\n", "CodeBleu_score": 29.150775599146705}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tauto start = Clock::now();\n\twhile (episode.CurrentFrame() < frame) {\n\t\tif (Clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.TrafficManager().Tick();\n\treturn true;\n}\n", "CodeBleu_score": 30.692655750223818}, {"code": "static bool SynchronizeFrame(uint64_t frame, const Episode &episode, time_duration timeout)\tauto start = Clock::now();\n\twhile (episode.Frame() < frame) {\n\t\tif (Clock::now() - start > timeout) {\n\t\t\treturn false;\n\t\t}\n\t\tstd::this_thread::yield();\n\t}\n\tepisode.Tick();\n\treturn true;\n}\n", "CodeBleu_score": 28.82601092339982}]}
{"instance_id": "4429195cd1ee", "generation_result": [{"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tEpisodeProxy episode = EpisodeProxy(this, map_name, reset_settings, map_layers);\n\tepisode.Load();\n\treturn episode;\n}\n", "CodeBleu_score": 18.8210512854665}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\tEpisodeProxy episode_proxy(this->id, map_name, reset_settings, map_layers);\n\tepisode_proxy.Connect();\n\treturn episode_proxy;\n}\n", "CodeBleu_score": 18.51891014891519}, {"code": "EpisodeProxy Simulator::LoadEpisode(std::string map_name, bool reset_settings, rpc::MapLayer map_layers)\t// Create a new episode proxy\n\tEpisodeProxy episode_proxy;\n\n\t// Create a new episode object\n\tEpisode episode;\n\n\t// Create a new map object\n\tMap map;\n\n\t// Set the map name\n\tmap.set_map_name(map_name);\n\n\t// Set the reset settings\n\tmap.set_reset_settings(reset_settings);\n\n\t// Set the map layers\n\tmap.set_map_layers(map_layers);\n\n\t// Set the map\n\tepisode.set_map(map);\n\n\t// Create a new connection\n\tConnection connection;\n\n\t// Create a new connection request\n\tConnectionRequest connection_request;\n\n\t// Set the connection request\n\tconnection_request.set_episode(episode);\n\n\t// Set the connection request\n\tconnection.set_request(connection_request);\n\n\t// Create a new connection response\n\tConnectionResponse connection_response;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_new;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_old;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_current;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_previous;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next_next;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next_next_next;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next_next_next_next;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next_next_next_next_next;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next_next_next_next_next_next;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next_next_next_next_next_next_next;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next_next_next_next_next_next_next_next;\n\n\t// Create a new connection response\n\tConnectionResponse connection_response_next_next_next_next_next_next_next_next_next;\n\n\t// Create", "CodeBleu_score": 25.14869900425313}]}
{"instance_id": "5b517adc0516", "generation_result": [{"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\tif (controller.GetWalker() == nullptr) {\n\t\tthrow std::runtime_error(\"AI Controller must have a walker\");\n\t}\n\n\tif (controller.GetWalker()->GetEpisode() == nullptr) {\n\t\tthrow std::runtime_error(\"AI Controller must have an episode\");\n\t}\n\n\tif (controller.GetWalker()->GetEpisode()->GetNavigation() == nullptr) {\n\t\tcontroller.GetWalker()->GetEpisode()->SetNavigation(new Navigation(controller.GetWalker()->GetEpisode()));\n\t}\n\n\tcontroller.GetWalker()->GetEpisode()->GetNavigation()->RegisterController(controller.GetWalker()->GetID(), controller);\n}\n", "CodeBleu_score": 35.286125203612684}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\t// Retrieve the walker associated with the controller\n\tWalker *walker = GetWalker(controller.GetWalkerID());\n\t// Throw an exception if the walker is not found\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found\");\n\t}\n\t// Assert that the episode is not null\n\tassert(m_episode!= nullptr);\n\t// Create navigation if it is missing\n\tif (m_navigation == nullptr) {\n\t\tm_navigation = new Navigation(this);\n\t}\n\t// Register the walker with the controller's ID\n\tm_navigation->RegisterAIController(controller.GetID(), walker);\n}\n", "CodeBleu_score": 52.168209606920925}, {"code": "void Simulator::RegisterAIController(const WalkerAIController &controller)\t// Retrieve the walker associated with the controller.\n\tWalker *walker = Walker::GetWalker(controller.GetWalkerID());\n\tif (walker == nullptr) {\n\t\tthrow std::runtime_error(\"Walker not found.\");\n\t}\n\n\t// Throw an exception if the episode is null.\n\tif (episode == nullptr) {\n\t\tthrow std::runtime_error(\"Episode is null.\");\n\t}\n\n\t// Create navigation if it is missing.\n\tif (navigation == nullptr) {\n\t\tnavigation = new Navigation(this);\n\t}\n\n\t// Register the walker with the controller's ID.\n\tcontrollers[controller.GetID()] = controller;\n\tcontrollers[controller.GetID()].SetWalker(walker);\n}\n", "CodeBleu_score": 53.05728735281239}]}
{"instance_id": "4bf89f90fc59", "generation_result": [{"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)\tSharedPtr<Actor> actor;\n\tif (parent) {\n\t\tactor = parent->SpawnChild(blueprint, transform, attachment_type, socket_name, gc);\n\t} else {\n\t\tactor = Spawn(blueprint, transform, gc);\n\t}\n\tif (actor) {\n\t\tactor->GetEpisode()->AddActor(actor);\n\t}\n\treturn actor;\n}\n", "CodeBleu_score": 30.059965485857465}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)\tSharedPtr<Actor> actor = CreateActor(blueprint, transform, parent, attachment_type, socket_name);\n\tif (actor == nullptr) {\n\t\treturn nullptr;\n\t}\n\n\tif (gc == GarbageCollectionPolicy::kAlwaysCollect) {\n\t\tactor->CollectGarbage();\n\t} else if (gc == GarbageCollectionPolicy::kNeverCollect) {\n\t\tactor->SetGarbageCollectionPolicy(GarbageCollectionPolicy::kNeverCollect);\n\t}\n\n\tif (parent!= nullptr) {\n\t\tparent->AddChild(actor);\n\t}\n\n\tif (actor->GetGarbageCollectionPolicy() == GarbageCollectionPolicy::kAlwaysCollect) {\n\t\tactor->CollectGarbage();\n\t}\n\n\tif (actor->GetGarbageCollectionPolicy() == GarbageCollectionPolicy::kAlwaysCollect) {\n\t\tactor->CollectGarbage();\n\t}\n\n\t// TODO: remove this once we have a better way to get the id of the actor\n\tactor->SetActorID(GetActorID());\n\n\tAddActor(actor);\n\treturn actor;\n}\n", "CodeBleu_score": 40.64310790196466}, {"code": "SharedPtr<Actor> Simulator::SpawnActor(\n      const ActorBlueprint &blueprint,\n      const geom::Transform &transform,\n      Actor *parent,\n      rpc::AttachmentType attachment_type,\n      GarbageCollectionPolicy gc,\n      const std::string& socket_name)#ifdef ACTOR_DEBUG\n  std::cout << \"Spawning actor: \" << blueprint.id() << std::endl;", "CodeBleu_score": 14.297137210040756}]}
{"instance_id": "120588756f18", "generation_result": [{"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)\tif (episode_!= nullptr) {\n\t\tauto sensor_data_stream = client_->SubscribeToStream(sensor.data_stream_name);\n\t\tsensor_data_stream->Subscribe([=](const std::vector<uint8_t> &data) {\n\t\t\tauto sensor_data = std::make_shared<sensor::SensorData>();\n\t\t\tsensor_data->ParseFromArray(data.data(), data.size());\n\t\t\tsensor_data->set_episode_id(episode_->id());\n\t\t\tcallback(sensor_data);\n\t\t});\n\t}\n}\n", "CodeBleu_score": 42.586909981305425}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)\tif (!episode_valid_) {\n\t\tthrow std::runtime_error(\"Invalid episode\");\n\t}\n\tauto stream_id = client_->SubscribeToStream(sensor.stream_id());\n\tauto callback_wrapper = [this, callback](const StreamData &stream_data) {\n\t\tif (stream_data.episode_id()!= episode_->id()) {\n\t\t\treturn;\n\t\t}\n\t\tauto sensor_data = sensor::SensorData::FromStreamData(stream_data);\n\t\tcallback(sensor_data);\n\t};\n\tcallbacks_[stream_id] = callback_wrapper;\n}\n", "CodeBleu_score": 39.80618293268765}, {"code": "void Simulator::SubscribeToSensor(\n      const Sensor &sensor,\n      std::function<void(SharedPtr<sensor::SensorData>)> callback)\tif (!episode_.IsValid()) {\n\t\tthrow std::runtime_error(\"Cannot subscribe to sensor. No episode is active.\");\n\t}\n\n\tauto subscription = client_.SubscribeToStream(sensor.GetStreamName());\n\tsubscription.OnNext([this, callback](const auto &data) {\n\t\tauto deserialized = sensor::SensorData::Deserialize(data);\n\t\tdeserialized->SetEpisode(episode_);\n\t\tcallback(deserialized);\n\t});\n}\n", "CodeBleu_score": 42.0727117196053}]}
{"instance_id": "a8ef7cb73186", "generation_result": [{"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// Load the current walkers\n\tauto walkers = episode->GetWalkers();\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// Remove any walkers that no longer exist\n\tauto walkersToRemove = std::vector<int>();\n\tfor (auto walker : walkers) {\n\t\tif (walker->GetStatus() == WalkerStatus::Dead) {\n\t\t\twalkersToRemove.push_back(walker->GetId());\n\t\t}\n\t}\n\tfor (auto walkerId : walkersToRemove) {\n\t\twalkers.erase(walkerId);\n\t}\n\n\t// Update the vehicles in the crowd\n\tauto vehicles = episode->GetVehicles();\n\tfor (auto vehicle : vehicles) {\n\t\tvehicle->Update();\n\t}\n\n\t// Update the crowd\n\tauto crowd = episode->GetCrowd();\n\tcrowd->Update();\n\n\t// Apply the walkers' states to the simulator\n\tauto walkerStates = std::vector<WalkerState>();\n\tfor (auto walker : walkers) {\n\t\tauto walkerState = WalkerState();\n\t\twalkerState.id = walker->GetId();\n\t\twalkerState.transform = walker->GetTransform();\n\t\twalkerState.speed = walker->GetSpeed();\n\t\twalkerStates.push_back(walkerState);\n\t}\n\tauto walkerStatesBatch = WalkerStatesBatch();\n\twalkerStatesBatch.walkerStates = walkerStates;\n\tauto walkerStatesBatchPtr = std::make_shared<WalkerStatesBatch>(walkerStatesBatch);\n\tauto walkerStatesBatchPtrPtr = std::make_shared<std::shared_ptr<WalkerStatesBatch>>(walkerStatesBatchPtr);\n\tauto walkerStatesBatchPtrPtrPtr = std::make_shared<std::shared_ptr<std::shared_ptr<WalkerStatesBatch>>>(walkerStatesBatchPtrPtr);\n\tauto walkerStatesBatchPtrPtrPtrPtr = std::make_shared<std::shared_ptr<std::shared_ptr<std::shared_ptr<WalkerStatesBatch>>>>(walkerStatesBatchPtrPtrPtr);\n\tauto walkerStatesBatchPtrPtrPtrPtrPtr = std::make_shared<std::shared_ptr<std::shared_ptr<std::shared_ptr<std::shared", "CodeBleu_score": 35.272283572571695}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// Load the current walkers\n\tstd::vector<std::shared_ptr<Walker>> walkers = episode->GetWalkers();\n\t// Check if there are no walkers in the episode\n\tif (walkers.size() == 0) {\n\t\treturn;\n\t}\n\t// Get the current state of the episode\n\tstd::vector<std::shared_ptr<State>> states = episode->GetStates();\n\t// Remove any walkers that are no longer in the episode\n\tfor (int i = 0; i < walkers.size(); i++) {\n\t\tif (states[i]->GetWalker() == nullptr) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tcrowd->RemoveWalker(walkers[i]);\n\t\t\t// Remove the walker from the list of walkers\n\t\t\twalkers.erase(walkers.begin() + i);\n\t\t\t// Decrement the index\n\t\t\ti--;\n\t\t}\n\t}\n\t// Update the vehicles in the crowd\n\tcrowd->UpdateVehicles();\n\t// Update the crowd\n\tcrowd->Update();\n\t// Get the current transform and speed of each walker\n\tfor (int i = 0; i < walkers.size(); i++) {\n\t\t// Get the transform and speed of the walker\n\t\tTransform transform = walkers[i]->GetTransform();\n\t\tfloat speed = walkers[i]->GetSpeed();\n\t\t// Apply the transform and speed to the walker\n\t\tcrowd->SetTargetVelocity(transform, speed);\n\t}\n\t// Check if any walker has been killed\n\tfor (int i = 0; i < walkers.size(); i++) {\n\t\tif (walkers[i]->IsDead()) {\n\t\t\t// Remove the walker from the crowd\n\t\t\tcrowd->RemoveWalker(walkers[i]);\n\t\t\t// Remove the walker from the list of walkers\n\t\t\twalkers.erase(walkers.begin() + i);\n\t\t\t// Decrement the index\n\t\t\ti--;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 31.868894136896326}, {"code": "void WalkerNavigation::Tick(std::shared_ptr<Episode> episode)\t// load the current walkers from the episode\n\tstd::vector<std::shared_ptr<Walker>> walkers = episode->GetWalkers();\n\t// if there are no walkers, return\n\tif (walkers.empty()) {\n\t\treturn;\n\t}\n\n\t// get the current state of the episode\n\tstd::shared_ptr<EpisodeState> state = episode->GetState();\n\t// remove walkers that no longer exist\n\twalkers = state->RemoveWalkers(walkers);\n\n\t// update the vehicles in the crowd\n\tcrowd->UpdateVehicles(walkers);\n\t// update the crowd itself\n\tcrowd->Update(walkers);\n\n\t// apply the states of the walkers to the simulator\n\tfor (std::shared_ptr<Walker> walker : walkers) {\n\t\t// get the transform and speed of the walker\n\t\tTransform transform = walker->GetTransform();\n\t\tfloat speed = walker->GetSpeed();\n\t\t// apply the walker's transform and speed to the simulator\n\t\tcrowd->ApplyState(transform, speed, walker->GetID());\n\t}\n\n\t// check if any walkers have been killed\n\tfor (std::shared_ptr<Walker> walker : walkers) {\n\t\t// if the walker is dead, remove them from the crowd\n\t\tif (walker->IsDead()) {\n\t\t\tcrowd->RemoveWalker(walker->GetID());\n\t\t}\n\t}\n}\n", "CodeBleu_score": 31.676645391119173}]}
{"instance_id": "89785106fdc3", "generation_result": [{"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription actorDescription;\n\tactorDescription.set_uid(uid);\n\tactorDescription.set_id(id);\n\tactorDescription.set_name(name);\n\tactorDescription.set_description(description);\n\tactorDescription.set_type(type);\n\tactorDescription.set_max_health(maxHealth);\n\tactorDescription.set_health(health);\n\tactorDescription.set_max_energy(maxEnergy);\n\tactorDescription.set_energy(energy);\n\tactorDescription.set_max_stamina(maxStamina);\n\tactorDescription.set_stamina(stamina);\n\tactorDescription.set_max_mana(maxMana);\n\tactorDescription.set_mana(mana);\n\tactorDescription.set_max_experience(maxExperience);\n\tactorDescription.set_experience(experience);\n\tactorDescription.set_level(level);\n\tactorDescription.set_gold(gold);\n\tactorDescription.set_inventory_size(inventorySize);\n\tactorDescription.set_inventory_capacity(inventoryCapacity);\n\tactorDescription.set_inventory_weight(inventoryWeight);\n\tactorDescription.set_inventory_volume(inventoryVolume);\n\tactorDescription.set_inventory_max_weight(inventoryMaxWeight);\n\tactorDescription.set_inventory_max_volume(inventoryMaxVolume);\n\tactorDescription.set_inventory_max_items(inventoryMaxItems);\n\tactorDescription.set_inventory_max_stacks(inventoryMaxStacks);\n\tactorDescription.set_inventory_max_size(inventoryMaxSize);\n\tactorDescription.set_inventory_max_capacity(inventoryMaxCapacity);\n\tactorDescription.set_inventory_max_weight(inventoryMaxWeight);\n\tactorDescription.set_inventory_max_volume(inventoryMaxVolume);\n\tactorDescription.set_inventory_max_items(inventoryMaxItems);\n\tactorDescription.set_inventory_max_stacks(inventoryMaxStacks);\n\tactorDescription.set_inventory_max_size(inventoryMaxSize);\n\tactorDescription.set_inventory_max_capacity(inventoryMaxCapacity);\n\tactorDescription.set_inventory_max_weight(inventoryMaxWeight);\n\tactorDescription.set_inventory_max_volume(inventoryMaxVolume", "CodeBleu_score": 36.49007423250855}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.set_name(name);\n\tdescription.set_type(type);\n\tdescription.set_class_id(class_id);\n\tdescription.set_class_name(class_name);\n\tdescription.set_is_active(is_active);\n\tdescription.set_is_visible(is_visible);\n\tdescription.set_is_persistent(is_persistent);\n\tdescription.set_is_player(is_player);\n\tdescription.set_is_controlled(is_controlled);\n\tdescription.set_is_targetable(is_targetable);\n\tdescription.set_is_selectable(is_selectable);\n\tdescription.set_is_selectable_by_player(is_selectable_by_player);\n\tdescription.set_is_selectable_by_ai(is_selectable_by_ai);\n\tdescription.set_is_selectable_by_player_and_ai(is_selectable_by_player_and_ai);\n\tdescription.set_is_selectable_by_player_and_ai_and_npc(is_selectable_by_player_and_ai_and_npc);\n\tdescription.set_is_selectable_by_npc(is_selectable_by_npc);\n\tdescription.set_is_selectable_by_npc_and_ai(is_selectable_by_npc_and_ai);\n\tdescription.set_is_selectable_by_npc_and_ai_and_player(is_selectable_by_npc_and_ai_and_player);\n\tdescription.set_is_selectable_by_npc_and_player(is_selectable_by_npc_and_player);\n\tdescription.set_is_selectable_by_player_and_npc(is_selectable_by_player_and_npc);\n\tdescription.set_is_selectable_by_player_and_npc_and_ai(is_selectable_by_player_and_npc_and_ai);\n\tdescription.set_is_selectable_by_player_and_npc_and_ai_and_player(is_selectable_by_player_and_npc", "CodeBleu_score": 37.215036931254474}, {"code": "rpc::ActorDescription ActorBlueprint::MakeActorDescription() const\trpc::ActorDescription description;\n\tdescription.set_uid(uid);\n\tdescription.set_id(id);\n\tdescription.set_name(name);\n\tdescription.set_type(type);\n\tdescription.set_x(x);\n\tdescription.set_y(y);\n\tdescription.set_z(z);\n\tdescription.set_yaw(yaw);\n\tdescription.set_pitch(pitch);\n\tdescription.set_roll(roll);\n\tdescription.set_scale_x(scale_x);\n\tdescription.set_scale_y(scale_y);\n\tdescription.set_scale_z(scale_z);\n\tdescription.set_color_r(color_r);\n\tdescription.set_color_g(color_g);\n\tdescription.set_color_b(color_b);\n\tdescription.set_color_a(color_a);\n\tdescription.set_mesh(mesh);\n\tdescription.set_material(material);\n\tdescription.set_texture(texture);\n\tdescription.set_texture_scale(texture_scale);\n\tdescription.set_texture_offset(texture_offset);\n\tdescription.set_texture_rotation(texture_rotation);\n\tdescription.set_texture_tiling(texture_tiling);\n\tdescription.set_texture_tiling_offset(texture_tiling_offset);\n\tdescription.set_texture_tiling_rotation(texture_tiling_rotation);\n\tdescription.set_texture_tiling_scale(texture_tiling_scale);\n\tdescription.set_texture_tiling_offset_x(texture_tiling_offset_x);\n\tdescription.set_texture_tiling_offset_y(texture_tiling_offset_y);\n\tdescription.set_texture_tiling_offset_z(texture_tiling_offset_z);\n\tdescription.set_texture_tiling_rotation_x(texture_tiling_rotation_x);\n\tdescription.set_texture_tiling_rotation_y(texture_tiling_rotation_y);\n\tdescription.set_texture_tiling_rotation_z(texture_tiling_rotation_z);\n\tdescription.set_texture_tiling_scale_x(", "CodeBleu_score": 30.913357502527784}]}
{"instance_id": "34df2bcf0cec", "generation_result": [{"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> result = make_shared<BlueprintLibrary>();\n\tfor (const auto &bp : *this) {\n\t\tif (bp->HasAttribute(name)) {\n\t\t\tif (bp->GetAttribute(name) == value) {\n\t\t\t\tresult->AddBlueprint(bp);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 29.42215437882649}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> result = std::make_shared<BlueprintLibrary>();\n\tfor (auto blueprint : *this) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tstd::string attributeValue = blueprint->GetAttribute(name);\n\t\t\tif (attributeValue == value || attributeValue == \"recommended\") {\n\t\t\t\tresult->AddBlueprint(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 36.29522763284611}, {"code": "SharedPtr<BlueprintLibrary> BlueprintLibrary::FilterByAttribute(\n      const std::string &name, const std::string& value) const\tSharedPtr<BlueprintLibrary> filtered = make_shared<BlueprintLibrary>();\n\tfor (const auto &blueprint : *this) {\n\t\tif (blueprint->HasAttribute(name)) {\n\t\t\tif (blueprint->GetAttribute(name) == value) {\n\t\t\t\tfiltered->Add(blueprint);\n\t\t\t}\n\t\t}\n\t}\n\treturn filtered;\n}\n", "CodeBleu_score": 29.859739920193423}]}
{"instance_id": "6514a623a4e4", "generation_result": [{"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string fullPath = baseFolder + path;\n\tif (!ValidatePath(fullPath)) {\n\t\treturn false;\n\t}\n\tstd::ofstream file(fullPath, std::ios::binary | std::ios::trunc);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.write((char*)content.data(), content.size());\n\tfile.close();\n\treturn true;\n}\n", "CodeBleu_score": 43.08307247219222}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\tstd::string full_path = base_folder_ + path;\n\tif (full_path.back()!= '/') {\n\t\tfull_path += '/';\n\t}\n\tfull_path += version_ + path;\n\tstd::ofstream file(full_path, std::ios::binary);\n\tif (file.is_open()) {\n\t\tfile.write((char*)content.data(), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 39.744415342326874}, {"code": "bool FileTransfer::WriteFile(std::string path, std::vector<uint8_t> content)\t// Validate the file path.\n\tif (path.empty()) {\n\t\treturn false;\n\t}\n\n\t// Construct the full file path.\n\tstd::string fullPath = GetFullFilePath(path);\n\n\t// Open the file in binary mode to truncate its contents.\n\tstd::ofstream file(fullPath, std::ios::binary);\n\n\t// If the file is successfully opened, write the content and close the file.\n\tif (file.is_open()) {\n\t\tfile.write(reinterpret_cast<char*>(content.data()), content.size());\n\t\tfile.close();\n\t\treturn true;\n\t}\n\n\t// If the file cannot be opened, return false.\n\treturn false;\n}\n", "CodeBleu_score": 34.05275178256832}]}
{"instance_id": "d4e7e6a9bb84", "generation_result": [{"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\tauto bounds = std::make_shared<Bounds>();\n\tbounds->frame = frame;\n\tbounds->corners.push_back(transform.location + transform.extent.x * transform.rotation.x + transform.extent.y * transform.rotation.y);\n\tbounds->corners.push_back(transform.location + transform.extent.x * transform.rotation.x - transform.extent.y * transform.rotation.y);\n\tbounds->corners.push_back(transform.location - transform.extent.x * transform.rotation.x - transform.extent.y * transform.rotation.y);\n\tbounds->corners.push_back(transform.location - transform.extent.x * transform.rotation.x + transform.extent.y * transform.rotation.y);\n\treturn bounds;\n}\n", "CodeBleu_score": 31.965718974949276}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\t// Create a shared pointer to a Bounds object\n\tstd::shared_ptr<Bounds> bounds = std::make_shared<Bounds>();\n\n\t// Set the frame number\n\tbounds->frame = frame;\n\n\t// Set the location\n\tbounds->location = transform.location + parent->GetLocation();\n\n\t// Set the extents\n\tbounds->extents = parent->GetExtents();\n\n\t// Set the yaw angle\n\tbounds->yaw = transform.yaw;\n\n\t// Calculate the four corners of the bounding box\n\tbounds->corners[0] = bounds->location + geom::Point3D(bounds->extents.x, bounds->extents.y, 0);\n\tbounds->corners[1] = bounds->location + geom::Point3D(bounds->extents.x, -bounds->extents.y, 0);\n\tbounds->corners[2] = bounds->location + geom::Point3D(-bounds->extents.x, -bounds->extents.y, 0);\n\tbounds->corners[3] = bounds->location + geom::Point3D(-bounds->extents.x, bounds->extents.y, 0);\n\n\t// Return the shared pointer to the Bounds object\n\treturn bounds;\n}\n", "CodeBleu_score": 42.038841323773646}, {"code": "std::shared_ptr<const LaneInvasionCallback::Bounds> LaneInvasionCallback::MakeBounds(\n      const size_t frame,\n      const geom::Transform &transform) const\t// Get the parent's bounding box location\n\tconst auto parent_bounds = GetParentBounds();\n\t// Get the transform's location\n\tconst auto location = transform.GetLocation();\n\t// Get the transform's yaw angle\n\tconst auto yaw = transform.GetYaw();\n\t// Get the transform's extents\n\tconst auto extents = transform.GetExtents();\n\t// Create a vector of four corners\n\tstd::vector<geom::Point> corners;\n\t// Add the parent's bounding box location to the transform's location\n\tconst auto location_plus_parent_bounds = location + parent_bounds.location;\n\t// Rotate the transform's extents based on the yaw angle\n\tconst auto rotated_extents = geom::Rotate(extents, yaw);\n\t// Create a vector of four corners\n\tcorners.emplace_back(location_plus_parent_bounds - rotated_extents);\n\tcorners.emplace_back(location_plus_parent_bounds + rotated_extents);\n\tcorners.emplace_back(location_plus_parent_bounds + geom::Point(rotated_extents.x, -rotated_extents.y));\n\tcorners.emplace_back(location_plus_parent_bounds - geom::Point(rotated_extents.x, -rotated_extents.y));\n\t// Return a shared pointer to a Bounds object containing the frame number and the calculated corners\n\treturn std::make_shared<Bounds>(frame, corners);\n}\n", "CodeBleu_score": 37.15845701900112}]}
{"instance_id": "88c28ecd93f2", "generation_result": [{"code": "void LightManager::QueryLightsStateToServer()\t//Lock mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\t//Retrieve light states from the server\n\tstd::vector<LightState> lightStates = _server->GetLightStates();\n\t//Update the local light states\n\tfor (LightState lightState : lightStates) {\n\t\t//Create a new light object if it does not already exist in the _lights map\n\t\tif (_lights.find(lightState.GetId()) == _lights.end()) {\n\t\t\t_lights[lightState.GetId()] = Light(lightState.GetId());\n\t\t}\n\t\t//Update the light object with the light state\n\t\t_lights[lightState.GetId()].SetState(lightState);\n\t}\n}\n", "CodeBleu_score": 28.71910927651107}, {"code": "void LightManager::QueryLightsStateToServer()\t// Lock the mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Query the server for the current light states\n\tstd::vector<LightState> serverLightStates = _server->QueryLightsState();\n\n\t// Update the local light states\n\tfor (auto& lightState : serverLightStates) {\n\t\t// Create a new light object if it does not already exist\n\t\tif (_lights.find(lightState.id) == _lights.end()) {\n\t\t\t_lights[lightState.id] = std::make_shared<Light>(lightState);\n\t\t}\n\t\t// Update the light object\n\t\t_lights[lightState.id]->Update(lightState);\n\t}\n}\n", "CodeBleu_score": 32.64896489188256}, {"code": "void LightManager::QueryLightsStateToServer()\t// Lock mutex to ensure thread safety\n\tstd::lock_guard<std::mutex> lock(_mutex);\n\n\t// Create JSON object to store the response from the server\n\tjson response;\n\n\t// Query the server for the current light states\n\tif (queryLightsState(response)) {\n\t\t// Loop through each light in the response\n\t\tfor (auto light : response.items()) {\n\t\t\t// Get the light ID and state\n\t\t\tint lightID = light.value()[\"id\"];\n\t\t\tbool lightState = light.value()[\"state\"];\n\n\t\t\t// Check if the light exists in the _lights map\n\t\t\tif (_lights.find(lightID) == _lights.end()) {\n\t\t\t\t// Create a new light object and add it to the _lights map\n\t\t\t\tLight* newLight = new Light(lightID, lightState);\n\t\t\t\t_lights.insert(std::make_pair(lightID, newLight));\n\t\t\t} else {\n\t\t\t\t// Update the light state in the _lights map\n\t\t\t\t_lights.at(lightID)->setState(lightState);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 37.61690603087139}]}
{"instance_id": "4fa452091640", "generation_result": [{"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tstd::lock_guard<std::mutex> lock(mutex);\n\tif (dirty) {\n\t\tdirty = false;\n\t\tauto msg = std::make_shared<Message>(Message::Type::LIGHTS);\n\t\tmsg->SetPayload(lights);\n\t\tif (discard_client) {\n\t\t\tlights.clear();\n\t\t}\n\t\telse {\n\t\t\tfor (auto& l : lights) {\n\t\t\t\tl.second.dirty = false;\n\t\t\t}\n\t\t}\n\t\tif (server) {\n\t\t\tserver->Send(msg);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.278898718976066}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tif (dirty) {\n\t\tstd::unique_lock<std::mutex> lock(mutex);\n\t\tif (dirty) {\n\t\t\tdirty = false;\n\t\t\tif (discard_client) {\n\t\t\t\tserver->Send(std::make_shared<LightStateMessage>(lights));\n\t\t\t} else {\n\t\t\t\tserver->Send(std::make_shared<LightStateMessage>(lights, true));\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 23.14091447308021}, {"code": "void LightManager::UpdateServerLightsState(bool discard_client)\tif (dirty) {\n\t\tstd::lock_guard<std::mutex> lock(mutex);\n\t\tif (dirty) {\n\t\t\tdirty = false;\n\t\t\tstd::string message = \"lights\";\n\t\t\tfor (auto it = lights.begin(); it!= lights.end(); ++it) {\n\t\t\t\tmessage += \" \";\n\t\t\t\tmessage += it->first;\n\t\t\t\tmessage += \" \";\n\t\t\t\tmessage += it->second->GetLightState();\n\t\t\t}\n\t\t\tif (discard_client) {\n\t\t\t\tmessage += \" discard\";\n\t\t\t}\n\t\t\tif (server!= nullptr) {\n\t\t\t\tserver->Send(message);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.14481146018629}]}
{"instance_id": "55f2a92d098d", "generation_result": [{"code": "void ServerSideSensor::Send(std::string message)\tif (id!= \"sensor.other.v2x_custom\") {\n\t\tLOG(WARNING) << \"ServerSideSensor::Send() called on sensor with ID \" << id << \" which is not \\\"sensor.other.v2x_custom\\\"\";\n\t\treturn;\n\t}\n\n\tauto msg = std::make_shared<std::string>(message);\n\tauto context = std::make_shared<zmq::context_t>(1);\n\tauto socket = std::make_shared<zmq::socket_t>(*context, ZMQ_PUSH);\n\tsocket->connect(\"tcp://localhost:\" + std::to_string(context_port));\n\tsocket->send(*msg);\n}\n", "CodeBleu_score": 39.59547536857969}, {"code": "void ServerSideSensor::Send(std::string message)\tif (id!= \"sensor.other.v2x_custom\") {\n\t\tLOG_WARN(\"ServerSideSensor::Send: Sensor ID is not sensor.other.v2x_custom!\");\n\t\treturn;\n\t}\n\tcontext->Send(message);\n}\n", "CodeBleu_score": 41.29965729605571}, {"code": "void ServerSideSensor::Send(std::string message)\tif (sensor_id == \"sensor.other.v2x_custom\") {\n\t\t// Do nothing\n\t} else {\n\t\tLOG(WARNING) << \"ServerSideSensor::Send() called with sensor_id \" << sensor_id << \", which is not sensor.other.v2x_custom\";\n\t}\n}\n", "CodeBleu_score": 25.902426102579913}]}
{"instance_id": "15ad3fa28627", "generation_result": [{"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\tthis->tm_port = tm_port;\n\t\tthis->autopilot_enabled = true;\n\t\tthis->tm_socket = socket(AF_INET, SOCK_STREAM, 0);\n\t\tif (this->tm_socket < 0) {\n\t\t\tperror(\"Socket creation failed\");\n\t\t\texit(1);\n\t\t}\n\t\tstruct sockaddr_in server_addr;\n\t\tserver_addr.sin_family = AF_INET;\n\t\tserver_addr.sin_port = htons(this->tm_port);\n\t\tserver_addr.sin_addr.s_addr = INADDR_ANY;\n\t\tif (bind(this->tm_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {\n\t\t\tperror(\"Socket bind failed\");\n\t\t\texit(1);\n\t\t}\n\t\tif (listen(this->tm_socket, 1) < 0) {\n\t\t\tperror(\"Socket listen failed\");\n\t\t\texit(1);\n\t\t}\n\t} else {\n\t\tthis->autopilot_enabled = false;\n\t\tclose(this->tm_socket);\n\t}\n}\n", "CodeBleu_score": 33.258615652031594}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\tif (tm_port == 0) {\n\t\t\ttm_port = 12345;\n\t\t}\n\t\ttm_client = new TrafficManagerClient(tm_port);\n\t\ttm_client->Register(this);\n\t} else {\n\t\tif (tm_client!= NULL) {\n\t\t\ttm_client->Unregister(this);\n\t\t\tdelete tm_client;\n\t\t\ttm_client = NULL;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.10895383816526}, {"code": "void Vehicle::SetAutopilot(bool enabled, uint16_t tm_port)\tif (enabled) {\n\t\ttm_port_ = tm_port;\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\ttm_port_ = htons(tm_port_);\n\t\ttm_port_ = ntohs(tm_port_);\n\t\t", "CodeBleu_score": 32.18706272564764}]}
{"instance_id": "d47601663346", "generation_result": [{"code": "void WalkerAIController::Start()\t// Retrieve the walker actor\n\twalkerActor = Cast<AWalkerActor>(GetPawn());\n\tif (!walkerActor) {\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"WalkerAIController::Start() - Could not cast pawn to walker actor\"));\n\t\treturn;\n\t}\n\n\t// Add the walker actor to the navigation system\n\twalkerActor->GetNavigationSystem()->AddAgent(walkerActor);\n\n\t// Disable the physics simulation and collisions for the walker actor\n\twalkerActor->GetRootComponent()->SetSimulatePhysics(false);\n\twalkerActor->GetRootComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}\n", "CodeBleu_score": 27.135254641912187}, {"code": "void WalkerAIController::Start()\t// Retrieve the walker actor and add it to the navigation system with its current location.\n\twalkerActor = GetWorld()->GetFirstPlayerController()->GetPawn();\n\tGetWorld()->GetNavigationSystem()->AddAgent(walkerActor);\n\n\t// Disable the physics simulation and collisions for the walker actor.\n\twalkerActor->GetMovementComponent()->SetMovementMode(MOVE_Flying);\n\twalkerActor->GetCollisionComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}\n", "CodeBleu_score": 33.82693684955921}, {"code": "void WalkerAIController::Start()\t// Retrieve the walker actor\n\twalker = GetWorld()->GetFirstPlayerController()->GetPawn();\n\n\t// Add the walker to the navigation system\n\tUNavigationSystemV1* NavSys = UNavigationSystemV1::GetCurrent(GetWorld());\n\tif (NavSys) {\n\t\tNavSys->SimpleMoveToActor(this, walker);\n\t}\n\n\t// Disable physics simulation and collisions for the walker actor\n\twalker->GetMovementComponent()->SetSimulatePhysics(false);\n\twalker->GetCollisionComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n}\n", "CodeBleu_score": 42.1646330042589}]}
{"instance_id": "d35f70145bed", "generation_result": [{"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tif (episode_ == nullptr) {\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, \"WalkerAIController::SetMaxSpeed - No episode instance found\");\n\t\treturn;\n\t}\n\n\tif (episode_->GetNavigation() == nullptr) {\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, \"WalkerAIController::SetMaxSpeed - No navigation instance found\");\n\t\treturn;\n\t}\n\n\tif (walker_ == nullptr) {\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, \"WalkerAIController::SetMaxSpeed - No walker instance found\");\n\t\treturn;\n\t}\n\n\tif (episode_->GetNavigation()->SetWalkerMaxSpeed(walker_, max_speed)) {\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Green, \"WalkerAIController::SetMaxSpeed - Max speed set to \" + FString::SanitizeFloat(max_speed));\n\t}\n\telse {\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, \"WalkerAIController::SetMaxSpeed - Failed to set max speed\");\n\t}\n}\n", "CodeBleu_score": 44.771136141499326}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tif (current_episode_->GetNavigation()!= nullptr) {\n\t\tWalker* walker = current_episode_->GetNavigation()->GetWalker();\n\t\tif (walker!= nullptr) {\n\t\t\tif (!walker->SetMaxSpeed(max_speed)) {\n\t\t\t\tLOG(WARNING) << \"Could not set maximum speed of walker \" << walker->GetName() << \".\";\n\t\t\t}\n\t\t} else {\n\t\t\tLOG(WARNING) << \"Could not find walker in episode.\";\n\t\t}\n\t} else {\n\t\tLOG(WARNING) << \"Could not find navigation instance in episode.\";\n\t}\n}\n", "CodeBleu_score": 42.54580752538024}, {"code": "void WalkerAIController::SetMaxSpeed(const float max_speed)\tif (episode_!= nullptr) {\n\t\tif (episode_->GetNavigation()!= nullptr) {\n\t\t\tWalker* walker = GetWalker();\n\t\t\tif (walker!= nullptr) {\n\t\t\t\tif (!episode_->GetNavigation()->SetMaxSpeed(walker, max_speed)) {\n\t\t\t\t\tLog::Warning(\"Failed to set walker maximum speed to \" + std::to_string(max_speed) + \".\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLog::Warning(\"Failed to set walker maximum speed to \" + std::to_string(max_speed) + \". Walker not found.\");\n\t\t\t}\n\t\t} else {\n\t\t\tLog::Warning(\"Failed to set walker maximum speed to \" + std::to_string(max_speed) + \". Navigation not found.\");\n\t\t}\n\t} else {\n\t\tLog::Warning(\"Failed to set walker maximum speed to \" + std::to_string(max_speed) + \". Episode not found.\");\n\t}\n}\n", "CodeBleu_score": 46.59117668671101}]}
{"instance_id": "97c4d0a8b802", "generation_result": [{"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> previous;\n\tstd::vector<Waypoint> waypoints = map->GetPrevious(distance);\n\tfor (auto waypoint : waypoints) {\n\t\tprevious.push_back(make_shared<Waypoint>(waypoint));\n\t}\n\treturn previous;\n}\n", "CodeBleu_score": 46.12889486200129}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> previous;\n\tstd::vector<Waypoint> waypoints = Map::GetPrevious(distance);\n\tfor (auto waypoint : waypoints) {\n\t\tprevious.push_back(SharedPtr<Waypoint>(new Waypoint(waypoint)));\n\t}\n\treturn previous;\n}\n", "CodeBleu_score": 48.15903670584857}, {"code": "std::vector<SharedPtr<Waypoint>> Waypoint::GetPrevious(double distance) const\tstd::vector<SharedPtr<Waypoint>> result;\n\tstd::vector<Waypoint> previousWaypoints = m_map->GetPrevious(m_position, distance);\n\tfor (auto& previousWaypoint : previousWaypoints) {\n\t\tresult.push_back(std::make_shared<Waypoint>(previousWaypoint));\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 50.82870864505396}]}
{"instance_id": "3f789cd118c7", "generation_result": [{"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance, stop_at_junction);\n\tstd::vector<SharedPtr<Landmark>> landmarks;\n\tfor (auto signal : signals) {\n\t\tif (std::find(landmarks.begin(), landmarks.end(), signal->GetLandmark()) == landmarks.end()) {\n\t\t\tlandmarks.push_back(signal->GetLandmark());\n\t\t}\n\t}\n\treturn landmarks;\n}\n", "CodeBleu_score": 30.119740363331253}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::set<int> signals;\n\tfor (const auto& signal : GetSignalsInDistance(distance, stop_at_junction)) {\n\t\tif (signals.count(signal->id()) == 0) {\n\t\t\tresult.push_back(MakeShared<Landmark>(signal));\n\t\t\tsignals.insert(signal->id());\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 33.26476783860355}, {"code": "std::vector<SharedPtr<Landmark>> Waypoint::GetAllLandmarksInDistance(\n      double distance, bool stop_at_junction) const\tstd::vector<SharedPtr<Landmark>> result;\n\tstd::vector<SharedPtr<Signal>> signals = GetSignalsInDistance(distance);\n\tfor (auto signal : signals) {\n\t\tif (std::find(result.begin(), result.end(), signal->GetLandmark()) == result.end()) {\n\t\t\tresult.push_back(signal->GetLandmark());\n\t\t}\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 28.013935172229797}]}
{"instance_id": "e71bab655973", "generation_result": [{"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\t// Check if the settings are valid\n\tif (!settings.has_episode_id()) {\n\t\tthrow std::runtime_error(\"EpisodeSettings must have an episode ID\");\n\t}\n\tif (!settings.has_settings()) {\n\t\tthrow std::runtime_error(\"EpisodeSettings must have settings\");\n\t}\n\tif (settings.settings().has_fixed_delta_time() && settings.settings().fixed_delta_time() <= 0) {\n\t\tthrow std::runtime_error(\"FixedDeltaTime must be greater than 0\");\n\t}\n\tif (settings.settings().has_fixed_delta_time() && settings.settings().fixed_delta_time() > 1.0) {\n\t\tthrow std::runtime_error(\"FixedDeltaTime must be less than 1.0\");\n\t}\n\n\t// Create a unique identifier for the settings\n\tuint64_t settingsId = settings.episode_id();\n\tsettingsId <<= 32;\n\tsettingsId |= _settingsIds.size();\n\n\t// Apply the settings\n\tstd::lock_guard<std::mutex> lock(_settingsMutex);\n\t_settingsIds.push_back(settingsId);\n\t_settings.push_back(settings);\n\n\t// Set the timeout\n\tif (timeout.is_zero()) {\n\t\ttimeout = _timeout;\n\t}\n\t_timeouts[settingsId] = timeout;\n\n\t// If the settings include a fixed delta time, verify it\n\tif (settings.settings().has_fixed_delta_time()) {\n\t\t// Get the current time\n\t\ttime_point now = steady_clock::now();\n\n\t\t// Start the timer\n\t\t_fixedDeltaTimeTimer[settingsId] = now;\n\n\t\t// Get the number of ticks to wait\n\t\tint32_t ticks = static_cast<int32_t>(settings.settings().fixed_delta_time() * 1000.0);\n\t\tif (ticks < 1) {\n\t\t\tticks = 1;\n\t\t}\n\n\t\t// Wait for the next tick\n\t\twhile (now < _fixedDeltaTimeTimer[settingsId] + ticks) {\n\t\t\tnow = steady_clock::now();\n\t\t}\n\n\t\t// If the timer hasn't expired, we've failed to apply the settings", "CodeBleu_score": 37.08912891252727}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\t// If we have a fixed delta time, verify the accuracy of this setting over a series of ticks\n\tif (settings.has_fixed_delta_time()) {\n\t\t// Get the current time\n\t\ttime_point now = clock::now();\n\t\t// Get the current time in milliseconds\n\t\tuint64_t now_ms = duration_cast<milliseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in microseconds\n\t\tuint64_t now_us = duration_cast<microseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in nanoseconds\n\t\tuint64_t now_ns = duration_cast<nanoseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in seconds\n\t\tuint64_t now_s = duration_cast<seconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in milliseconds\n\t\tuint64_t now_ms_2 = duration_cast<milliseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in microseconds\n\t\tuint64_t now_us_2 = duration_cast<microseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in nanoseconds\n\t\tuint64_t now_ns_2 = duration_cast<nanoseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in seconds\n\t\tuint64_t now_s_2 = duration_cast<seconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in milliseconds\n\t\tuint64_t now_ms_3 = duration_cast<milliseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in microseconds\n\t\tuint64_t now_us_3 = duration_cast<microseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in nanoseconds\n\t\tuint64_t now_ns_3 = duration_cast<nanoseconds>(now.time_since_epoch()).count();\n\t\t// Get the current time in seconds\n\t\tuint64_t now_s_3 = duration_cast<seconds>(now.time_since_epoch()).", "CodeBleu_score": 19.930094126224457}, {"code": "uint64_t World::ApplySettings(const rpc::EpisodeSettings &settings, time_duration timeout)\tif (settings.has_fixed_delta_time()) {\n\t\t// Apply the fixed delta time\n\t\tif (!ApplyFixedDeltaTime(settings.fixed_delta_time())) {\n\t\t\t// Failed to apply the fixed delta time\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t// Apply the episode settings\n\tuint64_t settings_id = ApplySettings(settings);\n\n\t// If the settings include a fixed delta time, attempt to verify the accuracy of this setting over a series of ticks\n\tif (settings.has_fixed_delta_time()) {\n\t\t// Verify the accuracy of the fixed delta time over a series of ticks\n\t\tVerifyFixedDeltaTime(settings_id, settings.fixed_delta_time(), timeout);\n\t}\n\n\t// Return the settings identifier\n\treturn settings_id;\n}\n", "CodeBleu_score": 19.667900116922336}]}
{"instance_id": "2dee4d311009", "generation_result": [{"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tconst Vector2& point,\n\tconst Vector2& segmentStart,\n\tconst Vector2& segmentEnd\n} {\n\tVector2 segment = segmentEnd - segmentStart;\n\tfloat segmentLengthSquared = segment.LengthSquared();\n\n\tif (segmentLengthSquared == 0) {\n\t\treturn { 0, Vector2::Distance(point, segmentStart) };\n\t}\n\n\tfloat t = Vector2::Dot(point - segmentStart, segment) / segmentLengthSquared;\n\tt = std::clamp(t, 0.0f, 1.0f);\n\n\tVector2 projection = segmentStart + t * segment;\n\treturn { Vector2::Distance(point, projection), Vector2::Distance(point, projection) };\n}\n", "CodeBleu_score": 41.61880735336881}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tVector2 point,\n\tVector2 segmentStart,\n\tVector2 segmentEnd\n} {\n\tfloat segmentLengthSquared = (segmentEnd - segmentStart).LengthSquared();\n\tif (segmentLengthSquared == 0.0f) {\n\t\treturn {\n\t\t\t(point - segmentStart).Length(),\n\t\t\t0.0f\n\t\t};\n\t}\n\n\tfloat t = std::max(0.0f, std::min(1.0f, (point - segmentStart).Dot(segmentEnd - segmentStart) / segmentLengthSquared));\n\tVector2 projection = segmentStart + t * (segmentEnd - segmentStart);\n\treturn {\n\t\t(point - projection).Length(),\n\t\t(point - projection).Length()\n\t};\n}\n", "CodeBleu_score": 34.76126180116238}, {"code": "std::pair<float, float> Math::DistanceSegmentToPoint\tconst Vector2& p,\n\tconst Vector2& a,\n\tconst Vector2& b\n}", "CodeBleu_score": 9.244835059124245}]}
{"instance_id": "ded98caeb2fc", "generation_result": [{"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)-    assert(vertices.size() >= 3);", "CodeBleu_score": 13.352843232204153}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)\tassert(vertices.size() >= 3);\n\tconst unsigned int initial_index = vertices.size() - 1;\n\tfor (unsigned int i = 0; i < vertices.size(); ++i) {\n\t\tAddVertex(vertices[i]);\n\t}\n\tfor (unsigned int i = 0; i < vertices.size() - 2; ++i) {\n\t\tAddTriangle(initial_index, initial_index + i + 1, initial_index + i + 2);\n\t}\n}\n", "CodeBleu_score": 35.755191669538014}, {"code": " void Mesh::AddTriangleFan(const std::vector<Mesh::vertex_type> &vertices)-    assert(vertices.size() >= 3);", "CodeBleu_score": 13.352843232204153}]}
{"instance_id": "e563ae11ea5a", "generation_result": [{"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (!message) {\n\t\tthrow std::runtime_error(\"Null message.\");\n\t}\n\n\tif (message->GetPayload().size() > MAX_MESSAGE_SIZE) {\n\t\tthrow std::runtime_error(\"Message is too large.\");\n\t}\n\n\tif (message->GetPayload().size() < MIN_MESSAGE_SIZE) {\n\t\tthrow std::runtime_error(\"Message is too small.\");\n\t}\n\n\tif (!socket_->is_open()) {\n\t\tthrow std::runtime_error(\"Socket is not open.\");\n\t}\n\n\tstrand_->post([this, message]() {\n\t\tif (!socket_->is_open()) {\n\t\t\treturn;\n\t\t}\n\n\t\tsocket_->expires_from_now(boost::posix_time::seconds(TIMEOUT));\n\t\tsocket_->async_write_some(boost::asio::buffer(message->GetPayload()), [this, message](const boost::system::error_code& error, std::size_t bytes_transferred) {\n\t\t\tHandleSent(error, bytes_transferred, message);\n\t\t});\n\t});\n}\n", "CodeBleu_score": 34.882312368791034}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (!message->IsValid()) {\n\t\tthrow std::runtime_error(\"Invalid message\");\n\t}\n\n\tstrand_.post([this, message]() {\n\t\tif (socket_.is_open()) {\n\t\t\tsocket_.expires_from_now(std::chrono::milliseconds(timeout_));\n\t\t\tsocket_.async_write_some(boost::asio::buffer(message->Data(), message->Size()),\n\t\t\t\t[this, message](boost::system::error_code ec, std::size_t bytes_transferred) {\n\t\t\t\t\tthis->HandleSent(ec, bytes_transferred, message);\n\t\t\t\t});\n\t\t} else {\n\t\t\tthrow std::runtime_error(\"Socket is not open\");\n\t\t}\n\t});\n}\n", "CodeBleu_score": 29.78324913488492}, {"code": "void Primary::Write(std::shared_ptr<const carla::streaming::detail::tcp::Message> message)\tif (!message) {\n\t\tthrow std::invalid_argument(\"message is null\");\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kHeartbeat) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kError) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kClose) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kPing) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kPong) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kRequest) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kResponse) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kRequestChunk) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kResponseChunk) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kRequestChunkData) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kResponseChunkData) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kRequestChunkDataAck) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::MessageType::kResponseChunkDataAck) {\n\t\treturn;\n\t}\n\n\tif (message->GetHeader().GetMessageType() == carla::streaming::detail::tcp::", "CodeBleu_score": 18.662515281278885}]}
{"instance_id": "152dbc61bfef", "generation_result": [{"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (ec) {\n\t\tlog->warn(\"Socket closing failed: {}\", ec.message());\n\t}\n\tif (socket->is_open()) {\n\t\tboost::system::error_code shutdown_ec;\n\t\tsocket->shutdown(boost::asio::ip::tcp::socket::shutdown_both, shutdown_ec);\n\t\tif (shutdown_ec) {\n\t\t\tlog->warn(\"Socket shutdown failed: {}\", shutdown_ec.message());\n\t\t}\n\t\tsocket->close();\n\t}\n\ton_closed();\n\tlog->info(\"Socket closed\");\n}\n", "CodeBleu_score": 51.674620189625074}, {"code": "void Primary::CloseNow(boost::system::error_code ec)\tif (ec) {\n\t\treturn;\n\t}\n\n\t// Cancel any outstanding deadline.\n\tdeadline_.cancel();\n\n\t// At this point the connection is closed gracefully\n\tif (socket_.is_open()) {\n\t\t// Attempt a graceful close of the socket\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\n\t\t// Close the socket\n\t\tsocket_.close();\n\t}\n\n\t// Trigger the on_closed callback and log that the session has been closed\n\ton_closed();\n\tLOG(INFO) << \"Session closed\";\n}\n", "CodeBleu_score": 44.16272039863724}, {"code": "void Primary::CloseNow(boost::system::error_code ec)\t// Cancel the deadline timer\n\tdeadline_.cancel();\n\n\t// If no error code is provided and the socket is open, attempt to shut down and close the socket\n\tif (!ec && socket_.is_open()) {\n\t\tboost::system::error_code ignored_ec;\n\t\tsocket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ignored_ec);\n\t\tsocket_.close();\n\t}\n\n\t// Trigger the on_closed callback\n\ton_closed();\n\n\t// Log that the session has been closed\n\tstd::cout << \"Session closed\" << std::endl;\n}\n", "CodeBleu_score": 56.47516546754665}]}
{"instance_id": "3d3ca7907fca", "generation_result": [{"code": "void PrimaryCommands::SendIsAlive()\tchar buffer[BUFFER_SIZE];\n\tint bytes_written;\n\tint bytes_read;\n\tint router_index = 0;\n\tchar response[BUFFER_SIZE];\n\tint response_size;\n\n\t// Create buffer\n\tbytes_written = sprintf(buffer, \"%s\", \"Are you alive?\");\n\n\t// Log sending action\n\tlog_info(\"Sending message to router %d: %s\", router_index, buffer);\n\n\t// Write buffer to next router\n\tbytes_written = write(router_index, buffer, bytes_written);\n\n\t// Wait for response\n\tbytes_read = read(router_index, response, BUFFER_SIZE);\n\n\t// Log response\n\tresponse_size = sprintf(response, \"%s\", response);\n\tlog_info(\"Received message from router %d: %s\", router_index, response);\n}\n", "CodeBleu_score": 36.73597842627871}, {"code": "void PrimaryCommands::SendIsAlive()\t//Create the buffer\n\tchar buffer[10];\n\tsprintf(buffer, \"%s\", \"Are you alive?\");\n\t//Log the sending action\n\tLog::log(Log::INFO, \"PrimaryCommands\", \"Sending message: Are you alive?\");\n\t//Write the buffer to the next router\n\twrite(nextRouter, buffer, 10);\n\t//Wait for the response\n\tchar response[10];\n\tread(nextRouter, response, 10);\n\t//Log the response\n\tLog::log(Log::INFO, \"PrimaryCommands\", \"Received response: %s\", response);\n}\n", "CodeBleu_score": 38.94609869755601}, {"code": "void PrimaryCommands::SendIsAlive()\t// Create the message\n\tchar buffer[100];\n\tstrcpy(buffer, \"Are you alive?\");\n\t// Log the sending action\n\tcout << \"PrimaryCommands::SendIsAlive: Sending message: \" << buffer << endl;\n\t// Send the message to the next router\n\tint router = NextRouter();\n\tint bytes_sent = sendto(socket_fd, buffer, strlen(buffer), 0, (struct sockaddr *) &router_addresses[router], sizeof(router_addresses[router]));\n\t// Log the response\n\tcout << \"PrimaryCommands::SendIsAlive: Sent \" << bytes_sent << \" bytes\" << endl;\n\t// Wait for the response\n\tchar response[100];\n\tint bytes_received = recvfrom(socket_fd, response, 100, 0, NULL, NULL);\n\t// Log the response\n\tcout << \"PrimaryCommands::SendIsAlive: Received \" << bytes_received << \" bytes\" << endl;\n\tcout << \"PrimaryCommands::SendIsAlive: Response: \" << response << endl;\n}\n", "CodeBleu_score": 36.36131450269904}]}
{"instance_id": "234b198bb14e", "generation_result": [{"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Create a buffer for the sensor ID\n\tuint8_t buffer[2];\n\tbuffer[0] = sensor_id >> 8;\n\tbuffer[1] = sensor_id & 0xFF;\n\n\t// Send the ENABLE_ROS command to the server using the router\n\tif (router.SendCommand(ENABLE_ROS, buffer, 2, true)) {\n\t\t// Wait for the server's response\n\t\tuint8_t response[2];\n\t\tif (router.GetResponse(response, 2)) {\n\t\t\t// If the sensor is enabled on the server, log the message\n\t\t\tif (response[0] == 0x01) {\n\t\t\t\tprintf(\"Sensor %d enabled for ROS.\\n\", sensor_id);\n\t\t\t}\n\t\t\t// If the sensor is not enabled on the server, log the error message\n\t\t\telse {\n\t\t\t\tprintf(\"ERROR: Sensor %d not enabled for ROS.\\n\", sensor_id);\n\t\t\t}\n\t\t}\n\t\t// If the server did not respond, log the error message\n\t\telse {\n\t\t\tprintf(\"ERROR: Sensor %d not enabled for ROS.\\n\", sensor_id);\n\t\t}\n\t}\n\t// If the command could not be sent, log the error message\n\telse {\n\t\tprintf(\"ERROR: Sensor %d not enabled for ROS.\\n\", sensor_id);\n\t}\n}\n", "CodeBleu_score": 35.237267514496025}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Check if the sensor has been activated on any secondary server\n\tif (sensor_id < 0 || sensor_id >= MAX_SENSORS) {\n\t\tLOG_ERROR(\"Invalid sensor ID: %d\", sensor_id);\n\t\treturn;\n\t}\n\n\t// Check if the sensor has been activated on any secondary server\n\tif (sensors[sensor_id].activated_on_secondary_server == false) {\n\t\tLOG_ERROR(\"Sensor %d has not been activated on any secondary server\", sensor_id);\n\t\treturn;\n\t}\n\n\t// Create the buffer\n\tuint8_t buffer[10];\n\tbuffer[0] = 0x00;\n\tbuffer[1] = 0x00;\n\tbuffer[2] = 0x00;\n\tbuffer[3] = 0x00;\n\tbuffer[4] = 0x00;\n\tbuffer[5] = 0x00;\n\tbuffer[6] = 0x00;\n\tbuffer[7] = 0x00;\n\tbuffer[8] = 0x00;\n\tbuffer[9] = 0x00;\n\n\t// Fill the buffer with the sensor ID\n\tbuffer[0] = (uint8_t) (sensor_id >> 24);\n\tbuffer[1] = (uint8_t) (sensor_id >> 16);\n\tbuffer[2] = (uint8_t) (sensor_id >> 8);\n\tbuffer[3] = (uint8_t) (sensor_id);\n\n\t// Send the ENABLE_ROS command to the server\n\trouter->SendCommand(ENABLE_ROS, buffer, 10);\n\n\t// Wait for and process the server's response\n\tuint8_t response[10];\n\trouter->WaitForResponse(response, 10);\n\n\t// Check if the response is correct\n\tif (response[0]!= 0x00 || response[1]!= 0x00 || response[2]!= 0x00 || response[3]!= 0x00 || response[4]!= 0x00 || response[5]!= 0x00 || response[6]!= ", "CodeBleu_score": 31.639492652718932}, {"code": "void PrimaryCommands::SendEnableForROS(stream_id sensor_id)\t// Check if the sensor has been activated on any secondary server\n\tif (sensor_id!= 0) {\n\t\t// Create a buffer to hold the sensor ID\n\t\tuint8_t buffer[2];\n\t\t// Write the sensor ID to the buffer\n\t\tbuffer[0] = sensor_id >> 8;\n\t\tbuffer[1] = sensor_id & 0xFF;\n\n\t\t// Send an ENABLE_ROS command to the server using the router\n\t\trouter->Send(buffer, 2, ENABLE_ROS);\n\n\t\t// Wait for and process the server's response\n\t\tuint8_t response_buffer[1];\n\t\trouter->Receive(response_buffer, 1);\n\t\tif (response_buffer[0] == ENABLE_ROS_SUCCESS) {\n\t\t\t// Log a message indicating that the sensor has been enabled for ROS\n\t\t\tstd::cout << \"Sensor \" << sensor_id << \" enabled for ROS\" << std::endl;\n\t\t} else {\n\t\t\t// Log an error message if the sensor was not found on any server\n\t\t\tstd::cout << \"Sensor \" << sensor_id << \" not found on any server\" << std::endl;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.447401239951525}]}
{"instance_id": "76bb90fe6a09", "generation_result": [{"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\ttoken_type token;\n\t// Check if the sensor is already activated\n\tif (sensor_id_to_token_map.find(sensor_id)!= sensor_id_to_token_map.end()) {\n\t\t// If the sensor is already activated, return the existing token\n\t\ttoken = sensor_id_to_token_map[sensor_id];\n\t\tLOG(INFO) << \"Sensor \" << sensor_id << \" is already activated. Token: \" << token;\n\t} else {\n\t\t// If the sensor is not activated, enable it on a secondary server\n\t\ttoken = EnableSensor(sensor_id);\n\t\t// Update the maps\n\t\tsensor_id_to_token_map[sensor_id] = token;\n\t\ttoken_to_sensor_id_map[token] = sensor_id;\n\t\t// Log the action\n\t\tLOG(INFO) << \"Sensor \" << sensor_id << \" is activated. Token: \" << token;\n\t}\n\treturn token;\n}\n", "CodeBleu_score": 44.99842707860957}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\t// Check if the sensor is already activated\n\tif (sensor_token_map.find(sensor_id)!= sensor_token_map.end()) {\n\t\t// If so, return the existing token\n\t\ttoken_type token = sensor_token_map[sensor_id];\n\t\tLOG_INFO << \"Token already exists for sensor \" << sensor_id << \". Returning token \" << token << \".\";\n\t\treturn token;\n\t}\n\t// If not, enable the sensor on a secondary server, retrieve a new token, update the maps, and return the new token\n\tLOG_INFO << \"Token does not exist for sensor \" << sensor_id << \". Enabling sensor \" << sensor_id << \" on secondary server.\";\n\ttoken_type token = EnableSensor(sensor_id);\n\tsensor_token_map[sensor_id] = token;\n\tsensor_stream_map[token] = sensor_id;\n\treturn token;\n}\n", "CodeBleu_score": 42.06419158635637}, {"code": "token_type PrimaryCommands::GetToken(stream_id sensor_id)\t// Check if sensor is already activated\n\tif (sensor_map.find(sensor_id)!= sensor_map.end()) {\n\t\t// Sensor is already activated\n\t\ttoken_type token = sensor_map[sensor_id];\n\t\t// Log the action\n\t\tlog_file << \"Sensor \" << sensor_id << \" is already activated. Token is \" << token << endl;\n\t\treturn token;\n\t}\n\t// Sensor is not activated\n\t// Enable the sensor\n\ttoken_type token = EnableSensor(sensor_id);\n\t// Update the maps\n\tsensor_map[sensor_id] = token;\n\tsensor_token_map[token] = sensor_id;\n\t// Log the action\n\tlog_file << \"Sensor \" << sensor_id << \" is activated. Token is \" << token << endl;\n\treturn token;\n}\n", "CodeBleu_score": 45.12080260811318}]}
{"instance_id": "8c99bd334140", "generation_result": [{"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file;\n\tfile.open(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(buffer);\n}\n", "CodeBleu_score": 61.433694903608306}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tstd::vector<unsigned char> data((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(data);\n}\n", "CodeBleu_score": 53.36598074659567}, {"code": "bool Navigation::Load(const std::string &filename)\tstd::ifstream file;\n\tfile.open(filename, std::ios::binary);\n\tif (!file.is_open()) {\n\t\treturn false;\n\t}\n\tfile.seekg(0, std::ios::end);\n\tstd::vector<char> file_content;\n\tfile_content.reserve(file.tellg());\n\tfile.seekg(0, std::ios::beg);\n\tfile_content.insert(file_content.begin(), std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());\n\tfile.close();\n\treturn Load(file_content);\n}\n", "CodeBleu_score": 57.18156262501643}]}
{"instance_id": "1026c106ca90", "generation_result": [{"code": "bool Navigation::RemoveAgent(ActorId id)\tif (!IsReady()) {\n\t\treturn false;\n\t}\n\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Find the agent in the walker and vehicle mappings.\n\tauto walkerIt = walkers.find(id);\n\tauto vehicleIt = vehicles.find(id);\n\n\t// If the agent is found, enter a critical section to safely remove it from the crowd.\n\tif (walkerIt!= walkers.end() || vehicleIt!= vehicles.end()) {\n\t\tEnterCriticalSection(&cs);\n\n\t\t// Remove the agent from the crowd.\n\t\tcrowd->RemoveAgent(walkerIt!= walkers.end()? walkerIt->second : vehicleIt->second);\n\n\t\t// Update the walker or vehicle manager.\n\t\tif (walkerIt!= walkers.end()) {\n\t\t\twalkerIt->second->RemoveAgent();\n\t\t\twalkers.erase(walkerIt);\n\t\t}\n\t\telse {\n\t\t\tvehicleIt->second->RemoveAgent();\n\t\t\tvehicles.erase(vehicleIt);\n\t\t}\n\n\t\tLeaveCriticalSection(&cs);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 44.90891419241668}, {"code": "bool Navigation::RemoveAgent(ActorId id)\t// Check if the system is ready\n\tif (!ready) {\n\t\treturn false;\n\t}\n\n\t// Check if the crowd object is null\n\tif (crowd == nullptr) {\n\t\treturn false;\n\t}\n\n\t// Enter a critical section to safely remove the agent from the crowd\n\tEnterCriticalSection(&critSec);\n\n\t// Search for the agent id in the walker and vehicle mappings\n\tauto walkerIt = walkers.find(id);\n\tauto vehicleIt = vehicles.find(id);\n\n\t// If found, remove the agent from the crowd, update the walker or vehicle manager, and remove the id from the mappings\n\tif (walkerIt!= walkers.end()) {\n\t\tcrowd->removeAgent(walkerIt->second);\n\t\twalkerIt->second->Remove();\n\t\twalkers.erase(walkerIt);\n\t}\n\telse if (vehicleIt!= vehicles.end()) {\n\t\tcrowd->removeAgent(vehicleIt->second);\n\t\tvehicleIt->second->Remove();\n\t\tvehicles.erase(vehicleIt);\n\t}\n\n\t// Leave the critical section\n\tLeaveCriticalSection(&critSec);\n\n\t// Return true if the agent is successfully removed, otherwise false\n\treturn true;\n}\n", "CodeBleu_score": 47.06005607926566}, {"code": "bool Navigation::RemoveAgent(ActorId id)\tif (m_ready) {\n\t\tif (m_crowd!= nullptr) {\n\t\t\tstd::lock_guard<std::mutex> lock(m_mutex);\n\t\t\tm_crowd->removeAgent(id);\n\t\t\tm_walkerManager->RemoveAgent(id);\n\t\t\tm_vehicleManager->RemoveAgent(id);\n\t\t\tm_agentIds.erase(id);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 27.30359303903997}]}
{"instance_id": "bba5a06a03fb", "generation_result": [{"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> currentVehicles;\n\tfor (auto it = vehicles_.begin(); it!= vehicles_.end(); ++it) {\n\t\tcurrentVehicles.insert(it->first);\n\t}\n\n\tfor (auto it = vehicles.begin(); it!= vehicles.end(); ++it) {\n\t\tif (currentVehicles.find(it->id)!= currentVehicles.end()) {\n\t\t\tvehicles_[it->id].updated = true;\n\t\t} else {\n\t\t\tvehicles_[it->id].updated = false;\n\t\t\tvehicles_[it->id].position = it->position;\n\t\t\tvehicles_[it->id].velocity = it->velocity;\n\t\t\tvehicles_[it->id].acceleration = it->acceleration;\n\t\t\tvehicles_[it->id].steeringAngle = it->steeringAngle;\n\t\t\tvehicles_[it->id].lane = it->lane;\n\t\t\tvehicles_[it->id].laneOffset = it->laneOffset;\n\t\t\tvehicles_[it->id].heading = it->heading;\n\t\t\tvehicles_[it->id].speed = it->speed;\n\t\t\tvehicles_[it->id].vehicleLength = it->vehicleLength;\n\t\t\tvehicles_[it->id].vehicleWidth = it->vehicleWidth;\n\t\t\tvehicles_[it->id].vehicleClass = it->vehicleClass;\n\t\t}\n\t}\n\n\tfor (auto it = currentVehicles.begin(); it!= currentVehicles.end(); ++it) {\n\t\tif (!vehicles_[*it].updated) {\n\t\t\tvehicles_.erase(*it);\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 45.01320082691418}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> vehicleIDs;\n\tfor (auto& vehicle : vehicles) {\n\t\tvehicleIDs.insert(vehicle.id);\n\t\tauto vehicleIter = m_vehicles.find(vehicle.id);\n\t\tif (vehicleIter!= m_vehicles.end()) {\n\t\t\tvehicleIter->second.updated = true;\n\t\t}\n\t\telse {\n\t\t\tm_vehicles[vehicle.id] = vehicle;\n\t\t}\n\t}\n\tfor (auto vehicleIter = m_vehicles.begin(); vehicleIter!= m_vehicles.end();) {\n\t\tif (!vehicleIDs.count(vehicleIter->first)) {\n\t\t\tvehicleIter = m_vehicles.erase(vehicleIter);\n\t\t}\n\t\telse {\n\t\t\t++vehicleIter;\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 43.5254234087023}, {"code": "bool Navigation::UpdateVehicles(std::vector<VehicleCollisionInfo> vehicles)\tstd::set<int> currentVehicles;\n\tfor (auto vehicle : vehicles) {\n\t\tcurrentVehicles.insert(vehicle.id);\n\t}\n\tfor (auto vehicle : vehicles) {\n\t\tif (vehicle.updated) {\n\t\t\tif (vehicle.exists) {\n\t\t\t\tif (vehicles_.find(vehicle.id) == vehicles_.end()) {\n\t\t\t\t\tvehicles_.insert({vehicle.id, Vehicle(vehicle.id, vehicle.position, vehicle.velocity, vehicle.heading, vehicle.speed)});\n\t\t\t\t} else {\n\t\t\t\t\tvehicles_[vehicle.id].SetPosition(vehicle.position);\n\t\t\t\t\tvehicles_[vehicle.id].SetVelocity(vehicle.velocity);\n\t\t\t\t\tvehicles_[vehicle.id].SetHeading(vehicle.heading);\n\t\t\t\t\tvehicles_[vehicle.id].SetSpeed(vehicle.speed);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvehicles_.erase(vehicle.id);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 42.11762544631159}]}
{"instance_id": "314091490a89", "generation_result": [{"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)#ifdef CARLA_SERVER\n  if (auto actor = GetActor(id)) {\n    if (auto vehicle = actor->GetVehicle()) {\n      // Check if the vehicle is in the crowd\n      const auto& location = vehicle->GetLocation();\n      const auto& velocity = vehicle->GetVelocity();\n      const auto& bounding_box = vehicle->GetBoundingBox();\n      const auto& crowd_position = crowd_->GetPosition(vehicle->GetID());\n      const auto& crowd_velocity = crowd_->GetVelocity(vehicle->GetID());\n      const auto& crowd_bounding_box = crowd_->GetBoundingBox(vehicle->GetID());\n      const auto& crowd_position_world = crowd_->GetPositionWorld(vehicle->GetID());\n      const auto& crowd_velocity_world = crowd_->GetVelocityWorld(vehicle->GetID());\n      const auto& crowd_bounding_box_world = crowd_->GetBoundingBoxWorld(vehicle->GetID());\n      const auto& crowd_position_world_2d = crowd_->GetPositionWorld2D(vehicle->GetID());\n      const auto& crowd_velocity_world_2d = crowd_->GetVelocityWorld2D(vehicle->GetID());\n      const auto& crowd_bounding_box_world_2d = crowd_->GetBoundingBoxWorld2D(vehicle->GetID());\n\n      if (crowd_position.x!= -1.0f) {\n        // Compute squared distance\n        const auto squared_distance = (crowd_position_world - location).SquaredLength();\n        // Check if the vehicle is within the distance\n        if (squared_distance <= distance * distance) {\n          // Check if the vehicle is in the direction\n          const auto& direction_vector = direction.ToVector3D();\n          const auto& direction_vector_world = direction_vector.Rotated(vehicle->GetRotation());\n          const auto& direction_vector_world_2d = direction_vector_world.To2D();\n          const auto& direction_vector_world_2d_normalized = direction_vector_world_2d.Normalized();\n          const auto& crowd_velocity_world_2d_normalized = crowd_velocity_world_2d.Normalized();\n          const auto& angle = direction_vector_world_2d_normalized.Angle(crowd_velocity_world_2d_", "CodeBleu_score": 32.33230697535725}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tif (!HasActor(id)) {\n\t\treturn false;\n\t}\n\tfloat squared_distance = distance * distance;\n\tstd::unique_lock<std::mutex> lock(mutex_);\n\tauto it = actors_.find(id);\n\tif (it!= actors_.end()) {\n\t\tauto vehicle = it->second;\n\t\tif (vehicle->IsVehicle()) {\n\t\t\tauto crowd = world_->GetCrowd();\n\t\t\tauto position = vehicle->GetActor()->GetLocation();\n\t\t\tauto velocity = vehicle->GetActor()->GetVelocity();\n\t\t\tauto forward = carla::geom::Vector3D(velocity.x, 0.0f, velocity.y);\n\t\t\tauto position_in_crowd = crowd->GetAgentPosition(vehicle->GetActorId());\n\t\t\tauto distance_squared = (position_in_crowd - position).SquaredLength();\n\t\t\tif (distance_squared < squared_distance) {\n\t\t\t\tauto forward_in_crowd = crowd->GetAgentState(vehicle->GetActorId()).velocity;\n\t\t\t\tauto dot_product = forward.Dot(forward_in_crowd);\n\t\t\t\tif (dot_product > 0.99f) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 46.23168775088132}, {"code": "bool Navigation::HasVehicleNear(ActorId id, float distance, carla::geom::Location direction)\tstd::lock_guard<std::mutex> lock(mutex_);\n\tauto it = walkers_.find(id);\n\tif (it!= walkers_.end()) {\n\t\tauto& walker = it->second;\n\t\tauto& transform = walker.transform;\n\t\tauto& location = transform.location;\n\t\tauto& rotation = transform.rotation;\n\t\tauto& vehicle_location = location + rotation.RotateVector(direction);\n\t\tauto squared_distance = location.DistanceSquared(vehicle_location);\n\t\tif (squared_distance < distance * distance) {\n\t\t\tauto& crowd = crowd_system_.get();\n\t\t\tauto& crowd_agent = crowd.getAgent(walker.agent_id);\n\t\t\tauto& crowd_agent_position = crowd_agent.getPosition();\n\t\t\tauto& crowd_agent_velocity = crowd_agent.getVelocity();\n\t\t\tauto& crowd_agent_velocity_normalized = crowd_agent_velocity.Normalized();\n\t\t\tauto& crowd_agent_position_near = crowd_agent_position + crowd_agent_velocity_normalized * distance;\n\t\t\tauto& crowd_agent_position_far = crowd_agent_position - crowd_agent_velocity_normalized * distance;\n\t\t\tauto& crowd_agent_position_near_location = carla::geom::Location(crowd_agent_position_near.x, crowd_agent_position_near.y, crowd_agent_position_near.z);\n\t\t\tauto& crowd_agent_position_far_location = carla::geom::Location(crowd_agent_position_far.x, crowd_agent_position_far.y, crowd_agent_position_far.z);\n\t\t\tauto& crowd_agent_position_near_location_distance = crowd_agent_position_near_location.DistanceSquared(vehicle_location);\n\t\t\tauto& crowd_agent_position_far_location_distance = crowd_agent_position_far_location.DistanceSquared(vehicle_location);\n\t\t\tif (crowd_agent_position_near_location_distance < distance * distance || crowd_agent_position_far_location_distance < distance * distance) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t", "CodeBleu_score": 40.65111972569812}]}
{"instance_id": "048b2b6668b5", "generation_result": [{"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tauto &walker = info.GetWalker();\n\tauto &route = info.GetRoute();\n\tauto &current = route.GetCurrent();\n\n\tWalkerEventVisitor visitor(info, delta);\n\tauto result = boost::apply_visitor(visitor, current.event);\n\treturn result;\n}\n", "CodeBleu_score": 47.26226588662591}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\t// Get the current route point\n\tauto &current = info.current;\n\n\t// Create the visitor\n\tWalkerEventVisitor visitor(info, delta);\n\n\t// Execute the event\n\tauto result = boost::apply_visitor(visitor, current.event);\n\n\t// Return the result\n\treturn result;\n}\n", "CodeBleu_score": 47.038574447384526}, {"code": "EventResult WalkerManager::ExecuteEvent(ActorId id, WalkerInfo &info, double delta)\tWalkerEventVisitor visitor(info, delta);\n\treturn boost::apply_visitor(visitor, info.currentEvent);\n}\n", "CodeBleu_score": 33.318835058130226}]}
{"instance_id": "e6582512af3b", "generation_result": [{"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)#ifdef DEBUG_PARSER\n  std::cout << \"LaneParser::Parse\" << std::endl;", "CodeBleu_score": 7.000021777386338}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)#if DEBUG_LANE_PARSER\n  std::cout << \"LaneParser::Parse\" << std::endl;", "CodeBleu_score": 7.000031164718848}, {"code": "void LaneParser::Parse(\n      const pugi::xml_document &xml,\n      carla::road::MapBuilder &map_builder)\n#if DEBUG_LANE_PARSER\n  std::cout << \"Parsing LaneParser\" << std::endl;", "CodeBleu_score": 7.000041662678515}]}
{"instance_id": "ba3155bc7ea0", "generation_result": [{"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.currentCountChange == 0) {\n\t\tstd::cerr << \"PublicationMatchedStatus::currentCountChange == 0\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (info.currentCountChange > 0) {\n\t\tif (m_matchedCount == 0) {\n\t\t\tm_firstConnection = true;\n\t\t}\n\t\tm_matchedCount += info.currentCountChange;\n\t\tstd::cout << \"Matched \" << m_matchedCount << \" instances of type \" << m_type << std::endl;\n\t} else {\n\t\tm_matchedCount += info.currentCountChange;\n\t\tif (m_matchedCount < 0) {\n\t\t\tm_matchedCount = 0;\n\t\t}\n\t\tstd::cout << \"Lost \" << -info.currentCountChange << \" instances of type \" << m_type << std::endl;\n\t}\n}\n", "CodeBleu_score": 54.37363102326053}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.currentCount == 0) {\n\t\t// This means there is no data match\n\t\t// Set the listener's matched status\n\t\tm_isMatched = false;\n\t} else {\n\t\t// If there is a new match change\n\t\tif (info.currentCount!= m_matchedCount) {\n\t\t\tif (info.currentCount > m_matchedCount) {\n\t\t\t\t// This means there is a new match\n\t\t\t\tm_isMatched = true;\n\t\t\t\tm_matchedCount = info.currentCount;\n\t\t\t} else {\n\t\t\t\t// This means there is a match loss\n\t\t\t\tm_matchedCount = info.currentCount;\n\t\t\t}\n\t\t} else {\n\t\t\t// This means there is an invalid change in matched count\n\t\t\tstd::cerr << \"Invalid change in matched count detected. Do not change the value of m_matchedCount\" << std::endl;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 59.43238115485835}, {"code": "void CarlaListenerImpl::on_publication_matched(efd::DataWriter* writer, const efd::PublicationMatchedStatus& info)\tif (info.currentCount > info.previousCount) {\n\t\tif (info.currentCount == 1) {\n\t\t\t// Set the matched count and mark the first connection.\n\t\t\tm_matchedCount = info.currentCount;\n\t\t\tm_firstConnection = true;\n\t\t}\n\t\telse {\n\t\t\t// Update the matched count.\n\t\t\tm_matchedCount = info.currentCount;\n\t\t}\n\t}\n\telse if (info.currentCount < info.previousCount) {\n\t\t// Update the matched count.\n\t\tm_matchedCount = info.currentCount;\n\t}\n\telse {\n\t\t// If the count is the same, then we have an error.\n\t\tstd::ostringstream errorMsg;\n\t\terrorMsg << \"Publication count changed with no change in state. Current count \" << info.currentCount << \", previous count \" << info.previousCount;\n\t\tlogError(errorMsg.str());\n\t}\n}\n", "CodeBleu_score": 55.829939866088765}]}
{"instance_id": "9745f41ab1c1", "generation_result": [{"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\t// TODO: Add logging here\n\tif (info.current_count_change == 0) {\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"ERROR: Invalid change count in subscription status.\" << std::endl;\n\t}\n\telse {\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Subscription matched status: \" << info.current_count_change << \" total count: \" << info.current_count << std::endl;\n\t}\n\n\tif (info.current_count == 0) {\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"No more subscriptions matched.\" << std::endl;\n\t\t// Destroy the subscriber\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging here\n\t\t//std::cout << \"Destroying subscriber.\" << std::endl;\n\t\t// TODO: Add logging", "CodeBleu_score": 22.777334748591322}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\tif (info.current_count_change == 1) {\n\t\tif (info.current_count == 1) {\n\t\t\tm_first_connected = true;\n\t\t}\n\t\tm_matched_count_change = info.current_count;\n\t} else if (info.current_count_change == -1) {\n\t\tm_matched_count_change = info.current_count;\n\t} else {\n\t\tm_matched_count_change = 0;\n\t\tstd::cerr << \"Error: invalid matched count\" << std::endl;\n\t}\n}\n", "CodeBleu_score": 61.35575463762755}, {"code": "void CarlaSubscriberListenerImpl::on_subscription_matched(efd::DataReader* reader, const efd::SubscriptionMatchedStatus& info)\tif (info.current_count_change == 0) {\n\t\tlog_error(\"Subscriber matched count change is invalid\");\n\t}\n\telse if (info.current_count_change > 0) {\n\t\tmatched_count += info.current_count_change;\n\t\tif (matched_count == 1) {\n\t\t\tfirst_connected = true;\n\t\t}\n\t}\n\telse if (info.current_count_change < 0) {\n\t\tmatched_count += info.current_count_change;\n\t\tif (matched_count == 0) {\n\t\t\tlog_info(\"Subscriber destroyed, no more matches\");\n\t\t\tsubscriber->destroy_subscriber();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 58.737007660593946}]}
{"instance_id": "140d0e12ec58", "generation_result": [{"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\tif (force_md5) {\n\t\t// always use md5\n\t\treturn false;\n\t}\n\t// force_md5 has been set -> do md5 calculation\n\n\tCarlaCollisionEvent* p_type = (CarlaCollisionEvent*) data;\n\n\t// TODO(Ricardo) check this:\n\thandle->value[0] = 0;\n\t// End of auto generated code\n\n\treturn true;\n}\n\n} // namespace carla", "CodeBleu_score": 12.75339714326573}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\tif (force_md5) {\n\t\treturn getKeyMD5(data, handle);\n\t}\n\treturn getKey(data, handle);\n}\n", "CodeBleu_score": 8.951875982721498}, {"code": "bool CarlaCollisionEventPubSubType::getKey(\n                void* data,\n                InstanceHandle_t* handle,\n                bool force_md5)\tif (force_md5) {\n\t\treturn getKeyMD5(data, handle);\n\t}\n\t//object_id\n\thandle->value[0] = ((CarlaCollisionEvent*) data)->getObjectId();\n\t//colliding_object_id\n\thandle->value[1] = ((CarlaCollisionEvent*) data)->getCollidingObjectId();\n\t//collision_point\n\thandle->value[2] = ((CarlaCollisionEvent*) data)->getCollisionPoint();\n\t//collision_normal\n\thandle->value[3] = ((CarlaCollisionEvent*) data)->getCollisionNormal();\n\t//collision_time\n\thandle->value[4] = ((CarlaCollisionEvent*) data)->getCollisionTime();\n\treturn true;\n}\n", "CodeBleu_score": 15.305971918429965}]}
{"instance_id": "96581065f962", "generation_result": [{"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)\tpayload->encapsulation = Endianness::BIG_ENDIAN;\n\tpayload->parentBuffer = reinterpret_cast<uint8_t*>(payload->buffer);\n\tpayload->parentEndianness = Endianness::BIG_ENDIAN;\n\tpayload->parentBufferLength = k_SERIALIZED_SIZE;\n\n\t// Initializing payload.data as default value 0, for normal case when payload.data pointer is correctly initalized.\n\tstd::memcpy(payload->data, &default_value_CarlaEgoVehicleControl_, sizeof(CarlaEgoVehicleControl_t));\n\tpayload->data[0] = reinterpret_cast<uint8_t*>(data);\n\tCdr cdr_serialize(&payload->parentBuffer[payload->parentBufferLength], payload->parentBufferLength - payload->parentBufferLength, payload->parentEndianness);\n\t// Cdr serialize in number of elements, you call write_type() for each serialized element\n\tcdr_serialize.write_type(static_cast<uint32_t>(1)); // write number of elements in the array\n\tcdr_serialize.write_type(static_cast<double>(data->throttle));\n\tcdr_serialize.write_type(static_cast<double>(data->brake));\n\tcdr_serialize.write_type(static_cast<double>(data->steering_angle));\n\tcdr_serialize.write_type(static_cast<double>(data->clutch));\n\tcdr_serialize.write_type(static_cast<double>(data->gear));\n\tcdr_serialize.write_type(static_cast<double>(data->engine_torque));\n\tcdr_serialize.write_type(static_cast<double>(data->engine_speed));\n\tcdr_serialize.write_type(static_cast<double>(data->wheel_slip_front_left));\n\tcdr_serialize.write_type(static_cast<double>(data->wheel_slip_front_right));\n\tcdr_serialize.write_type(static_cast<double>(data->wheel_slip_rear_left));\n\tcdr_serialize.write_type(static_cast<double>(data->wheel_slip_rear_right));\n\tcdr_serialize.write_type(static_", "CodeBleu_score": 35.482879670505355}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)\t// Set the endianness of the payload\n\tif (payload->encapsulation == CDR_BE_ENDIANNESS) {\n\t\tpayload->endianness = ENDIANNESS_BIGENDIAN;\n\t} else if (payload->encapsulation == CDR_LE_ENDIANNESS) {\n\t\tpayload->endianness = ENDIANNESS_LITTLEENDIAN;\n\t} else {\n\t\treturn false;\n\t}\n\n\t// Create a FastBuffer\n\tFastBuffer fastBuffer(payload->max_size);\n\t// Create a Cdr serialization type\n\tCdr serializationCdr(fastBuffer, payload->encapsulation);\n\n\t// Serialize the object\n\tif (!serialize(data, serializationCdr)) {\n\t\treturn false;\n\t}\n\n\t// Get the serialized length\n\tpayload->length = static_cast<uint32_t>(serializationCdr.getSerializedDataLength());\n\t// Copy the serialized data\n\tmemcpy(payload->data, fastBuffer.getBuffer(), payload->length);\n\n\treturn true;\n}\n", "CodeBleu_score": 44.767002383660305}, {"code": "bool CarlaEgoVehicleControlPubSubType::serialize(\n                void* data,\n                SerializedPayload_t* payload)\tCarlaEgoVehicleControl* p_type = (CarlaEgoVehicleControl*)data;\n\teprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size);\n\t// Object that manages the raw buffer.\n\teprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,\n\t\t\teprosima::fastcdr::Cdr::DDS_CDR);\n\tpayload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS? CDR_BE : CDR_LE;\n\t// Serialize encapsulation\n\tser.serialize_encapsulation();\n\n\ttry\n\t{\n\t\tp_type->serialize(ser);\n\t}\n\tcatch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)\n\t{\n\t\treturn false;\n\t}\n\n\tpayload->length = (uint32_t)ser.getSerializedDataLength();\n\treturn true;\n}\n", "CodeBleu_score": 71.37294619665711}]}
{"instance_id": "94085ddc10d3", "generation_result": [{"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\tif (target_set) return;\n\tif (msg.sysid!= target_sysid) return;\n\tswitch (msg.msgid) {\n\tcase MAVLINK_MSG_ID_GLOBAL_POSITION_INT:\n\t\ttarget_set = true;\n\t\ttarget_lat = msg.payload64[0];\n\t\ttarget_lon = msg.payload64[1];\n\t\ttarget_alt = msg.payload64[2];\n\t\ttarget_alt_rel = msg.payload64[3];\n\t\ttarget_vx = msg.payload64[4];\n\t\ttarget_vy = msg.payload64[5];\n\t\ttarget_vz = msg.payload64[6];\n\t\ttarget_hdg = msg.payload64[7];\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_ATTITUDE:\n\t\ttarget_set = true;\n\t\ttarget_roll = msg.payload64[0];\n\t\ttarget_pitch = msg.payload64[1];\n\t\ttarget_yaw = msg.payload64[2];\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_HEARTBEAT:\n\t\ttarget_set = true;\n\t\ttarget_type = msg.payload64[0];\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_SYS_STATUS:\n\t\ttarget_set = true;\n\t\ttarget_voltage = msg.payload64[0];\n\t\ttarget_current = msg.payload64[1];\n\t\ttarget_battery_remaining = msg.payload64[2];\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_BATTERY_STATUS:\n\t\ttarget_set = true;\n\t\ttarget_current_battery = msg.payload64[0];\n\t\ttarget_voltage_battery = msg.payload64[1];\n\t\ttarget_remaining_battery = msg.payload64[2];\n\t\tbreak;\n\tcase MAVLINK_MSG_ID_VFR_HUD:\n\t\ttarget_set = true;\n\t\ttarget_airspeed = msg.payload64[0];\n\t\ttarget_groundspeed = msg.payload64[1];\n\t\ttarget_climb = msg.payload64[2];\n\t\tbreak;\n\t", "CodeBleu_score": 30.51071012543086}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\tif (msg.sysid == target_sysid) {\n\t\tif (msg.msgid == MAVLINK_MSG_ID_HEARTBEAT) {\n\t\t\tmavlink_heartbeat_t heartbeat;\n\t\t\tmavlink_msg_heartbeat_decode(&msg, &heartbeat);\n\t\t\tif (heartbeat.type == MAV_TYPE_GCS) {\n\t\t\t\ttarget_type = MAV_TYPE_GCS;\n\t\t\t} else {\n\t\t\t\ttarget_type = MAV_TYPE_FIXED_WING;\n\t\t\t}\n\t\t} else if (msg.msgid == MAVLINK_MSG_ID_SYS_STATUS) {\n\t\t\tmavlink_sys_status_t sys_status;\n\t\t\tmavlink_msg_sys_status_decode(&msg, &sys_status);\n\t\t\ttarget_type = sys_status.onboard_control_sensors_present;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tif (target_sysid == 0) {\n\t\t\ttarget_sysid = msg.sysid;\n\t\t\tif (target_type == MAV_TYPE_GCS) {\n\t\t\t\tmavlink_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_MSG_ID_GPS_RAW_INT, 1, 1);\n\t\t\t\tmavlink_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_MSG_ID_ATTITUDE, 1, 1);\n\t\t\t\tmavlink_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, 1, 1);\n\t\t\t\tmavlink_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_MSG_ID_VFR_HUD, 1, 1);\n\t\t\t\tmavlink_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_MSG_ID_HIGHRES_IMU, 1, 1);\n\t\t\t\tmavlink_request_data_stream_send(MAVLINK_COMM_0, target_sysid, MAVLINK_MSG_ID_HEART", "CodeBleu_score": 42.16211864443563}, {"code": "void GCS_MAVLINK_Tracker::mavlink_check_target(const mavlink_message_t &msg)\t// Check if the target is already set\n\tif (target_set) return;\n\n\t// Decode the message\n\tmavlink_message_t mavlink_msg;\n\tmavlink_msg_message_decode(&msg, &mavlink_msg);\n\n\t// Exit if the message type is not one that should be tracked\n\tif (mavlink_msg.msgid!= MAVLINK_MSG_ID_HEARTBEAT &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_SYS_STATUS &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_GPS_RAW_INT &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_ATTITUDE &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_VFR_HUD &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_ATTITUDE_QUATERNION &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_GLOBAL_POSITION_INT &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_SCALED_PRESSURE &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_RAW_IMU &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_LOCAL_POSITION_NED &&\n\t\tmavlink_msg.msgid!= MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV) {\n\t\treturn;\n\t}\n\n\t// Set the target system ID\n\tif (target_sysid == 0) {\n\t\ttarget_sysid = mavlink_msg.sysid;\n\t\tsend_message(MAVLINK_MSG_ID_REQUEST_DATA_STREAM, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0", "CodeBleu_score": 32.80531792722664}]}
{"instance_id": "88fefdf78944", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\t//MAV_RESULT result = GCS_MAVLINK::GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\t//if (result == MAV_RESULT_ACCEPTED) {\n\t//\t_altitude_calibration_needed = true;\n\t//}\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 13.592567279860498}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\tMAV_RESULT result = GCS_MAVLINK_Tracker::_handle_command_preflight_calibration(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_altitude_calibration_needed = true;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 52.9498591737136}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)\t// Handle preflight calibration for the barometer\n\t// This function calls the base class handler and if the result is MAV_RESULT_ACCEPTED, it sets a flag to indicate that altitude calibration is needed on the next barometer update\n\t// The function then returns the result of the base class handler\n\tMAV_RESULT result = GCS_MAVLINK::handle_command_preflight_calibration_baro(msg);\n\tif (result == MAV_RESULT_ACCEPTED) {\n\t\t_need_baro_calibration = true;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 53.068829816963195}]}
{"instance_id": "3a4502c288b4", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tif (packet.param1 == 1.0f) {\n\t\t// arm\n\t\tif (packet.param2 == 1.0f) {\n\t\t\t// enable all\n\t\t\tfor (uint8_t i = 0; i < _component_count; i++) {\n\t\t\t\tif (_component_list[i].type == COMPONENT_TYPE_SERVO) {\n\t\t\t\t\t_component_list[i].enabled = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param2 == 0.0f) {\n\t\t\t// disable all\n\t\t\tfor (uint8_t i = 0; i < _component_count; i++) {\n\t\t\t\tif (_component_list[i].type == COMPONENT_TYPE_SERVO) {\n\t\t\t\t\t_component_list[i].enabled = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_UNSUPPORTED;\n\t\t}\n\t} else if (packet.param1 == 0.0f) {\n\t\t// disarm\n\t\tif (packet.param2 == 1.0f) {\n\t\t\t// enable all\n\t\t\tfor (uint8_t i = 0; i < _component_count; i++) {\n\t\t\t\tif (_component_list[i].type == COMPONENT_TYPE_SERVO) {\n\t\t\t\t\t_component_list[i].enabled = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else if (packet.param2 == 0.0f) {\n\t\t\t// disable all\n\t\t\tfor (uint8_t i = 0; i < _component_count; i++) {\n\t\t\t\tif (_component_list[i].type == COMPONENT_TYPE_SERVO) {\n\t\t\t\t\t_component_list[i].enabled = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn MAV_RESULT_ACCEPTED;\n\t\t} else {\n\t\t\treturn MAV_RESULT_UNSUPPORTED;\n\t\t}\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 42.31983701221944}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tfloat command = packet.param1;\n\tif (command == 1.0) {\n\t\t//arm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else if (command == 0) {\n\t\t//disarm\n\t\treturn MAV_RESULT_ACCEPTED;\n\t} else {\n\t\treturn MAV_RESULT_UNSUPPORTED;\n\t}\n}\n", "CodeBleu_score": 45.60717434849684}, {"code": "MAV_RESULT GCS_MAVLINK_Tracker::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)\tif (packet.param1 == 1.0f) {\n\t\t_vehicle_armed = true;\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\tif (packet.param1 == 0.0f) {\n\t\t_vehicle_armed = false;\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\treturn MAV_RESULT_UNSUPPORTED;\n}\n", "CodeBleu_score": 58.932526092723755}]}
{"instance_id": "82ee329fd6e4", "generation_result": [{"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\t// Check if the system ID is valid\n\tif (sysid == 0) {\n\t\treturn;\n\t}\n\n\t// Check if the component ID is valid\n\tif (compid == 0) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_position_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_attitude_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra1_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra2_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra3_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra4_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra5_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra6_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra7_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra8_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra9_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra10_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra11_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra12_active) {\n\t\treturn;\n\t}\n\n\t// Check if the data stream is already active\n\tif (_datastream_extra13", "CodeBleu_score": 19.555166782838707}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\t// Send a data stream request for position data\n\tfor (uint8_t i = 0; i < MAX_CHANNELS; i++) {\n\t\tif (GCS_channels[i].available_payload_space() > 12) {\n\t\t\tGCS_channels[i].request_datastream(sysid, compid, MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED, 100);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.07245202295253}, {"code": "void GCS_Tracker::request_datastream_position(const uint8_t sysid, const uint8_t compid)\t// iterate through all available GCS channels\n\tfor (uint8_t i = 0; i < NUM_GCS_CHANNELS; i++) {\n\t\t// check if there is available payload space\n\t\tif (gcs_channels[i].available_payload_space()) {\n\t\t\t// send request to start data stream\n\t\t\tgcs_channels[i].send_request_datastream_position(sysid, compid);\n\t\t\treturn;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.11733229923047}]}
{"instance_id": "3220d1062a93", "generation_result": [{"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\tif (pitch!= 0.0f) {\n\t\tef_pitch = pitch;\n\t\tef_yaw = yaw;\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 24.100164362264536}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\tif (pitch_cosine == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = pitch - pitch_cosine * yaw;\n\tef_yaw = yaw;\n\treturn true;\n}\n", "CodeBleu_score": 30.936715680165207}, {"code": "bool Mode::convert_bf_to_ef(float pitch, float yaw, float& ef_pitch, float& ef_yaw)\tif (pitch == 0) {\n\t\treturn false;\n\t}\n\tef_pitch = pitch;\n\tef_yaw = yaw;\n\treturn true;\n}\n", "CodeBleu_score": 24.80080002359803}]}
{"instance_id": "a71eaa3dc4f4", "generation_result": [{"code": "void Mode::update_auto(void)\t// Update the target yaw and pitch\n\tfloat target_yaw = 0;\n\tfloat target_pitch = 0;\n\tfloat target_distance = 0;\n\n\t// Check if the target is valid\n\tif (navigation_status.target_valid) {\n\t\t// Get the target yaw and pitch\n\t\ttarget_yaw = navigation_status.target_yaw;\n\t\ttarget_pitch = navigation_status.target_pitch;\n\n\t\t// Check if the target distance is valid\n\t\tif (navigation_status.target_distance_valid || navigation_status.minimum_distance == 0) {\n\t\t\t// Get the target distance\n\t\t\ttarget_distance = navigation_status.target_distance;\n\n\t\t\t// Check if the target distance is greater than the minimum distance\n\t\t\tif (target_distance > navigation_status.minimum_distance) {\n\t\t\t\t// Check if the target is in the reverse direction\n\t\t\t\tif (navigation_status.target_direction_reversed) {\n\t\t\t\t\t// Reverse the target yaw and pitch\n\t\t\t\t\ttarget_yaw = -target_yaw;\n\t\t\t\t\ttarget_pitch = -target_pitch;\n\t\t\t\t}\n\n\t\t\t\t// Convert the yaw and pitch from centidegrees to degrees\n\t\t\t\ttarget_yaw = target_yaw / 100;\n\t\t\t\ttarget_pitch = target_pitch / 100;\n\n\t\t\t\t// Calculate the yaw and pitch errors\n\t\t\t\tfloat yaw_error = target_yaw - navigation_status.yaw;\n\t\t\t\tfloat pitch_error = target_pitch - navigation_status.pitch;\n\n\t\t\t\t// Convert the errors from earth frame to body frame\n\t\t\t\tfloat yaw_error_body = yaw_error * cos(navigation_status.pitch * PI / 180) + pitch_error * sin(navigation_status.pitch * PI / 180) * sin(navigation_status.yaw * PI / 180);\n\t\t\t\tfloat pitch_error_body = pitch_error * cos(navigation_status.pitch * PI / 180) - yaw_error * sin(navigation_status.pitch * PI / 180) * sin(navigation_status.yaw * PI / 180);\n\n\t\t\t\t// Update the pitch and yaw servos\n\t\t\t\tpitch_servo.set_angle(pitch_error_body);\n\t\t\t\tyaw_servo.set_angle(yaw_error", "CodeBleu_score": 37.45944737146779}, {"code": "void Mode::update_auto(void)\tfloat target_yaw = 0.0f;\n\tfloat target_pitch = 0.0f;\n\tfloat yaw_error = 0.0f;\n\tfloat pitch_error = 0.0f;\n\tfloat target_distance = 0.0f;\n\tfloat target_bearing = 0.0f;\n\tfloat target_elevation = 0.0f;\n\n\t// Calculate the target yaw and pitch in centidegrees\n\ttarget_yaw = (float) (navigation.get_bearing() - 90.0f);\n\ttarget_pitch = (float) (navigation.get_elevation() - 90.0f);\n\n\t// Check if the direction is reversed\n\tif (navigation.get_direction_reversed() == true) {\n\t\ttarget_yaw = -target_yaw;\n\t\ttarget_pitch = -target_pitch;\n\t}\n\n\t// Convert the errors from earth frame to body frame\n\tyaw_error = (float) (target_yaw - tracker.get_yaw());\n\tpitch_error = (float) (target_pitch - tracker.get_pitch());\n\n\t// Convert the errors from centidegrees to degrees\n\tyaw_error = (float) (yaw_error / 10.0f);\n\tpitch_error = (float) (pitch_error / 10.0f);\n\n\t// If the target distance is valid or no minimum distance is set, update the pitch and yaw servos accordingly\n\tif (navigation.get_distance() > 0.0f || navigation.get_min_distance() == 0.0f) {\n\t\t// Update the pitch servo\n\t\tif (abs(pitch_error) > 5.0f) {\n\t\t\tif (pitch_error < 0.0f) {\n\t\t\t\ttracker.set_pitch_servo_position(tracker.get_pitch_servo_position() - 1);\n\t\t\t} else {\n\t\t\t\ttracker.set_pitch_servo_position(tracker.get_pitch_servo_position() + 1);\n\t\t\t}\n\t\t}\n\n\t\t// Update the yaw servo\n\t\tif (abs(yaw_error) > 5.0f) {\n\t\t\tif (yaw_error < 0.0f) {\n\t\t\t\ttracker", "CodeBleu_score": 35.4366629302452}, {"code": "void Mode::update_auto(void)\t// Check if we are in auto mode\n\tif (status.mode!= Mode::AUTO) {\n\t\treturn;\n\t}\n\n\t// Check if we are in navigation mode\n\tif (status.nav_status == NAV_STATUS_LOITER) {\n\t\t// Check if we are in loiter mode\n\t\tif (status.loiter_mode == 0) {\n\t\t\t// Check if we have a valid target distance\n\t\t\tif (status.target_distance > 0) {\n\t\t\t\t// Check if we are in reverse mode\n\t\t\t\tif (status.reverse_mode == 1) {\n\t\t\t\t\t// Check if we are in reverse mode\n\t\t\t\t\tif (status.reverse_mode == 1) {\n\t\t\t\t\t\t// Check if we are in reverse mode\n\t\t\t\t\t\tif (status.reverse_mode == 1) {\n\t\t\t\t\t\t\t// Calculate the yaw and pitch\n\t\t\t\t\t\t\tstatus.target_yaw = status.target_yaw_reverse;\n\t\t\t\t\t\t\tstatus.target_pitch = status.target_pitch_reverse;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Calculate the yaw and pitch\n\t\t\t\t\t\t\tstatus.target_yaw = status.target_yaw_forward;\n\t\t\t\t\t\t\tstatus.target_pitch = status.target_pitch_forward;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Calculate the yaw and pitch\n\t\t\t\t\t\tstatus.target_yaw = status.target_yaw_forward;\n\t\t\t\t\t\tstatus.target_pitch = status.target_pitch_forward;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Calculate the yaw and pitch\n\t\t\t\t\tstatus.target_yaw = status.target_yaw_forward;\n\t\t\t\t\tstatus.target_pitch = status.target_pitch_forward;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Set the target yaw to 0\n\t\t\t\tstatus.target_yaw = 0;\n\t\t\t\t// Set the target pitch to 0\n\t\t\t\tstatus.target_pitch = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t// Set the target yaw to 0\n\t\t\tstatus.target_yaw = 0;\n\t\t\t// Set the target pitch to 0\n\t\t\tstatus.target_pitch = 0;\n\t\t}\n\t} else {\n\t\t// Set the target yaw to 0\n\t\tstatus.target_yaw = 0;\n\t\t// Set the target pitch to 0\n\t\tstatus.target_pitch = 0;\n", "CodeBleu_score": 16.496779418655052}]}
{"instance_id": "4bab01816a64", "generation_result": [{"code": "void Tracker::update_GPS(void)\tif (gps_data.status == 0) {\n\t\treturn;\n\t}\n\n\tif (gps_data.last_message_time!= last_gps_message_time) {\n\t\tlast_gps_message_time = gps_data.last_message_time;\n\n\t\tif (gps_data.status >= 3) {\n\t\t\tif (ground_start_countdown > 0) {\n\t\t\t\tground_start_countdown--;\n\t\t\t}\n\n\t\t\tif (ground_start_countdown == 0) {\n\t\t\t\tif (gps_data.location_valid) {\n\t\t\t\t\thome_location = gps_data.location;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tground_start_countdown = 5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tground_start_countdown = 5;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.20411799125266}, {"code": "void Tracker::update_GPS(void)\t// Update the GPS\n\tgps.update();\n\n\t// Check if the GPS has a new message\n\tif (gps.newNMEA()) {\n\t\t// Check if the GPS is at least 3D fix\n\t\tif (gps.fix() >= 3) {\n\t\t\t// Check if the GPS has a new message time\n\t\t\tif (gps.time.second()!= last_gps_time) {\n\t\t\t\t// Update the last GPS message time\n\t\t\t\tlast_gps_time = gps.time.second();\n\n\t\t\t\t// Check if the GPS has a new location\n\t\t\t\tif (gps.location.isValid()) {\n\t\t\t\t\t// Check if the GPS has a new location time\n\t\t\t\t\tif (gps.location.age() > 1000) {\n\t\t\t\t\t\t// Update the last GPS location time\n\t\t\t\t\t\tlast_gps_location_time = gps.location.age();\n\n\t\t\t\t\t\t// Check if the GPS has a new altitude\n\t\t\t\t\t\tif (gps.altitude.isValid()) {\n\t\t\t\t\t\t\t// Update the last GPS altitude time\n\t\t\t\t\t\t\tlast_gps_altitude_time = gps.altitude.age();\n\n\t\t\t\t\t\t\t// Check if the GPS has a new course\n\t\t\t\t\t\t\tif (gps.course.isValid()) {\n\t\t\t\t\t\t\t\t// Update the last GPS course time\n\t\t\t\t\t\t\t\tlast_gps_course_time = gps.course.age();\n\n\t\t\t\t\t\t\t\t// Check if the GPS has a new speed\n\t\t\t\t\t\t\t\tif (gps.speed.isValid()) {\n\t\t\t\t\t\t\t\t\t// Update the last GPS speed time\n\t\t\t\t\t\t\t\t\tlast_gps_speed_time = gps.speed.age();\n\n\t\t\t\t\t\t\t\t\t// Check if the home location has been set\n\t\t\t\t\t\t\t\t\tif (home_set) {\n\t\t\t\t\t\t\t\t\t\t// Check if the home location has been updated\n\t\t\t\t\t\t\t\t\t\tif (home_location_updated) {\n\t\t\t\t\t\t\t\t\t\t\t// Check if the home location is valid\n\t\t\t\t\t\t\t\t\t\t\tif (home_location.isValid()) {\n\t\t\t\t\t\t\t\t\t\t\t\t// Check if the home location is within 10 meters of the current location\n\t\t\t\t\t\t\t\t\t\t\t\tif (home_location.distanceBetween(gps.location) < 10) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the home location has been updated\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (home_location_updated) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the home location has been updated\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (home_location_updated) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the home location has been updated\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (home_location_updated) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if the home location has been", "CodeBleu_score": 32.61812599585971}, {"code": "void Tracker::update_GPS(void)\t// Update the GPS\n\tgps.update();\n\n\t// Check if the GPS status is at least 3D fix\n\tif (gps.status() < 3) {\n\t\t// Reset the countdown\n\t\tground_start_countdown = 0;\n\t}\n\n\t// Check if the last message time has changed\n\tif (millis() - last_message_time > 2000) {\n\t\t// Reset the countdown\n\t\tground_start_countdown = 0;\n\t}\n\n\t// Check if the countdown has reached one\n\tif (ground_start_countdown == 1) {\n\t\t// Check if the current location is valid\n\t\tif (gps.location.isValid()) {\n\t\t\t// Set the home location\n\t\t\thome_location = gps.location;\n\t\t}\n\n\t\t// Reset the countdown\n\t\tground_start_countdown = 0;\n\t}\n\n\t// Increment the countdown\n\tground_start_countdown++;\n}\n", "CodeBleu_score": 29.446975668564296}]}
{"instance_id": "8af34a0b0216", "generation_result": [{"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch > 100) {\n\t\tpitch = 100;\n\t}\n\tif (pitch < -100) {\n\t\tpitch = -100;\n\t}\n\tif (pitch > 0) {\n\t\tpitch = 100 - pitch;\n\t}\n\tif (pitch < 0) {\n\t\tpitch = -pitch;\n\t}\n\tif (pitch > 100) {\n\t\tpitch = 100;\n\t}\n\tpitch = pitch / 100;\n\tpitch = pitch * 180;\n\tpitch = 180 - pitch;\n\tpitch = pitch / 180;\n\tpitch = pitch * 255;\n\tpitch = 255 - pitch;\n\tpitch = pitch / 255;\n\tpitch = pitch * 1024;\n\tpitch = 1024 - pitch;\n\tpitch = pitch / 1024;\n\tpitch = pitch * 2000;\n\tpitch = 2000 - pitch;\n\tpitch = pitch / 2000;\n\tpitch = pitch * 180;\n\tpitch = 180 - pitch;\n\tpitch = pitch / 180;\n\tpitch = pitch * 255;\n\tpitch = 255 - pitch;\n\tpitch = pitch / 255;\n\tpitch = pitch * 1024;\n\tpitch = 1024 - pitch;\n\tpitch = pitch / 1024;\n\tpitch = pitch * 2000;\n\tpitch = 2000 - pitch;\n\tpitch = pitch / 2000;\n\tpitch = pitch * 180;\n\tpitch = 180 - pitch;\n\tpitch = pitch / 180;\n\tpitch = pitch * 255;\n\tpitch = 255 - pitch;\n\tpitch = pitch / 255;\n\tpitch = pitch * 1024;\n\tpitch = 1024 - pitch;\n\tpitch = pitch / 1024;\n\tpitch = pitch * 2", "CodeBleu_score": 12.322898182758355}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tpitch_onoff_servo.write(pitch);\n}\n", "CodeBleu_score": 9.56236606000126}, {"code": "void Tracker::update_pitch_onoff_servo(float pitch) const\tif (pitch > 0) {\n\t\tpitch_onoff_servo.write(1);\n\t} else {\n\t\tpitch_onoff_servo.write(0);\n\t}\n}\n", "CodeBleu_score": 13.207111294909579}]}
{"instance_id": "6b7fe72cd11e", "generation_result": [{"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\t// Call the base class's barometer_checks function\n\tif (!AP_Arming::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// Check the barometer reference\n\tif (AP_InertialSensor::get_baro_reference() == 0) {\n\t\tif (display_failure) {\n\t\t\t// Log the failure\n\t\t\t_failure_reason = ARMING_CHECK_BARO_REF;\n\n\t\t\t// Log the failure\n\t\t\t_failure_count++;\n\t\t}\n\n\t\t// Return false\n\t\treturn false;\n\t}\n\n\t// Check the barometer altitude\n\tif (AP_InertialSensor::get_baro_alt() - AP_InertialSensor::get_nav_alt() > _baro_disparity_limit) {\n\t\tif (display_failure) {\n\t\t\t// Log the failure\n\t\t\t_failure_reason = ARMING_CHECK_BARO;\n\n\t\t\t// Log the failure\n\t\t\t_failure_count++;\n\t\t}\n\n\t\t// Return false\n\t\treturn false;\n\t}\n\n\t// Return true\n\treturn true;\n}\n", "CodeBleu_score": 34.0847794067309}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\t// Call the base class's barometer checks function\n\tbool ret = AP_Arming::barometer_checks(display_failure);\n\n\t// If ARMING_CHECK_BARO is enabled, check the barometer reference and compare the barometer altitude with the inertial navigation altitude\n\tif (_params.ARMING_CHECK_BARO) {\n\t\t// Get the barometer reference altitude\n\t\tfloat baro_ref = _barometer.get_reference_alt();\n\n\t\t// Get the inertial navigation altitude\n\t\tfloat inertial_nav_alt = _inertial_nav.get_altitude();\n\n\t\t// If the disparity exceeds a predefined limit, log a failure and return false\n\t\tif (fabsf(baro_ref - inertial_nav_alt) > _params.ARMING_CHECK_BARO_DISPARITY_LIMIT) {\n\t\t\t// Log the failure\n\t\t\tif (display_failure) {\n\t\t\t\t// Log the failure\n\t\t\t\t_failure_detector.log_failure(AP_Arming_Copter::ARMING_CHECK_BARO_DISPARITY_LIMIT_FAILURE);\n\t\t\t}\n\n\t\t\t// Return false\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Return true\n\treturn ret;\n}\n", "CodeBleu_score": 41.32801971206083}, {"code": "bool AP_Arming_Copter::barometer_checks(bool display_failure)\tif (!AP_Arming_MultiCopter::barometer_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\tif (_params.ARMING_CHECK_BARO && _params.ARMING_BARO_DISPARITY_CM > 0) {\n\t\tif (abs(baro_ref_alt - _inav_alt) > _params.ARMING_BARO_DISPARITY_CM) {\n\t\t\tif (display_failure) {\n\t\t\t\t_failure_reason = \"baro_disparity\";\n\t\t\t\t_failure_sub_reason = \"baro_disparity\";\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 29.70532891493137}]}
{"instance_id": "d57f2afc4550", "generation_result": [{"code": "bool AP_Arming_Copter::terrain_database_required() const\t// If the terrain source is from a rangefinder, it returns false\n\tif (_params.terrain_source == Terrain_Source_Rangefinder) {\n\t\treturn false;\n\t}\n\n\t// If the terrain source is from the terrain database and the RTL altitude type is terrain, it returns true\n\tif (_params.terrain_source == Terrain_Source_Terrain_Database && _params.rtl_altitude_type == RTL_Altitude_Terrain) {\n\t\treturn true;\n\t}\n\n\t// Otherwise, it defers to the base class implementation of terrain_database_required\n\treturn AP_Arming_Copter::terrain_database_required();\n}\n", "CodeBleu_score": 58.25596712879613}, {"code": "bool AP_Arming_Copter::terrain_database_required() const\treturn AP_Arming::terrain_database_required() || _params.terrain_source == TerrainSource::RangeFinder;\n}\n", "CodeBleu_score": 21.177784575418375}, {"code": "bool AP_Arming_Copter::terrain_database_required() const\tif (_params.terrain_source == AP_Param::Param_Terrain_Source::SOURCE_RANGEFINDER) {\n\t\treturn false;\n\t}\n\n\tif (_params.terrain_source == AP_Param::Param_Terrain_Source::SOURCE_TERRAIN_DB && _params.rtl_altitude_type == AP_Param::Param_Rtl_Altitude_Type::ALT_TERRAIN) {\n\t\treturn true;\n\t}\n\n\treturn AP_Arming::terrain_database_required();\n}\n", "CodeBleu_score": 62.63769229315721}]}
{"instance_id": "9a0065e79a57", "generation_result": [{"code": "void Copter::run_rate_controller()\t// Set the loop time for the rate controller.\n\trate_controller.set_loop_time(last_loop_time);\n\n\t// Run the rate controller.\n\trate_controller.run();\n}\n", "CodeBleu_score": 29.59332408293654}, {"code": "void Copter::run_rate_controller()\t// set the loop time\n\t_loop_time = _scheduler->get_last_loop_time();\n\n\t// run the rate controller\n\t_attitude_control.run_rate_controller(_loop_time);\n}\n", "CodeBleu_score": 40.514303218902434}, {"code": "void Copter::run_rate_controller()\t// get last loop time\n\tuint64_t now = hrt_absolute_time();\n\tfloat dt = (now - _last_loop_time) * 1e-6f;\n\t_last_loop_time = now;\n\n\t// run rate controller\n\trate_controller_run(dt);\n}\n", "CodeBleu_score": 34.753649102261605}]}
{"instance_id": "9fe9459ec4d1", "generation_result": [{"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.get_frame()!= new_loc.get_frame()) {\n\t\treturn false;\n\t}\n\n\tif (old_loc.get_waypoint() == new_loc.get_waypoint()) {\n\t\treturn false;\n\t}\n\n\ttarget_loc = new_loc;\n\treturn true;\n}\n", "CodeBleu_score": 45.42728785586889}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\t// Check if the new location is the same as the old location\n\tif (new_loc == old_loc) {\n\t\treturn false;\n\t}\n\n\t// Check if the altitude frames are the same\n\tif (new_loc.get_altitude_frame()!= old_loc.get_altitude_frame()) {\n\t\treturn false;\n\t}\n\n\t// Set the new location as the target\n\ttarget_location = new_loc;\n\n\treturn true;\n}\n", "CodeBleu_score": 49.25778863597839}, {"code": "bool Copter::update_target_location(const Location &old_loc, const Location &new_loc)\tif (old_loc.get_lat() == new_loc.get_lat() && old_loc.get_lon() == new_loc.get_lon() && old_loc.get_alt() == new_loc.get_alt()) {\n\t\treturn false;\n\t}\n\telse {\n\t\ttarget_location = new_loc;\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 46.253342730165734}]}
{"instance_id": "e4f49f57ad52", "generation_result": [{"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (get_mode()!= mode) {\n\t\t\tset_mode(mode);\n\t\t}\n\n\t} else {\n\t\tif (get_mode() == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 53.25394418992266}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (get_mode()!= mode) {\n\t\t\tif (set_mode(mode)) {\n\t\t\t\trc().reset_mode_switch();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (get_mode() == mode) {\n\t\t\trc().reset_mode_switch();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 54.88752215547436}, {"code": "void RC_Channel_Copter::do_aux_function_change_mode(const Mode::Number mode,\n                                                    const AuxSwitchPos ch_flag)\tif (ch_flag == AuxSwitchPos::HIGH) {\n\t\tif (get_mode()!= mode) {\n\t\t\t// if the switch is in the HIGH position, it attempts to set the mode using the copter's set_mode method\n\t\t\tset_mode(mode);\n\t\t}\n\t} else {\n\t\t// if the switch is not in the HIGH position and the current flight mode matches the given mode, it resets the mode switch using rc().reset_mode_switch\n\t\tif (get_mode() == mode) {\n\t\t\treset_mode_switch();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.16065554381132}]}
{"instance_id": "b8fd7e165620", "generation_result": [{"code": "void Copter::save_trim()\t//Calculate trim values from control inputs\n\tfloat roll_trim = (float) (roll_control_input - 1500) / 1000;\n\tfloat pitch_trim = (float) (pitch_control_input - 1500) / 1000;\n\n\t//Convert trim values to radians\n\troll_trim = roll_trim * M_PI / 2;\n\tpitch_trim = pitch_trim * M_PI / 2;\n\n\t//Add trim values to AHRS trim\n\tahrs.trim.x() += roll_trim;\n\tahrs.trim.y() += pitch_trim;\n\n\t//Log event\n\tmavlink_log_event(MAV_SEVERITY_INFO, EVENT_TRIM_SAVE, 0, 0, 0, 0, 0, 0, 0);\n}\n", "CodeBleu_score": 44.296844799885335}, {"code": "void Copter::save_trim()\tfloat roll_trim = (float) (roll_trim_ch - 1500) / 500.0f;\n\tfloat pitch_trim = (float) (pitch_trim_ch - 1500) / 500.0f;\n\t// convert to radians\n\troll_trim = roll_trim * M_PI_F / 2.0f;\n\tpitch_trim = pitch_trim * M_PI_F / 2.0f;\n\t// add to the AHRS trim\n\tahrs.add_trim(roll_trim, pitch_trim);\n\t// log the event\n\tlog_event(MAV_SEVERITY_INFO, \"Trim saved\");\n\t// send a confirmation message\n\tmavlink_message_t msg;\n\tmavlink_msg_command_ack_pack(1, 1, &msg, 1, MAV_RESULT_ACCEPTED, 1, 0, 0, 0, 0, 0);\n\tsend_message(msg);\n}\n", "CodeBleu_score": 47.409594277791975}, {"code": "void Copter::save_trim()\t// Calculate the trim values from the control inputs of the roll and pitch channels.\n\tfloat roll_trim = (float) (roll_trim_channel - 1500) / 500.0f * M_PI_F;\n\tfloat pitch_trim = (float) (pitch_trim_channel - 1500) / 500.0f * M_PI_F;\n\n\t// Add the trim values to the AHRS trim.\n\tahrs_roll_trim += roll_trim;\n\tahrs_pitch_trim += pitch_trim;\n\n\t// Log the event.\n\tmavlink_log_event(MAV_SEVERITY_INFO, MAV_LOG_ID_SYSTEM, \"Trimmed roll to %.2f\", roll_trim);\n\tmavlink_log_event(MAV_SEVERITY_INFO, MAV_LOG_ID_SYSTEM, \"Trimmed pitch to %.2f\", pitch_trim);\n\n\t// Send a confirmation message with MAV_SEVERITY_INFO.\n\tmavlink_message_t message;\n\tmavlink_msg_command_ack_pack(system_id, component_id, &message, MAV_COMP_ID_ALL, MAV_CMD_DO_SET_SERVO, MAV_RESULT_ACCEPTED, 0, 0, 0, 0, 0, 0);\n\tmavlink_send_message(&message);\n}\n", "CodeBleu_score": 39.11605345184192}]}
{"instance_id": "8cdc9cd2135b", "generation_result": [{"code": "float Mode::AutoYaw::look_ahead_yaw()\t// Get the current velocity\n\tVector3f velocity = _copter.get_velocity();\n\n\t// Calculate the speed squared\n\tfloat speed_squared = velocity.length_squared();\n\n\t// If the copter's position is valid and the speed exceeds a minimum threshold, update the look-ahead yaw angle\n\tif (_copter.get_position_valid() && speed_squared > _minimum_speed_squared) {\n\t\t// Calculate the look-ahead yaw angle\n\t\t_look_ahead_yaw = atan2f(velocity.x, velocity.y);\n\t}\n\n\t// Return the look-ahead yaw angle\n\treturn _look_ahead_yaw;\n}\n", "CodeBleu_score": 47.75530669912654}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\tfloat yaw = 0.0f;\n\tif (copter.position_valid() && copter.velocity_valid() && copter.velocity_squared() >= _min_speed_squared) {\n\t\tyaw = atan2f(copter.velocity_y(), copter.velocity_x());\n\t}\n\treturn yaw;\n}\n", "CodeBleu_score": 26.111419798731806}, {"code": "float Mode::AutoYaw::look_ahead_yaw()\tfloat look_ahead_yaw = 0.0f;\n\tif (vehicle_position_valid() && velocity_valid()) {\n\t\tfloat speed_squared = velocity_x * velocity_x + velocity_y * velocity_y;\n\t\tif (speed_squared > 0.000001f) {\n\t\t\tlook_ahead_yaw = atan2f(velocity_y, velocity_x);\n\t\t}\n\t}\n\treturn look_ahead_yaw;\n}\n", "CodeBleu_score": 35.72898912685782}]}
{"instance_id": "b6aa851ecabd", "generation_result": [{"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (_armed_flags.is_armed_check_disabled) {\n\t\treturn true;\n\t}\n\n\tif (_armed_flags.is_watchdog_armed) {\n\t\treturn true;\n\t}\n\n\tif (method == AP_Arming::RUDDER) {\n\t\tif (_armed_flags.is_rudder_arming_disabled) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (_armed_flags.is_throttle_zero) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming_Multirotor::arm_checks(method);\n}\n", "CodeBleu_score": 45.8650791452325}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (method == AP_Arming::RUDDER) {\n\t\tif (_rudder_arming_disabled || _throttle_non_zero) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn AP_Arming_Multirotor::arm_checks(method);\n}\n", "CodeBleu_score": 27.55502310618264}, {"code": "bool AP_Arming_Plane::arm_checks(AP_Arming::Method method)\tif (method == AP_Arming::RUDDER) {\n\t\tif (!_rudder_arming_enabled || _throttle_setpoint!= 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn AP_Arming_Multicopter::arm_checks(method);\n}\n", "CodeBleu_score": 28.329340580512273}]}
{"instance_id": "5a4cace96cc9", "generation_result": [{"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\tif (!do_arming_checks) {\n\t\t// arm immediately\n\t\tif (arm_immediate(method)) {\n\t\t\t// update home location\n\t\t\t_ahrs.set_home_location(_current_loc);\n\t\t\t// update current location\n\t\t\t_current_loc = _ahrs.get_position();\n\t\t\t// change arm state\n\t\t\t_arm_state = ARMED;\n\t\t\t// set delay arming flag\n\t\t\t_delay_arming = false;\n\t\t\t// send status text\n\t\t\t_status_text_sysid = AP_System::SYSTEM_ID_INVALID;\n\t\t\t_status_text_id = AP_MSG_ARMED;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// arming checks are required\n\tif (method == AP_Arming::METHOD_NONE) {\n\t\t// arm immediately\n\t\tif (arm_immediate(method)) {\n\t\t\t// update home location\n\t\t\t_ahrs.set_home_location(_current_loc);\n\t\t\t// update current location\n\t\t\t_current_loc = _ahrs.get_position();\n\t\t\t// change arm state\n\t\t\t_arm_state = ARMED;\n\t\t\t// set delay arming flag\n\t\t\t_delay_arming = false;\n\t\t\t// send status text\n\t\t\t_status_text_sysid = AP_System::SYSTEM_ID_INVALID;\n\t\t\t_status_text_id = AP_MSG_ARMED;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// check if we are already armed\n\tif (_arm_state == ARMED) {\n\t\treturn true;\n\t}\n\n\t// check if we are already disarmed\n\tif (_arm_state == DISARMED) {\n\t\treturn false;\n\t}\n\n\t// check if we are already disarmed\n\tif (_arm_state == DISARMED_THROTTLE) {\n\t\treturn false;\n\t}\n\n\t// check if we are already arming\n\tif (_arm_state == ARMING) {\n\t\treturn false;\n\t}\n\n\t// check if we are already delay arming\n\tif (_arm_state == DELAY_ARMING) {\n\t\treturn false;\n\t}\n\n\t", "CodeBleu_score": 47.516308237587914}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\t// If the plane is already armed, return true\n\tif (is_armed()) {\n\t\treturn true;\n\t}\n\n\t// If the plane is already arming, return false\n\tif (is_arming()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already disarmed, return false\n\tif (is_disarmed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already arming, return false\n\tif (is_disarming()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already arming, return false\n\tif (is_arming_delayed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already disarming, return false\n\tif (is_disarming_delayed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already arming, return false\n\tif (is_arming_failed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already disarming, return false\n\tif (is_disarming_failed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already arming, return false\n\tif (is_arming_in_progress()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already disarming, return false\n\tif (is_disarming_in_progress()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already arming, return false\n\tif (is_arming_failed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already disarming, return false\n\tif (is_disarming_failed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already arming, return false\n\tif (is_arming_delayed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already disarming, return false\n\tif (is_disarming_delayed()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is already arming, return false\n\tif (is_arming_in_progress()) {\n\t\treturn false;\n\t}\n\n\t// If the plane is", "CodeBleu_score": 39.148028347304816}, {"code": "bool AP_Arming_Plane::arm(const AP_Arming::Method method, const bool do_arming_checks)\t// Check if we are already armed\n\tif (_armed) {\n\t\t// If we are already armed, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of arming\n\tif (_delay_arming) {\n\t\t// If we are already in the process of arming, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of disarming\n\tif (_delay_disarming) {\n\t\t// If we are already in the process of disarming, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of aborting\n\tif (_delay_aborting) {\n\t\t// If we are already in the process of aborting, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of landing\n\tif (_delay_landing) {\n\t\t// If we are already in the process of landing, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of taking off\n\tif (_delay_takeoff) {\n\t\t// If we are already in the process of taking off, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of returning\n\tif (_delay_return) {\n\t\t// If we are already in the process of returning, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of going into emergency\n\tif (_delay_emergency) {\n\t\t// If we are already in the process of going into emergency, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of going into guided mode\n\tif (_delay_guided) {\n\t\t// If we are already in the process of going into guided mode, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of going into guided mode\n\tif (_delay_rtl) {\n\t\t// If we are already in the process of going into guided mode, return false\n\t\treturn false;\n\t}\n\n\t// Check if we are already in the process of going into guided mode\n\tif (_delay_loiter) {\n\t\t// If", "CodeBleu_score": 17.194510000241845}]}
{"instance_id": "7a25ae8fa8a2", "generation_result": [{"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\tif (AP_Arming::pre_arm_checks(display_failure)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 24.83856288763858}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\tif (vehicle_status.is_armed()) {\n\t\treturn true;\n\t}\n\n\tif (vehicle_status.is_disarmed()) {\n\t\tif (display_failure) {\n\t\t\t// TODO: display failure message\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tif (disarm_button_configured()) {\n\t\treturn AP_Arming::pre_arm_checks(display_failure);\n\t}\n\n\tif (display_failure) {\n\t\t// TODO: display failure message\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 58.23807343753161}, {"code": "bool AP_Arming_Sub::pre_arm_checks(bool display_failure)\tif (disarm_button_configured) {\n\t\tif (AP_Arming::pre_arm_checks(display_failure)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} else {\n\t\tif (display_failure) {\n\t\t\t// Display failure message\n\t\t}\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 51.35619617057239}]}
{"instance_id": "29ab883ed0b2", "generation_result": [{"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 51.56154359553895}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\t// Rotate the coordinates to the North-East frame\n\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\n\t// Update the coordinates with the new values\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 51.62760432677133}, {"code": "void Sub::rotate_body_frame_to_NE(float &x, float &y)\tfloat ne_x = x * cos(yaw) + y * sin(yaw);\n\tfloat ne_y = -x * sin(yaw) + y * cos(yaw);\n\tx = ne_x;\n\ty = ne_y;\n}\n", "CodeBleu_score": 51.56154359553895}]}
{"instance_id": "cc11e8079f6d", "generation_result": [{"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t// TODO: Add command to adjust the yaw condition\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and param4 values\n\t// TODO: Add check for yaw angle and", "CodeBleu_score": 4.175164550495353}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\t//MAV_CMD_CONDITION_YAW\n\t//uint8_t target_system; //System ID\n\t//uint8_t target_component; //Component ID\n\t//float param1; //Yaw angle\n\t//float param2; //Yaw speed\n\t//float param3; //Yaw tolerance\n\t//float param4; //Yaw speed tolerance\n\t//uint16_t command; //The system to be controlled, as defined by MAV_SYS_ID. Only systems with a MAVLink protocol are allowed for this command.\n\t//uint8_t confirmation; //0: Do not acknowledge, 1: Acknowledge\n\t//uint8_t _padding0; //Unused\n\t//uint8_t _padding1; //Unused\n\t//uint8_t _padding2; //Unused\n\t//uint8_t _padding3; //Unused\n\n\t//Check if the yaw angle and param4 values are within acceptable ranges.\n\tif (param1 >= -180 && param1 <= 180 && param4 >= 0 && param4 <= 180) {\n\t\t//If valid, set the yaw heading using the provided parameters and return MAV_RESULT_ACCEPTED.\n\t\t_yaw_setpoint = param1;\n\t\t_yaw_speed = param2;\n\t\t_yaw_tolerance = param3;\n\t\t_yaw_speed_tolerance = param4;\n\t\treturn MAV_RESULT_ACCEPTED;\n\t}\n\n\t//If not valid, return MAV_RESULT_DENIED.\n\treturn MAV_RESULT_DENIED;\n}\n", "CodeBleu_score": 28.428393185990725}, {"code": "MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)\tfloat yaw_angle = packet.param1;\n\tfloat yaw_rate = packet.param2;\n\tfloat yaw_tolerance = packet.param3;\n\tfloat yaw_direction = packet.param4;\n\n\tif (yaw_angle < -180 || yaw_angle > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (yaw_rate < -180 || yaw_rate > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (yaw_tolerance < 0 || yaw_tolerance > 180) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\tif (yaw_direction < -1 || yaw_direction > 1) {\n\t\treturn MAV_RESULT_DENIED;\n\t}\n\n\t_yaw_angle = yaw_angle;\n\t_yaw_rate = yaw_rate;\n\t_yaw_tolerance = yaw_tolerance;\n\t_yaw_direction = yaw_direction;\n\n\treturn MAV_RESULT_ACCEPTED;\n}\n", "CodeBleu_score": 31.879510881389784}]}
{"instance_id": "ffe0f0f67d97", "generation_result": [{"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn (uint8_t) ((control_mode() == 0 || control_mode() == 1)? (uint16_t) (int16_t) (waypoint_bearing() / 2) : 0);\n}\n", "CodeBleu_score": 28.74285809946027}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn (uint8_t) ((this->control_mode == 1 || this->control_mode == 2)? this->wp_bearing / 2 : 0);\n}\n", "CodeBleu_score": 10.807869807531837}, {"code": "uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const\treturn mavlink_msg_high_latency_tgt_heading_get_tgt_heading(&msg);\n}\n", "CodeBleu_score": 6.570575691874492}]}
{"instance_id": "33e0b011f6a7", "generation_result": [{"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (logging) {\n\t\t// Create a log packet\n\t\tLogPacket packet;\n\t\tpacket.time = Get_Time();\n\t\tpacket.data_id = id;\n\t\tpacket.data = value;\n\n\t\t// Write the packet to the logger\n\t\tCritical_Block_Write(packet);\n\t}\n}\n", "CodeBleu_score": 33.58038047037806}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (Logging_Enabled) {\n\t\tLogPacket packet;\n\t\tpacket.time = Get_Time();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tCritical_Block(packet);\n\t}\n}\n", "CodeBleu_score": 36.53436850243562}, {"code": "void Sub::Log_Write_Data(LogDataID id, int32_t value)\tif (Logging_Enabled) {\n\t\tLogPacket packet;\n\t\tpacket.time = Get_Time();\n\t\tpacket.id = id;\n\t\tpacket.value = value;\n\t\tLog_Write_Packet(packet);\n\t}\n}\n", "CodeBleu_score": 36.206972242067934}]}
{"instance_id": "9d8f6294ccf1", "generation_result": [{"code": "void Sub::update_home_from_EKF()\t// check if home is already set\n\tif (_home_set) {\n\t\treturn;\n\t}\n\n\t// check if motors are armed\n\tif (_armed) {\n\t\t// set home to current location\n\t\t_home_set = true;\n\t\t_home_position = _ekf.get_position();\n\t\t_home_heading = _ekf.get_heading();\n\t} else {\n\t\t// set home to current EKF location\n\t\tif (_ekf.get_position_valid()) {\n\t\t\t_home_set = true;\n\t\t\t_home_position = _ekf.get_position();\n\t\t\t_home_heading = _ekf.get_heading();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 28.209508608822}, {"code": "void Sub::update_home_from_EKF()\tif (is_home_set()) {\n\t\treturn;\n\t}\n\n\tif (is_armed()) {\n\t\tset_home_position(get_position());\n\t} else {\n\t\tset_home_position(get_ekf_position());\n\t}\n}\n", "CodeBleu_score": 20.81570934874901}, {"code": "void Sub::update_home_from_EKF()\tif (_home_set) {\n\t\treturn;\n\t}\n\n\tif (is_armed()) {\n\t\t_home_set = true;\n\t\t_home_lat = _ekf.get_lat();\n\t\t_home_lon = _ekf.get_lon();\n\t\t_home_alt = _ekf.get_alt();\n\t} else {\n\t\t_home_set = _ekf.set_home();\n\t}\n}\n", "CodeBleu_score": 24.708226291711906}]}
{"instance_id": "3f01d797b484", "generation_result": [{"code": "void ModeAcro::run()\tif (!_armed) {\n\t\t_throttle = 0.0f;\n\t\t_spool_state = SpoolState::Unlimited;\n\t\t_relax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t_spool_state = SpoolState::UnlimitedThrottle;\n\n\t// Convert pilot inputs to desired body frame rates\n\t_body_rates.x = _pilot_rates.x;\n\t_body_rates.y = _pilot_rates.y;\n\t_body_rates.z = _pilot_rates.z;\n\n\t// Run attitude controller\n\t_attitude_controller->run(_body_rates);\n\n\t// Output pilot's throttle input without angle boost\n\t_throttle = _pilot_throttle;\n\n\t// Set motor inputs\n\t_set_motor_inputs();\n}\n", "CodeBleu_score": 29.94102807468569}, {"code": "void ModeAcro::run()\t// If the motors are not armed, set the throttle to zero, adjust the spool state, relax the attitude controllers, and exit.\n\tif (!motors_armed) {\n\t\tthrottle_spool_state = SpoolState::ZERO;\n\t\tthrottle_spool.relax();\n\t\tattitude_controller.relax();\n\t\treturn;\n\t}\n\n\t// If armed, set the spool state to unlimited throttle, convert pilot inputs to desired body frame rates, and run the attitude controller with these rates.\n\tthrottle_spool_state = SpoolState::UNLIMITED;\n\tthrottle_spool.run();\n\tattitude_controller.run(roll_rate_sp, pitch_rate_sp, yaw_rate_sp);\n\n\t// Output the pilot's throttle input without angle boost and set the forward and lateral motor inputs based on pilot controls.\n\tfloat throttle_input = pilot_inputs.throttle_input;\n\tfloat roll_input = pilot_inputs.roll_input;\n\tfloat pitch_input = pilot_inputs.pitch_input;\n\tfloat yaw_input = pilot_inputs.yaw_input;\n\tfloat roll_rate_input = roll_input * roll_rate_max;\n\tfloat pitch_rate_input = pitch_input * pitch_rate_max;\n\tfloat yaw_rate_input = yaw_input * yaw_rate_max;\n\tfloat throttle_output = throttle_spool.output(throttle_input);\n\tfloat roll_rate_output = attitude_controller.output(roll_rate_input);\n\tfloat pitch_rate_output = attitude_controller.output(pitch_rate_input);\n\tfloat yaw_rate_output = attitude_controller.output(yaw_rate_input);\n\tfloat forward_motor_input = throttle_output - roll_rate_output - pitch_rate_output - yaw_rate_output;\n\tfloat lateral_motor_input = roll_rate_output - pitch_rate_output;\n\tfloat vertical_motor_input = throttle_output - yaw_rate_output;\n\tfloat motor_input_norm = sqrt(forward_motor_input * forward_motor_input + lateral_motor_input * lateral_motor", "CodeBleu_score": 44.88169512771094}, {"code": "void ModeAcro::run()\tif (!_armed) {\n\t\t_throttle_sp = 0;\n\t\t_spool_state = SPOOL_STATE_UNLIMITED_THROTTLE;\n\t\trelax_attitude_controllers();\n\t\treturn;\n\t}\n\n\t_spool_state = SPOOL_STATE_UNLIMITED_THROTTLE;\n\n\t// Convert pilot inputs to desired body frame rates\n\tconst float pilot_throttle = _pilot_inputs.throttle;\n\tconst float pilot_roll = _pilot_inputs.roll;\n\tconst float pilot_pitch = _pilot_inputs.pitch;\n\tconst float pilot_yaw = _pilot_inputs.yaw;\n\n\t// Convert pilot inputs to desired body frame rates\n\tconst float throttle_sp = pilot_throttle * _throttle_scale;\n\tconst float roll_sp = pilot_roll * _roll_scale;\n\tconst float pitch_sp = pilot_pitch * _pitch_scale;\n\tconst float yaw_sp = pilot_yaw * _yaw_scale;\n\n\t// Run the attitude controller\n\tconst Vector3f body_rates_sp(roll_sp, pitch_sp, yaw_sp);\n\tconst Vector3f body_rates_fb = _attitude_controller.update(body_rates_sp);\n\t_motor_inputs.forward = body_rates_fb.x();\n\t_motor_inputs.lateral = body_rates_fb.y();\n\t_motor_inputs.vertical = body_rates_fb.z();\n\n\t// Set the throttle\n\t_throttle_sp = throttle_sp;\n}\n", "CodeBleu_score": 40.117107108339766}]}
{"instance_id": "b2f5c47e5e03", "generation_result": [{"code": "void ModeGuided::guided_pos_control_start()\t// Set the mode to position control mode\n\tmode = Mode::PositionControl;\n\n\t// Set the waypoint destination to the stopping point\n\twaypoint_controller.set_waypoint_destination(stopping_point);\n\n\t// Set the yaw to the default auto yaw mode\n\tyaw_controller.set_yaw_mode(YawMode::Auto);\n}\n", "CodeBleu_score": 14.400872684622668}, {"code": "void ModeGuided::guided_pos_control_start()\t// set to position control mode\n\tmode = Mode::position_control;\n\n\t// initialize waypoint controller\n\twaypoint_controller.initialize();\n\n\t// retrieve the stopping point\n\twaypoint_controller.get_stopping_point();\n\n\t// set the waypoint destination to the stopping point\n\twaypoint_controller.set_destination(waypoint_controller.get_stopping_point());\n\n\t// initialize yaw using the default auto yaw mode\n\tyaw_controller.initialize();\n}\n", "CodeBleu_score": 30.910154163123643}, {"code": "void ModeGuided::guided_pos_control_start()\t// Set mode to position control\n\tmode = Mode::PositionControl;\n\n\t// Set the waypoint destination to the stopping point\n\twaypoint_controller.set_destination(stopping_point);\n\n\t// Initialize yaw using default auto yaw mode\n\tyaw_controller.set_auto_yaw_mode(true);\n}\n", "CodeBleu_score": 13.988170932884097}]}
{"instance_id": "324de618ad6c", "generation_result": [{"code": "void ModeGuided::guided_vel_control_start()\t// Set the guided mode to velocity control\n\tguided_mode = GUIDED_MODE_VELOCITY;\n\n\t// Set the maximum vertical speeds and acceleration\n\tmax_vertical_speed = _params->max_vertical_speed;\n\tmax_vertical_accel = _params->max_vertical_accel;\n\n\t// Initialize the vertical velocity controller\n\t_v_controller.set_parameters(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);\n\t_v_controller.set_velocity_setpoint(0.0f);\n\t_v_controller.set_acceleration_setpoint(0.0f);\n\n\t// Initialize the horizontal velocity controller\n\t_h_controller.set_parameters(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);\n\t_h_controller.set_velocity_setpoint(0.0f);\n\t_h_controller.set_acceleration_setpoint(0.0f);\n\n\t// Set the yaw control mode to AUTO_YAW_HOLD\n\t_yaw_mode = AUTO_YAW_HOLD;\n}\n", "CodeBleu_score": 31.406547860205826}, {"code": "void ModeGuided::guided_vel_control_start()\t// Set guided mode to velocity controller\n\tguided_mode = GUIDED_MODE_VEL;\n\n\t// Initialize vertical maximum speeds and acceleration using pilot-defined parameters\n\tguided_max_vertical_speed = _params->guided_max_vertical_speed;\n\tguided_max_vertical_accel = _params->guided_max_vertical_accel;\n\n\t// Initialize the vertical and horizontal velocity controllers\n\t_v_control.set_params(_params->guided_vel_control_kp, _params->guided_vel_control_ki, _params->guided_vel_control_kd,\n\t\t\t   _params->guided_vel_control_min_output, _params->guided_vel_control_max_output,\n\t\t\t   _params->guided_vel_control_max_integral, _params->guided_vel_control_integral_rate,\n\t\t\t   _params->guided_vel_control_min_rate, _params->guided_vel_control_max_rate,\n\t\t\t   _params->guided_vel_control_rate_tolerance);\n\t_h_control.set_params(_params->guided_vel_control_kp, _params->guided_vel_control_ki, _params->guided_vel_control_kd,\n\t\t\t   _params->guided_vel_control_min_output, _params->guided_vel_control_max_output,\n\t\t\t   _params->guided_vel_control_max_integral, _params->guided_vel_control_integral_rate,\n\t\t\t   _params->guided_vel_control_min_rate, _params->guided_vel_control_max_rate,\n\t\t\t   _params->guided_vel_control_rate_tolerance);\n\n\t// Set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\t_yaw_control_mode = AUTO_YAW_HOLD;\n}\n", "CodeBleu_score": 32.34330175371611}, {"code": "void ModeGuided::guided_vel_control_start()\t// set guided mode to velocity controller\n\tguided_mode = GUIDED_VEL_CONTROL;\n\n\t// initialize vertical maximum speeds and acceleration\n\tv_max = pilot_v_max;\n\tv_min = pilot_v_min;\n\tv_accel = pilot_v_accel;\n\tv_decel = pilot_v_decel;\n\n\t// initialize the vertical and horizontal velocity controllers\n\tv_controller.set_parameters(v_max, v_min, v_accel, v_decel);\n\th_controller.set_parameters(h_max, h_min, h_accel, h_decel);\n\n\t// set yaw control mode to AUTO_YAW_HOLD, indicating that the pilot always controls yaw\n\tyaw_mode = AUTO_YAW_HOLD;\n}\n", "CodeBleu_score": 32.23226306300504}]}
{"instance_id": "3100e2efb0fe", "generation_result": [{"code": "bool ModeGuided::guided_limit_check()\t// Check if the timeout has been exceeded\n\tif (hrt_elapsed_time(&_guided_timeout) > _params->guided_timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is below the minimum threshold\n\tif (_vehicle_local_position.z_valid && _vehicle_local_position.z < _params->guided_min_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is above the maximum threshold\n\tif (_vehicle_local_position.z_valid && _vehicle_local_position.z > _params->guided_max_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the limit\n\tif (_vehicle_local_position.xy_valid && _vehicle_local_position.xy_global.dist(_guided_start_position.xy_global) > _params->guided_max_distance) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}\n", "CodeBleu_score": 37.33957075569912}, {"code": "bool ModeGuided::guided_limit_check()\t// Check if timeout has been exceeded.\n\tif (hrt_elapsed_time(&_last_position_time) > _params.guided_timeout) {\n\t\t// If so, return true.\n\t\treturn true;\n\t}\n\n\t// Check if current altitude is below a minimum or above a maximum threshold.\n\tif (_current_alt < _params.guided_min_alt || _current_alt > _params.guided_max_alt) {\n\t\t// If so, return true.\n\t\treturn true;\n\t}\n\n\t// Check if horizontal distance moved exceeds a specified limit.\n\tif (_distance_moved > _params.guided_max_dist) {\n\t\t// If so, return true.\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false.\n\treturn false;\n}\n", "CodeBleu_score": 28.154662191561812}, {"code": "bool ModeGuided::guided_limit_check()\t// Check if the timeout has been exceeded\n\tif (hrt_elapsed_time(&_last_guided_time) > _guided_timeout) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is below the minimum threshold\n\tif (_current_alt < _min_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if the current altitude is above the maximum threshold\n\tif (_current_alt > _max_altitude) {\n\t\treturn true;\n\t}\n\n\t// Check if the horizontal distance moved exceeds the limit\n\tif (_distance_moved > _max_distance) {\n\t\treturn true;\n\t}\n\n\t// If none of the above conditions are met, return false\n\treturn false;\n}\n", "CodeBleu_score": 17.98655836414791}]}
{"instance_id": "5b8f035aca37", "generation_result": [{"code": "bool Sub::verify_motor_test()\tif (motor_test_request_received_time == 0) {\n\t\tmotor_test_request_received_time = time_keeper->get_time();\n\t}\n\n\tif (time_keeper->get_time() - motor_test_request_received_time > 2000) {\n\t\tmotor_test_request_received_time = 0;\n\t\tmotor_test_timeout_message_sent = false;\n\t\tmotor_test_pass = false;\n\t\tmotor_test_disabled = true;\n\t\tdisarm_system();\n\t\trecord_failure_time();\n\t\treturn false;\n\t}\n\n\tif (motor_test_request_received_time!= 0 &&!motor_test_timeout_message_sent) {\n\t\tmotor_test_timeout_message_sent = true;\n\t\tsend_message(MOTOR_TEST_TIMEOUT);\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 44.41163554138624}, {"code": "bool Sub::verify_motor_test()\t//Check if motor test is enabled\n\tif (motor_test_enabled) {\n\t\t//Check if motor test has been enabled\n\t\tif (motor_test_enabled_time!= 0) {\n\t\t\t//Check if motor test requests have been received at least every 2 Hz\n\t\t\tif (motor_test_request_time - motor_test_enabled_time > 2) {\n\t\t\t\t//Send a timeout message\n\t\t\t\tsend_message(MSG_MOTOR_TEST_TIMEOUT, \"Motor test requests timed out.\");\n\t\t\t\t//Set the pass flag to false\n\t\t\t\tmotor_test_pass = false;\n\t\t\t\t//Disable the motor test\n\t\t\t\tmotor_test_enabled = false;\n\t\t\t\t//Disarm the system\n\t\t\t\tdisarm();\n\t\t\t\t//Record the failure time\n\t\t\t\tmotor_test_fail_time = motor_test_request_time;\n\t\t\t\t//Return false\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t//Return true\n\treturn true;\n}\n", "CodeBleu_score": 44.671295362059006}, {"code": "bool Sub::verify_motor_test()\tif (motor_test_request_received) {\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.reset();\n\t\treturn true;\n\t}\n\telse if (motor_test_request_timer.read() > 5.0) {\n\t\tmotor_test_request_timer.reset();\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\tmotor_test_request_timer.start();\n\t\tmotor_test_request_received = false;\n\t\t", "CodeBleu_score": 34.80069015076167}]}
{"instance_id": "b2afbbd2ff1f", "generation_result": [{"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\t// Get roll and pitch from wp_nav\n\tfloat roll = _wp_nav_roll;\n\tfloat pitch = _wp_nav_pitch;\n\n\t// Constrain roll and pitch within the maximum angle range\n\troll = constrain(roll, -_max_angle, _max_angle);\n\tpitch = constrain(pitch, -_max_angle, _max_angle);\n\n\t// Normalize roll and pitch\n\troll = roll / _max_angle;\n\tpitch = pitch / _max_angle;\n\n\t// Assign normalized roll and pitch to lateral_out and forward_out\n\tlateral_out = roll;\n\tforward_out = pitch;\n}\n", "CodeBleu_score": 30.334235375778327}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\tfloat roll_target_in_deg = _wpnav_roll_target_deg;\n\tfloat pitch_target_in_deg = _wpnav_pitch_target_deg;\n\n\t// constrain roll and pitch targets to within the specified maximum angle range\n\tif (roll_target_in_deg > _max_roll_deg) {\n\t\troll_target_in_deg = _max_roll_deg;\n\t} else if (roll_target_in_deg < -_max_roll_deg) {\n\t\troll_target_in_deg = -_max_roll_deg;\n\t}\n\n\tif (pitch_target_in_deg > _max_pitch_deg) {\n\t\tpitch_target_in_deg = _max_pitch_deg;\n\t} else if (pitch_target_in_deg < -_max_pitch_deg) {\n\t\tpitch_target_in_deg = -_max_pitch_deg;\n\t}\n\n\t// normalize roll and pitch targets to within the specified maximum angle range\n\tfloat roll_target_in_rad = roll_target_in_deg * M_DEG_TO_RAD_F;\n\tfloat pitch_target_in_rad = pitch_target_in_deg * M_DEG_TO_RAD_F;\n\n\tfloat roll_target_out_rad = roll_target_in_rad / _max_roll_rad;\n\tfloat pitch_target_out_rad = pitch_target_in_rad / _max_pitch_rad;\n\n\t// assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target_out_rad;\n\tforward_out = pitch_target_out_rad;\n}\n", "CodeBleu_score": 28.062320013913734}, {"code": "void Sub::translate_wpnav_rp(float &lateral_out, float &forward_out)\t// Get roll and pitch targets from wp_nav in centidegrees\n\tfloat roll_target_c = _wp_nav_roll_c;\n\tfloat pitch_target_c = _wp_nav_pitch_c;\n\n\t// Constrain roll and pitch targets within a specified maximum angle range\n\tfloat max_roll_c = _max_roll_c;\n\tfloat max_pitch_c = _max_pitch_c;\n\n\tif (roll_target_c > max_roll_c) {\n\t\troll_target_c = max_roll_c;\n\t} else if (roll_target_c < -max_roll_c) {\n\t\troll_target_c = -max_roll_c;\n\t}\n\n\tif (pitch_target_c > max_pitch_c) {\n\t\tpitch_target_c = max_pitch_c;\n\t} else if (pitch_target_c < -max_pitch_c) {\n\t\tpitch_target_c = -max_pitch_c;\n\t}\n\n\t// Normalize roll and pitch targets\n\tfloat roll_target_norm = roll_target_c / max_roll_c;\n\tfloat pitch_target_norm = pitch_target_c / max_pitch_c;\n\n\t// Assign normalized roll and pitch targets to lateral_out and forward_out\n\tlateral_out = roll_target_norm;\n\tforward_out = pitch_target_norm;\n}\n", "CodeBleu_score": 29.77855430316684}]}
{"instance_id": "8237462c02d4", "generation_result": [{"code": "void Sub::read_barometer()\t// Check if the barometer is healthy\n\tif (barometer_healthy) {\n\t\t// Check if the altitude is above zero\n\t\tif (barometer_altitude > 0) {\n\t\t\t// Update the barometer calibration\n\t\t\tbarometer_calibration = barometer_altitude;\n\t\t}\n\t}\n\t// Check if the depth sensor is present\n\tif (depth_sensor_present) {\n\t\t// Update the sensor health status based on the barometer's health\n\t\tsensor_health_status = barometer_healthy;\n\t}\n}\n", "CodeBleu_score": 32.9188740816377}, {"code": "void Sub::read_barometer()\t// If the altitude is above zero, update the barometer calibration\n\tif (barometer_data.altitude > 0) {\n\t\tbarometer_calibration.set_calibration(barometer_data.pressure, barometer_data.altitude);\n\t}\n\n\t// If a depth sensor is present, update the sensor health status based on the barometer's health\n\tif (depth_sensor_present) {\n\t\tif (barometer_data.pressure_health == 0) {\n\t\t\tdepth_sensor_health = 0;\n\t\t} else {\n\t\t\tdepth_sensor_health = 1;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.72622050247908}, {"code": "void Sub::read_barometer()\t// if the altitude is above zero, update the barometer calibration\n\tif (_barometer_alt > 0.0f) {\n\t\t_barometer_calibrated = true;\n\n\t\t// if the barometer calibration is not yet set, set it\n\t\tif (!_barometer_calibrated) {\n\t\t\t_barometer_calibrated = true;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t}\n\n\t\t// if the barometer calibration is not yet set, set it\n\t\tif (!_barometer_calibrated) {\n\t\t\t_barometer_calibrated = true;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t}\n\n\t\t// if the barometer calibration is not yet set, set it\n\t\tif (!_barometer_calibrated) {\n\t\t\t_barometer_calibrated = true;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t}\n\n\t\t// if the barometer calibration is not yet set, set it\n\t\tif (!_barometer_calibrated) {\n\t\t\t_barometer_calibrated = true;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t\t_barometer_cal_a = _barometer_cal_b = 0.0f;\n\t\t}\n\n\t\t// if the barometer calibration is not yet set,", "CodeBleu_score": 31.47597677542872}]}
{"instance_id": "fa05e0fdd752", "generation_result": [{"code": "bool Sub::ekf_position_ok()\tif (_inertial_nav_status!= INAV_STATUS_OK) {\n\t\treturn false;\n\t}\n\n\tif (_armed && _ekf_in_pos_mode) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 10.38714808797791}, {"code": "bool Sub::ekf_position_ok()\t// Check if inertial navigation is available\n\tif (!_inertial_nav_ok) {\n\t\treturn false;\n\t}\n\n\t// Check if the motors are disarmed\n\tif (_motors_armed) {\n\t\t// Check if the EKF is in constant position mode\n\t\tif (_ekf_pos_mode == ekf_pos_mode_t::EKF_POS_CONST_POS) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if the EKF has a good absolute position\n\t\tif (_ekf_pos_mode == ekf_pos_mode_t::EKF_POS_ABSOLUTE) {\n\t\t\tif (_ekf_pos_horiz_accuracy > 0.1f) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Position is good\n\treturn true;\n}\n", "CodeBleu_score": 26.58296562799478}, {"code": "bool Sub::ekf_position_ok()\tif (_control_status.flags.inertial_nav_fail) {\n\t\treturn false;\n\t}\n\n\tif (_control_status.flags.motors_armed) {\n\t\tif (_control_status.flags.ekf_hgt_mode) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (_control_status.flags.ekf_pos_mode) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 43.500409000209736}]}
{"instance_id": "86658e22ec4a", "generation_result": [{"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tbool gps_checks_result = AP_Arming_Common::gps_checks(display_failure);\n\n\tif (gps_checks_result) {\n\t\t// Check if AHRS system is ready\n\t\tif (!_ahrs->is_ready()) {\n\t\t\tif (display_failure) {\n\t\t\t\t_mavlink->send_statustext_all(MAV_SEVERITY_ERROR, \"AHRS system not ready\");\n\t\t\t}\n\t\t\tgps_checks_result = false;\n\t\t}\n\n\t\t// Check if EKF failsafe is active\n\t\tif (_ekf_failsafe) {\n\t\t\tif (display_failure) {\n\t\t\t\t_mavlink->send_statustext_all(MAV_SEVERITY_ERROR, \"EKF failsafe active\");\n\t\t\t}\n\t\t\tgps_checks_result = false;\n\t\t}\n\n\t\t// Check if position estimate is valid\n\t\tif (!_ahrs->is_position_valid()) {\n\t\t\tif (display_failure) {\n\t\t\t\t_mavlink->send_statustext_all(MAV_SEVERITY_ERROR, \"Position estimate not valid\");\n\t\t\t}\n\t\t\tgps_checks_result = false;\n\t\t}\n\t}\n\n\treturn gps_checks_result;\n}\n", "CodeBleu_score": 41.07950103369519}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\tbool gps_checks_passed = AP_Arming::gps_checks(display_failure);\n\tif (gps_checks_passed) {\n\t\tif (ahrs.get_ready() &&!ekf_failsafe) {\n\t\t\tif (gps->get_position_ok()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 18.70038269439002}, {"code": "bool AP_Arming_Rover::gps_checks(bool display_failure)\t// If the current control mode does not require position or velocity, return true\n\tif (!(_control_mode == Control_Mode::Position_Hold || _control_mode == Control_Mode::Velocity || _control_mode == Control_Mode::Acro)) {\n\t\treturn true;\n\t}\n\n\t// Call the parent class's GPS checks and return false if they fail\n\tif (!AP_Arming_Multicopter::gps_checks(display_failure)) {\n\t\treturn false;\n\t}\n\n\t// Check if the AHRS system is ready\n\tif (!_ahrs.is_ready()) {\n\t\tif (display_failure) {\n\t\t\tap_notify(\"AHRS system not ready\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check if the EKF failsafe is active\n\tif (_ekf_failsafe_active) {\n\t\tif (display_failure) {\n\t\t\tap_notify(\"EKF failsafe active\");\n\t\t}\n\t\treturn false;\n\t}\n\n\t// Check if the position estimate is valid\n\tif (!_ahrs.get_position_estimate_valid()) {\n\t\tif (display_failure) {\n\t\t\tap_notify(\"Position estimate invalid\");\n\t\t}\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 50.166221086185594}]}
{"instance_id": "ec68de91b0e9", "generation_result": [{"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\tif (method == AP_Arming::METHOD_SIMPLE_MODE) {\n\t\tif (do_arming_checks) {\n\t\t\tif (is_armed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// arm the rover\n\t\t_vehicle_status.arming_state = AP_VehicleStatus::ARMING_STATE_ARMED;\n\t\t_vehicle_status.arming_reason = AP_VehicleStatus::ARMING_REASON_SIMPLE_MODE;\n\n\t\t// set the home location\n\t\t_vehicle_status.home_location = _vehicle_location;\n\n\t\t// set the simple mode heading\n\t\t_vehicle_status.heading_simple_mode = _vehicle_status.heading_gps;\n\n\t\t// update the soft armed status\n\t\t_vehicle_status.soft_armed = true;\n\n\t\t// send an arm/disarm status text\n\t\t_vehicle_status.send_arm_status_text();\n\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 36.86191733802786}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\tbool armed = false;\n\n\t// Check if arming is already in progress\n\tif (armed_state!= AP_Arming::ARMED) {\n\t\t// Check if we are arming\n\t\tif (method == AP_Arming::ARMING) {\n\t\t\t// Check if we have been armed before\n\t\t\tif (armed_state == AP_Arming::ARMED_WITH_GPS) {\n\t\t\t\t// Check if we have a valid home location\n\t\t\t\tif (home_location.is_valid()) {\n\t\t\t\t\t// Check if we are already at the home location\n\t\t\t\t\tif (home_location.distance_to_current_loc() < 2.0f) {\n\t\t\t\t\t\t// We are at the home location\n\t\t\t\t\t\t// Check if we are already in simple mode\n\t\t\t\t\t\tif (simple_mode_heading == 0.0f) {\n\t\t\t\t\t\t\t// We are in simple mode\n\t\t\t\t\t\t\t// Check if we are already in simple mode heading\n\t\t\t\t\t\t\tif (simple_mode_heading == 0.0f) {\n\t\t\t\t\t\t\t\t// We are in simple mode heading\n\t\t\t\t\t\t\t\t// Check if we are already in soft armed\n\t\t\t\t\t\t\t\tif (soft_armed) {\n\t\t\t\t\t\t\t\t\t// We are in soft armed\n\t\t\t\t\t\t\t\t\t// Check if we are already in armed state\n\t\t\t\t\t\t\t\t\tif (armed_state == AP_Arming::ARMED) {\n\t\t\t\t\t\t\t\t\t\t// We are in armed state\n\t\t\t\t\t\t\t\t\t\t// Check if we are already in armed with gps state\n\t\t\t\t\t\t\t\t\t\tif (armed_state == AP_Arming::ARMED_WITH_GPS) {\n\t\t\t\t\t\t\t\t\t\t\t// We are in armed with gps state\n\t\t\t\t\t\t\t\t\t\t\t// Check if we are already in armed with gps and simple mode state\n\t\t\t\t\t\t\t\t\t\t\tif (armed_state == AP_Arming::ARMED_WITH_GPS_SIMPLE_MODE) {\n\t\t\t\t\t\t\t\t\t\t\t\t// We are in armed with gps and simple mode state\n\t\t\t\t\t\t\t\t\t\t\t\t// Check if we are already in armed with gps and simple mode heading state\n\t\t\t\t\t\t\t\t\t\t\t\tif (armed_state == AP_Arming::ARMED_WITH_GPS_SIMPLE_MODE_HEADING) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// We are in armed with gps and simple mode heading state\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Check if we are already in armed with gps and simple mode heading and soft armed state\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (armed_state == AP_Arming::ARMED_WITH", "CodeBleu_score": 35.355791529093665}, {"code": "bool AP_Arming_Rover::arm(AP_Arming::Method method, const bool do_arming_checks)\tif (is_armed()) {\n\t\treturn false;\n\t}\n\n\t// Check for valid method\n\tif (method!= AP_Arming::Method::AUTO && method!= AP_Arming::Method::SIMPLE) {\n\t\treturn false;\n\t}\n\n\t// Check for valid mode\n\tif (get_mode()!= AP_Mode::Mode::RTL && get_mode()!= AP_Mode::Mode::LOITER) {\n\t\treturn false;\n\t}\n\n\t// Check for valid simple mode heading\n\tif (get_mode() == AP_Mode::Mode::LOITER && get_simple_mode_heading() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check for valid simple mode heading\n\tif (get_mode() == AP_Mode::Mode::RTL && get_simple_mode_heading() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check for valid home location\n\tif (get_home_location() == Vector3f(0, 0, 0)) {\n\t\treturn false;\n\t}\n\n\t// Check for valid home heading\n\tif (get_home_heading() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check for valid home altitude\n\tif (get_home_altitude() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check for valid home time\n\tif (get_home_time() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check for valid simple mode altitude\n\tif (get_mode() == AP_Mode::Mode::LOITER && get_simple_mode_altitude() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check for valid simple mode altitude\n\tif (get_mode() == AP_Mode::Mode::RTL && get_simple_mode_altitude() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check for valid simple mode radius\n\tif (get_mode() == AP_Mode::Mode::LOITER && get_simple_mode_radius() == 0) {\n\t\treturn false;\n\t}\n\n\t// Check for valid simple mode radius\n\tif (get_mode() == AP_Mode::Mode::RTL && get_simple_mode_", "CodeBleu_score": 37.373068087374435}]}
{"instance_id": "f27a1a799e44", "generation_result": [{"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tif (charging_enabled_since > 0) {\n\t\t\t\tif (millis() - charging_enabled_since > charging_enabled_for) {\n\t\t\t\t\tcharging_enabled = false;\n\t\t\t\t\tcharging_enabled_since = 0;\n\t\t\t\t\tif (charging_enabled_for > 0) {\n\t\t\t\t\t\tcharging_enabled_for = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_enabled_since = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (charging_enabled_since == 0) {\n\t\t\t\tcharging_enabled_since = millis();\n\t\t\t}\n\t\t\tif (millis() - charging_enabled_since > charging_retry_delay) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t\tcharging_enabled_since = millis();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tcharging_enabled = false;\n\t\t\tcharging_enabled_since = 0;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 42.141086577270315}, {"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (charging_enabled) {\n\t\t\tif (!charge_allowed) {\n\t\t\t\tcharging_enabled = false;\n\t\t\t\tcharging_disabled_time = millis();\n\t\t\t}\n\t\t} else {\n\t\t\tif (charge_allowed) {\n\t\t\t\tcharging_enabled = true;\n\t\t\t} else {\n\t\t\t\tif (millis() - charging_disabled_time >= charging_disabled_delay) {\n\t\t\t\t\tcharging_enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcharging_enabled = false;\n\t}\n}\n", "CodeBleu_score": 43.18985028217918}, {"code": "void updateChargingEnabled()\tif (charging_allowed) {\n\t\tif (!charging_enabled) {\n\t\t\tenableCharging();\n\t\t}\n\t} else {\n\t\tif (charging_enabled) {\n\t\t\tdisableCharging();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 12.089712165682991}]}
{"instance_id": "519b3db03cbf", "generation_result": [{"code": "void sendMessage(void *message, size_t size)\tif (ros::ok() && size >= 4) {\n\t\tuint16_t crc = crc16(message, size);\n\t\tmemcpy(message + size, &crc, 2);\n\t\tpacketSerial.write(message, size + 2);\n\t}\n}\n", "CodeBleu_score": 28.849319060571325}, {"code": "void sendMessage(void *message, size_t size)\tif (ros::ok()) {\n\t\tif (size >= 4) {\n\t\t\tuint32_t crc = crc32(message, size);\n\t\t\tuint8_t *crc_bytes = (uint8_t *) &crc;\n\t\t\tpacketSerial.write(crc_bytes, 4);\n\t\t\tpacketSerial.write(message, size);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.84257987179271}, {"code": "void sendMessage(void *message, size_t size)\tif (ros::ok() && size >= 4) {\n\t\tuint16_t crc = crc16(message, size);\n\t\tuint8_t *message_ptr = (uint8_t *) message;\n\t\tmessage_ptr[size] = crc & 0xFF;\n\t\tmessage_ptr[size + 1] = crc >> 8;\n\t\tpacketSerial.write(message_ptr, size + 2);\n\t}\n}\n", "CodeBleu_score": 51.77987066386318}]}
{"instance_id": "0ac148219164", "generation_result": [{"code": "bool MP3Sound::begin()\tif (Serial.availableForWrite() >= 1) {\n\t\tSerial.write(0x7E);\n\t\tSerial.write(0xFF);\n\t\tSerial.write(0x06);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0xEF);\n\t}\n\tdelay(100);\n\tif (Serial.availableForWrite() >= 1) {\n\t\tSerial.write(0x7E);\n\t\tSerial.write(0xFF);\n\t\tSerial.write(0x06);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t}\n\tdelay(100);\n\tif (Serial.availableForWrite() >= 1) {\n\t\tSerial.write(0x7E);\n\t\tSerial.write(0xFF);\n\t\tSerial.write(0x06);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t}\n\tdelay(100);\n\tif (Serial.availableForWrite() >= 1) {\n\t\tSerial.write(0x7E);\n\t\tSerial.write(0xFF);\n\t\tSerial.write(0x06);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00);\n\t}\n\tdelay(100);\n\tif (Serial.availableForWrite() >= 1) {\n\t\tSerial.write(0x7E);\n\t\tSerial.write(0xFF);\n\t\tSerial.write(0x06);\n\t\tSerial.write(0x00);\n\t\tSerial.write(0x00", "CodeBleu_score": 31.558757926628427}, {"code": "bool MP3Sound::begin()\tSerial.begin(9600);\n\tSerial.print(\"AT+RST\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+GMR\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+CWMODE=1\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+CWJAP=\\\"SSID\\\",\\\"PASSWORD\\\"\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+CIFSR\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+CIPMUX=1\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+CIPSERVER=1,80\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+CIPSTO=100\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.print(\"AT+RESTORE\\r\\n\");\n\tdelay(1000);\n\tSerial.", "CodeBleu_score": 33.398188042319035}, {"code": "bool MP3Sound::begin()\tSerial.begin(9600);\n\twhile (!Serial) {\n\t\t; // wait for serial port to connect. Needed for native USB port only\n\t}\n\n\t// Initialize the SD card\n\tif (!SD.begin(SD_CS_PIN)) {\n\t\treturn false;\n\t}\n\n\t// Initialize the sound module\n\tif (!MP3player.begin()) {\n\t\treturn false;\n\t}\n\n\t// Clear the buffer\n\twhile (Serial.available()) {\n\t\tSerial.read();\n\t}\n\n\t// Retrieve the number of sound files available\n\tif (!MP3player.get_total_tracks(numSounds)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 47.56020007607421}]}
{"instance_id": "54f11991cc01", "generation_result": [{"code": "int MP3Sound::processSounds()\tif (activeSounds.empty()) {\n\t\treturn 0;\n\t}\n\tif (mp3->isPlaying()) {\n\t\treturn activeSounds.size();\n\t}\n\tif (activeSounds.size() == 1) {\n\t\tmp3->play(activeSounds.back()->getFilename());\n\t\tactiveSounds.pop_back();\n\t\treturn 0;\n\t}\n\tint index = rand() % activeSounds.size();\n\tmp3->play(activeSounds[index]->getFilename());\n\tactiveSounds.erase(activeSounds.begin() + index);\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 40.03882518651064}, {"code": "int MP3Sound::processSounds()\tif (activeSounds.empty()) {\n\t\treturn 0;\n\t}\n\tif (mp3IsPlaying) {\n\t\treturn activeSounds.size();\n\t}\n\tint soundID = activeSounds.back();\n\tactiveSounds.pop_back();\n\tplaySound(soundID);\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 41.363177257096716}, {"code": "int MP3Sound::processSounds()\tint numActiveSounds = activeSounds.size();\n\tif (numActiveSounds == 0 || playing) {\n\t\treturn numActiveSounds;\n\t}\n\n\t// Play the last sound in the list\n\tSound *s = activeSounds.back();\n\ts->play();\n\tactiveSounds.pop_back();\n\n\t// Return the number of active sounds\n\treturn activeSounds.size();\n}\n", "CodeBleu_score": 46.526015692050244}]}
{"instance_id": "fb7393f9ebef", "generation_result": [{"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)#ifdef _WIN32\n  WbAbstractCamera *camera = WB_ABSTRACT_CAMERA(d);\n  WbRequestMemoryMappedFile *request = WB_REQUEST_MEMORY_MAPPED_FILE(r);\n\n  switch (command) {\n    case C_CAMERA_MEMORY_MAPPED_FILE: {\n      if (camera->memoryMappedFile!= NULL) {\n        wb_abstract_camera_close_memory_mapped_file(camera);\n      }\n      camera->memoryMappedFile = wb_abstract_camera_open_memory_mapped_file(camera, request->fileSize);\n      camera->memoryMappedFileOffset = request->offset;\n      camera->memoryMappedFileLength = request->length;\n      camera->memoryMappedFileLength = request->length;\n      camera->memoryMappedFileIsLittleEndian = request->isLittleEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->isBigEndian;\n      camera->memoryMappedFileIsBigEndian = request->is", "CodeBleu_score": 31.933115819132908}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)#ifdef _WIN32\n  if (command == C_CAMERA_MEMORY_MAPPED_FILE) {\n    wb_abstract_camera_clean_memory_mapped_file(d);\n    wb_abstract_camera_setup_memory_mapped_file(d, r);\n    return true;\n  } else {\n    wb_request_set_command_handled(r, false);\n    return false;\n  }", "CodeBleu_score": 24.29035216363186}, {"code": "bool wb_abstract_camera_handle_command(WbDevice *d, WbRequest *r, unsigned char command)}\n", "CodeBleu_score": 6.48713104527464}]}
{"instance_id": "4b123b2ae40e", "generation_result": [{"code": "int wb_abstract_camera_get_height(WbDevice *d)\tWbDeviceTag tag = wb_device_get_tag(d);\n\tWbCamera *camera = (WbCamera *) wb_device_get_user_data(d);\n\tint height;\n\tpthread_mutex_lock(&camera->mutex);\n\theight = camera->height;\n\tpthread_mutex_unlock(&camera->mutex);\n\treturn height;\n}\n", "CodeBleu_score": 39.23031984675641}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)\tint height = -1;\n\tif (d!= NULL) {\n\t\tWbAbstractCamera *camera = (WbAbstractCamera *) d->pdata;\n\t\tif (camera!= NULL) {\n\t\t\tpthread_mutex_lock(&camera->mutex);\n\t\t\theight = camera->height;\n\t\t\tpthread_mutex_unlock(&camera->mutex);\n\t\t}\n\t}\n\treturn height;\n}\n", "CodeBleu_score": 41.415869328858115}, {"code": "int wb_abstract_camera_get_height(WbDevice *d)\treturn wb_abstract_camera_get_height_internal(d, false);\n}\n", "CodeBleu_score": 3.9396910658771307}]}
{"instance_id": "87059b84045d", "generation_result": [{"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tstruct wb_accelerometer *accelerometer = wb_accelerometer_get_struct(tag);\n\tif (accelerometer) {\n\t\treturn accelerometer->sampling_period;\n\t}\n\tfprintf(stderr, \"wb_accelerometer_get_sampling_period: invalid accelerometer tag\\n\");\n\treturn -1;\n}\n", "CodeBleu_score": 17.19183415888722}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tstruct wb_accelerometer *accelerometer = wb_accelerometer_get_struct(tag);\n\tif (accelerometer) {\n\t\tint sampling_period = accelerometer->sampling_period;\n\t\twb_accelerometer_unlock(tag);\n\t\treturn sampling_period;\n\t}\n\telse\n\t\tfprintf(stderr, \"Warning: wb_accelerometer_get_sampling_period: invalid tag.\\n\");\n\twb_accelerometer_unlock(tag);\n\treturn -1;\n}\n", "CodeBleu_score": 49.04843176761692}, {"code": "int wb_accelerometer_get_sampling_period(WbDeviceTag tag)\tint sampling_period = 0;\n\taccelerometer_struct *accelerometer = NULL;\n\taccelerometer = (accelerometer_struct *) wb_device_get_node_data(tag);\n\tif (accelerometer!= NULL) {\n\t\tsampling_period = accelerometer->sampling_period;\n\t} else {\n\t\tfprintf(stderr, \"wb_accelerometer_get_sampling_period: Invalid device tag\\n\");\n\t}\n\tpthread_mutex_unlock(&accelerometer->mutex);\n\treturn sampling_period;\n}\n", "CodeBleu_score": 37.49754853133314}]}
{"instance_id": "3550d350877a", "generation_result": [{"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar *dms_str = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dms(dms_str);\n\tfree(dms_str);\n\treturn dms;\n}\n", "CodeBleu_score": 38.439516337423896}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar* dms = wb_gps_convert_to_degrees_minutes_seconds(decimalDegree);\n\tstring dmsString = dms;\n\tfree(dms);\n\treturn dmsString;\n}\n", "CodeBleu_score": 42.57779746336043}, {"code": "string GPS::convertToDegreesMinutesSeconds(double decimalDegree)\tchar* dms;\n\twb_gps_convert_to_degrees_minutes_seconds(decimalDegree, &dms);\n\tstring dmsString = dms;\n\tfree(dms);\n\treturn dmsString;\n}\n", "CodeBleu_score": 41.3570295969913}]}
{"instance_id": "21eca9880c41", "generation_result": [{"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdVector3 p;\n\tdVector3 n;\n\tdVector3 v;\n\tdVector3 c;\n\tdGeomBoxData *data;\n\tdReal r;\n\n\tdata = (dGeomBoxData *) dGeomGetData (g);\n\tdGeomBoxGetParams (g, &r, c);\n\n\tp[0] = x - c[0];\n\tp[1] = y - c[1];\n\tp[2] = z - c[2];\n\n\tn[0] = 0;\n\tn[1] = 0;\n\tn[2] = 0;\n\n\tif (fabs (p[0]) > fabs (p[1]) && fabs (p[0]) > fabs (p[2])) {\n\t\tif (p[0] > r) {\n\t\t\tn[0] = 1;\n\t\t\tv[0] = r;\n\t\t} else if (p[0] < -r) {\n\t\t\tn[0] = -1;\n\t\t\tv[0] = -r;\n\t\t}\n\t} else if (fabs (p[1]) > fabs (p[0]) && fabs (p[1]) > fabs (p[2])) {\n\t\tif (p[1] > r) {\n\t\t\tn[1] = 1;\n\t\t\tv[1] = r;\n\t\t} else if (p[1] < -r) {\n\t\t\tn[1] = -1;\n\t\t\tv[1] = -r;\n\t\t}\n\t} else {\n\t\tif (p[2] > r) {\n\t\t\tn[2] = 1;\n\t\t\tv[2] = r;\n\t\t} else if (p[2] < -r) {\n\t\t\tn[2] = -1;\n\t\t\tv[2] = -r;\n\t\t}\n\t}\n\n\tdCROSS (v, n, plane);\n\tplane[3] = dDOT (v, n);\n}\n", "CodeBleu_score": 26.809297669066478}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdVector3 p;\n\tdVector3 normal;\n\tdReal dist;\n\tdReal dx, dy, dz;\n\tdGeomBoxData *data;\n\n\tdata = (dGeomBoxData*) dGeomGetData (g);\n\tif (data->class_id!= dBoxClass) {\n\t\tdWarning (\"dGeomBoxGetTangentPlane: not a box\");\n\t\treturn;\n\t}\n\n\tp[0] = x;\n\tp[1] = y;\n\tp[2] = z;\n\tdVectorScale (data->side, 0.5, p);\n\tdVectorAdd (p, data->pos, p);\n\n\tdx = fabs (p[0] - data->pos[0]);\n\tdy = fabs (p[1] - data->pos[1]);\n\tdz = fabs (p[2] - data->pos[2]);\n\n\tif (dx > dy && dx > dz) {\n\t\tif (p[0] < data->pos[0]) {\n\t\t\tnormal[0] = -1.0;\n\t\t} else {\n\t\t\tnormal[0] = 1.0;\n\t\t}\n\t\tnormal[1] = 0.0;\n\t\tnormal[2] = 0.0;\n\t\tdist = p[0] - data->pos[0];\n\t} else if (dy > dx && dy > dz) {\n\t\tif (p[1] < data->pos[1]) {\n\t\t\tnormal[1] = -1.0;\n\t\t} else {\n\t\t\tnormal[1] = 1.0;\n\t\t}\n\t\tnormal[0] = 0.0;\n\t\tnormal[2] = 0.0;\n\t\tdist = p[1] - data->pos[1];\n\t} else {\n\t\tif (p[2] < data->pos[2]) {\n\t\t\tnormal[2] = -1.0;\n\t\t} else {\n\t\t\tnormal[2] = 1.0;\n\t\t}\n\t\tnormal[0] = 0.0;\n\t\tnormal[1] = 0.0;\n\t\tdist = p[2] - data->pos[2];\n\t}\n\n\tdVectorSet (plane, normal[0], normal[", "CodeBleu_score": 28.50480660777669}, {"code": "void dGeomBoxGetTangentPlane (dGeomID g, dReal x, dReal y, dReal z, dVector4 plane)\tdUASSERT(0,\"dGeomBoxGetTangentPlane() not implemented\");\n}\n", "CodeBleu_score": 1.4747180181153579}]}
{"instance_id": "78037ded1d5d", "generation_result": [{"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tif (!box ||!box->body) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_FLUID) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_BOX) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_CONTACT) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_FLUID) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT_FLUID) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT_FLUID_NO_SELF_CONTACT) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT_FLUID_NO_SELF_FLUID) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT_FLUID_NO_SELF_FLUID_NO_SELF_CONTACT) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT_FLUID_NO_SELF_FLUID_NO_SELF_CONTACT_FLUID) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT_FLUID_NO_SELF_FLUID_NO_SELF_CONTACT_FLUID_NO_SELF_CONTACT) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT_FLUID_NO_SELF_FLUID_NO_SELF_CONTACT_FLUID_NO_SELF_CONTACT_FLUID) {\n\t\treturn 0;\n\t}\n\tif (flags & dIMMERSE_NO_SELF_CONTACT_FLUID_NO_SELF_FLUID_NO_SELF_CONTACT_FLUID_NO_SELF_CONTACT_FLUID_NO_SELF_CONTACT) {\n\t\treturn 0;\n\t}\n", "CodeBleu_score": 27.28209654264554}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tdVector3 plane;\n\tdVector3 boxCenter;\n\tdVector3 boxExtents;\n\tdVector3 boxPos;\n\tdVector3 boxVel;\n\tdVector3 boxRot;\n\tdVector3 boxVelRel;\n\tdVector3 boxRotRel;\n\tdVector3 boxVelRelPlane;\n\tdVector3 boxRotRelPlane;\n\tdVector3 boxVelRelPlaneNorm;\n\tdVector3 boxRotRelPlaneNorm;\n\tdVector3 boxVelRelPlaneTangent;\n\tdVector3 boxRotRelPlaneTangent;\n\tdVector3 boxVelRelPlaneTangentNorm;\n\tdVector3 boxRotRelPlaneTangentNorm;\n\tdVector3 boxVelRelPlaneTangentNormProj;\n\tdVector3 boxRotRelPlaneTangentNormProj;\n\tdVector3 boxVelRelPlaneTangentNormProjRel;\n\tdVector3 boxRotRelPlaneTangentNormProjRel;\n\tdVector3 boxVelRelPlaneTangentNormProjRelPlane;\n\tdVector3 boxRotRelPlaneTangentNormProjRelPlane;\n\tdVector3 boxVelRelPlaneTangentNormProjRelPlaneNorm;\n\tdVector3 boxRotRelPlaneTangentNormProjRelPlaneNorm;\n\tdVector3 boxVelRelPlaneTangentNormProjRelPlaneNormProj;\n\tdVector3 boxRotRelPlaneTangentNormProjRelPlaneNormProj;\n\tdVector3 boxVelRelPlaneTangentNormProjRelPlaneNormProjRel;\n\tdVector3 boxRotRelPlaneTangentNormProjRelPlaneNormProjRel;\n\tdVector3 boxVelRelPlaneTangentNormProjRelPlaneNormProjRelPlane;\n\tdVector3 boxRotRelPlaneTangentNormProjRelPlaneNormProjRelPlane;\n\tdVector3 boxVelRelPlaneTangentNormProjRelPlaneNormProjRelPlaneNorm;\n\tdVector3 boxRotRelPlaneTangentNormProjRelPlaneNormProjRelPlaneNorm;\n\tdVector3 boxVelRelPlaneTangentNormProjRelPlaneNormProjRelPlaneNormProj;\n\tdVector3 boxRotRelPlaneTangentNormProjRelPlaneNormProjRelPlaneNormProj;\n\tdVector3 boxVelRelPlaneTangentNormProjRelPlaneNormProjRelPlaneNormProjRel;\n\tdVector3 boxRotRelPlaneTangentNormProjRelPlaneNormProjRelPlaneNormProjRel;\n\tdVector3 boxVelRelPlane", "CodeBleu_score": 15.789406721645232}, {"code": "int dImmerseBox (dxBox *box, const dReal *fluidPlane, int flags,\n      dImmersionGeom *immersion)\tint result;\n\tdImmersionGeom immersed;\n\n\tassert (box);\n\tassert (box->body);\n\tassert (fluidPlane);\n\tassert (flags >= 0);\n\tassert (immersion);\n\n\tif (flags & dIMMERSE_BOX_NO_BOX_COLLISIONS) {\n\t\tresult = dImmerseBoxNoBoxCollisions (box, fluidPlane, &immersed);\n\t} else {\n\t\tresult = dImmerseBoxWithBoxCollisions (box, fluidPlane, &immersed);\n\t}\n\n\tif (result == 1) {\n\t\t*immersion = immersed;\n\t}\n\n\treturn result;\n}\n", "CodeBleu_score": 41.49112212328307}]}
{"instance_id": "8a0465e493b5", "generation_result": [{"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdVector3 pos1, pos2;\n\tdMatrix3 R1, R2;\n\tdVector3 boxSize;\n\tdVector3 capsuleAxis;\n\tdVector3 capsuleCenter;\n\tdVector3 capsulePoint;\n\tdVector3 capsulePoint2;\n\tdVector3 capsulePoint3;\n\tdVector3 capsulePoint4;\n\tdVector3 capsulePoint5;\n\tdVector3 capsulePoint6;\n\tdVector3 capsulePoint7;\n\tdVector3 capsulePoint8;\n\tdVector3 capsulePoint9;\n\tdVector3 capsulePoint10;\n\tdVector3 capsulePoint11;\n\tdVector3 capsulePoint12;\n\tdVector3 capsulePoint13;\n\tdVector3 capsulePoint14;\n\tdVector3 capsulePoint15;\n\tdVector3 capsulePoint16;\n\tdVector3 capsulePoint17;\n\tdVector3 capsulePoint18;\n\tdVector3 capsulePoint19;\n\tdVector3 capsulePoint20;\n\tdVector3 capsulePoint21;\n\tdVector3 capsulePoint22;\n\tdVector3 capsulePoint23;\n\tdVector3 capsulePoint24;\n\tdVector3 capsulePoint25;\n\tdVector3 capsulePoint26;\n\tdVector3 capsulePoint27;\n\tdVector3 capsulePoint28;\n\tdVector3 capsulePoint29;\n\tdVector3 capsulePoint30;\n\tdVector3 capsulePoint31;\n\tdVector3 capsulePoint32;\n\tdVector3 capsulePoint33;\n\tdVector3 capsulePoint34;\n\tdVector3 capsulePoint35;\n\tdVector3 capsulePoint36;\n\tdVector3 capsulePoint37;\n\tdVector3 capsulePoint38;\n\tdVector3 capsulePoint39;\n\tdVector3 capsulePoint40;\n\tdVector3 capsulePoint41;\n\tdVector3 capsulePoint42;\n\tdVector3 capsulePoint43;\n\t", "CodeBleu_score": 5.5557777579964895}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tif (o1 == NULL || o2 == NULL || immersion == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (flags!= 0 && flags!= 1) {\n\t\treturn 0;\n\t}\n\n\tdVector3 box_center, capsule_center, capsule_axis, capsule_start, capsule_end;\n\tdVector3 box_size, capsule_radius;\n\tdMatrix3 box_R, capsule_R;\n\tdReal box_extents[3], capsule_extents[3];\n\tdVector3 box_normal, capsule_normal;\n\tdVector3 box_plane, capsule_plane;\n\tdReal box_dist, capsule_dist;\n\tdVector3 box_p1, box_p2, box_p3, box_p4, box_p5, box_p6, box_p7, box_p8;\n\tdVector3 capsule_p1, capsule_p2, capsule_p3, capsule_p4, capsule_p5, capsule_p6, capsule_p7, capsule_p8;\n\tdVector3 box_edge_1, box_edge_2, box_edge_3, box_edge_4, box_edge_5, box_edge_6, box_edge_7, box_edge_8;\n\tdVector3 capsule_edge_1, capsule_edge_2, capsule_edge_3, capsule_edge_4, capsule_edge_5, capsule_edge_6, capsule_edge_7, capsule_edge_8;\n\tdVector3 box_point_1, box_point_2, box_point_3, box_point_4, box_point_5, box_point_6, box_point_7, box_point_8;\n\tdVector3 capsule_point_1, capsule_point_2, capsule_point_3, capsule_point_4, capsule_point_5, capsule_point_6, capsule_point_7, capsule_point_8;\n\tdVector3 box_edge_1_2, box_edge_", "CodeBleu_score": 16.38505749590047}, {"code": "int dImmerseBoxCapsule (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdVector3 boxCenter, capsuleCenter;\n\tdVector3 boxHalfExtents, capsuleHalfExtents;\n\tdVector3 boxAxis[3], capsuleAxis[3];\n\tdVector3 boxNormal, capsuleNormal;\n\tdVector3 boxPoint, capsulePoint;\n\tdVector3 boxPlane, capsulePlane;\n\tdVector3 boxPlaneNormal, capsulePlaneNormal;\n\tdVector3 boxPlanePoint, capsulePlanePoint;\n\tdVector3 boxPlaneNormalInv, capsulePlaneNormalInv;\n\tdVector3 boxPlanePointInv, capsulePlanePointInv;\n\tdVector3 boxPlaneNormalInvTrans, capsulePlaneNormalInvTrans;\n\tdVector3 boxPlanePointInvTrans, capsulePlanePointInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlaneNormalInvTrans;\n\tdVector3 boxPlanePointInvTransCapsulePlanePointInvTrans;\n\tdVector3 boxPlanePointInvTransCapsulePlaneNormalInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlanePointInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlaneNormalInvTransCapsulePlanePointInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlanePointInvTransCapsulePlaneNormalInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlaneNormalInvTransCapsulePlanePointInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlanePointInvTransCapsulePlaneNormalInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlanePointInvTransCapsulePlanePointInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlaneNormalInvTransCapsulePlaneNormalInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlanePointInvTransCapsulePlaneNormalInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlanePointInvTransCapsulePlanePointInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlaneNormalInvTransCapsulePlanePointInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlanePointInvTransCapsulePlaneNormalInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlanePointInvTransCapsulePlanePointInvTrans;\n\tdVector3 boxPlaneNormalInvTransCapsulePlaneNormalInvTrans", "CodeBleu_score": 15.647145623378295}]}
{"instance_id": "61daf30a6976", "generation_result": [{"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal z0 = zIOverR;\n\tdReal z1 = z0 + tanTheta0;\n\tdReal z2 = z1 + tanTheta0;\n\n\tdReal z0sq = z0 * z0;\n\tdReal z1sq = z1 * z1;\n\tdReal z2sq = z2 * z2;\n\n\tdReal z0cub = z0 * z0sq;\n\tdReal z1cub = z1 * z1sq;\n\tdReal z2cub = z2 * z2sq;\n\n\tdReal z0qud = z0 * z0cub;\n\tdReal z1qud = z1 * z1cub;\n\tdReal z2qud = z2 * z2cub;\n\n\tdReal z0sin = z0 * sinTheta1;\n\tdReal z1sin = z1 * sinTheta1;\n\tdReal z2sin = z2 * sinTheta1;\n\n\tdReal z0cos = z0 * cosTheta1;\n\tdReal z1cos = z1 * cosTheta1;\n\tdReal z2cos = z2 * cosTheta1;\n\n\tdReal z0sin2 = z0sin * z0sin;\n\tdReal z1sin2 = z1sin * z1sin;\n\tdReal z2sin2 = z2sin * z2sin;\n\n\tdReal z0cos2 = z0cos * z0cos;\n\tdReal z1cos2 = z1cos * z1cos;\n\tdReal z2cos2 = z2cos * z2cos;\n\n\tdReal z0sin3 = z0sin2 * z0sin;\n\tdReal z1sin3 = z1sin2 * z1sin;\n\tdReal z2sin3 = z2sin2 * z2sin;\n\n\tdReal z0cos3 = z0cos2 * z0cos;\n\tdReal z1cos3 = z1cos2 * z1cos;\n\tdReal z2cos3 = z2cos2 * z2cos;\n\n\tdReal z0sin4 = z0sin2 * z0sin2;\n\tdReal z1sin4 = z1sin2 * z1sin2;", "CodeBleu_score": 34.001506970411704}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal z0 = zIOverR*cosTheta0;\n\tdReal z1 = zIOverR*cosTheta1;\n\tdReal z2 = zIOverR*cosTheta2;\n\tdReal z3 = zIOverR*cosTheta3;\n\tdReal z4 = zIOverR*cosTheta4;\n\tdReal z5 = zIOverR*cosTheta5;\n\tdReal z6 = zIOverR*cosTheta6;\n\tdReal z7 = zIOverR*cosTheta7;\n\tdReal z8 = zIOverR*cosTheta8;\n\tdReal z9 = zIOverR*cosTheta9;\n\tdReal z10 = zIOverR*cosTheta10;\n\tdReal z11 = zIOverR*cosTheta11;\n\tdReal z12 = zIOverR*cosTheta12;\n\tdReal z13 = zIOverR*cosTheta13;\n\tdReal z14 = zIOverR*cosTheta14;\n\tdReal z15 = zIOverR*cosTheta15;\n\tdReal z16 = zIOverR*cosTheta16;\n\tdReal z17 = zIOverR*cosTheta17;\n\tdReal z18 = zIOverR*cosTheta18;\n\tdReal z19 = zIOverR*cosTheta19;\n\tdReal z20 = zIOverR*cosTheta20;\n\tdReal z21 = zIOverR*cosTheta21;\n\tdReal z22 = zIOverR*cosTheta22;\n\tdReal z23 = zIOverR*cosTheta23;\n\tdReal z24 = zIOverR*cosTheta24;\n\tdReal z25 = zIOverR*cosTheta25;\n\tdReal z26 = zIOverR*cosTheta26;\n\tdReal z27 = zIOverR*cosTheta27;\n\tdReal z28 = zIOverR*cosTheta28;\n\tdReal z29 = zIOver", "CodeBleu_score": 12.135363830669048}, {"code": "dReal sCapsuleImmersionData::normalizedImmersedHemisphereVolume(dReal zIOverR, dReal tanTheta0, dReal sinTheta1) const\tdReal z0 = zIOverR * (1.0 - tanTheta0);\n\tdReal z1 = zIOverR * (1.0 + tanTheta0);\n\tdReal z2 = zIOverR * (1.0 - tanTheta1);\n\tdReal z3 = zIOverR * (1.0 + tanTheta1);\n\n\tdReal f0 = (z0 * z0 * z0) / 3.0;\n\tdReal f1 = (z1 * z1 * z1) / 3.0;\n\tdReal f2 = (z2 * z2 * z2) / 3.0;\n\tdReal f3 = (z3 * z3 * z3) / 3.0;\n\n\tdReal d0 = (z0 - z1) / 6.0;\n\tdReal d1 = (z1 - z2) / 6.0;\n\tdReal d2 = (z2 - z3) / 6.0;\n\n\tdReal f01 = f0 + f1;\n\tdReal f23 = f2 + f3;\n\n\tdReal d01 = d0 + d1;\n\tdReal d23 = d2 + d3;\n\n\tdReal f0123 = f01 + f23;\n\tdReal d0123 = d01 + d23;\n\n\treturn f0123 + d0123 * (z1 + z2);\n}\n", "CodeBleu_score": 35.571681388590434}]}
{"instance_id": "a56f300e5305", "generation_result": [{"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal xBuoyancyCenter = 0.0;\n\tdReal theta = 0.0;\n\tdReal sinTheta = 0.0;\n\tdReal cosTheta = 0.0;\n\tdReal dSinTheta = 0.0;\n\tdReal dCosTheta = 0.0;\n\tdReal dCosTheta2 = 0.0;\n\tdReal dCosTheta3 = 0.0;\n\tdReal dCosTheta4 = 0.0;\n\tdReal dCosTheta5 = 0.0;\n\tdReal dCosTheta6 = 0.0;\n\tdReal dCosTheta7 = 0.0;\n\tdReal dCosTheta8 = 0.0;\n\tdReal dCosTheta9 = 0.0;\n\tdReal dCosTheta10 = 0.0;\n\tdReal dCosTheta11 = 0.0;\n\tdReal dCosTheta12 = 0.0;\n\tdReal dCosTheta13 = 0.0;\n\tdReal dCosTheta14 = 0.0;\n\tdReal dCosTheta15 = 0.0;\n\tdReal dCosTheta16 = 0.0;\n\tdReal dCosTheta17 = 0.0;\n\tdReal dCosTheta18 = 0.0;\n\tdReal dCosTheta19 = 0.0;\n\tdReal dCosTheta20 = 0.0;\n\tdReal dCosTheta21 = 0.0;\n\tdReal dCosTheta22 = 0.0;\n\tdReal dCosTheta23 = 0.0;\n\tdReal dCosTheta24 = 0.0;\n\tdReal dCosTheta25 = 0.0;\n\tdReal dCosTheta26 = 0.0;\n\tdReal dCosTheta27 = 0.0;\n\tdReal dCosTheta28 = 0.0;\n\tdReal dCosTheta29 = 0.0;\n\tdReal dCosTheta30 = 0.0;\n\tdReal dCosTheta31 =", "CodeBleu_score": 10.50265732113244}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal x0 = 0;\n\tdReal x1 = zIOverR;\n\tdReal x2 = zIOverR * cos(dReal(M_PI_4));\n\tdReal x3 = zIOverR * cos(dReal(M_PI_2));\n\tdReal x4 = zIOverR * cos(dReal(3 * M_PI_4));\n\tdReal x5 = zIOverR * cos(dReal(M_PI));\n\tdReal x6 = zIOverR * cos(dReal(5 * M_PI_4));\n\tdReal x7 = zIOverR * cos(dReal(3 * M_PI_2));\n\tdReal x8 = zIOverR * cos(dReal(7 * M_PI_4));\n\tdReal x9 = zIOverR * cos(dReal(2 * M_PI));\n\tdReal x10 = zIOverR * cos(dReal(9 * M_PI_4));\n\tdReal x11 = zIOverR * cos(dReal(5 * M_PI_2));\n\tdReal x12 = zIOverR * cos(dReal(11 * M_PI_4));\n\tdReal x13 = zIOverR * cos(dReal(3 * M_PI));\n\tdReal x14 = zIOverR * cos(dReal(13 * M_PI_4));\n\tdReal x15 = zIOverR * cos(dReal(7 * M_PI_2));\n\tdReal x16 = zIOverR * cos(dReal(15 * M_PI_4));\n\tdReal x17 = zIOverR * cos(dReal(4 * M_PI));\n\tdReal x18 = zIOverR * cos(dReal(17 * M_PI_4));\n\tdReal x19 = zIOverR * cos(dReal(9 * M_PI_2));\n\tdReal x20 = zIOverR * cos(dReal(21 * M_PI_4));\n\tdReal x21 = zIOverR * cos", "CodeBleu_score": 32.21337243124622}, {"code": "dReal sCapsuleImmersionData::immersedHemisphereXBuoyancyCenter(dReal zIOverR, dReal tanTheta0, dReal sinTheta1, dReal volume) const\tdReal theta0 = atan(tanTheta0);\n\tdReal theta1 = acos(sinTheta1);\n\tdReal theta2 = dPI - theta1;\n\tdReal x = 0;\n\tdReal theta = theta0;\n\tdReal dtheta = (theta1 - theta0) / 6;\n\tfor (int i = 0; i < 6; i++) {\n\t\tx += (zIOverR * zIOverR * sin(theta) * sin(theta) + 1) * dtheta;\n\t\ttheta += dtheta;\n\t}\n\ttheta = theta1;\n\tdtheta = (theta2 - theta1) / 6;\n\tfor (int i = 0; i < 6; i++) {\n\t\tx += (zIOverR * zIOverR * sin(theta) * sin(theta) + 1) * dtheta;\n\t\ttheta += dtheta;\n\t}\n\tx *= volume;\n\treturn x;\n}\n", "CodeBleu_score": 38.563351976325784}]}
{"instance_id": "1b2c92a2e577", "generation_result": [{"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdVector3 *p1, *p2;\n\tdVector3 *n1, *n2;\n\tdVector3 *g1, *g2;\n\tdVector3 *c1, *c2;\n\tdVector3 *b1, *b2;\n\tdVector3 *v1, *v2;\n\tdVector3 *s1, *s2;\n\tdVector3 *c, *b;\n\tdVector3 *x1, *x2;\n\tdVector3 *v;\n\tdVector3 *s;\n\tdVector3 *x;\n\tdVector3 *t;\n\tdVector3 *p;\n\tdVector3 *n;\n\tdVector3 *g;\n\tdVector3 *c0;\n\tdVector3 *b0;\n\tdVector3 *v0;\n\tdVector3 *s0;\n\tdVector3 *x0;\n\tdVector3 *v10;\n\tdVector3 *v20;\n\tdVector3 *v11;\n\tdVector3 *v21;\n\tdVector3 *v12;\n\tdVector3 *v22;\n\tdVector3 *v13;\n\tdVector3 *v23;\n\tdVector3 *v14;\n\tdVector3 *v24;\n\tdVector3 *v15;\n\tdVector3 *v25;\n\tdVector3 *v16;\n\tdVector3 *v26;\n\tdVector3 *v17;\n\tdVector3 *v27;\n\tdVector3 *v18;\n\tdVector3 *v28;\n\tdVector3 *v19;\n\tdVector3 *v29;\n\tdVector3 *v110;\n\tdVector3 *v210;\n\tdVector3 *v111;\n\tdVector3 *v211;\n\tdVector3 *v112;\n\tdVector3 *v212;\n\tdVector3 *v113;\n\tdVector3 *v213;\n\tdVector3 *v11", "CodeBleu_score": 7.504409817727529}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tint i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n\tint a, b, c, d, e, f, g, h, ii, jj, kk, ll, mm, nn, oo, pp, qq, rr, ss, tt, uu, vv, ww, xx, yy, zz;\n\tint aa, bb, cc, dd, ee, ff, gg, hh, ii, jj, kk, ll, mm, nn, oo, pp, qq, rr, ss, tt, uu, vv, ww, xx, yy, zz;\n\tint aaa, bbb, ccc, ddd, eee, fff, ggg, hhh, iii, jjj, kkk, lll, mmm, nnn, ooo, ppp, qqq, rrr, sss, ttt, uuu, vvv, www, xxx, yyy, zzz;\n\tint aaaa, bbbb, cccc, dddd, eeee, ffff, gggg, hhhh, iiii, jjjj, kkkk, llll, mmmm, nnnn, ooon, pppp, qqqq, rrrr, ssss, tttt, uuuu, vvvv, wwww, xxxx, yyyy, zzzz;\n\tint aaaaa, bbbbb, ccccc, ddddd, eeeee, fffff, ggggg, hhhhh, iiiii, jjjjj, kkkkk, lllll, mmmmm, nnnnn, oooon, ppppp, qqqqq, rrrrr, sssss, ttttt, uuuuu, vvvvv, wwwww, xxxxx, yyyyy, zzzzz;\n\tint aaaaaa, bbbbbb, cccccc, dddddd, eeeeee, ffffff, gggggg, hhhhhh, iiiiii, jjjjjj, kkkkkk, llllll, mmmmmm, nnnnnn, oooooo, pppppp, qqqqqq, rrrrrr, ssssss, ttt", "CodeBleu_score": 19.872605642682473}, {"code": "int dImmerseCapsuleTrimesh (dxGeom *o1, dxGeom *o2, int flags, dImmersionGeom *immersion)\tdImmersionGeom *immersionGeom;\n\tdImmersionCapsule *immersionCapsule;\n\tdImmersionCapsule *immersionCapsule2;\n\tdImmersionCapsule *immersionCapsule3;\n\tdImmersionCapsule *immersionCapsule4;\n\tdImmersionCapsule *immersionCapsule5;\n\tdImmersionCapsule *immersionCapsule6;\n\tdImmersionCapsule *immersionCapsule7;\n\tdImmersionCapsule *immersionCapsule8;\n\tdImmersionCapsule *immersionCapsule9;\n\tdImmersionCapsule *immersionCapsule10;\n\tdImmersionCapsule *immersionCapsule11;\n\tdImmersionCapsule *immersionCapsule12;\n\tdImmersionCapsule *immersionCapsule13;\n\tdImmersionCapsule *immersionCapsule14;\n\tdImmersionCapsule *immersionCapsule15;\n\tdImmersionCapsule *immersionCapsule16;\n\tdImmersionCapsule *immersionCapsule17;\n\tdImmersionCapsule *immersionCapsule18;\n\tdImmersionCapsule *immersionCapsule19;\n\tdImmersionCapsule *immersionCapsule20;\n\tdImmersionCapsule *immersionCapsule21;\n\tdImmersionCapsule *immersionCapsule22;\n\tdImmersionCapsule *immersionCapsule23;\n\tdImmersionCapsule *immersionCapsule24;\n\tdImmersionCapsule *immersionCapsule25;\n\tdImmersionCapsule *immersionCapsule26;\n\tdImmersionCapsule *immersionCapsule27;\n\tdImmersionCapsule *immersionCapsule28;\n\tdImmersionCapsule *immersionCapsule29;\n\tdImmersionCapsule *immersionCapsule30;\n\tdImmersionCapsule *immersionCapsule31;\n\tdImmersionCapsule *immersionCapsule32;\n\tdImmersionCapsule *immersionCapsule33;\n\tdImmersionCapsule *immersionCapsule34;\n\t", "CodeBleu_score": 6.0506453054253315}]}
{"instance_id": "18924c6af690", "generation_result": [{"code": "NodeStatus SleepNode::onStart()\t// Get the sleep duration from the input.\n\tauto sleep_duration = getInputValue<int>(INPUT_SLEEP_DURATION);\n\n\t// If the duration is missing or non-positive, return SUCCESS.\n\tif (sleep_duration <= 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Otherwise, set the node status to RUNNING, start the timer, and set a callback to emit a wake-up signal when the timer expires.\n\tsetNodeStatus(NodeStatus::RUNNING);\n\ttimer_waiting_ = true;\n\ttimer_->start(sleep_duration, [this]() {\n\t\temitWakeUpSignal();\n\t});\n\n\t// If the timer is aborted, ensure the timer_waiting_ flag is reset.\n\tif (timer_->isAborted()) {\n\t\ttimer_waiting_ = false;\n\t}\n\n\treturn NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 46.676601388159845}, {"code": "NodeStatus SleepNode::onStart()\tif (duration_ms <= 0) {\n\t\treturn SUCCESS;\n\t}\n\n\tstatus_ = RUNNING;\n\ttimer_waiting_ = true;\n\ttimer_.start(duration_ms, [this]() {\n\t\tthis->emitWakeUp();\n\t\tthis->timer_waiting_ = false;\n\t});\n\treturn RUNNING;\n}\n", "CodeBleu_score": 25.79342208437611}, {"code": "NodeStatus SleepNode::onStart()\t// get the sleep duration\n\tauto sleep_duration = getInput<int>(\"sleep_duration\");\n\t// if the duration is missing or non-positive, return SUCCESS\n\tif (sleep_duration == 0 || sleep_duration < 0) {\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\t// set the node status to RUNNING\n\tsetStatus(NodeStatus::RUNNING);\n\t// start the timer\n\ttimer_ = std::make_unique<Timer>(sleep_duration);\n\t// set the callback to emit a wake-up signal when the timer expires\n\ttimer_->onTimeout.connect(this, &SleepNode::onWakeUp);\n\t// if the timer is aborted, ensure the timer_waiting_ flag is reset\n\ttimer_->onAbort.connect(this, &SleepNode::onAbort);\n\treturn NodeStatus::RUNNING;\n}\n", "CodeBleu_score": 40.490014030580426}]}
{"instance_id": "decdbb003812", "generation_result": [{"code": "NodeStatus EntryUpdatedAction::tick()\tEntry<int> *entry = blackboard->getEntry<int>(name);\n\n\tif (entry!= NULL) {\n\t\tentry->lock();\n\n\t\tif (entry->getSequenceID()!= sequenceID) {\n\t\t\tsequenceID = entry->getSequenceID();\n\t\t\tentry->unlock();\n\t\t\treturn NodeStatus::SUCCESS;\n\t\t}\n\n\t\tentry->unlock();\n\t}\n\n\treturn NodeStatus::FAILURE;\n}\n", "CodeBleu_score": 26.150755581973456}, {"code": "NodeStatus EntryUpdatedAction::tick()\t// Get the entry from the blackboard\n\tEntry *entry = (Entry*)blackboard->get(entryID);\n\n\t// If the entry is not found, return failure\n\tif (entry == NULL) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the mutex of the entry\n\tentry->mutex.lock();\n\n\t// Check if the entry has been updated\n\tif (entry->sequenceID!= entry->previousSequenceID) {\n\t\t// Update the sequence ID\n\t\tentry->previousSequenceID = entry->sequenceID;\n\n\t\t// Unlock the mutex\n\t\tentry->mutex.unlock();\n\n\t\t// Return success\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Unlock the mutex\n\tentry->mutex.unlock();\n\n\t// Return failure\n\treturn NodeStatus::FAILURE;\n}\n\n} /* namespace behaviortree */", "CodeBleu_score": 32.04358339928493}, {"code": "NodeStatus EntryUpdatedAction::tick()\t// Get the entry\n\tboost::shared_ptr<Entry> entry = blackboard->getEntry<Entry>(entry_key);\n\tif (!entry) {\n\t\treturn NodeStatus::FAILURE;\n\t}\n\n\t// Lock the mutex\n\tboost::unique_lock<boost::mutex> lock(entry->getMutex());\n\n\t// Check if the entry has been updated\n\tif (entry->getSequenceID()!= sequence_id) {\n\t\t// Update the sequence ID\n\t\tsequence_id = entry->getSequenceID();\n\n\t\t// Return success\n\t\treturn NodeStatus::SUCCESS;\n\t}\n\n\t// Return failure\n\treturn NodeStatus::FAILURE;\n}\n\n} /* namespace action */\n} /* namespace fawkes */\n", "CodeBleu_score": 38.1784182315101}]}
{"instance_id": "d1eac9aa9b89", "generation_result": [{"code": "size_t ParallelNode::successThreshold() const\tif (successThreshold_ < 0) {\n\t\tif (successThreshold_ == -1) {\n\t\t\treturn childCount();\n\t\t}\n\t\treturn (size_t) std::max(0, successThreshold_ + childCount());\n\t}\n\treturn successThreshold_;\n}\n", "CodeBleu_score": 46.44564543426834}, {"code": "size_t ParallelNode::successThreshold() const\tif (this->successThreshold_ < 0) {\n\t\tsize_t childCount = this->childCount();\n\t\tif (childCount == 0) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn this->successThreshold_ + childCount;\n\t\t}\n\t} else {\n\t\treturn this->successThreshold_;\n\t}\n}\n", "CodeBleu_score": 47.91917828854969}, {"code": "size_t ParallelNode::successThreshold() const\tif (m_successThreshold < 0) {\n\t\treturn std::max(size_t(0), m_successThreshold + m_children.size());\n\t}\n\treturn m_successThreshold;\n}\n", "CodeBleu_score": 48.86442920324744}]}
{"instance_id": "e5a42d88e4e1", "generation_result": [{"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\t// Sleep for 10 milliseconds\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\n\t\t// If the heartbeat is still active\n\t\tif (isHeartbeatActive()) {\n\t\t\t// Enable all breakpoints\n\t\t\tfor (auto& breakpoint : breakpoints) {\n\t\t\t\tbreakpoint.second->enable();\n\t\t\t}\n\t\t} else {\n\t\t\t// Disable all breakpoints\n\t\t\tfor (auto& breakpoint : breakpoints) {\n\t\t\t\tbreakpoint.second->disable();\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 28.87630899858602}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (server->heartbeatStatus()) {\n\t\t\tif (lastHeartbeatTime == 0) {\n\t\t\t\tlastHeartbeatTime = std::chrono::system_clock::now();\n\t\t\t\tfor (auto &breakpoint : breakpoints) {\n\t\t\t\t\tbreakpoint->enable();\n\t\t\t\t}\n\t\t\t} else if (std::chrono::system_clock::now() - lastHeartbeatTime > std::chrono::seconds(3)) {\n\t\t\t\tfor (auto &breakpoint : breakpoints) {\n\t\t\t\t\tbreakpoint->disable();\n\t\t\t\t}\n\t\t\t\tlastHeartbeatTime = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (auto &breakpoint : breakpoints) {\n\t\t\t\tbreakpoint->disable();\n\t\t\t}\n\t\t\tlastHeartbeatTime = 0;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 43.0366757751112}, {"code": "void Groot2Publisher::heartbeatLoop()\twhile (true) {\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\n\t\tif (heartbeatTime.load() + 1000 < time(NULL)) {\n\t\t\tif (heartbeatActive.load()) {\n\t\t\t\theartbeatActive.store(false);\n\t\t\t\tfor (auto& breakpoint : breakpoints) {\n\t\t\t\t\tbreakpoint->enabled.store(false);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!heartbeatActive.load()) {\n\t\t\t\theartbeatActive.store(true);\n\t\t\t\tfor (auto& breakpoint : breakpoints) {\n\t\t\t\t\tbreakpoint->enabled.store(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.916567199358695}]}
{"instance_id": "2b3229ac1588", "generation_result": [{"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> dump;\n\tstd::vector<std::string> bb_names;\n\tstd::string bb_name;\n\tstd::string bb_list_copy = bb_list;\n\tstd::string delimiter = \",\";\n\tsize_t pos = 0;\n\twhile ((pos = bb_list_copy.find(delimiter))!= std::string::npos) {\n\t\tbb_name = bb_list_copy.substr(0, pos);\n\t\tbb_names.push_back(bb_name);\n\t\tbb_list_copy.erase(0, pos + delimiter.length());\n\t}\n\tbb_names.push_back(bb_list_copy);\n\tfor (auto bb_name : bb_names) {\n\t\tauto bb = getBlackboard(bb_name);\n\t\tif (bb) {\n\t\t\tauto subtree = bb->lock();\n\t\t\tif (subtree) {\n\t\t\t\tnlohmann::json bb_json = subtree->toJson();\n\t\t\t\tbb->unlock();\n\t\t\t\tdump.insert(dump.end(), bb_json.dump().begin(), bb_json.dump().end());\n\t\t\t}\n\t\t}\n\t}\n\treturn dump;\n}\n", "CodeBleu_score": 46.379873801873764}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> bb_dump;\n\ttry {\n\t\tauto bb_names = splitString(bb_list, ',');\n\t\tnlohmann::json bb_dump_json;\n\t\tfor (auto bb_name : bb_names) {\n\t\t\tauto bb = blackboard_tree->findBlackboard(bb_name);\n\t\t\tif (bb!= nullptr) {\n\t\t\t\tbb->lock();\n\t\t\t\tbb_dump_json[bb_name] = bb->getJSON();\n\t\t\t\tbb->unlock();\n\t\t\t}\n\t\t}\n\t\tbb_dump = bb_dump_json.dump();\n\t} catch (std::exception& e) {\n\t\tstd::cout << \"Error: \" << e.what() << std::endl;\n\t\tbb_dump.clear();\n\t}\n\treturn bb_dump;\n}\n", "CodeBleu_score": 47.04032143480349}, {"code": "std::vector<uint8_t> Groot2Publisher::generateBlackboardsDump(const std::string& bb_list)\tstd::vector<uint8_t> result;\n\tnlohmann::json json_object;\n\tstd::vector<std::string> blackboard_names = splitString(bb_list, ',');\n\tfor (const std::string& bb_name : blackboard_names) {\n\t\tBlackboard* subtree = findSubtree(bb_name);\n\t\tif (subtree!= nullptr) {\n\t\t\tstd::vector<uint8_t> subtree_dump = subtree->dump();\n\t\t\tjson_object[bb_name] = subtree_dump;\n\t\t}\n\t}\n\tresult = json_object.dump().c_str();\n\treturn result;\n}\n", "CodeBleu_score": 43.077196816260646}]}
{"instance_id": "de734043ce56", "generation_result": [{"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Check if the node exists and is valid\n\tif (!isNodeValid(node_uid)) {\n\t\treturn false;\n\t}\n\n\t// Get the hook for the node\n\tstd::shared_ptr<Groot2Hook> hook = getHook(node_uid);\n\n\t// Lock the mutex\n\tstd::unique_lock<std::mutex> lock(hook->mutex);\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (hook->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// Set the desired status and removal flag\n\thook->status = result;\n\thook->remove = remove;\n\n\t// Mark the hook as ready\n\thook->ready = true;\n\n\t// Notify all waiting threads\n\thook->cond.notify_all();\n\n\treturn true;\n}\n", "CodeBleu_score": 38.05353552178039}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Lock the mutex\n\tstd::unique_lock<std::mutex> lock(mutex_hook_map);\n\n\t// Check if the node exists\n\tif (hook_map.find(node_uid) == hook_map.end()) {\n\t\treturn false;\n\t}\n\n\t// Get the hook\n\tauto hook = hook_map.at(node_uid);\n\n\t// Lock the mutex\n\thook->lock();\n\n\t// Set the desired status\n\thook->status = result;\n\thook->remove = remove;\n\thook->ready = true;\n\n\t// Notify all waiting threads\n\thook->cond_var.notify_all();\n\n\t// Unlock the mutex\n\thook->unlock();\n\n\treturn true;\n}\n", "CodeBleu_score": 41.47605679746073}, {"code": "bool Groot2Publisher::unlockBreakpoint(Position pos, uint16_t node_uid, NodeStatus result,\n                                       bool remove)\t// Check if the node is valid\n\tif (node_uid >= _node_list.size()) {\n\t\treturn false;\n\t}\n\n\t// Get the hook\n\tstd::unique_lock<std::mutex> lock(_hook_mutex);\n\tauto it = _hook_list.find(node_uid);\n\tif (it == _hook_list.end()) {\n\t\treturn false;\n\t}\n\n\t// Check if the hook is in BREAKPOINT mode\n\tif (it->second->mode!= HookMode::BREAKPOINT) {\n\t\treturn false;\n\t}\n\n\t// Set the desired status and removal flag\n\tit->second->status = result;\n\tit->second->remove = remove;\n\n\t// Mark the hook as ready and notify all waiting threads\n\tit->second->ready = true;\n\t_hook_cv.notify_all();\n\n\treturn true;\n}\n", "CodeBleu_score": 39.57046674616282}]}
{"instance_id": "3845c5a83a5d", "generation_result": [{"code": "NodeStatus BT::ThreadedAction::executeTick()\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread thread(&ThreadedAction::executeTickAsync, this);\n\t\tthread.detach();\n\t}\n\tif (status_ == NodeStatus::RUNNING) {\n\t\tif (!halt_requested_) {\n\t\t\tstatus_ = NodeStatus::SUCCESS;\n\t\t}\n\t}\n\tif (status_ == NodeStatus::RUNNING) {\n\t\ttry {\n\t\t\ttick();\n\t\t} catch (const BT::Exception &e) {\n\t\t\tstatus_ = NodeStatus::FAILURE;\n\t\t\tstd::cout << \"Exception: \" << e.what() << std::endl;\n\t\t} catch (...) {\n\t\t\tstatus_ = NodeStatus::FAILURE;\n\t\t\tstd::cout << \"Unknown exception\" << std::endl;\n\t\t}\n\t}\n\treturn status_;\n}\n", "CodeBleu_score": 37.839906051369965}, {"code": "NodeStatus BT::ThreadedAction::executeTick()\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread t(&BT::ThreadedAction::executeTickAsync, this);\n\t\tt.detach();\n\t}\n\tif (halt_requested_) {\n\t\tstatus_ = NodeStatus::IDLE;\n\t}\n\treturn status_;\n}\n", "CodeBleu_score": 20.79892527037593}, {"code": "NodeStatus BT::ThreadedAction::executeTick()\tif (status_ == NodeStatus::IDLE) {\n\t\tstatus_ = NodeStatus::RUNNING;\n\t\thalt_requested_ = false;\n\t\tstd::thread t(&ThreadedAction::executeTickAsync, this);\n\t\tt.detach();\n\t}\n\tif (halt_requested_) {\n\t\tstatus_ = NodeStatus::IDLE;\n\t}\n\treturn status_;\n}\n", "CodeBleu_score": 20.728672988875473}]}
{"instance_id": "22e1acefc954", "generation_result": [{"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\t// Print the tree structure\n\tstream << \"-----------------------------------\" << std::endl;\n\tstream << \"Tree structure:\" << std::endl;\n\tstream << \"-----------------------------------\" << std::endl;\n\t// Print the tree recursively\n\tprintTreeRecursively(root_node, stream, 0);\n\t// Print the separator line\n\tstream << \"-----------------------------------\" << std::endl;\n}\n", "CodeBleu_score": 18.827634916143296}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tstd::string indent = \"\";\n\tstd::function<void(const TreeNode*)> printTreeRecursively_lambda = [&printTreeRecursively_lambda, &indent, &stream](const TreeNode* node) {\n\t\tindent += \"   \";\n\t\tstream << indent << node->getName() << std::endl;\n\t\tif (node->isControlNode()) {\n\t\t\tfor (const TreeNode* child : node->getChildren()) {\n\t\t\t\tprintTreeRecursively_lambda(child);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tprintTreeRecursively_lambda(node->getChild());\n\t\t}\n\t\tindent = indent.substr(0, indent.length() - 3);\n\t};\n\tstream << std::endl;\n\tprintTreeRecursively_lambda(root_node);\n\tstream << std::endl;\n}\n", "CodeBleu_score": 36.368806453014756}, {"code": "void printTreeRecursively(const TreeNode* root_node, std::ostream& stream)\tstd::string indent = \"\";\n\tfor (int i = 0; i < root_node->depth; i++) {\n\t\tindent += \"  \";\n\t}\n\tstream << indent << \"\u251c\u2500 \" << root_node->name << std::endl;\n\tif (root_node->children.size() == 0) {\n\t\treturn;\n\t}\n\telse {\n\t\tstd::for_each(root_node->children.begin(), root_node->children.end(), [&](const TreeNode* child) {\n\t\t\tprintTreeRecursively(child, stream);\n\t\t});\n\t}\n}\n", "CodeBleu_score": 25.659224595840087}]}
{"instance_id": "cf05b794dd43", "generation_result": [{"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (node->isControlNode()) {\n\t\tfor (auto child : node->getChildren()) {\n\t\t\tapplyRecursiveVisitor(child.get(), visitor);\n\t\t}\n\t} else if (node->isDecoratorNode()) {\n\t\tapplyRecursiveVisitor(node->getChildren().front().get(), visitor);\n\t}\n}\n", "CodeBleu_score": 43.48661119113064}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (node->type == ControlNode) {\n\t\tfor (auto child : node->children) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t}\n\telse if (node->type == DecoratorNode) {\n\t\tapplyRecursiveVisitor(node->children[0], visitor);\n\t}\n}\n", "CodeBleu_score": 40.78122512942367}, {"code": "void applyRecursiveVisitor(const TreeNode* node,\n                           const std::function<void(const TreeNode*)>& visitor)\tif (node == nullptr) {\n\t\tthrow std::logic_error(\"applyRecursiveVisitor: node is null\");\n\t}\n\tvisitor(node);\n\tif (node->getType() == ControlNode::Type::ControlNode) {\n\t\tfor (const TreeNode* child : node->getChildren()) {\n\t\t\tapplyRecursiveVisitor(child, visitor);\n\t\t}\n\t} else if (node->getType() == DecoratorNode::Type::DecoratorNode) {\n\t\tapplyRecursiveVisitor(node->getChildren()[0], visitor);\n\t}\n}\n", "CodeBleu_score": 43.35938756237926}]}
{"instance_id": "72dfdacfbdb4", "generation_result": [{"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tif (builders.count(manifest.registrationId) > 0) {\n\t\tthrow BehaviorTreeException(\n\t\t\t\"Builder with registration ID \" + manifest.registrationId +\n\t\t\t\" already registered.\");\n\t}\n\tbuilders[manifest.registrationId] = builder;\n\tmanifests[manifest.registrationId] = manifest;\n}\n", "CodeBleu_score": 43.17011261486831}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\t// Check if the builder is already registered\n\tif (builders.find(manifest.registrationId)!= builders.end()) {\n\t\tthrow BehaviorTreeException(\"Builder with ID \" + manifest.registrationId + \" already registered.\");\n\t}\n\n\t// Insert the builder and manifest into their respective maps\n\tbuilders[manifest.registrationId] = builder;\n\tmanifests[manifest.registrationId] = manifest;\n}\n", "CodeBleu_score": 45.45739538545626}, {"code": "void BehaviorTreeFactory::registerBuilder(const TreeNodeManifest& manifest,\n                                          const NodeBuilder& builder)\tif (builders_.find(manifest.id)!= builders_.end()) {\n\t\tthrow BehaviorTreeException(\"Builder already registered: \" + manifest.id);\n\t}\n\n\tbuilders_[manifest.id] = builder;\n\tmanifests_[manifest.id] = manifest;\n}\n", "CodeBleu_score": 39.45687646780032}]}
{"instance_id": "856bf8e3afb7", "generation_result": [{"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\tregisterBuilder(ID, [tick_functor, ports](const TreeNodeManifest& manifest) {\n\t\treturn std::make_shared<SimpleActionNode>(tick_functor, manifest, ports);\n\t}, ports);\n}\n", "CodeBleu_score": 37.41024547560534}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\tNodeBuilder builder = [tick_functor, ports](const TreeNodeManifest& manifest) {\n\t\treturn std::make_unique<SimpleActionNode>(tick_functor, ports);\n\t};\n\tTreeNodeManifest manifest{SimpleActionNode::type(), ID, ports};\n\tregisterBuilder(manifest, builder);\n}\n", "CodeBleu_score": 49.452347686762984}, {"code": "void BehaviorTreeFactory::registerSimpleAction(\n    const std::string& ID, const SimpleActionNode::TickFunctor& tick_functor,\n    PortsList ports)\t// Create a NodeBuilder lambda that constructs a SimpleActionNode using the provided tick functor and configuration.\n\tauto builder = [tick_functor, ports](const TreeNodeManifest& manifest) {\n\t\treturn std::make_unique<SimpleActionNode>(tick_functor, manifest, ports);\n\t};\n\t// Create a TreeNodeManifest with the action node type, ID, and ports list.\n\tTreeNodeManifest manifest(SimpleActionNode::type(), ID, ports);\n\t// Call registerBuilder to register the manifest and builder.\n\tregisterBuilder(manifest, builder);\n}\n", "CodeBleu_score": 50.09836047355067}]}
{"instance_id": "ed0fde814599", "generation_result": [{"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backup;\n\tbackup.reserve(tree.NumSubtrees());\n\tfor (int i = 0; i < tree.NumSubtrees(); i++) {\n\t\tauto subtree = tree.GetSubtree(i);\n\t\tBlackboard::Ptr subtree_bb = subtree.GetBlackboard()->Clone();\n\t\tbackup.push_back(subtree_bb);\n\t}\n\treturn backup;\n}\n", "CodeBleu_score": 49.52605939303707}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.subtrees.size());\n\tfor (auto subtree : tree.subtrees) {\n\t\tBlackboard::Ptr backup = std::make_shared<Blackboard>(*subtree->blackboard);\n\t\tbackups.push_back(backup);\n\t}\n\treturn backups;\n}\n", "CodeBleu_score": 55.73008934995143}, {"code": "std::vector<Blackboard::Ptr> BlackboardBackup(const Tree& tree)\tstd::vector<Blackboard::Ptr> backups;\n\tbackups.reserve(tree.SubTrees().size());\n\tfor (auto& subtree : tree.SubTrees()) {\n\t\tbackups.push_back(std::make_shared<Blackboard>(*subtree.Blackboard()));\n\t}\n\treturn backups;\n}\n", "CodeBleu_score": 53.329795542037154}]}
{"instance_id": "2179772e74ec", "generation_result": [{"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto parseResult = ParseScript(env, script);\n\tif (!parseResult) {\n\t\treturn nonstd::make_unexpected(parseResult.error());\n\t}\n\treturn ExecuteScript(*parseResult, env);\n}\n", "CodeBleu_score": 53.37674103913487}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(env, script);\n\tif (!executor) {\n\t\treturn std::unexpected(executor.error());\n\t}\n\treturn executor.value().Execute();\n}\n\n} // namespace BT", "CodeBleu_score": 59.619962012330966}, {"code": "BT::Expected<Any> ParseScriptAndExecute(Ast::Environment& env, const std::string& script)\tauto executor = ParseScript(env, script);\n\tif (!executor) {\n\t\treturn executor.error();\n\t}\n\treturn executor.value()();\n}\n\n}", "CodeBleu_score": 51.304815086626895}]}
{"instance_id": "22dd2cc593f1", "generation_result": [{"code": "void SharedLibrary::load(const std::string& path, int)\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Library already loaded\");\n\t}\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded = true;\n\tlibPath = path;\n}\n", "CodeBleu_score": 49.751101211659446}, {"code": "void SharedLibrary::load(const std::string& path, int)\tif (loaded) {\n\t\tthrow RuntimeError(\"Library is already loaded\");\n\t}\n\t// Acquire a unique lock on the mutex\n\tstd::unique_lock<std::mutex> lock(mutex);\n\t// Load the library using dlopen\n\tvoid* handle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == nullptr) {\n\t\t// Retrieve the error message\n\t\tstd::string error = dlerror();\n\t\t// Throw a RuntimeError with the error message\n\t\tthrow RuntimeError(\"Failed to load library: \" + error);\n\t}\n\t// Store the path of the loaded library\n\tthis->path = path;\n\t// Set the loaded flag to true\n\tloaded = true;\n}\n", "CodeBleu_score": 55.78082221043608}, {"code": "void SharedLibrary::load(const std::string& path, int)\tstd::unique_lock<std::mutex> lock(mutex);\n\tif (loaded) {\n\t\tthrow RuntimeError(\"Shared library already loaded\");\n\t}\n\thandle = dlopen(path.c_str(), RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == nullptr) {\n\t\tthrow RuntimeError(dlerror());\n\t}\n\tloaded = true;\n\tthis->path = path;\n}\n", "CodeBleu_score": 50.31626160924123}]}
{"instance_id": "0a1b4487dc57", "generation_result": [{"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.startsWith('{') && stripped.endsWith('}')) {\n\t\tif (stripped_pointer) {\n\t\t\t*stripped_pointer = stripped.substring(1, stripped.length() - 1);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 21.975069659592606}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.size() < 3) {\n\t\treturn false;\n\t}\n\tStringView stripped = str.strip();\n\tif (stripped.size() < 3) {\n\t\treturn false;\n\t}\n\tif (stripped[0]!= '{' || stripped[stripped.size() - 1]!= '}') {\n\t\treturn false;\n\t}\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped.substring(1, stripped.size() - 1);\n\t}\n\treturn true;\n}\n", "CodeBleu_score": 25.140569833992927}, {"code": "bool TreeNode::isBlackboardPointer(StringView str, StringView* stripped_pointer)\tif (str.length() < 3) {\n\t\treturn false;\n\t}\n\n\tStringView stripped_str = str.trim();\n\tif (stripped_str.length() < 3) {\n\t\treturn false;\n\t}\n\n\tif (stripped_str.first()!= '{' || stripped_str.last()!= '}') {\n\t\treturn false;\n\t}\n\n\tif (stripped_pointer) {\n\t\t*stripped_pointer = stripped_str.substring(1, stripped_str.length() - 1);\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 24.05854401015917}]}
{"instance_id": "2476cdfee74c", "generation_result": [{"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble line_cost = 0;\n\t// Create a LineIterator object initialized to a line between the two points\n\tcv::LineIterator it(costmap_, cv::Point(x0, y0), cv::Point(x1, y1));\n\t// Iterate through the line and calculate the point cost\n\tfor (int i = 0; i < it.count; i++, ++it) {\n\t\tint x = it.pos().x;\n\t\tint y = it.pos().y;\n\t\tdouble point_cost = cellCost(x, y);\n\t\t// Return the point cost immediately if it is negative\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\t// Update the line cost if the point cost is higher\n\t\tif (point_cost > line_cost) {\n\t\t\tline_cost = point_cost;\n\t\t}\n\t}\n\t// Return the total line cost\n\treturn line_cost;\n}\n", "CodeBleu_score": 56.11781632069015}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble cost = 0.0;\n\tLineIterator it(costmap_, Point(x0, y0), Point(x1, y1));\n\tfor (int i = 0; i < it.count; i++, ++it) {\n\t\tdouble pointCost = pointCost(it.pos());\n\t\tif (pointCost < 0) {\n\t\t\treturn pointCost;\n\t\t}\n\t\tif (pointCost > cost) {\n\t\t\tcost = pointCost;\n\t\t}\n\t}\n\treturn cost;\n}\n", "CodeBleu_score": 47.0378904518817}, {"code": "double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const\tdouble cost = 0.0;\n\t// LineIterator iterates through each point on the line between (x0, y0) and (x1, y1).\n\tLineIterator iter(costmap_, Point(x0, y0), Point(x1, y1), 8);\n\t// For each point on the line, calculate the point cost.\n\tfor (int i = 0; i < iter.count; i++, iter++) {\n\t\tdouble point_cost = pointCost(iter.pos().x, iter.pos().y);\n\t\t// If the point cost is negative, return the point cost immediately.\n\t\tif (point_cost < 0) {\n\t\t\treturn point_cost;\n\t\t}\n\t\t// Otherwise, update the line cost if the point cost is higher.\n\t\tif (point_cost > cost) {\n\t\t\tcost = point_cost;\n\t\t}\n\t}\n\t// Return the total line cost.\n\treturn cost;\n}\n", "CodeBleu_score": 39.49109655087166}]}
{"instance_id": "ba84c4c8709a", "generation_result": [{"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.size() == 0) {\n\t\tROS_WARN(\"Path is empty\");\n\t\treturn;\n\t}\n\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\n\tfor (int i = 0; i < path.size(); i++) {\n\t\tpath_msg.poses.push_back(path[i]);\n\t}\n\n\tpub.publish(path_msg);\n}\n", "CodeBleu_score": 58.05722114272571}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.empty()) {\n\t\treturn;\n\t}\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path[0].header.frame_id;\n\tpath_msg.header.stamp = path[0].header.stamp;\n\tpath_msg.poses.resize(path.size());\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tpath_msg.poses[i] = path[i];\n\t}\n\tpub.publish(path_msg);\n}\n", "CodeBleu_score": 67.06449600557941}, {"code": "void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) \tif (path.empty()) {\n\t\treturn;\n\t}\n\tnav_msgs::Path path_msg;\n\tpath_msg.header.frame_id = path.front().header.frame_id;\n\tpath_msg.header.stamp = path.front().header.stamp;\n\tpath_msg.poses.resize(path.size());\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tpath_msg.poses[i] = path[i];\n\t}\n\tpub.publish(path_msg);\n}\n", "CodeBleu_score": 61.930291090594366}]}
{"instance_id": "4918505c2f31", "generation_result": [{"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\tif (rot_vel <= rot_stopped_velocity && trans_vel <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 52.23755546059732}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\tdouble rot_vel = base_odom.twist.twist.angular.z;\n\tdouble trans_vel = base_odom.twist.twist.linear.x;\n\tif(rot_vel <= rot_stopped_velocity && trans_vel <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 52.288555226185466}, {"code": "bool stopped(const nav_msgs::Odometry& base_odom, \n      const double& rot_stopped_velocity, const double& trans_stopped_velocity)\tif (base_odom.twist.twist.angular.z <= rot_stopped_velocity && base_odom.twist.twist.linear.x <= trans_stopped_velocity) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 46.26302680301632}]}
{"instance_id": "f80c5118823c", "generation_result": [{"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (restore_defaults) {\n\t\t// Reset the configuration to default limits\n\t\tconfig = LocalPlannerLimits();\n\t}\n\n\tif (!setup) {\n\t\t// Initialize the default limits with the provided configuration\n\t\tdefault_limits = config;\n\t\tsetup = true;\n\t}\n\n\t// Lock the configuration mutex and update the current limits with the new configuration\n\tstd::lock_guard<std::mutex> lock(mutex);\n\tcurrent_limits = config;\n}\n", "CodeBleu_score": 43.11821373007915}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\t// If the setup flag is true and restore_defaults is requested, it resets the configuration to default limits.\n\tif (setup_ && restore_defaults) {\n\t\tconfig = default_limits_;\n\t}\n\t// If setup is not yet done, it initializes the default limits with the provided configuration and sets up the flag.\n\telse if (!setup_) {\n\t\tdefault_limits_ = config;\n\t\tsetup_ = true;\n\t}\n\t// Finally, it locks the configuration mutex and updates the current limits with the new configuration.\n\telse {\n\t\tstd::lock_guard<std::mutex> lock(configuration_mutex_);\n\t\tcurrent_limits_ = config;\n\t}\n}\n", "CodeBleu_score": 67.7113083214212}, {"code": "void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)\tif (setup_) {\n\t\tif (restore_defaults) {\n\t\t\tconfig.restoreDefaults();\n\t\t}\n\t\telse {\n\t\t\tconfig.setup(config);\n\t\t}\n\t}\n\telse {\n\t\tsetup_ = true;\n\t\tconfig.setup(config);\n\t}\n\n\tconfig_mutex_.lock();\n\tcurrent_limits_ = config;\n\tconfig_mutex_.unlock();\n}\n", "CodeBleu_score": 45.622472152786166}]}
{"instance_id": "f826f9eac433", "generation_result": [{"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\t// Check if the cell is an obstacle or has no information\n\tif (costmap.getCost(check_cell->x, check_cell->y) == costmap_2d::NO_INFORMATION ||\n\t\tcostmap.getCost(check_cell->x, check_cell->y) == costmap_2d::LETHAL_OBSTACLE) {\n\t\t// Set the target distance to the maximum obstacle cost\n\t\tcheck_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance\n\tfloat new_target_distance = current_cell->target_distance + costmap.getCost(check_cell->x, check_cell->y);\n\n\t// Check if the new distance is shorter\n\tif (new_target_distance < check_cell->target_distance) {\n\t\t// Update the target distance\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\t// The new distance is not shorter\n\treturn false;\n}\n", "CodeBleu_score": 50.537400142293976}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\t// Get the cost of the cell.\n\tunsigned char cell_cost = costmap.getCost(check_cell->x, check_cell->y);\n\n\t// If the cell is an obstacle, set the target distance to the maximum obstacle cost.\n\tif (cell_cost == costmap_2d::NO_INFORMATION || cell_cost >= costmap.getCostmap()->getCharMap().size() - 1) {\n\t\tcheck_cell->target_distance = std::numeric_limits<float>::max();\n\t\treturn false;\n\t}\n\n\t// Calculate the new target distance.\n\tfloat new_target_distance = current_cell->target_distance + costmap.getCostmap()->getCharMap().size() - cell_cost;\n\n\t// If the new target distance is shorter, update the cell's target distance.\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n", "CodeBleu_score": 55.63648046176236}, {"code": "inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,\n      const costmap_2d::Costmap2D& costmap)\t// If the cell is an obstacle or has no information, set the target distance to the maximum obstacle cost and return false.\n\tif (check_cell->cost == costmap_2d::NO_INFORMATION || check_cell->cost == costmap_2d::LETHAL_OBSTACLE) {\n\t\tcheck_cell->target_distance = costmap.getCost(check_cell->x, check_cell->y);\n\t\treturn false;\n\t}\n\n\t// Calculate a new target distance and update the cell's target distance if the new distance is shorter.\n\tfloat new_target_distance = calculateTargetDistance(current_cell, check_cell);\n\tif (new_target_distance < check_cell->target_distance) {\n\t\tcheck_cell->target_distance = new_target_distance;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 52.453403762509666}]}
{"instance_id": "0e460baae05f", "generation_result": [{"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\t//initialize cost and scaling factor\n\tdouble cost = 0;\n\tdouble scaling_factor = 1;\n\tif (traj.getSpeed() < 0.0001) {\n\t\tROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: speed is too small\");\n\t\treturn -9;\n\t}\n\tscaling_factor = 1 / traj.getSpeed();\n\t//if footprint is empty, log error and return -9\n\tif (footprint_.empty()) {\n\t\tROS_ERROR(\"ObstacleCostFunction::scoreTrajectory: footprint is empty\");\n\t\treturn -9;\n\t}\n\t//for each point in the trajectory\n\tfor (int i = 0; i < traj.getPoints().size(); i++) {\n\t\t//calculate footprint cost\n\t\tdouble footprint_cost = footprintCost(traj.getPoints()[i]);\n\t\t//if footprint cost is negative, return cost immediately\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t}\n\t\t//otherwise, either sum the scores or take the maximum score\n\t\tif (sum_scores_) {\n\t\t\tcost += footprint_cost * scaling_factor;\n\t\t} else {\n\t\t\tif (footprint_cost * scaling_factor > cost) {\n\t\t\t\tcost = footprint_cost * scaling_factor;\n\t\t\t}\n\t\t}\n\t}\n\t//return total cost\n\treturn cost;\n}\n", "CodeBleu_score": 46.416355684878084}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tif (traj.footprint.size() == 0) {\n\t\tROS_ERROR(\"Footprint is empty.\");\n\t\treturn -9;\n\t}\n\n\tdouble cost = 0.0;\n\tdouble scaling = 0.0;\n\n\t// Initialize cost and scaling factor\n\tif (traj.speed > 0) {\n\t\tscaling = traj.speed;\n\t} else {\n\t\tscaling = 1.0;\n\t}\n\n\t// Calculate footprint cost for each point\n\tfor (int i = 0; i < traj.footprint.size(); i++) {\n\t\tdouble footprint_cost = footprintCost(traj.footprint[i]);\n\t\tif (footprint_cost < 0) {\n\t\t\treturn footprint_cost;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return cost\n\treturn cost * scaling;\n}\n", "CodeBleu_score": 42.87669372734485}, {"code": "double ObstacleCostFunction::scoreTrajectory(Trajectory &traj)\tdouble cost = 0.0;\n\tdouble scaling_factor = 0.0;\n\tif (traj.footprint_spec.empty()) {\n\t\tROS_ERROR(\"Footprint specification is empty. Cannot score trajectory.\");\n\t\treturn -9;\n\t}\n\t// Initialize cost and scaling factor based on the trajectory and speed parameters.\n\tif (traj.v_max > 0.0) {\n\t\tscaling_factor = traj.v_max * traj.dt;\n\t} else {\n\t\tscaling_factor = 1.0;\n\t}\n\t// For each point in the trajectory, calculate the footprint cost.\n\tfor (unsigned int i = 0; i < traj.x.size(); i++) {\n\t\tdouble footprint_cost = footprintCost(traj.x[i], traj.y[i], traj.yaw[i], traj.dt);\n\t\tif (footprint_cost < 0.0) {\n\t\t\treturn cost;\n\t\t} else {\n\t\t\tif (sum_scores_) {\n\t\t\t\tcost += footprint_cost * scaling_factor;\n\t\t\t} else {\n\t\t\t\tcost = std::max(cost, footprint_cost * scaling_factor);\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}\n", "CodeBleu_score": 44.334859548069595}]}
{"instance_id": "8c6b01297181", "generation_result": [{"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\tdouble max_cost = -1.0;\n\tdouble cost = -1.0;\n\tgeometry_msgs::Point footprint_point;\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\tfootprint_point.x = footprint_spec[i].x;\n\t\tfootprint_point.y = footprint_spec[i].y;\n\t\tfootprint_point.z = footprint_spec[i].z;\n\t\tcost = world_model->footprintCost(footprint_point, x, y, th, scale, costmap);\n\t\tif (cost > max_cost) {\n\t\t\tmax_cost = cost;\n\t\t}\n\t}\n\tif (max_cost < 0) {\n\t\treturn -6.0;\n\t}\n\tif (!costmap->worldToMap(x, y, ix, iy)) {\n\t\treturn -7.0;\n\t}\n\tdouble cell_cost = costmap->getCost(ix, iy);\n\tif (max_cost > cell_cost) {\n\t\treturn max_cost;\n\t}\n\treturn cell_cost;\n}\n", "CodeBleu_score": 63.00747576945681}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\t// TODO Auto-generated constructor stub\n\tdouble footprint_cost = 0.0;\n\tdouble cell_cost = 0.0;\n\tdouble max_cost = 0.0;\n\tdouble wx = 0.0;\n\tdouble wy = 0.0;\n\tdouble cost = 0.0;\n\tunsigned int mx = 0;\n\tunsigned int my = 0;\n\n\t// Get the footprint cost\n\tfor (unsigned int i = 0; i < footprint_spec.size(); ++i) {\n\t\twx = x + (footprint_spec[i].x * cos(th) - footprint_spec[i].y * sin(th));\n\t\twy = y + (footprint_spec[i].x * sin(th) + footprint_spec[i].y * cos(th));\n\n\t\t// Get the map coordinates of the point\n\t\tif (!costmap->worldToMap(wx, wy, mx, my)) {\n\t\t\treturn -7.0;\n\t\t}\n\n\t\t// Get the footprint cell cost\n\t\tcost = (double) costmap->getCost(mx, my);\n\t\tif (cost >= costmap_2d::LETHAL_OBSTACLE) {\n\t\t\treturn -6.0;\n\t\t}\n\t\tfootprint_cost += cost;\n\t}\n\n\t// Get the cell cost at the given position\n\tif (!costmap->worldToMap(x, y, mx, my)) {\n\t\treturn -7.0;\n\t}\n\tcell_cost = (double) costmap->getCost(mx, my);\n\n\t// Get the maximum cost between the footprint cost and the cell cost\n\tmax_cost = std::max(footprint_cost, cell_cost);\n\n\t// Return the scaled maximum cost\n\treturn scale * max_cost;\n}\n", "CodeBleu_score": 59.470720220205145}, {"code": "double ObstacleCostFunction::footprintCost (\n    const double& x,\n    const double& y,\n    const double& th,\n    double scale,\n    std::vector<geometry_msgs::Point> footprint_spec,\n    costmap_2d::Costmap2D* costmap,\n    base_local_planner::WorldModel* world_model)\t// Get the footprint of the robot\n\tstd::vector<geometry_msgs::Point> footprint = footprint_spec;\n\n\t// Scale the footprint\n\tfor (int i = 0; i < footprint.size(); i++) {\n\t\tfootprint[i].x *= scale;\n\t\tfootprint[i].y *= scale;\n\t}\n\n\t// Get the footprint cost\n\tdouble footprint_cost = world_model->footprintCost(x, y, th, footprint);\n\n\t// Check if the footprint cost is negative\n\tif (footprint_cost < 0) {\n\t\treturn -6.0;\n\t}\n\n\t// Check if the position is off the map\n\tif (!costmap->worldToMap(x, y, x, y)) {\n\t\treturn -7.0;\n\t}\n\n\t// Get the cell cost\n\tunsigned int mx, my;\n\tcostmap->worldToMap(x, y, mx, my);\n\tunsigned char cell_cost = costmap->getCost(mx, my);\n\n\t// Return the maximum cost between the footprint cost and the cell cost\n\treturn std::max(footprint_cost, cell_cost);\n}\n", "CodeBleu_score": 62.681532808748216}]}
{"instance_id": "a1427185da52", "generation_result": [{"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (odom_topic_.empty()) {\n\t\t\tif (odom_sub_.get()) {\n\t\t\t\todom_sub_.shutdown();\n\t\t\t\todom_sub_.reset();\n\t\t\t}\n\t\t} else {\n\t\t\tif (odom_sub_.get() == NULL) {\n\t\t\t\todom_sub_.reset(new OdometrySubscriber(odom_topic_, 1, &OdometryHelperRos::odomCallback, this));\n\t\t\t} else {\n\t\t\t\todom_sub_->unsubscribe();\n\t\t\t\todom_sub_->subscribe(odom_topic_, 1);\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.19356646304439}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic!= odom_topic_name) {\n\t\tif (odom_topic!= \"\") {\n\t\t\todom_topic_name = odom_topic;\n\t\t\todom_sub = nh.subscribe(odom_topic, 1, &OdometryHelperRos::odomCallback, this);\n\t\t} else {\n\t\t\todom_topic_name = odom_topic;\n\t\t\todom_sub.shutdown();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 38.28620076725223}, {"code": "void OdometryHelperRos::setOdomTopic(std::string odom_topic)\tif (odom_topic!= odom_topic_) {\n\t\todom_topic_ = odom_topic;\n\t\tif (odom_topic_.empty()) {\n\t\t\todom_sub_.shutdown();\n\t\t} else {\n\t\t\todom_sub_ = nh_.subscribe(odom_topic_, 1, &OdometryHelperRos::odomCallback, this);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.5461774904008}]}
{"instance_id": "328bb3066bf7", "generation_result": [{"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\tfloat squaredDistance = (pos - prev).squaredNorm();\n\tfloat angleDifference = std::acos(pos.dot(prev) / (pos.norm() * prev.norm()));\n\n\tif (squaredDistance > _squaredDistanceThreshold || angleDifference > _angleThreshold) {\n\t\t_oscillationFlags = OscillationFlags::NONE;\n\t}\n}\n", "CodeBleu_score": 30.002111951919264}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\t// calculate the squared distance between the current and previous position\n\tfloat dist = (pos - prev).squaredNorm();\n\n\t// calculate the angular difference between the current and previous position\n\tfloat angle = std::acos(std::min(1.0f, std::max(-1.0f, Eigen::Vector3f::UnitZ().dot(pos.normalized()))));\n\n\t// check if the squared distance exceeds a threshold or the angular difference is greater than a set angle\n\tif (dist > _resetOscillationDistanceThreshold || angle > _resetOscillationAngleThreshold) {\n\t\t// reset the oscillation flags\n\t\t_oscillationFlags = OscillationFlags::NONE;\n\t}\n}\n", "CodeBleu_score": 27.267003367752267}, {"code": "void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev)\t// Calculate squared distance between current and previous positions\n\tfloat squaredDistance = (pos - prev).squaredNorm();\n\t// Calculate angular difference between current and previous positions\n\tfloat angularDifference = (pos - prev).normalized().dot(prev.normalized());\n\n\t// If the squared distance exceeds a threshold or the angular difference is greater than a set angle, reset the oscillation flags\n\tif (squaredDistance > squaredDistanceThreshold || angularDifference > angularDifferenceThreshold) {\n\t\tisOscillating = false;\n\t\tisMoving = false;\n\t}\n}\n", "CodeBleu_score": 27.23580278536329}]}
{"instance_id": "51049617b91b", "generation_result": [{"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// Determine the grid coordinates of the point\n\tint x_coord = (pt.x - x_min_) / x_res_;\n\tint y_coord = (pt.y - y_min_) / y_res_;\n\tint z_coord = (pt.z - z_min_) / z_res_;\n\n\t// Check if the point is outside the grid bounds\n\tif (x_coord < 0 || x_coord >= x_dim_ || y_coord < 0 || y_coord >= y_dim_ || z_coord < 0 || z_coord >= z_dim_) {\n\t\treturn;\n\t}\n\n\t// Check if the point is too close to its nearest neighbor\n\tfloat dist_to_nearest_neighbor = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 33.801772482925244}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\tint x_index = (int) (floor(pt.x / cell_size_x));\n\tint y_index = (int) (floor(pt.y / cell_size_y));\n\tint z_index = (int) (floor(pt.z / cell_size_z));\n\n\tif (x_index < 0 || x_index >= grid_size_x || y_index < 0 || y_index >= grid_size_y || z_index < 0 || z_index >= grid_size_z) {\n\t\treturn;\n\t}\n\n\tint index = getIndex(x_index, y_index, z_index);\n\n\tif (index < 0 || index >= grid_size) {\n\t\treturn;\n\t}\n\n\tif (cells[index].size() == 0) {\n\t\tcells[index].push_back(pt);\n\t} else {\n\t\tdouble min_dist = 1000000000;\n\t\tfor (int i = 0; i < cells[index].size(); i++) {\n\t\t\tdouble dist = getDistance(pt, cells[index][i]);\n\t\t\tif (dist < min_dist) {\n\t\t\t\tmin_dist = dist;\n\t\t\t}\n\t\t}\n\t\tif (min_dist > min_dist_threshold) {\n\t\t\tcells[index].push_back(pt);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 41.87539342667475}, {"code": "void PointGrid::insert(const geometry_msgs::Point32& pt)\t// determine grid coordinates\n\tint x, y, z;\n\tgrid_coords(pt, x, y, z);\n\n\t// check if point is inside grid bounds\n\tif (x < 0 || x >= nx_ || y < 0 || y >= ny_ || z < 0 || z >= nz_) {\n\t\treturn;\n\t}\n\n\t// check if point is too close to a neighbor\n\tif (too_close(pt, x, y, z)) {\n\t\treturn;\n\t}\n\n\t// calculate grid index\n\tint i = x + nx_ * (y + ny_ * z);\n\n\t// insert point into grid\n\tgrid_[i].push_back(pt);\n}\n", "CodeBleu_score": 43.96670019228667}]}
{"instance_id": "bd34be6d6931", "generation_result": [{"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = vel[i] + acclimits[i] * dt;\n\t\t\tif (new_vel[i] > sample_target_vel[i]) {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t}\n\t\t} else if (sample_target_vel[i] < vel[i]) {\n\t\t\tnew_vel[i] = vel[i] - acclimits[i] * dt;\n\t\t\tif (new_vel[i] < sample_target_vel[i]) {\n\t\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 67.18055674095608}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\t// Initialize a new velocity vector to zero\n\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\n\t// For each of the three velocity components, increase or decrease the current velocity towards the target velocity within the acceleration limits\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel(i) > vel(i)) {\n\t\t\tif (vel(i) + acclimits(i) * dt < sample_target_vel(i)) {\n\t\t\t\tnew_vel(i) = vel(i) + acclimits(i) * dt;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t\t}\n\t\t}\n\t\telse if (sample_target_vel(i) < vel(i)) {\n\t\t\tif (vel(i) - acclimits(i) * dt > sample_target_vel(i)) {\n\t\t\t\tnew_vel(i) = vel(i) - acclimits(i) * dt;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnew_vel(i) = sample_target_vel(i);\n\t\t}\n\t}\n\n\treturn new_vel;\n}\n", "CodeBleu_score": 49.918628179085964}, {"code": "Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,\n    const Eigen::Vector3f& vel, Eigen::Vector3f acclimits, double dt)\tEigen::Vector3f new_vel;\n\tnew_vel.setZero();\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (sample_target_vel[i] > vel[i]) {\n\t\t\tnew_vel[i] = std::min(vel[i] + acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t\telse if (sample_target_vel[i] < vel[i]) {\n\t\t\tnew_vel[i] = std::max(vel[i] - acclimits[i] * dt, sample_target_vel[i]);\n\t\t}\n\t\telse {\n\t\t\tnew_vel[i] = sample_target_vel[i];\n\t\t}\n\t}\n\treturn new_vel;\n}\n", "CodeBleu_score": 68.61428499083424}]}
{"instance_id": "e15bd73d0415", "generation_result": [{"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\t//std::cout << \"Heading Diff: \" << cell_x << \", \" << cell_y << \", \" << x << \", \" << y << \", \" << heading << std::endl;\n\tdouble diff = DBL_MAX;\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\tif (global_plan[i].x == cell_x && global_plan[i].y == cell_y) {\n\t\t\tbreak;\n\t\t}\n\t\tif (global_plan[i].x == -1 && global_plan[i].y == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\t//std::cout << \"Comparing: \" << global_plan[i].x << \", \" << global_plan[i].y << \" to \" << x << \", \" << y << std::endl;\n\t\tdouble dx = x - global_plan[i].x;\n\t\tdouble dy = y - global_plan[i].y;\n\t\tdouble dist = sqrt(dx*dx + dy*dy);\n\t\tdouble angle = atan2(dy, dx);\n\t\t//std::cout << \"Distance: \" << dist << \", Angle: \" << angle << std::endl;\n\t\tif (dist > 1.0) {\n\t\t\tdiff = angle - heading;\n\t\t\tdiff = std::fmod(diff + M_PI, 2.0*M_PI) - M_PI;\n\t\t\t//std::cout << \"Diff: \" << diff << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diff;\n}\n", "CodeBleu_score": 46.19284737352078}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble diff = DBL_MAX;\n\tfor (int i = global_plan.size() - 1; i >= 0; i--) {\n\t\tif (global_plan[i].x == cell_x && global_plan[i].y == cell_y) {\n\t\t\tdiff = std::abs(atan2(y - global_plan[i].y, x - global_plan[i].x) - heading);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diff;\n}\n", "CodeBleu_score": 35.38990629648123}, {"code": "double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading)\tdouble dx = x - cell_x;\n\tdouble dy = y - cell_y;\n\tdouble angle = atan2(dy, dx);\n\tdouble diff = heading - angle;\n\tif (diff > M_PI) {\n\t\tdiff = diff - 2 * M_PI;\n\t}\n\tif (diff < -M_PI) {\n\t\tdiff = diff + 2 * M_PI;\n\t}\n\treturn abs(diff);\n}\n", "CodeBleu_score": 21.92965344695481}]}
{"instance_id": "f64442fc88fb", "generation_result": [{"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t} else {\n\t\tROS_WARN_STREAM(\"Trajectory cost: \" << cost << \" vx: \" << vx_samp << \" vy: \" << vy_samp << \" vtheta: \" << vtheta_samp);\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 72.65929839469597}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\tdouble cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n\tif (cost >= 0) {\n\t\treturn true;\n\t}\n\telse {\n\t\tROS_WARN(\"Trajectory cost: %f\", cost);\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 69.34719676815288}, {"code": "bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,\n      double vtheta, double vx_samp, double vy_samp, double vtheta_samp)\t// TODO: Fill in this function\n  double cost = scoreTrajectory(x, y, theta, vx, vy, vtheta, vx_samp, vy_samp, vtheta_samp);\n  if(cost >= 0) {\n    return true;\n  } else {\n    ROS_WARN(\"Trajectory is invalid: cost = %f\", cost);\n    return false;\n  }\n}\n", "CodeBleu_score": 74.37098636389328}]}
{"instance_id": "f553316a468e", "generation_result": [{"code": "void ClearCostmapRecovery::runBehavior()\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"This object must be initialized with a global and local costmap\");\n\t\treturn;\n\t}\n\n\t// Log the costmap clearing behavior\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"Clearing the global and local costmaps inside the specified area\");\n\t} else {\n\t\tROS_WARN(\"Clearing the global and local costmaps outside the specified area\");\n\t}\n\n\t// Clear the costmaps\n\tROS_INFO(\"Clearing the global costmap\");\n\tif (affected_maps_ & CLEAR_GLOBAL_COSTMAP) {\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->resetMap();\n\t\t} else {\n\t\t\tglobal_costmap_->clearCostmap();\n\t\t}\n\t}\n\tROS_INFO(\"Clearing the local costmap\");\n\tif (affected_maps_ & CLEAR_LOCAL_COSTMAP) {\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->resetMap();\n\t\t} else {\n\t\t\tlocal_costmap_->clearCostmap();\n\t\t}\n\t}\n\n\t// Log the time taken for each operation\n\tROS_INFO(\"Clearing the global costmap took %.4f seconds\", (ros::Time::now() - global_costmap_start_time_).toSec());\n\tROS_INFO(\"Clearing the local costmap took %.4f seconds\", (ros::Time::now() - local_costmap_start_time_).toSec());\n}\n\n} // namespace clear_costmap_recovery", "CodeBleu_score": 48.27653520496178}, {"code": "void ClearCostmapRecovery::runBehavior()\t// Check if object is initialized\n\tif (!initialized_) {\n\t\tROS_ERROR(\"ClearCostmapRecovery: Object not initialized, unable to run clear costmap behavior.\");\n\t\treturn;\n\t}\n\n\t// Check if costmaps are NULL\n\tif (global_costmap_ == NULL || local_costmap_ == NULL) {\n\t\tROS_ERROR(\"ClearCostmapRecovery: Costmaps are NULL, unable to run clear costmap behavior.\");\n\t\treturn;\n\t}\n\n\t// Log warning about clearing inside or outside area\n\tif (invert_area_to_clear_) {\n\t\tROS_WARN(\"ClearCostmapRecovery: Clearing inside specified area.\");\n\t} else {\n\t\tROS_WARN(\"ClearCostmapRecovery: Clearing outside specified area.\");\n\t}\n\n\t// Clear costmaps\n\tros::Time clear_start = ros::Time::now();\n\tif (affected_maps_ & GLOBAL_COSTMAP) {\n\t\tROS_INFO(\"ClearCostmapRecovery: Clearing global costmap.\");\n\t\tif (force_update_) {\n\t\t\tglobal_costmap_->updateMap();\n\t\t}\n\t\tglobal_costmap_->resetMap(invert_area_to_clear_);\n\t}\n\tif (affected_maps_ & LOCAL_COSTMAP) {\n\t\tROS_INFO(\"ClearCostmapRecovery: Clearing local costmap.\");\n\t\tif (force_update_) {\n\t\t\tlocal_costmap_->updateMap();\n\t\t}\n\t\tlocal_costmap_->resetMap(invert_area_to_clear_);\n\t}\n\tros::Time clear_end = ros::Time::now();\n\n\t// Log time taken for each operation\n\tROS_INFO(\"ClearCostmapRecovery: Clearing costmaps took %f seconds.\", (clear_end - clear_start).toSec());\n}\n", "CodeBleu_score": 46.49800037207782}, {"code": "void ClearCostmapRecovery::runBehavior()\tif (!initialized_) {\n\t\tROS_ERROR(\"This object must be initialized before runBehavior is called\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL) {\n\t\tROS_ERROR(\"The global_costmap_ is not set, calling runBehavior on it without setting the costmap will likely lead to errors\");\n\t\treturn;\n\t}\n\n\tif (local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The local_costmap_ is not set, calling runBehavior on it without setting the costmap will likely lead to errors\");\n\t\treturn;\n\t}\n\n\tif (global_costmap_ == NULL && local_costmap_ == NULL) {\n\t\tROS_ERROR(\"The global_costmap_ and local_costmap_ are not set, calling runBehavior on it without setting the costmaps will likely lead to errors\");\n\t\treturn;\n\t}\n\n\t// Set the global costmap to be cleared\n\tbool clear_global_costmap = false;\n\tif (affected_maps_ & CLEAR_GLOBAL_COSTMAP) {\n\t\tclear_global_costmap = true;\n\t}\n\n\t// Set the local costmap to be cleared\n\tbool clear_local_costmap = false;\n\tif (affected_maps_ & CLEAR_LOCAL_COSTMAP) {\n\t\tclear_local_costmap = true;\n\t}\n\n\t// Set the area to be cleared\n\tgeometry_msgs::PolygonStamped area_to_clear;\n\tif (affected_maps_ & CLEAR_AREA) {\n\t\tarea_to_clear = area_to_clear_;\n\t}\n\n\t// Set the force_update flag\n\tbool force_update = false;\n\tif (affected_maps_ & FORCE_UPDATE) {\n\t\tforce_update = true;\n\t}\n\n\t// Set the clear_inside flag\n\tbool clear_inside = false;\n\tif (affected_maps_ & CLEAR_INSIDE) {\n\t\tclear_inside = true;\n\t}\n\n\t// Set the clear_outside flag\n\tbool clear_outside = false;\n\tif (affected_maps_ & CLEAR_OUTSIDE) {\n\t\tclear_outside = true;\n\t}\n\n\t// Set the clear_unknown flag\n\tbool clear_unknown", "CodeBleu_score": 42.3663640818509}]}
{"instance_id": "a89157df3cad", "generation_result": [{"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\t// TODO: Implement\n\t//std::cout << \"polygonOutlineCells\" << std::endl;\n\t//std::cout << \"polygonOutlineCells: polygon.size(): \" << polygon.size() << std::endl;\n\tif (polygon.size() > 0) {\n\t\tMapLocation first = polygon[0];\n\t\tMapLocation last = polygon[polygon.size() - 1];\n\t\t//std::cout << \"polygonOutlineCells: first: \" << first.x << \", \" << first.y << std::endl;\n\t\t//std::cout << \"polygonOutlineCells: last: \" << last.x << \", \" << last.y << std::endl;\n\t\tif (first == last) {\n\t\t\tpolygon_cells.push_back(first);\n\t\t\t//std::cout << \"polygonOutlineCells: polygon_cells.size(): \" << polygon_cells.size() << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tMapLocation current;\n\t\tfor (int i = 0; i < polygon.size() - 1; i++) {\n\t\t\tcurrent = polygon[i];\n\t\t\t//std::cout << \"polygonOutlineCells: current: \" << current.x << \", \" << current.y << std::endl;\n\t\t\traytraceLine(current, polygon[i + 1], polygon_cells);\n\t\t}\n\t\tcurrent = polygon[polygon.size() - 1];\n\t\t//std::cout << \"polygonOutlineCells: current: \" << current.x << \", \" << current.y << std::endl;\n\t\traytraceLine(current, first, polygon_cells);\n\t\t//std::cout << \"polygonOutlineCells: polygon_cells.size(): \" << polygon_cells.size() << std::endl;\n\t}\n}\n", "CodeBleu_score": 51.32295180353348}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\t//std::cout << \"polygonOutlineCells\" << std::endl;\n\tPolygonOutlineCells polygon_outline_cells(this);\n\tif (!polygon.empty()) {\n\t\tMapLocation first = polygon.front();\n\t\tMapLocation last = polygon.back();\n\t\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\t\tMapLocation current = polygon[i];\n\t\t\tMapLocation next = polygon[i + 1];\n\t\t\traytraceLine(current, next, polygon_outline_cells);\n\t\t}\n\t\tif (first!= last) {\n\t\t\traytraceLine(last, first, polygon_outline_cells);\n\t\t}\n\t}\n\tpolygon_cells = polygon_outline_cells.getPolygonOutlineCells();\n}\n", "CodeBleu_score": 51.71594408996951}, {"code": "void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)\tif (polygon.size() > 0) {\n\t\tMapLocation first = polygon[0];\n\t\tMapLocation last = polygon[polygon.size() - 1];\n\t\tfor (unsigned int i = 0; i < polygon.size() - 1; i++) {\n\t\t\tMapLocation current = polygon[i];\n\t\t\tMapLocation next = polygon[i + 1];\n\t\t\traytraceLine(current, next, polygon_cells);\n\t\t}\n\t\traytraceLine(last, first, polygon_cells);\n\t}\n}\n", "CodeBleu_score": 50.03398162856193}]}
{"instance_id": "10e1ddf5f77d", "generation_result": [{"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t//prepare the grid data\n\tprepareGrid();\n\n\t//publish the prepared grid data\n\tpub.publish(grid);\n}\n", "CodeBleu_score": 60.999076027827705}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t// prepareGrid is called to set up the grid data\n\tprepareGrid();\n\t// publish the prepared grid\n\tpub.publish(grid_data_);\n}\n", "CodeBleu_score": 57.04014716178754}, {"code": "void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)\t//ROS_INFO(\"Costmap2DPublisher::onNewSubscription\");\n\t// Prepare the grid data\n\tprepareGrid();\n\t// Publish the prepared grid\n\tpub.publish(grid);\n}\n", "CodeBleu_score": 56.73676267194245}]}
{"instance_id": "bc176301608b", "generation_result": [{"code": "void Costmap2DPublisher::prepareGrid()\t// lock the costmap mutex\n\tcostmap_2d::Costmap2D* costmap = layered_costmap_->getCostmap();\n\tcostmap->lock();\n\n\t// get the resolution\n\tdouble resolution = costmap->getResolution();\n\n\t// set the grid header\n\tgrid_msg_.header.stamp = ros::Time::now();\n\tgrid_msg_.header.frame_id = costmap->getGlobalFrameID();\n\n\t// set the resolution\n\tgrid_msg_.info.resolution = resolution;\n\n\t// set the width and height\n\tgrid_msg_.info.width = costmap->getSizeInCellsX();\n\tgrid_msg_.info.height = costmap->getSizeInCellsY();\n\n\t// convert the map coordinates to world coordinates for the origin\n\tgeometry_msgs::Pose origin = costmap->getOrigin();\n\ttf::poseStampedTFToMsg(origin, grid_msg_.info.origin);\n\n\t// save the origin coordinates\n\torigin_x_ = origin.position.x;\n\torigin_y_ = origin.position.y;\n\n\t// resize the grid data vector\n\tgrid_msg_.data.resize(grid_msg_.info.width * grid_msg_.info.height);\n\n\t// populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < costmap->getSizeInCellsX(); ++i) {\n\t\tfor (unsigned int j = 0; j < costmap->getSizeInCellsY(); ++j) {\n\t\t\tunsigned int index = i + j * costmap->getSizeInCellsX();\n\t\t\tgrid_msg_.data[index] = costmap_translation_table_[costmap->getCharMapValue(i, j)];\n\t\t}\n\t}\n\n\t// unlock the costmap mutex\n\tcostmap->unlock();\n}\n", "CodeBleu_score": 53.94636083482941}, {"code": "void Costmap2DPublisher::prepareGrid()\t// Lock the costmap mutex\n\tboost::unique_lock<costmap_2d::Costmap2D::mutex_t> lock(*(costmap_->getMutex()));\n\n\t// Get the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the header\n\tgrid_.header.frame_id = global_frame_;\n\tgrid_.header.stamp = ros::Time::now();\n\n\t// Set the resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tcostmap_->mapToWorld(0, 0, grid_.info.origin.position.x, grid_.info.origin.position.y);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_x_ = grid_.info.origin.position.x;\n\torigin_y_ = grid_.info.origin.position.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map\n\tfor (unsigned int i = 0; i < grid_.info.width; i++) {\n\t\tfor (unsigned int j = 0; j < grid_.info.height; j++) {\n\t\t\t// Get the cost value\n\t\t\tunsigned char cost = costmap_->getCost(i, j);\n\n\t\t\t// Translate the cost value to the grid data\n\t\t\tgrid_.data[i + (j * grid_.info.width)] = cost_translation_table_[cost];\n\t\t}\n\t}\n}\n", "CodeBleu_score": 64.26014888904356}, {"code": "void Costmap2DPublisher::prepareGrid()\t// Lock the costmap mutex\n\tcostmap_mutex.lock();\n\n\t// Retrieve the resolution\n\tdouble resolution = costmap_->getResolution();\n\n\t// Set the grid's header\n\tgrid_.header.stamp = ros::Time::now();\n\tgrid_.header.frame_id = frame_id_;\n\n\t// Set the resolution, width, and height\n\tgrid_.info.resolution = resolution;\n\tgrid_.info.width = costmap_->getSizeInCellsX();\n\tgrid_.info.height = costmap_->getSizeInCellsY();\n\n\t// Convert the map coordinates to world coordinates for the origin\n\tcostmap_2d::MapLocation origin = costmap_->mapToWorld(0, 0);\n\n\t// Set the origin's position and orientation\n\tgrid_.info.origin.position.x = origin.x;\n\tgrid_.info.origin.position.y = origin.y;\n\tgrid_.info.origin.position.z = 0.0;\n\tgrid_.info.origin.orientation.x = 0.0;\n\tgrid_.info.origin.orientation.y = 0.0;\n\tgrid_.info.origin.orientation.z = 0.0;\n\tgrid_.info.origin.orientation.w = 1.0;\n\n\t// Save the origin coordinates\n\torigin_x_ = origin.x;\n\torigin_y_ = origin.y;\n\n\t// Resize the grid data vector\n\tgrid_.data.resize(grid_.info.width * grid_.info.height);\n\n\t// Populate the grid data from the costmap's character map using a translation table\n\tfor (unsigned int i = 0; i < grid_.info.height; i++) {\n\t\tfor (unsigned int j = 0; j < grid_.info.width; j++) {\n\t\t\tgrid_.data[i * grid_.info.width + j] = costmap_translation_table_[costmap_->getCharMapValue(j, i)];\n\t\t}\n\t}\n\n\t// Unlock the costmap mutex\n\tcostmap_mutex.unlock();\n}\n", "CodeBleu_score": 56.40482651378236}]}
{"instance_id": "5e4677d452b7", "generation_result": [{"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\t// If the footprint and robot radius in the new and old configurations are the same, it returns immediately.\n\tif (new_config.footprint == old_config.footprint && new_config.inflation_radius == old_config.inflation_radius) {\n\t\treturn;\n\t}\n\n\t// If the new configuration contains a valid footprint string, it converts the string to a footprint and sets it.\n\tif (new_config.footprint.size() > 0) {\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tif (costmap_2d::readFootprintFromConfig(new_config.footprint, footprint)) {\n\t\t\tsetFootprint(footprint);\n\t\t} else {\n\t\t\tROS_ERROR(\"The footprint provided to the costmap2DROS plugin is not a valid polygon and will be ignored.\");\n\t\t}\n\t} else {\n\t\t// If the footprint string is invalid, it logs an error.\n\t\tif (new_config.inflation_radius!= old_config.inflation_radius) {\n\t\t\tROS_ERROR(\"The inflation radius provided to the costmap2DROS plugin is invalid and will be ignored.\");\n\t\t}\n\n\t\t// If no valid footprint string is provided, it sets the footprint based on the robot radius.\n\t\tstd::vector<geometry_msgs::Point> footprint;\n\t\tfootprint.push_back(geometry_msgs::Point(new_config.inflation_radius, 0.0, 0.0));\n\t\tfootprint.push_back(geometry_msgs::Point(new_config.inflation_radius, new_config.inflation_radius, 0.0));\n\t\tfootprint.push_back(geometry_msgs::Point(0.0, new_config.inflation_radius, 0.0));\n\t\tfootprint.push_back(geometry_msgs::Point(-new_config.inflation_radius, new_config.inflation_radius, 0.0));\n\t\tfootprint.push_back(geometry_msgs::Point(-new_config.inflation_radius, 0.0, 0.0));\n\t\tfootprint.push_back(geometry_msgs::Point(-new_", "CodeBleu_score": 48.07655889938566}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\t// if the footprint and robot radius are the same, return\n\tif (new_config.footprint.size() == old_config.footprint.size() && new_config.inscribed_radius == old_config.inscribed_radius && new_config.circumscribed_radius == old_config.circumscribed_radius) {\n\t\treturn;\n\t}\n\n\t// if the footprint is valid, convert the string to a footprint and set it\n\tif (new_config.footprint.size() > 0) {\n\t\tif (!costmap_2d::readFootprint(new_config.footprint, robot_footprint_)) {\n\t\t\tROS_ERROR(\"The footprint string is invalid.  Using default footprint.\");\n\t\t\trobot_footprint_ = robot_radius_;\n\t\t}\n\t} else {\n\t\t// if the footprint string is invalid, log an error\n\t\tROS_ERROR(\"The footprint string is invalid.  Using default footprint.\");\n\t\trobot_footprint_ = robot_radius_;\n\t}\n}\n", "CodeBleu_score": 53.21329798747667}, {"code": "void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,\n                                           const costmap_2d::Costmap2DConfig &old_config)\tif (new_config.footprint.size() == old_config.footprint.size() && new_config.inscribed_radius == old_config.inscribed_radius) {\n\t\treturn;\n\t}\n\n\tif (new_config.footprint.size() > 0) {\n\t\tif (readFootprintFromConfig(new_config.footprint)) {\n\t\t\tROS_INFO(\"New footprint loaded from parameter server\");\n\t\t} else {\n\t\t\tROS_ERROR(\"Invalid footprint string in parameter server\");\n\t\t}\n\t} else {\n\t\tROS_INFO(\"No footprint provided. Using default.\");\n\t\tif (readFootprintFromConfig(old_config.footprint)) {\n\t\t\tROS_INFO(\"Using default footprint\");\n\t\t} else {\n\t\t\tROS_ERROR(\"Invalid default footprint\");\n\t\t}\n\t}\n}\n", "CodeBleu_score": 51.07449842970001}]}
{"instance_id": "b059bebd3800", "generation_result": [{"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\tif (!new_pose_received_) {\n\t\t// Get the robot's current pose.\n\t\ttf::Stamped<tf::Pose> robot_pose;\n\t\ttry {\n\t\t\ttf_listener_.lookupTransform(global_frame_, base_frame_, ros::Time(0), robot_pose);\n\t\t} catch (tf::TransformException &ex) {\n\t\t\tROS_WARN(\"Received a transform that could not be used to update the costmap: %s\", ex.what());\n\t\t\treturn;\n\t\t}\n\n\t\t// Convert the pose to the costmap's frame.\n\t\ttf::Stamped<tf::Pose> global_pose = robot_pose;\n\t\ttf_.transformPose(global_frame_, global_pose, global_pose);\n\n\t\t// Store the pose.\n\t\tnew_pose_ = global_pose;\n\t\tnew_pose_received_ = true;\n\t}\n}\n", "CodeBleu_score": 40.368313293160014}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\tif (!new_pose_available_) {\n\t\tnew_pose_available_ = true;\n\t\tif (!getRobotPose(new_pose_)) {\n\t\t\tROS_WARN(\"Failed to get robot pose.\");\n\t\t\tcancelReconfigure();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 52.55477533482772}, {"code": "void Costmap2DROS::movementCB(const ros::TimerEvent &event)\tif (robot_stopped_) {\n\t\t// If the robot is stopped, we don't need to do anything.\n\t\treturn;\n\t}\n\t// If we're not currently reconfiguring, we don't need to do anything.\n\tif (!reconfiguring_) {\n\t\treturn;\n\t}\n\t// Attempt to get the robot's current pose.\n\tif (getRobotPose(new_pose_)) {\n\t\t// If we successfully retrieved the pose, we're done reconfiguring.\n\t\treconfiguring_ = false;\n\t\treturn;\n\t}\n\t// If we failed to retrieve the pose, log a warning message and cancel reconfiguration.\n\tROS_WARN(\"Failed to retrieve robot pose. Canceling reconfiguration.\");\n\treconfigure_server_->setAborted();\n\treconfiguring_ = false;\n}\n", "CodeBleu_score": 45.26916419026968}]}
{"instance_id": "923b41db08fa", "generation_result": [{"code": "void Costmap2DROS::start()\t// Check if costmap is stopped\n\tif (stopped_) {\n\t\t// Get list of plugins\n\t\tstd::vector<boost::shared_ptr<Plugin> > plugins;\n\t\tplugin_loader_.getPlugins(plugins);\n\n\t\t// Check if costmap is stopped\n\t\tfor (unsigned int i = 0; i < plugins.size(); ++i) {\n\t\t\t// Check if plugin is stopped\n\t\t\tif (plugins[i]->isStopped()) {\n\t\t\t\t// Activate plugin\n\t\t\t\tplugins[i]->activate();\n\n\t\t\t\t// Check if plugin is a subscriber\n\t\t\t\tif (dynamic_cast<SubscriberPlugin*>(plugins[i].get())!= NULL) {\n\t\t\t\t\t// Cast plugin to subscriber plugin\n\t\t\t\t\tSubscriberPlugin* sub_plugin = dynamic_cast<SubscriberPlugin*>(plugins[i].get());\n\n\t\t\t\t\t// Subscribe to topic\n\t\t\t\t\tsub_plugin->subscribe();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set stopped flag to false\n\t\tstopped_ = false;\n\t}\n\n\t// Wait until ROS is running\n\twhile (!ros::isInitialized()) {\n\t\t// Sleep for a second\n\t\tusleep(1000000);\n\t}\n\n\t// Check if costmap is initialized\n\tif (!initialized_) {\n\t\t// Initialize costmap\n\t\tinitialize();\n\t}\n\n\t// Check if map update thread is active\n\tif (!map_update_thread_active_) {\n\t\t// Start map update thread\n\t\tmap_update_thread_ = boost::thread(boost::bind(&Costmap2DROS::mapUpdateLoop, this));\n\n\t\t// Set map update thread active flag\n\t\tmap_update_thread_active_ = true;\n\t}\n}\n", "CodeBleu_score": 48.96864206296355}, {"code": "void Costmap2DROS::start()\tif (stopped_) {\n\t\tstopped_ = false;\n\t\t// \u91cd\u65b0\u8ba2\u9605\n\t\tfor (std::vector<boost::shared_ptr<Costmap2DROSPlugin> >::iterator plugin_it = plugins_.begin(); plugin_it!= plugins_.end(); ++plugin_it) {\n\t\t\tplugin_it->get()->activate();\n\t\t}\n\t\tstop_updates_ = false;\n\t\t// \u7b49\u5f85ROS\u8fd0\u884c\n\t\twhile (!ros::isInitialized()) {\n\t\t\tif (stop_updates_) {\n\t\t\t\tROS_ERROR(\"Costmap2DROS: stop_updates_ is set to true, terminating costmap update thread.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tROS_INFO(\"Costmap2DROS: Waiting for ROS to initialize.\");\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t\t// \u7b49\u5f85\u5730\u56fe\u521d\u59cb\u5316\n\t\twhile (map_.info.width == 0 || map_.info.height == 0) {\n\t\t\tif (stop_updates_) {\n\t\t\t\tROS_ERROR(\"Costmap2DROS: stop_updates_ is set to true, terminating costmap update thread.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tROS_INFO(\"Costmap2DROS: Waiting for map to be initialized...\");\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t\t// \u7b49\u5f85\u5730\u56fe\u66f4\u65b0\u7ebf\u7a0b\n\t\twhile (!map_update_thread_running_) {\n\t\t\tif (stop_updates_) {\n\t\t\t\tROS_ERROR(\"Costmap2DROS: stop_updates_ is set to true, terminating costmap update thread.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tROS_INFO(\"Costmap2DROS: Waiting for map update thread to start.\");\n\t\t\tros::spinOnce();\n\t\t\tloop_rate_.sleep();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 49.961474477666556}, {"code": "void Costmap2DROS::start()\t// Get the list of plugins\n\tstd::vector<std::string> plugins = plugin_loader_.getDeclaredClasses();\n\n\t// Check if the costmap was stopped\n\tif (stopped_) {\n\t\t// Re-subscribe to topics\n\t\tfor (std::vector<std::string>::iterator plugin_it = plugins.begin(); plugin_it!= plugins.end(); ++plugin_it) {\n\t\t\t// Get the plugin\n\t\t\tboost::shared_ptr<Costmap2DPlugin> plugin = plugin_loader_.createInstance(*plugin_it);\n\n\t\t\t// Set the plugin to be active\n\t\t\tplugin->set_active(true);\n\n\t\t\t// Add the plugin to the list of active plugins\n\t\t\tactive_plugins_.push_back(plugin);\n\n\t\t\t// Subscribe to the topic\n\t\t\tplugin->subscribe();\n\t\t}\n\n\t\t// Set the stopped flag to false\n\t\tstopped_ = false;\n\t}\n\n\t// Set stop_updates_ to false\n\tstop_updates_ = false;\n\n\t// Wait until ROS is running\n\twhile (!ros::isInitialized()) {\n\t\t// Sleep for a second\n\t\tros::Duration(1.0).sleep();\n\n\t\t// Check if the costmap should stop\n\t\tif (stop_updates_) {\n\t\t\t// Stop the costmap\n\t\t\tstop();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Wait until the costmap is initialized\n\twhile (!is_initialized_) {\n\t\t// Sleep for a second\n\t\tros::Duration(1.0).sleep();\n\n\t\t// Check if the costmap should stop\n\t\tif (stop_updates_) {\n\t\t\t// Stop the costmap\n\t\t\tstop();\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Wait until the map update thread is active\n\twhile (!map_update_thread_active_) {\n\t\t// Sleep for a second\n\t\tros::Duration(1.0).sleep();\n\n\t\t// Check if the costmap should stop\n\t\tif (stop_updates_) {\n\t\t\t// Stop the costmap\n\t\t\tstop();\n\t\t\treturn;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 49.672574694744}]}
{"instance_id": "7f33ea4f2b6c", "generation_result": [{"code": "void ObservationBuffer::purgeStaleObservations()\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\n\t// Iterate through the list and remove observations that are older than the specified keep time\n\tfor (std::list<Observation>::iterator it = observations_.begin(); it!= observations_.end();) {\n\t\tif (it->time_stamp_ < (ros::Time::now() - observation_keep_time_)) {\n\t\t\tit = observations_.erase(it);\n\t\t} else {\n\t\t\tit++;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.275262412436504}, {"code": "void ObservationBuffer::purgeStaleObservations()\t// If the observation_keep_time_ is zero, it keeps only the most recent observation.\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\n\t// Otherwise, it iterates through the list and removes observations that are older than the specified keep time, stopping once it finds a valid observation.\n\tfor (std::list<Observation>::iterator it = observations_.begin(); it!= observations_.end();) {\n\t\tif (it->time_stamp_ < (ros::Time::now() - ros::Duration(observation_keep_time_))) {\n\t\t\tit = observations_.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 36.544139622138}, {"code": "void ObservationBuffer::purgeStaleObservations()\t// If the keep time is zero, we don't need to purge anything.\n\tif (observation_keep_time_ == 0) {\n\t\treturn;\n\t}\n\n\t// Iterate through the list of observations.\n\tfor (auto it = observations_.begin(); it!= observations_.end(); it++) {\n\t\t// If the current observation is older than the keep time, remove it.\n\t\tif (it->first < ros::Time::now() - observation_keep_time_) {\n\t\t\tobservations_.erase(it);\n\t\t\treturn;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.16366186781207}]}
{"instance_id": "71ce07e3ac3c", "generation_result": [{"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\t// Calculate the yaw angles at the start and end indices\n\tdouble start_yaw = tf::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between them\n\tdouble angular_distance = shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose\n\tdouble increment = angular_distance / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range accordingly\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble new_yaw = start_yaw + increment * (i - start_index);\n\t\ttf::Quaternion new_orientation = tf::createQuaternionFromYaw(new_yaw);\n\t\tpath[i].pose.orientation.x = new_orientation.x();\n\t\tpath[i].pose.orientation.y = new_orientation.y();\n\t\tpath[i].pose.orientation.z = new_orientation.z();\n\t\tpath[i].pose.orientation.w = new_orientation.w();\n\t}\n}\n", "CodeBleu_score": 59.60908972508043}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\t// Get the yaw angles at the start and end indices\n\tdouble start_yaw = tf::getYaw(path[start_index].pose.orientation);\n\tdouble end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\n\t// Determine the shortest angular distance between them\n\tdouble delta_yaw = shortest_angular_distance(start_yaw, end_yaw);\n\n\t// Compute the incremental change in angle for each pose\n\tdouble delta_angle = delta_yaw / (end_index - start_index);\n\n\t// Update the orientation of each pose in the specified range accordingly\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tdouble new_yaw = start_yaw + (i - start_index) * delta_angle;\n\t\ttf::Quaternion new_orientation = tf::createQuaternionFromYaw(new_yaw);\n\t\tpath[i].pose.orientation.x = new_orientation.x();\n\t\tpath[i].pose.orientation.y = new_orientation.y();\n\t\tpath[i].pose.orientation.z = new_orientation.z();\n\t\tpath[i].pose.orientation.w = new_orientation.w();\n\t}\n}\n", "CodeBleu_score": 55.01693374761095}, {"code": "void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, \n                                    int start_index, int end_index)\tfloat start_yaw = tf::getYaw(path[start_index].pose.orientation);\n\tfloat end_yaw = tf::getYaw(path[end_index].pose.orientation);\n\tfloat angle_diff = end_yaw - start_yaw;\n\tfloat angle_diff_short = angle_diff;\n\tif (angle_diff > M_PI) {\n\t\tangle_diff_short = angle_diff - 2 * M_PI;\n\t} else if (angle_diff < -M_PI) {\n\t\tangle_diff_short = angle_diff + 2 * M_PI;\n\t}\n\tfloat angle_diff_increment = angle_diff_short / (end_index - start_index);\n\tfor (int i = start_index + 1; i < end_index; i++) {\n\t\tpath[i].pose.orientation = tf::createQuaternionMsgFromYaw(start_yaw + (i - start_index) * angle_diff_increment);\n\t}\n}\n", "CodeBleu_score": 53.25755258199707}]}
{"instance_id": "627b7bd5cdcc", "generation_result": [{"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\t// Set the frame_id of the start and goal to \"map\"\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// Call makePlan to generate a path\n\tif (makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\t// Update the response with the success status and the generated path if a plan is found\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.plan.header.frame_id = \"map\";\n\t\tresp.error_code.val = resp.error_code.SUCCESS;\n\t\treturn true;\n\t}\n\t// If no plan is found, update the response with the failure status\n\tresp.error_code.val = resp.error_code.PLANNING_FAILED;\n\treturn false;\n}\n", "CodeBleu_score": 45.761088393990846}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\tif(!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn false;\n\t}\n\n\t// get the starting pose of the robot\n\tgeometry_msgs::PoseStamped start;\n\tstart.header.frame_id = req.start.header.frame_id;\n\tstart.header.stamp = ros::Time::now();\n\tstart.pose = req.start.pose;\n\n\t// get the goal pose of the robot\n\tgeometry_msgs::PoseStamped goal;\n\tgoal.header.frame_id = req.goal.header.frame_id;\n\tgoal.header.stamp = ros::Time::now();\n\tgoal.pose = req.goal.pose;\n\n\t// make sure the goal pose is valid\n\tif(!isGoalPoseValid(goal)) {\n\t\tROS_ERROR(\"The goal pose passed to the planner is invalid. Planning to this goal may result in planning failures.\");\n\t\tresp.plan.poses.clear();\n\t\tresp.error_code = resp.INVALID_GOAL;\n\t\treturn true;\n\t}\n\n\t// make sure the goal pose is valid\n\tif(!isStartPoseValid(start)) {\n\t\tROS_ERROR(\"The start pose passed to the planner is invalid. Planning to this start may result in planning failures.\");\n\t\tresp.plan.poses.clear();\n\t\tresp.error_code = resp.INVALID_START;\n\t\treturn true;\n\t}\n\n\t// get the plan\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tbool success = makePlan(start, goal, plan);\n\n\tif(success) {\n\t\t// set the plan\n\t\tresp.plan.poses.clear();\n\t\tresp.plan.poses.resize(plan.size());\n\t\tfor(unsigned int i = 0; i < plan.size(); ++i) {\n\t\t\tresp.plan.poses[i] = plan[i];\n\t\t}\n\t\tresp.error_code = resp.SUCCESS;\n\t} else {\n\t\tROS_ERROR(\"Failed to find a plan to the goal\");\n\t\tresp.plan.poses.clear();\n\t\tresp.error_code = resp.NO_PLAN_FOUND;\n\t}\n\n\t", "CodeBleu_score": 43.68895831847962}, {"code": "bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp)\t// set the frame_id of the start and goal to \"map\"\n\t// this is needed for the global planner\n\treq.start.header.frame_id = \"map\";\n\treq.goal.header.frame_id = \"map\";\n\n\t// call makePlan to generate a path\n\tif (makePlan(req.start, req.goal, resp.plan.poses)) {\n\t\tresp.plan.header.stamp = ros::Time::now();\n\t\tresp.plan.header.frame_id = \"map\";\n\t\tresp.error_code = resp.error_code.SUCCESS;\n\t\treturn true;\n\t}\n\telse {\n\t\tROS_ERROR(\"No plan found.\");\n\t\tresp.error_code = resp.error_code.NO_PLAN_FOUND;\n\t\treturn false;\n\t}\n}\n", "CodeBleu_score": 45.109504412611265}]}
{"instance_id": "2375e2cf5e04", "generation_result": [{"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\tros::NodeHandle private_nh(\"~/\" + name);\n\tros::NodeHandle nh;\n\n\t// Create the service\n\tmake_plan_srv_ = nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n\t// Subscribe to the goal topic\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n}\n", "CodeBleu_score": 56.66003379992289}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\tros::NodeHandle nh;\n\tros::NodeHandle private_nh(\"~/\" + name);\n\n\t// Create the ROS wrapper for the planner's costmap, and initialize the costmap to be an empty 2D grid\n\tcostmap_ros_ = cmap;\n\n\t// Create a service for the planner\n\tmake_plan_srv_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\n\t// Create a subscriber for the planner's goal point\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCB, this);\n\n\t// Initialize the planner's start and goal positions\n\tstart_ = geometry_msgs::PoseStamped();\n\tgoal_ = geometry_msgs::PoseStamped();\n\n\t// Initialize the planner's current plan\n\tcurrent_plan_ = std::vector<geometry_msgs::PoseStamped>();\n}\n", "CodeBleu_score": 56.77857142565518}, {"code": "PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :\n        GlobalPlanner(name, cmap->getCostmap(), cmap->getGlobalFrameID())\tros::NodeHandle private_nh(\"~/\" + name);\n\tmake_plan_service_ = private_nh.advertiseService(\"make_plan\", &PlannerWithCostmap::makePlanService, this);\n\tgoal_sub_ = private_nh.subscribe<geometry_msgs::PoseStamped>(\"goal\", 1, &PlannerWithCostmap::goalCallback, this);\n}\n", "CodeBleu_score": 63.91010566068211}]}
{"instance_id": "dd43b1eec476", "generation_result": [{"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\t// check if the world coordinates are within the bounds of the costmap's origin\n\tif (wx < origin_x_ || wy < origin_y_) {\n\t\tROS_ERROR(\"The world coordinates (%f, %f) are out of bounds!\", wx, wy);\n\t\treturn false;\n\t}\n\n\t// calculate the map coordinates using the costmap's resolution and an offset\n\tmx = (wx - origin_x_) / resolution_;\n\tmy = (wy - origin_y_) / resolution_;\n\n\t// check if the map coordinates are within the costmap's size limits\n\tif (mx < 0 || my < 0 || mx >= width_ || my >= height_) {\n\t\tROS_ERROR(\"The map coordinates (%f, %f) are out of bounds!\", mx, my);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 43.40721819238762}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (wx < origin_x_ || wy < origin_y_) {\n\t\tROS_WARN(\"The world coordinates passed to costmap_2d::worldToMap are out of bounds.\\n\"\n\t\t\t\t\"World coordinate ( %f, %f ) is out of bounds. The costmap bounds are ( %f, %f ) to ( %f, %f ).\",\n\t\t\t\twx, wy, origin_x_, origin_y_, (origin_x_ + (double) width_ * resolution_), (origin_y_ + (double) height_ * resolution_));\n\t\treturn false;\n\t}\n\n\tmx = (wx - origin_x_) / resolution_;\n\tmy = (wy - origin_y_) / resolution_;\n\n\tif (mx < 0 || my < 0 || mx >= width_ || my >= height_) {\n\t\tROS_WARN(\"The map coordinates passed to costmap_2d::worldToMap are out of bounds.\\n\"\n\t\t\t\t\"Map coordinate ( %f, %f ) is out of bounds. The costmap is %d X %d.\", mx, my, width_, height_);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 45.9387837232671}, {"code": "bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my)\tif (wx < world_size_x_ / 2.0 && wx > -world_size_x_ / 2.0 && wy < world_size_y_ / 2.0 && wy > -world_size_y_ / 2.0) {\n\t\tmx = wx / resolution_x_ + origin_x_;\n\t\tmy = wy / resolution_y_ + origin_y_;\n\t\treturn true;\n\t}\n\treturn false;\n}\n", "CodeBleu_score": 25.514775243202127}]}
{"instance_id": "a872b0e4c5a1", "generation_result": [{"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized, please call initialize() before using this planner\");\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path with the path, which we will then publish\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the position from the path's poses\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\t// Publish the path\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 84.28659084725064}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path with the plan to publish\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the plan in world co-ordinates, we assume the path is all in the same frame\n\tfor (unsigned int i = 0; i < path.size(); ++i) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 89.71608726818081}, {"code": "void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) \tif (!initialized_) {\n\t\tROS_ERROR(\"This planner has not been initialized yet, but it is being used, please call initialize() before use\");\n\t\treturn;\n\t}\n\n\t// Create a nav_msgs::Path with the given parameters\n\tnav_msgs::Path gui_path;\n\tgui_path.poses.resize(path.size());\n\tgui_path.header.frame_id = frame_id_;\n\tgui_path.header.stamp = ros::Time::now();\n\n\t// Extract the position from the pose and put it into the Path message\n\tfor (unsigned int i = 0; i < path.size(); i++) {\n\t\tgui_path.poses[i] = path[i];\n\t}\n\n\t// Publish the path\n\tplan_pub_.publish(gui_path);\n}\n", "CodeBleu_score": 91.20790545614979}]}
{"instance_id": "d951b6aa5415", "generation_result": [{"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\t// Create an action message to send to the action server\n\tMoveBaseActionGoal action_goal;\n\taction_goal.header.stamp = ros::Time::now();\n\taction_goal.goal.target_pose = *goal;\n\n\t// Log a message indicating that the goal has been received\n\tROS_INFO_STREAM(\"Received a new goal from the Planner: \" << action_goal.goal.target_pose);\n\n\t// Publish the goal to the action server\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 65.92339186964111}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\t// Create a MoveBaseActionGoal\n\tmove_base_msgs::MoveBaseActionGoal goal_msg;\n\n\t// Set the timestamp to the current time\n\tgoal_msg.header.stamp = ros::Time::now();\n\n\t// Set the goal pose\n\tgoal_msg.goal.target_pose = *goal;\n\n\t// Publish the action goal\n\taction_goal_pub_.publish(goal_msg);\n\n\t// Log a debug message indicating it is wrapping the goal in an action message\n\tROS_DEBUG(\"MoveBase::goalCB: Wrapping the goal in an action message.\");\n}\n", "CodeBleu_score": 60.73483291721451}, {"code": "void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal)\t// Log a debug message indicating the goal has been received.\n\tROS_DEBUG_NAMED(\"move_base\", \"Received a goal of x: %f, y: %f, theta: %f\", goal->pose.position.x, goal->pose.position.y, goal->pose.orientation.w);\n\n\t// Create a MoveBaseActionGoal message.\n\tmove_base_msgs::MoveBaseActionGoal action_goal;\n\n\t// Set the timestamp to the current time.\n\taction_goal.header.stamp = ros::Time::now();\n\n\t// Assign the received goal to the target_pose.\n\taction_goal.goal.target_pose = *goal;\n\n\t// Publish the action goal to the action_goal_pub_ topic.\n\taction_goal_pub_.publish(action_goal);\n}\n", "CodeBleu_score": 68.30589281966961}]}
{"instance_id": "c0a0aa52bf2a", "generation_result": [{"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tif (this->distanceMovedSquared > this->distanceLimitSquared) {\n\t\tROS_INFO(\"Distance limit reached, stopping distance check\");\n\t\tthis->distanceCheckTimer.stop();\n\t\tthis->removeLimitThread = boost::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tthis->removeLimitThread.join();\n\t\tthis->stop();\n\t}\n}\n", "CodeBleu_score": 22.085916554412364}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\tif (pow(distanceLimit, 2) < pow(currentDistance, 2)) {\n\t\tROS_INFO(\"Robot moved enough to clear the distance limit.\");\n\t\tif (removeLimitThread.joinable()) {\n\t\t\tremoveLimitThread.join();\n\t\t}\n\t\tremoveLimitThread = std::thread(&MoveSlowAndClear::removeLimit, this);\n\t\tdistanceCheckTimer.stop();\n\t}\n}\n", "CodeBleu_score": 47.05764647327225}, {"code": "void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)\t//ROS_INFO(\"Distance check\");\n\tif(ros::Duration(e.current_real).toSec() > 1) {\n\t\tif(this->currentDistance < this->limitedDistance) {\n\t\t\tROS_INFO(\"Robot has moved far enough. Stopping distance check.\");\n\t\t\tthis->distanceCheckTimer.stop();\n\t\t\tthis->removeLimitThread.join();\n\t\t\tthis->removeLimitThread = boost::thread(boost::bind(&MoveSlowAndClear::removeLimit, this));\n\t\t}\n\t}\n}\n", "CodeBleu_score": 35.67915896359692}]}
{"instance_id": "1dfe1160ebc8", "generation_result": [{"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\t// Get the current pose of the robot\n\tgeometry_msgs::PoseStamped global_pose = *getRobotPose();\n\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tmakePlan(global_pose, *goal, plan);\n\n\t// Publish the path to the topic /move_base/NavfnROS/plan\n\tpublishPlan(plan);\n}\n", "CodeBleu_score": 50.000277074507714}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\tROS_INFO(\"Goal received\");\n\t// get the current pose of the robot\n\ttf::Stamped<tf::Pose> global_pose;\n\tgetRobotPose(global_pose);\n\t// create a vector of PoseStamped to store the path\n\tstd::vector<geometry_msgs::PoseStamped> path;\n\t// call makePlan with the global pose, goal pose, and empty path vector\n\tmakePlan(global_pose, goal, path);\n}\n", "CodeBleu_score": 53.60776000766043}, {"code": "void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal)\tROS_INFO(\"poseCallback\");\n\t// Get the current global pose of the robot\n\tgeometry_msgs::PoseStamped global_pose = *getRobotPose();\n\t// Generate a path from the current pose to the goal pose\n\tstd::vector<geometry_msgs::PoseStamped> plan;\n\tmakePlan(global_pose, *goal, plan);\n\t// Publish the path\n\tpublishPlan(plan);\n}\n", "CodeBleu_score": 50.81324102671281}]}
{"instance_id": "b676d86cb556", "generation_result": [{"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\t// Create a param_set service request\n\tmavros_msgs::ParamSet srv;\n\tsrv.request.param_id = param_set.param_id;\n\tsrv.request.value = param_set.param_value;\n\t// Send the param_set service request\n\tif (param_set_client_.call(srv)) {\n\t\tROS_INFO(\"Gimbal parameter set: %s\", srv.response.success? \"success\" : \"failure\");\n\t}\n\telse {\n\t\tROS_ERROR(\"Failed to call service param_set\");\n\t}\n}\n", "CodeBleu_score": 60.46861657539267}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.param_value = param_set.param_value;\n\tparam_set_srv.request.target_system = param_set.target_system;\n\tparam_set_srv.request.target_component = param_set.target_component;\n\tparam_set_srv.request.param_type = param_set.param_type;\n\tparam_set_client_.call(param_set_srv);\n}\n", "CodeBleu_score": 49.718344203847195}, {"code": "void AutonomousLanding::gimbalParamSetServer(struct GimbalParamSet param_set)\tmavros_msgs::ParamSet param_set_srv;\n\tparam_set_srv.request.param_id = param_set.param_id;\n\tparam_set_srv.request.value = param_set.value;\n\tparam_set_srv.request.param_type = param_set.param_type;\n\n\tparam_set_client_.call(param_set_srv);\n}\n", "CodeBleu_score": 54.66874454677908}]}
{"instance_id": "62e31971c89c", "generation_result": [{"code": "void CommunicationBridge::serverFun()\tint serverSocket, newSocket;\n\tstruct sockaddr_in serverAddr;\n\tstruct sockaddr_storage serverStorage;\n\tsocklen_t addr_size;\n\tchar buffer[256];\n\tint n;\n\n\t/*Create the socket.*/\n\tserverSocket = socket(PF_INET, SOCK_STREAM, 0);\n\n\t/*Configure settings of the server address struct.*/\n\t/*Address family = Internet.*/\n\tserverAddr.sin_family = AF_INET;\n\t/*Set port number, using htons function to use proper byte order.*/\n\tserverAddr.sin_port = htons(PORT);\n\t/*Set IP address to localhost */\n\tserverAddr.sin_addr.s_addr = inet_addr(IP_ADDRESS);\n\t/*Set all bits of the padding field to 0*/\n\tmemset(serverAddr.sin_zero, '\\0', sizeof serverAddr.sin_zero);\n\n\t/*Bind the address struct to the socket.*/\n\tbind(serverSocket, (struct sockaddr *) &serverAddr, sizeof(serverAddr));\n\n\t/*Listen on the socket, with 40 max connection requests queued.*/\n\tif (listen(serverSocket, 40)!= 0) {\n\t\tstd::cout << \"Error: Could not listen on socket\" << std::endl;\n\t}\n\n\t/*Accept call creates a new socket for the incoming connection*/\n\taddr_size = sizeof serverStorage;\n\tnewSocket = accept(serverSocket, (struct sockaddr *) &serverStorage, &addr_size);\n\n\t/*If connection is accepted, display server details*/\n\tstd::cout << \"Connection accepted\" << std::endl;\n\tstd::cout << \"IP: \" << inet_ntoa(serverStorage.ss_family) << std::endl;\n\n\t/*Receive data from the socket*/\n\tn = recv(newSocket, buffer, 256, 0);\n\tif (n < 0) {\n\t\tstd::cout << \"Error: Could not receive data\" << std::endl;\n\t}\n\n\t/*Print the received message*/\n\tstd::cout << \"Received: \" << buffer << std::endl;\n\n\t/*Decode the message and publish it*/\n\tstd::string message = buffer;\n\tstd::string delimiter = \",\";\n\tstd::", "CodeBleu_score": 39.16294417656185}, {"code": "void CommunicationBridge::serverFun()\t// Create a socket\n\tint server_socket;\n\tserver_socket = socket(AF_INET, SOCK_STREAM, 0);\n\n\t// Set socket options\n\tint enable = 1;\n\tsetsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int));\n\n\t// Define the server address\n\tstruct sockaddr_in server_address;\n\tserver_address.sin_family = AF_INET;\n\tserver_address.sin_addr.s_addr = INADDR_ANY;\n\tserver_address.sin_port = htons(PORT);\n\n\t// Bind the socket to the server address\n\tbind(server_socket, (struct sockaddr*) &server_address, sizeof(server_address));\n\n\t// Listen for incoming connections\n\tlisten(server_socket, 10);\n\n\t// Accept incoming connections\n\tstruct sockaddr_in client_address;\n\tsocklen_t client_address_length = sizeof(client_address);\n\tint client_socket = accept(server_socket, (struct sockaddr*) &client_address, &client_address_length);\n\n\t// Close the server socket\n\tclose(server_socket);\n\n\t// Loop to handle further connections\n\twhile (true) {\n\t\t// Receive data\n\t\tchar buffer[BUFFER_SIZE];\n\t\tint received_bytes = recv(client_socket, buffer, BUFFER_SIZE, 0);\n\n\t\t// Check if the received message is empty\n\t\tif (received_bytes <= 0) {\n\t\t\t// Log error and close socket\n\t\t\tstd::cout << \"Error: Received empty message\" << std::endl;\n\t\t\tclose(client_socket);\n\n\t\t\t// Exit the loop\n\t\t\tbreak;\n\t\t}\n\n\t\t// Decode the message\n\t\tstd::string message(buffer, received_bytes);\n\t\tstd::string decoded_message = decodeMessage(message);\n\n\t\t// Publish the decoded message\n\t\tstd::cout << \"Received message: \" << decoded_message << std::endl;\n\t\tthis->pub.publish(decoded_message);\n\t}\n}\n", "CodeBleu_score": 42.27307253855321}, {"code": "void CommunicationBridge::serverFun()\t// create a socket\n\tint server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\tif (server_socket < 0) {\n\t\tROS_ERROR(\"Error creating socket\");\n\t\treturn;\n\t}\n\n\t// bind the socket to the port\n\tstruct sockaddr_in server_address;\n\tserver_address.sin_family = AF_INET;\n\tserver_address.sin_port = htons(port);\n\tserver_address.sin_addr.s_addr = INADDR_ANY;\n\tint bind_result = bind(server_socket, (struct sockaddr *) &server_address, sizeof(server_address));\n\tif (bind_result < 0) {\n\t\tROS_ERROR(\"Error binding socket to port\");\n\t\treturn;\n\t}\n\n\t// listen for incoming connections\n\tint listen_result = listen(server_socket, 1);\n\tif (listen_result < 0) {\n\t\tROS_ERROR(\"Error listening for incoming connections\");\n\t\treturn;\n\t}\n\n\t// accept an incoming connection\n\tstruct sockaddr_in client_address;\n\tsocklen_t client_address_len = sizeof(client_address);\n\tint client_socket = accept(server_socket, (struct sockaddr *) &client_address, &client_address_len);\n\tif (client_socket < 0) {\n\t\tROS_ERROR(\"Error accepting incoming connection\");\n\t\treturn;\n\t}\n\n\t// receive data\n\tchar buffer[1024];\n\tint bytes_received;\n\twhile ((bytes_received = recv(client_socket, buffer, 1024, 0)) > 0) {\n\t\t// decode message\n\t\tstd::string message(buffer, bytes_received);\n\t\tstd::vector<std::string> message_parts = split(message, ':');\n\t\tif (message_parts.size()!= 2) {\n\t\t\tROS_ERROR(\"Invalid message received\");\n\t\t\tcontinue;\n\t\t}\n\t\tstd::string message_type = message_parts[0];\n\t\tstd::string message_data = message_parts[1];\n\n\t\t// publish message\n\t\tif (message_type == \"data\") {\n\t\t\tROS_INFO(\"Received data\");\n\t\t\tpublishData(message", "CodeBleu_score": 39.95789484985307}]}
{"instance_id": "5821c289e637", "generation_result": [{"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (simulation_mode_) {\n\t\t// find the UAV in the swarm_control_simulation_\n\t\tfor (auto uav : swarm_control_simulation_) {\n\t\t\tif (uav.ID == uav_cmd.ID) {\n\t\t\t\tuav_basic_.publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuav_basic_.publish(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 29.869007230507872}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (!simulation_mode_) {\n\t\tuav_basic_.publish(uav_cmd);\n\t} else {\n\t\t// Find the UAV with the given ID\n\t\tint i;\n\t\tfor (i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].uav_id == uav_cmd.uav_id) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == swarm_control_simulation_.size()) {\n\t\t\tROS_ERROR(\"UAV %d not found in simulation mode\", uav_cmd.uav_id);\n\t\t\treturn;\n\t\t}\n\t\t// Publish the command to the UAV\n\t\tswarm_control_simulation_[i].uav_basic.publish(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 39.095789935276954}, {"code": "void CommunicationBridge::recvData(struct UAVCommand uav_cmd)\tif (simulation_mode_) {\n\t\t// find the corresponding UAV by ID from swarm_control_simulation_\n\t\tfor (int i = 0; i < swarm_control_simulation_.size(); i++) {\n\t\t\tif (swarm_control_simulation_[i].uav_id == uav_cmd.uav_id) {\n\t\t\t\t// publish to the UAV\n\t\t\t\tuav_basic_pubs_[i].publish(uav_cmd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// publish to the UAV\n\t\tuav_basic_pub_.publish(uav_cmd);\n\t}\n}\n", "CodeBleu_score": 36.260609072121916}]}
{"instance_id": "5c3d44ff8f30", "generation_result": [{"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif (mode_selection.use_mode == REBOOTNX) {\n\t\t// Rebooting the NX\n\t\tsystem(\"rebootnx\");\n\t} else if (mode_selection.use_mode == EXITNX) {\n\t\t// Exiting the NX\n\t\tsystem(\"exitnx\");\n\t} else if (mode_selection.use_mode == CREATEMODE) {\n\t\t// Creating a new mode\n\t\tcreateMode(mode_selection.mode_name);\n\t} else if (mode_selection.use_mode == DELETEMODE) {\n\t\t// Deleting a mode\n\t\tdeleteMode(mode_selection.mode_name);\n\t}\n}\n", "CodeBleu_score": 48.99654624195555}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\tif(mode_selection.use_mode == REBOOTNX) {\n\t\tsystem(\"rebootnx\");\n\t} else if(mode_selection.use_mode == EXITNX) {\n\t\tsystem(\"exitnx\");\n\t} else if(mode_selection.use_mode == CREATEMODE) {\n\t\tcreateMode(mode_selection);\n\t} else if(mode_selection.use_mode == DELETEMODE) {\n\t\tdeleteMode(mode_selection);\n\t}\n}\n", "CodeBleu_score": 54.5671913594707}, {"code": "void CommunicationBridge::modeSwitch(struct ModeSelection mode_selection)\t// TODO: Implement mode switching\n\tif (mode_selection.use_mode == 0) {\n\t\t// RebootNX\n\t\tstd::string command = \"rebootnx\";\n\t\tsystem(command.c_str());\n\t} else if (mode_selection.use_mode == 1) {\n\t\t// ExitNX\n\t\tstd::string command = \"exitnx\";\n\t\tsystem(command.c_str());\n\t} else {\n\t\t// Create or delete mode\n\t\tif (mode_selection.use_mode == 2) {\n\t\t\t// Create mode\n\t\t\tcreateMode(mode_selection.mode_name);\n\t\t} else if (mode_selection.use_mode == 3) {\n\t\t\t// Delete mode\n\t\t\tdeleteMode(mode_selection.mode_name);\n\t\t}\n\t}\n}\n", "CodeBleu_score": 50.74384132416036}]}
{"instance_id": "bcf7b6ccf539", "generation_result": [{"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\tif (this->heartbeat_count == this->heartbeat_count_prev) {\n\t\tthis->heartbeat_count_prev = this->heartbeat_count;\n\t\tthis->heartbeat_count++;\n\t\tif (this->heartbeat_count > this->max_heartbeat_count) {\n\t\t\tif (this->vehicle_type == VehicleType::UAV) {\n\t\t\t\tROS_ERROR(\"No heartbeat from UAV, shutting down...\");\n\t\t\t\tthis->disconnect_flag = true;\n\t\t\t} else if (this->vehicle_type == VehicleType::UGV) {\n\t\t\t\tROS_ERROR(\"No heartbeat from UGV, shutting down...\");\n\t\t\t\tthis->disconnect_flag = true;\n\t\t\t} else if (this->vehicle_type == VehicleType::Swarm) {\n\t\t\t\tROS_ERROR(\"No heartbeat from swarm, shutting down...\");\n\t\t\t\tthis->disconnect_flag = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tthis->heartbeat_count_prev = this->heartbeat_count;\n\t\tthis->heartbeat_count = 0;\n\t}\n}\n", "CodeBleu_score": 21.207034293375436}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\t// Increment the heartbeat counter\n\theartbeat_counter++;\n\t// Check if the heartbeat counter has reached the maximum number of missed heartbeats\n\tif (heartbeat_counter >= MAX_HEARTBEAT_MISSES) {\n\t\t// Check if the vehicle is a swarm vehicle\n\t\tif (vehicle_type == \"swarm\") {\n\t\t\t// Check if the vehicle is a UAV\n\t\t\tif (vehicle_subtype == \"uav\") {\n\t\t\t\t// Print an error message\n\t\t\t\tROS_ERROR(\"UAV %d has not received a heartbeat for %d consecutive attempts. Disconnecting from the swarm.\", vehicle_id, MAX_HEARTBEAT_MISSES);\n\t\t\t\t// Set the disconnect flag to true\n\t\t\t\tdisconnect_flag = true;\n\t\t\t}\n\t\t\t// Check if the vehicle is an UGV\n\t\t\telse if (vehicle_subtype == \"ugv\") {\n\t\t\t\t// Print an error message\n\t\t\t\tROS_ERROR(\"UGV %d has not received a heartbeat for %d consecutive attempts. Disconnecting from the swarm.\", vehicle_id, MAX_HEARTBEAT_MISSES);\n\t\t\t\t// Set the disconnect flag to true\n\t\t\t\tdisconnect_flag = true;\n\t\t\t}\n\t\t}\n\t\t// Check if the vehicle is a UAV\n\t\telse if (vehicle_type == \"uav\") {\n\t\t\t// Print an error message\n\t\t\tROS_ERROR(\"UAV %d has not received a heartbeat for %d consecutive attempts. Disconnecting from the UAV.\", vehicle_id, MAX_HEARTBEAT_MISSES);\n\t\t\t// Set the disconnect flag to true\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t\t// Check if the vehicle is an UGV\n\t\telse if (vehicle_type == \"ugv\") {\n\t\t\t// Print an error message\n\t\t\tROS_ERROR(\"UGV %d has not received a heartbeat for %d consecutive attempts. Disconnecting from the UGV.\", vehicle_id, MAX_HEARTBEAT_MISSES);\n\t\t\t// Set the disconnect flag to true\n\t\t\tdisconnect_flag = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.43349711339957}, {"code": "void CommunicationBridge::checkHeartbeatState(const ros::TimerEvent &time_event)\t// If the heartbeat is not received for a specified number of attempts, print an error message and disconnect\n\tif (heartbeat_counter >= heartbeat_attempts) {\n\t\tROS_ERROR(\"Heartbeat not received for %d attempts. Disconnecting.\", heartbeat_counter);\n\t\tdisconnect_flag = true;\n\t}\n\t// If the heartbeat is received, reset the counter\n\telse {\n\t\theartbeat_counter = 0;\n\t}\n}\n", "CodeBleu_score": 15.935388888023427}]}
{"instance_id": "9902ba9e57ac", "generation_result": [{"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\t// Extract drone ID from message\n\tint drone_id = msg->drone_id;\n\n\t// Extract trajectory data from message\n\tstd::vector<prometheus_msgs::Trajectory> trajectories = msg->trajectories;\n\n\t// For each trajectory, initialize a Bspline struct\n\tstd::vector<Bspline> bsplines;\n\tfor (int i = 0; i < trajectories.size(); i++) {\n\t\tBspline bspline;\n\n\t\t// Set attributes\n\t\tbspline.drone_id = drone_id;\n\t\tbspline.trajectory_id = trajectories[i].trajectory_id;\n\t\tbspline.num_knots = trajectories[i].num_knots;\n\t\tbspline.num_position_points = trajectories[i].num_position_points;\n\t\tbspline.num_yaw_points = trajectories[i].num_yaw_points;\n\n\t\t// Populate knots\n\t\tbspline.knots = trajectories[i].knots;\n\n\t\t// Populate position points\n\t\tbspline.position_points = trajectories[i].position_points;\n\n\t\t// Populate yaw points\n\t\tbspline.yaw_points = trajectories[i].yaw_points;\n\n\t\t// Add bspline to vector\n\t\tbsplines.push_back(bspline);\n\t}\n\n\t// Encode MultiBsplines data\n\tstd::string data = encodeMultiBsplines(bsplines);\n\n\t// Send MultiBsplines data via TCP\n\tcommunication_module->sendTcp(data);\n}\n", "CodeBleu_score": 34.27434687940127}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\t// Get the drone ID from the message\n\tint droneId = msg->drone_id;\n\n\t// Create a Bspline struct for each trajectory in the message\n\tfor (int i = 0; i < msg->num_bsplines; i++) {\n\t\t// Initialize the Bspline struct\n\t\tBspline *bspline = new Bspline();\n\t\tbspline->droneId = droneId;\n\t\tbspline->numKnots = msg->num_knots;\n\t\tbspline->numPoints = msg->num_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg->num_yaw_points;\n\t\tbspline->numYawPoints = msg", "CodeBleu_score": 29.666203589662672}, {"code": "void EGOPlannerSwarm::multitrajSubTcpCb(const prometheus_msgs::MultiBsplines::ConstPtr &msg)\t//std::cout << \"MultiBsplines message received\" << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;\n\t//std::cout << \"Number of trajectories: \" << msg->trajectories.size() << std::endl;", "CodeBleu_score": 1.2565189736005007}]}
{"instance_id": "06a33ff38797", "generation_result": [{"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Create a pcl::PointCloud object to store the input message\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create an octree object\n\toctomap::OcTree octree(0.05);\n\n\t// Insert the points from the input message into the octree\n\tfor (const auto& point : cloud.points) {\n\t\toctree.insert(point.x, point.y, point.z);\n\t}\n\n\t// Compress the octree\n\toctree.updateInnerOccupancy();\n\toctree.prune();\n\n\t// Create a new PointCloud2 message to store the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Convert the compressed octree to a PointCloud2 message\n\toctree.toROSMsg(compressed_msg);\n\n\t// Return the compressed PointCloud2 message\n\treturn compressed_msg;\n}\n", "CodeBleu_score": 25.948600769998}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\t// Create a new PointCloud2 message to store the compressed data\n\tsensor_msgs::PointCloud2 compressed_msg;\n\n\t// Convert the input message to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\n\t// Create a new Octree object with a resolution of 0.01\n\tpcl::octree::OctreePointCloud<pcl::PointXYZ> octree(0.01);\n\n\t// Add the points to the octree\n\toctree.setInputCloud(cloud.makeShared());\n\toctree.addPointsFromInputCloud();\n\n\t// Create a new vector to store the compressed point indices\n\tstd::vector<int> compressed_indices;\n\n\t// Get the compressed point indices from the octree\n\toctree.getCompressedPointIndices(compressed_indices);\n\n\t// Create a new vector to store the compressed points\n\tstd::vector<pcl::PointXYZ> compressed_points;\n\n\t// Get the compressed points from the octree\n\toctree.getCompressedPointCloud(compressed_points);\n\n\t// Convert the compressed points to a PointCloud2 message\n\tpcl::toROSMsg(compressed_points, compressed_msg);\n\n\t// Set the header of the compressed message to the same as the input message\n\tcompressed_msg.header = msg.header;\n\n\t// Return the compressed message\n\treturn compressed_msg;\n}\n", "CodeBleu_score": 35.1003270979711}, {"code": "sensor_msgs::PointCloud2 ReduceTheFrequency::compressed(const sensor_msgs::PointCloud2 msg)\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(msg, cloud);\n\toctree.setInputCloud(cloud.makeShared());\n\toctree.defineBoundingBox();\n\toctree.addPointsFromInputCloud();\n\tstd::vector<int> point_idx_vec;\n\tpcl::PointIndices::Ptr indices(new pcl::PointIndices);\n\toctree.getPointIndicesFromNewVoxels(point_idx_vec, *indices);\n\tpcl::PointCloud<pcl::PointXYZ> cloud_filtered;\n\tpcl::copyPointCloud(cloud, *indices, cloud_filtered);\n\tpcl::toROSMsg(cloud_filtered, msg);\n\treturn msg;\n}\n", "CodeBleu_score": 29.58200643609752}]}
{"instance_id": "b40ab9b96523", "generation_result": [{"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 52.70485476797218}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 57.5763087166318}, {"code": "void SwarmControl::updateAllUAVState(struct UAVState uav_state)\tfor (int i = 0; i < multi_uav_state_.size(); i++) {\n\t\tif (multi_uav_state_[i].uav_id == uav_state.uav_id) {\n\t\t\tmulti_uav_state_[i] = uav_state;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 52.70485476797218}]}
{"instance_id": "2b10d764e7d1", "generation_result": [{"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\tMultiUGVState multi_ugv_state;\n\tUGVState ugv_state;\n\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_state_count; i++) {\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state.attitude.x = m_multi_ugv_state.ugv_state[i].attitude.x;\n\t\tugv_state.attitude.y = m_multi_ugv_state.ugv_state[i].attitude.y;\n\t\tugv_state.attitude.z = m_multi_ugv_state.ugv_state[i].attitude.z;\n\t\tugv_state.attitude.w = m_multi_ugv_state.ugv_state[i].attitude.w;\n\n\t\tmulti_ugv_state.ugv_state.push_back(ugv_state);\n\t}\n\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_state_count;\n\tm_pub_all_ugv_state.publish(multi_ugv_state);\n}\n", "CodeBleu_score": 42.9874299382384}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\tMultiUGVState multi_ugv_state;\n\tUGVState ugv_state;\n\tint i;\n\tfor (i = 0; i < m_multi_ugv_state.ugv_state_length; i++) {\n\t\tugv_state.id = m_multi_ugv_state.ugv_state[i].id;\n\t\tugv_state.battery = m_multi_ugv_state.ugv_state[i].battery;\n\t\tugv_state.position.x = m_multi_ugv_state.ugv_state[i].position.x;\n\t\tugv_state.position.y = m_multi_ugv_state.ugv_state[i].position.y;\n\t\tugv_state.position.z = m_multi_ugv_state.ugv_state[i].position.z;\n\t\tugv_state.velocity.x = m_multi_ugv_state.ugv_state[i].velocity.x;\n\t\tugv_state.velocity.y = m_multi_ugv_state.ugv_state[i].velocity.y;\n\t\tugv_state.velocity.z = m_multi_ugv_state.ugv_state[i].velocity.z;\n\t\tugv_state.attitude.roll = m_multi_ugv_state.ugv_state[i].attitude.roll;\n\t\tugv_state.attitude.pitch = m_multi_ugv_state.ugv_state[i].attitude.pitch;\n\t\tugv_state.attitude.yaw = m_multi_ugv_state.ugv_state[i].attitude.yaw;\n\t\tmulti_ugv_state.ugv_state.push_back(ugv_state);\n\t}\n\tmulti_ugv_state.ugv_count = m_multi_ugv_state.ugv_count;\n\tm_all_ugv_state_pub.publish(multi_ugv_state);\n}\n", "CodeBleu_score": 41.166814211501425}, {"code": "void SwarmControl::allUGVStatePub(struct MultiUGVState m_multi_ugv_state)\t// Create a MultiUGVState message\n\tMultiUGVState ugv_state_msg;\n\n\t// Set the UGV count\n\tugv_state_msg.ugv_count = m_multi_ugv_state.ugv_count;\n\n\t// Iterate through each UGV state\n\tfor (int i = 0; i < m_multi_ugv_state.ugv_count; i++) {\n\t\t// Create a UGVState message\n\t\tUGVState ugv_state_msg_i;\n\n\t\t// Set the ID\n\t\tugv_state_msg_i.id = m_multi_ugv_state.ugv_states[i].id;\n\n\t\t// Set the battery\n\t\tugv_state_msg_i.battery = m_multi_ugv_state.ugv_states[i].battery;\n\n\t\t// Set the position\n\t\tugv_state_msg_i.position.x = m_multi_ugv_state.ugv_states[i].position.x;\n\t\tugv_state_msg_i.position.y = m_multi_ugv_state.ugv_states[i].position.y;\n\t\tugv_state_msg_i.position.z = m_multi_ugv_state.ugv_states[i].position.z;\n\n\t\t// Set the velocity\n\t\tugv_state_msg_i.velocity.x = m_multi_ugv_state.ugv_states[i].velocity.x;\n\t\tugv_state_msg_i.velocity.y = m_multi_ugv_state.ugv_states[i].velocity.y;\n\t\tugv_state_msg_i.velocity.z = m_multi_ugv_state.ugv_states[i].velocity.z;\n\n\t\t// Set the attitude\n\t\tugv_state_msg_i.attitude.x = m_multi_ugv_state.ugv_states[i].attitude.x;\n\t\tugv_state_msg_i.attitude.y = m_multi_ugv_state.ugv_states[i].attitude.y;\n\t\tugv_state_msg_i.attitude.z =", "CodeBleu_score": 41.3669370655401}]}
{"instance_id": "4a018cebf34b", "generation_result": [{"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// Calculate the cost and gradient of the B-spline trajectory concerning moving objects.\n\t// It iterates through control points of the B-spline, computes the predicted positions of moving objects, and evaluates the distance between control points and these objects.\n\t// If the distance is less than a specified clearance, it updates the cost and gradient based on the distance error.\n\n\t// Get the number of control points and the dimension of the B-spline trajectory.\n\tconst int numControlPoints = q.rows();\n\tconst int dim = q.cols();\n\n\t// Initialize the cost and gradient.\n\tcost = 0.0;\n\tgradient.resize(numControlPoints, dim);\n\tgradient.setZero();\n\n\t// Iterate through control points.\n\tfor (int i = 0; i < numControlPoints; i++) {\n\t\t// Get the position of the i-th control point.\n\t\tEigen::VectorXd qi = q.row(i);\n\n\t\t// Compute the predicted position of the moving objects.\n\t\tEigen::VectorXd q_pred = predictMovingObj(qi);\n\n\t\t// Evaluate the distance between the i-th control point and the predicted position of the moving objects.\n\t\tdouble dist = (qi - q_pred).norm();\n\n\t\t// If the distance is less than the specified clearance, update the cost and gradient.\n\t\tif (dist < clearance) {\n\t\t\tcost += dist;\n\t\t\tgradient.row(i) = (qi - q_pred) / dist;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 30.838821826930783}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tcost = 0.0;\n\tgradient.setZero();\n\tfor (int i = 0; i < q.rows(); i++) {\n\t\tEigen::Vector3d q_i(q(i, 0), q(i, 1), q(i, 2));\n\t\tEigen::Vector3d q_i_next(q(i + 1, 0), q(i + 1, 1), q(i + 1, 2));\n\t\tEigen::Vector3d q_i_next_next(q(i + 2, 0), q(i + 2, 1), q(i + 2, 2));\n\t\tEigen::Vector3d q_i_next_next_next(q(i + 3, 0), q(i + 3, 1), q(i + 3, 2));\n\t\tEigen::Vector3d q_i_next_next_next_next(q(i + 4, 0), q(i + 4, 1), q(i + 4, 2));\n\t\tEigen::Vector3d q_i_next_next_next_next_next(q(i + 5, 0), q(i + 5, 1), q(i + 5, 2));\n\t\tEigen::Vector3d q_i_next_next_next_next_next_next(q(i + 6, 0), q(i + 6, 1), q(i + 6, 2));\n\t\tEigen::Vector3d q_i_next_next_next_next_next_next_next(q(i + 7, 0), q(i + 7, 1), q(i + 7, 2));\n\t\tEigen::Vector3d q_i_next_next_next_next_next_next_next_next(q(i + 8, 0), q(i + 8, 1), q(i + 8, 2));\n\t\tEigen::Vector3d q_i_next_next_next_next_next_next_next_next_next(q(i + 9, 0), q(i + 9,", "CodeBleu_score": 18.503475645143045}, {"code": "void BsplineOptimizer::calcMovingObjCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\tdouble obj_cost = 0;\n\tEigen::MatrixXd obj_gradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\tEigen::Vector3d obj_pos;\n\tEigen::Vector3d obj_vel;\n\tEigen::Vector3d obj_acc;\n\tEigen::Vector3d obj_jerk;\n\tEigen::Vector3d obj_snap;\n\tEigen::Vector3d obj_crackle;\n\tEigen::Vector3d obj_pop;\n\tEigen::Vector3d obj_deriv;\n\tEigen::Vector3d obj_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv_deriv;\n\tEigen::Vector3d obj_deriv_deriv_deriv_deriv_deriv_deriv_deriv_", "CodeBleu_score": 11.102810759893792}]}
{"instance_id": "e805f5d0beea", "generation_result": [{"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// initialize cost to zero\n\tcost = 0;\n\n\t// initialize gradient to zero\n\tgradient = Eigen::MatrixXd::Zero(q.rows(), q.cols());\n\n\t// iterate through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// compute positional error\n\t\tEigen::VectorXd error = q.col(i) - ref_q.col(i);\n\n\t\t// compute velocity vector\n\t\tEigen::VectorXd vel = (q.col(i) - q.col(i - 1)) / dt;\n\n\t\t// compute cost\n\t\tdouble cost_i = (error.dot(error) / a2) + (vel.cross(ref_dq.col(i)).dot(vel) / b2);\n\t\tcost += cost_i;\n\n\t\t// compute gradient\n\t\tgradient.col(i) = (2 * error) / a2 + (2 * vel.cross(ref_dq.col(i))) / b2;\n\t}\n}\n", "CodeBleu_score": 28.02716043871749}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// initialize cost to zero\n\tcost = 0;\n\t// initialize gradient to zero\n\tgradient.setZero(q.rows(), q.cols());\n\n\t// loop through control points\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// compute positional error\n\t\tEigen::VectorXd error = q.col(i) - q_ref.col(i);\n\t\t// compute velocity vector\n\t\tEigen::VectorXd v = q.col(i + 1) - q.col(i);\n\t\t// compute cost and gradient for control point\n\t\tdouble cost_i, grad_i;\n\t\tcalcFitnessCost(error, v, cost_i, grad_i);\n\t\t// update cost\n\t\tcost += cost_i;\n\t\t// update gradient\n\t\tgradient.col(i) += grad_i;\n\t\tgradient.col(i + 1) -= grad_i;\n\t}\n}\n", "CodeBleu_score": 24.128150711427082}, {"code": "void BsplineOptimizer::calcFitnessCost(const Eigen::MatrixXd &q, double &cost, Eigen::MatrixXd &gradient)\t// initialize cost to zero\n\tcost = 0;\n\t// initialize gradient to zero\n\tgradient.setZero(q.rows(), q.cols());\n\n\t// for each control point\n\tfor (int i = 0; i < q.cols(); i++) {\n\t\t// compute error and velocity\n\t\tEigen::Vector3d e = q.col(i) - qRef.col(i);\n\t\tEigen::Vector3d v = q.col(i + 1) - q.col(i);\n\t\t// update cost\n\t\tcost += a2 * e.dot(e) + b2 * v.dot(v);\n\t\t// update gradient\n\t\tgradient.col(i) += 2 * a2 * e + 2 * b2 * v;\n\t\tgradient.col(i + 1) += 2 * a2 * e + 2 * b2 * v;\n\t}\n}\n", "CodeBleu_score": 26.772826421157102}]}
{"instance_id": "265612743518", "generation_result": [{"code": "double UniformBspline::getJerk()\t// Get the third derivative of the spline\n\tMatrixXd jerk = getDerivative(3);\n\n\t// Get the knot times and control points of the jerk trajectory\n\tvector<double> knots = getKnots();\n\tMatrixXd controlPoints = getControlPoints();\n\n\t// Initialize the jerk value\n\tdouble jerkValue = 0.0;\n\n\t// Iterate through the control points and dimensions\n\tfor (int i = 0; i < controlPoints.rows(); i++) {\n\t\tfor (int j = 0; j < controlPoints.cols(); j++) {\n\t\t\t// Sum the squared control point values multiplied by the differences in knot times\n\t\t\tjerkValue += pow(controlPoints(i, j), 2) * (knots[i + 3] - knots[i + 2]);\n\t\t}\n\t}\n\n\t// Return the jerk value\n\treturn jerkValue;\n}\n", "CodeBleu_score": 44.22326593590835}, {"code": "double UniformBspline::getJerk()\tif (this->jerk == -1) {\n\t\tthis->jerk = 0;\n\t\tdouble jerk_x = 0;\n\t\tdouble jerk_y = 0;\n\t\tdouble jerk_z = 0;\n\t\tfor (int i = 0; i < this->num_points; i++) {\n\t\t\tjerk_x += pow(this->jerk_x[i], 2) * (this->knot_times[i + 1] - this->knot_times[i]);\n\t\t\tjerk_y += pow(this->jerk_y[i], 2) * (this->knot_times[i + 1] - this->knot_times[i]);\n\t\t\tjerk_z += pow(this->jerk_z[i], 2) * (this->knot_times[i + 1] - this->knot_times[i]);\n\t\t}\n\t\tthis->jerk = sqrt(jerk_x + jerk_y + jerk_z);\n\t}\n\treturn this->jerk;\n}\n", "CodeBleu_score": 30.12753359076157}, {"code": "double UniformBspline::getJerk()\t// Calculate the third derivative of the spline\n\tvector<double> jerk = spline.getDerivative(3);\n\n\t// Retrieve the knot times and control points of the jerk trajectory\n\tvector<double> knotTimes = spline.getKnotTimes();\n\tvector<vector<double>> controlPoints = spline.getControlPoints();\n\n\t// Iterate through the control points and dimensions, summing the squared control point values multiplied by the differences in knot times\n\tdouble totalJerk = 0;\n\tfor (int i = 0; i < controlPoints.size(); i++) {\n\t\tfor (int j = 0; j < controlPoints[i].size(); j++) {\n\t\t\ttotalJerk += pow(controlPoints[i][j], 2) * (knotTimes[i + 3] - knotTimes[i]);\n\t\t}\n\t}\n\n\t// Return the total jerk value\n\treturn totalJerk;\n}\n", "CodeBleu_score": 42.71716975074437}]}
{"instance_id": "87e33e1ff32a", "generation_result": [{"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tEigen::Vector4d pos;\n\tpos << (u - cx_) * depth / fx_, (v - cy_) * depth / fy_, depth, 1.0;\n\treturn pos;\n}\n", "CodeBleu_score": 47.9707186015799}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \tfloat x = (u - cx_) * depth / fx_;\n\tfloat y = (v - cy_) * depth / fy_;\n\tEigen::Vector4d pos(x, y, depth, 1);\n\treturn pos;\n}\n", "CodeBleu_score": 50.34521440831355}, {"code": "inline Eigen::Vector4d DroneDetector::depth2Pos(int u, int v, float depth) \t//TODO: Implement this function\n\t//This function is already implemented for you.\n\t//Please refer to the lecture slides for the formula.\n\tEigen::Vector4d pos;\n\tpos(0) = (u - cx_)*depth/fx_;\n\tpos(1) = (v - cy_)*depth/fy_;\n\tpos(2) = depth;\n\tpos(3) = 1;\n\treturn pos;\n}\n", "CodeBleu_score": 60.618691426588}]}
{"instance_id": "f3fb61d01c80", "generation_result": [{"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneIdFromFrameId(odom.child_frame_id));\n\t} catch (std::exception& e) {\n\t\tROS_WARN(\"Exception caught in DroneDetector::rcvDroneXOdomCallback: %s\", e.what());\n\t}\n}\n", "CodeBleu_score": 36.59997680336703}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\trcvDroneOdomCallbackBase(odom, getDroneId(odom.child_frame_id));\n\t}\n\tcatch (const std::invalid_argument& e) {\n\t\tROS_ERROR_STREAM(\"Exception caught: \" << e.what());\n\t}\n}\n", "CodeBleu_score": 36.27764739517861}, {"code": "void DroneDetector::rcvDroneXOdomCallback(const nav_msgs::Odometry& odom)\ttry {\n\t\trcvDroneOdomCallbackBase(odom, odom.child_frame_id);\n\t} catch (const std::exception& e) {\n\t\tROS_ERROR_STREAM(\"Exception caught in DroneDetector::rcvDroneXOdomCallback: \" << e.what());\n\t}\n}\n", "CodeBleu_score": 38.33945514344846}]}
{"instance_id": "6710d78c1118", "generation_result": [{"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t//TODO: Implement this function\n}\n", "CodeBleu_score": 3.1161608304283694}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// TODO: Implement this function\n\t// NOTE: You may find it useful to use the helper function get_drone_pose\n\t// to get the pose of the drone in the camera frame.\n\n\t// Get the drone's pose in the camera frame\n\tEigen::Vector3d drone_pose = get_drone_pose(drone_id);\n\n\t// Calculate the pose error\n\tEigen::Vector3d pose_error = drone_pose - true_pixel;\n\n\t// Update the debug result\n\tdebug_result.drone_id = drone_id;\n\tdebug_result.pose_error = pose_error;\n\n\t// If the drone is found, publish the pose error\n\tif (found_drone) {\n\t\tpose_error_pub.publish(pose_error);\n\t}\n}\n", "CodeBleu_score": 24.59796514569578}, {"code": "void DroneDetector::detect(int drone_id, Eigen::Vector2i &true_pixel)\t// get drone pose in camera frame\n\tEigen::Vector3d camera_pose = drone_id_to_camera_pose.at(drone_id);\n\n\t// get drone pose in world frame\n\tEigen::Vector3d world_pose = drone_id_to_world_pose.at(drone_id);\n\n\t// compute pose error\n\tEigen::Vector3d pose_error = camera_pose - world_pose;\n\n\t// check if drone is found\n\tif (pose_error.norm() < max_pose_error) {\n\t\t// drone is found\n\t\t// update debug result\n\t\tdebug_result.found = true;\n\t\tdebug_result.pose_error = pose_error;\n\t\tdebug_result.pose_error_norm = pose_error.norm();\n\t} else {\n\t\t// drone is not found\n\t\t// update debug result\n\t\tdebug_result.found = false;\n\t\tdebug_result.pose_error = Eigen::Vector3d::Zero();\n\t\tdebug_result.pose_error_norm = 0.0;\n\t}\n\n\t// publish debug result\n\tdebug_result_publisher.publish(debug_result);\n}\n", "CodeBleu_score": 30.8065314927794}]}
{"instance_id": "d06c9f07769a", "generation_result": [{"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current!= start) {\n\t\tcurrent = cameFrom[current];\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 67.99917692323582}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tpath.push_back(current);\n\twhile (current->cameFrom!= nullptr) {\n\t\tcurrent = current->cameFrom;\n\t\tpath.push_back(current);\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 80.66503328961358}, {"code": "vector<GridNodePtr> AStar::retrievePath(GridNodePtr current)\tvector<GridNodePtr> path;\n\tGridNodePtr temp = current;\n\twhile (temp!= nullptr) {\n\t\tpath.push_back(temp);\n\t\ttemp = cameFrom[temp];\n\t}\n\treturn path;\n}\n", "CodeBleu_score": 45.17654951925436}]}
{"instance_id": "22b98a6c5348", "generation_result": [{"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert the start and end points to indices\n\tif (!ConvertToIndex(start_pt, start_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Failed to convert start point to index\");\n\t\treturn false;\n\t}\n\tif (!ConvertToIndex(end_pt, end_idx)) {\n\t\tROS_ERROR(\"AStar::ConvertToIndexAndAdjustStartEndPoints: Failed to convert end point to index\");\n\t\treturn false;\n\t}\n\n\t// Check if the start and end points are inside obstacles\n\tif (IsIndexInsideObstacle(start_idx) || IsIndexInsideObstacle(end_idx)) {\n\t\t// If either the start or end point is inside an obstacle, adjust it by moving it away from the other point until it is no longer in an obstacle\n\t\twhile (IsIndexInsideObstacle(start_idx) || IsIndexInsideObstacle(end_idx)) {\n\t\t\t// If the start point is inside an obstacle, move it away from the end point\n\t\t\tif (IsIndexInsideObstacle(start_idx)) {\n\t\t\t\t// Move the start point away from the end point\n\t\t\t\tstart_idx += (end_idx - start_idx) / 2;\n\t\t\t\t// Check if the start point is inside an obstacle\n\t\t\t\tif (IsIndexInsideObstacle(start_idx)) {\n\t\t\t\t\t// If the start point is still inside an obstacle, adjust the start point by moving it away from the end point\n\t\t\t\t\tstart_idx += (end_idx - start_idx) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If the end point is inside an obstacle, move it away from the start point\n\t\t\telse if (IsIndexInsideObstacle(end_idx)) {\n\t\t\t\t// Move the end point away from the start point\n\t\t\t\tend_idx += (start_idx - end_idx) / 2;\n\t\t\t\t// Check if the end point is inside an obstacle\n\t\t\t\tif (IsIndexInsideObstacle(end_idx)) {\n\t\t\t\t\t// If the end point is still inside an obstacle, adjust the end point by moving it away from the start point\n\t\t\t\t\tend_idx += (start_idx - end_idx) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 38.244176638463976}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert points to indices\n\tif (!ConvertToIndex(start_pt, start_idx) ||!ConvertToIndex(end_pt, end_idx)) {\n\t\treturn false;\n\t}\n\n\t// Check if start or end point is inside an obstacle\n\tif (IsPointInObstacle(start_idx) || IsPointInObstacle(end_idx)) {\n\t\t// Iterate until the start or end point is no longer inside an obstacle\n\t\twhile (IsPointInObstacle(start_idx) || IsPointInObstacle(end_idx)) {\n\t\t\t// Move start point away from end point\n\t\t\tif (IsPointInObstacle(start_idx)) {\n\t\t\t\tstart_idx += (end_idx - start_idx).cwiseAbs().maxCoeff() * Vector3i::Ones();\n\t\t\t}\n\t\t\t// Move end point away from start point\n\t\t\tif (IsPointInObstacle(end_idx)) {\n\t\t\t\tend_idx += (start_idx - end_idx).cwiseAbs().maxCoeff() * Vector3i::Ones();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 39.29408845747625}, {"code": "bool AStar::ConvertToIndexAndAdjustStartEndPoints(Vector3d start_pt, Vector3d end_pt, Vector3i &start_idx, Vector3i &end_idx)\t// Convert points to indices\n\tif (!ConvertToIndex(start_pt, start_idx))\n\t\treturn false;\n\tif (!ConvertToIndex(end_pt, end_idx))\n\t\treturn false;\n\n\t// Adjust points if they are inside obstacles\n\tif (IsPointInObstacle(start_idx)) {\n\t\tif (!AdjustPoint(start_pt, start_idx))\n\t\t\treturn false;\n\t}\n\tif (IsPointInObstacle(end_idx)) {\n\t\tif (!AdjustPoint(end_pt, end_idx))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n", "CodeBleu_score": 35.08622821625534}]}
{"instance_id": "4c5e9b3dd1d9", "generation_result": [{"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\t// Check if the min and max positions are valid\n\tif (min_pos.x() < 0 || min_pos.y() < 0 || min_pos.z() < 0 || max_pos.x() < 0 || max_pos.y() < 0 || max_pos.z() < 0) {\n\t\tROS_ERROR_STREAM(\"Invalid min and/or max position\");\n\t\treturn;\n\t}\n\n\t// Convert the min and max positions to grid coordinates\n\tEigen::Vector3i min_id = this->worldToMap(min_pos);\n\tEigen::Vector3i max_id = this->worldToMap(max_pos);\n\n\t// Reset the occupancy buffer\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\tthis->occupancy_buffer_inflate_[x][y][z] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 47.04372492371672}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\t// get min and max grid coordinates\n\tEigen::Vector3i min_id = this->worldToMap(min_pos);\n\tEigen::Vector3i max_id = this->worldToMap(max_pos);\n\n\t// iterate over all grid coordinates within the specified region\n\tfor (int x = min_id.x(); x <= max_id.x(); x++) {\n\t\tfor (int y = min_id.y(); y <= max_id.y(); y++) {\n\t\t\tfor (int z = min_id.z(); z <= max_id.z(); z++) {\n\t\t\t\t// get the buffer index\n\t\t\t\tint index = this->getIndex(x, y, z);\n\t\t\t\t// reset the occupancy buffer\n\t\t\t\tthis->occupancy_buffer_inflate_[index] = 0;\n\t\t\t\t// reset the distance buffer\n\t\t\t\tthis->distance_buffer_inflate_[index] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 45.03801039777572}, {"code": "void GridMap::resetBuffer(Eigen::Vector3d min_pos, Eigen::Vector3d max_pos)\t// Get the min and max coordinates of the region\n\tint min_id_x = (int)floor(min_pos.x() / resolution_);\n\tint min_id_y = (int)floor(min_pos.y() / resolution_);\n\tint min_id_z = (int)floor(min_pos.z() / resolution_);\n\tint max_id_x = (int)floor(max_pos.x() / resolution_);\n\tint max_id_y = (int)floor(max_pos.y() / resolution_);\n\tint max_id_z = (int)floor(max_pos.z() / resolution_);\n\n\t// Iterate over the region and set the occupancy buffer to zero\n\tfor (int x = min_id_x; x <= max_id_x; x++) {\n\t\tfor (int y = min_id_y; y <= max_id_y; y++) {\n\t\t\tfor (int z = min_id_z; z <= max_id_z; z++) {\n\t\t\t\tint index = getIndex(x, y, z);\n\t\t\t\toccupancy_buffer_inflate_[index] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.440289779658016}]}
{"instance_id": "83b0066d4e0c", "generation_result": [{"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\t// Compute the difference vector between the point and the camera position.\n\tEigen::Vector3d diff = pt - camera_pt;\n\n\t// Compute the maximum and minimum translation coefficients along each axis.\n\tdouble min_x = -map_size_x_ / 2.0 + camera_pt(0);\n\tdouble max_x = map_size_x_ / 2.0 + camera_pt(0);\n\tdouble min_y = -map_size_y_ / 2.0 + camera_pt(1);\n\tdouble max_y = map_size_y_ / 2.0 + camera_pt(1);\n\tdouble min_z = -map_size_z_ / 2.0 + camera_pt(2);\n\tdouble max_z = map_size_z_ / 2.0 + camera_pt(2);\n\n\t// Iterate through each axis to find the minimum positive scaling factor that keeps the point within map boundaries.\n\tdouble x_scale = 1.0;\n\tif (diff(0) < min_x) {\n\t\tx_scale = std::min(1.0, (min_x - diff(0)) / diff(0));\n\t} else if (diff(0) > max_x) {\n\t\tx_scale = std::min(1.0, (max_x - diff(0)) / diff(0));\n\t}\n\n\tdouble y_scale = 1.0;\n\tif (diff(1) < min_y) {\n\t\ty_scale = std::min(1.0, (min_y - diff(1)) / diff(1));\n\t} else if (diff(1) > max_y) {\n\t\ty_scale = std::min(1.0, (max_y - diff(1)) / diff(1));\n\t}\n\n\tdouble z_scale = 1.0;\n\tif (diff(2) < min_z) {\n\t\tz_scale = std::min(1.0, (min_z - diff(2)) / diff(2));\n\t} else if (diff(2) > max_z) {\n\t\tz_scale = std::min(1.0, (max_z - diff(2", "CodeBleu_score": 36.10349954157811}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\tdouble x_min = -1 * (m_width / 2);\n\tdouble x_max = m_width / 2;\n\tdouble y_min = -1 * (m_height / 2);\n\tdouble y_max = m_height / 2;\n\tdouble z_min = 0;\n\tdouble z_max = m_depth;\n\n\tdouble x_diff = pt(0) - camera_pt(0);\n\tdouble y_diff = pt(1) - camera_pt(1);\n\tdouble z_diff = pt(2) - camera_pt(2);\n\n\tdouble x_scale = 1;\n\tdouble y_scale = 1;\n\tdouble z_scale = 1;\n\n\tif (x_diff < x_min) {\n\t\tx_scale = (x_min - x_diff) / x_diff;\n\t} else if (x_diff > x_max) {\n\t\tx_scale = (x_max - x_diff) / x_diff;\n\t}\n\n\tif (y_diff < y_min) {\n\t\ty_scale = (y_min - y_diff) / y_diff;\n\t} else if (y_diff > y_max) {\n\t\ty_scale = (y_max - y_diff) / y_diff;\n\t}\n\n\tif (z_diff < z_min) {\n\t\tz_scale = (z_min - z_diff) / z_diff;\n\t} else if (z_diff > z_max) {\n\t\tz_scale = (z_max - z_diff) / z_diff;\n\t}\n\n\tEigen::Vector3d closest_pt = pt;\n\n\tif (x_scale < y_scale && x_scale < z_scale) {\n\t\tclosest_pt(0) = camera_pt(0) + x_scale * x_diff;\n\t} else if (y_scale < x_scale && y_scale < z_scale) {\n\t\tclosest_pt(1) = camera_pt(1) + y_scale * y_diff;\n\t} else if (z_scale < x_scale && z_scale < y_scale) {\n\t\tclosest", "CodeBleu_score": 30.337502412964234}, {"code": "Eigen::Vector3d GridMap::closetPointInMap(const Eigen::Vector3d &pt, const Eigen::Vector3d &camera_pt)\tEigen::Vector3d diff = pt - camera_pt;\n\tdouble max_x = std::max(0.0, pt.x() - camera_pt.x());\n\tdouble min_x = std::min(0.0, pt.x() - camera_pt.x());\n\tdouble max_y = std::max(0.0, pt.y() - camera_pt.y());\n\tdouble min_y = std::min(0.0, pt.y() - camera_pt.y());\n\tdouble max_z = std::max(0.0, pt.z() - camera_pt.z());\n\tdouble min_z = std::min(0.0, pt.z() - camera_pt.z());\n\tdouble scale_x = 1.0;\n\tdouble scale_y = 1.0;\n\tdouble scale_z = 1.0;\n\tif (max_x!= 0.0) {\n\t\tscale_x = max_x / diff.x();\n\t}\n\tif (min_x!= 0.0) {\n\t\tscale_x = std::min(scale_x, min_x / diff.x());\n\t}\n\tif (max_y!= 0.0) {\n\t\tscale_y = max_y / diff.y();\n\t}\n\tif (min_y!= 0.0) {\n\t\tscale_y = std::min(scale_y, min_y / diff.y());\n\t}\n\tif (max_z!= 0.0) {\n\t\tscale_z = max_z / diff.z();\n\t}\n\tif (min_z!= 0.0) {\n\t\tscale_z = std::min(scale_z, min_z / diff.z());\n\t}\n\treturn camera_pt + diff * scale_x * scale_y * scale_z;\n}\n", "CodeBleu_score": 39.514969280140576}]}
{"instance_id": "9d60c28d75a3", "generation_result": [{"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// Update last occupancy update time\n\tlastOccupancyUpdateTime_ = ros::Time::now();\n\n\t// Check if the local map has been updated\n\tif (localMapUpdated_) {\n\t\t// Clear and inflate local map\n\t\tlocalMap_.clear();\n\t\tlocalMap_.inflate(localMapInflateRadius_);\n\t\tlocalMapUpdated_ = false;\n\t}\n\n\t// Check if depth data is available\n\tif (depthDataAvailable_) {\n\t\t// Project depth image into points\n\t\tpcl::PointCloud<pcl::PointXYZ> points;\n\t\tpcl::fromROSMsg(depthData_, points);\n\n\t\t// Raycast points to update occupancy grid\n\t\tfor (int i = 0; i < points.size(); i++) {\n\t\t\t// Get point\n\t\t\tpcl::PointXYZ point = points.points[i];\n\n\t\t\t// Check if point is within map bounds\n\t\t\tif (point.x >= -mapWidth_ / 2.0 && point.x <= mapWidth_ / 2.0 && point.y >= -mapHeight_ / 2.0 && point.y <= mapHeight_ / 2.0) {\n\t\t\t\t// Update occupancy grid\n\t\t\t\tupdateOccupancy(point.x, point.y);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if odometry data is available\n\tif (odometryDataAvailable_) {\n\t\t// Get odometry data\n\t\tgeometry_msgs::Pose2D odometryData = odometryData_;\n\n\t\t// Check if odometry data is valid\n\t\tif (odometryData.theta!= odometryData.theta) {\n\t\t\t// Set odometry data flag\n\t\t\todometryDataAvailable_ = false;\n\n\t\t\t// Set odometry data timeout flag\n\t\t\todometryDataTimeout_ = true;\n\t\t} else {\n\t\t\t// Get odometry data\n\t\t\tdouble odometryX = odometryData.x;\n\t\t\tdouble odometryY = odometryData.y;\n\t\t\tdouble odometryTheta = odometryData.theta;\n\n\t\t\t// Check if odometry data is valid\n\t\t\tif (odometryX!= odometryX || odometryY!= odometryY || odometryTheta!= odometryTheta) {\n\t\t\t\t// Set odometry data flag\n\t\t\t\todometryDataAvailable_ = false;\n\n\t\t\t\t// Set odometry data timeout flag\n\t\t\t\todometry", "CodeBleu_score": 29.157779516103272}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// Update last occupancy update time\n\tlastOccupancyUpdateTime_ = ros::Time::now();\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNewData_) {\n\t\treturn;\n\t}\n\n\t// If no new data, return\n\tif (!hasNew", "CodeBleu_score": 29.642752688169555}, {"code": "void GridMap::updateOccupancyCallback(const ros::TimerEvent & /*event*/)\t// Update last occupancy update time\n\tlastOccupancyUpdateTime_ = ros::Time::now();\n\n\t// Check if an update is needed\n\tif (depthImageUpdated_ || odometryUpdated_) {\n\t\t// Project depth image into points\n\t\tpcl::PointCloud<pcl::PointXYZ> points;\n\t\tif (depthImageUpdated_) {\n\t\t\tif (!projectDepthImageIntoPoints(points)) {\n\t\t\t\tROS_ERROR(\"Could not project depth image into points.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Process points with raycasting\n\t\tif (!raycastPoints(points)) {\n\t\t\tROS_ERROR(\"Could not process points with raycasting.\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear and inflate local map\n\t\tif (localMapUpdated_) {\n\t\t\t// Clear local map\n\t\t\tif (!clearLocalMap()) {\n\t\t\t\tROS_ERROR(\"Could not clear local map.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Inflate local map\n\t\t\tif (!inflateLocalMap()) {\n\t\t\t\tROS_ERROR(\"Could not inflate local map.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Set local map updated flag\n\t\tlocalMapUpdated_ = true;\n\t}\n\n\t// Set depth image updated flag\n\tdepthImageUpdated_ = false;\n\n\t// Set odometry updated flag\n\todometryUpdated_ = false;\n}\n", "CodeBleu_score": 32.152994296669775}]}
{"instance_id": "195347f7698b", "generation_result": [{"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\t// Load the ground truth ellipses for each image\n\tvector<vector<Ellipse>> gt_ellipses;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tgt_ellipses.push_back(_load_ellipses(gt_fns[i], gt_angle_radians));\n\t}\n\n\t// Load the detected ellipses for each image\n\tvector<vector<Ellipse>> dt_ellipses;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tdt_ellipses.push_back(_load_ellipses(dt_fns[i], gt_angle_radians));\n\t}\n\n\t// Calculate the F-measure for each image\n\tvector<float> f_measures;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tf_measures.push_back(_ellipse_f_measure(gt_ellipses[i], dt_ellipses[i]));\n\t}\n\n\t// Calculate the average F-measure\n\tfloat avg_f_measure = 0;\n\tfor (int i = 0; i < f_measures.size(); i++) {\n\t\tavg_f_measure += f_measures[i];\n\t}\n\tavg_f_measure /= f_measures.size();\n\n\treturn avg_f_measure;\n}\n", "CodeBleu_score": 57.52174595638079}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\t// TODO: Implement this function\n\treturn 0.0f;\n}\n", "CodeBleu_score": 8.374933762891343}, {"code": "float _ellipse_evaluate(vector<string>& image_fns, vector<string>& gt_fns, vector<string>& dt_fns, bool gt_angle_radians)\t// Load the ground truth ellipses and detected ellipses for each image\n\tvector<vector<Ellipse>> gt_ellipses;\n\tvector<vector<Ellipse>> dt_ellipses;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tvector<Ellipse> gt_ellipses_i = _load_ellipses(gt_fns[i], gt_angle_radians);\n\t\tvector<Ellipse> dt_ellipses_i = _load_ellipses(dt_fns[i], gt_angle_radians);\n\t\tgt_ellipses.push_back(gt_ellipses_i);\n\t\tdt_ellipses.push_back(dt_ellipses_i);\n\t}\n\n\t// Calculate the F-measure for each image\n\tvector<float> f_measures;\n\tfor (int i = 0; i < image_fns.size(); i++) {\n\t\tf_measures.push_back(_ellipse_f_measure(gt_ellipses[i], dt_ellipses[i]));\n\t}\n\n\t// Calculate the average F-measure\n\tfloat avg_f_measure = 0;\n\tfor (int i = 0; i < f_measures.size(); i++) {\n\t\tavg_f_measure += f_measures[i];\n\t}\n\tavg_f_measure /= f_measures.size();\n\n\treturn avg_f_measure;\n}\n", "CodeBleu_score": 51.38610773464756}]}
{"instance_id": "33d20170f6d2", "generation_result": [{"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tfloat angle = atan2f(y - foci[1], x - foci[0]) - atan2f(y - foci[3], x - foci[2]);\n\treturn angle < -M_PI? angle + 2 * M_PI : angle > M_PI? angle - 2 * M_PI : angle;\n}\n", "CodeBleu_score": 31.823553432429385}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tfloat angle1 = atan2(y - foci[1], x - foci[0]);\n\tfloat angle2 = atan2(y - foci[3], x - foci[2]);\n\tfloat angle = angle1 - angle2;\n\tif (angle > M_PI) {\n\t\tangle -= 2 * M_PI;\n\t} else if (angle < -M_PI) {\n\t\tangle += 2 * M_PI;\n\t}\n\treturn angle;\n}\n", "CodeBleu_score": 43.033153222417184}, {"code": "float _ellipse_normal_angle(float x, float y, float *foci)\tfloat angle_1 = atan2(y - foci[1], x - foci[0]);\n\tfloat angle_2 = atan2(y - foci[3], x - foci[2]);\n\tfloat normal_angle = angle_1 - angle_2;\n\n\tif (normal_angle > M_PI) {\n\t\tnormal_angle -= 2 * M_PI;\n\t} else if (normal_angle < -M_PI) {\n\t\tnormal_angle += 2 * M_PI;\n\t}\n\n\treturn normal_angle;\n}\n", "CodeBleu_score": 44.46887550217916}]}
{"instance_id": "2c1daf41f894", "generation_result": [{"code": "bool inline concave_check(VP& vp1, int start, int end)\tdouble min_x = vp1[start].x;\n\tdouble max_x = vp1[start].x;\n\tdouble min_y = vp1[start].y;\n\tdouble max_y = vp1[start].y;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\tif (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\tif (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\tdouble integral_above = 0.0;\n\tdouble integral_below = 0.0;\n\tfor (int i = start; i < end; i++) {\n\t\tintegral_above += (vp1[i].x - min_x)*(vp1[i + 1].y - vp1[i].y) - (vp1[i + 1].x - vp1[i].x)*(vp1[i].y - min_y);\n\t\tintegral_below += (vp1[i].x - min_x)*(vp1[i + 1].y - vp1[i].y) - (vp1[i + 1].x - vp1[i].x)*(vp1[i].y - max_y);\n\t}\n\tif (integral_above < integral_below) return false;\n\treturn true;\n}\n", "CodeBleu_score": 38.588309950337596}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\tdouble minX = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "CodeBleu_score": 2.8887296333888806}, {"code": "bool inline concave_check(VP& vp1, int start, int end)\t// Find the minimum and maximum x and y coordinates of the points in the section\n\tdouble min_x = vp1[start].x, max_x = vp1[start].x, min_y = vp1[start].y, max_y = vp1[start].y;\n\tfor (int i = start; i <= end; i++) {\n\t\tif (vp1[i].x < min_x) min_x = vp1[i].x;\n\t\telse if (vp1[i].x > max_x) max_x = vp1[i].x;\n\t\tif (vp1[i].y < min_y) min_y = vp1[i].y;\n\t\telse if (vp1[i].y > max_y) max_y = vp1[i].y;\n\t}\n\n\t// Compute the integral above and below the polygon section\n\tdouble integral_above = 0.0, integral_below = 0.0;\n\tfor (int i = start; i <= end; i++) {\n\t\t// Integral above\n\t\tif (i == end) {\n\t\t\tintegral_above += (vp1[i].y + vp1[start].y) * (vp1[i].x - vp1[start].x) / 2.0;\n\t\t}\n\t\telse {\n\t\t\tintegral_above += (vp1[i].y + vp1[i + 1].y) * (vp1[i].x - vp1[i + 1].x) / 2.0;\n\t\t}\n\t\t// Integral below\n\t\tif (i == start) {\n\t\t\tintegral_below += (vp1[i].y + vp1[end].y) * (vp1[i].x - vp1[end].x) / 2.0;\n\t\t}\n\t\telse {\n\t\t\tintegral_below += (vp1[i].y + vp1[i - 1].y) * (vp1[i].x - vp1[i - 1].x) / 2.0;\n\t\t}\n\t}\n\n\t// If the integral above is less than the integral below, the section is convex; otherwise, it is concave\n\treturn integral_above < integral_below;\n", "CodeBleu_score": 38.05960784597263}]}
{"instance_id": "7e8e0befa54d", "generation_result": [{"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\tif (msg->detections.size() == 0) {\n\t\tis_detected = false;\n\t\treturn;\n\t}\n\tis_detected = true;\n\tfor (int i = 0; i < msg->detections.size(); i++) {\n\t\tif (msg->detections[i].object_name == \"T\") {\n\t\t\tnum_regain++;\n\t\t\tnum_lost = 0;\n\t\t} else {\n\t\t\tnum_regain = 0;\n\t\t\tnum_lost++;\n\t\t}\n\t\tif (num_lost > VISION_THRES) {\n\t\t\tis_detected = false;\n\t\t}\n\t\tif (num_regain > VISION_THRES) {\n\t\t\tis_detected = true;\n\t\t}\n\t\tif (msg->detections[i].object_name == \"T\") {\n\t\t\tellipse_det.sight_angle = -1 * msg->detections[i].sight_angle;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 58.71753172878993}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\t//ROS_INFO(\"Ellipse detection callback\");\n\tif (msg->detections.size() > 0) {\n\t\tfor (size_t i = 0; i < msg->detections.size(); i++) {\n\t\t\tif (msg->detections[i].label.compare(\"T\") == 0) {\n\t\t\t\tnum_regain++;\n\t\t\t\tnum_lost = 0;\n\t\t\t} else {\n\t\t\t\tnum_regain = 0;\n\t\t\t\tnum_lost++;\n\t\t\t}\n\t\t\tif (num_lost > VISION_THRES) {\n\t\t\t\tis_detected = false;\n\t\t\t}\n\t\t\tif (num_regain > VISION_THRES) {\n\t\t\t\tis_detected = true;\n\t\t\t}\n\t\t}\n\t\t//ROS_INFO(\"is_detected: %d\", is_detected);\n\t\t//ROS_INFO(\"num_regain: %d\", num_regain);\n\t\t//ROS_INFO(\"num_lost: %d\", num_lost);\n\t}\n}\n", "CodeBleu_score": 52.401989148404795}, {"code": "void ellipse_det_cb(const prometheus_msgs::MultiDetectionInfo::ConstPtr &msg)\t//ROS_INFO(\"ellipse_det_cb\");\n\t//ROS_INFO(\"msg->detections.size(): %d\", msg->detections.size());\n\t//ROS_INFO(\"msg->detections.at(0).name: %s\", msg->detections.at(0).name.c_str());\n\t//ROS_INFO(\"msg->detections.at(0).pose.position.x: %f\", msg->detections.at(0).pose.position.x);\n\t//ROS_INFO(\"msg->detections.at(0).pose.position.y: %f\", msg->detections.at(0).pose.position.y);\n\t//ROS_INFO(\"msg->detections.at(0).pose.position.z: %f\", msg->detections.at(0).pose.position.z);\n\t//ROS_INFO(\"msg->detections.at(0).pose.orientation.x: %f\", msg->detections.at(0).pose.orientation.x);\n\t//ROS_INFO(\"msg->detections.at(0).pose.orientation.y: %f\", msg->detections.at(0).pose.orientation.y);\n\t//ROS_INFO(\"msg->detections.at(0).pose.orientation.z: %f\", msg->detections.at(0).pose.orientation.z);\n\t//ROS_INFO(\"msg->detections.at(0).pose.orientation.w: %f\", msg->detections.at(0).pose.orientation.w);\n\t//ROS_INFO(\"msg->detections.at(0).pose.covariance[0]: %f\", msg->detections.at(0).pose.covariance[0]);\n\t//ROS_INFO(\"msg->detections.at(0).pose.covariance[1]: %f\", msg->detections.at(0).pose.covariance[1]);\n\t//ROS_INFO(\"msg->detections.at(0).pose.covariance[2]: %f\", msg->detections.at(0).pose.covariance[2]);\n\t//ROS_INFO(\"msg->detections.at(0).pose.covariance[3]: %f\", msg->detections.at(0", "CodeBleu_score": 3.452524173720497}]}
{"instance_id": "f16741953a68", "generation_result": [{"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\tbool is_safe = true;\n\tdouble distance_to_obstacle = Occupy_map_ptr->get_distance_to_obstacle(cur_pos);\n\tif (distance_to_obstacle <= safe_distance) {\n\t\tis_safe = false;\n\t}\n\treturn is_safe;\n}\n", "CodeBleu_score": 46.055469356765634}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\t// TODO: Implement this function\n\t//std::cout << \"check_safety: \" << cur_pos << std::endl;\n\t//std::cout << \"safe_distance: \" << safe_distance << std::endl;\n\tdouble x = cur_pos(0);\n\tdouble y = cur_pos(1);\n\tdouble z = cur_pos(2);\n\tdouble distance = sqrt(x*x + y*y + z*z);\n\t//std::cout << \"distance: \" << distance << std::endl;\n\tif (distance > safe_distance) {\n\t\t//std::cout << \"distance > safe_distance\" << std::endl;\n\t\treturn false;\n\t}\n\telse {\n\t\t//std::cout << \"distance <= safe_distance\" << std::endl;\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 40.34650316292004}, {"code": "bool Astar::check_safety(Eigen::Vector3d &cur_pos, double safe_distance)\t// Check if the current position is in the safety zone\n\tif (occupy_map_ptr_->is_occupied(cur_pos)) {\n\t\t// If the current position is in the safety zone, return false\n\t\treturn false;\n\t} else {\n\t\t// If the current position is not in the safety zone, return true\n\t\treturn true;\n\t}\n}\n", "CodeBleu_score": 23.743054071479214}]}
{"instance_id": "34633c5633a4", "generation_result": [{"code": "void Astar::retrievePath(NodePtr end_node)\tpath_nodes_.clear();\n\tNodePtr current_node = end_node;\n\twhile (current_node->parent_!= nullptr) {\n\t\tpath_nodes_.push_back(current_node);\n\t\tcurrent_node = current_node->parent_;\n\t}\n\tpath_nodes_.push_back(current_node);\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 59.50021849950387}, {"code": "void Astar::retrievePath(NodePtr end_node)\t// TODO: Implement this function to retrieve the path from the end node to the start node\n\t// HINT: You can use the parent pointers to trace the path back to the start node.\n\t//       Remeber that the path should be stored in the order from start to end.\n\t//       The path should be stored in path_nodes_.\n\t//       The path should not include the start node.\n\t//       The path should not include the end node.\n\t//       The path should not include any nodes that are not in the open or closed set.\n\t//       The path should not include any nodes that are in the open set, but not the closed set.\n\t//       The path should not include any nodes that are in the closed set, but not the open set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes that are neither in the open nor the closed set.\n\t//       The path should not include any nodes", "CodeBleu_score": 6.8066041602473355}, {"code": "void Astar::retrievePath(NodePtr end_node)\t// Start from the end node and trace back to the start node.\n\t// Store the nodes in path_nodes_ in the order they are traversed.\n\tpath_nodes_.clear();\n\tNodePtr curr_node = end_node;\n\twhile (curr_node!= nullptr) {\n\t\tpath_nodes_.push_back(curr_node);\n\t\tcurr_node = curr_node->parent;\n\t}\n\n\t// Reverse the order of path_nodes_ to present the path from start to end.\n\tstd::reverse(path_nodes_.begin(), path_nodes_.end());\n}\n", "CodeBleu_score": 59.40656032130088}]}
{"instance_id": "4a6cd1a5a77a", "generation_result": [{"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \tif (simulation_mode) {\n\t\tdouble dist = sqrt(pow(odom->pose.pose.position.x - start_position.x, 2) + pow(odom->pose.pose.position.y - start_position.y, 2));\n\t\tif (dist > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t}\n\t\telse {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t}\n\telse {\n\t\tget_nei_state[id] = true;\n\t}\n\tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n}\n", "CodeBleu_score": 50.54424361681367}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].yaw = tf::getYaw(odom->pose.pose.orientation);\n\tif (sim_mode) {\n\t\tif (sqrt(pow(state_nei[id].x, 2) + pow(state_nei[id].y, 2)) > 5) {\n\t\t\tget_nei_state[id] = false;\n\t\t} else {\n\t\t\tget_nei_state[id] = true;\n\t\t}\n\t} else {\n\t\tget_nei_state[id] = true;\n\t}\n}\n", "CodeBleu_score": 49.45764962320936}, {"code": "void GlobalPlannerUGV::nei_odom_cb(const nav_msgs::Odometry::ConstPtr& odom, int id) \tstate_nei[id].x = odom->pose.pose.position.x;\n\tstate_nei[id].y = odom->pose.pose.position.y;\n\tstate_nei[id].z = odom->pose.pose.position.z;\n\tstate_nei[id].get_nei_state = true;\n\tif (sim_mode) {\n\t\tdouble dist = sqrt(pow(state_nei[id].x-start_x,2) + pow(state_nei[id].y-start_y,2));\n\t\tif (dist > 5) {\n\t\t\tstate_nei[id].get_nei_state = false;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 33.26392696459234}]}
{"instance_id": "e7507a698cf6", "generation_result": [{"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb\");\n\tif (sensor_ready) {\n\t\tif (update_counter == 5) {\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: updating map\");\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: update_counter = %d\", update_counter);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\tupdate_counter = 0;\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: update_counter = %d\", update_counter);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlannerUGV::Gpointcloud_cb: sensor_ready = %d\", sensor_ready);\n\t\t\t//ROS_INFO(\"GlobalPlanner", "CodeBleu_score": 21.2312193203624}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\t// Get the current time\n\tros::Time current_time = ros::Time::now();\n\t// Get the current transform\n\ttf::StampedTransform transform;\n\ttry {\n\t\tlistener.lookupTransform(\"/base_link\", \"/map\", ros::Time(0), transform);\n\t} catch (tf::TransformException &ex) {\n\t\tROS_ERROR(\"%s\", ex.what());\n\t\tros::Duration(1.0).sleep();\n\t}\n\t// Get the current odometry\n\ttf::Transform odom_transform = transform;\n\t// If odometry is not ready, return\n\tif (!odom_ready)\n\t\treturn;\n\t// If the sensor is ready, increment the update counter\n\tif (sensor_ready) {\n\t\tupdate_counter++;\n\t\t// If the update counter is 5, update the Astar map with the new point cloud data\n\t\tif (update_counter == 5) {\n\t\t\t// Set the sensor_ready flag to false\n\t\t\tsensor_ready = false;\n\t\t\t// Set the update counter to 0\n\t\t\tupdate_counter = 0;\n\t\t\t// Get the current transform\n\t\t\ttf::StampedTransform transform;\n\t\t\ttry {\n\t\t\t\tlistener.lookupTransform(\"/base_link\", \"/map\", ros::Time(0), transform);\n\t\t\t} catch (tf::TransformException &ex) {\n\t\t\t\tROS_ERROR(\"%s\", ex.what());\n\t\t\t\tros::Duration(1.0).sleep();\n\t\t\t}\n\t\t\t// Get the current odometry\n\t\t\ttf::Transform odom_transform = transform;\n\t\t\t// Get the current position of the UGV\n\t\t\ttf::Vector3 current_position = odom_transform.getOrigin();\n\t\t\t// Get the current orientation of the UGV\n\t\t\ttf::Quaternion current_orientation = odom_transform.getRotation();\n\t\t\t// Convert the current position and orientation to a geometry_msgs::Point\n\t\t\tgeometry_msgs::Point current_point;\n\t\t\tcurrent_point.x = current_position.getX();\n\t\t\tcurrent_point.y = current_position.getY();\n\t\t\tcurrent_point.z = current_position.getZ();\n\t\t\tgeometry_msgs::Quaternion current_quaternion;\n\t\t\tcurrent_quaternion.x = current_orientation.getX();\n\t\t\tcurrent_quaternion.y = current", "CodeBleu_score": 34.0637673246652}, {"code": "void GlobalPlannerUGV::Gpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (!odometry_ready) {\n\t\treturn;\n\t}\n\tsensor_ready = true;\n\tupdate_count++;\n\tif (update_count == 5) {\n\t\t// Update the A* map with the new point cloud data\n\t\tupdate_map(msg);\n\t\tupdate_count = 0;\n\t}\n}\n", "CodeBleu_score": 49.72710119982515}]}
{"instance_id": "8606e2b94164", "generation_result": [{"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl) {\n\t\t//ROS_INFO(\"get_gpcl is true\");\n\t\treturn;\n\t}\n\telse {\n\t\t//ROS_INFO(\"get_gpcl is false\");\n\t\tget_gpcl = true;\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*global_point, *cloud_ptr);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->size());\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points.size());\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[0].x);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[0].y);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[0].z);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[1].x);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[1].y);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[1].z);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[2].x);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[2].y);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[2].z);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[3].x);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[3].y);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[3].z);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[4].x);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_ptr->points[4].y);\n\t\t//ROS_INFO(\"cloud_ptr size is %d\", cloud_", "CodeBleu_score": 57.31965249137265}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered_downsampled_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered_downsampled_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered_downsampled_filtered_downsampled_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled_filtered_downsampled(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr gpcl_inflated_downsampled_filtered_downsampled_filtered_downsampled_filtered_down", "CodeBleu_score": 42.74900946175916}, {"code": "void Occupy_map::map_update_gpcl(const sensor_msgs::PointCloud2ConstPtr & global_point)\tif (get_gpcl == false) {\n\t\tget_gpcl = true;\n\t\tpcl::fromROSMsg(*global_point, *gpcl);\n\t\tgpcl->header.frame_id = \"map\";\n\t\tgpcl->header.stamp = ros::Time::now();\n\t\tgpcl->header.seq = 0;\n\t\tgpcl->width = gpcl->width * 1;\n\t\tgpcl->height = gpcl->height * 1;\n\t\tgpcl->is_dense = false;\n\t\tgpcl->points.resize(gpcl->width * gpcl->height);\n\t\tgpcl->points.clear();\n\t\tpcl::inflation::InflationVoxelGrid<pcl::PointXYZ> voxel_grid_filter;\n\t\tvoxel_grid_filter.setLeafSize(0.05, 0.05, 0.05);\n\t\tvoxel_grid_filter.setInputCloud(gpcl);\n\t\tvoxel_grid_filter.filter(*gpcl);\n\t\tgpcl->header.frame_id = \"map\";\n\t\tgpcl->header.stamp = ros::Time::now();\n\t\tgpcl->header.seq = 0;\n\t\tgpcl->width = gpcl->width * 1;\n\t\tgpcl->height = gpcl->height * 1;\n\t\tgpcl->is_dense = false;\n\t\tgpcl->points.resize(gpcl->width * gpcl->height);\n\t\tgpcl->points.clear();\n\t\tgpcl->header.frame_id = \"map\";\n\t\tgpcl->header.stamp = ros::Time::now();\n\t\tgpcl->header.seq = 0;\n\t\tgpcl->width = gpcl->width * 1;\n\t\tgpcl->height = gpcl->height * 1;\n\t\tgpcl->is_dense = false;\n\t\tgpcl->points.resize(gpcl->width * gpcl->height);\n\t\tgpcl->points.clear();\n\t\tgpcl->header.frame_id = \"map\";\n\t\tgpcl->header.stamp = ros::Time::now();\n\t\tgpcl->header.seq = 0;\n\t\tgpcl->width = gpcl->width * 1;\n\t\tgpcl->height = gpcl", "CodeBleu_score": 44.526606084678924}]}
{"instance_id": "fbce91db4aed", "generation_result": [{"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// Project the laser scan into a PointCloud2 format\n\tpcl::PointCloud<pcl::PointXYZ> cloud;\n\tpcl::fromROSMsg(*local_point, cloud);\n\n\t// Convert the PointCloud to a pcl::PointCloud\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl;\n\tcloud_pcl = *cloud.makeShared();\n\n\t// If not in simulation mode, merge the local map with the provided odometry data\n\tif (!sim_mode) {\n\t\tmerge_map(cloud_pcl, odom);\n\t}\n}\n", "CodeBleu_score": 45.4692539677704}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\t// Convert the laser scan to a point cloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*local_point, *laser_cloud);\n\n\t// Get the current robot position\n\tpcl::PointXYZ current_pos;\n\tcurrent_pos.x = odom.pose.pose.position.x;\n\tcurrent_pos.y = odom.pose.pose.position.y;\n\tcurrent_pos.z = odom.pose.pose.position.z;\n\n\t// Get the current robot orientation\n\ttf::Quaternion current_rot;\n\ttf::quaternionMsgToTF(odom.pose.pose.orientation, current_rot);\n\tdouble roll, pitch, yaw;\n\ttf::Matrix3x3(current_rot).getRPY(roll, pitch, yaw);\n\n\t// If we are not in simulation mode, merge the local map with the odometry data\n\tif (!simulation_mode) {\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr local_map(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tpcl::fromROSMsg(local_map_msg, *local_map);\n\t\tpcl::PointCloud<pcl::PointXYZ>::Ptr merged_map(new pcl::PointCloud<pcl::PointXYZ>);\n\t\tmerge_maps(local_map, laser_cloud, current_pos, current_rot, merged_map);\n\t\tpcl::toROSMsg(*merged_map, local_map_msg);\n\t}\n\t// Otherwise, just publish the laser scan\n\telse {\n\t\tpcl::toROSMsg(*laser_cloud, local_map_msg);\n\t}\n}\n", "CodeBleu_score": 45.70767592566053}, {"code": "void Occupy_map::map_update_laser(const sensor_msgs::LaserScanConstPtr & local_point, const nav_msgs::Odometry & odom)\tpcl::PointCloud<pcl::PointXYZ> local_map;\n\tpcl::PointCloud<pcl::PointXYZ> local_map_transformed;\n\tpcl::PointCloud<pcl::PointXYZ> local_map_transformed_merged;\n\tpcl::PointCloud<pcl::PointXYZ> local_map_transformed_merged_filtered;\n\n\t// Convert laser scan data to point cloud\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr laser_cloud (new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::fromROSMsg(*local_point, *laser_cloud);\n\n\t// Transform laser scan data to the robot's frame\n\tpcl::transformPointCloud(*laser_cloud, local_map, odom.pose.pose.orientation, odom.pose.pose.position);\n\n\t// Merge local map with odometry data\n\tif (!in_simulation_mode_) {\n\t\tpcl::transformPointCloud(*local_map_, local_map_transformed, odom.pose.pose.orientation, odom.pose.pose.position);\n\t\tpcl::concatenatePointCloud(local_map_transformed, local_map, local_map_transformed_merged);\n\t}\n\telse {\n\t\tlocal_map_transformed_merged = local_map;\n\t}\n\n\t// Filter out points outside of the map\n\tpcl::PassThrough<pcl::PointXYZ> pass;\n\tpass.setInputCloud(local_map_transformed_merged.makeShared());\n\tpass.setFilterFieldName(\"x\");\n\tpass.setFilterLimits(0.0, map_width_);\n\tpass.filter(local_map_transformed_merged_filtered);\n\tpass.setInputCloud(local_map_transformed_merged_filtered.makeShared());\n\tpass.setFilterFieldName(\"y\");\n\tpass.setFilterLimits(0.0, map_height_);\n\tpass.filter(local_map_transformed_merged_filtered);\n\n\t// Update the local map\n\tlocal_map_ = local_map_transformed_merged_filtered;\n}\n", "CodeBleu_score": 40.212501184735494}]}
{"instance_id": "6cd475e88f70", "generation_result": [{"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t// Convert the global point cloud map to a ROS message\n\tpcl::toROSMsg(*global_pcl_map, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\t// Publish the global point cloud\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Convert the inflated point cloud map to a ROS message\n\tpcl::toROSMsg(*inflate_pcl_map, inflate_pcl_msg);\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\t// Publish the inflated point cloud\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 52.131115269727765}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t// Convert global point cloud map to ROS message\n\tpcl::toROSMsg(*global_pcl, global_pcl_msg);\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\t// Publish global point cloud map\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Convert inflated point cloud map to ROS message\n\tpcl::toROSMsg(*inflate_pcl, inflate_pcl_msg);\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\t// Publish inflated point cloud map\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 51.56929799655661}, {"code": "void Occupy_map::pub_pcl_cb(const ros::TimerEvent& e)\t// Convert the global point cloud map to a ROS message\n\tsensor_msgs::PointCloud2 global_pcl_msg;\n\tpcl::toROSMsg(global_pcl_map, global_pcl_msg);\n\tglobal_pcl_msg.header.frame_id = \"world\";\n\tglobal_pcl_msg.header.stamp = ros::Time::now();\n\t// Publish the global point cloud map\n\tglobal_pcl_pub.publish(global_pcl_msg);\n\n\t// Convert and publish the inflated point cloud\n\tsensor_msgs::PointCloud2 inflate_pcl_msg;\n\tpcl::toROSMsg(inflate_pcl_map, inflate_pcl_msg);\n\tinflate_pcl_msg.header.frame_id = \"world\";\n\tinflate_pcl_msg.header.stamp = ros::Time::now();\n\tinflate_pcl_pub.publish(inflate_pcl_msg);\n}\n", "CodeBleu_score": 54.73666730538618}]}
{"instance_id": "09046bbcadb4", "generation_result": [{"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received LaserScan\");\n\t//ROS_INFO(\"Received L", "CodeBleu_score": 9.985729582596695}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\tif (msg->header.frame_id!= \"map\") {\n\t\tROS_WARN(\"Received pointcloud message with frame_id: %s\", msg->header.frame_id.c_str());\n\t\treturn;\n\t}\n\tif (!sensor_ready) {\n\t\tROS_INFO(\"Received first pointcloud message\");\n\t\tsensor_ready = true;\n\t}\n\tsensor_msgs::PointCloud2 cloud_in;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed_filtered_downsampled;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed_filtered_downsampled_final;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed_filtered_downsampled_final_transformed;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed_filtered_downsampled_final_transformed_filtered;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed_filtered_downsampled_final_transformed_filtered_downsampled;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed_filtered_downsampled_final_transformed_filtered_downsampled_final;\n\tpcl::PointCloud<pcl::PointXYZ> cloud_pcl_transformed_filtered_downsampled_final_transformed_filtered_downsampled", "CodeBleu_score": 44.84010133394135}, {"code": "void GlobalPlanner::Lpointcloud_cb(const sensor_msgs::PointCloud2ConstPtr &msg)\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO(\"Lpointcloud_cb\");\n\t//ROS_INFO", "CodeBleu_score": 8.485952566611562}]}
{"instance_id": "2202d147daad", "generation_result": [{"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get current time\n\tros::Time time = ros::Time::now();\n\n\t// Calculate target foot positions based on desired pose\n\tEigen::Vector3d target_foot_positions[4];\n\tbody_controller_->computeFootPositions(target_foot_positions);\n\n\t// Calculate velocity commands for legs\n\tEigen::Vector3d target_leg_velocities[4];\n\tleg_controller_->computeLegVelocities(target_foot_positions, target_leg_velocities);\n\n\t// Perform inverse kinematics to determine target joint positions\n\tEigen::VectorXd target_joint_positions[4];\n\tleg_controller_->computeLegJointPositions(target_leg_velocities, target_joint_positions);\n\n\t// Publish foot contact information\n\tfor (int i = 0; i < 4; i++) {\n\t\t// Create message\n\t\tgeometry_msgs::PointStamped foot_contact_point;\n\t\tfoot_contact_point.header.frame_id = \"base_link\";\n\t\tfoot_contact_point.header.stamp = time;\n\t\tfoot_contact_point.point.x = target_foot_positions[i](0);\n\t\tfoot_contact_point.point.y = target_foot_positions[i](1);\n\t\tfoot_contact_point.point.z = target_foot_positions[i](2);\n\n\t\t// Publish message\n\t\tfoot_contact_publisher_[i].publish(foot_contact_point);\n\t}\n\n\t// Publish joint positions\n\tfor (int i = 0; i < 4; i++) {\n\t\t// Create message\n\t\tsensor_msgs::JointState joint_state;\n\t\tjoint_state.header.frame_id = \"base_link\";\n\t\tjoint_state.header.stamp = time;\n\t\tjoint_state.name.push_back(\"leg\" + std::to_string(i + 1) + \"_joint_1\");\n\t\tjoint_state.name.push_back(\"leg\" + std::to_string(i + 1) + \"_joint_2\");\n\t\tjoint_state.name.push_back(\"leg\" + std::to_string(i + 1) + \"_joint_3\");\n\t\tjoint_state.name.push_back(\"leg\" + std", "CodeBleu_score": 48.348275105628744}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get the current time\n\tros::Time time = ros::Time::now();\n\n\t// Get the current pose\n\tgeometry_msgs::PoseStamped pose;\n\tpose_sub_.getMessage(pose);\n\n\t// Get the current foot positions\n\tgeometry_msgs::PoseStamped foot_positions[4];\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_position_subs_[i].getMessage(foot_positions[i]);\n\t}\n\n\t// Get the current joint positions\n\tsensor_msgs::JointState joint_state;\n\tjoint_state_sub_.getMessage(joint_state);\n\n\t// Get the current foot contact information\n\tstd_msgs::Bool foot_contact[4];\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contact_subs_[i].getMessage(foot_contact[i]);\n\t}\n\n\t// Compute the target joint positions\n\tstd::vector<double> target_joint_positions;\n\tfor (int i = 0; i < 4; i++) {\n\t\t// Compute the target foot position\n\t\tgeometry_msgs::PoseStamped target_foot_position;\n\t\ttarget_foot_position = body_controller_.computeTargetFootPosition(pose, i);\n\n\t\t// Compute the target joint positions\n\t\tstd::vector<double> target_joint_position = leg_controller_.computeTargetJointPosition(target_foot_position, foot_positions[i], joint_state, foot_contact[i]);\n\n\t\t// Add the target joint positions to the list\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\ttarget_joint_positions.push_back(target_joint_position[j]);\n\t\t}\n\t}\n\n\t// Publish the target joint positions\n\tstd_msgs::Float64MultiArray target_joint_positions_msg;\n\ttarget_joint_positions_msg.data = target_joint_positions;\n\ttarget_joint_positions_pub_.publish(target_joint_positions_msg);\n}\n", "CodeBleu_score": 45.10606537869338}, {"code": "void QuadrupedController::controlLoop_(const ros::TimerEvent& event)\t// Get the current time\n\tros::Time time = event.current_real;\n\n\t// Get the current pose\n\tEigen::Vector3d position;\n\tEigen::Quaterniond orientation;\n\tif (!getPose(position, orientation)) {\n\t\tROS_ERROR_STREAM(\"Failed to get pose\");\n\t\treturn;\n\t}\n\n\t// Get the desired pose\n\tEigen::Vector3d desired_position;\n\tEigen::Quaterniond desired_orientation;\n\tif (!getDesiredPose(desired_position, desired_orientation)) {\n\t\tROS_ERROR_STREAM(\"Failed to get desired pose\");\n\t\treturn;\n\t}\n\n\t// Get the current velocity\n\tEigen::Vector3d velocity;\n\tif (!getVelocity(velocity)) {\n\t\tROS_ERROR_STREAM(\"Failed to get velocity\");\n\t\treturn;\n\t}\n\n\t// Get the desired velocity\n\tEigen::Vector3d desired_velocity;\n\tif (!getDesiredVelocity(desired_velocity)) {\n\t\tROS_ERROR_STREAM(\"Failed to get desired velocity\");\n\t\treturn;\n\t}\n\n\t// Get the current acceleration\n\tEigen::Vector3d acceleration;\n\tif (!getAcceleration(acceleration)) {\n\t\tROS_ERROR_STREAM(\"Failed to get acceleration\");\n\t\treturn;\n\t}\n\n\t// Get the desired acceleration\n\tEigen::Vector3d desired_acceleration;\n\tif (!getDesiredAcceleration(desired_acceleration)) {\n\t\tROS_ERROR_STREAM(\"Failed to get desired acceleration\");\n\t\treturn;\n\t}\n\n\t// Get the current body orientation\n\tEigen::Quaterniond body_orientation;\n\tif (!getBodyOrientation(body_orientation)) {\n\t\tROS_ERROR_STREAM(\"Failed to get body orientation\");\n\t\treturn;\n\t}\n\n\t// Get the desired body orientation\n\tEigen::Quaterniond desired_body_orientation;\n\tif (!getDesiredBodyOrientation(desired_body_orientation)) {\n\t\tROS_ERROR_STREAM(\"Failed to get desired body orientation\");\n\t\treturn;\n\t}\n\n\t// Get the current body velocity\n\tEigen::Vector3d body_velocity;\n\tif (!getBodyVelocity(body_velocity)) {\n\t\tROS_ERROR_STREAM(\"Failed to get body velocity\");\n\t\treturn;\n\t}\n\n\t// Get the desired body velocity\n\tEigen::Vector3", "CodeBleu_score": 30.50005744997506}]}
{"instance_id": "1445b899d973", "generation_result": [{"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\tif (!foot_contacts_publisher_.get()) {\n\t\treturn;\n\t}\n\tif (!is_in_gazebo_) {\n\t\t// Create a new message\n\t\tfoot_contacts_msg_.header.stamp = ros::Time::now();\n\t\tfoot_contacts_msg_.header.frame_id = \"base_link\";\n\t\tfoot_contacts_msg_.contact_states.resize(4);\n\t\t// Populate the message\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\tfoot_contacts_msg_.contact_states[i] = ContactState::CONTACT;\n\t\t\t} else {\n\t\t\t\tfoot_contacts_msg_.contact_states[i] = ContactState::NO_CONTACT;\n\t\t\t}\n\t\t}\n\t\t// Publish the message\n\t\tfoot_contacts_publisher_->publish(foot_contacts_msg_);\n\t}\n}\n", "CodeBleu_score": 46.73206635875593}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\tif (foot_contacts_publishing_enabled_ &&!is_in_gazebo_) {\n\t\t// Create message\n\t\tgeometry_msgs::msg::Point point;\n\t\tstd::vector<geometry_msgs::msg::Point> points;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (foot_contacts[i]) {\n\t\t\t\tpoint.x = 1.0;\n\t\t\t\tpoint.y = 1.0;\n\t\t\t\tpoint.z = 1.0;\n\t\t\t} else {\n\t\t\t\tpoint.x = 0.0;\n\t\t\t\tpoint.y = 0.0;\n\t\t\t\tpoint.z = 0.0;\n\t\t\t}\n\t\t\tpoints.push_back(point);\n\t\t}\n\t\tgeometry_msgs::msg::Vector3 vector3;\n\t\tvector3.x = 0.0;\n\t\tvector3.y = 0.0;\n\t\tvector3.z = 0.0;\n\t\tgeometry_msgs::msg::Vector3 vector3_2;\n\t\tvector3_2.x = 0.0;\n\t\tvector3_2.y = 0.0;\n\t\tvector3_2.z = 0.0;\n\t\tgeometry_msgs::msg::Vector3 vector3_3;\n\t\tvector3_3.x = 0.0;\n\t\tvector3_3.y = 0.0;\n\t\tvector3_3.z = 0.0;\n\t\tgeometry_msgs::msg::Vector3 vector3_4;\n\t\tvector3_4.x = 0.0;\n\t\tvector3_4.y = 0.0;\n\t\tvector3_4.z = 0.0;\n\t\tgeometry_msgs::msg::Vector3 vector3_5;\n\t\tvector3_5.x = 0.0;\n\t\tvector3_5.y = 0.0;\n\t\tvector3_5.z = 0.0;\n\t\tgeometry_msgs::msg::Vector3 vector3_6;\n\t\tvector3_6.x = 0.0;\n\t\tvector3_6.y = 0.0;\n\t\tvector3_6.z = 0.0;\n\t\tgeometry_msgs::msg::Vector", "CodeBleu_score": 40.31687275583333}, {"code": "void QuadrupedController::publishFootContacts_(bool foot_contacts[4])\tif (foot_contacts_publisher_.getNumSubscribers() == 0 || gazebo_mode_) {\n\t\treturn;\n\t}\n\n\t// Create message\n\tstd_msgs::Header header;\n\theader.stamp = ros::Time::now();\n\theader.frame_id = \"world\";\n\n\t// Populate message\n\tstd_msgs::BoolMultiArray foot_contacts_msg;\n\tfoot_contacts_msg.header = header;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfoot_contacts_msg.data.push_back(foot_contacts[i]);\n\t}\n\n\t// Publish message\n\tfoot_contacts_publisher_.publish(foot_contacts_msg);\n}\n", "CodeBleu_score": 44.63164650937408}]}
{"instance_id": "7bcb5cb4a4e6", "generation_result": [{"code": "def joints_cmd_callback(self, joints)\t// Create a joints message with the first 12 joint positions\n\tvar joints_msg = new ROSLIB.Message({\n\t\tname: self.joint_names,\n\t\tposition: joints.slice(0, 12)\n\t});\n\n\t// Publish the joints message\n\tself.joints_pub.publish(joints_msg);\n\n\t// Create a joint trajectory message with the first 12 joint positions and a specified duration\n\tvar trajectory_msg = new ROSLIB.Message({\n\t\theader: {\n\t\t\tstamp: new ROSLIB.Time({\n\t\t\t\tnsecs: 0\n\t\t\t})\n\t\t},\n\t\tjoint_names: self.joint_names,\n\t\tpoints: [{\n\t\t\ttime_from_start: new ROSLIB.Duration({\n\t\t\t\tsecs: 0,\n\t\t\t\tnsecs: 100000000\n\t\t\t}),\n\t\t\tpositions: joints.slice(0, 12)\n\t\t}]\n\t});\n\n\t// Publish the trajectory message\n\tself.trajectory_pub.publish(trajectory_msg);\n}\n", "CodeBleu_score": 31.01322686169963}, {"code": "def joints_cmd_callback(self, joints)\t# Create a minimal joints message with the first 12 joint positions\n\tvar joints_msg = Joints()\n\tjoints_msg.name = joints.name[0:12]\n\tjoints_msg.position = joints.position[0:12]\n\n\t# Publish the joints message\n\tself.joints_pub.publish(joints_msg)\n\n\t# Construct a joint trajectory message with the same positions and a specified duration\n\tvar trajectory_msg = JointTrajectory()\n\ttrajectory_msg.joint_names = joints_msg.name\n\ttrajectory_msg.points.append(JointTrajectoryPoint())\n\ttrajectory_msg.points[0].positions = joints_msg.position\n\ttrajectory_msg.points[0].time_from_start = Duration(1.0)\n\n\t# Publish the trajectory message\n\tself.trajectory_pub.publish(trajectory_msg)\n}\n", "CodeBleu_score": 38.883994909997696}, {"code": "def joints_cmd_callback(self, joints)\t// Create a minimal joints message with the first 12 joint positions\n\tvar joint_msg = new JointState();\n\tjoint_msg.name = self.joint_names;\n\tjoint_msg.position = joints.position.slice(0,12);\n\tjoint_msg.header.stamp = new ROSLIB.Header({\n\t\tstamp: new ROSLIB.Time({\n\t\t\tsecs: 0,\n\t\t\tnsecs: 0\n\t\t})\n\t});\n\n\t// Publish the joints message\n\tself.joint_pub.publish(joint_msg);\n\n\t// Construct a joint trajectory message with the same positions and a specified duration\n\tvar traj_msg = new JointTrajectory();\n\ttraj_msg.header.stamp = new ROSLIB.Header({\n\t\tstamp: new ROSLIB.Time({\n\t\t\tsecs: 0,\n\t\t\tnsecs: 0\n\t\t})\n\t});\n\ttraj_msg.joint_names = self.joint_names;\n\ttraj_msg.points.push(new JointTrajectoryPoint({\n\t\tpositions: joints.position.slice(0,12),\n\t\ttime_from_start: new ROSLIB.Duration({\n\t\t\tsecs: 0,\n\t\t\tnsecs: 0\n\t\t})\n\t}));\n\n\t// Publish the trajectory message\n\tself.traj_pub.publish(traj_msg);\n}\n", "CodeBleu_score": 35.162623504996404}]}
{"instance_id": "955237744a73", "generation_result": [{"code": "void gazeboCallback_(ConstContactsPtr &_msg)\t// Get the number of contacts\n\tint numContacts = _msg->contact_size();\n\n\t// Initialize foot contact states to false\n\tfor (int i = 0; i < numContacts; i++) {\n\t\tfootContactStates_[i] = false;\n\t}\n\n\t// For each contact in the message\n\tfor (int i = 0; i < numContacts; i++) {\n\t\t// Split the collision string\n\t\tstd::vector<std::string> collision = splitString(_msg->contact(i).collision1(), '/');\n\n\t\t// If the collision string matches one of the foot links\n\t\tif (collision[0] == \"l_foot\" || collision[0] == \"r_foot\") {\n\t\t\t// Set the corresponding foot contact state to true\n\t\t\tfootContactStates_[i] = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 46.96896261378307}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\t// Initialize foot contact states to false\n\tfor (int i = 0; i < 2; i++) {\n\t\tfootContactState_[i] = false;\n\t}\n\n\t// For each contact in the message\n\tfor (int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split the collision string to identify the contact link\n\t\tstd::vector<std::string> collision = split(_msg->contact(i).collision1(), \"/\");\n\t\tstd::string linkName = collision[collision.size() - 1];\n\n\t\t// If a contact matches one of the foot links\n\t\tif (linkName == footLink_[0] || linkName == footLink_[1]) {\n\t\t\t// Set the corresponding foot contact state to true\n\t\t\tfootContactState_[linkName == footLink_[0]? 0 : 1] = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 55.78760582000501}, {"code": "void gazeboCallback_(ConstContactsPtr &_msg)\t// Initialize foot contact states to false.\n\tleftFootContactState_ = false;\n\trightFootContactState_ = false;\n\t// For each contact in the message, split the collision string to identify the contact link.\n\tfor (unsigned int i = 0; i < _msg->contact_size(); i++) {\n\t\t// Split the collision string to identify the contact link.\n\t\tstd::vector<std::string> contactLink = splitString(_msg->contact(i).collision1(), \"/\");\n\t\t// If a contact matches one of the foot links, set the corresponding foot contact state to true.\n\t\tif (contactLink[contactLink.size() - 1] == leftFootLinkName_) {\n\t\t\tleftFootContactState_ = true;\n\t\t} else if (contactLink[contactLink.size() - 1] == rightFootLinkName_) {\n\t\t\trightFootContactState_ = true;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 34.61862730491616}]}
{"instance_id": "9ff80dc14572", "generation_result": [{"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\tif (!is_active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Ensure input and parameters are valid\n\tif (rotor_velocities->size()!= 4) {\n\t\tthrow std::invalid_argument(\"rotor_velocities must have size 4\");\n\t}\n\n\tif (!parameters_.has_value()) {\n\t\tthrow std::invalid_argument(\"LeePositionController::CalculateRotorVelocities: parameters not set\");\n\t}\n\n\t// Compute desired acceleration and angular acceleration\n\tEigen::Vector3d acceleration = parameters_->K_p * (parameters_->position_target - position_) + parameters_->K_d * (parameters_->velocity_target - velocity_);\n\tEigen::Vector3d angular_acceleration = parameters_->K_p_angular * (parameters_->angular_position_target - angular_position_) + parameters_->K_d_angular * (parameters_->angular_velocity_target - angular_velocity_);\n\n\t// Project thrust onto body z-axis\n\tEigen::Vector3d thrust = parameters_->m * acceleration;\n\n\t// Combine angular acceleration and thrust into a single vector\n\tEigen::Vector3d a_w = angular_acceleration + thrust / parameters_->m;\n\n\t// Compute rotor velocities\n\tEigen::Vector4d w = Eigen::Vector4d::Zero();\n\tw(0) = std::sqrt(std::max(0.0, a_w(0)));\n\tw(1) = std::sqrt(std::max(0.0, a_w(1)));\n\tw(2) = std::sqrt(std::max(0.0, a_w(2)));\n\tw(3) = std::sqrt(std::max(0.0, -a_w(0) - a_w(1) - a_w(2)));\n\n\t*rotor_velocities = w;\n}\n", "CodeBleu_score": 39.475972878708006}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Ensure the input is valid\n\tif (rotor_velocities == NULL) {\n\t\tstd::cout << \"ERROR: rotor_velocities is NULL\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the controller is active\n\tif (!active_) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Ensure the parameters are valid\n\tif (rotor_configuration_.size()!= rotor_velocities->size()) {\n\t\tstd::cout << \"ERROR: rotor_velocities size does not match rotor_configuration\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the parameters are valid\n\tif (rotor_configuration_.size()!= rotor_velocities->size()) {\n\t\tstd::cout << \"ERROR: rotor_velocities size does not match rotor_configuration\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the parameters are valid\n\tif (rotor_configuration_.size()!= rotor_velocities->size()) {\n\t\tstd::cout << \"ERROR: rotor_velocities size does not match rotor_configuration\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the parameters are valid\n\tif (rotor_configuration_.size()!= rotor_velocities->size()) {\n\t\tstd::cout << \"ERROR: rotor_velocities size does not match rotor_configuration\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the parameters are valid\n\tif (rotor_configuration_.size()!= rotor_velocities->size()) {\n\t\tstd::cout << \"ERROR: rotor_velocities size does not match rotor_configuration\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the parameters are valid\n\tif (rotor_configuration_.size()!= rotor_velocities->size()) {\n\t\tstd::cout << \"ERROR: rotor_velocities size does not match rotor_configuration\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the parameters are valid\n\tif (rotor_configuration_.size()!= rotor_velocities->size()) {\n\t\tstd::cout << \"ERROR: rotor_velocities size does not", "CodeBleu_score": 29.306023285303016}, {"code": "void LeePositionController::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Ensure the input is valid\n\tif (!rotor_velocities) {\n\t\tthrow std::invalid_argument(\"rotor_velocities is NULL\");\n\t}\n\tif (rotor_velocities->size()!= 4) {\n\t\tthrow std::invalid_argument(\"rotor_velocities is not of size 4\");\n\t}\n\tif (!this->active) {\n\t\trotor_velocities->setZero();\n\t\treturn;\n\t}\n\n\t// Calculate the desired acceleration\n\tEigen::Vector3d acceleration = this->CalculateAcceleration();\n\n\t// Calculate the desired angular acceleration\n\tEigen::Vector3d angular_acceleration = this->CalculateAngularAcceleration();\n\n\t// Calculate the desired thrust\n\tEigen::Vector3d thrust = this->CalculateThrust();\n\n\t// Calculate the desired torque\n\tEigen::Vector3d torque = this->CalculateTorque();\n\n\t// Calculate the desired acceleration and angular acceleration\n\tEigen::VectorXd acceleration_and_angular_acceleration = Eigen::VectorXd::Zero(6);\n\tacceleration_and_angular_acceleration.segment(0, 3) = acceleration;\n\tacceleration_and_angular_acceleration.segment(3, 3) = angular_acceleration;\n\n\t// Calculate the desired thrust and torque\n\tEigen::VectorXd thrust_and_torque = Eigen::VectorXd::Zero(6);\n\tthrust_and_torque.segment(0, 3) = thrust;\n\tthrust_and_torque.segment(3, 3) = torque;\n\n\t// Calculate the desired acceleration and angular acceleration\n\tEigen::VectorXd acceleration_and_angular_acceleration_and_thrust_and_torque = Eigen::VectorXd::Zero(12);\n\tacceleration_and_angular_acceleration_and_thrust_and_torque.segment(0, 6) = acceleration_and_angular_acceleration;\n\tacceleration_and_angular_acceleration_and_thrust_and_torque.segment(6, 6) = thrust_and_torque;\n\n\t// Calculate the desired acceleration and angular acceleration\n\tEigen::VectorXd desired_acceleration_and_angular_acceleration = Eigen::VectorXd::Zero(6);\n\tdesired_acceleration_and_angular_acceleration.segment(0,", "CodeBleu_score": 37.60191080054929}]}
{"instance_id": "4f7b2beea6a5", "generation_result": [{"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// Calculate the position and velocity errors\n\tEigen::Vector3d position_error = position_command_ - current_odometry_.position;\n\tEigen::Vector3d velocity_error = velocity_command_ - current_odometry_.velocity;\n\n\t// Transform the velocity error to the world frame\n\tEigen::Vector3d velocity_error_world = current_odometry_.rotation.transpose() * velocity_error;\n\n\t// Calculate the desired acceleration\n\tEigen::Vector3d desired_acceleration = position_gain_ * position_error + velocity_gain_ * velocity_error_world;\n\tdesired_acceleration -= gravity_ * Eigen::Vector3d(0.0, 0.0, 1.0);\n\tdesired_acceleration += mass_ * acceleration_command_;\n\n\t// Set the desired acceleration\n\tacceleration->setZero();\n\t*acceleration = desired_acceleration;\n}\n", "CodeBleu_score": 41.95448024643934}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// Compute position and velocity errors.\n\tEigen::Vector3d position_error = position_command_ - position_;\n\tEigen::Vector3d velocity_error = velocity_command_ - velocity_;\n\n\t// Transform the vehicle's velocity to the world frame.\n\tEigen::Vector3d velocity_world = world_from_body_.rotation().transpose() * velocity_;\n\n\t// Compute the desired acceleration.\n\tEigen::Vector3d desired_acceleration = acceleration_command_;\n\tdesired_acceleration -= position_gain_ * position_error;\n\tdesired_acceleration -= velocity_gain_ * velocity_error;\n\tdesired_acceleration -= velocity_gain_ * velocity_world;\n\tdesired_acceleration += mass_ * gravity_;\n\t*acceleration = desired_acceleration;\n}\n", "CodeBleu_score": 37.937099398537825}, {"code": "void LeePositionController::ComputeDesiredAcceleration(Eigen::Vector3d* acceleration) const\t// get current position and velocity\n\tEigen::Vector3d current_position = current_odometry_->position();\n\tEigen::Vector3d current_velocity = current_odometry_->velocity();\n\n\t// get desired position and velocity\n\tEigen::Vector3d desired_position = desired_odometry_->position();\n\tEigen::Vector3d desired_velocity = desired_odometry_->velocity();\n\n\t// compute position error\n\tEigen::Vector3d position_error = desired_position - current_position;\n\n\t// compute velocity error\n\tEigen::Vector3d velocity_error = desired_velocity - current_velocity;\n\n\t// transform velocity to world frame\n\tEigen::Vector3d world_velocity = world_to_vehicle_ * current_velocity;\n\n\t// compute desired acceleration\n\t*acceleration = (position_gain_ * position_error) + (velocity_gain_ * velocity_error) + (world_velocity * mass_) + (Eigen::Vector3d(0, 0, -mass_ * gravity_));\n}\n\n} /* namespace lee_position_controller */", "CodeBleu_score": 43.943368744552565}]}
{"instance_id": "e56a7d85a6c8", "generation_result": [{"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Ensure the input is valid\n\tif (rotor_velocities == nullptr) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities is nullptr\" << std::endl;\n\t\treturn;\n\t}\n\tif (rotor_velocities->size()!= num_rotors_) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: rotor_velocities size does not match the number of rotors\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the input is valid\n\tif (thrust_reference_ == nullptr) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference_ is nullptr\" << std::endl;\n\t\treturn;\n\t}\n\tif (thrust_reference_->size()!= num_rotors_) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: thrust_reference_ size does not match the number of rotors\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the input is valid\n\tif (angular_acceleration_reference_ == nullptr) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: angular_acceleration_reference_ is nullptr\" << std::endl;\n\t\treturn;\n\t}\n\tif (angular_acceleration_reference_->size()!= 3) {\n\t\tstd::cerr << \"AttitudeControllerSamy::CalculateRotorVelocities: angular_acceleration_reference_ size does not match the number of rotors\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Calculate the desired angular acceleration\n\tEigen::Vector3d desired_angular_acceleration = *angular_acceleration_reference_ + *thrust_reference_;\n\n\t// Calculate the rotor velocities\n\tEigen::VectorXd rotor_velocities_temp = rotor_velocities_matrix_ * desired_angular_acceleration;\n\n\t// Ensure the rotor velocities are at least one\n\trotor_velocities_temp = rotor_velocities_temp.cwiseMax(Eigen::VectorXd::Constant(num_rotors_, 1.0));\n\n\t// Take the square root of each component\n\tfor (int", "CodeBleu_score": 32.66341488784717}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// Ensure the input is valid\n\tif (rotor_velocities->size()!= rotors_number) {\n\t\tstd::cerr << \"Error: rotor_velocities vector size does not match the number of rotors.\" << std::endl;\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Calculate the desired angular acceleration\n\tEigen::VectorXd angular_acceleration = CalculateAngularAcceleration();\n\n\t// Combine the desired angular acceleration with the thrust reference\n\tEigen::VectorXd combined_acceleration = angular_acceleration + thrust_reference;\n\n\t// Calculate the rotor velocities\n\tEigen::VectorXd desired_rotor_velocities = combined_acceleration.array().sqrt();\n\n\t// Ensure the rotor velocities are at least one\n\tdesired_rotor_velocities = desired_rotor_velocities.max(Eigen::VectorXd::Constant(desired_rotor_velocities.size(), 1.0));\n\n\t// Set the rotor velocities\n\t*rotor_velocities = desired_rotor_velocities;\n}\n", "CodeBleu_score": 41.89646709132656}, {"code": "void AttitudeControllerSamy::CalculateRotorVelocities(Eigen::VectorXd* rotor_velocities) const\t// TODO: Finish this function!\n\t// Right now it has some or all of the same code as the dummy in the template\n\t// Make sure to test the values you output with the dummy so you know if your\n\t// code is working or not!\n\n\t// Ensure the inputs are valid\n\tif (rotor_velocities == NULL) {\n\t\tstd::cerr << \"\\033[1;31mERROR: rotor_velocities cannot be NULL!\\033[0m\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the number of rotors is valid\n\tif (rotor_velocities->size()!= rotor_count_) {\n\t\tstd::cerr << \"\\033[1;31mERROR: rotor_velocities must be the same size as rotor_count!\\033[0m\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Ensure the rotor velocities are valid\n\tif (rotor_velocities->minCoeff() < 0) {\n\t\tstd::cerr << \"\\033[1;31mERROR: rotor_velocities cannot be negative!\\033[0m\" << std::endl;\n\t\treturn;\n\t}\n\n\t// Calculate the desired angular acceleration\n\tEigen::VectorXd desired_angular_acceleration = CalculateDesiredAngularAcceleration();\n\n\t// Combine the desired angular acceleration and thrust reference into a single vector\n\tEigen::VectorXd combined_vector = desired_angular_acceleration + thrust_reference_;\n\n\t// Reshape the combined vector to match the number of rotors\n\tcombined_vector.resize(rotor_count_);\n\n\t// Calculate the rotor velocities\n\t*rotor_velocities = rotor_matrix_ * combined_vector;\n\n\t// Ensure the rotor velocities are at least 1\n\trotor_velocities->array().max(1.0);\n\n\t// Take the square root of each rotor velocity\n\trotor_velocities->array().sqrt();\n}\n", "CodeBleu_score": 43.40318536834612}]}
{"instance_id": "cdf0e9e497da", "generation_result": [{"code": "def slice(self, start_time, end_time)\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    for attribute in self.__dict__:\n        sliced_object.__dict__[attribute] = self.__dict__[attribute][start_index:end_index]\n    return sliced_object\n\n  def get_index(self, time):\n    \"\"\"This function, get_index, returns the index of the time specified in the object's time attribute.\"\"\"\n    return np.where(self.time == time)[0][0]\n\n  def get_time(self, index):\n    \"\"\"This function, get_time, returns the time of the index specified in the object's time attribute.\"\"\"\n    return self.time[index]\n\n  def get_data(self, index):\n    \"\"\"This function, get_data, returns the data of the index specified in the object's data attribute.\"\"\"\n    return self.data[index]\n\n  def get_data_by_time(self, time):\n    \"\"\"This function, get_data_by_time, returns the data of the time specified in the object's data attribute.\"\"\"\n    return self.data[self.get_index(time)]\n\n  def get_data_by_index(self, index):\n    \"\"\"This function, get_data_by_index, returns the data of the index specified in the object's data attribute.\"\"\"\n    return self.data[index]\n\n  def get_time_by_index(self, index):\n    \"\"\"This function, get_time_by_index, returns the time of the index specified in the object's time attribute.\"\"\"\n    return self.time[index]\n\n  def get_time_by_data(self, data):\n    \"\"\"This function, get_time_by_data, returns the time of the data specified in the object's time attribute.\"\"\"\n    return self.time[self.get_index(data)]\n\n  def get_data_by_time_range(self, start_time, end_time):\n    \"\"\"This function, get_data_by_time_range, returns the data of the time range specified in the object's data attribute.\"\"\"\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    return self.data[start_", "CodeBleu_score": 39.361012996952574}, {"code": "def slice(self, start_time, end_time)\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    sliced_object = copy.deepcopy(self)\n    for attribute in self.__dict__:\n        sliced_object.__dict__[attribute] = self.__dict__[attribute][start_index:end_index]\n    return sliced_object\n", "CodeBleu_score": 28.96683281536915}, {"code": "def slice(self, start_time, end_time)\n    #Find indices for start and end times\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    #Create a copy of the object\n    sliced_object = copy.deepcopy(self)\n    #Update each attribute of the object to contain only the sliced data\n    for attribute in sliced_object.__dict__.keys():\n        sliced_object.__dict__[attribute] = sliced_object.__dict__[attribute][start_index:end_index]\n    return sliced_object\n\n  def get_index(self, time):\n    \"\"\"This function, get_index, returns the index of the time value in the object's time attribute.\"\"\"\n    return np.where(self.time == time)[0][0]\n\n  def get_time(self, index):\n    \"\"\"This function, get_time, returns the time value at the specified index in the object's time attribute.\"\"\"\n    return self.time[index]\n\n  def get_value(self, index):\n    \"\"\"This function, get_value, returns the value at the specified index in the object's value attribute.\"\"\"\n    return self.value[index]\n\n  def get_time_value(self, time):\n    \"\"\"This function, get_time_value, returns the value at the specified time in the object's time attribute.\"\"\"\n    return self.value[self.get_index(time)]\n\n  def get_time_value_range(self, start_time, end_time):\n    \"\"\"This function, get_time_value_range, returns the values between the specified start_time and end_time in the object's time attribute.\"\"\"\n    start_index = self.get_index(start_time)\n    end_index = self.get_index(end_time)\n    return self.value[start_index:end_index]\n\n  def get_time_value_range_average(self, start_time, end_time):\n    \"\"\"This function, get_time_value_range_average, returns the average value between the specified start_time and end_time in the object's time attribute.\"\"\"\n    return np.mean(self.get_time_value_range(start_time, end_time))\n\n  def get_time_value_range_std(self, start_time, end_time):\n    \"\"\"This function,", "CodeBleu_score": 43.18148894861967}]}
{"instance_id": "6a6adb6de4fd", "generation_result": [{"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation\n    x = waypoint_msg.pose.pose.position.x\n    y = waypoint_msg.pose.pose.position.y\n    z = waypoint_msg.pose.pose.position.z\n    yaw = waypoint_msg.pose.pose.orientation.z\n\n    # Convert rotation to Euler angles\n    roll, pitch, yaw = tf.transformations.euler_from_quaternion([0, 0, yaw, 1])\n\n    # Create a Point object\n    point = Point(x, y, z, yaw)\n\n    # Check if current waypoint is different from last one\n    if not self.waypoints or self.waypoints[-1].position!= point.position or self.waypoints[-1].yaw!= point.yaw:\n      # Append new point, yaw, and corresponding times\n      self.waypoints.append(point)\n      self.yaw_list.append(yaw)\n      self.time_list.append(msg_time)\n      self.bag_time_list.append(bag_time)\n\n  def append_odometry(self, odometry_msg, msg_time, bag_time):\n    \"\"\"This function, append_odometry, appends data from an odometry message to its corresponding arrays.\\nIt extracts the position and rotation, converts the rotation to Euler angles, and creates a Point object.\\nIt checks if the current odometry is different from the last one by comparing position and yaw values.\\nIf the odometry is different, it appends the new point, yaw, and corresponding times to their respective arrays.\"\"\"\n    # Extract position and rotation\n    x = odometry_msg.pose.pose.position.x\n    y = odometry_msg.pose.pose.position.y\n    z = odometry_msg.pose.pose.position.z\n    yaw = odometry_msg.pose.pose.orientation.z\n\n    # Convert rotation to Euler angles\n    roll, pitch, yaw = tf.transformations.euler_from_quaternion([0, 0, yaw, 1])\n\n    # Create a Point object\n    point = Point(x, y, z, yaw)\n\n    # Check if current odometry is different from last one\n    if not self.odometries or self.odometries[-1].position!= point.position or self.odometries[-1].yaw!= point.yaw:\n      #", "CodeBleu_score": 32.78833315828784}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    orientation = waypoint_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    quaternion = (orientation.x, orientation.y, orientation.z, orientation.w)\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n\n    # Create a Point object\n    point = Point(position.x, position.y, euler[2])\n\n    # Check if the current waypoint is different from the last one by comparing position and yaw values\n    if self.last_waypoint is None or (point.x!= self.last_waypoint.x or point.y!= self.last_waypoint.y or point.yaw!= self.last_waypoint.yaw):\n      # Append the new point, yaw, and corresponding times to their respective arrays\n      self.waypoints.append(point)\n      self.waypoints_yaw.append(point.yaw)\n      self.waypoints_time.append(msg_time - bag_time)\n      self.last_waypoint = point\n\n  def append_odometry(self, odometry_msg, msg_time, bag_time):\n    \"\"\"This function, append_odometry, appends data from an odometry message to its corresponding arrays.\\nIt extracts the position and rotation, converts the rotation to Euler angles, and creates a Point object.\\nIt checks if the current odometry is different from the last one by comparing position and yaw values.\\nIf the odometry is different, it appends the new point, yaw, and corresponding times to their respective arrays.\"\"\"\n    # Extract position and rotation\n    position = odometry_msg.pose.pose.position\n    orientation = odometry_msg.pose.pose.orientation\n\n    # Convert rotation to Euler angles\n    quaternion = (orientation.x, orientation.y, orientation.z, orientation.w)\n    euler = tf.transformations.euler_from_quaternion(quaternion)\n\n    # Create a Point object\n    point = Point(position.x, position.y, euler[2])\n\n    # Check if the current odometry is different from the last one by comparing position and yaw values\n    if self.last_odometry is None or (point.x!= self.last_odometry.x or point.y!= self.last_odometry.y or point", "CodeBleu_score": 33.672793845779395}, {"code": "def append_waypoint(self, waypoint_msg, msg_time, bag_time)\n    # Extract position and rotation\n    position = waypoint_msg.pose.pose.position\n    rotation = waypoint_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create Point object\n    point = Point(position.x, position.y, euler[2])\n    # Check if current waypoint is different from last one\n    if len(self.waypoints) == 0 or (point.x!= self.waypoints[-1].x or point.y!= self.waypoints[-1].y or point.yaw!= self.waypoints[-1].yaw):\n      # Append new point, yaw, and time to their respective arrays\n      self.waypoints.append(point)\n      self.yaw_values.append(point.yaw)\n      self.time_values.append(msg_time - bag_time)\n\n  def append_odom(self, odom_msg, msg_time, bag_time):\n    \"\"\"This function, append_odom, appends data from an odometry message to its corresponding arrays.\\nIt extracts the position and rotation, converts the rotation to Euler angles, and creates a Point object.\\nIt checks if the current odometry is different from the last one by comparing position and yaw values.\\nIf the odometry is different, it appends the new point, yaw, and corresponding times to their respective arrays.\"\"\"\n    # Extract position and rotation\n    position = odom_msg.pose.pose.position\n    rotation = odom_msg.pose.pose.orientation\n    # Convert rotation to Euler angles\n    euler = tf.transformations.euler_from_quaternion([rotation.x, rotation.y, rotation.z, rotation.w])\n    # Create Point object\n    point = Point(position.x, position.y, euler[2])\n    # Check if current odometry is different from last one\n    if len(self.odom) == 0 or (point.x!= self.odom[-1].x or point.y!= self.odom[-1].y or point.yaw!= self.odom[-1].yaw):\n      # Append new point, yaw, and time to their respective arrays\n      self.odom.append(point)", "CodeBleu_score": 36.09984876476564}]}
{"instance_id": "06de545616c1", "generation_result": [{"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == '/imu/data':\n        self.imu_data.append(msg.linear_acceleration.x)\n        self.imu_data.append(msg.linear_acceleration.y)\n        self.imu_data.append(msg.linear_acceleration.z)\n        self.imu_data.append(msg.header.stamp.secs)\n        self.imu_data.append(bag_time)\n        self.imu_data.append(msg.header.stamp.nsecs)\n        self.imu_data.append(msg.header.stamp.secs + (msg.header.stamp.nsecs / 1000000000))\n        self.imu_data.append(msg.header.stamp.secs + (msg.header.stamp.nsecs / 1000000000))\n    elif topic == '/imu/data_raw':\n        self.imu_data_raw.append(msg.linear_acceleration.x)\n        self.imu_data_raw.append(msg.linear_acceleration.y)\n        self.imu_data_raw.append(msg.linear_acceleration.z)\n        self.imu_data_raw.append(msg.header.stamp.secs)\n        self.imu_data_raw.append(bag_time)\n        self.imu_data_raw.append(msg.header.stamp.nsecs)\n        self.imu_data_raw.append(msg.header.stamp.secs + (msg.header.stamp.nsecs / 1000000000))\n        self.imu_data_raw.append(msg.header.stamp.secs + (msg.header.stamp.nsecs / 1000000000))\n    elif topic == '/imu/data_raw_calibrated':\n        self.imu_data_raw_calibrated.append(msg.linear_acceleration.x)\n        self.imu_data_raw_calibrated.append(msg.linear_acceleration.y)\n        self.imu_data_raw_calibrated.append(msg.linear_acceleration.z)\n        self.imu_data_raw_calibrated.append(msg.header.stamp.secs)\n        self.imu_data_raw_calibrated.append(", "CodeBleu_score": 24.517303061916653}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    # Extract IMU topics\n    if topic == \"/imu/data\":\n        self.imu_time.append(msg.header.stamp.to_sec())\n        self.imu_bag_time.append(bag_time)\n        self.imu_x_acc.append(msg.linear_acceleration.x)\n        self.imu_y_acc.append(msg.linear_acceleration.y)\n        self.imu_z_acc.append(msg.linear_acceleration.z)\n\n    elif topic == \"/imu/data_raw\":\n        self.imu_raw_time.append(msg.header.stamp.to_sec())\n        self.imu_raw_bag_time.append(bag_time)\n        self.imu_raw_x_acc.append(msg.linear_acceleration.x)\n        self.imu_raw_y_acc.append(msg.linear_acceleration.y)\n        self.imu_raw_z_acc.append(msg.linear_acceleration.z)\n\n    elif topic == \"/imu/data_mag\":\n        self.imu_mag_time.append(msg.header.stamp.to_sec())\n        self.imu_mag_bag_time.append(bag_time)\n        self.imu_mag_x_acc.append(msg.linear_acceleration.x)\n        self.imu_mag_y_acc.append(msg.linear_acceleration.y)\n        self.imu_mag_z_acc.append(msg.linear_acceleration.z)\n\n    elif topic == \"/imu/data_mag_cal\":\n        self.imu_mag_cal_time.append(msg.header.stamp.to_sec())\n        self.imu_mag_cal_bag_time.append(bag_time)\n        self.imu_mag_cal_x_acc.append(msg.linear_acceleration.x)\n        self.imu_mag_cal_y_acc.append(msg.linear_acceleration.y)\n        self.imu_mag_cal_z_acc.append(msg.linear_acceleration.z)\n\n    elif topic == \"/imu/data_mag_cal_raw\":\n        self.imu_mag_cal_raw_time.append(msg.header.stamp.to_sec())\n        self.imu_mag_cal_raw_bag_time.append(bag", "CodeBleu_score": 23.499565674791683}, {"code": "def extract_imu_topics(self, topic, msg, bag_time)\n    if topic == '/imu/linear_acceleration':\n        self.imu_time.append(msg.header.stamp.secs)\n        self.imu_bag_time.append(bag_time)\n        self.imu_x.append(msg.linear_acceleration.x)\n        self.imu_y.append(msg.linear_acceleration.y)\n        self.imu_z.append(msg.linear_acceleration.z)\n    else:\n        pass\n\n", "CodeBleu_score": 31.324943855569153}]}
{"instance_id": "d98100201d22", "generation_result": [{"code": "def plot_accelerations(self, plot_suffix=None)\n    fig, ax = plt.subplots()\n    ax.set_title('Acceleration')\n    for i in range(len(self.accelerations)):\n        ax.plot(self.accelerations[i].time, self.accelerations[i].x, label='x')\n        ax.plot(self.accelerations[i].time, self.accelerations[i].y, label='y')\n        ax.plot(self.accelerations[i].time, self.accelerations[i].z, label='z')\n    ax.set_xlabel('Time (s)')\n    ax.set_ylabel('Acceleration (m/s^2)')\n    ax.legend()\n    if self.save_plots:\n        filename = self.plot_prefix + 'accelerations'\n        if plot_suffix is not None:\n            filename += '_' + plot_suffix\n        filename += '.png'\n        fig.savefig(filename)\n    plt.show()\n", "CodeBleu_score": 38.13755001944028}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    if self.accelerations is None:\n        print(\"No acceleration data to plot\")\n        return\n    if plot_suffix is None:\n        plot_suffix = \"\"\n    plot_filename = self.plot_prefix + plot_suffix + \"_accelerations.png\"\n    plt.figure()\n    plt.title(\"Accelerations\")\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Acceleration (m/s^2)\")\n    for i in range(len(self.accelerations)):\n        plt.plot(self.accelerations[i][0], self.accelerations[i][1], label=\"x\")\n        plt.plot(self.accelerations[i][0], self.accelerations[i][2], label=\"y\")\n        plt.plot(self.accelerations[i][0], self.accelerations[i][3], label=\"z\")\n    plt.legend()\n    if self.save_plots:\n        plt.savefig(plot_filename)\n        print(\"Saved plot to \" + plot_filename)\n    plt.show()\n", "CodeBleu_score": 36.84071054741763}, {"code": "def plot_accelerations(self, plot_suffix=None)\n    # Create a figure with a title and a subplot for accelerations.\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.set_title(\"Accelerations\")\n    # Plot the x, y, and z components of each acceleration dataset over time.\n    for i, dataset in enumerate(self.accelerations):\n        ax.plot(dataset[\"timestamp\"], dataset[\"x\"], label=f\"x{i}\")\n        ax.plot(dataset[\"timestamp\"], dataset[\"y\"], label=f\"y{i}\")\n        ax.plot(dataset[\"timestamp\"], dataset[\"z\"], label=f\"z{i}\")\n    # Add labels for the x and y axes.\n    ax.set_xlabel(\"Timestamp\")\n    ax.set_ylabel(\"Acceleration (m/s^2)\")\n    # Add a legend to the plot.\n    ax.legend()\n    # If saving plots is enabled, construct a filename based on a prefix and optional suffix and save the plot as a PNG file.\n    if self.save_plots:\n        plot_filename = f\"accelerations{plot_suffix}.png\"\n        plt.savefig(plot_filename)\n        print(f\"Plot saved to {plot_filename}\")\n    # Show the plot.\n    plt.show()\n", "CodeBleu_score": 30.248106806347792}]}
{"instance_id": "7bd2685135d8", "generation_result": [{"code": "def compare_positions(self, pose_indeces)\n    #print(\"compare_positions\")\n    #print(pose_indeces)\n    #print(len(pose_indeces))\n    #print(len(self.poses))\n    if len(pose_indeces) < 2:\n        print(\"ERROR: compare_positions requires at least two pose indices to perform comparisons.\")\n        return\n    for i in range(len(pose_indeces)-1):\n        for j in range(i+1, len(pose_indeces)):\n            self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n    return\n\n", "CodeBleu_score": 37.43592966204807}, {"code": "def compare_positions(self, pose_indeces)\n    # Get the number of poses\n    num_poses = len(pose_indeces)\n    # Get the number of comparisons\n    num_comparisons = num_poses * (num_poses - 1) // 2\n    # Create a list of comparisons\n    comparisons = []\n    # Loop through the pose indices\n    for i in range(num_poses):\n        # Get the pose index\n        pose_index_i = pose_indeces[i]\n        # Loop through the subsequent pose indices\n        for j in range(i + 1, num_poses):\n            # Get the pose index\n            pose_index_j = pose_indeces[j]\n            # Compare the positions\n            comparison = self.compare_two_xyz(pose_index_i, pose_index_j)\n            # Append the comparison to the list of comparisons\n            comparisons.append(comparison)\n    # Return the list of comparisons\n    return comparisons\n\n  def compare_two_xyz(self, pose_index_i, pose_index_j):\n    \"\"\"This function, compare_two_xyz, compares the positions of two poses based on their indices.\\nIt requires two pose indices to perform the comparison.\\nIt returns a boolean value that indicates whether the two poses are within the threshold distance.\\nThe threshold distance is defined by the user and is set to 0.01 by default.\\nThe function uses the get_xyz_from_pose_index function to retrieve the positions of the poses and then compares them using the euclidean_distance function.\"\"\"\n    # Get the positions of the poses\n    xyz_i = self.get_xyz_from_pose_index(pose_index_i)\n    xyz_j = self.get_xyz_from_pose_index(pose_index_j)\n    # Compare the positions\n    distance = self.euclidean_distance(xyz_i, xyz_j)\n    # Return the comparison\n    return distance <= self.threshold_distance\n\n  def euclidean_distance(self, xyz_i, xyz_j):\n    \"\"\"This function, euclidean_distance, calculates the Euclidean distance between two points in 3D space.\\nIt requires two 3D points (xyz_i and xyz_j) to calculate the distance.\\nThe distance is calculated using the formula sqrt((x1-x2)^2 + (y1-y2)^2 + (z1", "CodeBleu_score": 27.75374060897453}, {"code": "def compare_positions(self, pose_indeces)\n    if len(pose_indeces) < 2:\n      raise ValueError(\"compare_positions requires at least two pose indices.\")\n    for i in range(len(pose_indeces) - 1):\n      for j in range(i + 1, len(pose_indeces)):\n        self.compare_two_xyz(pose_indeces[i], pose_indeces[j])\n\n  def compare_two_xyz(self, pose_index_1, pose_index_2):\n    \"\"\"This function, compare_two_xyz, compares the positions of two poses based on their indices.\\nIt requires two pose indices to perform comparisons.\\nIt compares the position of the first pose with the position of the second pose using the compare_two_xyz_values function.\"\"\"\n    if pose_index_1 == pose_index_2:\n      raise ValueError(\"The two poses to compare cannot be the same.\")\n    if pose_index_1 > len(self.poses) - 1 or pose_index_2 > len(self.poses) - 1:\n      raise ValueError(\"The pose indices must be less than the number of poses in the trajectory.\")\n    self.compare_two_xyz_values(self.poses[pose_index_1].xyz, self.poses[pose_index_2].xyz)\n\n  def compare_two_xyz_values(self, xyz_1, xyz_2):\n    \"\"\"This function, compare_two_xyz_values, compares the positions of two poses based on their xyz values.\\nIt requires two xyz values to perform comparisons.\\nIt compares the position of the first pose with the position of the second pose using the compare_two_xyz_values_values function.\"\"\"\n    self.compare_two_xyz_values_values(xyz_1, xyz_2)\n\n  def compare_two_xyz_values_values(self, xyz_1, xyz_2):\n    \"\"\"This function, compare_two_xyz_values_values, compares the positions of two poses based on their xyz values.\\nIt requires two xyz values to perform comparisons.\\nIt compares the position of the first pose with the position of the second pose using the compare_two_xyz_values_values_values function.\"\"\"\n    self.compare_two_xyz_values_values_values(xyz_1, xyz_2)\n\n ", "CodeBleu_score": 31.021963175363503}]}
{"instance_id": "faac3e9c9c1e", "generation_result": [{"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for collision in self.wrench:\n      if start_time <= collision.time <= end_time:\n        collision_times.append(collision.time)\n    return collision_times\n", "CodeBleu_score": 38.124697086273116}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collisions(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collisions, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for time in self.wrench:\n      if start_time <= time <= end_time:\n        collision_times.append(time)\n    return collision_times\n\n  def get_collisions(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collisions, retrieves", "CodeBleu_score": 37.714961919535604}, {"code": "def get_collisions(self, start_time=None, end_time=None)\n    collision_times = []\n    for collision in self.wrench:\n      if collision.time >= start_time and collision.time <= end_time:\n        collision_times.append(collision.time)\n    return collision_times\n\n  def get_collisions_by_type(self, start_time=None, end_time=None, collision_type=None):\n    \"\"\"This function, get_collisions_by_type, retrieves collision times within a specified time range by collision type.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, and the collision type is the same as the collision_type parameter, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for collision in self.wrench:\n      if collision.time >= start_time and collision.time <= end_time and collision.type == collision_type:\n        collision_times.append(collision.time)\n    return collision_times\n\n  def get_collision_times(self, start_time=None, end_time=None):\n    \"\"\"This function, get_collision_times, retrieves collision times within a specified time range.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, it appends the time to the collision_times list.\\nFinally, it returns the list of collision times.\"\"\"\n    collision_times = []\n    for collision in self.wrench:\n      if collision.time >= start_time and collision.time <= end_time:\n        collision_times.append(collision.time)\n    return collision_times\n\n  def get_collision_times_by_type(self, start_time=None, end_time=None, collision_type=None):\n    \"\"\"This function, get_collision_times_by_type, retrieves collision times within a specified time range by collision type.\\nIt initializes an empty list for collision times.\\nIt iterates through each collision's time in self.wrench, and if the time is within the start_time and end_time range, and the collision type is the same as the collision_type parameter, it app", "CodeBleu_score": 37.217772039231264}]}
{"instance_id": "2e743142ebc7", "generation_result": [{"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    end_time_settling = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time_settling, x_range, plot_suffix, [-1.5, 1.5])\n", "CodeBleu_score": 26.23654218218561}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n\n", "CodeBleu_score": 29.32422071502378}, {"code": "def plot_angular_velocities(analyze_bag, start_time, end_time, settling_time,\n                            x_range, plot_suffix)\n    settling_time = start_time + settling_time\n    analyze_bag.plot_angular_velocities(start_time, end_time, settling_time, x_range, plot_suffix, [-1.5, 1.5])\n", "CodeBleu_score": 29.32422071502378}]}
{"instance_id": "c1bd86aa7eb8", "generation_result": [{"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (!data) {\n\t\treturn;\n\t}\n\n\tEigen::Map<Eigen::VectorXf> depth_data(data, width * height);\n\n\tfloat multiplier = 1.0f / (depth_noise_std_dev_ * depth_noise_std_dev_);\n\tfloat rms_noise = 0.0f;\n\n\tfor (int i = 0; i < width * height; i++) {\n\t\tfloat noise = static_cast<float>(rand()) / static_cast<float>(RAND_MAX);\n\t\tfloat noise_val = multiplier * noise;\n\t\tfloat noise_val_abs = std::abs(noise_val);\n\n\t\tif (noise_val_abs < depth_noise_std_dev_) {\n\t\t\tdepth_data[i] += noise_val;\n\t\t} else {\n\t\t\tdepth_data[i] = bad_point_value_;\n\t\t}\n\n\t\trms_noise += noise_val_abs * noise_val_abs;\n\t}\n\n\trms_noise = std::sqrt(rms_noise / (width * height));\n\tstd::cout << \"D435DepthNoiseModel::ApplyNoise: RMS noise: \" << rms_noise << std::endl;\n}", "CodeBleu_score": 45.17616043430739}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (data == nullptr) {\n\t\treturn;\n\t}\n\n\tfloat multiplier = CalculateMultiplier(width, height);\n\tEigen::Map<Eigen::VectorXf> depthData(data, width * height);\n\n\tfloat rms_noise = CalculateRMSNoise(width, height, multiplier);\n\tfloat noise_value = CalculateNoiseValue(width, height, multiplier);\n\n\tfor (int i = 0; i < depthData.size(); i++) {\n\t\tif (depthData[i] < max_range_ && depthData[i] > min_range_) {\n\t\t\tdepthData[i] += noise_value * (static_cast<float>(rand()) / static_cast<float>(RAND_MAX));\n\t\t} else {\n\t\t\tdepthData[i] = bad_point_;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 44.85345536985281}, {"code": "void D435DepthNoiseModel::ApplyNoise(const uint32_t width,\n                                     const uint32_t height, float *data)\tif (data == nullptr) {\n\t\treturn;\n\t}\n\tEigen::Map<Eigen::VectorXf> depth(data, width * height);\n\tconst float multiplier = (float)height / (float)m_camera_params.height;\n\tfloat rms_noise = 0.0f;\n\tfloat noise_value = 0.0f;\n\tfor (uint32_t i = 0; i < depth.size(); i++) {\n\t\tif (depth(i) > m_camera_params.min_depth * multiplier && depth(i) < m_camera_params.max_depth * multiplier) {\n\t\t\tif (m_noise_type == NoiseType::Gaussian) {\n\t\t\t\tnoise_value = m_gaussian_noise_model.GetNoise(m_camera_params.min_depth * multiplier, m_camera_params.max_depth * multiplier);\n\t\t\t} else {\n\t\t\t\tnoise_value = m_uniform_noise_model.GetNoise(m_camera_params.min_depth * multiplier, m_camera_params.max_depth * multiplier);\n\t\t\t}\n\t\t\tdepth(i) += noise_value;\n\t\t\trms_noise += noise_value * noise_value;\n\t\t} else {\n\t\t\tdepth(i) = m_camera_params.bad_point;\n\t\t}\n\t}\n\trms_noise = std::sqrt(rms_noise / depth.size());\n\tm_rms_noise = rms_noise;\n}\n", "CodeBleu_score": 47.385890237445835}]}
{"instance_id": "52103858b08c", "generation_result": [{"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\t// Get current simulation time\n\tdouble sim_time = world_->GetSimTime().Double();\n\n\t// Convert to ROS time\n\tros::Time ros_time = ros::Time(sim_time);\n\n\t// Write to bag file\n\tbag_.write(namespace_ + \"/\" + waypoint_topic_, ros_time, trajectory_msg);\n}\n", "CodeBleu_score": 55.92901440129611}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\t// Get the current simulation time\n\tgazebo::common::Time current_time = gazebo_world_->GetSimTime();\n\t// Convert the simulation time to ROS time\n\tros::Time ros_time = ros::Time(current_time.sec, current_time.nsec);\n\t// Write the trajectory message to the bag file\n\tbag_file_->Write(waypoint_topic_, trajectory_msg, ros_time);\n}\n", "CodeBleu_score": 53.69254828106518}, {"code": "void GazeboBagPlugin::WaypointCallback(\n    const trajectory_msgs::MultiDOFJointTrajectoryConstPtr& trajectory_msg)\tif (trajectory_msg->points.size() > 0) {\n\t\tros::Time time = ros::Time::now();\n\t\ttrajectory_msgs::MultiDOFJointTrajectory trajectory_msg_copy = *trajectory_msg;\n\t\ttrajectory_msg_copy.header.stamp = time;\n\t\ttrajectory_msg_copy.header.frame_id = \"world\";\n\t\ttrajectory_msg_copy.header.seq++;\n\t\ttrajectory_msg_copy.header.stamp.sec = time.sec;\n\t\ttrajectory_msg_copy.header.stamp.nsec = time.nsec;\n\t\ttrajectory_msg_copy.header.frame_id = \"world\";\n\t\ttrajectory_msg_copy.header.seq++;\n\t\ttrajectory_msg_copy.header.stamp.sec = time.sec;\n\t\ttrajectory_msg_copy.header.stamp.nsec = time.nsec;\n\n\t\ttrajectory_msg_copy.header.frame_id = \"world\";\n\t\ttrajectory_msg_copy.header.seq++;\n\t\ttrajectory_msg_copy.header.stamp.sec = time.sec;\n\t\ttrajectory_msg_copy.header.stamp.nsec = time.nsec;\n\n\t\ttrajectory_msg_copy.header.frame_id = \"world\";\n\t\ttrajectory_msg_copy.header.seq++;\n\t\ttrajectory_msg_copy.header.stamp.sec = time.sec;\n\t\ttrajectory_msg_copy.header.stamp.nsec = time.nsec;\n\n\t\ttrajectory_msg_copy.header.frame_id = \"world\";\n\t\ttrajectory_msg_copy.header.seq++;\n\t\ttrajectory_msg_copy.header.stamp.sec = time.sec;\n\t\ttrajectory_msg_copy.header.stamp.nsec = time.nsec;\n\n\t\ttrajectory_msg_copy.header.frame_id = \"world\";\n\t\ttrajectory_msg_copy.header.seq++;\n\t\ttrajectory_msg_copy.header.stamp.sec = time.sec;\n\t\ttrajectory_msg_copy.header.stamp.nsec = time.nsec;\n\n\t\ttrajectory_msg_copy.header.frame_id = \"world\";\n\t\ttrajectory_msg_copy.header.seq++;\n\t\ttrajectory_msg_copy.header.stamp.sec = time.sec;\n\t\ttrajectory_msg_copy.header.", "CodeBleu_score": 39.04170033696263}]}
{"instance_id": "c657cbed871c", "generation_result": [{"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\tif (!this->isEnabled) {\n\t\treturn;\n\t}\n\n\t// Convert simulation time to ROS time\n\tros::Time rosTime = ros::Time::fromNSec(now.nsec);\n\n\t// Create a message for actuator velocities\n\tactuator_msgs::JointVelocities msg;\n\tmsg.header.stamp = rosTime;\n\n\t// Iterate through the motor joints\n\tfor (int i = 0; i < this->motorJoints.size(); i++) {\n\t\t// Get the motor joint\n\t\tphysics::JointPtr motorJoint = this->motorJoints[i];\n\n\t\t// Get the rotational velocity of the motor joint\n\t\tdouble rotationalVelocity = motorJoint->GetVelocity(0);\n\n\t\t// Calculate the slowed-down rotational velocity\n\t\tdouble slowedDownRotationalVelocity = rotationalVelocity / this->slowDownFactor;\n\n\t\t// Add the slowed-down rotational velocity to the message\n\t\tmsg.velocities.push_back(slowedDownRotationalVelocity);\n\t}\n\n\t// Write the message to the bag file\n\tthis->bag.write(this->motorTopic, rosTime, msg);\n}\n", "CodeBleu_score": 37.31896722724582}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\tif (this->motor_topic.empty()) return;\n\n\t// Get the current time in ROS format\n\tros::Time ros_now = ros::Time::fromNSec(now.nsec);\n\n\t// Prepare the message\n\tgazebo_msgs::MotorVelocities motor_velocities;\n\tmotor_velocities.header.stamp = ros_now;\n\n\t// Iterate through the motor joints and assign the velocities\n\tfor (auto &motor_joint : this->motor_joints) {\n\t\t// Get the joint\n\t\tgazebo::physics::JointPtr joint = this->world->GetJoint(motor_joint);\n\n\t\t// Get the joint velocity\n\t\tdouble joint_velocity = joint->GetVelocity(0);\n\n\t\t// Calculate the slowed-down joint velocity\n\t\tdouble slowed_down_joint_velocity = joint_velocity * this->slowdown_factor;\n\n\t\t// Assign the velocity to the message\n\t\tmotor_velocities.velocities.push_back(slowed_down_joint_velocity);\n\t}\n\n\t// Write the message to the bag file\n\tthis->motor_bag_file.write(this->motor_topic, ros_now, motor_velocities);\n}\n", "CodeBleu_score": 39.20394931758575}, {"code": "void GazeboBagPlugin::LogMotorVelocities(const common::Time now)\t// Convert simulation time to ROS time\n\tros::Time ros_time = ros::Time(now.sec, now.nsec);\n\n\t// Prepare message\n\tsensor_msgs::JointState msg;\n\tmsg.header.stamp = ros_time;\n\n\t// Iterate through motor joints\n\tfor (auto motor : this->motors) {\n\t\t// Get joint name\n\t\tstd::string joint_name = motor->GetScopedName();\n\n\t\t// Get joint velocity\n\t\tdouble joint_velocity = motor->GetVelocity(0);\n\n\t\t// Get joint velocity with slowdown\n\t\tdouble joint_velocity_slowdown = joint_velocity / this->slowdown_factor;\n\n\t\t// Assign to message\n\t\tmsg.name.push_back(joint_name);\n\t\tmsg.velocity.push_back(joint_velocity_slowdown);\n\t}\n\n\t// Write to bag file\n\tthis->bag.write(this->motor_topic, ros_time, msg);\n}\n", "CodeBleu_score": 43.36221538015417}]}
{"instance_id": "d35abe9c3114", "generation_result": [{"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#ifdef DEBUG_PRINTING\n  std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\" << std::endl;", "CodeBleu_score": 3.4147066217186195}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#ifdef DEBUG_PRINT_CALLBACKS\n  std::cout << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback\" << std::endl;", "CodeBleu_score": 3.441415067044807}, {"code": "void GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback(\n    GzRollPitchYawrateThrustMsgPtr& roll_pitch_yawrate_thrust_msg)#ifdef GAZEBO_DEBUG_PRINT_CALLBACKS\n  gzdbg << \"GazeboFwDynamicsPlugin::RollPitchYawrateThrustCallback() called.\\n\";", "CodeBleu_score": 2.991648036934133}]}
{"instance_id": "b025e662fa03", "generation_result": [{"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#ifdef GAZEBO_MAVLINK_INTERFACE_DEBUG_LOGGING\n  gzmsg << \"GazeboMavlinkInterface::pollForMAVLinkMessages()\" << std::endl;", "CodeBleu_score": 1.5046594552541526}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#ifdef GAZEBO_MAVLINK_INTERFACE_DEBUG\n  printf(\"GazeboMavlinkInterface::pollForMAVLinkMessages\\n\");", "CodeBleu_score": 1.4391371465768334}, {"code": "void GazeboMavlinkInterface::pollForMAVLinkMessages(\n    double _dt, uint32_t _timeoutMs)#ifdef _WIN32\n  // Windows does not support poll()\n  return;", "CodeBleu_score": 1.4044943820303513}]}
{"instance_id": "7fe2d4d0db74", "generation_result": [{"code": "void GazeboMavlinkInterface::close() \t// Lock mutex\n\tboost::unique_lock<boost::mutex> lock(this->mutex);\n\n\t// Check if interface is open\n\tif (this->isOpen) {\n\t\t// Stop the I/O service\n\t\tthis->ioService.stop();\n\n\t\t// Close the serial device\n\t\tthis->serial->close();\n\n\t\t// Check if the I/O thread is joinable\n\t\tif (this->ioThread.joinable()) {\n\t\t\t// Join the I/O thread\n\t\t\tthis->ioThread.join();\n\t\t}\n\n\t\t// Mark interface as closed\n\t\tthis->isOpen = false;\n\t}\n}\n", "CodeBleu_score": 26.386590946863027}, {"code": "void GazeboMavlinkInterface::close() \tif (this->isOpen()) {\n\t\tthis->ioService.stop();\n\t\tthis->serial->close();\n\t\tif (this->ioService.joinable()) {\n\t\t\tthis->ioService.join();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 26.871037857208847}, {"code": "void GazeboMavlinkInterface::close() \tif (this->isOpen()) {\n\t\tthis->stop();\n\t\tthis->serialPort.close();\n\t\tif (this->ioThread.joinable()) {\n\t\t\tthis->ioThread.join();\n\t\t}\n\t}\n}\n", "CodeBleu_score": 26.903806618347026}]}
{"instance_id": "9b62cd0071d5", "generation_result": [{"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\tconst ignition::math::Vector3d& pos,\n\tconst ignition::math::Vector3d& pos1,\n\tconst ignition::math::Vector3d& pos2,\n\tconst ignition::math::Vector3d& val1,\n\tconst ignition::math::Vector3d& val2\n} {\n\tignition::math::Vector3d result;\n\tignition::math::Vector3d diff = pos2 - pos1;\n\tignition::math::Vector3d diff2 = pos - pos1;\n\tdouble t = diff2.Dot(diff) / diff.Dot(diff);\n\tif (t < 0.0) {\n\t\tresult = val1;\n\t} else if (t > 1.0) {\n\t\tresult = val2;\n\t} else {\n\t\tresult = val1 + t * (val2 - val1);\n\t}\n\treturn result;\n}\n", "CodeBleu_score": 36.55980185186062}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\tdouble x1, y1, z1, x2, y2, z2, x, y, z;\n\tx1 = 0;\n\ty1 = 0;\n\tz1 = 0;\n\tx2 = 0;\n\ty2 = 0;\n\tz2 = 0;\n\tx = 0;\n\ty = 0;\n\tz = 0;\n\treturn ignition::math::Vector3d(x, y, z);\n}\n", "CodeBleu_score": 25.33167575297722}, {"code": "ignition::math::Vector3d GazeboWindPlugin::LinearInterpolation\tignition::math::Vector3d(0, 0, 0),\n\tignition::math::Vector3d(0, 0, 0),\n\tignition::math::Vector3d(0, 0, 0),\n\tignition::math::Vector3d(0, 0, 0)\n};\n", "CodeBleu_score": 22.02810093515131}]}
{"instance_id": "203d2baabb52", "generation_result": [{"code": "void Animation::SetTime(double _time)\tif (_time!= time) {\n\t\ttime = _time;\n\t\tif (looping) {\n\t\t\ttime = fmod(time, length);\n\t\t\tif (time < 0) {\n\t\t\t\ttime += length;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttime = std::max(0.0, std::min(time, length));\n\t\t}\n\t}\n}\n", "CodeBleu_score": 32.91346761025283}, {"code": "void Animation::SetTime(double _time)\tif (m_looping) {\n\t\twhile (_time < 0.0) {\n\t\t\t_time += m_length;\n\t\t}\n\t\twhile (_time > m_length) {\n\t\t\t_time -= m_length;\n\t\t}\n\t}\n\telse {\n\t\t_time = glm::clamp(_time, 0.0, m_length);\n\t}\n\n\tif (_time!= m_time) {\n\t\tm_time = _time;\n\n\t\tm_timePosition = m_time / m_length;\n\t}\n}\n", "CodeBleu_score": 33.92574487448291}, {"code": "void Animation::SetTime(double _time)\tif (m_time!= _time) {\n\t\tm_time = _time;\n\t\tif (m_time < 0) {\n\t\t\tm_time += m_length;\n\t\t}\n\t\telse if (m_time > m_length) {\n\t\t\tm_time -= m_length;\n\t\t}\n\t}\n}\n", "CodeBleu_score": 30.743272856915098}]}
{"instance_id": "8552ade39b9a", "generation_result": [{"code": "def hover(self)\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.set_target_motion(self.get_position(), self.get_yaw())\n    print(\"Vehicle type: %s, vehicle ID: %s, flight mode: %s\" % (self.get_vehicle_type(), self.get_vehicle_id(), self.get_flight_mode()))\n\n  def land(self):\n    \"\"\"This function, land, sets the vehicle's coordinate frame to 1 and motion type to 0.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.set_target_motion(self.get_position(), self.get_yaw())\n    print(\"Vehicle type: %s, vehicle ID: %s, flight mode: %s\" % (self.get_vehicle_type(), self.get_vehicle_id(), self.get_flight_mode()))\n\n  def set_frame(self, frame):\n    \"\"\"This function, set_frame, sets the vehicle's coordinate frame to the input frame.\\nThe input frame must be an integer between 0 and 3 inclusive.\"\"\"\n    if frame < 0 or frame > 3:\n      raise ValueError(\"Frame must be between 0 and 3 inclusive.\")\n    self.frame = frame\n\n  def get_frame(self):\n    \"\"\"This function, get_frame, returns the vehicle's coordinate frame.\"\"\"\n    return self.frame\n\n  def set_motion_type(self, motion_type):\n    \"\"\"This function, set_motion_type, sets the vehicle's motion type to the input motion type.\\nThe input motion type must be an integer between 0 and 2 inclusive.\"\"\"\n    if motion_type < 0 or motion_type > 2:\n      raise ValueError(\"Motion type must be between 0 and 2 inclusive.\")\n    self.motion_type = motion_type\n\n  def get_motion_type(self):\n    \"\"\"This function, get_motion_type, returns the vehicle's motion type.\"\"\"\n    return self.motion_type\n\n  def set_target_motion(self, target_position, target_yaw):\n    \"\"\"This function, set_target_motion, sets the vehicle's target motion to the input target", "CodeBleu_score": 24.84143144368916}, {"code": "def hover(self)\n    self.set_frame(1)\n    self.set_motion_type(0)\n    self.set_target_motion(self.get_position(), self.get_yaw())\n    print(self.get_vehicle_type(), self.get_vehicle_id(), self.get_flight_mode())\n\n  def set_target_motion(self, position, yaw):\n    \"\"\"This function, set_target_motion, sets the target position and yaw of the vehicle.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.set_target_position(position)\n    self.set_target_yaw(yaw)\n    print(self.get_vehicle_type(), self.get_vehicle_id(), self.get_flight_mode())\n\n  def set_target_position(self, position):\n    \"\"\"This function, set_target_position, sets the target position of the vehicle.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.target_position = position\n    print(self.get_vehicle_type(), self.get_vehicle_id(), self.get_flight_mode())\n\n  def set_target_yaw(self, yaw):\n    \"\"\"This function, set_target_yaw, sets the target yaw of the vehicle.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.target_yaw = yaw\n    print(self.get_vehicle_type(), self.get_vehicle_id(), self.get_flight_mode())\n\n  def get_target_position(self):\n    \"\"\"This function, get_target_position, returns the target position of the vehicle.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    return self.target_position\n\n  def get_target_yaw(self):\n    \"\"\"This function, get_target_yaw, returns the target yaw of the vehicle.\\nIt constructs a target motion using the current position and yaw.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    return self.target_yaw\n\n  def set_target_velocity(self, velocity", "CodeBleu_score": 18.755131480176665}, {"code": "def hover(self)\n    self.set_flight_mode(\"STABILIZE\")\n    self.set_position_target_local_ned(0,0,0,0,0,0,0,0)\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n  def set_flight_mode(self,flight_mode):\n    \"\"\"This function, set_flight_mode, sets the vehicle's flight mode to the input flight_mode.\\nIt then prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.vehicle.mode = VehicleMode(flight_mode)\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n  def arm(self):\n    \"\"\"This function, arm, arms the vehicle.\\nIt then prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.vehicle.armed = True\n    while not self.vehicle.armed:\n      print(\"Waiting for arming...\")\n      time.sleep(1)\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n  def disarm(self):\n    \"\"\"This function, disarm, disarms the vehicle.\\nIt then prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.vehicle.armed = False\n    print(\"Vehicle Type: %s\" % self.vehicle_type)\n    print(\"Vehicle ID: %s\" % self.vehicle_id)\n    print(\"Flight Mode: %s\" % self.flight_mode)\n\n  def set_position_target_local_ned(self,x,y,z,vx,vy,vz,yaw,yaw_rate):\n    \"\"\"This function, set_position_target_local_ned, sets the vehicle's position target to the input coordinates.\\nIt then prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    msg = vehicle_position_setpoint_s()\n    msg.type_mask = int('0x100", "CodeBleu_score": 22.401629711530262}]}
{"instance_id": "05c2de81ac63", "generation_result": [{"code": "def flight_mode_switch(self)\n    #hover mode\n    if self.flight_mode == 'HOVER':\n        self.hover = 1\n        self.hover_mode()\n        print('Switched to hover mode')\n        return True\n    #other modes\n    else:\n        #switch to hover mode\n        if self.flight_mode!= 'HOVER':\n            self.hover = 0\n            self.hover_mode()\n            #switch to new mode\n            if self.flight_mode!= 'HOVER':\n                try:\n                    self.flightModeService.switch_mode(self.flight_mode)\n                    print('Switched to'+ self.flight_mode +'mode')\n                    return True\n                except:\n                    print('Failed to switch to'+ self.flight_mode +'mode')\n                    return False\n", "CodeBleu_score": 35.58196531730255}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover()\n        return True\n    elif self.flight_mode == 'AUTO':\n        self.flight_mode = 'RTL'\n        return True\n    elif self.flight_mode == 'RTL':\n        self.flight_mode = 'AUTO'\n        return True\n    else:\n        self.flight_mode = 'AUTO'\n        return True\n", "CodeBleu_score": 39.54888105565417}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n        self.hover_flag = 1\n        self.hover()\n        print('Switched to HOVER mode.')\n        return True\n    else:\n        try:\n            self.flightModeService.change_mode(self.flight_mode)\n            print('Switched to {} mode.'.format(self.flight_mode))\n            return True\n        except:\n            print('Failed to switch to {} mode.'.format(self.flight_mode))\n            return False\n\n  def set_mode(self, mode):\n    \"\"\"This function, set_mode, sets the flight mode of a vehicle.\\nIt changes the flight mode of the vehicle to the mode specified in the argument.\\nIf the mode switch is successful, it prints a success message.\\nIf it fails, it prints a failure message.\"\"\"\n    if self.flight_mode_switch(mode):\n      self.flight_mode = mode\n    else:\n      print('Failed to set mode to {}.'.format(mode))\n\n  def set_velocity(self, velocity):\n    \"\"\"This function, set_velocity, sets the velocity of a vehicle.\\nIt sets the velocity of the vehicle to the velocity specified in the argument.\\nIt prints a success message if the velocity is set successfully, and a failure message otherwise.\"\"\"\n    try:\n      self.vehicle.velocity = velocity\n      print('Velocity set to {}.'.format(velocity))\n    except:\n      print('Failed to set velocity to {}.'.format(velocity))\n\n  def set_position(self, position):\n    \"\"\"This function, set_position, sets the position of a vehicle.\\nIt sets the position of the vehicle to the position specified in the argument.\\nIt prints a success message if the position is set successfully, and a failure message otherwise.\"\"\"\n    try:\n      self.vehicle.position = position\n      print('Position set to {}.'.format(position))\n    except:\n      print('Failed to set position to {}.'.format(position))\n\n  def set_attitude(self, attitude):\n    \"\"\"This function, set_attitude, sets the attitude of a vehicle.\\nIt sets the attitude of the vehicle to the attitude specified in the argument.\\nIt prints a success message if the attitude is set successfully, and a failure message otherwise.\"\"\"\n    try:\n      self.vehicle.attitude = attitude\n      print('Attitude set to {}.'.format(attitude))\n    except:", "CodeBleu_score": 52.43537295039332}]}
{"instance_id": "f32a06290dc6", "generation_result": [{"code": "def cmd_vel_enu_callback(self, msg)\n    if self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    elif self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z]\n\n", "CodeBleu_score": 54.958027737947205}, {"code": "def cmd_vel_enu_callback(self, msg)\n    if not self.hover_flag:\n        self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z)\n    elif not self.hold_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z, 'enu')\n    else:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = [msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.x, msg.angular.y, msg.angular.z]\n", "CodeBleu_score": 54.95549757224825}, {"code": "def cmd_vel_enu_callback(self, msg)\n    self.hover_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n    if not self.hover_flag:\n        self.hold_state_transition(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z, 'enu')\n    if not self.hover_flag and not self.hold_flag:\n        self.coordinate_frame = 1\n        self.motion_type = 1\n        self.target_motion = Motion(msg.linear.x, msg.linear.y, msg.linear.z, msg.angular.z)\n", "CodeBleu_score": 37.573445685249844}]}
{"instance_id": "26dec8bb97ca", "generation_result": [{"code": "def hover_state_transition(self, x, y, z, w)\n    if (x > 0.02 or y > 0.02 or z > 0.02 or w > 0.005):\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    elif (self.hover_flag == 0 and self.get_mode()!= \"HOVER\"):\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover()\n", "CodeBleu_score": 40.9629132483552}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if (abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or abs(w) > 0.005):\n        self.hover_flag = 0\n        self.set_mode('OFFBOARD')\n    elif (self.hover_flag == 1 and self.mode!= 'HOVER'):\n        self.hover_flag = 0\n        self.set_mode('HOVER')\n        self.hover()\n", "CodeBleu_score": 53.85288534075319}, {"code": "def hover_state_transition(self, x, y, z, w)\n    if abs(x) > 0.02 or abs(y) > 0.02 or abs(z) > 0.02 or w > 0.005:\n        self.hover_flag = 0\n        self.set_mode(\"OFFBOARD\")\n    elif self.hover_flag == 0 and self.mode!= \"HOVER\":\n        self.hover_flag = 1\n        self.set_mode(\"HOVER\")\n        self.hover()\n", "CodeBleu_score": 57.56856243613873}]}
{"instance_id": "76f2f38d2d3a", "generation_result": [{"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n      yaw = q.yaw\n    else:\n      q = Quaternion(q)\n      yaw = q.yaw\n    return yaw\n", "CodeBleu_score": 26.522018078564436}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        return Quaternion(q).yaw\n", "CodeBleu_score": 17.485641283375248}, {"code": "def q2yaw(self, q)\n    if isinstance(q, Quaternion):\n        return q.yaw\n    else:\n        q = Quaternion(q)\n        return q.yaw\n", "CodeBleu_score": 24.26411761619382}]}
{"instance_id": "e9600f2db7f4", "generation_result": [{"code": "def hover(self)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.ar", "CodeBleu_score": 15.935076963929609}, {"code": "def hover(self)\n    self.set_mode('GUIDED')\n    self.vehicle.airspeed = 0\n    self.vehicle.groundspeed = 0\n    self.vehicle.airspeed_mode = 'PASSIVE'\n    self.vehicle.groundspeed_mode = 'PASSIVE'\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    self.vehicle.simple_takeoff(10)\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    self.vehicle.mode = VehicleMode(\"GUIDED\")\n    self.vehicle.flush()\n    print(\"Vehicle type: %s\" % self.vehicle.model)\n    print(\"Vehicle ID: %s\" % self.vehicle.vehicle_id)\n    print(\"Flight Mode: %s\" % self.vehicle.mode.name)\n\n  def set_mode(self, mode):\n    \"\"\"This function, set_mode, sets the vehicle to a specified mode.\\nIt updates the coordinate frame and motion type.\\nIt constructs a target motion using the current position and yaw values.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.vehicle.mode = VehicleMode(mode)\n    self.vehicle.flush()\n    print(\"Vehicle type: %s\" % self.vehicle.model)\n    print(\"Vehicle ID: %s\" % self.vehicle.vehicle_id)\n    print(\"Flight Mode: %s\" % self.vehicle.mode.name)\n\n  def arm(self):\n    \"\"\"This function, arm, arms the vehicle.\\nIt updates the coordinate frame and motion type.\\nIt constructs a target motion using the current position and yaw values.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.vehicle.armed = True\n    self.vehicle.flush()\n    print(\"Vehicle type: %s\" % self.vehicle.model)\n    print(\"Vehicle ID: %s\" % self.vehicle.vehicle_id)\n    print(\"Flight Mode: %s\" % self.vehicle.mode.name)\n\n  def disarm(self):\n    \"\"\"This function, disarm, disarms the vehicle.\\nIt updates the coordinate frame and motion type.\\nIt constructs a target motion using the current position and yaw values.\\nFinally, it prints the vehicle type, vehicle ID,", "CodeBleu_score": 24.561331157865833}, {"code": "def hover(self)\n    self.target_motion = Motion(self.current_position, self.current_yaw, self.current_velocity, self.current_acceleration, self.current_yaw_rate, self.current_yaw_acceleration, self.hover_mode)\n    self.target_motion.update_coordinate_frame()\n    self.target_motion.update_motion_type()\n    self.target_motion.construct_target_motion()\n    print(\"Vehicle type: %s\\nVehicle ID: %s\\nFlight mode: %s\" % (self.vehicle_type, self.vehicle_id, self.hover_mode))\n\n  def land(self):\n    \"\"\"This function, land, sets the vehicle to land mode.\\nIt updates the coordinate frame and motion type.\\nIt constructs a target motion using the current position and yaw values.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.target_motion = Motion(self.current_position, self.current_yaw, self.current_velocity, self.current_acceleration, self.current_yaw_rate, self.current_yaw_acceleration, self.land_mode)\n    self.target_motion.update_coordinate_frame()\n    self.target_motion.update_motion_type()\n    self.target_motion.construct_target_motion()\n    print(\"Vehicle type: %s\\nVehicle ID: %s\\nFlight mode: %s\" % (self.vehicle_type, self.vehicle_id, self.land_mode))\n\n  def takeoff(self):\n    \"\"\"This function, takeoff, sets the vehicle to takeoff mode.\\nIt updates the coordinate frame and motion type.\\nIt constructs a target motion using the current position and yaw values.\\nFinally, it prints the vehicle type, vehicle ID, and flight mode.\"\"\"\n    self.target_motion = Motion(self.current_position, self.current_yaw, self.current_velocity, self.current_acceleration, self.current_yaw_rate, self.current_yaw_acceleration, self.takeoff_mode)\n    self.target_motion.update_coordinate_frame()\n    self.target_motion.update_motion_type()\n    self.target_motion.construct_target_motion()\n    print(\"Vehicle type: %s\\nVehicle ID: %s\\nFlight mode:", "CodeBleu_score": 33.54464667538134}]}
{"instance_id": "28e24810b7e7", "generation_result": [{"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      try:\n        self.flight_mode_service.set_mode(self.flight_mode)\n        self.print_flight_mode()\n        return True\n      except:\n        print('Failed to switch to flight mode %s' % self.flight_mode)\n        return False\n\n  def print_flight_mode(self):\n    \"\"\"This function, print_flight_mode, prints the current flight mode of a vehicle.\"\"\"\n    print('Flight mode: %s' % self.flight_mode)\n\n  def print_battery(self):\n    \"\"\"This function, print_battery, prints the current battery of a vehicle.\"\"\"\n    print('Battery: %s' % self.battery)\n\n  def print_armed(self):\n    \"\"\"This function, print_armed, prints the current armed status of a vehicle.\"\"\"\n    print('Armed: %s' % self.armed)\n\n  def print_mode(self):\n    \"\"\"This function, print_mode, prints the current mode of a vehicle.\"\"\"\n    print('Mode: %s' % self.mode)\n\n  def print_state(self):\n    \"\"\"This function, print_state, prints the current state of a vehicle.\"\"\"\n    print('State: %s' % self.state)\n\n  def print_gps_0(self):\n    \"\"\"This function, print_gps_0, prints the current GPS of a vehicle.\"\"\"\n    print('GPS: %s' % self.gps_0)\n\n  def print_attitude(self):\n    \"\"\"This function, print_attitude, prints the current attitude of a vehicle.\"\"\"\n    print('Attitude: %s' % self.attitude)\n\n  def print_global_position(self):\n    \"\"\"This function, print_global_position, prints the current global position of a vehicle.\"\"\"\n    print('Global Position: %s' % self.global_position)\n\n  def print_local_position(self):\n    \"\"\"This function, print_local_position, prints the current local position of a vehicle.\"\"\"\n    print('Local Position: %s' % self.local_position)\n\n  def print_velocity(self):\n    \"\"\"This function, print_velocity, prints the current velocity of a vehicle.\"\"\"\n    print('Velocity: %s' % self.velocity)\n\n  def print_position(self):\n   ", "CodeBleu_score": 32.88524131189453}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      if self.flight_mode_service.set_mode(self.flight_mode):\n        self.flight_mode = self.flight_mode_service.mode\n        print('Flight mode: %s' % self.flight_mode)\n        return True\n      else:\n        print('Failed to change modes')\n        return False\n\n  def set_takeoff_altitude(self, altitude):\n    \"\"\"This function, set_takeoff_altitude, sets the takeoff altitude of the vehicle.\\nIt attempts to set the takeoff altitude using the takeoffService.\\nIf successful, it prints the new altitude and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    if self.takeoff_service.set_takeoff_altitude(altitude):\n      self.takeoff_altitude = altitude\n      print('Takeoff altitude set to: %s' % self.takeoff_altitude)\n      return True\n    else:\n      print('Failed to set takeoff altitude')\n      return False\n\n  def set_land_altitude(self, altitude):\n    \"\"\"This function, set_land_altitude, sets the landing altitude of the vehicle.\\nIt attempts to set the landing altitude using the landService.\\nIf successful, it prints the new altitude and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    if self.land_service.set_land_altitude(altitude):\n      self.land_altitude = altitude\n      print('Land altitude set to: %s' % self.land_altitude)\n      return True\n    else:\n      print('Failed to set land altitude')\n      return False\n\n  def set_max_altitude(self, altitude):\n    \"\"\"This function, set_max_altitude, sets the maximum altitude of the vehicle.\\nIt attempts to set the maximum altitude using the set_max_altitude method of the flightModeService.\\nIf successful, it prints the new altitude and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    if self.flight_mode_service.set_max_altitude(altitude):\n      self.max_altitude = altitude\n      print('Max altitude set to: %s' % self.max_altitude)\n      return True", "CodeBleu_score": 31.220830507814725}, {"code": "def flight_mode_switch(self)\n    if self.flight_mode == 'HOVER':\n      self.hover()\n      return True\n    else:\n      try:\n        self.vehicle.mode = VehicleMode('AUTO')\n        self.flight_mode = 'AUTO'\n        print('Flight mode switched to AUTO.')\n        return True\n      except:\n        print('Flight mode switch failed.')\n        return False\n\n  def hover(self):\n    \"\"\"This function, hover, sets the hover flag to True and attempts to takeoff.\\nIf successful, it prints a success message and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    self.hover_flag = True\n    try:\n      self.vehicle.mode = VehicleMode('GUIDED')\n      self.vehicle.armed = True\n      self.vehicle.simple_takeoff(self.altitude)\n      print('Hovering...')\n      return True\n    except:\n      print('Hover failed.')\n      return False\n\n  def land(self):\n    \"\"\"This function, land, attempts to land the vehicle.\\nIf successful, it prints a success message and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    try:\n      self.vehicle.mode = VehicleMode('LAND')\n      print('Landing...')\n      return True\n    except:\n      print('Land failed.')\n      return False\n\n  def set_altitude(self, altitude):\n    \"\"\"This function, set_altitude, sets the altitude of the vehicle.\\nIf the altitude is greater than the current altitude, it attempts to takeoff.\\nOtherwise, it attempts to land.\\nIf successful, it prints a success message and returns True.\\nIf unsuccessful, it prints a failure message and returns False.\"\"\"\n    if altitude > self.altitude:\n      try:\n        self.vehicle.simple_takeoff(altitude)\n        print('Taking off...')\n        return True\n      except:\n        print('Takeoff failed.')\n        return False\n    else:\n      try:\n        self.vehicle.mode = VehicleMode('LAND')\n        print('Landing...')\n        return True\n      except:\n        print('Land failed.')\n        return False\n\n  def set_velocity(self, velocity):\n    \"\"\"This function, set_velocity, sets the velocity of the vehicle.\\nIf the velocity is greater than the current velocity, it attempts to increase the velocity.\\nOtherwise, it attempts to decrease the velocity.\\nIf successful, it prints a success message and returns True.\\n", "CodeBleu_score": 33.2769969018572}]}
{"instance_id": "4c0ba39b2a66", "generation_result": [{"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward by calling the get_reward function for each play.\"\"\"\n    total_reward = 0\n    for play in self.play:\n      total_reward += self.get_reward(play)\n    return total_reward\n\n  def get_reward(self, play):\n    \"\"\"This function, get_reward, calculates the reward for a given play by calling the get_reward_for_play function.\"\"\"\n    return self.get_reward_for_play(play)\n\n  def get_reward_for_play(self, play):\n    \"\"\"This function, get_reward_for_play, calculates the reward for a given play by calling the get_reward_for_player function for each player.\"\"\"\n    reward = 0\n    for player in play:\n      reward += self.get_reward_for_player(player)\n    return reward\n\n  def get_reward_for_player(self, player):\n    \"\"\"This function, get_reward_for_player, calculates the reward for a given player by calling the get_reward_for_player_in_play function for each play.\"\"\"\n    reward = 0\n    for play in self.play:\n      reward += self.get_reward_for_player_in_play(player, play)\n    return reward\n\n  def get_reward_for_player_in_play(self, player, play):\n    \"\"\"This function, get_reward_for_player_in_play, calculates the reward for a given player in a given play by calling the get_reward_for_player_in_play_in_round function for each round.\"\"\"\n    reward = 0\n    for rond in self.rond:\n      reward += self.get_reward_for_player_in_play_in_round(player, play, rond)\n    return reward\n\n  def get_reward_for_player_in_play_in_round(self, player, play, rond):\n    \"\"\"This function, get_reward_for_player_in_play_in_round, calculates the reward for a", "CodeBleu_score": 39.88298106328095}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward of the assignment by calling the get_reward method for each play.\"\"\"\n    total_reward = 0\n    for play in self.play:\n      total_reward += self.get_reward(play)\n    return total_reward\n\n  def get_reward(self, play):\n    \"\"\"This function, get_reward, calculates the reward of a play by calling the get_reward_for_player method for each player in the play.\"\"\"\n    reward = 0\n    for player in play:\n      reward += self.get_reward_for_player(player)\n    return reward\n\n  def get_reward_for_player(self, player):\n    \"\"\"This function, get_reward_for_player, calculates the reward for a player by calling the get_reward_for_player_for_assignment method for each assignment in the player.\"\"\"\n    reward = 0\n    for assignment in player:\n      reward += self.get_reward_for_player_for_assignment(assignment)\n    return reward\n\n  def get_reward_for_player_for_assignment(self, assignment):\n    \"\"\"This function, get_reward_for_player_for_assignment, calculates the reward for a player for an assignment by calling the get_reward_for_player_for_assignment_for_algorithm method for each algorithm in the assignment.\"\"\"\n    reward = 0\n    for algorithm in assignment:\n      reward += self.get_reward_for_player_for_assignment_for_algorithm(algorithm)\n    return reward\n\n  def get_reward_for_player_for_assignment_for_algorithm(self, algorithm):\n    \"\"\"This function, get_reward_for_player_for_assignment_for_algorithm, calculates the reward for a player for an assignment for an algorithm by calling the get_reward_for_player_for_assignment_for_algorithm_for_play method for each play in the algorithm.\"\"\"\n    reward = 0\n    for play in algorithm:\n      reward += self.get_reward_for_player_for_assignment_for_algorithm_for_play", "CodeBleu_score": 37.953715261904925}, {"code": "def run(self, assignment, algorithm, play, rond)\n    self.assignment = assignment\n    self.algorithm = algorithm\n    self.play = play\n    self.rond = rond\n    self.total_reward = self.get_total_reward()\n    if self.visualization:\n      self.visualize()\n\n  def get_total_reward(self):\n    \"\"\"This function, get_total_reward, calculates the total reward of the assignment by calling the get_reward function for each assignment.\"\"\"\n    total_reward = 0\n    for assignment in self.assignment:\n      total_reward += self.get_reward(assignment)\n    return total_reward\n\n  def get_reward(self, assignment):\n    \"\"\"This function, get_reward, calculates the reward of the assignment by calling the get_reward function for each assignment.\"\"\"\n    return self.algorithm.get_reward(assignment, self.play, self.rond)\n\n  def visualize(self):\n    \"\"\"This function, visualize, calls the visualize method for each assignment.\"\"\"\n    for assignment in self.assignment:\n      assignment.visualize()\n\n  def __str__(self):\n    \"\"\"This function, __str__, returns a string representation of the object.\"\"\"\n    return \"Assignment: \" + str(self.assignment) + \"\\nAlgorithm: \" + str(self.algorithm) + \"\\nPlay: \" + str(self.play) + \"\\nRond: \" + str(self.rond) + \"\\nTotal reward: \" + str(self.total_reward)\n", "CodeBleu_score": 50.028619265562725}]}
{"instance_id": "655d3710840c", "generation_result": [{"code": "def local_pose_callback(self, msg, i)\n    if i == self.uav_id:\n      self.local_pose = msg\n      if self.gcs_command == self.gcs_command_takeoff:\n        self.takeoff_target_pose = msg\n      elif self.gcs_command == self.gcs_command_hover:\n        self.hover_target_pose = msg\n      elif self.gcs_command == self.gcs_command_land:\n        self.land_target_pose = msg\n      elif self.gcs_command == self.gcs_command_go_to:\n        self.go_to_target_pose = msg\n      elif self.gcs_command == self.gcs_command_move_to:\n        self.move_to_target_pose = msg\n      elif self.gcs_command == self.gcs_command_stop:\n        self.stop_target_pose = msg\n      elif self.gcs_command == self.gcs_command_reset:\n        self.reset_target_pose = msg\n      elif self.gcs_command == self.gcs_command_follow:\n        self.follow_target_pose = msg\n      elif self.gcs_command == self.gcs_command_takeoff_from_here:\n        self.takeoff_from_here_target_pose = msg\n      elif self.gcs_command == self.gcs_command_land_from_here:\n        self.land_from_here_target_pose = msg\n      elif self.gcs_command == self.gcs_command_go_to_from_here:\n        self.go_to_from_here_target_pose = msg\n      elif self.gcs_command == self.gcs_command_move_to_from_here:\n        self.move_to_from_here_target_pose = msg\n      elif self.gcs_command == self.gcs_command_stop_from_here:\n        self.stop_from_here_target_pose = msg\n      elif self.gcs_command == self.gcs_command_reset_from_here:\n        self.reset_from_here_target_pose = msg\n      elif self.gcs_command == self.gcs_command_follow_from_here:\n        self.follow_from_here_target_", "CodeBleu_score": 12.844254575486008}, {"code": "def local_pose_callback(self, msg, i)\n    if i == self.uav_id:\n      self.local_pose = msg\n      if self.gcs_command == self.gcs_command_enum.takeoff:\n        self.takeoff_target_pose = msg\n      elif self.gcs_command == self.gcs_command_enum.hover:\n        self.hover_target_pose = msg\n      elif self.gcs_command == self.gcs_command_enum.land:\n        self.land_target_pose = msg\n      elif self.gcs_command == self.gcs_command_enum.takeoff_and_hover:\n        self.takeoff_target_pose = msg\n        self.hover_target_pose = msg\n      elif self.gcs_command == self.gcs_command_enum.takeoff_and_land:\n        self.takeoff_target_pose = msg\n        self.land_target_pose = msg\n      elif self.gcs_command == self.gcs_command_enum.hover_and_land:\n        self.hover_target_pose = msg\n        self.land_target_pose = msg\n      elif self.gcs_command == self.gcs_command_enum.takeoff_hover_and_land:\n        self.takeoff_target_pose = msg\n        self.hover_target_pose = msg\n        self.land_target_pose = msg\n      else:\n        pass\n      self.global_pose = PoseStamped()\n      self.global_pose.header.stamp = rospy.Time.now()\n      self.global_pose.header.frame_id ='map'\n      self.global_pose.pose.position.x = self.local_pose.pose.position.x + self.uav_pose_bias.x\n      self.global_pose.pose.position.y = self.local_pose.pose.position.y + self.uav_pose_bias.y\n      self.global_pose.pose.position.z = self.local_pose.pose.position.z + self.uav_pose_bias.z\n      self.global_pose.pose.orientation.x = self.local_pose.pose.orientation.x\n      self.global_pose.pose.orientation.y = self.local_pose.pose.orientation.y\n      self.global", "CodeBleu_score": 17.867244789189172}, {"code": "def local_pose_callback(self, msg, i)\n    if i == self.uav_id:\n      self.local_pose = msg\n      if self.gcs_command == 'takeoff':\n        self.takeoff_target_pose = msg\n      elif self.gcs_command == 'hover':\n        self.hover_target_pose = msg\n      elif self.gcs_command == 'land':\n        self.land_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list_repeat':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list_repeat_with_altitude':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list_repeat_with_altitude_and_yaw':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list_repeat_with_altitude_and_yaw_and_velocity':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list_repeat_with_altitude_and_yaw_and_velocity_and_acceleration':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list_repeat_with_altitude_and_yaw_and_velocity_and_acceleration_and_jerk':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list_repeat_with_altitude_and_yaw_and_velocity_and_acceleration_and_jerk_and_snap':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_waypoint_list_repeat_with_altitude_and_yaw_and_velocity_and_acceleration_and_jerk_and_snap_and_cruise':\n        self.waypoint_target_pose = msg\n      elif self.gcs_command == 'go_to_", "CodeBleu_score": 14.74852753158127}]}
{"instance_id": "63ba33d45de2", "generation_result": [{"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == \"active\":\n      return True\n    else:\n      return False\n", "CodeBleu_score": 62.044114774432614}, {"code": "def takeoff_detection(self)\n    if self.altitude > 0.2 and self.arm_state == 'active':\n        return True\n    else:\n        return False\n", "CodeBleu_score": 62.862379601652705}, {"code": "def takeoff_detection(self)\n    if self.get_altitude() > 0.2 and self.get_arm_state() == \"active\":\n        return True\n    else:\n        return False\n", "CodeBleu_score": 61.808182576807155}]}
{"instance_id": "f53f1a3b1fc1", "generation_result": [{"code": "def build_graph(self, orig_formation, change_formation)\n    # calculate pairwise distances between UAVs in the original formation\n    orig_formation_dist_matrix = distance_matrix(orig_formation)\n    # calculate pairwise distances between UAVs in the changed formation\n    change_formation_dist_matrix = distance_matrix(change_formation)\n    # adjust distances by subtracting them from 50 and converting to integers\n    distance_matrix = np.subtract(orig_formation_dist_matrix, change_formation_dist_matrix)\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n\n  def build_distance_graph(self, orig_formation, change_formation):\n    \"\"\"This function, build_distance_graph, constructs a distance graph for UAV formations.\\nIt calculates the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\\nThe distances are adjusted by subtracting them from 50 and converted to integers.\\nThe resulting distance graph is returned.\"\"\"\n    # calculate pairwise distances between UAVs in the original formation\n    orig_formation_dist_matrix = distance_matrix(orig_formation)\n    # calculate pairwise distances between UAVs in the changed formation\n    change_formation_dist_matrix = distance_matrix(change_formation)\n    # adjust distances by subtracting them from 50 and converting to integers\n    distance_matrix = np.subtract(orig_formation_dist_matrix, change_formation_dist_matrix)\n    distance_matrix = distance_matrix.astype(int)\n    # build the distance graph\n    distance_graph = nx.from_numpy_matrix(distance_matrix)\n    return distance_graph\n\n  def build_edge_list(self, orig_formation, change_formation):\n    \"\"\"This function, build_edge_list, constructs an edge list for UAV formations.\\nIt calculates the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\\nThe distances are adjusted by subtracting them from 50 and converted to integers.\\nThe resulting edge list is returned.\"\"\"\n    # calculate pairwise distances between UAVs in the original formation\n    orig_formation_dist_matrix = distance_matrix(orig_formation)\n    # calculate pairwise distances between UAVs in the changed formation\n    change_formation_dist_matrix = distance_matrix(change_formation)\n    # adjust distances by subtracting", "CodeBleu_score": 15.04194803069112}, {"code": "def build_graph(self, orig_formation, change_formation)\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n      for j in range(len(change_formation)):\n        distance_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n    distance_matrix = distance_matrix - 50\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n\n  def build_graph_2(self, orig_formation, change_formation):\n    \"\"\"This function, build_graph_2, constructs a distance matrix for UAV formations.\\nIt calculates the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\\nThe distances are adjusted by subtracting them from 50 and converted to integers.\\nThe resulting distance matrix is returned.\"\"\"\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n      for j in range(len(change_formation)):\n        distance_matrix[i][j] = np.linalg.norm(orig_formation[i] - change_formation[j])\n    distance_matrix = distance_matrix - 50\n    distance_matrix = distance_matrix.astype(int)\n    return distance_matrix\n\n  def build_graph_3(self, orig_formation, change_formation):\n    \"\"\"This function, build_graph_3, constructs a distance matrix for UAV formations.\\nIt calculates the pairwise distances between UAVs in the original and changed formations using the Euclidean norm.\\nThe distances are adjusted by subtracting them from 50 and converted to integers.\\nThe resulting distance matrix is returned.\"\"\"\n    orig_formation = np.array(orig_formation)\n    change_formation = np.array(change_formation)\n    distance_matrix = np.zeros((len(orig_formation), len(change_formation)))\n    for i in range(len(orig_formation)):\n      for j in range(len(change_formation)):\n        distance_", "CodeBleu_score": 26.13736438291815}, {"code": "def build_graph(self, orig_formation, change_formation)\n    # get the number of UAVs in the original formation\n    num_uavs = len(orig_formation)\n    # initialize a distance matrix\n    distance_matrix = np.zeros((num_uavs, num_uavs))\n    # iterate through the original formation\n    for i in range(num_uavs):\n        # iterate through the original formation\n        for j in range(num_uavs):\n            # get the x and y coordinates of the ith UAV in the original formation\n            x1, y1 = orig_formation[i]\n            # get the x and y coordinates of the jth UAV in the original formation\n            x2, y2 = orig_formation[j]\n            # calculate the Euclidean distance between the ith and jth UAV in the original formation\n            distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n            # adjust the distance by subtracting it from 50 and converting it to an integer\n            distance_matrix[i, j] = int(50 - distance)\n    # return the distance matrix\n    return distance_matrix\n", "CodeBleu_score": 24.352535392219508}]}
{"instance_id": "f08b0e0bcb22", "generation_result": [{"code": "def find_path(self, i)\n    self.visited[i] = True\n    for j in range(self.n):\n      if self.G[i][j]!= 0:\n        if self.match[j] == -1 or not self.visited[self.match[j]]:\n          if self.slack[j] > self.G[i][j] - self.match_weight[i]:\n            self.slack[j] = self.G[i][j] - self.match_weight[i]\n            self.slack_vertex[j] = i\n          if self.match_weight[i] + self.slack[j] == 0:\n            if self.find_path(self.match[j]):\n              self.match_weight[i] += self.slack[j]\n              self.match[j] = i\n              return True\n        else:\n          if self.slack[j] > self.slack[self.match[j]] + self.G[i][j] - self.match_weight[i]:\n            self.slack[j] = self.slack[self.match[j]] + self.G[i][j] - self.match_weight[i]\n            self.slack_vertex[j] = i\n    return False\n\n  def max_weight_matching(self):\n    \"\"\"This function, max_weight_matching, returns the maximum weight of a matching in a bipartite graph.\\nIt initializes the match and match weight arrays and iterates through the left vertices.\\nIf a vertex is not visited, it finds an augmenting path.\\nIf a path is found, it updates the match and match weight.\\nIt returns the sum of match weight.\"\"\"\n    self.match = [-1] * self.n\n    self.match_weight = [0] * self.n\n    for i in range(self.n):\n      if self.match[i] == -1:\n        self.visited = [False] * self.n\n        self.slack = [float('inf')] * self.n\n        self.slack_vertex = [-1] * self.n\n        if not self.find_path(i):\n          return -1\n    return sum(self.match_weight)\n", "CodeBleu_score": 34.0243904815446}, {"code": "def find_path(self, i)\n    visited = [False] * self.n\n    visited[i] = True\n    for j in range(self.n, 2 * self.n):\n      if self.match[j] == -1 and self.labels[i] + self.labels[j] == 0:\n        self.match[j] = i\n        return True\n      elif self.match[j] == -1:\n        if not visited[self.match[j]]:\n          if self.find_path(self.match[j]):\n            self.match[j] = i\n            return True\n      else:\n        if not visited[self.match[j]]:\n          if self.labels[i] + self.labels[j] - self.slack[self.match[j]] < 0:\n            self.slack[self.match[j]] = self.labels[i] + self.labels[j]\n          else:\n            self.slack[self.match[j]] = 0\n            if self.find_path(self.match[j]):\n              self.match[j] = i\n              return True\n    return False\n\n  def max_weight_bipartite_matching(self):\n    \"\"\"This function, max_weight_bipartite_matching, attempts to find the maximum weight matching in a bipartite graph.\\nIt initializes the labels and match arrays.\\nIt iterates through the left vertices and finds an augmenting path.\\nIf a path is found, it updates the labels and match arrays.\\nThe function returns the maximum weight of the matching.\"\"\"\n    self.labels = [0] * self.n\n    self.match = [-1] * (2 * self.n)\n    for i in range(self.n):\n      if self.match[i] == -1:\n        self.slack = [0] * (2 * self.n)\n        if self.find_path(i):\n          self.labels[i] -= self.slack[self.match[i]]\n    return sum(self.labels)", "CodeBleu_score": 35.03924365008119}, {"code": "def find_path(self, i)\n    self.visited[i] = True\n    for j in self.graph[i]:\n      if self.match[j] == 0:\n        self.match[j] = i\n        return True\n      elif self.visited[self.match[j]] == False:\n        self.visited[self.match[j]] = True\n        if self.find_path(self.match[j]):\n          self.match[j] = i\n          return True\n    return False\n\n  def max_weight_matching(self):\n    \"\"\"This function, max_weight_matching, calculates the maximum weight matching using the Hungarian Algorithm.\\nIt creates a list of visited vertices and a list of slack values.\\nIt iterates through the left vertices and calls find_path to find a path.\\nIf a path is found, it resets the visited and slack values.\\nIt returns the match and the maximum weight.\"\"\"\n    self.visited = [False] * self.n\n    self.match = [0] * self.m\n    self.slack = [0] * self.m\n    for i in range(self.n):\n      if self.match[i] == 0 and self.find_path(i):\n        self.visited = [False] * self.n\n        self.slack = [0] * self.m\n    return self.match, self.weight\n", "CodeBleu_score": 35.70838734121145}]}
{"instance_id": "ff38be7544dc", "generation_result": [{"code": "def KM(self)\n    # Initialize slack variables and visit arrays\n    self.slack = np.zeros(self.N_UAV)\n    self.slack_visit = np.zeros(self.N_UAV)\n    self.visit = np.zeros(self.N_UAV)\n    # Iterate over UAVs\n    for i in range(self.N_UAV):\n        # Initialize slack variables and visit arrays\n        self.slack = np.zeros(self.N_UAV)\n        self.slack_visit = np.zeros(self.N_UAV)\n        self.visit = np.zeros(self.N_UAV)\n        # Find a path from the current UAV\n        self.KM_path(i)\n        # Adjust labels\n        self.KM_label_adjust()\n    # Return the match results\n    return self.match_results\n\n  def KM_path(self, i):\n    \"\"\"This function, KM_path, finds a path from a UAV to the right side of the bipartite graph.\\nIt starts from the current UAV and iterates over the right side of the bipartite graph.\\nIf a right side vertex is unmatched, it checks if it can be matched to the current UAV.\\nIf it can, it updates the match results and returns True.\\nIf no right side vertex can be matched to the current UAV, it finds the minimum slack value and updates the labels accordingly.\\nThis process continues until a path is found or no more right side vertices can be matched to the current UAV.\"\"\"\n    # Initialize visit array for the current UAV\n    self.visit[i] = 1\n    # Iterate over right side vertices\n    for j in range(self.N_UAV):\n        # If the right side vertex is unmatched\n        if self.match_results[j] == -1:\n            # Check if it can be matched to the current UAV\n            if self.KM_check_path(i, j):\n                # Update the match results\n                self.match_results[j] = i\n                return True\n        # If the right side vertex is matched\n        else:\n            # Check if the current UAV can be matched to the right side vertex\n            if self.KM_check_path(self.match_results[j], j):\n                # Update the match results\n                self.match_results[j] = i\n                return True\n   ", "CodeBleu_score": 28.07405462740405}, {"code": "def KM(self)\n    # initialize slack variables and visit arrays\n    self.slack = np.zeros((self.num_uavs,self.num_uavs))\n    self.slack_row = np.zeros((self.num_uavs,self.num_uavs))\n    self.slack_col = np.zeros((self.num_uavs,self.num_uavs))\n    self.visited_row = np.zeros((self.num_uavs,self.num_uavs))\n    self.visited_col = np.zeros((self.num_uavs,self.num_uavs))\n\n    # find maximum matching\n    for i in range(self.num_uavs):\n      # initialize slack variables and visit arrays\n      self.slack = np.zeros((self.num_uavs,self.num_uavs))\n      self.slack_row = np.zeros((self.num_uavs,self.num_uavs))\n      self.slack_col = np.zeros((self.num_uavs,self.num_uavs))\n      self.visited_row = np.zeros((self.num_uavs,self.num_uavs))\n      self.visited_col = np.zeros((self.num_uavs,self.num_uavs))\n      # find path\n      path = self.path(i)\n      # if no path is found, adjust labels\n      if path == []:\n        # find minimum slack value\n        min_slack = np.min(self.slack)\n        # adjust labels\n        self.label_row = self.label_row + min_slack\n        self.label_col = self.label_col - min_slack\n    # return match results\n    return self.match_results()\n\n  def path(self, uav):\n    \"\"\"This function, path, implements the path finding algorithm for the Kuhn-Munkres algorithm.\\nIt iterates over UAVs, initializing slack variables and resetting visit arrays for each UAV.\\nIf no path is found, it adjusts the labels based on the minimum slack value.\\nThis process continues until a path is found for each UAV.\\nFinally, it returns the match results for the right side of the bipartite graph.\"\"\"\n    # initialize slack variables and visit", "CodeBleu_score": 22.583055709558895}, {"code": "def KM(self)\n    self.slack = np.zeros(self.N)\n    self.slack_row = np.zeros(self.N)\n    self.slack_col = np.zeros(self.N)\n    self.visit_row = np.zeros(self.N)\n    self.visit_col = np.zeros(self.N)\n    self.match_row = np.zeros(self.N)\n    self.match_col = np.zeros(self.N)\n    for i in range(self.N):\n      self.match_row[i] = -1\n      self.match_col[i] = -1\n    for i in range(self.N):\n      if self.match_row[i] == -1:\n        self.visit_row[i] = 1\n        self.visit_col = np.zeros(self.N)\n        if self.KM_recurse(i):\n          return self.match_row, self.match_col\n        else:\n          self.KM_label_correct()\n    return self.match_row, self.match_col\n\n  def KM_recurse(self, u):\n    \"\"\"This function, KM_recurse, implements the recursion of the Kuhn-Munkres algorithm.\\nIt iterates over the columns of the bipartite graph, updating the slack variables.\\nIf a column is not visited and the slack value is less than the cost of the edge, the edge is traversed.\\nIf a path is found, the match results are updated and the function returns true.\\nIf no path is found, the function returns false.\"\"\"\n    for j in range(self.N):\n      if self.visit_col[j] == 0 and self.slack[j] > self.cost[u][j]:\n        self.slack[j] = self.cost[u][j]\n        self.slack_row[j] = u\n        if self.match_col[j] == -1 or self.KM_recurse(self.match_col[j]):\n          self.match_row[u] = j\n          self.match_col[j] = u\n          return True\n    return False\n\n  def KM_label_correct(self):\n    \"\"\"This function, KM_label_correct, implements the label correction of the Kuhn-Munkres algorithm.\\n", "CodeBleu_score": 26.088494593315374}]}
{"instance_id": "681b1afafb29", "generation_result": [{"code": "def yellow_dectection(image)\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n\n", "CodeBleu_score": 27.09532694324272}, {"code": "def yellow_dectection(image)\n    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower_yellow = np.array([20, 100, 100])\n    upper_yellow = np.array([30, 255, 255])\n    mask = cv2.inRange(hsv_image, lower_yellow, upper_yellow)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 27.09532694324272}, {"code": "def yellow_dectection(image)\n    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n    lower = np.array([20,100,100])\n    upper = np.array([30,255,255])\n    mask = cv2.inRange(hsv, lower, upper)\n    result = cv2.bitwise_and(image, image, mask=mask)\n    return result\n", "CodeBleu_score": 36.029852972474444}]}
{"instance_id": "6b245978b261", "generation_result": [{"code": "bool TagDetector::findStandaloneTagDescription\tconst std::string& id,\n\tStandaloneTagDescription& descriptionContainer,\n\tbool printWarning\n} const {\n\tauto it = standalone_tag_descriptions_.find(id);\n\tif (it == standalone_tag_descriptions_.end()) {\n\t\tif (printWarning) {\n\t\t\tstd::stringstream ss;\n\t\t\tss << \"TagDetector::findStandaloneTagDescription: Warning: Tag description with ID \" << id << \" not found.\";\n\t\t\tLOG_WARNING(ss.str());\n\t\t}\n\t\treturn false;\n\t}\n\tdescriptionContainer = it->second;\n\treturn true;\n}\n", "CodeBleu_score": 50.272579500280045}, {"code": "bool TagDetector::findStandaloneTagDescription\tconst TagDescriptionContainer& descriptionContainer,\n\tconst TagID& id,\n\tconst bool& printWarning", "CodeBleu_score": 7.6698171781931626}, {"code": "bool TagDetector::findStandaloneTagDescription\t(TagDetector* tagDetector, int tagID, TagDescriptionContainer* descriptionContainer, bool printWarning) {\n\t\tif (tagDetector->standalone_tag_descriptions_.find(tagID) == tagDetector->standalone_tag_descriptions_.end()) {\n\t\t\tif (printWarning) {\n\t\t\t\tstd::cerr << \"Warning: TagDetector::findStandaloneTagDescription could not find a standalone tag description for ID \" << tagID << std::endl;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t*descriptionContainer = tagDetector->standalone_tag_descriptions_[tagID];\n\t\treturn true;\n\t}\n};\n", "CodeBleu_score": 45.25284782507973}]}
